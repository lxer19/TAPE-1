URL: http://www.cs.ucsd.edu/~wgg/Abstracts/isaw2.ps.gz
Refering-URL: http://www.cs.ucsd.edu/~wgg/papers.html
Root-URL: http://www.cs.ucsd.edu
Email: wgg@cs.ucsd.edu  
Title: Just-in-Time Architecture: Planning Software in an Uncertain World  
Author: William G. Griswold 
Address: La Jolla, CA 92093-0114  
Affiliation: Department of Computer Science and Engineering University of California, San Diego  
Abstract: In the development of software, architecture has been conceptualized largely as a fully preplanned and imposed structure. However, planning is so difficult in our chaotic world that successful software projects must continually adapt to the shifting conditions of technology and the market. Consequently, software projects must admit the need to restructure their systems to introduce structure as needed as well as find architecture where none was seen before. By delaying the introduction of costly architecture, software projects can get to market more quickly, developing a customer base to fund future architectural efforts and providing much needed feedback on what architecture would be appropriate. 
Abstract-found: 1
Intro-found: 1
Reference: [Boehm 88] <author> B. W. Boehm. </author> <title> A spiral model of software development and enhancement. </title> <journal> Computer, </journal> <volume> 21(5) </volume> <pages> 61-72, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Such a model of software development seems to contradict the widely accepted premise that successful software systems must be planned, and the plan must be followed <ref> [Boehm 88] </ref>. To do otherwise, it is argued, invites project chaos, delays, and low quality. The fact is, however, that many of these loosely planned projects fl This work supported in part by NSF Grants CCR-9211002 and CCR-9508745, and UC MICRO grant 96-5449 with Hughes Aircraft.
Reference: [Bowdidge & Griswold 94] <author> R. W. Bowdidge and W. G. Griswold. </author> <title> Automated support for encapsulating abstract data types. </title> <booktitle> In ACM SIGSOFT '94 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 97-110, </pages> <month> December </month> <year> 1994. </year>
Reference: [Bowdidge & Griswold 96] <author> R. W. Bowdidge and W. G. Griswold. </author> <title> How software tools organize programmer behavior during the task of data encapsulation. </title> <type> Technical Report CS95-443, </type> <institution> University of California, San Diego, Department of Computer Science and Engineering, </institution> <month> August </month> <year> 1995 </year> <month> (revised February </month> <year> 1996). </year>
Reference-contexts: Methods have been developed for automating the difficult aspects of restructuring [Griswold 91, Griswold & Notkin 93, Bowdidge & Griswold 94, Bowdidge 95, Griswold et al. 96], but industrial-strength tools are still a ways off. However, systematic manual restructuring that emulates these methods are feasible <ref> [Bowdidge & Griswold 96, Griswold et al. 96] </ref>.
Reference: [Bowdidge 95] <author> R. W. Bowdidge. </author> <title> Supporting the Restructuring of Data Abstractions through Manipulation of a Program Visualization. </title> <type> PhD dissertation, </type> <institution> University of California, San Diego, Department of Computer Science & Engineering, </institution> <month> November </month> <year> 1995. </year> <note> Technical Report CS95-457. </note>
Reference: [Chow & Notkin 96] <author> K. Chow and D. Notkin. </author> <title> Semi-automatic update of applications in response to library changes. </title> <type> Technical Report UW-CSE 96-03-01, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <year> 1996. </year> <note> To appear in ICSM '96. </note>
Reference-contexts: This has been a recurring problem with changes to the Apple Macintosh Toolbox, even though it was reasonably well-designed from the beginning. However, this example also demonstrates that architectural changes will (eventually) occur in spite of this drawback. Tool assistance in managing such distributed changes would be valuable <ref> [Chow & Notkin 96] </ref>. Example: Retargeting a C Restructuring Tool to Ada. My research group has developed a restructuring tool for C [Morgen-thaler & Griswold 95] that we desire to retarget to a Pascal subset of Ada.
Reference: [Cusumano & Selby 95] <author> M. A. Cusumano and R. W. Selby. </author> <title> Microsoft Secrets: How the World's Most Powerful Software Company Creates Technology, Shapes Markets, and Manages People. </title> <publisher> Free Press, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: As a consequence, some development effortslike those at Microsoft change their course regularly in response to user feedback, market developments, technology advances, and the like <ref> [Cusumano & Selby 95] </ref>. Such a model of software development seems to contradict the widely accepted premise that successful software systems must be planned, and the plan must be followed [Boehm 88]. To do otherwise, it is argued, invites project chaos, delays, and low quality.
Reference: [DeMarco 95] <author> T. </author> <title> DeMarco. </title> <booktitle> On systems architecture. In Proceedings of the 1995 Monterey Workshop on Increasing the Practical Impact of Formal Methods for Computer-Aided Software Development: Specification-Based Software Architectures, </booktitle> <year> 1995. </year>
Reference-contexts: One successful example is Hewlett Packard's software infrastructure for their printer line [Malan & Wentzel 93]. However, DeMarco estimates that the first release of a novel system costs three times as much when developed with a well-planned architecture <ref> [DeMarco 95] </ref>. This cost represents a high risk since today's farsighted architecture can be tomorrow's inappropriate architecture. Indeed, Parnas says, It usually pays to apply the [Parnas program family design] method only when one expects the eventual implementation of a wide selection of possible family members [Parnas 76, p. 7]. <p> Indeed, DeMarco cites several successful cases of unplanned, emergent architecture, but also argues that planning is in general better than not <ref> [DeMarco 95] </ref>. How, then, can architecture be delayed without being wholly unplanned? (a) Start with version A (b) Add version B (c) Add version C the tree represents those modules shared by the indicated versions. I propose a modified version of Parnas's program family design method [Parnas 76].
Reference: [Griswold & Notkin 93] <author> W. G. Griswold and D. Notkin. </author> <title> Automated assistance for program restructuring. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 2(3) </volume> <pages> 228-269, </pages> <month> July </month> <year> 1993. </year>
Reference: [Griswold & Notkin 95] <author> W. G. Griswold and D. Notkin. </author> <title> Architectural tradeoffs for a meaning-preserving program restructuring tool. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 275-287, </pages> <year> 1995. </year>
Reference-contexts: After some thought, it became apparent there were not only layers and loosely integrated modules in the system, but also columns of representation operating orthogonally to the lay 3 ers: AST, data flow representations, and the mappings between them <ref> [Griswold & Notkin 95] </ref> (See Figure 2). However, these columns became visible only after I had considered how the direct-update implementation would fit into the current design, much as the effects of wind only became apparent when bridge weight was reduced. <p> However, once this latent architecture was recognized and analytically codified, it nonetheless proved to be a valuable guide in resolving low-level design issues as direct-update was introduced into the tool <ref> [Griswold & Notkin 95] </ref>. 4 Conclusion Software architecture has been conceptualized largely as a fully preplanned and imposed structure. However, to remain successful in our chaotic world, software projects must continually adapt to the shifting conditions of technology and the market.
Reference: [Griswold 91] <author> W. G. Griswold. </author> <title> Program Restructuring as an Aid to Software Maintenance. </title> <type> PhD dissertation, </type> <institution> University of Washington, Dept. of Computer Science & Engineering, </institution> <month> August </month> <year> 1991. </year> <note> Technical Report No. 91-08-04. </note>
Reference: [Griswold 93] <author> W. G. Griswold. </author> <title> Direct update of dataflow representations for a meaning-preserving program restructuring tool. </title> <booktitle> In ACM SIGSOFT '93 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 42-55, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Once the basic concept of a meaning-preserving restructuring tool was demonstrated, performance became an important issue. Fortunately, in the process of implementing the original tool, I had invented a technique for directly updating the tool's data flow information <ref> [Griswold 93] </ref>. The only question was whether it could be shoe-horned into the existing implementation with minimal changes.
Reference: [Griswold et al. 96] <author> W. G. Griswold, M. I. Chen, R. W. Bowdidge, and J. D. Morgenthaler. </author> <title> Tool support for planning the restructuring of data abstractions in large systems. </title> <booktitle> In ACM SIGSOFT '96 Symposium on the Foundations of Software Engineering, </booktitle> <month> October </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: Methods have been developed for automating the difficult aspects of restructuring [Griswold 91, Griswold & Notkin 93, Bowdidge & Griswold 94, Bowdidge 95, Griswold et al. 96], but industrial-strength tools are still a ways off. However, systematic manual restructuring that emulates these methods are feasible <ref> [Bowdidge & Griswold 96, Griswold et al. 96] </ref>.
Reference: [Kiczales 94] <author> G. Kiczales. </author> <title> Why black boxes are so hard to reuse: A new approach to abstraction for the engineering of software. Videotape. </title> <booktitle> Selections from OOPSLA '94, </booktitle> <year> 1994. </year> <note> See also http://www.parc.xerox.com/spl/projects/oi/. </note>
Reference-contexts: As Kiczales has noted, not all software abstractions need to be constructive, as modules and classes are <ref> [Kiczales 94, Kiczales 96] </ref>. Some abstractions are more useful in a descriptive form, which Kiczales refers to as analytic abstractions. Unlike constructive abstractions, analytic abstractions can be introduced after the development of the software without requiring changes, in particular at the time when they become useful.
Reference: [Kiczales 96] <author> G. Kiczales. </author> <title> Beyond the black box: Open implementation. </title> <journal> IEEE Software, </journal> <volume> 13(1) </volume> <pages> 8-11, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: As Kiczales has noted, not all software abstractions need to be constructive, as modules and classes are <ref> [Kiczales 94, Kiczales 96] </ref>. Some abstractions are more useful in a descriptive form, which Kiczales refers to as analytic abstractions. Unlike constructive abstractions, analytic abstractions can be introduced after the development of the software without requiring changes, in particular at the time when they become useful.
Reference: [Malan & Wentzel 93] <author> R. A. Malan and K. Wentzel. </author> <title> Economics of software reuse revisited. </title> <booktitle> In Proceedings of the 3rd Irvine Software Symposium, </booktitle> <pages> pages 109-121, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: By investing in architecture up front, substantial savings can be realized later on, and the turnaround time on releases can drop, improving rather than harming opportunity cost. One successful example is Hewlett Packard's software infrastructure for their printer line <ref> [Malan & Wentzel 93] </ref>. However, DeMarco estimates that the first release of a novel system costs three times as much when developed with a well-planned architecture [DeMarco 95]. This cost represents a high risk since today's farsighted architecture can be tomorrow's inappropriate architecture.
Reference: [Morgenthaler & Griswold 95] <author> J. D. Morgenthaler and W. G. Griswold. </author> <title> Program analysis for practical program restructuring. </title> <booktitle> In Proceedings of the ICSE-17 Workshop on Program Transformations for Software Evolution, </booktitle> <year> 1995. </year> <type> Tech. Report CS95-418, </type> <institution> Department of Computer Science and Engineering, University of California, </institution> <address> San Diego. </address>
Reference: [Muller et al. 92] <author> H. A. Muller, S. R. Tilley, M. A. Orgun, B. D. Corrie, and N. H. Madhavji. </author> <title> A reverse engineering environment based on spatial and visual software interconnection models. </title> <booktitle> In Proceedings of the SIG-SOFT '92 Fifth Symposium on Software Development Environments, </booktitle> <month> December </month> <year> 1992. </year>
Reference-contexts: Unlike a constructive abstraction, which is part of the software, an analytic abstraction is often matched to the software using general-purpose tools such as grep, or special-purpose tools such as RIGI <ref> [Muller et al. 92] </ref> or a reflexion modeling tool [Murphy et al. 95]. Example: Improving the Performance of a Restructuring Tool. In an earlier restructuring project, I investigated how to dramatically speed up a restructuring tool for Scheme.
Reference: [Murphy 96] <author> G. C. Murphy. </author> <title> Lightweight Structural Summarization as an Aid to Software Evolution. </title> <type> PhD dissertation, </type> <institution> University of Washington, Department of Computer Science & Engineering, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: Informal naming and file conventions were used to flag the columnar properties, but these are by no means constructive or highly visible. Indeed, an analysis of the architecture with a reflexion modeling tool was helpful in understanding some of the detailed relationships <ref> [Murphy et al. 95, Murphy 96] </ref>.
Reference: [Murphy et al. 95] <author> G. C. Murphy, D. Notkin, and K. Sullivan. </author> <title> Software reflexion models: bridging the gap between source and high-level models. </title> <booktitle> In ACM SIGSOFT '95 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 18-28, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Unlike a constructive abstraction, which is part of the software, an analytic abstraction is often matched to the software using general-purpose tools such as grep, or special-purpose tools such as RIGI [Muller et al. 92] or a reflexion modeling tool <ref> [Murphy et al. 95] </ref>. Example: Improving the Performance of a Restructuring Tool. In an earlier restructuring project, I investigated how to dramatically speed up a restructuring tool for Scheme. <p> Informal naming and file conventions were used to flag the columnar properties, but these are by no means constructive or highly visible. Indeed, an analysis of the architecture with a reflexion modeling tool was helpful in understanding some of the detailed relationships <ref> [Murphy et al. 95, Murphy 96] </ref>.
Reference: [Parnas 72] <author> D. L. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12) </volume> <pages> 1053-1058, </pages> <month> December </month> <year> 1972. </year>
Reference-contexts: In Parnas's method, the software architect first identifies the members of the program family, and then identifies the design decisions that will differ due to the variants. These decisions are to be isolated in modules according to Parnas's original information hiding principles <ref> [Parnas 72] </ref>. However, the modules are organized as a hierarchy of design decisions. The root of the hierarchy are those modules that are shared by all members.
Reference: [Parnas 76] <author> D. L. Parnas. </author> <title> On the design and development of program families. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 2(1) </volume> <pages> 1-9, </pages> <month> March </month> <year> 1976. </year>
Reference-contexts: One of the principal benefits of planning is the establishment of a software infrastructurea software architecturethat can be shared amongst a family of systems <ref> [Parnas 76] </ref> or used in the enhancement of an existing system. By investing in architecture up front, substantial savings can be realized later on, and the turnaround time on releases can drop, improving rather than harming opportunity cost. <p> This cost represents a high risk since today's farsighted architecture can be tomorrow's inappropriate architecture. Indeed, Parnas says, It usually pays to apply the [Parnas program family design] method only when one expects the eventual implementation of a wide selection of possible family members <ref> [Parnas 76, p. 7] </ref>. <p> How, then, can architecture be delayed without being wholly unplanned? (a) Start with version A (b) Add version B (c) Add version C the tree represents those modules shared by the indicated versions. I propose a modified version of Parnas's program family design method <ref> [Parnas 76] </ref>. In Parnas's method, the software architect first identifies the members of the program family, and then identifies the design decisions that will differ due to the variants. These decisions are to be isolated in modules according to Parnas's original information hiding principles [Parnas 72].
Reference: [Petroski 94] <author> H. Petroski. </author> <title> Design Paradigms: Case Histories of Error and Judgment in Engineering. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, England, </address> <year> 1994. </year>
Reference-contexts: As an example, early suspension bridges were overdesigned because civil engineers did not know how to make such a bridge both light and safe <ref> [Petroski 94] </ref>. Over time, the construction of several successful bridges led to insights about how to reduce weight.
Reference: [Sullivan & Notkin 92] <author> K. J. Sullivan and D. Notkin. </author> <title> Reconciling environment integration and component independence. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(3) </volume> <pages> 229-268, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Consequently I ignored the issue, but I pursued a layered design that used loose integration in the style of mediators <ref> [Sullivan & Notkin 92, Sullivan 94] </ref> to separate the data flow representations from the AST. Once the basic concept of a meaning-preserving restructuring tool was demonstrated, performance became an important issue.
Reference: [Sullivan 94] <author> K. J. Sullivan. Mediators: </author> <title> Easing the Design and Evolution of Integrated Systems. </title> <type> PhD dissertation, </type> <institution> University of Washington, Dept. of Computer Science & Engineering, </institution> <month> August </month> <year> 1994. </year> <month> 4 </month>
Reference-contexts: Consequently I ignored the issue, but I pursued a layered design that used loose integration in the style of mediators <ref> [Sullivan & Notkin 92, Sullivan 94] </ref> to separate the data flow representations from the AST. Once the basic concept of a meaning-preserving restructuring tool was demonstrated, performance became an important issue.
References-found: 24

