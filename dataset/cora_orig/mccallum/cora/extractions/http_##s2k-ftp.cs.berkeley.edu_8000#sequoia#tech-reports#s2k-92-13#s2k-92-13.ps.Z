URL: http://s2k-ftp.cs.berkeley.edu:8000/sequoia/tech-reports/s2k-92-13/s2k-92-13.ps.Z
Refering-URL: http://s2k-ftp.cs.berkeley.edu:8000/sequoia/tech-reports/s2k-92-13/
Root-URL: http://www.cs.berkeley.edu
Email: joey@postgres.berkeley.edu  
Title: Predicate Migration: Optimizing Queries with Expensive Predicates  
Author: Joseph M. Hellerstein 
Date: December 3, 1992  
Address: Berkeley, CA 94720  
Affiliation: Computer Science Division, EECS Department University of California,  
Abstract: The traditional focus of relational query optimization schemes has been on the choice of join methods and join orders. Restrictions have typically been handled in query optimizers by predicate pushdown rules, which apply restrictions in some random order before as many joins as possible. These rules work under the assumption that restriction is essentially a zero-time operation. However, today's extensible and object-oriented database systems allow users to define time-consuming functions, which may be used in a query's restriction and join predicates. Furthermore, SQL has long supported subquery predicates, which may be arbitrarily time-consuming to check. Thus restrictions should not be considered zero-time operations, and the model of query optimization must be enhanced. In this paper we develop a theory for moving expensive predicates in a query plan so that the total cost of the plan including the costs of both joins and restrictions is minimal. We present an algorithm to implement the theory, as well as results of our implementation in POSTGRES. Our experience with the newly enhanced POSTGRES query optimizer demonstrates that correctly optimizing queries with expensive predicates often produces plans that are orders of magnitude faster than plans generated by a traditional query optimizer. The additional complexity of considering expensive predicates during optimization is found to be manageably small.
Abstract-found: 1
Intro-found: 1
Reference: [CGK89] <author> Danette Chimenti, Ruben Gamboa, and Ravi Krishnamurthy. </author> <title> Towards an Open Architecture for LDL. </title> <booktitle> In Proc. 15th International Conference on Very Large Data Bases, </booktitle> <address> Amsterdam, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: The notion of expensive restrictions was considered in the context of the LDL logic programming system <ref> [CGK89] </ref>. Their solution was to model a restriction on relation R as a join between R and a virtual relation of infinite cardinality containing the entire logical predicate of the restriction. By modeling restrictions as joins, they were able to use a join-based query optimizer to order all predicates appropriately.
Reference: [D + 90] <author> O. </author> <title> Deux et al. </title> <journal> The Story of O 2 . IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1), </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: In today's systems, however, restriction can no longer be considered to be a zero-time operation. Extensible database systems such as POSTGRES [SR86] and Star-burst [HCL + 90], as well as various Object-Oriented DBMSs (e.g., [MS87], [WLH90], <ref> [D + 90] </ref>, [ONT92], etc.) allow users to implement predicate functions in a general-purpose programming language such as C or C++. These functions can be arbitrarily complex, potentially requiring access to large amounts of data, and extremely complex processing.
Reference: [Day87] <author> Umeshwar Dayal. </author> <title> Of Nests and Trees: A Unified Approach to Processing Queries that Contain Nested Subqueries, Aggregates, and Quantifiers. </title> <booktitle> In Proc. VLDB 87 [Pro87], </booktitle> <pages> pages 197-208. 15 </pages>
Reference-contexts: The cost of a subquery predicate may be lowered by transforming it to another subquery predicate [LDH + 87], and by early stop techniques, which stop materializing or scanning a subquery as soon as the predicate can be resolved <ref> [Day87] </ref>.
Reference: [HCL + 90] <author> L.M. Haas, W. Chang, G.M. Lohman, J. McPherson, P.F. Wilms, G. Lapis, B. Lindsay, H. Pirahesh, M. Carey, and E. Shekita. </author> <title> Starburst Mid-Flight: As the Dust Clears. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <pages> pages 143-160, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: In today's systems, however, restriction can no longer be considered to be a zero-time operation. Extensible database systems such as POSTGRES [SR86] and Star-burst <ref> [HCL + 90] </ref>, as well as various Object-Oriented DBMSs (e.g., [MS87], [WLH90], [D + 90], [ONT92], etc.) allow users to implement predicate functions in a general-purpose programming language such as C or C++.
Reference: [HOT88] <author> Wen-Chi Hou, Gultekin Ozsoyoglu, and Baldeao K. Taneja. </author> <title> Statistical Estimators for Relational Algebra Expressions. </title> <booktitle> In Proc. 7th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 276-287, </pages> <address> Austin, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: Typically these estimations are based on default values and system statistics [SAC + 79], although recent work suggests that accurate and inexpensive sampling techniques can be used <ref> [LNSS93, HOT88] </ref>. 2.1 Cost of User-Defined Functions in POSTGRES In an extensible system such as POSTGRES, arbitrary user-defined functions may be introduced into both restriction and join predicates. These functions may be written in a general programming language such as C, or in the database query language, e.g.
Reference: [IK84] <author> Toshihide Ibaraki and Tiko Kameda. </author> <title> Optimal Nesting for Computing N-relational Joins. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(3) </volume> <pages> 482-502, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: It is expected that these researchers will be writing queries with expensive functions to analyze this data. A benchmark of such queries is presented in [SFG92]. Ibaraki and Kameda <ref> [IK84] </ref>, Krishnamurthy, Boral and Zaniolo [KBZ86], and Swami and Iyer [SI92] have developed and refined a query optimization scheme that is built on the notion of rank that we will use below. However, their scheme uses rank to reorder joins rather than restrictions. <p> Furthermore, their schemes are a proposal for a completely new method for query optimization, while ours is an extension that can be applied to the plans of any query optimizer. It is possible to fuse the technique we develop in this paper with those of <ref> [IK84, KBZ86, SI92] </ref>, but we do not focus on that issue here since their schemes are not widely in use. The notion of expensive restrictions was considered in the context of the LDL logic programming system [CGK89].
Reference: [ISO91] <author> ISO ANSI. </author> <title> Database Language SQL ISO/IEC 9075:1992, </title> <year> 1991. </year>
Reference-contexts: This will be illustrated below. 1.1 Application to Existing Systems: SQL and Subqueries It is important to note that expensive predicate functions do not exist only in next-generation research prototypes. Current relational languages, such as the industry standard, SQL <ref> [ISO91] </ref>, have long supported expensive predicate functions in the guise of subquery predicates.
Reference: [Jhi88] <author> Anant Jhingran. </author> <title> A Performance Study of Query Optimization Algorithms on a Database System Supporting Procedures. </title> <booktitle> In Proc. VLDB 88 [Pro88]. </booktitle>
Reference-contexts: The scheme presented here does not cause traditional optimizers to exhibit this exponential growth in optimization time. Caching the return values of function calls will prove to be vital to the techniques presented in this paper. Jhingran <ref> [Jhi88] </ref> has explored a number of the issues involved in caching procedures for query optimization. Our model is slightly different, since our caching scheme is value-based, simply storing the results of a function on a set of argument values.
Reference: [KBZ86] <author> Ravi Krishnamurthy, Haran Boral, and Carlo Zaniolo. </author> <title> Optimization of Nonrecursive Queries. </title> <booktitle> In Proc. 12th International Conference on Very Large Data Bases, </booktitle> <pages> pages 128-137, </pages> <address> Kyoto, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: It is expected that these researchers will be writing queries with expensive functions to analyze this data. A benchmark of such queries is presented in [SFG92]. Ibaraki and Kameda [IK84], Krishnamurthy, Boral and Zaniolo <ref> [KBZ86] </ref>, and Swami and Iyer [SI92] have developed and refined a query optimization scheme that is built on the notion of rank that we will use below. However, their scheme uses rank to reorder joins rather than restrictions. <p> Furthermore, their schemes are a proposal for a completely new method for query optimization, while ours is an extension that can be applied to the plans of any query optimizer. It is possible to fuse the technique we develop in this paper with those of <ref> [IK84, KBZ86, SI92] </ref>, but we do not focus on that issue here since their schemes are not widely in use. The notion of expensive restrictions was considered in the context of the LDL logic programming system [CGK89].
Reference: [LDH + 87] <author> Guy M. Lohman, Dean Daniels, Laura M. Haas, Ruth Kistler, and Patricia G. Selinger. </author> <title> Optimization of Nested Queries in a Distributed Relational Database. </title> <booktitle> In Proc. VLDB 87 [Pro87]. </booktitle>
Reference-contexts: The cost estimates presented here for query language functions form a simple model and raise some issues in setting costs for subqueries. The cost of a subquery predicate may be lowered by transforming it to another subquery predicate <ref> [LDH + 87] </ref>, and by early stop techniques, which stop materializing or scanning a subquery as soon as the predicate can be resolved [Day87].
Reference: [LNSS93] <author> Richard J. Lipton, Jeffrey F. Naughton, Donovan A. Schneider, and S. Seshadri. </author> <title> Efficient Sampling Strategies for Relational Database Operations. </title> <note> To appear in Theoretical Computer Science, </note> <year> 1993. </year>
Reference-contexts: Typically these estimations are based on default values and system statistics [SAC + 79], although recent work suggests that accurate and inexpensive sampling techniques can be used <ref> [LNSS93, HOT88] </ref>. 2.1 Cost of User-Defined Functions in POSTGRES In an extensible system such as POSTGRES, arbitrary user-defined functions may be introduced into both restriction and join predicates. These functions may be written in a general programming language such as C, or in the database query language, e.g.
Reference: [LS88] <author> C. Lynch and M. Stonebraker. </author> <title> Extended User-Defined Indexing with Application to Textual Databases. </title> <booktitle> In Proc. VLDB 88 [Pro88]. </booktitle>
Reference-contexts: We ran the query in POSTGRES without the rank-sort optimization, generating Plan 1 of Figure 1, and with the rank-sort optimization, 3 It is possible to index tables on function values as well as on table attributes <ref> [MS86, LS88] </ref>.
Reference: [MFPR90] <author> Inderpal Singh Mumick, Sheldon J. Finkelstein, Hamid Pirahesh, and Raghu Ramakrishnan. </author> <title> Magic is Relevant. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 247-258, </pages> <address> Atlantic City, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: It would be interesting to attempt to extend this work to handle queries with common subexpressions and recursion. The Magic Sets optimization technique for recursive and non-recursive queries <ref> [MFPR90] </ref> actually generates predicates in a query plan and pushes them down. It is not clear when this generation is cost-effective, and our model here may be useful for making that decision.
Reference: [Mos90] <author> Claire Mosher (ed.). </author> <title> The POSTGRES Reference Manual, Volume 2. </title> <type> Technical Report M90/53, </type> <institution> Electronics Research Laboratory, University of California, Berkeley, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Selectivity modeling for user-defined operators in POSTGRES has been described in <ref> [Mos90] </ref>. To introduce a function to POSTGRES, a user first writes the function in C and compiles it, and then issues Postquel's define function command. To capture expense information, the define function command accepts a number of special flags, which are summarized in Table 1.
Reference: [MS79] <author> C. L. Monma and J.B. Sidney. </author> <title> Sequencing with Series-Parallel Precedence Constraints. </title> <journal> Mathematics of Operations Research, </journal> <volume> 4 </volume> <pages> 215-224, </pages> <year> 1979. </year>
Reference-contexts: It is analogous to the Least-Cost Fault Detection problem solved in <ref> [MS79] </ref>. <p> In such situations, we will need to find the optimal ordering of predicates in the stream subject to the precedence constraints. Monma and Sidney <ref> [MS79] </ref> have shown that finding the optimal ordering under arbitrary precedence constraints can be done fairly simply. Their analysis is based on two key results: 1. <p> We use their algorithm as a subroutine in our optimization algorithm: Predicate Migration Algorithm: To optimize a plan tree, we push all predicates down as far as possible, 5 and then repeatedly apply the Series-Parallel Algorithm Using Parallel Chains <ref> [MS79] </ref> to each stream in the tree, until no more progress can be made. Upon termination, the Predicate Migration Algorithm produces a tree in which each stream is well-ordered (i.e. optimally ordered subject to the precedence constraints). <p> If one does not assume linear join costs, then the algorithm of <ref> [MS79] </ref> no longer applies. It would be interesting to discover whether the problem of Predicate Migration can be solved in polynomial time in general, or whether the assumptions made here are in fact crucial to a poly-time solution. The implementation of function caching in POSTGRES has not been completed.
Reference: [MS86] <author> D. Maier and J. Stein. </author> <title> Indexing in an Object-Oriented DBMS. </title> <editor> In Klaus R. Dittrich and Umeshwar Dayal, editors, </editor> <booktitle> Proc. Workshop on Object-Oriented Database Systems, Asilomar, </booktitle> <month> September </month> <year> 1986. </year>
Reference-contexts: We ran the query in POSTGRES without the rank-sort optimization, generating Plan 1 of Figure 1, and with the rank-sort optimization, 3 It is possible to index tables on function values as well as on table attributes <ref> [MS86, LS88] </ref>.
Reference: [MS87] <author> D. Maier and J. Stein. </author> <title> Development and Implementation of an Object-Oriented DBMS. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: In today's systems, however, restriction can no longer be considered to be a zero-time operation. Extensible database systems such as POSTGRES [SR86] and Star-burst [HCL + 90], as well as various Object-Oriented DBMSs (e.g., <ref> [MS87] </ref>, [WLH90], [D + 90], [ONT92], etc.) allow users to implement predicate functions in a general-purpose programming language such as C or C++. These functions can be arbitrarily complex, potentially requiring access to large amounts of data, and extremely complex processing.
Reference: [Ols92] <author> Michael A. Olson. </author> <title> Extending the POSTGRES Database System to Manage Tertiary Storage. </title> <type> Master's thesis, </type> <institution> University of California, Berkeley, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Each tuple in maps contains a reference to a POSTGRES large object <ref> [Ols92] </ref>, which is a map picture taken by a satellite. These map pictures were taken weekly, and the maps table contains a foreign key to the weeks table, which stores information about the week in which each picture was taken.
Reference: [O'N89] <author> P. O'Neil. </author> <title> Revisiting DBMS Benchmarks. </title> <journal> Datamation, </journal> <pages> pages 47-54, </pages> <month> September 15, </month> <year> 1989. </year>
Reference: [ONT92] <author> ONTOS, Inc. </author> <title> ONTOS Object SQL Guide, </title> <month> February </month> <year> 1992. </year> <title> For the ONTOS DB database, Release 2.2. </title>
Reference-contexts: In today's systems, however, restriction can no longer be considered to be a zero-time operation. Extensible database systems such as POSTGRES [SR86] and Star-burst [HCL + 90], as well as various Object-Oriented DBMSs (e.g., [MS87], [WLH90], [D + 90], <ref> [ONT92] </ref>, etc.) allow users to implement predicate functions in a general-purpose programming language such as C or C++. These functions can be arbitrarily complex, potentially requiring access to large amounts of data, and extremely complex processing.
Reference: [PHH92] <author> Hamid Pirahesh, Joseph M. Hellerstein, and Waqar Hasan. </author> <title> Extensible/Rule-Based Query Rewrite Optimization in Starburst. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 39-48, </pages> <address> San Diego, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: While some subquery predicates can be converted into joins (thereby becoming subject to traditional join-based optimization strategies) even sophisticated SQL rewrite systems, such as that of Starburst <ref> [PHH92] </ref>, cannot convert all subqueries to joins. When one is forced to compute a subquery in order to evaluate a predicate, then the predicate should be treated as an expensive function. <p> In SQL, the query is: SELECT name FROM dept d1 WHERE d1.category = 'tech' AND (d1.budget &lt; 1000 OR EXISTS (SELECT 1 FROM emp WHERE emp.dno = d1.dno AND emp.age &gt; 65)); Since the existential subquery is nested within an OR, the subquery cannot be converted to a join <ref> [PHH92] </ref>.
Reference: [Pro87] <editor> Proc. </editor> <booktitle> 13th International Conference on Very Large Data Bases, </booktitle> <address> Brighton, </address> <month> September </month> <year> 1987. </year>
Reference: [Pro88] <editor> Proc. </editor> <booktitle> 14th International Conference on Very Large Data Bases, </booktitle> <address> Los Angeles, </address> <month> August-September </month> <year> 1988. </year> <month> 16 </month>
Reference: [RS87] <author> L.A. Rowe and M.R. Stonebraker. </author> <title> The POSTGRES Data Model. </title> <booktitle> In Proc. VLDB 87 [Pro87], </booktitle> <pages> pages 83-96. </pages>
Reference-contexts: execution time per invocation, regardless of the size of the arguments perbyte cpu execution time per byte of arguments byte pct percentage of argument bytes that the function will need to access Table 1: Function Expense Parameters in POSTGRES A relational query in a language such as SQL or Postquel <ref> [RS87] </ref> may have a where clause, which contains an arbitrary Boolean expression over constants and the range variables of the query.
Reference: [SAC + 79] <author> Patricia G. Selinger, M. Astrahan, D. Chamberlin, Raymond Lorie, and T. Price. </author> <title> Access Path Selection in a Relational Database Management System. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Boston, </address> <month> June </month> <year> 1979. </year>
Reference-contexts: We break such clauses into a maximal set of conjuncts, or Boolean factors <ref> [SAC + 79] </ref>, and refer to each Boolean factor as a distinct predicate to be satisfied by each result tuple of the query. When we use the term predicate below, we refer to a Boolean factor of the query's where clause. <p> That is, for any predicate p (join or restriction) they estimate the value selectivity (p) = card (output (p)) card (input (p)) and make the assumption that selectivities of different predicates are independent. Typically these estimations are based on default values and system statistics <ref> [SAC + 79] </ref>, although recent work suggests that accurate and inexpensive sampling techniques can be used [LNSS93, HOT88]. 2.1 Cost of User-Defined Functions in POSTGRES In an extensible system such as POSTGRES, arbitrary user-defined functions may be introduced into both restriction and join predicates. <p> To benefit from the techniques described in this paper, an SQL system must be enhanced to do this caching, at least for the duration of a query. It is interesting to note that in the original paper on optimizing SQL queries in System R <ref> [SAC + 79] </ref>, there is a description of a limited form of caching for correlated subqueries. <p> minimal-cost plan for the query. 5 Most systems perform this operation while building plan trees, since predicate pushdown is traditionally considered a good heuristic. 11 A traditional query optimizer, however, does not enumerate all possible plans for a query; it does some pruning of the plan space while enumerating plans <ref> [SAC + 79] </ref>. Although this pruning does not affect the basic exponential nature of join plan enumeration, it can significantly lower the amounts of space and time required to optimize queries with many joins.
Reference: [SD92] <author> Michael Stonebraker and Jeff Dozier. </author> <title> Sequoia 2000: Large Capacity Object Servers to Support Global Change Research. </title> <type> Technical Report Sequoia 2000 91/1, </type> <institution> University of California, Berkeley, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: The questions posed by Stonebraker are directly addressed in this paper, although we vary slightly in the definition of cost metrics for expensive functions. One of the main applications of the system described in [Sto91] is Project Sequoia 2000 <ref> [SD92] </ref>, a University of California project that will manage terabytes of Geographic Information System (GIS) data, to support global change researchers. It is expected that these researchers will be writing queries with expensive functions to analyze this data. A benchmark of such queries is presented in [SFG92].
Reference: [SFG92] <author> Michael Stonebraker, James Frew, and Kenn Gardels. </author> <title> The Sequoia 2000 Benchmark. </title> <type> Technical Report Sequoia 2000 92/12, </type> <institution> University of California, Berkeley, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: It is expected that these researchers will be writing queries with expensive functions to analyze this data. A benchmark of such queries is presented in <ref> [SFG92] </ref>. Ibaraki and Kameda [IK84], Krishnamurthy, Boral and Zaniolo [KBZ86], and Swami and Iyer [SI92] have developed and refined a query optimization scheme that is built on the notion of rank that we will use below. However, their scheme uses rank to reorder joins rather than restrictions.
Reference: [SI92] <author> Arun Swami and Balakrishna R. Iyer. </author> <title> A Polynomial Time Algorithm for Optimizing Join Queries. </title> <type> Research Report RJ 8812, </type> <institution> IBM Almaden Research Center, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: It is expected that these researchers will be writing queries with expensive functions to analyze this data. A benchmark of such queries is presented in [SFG92]. Ibaraki and Kameda [IK84], Krishnamurthy, Boral and Zaniolo [KBZ86], and Swami and Iyer <ref> [SI92] </ref> have developed and refined a query optimization scheme that is built on the notion of rank that we will use below. However, their scheme uses rank to reorder joins rather than restrictions. <p> Furthermore, their schemes are a proposal for a completely new method for query optimization, while ours is an extension that can be applied to the plans of any query optimizer. It is possible to fuse the technique we develop in this paper with those of <ref> [IK84, KBZ86, SI92] </ref>, but we do not focus on that issue here since their schemes are not widely in use. The notion of expensive restrictions was considered in the context of the LDL logic programming system [CGK89].
Reference: [SR86] <author> M.R. Stonebraker and L.A. Rowe. </author> <title> The Design of POSTGRES. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Washington, D.C., </address> <month> May </month> <year> 1986. </year>
Reference-contexts: The rationale behind these pushdown rules is that the relational restriction and projection operators take essentially no time to carry out, and reduce subsequent join costs. In today's systems, however, restriction can no longer be considered to be a zero-time operation. Extensible database systems such as POSTGRES <ref> [SR86] </ref> and Star-burst [HCL + 90], as well as various Object-Oriented DBMSs (e.g., [MS87], [WLH90], [D + 90], [ONT92], etc.) allow users to implement predicate functions in a general-purpose programming language such as C or C++.
Reference: [Sto91] <author> Michael Stonebraker. </author> <title> Managing Persistent Objects in a Multi-Level Store. </title> <booktitle> In Proc. ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 2-11, </pages> <address> Denver, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Thus the work presented in this paper is applicable to the majority of today's production RDBMSs, which support SQL. 1.2 Related Work Stonebraker first raised the issue of expensive predicate optimization in the context of the POSTGRES multi-level store <ref> [Sto91] </ref>. The questions posed by Stonebraker are directly addressed in this paper, although we vary slightly in the definition of cost metrics for expensive functions. One of the main applications of the system described in [Sto91] is Project Sequoia 2000 [SD92], a University of California project that will manage terabytes of <p> raised the issue of expensive predicate optimization in the context of the POSTGRES multi-level store <ref> [Sto91] </ref>. The questions posed by Stonebraker are directly addressed in this paper, although we vary slightly in the definition of cost metrics for expensive functions. One of the main applications of the system described in [Sto91] is Project Sequoia 2000 [SD92], a University of California project that will manage terabytes of Geographic Information System (GIS) data, to support global change researchers. It is expected that these researchers will be writing queries with expensive functions to analyze this data. <p> This data may be stored anywhere in the various levels of the POSTGRES multi-level store, but unlike <ref> [Sto91] </ref> we do not require the user to 1 After repeated applications of a function, one could collect performance statistics and use curve-fitting techniques to make estimates about the function's behavior.
Reference: [TOB89] <author> C. Turbyfill, C. Orji, and Dina Bitton. </author> <title> AS3AP A Comparative Relational Database Benchmark. </title> <booktitle> In Proc. IEEE Compcon Spring '89, </booktitle> <month> February </month> <year> 1989. </year>
Reference: [Ull89] <author> Jeffrey D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> volume 2. </volume> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Traditional relational database (RDBMS) literature on query optimization stresses the significance of choosing an efficient order of joins in a query plan. The placement of the other standard relational operators (restriction and projection) in the plan has typically been handled by pushdown rules (see e.g., <ref> [Ull89] </ref>), which state that restrictions and projections should be pushed down the query plan tree as far as possible. These rules place no importance on the ordering of projections and restrictions once they have been pushed below joins.
Reference: [WLH90] <author> K. Wilkinson, P. Lyngbaek, and W. Hasan. </author> <title> The Iris Architecture and Implementation. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1), </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: In today's systems, however, restriction can no longer be considered to be a zero-time operation. Extensible database systems such as POSTGRES [SR86] and Star-burst [HCL + 90], as well as various Object-Oriented DBMSs (e.g., [MS87], <ref> [WLH90] </ref>, [D + 90], [ONT92], etc.) allow users to implement predicate functions in a general-purpose programming language such as C or C++. These functions can be arbitrarily complex, potentially requiring access to large amounts of data, and extremely complex processing.
References-found: 33

