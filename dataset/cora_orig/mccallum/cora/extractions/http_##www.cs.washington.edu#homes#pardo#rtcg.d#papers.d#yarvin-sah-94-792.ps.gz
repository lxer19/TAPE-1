URL: http://www.cs.washington.edu/homes/pardo/rtcg.d/papers.d/yarvin-sah-94-792.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/pardo/rtcg.d/index.html
Root-URL: 
Title: QuaC: Binary Optimization for Fast Runtime Code Generation in C (EXTENDED ABSTRACT)  
Author: Curtis Yarvin Adam Sah 
Abstract: Runtime code generation (RTCG) has considerable theoretical potential but has so far seen little use in practice. Adequate tools are lacking. We present QuaC, an RTCG system that lets C programmers specialize their functions at runtime with a simple, portable user interface. QuaC works by applying compiler optimization techniques to machine code in memory. It is fast and highly retargetable. 
Abstract-found: 1
Intro-found: 1
Reference: [Chr94] <author> Wayne Christopher. </author> <title> Multiple-Representation Editing of Physically-Based 3D Animation. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <month> January </month> <year> 1994. </year> <month> 5 </month>
Reference-contexts: This is efficient, but it makes the entire system unportable and forces its programmer to work closely with assembly language. * Performance. Some systems forego any attempt at an interface for specialization, and generate full HLL code by hand at runtime. A good example is Christopher's Asgard system <ref> [Chr94] </ref>, which needs to repeatedly evaluate complex algebraic expressions defined at runtime; it converts them into C, sends them to the compiler, and dynamically loads the resulting object module. This process produces good code, but causes performance problems.
Reference: [CU91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 26(11) </volume> <pages> 1-15, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: With the advent of high-level languages, self-modifying code and other forms of RTCG largely disappeared, because HLLs provide no obvious mechanism to support it; but experiments continued in dedicated systems [[PLR85], [May87]] and compilers [[PS84], <ref> [CU91] </ref>], which could afford to be machine-dependent. One of the most interesting and spectacular uses of RTCG in recent years, and the one which sparked our interest in the field, is Massalin's Synthesis operating system [[MP89]].
Reference: [Dig] <institution> Digital Equipment Corporation. </institution> <note> Ultrix v4.2 pixie Manual Page. </note>
Reference-contexts: The most similar RTCG system we know of is Keppel's [KEH93], which uses intermediate-code templates and a compiler backend. Binary code analysis was pioneered in profiling systems, such as pixie <ref> [Dig] </ref>; but the analysis techniques needed for profiling differ from those for optimization. Currying and partial evaluation are old techniques from the programming language community; they are usually applied in higher-level languages than C. 9 Conclusion QuaC is hardly a finished system.
Reference: [FH91] <author> C. W. Fraser and R. R. Henry. </author> <title> Hard-Coding Bottom-Up Code Generation Tables to Save Time and Space. </title> <journal> Software|Practice and Experience, </journal> <volume> 21(1) </volume> <pages> 1-12, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Optimization demands more knowledge of the instruction set; we need rules for improving instructions based on knowledge of constant data. This can be coded ad hoc or done with a rule engine as in lcc <ref> [FH91] </ref>. This approach maps well onto all RISC and CISC architectures we know of, including those with delay slots. 6 Implementation We are in the early stages of implementation on QuaC. Our prototype system does dataflow analysis, all our standard optimizations, and none of the optional ones.
Reference: [KEH93] <author> David Keppel, Susan J. Eggers, and Robert R. Henry. </author> <title> Evaluating Runtime-Compiled Value-Specific Optimizations. </title> <type> Technical Report 93-11-02, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: We would add the fix and synth keywords to the parser, and modify the output generator to include information for specialization (such as a copy of the intermediate representation for template functions). Such an implementation would be straightforward. <ref> [KEH93] </ref> describes an RTCG system that works this way. With the template's intermediate representation stored in the executable, the runtime system needs be little more than the compiler's optimizer and code generator. <p> The most similar RTCG system we know of is Keppel's <ref> [KEH93] </ref>, which uses intermediate-code templates and a compiler backend. Binary code analysis was pioneered in profiling systems, such as pixie [Dig]; but the analysis techniques needed for profiling differ from those for optimization.
Reference: [May87] <author> Cathy May. </author> <title> A Fast S/370 Simulator. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 22(6) </volume> <pages> 1-13, </pages> <year> 1987. </year>
Reference-contexts: With the advent of high-level languages, self-modifying code and other forms of RTCG largely disappeared, because HLLs provide no obvious mechanism to support it; but experiments continued in dedicated systems [[PLR85], <ref> [May87] </ref>] and compilers [[PS84], [CU91]], which could afford to be machine-dependent. One of the most interesting and spectacular uses of RTCG in recent years, and the one which sparked our interest in the field, is Massalin's Synthesis operating system [[MP89]].
Reference: [MP89] <author> Henry Massalin and Calton Pu. </author> <title> Threads and Input/Output in the Synthesis Kernel. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201, </pages> <year> 1989. </year>
Reference: [PLR85] <author> Rob Pike, Bart N. Locanthi, and J. F. Reiser. </author> <title> Hardware/Software Tradeoffs for Bitmap Graphics on the Blit. </title> <journal> Software|Practice and Experience, </journal> <volume> 16(2) </volume> <pages> 131-151, </pages> <month> February </month> <year> 1985. </year>
Reference: [PS84] <author> Lori L. Pollock and Mary Lou Soffa. </author> <title> Incremental Compilation of Locally Optimized Code. </title> <booktitle> In Proceedings of the ACM SIGPLAN '84 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 152-164, </pages> <year> 1984. </year>
Reference: [WLG94] <author> Robert Wahbe, Steven Lucco, and Susan L. Graham. </author> <title> Adaptable Binary Programs, </title> <note> 1994. Submitted to PLDI '94. </note>
Reference-contexts: For this we need to know the calling convention and the number of arguments passed; for the latter we take a hint. 3.5 Adaptable Binaries Future compilers may provide program structure information such as that from Wahbe and Lucco's ABS <ref> [WLG94] </ref>. In that case, hints and range analysis are unnecessary. 4 Choosing Optimizations If there are no unknown stack indirections we have the same information as a compiler-based optimizer and can perform the same transformations.
Reference: [YBA93] <author> Curtis Yarvin, Richard Bukowski, and Thomas Anderson. Anonymous RPC: </author> <title> Low-Latency Protection in a 64-Bit Address Space. </title> <booktitle> In Proceedings of the 1993 Summer USENIX Conference, </booktitle> <year> 1993. </year>
Reference-contexts: This is slow but may be valuable for frequently-executed routines, because it converges on optimal code. For extremely large or offset jump tables we need to place the jump table in an anonymous section of memory <ref> [YBA93] </ref> and regenerate on page faults; this may require OS support. 3.4 Restoring Function Call Information QuaC's analysis is intraprocedural. We need to be able to recognize function calls and work around them.
References-found: 11

