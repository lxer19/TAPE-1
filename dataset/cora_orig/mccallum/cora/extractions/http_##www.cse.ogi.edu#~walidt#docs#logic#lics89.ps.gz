URL: http://www.cse.ogi.edu/~walidt/docs/logic/lics89.ps.gz
Refering-URL: http://www.cse.ogi.edu/~walidt/docs/logic/
Root-URL: http://www.cse.ogi.edu
Title: Computational lambda-calculus and monads  
Author: Eugenio Moggi 
Note: On leave from  
Address: EH9 3JZ Edinburgh, UK  
Affiliation: Lab. for Found. of Comp. Sci. University of Edinburgh  Univ. di Pisa  
Abstract: The -calculus is considered an useful mathematical tool in the study of programming languages. However, if one uses fi-conversion to prove equivalence of programs, then a gross simplification 1 is introduced. We give a calculus based on a categorical semantics for computations, which provides a correct basis for proving equivalence of programs, independent from any specific computational model. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R.L. Constable and S.F. Smith. </author> <title> Partial objects in constructive type theory. </title> <booktitle> In 2nd LICS Conf. IEEE, </booktitle> <year> 1987. </year>
Reference-contexts: The view that "category theory comes, logically, before the -calculus" led us to consider a categorical semantics of computations first, rather than to modify directly the rules of fi-conversion to get a correct calculus. A type theoretic approach to partial functions and computations is attempted in <ref> [1] </ref> by introducing a type constructor A, whose intuitive meaning is the set of computations of type A. Our categorical semantics is based on a similar idea.
Reference: [2] <author> J.M.E. Hyland and A.M. Pitts. </author> <title> The theory of constructions: Categorical semantics and topos-theoretic models. </title> <booktitle> In Proc. AMS Conf. on Categories in Comp. Sci. and Logic (Boulder 1987), </booktitle> <year> 1987. </year>
Reference-contexts: So a strong monad is just a monad over C enriched over itself in the 2-category of C-enriched categories. The second explanation was suggested to us by G. Plotkin, and takes as fundamental structure a class D of display maps over C, which models dependent types (see <ref> [2] </ref>), and induces a C-indexed category C= D . Then a strong monad over a category C with finite products amounts to a monad over C= D in the 2-category of C-indexed categories, where D is the class of first projections (corresponding to constant type dependency).
Reference: [3] <author> P.T. Johnstone and R. Pare, </author> <title> editors. Indexed Categories and their Applications, </title> <booktitle> volume 661 of Lecture Notes in Mathematics. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1978. </year>
Reference-contexts: Following this general principle we can give two explanations for t, one based on enriched categories (see [4]) and the other on indexed categories (see <ref> [3] </ref>). The first explanation takes as fundamental a commutative monoidal structure on C, which models the tensor product of linear logic (see [6, 14]).
Reference: [4] <author> G.M. Kelly. </author> <title> Basic Concepts of Enriched Category Theory. </title> <publisher> Cambridge University Press, </publisher> <year> 1982. </year>
Reference-contexts: Since monads and adjunctions are 2-category concepts, the most natural way to model computations (and datatypes) for more complex languages is simply by monads (and adjunctions) in a suitable 2-category. Following this general principle we can give two explanations for t, one based on enriched categories (see <ref> [4] </ref>) and the other on indexed categories (see [3]). The first explanation takes as fundamental a commutative monoidal structure on C, which models the tensor product of linear logic (see [6, 14]).
Reference: [5] <author> A. Kock. </author> <title> Strong functors and monoidal monads. </title> <journal> Archiv der Mathematik, </journal> <volume> 23, </volume> <year> 1972. </year>
Reference-contexts: If C is a monoidal closed category, in particular a ccc, then it can be enriched over itself by taking C (A; B) to be the object B A . The equations for t are taken from <ref> [5] </ref>, where a one-one correspondence is established between functorial and tensorial strengths 3 : * the first two equations say that t is a tensorial strength of T , so that T is a C-enriched functor. * the last two equations say that and are natural transformations between C-enriched functors, namely <p> There is also 3 A functorial strength for an endofunctor T is a natural transformation st A;B : B A ! (T B) T A which internalizes the action of T on morphisms. a dual notion of pairing, ~ A;B = c A;B ; B;A ; T c B;A (see <ref> [5] </ref>), which amounts to first evaluating the second argument and then the first.
Reference: [6] <author> Y. Lafont. </author> <title> The linear abstract machine. </title> <journal> Theoretical Computer Science, </journal> <volume> 59, </volume> <year> 1988. </year>
Reference-contexts: Following this general principle we can give two explanations for t, one based on enriched categories (see [4]) and the other on indexed categories (see [3]). The first explanation takes as fundamental a commutative monoidal structure on C, which models the tensor product of linear logic (see <ref> [6, 14] </ref>). If C is a monoidal closed category, in particular a ccc, then it can be enriched over itself by taking C (A; B) to be the object B A .
Reference: [7] <author> E. Manes. </author> <title> Algebraic Theories, volume 26 of Graduate Texts in Mathematics. </title> <publisher> Springer Verlag, </publisher> <year> 1976. </year>
Reference-contexts: There is an alternative description of a monad (see <ref> [7] </ref>), which is easier to justify computationally.
Reference: [8] <author> E. Moggi. </author> <title> Categories of partial morphisms and the partial lambda-calculus. </title> <booktitle> In Proceedings Workshop on Category Theory and Computer Programming, Guildford 1985, volume 240 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1986. </year>
Reference-contexts: At the end we get a formal system, the computational lambda-calculus ( c -calculus for short), for proving equivalence of programs, which is sound and complete w.r.t. the categorical semantics of computations. 1 The methodology outlined above is inspired by [13] 2 , and it is followed in <ref> [11, 8] </ref> to obtain the p -calculus. The view that "category theory comes, logically, before the -calculus" led us to consider a categorical semantics of computations first, rather than to modify directly the rules of fi-conversion to get a correct calculus. <p> By analogy with partial cartesian closed categories (see <ref> [8, 11] </ref>), we will interpret functional types by exponentials of the form (T B) .
Reference: [9] <author> E. Moggi. </author> <title> The Partial Lambda-Calculus. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1988. </year>
Reference-contexts: These modifications are similar to those introduced in the logic of partial terms (see Section 2.4 in <ref> [9] </ref>). rather unrelated, although both of them can be un-derstood in terms of functions. For instance, various logical modalities (like possibility and necessity in modal logic or why not and of course of linear logic) are modelled by monads or comonads which cannot have a tensorial strength.
Reference: [10] <author> G.D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1, </volume> <year> 1975. </year>
Reference-contexts: There are three approaches to proving equivalence of programs: * The operational approach starts from an operational semantics, e.g. a partial function mapping every program (i.e. closed term) to its resulting value (if any), which induces a congruence relation on open terms called operational equivalence (see e.g. <ref> [10] </ref>). Then the problem is to prove that two terms are operationally equivalent. * The denotational approach gives an interpretation of the (programming) language in a mathematical structure, the intended model. <p> This view of programs corresponds to call-by-value parameter passing, but there is an alternative view of "programs as functions from computations to computations" corresponding to call-by-name (see <ref> [10] </ref>). In any case, the real issue is that the notions of value and computation should not be confused. By taking call-by-value we can stress better the importance of values. Moreover, call-by-name can be more easily represented in call-by-value than the other way around.
Reference: [11] <author> G. Rosolini. </author> <title> Continuity and Effectiveness in Topoi. </title> <type> PhD thesis, </type> <institution> University of Oxford, </institution> <year> 1986. </year>
Reference-contexts: At the end we get a formal system, the computational lambda-calculus ( c -calculus for short), for proving equivalence of programs, which is sound and complete w.r.t. the categorical semantics of computations. 1 The methodology outlined above is inspired by [13] 2 , and it is followed in <ref> [11, 8] </ref> to obtain the p -calculus. The view that "category theory comes, logically, before the -calculus" led us to consider a categorical semantics of computations first, rather than to modify directly the rules of fi-conversion to get a correct calculus. <p> By analogy with partial cartesian closed categories (see <ref> [8, 11] </ref>), we will interpret functional types by exponentials of the form (T B) .
Reference: [12] <author> D.S. Scott. </author> <title> A type-theoretic alternative to CUCH, </title> <publisher> ISWIM, OWHY. Oxford notes, </publisher> <year> 1969. </year>
Reference-contexts: We believe that there is a great potential to be exploited here. The c -calculus open also the possibility to develop a new Logic of Computable Functions (see <ref> [12] </ref>), based on an abstract semantic of computations rather than domain theory, for studying axiomatically different notions of computation and their relations. Acknowledgements My thanks to M. Hyland, A. Kock (and other participants to the 1988 Category Theory Meeting in Sus-sex) for directing me towards the literature on monads.
Reference: [13] <author> D.S. Scott. </author> <title> Relating theories of the -calculus. </title> <editor> In R. Hindley and J. Seldin, editors, </editor> <booktitle> To H.B. Curry: essays in Combinarory Logic, lambda calculus and Formalisms. </booktitle> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: At the end we get a formal system, the computational lambda-calculus ( c -calculus for short), for proving equivalence of programs, which is sound and complete w.r.t. the categorical semantics of computations. 1 The methodology outlined above is inspired by <ref> [13] </ref> 2 , and it is followed in [11, 8] to obtain the p -calculus. The view that "category theory comes, logically, before the -calculus" led us to consider a categorical semantics of computations first, rather than to modify directly the rules of fi-conversion to get a correct calculus.

References-found: 13

