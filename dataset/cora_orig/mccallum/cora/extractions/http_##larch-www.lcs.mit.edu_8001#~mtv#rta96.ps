URL: http://larch-www.lcs.mit.edu:8001/~mtv/rta96.ps
Refering-URL: http://larch-www.lcs.mit.edu:8001/~mtv/
Root-URL: 
Email: mtv@lcs.mit.edu  kapur@cs.albany.edu  
Phone: 02139, +1 617 253-3538,  2  
Title: Distributed Larch Prover (DLP): An Experiment in Parallelizing a Rewrite-Rule based Prover  
Author: Mark T. Vandevoorde and Deepak Kapur 
Note: DLP runs on a network of workstations.  
Address: Cambridge, MA  New York, Albany, NY 12222.  
Affiliation: 1 Lab. for Computer Science, Massachusetts Institute of Technology,  Dept. of Computer Science, State University of  
Abstract: The Distributed Larch Prover, DLP, is a distributed and parallel version of LP, an interactive prover. DLP helps users find proofs by creating and managing many proof attempts that run in parallel. Parallel attempts may cooperate by working on different subgoals, and they may compete by using different inference methods to prove the same goal. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Avenhaus, J., and Denzinger, D., </author> <title> "Distributed equational theorem proving," </title> <booktitle> Proc. 5th Conf. on Rewriting Techniques and Applications, </booktitle> <publisher> LNCS 690 (ed. Kirchner), </publisher> <address> Montreal, 62-76, </address> <year> 1993. </year>
Reference-contexts: For example, a rewrite-based prover can exploit parallel algorithms for matching, normalization, and completion, for instance, by generating critical pairs among rewrite rules in parallel, or by running completion using different strategies as in DISCOUNT <ref> [1] </ref>. Resolutions-based provers such as Peers [2] and ROO parallelize closure computation by distributing work among processors for performing resolution steps among different subsets of clauses in parallel. Model-elimination and model-generation theorem provers exploit parallelism in searching independent parts of the or-search tree and for generating different models, respectively.
Reference: 2. <author> Bonacina, M. P., and McCune, W., </author> <title> "Distributed theorem proving by Peers," </title> <booktitle> Proc. 12th Intl. Conf. on Automated Deduction (CADE-12), </booktitle> <publisher> LNAI 814 (ed. Bundy), </publisher> <address> Nancy, France, </address> <year> 1994, </year> <pages> 841-845. </pages>
Reference-contexts: For example, a rewrite-based prover can exploit parallel algorithms for matching, normalization, and completion, for instance, by generating critical pairs among rewrite rules in parallel, or by running completion using different strategies as in DISCOUNT [1]. Resolutions-based provers such as Peers <ref> [2] </ref> and ROO parallelize closure computation by distributing work among processors for performing resolution steps among different subsets of clauses in parallel. Model-elimination and model-generation theorem provers exploit parallelism in searching independent parts of the or-search tree and for generating different models, respectively.
Reference: 3. <editor> Fronhoefer, B., and Wrightson, G. (eds). </editor> <title> Parallelization in Inference Systems. </title> <booktitle> Proc. of Intl. Workshop, </booktitle> <address> Germany, Dec. 1990, </address> <publisher> Springer LNAI 590, </publisher> <year> 1992. </year>
Reference-contexts: Model-elimination and model-generation theorem provers exploit parallelism in searching independent parts of the or-search tree and for generating different models, respectively. Each of these provers aims to improve performance while presenting a familiar, sequential interface to the user. 3 3 In <ref> [3] </ref>, a survey of parallel theorem provers as of 1992 is included. The proceedings 2 Adding Parallelism to LP LP was developed at MIT by Steve Garland and John Guttag to reason about designs for circuits, concurrent algorithms, hardware, and software [4].
Reference: 4. <author> Garland, S., and Guttag, J., </author> <title> "An overview of LP," </title> <booktitle> Proc. 3rd Conf. on Rewriting Techniques and Applications, </booktitle> <publisher> LNCS 355 (ed. Dershowitz), </publisher> <year> 1989, </year> <pages> 137-151. </pages>
Reference-contexts: 1 Introduction The Distributed Larch Prover, DLP, is an experiment in parallelizing LP, the Larch Prover. LP is an interactive, rewrite-rule based reasoning system for proving formulas in first-order, multi-sorted logic by first-order reasoning and induction <ref> [4] </ref>. DLP runs on a network of workstations. DLP uses a novel approach for exploiting parallelism. The user of DLP is encouraged to launch many parallel attempts to prove conjectures. <p> The proceedings 2 Adding Parallelism to LP LP was developed at MIT by Steve Garland and John Guttag to reason about designs for circuits, concurrent algorithms, hardware, and software <ref> [4] </ref>. LP is an interactive prover whose design is based on the assumption that most attempts to prove interesting conjectures fail initially because of errors or omissions in the formalization. Consequently, LP does not support agressive heuristics for automatically finding proofs.
Reference: 5. <author> Kapur, D. and Vandevoorde, </author> <title> M.T., "DLP: A paradigm for parallel interactive theorem proving," </title> <note> submitted to CADE. </note>
Reference-contexts: The basic idea is to find a proof more quickly by exploiting coarse-grain parallelism and by trying more inference methods in parallel <ref> [5] </ref>. In contrast, the conventional approach for adding parallelism to a prover is to exploit parallelism in the implementation while leaving the user interface unchanged. <p> Another Emacs window displays the full input and output associated with each goal and proof attempt. DLP has many facilities for navigating through the and/or tree, for selectively hiding portions of the and/or-tree, broadcasting and multicasting commands to a selected subset of leaf nodes, etc. <ref> [8, 5] </ref>. 2.3 Implementation DLP runs on a network of uniprocessor workstations. It is implemented as n worker UNIX processes|one per workstation|plus a coordinator process and an Emacs process. The coordinator is a scheduler that tells the workers what tasks they should execute. <p> Below we provide some highlights of our experience in using DLP; more details about proofs of these problems are given in <ref> [5] </ref>. Using DLP, we found a simpler and shorter proof of one of the main conjectures in verifying the correctness of a pipeline processor in [7]. <p> We have identified useful proof strategies that can be invoked at the top level of DLP to automatically solve many problems; see <ref> [5] </ref> for details.
Reference: 6. <author> McCarthy, J., </author> <title> "The mutilated checkerboard in set theory," in The QED II Workshop report (ed. </title> <institution> R. Matuszewski), L/1/95, Warsaw University, </institution> <month> Oct. </month> <year> 1995, </year> <note> http: //www.mcs.anl.gov/qed/index.html. </note>
Reference-contexts: [8]. 3 Experiments with DLP DLP has been successfully tried on a variety of problems, including examples from Larch and LP libraries of specifications and proofs as well as problems never tried before on LP including subproblems arising from experiments with Robbins' algebra conjecture [9], McCarthy's mutilated checker board problem <ref> [6] </ref>, first-order problems including SAM's Lemma, Bledsoe's Intermediate Value Theorem and a problem involving equalities in clauses suggested by Ganzinger. Below we provide some highlights of our experience in using DLP; more details about proofs of these problems are given in [5].
Reference: 7. <author> Saxe, J., Guttag, J., Horning, J., and Garland, S., </author> <title> "Using transformations and verification in circuit design," Formal Methods in System Design, </title> <booktitle> 1993, </booktitle> <pages> 181-209. </pages>
Reference-contexts: Below we provide some highlights of our experience in using DLP; more details about proofs of these problems are given in [5]. Using DLP, we found a simpler and shorter proof of one of the main conjectures in verifying the correctness of a pipeline processor in <ref> [7] </ref>. This came as a pleasant surprise to one of the coauthors of [7] since they had spent considerable effort in manually trying to find short proofs. LP is not designed to automatically prove first-order formulas, as it does not support any complete inference strategy for first-order theorem proving. <p> Using DLP, we found a simpler and shorter proof of one of the main conjectures in verifying the correctness of a pipeline processor in <ref> [7] </ref>. This came as a pleasant surprise to one of the coauthors of [7] since they had spent considerable effort in manually trying to find short proofs. LP is not designed to automatically prove first-order formulas, as it does not support any complete inference strategy for first-order theorem proving.
Reference: 8. <author> Vandevoorde, M.T., and Kapur, D., </author> <title> Parallel user interfaces for parallel applications, </title> <type> Unpublished Manuscript, </type> <institution> Lab. for Computer Science, MIT, </institution> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: Another Emacs window displays the full input and output associated with each goal and proof attempt. DLP has many facilities for navigating through the and/or tree, for selectively hiding portions of the and/or-tree, broadcasting and multicasting commands to a selected subset of leaf nodes, etc. <ref> [8, 5] </ref>. 2.3 Implementation DLP runs on a network of uniprocessor workstations. It is implemented as n worker UNIX processes|one per workstation|plus a coordinator process and an Emacs process. The coordinator is a scheduler that tells the workers what tasks they should execute. <p> The coordinator is a scheduler that tells the workers what tasks they should execute. The coordinator also performs load balancing by telling a worker to migrate a task to another worker. All communication between processes follows the message-passing paradigm rather than the shared-memory paradigm. More details are given in <ref> [8] </ref>. 3 Experiments with DLP DLP has been successfully tried on a variety of problems, including examples from Larch and LP libraries of specifications and proofs as well as problems never tried before on LP including subproblems arising from experiments with Robbins' algebra conjecture [9], McCarthy's mutilated checker board problem [6],
Reference: 9. <author> Winker, S., </author> <title> "Robbins algebra: conditions that make a near-boolean algebra boolean," </title> <journal> J. of Automated Reasoning, </journal> <volume> 6, 4, </volume> <year> 1990, </year> <month> 465-489. </month> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: More details are given in [8]. 3 Experiments with DLP DLP has been successfully tried on a variety of problems, including examples from Larch and LP libraries of specifications and proofs as well as problems never tried before on LP including subproblems arising from experiments with Robbins' algebra conjecture <ref> [9] </ref>, McCarthy's mutilated checker board problem [6], first-order problems including SAM's Lemma, Bledsoe's Intermediate Value Theorem and a problem involving equalities in clauses suggested by Ganzinger. Below we provide some highlights of our experience in using DLP; more details about proofs of these problems are given in [5].
References-found: 9

