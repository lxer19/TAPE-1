URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-209.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: borgida@cs.rutgers.edu  
Title: The frame problem in object-oriented specifications: an exhibition of problems and approaches assumption that things
Author: Alex Borgida 
Note: Of particular interest may be the introduction of a model-theoretic version of the  This research was supported in part by grants from the National Science and Engineering Research Council of Canada, the Institute for Robotic and Intelligent Systems (IRIS) (funded by the Government of Canada through the Networks of Excellence programme), and the NSF of USA under grant IRI91-19310.  
Date: October 2, 1992  
Address: New Brunswick, NJ 08903  
Affiliation: Dept. of Computer Science Rutgers University  
Pubnum: Technical Report LCSR-TR-209  
Abstract: We present first a series of examples involving the development of information systems, which suggest a number of desirable features for object-oriented specification techniques, especialy those supporting inheritance. Most of these features have difficulties with the so-called frame axioms | assertions which state what values have been left unchanged by some procedure. We then examine the benefits and disadvantages of a variety of proposals for dealing with the frame problem, some of which are based on ideas presented earlier in the literature, while others are novel. The approaches are grouped into two families: one which introduces notational conventions/abbreviation for stating frame axioms, and one which embeds them into the language semantics. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abrial, J. R., P. Gardiner, C. Morgan, and M. Spivey, </author> <title> "Abstract Machines", </title> <address> Part1 - Part4, 26 Rue des Plantes, Paris 75014 June 1988. </address> <month> 16 </month>
Reference-contexts: Unfortunately, this approach still does not deal with examples such as those of classes D and E in Figure 1. 3.5 Predicate transformers We note here that specification techniques based on predicate transformers (e.g., <ref> [11, 1] </ref>) appear to sidestep the frame problem by bottoming out in some kind of assignment/substitution statement of the form [ v := E], where E can involve non-deterministic choice. <p> This approach was taken in the FIDE project [25], where specifications in TDL were replaced by an "equivalent" abstract machine specification <ref> [1] </ref>. One major hurdle faced by this technique is deciding over what set of variable names should the substitution take place.
Reference: [2] <author> Alencar, A. and J. Goguen, </author> <title> "OOZE: An object-oriented Z environment", </title> <booktitle> Proc. </booktitle> <address> ECOOP'91 </address>
Reference-contexts: 1 Introduction There is considerable interest in object-oriented approaches both in the general programming community, and in the area of formal program specification, as evidenced by the profusion of papers on this topic at recent conferences, including the following papers in the Z paradigm <ref> [26, 12, 15, 2, 16] </ref>. In this paper, we shall concentrate on the specification of a particular family of software systems, namely Information Systems. 1 Information systems maintain models of some aspect of the "real world" by storing information about individuals, their inter-relationships, and the activities that change these relationships.
Reference: [3] <author> Borgida, A. </author> <title> "On the definition of specialization hierarchies for procedures", </title> <booktitle> Proceedings of the 7th Int. Joint Conf. on Artificial Intelligence, </booktitle> <address> Vancouver, B.C., </address> <month> August </month> <year> 1981, </year> <month> pp.254-256. </month>
Reference-contexts: variants rather than complete redevelopment. * Polymorphism: procedures developed for objects of one type, can be applied to all objects whose type is a subtype of the original one. * Verification: in some situations, it is possible to re-use proofs of correctness so that they are inherited to subclases (see <ref> [3] </ref>). It is widely agreed that during specialization new attributes may be added to a class, as well as new methods modifying them. There are however a number of extensions of this idea which are potentially very valuable: 6 1.
Reference: [4] <author> Borgida, A., J.Mylopoulos, and H.K.T.Wong, </author> <title> "Generalization/Specialization as a basis for software specification", in On Conceptual Modeling, </title> <editor> M.Brodie et al. (eds.), </editor> <publisher> Springer Verlag, </publisher> <year> 1984, </year> <pages> pp. 87-114. </pages>
Reference-contexts: Furthermore, the invariant stating that (P atients P ersons) is automatically added to the specification. The subclass hierarchy and inheritance are useful for a number of reasons (see for example <ref> [4, 6] </ref>), including: * Abbreviation: the specification of the entire system is made shorter (hence more easily readable) by factoring out commonalities. * Propagation of changes: when a super class is changed (e.g., by the addition of a new attribute or by changing the post-condition of a method), all its subclasses
Reference: [5] <author> A.Borgida, </author> <title> "Features of Languages for the Development of Information Systems at the Conceptual Level", </title> <journal> IEEE Software, </journal> <volume> 2(1), </volume> <month> January </month> <year> 1985, </year> <month> pp.63-73. </month>
Reference-contexts: The history of object orientation in Information System development is quite long, be ginning with the so-called conceptual/semantic modeling languages such as Taxis [21], which were often based on knowledge representation ideas. (See <ref> [5] </ref> for a review and comparison of such languages.) More recently, several object-oriented databases, supporting persistence for object-oriented languages, have been introduced, O 2 [22] and Gemstone [9] being just two exemplars.
Reference: [6] <author> A. Borgida, </author> <title> "Modeling Class Hierarchies with Contradictions", </title> <booktitle> Proc. ACM SIGMOD '88 Conference, </booktitle> <address> Chicago, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: Furthermore, the invariant stating that (P atients P ersons) is automatically added to the specification. The subclass hierarchy and inheritance are useful for a number of reasons (see for example <ref> [4, 6] </ref>), including: * Abbreviation: the specification of the entire system is made shorter (hence more easily readable) by factoring out commonalities. * Propagation of changes: when a super class is changed (e.g., by the addition of a new attribute or by changing the post-condition of a method), all its subclasses
Reference: [7] <author> A. Borgida, J. Mylopoulos, J. Schmidt and I. Wetzel, </author> <title> "Support for Data-Intensive Applications: Conceptual Design and Software Development", Database Programming Languages, </title> <editor> (R.Hull, R. Morrison, D.Stemple eds.), </editor> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo CA., </address> <year> 1990. </year>
Reference-contexts: This paper is particularly concerned with speci fication languages that describe procedures in the familiar pre- and post-condition notation, relating the values of "variables" in the starting and terminating states of the procedure. In trying to define one such language, TDL <ref> [7] </ref>, we encountered serious difficulties because the obvious way of describing "more specialized procedures" | a key notion of object-oriented approaches with inheritance | lead to inconsistencies. <p> As noted in [8], the above effort to state that things have not changed unless otherwise provable, is one of the topics studied by non-monotonic logic (see, for example, the collection of papers in [13]). In the specification language TDL <ref> [7] </ref>, we used default logic [24] to express that things tend to remain as they are.
Reference: [8] <author> Borgida, A., J. Mylopoulos, and R. Reiter, </author> ""... <title> and nothing else changes": the frame problem in procedure specifications", </title> <institution> Department of Computer Science, University of Toronto, </institution> <note> submitted for publication, 1992. (An expanded version appears as Rutgers Tech Report </note> # ). 
Reference-contexts: We identified the need to state explicitly that variables do not change | something which is not done in programming languages | as the source of our difficulties, and then discovered that these problems in fact arise in some form or another in all kinds of specifications, as explained in <ref> [8] </ref>. Surprisingly, with rare exceptions (e.g. [26, 23]), the work in the Formal Methods community has not addressed directly these issues. This paper is therefore intended to first of all present some examples of situations where the need to express explicitly the so-called "frame axioms" leads to difficulties. <p> As noted in <ref> [8] </ref>, the above effort to state that things have not changed unless otherwise provable, is one of the topics studied by non-monotonic logic (see, for example, the collection of papers in [13]). <p> To deal with this second problem, and in order to achieve considerable simplification in general formal specifications (not just object-oriented ones | see <ref> [8] </ref>), we examined a second approach: namely, building into the language semantics that things remain unchanged as much as possible. This approach was pioneered in formal methods by Schuman and Pitt, but is widely known in the area of non-monotonic reasoning in Artificial Intelligence. <p> With k procedures, each of which has its own frame axioms, we would then need kn axioms | a very large number, especially if we plan to use some standard theorem prover. In <ref> [8] </ref>, we introduce a simple technique which relies on reifying procedures in order to reduce the total size of the axioms to O (k + n). Finally, we remark that a third class of approaches to the frame problem could be based on the idea, mentioned in [23] and [8], that <p> In <ref> [8] </ref>, we introduce a simple technique which relies on reifying procedures in order to reduce the total size of the axioms to O (k + n). Finally, we remark that a third class of approaches to the frame problem could be based on the idea, mentioned in [23] and [8], that computer tools could be used to generate candidate frame axioms, which may then be edited by the specifier. Acknowledgements I am indebted to my collaborators, Raymond Reiter and John Mylopoulos, without whom I would not be working on the problems discussed in this paper.
Reference: [9] <author> Bretl, R., D. Maier, A. Otis, J. Penney, B. Schuchardt, J. Stein, E. Harold WIlliams, M. Wiliams, </author> <title> "The GemStone Data Management System", Object Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. Lochovsky editors, </editor> <publisher> ACM Press, </publisher> <address> New Yor, </address> <year> 1989. </year>
Reference-contexts: quite long, be ginning with the so-called conceptual/semantic modeling languages such as Taxis [21], which were often based on knowledge representation ideas. (See [5] for a review and comparison of such languages.) More recently, several object-oriented databases, supporting persistence for object-oriented languages, have been introduced, O 2 [22] and Gemstone <ref> [9] </ref> being just two exemplars. However, there has been relatively little work in Information Systems on specification languages for describing what is to be implemented, rather than programming languages describing how things are to be implemented.
Reference: [10] <author> Cusack, E., </author> <title> "Inheritance in object-oriented Z", </title> <booktitle> Proc. </booktitle> <address> ECOOP'91, </address> <publisher> Springer Verlag LNCS #512, pp.167-179 </publisher>
Reference-contexts: section, this technique no longer works. 6 This approach was suggested to me in personal communication by James Power, Dublin City University. 10 3.4 Context-dependent abbreviation If we take the attitude that a procedure can only see the locally declared attributes and those of its superclasses | as in ObjectZ <ref> [12, 10] </ref> and Z++ [16], then (p) can be expanded context-dependently, depending on the visibility of the variables. For example, in class B, (p) asserts (q 0 = q), while in methods of class D it says (q 0 = q ^ r 0 = r).
Reference: [11] <author> Dijkstra, </author> <title> E.W., A discipline of programming, </title> <publisher> Prentice Hall, </publisher> <year> 1976. </year>
Reference-contexts: Unfortunately, this approach still does not deal with examples such as those of classes D and E in Figure 1. 3.5 Predicate transformers We note here that specification techniques based on predicate transformers (e.g., <ref> [11, 1] </ref>) appear to sidestep the frame problem by bottoming out in some kind of assignment/substitution statement of the form [ v := E], where E can involve non-deterministic choice.
Reference: [12] <author> Duke, D. and R. Duke, </author> <title> "Towards a Semantics for Object Z", VDM and Z | Formal Methods in Software Development, </title> <publisher> LNCS Vol. </publisher> <address> 428, pp.244-261, </address> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction There is considerable interest in object-oriented approaches both in the general programming community, and in the area of formal program specification, as evidenced by the profusion of papers on this topic at recent conferences, including the following papers in the Z paradigm <ref> [26, 12, 15, 2, 16] </ref>. In this paper, we shall concentrate on the specification of a particular family of software systems, namely Information Systems. 1 Information systems maintain models of some aspect of the "real world" by storing information about individuals, their inter-relationships, and the activities that change these relationships. <p> Following ObjectZ <ref> [12] </ref> (with its (p) notation indicating that everything but p remains unchanged), and Larch [14] (with its modifies at most assertion), we use the notation (x,y) to indicate that "everything but maybe x and y remain unchanged". <p> section, this technique no longer works. 6 This approach was suggested to me in personal communication by James Power, Dublin City University. 10 3.4 Context-dependent abbreviation If we take the attitude that a procedure can only see the locally declared attributes and those of its superclasses | as in ObjectZ <ref> [12, 10] </ref> and Z++ [16], then (p) can be expanded context-dependently, depending on the visibility of the variables. For example, in class B, (p) asserts (q 0 = q), while in methods of class D it says (q 0 = q ^ r 0 = r). <p> languages support "principled" specialization, where (in contrast to languages such as Smalltalk, where inheritance is just a syntactic code sharing technique), a specialized method cannot just blindly over-ride what it inherits. 15 Some of these features do not however appear in formal specification techniques that follow the object-oriented paradigm (e.g., <ref> [26, 12, 16, 17] </ref>). For example, they do not allow the effects of a procedure to include modifications of variables in other objects, reachable from this one.
Reference: [13] <editor> Readings in Nonmonotonic Reasoning, M. Ginsberg (ed.), </editor> <publisher> Morgan Kaufman, </publisher> <address> Palo Alto, </address> <year> 1990. </year>
Reference-contexts: As noted in [8], the above effort to state that things have not changed unless otherwise provable, is one of the topics studied by non-monotonic logic (see, for example, the collection of papers in <ref> [13] </ref>). In the specification language TDL [7], we used default logic [24] to express that things tend to remain as they are.
Reference: [14] <author> Guttag, J., J.J. Horning, and J.W. Wing, </author> <title> "Larch in five easy pieces", </title> <type> TR 5, </type> <institution> DEC Systems Research Center, </institution> <year> 1985. </year>
Reference-contexts: Following ObjectZ [12] (with its (p) notation indicating that everything but p remains unchanged), and Larch <ref> [14] </ref> (with its modifies at most assertion), we use the notation (x,y) to indicate that "everything but maybe x and y remain unchanged".
Reference: [15] <author> Hall, A. </author> <title> "Using Z as a specification calculus for object-oriented systems", VDM and Z | Formal Methods in Software Development, </title> <publisher> LNCS Vol. </publisher> <address> 428, pp.290-317, </address> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction There is considerable interest in object-oriented approaches both in the general programming community, and in the area of formal program specification, as evidenced by the profusion of papers on this topic at recent conferences, including the following papers in the Z paradigm <ref> [26, 12, 15, 2, 16] </ref>. In this paper, we shall concentrate on the specification of a particular family of software systems, namely Information Systems. 1 Information systems maintain models of some aspect of the "real world" by storing information about individuals, their inter-relationships, and the activities that change these relationships.
Reference: [16] <author> Lano, K., and H. Haughton, </author> <title> "Reasoning and refinement in object-oriented specification languages", </title> <booktitle> Proc. </booktitle> <address> ECOOP'92, </address> <publisher> Springer Verlag LNCS #615, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction There is considerable interest in object-oriented approaches both in the general programming community, and in the area of formal program specification, as evidenced by the profusion of papers on this topic at recent conferences, including the following papers in the Z paradigm <ref> [26, 12, 15, 2, 16] </ref>. In this paper, we shall concentrate on the specification of a particular family of software systems, namely Information Systems. 1 Information systems maintain models of some aspect of the "real world" by storing information about individuals, their inter-relationships, and the activities that change these relationships. <p> longer works. 6 This approach was suggested to me in personal communication by James Power, Dublin City University. 10 3.4 Context-dependent abbreviation If we take the attitude that a procedure can only see the locally declared attributes and those of its superclasses | as in ObjectZ [12, 10] and Z++ <ref> [16] </ref>, then (p) can be expanded context-dependently, depending on the visibility of the variables. For example, in class B, (p) asserts (q 0 = q), while in methods of class D it says (q 0 = q ^ r 0 = r). <p> languages support "principled" specialization, where (in contrast to languages such as Smalltalk, where inheritance is just a syntactic code sharing technique), a specialized method cannot just blindly over-ride what it inherits. 15 Some of these features do not however appear in formal specification techniques that follow the object-oriented paradigm (e.g., <ref> [26, 12, 16, 17] </ref>). For example, they do not allow the effects of a procedure to include modifications of variables in other objects, reachable from this one.
Reference: [17] <author> Marshall, L., and L. Simon, </author> <title> "Using VDM within an object-oriented framework", VDM'91: Formal Software Development Methods, </title> <publisher> Springer Verlag LNCS # 551, </publisher> <year> 1991. </year>
Reference-contexts: languages support "principled" specialization, where (in contrast to languages such as Smalltalk, where inheritance is just a syntactic code sharing technique), a specialized method cannot just blindly over-ride what it inherits. 15 Some of these features do not however appear in formal specification techniques that follow the object-oriented paradigm (e.g., <ref> [26, 12, 16, 17] </ref>). For example, they do not allow the effects of a procedure to include modifications of variables in other objects, reachable from this one.
Reference: [18] <author> McCarthy, J., and P. Hayes, </author> <title> "Some philosophical problems from the standpoint of aritificial intelligence", </title> <booktitle> Machine Intelligence 4, </booktitle> <editor> pp.4463-502 (eds Melzter, B. and Michie, D.). Edin-burgh: </editor> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year> <month> 17 </month>
Reference-contexts: Since this predicate transformer leaves unchanged every part of an assertion other than the variable v, it seems to solve the frame problem. (Interestingly, the original paper on the frame problem by McCarty and Hayes <ref> [18] </ref> listed the assignment statement as one possible avenue to be explored.) One approach to solving the frame problem is then to try to convert the specification of the goal (without frame assertions) into a predicate transformer/generalized substitution.
Reference: [19] <author> McCarthy, J., </author> <title> "Circumscription | a form of non-monotonic reasoning", </title> <booktitle> Artificial Intelligence 13, </booktitle> <address> pp.27-39, </address> <year> 1980. </year>
Reference-contexts: For this, we can turn to the technique of circumscription <ref> [19] </ref>, which has been used to model non-monotonicity. Circumscription essentially selects only those models of a theory which minimize the extents of some predicate (s). <p> This set of models can in fact be characterized using a second-order axiom schema (see <ref> [19] </ref>), which we shall not present here, and which would constitute the frame assertion.
Reference: [20] <author> Meyer, B. </author> <title> Object Oriented Software Construction, </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: In languages such as Eiffel <ref> [20] </ref> and Taxis [21] specialization of a method is restricted to strengthening the post-condition 5 . For example, HEART-PATIENT$admit does additional things to those performed by PATIENT$admit, such as notifying the cardiology resident on call.
Reference: [21] <author> Mylopoulos, J., P. Bernstein, and H. Wong, </author> <title> "A language facility for designing data-intensive applications", </title> <journal> ACM TODS 5(2), </journal> <month> June </month> <year> 1980. </year>
Reference-contexts: The history of object orientation in Information System development is quite long, be ginning with the so-called conceptual/semantic modeling languages such as Taxis <ref> [21] </ref>, which were often based on knowledge representation ideas. (See [5] for a review and comparison of such languages.) More recently, several object-oriented databases, supporting persistence for object-oriented languages, have been introduced, O 2 [22] and Gemstone [9] being just two exemplars. <p> In languages such as Eiffel [20] and Taxis <ref> [21] </ref> specialization of a method is restricted to strengthening the post-condition 5 . For example, HEART-PATIENT$admit does additional things to those performed by PATIENT$admit, such as notifying the cardiology resident on call.
Reference: [22] <author> O.Deux et al., </author> <title> "The storyof O2", </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1), </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: System development is quite long, be ginning with the so-called conceptual/semantic modeling languages such as Taxis [21], which were often based on knowledge representation ideas. (See [5] for a review and comparison of such languages.) More recently, several object-oriented databases, supporting persistence for object-oriented languages, have been introduced, O 2 <ref> [22] </ref> and Gemstone [9] being just two exemplars. However, there has been relatively little work in Information Systems on specification languages for describing what is to be implemented, rather than programming languages describing how things are to be implemented.
Reference: [23] <author> Penny, D., R.C.Holt, M.Godfrey, </author> <title> "Formal specification in metamorphic programming", VDM'91: Formal Software Development Methods, </title> <publisher> Springer Verlag LNCS # 551, </publisher> <year> 1991. </year>
Reference-contexts: Surprisingly, with rare exceptions (e.g. <ref> [26, 23] </ref>), the work in the Formal Methods community has not addressed directly these issues. This paper is therefore intended to first of all present some examples of situations where the need to express explicitly the so-called "frame axioms" leads to difficulties. <p> In [8], we introduce a simple technique which relies on reifying procedures in order to reduce the total size of the axioms to O (k + n). Finally, we remark that a third class of approaches to the frame problem could be based on the idea, mentioned in <ref> [23] </ref> and [8], that computer tools could be used to generate candidate frame axioms, which may then be edited by the specifier. Acknowledgements I am indebted to my collaborators, Raymond Reiter and John Mylopoulos, without whom I would not be working on the problems discussed in this paper.
Reference: [24] <author> Reiter, R. </author> <title> "A Logic for Default Reasoning", </title> <journal> Artificial Intelligence, </journal> <volume> 13(1) </volume> <pages> 81-132, </pages> <year> 1980. </year>
Reference-contexts: As noted in [8], the above effort to state that things have not changed unless otherwise provable, is one of the topics studied by non-monotonic logic (see, for example, the collection of papers in [13]). In the specification language TDL [7], we used default logic <ref> [24] </ref> to express that things tend to remain as they are. This is done by asserting that for every value c and set-variable p, if c is (is not) in p, and it is consistent to assume that c is (is not) in p', then do so.
Reference: [25] <author> Schewe, K-D., Schmidt, J., Wetzel, I., </author> <title> "Specification and refinement in an integrated database application environment", VDM'91: Formal Software Development Methods, </title> <publisher> Springer Verlag LNCS # 551, </publisher> <year> 1991. </year>
Reference-contexts: This approach was taken in the FIDE project <ref> [25] </ref>, where specifications in TDL were replaced by an "equivalent" abstract machine specification [1]. One major hurdle faced by this technique is deciding over what set of variable names should the substitution take place.
Reference: [26] <author> Schuman, S.A. and D.H.Pitt, </author> <title> "Object-oriented subsystem specification", Program Specification and Transformation, </title> <editor> L.G.L.T.Meertens (ed), </editor> <publisher> North Holland, </publisher> <year> 1987, </year> <month> pp.313-341. </month>
Reference-contexts: 1 Introduction There is considerable interest in object-oriented approaches both in the general programming community, and in the area of formal program specification, as evidenced by the profusion of papers on this topic at recent conferences, including the following papers in the Z paradigm <ref> [26, 12, 15, 2, 16] </ref>. In this paper, we shall concentrate on the specification of a particular family of software systems, namely Information Systems. 1 Information systems maintain models of some aspect of the "real world" by storing information about individuals, their inter-relationships, and the activities that change these relationships. <p> Surprisingly, with rare exceptions (e.g. <ref> [26, 23] </ref>), the work in the Formal Methods community has not addressed directly these issues. This paper is therefore intended to first of all present some examples of situations where the need to express explicitly the so-called "frame axioms" leads to difficulties. <p> As 11 argued in <ref> [26] </ref>, the problem can be attributed to an over-specification: all we intend to say in B$m is that 1 is added to the set in attribute p, and then E asserts that 4 is also added. The key idea introduced in [26] is that goals such as (p 0 = p <p> As 11 argued in <ref> [26] </ref>, the problem can be attributed to an over-specification: all we intend to say in B$m is that 1 is added to the set in attribute p, and then E asserts that 4 is also added. The key idea introduced in [26] is that goals such as (p 0 = p [ f1g) and (p 0 = p [ f4g) in fact act in part as frame axioms for set-valued variables, and should instead be rephrased as (1 2 p 0 ) and (4 2 p 0 ) respectively; their conjunction then <p> According to Schuman and Pitt <ref> [26] </ref>, the appropriate weakenings come from the set of formulas N eutral (V; P OST ) = fffj ( V ff consistent with P OST g where V is the set of all variables in the program state. <p> Following the spirit of <ref> [26] </ref>, we must therefore look at the maximal sets of neutral formulas consistent with the post-condition, and to be cautious, we should take as frame axioms only those assertions that are in the intersection of all of them, i.e., can be consistently believed in every possible terminating state of the procedure. <p> languages support "principled" specialization, where (in contrast to languages such as Smalltalk, where inheritance is just a syntactic code sharing technique), a specialized method cannot just blindly over-ride what it inherits. 15 Some of these features do not however appear in formal specification techniques that follow the object-oriented paradigm (e.g., <ref> [26, 12, 16, 17] </ref>). For example, they do not allow the effects of a procedure to include modifications of variables in other objects, reachable from this one.
Reference: [27] <author> Sethi, R. </author> <title> Programming languages: concepts and constructs, </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The subclass may also specialize previously introduced methods. One of the two distinguishing features of object-oriented programming languages (as noted in <ref> [27] </ref>) is in fact the ability to dynamically select the appropriate version of the procedure to be executed, depending on the class membership of the individual object: p.restrictDiet will execute different procedures depending on the class to which p belongs. 5.
Reference: [28] <author> Spivey, J.M., </author> <title> The Z notation: a reference manual, </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference: [29] <author> Zave, P. and M. Jackson, </author> <note> "Conjunction as composition", manuscript submitted for publication, </note> <institution> AT&T Bell Laboratories, </institution> <year> 1992. </year> <month> 18 </month>
Reference-contexts: Therefore the execution of a method on some object may, through side effects, change the state of arbitrary other objects. Note also that this is 3 A similar interpretation of Z-like schemas into first order logic is suggested in <ref> [29] </ref>. 5 not just some example of "bad style" but the essence of the paradigm of "message passing between independent agents", which is touted as one of the important advantages of object orientation. 2.3 Subclasses and inheritance Another property of object-oriented specifications is that they support factoring out commonalities between many
References-found: 29

