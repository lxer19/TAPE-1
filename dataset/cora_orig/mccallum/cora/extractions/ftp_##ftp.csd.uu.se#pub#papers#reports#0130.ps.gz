URL: ftp://ftp.csd.uu.se/pub/papers/reports/0130.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: kung-kiu@cs.man.ac.uk ornaghi@hermes.mc.dsi.unimi.it  
Title: The Relationship between Logic Programs and Specifications The Subset Example Revisited  
Author: Kung-Kiu Lau Mario Ornaghi 
Address: Manchester M13 9PL Via Comelico 39/41, Milano United Kingdom Italy  
Affiliation: Dept of Computer Science DSI University of Manchester Universita' degli studi di Milano  
Date: September, 1996 ISSN 1100-0686  
Note: 19  
Abstract: UPMAIL Technical Report No. 130 Abstract The fundamental relation between a program P and its specification S is correctness: P satisfies S if and only if P is correct with respect to S. In logic programming, this relationship can be particularly close, since logic can be used to express both specifications and programs. Indeed logic programs are often regarded and used as (executable) specifications themselves. In this paper, we argue that the relation between S and P should be firmly set in the context of the underlying problem domain, which we call a framework F, and we give a model-theoretic view of the correctness relation between specifications and programs in F. We show that the correctness relation between S and P is always well-defined. It thus provides a basis for properly distinguishing between S and P . We use the subset example throughout, to illustrate our model-theoretic approach. fl A revised version of this paper will appear in the Journal of Logic Programming. y Part of this work was done while the first author was Visiting Professor in the Computing Science Dept at Uppsala University, supported by the European Union HCM project on Logic Program Synthesis and Transformation, contract no. 93/414. He wishes to thank Jonas Barklund for his invitation and hospitality. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bertoni, G. Mauri and P. Miglioli. </author> <title> On the power of model theory in specifying abstract data types and in capturing their recursiveness. </title> <note> Fundamenta Informaticae VI(2):127-170, </note> <year> 1983. </year>
Reference-contexts: In particular, the elements of a set can be listed in any order and may contain duplicates. It is easy to see that the meaning of P1 coincides completely with that of S1. For example, for the query Q1: ? subset ([A; B]; <ref> [1; 2; 3] </ref>): (Q1) P1 produces the following nine expected answers: A=1,B=1; A=1,B=2; A=1,B=3; A=3,B=1; A=3,B=2; A=3,B=3. representing the 1-element subsets f1g, f2g, f3g, and the 2-element subsets f1,2g, f1,3g, f2,3g. <p> However, whenever the pre-condition in S2 is not satisfied, P2 does not coincide with S2. Indeed P2 will happily accept Large with duplicates and produce Small with duplicates. For example, for the query Q2: ? subset ([A; B]; <ref> [1; 2; 1] </ref>): (Q2) P2 produces the following six answers: A=1,B=2 (two times); A=1,B=1 (two times); A=2,B=1 (two times). Thus we can distinguish between S2 and P2: the latter is only a correct implementation of the former. It is worth noting that we do not care about repetitions in answers. <p> P3 assumes this precondition, but nevertheless it is a correct implementation of S3. The query Q1 now has just three answers: A=1,B=2; A=1,B=3; A=2,B=3. However, if Large is not sorted, then neither will Small be. For example, the query Q3: ? subset ([A; B]; <ref> [3; 2; 1] </ref>): (Q3) will give the answers: A=3,B=2; A=3,B=1; A=2,B=1. So we can distinguish between S3 and P3 because the latter in only correct with respect to the former. <p> For non-reachable models initiality and isoini tiality are independent properties (see <ref> [1] </ref>). 7 axioms: 8x (:0 = s (x)) ^ 8x; y (s (x) = s (y) ! x = y); 8x (x + 0 = x); 8x (x fl 0 = 0); 8 (H (0) ^ 8i (H (i) ! H (s (i))) ! 8x H (x)); and is constructed thus:
Reference: [2] <author> A. Bossi, M. Gabbrielli, G. Levi and M.C. Meo. </author> <title> A compositional semantics for logic programs. </title> <booktitle> Theoretical Computer Science 122 </booktitle> <pages> 3-47, </pages> <year> 1994. </year>
Reference-contexts: In particular, the elements of a set can be listed in any order and may contain duplicates. It is easy to see that the meaning of P1 coincides completely with that of S1. For example, for the query Q1: ? subset ([A; B]; <ref> [1; 2; 3] </ref>): (Q1) P1 produces the following nine expected answers: A=1,B=1; A=1,B=2; A=1,B=3; A=3,B=1; A=3,B=2; A=3,B=3. representing the 1-element subsets f1g, f2g, f3g, and the 2-element subsets f1,2g, f1,3g, f2,3g. <p> However, whenever the pre-condition in S2 is not satisfied, P2 does not coincide with S2. Indeed P2 will happily accept Large with duplicates and produce Small with duplicates. For example, for the query Q2: ? subset ([A; B]; <ref> [1; 2; 1] </ref>): (Q2) P2 produces the following six answers: A=1,B=2 (two times); A=1,B=1 (two times); A=2,B=1 (two times). Thus we can distinguish between S2 and P2: the latter is only a correct implementation of the former. It is worth noting that we do not care about repetitions in answers. <p> P3 assumes this precondition, but nevertheless it is a correct implementation of S3. The query Q1 now has just three answers: A=1,B=2; A=1,B=3; A=2,B=3. However, if Large is not sorted, then neither will Small be. For example, the query Q3: ? subset ([A; B]; <ref> [3; 2; 1] </ref>): (Q3) will give the answers: A=3,B=2; A=3,B=1; A=2,B=1. So we can distinguish between S3 and P3 because the latter in only correct with respect to the former. <p> In our example, Ocomp (car prices), the open 25 In a framework, we may even have open function symbols, but they are not of interest here. 26 Other modifications of minimum model semantics for open programs have also been proposed, see e.g. <ref> [3, 2] </ref>. 16 completion of car prices is: free (spider ; elan ; 0; 1; 2; : : :) = f:spider = elan; :0 = 1; :0 = 2; : : :g diag () = f0 0; 0 1; 1 1; :1 0; :2 0; :2 1; : : :g car <p> This kind of correctness, which we call steadfastness ([12]), that is preserved through inheritance hierarchies seems to be a promising tool for formal object-oriented software engineering. Our semantics for open programs, their correctness, and the correctness of their composition is also different from other model-theoretic approaches such as <ref> [3, 2] </ref>. Again, the main difference lies in our use of a framework that allows us to reason about the correctness of program composition. This enables us to define steadfastness, which is the basis of formal correctness of object-oriented programs.
Reference: [3] <author> A. Brogi, E. Lamma and P. Mello. </author> <title> Composing open logic programs. </title> <editor> J. </editor> <booktitle> Logic and Computation 3(4) </booktitle> <pages> 417-439, </pages> <year> 1993. </year>
Reference-contexts: In particular, the elements of a set can be listed in any order and may contain duplicates. It is easy to see that the meaning of P1 coincides completely with that of S1. For example, for the query Q1: ? subset ([A; B]; <ref> [1; 2; 3] </ref>): (Q1) P1 produces the following nine expected answers: A=1,B=1; A=1,B=2; A=1,B=3; A=3,B=1; A=3,B=2; A=3,B=3. representing the 1-element subsets f1g, f2g, f3g, and the 2-element subsets f1,2g, f1,3g, f2,3g. <p> P3 assumes this precondition, but nevertheless it is a correct implementation of S3. The query Q1 now has just three answers: A=1,B=2; A=1,B=3; A=2,B=3. However, if Large is not sorted, then neither will Small be. For example, the query Q3: ? subset ([A; B]; <ref> [3; 2; 1] </ref>): (Q3) will give the answers: A=3,B=2; A=3,B=1; A=2,B=1. So we can distinguish between S3 and P3 because the latter in only correct with respect to the former. <p> In our example, Ocomp (car prices), the open 25 In a framework, we may even have open function symbols, but they are not of interest here. 26 Other modifications of minimum model semantics for open programs have also been proposed, see e.g. <ref> [3, 2] </ref>. 16 completion of car prices is: free (spider ; elan ; 0; 1; 2; : : :) = f:spider = elan; :0 = 1; :0 = 2; : : :g diag () = f0 0; 0 1; 1 1; :1 0; :2 0; :2 1; : : :g car <p> This kind of correctness, which we call steadfastness ([12]), that is preserved through inheritance hierarchies seems to be a promising tool for formal object-oriented software engineering. Our semantics for open programs, their correctness, and the correctness of their composition is also different from other model-theoretic approaches such as <ref> [3, 2] </ref>. Again, the main difference lies in our use of a framework that allows us to reason about the correctness of program composition. This enables us to define steadfastness, which is the basis of formal correctness of object-oriented programs.
Reference: [4] <author> J.H. Gallier. </author> <title> Logic for Computer Science: Foundations for Automatic Theorem Proving. </title> <publisher> Harper and Row, </publisher> <year> 1986. </year>
Reference-contexts: The latter is not quite satisfactory, since the meaning of correctness must be defined in terms of something other than logic programs themselves (see e.g. <ref> [4, p. 410] </ref>). We have shown that in a framework, we can define correctness in a semantic way, either informally or formally. Informal correctness allows us to distinguish programs (as executable specifications) from their (informal) intended meanings.
Reference: [5] <author> P.M. Hill and J.W. Lloyd. </author> <title> The Godel Programming Language. </title> <publisher> MIT Press, </publisher> <year> 1994. </year> <month> 20 </month>
Reference-contexts: Axioms for the old sorts are imported, and new ones are added to define new functions and relations on T . The syntax of a framework F is similar to that used in algebraic abstract data types (e.g. [16]), or in typed logic programming languages such as Godel <ref> [5] </ref>. However, whilst an algebraic abstract data type is an initial model (defined below) of its specification, the intended model of F , i.e. the abstract data type it axiomatises, is an isoinitial model.
Reference: [6] <author> W. Hodges. </author> <title> Logical features of Horn clauses. In D.M. </title> <editor> Gabbay, C.J. Hog--ger, and J.A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <volume> Vol 1, </volume> <pages> pages 449-503, </pages> <publisher> Oxford University Press, </publisher> <year> 1993. </year>
Reference: [7] <author> R.A. Kowalski. </author> <title> The relation between logic programming and logic specification. In C.A.R. Hoare and J.C. </title> <editor> Shepherdson, editors, </editor> <booktitle> Mathematical Logic and Programming Languages, </booktitle> <pages> pages 11-27, </pages> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: The precise nature of this relation depends on the chosen specification language L S (and the notion of correctness that has been adopted). For instance, if L S is also a logic language, then this relation could be very close (see e.g. <ref> [7] </ref>). Indeed logic programs are often regarded and used as (executable) specifications themselves. After all, a logic program is a Horn clause theory ([6]), and as such it can double as a definition.
Reference: [8] <author> K.K. Lau and M. Ornaghi. </author> <title> On specification frameworks and deductive synthesis of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. LOPSTR 94 and META 94 , Lecture Notes in Computer Science 883, </booktitle> <pages> pages 104-121, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: It should be obvious, in this simple example, that in every Herbrand instance free (K) [ SET (Elem), the corresponding (Herbrand) instance of 28 A formal treatment of adequacy can be found in <ref> [8] </ref>. 18 P1' is semantically correct with respect to (2). Thus we say that P1' is semantically correct in the open framework SET (Elem). Similarly, the open program P2' is also semantically correct (with respect to (2)) in SET (Elem).
Reference: [9] <author> K.K. Lau, M. Ornaghi and S. A. </author> <title> Tarnlund. The halting problem for deductive synthesis of logic programs. </title> <editor> In P. van Hentenryck, editor, </editor> <booktitle> Proc. 11 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 665-683, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: In this section, we shall consider the model-theoretic correctness relation between S and P , following our approach to deductive synthesis of (both standard and constraint) logic programs (see e.g. <ref> [9, 11] </ref>), and illustrate it for the subset example. We shall define F to be a full first-order logical theory, S a first-order formula in F that defines a relation r, 6 and P a Horn theory whose language contains the relation r.
Reference: [10] <author> K.K. Lau and M. Ornaghi. </author> <title> Towards an object-oriented methodology for deductive synthesis of logic programs. </title> <editor> In M. Proietti, editor, </editor> <booktitle> Proc. </booktitle> <volume> LOPSTR 95 , LNCS 1048 </volume> <pages> 152-169, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: In general we can use our approach to specify what are called generic classes in object-oriented programming, and define correctness of open methods with respect to to their specifications when they are inherited (see <ref> [10] </ref>). This kind of correctness, which we call steadfastness ([12]), that is preserved through inheritance hierarchies seems to be a promising tool for formal object-oriented software engineering.
Reference: [11] <author> K.K. Lau and M. Ornaghi. </author> <title> A formal approach to deductive synthesis of constraint logic programs. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proc. 1995 Int. Logic Programming Symp., </booktitle> <pages> pages 543-557, </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: In this section, we shall consider the model-theoretic correctness relation between S and P , following our approach to deductive synthesis of (both standard and constraint) logic programs (see e.g. <ref> [9, 11] </ref>), and illustrate it for the subset example. We shall define F to be a full first-order logical theory, S a first-order formula in F that defines a relation r, 6 and P a Horn theory whose language contains the relation r.
Reference: [12] <author> K.K. Lau, M. Ornaghi and S.-. A. </author> <title> Tarnlund. Steadfast logic programs. </title> <note> Submitted to J. Logic Programming. </note>
Reference-contexts: and (b) will mean the semantic correctness of the implementation of P with respect to the chosen conditional specification. 21 Indeed, in this case, the clauses of P are theorems of SET [ f8 (sublist (X; Y ) $ big (X; Y ))g. 22 A proof can be found in <ref> [12] </ref>. 13 As an example, consider the specification (3) where both the input and output conditions IC and OC are the relation nocc 1 : 23 nocc 1 (L) $ 8a nocc (a; L) 1 and consider the program P2': sublist (nil ; Y ) sublist (x:X; Y ) select (x;
Reference: [13] <author> P. Miglioli, U. Moscato and M. Ornaghi. </author> <title> Abstract parametric classes and abstract data types defined by classical and constructive logical methods. </title> <journal> J. Symb. Comp. </journal> <volume> 18 </volume> <pages> 41-81, </pages> <year> 1994. </year>
Reference: [14] <author> R.A. O'Keefe. </author> <title> What does subset mean? ALP Newsletter 8(3):10, </title> <month> August </month> <year> 1995. </year>
Reference-contexts: Clearly, this exercise is predicated on a potential difference between S and P . In this section, we illustrate the distinction between S and P in an informal framework, by considering several Prolog programs for subset together 1 with their intended meanings. These programs are given by O'Keefe in <ref> [14] </ref> to compute subset (Small, Large) correctly according to different informal specifications, in order to find Small for a given Large, where Small and Large are lists representing sets in various ways. <p> It is worth noting that we do not care about repetitions in answers. Essentially we compare S and P under minimum model semantics, i.e. we 3 compare the relations (sets of tuples) described by S with the minimum model of P . 3 The third Prolog program in <ref> [14] </ref> assumes that Large (possibly with duplicates) is sorted, and whenever this holds, the program yields a sorted Small: append ([], L, L). append ([H|T], L, [H|R]) :- append (T, L, R). subset ([], _). subset ([X|Xs], Set) :- append (_, [X|Set1], Set), subset (Xs, Set1). (P3) Its informal specification S3 <p> We have inferred it from <ref> [14] </ref>. 4 The informal specification S4 of P4 is: 5 "subset (Small, Large) is to be true if: Large is a list containing the elements of a set, possibly containing duplicates; Small is a sorted list containing the elements of a set, there being no duplicates; the set Small represents is <p> For example, we define a framework SET (Int ) for sets as lists of integers as follows: 5 Again, this is not stated explicitly in <ref> [14] </ref>. 6 Both S and r may be sets. 7 Dotted arrows denote semantic mappings, and the full double-headed arrow represents an isomorphism. 8 Function symbols include constant symbols. 5 Framework SET (Int ); import: LIST (Int ); sorts: Int ; List ; Set ; functions: f g : List !
Reference: [15] <author> J.C. Shepherdson. </author> <title> Negation in logic programming. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 19-88. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Indeed, we only ever construct such frameworks. To construct such a framework F n for axiomatising a type T , we proceed incrementally. We start with a small framework F 0 with an obvious isoinitial model I 0 . For instance, if the freeness axioms (see <ref> [15] </ref>) hold in T , then F 0 consists of just the constructor symbols in F n together with their freeness axioms. The term model generated by the constructors is of course just the set of ground terms of T . <p> For example, the following framework NAT axiomatises the abstract data type of Peano arithmetic: Framework NAT ; sorts: Nat ; functions: 0 : ! Nat ; s : Nat ! Nat ; 9 Thus an isoinitial model is a generic model (see <ref> [15] </ref>). 10 This holds only for reachable models.
Reference: [16] <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year> <month> 21 </month>
Reference-contexts: T is constructed from constructors (e.g. f g), declared as functions. Axioms for the old sorts are imported, and new ones are added to define new functions and relations on T . The syntax of a framework F is similar to that used in algebraic abstract data types (e.g. <ref> [16] </ref>), or in typed logic programming languages such as Godel [5]. However, whilst an algebraic abstract data type is an initial model (defined below) of its specification, the intended model of F , i.e. the abstract data type it axiomatises, is an isoinitial model.
References-found: 16

