URL: http://www.cs.man.ac.uk/~kung-kiu/pub/jlp97.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Title: THE RELATIONSHIP BETWEEN LOGIC PROGRAMS AND SPECIFICATIONS THE SUBSET EXAMPLE REVISITED  
Author: KUNG-KIU LAU AND MARIO ORNAGHI 
Date: 1994:19, 20:1-679 1  
Note: J. LOGIC PROGRAMMING  
Abstract: The fundamental relation between a program P and its specification S is correctness: P satisfies S if and only if P is correct with respect to S. In logic programming, this relationship can be particularly close, since logic can be used to express both specifications and programs. Indeed logic programs are often regarded and used as (executable) specifications themselves. In this paper, we argue that the relation between S and P should be firmly set in the context of the underlying problem domain, which we call a framework F, and we give a model-theoretic view of the correctness relation between specifications and programs in F. We show that the correctness relation between S and P is always well-defined. It thus provides a basis for properly distinguishing between S and P . We use the subset example throughout, to illustrate our model-theoretic approach. / 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Bertoni, G. Mauri and P. Miglioli. </author> <title> On the power of model theory in specifying abstract data types and in capturing their recursiveness. </title> <note> Fundamenta Informaticae VI(2):127-170, </note> <year> 1983. </year>
Reference-contexts: It is easy to see that these two meanings of subset coincide completely, i.e. P1 is correct with respect to S1. For example, for the query Q1: ? subset ([A; B]; <ref> [1; 2; 3] </ref>): (Q1) P1 produces the following nine expected answers (i.e. values of A, B such that subset ([A,B], [1,2,3]) is true according to S1): A=1,B=1; A=1,B=2; A=1,B=3; A=3,B=1; A=3,B=2; A=3,B=3. <p> We start with a small framework F 0 with an obvious isoinitial model I 0 . 6 Thus an isoinitial model is a generic model (see [16]). 7 This holds only for reachable models. For non-reachable models initiality and isoinitiality are independent properties (see <ref> [1] </ref>). 7 For instance, if the freeness axioms (see [16]) hold in T , then F 0 consists of just the constructor symbols in F n together with their freeness axioms. The term model generated by the constructors is of course just the set of ground terms of T .
Reference: 2. <author> A. Bossi, M. Gabbrielli, G. Levi and M.C. Meo. </author> <title> A compositional semantics for logic programs. </title> <booktitle> Theoretical Computer Science 122 </booktitle> <pages> 3-47, </pages> <year> 1994. </year>
Reference-contexts: It is easy to see that these two meanings of subset coincide completely, i.e. P1 is correct with respect to S1. For example, for the query Q1: ? subset ([A; B]; <ref> [1; 2; 3] </ref>): (Q1) P1 produces the following nine expected answers (i.e. values of A, B such that subset ([A,B], [1,2,3]) is true according to S1): A=1,B=1; A=1,B=2; A=1,B=3; A=3,B=1; A=3,B=2; A=3,B=3. <p> Specifications and programs in an open framework F may be open, i.e. they may contain the parameters of F . When two frameworks are composed, their 14 programs will be composed too. Open programs and program composition have been introduced in logic programming, e.g. in <ref> [3, 2] </ref>. Again, here the main difference in our approach is the use of frameworks and specifications. <p> This 18 Isoinitial semantics gives a more abstract characterisation of open programs than other modifications of minimum model semantics, e.g. <ref> [3, 2] </ref>. 15 diagram contains both positive and negative information. * The completed definitions of the predicates defined by the program, e.g. car and cheaper . The key difference between Ocomp and the standard completion Comp is that Ocomp does not contain any axioms for the open symbols, e.g. price. <p> This kind of correctness, which we call steadfastness ([13]), that is preserved through inheritance hierarchies seems to be a promising tool for formal object-oriented software engineering. Our semantics for open programs, their correctness, and the correctness of their composition is also different from other model-theoretic approaches such as <ref> [3, 2] </ref>. Again, the main difference lies in our use of a framework that allows us to reason about the correctness of program composition. This enables us to define steadfastness, which is the basis of formal correctness of object-oriented programs.
Reference: 3. <author> A. Brogi, E. Lamma and P. Mello. </author> <title> Composing open logic programs. </title> <editor> J. </editor> <booktitle> Logic and Computation 3(4) </booktitle> <pages> 417-439, </pages> <year> 1993. </year>
Reference-contexts: It is easy to see that these two meanings of subset coincide completely, i.e. P1 is correct with respect to S1. For example, for the query Q1: ? subset ([A; B]; <ref> [1; 2; 3] </ref>): (Q1) P1 produces the following nine expected answers (i.e. values of A, B such that subset ([A,B], [1,2,3]) is true according to S1): A=1,B=1; A=1,B=2; A=1,B=3; A=3,B=1; A=3,B=2; A=3,B=3. <p> Specifications and programs in an open framework F may be open, i.e. they may contain the parameters of F . When two frameworks are composed, their 14 programs will be composed too. Open programs and program composition have been introduced in logic programming, e.g. in <ref> [3, 2] </ref>. Again, here the main difference in our approach is the use of frameworks and specifications. <p> This 18 Isoinitial semantics gives a more abstract characterisation of open programs than other modifications of minimum model semantics, e.g. <ref> [3, 2] </ref>. 15 diagram contains both positive and negative information. * The completed definitions of the predicates defined by the program, e.g. car and cheaper . The key difference between Ocomp and the standard completion Comp is that Ocomp does not contain any axioms for the open symbols, e.g. price. <p> This kind of correctness, which we call steadfastness ([13]), that is preserved through inheritance hierarchies seems to be a promising tool for formal object-oriented software engineering. Our semantics for open programs, their correctness, and the correctness of their composition is also different from other model-theoretic approaches such as <ref> [3, 2] </ref>. Again, the main difference lies in our use of a framework that allows us to reason about the correctness of program composition. This enables us to define steadfastness, which is the basis of formal correctness of object-oriented programs.
Reference: 4. <author> Y. Deville and K.K. Lau. </author> <title> Logic program synthesis. </title> <journal> J. Logic Programming 19,20:321-350, </journal> <note> 1994. Special issue: Ten years of logic programming. </note>
Reference-contexts: In general, model-theoretic correctness is based on the comparison between specifications and the intended models of programs (see e.g. <ref> [4] </ref> for a brief survey). The distinguishing feature of our approach is that specifications, programs and correctness are defined within a framework F (the use of frameworks is discussed in [9, 11]).
Reference: 5. <author> J.H. Gallier. </author> <title> Logic for Computer Science: Foundations for Automatic Theorem Proving. </title> <publisher> Harper and Row, </publisher> <year> 1986. </year> <month> 18 </month>
Reference-contexts: The latter is not quite satisfactory, since the meaning of correctness must be defined in terms of something other than logic programs themselves (see e.g. <ref> [5, p. 410] </ref>). We have shown that in a framework, we can define correctness in a semantic way, either informally or formally. Informal correctness allows us to relate programs to their informal specifications. Formal correctness involves full first-order logical theories, and is defined in terms of model theory.
Reference: 6. <author> P.M. Hill and J.W. Lloyd. </author> <title> The Godel Programming Language. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Axioms for the old sorts are imported, and new ones are added to define new functions and relations on T . The syntax of a framework F is similar to that used in algebraic abstract data types (e.g. [17]), or in typed logic programming languages such as Godel <ref> [6] </ref>. However, whilst an algebraic abstract data type is an initial model (defined below) of its specification, the intended model of F, i.e. the abstract data type it axiomatises, is an isoinitial model.
Reference: 7. <author> W. Hodges. </author> <title> Logical features of Horn clauses. In D.M. </title> <editor> Gabbay, C.J. Hogger, and J.A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <volume> Vol 1, </volume> <pages> pages 449-503, </pages> <publisher> Oxford University Press, </publisher> <year> 1993. </year>
Reference: 8. <author> R.A. Kowalski. </author> <title> The relation between logic programming and logic specification. In C.A.R. Hoare and J.C. </title> <editor> Shepherdson, editors, </editor> <booktitle> Mathematical Logic and Programming Languages, </booktitle> <pages> pages 11-27, </pages> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: The precise nature of this relationship depends on the chosen specification language L S (and the notion of correctness that has been adopted). For instance, if L S is also a logic language, then this relation could be very close (see e.g. <ref> [8] </ref>). Indeed logic programs are often regarded and used as (executable) specifications themselves. After all, a logic program is a Horn clause theory ([7]), and as such it can double as a definition.
Reference: 9. <author> K.K. Lau and M. Ornaghi. </author> <title> On specification frameworks and deductive synthesis of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. LOPSTR 94 and META 94 , Lecture Notes in Computer Science 883, </booktitle> <pages> pages 104-121, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In general, model-theoretic correctness is based on the comparison between specifications and the intended models of programs (see e.g. [4] for a brief survey). The distinguishing feature of our approach is that specifications, programs and correctness are defined within a framework F (the use of frameworks is discussed in <ref> [9, 11] </ref>). We shall define F to be a full first-order logical theory, S a first-order formula in F that defines a relation r, 3 and P a Horn theory whose language contains the relation r. <p> We will call C [ SET (Elem ) an instance of SET (Elem). If all the instances of an open framework are closed frameworks, then we say that the open framework is adequate (see <ref> [9] </ref>). 19 For example, we can show that SET (Elem) is adequate. Without adequacy, framework composition and program correctness would be ill-defined and quite useless, and so we shall always use adequate open frameworks.
Reference: 10. <author> K.K. Lau, M. Ornaghi and S.- A. </author> <title> Tarnlund. The halting problem for deductive synthesis of logic programs. </title> <editor> In P. van Hentenryck, editor, </editor> <booktitle> Proc. 11 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 665-683, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: In this section, we shall consider the model-theoretic 5 correctness relation between S and P , within a formal framework F, following our approach to deductive synthesis of (both standard and constraint) logic programs (see e.g. <ref> [10, 12] </ref>). In general, model-theoretic correctness is based on the comparison between specifications and the intended models of programs (see e.g. [4] for a brief survey).
Reference: 11. <author> K.K. Lau and M. Ornaghi. </author> <title> Towards an object-oriented methodology for deductive synthesis of logic programs. </title> <editor> In M. Proietti, editor, </editor> <booktitle> Proc. </booktitle> <volume> LOPSTR 95 , LNCS 1048 </volume> <pages> 152-169, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: In general, model-theoretic correctness is based on the comparison between specifications and the intended models of programs (see e.g. [4] for a brief survey). The distinguishing feature of our approach is that specifications, programs and correctness are defined within a framework F (the use of frameworks is discussed in <ref> [9, 11] </ref>). We shall define F to be a full first-order logical theory, S a first-order formula in F that defines a relation r, 3 and P a Horn theory whose language contains the relation r. <p> This enables us to define an important notion of correctness: when two frameworks are composed, together with their correct programs, correctness is automatically preserved, i.e. the resulting programs are guaranteed to be correct in the composite framework. This kind of correctness is applicable to object-oriented programs <ref> [11] </ref>. In this section, we will briefly explain model-theoretic correctness in open frameworks, as an extension of correctness in closed frameworks, and we will show that it is better to use isoinitial semantics for both frameworks and programs. An open program or an open framework has a class of models. <p> In general we can use our approach to specify what are called generic classes in object-oriented programming, and define correctness of open methods with respect to to their specifications when they are inherited (see <ref> [11] </ref>). This kind of correctness, which we call steadfastness ([13]), that is preserved through inheritance hierarchies seems to be a promising tool for formal object-oriented software engineering.
Reference: 12. <author> K.K. Lau and M. Ornaghi. </author> <title> A formal approach to deductive synthesis of constraint logic programs. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proc. 1995 Int. Logic Programming Symp., </booktitle> <pages> pages 543-557, </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: In this section, we shall consider the model-theoretic 5 correctness relation between S and P , within a formal framework F, following our approach to deductive synthesis of (both standard and constraint) logic programs (see e.g. <ref> [10, 12] </ref>). In general, model-theoretic correctness is based on the comparison between specifications and the intended models of programs (see e.g. [4] for a brief survey).
Reference: 13. <author> K.K. Lau, M. Ornaghi and S.-. A. </author> <title> Tarnlund. Steadfast logic programs. </title> <note> Submitted to J. Logic Programming. </note>
Reference-contexts: to (b), i.e. we assume select (X; Y ) $ small (X; Y ), and try to prove the 15 Indeed, in this case, the clauses of P are theorems of SET [ f8 (sublist (X; Y ) $ big (X; Y ))g. 16 A proof can be found in <ref> [13] </ref>. 17 nocc 1 (L) means L does not contain duplicates. 13 only-if part of the completion of P2', namely: sublist (A; Y ) ! A = nil _ 9x; X; H: (A = x:X ^ select (x; Y; H)^ sublist (X; H)) Since 8A: List (A = nil _ 9x;
Reference: 14. <author> P. Miglioli, U. Moscato and M. Ornaghi. </author> <title> Abstract parametric classes and abstract data types defined by classical and constructive logical methods. </title> <journal> J. Symb. Comp. </journal> <volume> 18 </volume> <pages> 41-81, </pages> <year> 1994. </year>
Reference: 15. <author> R.A. O'Keefe. </author> <title> What does subset mean? ALP Newsletter 8(3):10, </title> <month> August </month> <year> 1995. </year>
Reference-contexts: In this section, we illustrate the correctness relationship between S and P in an informal framework, by considering several Prolog programs for subset together with their informal specifications. These programs (and their specifications) are given by O'Keefe in <ref> [15] </ref> to compute subset (Small, Large) correctly according to different informal specifications, in order to find Small for a given Large, where Small and Large are lists representing sets in various ways. <p> For example, for the query Q1, P2 gives the six expected answers: A=1,B=2; A=1,B=3; A=3,B=1; A=3,B=2. However, whenever the pre-condition in S2 is not satisfied, P2 does not satisfy S2. Indeed P2 happily accepts Large containing duplicates and produces Small containing duplicates. 4 The third Prolog program in <ref> [15] </ref> assumes that Large is sorted, and whenever this holds, the program yields a sorted Small: append ([], L, L). append ([H|T], L, [H|R]) :- append (T, L, R). subset ([], _). subset ([X|Xs], Set) :- append (_, [X|Set1], Set), subset (Xs, Set1). (P3) It is easy to see that P3
Reference: 16. <author> J.C. Shepherdson. </author> <title> Negation in logic programming. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 19-88. </pages> <publisher> Morgan Kauf-mann, </publisher> <year> 1988. </year>
Reference-contexts: Indeed, we only ever construct such frameworks. To construct such a framework F n for axiomatising a type T , we proceed incrementally. We start with a small framework F 0 with an obvious isoinitial model I 0 . 6 Thus an isoinitial model is a generic model (see <ref> [16] </ref>). 7 This holds only for reachable models. For non-reachable models initiality and isoinitiality are independent properties (see [1]). 7 For instance, if the freeness axioms (see [16]) hold in T , then F 0 consists of just the constructor symbols in F n together with their freeness axioms. <p> a small framework F 0 with an obvious isoinitial model I 0 . 6 Thus an isoinitial model is a generic model (see <ref> [16] </ref>). 7 This holds only for reachable models. For non-reachable models initiality and isoinitiality are independent properties (see [1]). 7 For instance, if the freeness axioms (see [16]) hold in T , then F 0 consists of just the constructor symbols in F n together with their freeness axioms. The term model generated by the constructors is of course just the set of ground terms of T .
Reference: 17. <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: T is constructed from constructors (e.g. f g), declared as functions. Axioms for the old sorts are imported, and new ones are added to define new functions and relations on T . The syntax of a framework F is similar to that used in algebraic abstract data types (e.g. <ref> [17] </ref>), or in typed logic programming languages such as Godel [6]. However, whilst an algebraic abstract data type is an initial model (defined below) of its specification, the intended model of F, i.e. the abstract data type it axiomatises, is an isoinitial model.
References-found: 17

