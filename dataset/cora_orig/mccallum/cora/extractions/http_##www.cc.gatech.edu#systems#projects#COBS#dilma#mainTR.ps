URL: http://www.cc.gatech.edu/systems/projects/COBS/dilma/mainTR.ps
Refering-URL: http://www.cs.gatech.edu/people/home/dilma/
Root-URL: 
Email: dilma@ime.usp.br schwan@cc.gatech.edu  
Title: CTK: Configurable Object Abstractions for Multiprocessors  
Author: Dilma M. Silva Karsten Schwan 
Keyword: Index Terms: configurable systems, high performance objects, object fragmentation, dynamic adapta tion, complex parallel programming, library operating systems  
Note: This research was supported in part by CNPq-Brazil (under contract 200199/90-0) and DARPA (under contract DABT63-95-C-0125)  
Web: GIT-CC-97-03  
Address: S~ao Paulo, Brazil Atlanta, GA 30332  
Affiliation: Computer Science Department College of Computing University of S~ao Paulo Georgia Institute of Technology  
Abstract: The Configuration Toolkit (CTK) is a library for constructing configurable object-based abstractions that are part of multiprocessor programs or operating systems. The library is unique in its exploration of runtime configuration for attaining performance improvements: (1) its programming model facilitates the expression and implementation of program configuration, and (2) its efficient runtime support enables performance improvements by configuration of program components during their execution. Program configuration is attained without compromising the encapsulation or the reuse of software abstractions, by explicitly separating the type-dependent object functionality from its properties subject to configuration, including its performance, reliability, and timing properties. CTK programs are configured using attributes associated with object classes, object instances, state variables, operations, and object invocations. At runtime, such attributes are interpreted by policy classes, which may be varied separately from the abstractions with which they are associated. Using policies and attributes, an object's runtime behavior may be varied by (1) changing its performance or reliability while preserving the implementation of its functional behavior or (2) changing the implementation of its internal computational strategy. This paper demonstrates the benefits attained from using policies and attributes, which jointly implement `configuration abstractions' that have been separated from objects' basic functionalities. Such abstractions provide a convenient means for configuring objects during execution or for experimenting with alternative object implementations. Specifically, using policies and attributes, objects may be specialized using diverse techniques, including parameterization and interposition. Multiple specializations may be applied simultaneously by association of multiple policies with objects, resulting in dynamically configurable systems where attributes resemble `knobs' being manipulated at runtime and policies implement the changes resulting from such manipulations. CTK's multiprocessor implementation is layered on a Cthreads-compatible programming library, which results in its portability to a wide variety of uni- and multi-processor machines, including a Kendall Square KSR-2 Supercomputer, SGI machines, various SUN workstations, and as a native kernel on the GP1000 BBN Butterfly multiprocessor. The platforms evaluated in this paper are the KSR and SGI machines. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Agnew, C. Hofmeister, and J. Purtilo. </author> <title> Planning for change: A reconfiguration language for distributed systems. </title> <booktitle> In Proc. of the Second International Workshop in Configurable Distributed Systems, </booktitle> <pages> pages 15-22. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: [53], the redirection of selected system calls using interposition in [37] and using subcontracts in Spring [31], the dynamic adjustment of meta-objects in [55], the dynamic adaptation of object and invocation implementations [50], the runtime adjustment of individual object parameters [56] or of structural properties of sets of communicating objects <ref> [1] </ref>. Compiler-based techniques for runtime configuration have included the dynamic synthesis of program code [46] and the re-direction of procedure calls [40]. Our research builds on and partly extends past work in configurable systems.
Reference: [2] <author> M. Ahamad and K. Schwan. </author> <title> The COBS Project. </title> <note> http://www.cc.gatech.edu/systems/projects/COBS. 28 </note>
Reference-contexts: For larger-scale parallel application programs, we expect to achieve cumulative performance gains approaching or exceeding 100%. Similarly, in our current work with the runtime configuration of objects on distributed platforms <ref> [2, 67] </ref>, we expect to realize substantial performance gains by configuring applications simultaneously at several levels of abstraction in the distributed program and in the underlying operating systems and networks [26]: (1) in the application itself, (2) in the object transport substrate, and (3) at the protocol level.
Reference: [3] <author> T. Bihari and K. Schwan. </author> <title> Dynamic adaptation of real-time software. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 143-174, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: It also distinguishes this research from our own past work <ref> [3, 28] </ref>, in which we investigate how the needs of real-time applications affect the object model and its required runtime support [25].
Reference: [4] <author> K. P. Birman and et.al. </author> <title> Implementing fault-tolerant distributed objects. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 502-508, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: not related to object functionality (e.g., timing behavior) or for the dynamic adjustment of object characteristics determining such behavior (e.g., for performance). 4 2.2 Real-time and Object-based Systems CTK's emphasis on the attainment of improved performance in parallel systems distinguishes our work from other efforts addressing distributed or real-time systems <ref> [44, 64, 4, 39, 45, 68, 47] </ref>, where the primary concern has been to maintain certain levels of system responsiveness or reliability in the presence of uncertain execution environments.
Reference: [5] <author> R. Campbell, V. Russo, and G. Johnson. </author> <title> Choices (class hierarchical open interface for custom embedded systems). </title> <journal> ACM Operating Systems Review, </journal> <volume> 21(3) </volume> <pages> 9-17, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Such joint configuration is explored in several recent object-based efforts [38], including the Choices <ref> [5] </ref>, Spring [31], Chaos [61], Apertos [71], and ACE [55] operating systems. It is also being explored in efforts that address object fragmentation, including our own past research on hypercubes [59, 10], Shapiro's work on fragmented network objects [66], and recent work on object fragmentation by Tanenbaum [33]. <p> Program or operating system configuration may be performed with diverse methods and at different times, including at compile-, link-, boot-time <ref> [21, 8, 19, 5] </ref>.
Reference: [6] <editor> Proc. </editor> <booktitle> of the 3rd International Conference on Configurable Distributed Systems. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: It also distinguishes this research from our own past work [3, 28], in which we investigate how the needs of real-time applications affect the object model and its required runtime support [25]. Similarly, recent work on the dynamic configuration of distributed and object-based systems <ref> [6] </ref> often concerns specific configuration methods or general (rather than high performance) frameworks for implementing dynamically configurable applications, whereas CTK is exploring flexible mechanisms with which efficient, configurable program and operating system abstractions may be implemented.
Reference: [7] <author> K. M. Chandy and C. Kesselman. </author> <title> CC++: A declarative concurrent object oriented programming notation. In Research Directions in Object Oriented Programming. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: An `ADT' (abstract data type) defines an object that has no execution threads of its own and doesn't synchronize among concurrent 1 The built-in object classes in CTK are quite similar to concurrent object constructs offered in recent designs and implementations of object-oriented concurrent languages <ref> [7] </ref>. 6 invocations. Invoking an ADT causes the execution of its method in the address space of the invoker. In comparison, invoking a `TADT' (threaded abstract data type) creates a new execution thread for execution of the called operation, but also does not synchronize concurrent calls.
Reference: [8] <author> J. B. Chen and B. N. Bershad. </author> <title> The impact of operating system structure on memory system performance. </title> <booktitle> In Proc. of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 120-133. </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1993. </year>
Reference-contexts: the early work on policy-mechanism separation in Hydra [41, 12], the removal of operating system services from `fixed' kernels to the configurable user level in the Mach [53] and NT [13] operating systems, and ultimately leading to the notion of micro-kernels and user-level libraries for implementing customized operating system abstractions <ref> [8, 19] </ref>. In effect, such research has established the fact that application programs may be `combined' with operating system functions such that both may be configured jointly, using the same programming techniques and software infrastructures sometimes called `operating software'[57]. <p> Program or operating system configuration may be performed with diverse methods and at different times, including at compile-, link-, boot-time <ref> [21, 8, 19, 5] </ref>.
Reference: [9] <author> C. Clemencon, B. Mukherjee, and K. Schwan. </author> <title> Distributed shared abstractions (dsa) on large-scale multiprocessors. </title> <type> Technical report, </type> <institution> College of Computing, Georgia Institute of Technology, GIT-CC-93-25, </institution> <month> May </month> <year> 1993. </year> <title> Also in in `Symposium on Experiences with Distributed and Multiprocessor Systems (SEDMS-4)', </title> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: Extensive experimental results with alternative implementations of the Traveling Salesperson Problem (TSP) on distributed memory (an Intel iPSC machine [58]) and on shared memory machines (the BBN Butterfly and Kendall Square NUMA multiprocessors <ref> [9, 10] </ref>) have demonstrated that the dynamic configuration of selected attributes of the distributed queue is essential for good runtime performance. <p> Specifically, adequate performance on large-scale parallel machines can be attained (1) if the queue is implemented as multiple cooperating fragments distributed across the different nodes of the multiprocessor <ref> [62, 9, 10] </ref>, (2) if some desirable global ordering on queue elements is maintained across all fragments, and (3) if the access policies to queue fragments and the interconnections among queue fragments can be customized to specific application runs. <p> The collection of fragments mimics the behavior of a central queue. The queue policy achieves this by either using a single fragment or by coordinating fragments during `remove' invocations. Our implementation uses multiple fragments (see <ref> [9] </ref> for implementations with a single fragment), which facilitates the transition from this ordering protocol to the others described above. 2. Topology the topology of the communication structure among queue fragments (e.g., a ring, a tree, complete graph, etc). 3. Invocation mode maybe synchronous or asynchronous.
Reference: [10] <author> C. Clemencon, B. Mukherjee, and K. Schwan. </author> <title> Distributed shared abstractions (DSA) on multiprocessors. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(2) </volume> <pages> 132-152, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: Similarly, research in high performance programming and in operating systems has derived gains in performance and reliability from the dynamic configuration of multiprocessor synchronization constructs [18, 49], of network communications [34], of file systems [52], and of distributed object abstractions <ref> [10] </ref>. In all of these cases, basic component functionality is separated from the implementation attributes affecting performance. <p> Such joint configuration is explored in several recent object-based efforts [38], including the Choices [5], Spring [31], Chaos [61], Apertos [71], and ACE [55] operating systems. It is also being explored in efforts that address object fragmentation, including our own past research on hypercubes <ref> [59, 10] </ref>, Shapiro's work on fragmented network objects [66], and recent work on object fragmentation by Tanenbaum [33]. Program or operating system configuration may be performed with diverse methods and at different times, including at compile-, link-, boot-time [21, 8, 19, 5]. <p> Extensive experimental results with alternative implementations of the Traveling Salesperson Problem (TSP) on distributed memory (an Intel iPSC machine [58]) and on shared memory machines (the BBN Butterfly and Kendall Square NUMA multiprocessors <ref> [9, 10] </ref>) have demonstrated that the dynamic configuration of selected attributes of the distributed queue is essential for good runtime performance. <p> Specifically, adequate performance on large-scale parallel machines can be attained (1) if the queue is implemented as multiple cooperating fragments distributed across the different nodes of the multiprocessor <ref> [62, 9, 10] </ref>, (2) if some desirable global ordering on queue elements is maintained across all fragments, and (3) if the access policies to queue fragments and the interconnections among queue fragments can be customized to specific application runs.
Reference: [11] <author> E. C. Cooper and R. P. Draves. </author> <title> C threads. </title> <type> Technical report, </type> <institution> Computer Science, Carnegie-Mellon University, CMU-CS-88-154, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Our earlier contribution to this goal was the construction of a parallel programming library that offers the well-known Cthreads programming interface <ref> [11] </ref> along with built-in self-configuring Cthreads abstractions (e.g., a configurable lock abstraction described in [49]) and with support functions for the efficient collection and, ultimately, display [29] of threads' runtime state.
Reference: [12] <author> G. Cox, W. M. Corwin, K. K. Lai, and F. J. Pollack. </author> <title> A unified model and implementation for in-terprocess communication in a multiprocessor environment. </title> <booktitle> In Proc. of the 8th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 44-53, </pages> <month> Dec. </month> <year> 1981. </year>
Reference-contexts: A variety of research results has enabled the runtime configuration of operating systems in order to improve the performance of specific user programs, including the early work on policy-mechanism separation in Hydra <ref> [41, 12] </ref>, the removal of operating system services from `fixed' kernels to the configurable user level in the Mach [53] and NT [13] operating systems, and ultimately leading to the notion of micro-kernels and user-level libraries for implementing customized operating system abstractions [8, 19].
Reference: [13] <author> H. Custer. </author> <title> Inside Windows NT. </title> <publisher> Microsoft Press, </publisher> <address> Redmond, Washington, </address> <year> 1993. </year>
Reference-contexts: results has enabled the runtime configuration of operating systems in order to improve the performance of specific user programs, including the early work on policy-mechanism separation in Hydra [41, 12], the removal of operating system services from `fixed' kernels to the configurable user level in the Mach [53] and NT <ref> [13] </ref> operating systems, and ultimately leading to the notion of micro-kernels and user-level libraries for implementing customized operating system abstractions [8, 19].
Reference: [14] <author> S. Danforth and I. Forman. </author> <title> Reflections on metaclass programming in SOM. </title> <booktitle> In Proc. of OOPSLA'94, </booktitle> <pages> pages 440-452. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: Recent work on reflective programming [43] partly performed concurrently with our research is now leading researchers to offer abstractions like `meta objects', which are similar to the policy objects used in CTK <ref> [14] </ref>. Both approaches provide mechanisms for changing an object's behaviors dynamically in most of its aspects (object creation, method invocation, etc), but in general, meta-object protocols address configuration problems for which efficient runtime configuration is not crucial. <p> The resulting required runtime checking of meta-object compatibility is too computationally expensive for applications in which configuration may be highly dynamic or short-lived. In SOM <ref> [14] </ref> or CLOS [51], reflection principles are used for changing object behavior by invoking the methods available to create and initialize classes, to compose their methods tables, etc.
Reference: [15] <author> P. Druschel, L. Peterson, and N. Hutchinson. </author> <title> Beyond microkernel design: Decoupling modularity and protection in Lipto. </title> <booktitle> In Proc. of the 12th Internacional Conference on Distributed Computing Systems, </booktitle> <pages> pages 512-520, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: This is exemplified by the replication of file objects in the Spring operating system [31], by a location transparent invocation mechanism in the Lipto system <ref> [15] </ref>, and by object migration in the Apertos system for uniprocessor platforms [71]. Performance improvements derived from program configuration typically correct mismatches between desired vs. current program or system primitives, policies, and state.
Reference: [16] <author> G. Eisenhauer, B. Schroeder, and K. Schwan. </author> <title> From interactive high performance programs to distributed laboratories: A research agenda. </title> <booktitle> In Proc. of the SPDP'96 Workshop on Program Visualization and Instrumentation, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: The object technologies presented in this paper are an essential part of such efforts <ref> [16] </ref>, in part because they permit such steering to be performed for any target parallel program, regardless of whether it implements specific applications or relevant operating system services.
Reference: [17] <author> G. Eisenhauer and K. Schwan. </author> <title> Parallelization of a molecular dynamics code. </title> <journal> Journal of Parallel and Distributed Computing (SPDT), </journal> <volume> 34(2), </volume> <month> May </month> <year> 1996. </year>
Reference-contexts: Concerning (2), our group has been investigating the interactive steering of high performance programs, to realize gains in performance and functionality <ref> [30, 17, 29] </ref> The essential idea of this technology is to give users the ability to steer their programs quickly past uninteresting results or data domains, therefore significantly reducing program execution time or alternatively, offering additional computing power for required high-fidelity computations.
Reference: [18] <author> J. E.M. Chaves, P. Das, T. LeBlanc, B. Marsh, and M. Scott. </author> <title> Kernel-kernel communication in a shared-memory multiprocessor. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 5(3) </volume> <pages> 171-192, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Similarly, research in high performance programming and in operating systems has derived gains in performance and reliability from the dynamic configuration of multiprocessor synchronization constructs <ref> [18, 49] </ref>, of network communications [34], of file systems [52], and of distributed object abstractions [10]. In all of these cases, basic component functionality is separated from the implementation attributes affecting performance.
Reference: [19] <author> D. R. Engler, M. F. Kaashoek, and J. O. Jr. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proc. of the 15th Symposium on Operating Systems Principles. </booktitle> <publisher> ACM Press, </publisher> <month> December </month> <year> 1995. </year>
Reference-contexts: The general importance of this work is derived from two sources: (1) its implications on how parallel programs, library operating systems <ref> [19] </ref>, or kernels may be structured, and (2) its exploit of configuration for object-based systems, which is particularly important for distributed object-oriented systems, as demonstrated in our current work [67]. <p> the early work on policy-mechanism separation in Hydra [41, 12], the removal of operating system services from `fixed' kernels to the configurable user level in the Mach [53] and NT [13] operating systems, and ultimately leading to the notion of micro-kernels and user-level libraries for implementing customized operating system abstractions <ref> [8, 19] </ref>. In effect, such research has established the fact that application programs may be `combined' with operating system functions such that both may be configured jointly, using the same programming techniques and software infrastructures sometimes called `operating software'[57]. <p> Program or operating system configuration may be performed with diverse methods and at different times, including at compile-, link-, boot-time <ref> [21, 8, 19, 5] </ref>.
Reference: [20] <author> D. Ferrari, A. Banerjea, and H. Zhang. </author> <title> Network support for multimedia: A discussion of the tenet approach. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 26(10), </volume> <month> July </month> <year> 1994. </year> <month> 29 </month>
Reference-contexts: For example, in complex multi-media and real-time applications, timing requirements and the components implementing the resource allocation mechanisms used to enforce these requirements are routinely separated from the applications' basic functionalities and adjusted at runtime <ref> [20, 28, 72] </ref>. Similarly, research in high performance programming and in operating systems has derived gains in performance and reliability from the dynamic configuration of multiprocessor synchronization constructs [18, 49], of network communications [34], of file systems [52], and of distributed object abstractions [10].
Reference: [21] <author> A. Forin, J. Barrera, M. Yound, and R. Rashid. </author> <title> Design, implementation and performance evaluation of a distributed shared memory server for mach. </title> <type> Technical Report CMU-CS-88-1, CMU, </type> <year> 1988. </year> <note> A short version appears in Proc. Winter 1989 Winter Conference. </note>
Reference-contexts: Program or operating system configuration may be performed with diverse methods and at different times, including at compile-, link-, boot-time <ref> [21, 8, 19, 5] </ref>.
Reference: [22] <author> H. P. F. Forum. </author> <title> High Performance Fortran language specification, version 1.0. </title> <type> Technical Report CRPC-TR92225, </type> <institution> Rice University, </institution> <year> 1996. </year>
Reference-contexts: A similar reaction has been to minimize the runtime 3 use of operating system facilities to those that offer suitable performance, often sacrificing ease of programming [36, 70], or to tailor programs to underlying hardware and systems using compiler support <ref> [63, 22] </ref>. We posit that such approaches should be combined with the configuration-based techniques presented in this paper, thereby resulting in improved programmability, extensibility, and scalability of high performance applications.
Reference: [23] <author> G. C. Fox, M. A. Johnson, G. A. Lyzenga, S. W. Otto, J. K. Salmon, and D. W. Walker. </author> <title> Solving Problems On Concurrent Processors. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Historically, high performance applications have dealt with potential static or dynamic mismatches with the operating system by entirely removing it at runtime, as evident in early hypercube machines <ref> [23] </ref> that offer only basic runtime support for process creation and message passing.
Reference: [24] <author> A. Gheith. </author> <title> Support for Multi-Weight Objects, Invocations, and Atomicity in Real-Time Systems. </title> <type> PhD thesis, </type> <institution> Georgia Institute of Technology, College of Computing, </institution> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: This paper describes the next step in our research, which is embodied by the CTK object-based library layered on top of configurable threads and used for the construction of configurable objects on multiprocessor platforms. CTK and its policy objects were conceived and implemented <ref> [24] </ref> prior to Spring's subcontracts [31].
Reference: [25] <author> A. Gheith, P. Gopinath, K. Schwan, and P. Wiley. </author> <title> Chaos and chaos-art: Extensions to an object-based kernel. </title> <booktitle> In IEEE Computer Society Fifth Workshop on Real-Time Operating Systems, </booktitle> <address> Washington, D.C. </address> <publisher> IEEE, </publisher> <month> April </month> <year> 1988. </year>
Reference-contexts: It also distinguishes this research from our own past work [3, 28], in which we investigate how the needs of real-time applications affect the object model and its required runtime support <ref> [25] </ref>. Similarly, recent work on the dynamic configuration of distributed and object-based systems [6] often concerns specific configuration methods or general (rather than high performance) frameworks for implementing dynamically configurable applications, whereas CTK is exploring flexible mechanisms with which efficient, configurable program and operating system abstractions may be implemented.
Reference: [26] <author> A. Gheith, B. Mukherjee, Dilma Menezes da Silva, and K. Schwan. </author> <title> Configurable objects and invocations. </title> <booktitle> In Proc. of the Second International Workshop in Configurable Distributed Systems, </booktitle> <pages> pages 92-104. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> may </month> <year> 1994. </year>
Reference-contexts: Similarly, in our current work with the runtime configuration of objects on distributed platforms [2, 67], we expect to realize substantial performance gains by configuring applications simultaneously at several levels of abstraction in the distributed program and in the underlying operating systems and networks <ref> [26] </ref>: (1) in the application itself, (2) in the object transport substrate, and (3) at the protocol level. <p> Our previous work has demonstrated the performance gains from configuration at each of these levels <ref> [34, 26] </ref>, but we have not yet been able to show gains by simultaneous configuration at multiple levels of abstraction. The extensions of object functionality described in this paper concern persistence and monitoring.
Reference: [27] <author> A. Gheith and K. Schwan. Chaos-art: </author> <title> Kernel support for atomic transactions in real-time applications. </title> <booktitle> In Nineteenth International Symposium on Fault-Tolerant Computing, </booktitle> <address> Chicago, </address> <publisher> ILL, </publisher> <pages> pages 462-469, </pages> <month> June </month> <year> 1989. </year> <note> Also see GIT-ICS-90/06, </note> <institution> College of Computing, Georgia Tech, </institution> <address> Atlanta, GA 30332. </address>
Reference-contexts: In addition, programmers can easily implement object representations and invocation semantics tailored to their applications' specific requirements in functionality and performance, such as `toggle' or periodic invocations for real-time applications and invocations resembling transactions that can 5 use state information about other objects' invocations <ref> [27] </ref>. As an example, consider the attribute `InvocationType', which is a name-value pair: InvocationType: enum fsynchr, asynchrg This attribute expresses that an invocation can be of type `synchronous' or `asynchronous'.
Reference: [28] <author> A. Gheith and K. Schwan. </author> <title> Chaos-arc kernel support for multi-weight objects, invocations, and atomicity in real-time applications. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(1) </volume> <pages> 33-72, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: For example, in complex multi-media and real-time applications, timing requirements and the components implementing the resource allocation mechanisms used to enforce these requirements are routinely separated from the applications' basic functionalities and adjusted at runtime <ref> [20, 28, 72] </ref>. Similarly, research in high performance programming and in operating systems has derived gains in performance and reliability from the dynamic configuration of multiprocessor synchronization constructs [18, 49], of network communications [34], of file systems [52], and of distributed object abstractions [10]. <p> It also distinguishes this research from our own past work <ref> [3, 28] </ref>, in which we investigate how the needs of real-time applications affect the object model and its required runtime support [25]. <p> New abstractions and functionality (ie., classes, policies, and attributes) are easily added while potentially maintaining a uniform kernel interface (e.g., when not adding any new kernel classes). In our past work, we have developed a significant extension of the CTK library, resulting in a complex real-time operating system kernel <ref> [28] </ref>. We have also experimented with a second extension of CTK supporting configurable communication protocols [42]. This paper does not focus on the use of CTK for operating system configuration and extension. <p> A sample invocation attribute is one that specifies dynamically determined limits on the permissible duration of an invocation for multi-media or real-time applications <ref> [28] </ref>. * A policy can also extend an object's interface with special services. <p> For brevity, we elide measurements of previous prototypes of CTK on other Unix machines, like the Sequent Symmetry, Sun3's, Sun386's, and measurements of its implementation as a native real-time kernel on the GP1000 BBN Butterfly multiprocessor <ref> [28] </ref>. The KSR-2 machine is a NUMA (non-uniform memory access) shared memory, cache-only architecture with an interconnection network that consists of hierarchically interconnected rings, each of 4 The measurements in Table 1 utilize a non-optimized implementation of CTK for the SGI machine.
Reference: [29] <author> W. Gu, G. Eisenhauer, E. Kraemer, K. Schwan, J. Stasko, J. Vetter, and N. Mallavarupu. </author> <title> Falcon: On-line monitoring and steering of large-scale parallel programs. </title> <booktitle> In Proc. of FRONTIERS'95, </booktitle> <month> Feb. </month> <year> 1995. </year> <note> Also available as Technical Report GIT-CC-94-21, </note> <institution> College of Computing, Georgia Institute of Technology. </institution>
Reference-contexts: Our earlier contribution to this goal was the construction of a parallel programming library that offers the well-known Cthreads programming interface [11] along with built-in self-configuring Cthreads abstractions (e.g., a configurable lock abstraction described in [49]) and with support functions for the efficient collection and, ultimately, display <ref> [29] </ref> of threads' runtime state. This paper describes the next step in our research, which is embodied by the CTK object-based library layered on top of configurable threads and used for the construction of configurable objects on multiprocessor platforms. <p> The approach's disadvantage is that obtaining a snapshot of available subproblems would require that all policies cooperate in achieving global synchronization. Monitored objects. The monitoring of CTK objects is implemented via another policy which internally utilizes the online monitoring mechanisms provided by the Falcon project <ref> [29, 65] </ref>. <p> Concerning (2), our group has been investigating the interactive steering of high performance programs, to realize gains in performance and functionality <ref> [30, 17, 29] </ref> The essential idea of this technology is to give users the ability to steer their programs quickly past uninteresting results or data domains, therefore significantly reducing program execution time or alternatively, offering additional computing power for required high-fidelity computations.
Reference: [30] <author> W. Gu, J. Vetter, and K. Schwan. </author> <title> An annotated bibliography of interactive program steering. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(9) </volume> <pages> 140-148, </pages> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: Concerning (2), our group has been investigating the interactive steering of high performance programs, to realize gains in performance and functionality <ref> [30, 17, 29] </ref> The essential idea of this technology is to give users the ability to steer their programs quickly past uninteresting results or data domains, therefore significantly reducing program execution time or alternatively, offering additional computing power for required high-fidelity computations.
Reference: [31] <author> G. Hamilton, M. Powelol, and J. Mitchell. Subcontract: </author> <title> A flexible base for distributed computing. </title> <booktitle> In Proc. of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 69-79. </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1993. </year>
Reference-contexts: Separation and configuration can also be the mechanisms for maintaining backward compatibility with existing applications' type-dependent interfaces or with previous versions of operating systems, neither of which should change when developers offer additional functionality. This is exemplified by the replication of file objects in the Spring operating system <ref> [31] </ref>, by a location transparent invocation mechanism in the Lipto system [15], and by object migration in the Apertos system for uniprocessor platforms [71]. Performance improvements derived from program configuration typically correct mismatches between desired vs. current program or system primitives, policies, and state. <p> Such joint configuration is explored in several recent object-based efforts [38], including the Choices [5], Spring <ref> [31] </ref>, Chaos [61], Apertos [71], and ACE [55] operating systems. It is also being explored in efforts that address object fragmentation, including our own past research on hypercubes [59, 10], Shapiro's work on fragmented network objects [66], and recent work on object fragmentation by Tanenbaum [33]. <p> Runtime configuration methods include the dynamic re-linking of OS kernels, server process creation and deletion [53], the redirection of selected system calls using interposition in [37] and using subcontracts in Spring <ref> [31] </ref>, the dynamic adjustment of meta-objects in [55], the dynamic adaptation of object and invocation implementations [50], the runtime adjustment of individual object parameters [56] or of structural properties of sets of communicating objects [1]. <p> This paper describes the next step in our research, which is embodied by the CTK object-based library layered on top of configurable threads and used for the construction of configurable objects on multiprocessor platforms. CTK and its policy objects were conceived and implemented [24] prior to Spring's subcontracts <ref> [31] </ref>.
Reference: [32] <author> C. A. R. Hoare. </author> <title> Monitors: An operating system structuring concept. </title> <journal> Communications of the ACM, </journal> <volume> 17(10) </volume> <pages> 549-557, </pages> <year> 1974. </year>
Reference-contexts: Invoking an ADT causes the execution of its method in the address space of the invoker. In comparison, invoking a `TADT' (threaded abstract data type) creates a new execution thread for execution of the called operation, but also does not synchronize concurrent calls. A `Monitor' <ref> [32] </ref> is an object without execution threads that only allows a single call to be active at a time. It can also define condition variables on which calls can wait, thereby allowing other calls to proceed, until the condition variable is signaled.
Reference: [33] <author> P. Homburg, L. van Doorn, M. van Steen, A. S. Tanenbaum, and W. de Jonge. </author> <title> An object model for flexible distributed systems. </title> <booktitle> In Proc. of ASCI'95, </booktitle> <publisher> ASCI T.U. </publisher> <address> Delft, </address> <pages> pages 69-78, </pages> <year> 1995. </year>
Reference-contexts: It is also being explored in efforts that address object fragmentation, including our own past research on hypercubes [59, 10], Shapiro's work on fragmented network objects [66], and recent work on object fragmentation by Tanenbaum <ref> [33] </ref>. Program or operating system configuration may be performed with diverse methods and at different times, including at compile-, link-, boot-time [21, 8, 19, 5].
Reference: [34] <author> D. Ivan-Rosu and K. Schwan. </author> <title> Improving protocol performance by dynamic control of communication resources. </title> <booktitle> In Second International Conference on Engineering Complex Systems, Montreal, </booktitle> <pages> pages 249-256. </pages> <publisher> IEEE, </publisher> <month> October </month> <year> 1996. </year> <note> Outstanding paper award. </note>
Reference-contexts: Similarly, research in high performance programming and in operating systems has derived gains in performance and reliability from the dynamic configuration of multiprocessor synchronization constructs [18, 49], of network communications <ref> [34] </ref>, of file systems [52], and of distributed object abstractions [10]. In all of these cases, basic component functionality is separated from the implementation attributes affecting performance. <p> Our previous work has demonstrated the performance gains from configuration at each of these levels <ref> [34, 26] </ref>, but we have not yet been able to show gains by simultaneous configuration at multiple levels of abstraction. The extensions of object functionality described in this paper concern persistence and monitoring.
Reference: [35] <author> R. Jha, M. Muhammad, S. Yalamanchili, K. Schwan, D. Ivan-Rosu, and C. DeCastro. </author> <title> Adaptive resource allocation for embedded parallel applications. </title> <booktitle> In Third International Conference on High Performance Computing. IEEE, </booktitle> <month> December </month> <year> 1996. </year>
Reference-contexts: However, its use with the TSP application has high costs due to the application's rapid generation and expansion of many different subproblems. In comparison, its use with the branch-and-bound solutions to the processor mapping problem described in <ref> [35] </ref> is appropriate, since that problem's relatively small number of expansions each require substantive amounts of processing. Despite its prohibitive costs, our implementation of the logging policy for the TSP application is interesting since it addresses how logging may be performed for internally fragmented objects.
Reference: [36] <author> A. K. Jones and P. Schwarz. </author> <title> Experience using multiprocessor systems: A status report. </title> <journal> Surveys of the Assoc. Comput. Mach., </journal> <volume> 12(2) </volume> <pages> 121-166, </pages> <month> June </month> <year> 1980. </year>
Reference-contexts: A similar reaction has been to minimize the runtime 3 use of operating system facilities to those that offer suitable performance, often sacrificing ease of programming <ref> [36, 70] </ref>, or to tailor programs to underlying hardware and systems using compiler support [63, 22]. We posit that such approaches should be combined with the configuration-based techniques presented in this paper, thereby resulting in improved programmability, extensibility, and scalability of high performance applications.
Reference: [37] <author> M. Jones. </author> <title> Interposition agents: Transparently interposing user code at the system interface. </title> <journal> Operating System Review, </journal> <volume> 27(5) </volume> <pages> 69-79, </pages> <month> December </month> <year> 1993. </year> <booktitle> Proc. 14th ACM Symp. on Operating Systems Principles. </booktitle> <pages> 30 </pages>
Reference-contexts: Program or operating system configuration may be performed with diverse methods and at different times, including at compile-, link-, boot-time [21, 8, 19, 5]. Runtime configuration methods include the dynamic re-linking of OS kernels, server process creation and deletion [53], the redirection of selected system calls using interposition in <ref> [37] </ref> and using subcontracts in Spring [31], the dynamic adjustment of meta-objects in [55], the dynamic adaptation of object and invocation implementations [50], the runtime adjustment of individual object parameters [56] or of structural properties of sets of communicating objects [1].
Reference: [38] <author> G. Kiczales and J. </author> <title> Lamping. </title> <booktitle> Operating systems: Why object oriented? In International Workshop in Object Oriented Operating Systems, </booktitle> <pages> pages 25-30, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: In effect, such research has established the fact that application programs may be `combined' with operating system functions such that both may be configured jointly, using the same programming techniques and software infrastructures sometimes called `operating software'[57]. Such joint configuration is explored in several recent object-based efforts <ref> [38] </ref>, including the Choices [5], Spring [31], Chaos [61], Apertos [71], and ACE [55] operating systems.
Reference: [39] <author> J. Kramer and J. Magee. </author> <title> Dynamic configuration for distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(4):424-436, </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: not related to object functionality (e.g., timing behavior) or for the dynamic adjustment of object characteristics determining such behavior (e.g., for performance). 4 2.2 Real-time and Object-based Systems CTK's emphasis on the attainment of improved performance in parallel systems distinguishes our work from other efforts addressing distributed or real-time systems <ref> [44, 64, 4, 39, 45, 68, 47] </ref>, where the primary concern has been to maintain certain levels of system responsiveness or reliability in the presence of uncertain execution environments.
Reference: [40] <author> I. Lee and V. Gehlot. </author> <title> Language constructs for distributed real-time programming. </title> <booktitle> In Proc. of the 6th Real-Time Systems Symposium, </booktitle> <address> San Diego, CA, </address> <pages> pages 57-66. </pages> <publisher> IEEE, </publisher> <month> Dec. </month> <year> 1985. </year>
Reference-contexts: Compiler-based techniques for runtime configuration have included the dynamic synthesis of program code [46] and the re-direction of procedure calls <ref> [40] </ref>. Our research builds on and partly extends past work in configurable systems. Our aim is not to explore specific configuration techniques, but instead, to attain improved performance in parallel programs by giving programmers user- or kernel-level libraries with which they may construct dynamically configurable software abstractions.
Reference: [41] <author> R. Levin, E. Cohen, W. Corwin, F. Pollack, and W. Wulf. </author> <title> Policy/mechanism separation in hydra. </title> <booktitle> In Proc. of the 5th ACM Symposium on Operating System Principles, </booktitle> <month> Nov. </month> <year> 1975. </year>
Reference-contexts: A variety of research results has enabled the runtime configuration of operating systems in order to improve the performance of specific user programs, including the early work on policy-mechanism separation in Hydra <ref> [41, 12] </ref>, the removal of operating system services from `fixed' kernels to the configurable user level in the Mach [53] and NT [13] operating systems, and ultimately leading to the notion of micro-kernels and user-level libraries for implementing customized operating system abstractions [8, 19].
Reference: [42] <author> B. Lindgren, B. Krupczak, M. Ammar, and K. Schwan. </author> <title> An architecture and toolkit for parallel and configurable protocols. </title> <booktitle> In Proceedings of the International Conference on Network Protocols (ICNP-93), </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: In our past work, we have developed a significant extension of the CTK library, resulting in a complex real-time operating system kernel [28]. We have also experimented with a second extension of CTK supporting configurable communication protocols <ref> [42] </ref>. This paper does not focus on the use of CTK for operating system configuration and extension.
Reference: [43] <author> P. Maes. </author> <title> Concepts and experiments in computational reflection. </title> <booktitle> In Proc. of OOPSLA'94, </booktitle> <pages> pages 147-155. </pages> <publisher> Vrijie Universiteit Brussel, ACM Press, </publisher> <month> October </month> <year> 1987. </year>
Reference-contexts: Recent work on reflective programming <ref> [43] </ref> partly performed concurrently with our research is now leading researchers to offer abstractions like `meta objects', which are similar to the policy objects used in CTK [14].
Reference: [44] <author> J. Magee and J. Kramer. </author> <title> Dynamic configuration for distributed real-time systems. </title> <booktitle> In Proc. of the International Conference on Parallel Processing, </booktitle> <pages> pages 277-288, </pages> <month> Aug. </month> <year> 1983. </year>
Reference-contexts: not related to object functionality (e.g., timing behavior) or for the dynamic adjustment of object characteristics determining such behavior (e.g., for performance). 4 2.2 Real-time and Object-based Systems CTK's emphasis on the attainment of improved performance in parallel systems distinguishes our work from other efforts addressing distributed or real-time systems <ref> [44, 64, 4, 39, 45, 68, 47] </ref>, where the primary concern has been to maintain certain levels of system responsiveness or reliability in the presence of uncertain execution environments.
Reference: [45] <author> K. Marzullo and M. Wood. </author> <title> Making real-time systems reactive. </title> <journal> ACM Operating Systems Review, </journal> <volume> 25(1), </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: not related to object functionality (e.g., timing behavior) or for the dynamic adjustment of object characteristics determining such behavior (e.g., for performance). 4 2.2 Real-time and Object-based Systems CTK's emphasis on the attainment of improved performance in parallel systems distinguishes our work from other efforts addressing distributed or real-time systems <ref> [44, 64, 4, 39, 45, 68, 47] </ref>, where the primary concern has been to maintain certain levels of system responsiveness or reliability in the presence of uncertain execution environments.
Reference: [46] <author> H. Massalin and C. Pu. </author> <title> Threads and input/output in the synthesis kernel. </title> <booktitle> In Proc. of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201, </pages> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: Compiler-based techniques for runtime configuration have included the dynamic synthesis of program code <ref> [46] </ref> and the re-direction of procedure calls [40]. Our research builds on and partly extends past work in configurable systems.
Reference: [47] <author> L. Molesky, K. Ramamritham, C. Shen, J. Stankovic, and G. Zlokapa. </author> <title> Implementing a predictable real-time multiprocessor kernel the Spring kernel. </title> <booktitle> In Proc. of the IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <year> 1990. </year>
Reference-contexts: not related to object functionality (e.g., timing behavior) or for the dynamic adjustment of object characteristics determining such behavior (e.g., for performance). 4 2.2 Real-time and Object-based Systems CTK's emphasis on the attainment of improved performance in parallel systems distinguishes our work from other efforts addressing distributed or real-time systems <ref> [44, 64, 4, 39, 45, 68, 47] </ref>, where the primary concern has been to maintain certain levels of system responsiveness or reliability in the presence of uncertain execution environments.
Reference: [48] <author> B. Mukherjee. </author> <title> A portable and reconfigurable threads package. </title> <booktitle> In Proc. of the Sun User Group Technical Conference, </booktitle> <pages> pages 101-112, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Such interactions are useful for program-driven dynamic changes to objects. 7 CTK structure and implementation. The structure and implementation of the Configuration Toolkit are depicted in Fig. 1 as consisting of three components: (1) configurable threads, which is the portable Cthreads package underlying CTK <ref> [60, 48] </ref>, (2) built-in object types and its support for attributes and policies, and (3) the various policies and attributes implemented for the application programs built with CTK and the hardware platforms for which CTK was optimized. <p> Another example explained in the next section is a complex object implementing a global queue object internally consisting of multiple ADTs serving as distinct object fragments. Configurable Cthreads is the partially machine dependent component <ref> [48] </ref> that implements the basic abstractions used by the remainder of CTK: execution threads, virtual memory regions, synchronization primitives, monitoring support (for capture of parallel program and CTK state), and a limited number of basic attributes for the configuration of threads-level abstractions, such as synchronization primitives and low-level scheduling. 8 4 <p> The parallel programming model implemented by the KSR's OSF Unix operating system is one of kernel-level threads, but CTK's implementation uses the user-level Cthreads package described in <ref> [48] </ref>. The SGI machine is a symmetric multiprocessor with faster processors, memory, and interconnect than the KSR machine. It offers a computation/communication speed ratio not too dissimilar from that of the KSR machine.
Reference: [49] <author> B. Mukherjee and K. Schwan. </author> <title> Improving performance by use of adaptive objects: Experimentation with a configurable multiprocessor thread package. </title> <booktitle> In Proc. of the Second International Symposium on High Performance Distributed Computing (HPDC-2), </booktitle> <pages> pages 59-66, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Similarly, research in high performance programming and in operating systems has derived gains in performance and reliability from the dynamic configuration of multiprocessor synchronization constructs <ref> [18, 49] </ref>, of network communications [34], of file systems [52], and of distributed object abstractions [10]. In all of these cases, basic component functionality is separated from the implementation attributes affecting performance. <p> For example, since system loads cannot be predicted in multi-user systems, the optimal levels of parallelism (ie., scheduling) for a parallel program can only be determined and set dynamically [69].Similarly, runtime changes in lock implementations on multiprocessor programs can lead to substantial performance gains <ref> [49] </ref>. <p> Our earlier contribution to this goal was the construction of a parallel programming library that offers the well-known Cthreads programming interface [11] along with built-in self-configuring Cthreads abstractions (e.g., a configurable lock abstraction described in <ref> [49] </ref>) and with support functions for the efficient collection and, ultimately, display [29] of threads' runtime state.
Reference: [50] <author> B. Mukherjee, D. M. Silva, K. Schwan, and A. Gheith. KTK: </author> <title> kernel support for configurable objects and invocations. </title> <journal> Distributed Systems Engineering Journal, </journal> <volume> 1 </volume> <pages> 259-270, </pages> <year> 1994. </year>
Reference-contexts: Runtime configuration methods include the dynamic re-linking of OS kernels, server process creation and deletion [53], the redirection of selected system calls using interposition in [37] and using subcontracts in Spring [31], the dynamic adjustment of meta-objects in [55], the dynamic adaptation of object and invocation implementations <ref> [50] </ref>, the runtime adjustment of individual object parameters [56] or of structural properties of sets of communicating objects [1]. Compiler-based techniques for runtime configuration have included the dynamic synthesis of program code [46] and the re-direction of procedure calls [40].
Reference: [51] <editor> A. Paepcke, editor. </editor> <title> Object-Oriented Programming The CLOS Perspective. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The resulting required runtime checking of meta-object compatibility is too computationally expensive for applications in which configuration may be highly dynamic or short-lived. In SOM [14] or CLOS <ref> [51] </ref>, reflection principles are used for changing object behavior by invoking the methods available to create and initialize classes, to compose their methods tables, etc.
Reference: [52] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <month> Winter </month> <year> 1988. </year>
Reference-contexts: Similarly, research in high performance programming and in operating systems has derived gains in performance and reliability from the dynamic configuration of multiprocessor synchronization constructs [18, 49], of network communications [34], of file systems <ref> [52] </ref>, and of distributed object abstractions [10]. In all of these cases, basic component functionality is separated from the implementation attributes affecting performance.
Reference: [53] <author> R. Rashid, D. Julin, and et al. </author> <title> Mach: A system software kernel. </title> <booktitle> In Proc. of the 34th IEEE Computer society International Conference (COMPCON 89), </booktitle> <pages> pages 176-178, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: variety of research results has enabled the runtime configuration of operating systems in order to improve the performance of specific user programs, including the early work on policy-mechanism separation in Hydra [41, 12], the removal of operating system services from `fixed' kernels to the configurable user level in the Mach <ref> [53] </ref> and NT [13] operating systems, and ultimately leading to the notion of micro-kernels and user-level libraries for implementing customized operating system abstractions [8, 19]. <p> Program or operating system configuration may be performed with diverse methods and at different times, including at compile-, link-, boot-time [21, 8, 19, 5]. Runtime configuration methods include the dynamic re-linking of OS kernels, server process creation and deletion <ref> [53] </ref>, the redirection of selected system calls using interposition in [37] and using subcontracts in Spring [31], the dynamic adjustment of meta-objects in [55], the dynamic adaptation of object and invocation implementations [50], the runtime adjustment of individual object parameters [56] or of structural properties of sets of communicating objects [1].
Reference: [54] <author> G. Reinelt. </author> <title> TSPLIB | a traveling salesman problem library. </title> <journal> ORSA Journal on Computing, </journal> <volume> 3(4) </volume> <pages> 376-384, </pages> <year> 1991. </year>
Reference-contexts: the number of processors gets larger than 10, the weakly ordered TSP execution starts to spend most of the CPU time working on suboptimal problems (optimal locally, but not globally), and the central 5 The Traveling salesman problem library (TSPLIB) provides researchers with a broad set of standard test problems <ref> [54] </ref>. 20 queue TSP execution outperforms the weakly order again. Discussion of experimentation. This section has demonstrated the benefits derived from object configuration implemented with CTK's policies and attributes. In part, such benefits are due to the efficient and `pay as needed' implementation of CTK's configuration mechanisms.
Reference: [55] <author> D. Schmidt. </author> <title> The adaptive communication environment. </title> <booktitle> In Proc. of the 11th Sun User Group Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Such joint configuration is explored in several recent object-based efforts [38], including the Choices [5], Spring [31], Chaos [61], Apertos [71], and ACE <ref> [55] </ref> operating systems. It is also being explored in efforts that address object fragmentation, including our own past research on hypercubes [59, 10], Shapiro's work on fragmented network objects [66], and recent work on object fragmentation by Tanenbaum [33]. <p> Runtime configuration methods include the dynamic re-linking of OS kernels, server process creation and deletion [53], the redirection of selected system calls using interposition in [37] and using subcontracts in Spring [31], the dynamic adjustment of meta-objects in <ref> [55] </ref>, the dynamic adaptation of object and invocation implementations [50], the runtime adjustment of individual object parameters [56] or of structural properties of sets of communicating objects [1]. Compiler-based techniques for runtime configuration have included the dynamic synthesis of program code [46] and the re-direction of procedure calls [40]. <p> In order to separate configuration from an object's basic functionality, each object has two distinct views: (1) the application view and (2) the configuration view, the latter being roughly equivalent to recent notions of meta-objects implemented in systems like ACE <ref> [55] </ref>. The application view of an object is presented in terms of its class, characterizing its external interface (methods). The configuration view is defined by the object's policies and attributes.
Reference: [56] <author> K. Schwan. </author> <title> Poster session: The Issos project. </title> <booktitle> In Proc. of the 9th Symposium on Operating Systems Principles. </booktitle> <publisher> Assoc. Comput. Mach., </publisher> <month> Oct. </month> <year> 1983. </year>
Reference-contexts: dynamic re-linking of OS kernels, server process creation and deletion [53], the redirection of selected system calls using interposition in [37] and using subcontracts in Spring [31], the dynamic adjustment of meta-objects in [55], the dynamic adaptation of object and invocation implementations [50], the runtime adjustment of individual object parameters <ref> [56] </ref> or of structural properties of sets of communicating objects [1]. Compiler-based techniques for runtime configuration have included the dynamic synthesis of program code [46] and the re-direction of procedure calls [40]. Our research builds on and partly extends past work in configurable systems.
Reference: [57] <author> K. Schwan, T. Bihari, B. W. Weide, and G. Taulbee. </author> <title> Gem: Operating system primitives for robots and real-time control. </title> <booktitle> In Proc. of the International Conference on Robotics and Automation, </booktitle> <address> St. Louis, </address> <publisher> Missouri, </publisher> <pages> pages 807-813. </pages> <publisher> IEEE, </publisher> <month> March </month> <year> 1985. </year> <note> Also published as article in ACM TOCS. 31 </note>
Reference: [58] <author> K. Schwan, B. Blake, W. Bo, and J. Gawkowski. </author> <title> Global data and control in multicomputers: Operating system primitives and experimentation with a parallel branch-and-bound algorithm. </title> <journal> Concurrency: Practice and Experience, </journal> <pages> pages 191-218, </pages> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: Specifically, both a centralized implementation and one that maintains non-cooperating queue fragments local to each processor lead to poor performance, as demonstrated for several parallel platforms by our previous work. Extensive experimental results with alternative implementations of the Traveling Salesperson Problem (TSP) on distributed memory (an Intel iPSC machine <ref> [58] </ref>) and on shared memory machines (the BBN Butterfly and Kendall Square NUMA multiprocessors [9, 10]) have demonstrated that the dynamic configuration of selected attributes of the distributed queue is essential for good runtime performance.
Reference: [59] <author> K. Schwan and W. Bo. </author> <title> Topologies distributed objects on multicomputers. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(2) </volume> <pages> 111-157, </pages> <month> May </month> <year> 1990. </year> <note> Older version available as OSU-CISRC-3/88-TR11. </note>
Reference-contexts: Such joint configuration is explored in several recent object-based efforts [38], including the Choices [5], Spring [31], Chaos [61], Apertos [71], and ACE [55] operating systems. It is also being explored in efforts that address object fragmentation, including our own past research on hypercubes <ref> [59, 10] </ref>, Shapiro's work on fragmented network objects [66], and recent work on object fragmentation by Tanenbaum [33]. Program or operating system configuration may be performed with diverse methods and at different times, including at compile-, link-, boot-time [21, 8, 19, 5].
Reference: [60] <author> K. Schwan, H. Forbes, A. Gheith, B. Mukherjee, and Y. Samiotakis. </author> <title> A Cthread library for multiprocessors. </title> <type> Technical report, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <address> Atlanta, GA 30332, GIT-ICS-91/02, </address> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: Such interactions are useful for program-driven dynamic changes to objects. 7 CTK structure and implementation. The structure and implementation of the Configuration Toolkit are depicted in Fig. 1 as consisting of three components: (1) configurable threads, which is the portable Cthreads package underlying CTK <ref> [60, 48] </ref>, (2) built-in object types and its support for attributes and policies, and (3) the various policies and attributes implemented for the application programs built with CTK and the hardware platforms for which CTK was optimized.
Reference: [61] <author> K. Schwan, A. Gheith, and H. Zhou. Chaos-arc: </author> <title> A kernel for predictable programs in dynamic real-time systems. </title> <booktitle> In 7th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <institution> Univ. of Virginia, </institution> <address> Charlottesville, </address> <pages> pages 11-19, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Such joint configuration is explored in several recent object-based efforts [38], including the Choices [5], Spring [31], Chaos <ref> [61] </ref>, Apertos [71], and ACE [55] operating systems. It is also being explored in efforts that address object fragmentation, including our own past research on hypercubes [59, 10], Shapiro's work on fragmented network objects [66], and recent work on object fragmentation by Tanenbaum [33].
Reference: [62] <author> K. Schwan, A. Gheith, and H. Zhou. </author> <title> From chaos-min to chaos-arc: A family of real-time multiprocessor kernels. </title> <booktitle> In Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 82-92, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Specifically, adequate performance on large-scale parallel machines can be attained (1) if the queue is implemented as multiple cooperating fragments distributed across the different nodes of the multiprocessor <ref> [62, 9, 10] </ref>, (2) if some desirable global ordering on queue elements is maintained across all fragments, and (3) if the access policies to queue fragments and the interconnections among queue fragments can be customized to specific application runs. <p> Topology the topology of the communication structure among queue fragments (e.g., a ring, a tree, complete graph, etc). 3. Invocation mode maybe synchronous or asynchronous. This has been shown useful in non-shared memory multicomputers <ref> [62] </ref>, where a retrieval from a remote fragment may be sufficiently slow so that the invoking object should first complete some other work before checking for the arrival of the sought queue element. 4. Priority a queue element's priority may have several sources.
Reference: [63] <author> K. Schwan and A. K. Jones. </author> <title> Flexible software development for multiple computer systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(3):385-401, </volume> <month> March </month> <year> 1986. </year>
Reference-contexts: A similar reaction has been to minimize the runtime 3 use of operating system facilities to those that offer suitable performance, often sacrificing ease of programming [36, 70], or to tailor programs to underlying hardware and systems using compiler support <ref> [63, 22] </ref>. We posit that such approaches should be combined with the configuration-based techniques presented in this paper, thereby resulting in improved programmability, extensibility, and scalability of high performance applications.
Reference: [64] <author> K. Schwan and R. Ramnath. </author> <title> Adaptable operating software for manufacturing systems and robots: </title> <booktitle> A computer science research agenda. In Proc. of the 5th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 255-262, </pages> <month> Dec. </month> <year> 1984. </year>
Reference-contexts: not related to object functionality (e.g., timing behavior) or for the dynamic adjustment of object characteristics determining such behavior (e.g., for performance). 4 2.2 Real-time and Object-based Systems CTK's emphasis on the attainment of improved performance in parallel systems distinguishes our work from other efforts addressing distributed or real-time systems <ref> [44, 64, 4, 39, 45, 68, 47] </ref>, where the primary concern has been to maintain certain levels of system responsiveness or reliability in the presence of uncertain execution environments.
Reference: [65] <author> K. Schwan et al. </author> <title> The falcon monitoring and steering system. </title> <address> http://www.cc.gatech.edu/systems/- projects/FALCON/. </address>
Reference-contexts: The approach's disadvantage is that obtaining a snapshot of available subproblems would require that all policies cooperate in achieving global synchronization. Monitored objects. The monitoring of CTK objects is implemented via another policy which internally utilizes the online monitoring mechanisms provided by the Falcon project <ref> [29, 65] </ref>.
Reference: [66] <author> M. Shapiro. </author> <title> Structure and encapsulation in distributed systems: The proxy principle. </title> <booktitle> In Sixth International Conference on Distributed Computing Systems, </booktitle> <address> Boston, Mass., </address> <pages> pages 198-204. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1986. </year>
Reference-contexts: It is also being explored in efforts that address object fragmentation, including our own past research on hypercubes [59, 10], Shapiro's work on fragmented network objects <ref> [66] </ref>, and recent work on object fragmentation by Tanenbaum [33]. Program or operating system configuration may be performed with diverse methods and at different times, including at compile-, link-, boot-time [21, 8, 19, 5].
Reference: [67] <author> D. M. Silva. </author> <title> A Framework for Building Flexible Systems. </title> <type> PhD thesis, </type> <institution> Georgia Institute of Technology, </institution> <year> 1997. </year>
Reference-contexts: The general importance of this work is derived from two sources: (1) its implications on how parallel programs, library operating systems [19], or kernels may be structured, and (2) its exploit of configuration for object-based systems, which is particularly important for distributed object-oriented systems, as demonstrated in our current work <ref> [67] </ref>. More specifically, this paper's presentation of CTK and its use offers several interesting insights into the construction of high performance software. First, we describe the fashion in which basic object functionality may be separated from its configurable attributes, by designing a sample configurable multiprocessor object (see Section 4.1). <p> For example, attributes permit the selection of storage media (e.g, the local file system or a remote data server) for persistence data. For brevity, details of the persistence policy's implementation are elided in this paper (see <ref> [67] </ref>). Instead, we next discuss the implications of two alternative persistence policy realizations for the TSP application: * Checkpointing: Periodically, all of the information about the state and the attribute values of queue fragments is placed into checkpoint files. <p> For larger-scale parallel application programs, we expect to achieve cumulative performance gains approaching or exceeding 100%. Similarly, in our current work with the runtime configuration of objects on distributed platforms <ref> [2, 67] </ref>, we expect to realize substantial performance gains by configuring applications simultaneously at several levels of abstraction in the distributed program and in the underlying operating systems and networks [26]: (1) in the application itself, (2) in the object transport substrate, and (3) at the protocol level.
Reference: [68] <author> J. Stankovic and K. Ramamritham. </author> <title> The design of the Spring kernel. </title> <booktitle> In Proc. of the IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 146-157, </pages> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: not related to object functionality (e.g., timing behavior) or for the dynamic adjustment of object characteristics determining such behavior (e.g., for performance). 4 2.2 Real-time and Object-based Systems CTK's emphasis on the attainment of improved performance in parallel systems distinguishes our work from other efforts addressing distributed or real-time systems <ref> [44, 64, 4, 39, 45, 68, 47] </ref>, where the primary concern has been to maintain certain levels of system responsiveness or reliability in the presence of uncertain execution environments.
Reference: [69] <author> A. Tucker and A. Gupta. </author> <title> Process control and scheduling issues on a network of multiprocessors. </title> <booktitle> In Proc. of the 12th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 159-166, </pages> <month> Dec. </month> <year> 1989. </year>
Reference: [70] <author> W. A. Wulf, R. Levin, and S. R. Harbison. Hydra/C.mmp: </author> <title> An Experimental Computer System. </title> <booktitle> McGraw-Hill Advanced Computer Science Series, </booktitle> <year> 1981. </year>
Reference-contexts: A similar reaction has been to minimize the runtime 3 use of operating system facilities to those that offer suitable performance, often sacrificing ease of programming <ref> [36, 70] </ref>, or to tailor programs to underlying hardware and systems using compiler support [63, 22]. We posit that such approaches should be combined with the configuration-based techniques presented in this paper, thereby resulting in improved programmability, extensibility, and scalability of high performance applications.
Reference: [71] <author> Y. Yokote. </author> <title> The Apertos reflective operating system: The concept and its implementation. </title> <booktitle> In Proc. of OOPSLA'92, </booktitle> <pages> pages 414-434. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1992. </year>
Reference-contexts: This is exemplified by the replication of file objects in the Spring operating system [31], by a location transparent invocation mechanism in the Lipto system [15], and by object migration in the Apertos system for uniprocessor platforms <ref> [71] </ref>. Performance improvements derived from program configuration typically correct mismatches between desired vs. current program or system primitives, policies, and state. Since such mismatches may arise at any time during a program's execution, configuration must often be performed dynamically (at runtime). <p> Such joint configuration is explored in several recent object-based efforts [38], including the Choices [5], Spring [31], Chaos [61], Apertos <ref> [71] </ref>, and ACE [55] operating systems. It is also being explored in efforts that address object fragmentation, including our own past research on hypercubes [59, 10], Shapiro's work on fragmented network objects [66], and recent work on object fragmentation by Tanenbaum [33]. <p> Both approaches provide mechanisms for changing an object's behaviors dynamically in most of its aspects (object creation, method invocation, etc), but in general, meta-object protocols address configuration problems for which efficient runtime configuration is not crucial. For example, in Apertos <ref> [71] </ref>, meta-objects are used to achieve object heterogeneity such that changes in object behavior persist despite object migration among different meta-object spaces. The resulting required runtime checking of meta-object compatibility is too computationally expensive for applications in which configuration may be highly dynamic or short-lived.
Reference: [72] <author> H. Zhou, K. Schwan, and I. Akyildiz. </author> <title> Performance effects of information sharing in a distributed multiprocessor real-time scheduler. </title> <booktitle> In Proc. of the 1992 Real-time Systems Symposium, </booktitle> <address> Phoenix, AZ. </address> <publisher> IEEE, </publisher> <month> Dec. </month> <year> 1992. </year> <note> Also available as technical report GIT-CC-91/40. 32 </note>
Reference-contexts: For example, in complex multi-media and real-time applications, timing requirements and the components implementing the resource allocation mechanisms used to enforce these requirements are routinely separated from the applications' basic functionalities and adjusted at runtime <ref> [20, 28, 72] </ref>. Similarly, research in high performance programming and in operating systems has derived gains in performance and reliability from the dynamic configuration of multiprocessor synchronization constructs [18, 49], of network communications [34], of file systems [52], and of distributed object abstractions [10].
References-found: 72

