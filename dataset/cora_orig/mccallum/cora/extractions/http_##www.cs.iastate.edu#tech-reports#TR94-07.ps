URL: http://www.cs.iastate.edu/tech-reports/TR94-07.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Tree-based algorithm to Find the k-th Value in Distributed Systems TR94-07  
Author: Yoonsik Cheon and Johnny Wong 
Address: 226 Atanasoff Ames, IA 50011  
Affiliation: Iowa State University of Science and Technology Department of Computer Science  
Date: April 27, 1994  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> LeLann, G. </author> <title> Distributed systems | towards a formal approach. </title> <journal> Information Processing Letter, </journal> <volume> 77 </volume> <pages> 155-160, </pages> <year> 1977. </year>
Reference-contexts: We extend this problem to find the processor with the k-th largest (or smallest) value. Distributed extrema-finding in circular configuration of processors and where no processor knows the total number of participants has been extensively studied. The original solution is due to LeLann <ref> [1] </ref> who presented an algorithm that requires O (N 2 ) messages. Chang and Roberts [2] proposed an improved algorithm that requires only O (N log N ) messages on the average but, in the worst case, still requires O (N 2 ) messages. <p> Each node computes parent := sender; /* sender can be the node itself */ n := 0; if (num neighbor = 1) /* leaf? */ then send the message reply (my val) to parent parent := nil; else val <ref> [1] </ref> = my val; n := 1; for each child send the message find (k) to it; endfor endif val [1..min (k,n+m)] := merge (val [1..n],n 1 ; : : : ; n m ); n = min (k,n+m) if (num of received messages = num of children) then if (parent <p> to it; endfor endif val [1..min (k,n+m)] := merge (val [1..n],n 1 ; : : : ; n m ); n = min (k,n+m) if (num of received messages = num of children) then if (parent = myself) then found the k-th largest value, val [k]; else send reply (val <ref> [1] </ref>, : : : , val [n]) to parent; parent := nil; endif endif the k largest values in the subtree rooted by itself and passes them to its temporary parent.
Reference: [2] <author> Chang, E. and Robert, R. </author> <title> An improved algorithm for decentralized extrema-finding in circular configurations of processes. </title> <journal> Communications of the ACM, </journal> <volume> 11(5) </volume> <pages> 281-283, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: Distributed extrema-finding in circular configuration of processors and where no processor knows the total number of participants has been extensively studied. The original solution is due to LeLann [1] who presented an algorithm that requires O (N 2 ) messages. Chang and Roberts <ref> [2] </ref> proposed an improved algorithm that requires only O (N log N ) messages on the average but, in the worst case, still requires O (N 2 ) messages.
Reference: [3] <author> Hirschberg, D. and Sinclair, J. </author> <title> Decentralized extrema-finding in circular configurations of processors. </title> <journal> Communications of the ACM, </journal> <volume> 23(11) </volume> <pages> 627-628, </pages> <month> November </month> <year> 1980. </year>
Reference-contexts: Both algorithms assumed the capability of each processor to pass a message "to the left" in a global sense, i.e., the communication is unidirec tional. This condition was relaxed in <ref> [3] </ref> in that a processor can pass messages in either or both directions (i.e., bidirectional communication), giving an algorithm requiring O (N log N ) messages in the worst case.
Reference: [4] <author> Peterson, G. L. </author> <title> An O(n log n) unidirectional algorithm for the circular extrema problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(4) </volume> <pages> 758-762, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: This condition was relaxed in [3] in that a processor can pass messages in either or both directions (i.e., bidirectional communication), giving an algorithm requiring O (N log N ) messages in the worst case. Later, Peterson <ref> [4] </ref> showed that one still can achieve an O (N log N ) algorithm with unidirectional communications, which is a unidirectional simulation of an bidirectional algorithm. <p> The messages are guaranteed to be delivered by the communication network. Initially we assume that all the nodes are completely reliable, and node failures will be considered in the later section. The first algorithm is an extension to Peterson's extrema-finding algorithm <ref> [4] </ref>. It requires O (log N ) steps and each step requires O (N ) message passing, thus requiring O (N log N ) messages in total. In the second algorithm we do not require the processors to be configured in a circle. <p> The number of processors, N , is not initially known, a property known as uniformity of the algorithms. The algorithm is shown in Figure 1. It is an extension to the Peterson's extrema finding algorithm <ref> [4] </ref>. All messages are assumed to be passed only to the right. Processors are divided into two categories: active and relay. Active processors operate in phases. Relay processors just pass on any messages they receive. All processors are initially active. <p> We first extended an existing extrema-finding algorithm <ref> [4] </ref> to finding the k-th value in a circular configuration. Later, a tree-based algorithm that requires O (log N ) rounds and O (N ) messages was devised. The tree-based algorithm has a couple of interesting features.
Reference: [5] <author> Lakshman, T. and Agrawala, A. K. </author> <title> Efficient decentralized consensus protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(5):600-607, </volume> <month> May </month> <year> 1986. </year>
Reference-contexts: Later, Peterson [4] showed that one still can achieve an O (N log N ) algorithm with unidirectional communications, which is a unidirectional simulation of an bidirectional algorithm. The original problem was slightly modified in <ref> [5] </ref> in that they assumed knowledge of the number of participating processes and of the communication scheme, did not use circular configuration, and required the computation to be done within two rounds of message exchange.
Reference: [6] <author> Raymond, K. </author> <title> A tree-based algorithm for distributed mutual exclusion. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(1) </volume> <pages> 61-77, </pages> <month> January </month> <year> 1989. </year> <month> 4 </month>
Reference-contexts: In the second algorithm we do not require the processors to be configured in a circle. They can be in an arbitrary network topology. The algorithm uses a spanning tree of the computer network, and is based on the Raymond's tree algorithm for distributed mutual exclusion problem <ref> [6] </ref>. The performance of the algorithm depends on the topology of the network spanning tree used, but the average number of steps (round of message passing) is O (log N ) and the total number of messages is O (N ). <p> Therefore, the message complexity is O (N log N ). If k = 1, the algorithm become the Peterson's original algorithm. 3 Tree-Based Algorithm In this section we consider a network of arbitrary topology. The proposed algorithm is based on the Raymond's tree-based distributed mutual exclusion algorithm <ref> [6] </ref>. The nodes are assumed to be arranged in an unrooted tree structure. The tree may be either a minimal spanning tree of the actual network topology, or merely a logical structure imposed on the underlying physical network. All messages travel along the (undirected) edges of this tree. <p> In the case of recovering, it is possible for the failed node to reconstruct the lost information from node's neighbors when the node restarts. The recovering node needs to interact with only its immediate neighbors. The procedure will similar to that of Raymond's <ref> [6] </ref>. The tree-based algorithm was implemented using both the Berkeley Software Distribution (BSD) Socket Programming Interface and Remote Procedure Call (RPC).
References-found: 6

