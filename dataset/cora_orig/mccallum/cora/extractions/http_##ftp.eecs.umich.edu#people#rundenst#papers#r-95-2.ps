URL: http://ftp.eecs.umich.edu/people/rundenst/papers/r-95-2.ps
Refering-URL: http://ftp.eecs.umich.edu/people/rundenst/papers/
Root-URL: http://www.eecs.umich.edu
Email: e-mail: ygra@eecs.umich.edu, rundenst@eecs.umich.edu  
Title: A Transparent Object-Oriented Schema Change Approach Using View Evolution  
Author: Young-Gook Ra and Elke A. Rundensteiner 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Dept. of Electrical Engineering and Computer Science; Software Systems Research Lab. The University of Michigan,  
Abstract: When a database is shared by many users, updates to the database schema are almost always prohibited because there is a risk of making existing application programs obsolete when they run against the modified schema. This paper addresses the problem by integrating schema evolution with view facilities. When new requirements necessitate schema updates for a particular user, the user specifies schema changes to the personal view rather than to the shared base schema. Our view evolution approach then computes a new view schema that reflects the semantics of the desired schema change, and replaces the old view with the new one. We present algorithms that implement the set of schema evolution operations typically supported by OODB systems as view definitions. This approach provides the means for schema change without affecting other views (and thus without affecting existing application programs). The persistent data is shared by different views of the schema, i.e., both old as well as newly developed applications can continue to interoperate. In this paper, we present examples that demonstrate our approach. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Banerjee, W. Kim, and H. Kim, </author> <booktitle> "Semantics and Implementation of Schema Evolution in OODB ," in ACM SIGMOD, </booktitle> <pages> pp. 311-322, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Schema evolution is an important issue in Object-Oriented Database (OODB) research <ref> [1, 7, 8, 18, 4, 19] </ref>, not only because data models are less stable than expected [6], but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. <p> Content-based evolution utilizes a query language to restructure relevant objects based on their content rather than just performing a syntax (type)-based transformation as done by other schema evolution mechanism <ref> [1, 9, 19] </ref>. For a simple example, suppose we want to keep track of the amount of tax only for rich persons. <p> this model is however beyond the scope of this paper, and can be found elsewhere [11]. 5.3 Implementing the Add-Attribute Operator Semantics: The schema change operator defined by "add attribute x:attribute-def to C" augments the types of the class C and its subclasses C sub with the new attribute x <ref> [1] </ref>. The extents of the classes are not changed in terms of membership. However, the instance objects of the classes now have one additional attribute x. If there is a property in class C with the same name x, the operation is rejected.
Reference: [2] <author> E. Bertino, </author> <title> "A View Mechanism for Object-Oriented Databases," </title> <booktitle> in EDBT, </booktitle> <pages> pp. 136-151, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: In our approach, old tools don't have to be rewritten or even recompiled for schema evolution because the old schema is "alive" despite the schema change. The use of view mechanisms to achieve schema evolution has also been advocated by other researchers <ref> [18, 15, 2] </ref>. <p> For instance, [18] presents several examples of schema changes that can be simulated by views, without giving general algorithms and/or any implementation solutions. [15] refers to the issue of schema evolution as a potential feature but no details on how this could be achieved nor any examples are given. <ref> [2] </ref> discusses how an individual class can be modified using view specifications in place of schema modification operators but the effect of such class modifications to its subclasses is not considered. Again general algorithms for supporting all typical schema change operations are not given. <p> A recent SIGMOD record article by Tresch and Scholl [18] also advocates views as a suitable mechanism for simulating schema evolution. They state that schema evolution can be simulated using views if they are not capacity-augmenting. In addition, Bertino <ref> [2] </ref> presents a view mechanism and indicates that it can be utilized to simulate schema evolution. The proposed mechanism is capacity-augmenting in that new stored attributes can be added to a view. However, the paper focuses on the evolution of individual classes rather than the schema.
Reference: [3] <author> H. Kim, </author> <title> "Issues in OODB Schemas," in Diss., </title> <institution> Dept. of Comp. Sci., Univ. of Texas, Austin, TR-88-20, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: The new view is assigned to the user, while the old one is maintained by the system for other application programs. In TSE, unlike in other systems <ref> [4, 3] </ref>, the scope of a schema version (view) is not confined to the objects which have been created under this particular schema version. <p> Our TSE approach offers the following three advantages over conventional approaches: (1) it allows all instances to be directly shared by each schema, (2) it integrates the restructuring power of views and schema evolution, and (3) it simplifies version merging. 3.1 Instance Sharing Among Schema Versions Most schema version systems <ref> [4, 3] </ref> utilize traditional ver-sioning concepts where new versions of the schema and object instances are constructed, with every instance of the old schema being copied and converted to become an instance of the new schema version. <p> Our TSE system successfully addresses all these issues [10]. 5 Algorithms for Realizing Schema Changes in TSE 5.1 Introduction The taxonomy of base schema evolution operators first introduced by Banerjee et al. [4] for Orion has been adopted in most other schema evolution research <ref> [17, 3, 8, 7] </ref>. In fact, most commercial OODB systems such as O 2 [19] and GemStone [9] only support a subset of this taxonomy. To demonstrate the feasibility of the TSE approach, it is thus important to show that our approach can realize this set of schema change operations. <p> of T A 0 and SupportStaf f . 4 The term `extent' used in this paper is implicitly assumed to be global extent, and not local extent. 6 Related Research The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [17, 4, 3, 7] </ref>. <p> Some systems require the user to provide the exception handlers to resolve the type mismatches between the underlying object instance representation and the schema to access it [17]. Others require the user to keep track of class versions for each valid schema <ref> [3] </ref>. * flexibility to build a new schema from class versions: It refers to the capability of composing various schemas by combining class versions. * subschema evolution: It refers to the capability to confine the effect of schema evolution to a subgraph rather than propagating the effect to many, possibly unnecessary, <p> Second, the content-based derivation power of views could be exploited to support more complex schema customizations as possible with the graph manipulation operators typically supported by schema evolution. Table 1 shows the comparisons of our TSE system with other systems such as Encore [17], Orion [4], Goose <ref> [3] </ref>, CLOSQL [8] and Rose [7]. None of these other systems uses the view approach, rather they utilize more traditional versioning concepts. <p> By adopting the view mechanism as foundation for our approach, the object instances are shared by all views, independently from the order in which these view schemas were created. This removes the inconsistency caused by not allowing back propagation in the schema version approach. Kim et al. <ref> [3] </ref> propose the versioning of individual classes instead of the entire schema. A complete schema is constructed in Goose by selecting a version from each class.
Reference: [4] <author> W. Kim and H. Chou, </author> <title> "Versions of Schema For OODBs," </title> <booktitle> in Proc. 14th VLDB, </booktitle> <pages> pp. 148-159, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Schema evolution is an important issue in Object-Oriented Database (OODB) research <ref> [1, 7, 8, 18, 4, 19] </ref>, not only because data models are less stable than expected [6], but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. <p> The new view is assigned to the user, while the old one is maintained by the system for other application programs. In TSE, unlike in other systems <ref> [4, 3] </ref>, the scope of a schema version (view) is not confined to the objects which have been created under this particular schema version. <p> Our TSE approach offers the following three advantages over conventional approaches: (1) it allows all instances to be directly shared by each schema, (2) it integrates the restructuring power of views and schema evolution, and (3) it simplifies version merging. 3.1 Instance Sharing Among Schema Versions Most schema version systems <ref> [4, 3] </ref> utilize traditional ver-sioning concepts where new versions of the schema and object instances are constructed, with every instance of the old schema being copied and converted to become an instance of the new schema version. <p> This merging process is likely to be very complicated in other schema version systems <ref> [4, 17] </ref>. First, if instances have been copied for each version, all instance versions (duplicates) with the same object identity should be merged into a single instance. Second, the two separate schemas must be combined into one consistent schema, integrating also their generalization and aggregation hierarchies. <p> Our TSE system successfully addresses all these issues [10]. 5 Algorithms for Realizing Schema Changes in TSE 5.1 Introduction The taxonomy of base schema evolution operators first introduced by Banerjee et al. <ref> [4] </ref> for Orion has been adopted in most other schema evolution research [17, 3, 8, 7]. In fact, most commercial OODB systems such as O 2 [19] and GemStone [9] only support a subset of this taxonomy. <p> of T A 0 and SupportStaf f . 4 The term `extent' used in this paper is implicitly assumed to be global extent, and not local extent. 6 Related Research The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [17, 4, 3, 7] </ref>. <p> Second, the content-based derivation power of views could be exploited to support more complex schema customizations as possible with the graph manipulation operators typically supported by schema evolution. Table 1 shows the comparisons of our TSE system with other systems such as Encore [17], Orion <ref> [4] </ref>, Goose [3], CLOSQL [8] and Rose [7]. None of these other systems uses the view approach, rather they utilize more traditional versioning concepts. <p> The schema version mechanism proposed for Orion by Kim and Chou <ref> [4] </ref> keeps versions of the whole schema hierarchy instead of the individual classes or types. Every instance object of an old version schema can be copied and converted to become an instance of the new version schema.
Reference: [5] <author> H. A. Kuno and E. A. Rundensteiner, </author> <title> "Developing an Object-Oriented View Management System," </title> <booktitle> in Proceedings of CASCON, </booktitle> <pages> pp. 548-562, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: old tool Layout new tool instance1 instance2 instance3 instance4 Shared Instances Read Create Access Schema1 Schema2 add-attribute ( height, width) to Component; Write 3.2 Integrating View and Evolution Mechanisms Views allow a programmer to restructure the database to meet the specific needs of an application without affecting other application programs <ref> [5, 16, 12] </ref>. View mechanisms typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> After the execution of "de-fineVC &lt;name&gt; as &lt;query&gt;" statement, &lt;name&gt; will appear as a persistent class with its extent of the virtual class &lt;name&gt; defined by the &lt;query&gt; expression. However, like other current OO view systems that we are aware of <ref> [5, 16, 12] </ref>, the original MultiView prototype did not support capacity-augmenting views. For TSE we need views that augment the information content of a database by creating virtual classes with new stored attributes in addition to deriving data as a function of already existing data [18, 10].
Reference: [6] <author> S. Marche, </author> <title> "Measuring the Stability of Data Models," </title> <journal> European Journal of Information Systems, </journal> <volume> vol. 2, no. 1, </volume> <pages> pp. 37-47, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Schema evolution is an important issue in Object-Oriented Database (OODB) research [1, 7, 8, 18, 4, 19], not only because data models are less stable than expected <ref> [6] </ref>, but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. However, even with the schema evolution support by most OODBs, schema updates on shared OODBs are problematic.
Reference: [7] <author> A. Mehta, D. L. Spooner, and M. Hardwick, </author> <title> "Resolution of Type Mismatches in an Engineering Persistent Object System," in Techn. </title> <type> Report, </type> <institution> Computer Science Dept., Rensselaer Polytechnic Institute, </institution> <year> 1993. </year>
Reference-contexts: 1 Introduction Schema evolution is an important issue in Object-Oriented Database (OODB) research <ref> [1, 7, 8, 18, 4, 19] </ref>, not only because data models are less stable than expected [6], but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. <p> Our TSE system successfully addresses all these issues [10]. 5 Algorithms for Realizing Schema Changes in TSE 5.1 Introduction The taxonomy of base schema evolution operators first introduced by Banerjee et al. [4] for Orion has been adopted in most other schema evolution research <ref> [17, 3, 8, 7] </ref>. In fact, most commercial OODB systems such as O 2 [19] and GemStone [9] only support a subset of this taxonomy. To demonstrate the feasibility of the TSE approach, it is thus important to show that our approach can realize this set of schema change operations. <p> of T A 0 and SupportStaf f . 4 The term `extent' used in this paper is implicitly assumed to be global extent, and not local extent. 6 Related Research The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [17, 4, 3, 7] </ref>. <p> Table 1 shows the comparisons of our TSE system with other systems such as Encore [17], Orion [4], Goose [3], CLOSQL [8] and Rose <ref> [7] </ref>. None of these other systems uses the view approach, rather they utilize more traditional versioning concepts. They typically construct new versions of the schema as well as of the object instances, with instances being assigned to the schema version under which they have been created. <p> We have successfully addressed this problem using an object-slicing approach [11]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [17, 8, 7, 19, 9] </ref>. As a result, we have also shown that an object-preserving algebra, as provided by MultiView, is sufficient for supporting a comprehensive set of schema changes. This assures that the resulting view schemas are updatable [16]. In the future, we'll study the use of object-generating views.
Reference: [8] <author> S. Monk and I. Sommerville, </author> <title> "Schema Evolution in OODBs Using Class Versioning," </title> <booktitle> in SIGMOD RECORD, </booktitle> <volume> VOL. 22, NO.3, </volume> <pages> pp. 16-22, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Schema evolution is an important issue in Object-Oriented Database (OODB) research <ref> [1, 7, 8, 18, 4, 19] </ref>, not only because data models are less stable than expected [6], but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. <p> Our TSE system successfully addresses all these issues [10]. 5 Algorithms for Realizing Schema Changes in TSE 5.1 Introduction The taxonomy of base schema evolution operators first introduced by Banerjee et al. [4] for Orion has been adopted in most other schema evolution research <ref> [17, 3, 8, 7] </ref>. In fact, most commercial OODB systems such as O 2 [19] and GemStone [9] only support a subset of this taxonomy. To demonstrate the feasibility of the TSE approach, it is thus important to show that our approach can realize this set of schema change operations. <p> Second, the content-based derivation power of views could be exploited to support more complex schema customizations as possible with the graph manipulation operators typically supported by schema evolution. Table 1 shows the comparisons of our TSE system with other systems such as Encore [17], Orion [4], Goose [3], CLOSQL <ref> [8] </ref> and Rose [7]. None of these other systems uses the view approach, rather they utilize more traditional versioning concepts. They typically construct new versions of the schema as well as of the object instances, with instances being assigned to the schema version under which they have been created. <p> A complete schema is constructed in Goose by selecting a version from each class. This gives flexibility to the user in constructing many possible schemas, but it also results in the overhead of figuring out whether a given schema is consistent. The class versioning approach CLOSQL, proposed by Monk <ref> [8] </ref>, provides update/backdate functions for each attribute which convert the instances from the format in which the instance is stored to the format that an application program expects. In such a system, the user's responsibility would be great even if the system provides the default conversion functions. <p> We have successfully addressed this problem using an object-slicing approach [11]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [17, 8, 7, 19, 9] </ref>. As a result, we have also shown that an object-preserving algebra, as provided by MultiView, is sufficient for supporting a comprehensive set of schema changes. This assures that the resulting view schemas are updatable [16]. In the future, we'll study the use of object-generating views.
Reference: [9] <author> D. Penney and J. Stein, </author> <title> "Class Modification in the GemStone Object-Oriented DBMS," </title> <booktitle> in Proc. 2nd OOPSLA, </booktitle> <pages> pp. 111-117, </pages> <year> 1987. </year>
Reference-contexts: Content-based evolution utilizes a query language to restructure relevant objects based on their content rather than just performing a syntax (type)-based transformation as done by other schema evolution mechanism <ref> [1, 9, 19] </ref>. For a simple example, suppose we want to keep track of the amount of tax only for rich persons. <p> In fact, most commercial OODB systems such as O 2 [19] and GemStone <ref> [9] </ref> only support a subset of this taxonomy. To demonstrate the feasibility of the TSE approach, it is thus important to show that our approach can realize this set of schema change operations. <p> We have successfully addressed this problem using an object-slicing approach [11]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [17, 8, 7, 19, 9] </ref>. As a result, we have also shown that an object-preserving algebra, as provided by MultiView, is sufficient for supporting a comprehensive set of schema changes. This assures that the resulting view schemas are updatable [16]. In the future, we'll study the use of object-generating views.
Reference: [10] <author> Y. Ra and E. A. Rundensteiner, </author> <title> "A Transparent Object-Oriented Schema Change Approach Using View Schema Evolution," </title> <note> in Tech. Report CSE-TR-211-94, </note> <institution> Dept. of EECS, Univ. of Michigan, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Because current OODB systems do not provide such capacity-augmenting view mechanisms, we need to develop such a view system as foundation for our schema change prototype. Our TSE system successfully addresses all these issues <ref> [10] </ref>. 5 Algorithms for Realizing Schema Changes in TSE 5.1 Introduction The taxonomy of base schema evolution operators first introduced by Banerjee et al. [4] for Orion has been adopted in most other schema evolution research [17, 3, 8, 7]. <p> We have developed a complete set of translation algorithms, including proofs of correctness, for all schema change operators, which due to space limitations can be found in our technical report <ref> [10] </ref>. To the best of our knowledge, this is the first work on developing a complete set of such general algorithms. Below, we present algorithms for two representative examples. 5.2 MultiView System and its Extension for TSE We have chosen to implement TSE on top of the Multi-View system [12]. <p> For TSE we need views that augment the information content of a database by creating virtual classes with new stored attributes in addition to deriving data as a function of already existing data <ref> [18, 10] </ref>. In particular, we modify the refine operator to support stored attribute extensions (in addition to methods), i.e., to create virtual classes that effectively augment the capacity of the database by adding new stored attributes to existing classes.
Reference: [11] <author> Y. Ra, H. Kuno, and E. Rundensteiner, </author> <title> "A Flexible OODB Model and Implementations for Capacity-Augmenting Object-Oriented Views," </title> <type> in Tech. </type> <institution> Report CSE-TR-215-94,EECS Dept., Univ. of Mich., </institution> <year> 1994. </year>
Reference-contexts: Thus, the underlying system must support the flexible restructuring of object instances. We have developed an object model paradigm that addresses these two requirements of multiple classification and flexible restructuring. A treatment of this model is however beyond the scope of this paper, and can be found elsewhere <ref> [11] </ref>. 5.3 Implementing the Add-Attribute Operator Semantics: The schema change operator defined by "add attribute x:attribute-def to C" augments the types of the class C and its subclasses C sub with the new attribute x [1]. The extents of the classes are not changed in terms of membership. <p> We have identified multiple classification as a key feature required of capacity-augmenting view systems in order to support schema evolution a feature not provided by current OODB systems. We have successfully addressed this problem using an object-slicing approach <ref> [11] </ref>. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs [17, 8, 7, 19, 9].
Reference: [12] <author> E. A. Rundensteiner, </author> <title> "MultiView: A Methodology for Supporting Multiple View Schemata in OODBs," </title> <booktitle> in 18th VLDB, </booktitle> <pages> pp. 187-198, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: It renames the Student' and TA' classes to Student and TA within the context of the view, respectively. Fourth, a new view schema VS2 is generated from the selected classes by running the schema generation algorithm <ref> [12] </ref>. At last, the system replaces the old view with the newly generated view. Note that the above algorithm runs in the context of a view, so it only creates virtual classes for all subclasses of a class C within a view. <p> old tool Layout new tool instance1 instance2 instance3 instance4 Shared Instances Read Create Access Schema1 Schema2 add-attribute ( height, width) to Component; Write 3.2 Integrating View and Evolution Mechanisms Views allow a programmer to restructure the database to meet the specific needs of an application without affecting other application programs <ref> [5, 16, 12] </ref>. View mechanisms typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> To the best of our knowledge, this is the first work on developing a complete set of such general algorithms. Below, we present algorithms for two representative examples. 5.2 MultiView System and its Extension for TSE We have chosen to implement TSE on top of the Multi-View system <ref> [12] </ref>. Unlike most other OO view mechanisms, MultiView creates a complete view schema rather than just deriving individual virtual classes. <p> Since TSE is built using MultiView, we utilize Multi-View's view definition language, an object algebra <ref> [12, 13] </ref>, as foundation of our TSE system. TSE requires only a subset of Multiview's algebra operators namely hide, difference, union and refine [14]. MultiView allows arbitrary queries composed by nesting these object algebra operators to serve as view definitions. <p> After the execution of "de-fineVC &lt;name&gt; as &lt;query&gt;" statement, &lt;name&gt; will appear as a persistent class with its extent of the virtual class &lt;name&gt; defined by the &lt;query&gt; expression. However, like other current OO view systems that we are aware of <ref> [5, 16, 12] </ref>, the original MultiView prototype did not support capacity-augmenting views. For TSE we need views that augment the information content of a database by creating virtual classes with new stored attributes in addition to deriving data as a function of already existing data [18, 10]. <p> It then renames the Student' and TA' classes to Student and TA within the context of VS2, respectively. Finally, generalization edges are generated by View Schema Generator for the classes selected for VS2 <ref> [12] </ref>. At last, the system replaces the old view VS1 with the newly generated view VS2. 3 The algorithm names each virtual class by appending a prime to the name of their corresponding original class. <p> In addition, by associating all objects with a single underlying schema, we solve the problem of sharing the persistent objects among all versions of the schema | independently from the schema version under which they were created. To support the view technology required for our approach, MultiView <ref> [12] </ref> is chosen because it generates up-datable views and complete view schemas rather than individual view classes. We have made several extensions to MultiView to support view evolution, in particular, we added capacity-augmenting capabilities.
Reference: [13] <author> E. A. Rundensteiner, </author> <title> "A Classification Algorithm For Supporting Consistent Object Views," </title> <booktitle> in CIKM, </booktitle> <year> 1994. </year>
Reference-contexts: The dashed ellipses represent virtual classes, whereas the solid ellipses represent base classes. Second, the two virtual classes are integrated into the global schema by the classification algorithm of our view system (Figure 2 (d)) <ref> [13] </ref>. Third, the system selects the classes Person, Student' and TA' for the new view. It renames the Student' and TA' classes to Student and TA within the context of the view, respectively. <p> Thus, the merging of object instances is by design taken care of by our system. The integration of two schemas into one is also automatically achieved in our system, since the classification algorithm integrates all virtual classes into one consistent global schema graph <ref> [13] </ref>. In our system, it is thus straightforward to determine based on the global schema whether the same named classes are really identical. Similarly, differently named classes of separate schemas are easily found to be identical if they are identical in the global schema. versions. <p> Since TSE is built using MultiView, we utilize Multi-View's view definition language, an object algebra <ref> [12, 13] </ref>, as foundation of our TSE system. TSE requires only a subset of Multiview's algebra operators namely hide, difference, union and refine [14]. MultiView allows arbitrary queries composed by nesting these object algebra operators to serve as view definitions.
Reference: [14] <author> E. A. Rundensteiner and L. Bic, </author> <title> "Set Operations in Object-Based Data Models," </title> <journal> IEEE Trans. on Data and Knowledge Engineering, </journal> <pages> pp. 382-398, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Since TSE is built using MultiView, we utilize Multi-View's view definition language, an object algebra [12, 13], as foundation of our TSE system. TSE requires only a subset of Multiview's algebra operators namely hide, difference, union and refine <ref> [14] </ref>. MultiView allows arbitrary queries composed by nesting these object algebra operators to serve as view definitions. After the execution of "de-fineVC &lt;name&gt; as &lt;query&gt;" statement, &lt;name&gt; will appear as a persistent class with its extent of the virtual class &lt;name&gt; defined by the &lt;query&gt; expression.
Reference: [15] <author> C. S. Santos, S. Abiteboul, and C. Delobel, </author> <title> "Virtual Schema and Bases," </title> <booktitle> in EDBT, </booktitle> <year> 1994. </year>
Reference-contexts: In our approach, old tools don't have to be rewritten or even recompiled for schema evolution because the old schema is "alive" despite the schema change. The use of view mechanisms to achieve schema evolution has also been advocated by other researchers <ref> [18, 15, 2] </ref>. <p> The use of view mechanisms to achieve schema evolution has also been advocated by other researchers [18, 15, 2]. For instance, [18] presents several examples of schema changes that can be simulated by views, without giving general algorithms and/or any implementation solutions. <ref> [15] </ref> refers to the issue of schema evolution as a potential feature but no details on how this could be achieved nor any examples are given. [2] discusses how an individual class can be modified using view specifications in place of schema modification operators but the effect of such class modifications
Reference: [16] <author> M. Scholl and C. Laasch, </author> <title> "Updatable views in OODBs," </title> <booktitle> in DOOD, </booktitle> <pages> pp. 1-19, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: old tool Layout new tool instance1 instance2 instance3 instance4 Shared Instances Read Create Access Schema1 Schema2 add-attribute ( height, width) to Component; Write 3.2 Integrating View and Evolution Mechanisms Views allow a programmer to restructure the database to meet the specific needs of an application without affecting other application programs <ref> [5, 16, 12] </ref>. View mechanisms typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> After the execution of "de-fineVC &lt;name&gt; as &lt;query&gt;" statement, &lt;name&gt; will appear as a persistent class with its extent of the virtual class &lt;name&gt; defined by the &lt;query&gt; expression. However, like other current OO view systems that we are aware of <ref> [5, 16, 12] </ref>, the original MultiView prototype did not support capacity-augmenting views. For TSE we need views that augment the information content of a database by creating virtual classes with new stored attributes in addition to deriving data as a function of already existing data [18, 10]. <p> As a result, we have also shown that an object-preserving algebra, as provided by MultiView, is sufficient for supporting a comprehensive set of schema changes. This assures that the resulting view schemas are updatable <ref> [16] </ref>. In the future, we'll study the use of object-generating views. We also want to develop optimization strategies for update propagation through virtual classes in TSE. Acknowledgements: We thank Harumi A. Kuno, who has implemented the initial MultiView prototype as well as Mul-tiView 2 based on object-slicing, for her help.
Reference: [17] <author> A. H. Skarra and S. B. Zdonik, </author> <title> "The Management of Changing Types in an Object-Oriented Database," </title> <booktitle> in Proc. 1st OOPSLA, </booktitle> <pages> pp. 483-494, </pages> <year> 1986. </year>
Reference-contexts: This merging process is likely to be very complicated in other schema version systems <ref> [4, 17] </ref>. First, if instances have been copied for each version, all instance versions (duplicates) with the same object identity should be merged into a single instance. Second, the two separate schemas must be combined into one consistent schema, integrating also their generalization and aggregation hierarchies. <p> Our TSE system successfully addresses all these issues [10]. 5 Algorithms for Realizing Schema Changes in TSE 5.1 Introduction The taxonomy of base schema evolution operators first introduced by Banerjee et al. [4] for Orion has been adopted in most other schema evolution research <ref> [17, 3, 8, 7] </ref>. In fact, most commercial OODB systems such as O 2 [19] and GemStone [9] only support a subset of this taxonomy. To demonstrate the feasibility of the TSE approach, it is thus important to show that our approach can realize this set of schema change operations. <p> of T A 0 and SupportStaf f . 4 The term `extent' used in this paper is implicitly assumed to be global extent, and not local extent. 6 Related Research The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [17, 4, 3, 7] </ref>. <p> Some systems require the user to provide the exception handlers to resolve the type mismatches between the underlying object instance representation and the schema to access it <ref> [17] </ref>. <p> Second, the content-based derivation power of views could be exploited to support more complex schema customizations as possible with the graph manipulation operators typically supported by schema evolution. Table 1 shows the comparisons of our TSE system with other systems such as Encore <ref> [17] </ref>, Orion [4], Goose [3], CLOSQL [8] and Rose [7]. None of these other systems uses the view approach, rather they utilize more traditional versioning concepts. <p> To the best of our knowledge, other schema evolution database systems have not addressed this issue. Zdonik et al.'s approach towards type changes in the Encore System <ref> [17] </ref> is to keep different versions of each type, and to bind objects to a specific version of the type. Objects of different versions can be accessed by providing exception handlers for the properties that the types of the object instances do not contain. <p> We have successfully addressed this problem using an object-slicing approach [11]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [17, 8, 7, 19, 9] </ref>. As a result, we have also shown that an object-preserving algebra, as provided by MultiView, is sufficient for supporting a comprehensive set of schema changes. This assures that the resulting view schemas are updatable [16]. In the future, we'll study the use of object-generating views.
Reference: [18] <author> M. Tresch and M. H. Scholl, </author> <title> "Schema Transformation without Database Reorganization," </title> <booktitle> in SIGMOD RECORD, </booktitle> <pages> pp. 21-27, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Schema evolution is an important issue in Object-Oriented Database (OODB) research <ref> [1, 7, 8, 18, 4, 19] </ref>, not only because data models are less stable than expected [6], but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. <p> In our approach, old tools don't have to be rewritten or even recompiled for schema evolution because the old schema is "alive" despite the schema change. The use of view mechanisms to achieve schema evolution has also been advocated by other researchers <ref> [18, 15, 2] </ref>. <p> In our approach, old tools don't have to be rewritten or even recompiled for schema evolution because the old schema is "alive" despite the schema change. The use of view mechanisms to achieve schema evolution has also been advocated by other researchers [18, 15, 2]. For instance, <ref> [18] </ref> presents several examples of schema changes that can be simulated by views, without giving general algorithms and/or any implementation solutions. [15] refers to the issue of schema evolution as a potential feature but no details on how this could be achieved nor any examples are given. [2] discusses how an <p> For TSE we need views that augment the information content of a database by creating virtual classes with new stored attributes in addition to deriving data as a function of already existing data <ref> [18, 10] </ref>. In particular, we modify the refine operator to support stored attribute extensions (in addition to methods), i.e., to create virtual classes that effectively augment the capacity of the database by adding new stored attributes to existing classes. <p> In addition, the computation time for conversion might be a significant overhead. Extensions for handling new stored attributes appear not to have been dealt with. A recent SIGMOD record article by Tresch and Scholl <ref> [18] </ref> also advocates views as a suitable mechanism for simulating schema evolution. They state that schema evolution can be simulated using views if they are not capacity-augmenting. In addition, Bertino [2] presents a view mechanism and indicates that it can be utilized to simulate schema evolution.
Reference: [19] <author> R. Zicari, </author> <title> "A Framework for O 2 Schema Updates," </title> <booktitle> in Int. Conf. on Data Eng., </booktitle> <pages> pp. 146-182, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Schema evolution is an important issue in Object-Oriented Database (OODB) research <ref> [1, 7, 8, 18, 4, 19] </ref>, not only because data models are less stable than expected [6], but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. <p> Content-based evolution utilizes a query language to restructure relevant objects based on their content rather than just performing a syntax (type)-based transformation as done by other schema evolution mechanism <ref> [1, 9, 19] </ref>. For a simple example, suppose we want to keep track of the amount of tax only for rich persons. <p> In fact, most commercial OODB systems such as O 2 <ref> [19] </ref> and GemStone [9] only support a subset of this taxonomy. To demonstrate the feasibility of the TSE approach, it is thus important to show that our approach can realize this set of schema change operations. <p> We have successfully addressed this problem using an object-slicing approach [11]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [17, 8, 7, 19, 9] </ref>. As a result, we have also shown that an object-preserving algebra, as provided by MultiView, is sufficient for supporting a comprehensive set of schema changes. This assures that the resulting view schemas are updatable [16]. In the future, we'll study the use of object-generating views.
References-found: 19

