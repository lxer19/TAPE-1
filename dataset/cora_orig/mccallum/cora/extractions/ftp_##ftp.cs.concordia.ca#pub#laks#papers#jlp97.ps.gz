URL: ftp://ftp.cs.concordia.ca/pub/laks/papers/jlp97.ps.gz
Refering-URL: http://www.cs.concordia.ca/~faculty/laks/papers.html
Root-URL: http://www.cs.concordia.ca
Email: laks@cs.concordia.ca  sadri@uncg.edu  subbu@cs.concordia.ca  
Phone: 2  3  
Title: LOGIC AND ALGEBRAIC LANGUAGES FOR INTEROPERABILITY IN MULTIDATABASE SYSTEMS  
Author: LAKS V.S. LAKSHMANAN FEREIDOON SADRI AND IYER N. SUBRAMANIAN 
Affiliation: Department of Mathematical Sciences, University of North Carolina at  Department of Computer Science, Concordia University,  Sciences and Engineering Research Council of Canada and the Fonds Pour Formation De Chercheurs Et L'Aide A La Recherche of  
Address: Montreal, Canada,  Greensboro, Greensboro, NC, USA,  Montreal, Canada,  Quebec.  
Date: 101-149, November 1997.  
Note: Appears in Journal of Logic Programming 33(2), pp.  This research was supported in part by grants from the Natural  
Abstract: Developing a declarative approach to interoperability in the context of multidatabase systems is a major goal of this research. We take a first step toward this goal in this paper, by developing a simple logic called SchemaLog which is syntactically higher-order but has a first-order semantics. SchemaLog can provide for interoperability among multiple relational databases in a federation of database systems. We develop a fixpoint theory for the definite clause fragment of SchemaLog and show its equivalence to the model-theoretic semantics. We also develop a sound and complete proof procedure for all clausal theories. We establish the correspondence between SchemaLog and first-order predicate calculus and provide a reduction of SchemaLog to predicate calculus. We propose an extension to classical relational algebra, capable of retrieving and manipulating data and schema from databases in a multidatabase system, and prove its equivalence to a form of relational calculus inspired by SchemaLog syntax. We 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Abiteboul, S. and Grumbach, S. Col: </author> <title> A Logic-based Language for Complex Objects. </title> <booktitle> In Proc. of Workshop on Database Programming Languages, </booktitle> <pages> pages 253-276, </pages> <year> 1987. </year>
Reference-contexts: This paper also illustrates a template mechanism to define the database schema. But it is not obvious how to extend this language to a framework which would support queries over higher-order objects across multiple databases. COL: Abiteboul and Grumbach <ref> [1] </ref> introduce a logic called COL for defining and manipulating complex objects. COL achieves the functionality for manipulating complex objects by introducing what are called (base and derived) "data functions". The syntax as well as the semantics of COL is higher-order.
Reference: 2. <institution> ACM Computing Surveys, </institution> <month> 22(3), Sept </month> <year> 1990. </year> <note> Special issue on HDBS. 45 </note>
Reference-contexts: Multidatabase systems are also referred to as Heterogeneous Database Systems (HDBS) and Federated Database Systems (FDBS) by different authors. The reader is referred to <ref> [2] </ref> (in particular, see Sheth and Larson [48], Litwin, Mark, and Roussopoulos [37]), Hsiao [19], and [20] for surveys in the field. One basic functionality MDBS should feature is interoperability. Interoperability can be defined as the ability to uniformly share, interpret, and manipulate information across component databases in an MDBS.
Reference: 3. <editor> ACM. </editor> <booktitle> ACM Transactions on Database Systems, </booktitle> <volume> volume 19, </volume> <month> June </month> <year> 1994. </year>
Reference-contexts: In the following, we survey representative works in both of these approaches. For a comprehensive survey of related literature, the reader is referred to [37] and <ref> [3] </ref>. Common data model: The databases participating in the federation are mapped to a common data model (CDM) (such as the object-oriented model, that naturally meets the CDM requirements in terms of richness of modeling power) which acts as an `interpreter' among them.
Reference: 4. <author> Ahmed, R., DeSmedt, P., Kent, W., Ketabchi, M., Litwin, W., Rafii, A., and Shan, </author> <title> M.C. Pegasus: A System for Seamless Integration of Heterogeneous Information Sources. </title> <booktitle> In IEEE COMPCON, </booktitle> <pages> pages 128-135, </pages> <year> 1991. </year>
Reference: 5. <author> Ahmed, R., Smedt, P., Du, W., Kent, W., Ketabchi, A., and Litwin, W. </author> <title> The Pegasus Heterogeneous Multidatabase System. </title> <booktitle> IEEE Computer, </booktitle> <month> December </month> <year> 1991. </year>
Reference-contexts: of the participating databases are defined on the CDM, thus providing the user with a convenient illusion that all the information she gets is from her own database. (This is called tight coupling [48].) A "canonical" example of the CDM based approach is the Pegasus project of Ahmed et. al. <ref> [5] </ref>. Pegasus defines a common object model for unifying the data models of the underlying systems. Landers and Rosenberg use the functional model of DAPLEX as the CDM in their Multibase project [32].
Reference: 6. <author> Asirelli, P., Renso, C., and Turini, F. </author> <title> Language Extensions for Semantic Integration of Deductive Databases. </title> <booktitle> In Proc. Intl. Workshop on Logic in Databases (LID'96), </booktitle> <pages> pages 425-444, </pages> <address> Pisa, Italy, </address> <month> July </month> <year> 1996. </year>
Reference: 7. <author> Barsalou, T. and Gangopadhyay, D. </author> <title> An Open Framework for Interoperation of Multimodel Multidatabase Systems. </title> <booktitle> In IEEE Data Engg., </booktitle> <year> 1992. </year>
Reference-contexts: However, they do not provide a formal model-theoretic or proof-theoretic semantics for their language, and their language is not a full-fledged logic. An approach that falls in between the above two classifications is the M (DM) model of Barsalou and Gangopadhyay <ref> [7] </ref>. M (DM) deals with a set of metatypes that formalize data model constructs in second-order logic. A data model is hence a collection of M (DM) metatypes. A schema instantiates these metatypes into a set of first-order types. A database then consists of instances of the schema types. <p> In <ref> [7] </ref>, although the combination of logic, object orientation, and metaprogramming gives much power to the M (DM) model, its second-order nature raises questions about the possibility of practical implementations based on this approach. Also, its semantics is quite complex.
Reference: 8. <author> Carey, M., DeWitt, D., Richardson, J., and Shekita, E. </author> <title> Object and File Management in the Exodus Extensible Database System. </title> <booktitle> In Proc. Intl. Conf. on Very Large Databases, </booktitle> <year> 1986. </year>
Reference-contexts: Details of this implementation are discussed in [31, 43]. As demonstrated in this implementation, the simplicity of SchemaLog has resulted in an elegant design, and in its easy realization even within the framework of current relational database systems. Our ongoing work involves using the database storage manager EXODUS <ref> [8] </ref> for storing the output of Phase 1. We expect this to yield a significant gain in performance, as CORAL has a direct interface to EXODUS for storing and manipulating persistent relations.
Reference: 9. <author> Chang, C.L. and Lee, R.C.T. </author> <title> Symbolic Logic and Mechanical Theorem Proving. </title> <address> New York, </address> <publisher> Academic Press, </publisher> <year> 1973. </year>
Reference-contexts: This transformation is along the lines of the one used in predicate calculus. An algorithm for this transformation can be found in Chang and Lee <ref> [9] </ref> and can be easily adapted for SchemaLog. Skolemization is the process of eliminating the existential quantifiers in a formula by replacing them with suitable functions (called Skolem functions). The intuition behind Skolemization is the following. <p> The authors of HiLog get around this difficulty by using an unused arity of one of the old symbols to represent the Skolem function. (See [12] for the details.) For SchemaLog, since Skolemization works in a manner identical to that of predicate calculus, we refer the reader to <ref> [9] </ref> for the details. 5.2.2. Herbrand's Theorem By virtue of Skolemization, without loss of generality, we can restrict our attention to formulas in prenex normal form which are universally quantified. By transforming such formulas into conjunctive normal form, we can obtain SchemaLog formulas that are in Clausal form. <p> A set of clauses S is unsatisfiable iff it is false with respect to all Herbrand structures. Proof. If S is satisfiable, then Proposition 5.1 shows that it has a Herbrand model. 2 Following Chang and Lee <ref> [9] </ref>, we next introduce the notion of a semantic tree. As in the classical case, we shall use semantic trees to establish the strong version of Herbrand's Theorem (see Theorem 5.2 below) for SchemaLog, as well as to prove the completeness of our proof procedure. <p> Theorem 5.2. (Herbrand's Theorem) A set S of wffs in clausal form is unsatisfiable iff every complete semantic tree T for S has a finite closed subtree. Note that just as in the classical case <ref> [9] </ref>, we get as an easy consequence of Theorem 5.2 that a set S of clauses is unsatisfiable if and only if some finite subset of the ground instances of S is. 5.2.3. Unification Unification in SchemaLog has to be treated differently from the way it is done conventionally. <p> The proof for the following lemma (given in Appendix A.2), and the proof for completeness theorem that follows, both closely follow the proofs of corresponding results for predicate calculus <ref> [9] </ref>. In both cases, we provide the major steps and ideas involved in the proof; other details are analogous to those in [9]. Lemma 5.4. <p> proof for the following lemma (given in Appendix A.2), and the proof for completeness theorem that follows, both closely follow the proofs of corresponding results for predicate calculus <ref> [9] </ref>. In both cases, we provide the major steps and ideas involved in the proof; other details are analogous to those in [9]. Lemma 5.4.
Reference: 10. <author> Chawathe, S., Garcia-Molina, H., Hammer, H., Ireland, K., Papakonstantinou, Y., Ullman, J.D., and Widom, J. </author> <title> The TSIMMIS Project: Integration of Heterogeneous Information Sources. </title> <booktitle> In Proc. of IPSJ, </booktitle> <address> Tokyo, Japan, </address> <year> 1994. </year>
Reference: 11. <author> Chen, W., Kifer, M., and Warren, </author> <title> D.S. Hilog As a Platform for Database Language. </title> <booktitle> In 2nd Intl. Workshop on Database Programming Languages, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: HiLog also blurs the distinction between the atoms and terms. Thus, the language has a powerful syntactic expressivity and finds natural applications in numerous contexts (see [12] for details). HiLog has a sound and complete proof theory. <ref> [11] </ref> discusses the applicability of HiLog as a database programming language. The higher-order syntactic features of the language find interesting applications for schema browsing, set operations, and as an implementation vehicle for object-oriented languages.
Reference: 12. <author> Chen, W., Kifer, M., and Warren, </author> <title> D.S. A Foundation for Higher-order Logic Programming. </title> <type> Technical report, </type> <institution> SUNY at Stony Brook, </institution> <year> 1990. </year> <note> (Preliminary versions appear in Proc. 2nd Intl. Workshop on DBPL, 1989 and Proc. NACLP 1989.). </note>
Reference-contexts: Thus, unlike their language, SchemaLog is a full-fledged logic. Besides, technically the framework developed by us is different from that of [26]. * We propose a proof procedure for full clausal SchemaLog and show that it is sound and complete (Section 5.2). * SchemaLog, like HiLog (Chen et. al. <ref> [12] </ref>), is syntactically higher-order but semantically first-order. We give a reduction of SchemaLog to first-order predicate calculus (Section 4). This reduction yields the technical benefits of soundness, completeness, and compactness for SchemaLog. <p> There, a new symbol chosen to represent a Skolem function must be assigned a new intension, which may not always be possible. The authors of HiLog get around this difficulty by using an unused arity of one of the old symbols to represent the Skolem function. (See <ref> [12] </ref> for the details.) For SchemaLog, since Skolemization works in a manner identical to that of predicate calculus, we refer the reader to [9] for the details. 5.2.2. <p> Yet its higher-order syntax gives it sufficient power to express complex queries in a natural way thus bringing programming closer to intuition. For instance let us take a look at the following example query adopted from <ref> [12] </ref>. (Q 3 ) "Find the names of all the binary relations in which the token `john' appears." 30 This query can be expressed in HiLog, the following way 10 : relations (Y )(X) X (Y; Z) relations (Z)(X) X (Y; Z) ? relations (john)(X) Now, consider a variant of Q <p> In [30], we develop a language called SchemaSQL, drawing on the inspiration from the SchemaLog experience. We also illustrate the usefulness of SchemaSQL for OLAP applications. 8. COMPARISON WITH OTHER LOGICS The notion of "higher-orderness" associated with a logic is ill-defined. Chen et. al. <ref> [12] </ref> point this out and provide a clear classification of logics based on the order of their syntax and semantics. It is generally believed that higher-order syntax would be quite useful in the context of object-oriented databases, database programming, and schema integration. <p> In this section, we compare SchemaLog with existing higher-order logics. We also comment on the "design decisions" made in the development of SchemaLog. HiLog: HiLog (Chen et. al. <ref> [12] </ref>) is a powerful logic based on higher-order syntax but with a first-order semantics. Parameters are arityless in this language and the distinction between predicate, function, and constant symbols is eliminated. HiLog terms could be constructed from any logical symbol followed by any finite number of arguments. <p> HiLog terms could be constructed from any logical symbol followed by any finite number of arguments. HiLog also blurs the distinction between the atoms and terms. Thus, the language has a powerful syntactic expressivity and finds natural applications in numerous contexts (see <ref> [12] </ref> for details). HiLog has a sound and complete proof theory. [11] discusses the applicability of HiLog as a database programming language. The higher-order syntactic features of the language find interesting applications for schema browsing, set operations, and as an implementation vehicle for object-oriented languages.
Reference: 13. <author> Chomicki, J. and Litwin, W. </author> <title> Declarative Definition of Object-oriented Multi-database Mappings. In Ozsu, M.T, Dayal, U, and Valduriez, P, editors, Distributed Object Management. </title> <editor> M. </editor> <publisher> Kaufmann Publishers, </publisher> <address> Los Altos, California, </address> <year> 1993. </year>
Reference-contexts: This severely limits the schema browsing capabilities from the user interface. Approaches that base interoperability on higher-order mappings among component databases ([13, 34]) do not provide support for ad-hoc queries that refer to (and possibly compare) data and schema components of multiple databases in one shot. <ref> [13] </ref> and [46] do not provide a uniform syntax for multiple databases in a manner that glosses over their schematic discrepancies.
Reference: 14. <author> Codd, E.F., Codd, </author> <title> S.B., and Salley C.T. Providing OLAP (On-Line Analytical Processing) to User-Analysts: An IT Mandate, </title> <note> 1995. White paper - URL:http://www.arborsoft.com/papers/coddTOC.html. </note>
Reference: 15. <author> Cuppens, F. and Demolombe, R. </author> <title> Cooperative Answering: A Methodology to Provide Intelligent Access to Databases. </title> <booktitle> In Second Intl. conf. on Expert Database Systems, </booktitle> <year> 1988. </year>
Reference-contexts: We also consider the aspect of CQA, concerned with answering queries in data/knowledge-base systems by extending the scope of the query so that more information can be gathered in the answers, as discussed in Cuppens and Demolombe <ref> [15] </ref>. Responses can be generated by looking for details that are related to the original answers, but are not themselves literal answers of the original query. Consider the application of schema evolution discussed in the previous section.
Reference: 16. <author> Dobbie, Gillian. </author> <title> Foundations of Deductive Object-oriented Database Systems. </title> <type> Phd Dissertation, </type> <institution> Research Report, University of Melbourne, </institution> <address> Parkville, Australia, </address> <month> March </month> <year> 1995. </year>
Reference: 17. <author> Gaasterland, T., Godfrey, P., and Minker, J. </author> <title> An Overview of Cooperative Answering. </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 1 </volume> <pages> 123-157., </pages> <year> 1992. </year>
Reference-contexts: An overview of the work done in this area can be found in Gaasterland et. al <ref> [17] </ref>. We also consider the aspect of CQA, concerned with answering queries in data/knowledge-base systems by extending the scope of the query so that more information can be gathered in the answers, as discussed in Cuppens and Demolombe [15].
Reference: 18. <author> Gyssens, Marc, Lakshmanan, L.V.S., and Subramanian, I. N. </author> <title> Tables As a Paradigm for Querying and Restructuring. </title> <booktitle> In Proc. ACM Symposium on Principles of Database Systems (PODS), </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: The dynamic restructuring and horizontal or block aggregation capabilities offered by the flexible syntax of SchemaLog indicate that SchemaLog can be used to develop a theoretical foundation for OLAP (On-Line Analytical Processing) ([14]), a fledgling technology with tremendous practical potential, lacking clear foundations. Indeed, in <ref> [18] </ref>, we show that the querying and restructuring capabilities of SchemaLog can be visualized in terms of four fundamental restructuring algebraic operators, augmented by classical algebraic operators.
Reference: 19. <author> Hsiao, D.K. </author> <title> Federated Databases and Systems: Part-One ATutorial on Their Data Sharing. </title> <journal> VLDB Journal, </journal> <volume> 1 </volume> <pages> 127-179, </pages> <year> 1992. </year>
Reference-contexts: Multidatabase systems are also referred to as Heterogeneous Database Systems (HDBS) and Federated Database Systems (FDBS) by different authors. The reader is referred to [2] (in particular, see Sheth and Larson [48], Litwin, Mark, and Roussopoulos [37]), Hsiao <ref> [19] </ref>, and [20] for surveys in the field. One basic functionality MDBS should feature is interoperability. Interoperability can be defined as the ability to uniformly share, interpret, and manipulate information across component databases in an MDBS.
Reference: 20. <author> Hurson, A.R., Bright, M.W., and Pakzad, S. </author> <title> Multidatabase Systems : An Advanced Solution For Global Information Sharing. </title> <publisher> IEEE Computer Society, Los Alamitos, </publisher> <address> CA, </address> <year> 1994. </year> <title> Collection of Papers. </title>
Reference-contexts: Multidatabase systems are also referred to as Heterogeneous Database Systems (HDBS) and Federated Database Systems (FDBS) by different authors. The reader is referred to [2] (in particular, see Sheth and Larson [48], Litwin, Mark, and Roussopoulos [37]), Hsiao [19], and <ref> [20] </ref> for surveys in the field. One basic functionality MDBS should feature is interoperability. Interoperability can be defined as the ability to uniformly share, interpret, and manipulate information across component databases in an MDBS.
Reference: 21. <author> Kifer M., Lausen G., and Wu J. </author> <title> Logical Foundations for Object-oriented and Frame-based Languages. </title> <journal> Journal of ACM, </journal> <month> May </month> <year> 1995. </year> <type> (Tech. Rep., </type> <institution> SUNY Stony Brook, </institution> <year> 1990). </year>
Reference-contexts: The major advantage associated with such approaches is the declarativity they derive from their logical foundations. 5 Lefebvre, Bernus, and Topor [34] use F-logic (Kifer et. al. <ref> [21] </ref>), to provide data mappings between local databases and an assumed global database (that is an integrated view of the local databases). The mappings take care of the data as well as the schema discrepancies in the local databases. <p> In spirit, this is similar to the molecules in F-logic <ref> [21] </ref>. A literal is an atom or the negation of an atom. <p> Definition 5.9. A unifier of literal L i to literal L j is a substitution such that L j 5 The directionality associated with unification also arises in F-logic <ref> [21] </ref> but for a different reason: a molecule with fewer components may be unified to one with more components. This feature is present in SchemaLog as well, at the molecular level. <p> Hence HiLog (without further extensions) seems to be unsuitable for the purpose of interoperability. 41 F-logic: Kifer et. al. <ref> [21] </ref> provide a logical foundation for object-oriented databases using a logic called F-logic. Like HiLog, F-logic is a logic with a higher-order syntax but a first-order semantics 15 . The logic is powerful enough to capture the object-oriented notions of complex objects, classes, types, methods, and inheritance.
Reference: 22. <author> Kifer, M. and Li, A. </author> <title> On the Semantics of Rule-based Expert Systems with Uncertainty. </title> <editor> In M. Gyssens, J. Paradaens, and D. van Gucht, editors, </editor> <booktitle> 2nd Intl. Conf. on Database Theory, </booktitle> <pages> pages 102-117, </pages> <address> Bruges, Belgium, </address> <note> August 31-September 2 1988. Springer-Verlag LNCS-326. 46 </note>
Reference-contexts: The syntax does not support the constructs necessary for interoperability. Approach based on Annotated logic: In recent work, Subrahmanian [50] has studied the problem of integrating multiple deductive databases featuring inconsistencies, uncertainties, and non-monotonic forms of negation. He proposes an approach based on annotated logics ([49], <ref> [22] </ref>, [23]) for realizing a "mediator" between the component knowledge-bases. We observe that the contribution of this paper neatly complements that of SchemaLog for data integration, in that SchemaLog helps resolve conflicts arising from data/meta-data interplay whereas Subrahma-nian's framework allows to handle inconsistencies between (the data in) component databases.
Reference: 23. <author> Kifer, Michael and Subrahmanian, </author> <title> V.S. Theory of Generalized Annotated Logic Programming and Its Applications. </title> <journal> Journal of Logic Programming, </journal> <volume> 12 </volume> <pages> 335-367, </pages> <year> 1992. </year>
Reference-contexts: The syntax does not support the constructs necessary for interoperability. Approach based on Annotated logic: In recent work, Subrahmanian [50] has studied the problem of integrating multiple deductive databases featuring inconsistencies, uncertainties, and non-monotonic forms of negation. He proposes an approach based on annotated logics ([49], [22], <ref> [23] </ref>) for realizing a "mediator" between the component knowledge-bases. We observe that the contribution of this paper neatly complements that of SchemaLog for data integration, in that SchemaLog helps resolve conflicts arising from data/meta-data interplay whereas Subrahma-nian's framework allows to handle inconsistencies between (the data in) component databases.
Reference: 24. <author> Kim, Won. </author> <title> Introduction to Object Oriented Databases. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Schema Evolution Schema Evolution is the process of assisting and maintaining the changes to the schematic information and contents of a database. It is a somewhat abused term in the database field, in that it has been interpreted to mean different things by different researchers. While Kim <ref> [24] </ref> treats versioning of schema for object management as schema evolution, Nguyen and Rieu [41] considers the various schema change operations and the associated consequences as being its main issues.
Reference: 25. <author> Krishnamurthy, R., Litwin, W., and Kent, W. </author> <title> Language Features for Interoperability of Databases With Schematic Discrepancies. </title> <booktitle> In ACM SIGMOD Intl. Conference on Management of Data, </booktitle> <pages> pages 40-49, </pages> <year> 1991. </year>
Reference-contexts: Krishnamurthy and Naqvi [26] propose a Horn-clause like language that can "range over" both data and meta-data by allowing "higher-order" variables. Krishnamurthy, Litwin, and Kent <ref> [25] </ref> extend this language and demonstrate its capability for interoperability. However, they do not provide a formal model-theoretic or proof-theoretic semantics for their language, and their language is not a full-fledged logic.
Reference: 26. <author> Krishnamurthy, R. and Naqvi, S. </author> <title> Towards a Real Horn Clause Language. </title> <booktitle> In Proc. 14th VLDB Conf., </booktitle> <pages> pages 252-263, </pages> <year> 1988. </year>
Reference-contexts: Global queries are translated into the local ones via a query translation algorithm, also written in F-logic. The major strength of this approach is that using a declarative medium to provide mapping as well as query translation rules helps in conciseness, modularity, and maintenance. Krishnamurthy and Naqvi <ref> [26] </ref> propose a Horn-clause like language that can "range over" both data and meta-data by allowing "higher-order" variables. Krishnamurthy, Litwin, and Kent [25] extend this language and demonstrate its capability for interoperability. <p> Contributions * In this paper, we develop the logical foundations of interoperability in MDBS based on a higher-order logic called SchemaLog. We introduce SchemaLog informally with a motivating example (Section 2). Our syntax (Section 3.1) was inspired in part by that of <ref> [26] </ref>. However while they provide no formal semantics, we develop model-theoretic (Section 3.2), fixpoint (Section 5.1), and proof-theoretic (Section 5.2) semantics for SchemaLog. Thus, unlike their language, SchemaLog is a full-fledged logic. Besides, technically the framework developed by us is different from that of [26]. * We propose a proof procedure <p> inspired in part by that of <ref> [26] </ref>. However while they provide no formal semantics, we develop model-theoretic (Section 3.2), fixpoint (Section 5.1), and proof-theoretic (Section 5.2) semantics for SchemaLog. Thus, unlike their language, SchemaLog is a full-fledged logic. Besides, technically the framework developed by us is different from that of [26]. * We propose a proof procedure for full clausal SchemaLog and show that it is sound and complete (Section 5.2). * SchemaLog, like HiLog (Chen et. al. [12]), is syntactically higher-order but semantically first-order. We give a reduction of SchemaLog to first-order predicate calculus (Section 4). <p> This approach to unifying representations in component databases obviates the need for a canonical datamodel (see Section 1). In fact, in contrast with the CDM-based 11 This example is an adaptation of a similar example in <ref> [26] </ref>. 32 approach, this approach affords great flexibility for maintaining mappings against changes to component representations. In recent work, Turini et. al. ([6, 39]) at the University of Pisa have implemented a mediator language using SchemaLog. 7.3.
Reference: 27. <author> Lakshmanan, Laks V.S. and Sadri, F. </author> <title> Modeling Uncertainty in Deductive Databases. </title> <booktitle> In Proc. Intl. Conf. on Database Expert Systems and Applications (DEXA '94), </booktitle> <address> Athens, Greece, </address> <month> September </month> <year> 1994. </year> <note> Springer-Verlag, LNCS-856. </note>
Reference-contexts: We can easily augment the framework of SchemaLog either with annotations (in the spirit of annotated logics) or with the Information Source Tracking framework studied by Lakshmanan and Sadri <ref> [27] </ref>. The resulting language will be powerful enough to handle both kinds of inconsistencies. The SchemaLog Approach: In principle, one could augment HiLog or F-logic with the facilities for naming individual schemas as well as naming attributes (in the case of HiLog).
Reference: 28. <author> Lakshmanan, Laks V.S. and Subramanian, Iyer N. </author> <title> On Higher-order Logics for Mul-tidatabase Interoperability. </title> <type> Tech. report, </type> <institution> Concordia University, </institution> <address> Montreal, Quebec, </address> <year> 1995. </year>
Reference-contexts: The syntax of F-logic, unlike that of Schema-Log, was not designed with interoperability as one of the main goals. Thus, using F-logic for MDBS interoperability admits several alternatives, depending on how an MDBS is modeled within F-logic syntax. In <ref> [28] </ref> we undertake a detailed study of the various possibilities for modeling MDBS in F-logic as well as other proposed higher-order logics and contrast these approaches with the SchemaLog based approach for interoperability. Based on our analysis, we have derived the following conclusions in respect of approaches based on F-logic. <p> Based on our analysis, we have derived the following conclusions in respect of approaches based on F-logic. For further details, the reader is referred to <ref> [28] </ref>.
Reference: 29. <author> Lakshmanan, L.V.S., Sadri, F., and Subramanian, I. N. </author> <title> Extending Database Technology for Sophisticated Database Programming. </title> <type> Tech. report, </type> <institution> Concordia University, Montreal, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: Semantics for the case when db and/or rel are non-ground is defined analogously. In this paper, we make use of the informal semantics above. Investigation of formal issues arising in SchemaLog queries with aggregates is a subject addressed in depth in <ref> [29] </ref>. Example 7.3. Consider the relation in Figure 7.1 (which is a part of a database db) storing information on prices of various stocks at different exchanges (possibly in different countries) on a day to day basis, during May 1995.
Reference: 30. <author> Lakshmanan, L.V.S., Sadri, F., and Subramanian, I. N. </author> <title> SchemaSQL A Language for Querying and Restructuring Multidatabase Systems. </title> <booktitle> In Proc. IEEE Int. Conf. on Very Large Databases (VLDB'96), </booktitle> <pages> pages 239-250, </pages> <address> Bombay, India, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: We develop such an algebra in the context of a two-dimensional data model called the tabular data model and prove that it is complete for all generic, computable transformations. We show that the tabular data model and the tabular algebra can serve as a foundation for OLAP. In <ref> [30] </ref>, we develop a language called SchemaSQL, drawing on the inspiration from the SchemaLog experience. We also illustrate the usefulness of SchemaSQL for OLAP applications. 8. COMPARISON WITH OTHER LOGICS The notion of "higher-orderness" associated with a logic is ill-defined.
Reference: 31. <author> Lakshmanan, L.V.S., Subramanian, I. N., Papoulis, Despina, and Shiri, Nematol-laah. </author> <title> A Declarative System for Multi-database Interoperability. </title> <editor> In V. S. Alagar, editor, </editor> <booktitle> Proc. of the 4th Intl. Conference on Algebraic Methodology and Software Technology (AMAST), </booktitle> <address> Montreal, Canada, </address> <month> July </month> <year> 1995. </year> <note> Springer-Verlag. Tools Demo. </note>
Reference-contexts: In the second phase, the inference engine of CORAL and its rich suite of recursive query optimization strategies are exploited for efficient query processing. The system sports a pleasant user interface capable, among other things, of a schema browsing facility. Details of this implementation are discussed in <ref> [31, 43] </ref>. As demonstrated in this implementation, the simplicity of SchemaLog has resulted in an elegant design, and in its easy realization even within the framework of current relational database systems. Our ongoing work involves using the database storage manager EXODUS [8] for storing the output of Phase 1.
Reference: 32. <author> Landers, T. and Rosenberg, R. </author> <title> An Overview of Multibase. </title> <booktitle> Distributed Databases, </booktitle> <pages> pages 153-184, </pages> <year> 1982. </year>
Reference-contexts: Pegasus defines a common object model for unifying the data models of the underlying systems. Landers and Rosenberg use the functional model of DAPLEX as the CDM in their Multibase project <ref> [32] </ref>. Mermaid (Templeton et. al [52]) uses a relational CDM, and allows only for relational interoperability (with extensions to include text).
Reference: 33. <author> Lawley, M. J. </author> <title> A Prolog Interpreter for F-logic. </title> <type> Tech. report, </type> <institution> Griffith University, </institution> <year> 1993. </year>
Reference-contexts: The development of a relational calculus inspired by SchemaLog syntax and of an algebra with an equivalent expressive power has had a strong impact on the ease and efficiency of our implementation of SchemaLog. In <ref> [33] </ref> it has been pointed out based on implementation experience that there are many difficulties in implementing F-logic with its complex semantics and proof-theory. Indeed, this has led some researchers to investigate implementations of languages based on restricted versions of F-logic ([16]).
Reference: 34. <author> Lefebvre, A., Bernus, P., and Topor, R. </author> <title> Query Transformation for Accessing Heterogeneous Databases. </title> <booktitle> In Workshop on Deductive Databases in conjunction with JICSLP, </booktitle> <pages> pages 31-40, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: These approaches involve defining a higher-order logical language that can express queries ranging over the (meta)information corresponding to the individual databases and their schemas. The major advantage associated with such approaches is the declarativity they derive from their logical foundations. 5 Lefebvre, Bernus, and Topor <ref> [34] </ref> use F-logic (Kifer et. al. [21]), to provide data mappings between local databases and an assumed global database (that is an integrated view of the local databases). The mappings take care of the data as well as the schema discrepancies in the local databases. <p> This functionality is lacking in some of the above approaches ([36, 46]). In these approaches, as there is no uniform treatment of data and meta-data, schema browsing and specifying "higher-order mappings" would be inconvenient. While <ref> [34] </ref> makes use of the higher-order capabilities of F-logic in uniformly manipulating data and schema, their approach uses F-logic primarily for query translation and provides an SQL-based user interface. This severely limits the schema browsing capabilities from the user interface.
Reference: 35. <author> Levy, A.Y., Srivastava, D., and Kirk, T. </author> <title> Data Model and Query Evaluation in Global Information Systems. </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 4, </volume> <month> Sept </month> <year> 1995. </year> <note> Special Issue On Networked Information Systems (To Appear). </note>
Reference-contexts: Also in many cases, autonomy requirements might impose limits on the information available for constructing the CDM mappings. In recent work, Levy, Srivastava, and Kirk <ref> [35] </ref> present an architecture for query processing in global information systems. Their approach is based on description logic. While their framework is more general than that of traditional MDBS, many of the issues they study also arise in MDBS and their techniques are applicable to MDBS.
Reference: 36. <author> Litwin, W. MSQL: </author> <title> A Multidatabase Language. </title> <journal> Information Science, </journal> <volume> 48(2), </volume> <year> 1989. </year>
Reference-contexts: Litwin, Mark, and Roussopoulos [37], advocate that the concept of an MDBS language is central to the notion of a MDBS system. They argue against a global interpretation (as obtained in the CDM approach), and discuss the merits of a language MSQL (Multidatabase-SQL) <ref> [36] </ref>, an extension of SQL for interoperability among multiple relational databases. The salient features of this language include the ability to retrieve and update relations in different databases, define multi-database views, and specify compatible and equivalent domains across different databases.
Reference: 37. <author> Litwin, Witold, Mark, Leo, and Roussopoulos, Nick. </author> <title> Interoperability of Multiple Autonomous Databases. </title> <journal> ACM computing surveys, </journal> <volume> 22(3) </volume> <pages> 267-293, </pages> <month> Sept </month> <year> 1990. </year>
Reference-contexts: Multidatabase systems are also referred to as Heterogeneous Database Systems (HDBS) and Federated Database Systems (FDBS) by different authors. The reader is referred to [2] (in particular, see Sheth and Larson [48], Litwin, Mark, and Roussopoulos <ref> [37] </ref>), Hsiao [19], and [20] for surveys in the field. One basic functionality MDBS should feature is interoperability. Interoperability can be defined as the ability to uniformly share, interpret, and manipulate information across component databases in an MDBS. <p> In the following, we survey representative works in both of these approaches. For a comprehensive survey of related literature, the reader is referred to <ref> [37] </ref> and [3]. Common data model: The databases participating in the federation are mapped to a common data model (CDM) (such as the object-oriented model, that naturally meets the CDM requirements in terms of richness of modeling power) which acts as an `interpreter' among them. <p> Thus a CDM, as defined in the previous case is not required; the non-procedural language in some sense plays the role of the CDM here. The major advantage associated with this approach is the flexibility such a loose coupling ([48]) provides. Litwin, Mark, and Roussopoulos <ref> [37] </ref>, advocate that the concept of an MDBS language is central to the notion of a MDBS system. They argue against a global interpretation (as obtained in the CDM approach), and discuss the merits of a language MSQL (Multidatabase-SQL) [36], an extension of SQL for interoperability among multiple relational databases.
Reference: 38. <author> Manchanda, S. </author> <title> Higher-order Logic As a Data Model. </title> <booktitle> In Proc. of the North American Conf. on Logic Programming, </booktitle> <pages> pages 330-341, </pages> <year> 1989. </year>
Reference-contexts: HOL: A higher-order language for computing with labeled sets is introduced in Manchanda <ref> [38] </ref>. The language supports structured data, object-identity, and sets. This also belongs to the above class of languages in that its semantics is first-order. This paper also illustrates a template mechanism to define the database schema.
Reference: 39. <author> Gori, Mario and Della Lena, Fabio. </author> <title> A Schemalog Implementation for a Mediator Language. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Pisa, Pisa, Italy, </institution> <month> October </month> <year> 1996. </year>
Reference: 40. <author> Mumick, I.S., Pirahesh, H., and Ramakrishnan, R. </author> <title> The Magic of Duplicates and Aggregates. </title> <booktitle> In Proc. 16th Intl. Conference on Very Large Databases (VLDB'90), </booktitle> <pages> pages 264-277, </pages> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: Throughout this section, we shall mainly consider aggregate queries in the context of non-recursive queries. The semantics of aggregate queries in deductive databases (with and without recursion) is discussed in Ramakrishnan et al <ref> [40] </ref>. Based on this theme, the semantics of SchemaLog queries with aggregates (without recursion) can be obtained as follows.
Reference: 41. <author> Nguyen, G.T. and Rieu, D. </author> <title> Schema Evolution in Object-oriented Database Systems. </title> <journal> Data and Knowledge Engg., North-Holland, </journal> <volume> 4 </volume> <pages> 43-67, </pages> <year> 1989. </year>
Reference-contexts: It is a somewhat abused term in the database field, in that it has been interpreted to mean different things by different researchers. While Kim [24] treats versioning of schema for object management as schema evolution, Nguyen and Rieu <ref> [41] </ref> considers the various schema change operations and the associated consequences as being its main issues. Osborn [42] gives some interesting perspectives on the consequences of the polymorphic constructs in object-oriented databases and how this aids in avoiding code `evolution'.
Reference: 42. <author> Osborn, Sylvia. </author> <title> The Role of Polymorphism in Schema Evolution in an Object-oriented Database. </title> <journal> In IEEE Trans. on Knowledge and Data Engg., </journal> <pages> pages 310-317, </pages> <month> Sept </month> <year> 1989. </year>
Reference-contexts: While Kim [24] treats versioning of schema for object management as schema evolution, Nguyen and Rieu [41] considers the various schema change operations and the associated consequences as being its main issues. Osborn <ref> [42] </ref> gives some interesting perspectives on the consequences of the polymorphic constructs in object-oriented databases and how this aids in avoiding code `evolution'.
Reference: 43. <author> Papoulis, Despina. </author> <title> Realizing SchemaLog. </title> <type> Tech. report, </type> <institution> Dept. of CS, Concordia 47 Univ., Montreal, Canada, </institution> <year> 1994. </year>
Reference-contexts: In the second phase, the inference engine of CORAL and its rich suite of recursive query optimization strategies are exploited for efficient query processing. The system sports a pleasant user interface capable, among other things, of a schema browsing facility. Details of this implementation are discussed in <ref> [31, 43] </ref>. As demonstrated in this implementation, the simplicity of SchemaLog has resulted in an elegant design, and in its easy realization even within the framework of current relational database systems. Our ongoing work involves using the database storage manager EXODUS [8] for storing the output of Phase 1.
Reference: 44. <author> Ramakrishnan, R., Srivastava, D., and Sudarshan, S. </author> <title> CORAL: Control, Relations, </title> <booktitle> and Logic. In Proc. Intl. Conf. on Very Large Databases, </booktitle> <year> 1992. </year>
Reference-contexts: A significant feature of our implementation is that these two aspects are handled independently. The schema information is manipulated using operators of the ERA (Section 6) realized via the INGRES Embedded-SQL (ESQL) and, the deductive DBMS CORAL <ref> [44] </ref> is used for recursive query processing. Phase 1 of our implementation is concerned with extracting the schema related information of databases in the federation and converting it to a "first-order" form. This phase essentially makes use of the extended algebra (E RA) discussed in Section 6.
Reference: 45. <author> Ross, Kenneth. </author> <title> Relations With Relation Names As Arguments: Algebra and calculus. </title> <booktitle> In Proc. 11th ACM Symp. on PODS, </booktitle> <pages> pages 346-353, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Thus, notice that the simulated and simulating languages do not take the same federation of databases as input, although the inputs are equivalent. Ross <ref> [45] </ref> addresses a similar issue in the context of an algebra he proposes for HiLog and introduces the notion of a relation preserving simulation. He defines a simulation to be relation preserving, if the simulated as well as the simulating formalisms operate on the same database.
Reference: 46. <author> Sciore, E., Siegel, M., and Rosenthal, A. </author> <title> Using Semantic Values to Facilitate Interoperability Among Heterogeneous Information Systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(2) </volume> <pages> 254-290, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: In ([13]) Chomicki and Litwin propose an extension to OSQL ([4]), a functional object-oriented language. The language has constructs that are capable of declaratively specifying a broad class of mappings across multiple object-oriented databases. They also sketch the operational semantics of this language. More recently, Sciore, Siegel, and Rosenthal <ref> [46] </ref>, introduce a theory of semantic values as a unit of exchange that facilitates interoperability. They apply this theory on the relational model, and propose an extension to SQL called context-SQL (CSQL). <p> This severely limits the schema browsing capabilities from the user interface. Approaches that base interoperability on higher-order mappings among component databases ([13, 34]) do not provide support for ad-hoc queries that refer to (and possibly compare) data and schema components of multiple databases in one shot. [13] and <ref> [46] </ref> do not provide a uniform syntax for multiple databases in a manner that glosses over their schematic discrepancies.
Reference: 47. <author> Shepherdson, </author> <title> J.C. Negation in Logic Programming. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: The details are identical to those for classical logic programming ([56]). 2 4 X is directed if every finite subset of X has an upper bound in X. 17 Incorporating any of the various forms of negation studied in logic programming (e.g., see <ref> [47] </ref>) in SchemaLog is not very difficult. We do not discuss this issue further in this paper. 5.2. Proof Theory of SchemaLog In this section, we develop a sound and complete proof theory for SchemaLog as a full-fledged logic. We consider arbitrary SchemaLog theories, not just definite clauses. <p> We have also developed a fixpoint theoretic and proof-theoretic semantics of SchemaLog. In fact, the framework can be extended to incorporate the various forms of negation extensively studied in the literature of deductive databases and logic programming (see <ref> [47] </ref> for a survey), notably stratified negation, without much difficulty. We have studied an extension of classical relational algebra that is capable of manipulating both schema and data of component databases in a federation, and established its equivalence to a form of relational calculus inspired by SchemaLog syntax.
Reference: 48. <author> Sheth, Amit P. and Larson, James A. </author> <title> Federated Database System for Managing Distributed, Heterogeneous and Autonomous Databases. </title> <journal> ACM computing surveys, </journal> <volume> 22(3) </volume> <pages> 183-236, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Multidatabase systems are also referred to as Heterogeneous Database Systems (HDBS) and Federated Database Systems (FDBS) by different authors. The reader is referred to [2] (in particular, see Sheth and Larson <ref> [48] </ref>, Litwin, Mark, and Roussopoulos [37]), Hsiao [19], and [20] for surveys in the field. One basic functionality MDBS should feature is interoperability. Interoperability can be defined as the ability to uniformly share, interpret, and manipulate information across component databases in an MDBS. <p> In a more sophisticated scenario, `views' which correspond to the schema of the participating databases are defined on the CDM, thus providing the user with a convenient illusion that all the information she gets is from her own database. (This is called tight coupling <ref> [48] </ref>.) A "canonical" example of the CDM based approach is the Pegasus project of Ahmed et. al. [5]. Pegasus defines a common object model for unifying the data models of the underlying systems. Landers and Rosenberg use the functional model of DAPLEX as the CDM in their Multibase project [32].
Reference: 49. <author> Subrahmanian, </author> <title> V.S. On the Semantics of Quantitative Logic Programs. </title> <booktitle> In Proc. 4th IEEE Symposium on Logic Programming, </booktitle> <pages> pages 173-182, </pages> <publisher> Computer Society Press, </publisher> <address> Washington DC, </address> <year> 1987. </year>
Reference: 50. <author> Subrahmanian, </author> <title> V.S. Amalgamating Knowledge Bases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19, 2 </volume> <pages> 291-331, </pages> <year> 1994. </year>
Reference-contexts: COL achieves the functionality for manipulating complex objects by introducing what are called (base and derived) "data functions". The syntax as well as the semantics of COL is higher-order. The syntax does not support the constructs necessary for interoperability. Approach based on Annotated logic: In recent work, Subrahmanian <ref> [50] </ref> has studied the problem of integrating multiple deductive databases featuring inconsistencies, uncertainties, and non-monotonic forms of negation. He proposes an approach based on annotated logics ([49], [22], [23]) for realizing a "mediator" between the component knowledge-bases.
Reference: 51. <author> Subrahmanian, V.S., Adali, S., Brink, A., Emery, R., Lu, J.J, Rajput, A., Rogers, T.J., Ross, R., and Ward, C. </author> <title> Hermes: Heterogeneous Reasoning and Mediator System. </title> <type> Tech. report, </type> <note> submitted for publication, </note> <institution> Institute for Advanced Computer Studies and Department of Computer Science University of Maryland, College Park, MD 20742, </institution> <year> 1995. </year>
Reference: 52. <author> Templeton, M., et al. Mermaid: </author> <title> A Front-end to Distributed Heterogeneous Databases. </title> <booktitle> In Proc. IEEE 75, </booktitle> <volume> 5, </volume> <pages> pages 695-708, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Pegasus defines a common object model for unifying the data models of the underlying systems. Landers and Rosenberg use the functional model of DAPLEX as the CDM in their Multibase project [32]. Mermaid (Templeton et. al <ref> [52] </ref>) uses a relational CDM, and allows only for relational interoperability (with extensions to include text). Thus federation users may formulate queries using SQL. 4 The major problem associated with the approaches in this category is the amount of human participation required for obtaining the CDM mappings.
Reference: 53. <author> Ullman, J.D. </author> <title> Database Theory: Past and Future. </title> <booktitle> In Proc. of the ACM Symp. PODS, </booktitle> <year> 1987. </year>
Reference-contexts: In related work, Ullman <ref> [53] </ref> argues for the need for allowing the user to be ignorant about the structure of the database and pose queries to the database with only the knowledge about the attributes (in all relations) of the database.
Reference: 54. <author> Ullman, J.D. </author> <title> Principles of Database and Knowledge-Base Systems, volume II. </title> <publisher> Computer Science Press, </publisher> <address> Maryland, </address> <year> 1989. </year>
Reference-contexts: We have to adopt certain modifications to account for the peculiar syntax of SchemaLog and the somewhat different notion of unification defined above. We develop an algorithm below by modifying the unification algorithm discussed, e.g., in Ullman <ref> [54] </ref>. Consider any two SchemaLog atoms A and B. Without loss of generality, we may assume that there is no variable which occurs in both A and B. (Such variables can always be renamed). We would like to test if A can be unified to B. <p> Phase II of the algorithm constructs the MGU by considering each equivalence class obtained from the previous phase. This phase is identical to phase II of the unification algorithm for classical logic given in Ullman <ref> [54] </ref>, to which we refer the reader for details. 2 We give an example of unification, to illustrate the algorithm. Example 5.2. <p> Unification Theorem: Given atomic formulas A and B, Algorithm 5.1 correctly computes the most general unifier of A to B if the mgu exists. The proof of this theorem follows the same lines as the one discussed for classical logic in Ullman <ref> [54] </ref>. The modifications to the proof to account for the modified phase I of the algorithm are straightforward. 5.2.4. Resolution and Completeness In this section, we show that the extension of the resolution based proof procedure to the higher-order setting is sound and complete for SchemaLog. <p> Vertical Aggregation: Our first example is the simple query (Q 7 ) "For each stock, compute its average (during May 1995) closing price at the 13 The relation corresponding to the rule body can be computed using (minor adaptations to) the functions VTOA and ATOV discussed in Ullman <ref> [54] </ref>. 37 date stock Xge 1 : : : Xge n 01 s1 50 48 . 02 s1 35 39 . FIGURE 7.1. Stock Exchange Database Toronto stock exchange." This query is a conventional aggregate query expressible in conventional languages like SQL.
Reference: 55. <author> Ullman, J.D. </author> <title> Principles of Database and Knowledge-Base Systems, volume I. </title> <publisher> Computer Science Press, </publisher> <address> Maryland, </address> <year> 1989. </year> <note> 56. </note> <editor> van Emden, M.H. and Kowalski, R.A. </editor> <title> The Semantics of Predicate Logic As a Programming Language. </title> <journal> JACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <month> October </month> <year> 1976. </year>
Reference-contexts: Safety: We would like the formulas of L C that we consider, to "pay attention to the domain of the formula". Following Ullman <ref> [55] </ref>, we call such domain indepen 9 Note that atoms in L C correspond in general to molecules in L. Also note that explicit tid's are dispensed with in L C . 29 dent formulas as "safe formulas". We formally define safe formulas below.

References-found: 55

