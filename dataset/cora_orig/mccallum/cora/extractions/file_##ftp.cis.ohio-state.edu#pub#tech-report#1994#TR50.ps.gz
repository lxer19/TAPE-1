URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1994/TR50.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: The Polynomial Time Function Hierarchy  
Author:  J. Ramachandran 
Note: 1 This work was supported in part by NSF Grant CCR-8909071 2 Part of this research was done when the author was a visitor  
Address: Columbus, Ohio 43210  
Affiliation: Computer and Information Sciences Ohio State University  at New Mexico State University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Allender, E., and Rubinstein, R. </author> <title> P-printable sets. </title> <note> Submitted for publication, </note> <year> 1986. </year>
Reference-contexts: So, while it may be that, for some choice of f and g in #P, the function h (x) = f (x) g (x) may not be in #P, it is always in PF (#P) (in fact in PF (#P <ref> [1] </ref>)). Pragmatically speaking, allowing the extra work of PF seems entirely reasonable, because application of a "trivial" operator should not create functions of higher complexity than #P. Definition 1.4 Let DF and CF be function classes. 1. <p> A typical result is as follows: Theorem 1.5 #P is closed under majority in context PF ffi #P if and only if PP (PP) = P (#P <ref> [1] </ref>). It is helpful to consider the simplified case when the arity of the operator t is polynomially bounded in value. <p> The above statement is made without any context class DF ffi CF . If we consider the question under context PF ffi OptP, it is easy to show, using the fact that several OptP computations can be combined into a single OptP computation (PF OptP PF OptP <ref> [1] </ref> , Proposition 4.12): Theorem 1.7 OptP is closed under all polynomially bounded arity, polynomial time computable operators, under the context PF ffi OptP. <p> For example, Theorem 1.8 OptP is closed under majority in context PF ffi OptP if and only if PP (NP) = P (OptP <ref> [1] </ref>). In section 10 we conclude with a concise table of our results. The results in this paper form the basis for other results on approximating PFH functions ([14], [16].) 2 Definitions In this section we present definitions and notation for the function classes we will be working with. <p> Every f 2 F P k is metric reducible to some g 2 MM k . By Proposition 4.7, g is metric reducible to h 2 MM k . The statement now follows from closure, under composition, of metric reductions. 2 Proposition 4.12 8 k 0, PF MM k <ref> [1] </ref> = PF MM k = PF MM k [1] Proof. By Theorem 4.9 and Proposition 4.11, we have: PF MM k = PF (PF P k = k [1] , and PF MM k ) = F P k [1] . 2 We now state a lemma that complements Theorem <p> By Proposition 4.7, g is metric reducible to h 2 MM k . The statement now follows from closure, under composition, of metric reductions. 2 Proposition 4.12 8 k 0, PF MM k <ref> [1] </ref> = PF MM k = PF MM k [1] Proof. By Theorem 4.9 and Proposition 4.11, we have: PF MM k = PF (PF P k = k [1] , and PF MM k ) = F P k [1] . 2 We now state a lemma that complements Theorem 4.9. <p> The statement now follows from closure, under composition, of metric reductions. 2 Proposition 4.12 8 k 0, PF MM k <ref> [1] </ref> = PF MM k = PF MM k [1] Proof. By Theorem 4.9 and Proposition 4.11, we have: PF MM k = PF (PF P k = k [1] , and PF MM k ) = F P k [1] . 2 We now state a lemma that complements Theorem 4.9. Lemma 4.13 MM k F P 14 Proof. <p> reductions. 2 Proposition 4.12 8 k 0, PF MM k <ref> [1] </ref> = PF MM k = PF MM k [1] Proof. By Theorem 4.9 and Proposition 4.11, we have: PF MM k = PF (PF P k = k [1] , and PF MM k ) = F P k [1] . 2 We now state a lemma that complements Theorem 4.9. Lemma 4.13 MM k F P 14 Proof. The proof is in the appendix. 2 We extend the analogy between PFH and PH: Theorem 4.14 For all k 0, MM k [ MM k+1 MM k+1 . Proof. <p> The above results in the following picture of PFH, Figure 1, an exact analogy with PH, except for the fact that one query to a function oracle suffices at the F P k levels. 15 MM 3 2 <ref> [1] </ref> 2 MM PF OptP [1] OptP MM 1 4.3 Turing versus metric reductions We now study the differences between Turing and metric reductions: Theorem 4.15 If f is Turing reducible to a g in MM k , then there exists a g 0 2 MM k such that f is <p> The above results in the following picture of PFH, Figure 1, an exact analogy with PH, except for the fact that one query to a function oracle suffices at the F P k levels. 15 MM 3 2 <ref> [1] </ref> 2 MM PF OptP [1] OptP MM 1 4.3 Turing versus metric reductions We now study the differences between Turing and metric reductions: Theorem 4.15 If f is Turing reducible to a g in MM k , then there exists a g 0 2 MM k such that f is metric reducible to g 0 <p> So, while it may be that, for some choice of f and g in #P, the function h (x) = f (x) g (x) may not be in #P, it is always in PF (#P) (in fact in PF (#P <ref> [1] </ref>)). Pragmatically speaking, allowing the extra work of PF seems entirely reasonable, because application of a "trivial" operator should not create functions of higher complexity that #P. In [13] Ogiwara, Theirauf, Toda and Watanabe introduced the notion of "context". <p> We will shift the emphasis from #P to OptP. It is easy to show, using Theorem 4.15, that: Proposition 5.6 PF (OptP) = PF ffi OptP = PF (OptP <ref> [1] </ref>). 20 This shows that OptP is closed under an operator t in context PF ffi OptP if and only if functions in t (OptP) are metric reducible to OptP. <p> Lemma 6.1 1. B is in NP G and g is in PF B 2. If B 2 NP, then g 2 OptP. 3. If B 2 P OptP <ref> [1] </ref> , then g 2 PF OptP [1] . Proof. 1. The proof is straightforward. 2 read "Is CF closed under t in context DF ffi CF?". 21 2. <p> Lemma 6.1 1. B is in NP G and g is in PF B 2. If B 2 NP, then g 2 OptP. 3. If B 2 P OptP <ref> [1] </ref> , then g 2 PF OptP [1] . Proof. 1. The proof is straightforward. 2 read "Is CF closed under t in context DF ffi CF?". 21 2. <p> Hence g 2 OptP. 3. Use the fact that several OptP computations can be combined into a single OptP com putation (PF OptP PF OptP <ref> [1] </ref> , Proposition 4.12) Toran in [19] shows: Proposition 6.2 A set L is in PP (NP) if and only if there exists a set A in NP, and a polynomial p, such that for every x 2 fl , it holds that x 2 L () k fw 2 =p <p> For closure without context, the hypothesis PP (NP) = NP. 2. For closure under context PF ffi OptP, the hypothesis PP (NP) = P (OptP <ref> [1] </ref>). Lemma 6.3 Some useful facts (that also relativize): 1. P (P A [1] ) P A . 2. From Theorem 4.9: P (NP) P (OptP [1]). 3. From Krentel ([8]): OptP PF NP . 4. From Toda ([18]): PH P (PP). 5. <p> For closure without context, the hypothesis PP (NP) = NP. 2. For closure under context PF ffi OptP, the hypothesis PP (NP) = P (OptP <ref> [1] </ref>). Lemma 6.3 Some useful facts (that also relativize): 1. P (P A [1] ) P A . 2. From Theorem 4.9: P (NP) P (OptP [1]). 3. From Krentel ([8]): OptP PF NP . 4. From Toda ([18]): PH P (PP). 5. <p> For closure under context PF ffi OptP, the hypothesis PP (NP) = P (OptP <ref> [1] </ref>). Lemma 6.3 Some useful facts (that also relativize): 1. P (P A [1] ) P A . 2. From Theorem 4.9: P (NP) P (OptP [1]). 3. From Krentel ([8]): OptP PF NP . 4. From Toda ([18]): PH P (PP). 5. From Toda ([18]): PP P k =) PH = P Lemma 6.4 PP (NP) = NP () PH (PP (NP)) = NP. Proof. <p> From Toda ([18]): PH P (PP). 5. From Toda ([18]): PP P k =) PH = P Lemma 6.4 PP (NP) = NP () PH (PP (NP)) = NP. Proof. The proof is in the appendix. 2 Lemma 6.5 PP (NP) = P (OptP <ref> [1] </ref>) () PH (PP (NP)) = P (OptP [1]). Proof. <p> From Toda ([18]): PP P k =) PH = P Lemma 6.4 PP (NP) = NP () PH (PP (NP)) = NP. Proof. The proof is in the appendix. 2 Lemma 6.5 PP (NP) = P (OptP <ref> [1] </ref>) () PH (PP (NP)) = P (OptP [1]). Proof. The proof is in the appendix. 2 22 7 Complexity of exponential arity operators We use the definitions and notation of Ogiwara, Theirauf, Toda and Watanabe for continuity. 7.1 A majority algorithm We first construct an algorithm for computing a typical operator with exponential arity. <p> Theorem 9.3 The following statements are equivalent: 1. PP (NP) = P (OptP <ref> [1] </ref>)). 2. OptP is closed under sum in context PF ffi OptP: d sum [OptP] PF (OptP [1]). 29 3. OptP is closed under maj in context PF ffi OptP: d maj [OptP] PF (OptP [1]). 4. <p> Theorem 9.3 The following statements are equivalent: 1. PP (NP) = P (OptP <ref> [1] </ref>)). 2. OptP is closed under sum in context PF ffi OptP: d sum [OptP] PF (OptP [1]). 29 3. OptP is closed under maj in context PF ffi OptP: d maj [OptP] PF (OptP [1]). 4. OptP is closed under maj w in context PF ffi OptP: d maj w [OptP] PF (OptP [1]). 5. <p> Theorem 9.3 The following statements are equivalent: 1. PP (NP) = P (OptP <ref> [1] </ref>)). 2. OptP is closed under sum in context PF ffi OptP: d sum [OptP] PF (OptP [1]). 29 3. OptP is closed under maj in context PF ffi OptP: d maj [OptP] PF (OptP [1]). 4. OptP is closed under maj w in context PF ffi OptP: d maj w [OptP] PF (OptP [1]). 5. OptP is closed under mid in context PF ffi OptP: d mid [OptP] PF (OptP [1]). 6. <p> closed under sum in context PF ffi OptP: d sum [OptP] PF (OptP <ref> [1] </ref>). 29 3. OptP is closed under maj in context PF ffi OptP: d maj [OptP] PF (OptP [1]). 4. OptP is closed under maj w in context PF ffi OptP: d maj w [OptP] PF (OptP [1]). 5. OptP is closed under mid in context PF ffi OptP: d mid [OptP] PF (OptP [1]). 6. OptP is closed under plu in context PF ffi OptP: d plu [OptP] PF (OptP [1]). <p> is closed under maj in context PF ffi OptP: d maj [OptP] PF (OptP <ref> [1] </ref>). 4. OptP is closed under maj w in context PF ffi OptP: d maj w [OptP] PF (OptP [1]). 5. OptP is closed under mid in context PF ffi OptP: d mid [OptP] PF (OptP [1]). 6. OptP is closed under plu in context PF ffi OptP: d plu [OptP] PF (OptP [1]). <p> is closed under maj w in context PF ffi OptP: d maj w [OptP] PF (OptP <ref> [1] </ref>). 5. OptP is closed under mid in context PF ffi OptP: d mid [OptP] PF (OptP [1]). 6. OptP is closed under plu in context PF ffi OptP: d plu [OptP] PF (OptP [1]). We proceed by showing individually that (1) (= (2), (1) (= (3), (1) (= (4), (1) (= (5), and (1) (= (6) respectively; and then show individually that (1) =) (2), (1) =) (3), (1) =) (4), (1) =) (5), and (1) =) (6) respectively. <p> We proceed in a manner similar to [13]. 9.3 Closure of OptP under context implies a collapse Lemma 9.4 Let t be any of fsum, maj, maj w , mid, plug. If OptP is closed under t in context PF ffi OptP, then P (OptP <ref> [1] </ref>) = PP (NP). Proof. Choose e (x), the arity of the operator t under examination, to be exponentially bounded by some polynomial p, e (x) = 2 p (jxj) . Also, let L be in PP (NP) as assumed. We must show that L 2 P (OptP [1]) under our <p> P (OptP <ref> [1] </ref>) = PP (NP). Proof. Choose e (x), the arity of the operator t under examination, to be exponentially bounded by some polynomial p, e (x) = 2 p (jxj) . Also, let L be in PP (NP) as assumed. We must show that L 2 P (OptP [1]) under our hypothesis. <p> By hypothesis, g is computable in PF ffi OptP; i.e., there exists an PF (OptP <ref> [1] </ref>) machine that computes g. Then it is easy to modify this 30 transducer to create an acceptor M g that computes g (x) and accepts x if and only if g (x) &gt; 2 p (jxj)1 . This creates a P (OptP [1]) algorithm for L. (We insert a parenthetical <p> OptP; i.e., there exists an PF (OptP <ref> [1] </ref>) machine that computes g. Then it is easy to modify this 30 transducer to create an acceptor M g that computes g (x) and accepts x if and only if g (x) &gt; 2 p (jxj)1 . This creates a P (OptP [1]) algorithm for L. (We insert a parenthetical digression here to note how OptP differs from #P with regard to closure under the operators sum and maj w . In [13], #P is shown to be closed under maj w in context PF ffi #P. <p> Define the function g as g (x) = maj (f (1; x); f (2; x); : : : ; f (2 p (jxj) ; x)) Now consider any string x in fl . Then x 2 L () g (x) = 1. By hypothesis, there exists an PF (OptP <ref> [1] </ref>) machine that computes g. Then it is easy to modify this transducer to create an acceptor M g that computes g (x) and accepts x if and only if g (x) = 1. Thus L 2 P (OptP [1]). 3. t = maj w . <p> By hypothesis, there exists an PF (OptP <ref> [1] </ref>) machine that computes g. Then it is easy to modify this transducer to create an acceptor M g that computes g (x) and accepts x if and only if g (x) = 1. Thus L 2 P (OptP [1]). 3. t = maj w . Define the function g as g (x) = maj w (f (1; x); f (2; x); : : : ; f (2 p (jxj) ; x)) Now consider any string x in fl . Then x 2 L () g (x) = 1. <p> Then x 2 L () g (x) = 1. By hypothesis, there exists an PF (OptP <ref> [1] </ref>) machine that computes g. Then it is easy to modify this transducer to create an acceptor M g that computes g (x) and accepts x if and only if g (x) = 1. Thus L 2 P (OptP [1]). 4. t = mid. <p> By hypothesis, there exists an PF (OptP <ref> [1] </ref>) machine that computes g. Then it is easy to modify this transducer to create an acceptor M g that computes g (x) and accepts x if and only if g (x) = 1. Thus L 2 P (OptP [1]). 4. t = mid. Define the function g as g (x) = mid (f (1; x); f (2; x); : : : ; f (2 p (jxj) ; x)) Now consider any string x in fl . Then x 2 L () g (x) = 1. <p> Define the function g as g (x) = mid (f (1; x); f (2; x); : : : ; f (2 p (jxj) ; x)) Now consider any string x in fl . Then x 2 L () g (x) = 1. By hypothesis, there exists an PF (OptP <ref> [1] </ref>) machine that computes g. Then it is easy to modify this transducer to create an acceptor M g that computes g (x) and accepts x if and only if g (x) = 1. Thus L 2 P (OptP [1]). 5. t = plu. <p> By hypothesis, there exists an PF (OptP <ref> [1] </ref>) machine that computes g. Then it is easy to modify this transducer to create an acceptor M g that computes g (x) and accepts x if and only if g (x) = 1. Thus L 2 P (OptP [1]). 5. t = plu. Define the function g as g (x) = plu (f (1; x); f (2; x); : : : ; f (2 p (jxj) ; x)) Now consider any string x in fl . Then x 2 L () g (x) = 1. <p> Define the function g as g (x) = plu (f (1; x); f (2; x); : : : ; f (2 p (jxj) ; x)) Now consider any string x in fl . Then x 2 L () g (x) = 1. By hypothesis, there exists an PF (OptP <ref> [1] </ref>) machine that computes g. Then it is easy to modify this transducer to create an acceptor M g that computes g (x) and accepts x if and only if g (x) = 1. Thus L 2 P (OptP [1]). 9.4 A collapse implies closure of OptP under context The following <p> By hypothesis, there exists an PF (OptP <ref> [1] </ref>) machine that computes g. Then it is easy to modify this transducer to create an acceptor M g that computes g (x) and accepts x if and only if g (x) = 1. Thus L 2 P (OptP [1]). 9.4 A collapse implies closure of OptP under context The following is the converse to Lemma 9.4. Lemma 9.5 Let t be any of fsum, maj, maj w , mid, plug. If P (OptP [1]) = PP (NP) then OptP is closed under t in context PF ffi OptP. <p> Thus L 2 P (OptP <ref> [1] </ref>). 9.4 A collapse implies closure of OptP under context The following is the converse to Lemma 9.4. Lemma 9.5 Let t be any of fsum, maj, maj w , mid, plug. If P (OptP [1]) = PP (NP) then OptP is closed under t in context PF ffi OptP. Proof. Assume P (OptP [1]) = PP (NP). Let f be in OptP, let e (x) 2 PF, and let t be an operator. <p> Lemma 9.5 Let t be any of fsum, maj, maj w , mid, plug. If P (OptP <ref> [1] </ref>) = PP (NP) then OptP is closed under t in context PF ffi OptP. Proof. Assume P (OptP [1]) = PP (NP). Let f be in OptP, let e (x) 2 PF, and let t be an operator. <p> Therefore B 2 NP G 2 NP (PP (NP)). By Lemma 6.5, and the assumption of the theorem, B is in P (OptP <ref> [1] </ref>). By Lemma 6.1, g 2 PF (OptP [1]). Therefore OptP is closed under sum in context PF ffi OptP. 2. t = maj. By Corollary 7.2, G is in PP (NP), and therefore B 2 NP G 2 NP (PP (NP)). By Lemma 6.5, B is in P (OptP [1]), <p> Therefore B 2 NP G 2 NP (PP (NP)). By Lemma 6.5, and the assumption of the theorem, B is in P (OptP <ref> [1] </ref>). By Lemma 6.1, g 2 PF (OptP [1]). Therefore OptP is closed under sum in context PF ffi OptP. 2. t = maj. By Corollary 7.2, G is in PP (NP), and therefore B 2 NP G 2 NP (PP (NP)). By Lemma 6.5, B is in P (OptP [1]), and by Lemma 6.1, g 2 PF (OptP <p> <ref> [1] </ref>). By Lemma 6.1, g 2 PF (OptP [1]). Therefore OptP is closed under sum in context PF ffi OptP. 2. t = maj. By Corollary 7.2, G is in PP (NP), and therefore B 2 NP G 2 NP (PP (NP)). By Lemma 6.5, B is in P (OptP [1]), and by Lemma 6.1, g 2 PF (OptP [1]). Hence OptP is closed under maj in context PF ffi OptP. 3. t = maj w . By Corollary 7.2, G is in PP (NP), and therefore B 2 NP G 2 NP (PP (NP)). <p> By Corollary 7.2, G is in PP (NP), and therefore B 2 NP G 2 NP (PP (NP)). By Lemma 6.5, B is in P (OptP <ref> [1] </ref>), and by Lemma 6.1, g 2 PF (OptP [1]). Hence OptP is closed under maj in context PF ffi OptP. 3. t = maj w . By Corollary 7.2, G is in PP (NP), and therefore B 2 NP G 2 NP (PP (NP)). By Lemma 6.5, B is in P (OptP [1]), and by Lemma 6.1, g 2 <p> Lemma 6.1, g 2 PF (OptP <ref> [1] </ref>). Hence OptP is closed under maj in context PF ffi OptP. 3. t = maj w . By Corollary 7.2, G is in PP (NP), and therefore B 2 NP G 2 NP (PP (NP)). By Lemma 6.5, B is in P (OptP [1]), and by Lemma 6.1, g 2 PF (OptP [1]). Hence OptP is closed under maj w in context PF ffi OptP. 4. t = mid. By Corollary 7.2, G is in P (PP (NP)), and B 2 NP G 2 NP (PP (NP)). <p> By Corollary 7.2, G is in PP (NP), and therefore B 2 NP G 2 NP (PP (NP)). By Lemma 6.5, B is in P (OptP <ref> [1] </ref>), and by Lemma 6.1, g 2 PF (OptP [1]). Hence OptP is closed under maj w in context PF ffi OptP. 4. t = mid. By Corollary 7.2, G is in P (PP (NP)), and B 2 NP G 2 NP (PP (NP)). By Lemma 6.5, B is in P (OptP [1]), and by Lemma 6.1, g 2 PF <p> by Lemma 6.1, g 2 PF (OptP <ref> [1] </ref>). Hence OptP is closed under maj w in context PF ffi OptP. 4. t = mid. By Corollary 7.2, G is in P (PP (NP)), and B 2 NP G 2 NP (PP (NP)). By Lemma 6.5, B is in P (OptP [1]), and by Lemma 6.1, g 2 PF (OptP [1]). Hence OptP is closed under mid in context PF ffi OptP. 5. t = plu. By Corollary 7.2, G is in co-NP (PP (NP)). Since B 2 NP G , B is also in P 2 (PP (NP)). <p> By Corollary 7.2, G is in P (PP (NP)), and B 2 NP G 2 NP (PP (NP)). By Lemma 6.5, B is in P (OptP <ref> [1] </ref>), and by Lemma 6.1, g 2 PF (OptP [1]). Hence OptP is closed under mid in context PF ffi OptP. 5. t = plu. By Corollary 7.2, G is in co-NP (PP (NP)). Since B 2 NP G , B is also in P 2 (PP (NP)). By Lemma 6.5, B 2 P (OptP [1]), implying in turn by <p> g 2 PF (OptP <ref> [1] </ref>). Hence OptP is closed under mid in context PF ffi OptP. 5. t = plu. By Corollary 7.2, G is in co-NP (PP (NP)). Since B 2 NP G , B is also in P 2 (PP (NP)). By Lemma 6.5, B 2 P (OptP [1]), implying in turn by Lemma 6.1 that g 2 PF (OptP [1]). Hence OptP is closed under plu in context PF ffi OptP. 2 10 Corollaries to our main theorems We summarize our results in Table 10 using a polynomial p and OptP. <p> By Corollary 7.2, G is in co-NP (PP (NP)). Since B 2 NP G , B is also in P 2 (PP (NP)). By Lemma 6.5, B 2 P (OptP <ref> [1] </ref>), implying in turn by Lemma 6.1 that g 2 PF (OptP [1]). Hence OptP is closed under plu in context PF ffi OptP. 2 10 Corollaries to our main theorems We summarize our results in Table 10 using a polynomial p and OptP. <p> Corollary 10.2 The following statements are equivalent: 1. PP ( P j <ref> [1] </ref>). i ] PF ( MM 3. d maj [ MM j [1]). i ] PF ( MM 5. d plu [ MM j [1]). Note that the above results show a qualitative difference between min and max on one hand, and the above counting operators on the other. <p> Corollary 10.2 The following statements are equivalent: 1. PP ( P j <ref> [1] </ref>). i ] PF ( MM 3. d maj [ MM j [1]). i ] PF ( MM 5. d plu [ MM j [1]). Note that the above results show a qualitative difference between min and max on one hand, and the above counting operators on the other. <p> Corollary 10.2 The following statements are equivalent: 1. PP ( P j <ref> [1] </ref>). i ] PF ( MM 3. d maj [ MM j [1]). i ] PF ( MM 5. d plu [ MM j [1]). Note that the above results show a qualitative difference between min and max on one hand, and the above counting operators on the other.
Reference: [2] <author> Amir, A., Beigel, R., and Gasarch, W. </author> <title> Some connections between bounded query classes and non-uniform complexity. </title> <booktitle> In Proc. Fifth Annual IEEE Structure in Complexity Theory Conference (1990), </booktitle> <pages> pp. 232-243. </pages>
Reference: [3] <author> Balc azar, J., Diaz, J., and Gabarr o, J. </author> <title> Structural Complexity I. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year>
Reference-contexts: We use structural complexity theory definitions for Turing machines, reducibilities, and complxity classes such as P or NP, as found in <ref> [3] </ref>. The following definitions are due to Krentel. Definition 2.1 [8] An NP metric Turing machine N is a nondeterministic polynomial time bounded TM such that every computation path writes a binary number and accepts.
Reference: [4] <author> Balc azar, J., Diaz, J., and Gabarr o, J. </author> <title> Structural Complexity II. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference: [5] <author> Cai, J., and Hemachandra, L. </author> <title> Enumerative counting is hard. </title> <booktitle> Information and Computation 82 (1989), </booktitle> <pages> 34-44. </pages>
Reference: [6] <author> Hopcroft, J., and Ullman, J. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1979. </year>
Reference: [7] <author> Kadin, J. </author> <title> Restricted Turing reducibilities and the structure of the polynomial time hierarchy. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1988. </year>
Reference-contexts: Thus, when using function oracles from MM k , Turing reductions can be replaced by metric reductions. This is not true for many-one reducibility. In fact Kadin in <ref> [7] </ref> has shown that this query saving property does not seem to hold for language oracles: Recall that P NP [k] is the 4 class of languages acceptable with at most k queries to an NP-complete oracle, and the query hierarchy QH = [ k P NP [k] . <p> Theorem 1.2 <ref> [7] </ref> If, for any k, P NP [k] = P NP [k+1] , then PH = P NP NP [log n] , a subclass of the P 3 level of PH. We do show that in general Turing reducibilities and metric reducibilities to a function oracle outside PFH differ. <p> Thus, when using function oracles from MM k , Turing reductions can be replaced by metric reductions. Kadin <ref> [7] </ref> has shown that this query saving property does not seem to hold for language oracles. Recall that P NP [k] is the class of languages acceptable with at most k queries to an NP oracle, and that the query hierarchy QH = [ k P NP [k] . <p> Recall that P NP [k] is the class of languages acceptable with at most k queries to an NP oracle, and that the query hierarchy QH = [ k P NP [k] . Theorem 4.16 <ref> [7] </ref> If, for any k, P NP [k] = P NP [k+1] , then PH = P NP NP [log n] , a subclass of the P 3 level of PH.
Reference: [8] <author> Krentel, M. </author> <title> The complexity of optimization problems. </title> <journal> J. Computer Systems Sci. </journal> <volume> 36 (1988), </volume> <pages> 490-509. </pages>
Reference-contexts: Krentel, in <ref> [8] </ref> and [9], defined and studied optimization function classes defined analogously to the languages classes of Stockmeyer's polynomial time hierarchy (PH), and therefore naturally called the polynomial time function hierarchy (PFH). <p> We use structural complexity theory definitions for Turing machines, reducibilities, and complxity classes such as P or NP, as found in [3]. The following definitions are due to Krentel. Definition 2.1 <ref> [8] </ref> An NP metric Turing machine N is a nondeterministic polynomial time bounded TM such that every computation path writes a binary number and accepts. <p> For x 2 fl , we write opt N (x) for the largest value (for a maximization problem) output by any computation of N on input x. Definition 2.2 <ref> [8] </ref> A function f : fl ! N is in OptP if there exists an NP metric Turing machine N such that for all x 2 fl ; f (x) = opt N (x). Definition 2.3 [8] Let f; g : fl ! N . <p> Definition 2.2 <ref> [8] </ref> A function f : fl ! N is in OptP if there exists an NP metric Turing machine N such that for all x 2 fl ; f (x) = opt N (x). Definition 2.3 [8] Let f; g : fl ! N . <p> all g 2 MM k , there exists an f 2 MM k such that g is metric reducible to f ; and for all g 2 MM k , there exists an f 2 MM k such that g is metric reducible to f . 13 Krentel showed in <ref> [8] </ref> that metric reductions are closed under composition. As a conse- quence F P k is closed under metric reductions. However, recall that all MM k functions are metric reducible to the canonical metric complete function KF k for MM k .
Reference: [9] <author> Krentel, M. </author> <title> Generalizations of OptP to the Polynomial Hierarchy. </title> <note> Submitted to Theoretical Computer Science (1989). </note>
Reference-contexts: Krentel, in [8] and <ref> [9] </ref>, defined and studied optimization function classes defined analogously to the languages classes of Stockmeyer's polynomial time hierarchy (PH), and therefore naturally called the polynomial time function hierarchy (PFH). <p> Definition 2.4 <ref> [9] </ref> A polynomial time k-alternating max-min Turing transducer M is a polynomial time bounded TM with k alternations of max and min functions, beginning with max, such that every terminal state outputs a whole number in binary. <p> The path with the most alternations of min and max has k or less such alternations. The inputs to the circuit are the numbers computed at the bottom of the tree. Definition 2.5 <ref> [9] </ref>. A function f : fl ! N is said to be polynomial k-alternating max-min if there exists a polynomial k-alternating max-min machine M such that, 8 x 2 fl ; f (x) = val M (x). Krentel named the class of polynomial k-alternating max-min functions MM k . <p> Recall that the k th level of the polynomial hierarchy is P k . Definition 2.6 <ref> [9] </ref>. A function f : ( fl ) m ! N is in F P k if f is computable in polynomial time with an oracle for P k1 . <p> Finally, Krentel defined an infinite hierarchy of functions, analogous to Stockmeyer's polynomial-time hierarchy, called the polynomial time function hierarchy, abbreviated PFH. Definition 2.7 <ref> [9] </ref> PFH = S k . All reductions in the following discussion are polynomial time bounded. 3 An equivalent quantifier characterization of PFH Krentel introduced the MM k functions in terms of alternating max-min transducers, a machine based characterization. <p> We will now present a theorem from <ref> [9] </ref> that constructs a metric reduction from any F P k+1 function f to a MM k function that depends only on f . Theorem 4.9 [9] Let f 2 F P k+1 . <p> We will now present a theorem from <ref> [9] </ref> that constructs a metric reduction from any F P k+1 function f to a MM k function that depends only on f . Theorem 4.9 [9] Let f 2 F P k+1 . Then f can be expressed as f (x) = h (x; g (x)) where g 2 MM k and h : fl fi N ! N is computable in polynomial time. Proof. <p> Then f can be expressed as f (x) = h (x; g (x)) where g 2 MM k and h : fl fi N ! N is computable in polynomial time. Proof. The proof is in the appendix. 2 Krentel stated the following corollary of Theorem 4.9. Corollary 4.10 <ref> [9] </ref> F P k+1 ff : fl ! N : f is metric reducible to some g 2 MM k g. We also have the following: Proposition 4.11 For all k 0, every function in F P k is metric reducible to some function in MM Proof.
Reference: [10] <author> Ladner, R., Lynch, N., and Selman, A. </author> <title> A comparison of polynomial time reducibilities. </title> <institution> Theor. Comput. Sci. </institution> <month> 1 </month> <year> (1975), </year> <pages> 103-123. </pages>
Reference: [11] <author> Li, M., and Vitanyi, P. </author> <title> An Introduction to Kolmogorov Complexity and its applications. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [12] <author> Ogiwara, M., and Hemachandra, L. </author> <title> A complexity theory for feasible closure properties. </title> <booktitle> In Proc. 6th annual Structure in Complexity Theory conference (1991), </booktitle> <pages> pp. 16-29. </pages>
Reference-contexts: For example, Ogiwara and Hemachandra in <ref> [12] </ref> present a number of negative results on closure without context (which they simply called closure) such as the following: #P, although closed under addition, is not closed under subtraction, unless the counting hierarchy CH is in UP. <p> It is helpful to consider the simplified case when the arity of the operator t is polynomially bounded in value. Ogiwara and Hemachandra in <ref> [12] </ref> proved that OptP is probably not closed under every polynomial arity, polynomial time computable operator t : Theorem 1.6 [12] If OptP is closed under every polynomial arity polynomial time computable operator then PH = NP. The above statement is made without any context class DF ffi CF . <p> It is helpful to consider the simplified case when the arity of the operator t is polynomially bounded in value. Ogiwara and Hemachandra in <ref> [12] </ref> proved that OptP is probably not closed under every polynomial arity, polynomial time computable operator t : Theorem 1.6 [12] If OptP is closed under every polynomial arity polynomial time computable operator then PH = NP. The above statement is made without any context class DF ffi CF . <p> are interested in two forms of closure, closure without context and closure under context. 5.3 Closure without context Our first series of results in this section are on those closure properties which were the focus of the theory of closure properties, for function classes, developed by Ogiwara and Hemachandra in <ref> [12] </ref>. Let f 2 F be a function of arbitrary arity i, where f : ( fl ) i ! N . <p> Ogiwara, Theirauf, Toda and Watanabe, in [13], introduce this means of studying closure properties under certain contexts that allowed more flexibility in defining what "closure" entails. The questions asked by Ogiwara and Hemachandra in <ref> [12] </ref> are of the form: "Is b t [CF ] in CF?".
Reference: [13] <author> Ogiwara, M., Thierauf, T., Toda, S., and Watanabe, O. </author> <title> On closure properties of #P in the context of PFffi#P. </title> <booktitle> In Proc. 8th annual Structure in Complexity Theory conference (1993), </booktitle> <pages> pp. 139-146. </pages>
Reference-contexts: Ogiwara, Theirauf, Toda and Watanabe, in <ref> [13] </ref>, introduce this means of studying closure properties under certain contexts that allowed more flexibility in defining what "closure" entails. The questions asked by Ogiwara and Hemachandra in [12] are of the form: "Is b t [CF ] in CF?". <p> Pragmatically speaking, allowing the extra work of PF seems entirely reasonable, because application of a "trivial" operator should not create functions of higher complexity that #P. In <ref> [13] </ref> Ogiwara, Theirauf, Toda and Watanabe introduced the notion of "context". This notion considers closure at a higher level where minor oscillations can be absorbed, revealing the more drastic changes in complexity caused by applying an operator. <p> We define sets G, the graph of g ffi f , and B, the bits encoding the graph of g ffi f , as follows: G = fhx; yi j g (f (1; x); : : : ; f (e (x); x)) = yg and The following lemma is from <ref> [13] </ref>, with OptP substituted for #P. Lemma 6.1 1. B is in NP G and g is in PF B 2. If B 2 NP, then g 2 OptP. 3. If B 2 P OptP [1] , then g 2 PF OptP [1] . Proof. 1. <p> We proceed in a manner similar to <ref> [13] </ref>. 8.3 Closure of OptP implies a collapse Recall that the sum operator sums its operands; the maj operator returns the value that occurs more than half the time amongst its operands (or ? if no such value exists); the maj w operator returns the value that occurs more than half <p> We proceed in a manner similar to <ref> [13] </ref>. 9.3 Closure of OptP under context implies a collapse Lemma 9.4 Let t be any of fsum, maj, maj w , mid, plug. If OptP is closed under t in context PF ffi OptP, then P (OptP [1]) = PP (NP). Proof. <p> This creates a P (OptP [1]) algorithm for L. (We insert a parenthetical digression here to note how OptP differs from #P with regard to closure under the operators sum and maj w . In <ref> [13] </ref>, #P is shown to be closed under maj w in context PF ffi #P. The proof depended on #P being closed under addition of exponentially many #P functions.
Reference: [14] <author> Ramachandran, J. </author> <title> Set bit enumeration is hard. </title> <booktitle> In Proceedings, Seventh Annual Structure in Complexity Theory (1992), </booktitle> <pages> pp. 58-70. </pages> <publisher> IEEE Computer Society Press. </publisher>
Reference: [15] <author> Sch oning, U. </author> <title> Complexity and Structure. </title> <booktitle> Lecture Notes in Computer Science Vol. </booktitle> <volume> 211. </volume> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference: [16] <author> Schwentick, T., and Ramachandran, J. </author> <title> A Note on Set Bit Enumeration. </title> <type> Tech. rep., </type> <institution> The Ohio State University, Department of Computer & Information Science, The Ohio State University, Columbus, Ohio, </institution> <month> 43210, </month> <year> 1994. </year>
Reference-contexts: In section 10 we conclude with a concise table of our results. The results in this paper form the basis for other results on approximating PFH functions ([14], <ref> [16] </ref>.) 2 Definitions In this section we present definitions and notation for the function classes we will be working with. We use structural complexity theory definitions for Turing machines, reducibilities, and complxity classes such as P or NP, as found in [3]. The following definitions are due to Krentel.
Reference: [17] <author> Stockmeyer, L. </author> <title> The polynomial-time hierarchy. </title> <institution> Theor. Comput. Sci. </institution> <month> 3 </month> <year> (1976), </year> <pages> 1-22. </pages>
Reference: [18] <author> Toda, S. </author> <title> PP is as hard as the polynomial time hierarchy. </title> <journal> SIAM Journal on Computing 20 (1991), </journal> <pages> 865-877. </pages>
Reference-contexts: Toda presents strong evidence for the general belief that counting classes such as PP are more powerful that PH, by showing PH P (PP), <ref> [18] </ref>. Theorem 7.1 There exists an PF (PP (NP)) algorithm for computing h. Proof. Let f 2 OptP be bounded by polynomial p, and let R be in PF such that f (i; x) = max p y [R (i; x; y)]. <p> Note that the above results show a qualitative difference between min and max on one hand, and the above counting operators on the other. This seems to be primarily due to counting operators requiring the power of the class PP, which as Toda has shown, <ref> [18] </ref>, is very powerful relative to PH. The operators max and min on the other hand do not require PP and can be computed with oracles from PH itself. The above corollaries hold with MM substituted for MM everywhere.
Reference: [19] <author> Tor an, J. </author> <title> An oracle characterization of the counting hierarchy. </title> <booktitle> In Proc. 3rd Structure in Complexity Theory Conference, IEEE (1988), </booktitle> <pages> pp. 213-223. 35 </pages>
Reference-contexts: Hence g 2 OptP. 3. Use the fact that several OptP computations can be combined into a single OptP com putation (PF OptP PF OptP [1] , Proposition 4.12) Toran in <ref> [19] </ref> shows: Proposition 6.2 A set L is in PP (NP) if and only if there exists a set A in NP, and a polynomial p, such that for every x 2 fl , it holds that x 2 L () k fw 2 =p (jxj) j hx; wi 2 Ag
References-found: 19

