URL: http://www.dfki.uni-kl.de/~vega/relfun+/overtcs.ps
Refering-URL: http://www.dfki.uni-kl.de/~vega/relfun.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Functional-logic integration via minimal reciprocal extensions  
Author: Harold Boley 
Keyword: Key words: Functional programming; Logic programming; Herbrand models; Innermost conditional narrowing; WAM compilation  
Address: Box 2080, D-67608 Kaiserslautern, Germany  
Affiliation: DFKI,  
Abstract: RELFUN reciprocally extends Horn RELations and call-by-value FUNctions just enough to yield a unified operator concept. Relations acquire application nesting and higher-order notation; functions acquire non-groundness and non-determinism. Relations are defined by Horn-like clauses implicitly returning true; functions are defined by rules with an additional returned-value premise. This minimal relational-functional kernel permits common extensions without duplicate features in logic and functional languages. Procedural and model-theoretic semantics are developed for kernel RELFUN, transferring the Herbrand models of (Horn-clause) relational programming to (first-order) functional programming. The compiler system reuses the register X1 of the Warren Abstract Machine for value returning, statically flattening general nestings while optimizing first-argument nestings. Applications include a (hyper)graph library, a CAD-to-NC transformer, and sharable knowledge bases. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Hassan Ait-Kaci and Andreas Podelski. </author> <title> Logic Programming with Functions over Order-Sorted Feature Terms. </title> <editor> In Evelina Lamma and Paola Mello, editors, </editor> <booktitle> Proceedings of the 3rd International Workshop on Extensions of Logic Programming, ELP '92, Bologna 1992, volume 660 of LNAI. </booktitle> <publisher> Springer, </publisher> <year> 1993. </year> <month> 23 </month>
Reference-contexts: Since there is still some lack of reports on applications of relational-functional languages (comparable to the RELFUN applications sketched in section 4), this aspect will not appear here. Sorts and constraints: LIFE (Logic, Inheritance, Functions, Equations) <ref> [1] </ref> generalizes first-order constructor terms to -terms, built from sorts with an unordered, varying-length attachment of features (attributes); these are unified during relation calls in a special manner, involving the computation of the greatest lower bound (glb) in an explicit sort lattice.
Reference: [2] <author> Harold Boley. </author> <title> A relational/functional language and its compilation into the WAM. </title> <type> Technical Report SEKI SR-90-05, </type> <institution> University of Kaiserslautern, Department of Computer Science, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: The implementation of RELFUN generally rests on a definitional interpreter for operationally specifying the language, compilers/emulators that extend the WAM (Warren Abstract Machine) for executing it efficiently, and source-to-source transformers for reducing language extensions or preparing programs to source-to-instruction compilation (cf. <ref> [2] </ref> and [8]). Normally, there are alternative paths for efficiently running a RELFUN program. <p> In both languages, the higher-order syntax, although very useful, can be reduced to a first-order (Horn-logic) semantics by introducing an apply dummy operator [28]. Problems of its (more direct) WAM implementation are discussed in [11] as well as <ref> [2] </ref>. 6 Conclusions This paper has given an approach to minimality of an integrated declarative kernel language.
Reference: [3] <author> Harold Boley. </author> <title> Declarative operations on nets. </title> <editor> In Fritz Lehmann, editor, </editor> <booktitle> Semantic Networks in Artificial Intelligence, </booktitle> <volume> volume 23, </volume> <pages> pages 601-637. </pages> <note> Special Issue of Computers & Mathematics with Applications, Pergamon Press, 1992. Preprinted as: DFKI Research Report RR-90-12, </note> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: Generally, we have fo-cused the representation of engineering knowledge, supporting its evolutionary maintenance and inferential use. 1. Declarative (hyper)graph representation and processing: Directed recursive labelnode hypergraphs, which generalize directed labeled graphs with regards to more natural modeling of multi-level structures and n-ary relationships, were embedded into RELFUN <ref> [3] </ref>. Operations on such (generalized) graphs are specified in a declarative fashion to enhance readability and maintainability. For this, graphs are represented as nested RELFUN terms kept in a normal form by rules associated directly with their constructors.
Reference: [4] <author> Harold Boley. </author> <title> Extended Logic-plus-Functional Programming. </title> <editor> In Lars-Henrik Eriksson, Lars Hallnas, and Peter Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the 2nd International Workshop on Extensions of Logic Programming, ELP '91, Stockholm 1991, volume 596 of LNAI. </booktitle> <publisher> Springer, </publisher> <year> 1992. </year>
Reference-contexts: We approach certain issues of such an integration with an emphasis on syntactic and semantic simplicity as called for by practical use. The discussion is based on our experience with the design, semantics, implementation, and use of the RELFUN (RELational-FUNctional) language <ref> [4] </ref>. We first consider characteristics of PROLOG-like relational programming and LISP-like functional programming wrt relational-functional cross-extension and integration. The resulting relational-functional language design, kernel RELFUN, then provides a platform for the study of further useful extensions preserving uniformity.
Reference: [5] <author> Harold Boley. </author> <title> A Direct Semantic Characterization of RELFUN. </title> <editor> In Evelina Lamma and Paola Mello, editors, </editor> <booktitle> Proceedings of the 3rd International Workshop on Extensions of Logic Programming, ELP '92, Bologna 1992, volume 660 of LNAI. </booktitle> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: will immediately benefit both its relations and functions. 4 Thus, full RELFUN's OR-sequential single-cut separator "!" would correspond to an (optional) OR-parallel commit operator "|" in (extended) committed-choice languages. 6 3 Semantics and Implementation The semantics of the first-order-reduced RELFUN kernel is formalized by equivalent procedural, fixpoint, and model-theoretic means <ref> [5] </ref>, extending those of logic programming [24]. In particular, the procedural SLD-resolution for Horn-clause programs is extended to SLV-resolution for valued-clause programs, e.g. accomodating value returning and operator nesting. <p> The semantic notions treated here draw heavily on chapters 1 and 2 of J. W. Lloyd's book [24], exploiting a parallel between Horn-clause relations and first-order functions while focusing functions (omitted definitions, lemmas, and proofs can be found in <ref> [5] </ref>). This relational-functional parallel simplifies transferring soundness and completeness results of logic programming to eager, non-ground, non-deterministic first-order functional programming and to unified relational-functional programming. It is thus attempted to complement the `function-translating' characterization of innermost narrowing in [10] by a `function-modeling' characterization. <p> Then a formula can be given a truth value, true or false, (wrt I 10 and V ) as follows (only formulas that are relationships or unconditional or conditional directed equations are treated here; for full cases see <ref> [5] </ref>): (1) If the formula has the form r (E 1 ; : : : ; E n ), then the truth value of the formula is true if there exist t 0 1 2 E 0 n 2 E 0 n such that r 0 (t 0 1 ; : <p> The success set of all ground molecules e :& t such that P f [ f :& eg is SLV-refutable with t is equal to the least Herbrand cross model of P f , shown in the introductory table (for general proof see theorem 3 in <ref> [5] </ref>). Example 3 Employing the programs Q f and Q r , defined in the table below, Q f [ f :& omegaf ()g has no functional SLV-refutation, just as the equivalent Q r [ f :- omegar (U )g has no relational SLD-refutation. <p> We have to show that 8 ((B 1 ^ : : : ^ B k ) 1 : : : n ) is a logical consequence of P . The result is proved by induction on the length of the refutation (see <ref> [5] </ref>). The result for relational goals naturally carries over to functional goals, since :- B 1 ; : : : ; B k & F is `equivalent' to :- B 1 ; : : : ; B k ; (x .= F ) with x a new variable. <p> Since is correct, 8 ((B 1 ^ : : : ^ B k )) is a logical consequence of P . By lemma 5 in <ref> [5] </ref> there exists a refutation of P [ f :- B i g such that the computed answer is the identity, for 1 i k. We can combine these refutations into a refutation of P [ f :- G r g such that the computed answer is the identity.
Reference: [6] <author> Harold Boley. </author> <title> Finite Domains and Exclusions as First-Class Citizens. </title> <editor> In Roy Dyckhoff, editor, </editor> <booktitle> Proceedings of the 4th International Workshop on Extensions of Logic Programming, </booktitle> <address> ELP '93, St. Andrews, Scotland, </address> <year> 1993, </year> <title> volume 798 of LNAI. </title> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: the `most specific generalization' of PROLOG relations and LISP functions via four essential cross-extensions (detailed below). (2) Pure RELFUN extends this integrated kernel (i.e., relations and functions) mainly by constructors and operators of varying arities, a `first-class' reconstruction of the practically established finite domains (and the complementary, new finite exclusions <ref> [6] </ref>), and order-sorted logics; full RELFUN again extends the pure sublanguage by `single-cut' determinism specification for operator definitions, relational-functional meta-calls, (graphical) I/O, debugging tools, etc.
Reference: [7] <author> Harold Boley, Ulrich Buhrmann, and Christof Kremer. </author> <title> Towards a sharable knowledge base on recyclable plastics. </title> <editor> In James K. McDowell and Kenneth J. Meltsner, editors, </editor> <booktitle> Knowledge-Based Applications in Materials Science and Engineering, </booktitle> <pages> pages 29-42. TMS, </pages> <year> 1994. </year>
Reference-contexts: Sharable knowledge bases for materials science and engineering: Physical/chemical properties of the elements and their groupings (ELEMENTS) as well as engineering properties of certain plastics pertaining to production/recycling (RTPLAST) <ref> [7] </ref> have been provided as sharable REL-FUN knowledge bases.
Reference: [8] <author> Harold Boley, Klaus Elsbernd, Hans-Gunther Hein, Thomas Krause, Markus Perling, Michael Sintek, and Werner Stein. </author> <title> RFM Manual: Compiling RELFUN into the Relational/Functional Machine. Document D-91-03, </title> <institution> DFKI GmbH, </institution> <month> July </month> <year> 1996. </year> <note> Third, Revised Edition. </note>
Reference-contexts: The implementation of RELFUN generally rests on a definitional interpreter for operationally specifying the language, compilers/emulators that extend the WAM (Warren Abstract Machine) for executing it efficiently, and source-to-source transformers for reducing language extensions or preparing programs to source-to-instruction compilation (cf. [2] and <ref> [8] </ref>). Normally, there are alternative paths for efficiently running a RELFUN program. <p> (t; ) for P [ fG f g there exists a computed answer (s; ) for P [ fG f g and a substitution fl such that G f 3.2 Compilation into an Extended WAM The implementation concepts focussed here are transformation and code generation; for other compiler parts see <ref> [8] </ref>. First we discuss the static flattener as a central step in the compiler's source-to-source transformers, also invokable interactively by the flatten command. Clauses can always be flattened by recursively replacing evaluative (parenthesized) subformulas by variables [10].
Reference: [9] <author> Harold Boley, Markus Perling, and Michael Sintek. </author> <title> Transforming Workpiece Geometries into Lathe-NC Programs by Qualitative Simulation. </title> <editor> In Ulrich Geske, editor, </editor> <booktitle> Session on Simulation with Knowledge-Based Systems of the 15th IMACS World Congress on Scientific Computation, Modelling and Applied Mathematics. </booktitle> <publisher> Wissenschaft und Technik Verlag, </publisher> <address> Berlin, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: The package includes generalized set operations, structure-reducing operations, and extended path searching. 2. Generation of abstract NC programs from CAD-like geometries: In our COLAB suite of experimental NC-program generators for lathe turning of rotational-symmetric workpieces, one version was written entirely in REL-FUN <ref> [9] </ref>. This mainly functional program consists of three principal transformation components, which can be used individually and in combination. First, a term representation of the CAD-like geometrical raw data is parsed into a recursively classified workpiece, exhibiting production-relevant workpiece features (e.g. `grooves' and `shoulders') as a nested term.
Reference: [10] <author> P.G. Bosco, E. Giovannetti, and C. Moiso. </author> <title> Narrowing vs. </title> <journal> SLD-resolution. Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 3-23, </pages> <year> 1988. </year>
Reference-contexts: This relational-functional parallel simplifies transferring soundness and completeness results of logic programming to eager, non-ground, non-deterministic first-order functional programming and to unified relational-functional programming. It is thus attempted to complement the `function-translating' characterization of innermost narrowing in <ref> [10] </ref> by a `function-modeling' characterization. Since our model notion reflects call-by-value flattening, also our notion of completeness will differ from the general one in [20], as illustrated by example 3. <p> First we discuss the static flattener as a central step in the compiler's source-to-source transformers, also invokable interactively by the flatten command. Clauses can always be flattened by recursively replacing evaluative (parenthesized) subformulas by variables <ref> [10] </ref>. In the resulting flattened clauses the subformulas to be evaluated become ".="-rhs formulas, which simplifies their call-by-value reduction. Since a nesting of evaluative subformulas leads to a conjunction of ".="-calls, non-deterministic subformulas can be managed by the WAM's standard backtracking techniques, thus avoiding the direct handling of non-deterministic nestings.
Reference: [11] <author> Weidong Chen, Michael Kifer, and David S. Warren. HiLog: </author> <title> A Foundation for Higher-Order Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 15 </volume> <pages> 187-230, </pages> <year> 1993. </year>
Reference-contexts: The implementation of both languages uses an extended WAM: ALF has integrated deterministic rewriting into the WAM; RELFUN uses a WAM-coupled abstract stack machine for deterministic functions [27] (non-deterministic functions being WAM-integrated). 21 Higher-order notation: HiLog <ref> [11] </ref> extends Horn clauses by a higher-order syntax and allows arbitrary terms in places where constructors (functors) and relation names occur in predicate calculus. The same is true for RELFUN. For instance, a variable used as a constructor permits elegant structure traversal in both HiLog and RELFUN. <p> In both languages, the higher-order syntax, although very useful, can be reduced to a first-order (Horn-logic) semantics by introducing an apply dummy operator [28]. Problems of its (more direct) WAM implementation are discussed in <ref> [11] </ref> as well as [2]. 6 Conclusions This paper has given an approach to minimality of an integrated declarative kernel language.
Reference: [12] <editor> D. DeGroot and G. Lindstrom, editors. </editor> <title> Logic Programming: Functions, Relations, and Equations. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Historically, however, non-ground functional programming was proposed as a result of relational-functional integrations <ref> [12] </ref>, while non-deterministic functional programming was first introduced as a purely functional generalization [22]. (F1) The functional essential of application values (function applications return value terms, hence can be nested into `functional compositions') will be transferred to relational programming as follows: a relation that holds (its call succeeds) always returns the
Reference: [13] <author> Nachum Dershowitz. </author> <title> Goal Solving as Operational Semantics. </title> <editor> In John Lloyd, editor, </editor> <booktitle> Proceedings of the International Symposium on Logic Programming, </booktitle> <pages> pages 3-17, </pages> <address> Cambridge, December 1995. </address> <publisher> MIT Press. </publisher> <pages> 24 </pages>
Reference-contexts: But our RELFUN experience suggests that the simpler eager evaluation strategy may be superior in practice. Presumed advantages of laziness may turn out to be reproducible eagerly, as in the proposal to replace lazy streams by free length-counting logic variables <ref> [13] </ref>. This issue should be further studied by systematically comparing eager and lazy versions of declarative programs. Another open discussion is deterministic vs. non-deterministic functions.
Reference: [14] <author> J. H. Fasel, P. Hudak, S. Peyton-Jones, and P. Wadler. </author> <title> Special Issue on the Functional Programming Language Haskell. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(5), </volume> <year> 1992. </year>
Reference-contexts: 1 Introduction The two classical declarative paradigms are applicative (functional) programming in the tradition of pure LISP and logic (relational) programming following pure PROLOG. Basic communalities between these or modern functional (e.g., Haskell <ref> [14] </ref>) and relational (e.g., Godel [23]) languages have led to increasing efforts at their integration in search of a unified declarative paradigm ? This research was supported by the Univ. Kaiserslautern, the SFB 314, and the BMFT under Grants ITW 8902 C4 and 413-5839-ITW9304/3.
Reference: [15] <author> Laurent Fribourg. </author> <title> Oriented equational clauses as a programming language. </title> <journal> J. Logic Programming, </journal> <volume> 1(2) </volume> <pages> 165-177, </pages> <year> 1984. </year>
Reference-contexts: Simultaneously, the underlying Herbrand (base) models, containing ground `atoms' (flat relationships), are extended to Herbrand cross models, containing ground `molecules' (flat function applications asymmetrically ":&"-paired with terms). Instead of all ground term equations in the Herbrand base for models of logics with (e.g., symmetry-axiomatized) equality <ref> [15] </ref>, the Herbrand base for cross models thus contains all ground `innermost' defined-function applications associated with all ground terms, denoting their ultimate computation values (just as the usual Herbrand base contains all ground relation applications, denoting their ultimate truth).
Reference: [16] <author> Laurent Fribourg. SLOG: </author> <title> A logic programming language interpreter based on clausal superposition and rewriting. </title> <booktitle> In 1985 Symposium on Logic Programming, </booktitle> <pages> pages 172-184. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1985. </year>
Reference-contexts: With call-by-value (eager) evaluation of functional applications this will lead to innermost conditional narrowing <ref> [16] </ref>. (R2) Since a non-ground (e.g., inverse) function call may deliver several `solution values', this also entails a transfer of the relational essential of (don't-know) non-determinism (solution search, implemented by backtracking enumeration as in PROLOG) to functional programming. <p> The least Herbrand cross model of P f is shown in the above table. We now extend SLD-resolution to first-order relational-functional clauses, where the SLD-case will be called body resolution. The extended resolution method, similar to innermost conditional narrowing <ref> [16] </ref>, will be called SLV-resolution (SL-resolution for Valued clauses i.e., RELFUN's Definite-clause extension). It provides the set of inference rules of a first-order relational-functional theory; their application conditions specify a partial derivation order. The detailed example 2 will illustrate many SLV-resolution concepts.
Reference: [17] <author> J.C. Gonzalez-Moreno, M.T. Hortala-Gonzalez, and M. </author> <month> Rodrguez-Artalejo. </month>
Reference-contexts: Both relational essentials (R1, R2) and one of the functional essentials (F1) are semantically incorporated into the kernel. The other functional essential, higher-order functions (F2), is incorporated only syntactically. While this considerably simplified the model theory, there remains the challenge of adapting Henkin models [25], Hoare powerdomains <ref> [17] </ref>, or some other higher-order semantics for the first-order relational-functional essentials (R1, R2, F1): Except from the (presumably, rare) cases where its full expressive power is needed, this adaptation should preserve the simplicity of our current higher-order notation (F2), compatible with Herbrand models. <p> However, here we opted for allowing the more general non-deterministic case even in the RELFUN kernel: thus assimilating functions to (per se nondeterministic) relations, our tight relational-functional integration is actually simplified. Future work should profit from detailed comparisons with the rewriting logic of <ref> [17] </ref>, since, like RELFUN, it uses non-deterministic functions and, unlike RELFUN, lazy narrowing, as well as with the standardization proposal Curry [21], since, unlike RELFUN, it uses deterministic functions and needed narrowing.
References-found: 17

