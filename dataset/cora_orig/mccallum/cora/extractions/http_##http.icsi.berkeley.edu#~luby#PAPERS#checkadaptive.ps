URL: http://http.icsi.berkeley.edu/~luby/PAPERS/checkadaptive.ps
Refering-URL: http://http.icsi.berkeley.edu/~luby/self.html
Root-URL: http://http.icsi.berkeley.edu
Title: (Extended Abstract) The adaptive and private checkers given are general techniques that work for a
Author: Manuel Blum Michael Luby Ronitt Rubinfeld 
Date: May 17, 1990  
Address: Berkeley, California 94720  Berkeley, California 94704  Berkeley, California 94720  
Affiliation: Computer Science Division U.C. Berkeley  International Computer Science Institute  Computer Science Division U.C. Berkeley  
Note: Cryptographic Settings  Supported by NSF Grant No. CCR 88-13632. Supported by an IBM Graduate Fellowship and NSF Grant No. CCR 88-13632.  
Abstract: Program Result Checking Against Adaptive Programs and in Abstract The theory of program result checking introduced in [Blum] allows one to check that a program P correctly computes the function f on input x. The checker may use P 's outputs on other inputs to help it check that P (x) = f(x). In this setting, P is always assumed to be a fixed program, whose output on input x is a function P (x). We extend the theory to check a program P which returns a result on input x that may depend on previous questions asked of P . We call a checker that works for such a program an adaptive checker. We consider the case where there is an adaptive program that supposedly computes f running on each of several noninteracting machines. We design adaptive checkers that work for a constant number of independent and noninteracting programs. We also consider the following cryptographic scenario: A user wants to evaluate function f on input x using program P running on another machine. As in checking, the user does not trust the program to be correct. The additional requirement is that the user wants to let the other machine know as little information as possible about x from the questions asked of the program P (for example, the user may want the program to be able to learn at most the input size) as in [Abadi Feigenbaum Kilian] [Beaver Feigenbaum]. We call a program that satisfies the above constraints a private checker. As is the case for adaptive checking, we consider the case where there is a program that supposedly computes f on each of several noninteracting machines. We design private checkers that work for a constant number of independent and noninteracting programs. 
Abstract-found: 1
Intro-found: 1
Reference: [Adleman Huang Kompella] <author> Adleman, L., Huang, M., Kompella, K., </author> <type> Personal communication through L. Adleman. </type>
Reference-contexts: An adaptive checker is automatically a k-adaptive checker, and a k-adaptive checker is auto 2 matically a (non-adaptive) checker. Many checkers that have been found are also adaptive checkers. For example, it can easily be seen that the GCD checker in <ref> [Adleman Huang Kompella] </ref> and that all of the checkers given in [Blum Kannan] are adaptive. Other checkers do not work for an adaptive program. Examples of such checkers are the ones in [Blum Luby Rubinfeld], where adaptive programs can easily fool the checkers. <p> Previous to our work, [Kaminski] introduced a result checker for integer and polynomial multiplication based on computing the result of the program mod small special numbers. This checker trivially works for an adaptive program as well, because it makes no extra calls to the program. Independently of our work, <ref> [Adleman Huang Kompella] </ref> describe a result checker for multiplication in the same spirit but different than [Kaminski].
Reference: [Abadi Feigenbaum Kilian] <author> Abadi, M., Feigenbaum, J., Kilian, J., </author> <title> "On Hiding Information from an Oracle", </title> <journal> Journal of Computer and System Sciences, </journal> <volume> Vol. 39, No. 1, </volume> <month> August </month> <year> 1989, </year> <pages> pp. 29-50. </pages>
Reference-contexts: This is similar to the model introduced in <ref> [Abadi Feigenbaum Kilian] </ref> and later extended in [Beaver Feigenbaum] to allow using several non-communicating programs for the same function, except that here we do not trust the program to return correct answers. In addition, we only allow protocols which are restricted versions of [Abadi Feigenbaum Kilian] [Beaver Feigenbaum] where the checker <p> is similar to the model introduced in <ref> [Abadi Feigenbaum Kilian] </ref> and later extended in [Beaver Feigenbaum] to allow using several non-communicating programs for the same function, except that here we do not trust the program to return correct answers. In addition, we only allow protocols which are restricted versions of [Abadi Feigenbaum Kilian] [Beaver Feigenbaum] where the checker may only ask the program questions of the form "What is the value of f (x)?". <p> As in <ref> [Abadi Feigenbaum Kilian] </ref>, we define L to be a function which we call the leak function. Intuitively, L (x) is the amount of information leaked by the checker to the programs on input x. <p> For all problems, the checker algorithms are both efficient and different. Furthermore, the checker algorithms consists of the execution of the following basic operations at most a logarithmic number of times in a prescribed order: (1) calls to P on random instances of the problem; (2) additions; (3) comparisons. <ref> [Abadi Feigenbaum Kilian] </ref> show that there is not likely to be a (1; jxj)-private checker for SAT that runs in polynomial time (not including the time required by the oracle). [Beaver Feigenbaum] describe how to compute any function privately with O (jxj) oracles that are trusted not to err, however the
Reference: [Babai Fortnow Lund] <author> Babai, L., Fortnow, L., Lund, C., </author> <title> "Non-Deterministic Exponential Time has Two-Prover Interactive Protocols", </title> <type> Technical Report 90-03, </type> <institution> University of Chicago, Dept. of Computer Science. </institution>
Reference-contexts: A question that arises naturally is whether a checker can in general be converted into a 1-adaptive checker, as opposed to 2-adaptive. Since there is a complete language in NEXPTIME that has a checker <ref> [Babai Fortnow Lund] </ref>, there is no general technique that converts any checker into a 1-adaptive checker unless NEXPTIME=PSPACE. To see this, suppose there is such a general technique and consider the checker for the complete language in NEXPTIME.
Reference: [Beaver Feigenbaum] <author> Beaver, D., Feigenbaum, J., </author> <title> "Hiding Instance in Multioracle Queries", </title> <note> To appear in Proceedings of STACS 1990. </note>
Reference-contexts: This is similar to the model introduced in [Abadi Feigenbaum Kilian] and later extended in <ref> [Beaver Feigenbaum] </ref> to allow using several non-communicating programs for the same function, except that here we do not trust the program to return correct answers. In addition, we only allow protocols which are restricted versions of [Abadi Feigenbaum Kilian] [Beaver Feigenbaum] where the checker may only ask the program questions of <p> the model introduced in [Abadi Feigenbaum Kilian] and later extended in <ref> [Beaver Feigenbaum] </ref> to allow using several non-communicating programs for the same function, except that here we do not trust the program to return correct answers. In addition, we only allow protocols which are restricted versions of [Abadi Feigenbaum Kilian] [Beaver Feigenbaum] where the checker may only ask the program questions of the form "What is the value of f (x)?". <p> of times in a prescribed order: (1) calls to P on random instances of the problem; (2) additions; (3) comparisons. [Abadi Feigenbaum Kilian] show that there is not likely to be a (1; jxj)-private checker for SAT that runs in polynomial time (not including the time required by the oracle). <ref> [Beaver Feigenbaum] </ref> describe how to compute any function privately with O (jxj) oracles that are trusted not to err, however the oracles are not restricted to answer questions of the form "What is the value of f (x)?". [Beaver Feigenbaum Kilian Rogaway] later improved this result to show that it can <p> Recently [Feigenbaum Kannan Nisan] have shown that random boolean functions are not k-random-self-reducible for any polynomial k, and that if a function is 2-random-self-reducible, then the function can be computed nonuniformly in nondeterministic polynomial time. <ref> [Beaver Feigenbaum] </ref> [Lipton] show that any function that is a polynomial of degree d over a finite field is d-random-self-reducible.
Reference: [Beaver Feigenbaum Kilian Rogaway] <author> Beaver, D., Feigenbaum, J., Kilian, J., Rogaway, P., </author> <title> "Cryptographic Applications of Locally Random Reductions", </title> <institution> AT&T Bell Laboratories Technical Memorandum, </institution> <month> November </month> <year> 1989. </year> <month> 10 </month>
Reference-contexts: runs in polynomial time (not including the time required by the oracle). [Beaver Feigenbaum] describe how to compute any function privately with O (jxj) oracles that are trusted not to err, however the oracles are not restricted to answer questions of the form "What is the value of f (x)?". <ref> [Beaver Feigenbaum Kilian Rogaway] </ref> later improved this result to show that it can be done with O (jxj= log jxj) oracles. The notion of random-self-reducibility, as defined in [Feigenbaum Kannan Nisan], is related to private checking because it is possible to privately compute random-self-reducible functions.
Reference: [Blum] <author> Blum, M., </author> <title> "Designing programs to check their work". </title> <note> Submitted to CACM. </note>
Reference-contexts: One of the main difficulties of this task is that when P is implemented, it is difficult to verify that P (x) = f (x) for all inputs x. The theory of program result checking, introduced by <ref> [Blum] </ref>, provides a way of doing this. Intuitively, a checker C for f makes calls to a program P that supposedly computes f . C is a program that is much "different" than any correct program for computing f .
Reference: [Blum Kannan] <author> Blum, M., Kannan, S., </author> <title> "Program correctness checking ... and the design of programs that check their work", </title> <note> STOC 1989. </note>
Reference-contexts: Many checkers that have been found are also adaptive checkers. For example, it can easily be seen that the GCD checker in [Adleman Huang Kompella] and that all of the checkers given in <ref> [Blum Kannan] </ref> are adaptive. Other checkers do not work for an adaptive program. Examples of such checkers are the ones in [Blum Luby Rubinfeld], where adaptive programs can easily fool the checkers. At the present time we see no way to convert such a checker into an adaptive checker.
Reference: [Blum Luby Rubinfeld] <author> Blum, M., Luby, M., Rubinfeld, R., </author> <title> "Program Result Checking Against Adaptive Programs and in Cryptographic Settings", </title> <note> to appear in proceedings of STOC 1990. </note>
Reference-contexts: For example, it can easily be seen that the GCD checker in [Adleman Huang Kompella] and that all of the checkers given in [Blum Kannan] are adaptive. Other checkers do not work for an adaptive program. Examples of such checkers are the ones in <ref> [Blum Luby Rubinfeld] </ref>, where adaptive programs can easily fool the checkers. At the present time we see no way to convert such a checker into an adaptive checker. However, if more than one copy of the program exists, we show that a checkers based on the methods in [Blum Luby Rubinfeld] <p> ones in <ref> [Blum Luby Rubinfeld] </ref>, where adaptive programs can easily fool the checkers. At the present time we see no way to convert such a checker into an adaptive checker. However, if more than one copy of the program exists, we show that a checkers based on the methods in [Blum Luby Rubinfeld] can work for adaptive programs. Next suppose we are in the following cryptographic situation: A user wants to evaluate function f on input x using program P running on another machine. As in checking, the user does not trust the program to be correct. <p> The checkers given in this paper are all based on the algorithms given in <ref> [Blum Luby Rubinfeld] </ref>, though the proofs are different. They apply to integer multiplication, the mod function, modular multiplication, modular exponentiation, integer division, and polynomial and matrix multiplication over finite fields. For all problems, the checker algorithms are both efficient and different. <p> Thus, if the number of calls made to the program is not constant, the extra work done by their technique is not of the same time order. For example, we give a way of converting one of the checking techniques in <ref> [Blum Luby Rubinfeld] </ref>, which makes O (log n) calls to the program, into an adaptive checker which is of the same efficiency as the original checker. <p> Also previous to our work, [Freivalds] introduced 4 a result checker for matrix multiplication which does not call the program. 3 Three Properties of Functions The three properties described in this section are also described in <ref> [Blum Luby Rubinfeld] </ref> and for completeness we include them here. We build checkers for functions that have these properties. We include the running example of multiplication in order to show how the definitions are applied to a specific problem. <p> The checker is an adaptation of the self-testing/correcting pair using the method based on reduction to smaller sized inputs given in <ref> [Blum Luby Rubinfeld] </ref>. Algorithm: The algorithm is designed to run asking questions of programs P 1 ; . . . ; P c 1 running on noncommunicating machines. We describe the algorithm as if the questions are asked and immediately answered. <p> For i = 1; . . .; c 1 , ff i P i (^a i ): answer F (n; ^x; G (n; ^x; R); ff 1 ; . . . ; ff c 1 ) This checker is based on the checker in <ref> [Blum Luby Rubinfeld] </ref> which tests the program on successively larger ranges, bootstrapping on the fact that the smaller ranges have already been tested. Since testing has no meaning for an adaptive program, the proofs in [Blum Luby Rubinfeld] do not work in this setting. <p> . . ; ff c 1 ) This checker is based on the checker in <ref> [Blum Luby Rubinfeld] </ref> which tests the program on successively larger ranges, bootstrapping on the fact that the smaller ranges have already been tested. Since testing has no meaning for an adaptive program, the proofs in [Blum Luby Rubinfeld] do not work in this setting. In fact, a naive implementation of the protocol described in [Blum Luby Rubinfeld] can be fooled by c 1 adaptive programs, because the adaptive program can figure out where the checker is in the computation by the questions asked of it, and <p> Since testing has no meaning for an adaptive program, the proofs in <ref> [Blum Luby Rubinfeld] </ref> do not work in this setting. In fact, a naive implementation of the protocol described in [Blum Luby Rubinfeld] can be fooled by c 1 adaptive programs, because the adaptive program can figure out where the checker is in the computation by the questions asked of it, and lie accordingly. The above protocol overcomes this by asking the questions on each machine in a random order. <p> The above protocol overcomes this by asking the questions on each machine in a random order. Using the techniques of [Fortnow Rompel Sipser], one can simply transform the checker in <ref> [Blum Luby Rubinfeld] </ref> into a 2-adaptive checker, with an additional cost of O (log n) multiplicative overhead in the running time over the original checker. On the other hand, the adaptive checker presented here is as efficient as the original checker of [Blum Luby Rubinfeld]. <p> Sipser], one can simply transform the checker in <ref> [Blum Luby Rubinfeld] </ref> into a 2-adaptive checker, with an additional cost of O (log n) multiplicative overhead in the running time over the original checker. On the other hand, the adaptive checker presented here is as efficient as the original checker of [Blum Luby Rubinfeld]. Theorem 1: Any function which is computable by random inputs and computable by smaller inputs has a different and T (x)-efficient (c 1 ; L)-private/adaptive checker, where T (x) = L (x) is the size of x. <p> The checker is both different and efficient. It is also possible to construct an adaptive and private checker for any function computable by random homomorphisms. The checker is an adaptation of the self-testing/correcting pair using the method based on computability by random homomorphisms given in <ref> [Blum Luby Rubinfeld] </ref>. Theorem 2: Any function which is computable by random homomorphisms has efficient and different 2-adaptive and (k; L)-private/adaptive checkers, for constant k = maxf4; c 1 + 1g, where L (x) = G (G is the underlying group). <p> Otherwise, if the original checker would have returned "FAULTY", or if the second program answers differently than the first, the adaptive checker returns "FAULTY". An adaptation of the algorithm for self-testing/correcting based on computability by random homomorphisms in <ref> [Blum Luby Rubinfeld] </ref> combined with the technique of [Fortnow Rompel Sipser] proves Theorem 2. Corollary 2.1:There is a 2-adaptive and (5; L)-private/adaptive checker for modular multiplication f (a; b; q) = a fi b mod q, where L (a; b; q) = fjaj; jbj; qg.
Reference: [Feigenbaum Kannan Nisan] <author> Feigenbaum, J., Kannan, S., Nisan, N., </author> <title> "Lower Bounds on Random-Self-Reducibility", </title> <booktitle> to appear in proceedings of Structure in Complexity Theory Conference, </booktitle> <year> 1990. </year>
Reference-contexts: The notion of random-self-reducibility, as defined in <ref> [Feigenbaum Kannan Nisan] </ref>, is related to private checking because it is possible to privately compute random-self-reducible functions. Recently [Feigenbaum Kannan Nisan] have shown that random boolean functions are not k-random-self-reducible for any polynomial k, and that if a function is 2-random-self-reducible, then the function can be computed nonuniformly in nondeterministic polynomial <p> The notion of random-self-reducibility, as defined in <ref> [Feigenbaum Kannan Nisan] </ref>, is related to private checking because it is possible to privately compute random-self-reducible functions. Recently [Feigenbaum Kannan Nisan] have shown that random boolean functions are not k-random-self-reducible for any polynomial k, and that if a function is 2-random-self-reducible, then the function can be computed nonuniformly in nondeterministic polynomial time. [Beaver Feigenbaum] [Lipton] show that any function that is a polynomial of degree d over a finite
Reference: [Fortnow] <author> Fortnow, L., </author> <title> "Complexity-Theoretic Aspects of Interactive Proof Systems", </title> <type> Tech Report MIT/LCS/TR-447, </type> <month> May </month> <year> 1989. </year>
Reference: [Fortnow Rompel Sipser] <author> Fortnow, L., Rompel, J., Sipser, M., </author> <title> "On the Power of Multi-Prover Interactive Protocols", </title> <booktitle> Proc. 3 rd Structure in Complexity Theory Conference, </booktitle> <year> 1988, </year> <pages> pp. 156-161. </pages>
Reference-contexts: In <ref> [Fortnow Rompel Sipser] </ref>, there is a general technique for turning any checker into a 2-adaptive checker. This technique can actually be used for many of the checkers. However, it requires a quadratic blowup in the number of calls made. <p> For example, we give a way of converting one of the checking techniques in [Blum Luby Rubinfeld], which makes O (log n) calls to the program, into an adaptive checker which is of the same efficiency as the original checker. The techniques of <ref> [Fortnow Rompel Sipser] </ref> yield an adaptive checker that is slower than the original checker by a multiplicative factor of O (log n). Previous to our work, [Kaminski] introduced a result checker for integer and polynomial multiplication based on computing the result of the program mod small special numbers. <p> The above protocol overcomes this by asking the questions on each machine in a random order. Using the techniques of <ref> [Fortnow Rompel Sipser] </ref>, one can simply transform the checker in [Blum Luby Rubinfeld] into a 2-adaptive checker, with an additional cost of O (log n) multiplicative overhead in the running time over the original checker. <p> Theorem 2: Any function which is computable by random homomorphisms has efficient and different 2-adaptive and (k; L)-private/adaptive checkers, for constant k = maxf4; c 1 + 1g, where L (x) = G (G is the underlying group). Proof idea of Theorem 2: <ref> [Fortnow Rompel Sipser] </ref> show how to transform any checker into a 2-adaptive checker by simply running the original checking protocol with the first program. If the original checker would have accepted, a random question asked of the first program is chosen, and is also asked of the second program. <p> Otherwise, if the original checker would have returned "FAULTY", or if the second program answers differently than the first, the adaptive checker returns "FAULTY". An adaptation of the algorithm for self-testing/correcting based on computability by random homomorphisms in [Blum Luby Rubinfeld] combined with the technique of <ref> [Fortnow Rompel Sipser] </ref> proves Theorem 2. Corollary 2.1:There is a 2-adaptive and (5; L)-private/adaptive checker for modular multiplication f (a; b; q) = a fi b mod q, where L (a; b; q) = fjaj; jbj; qg. The checkers are both different and efficient. <p> Corollary 2.3:There is a 2-adaptive and (4; L)-private/adaptive checker for the exponentiation mod a prime function f (a; x; p) = a x mod p, where L (a; x; p) = fa; jxj; pg. The checkers are both 9 different and efficient. 5 Open Questions By the results of <ref> [Fortnow Rompel Sipser] </ref>, any checker can be converted into a 2-adaptive checker. A question that arises naturally is whether a checker can in general be converted into a 1-adaptive checker, as opposed to 2-adaptive. <p> Since there is probably no general technique for converting a checker into a 1-adaptive checker, it would be interesting to charactize which problems do have adaptive checkers. Another interesting question is under what conditions on L it is true that a (1; L)-private checker is always a 1-adaptive checker? <ref> [Fortnow Rompel Sipser] </ref> have shown a technique by which any checker can be made into a 2-adaptive checker.
Reference: [Freivalds] <author> Freivalds, </author> <title> R.,"Fast Probabilistic Algorithms", </title> <publisher> Springer Verlag Lecture Notes in CS No. </publisher> <pages> 74, </pages> <note> Mathematical Foundations of CS, </note> <month> 57-69 </month> <year> (1979). </year>
Reference-contexts: This checker trivially works for an adaptive program as well, because it makes no extra calls to the program. Independently of our work, [Adleman Huang Kompella] describe a result checker for multiplication in the same spirit but different than [Kaminski]. Also previous to our work, <ref> [Freivalds] </ref> introduced 4 a result checker for matrix multiplication which does not call the program. 3 Three Properties of Functions The three properties described in this section are also described in [Blum Luby Rubinfeld] and for completeness we include them here. We build checkers for functions that have these properties.
Reference: [Kaminski] <author> Kaminski, Michael, </author> <title> "A note on probabilistically verifying integer and polynomial products," </title> <journal> JACM, </journal> <volume> Vol. 36, No. 1, </volume> <month> January </month> <year> 1989, </year> <month> pp.142-149. </month>
Reference-contexts: The techniques of [Fortnow Rompel Sipser] yield an adaptive checker that is slower than the original checker by a multiplicative factor of O (log n). Previous to our work, <ref> [Kaminski] </ref> introduced a result checker for integer and polynomial multiplication based on computing the result of the program mod small special numbers. This checker trivially works for an adaptive program as well, because it makes no extra calls to the program. <p> This checker trivially works for an adaptive program as well, because it makes no extra calls to the program. Independently of our work, [Adleman Huang Kompella] describe a result checker for multiplication in the same spirit but different than <ref> [Kaminski] </ref>. Also previous to our work, [Freivalds] introduced 4 a result checker for matrix multiplication which does not call the program. 3 Three Properties of Functions The three properties described in this section are also described in [Blum Luby Rubinfeld] and for completeness we include them here.
Reference: [Lund Fortnow Karloff Nisan] <author> Lund, C., Fortnow, L., Karloff, H., Nisan, N., </author> <title> "The Polynomial Time Hierarchy has Interactive Proofs", </title> <type> Manuscript. </type>
Reference-contexts: To see this, suppose there is such a general technique and consider the checker for the complete language in NEXPTIME. Now, because we can supposedly convert this checker into a 1-adaptive checker, there is an interactive proof for the language. Then by the results of <ref> [Lund Fortnow Karloff Nisan] </ref> and [Shamir], the language must be in PSPACE. Since there is probably no general technique for converting a checker into a 1-adaptive checker, it would be interesting to charactize which problems do have adaptive checkers.
Reference: [Lipton] <author> Lipton, R., </author> <title> "New directions in testing", </title> <type> Manuscript. </type>
Reference-contexts: Recently [Feigenbaum Kannan Nisan] have shown that random boolean functions are not k-random-self-reducible for any polynomial k, and that if a function is 2-random-self-reducible, then the function can be computed nonuniformly in nondeterministic polynomial time. [Beaver Feigenbaum] <ref> [Lipton] </ref> show that any function that is a polynomial of degree d over a finite field is d-random-self-reducible.
Reference: [Rubinfeld] <author> Rubinfeld, R. </author> <title> "Designing checkers for programs that run in parallel", </title> <type> Manuscript. </type>
Reference: [Shamir] <author> Shamir, A., "IP=PSPACE", </author> <type> Manuscript. 11 </type>
Reference-contexts: Now, because we can supposedly convert this checker into a 1-adaptive checker, there is an interactive proof for the language. Then by the results of [Lund Fortnow Karloff Nisan] and <ref> [Shamir] </ref>, the language must be in PSPACE. Since there is probably no general technique for converting a checker into a 1-adaptive checker, it would be interesting to charactize which problems do have adaptive checkers.
References-found: 17

