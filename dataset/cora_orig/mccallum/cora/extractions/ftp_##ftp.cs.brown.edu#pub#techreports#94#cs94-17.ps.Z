URL: ftp://ftp.cs.brown.edu/pub/techreports/94/cs94-17.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-94-17.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Barbuti, M. Codish, R. Giacobazzi, and G. Levi. </author> <title> Modelling Prolog control. </title> <booktitle> In POPL-92, </booktitle> <pages> pages 95-104. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: There are many directions for extending this work. First, termination analysis can be improved by introducing a priori knowledge about termination <ref> [1] </ref> or by introducing symbolic values in the abstract domain to replace the postfixpoint computation by a mathematical induction argument. Second, sure success information can be improved by using a more sophisticated type domain (e.g. [9]).
Reference: [2] <author> M. Bruynooghe. </author> <title> A Practical Framework for the Abstract Interpretation of Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10(2) </volume> <pages> 91-124, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Section 6 discusses their new implementations. 5 The Abstract Interpretation Algorithm The algorithm of the cardinality analysis is a top-down chaotic iteration algorithm using dynamic dependencies to speed up convergence. The overall strategy as well as the use of dependencies is now well-understood and is used in Bruynooghe's framework <ref> [2] </ref>, in Hermenegildo's PLAI [14], and in GAIA [11, 13]. For space reasons, we will not repeat these results and the reader is referred to these papers for a comprehensive presentation. Our algorithm is derived from GAIA, uses normalized program, and is depicted in Figure 1.
Reference: [3] <author> A. Cortesi, B. Le Charlier, and P. Van Hentenryck. </author> <title> Combinations of Abstract Domains for Logic Programming. </title> <booktitle> In POPL-94, </booktitle> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Section 6 describes the implementation of the abstract operations. 4.1 Abstract Substitutions The precision of the cardinality analysis strongly depends on the information maintained on substitutions. Our abstraction of substitutions is best viewed as an instantiation of the generic pattern domain <ref> [3] </ref> with a mode, sharing, arithmetic, and subterm component. We describe each component successively. In the following, we denote abstract substitutions by fi possibly subscripted and the set of abstract substitutions by AS. <p> As a consequence, defining the R-domain amounts essentially to defining a traditional domain on substitutions and its operations. We now describe the various components of the R-domain which can be built as an open product <ref> [3] </ref>. The Mode Component The mode component was described in [13] and associates a mode from the set Modes = fvar,ground,novar,noground,ngv,gv,anyg with each subterm. <p> Most of these operations are presented elsewhere (e.g. <ref> [13, 3] </ref>) and their generalizations for the arithmetic and subterm components are omitted for space reasons.
Reference: [4] <author> P Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In POPL'77, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, CA, </address> <month> January </month> <year> 1977. </year>
Reference-contexts: The framework is presented in detail in a companion paper [12]. Concrete Semantics As is traditional in abstract interpretation <ref> [4] </ref>, the starting point of the analysis is a collecting semantics for the programming language. Our concrete semantics captures the top-down execution of Prolog using a left-to-right computation rule, a depth-first search, and the standard semantics for the cut.
Reference: [5] <author> S. Dawson, C.R. Ramakrishnan, I.V. Ramakrishnan, </author> <title> and R.C. Sekar. Extracting Determinacy in Logic Programs. </title> <booktitle> In ICLP-93, </booktitle> <address> Budapest (Hungary), </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The purpose of this paper is to propose a novel analysis, called cardinality analysis, to approximate the number of solutions to a goal. The analysis subsumes traditional determinacy analysis <ref> [6, 7, 15, 5] </ref> and applies to full Prolog (without dynamic predicates such as assert/retract). The theoretical foundation of the analysis is a novel generic abstract interpretation framework designed especially to deal with issues such as determinacy, termination, and the cut. <p> On the other hand, input and output abstract substitutions are used in the concatenation of abstract sequences to improve the cardinality analysis. The use of output patterns was proposed before for determinacy analysis (e.g. <ref> [7, 5] </ref>) but, to our knowledge, was never integrated or implemented in a complete framework. Efficiency: The cardinality analysis introduces a small overhead compared to a traditional mode analysis. <p> This is in contrast to existing determinacy analysis which either resort to special-purpose correctness proofs (e.g. [6, 15]) or exclude certain aspects of the analysis (e.g. how input and output patterns are used to detect determinacy) from their framework (e.g. <ref> [5] </ref>). Wide Applicability: The analysis applies to full Prolog, excluding dynamic predicates such as assert and retract. In particular, it handles the cut and arithmetic and meta-level predicates. The rest of this paper is organized as follows. Section 2 illustrates the functionality of the system on a set of examples. <p> Note that <ref> [7, 5] </ref> do not deal with the cut and cannot handle the first program. In addition, we know of no implemented system which can handle the second program. The analysis in [6] cannot detect determinacy in this case due to the absence of abstraction for arithmetic predicates.
Reference: [6] <author> S. Debray. </author> <title> Functional Computations in Logic Programs. </title> <journal> ACM TOPLAS, </journal> <volume> 11(3) </volume> <pages> 451-481, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Don't know nondeterminism is an appealing feature of logic programming allowing concise statements of many problems. It complicates however sequential and parallel implementation <ref> [6, 8] </ref>, partial evaluation [15], program transformation, and debugging. The number of solutions to a goal is thus useful for many purposes including indexing, cut insertion and elimination [6, 15], dead code elimination, and memory management and scheduling in parallel systems [8, 17]. <p> It complicates however sequential and parallel implementation [6, 8], partial evaluation [15], program transformation, and debugging. The number of solutions to a goal is thus useful for many purposes including indexing, cut insertion and elimination <ref> [6, 15] </ref>, dead code elimination, and memory management and scheduling in parallel systems [8, 17]. The purpose of this paper is to propose a novel analysis, called cardinality analysis, to approximate the number of solutions to a goal. <p> The purpose of this paper is to propose a novel analysis, called cardinality analysis, to approximate the number of solutions to a goal. The analysis subsumes traditional determinacy analysis <ref> [6, 7, 15, 5] </ref> and applies to full Prolog (without dynamic predicates such as assert/retract). The theoretical foundation of the analysis is a novel generic abstract interpretation framework designed especially to deal with issues such as determinacy, termination, and the cut. <p> Uniformity: All aspects of the analysis are captured in a unique abstract interpretation framework, simplifying the proof of correctness and the design of the analysis. This is in contrast to existing determinacy analysis which either resort to special-purpose correctness proofs (e.g. <ref> [6, 15] </ref>) or exclude certain aspects of the analysis (e.g. how input and output patterns are used to detect determinacy) from their framework (e.g. [5]). Wide Applicability: The analysis applies to full Prolog, excluding dynamic predicates such as assert and retract. <p> When given the input pattern delete last (v,g), where v, g denote respectively a variable and a ground term, our analysis returns, in 0.01 seconds, the output sequence hdelete last (g; [gjg]); 0; 1; pti, where pt stands for "possible termination". Note that the analysis in <ref> [6] </ref> cannot infer determinacy in this case, since it does not use output patterns. <p> Note that [7, 5] do not deal with the cut and cannot handle the first program. In addition, we know of no implemented system which can handle the second program. The analysis in <ref> [6] </ref> cannot detect determinacy in this case due to the absence of abstraction for arithmetic predicates. Consider now the program compress (L,Lc) which holds if Lc is a compressed version of the list L. For instance, the compressed version of [a,b,b,c,c,c] is [a,1,b,2,c,3].
Reference: [7] <author> R. Giacobazzi. </author> <title> Detecting Determinate Computations by Bottom-up Abstract Interpretation. </title> <booktitle> In ESOP'92, </booktitle> <pages> pages 167-181, </pages> <year> 1992. </year>
Reference-contexts: The purpose of this paper is to propose a novel analysis, called cardinality analysis, to approximate the number of solutions to a goal. The analysis subsumes traditional determinacy analysis <ref> [6, 7, 15, 5] </ref> and applies to full Prolog (without dynamic predicates such as assert/retract). The theoretical foundation of the analysis is a novel generic abstract interpretation framework designed especially to deal with issues such as determinacy, termination, and the cut. <p> On the other hand, input and output abstract substitutions are used in the concatenation of abstract sequences to improve the cardinality analysis. The use of output patterns was proposed before for determinacy analysis (e.g. <ref> [7, 5] </ref>) but, to our knowledge, was never integrated or implemented in a complete framework. Efficiency: The cardinality analysis introduces a small overhead compared to a traditional mode analysis. <p> Note that <ref> [7, 5] </ref> do not deal with the cut and cannot handle the first program. In addition, we know of no implemented system which can handle the second program. The analysis in [6] cannot detect determinacy in this case due to the absence of abstraction for arithmetic predicates.
Reference: [8] <author> M. Hermenegildo. </author> <title> An Abstract Machine for Restricted AND-parallel execution of logic programs. </title> <booktitle> In ICLP'96, </booktitle> <pages> pages 25-39, </pages> <address> London, </address> <month> July </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Don't know nondeterminism is an appealing feature of logic programming allowing concise statements of many problems. It complicates however sequential and parallel implementation <ref> [6, 8] </ref>, partial evaluation [15], program transformation, and debugging. The number of solutions to a goal is thus useful for many purposes including indexing, cut insertion and elimination [6, 15], dead code elimination, and memory management and scheduling in parallel systems [8, 17]. <p> It complicates however sequential and parallel implementation [6, 8], partial evaluation [15], program transformation, and debugging. The number of solutions to a goal is thus useful for many purposes including indexing, cut insertion and elimination [6, 15], dead code elimination, and memory management and scheduling in parallel systems <ref> [8, 17] </ref>. The purpose of this paper is to propose a novel analysis, called cardinality analysis, to approximate the number of solutions to a goal. The analysis subsumes traditional determinacy analysis [6, 7, 15, 5] and applies to full Prolog (without dynamic predicates such as assert/retract).
Reference: [9] <author> G. Janssens and M. Bruynooghe. </author> <title> Deriving Description of Possible Values of Program Variables by Means of Abstract Interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2-3):205-258, </volume> <year> 1992. </year>
Reference-contexts: Hence, we have to keep all incompatible abstract sequences separately until the procedure has been fully executed. No such treatment would be necessary if a more expressive type domain (e.g. type graphs <ref> [9] </ref>) would be used. 6 Implementation of the Abstract Operations We now turn to the definition of the abstract operations on abstract sequences. For space reasons, we only consider a subset of the operations, in particular, unification, upper bound, widening, cut, and the concatenation operation. <p> First, termination analysis can be improved by introducing a priori knowledge about termination [1] or by introducing symbolic values in the abstract domain to replace the postfixpoint computation by a mathematical induction argument. Second, sure success information can be improved by using a more sophisticated type domain (e.g. <ref> [9] </ref>). Finally, the mode analysis can be improved by generalizing the domain to preserve all abstract substitutions which surely succeed and an additional one to represent all remaining cases as suggested in [12]. The tradeoff accuracy/efficiency of these extensions need to be studied carefully. 13
Reference: [10] <author> T. Kanamori and T. Kawamura. </author> <title> Analysing Success Patterns of Logic Programs by Abstract Hybrid Interpretation. </title> <type> Technical report, </type> <institution> ICOT, </institution> <year> 1987. </year>
Reference-contexts: It should be emphasized that the pattern information is optional. In theory, information on all subterms could be kept but the requirement for a finite analysis makes this impossible for almost all applications. As a consequence, the domain shares some features with the depth-k abstraction <ref> [10] </ref>, although Pat (R) does not impose a fixed depth but adjusts it dynamically through upper bound and widening operations. Note that the identification of subterms (and hence the link between the structural components and the R-domain) is a somewhat arbitrary choice.
Reference: [11] <author> B. Le Charlier, K. Musumbu, and P. Van Hentenryck. </author> <title> A Generic Abstract Interpretation Algorithm and Its Complexity Analysis (Extended Abstract). </title> <booktitle> In ICLP-91, </booktitle> <pages> pages 64-78, </pages> <address> Paris (France), </address> <month> June </month> <year> 1991. </year>
Reference-contexts: The overall strategy as well as the use of dependencies is now well-understood and is used in Bruynooghe's framework [2], in Hermenegildo's PLAI [14], and in GAIA <ref> [11, 13] </ref>. For space reasons, we will not repeat these results and the reader is referred to these papers for a comprehensive presentation. Our algorithm is derived from GAIA, uses normalized program, and is depicted in Figure 1. Procedure solve goal is standard. <p> AI VARS (fi) = hfi out ; m; M; ti where hfi out ; flagi = AI VAR (fi) m = if flag = success then 1 else 0 M = if flag = failure then 0 else 1 t = st. Operation AI VAR on abstract substitutions (see <ref> [11, 13] </ref>) is slightly modified and returns, in addition to the substitution, a flag indicating if the unification always succeeds, always fails, or can both succeed and fail. For instance, unification of two variables will always succeed.
Reference: [12] <author> B. Le Charlier, S. Rossi, and P. Van Hentenryck. </author> <title> An Abstract Interpretation Framework for Almost Full Prolog. </title> <institution> Research Paper RP-94/?, Department of Computer Science, University of Namur, </institution> <month> March </month> <year> 1994. </year> <note> (Submitted to ILPS'94). </note>
Reference-contexts: The theoretical foundation of the analysis is a novel generic abstract interpretation framework designed especially to deal with issues such as determinacy, termination, and the cut. The framework is presented is detail in a companion paper <ref> [12] </ref>: its key idea is to describe the result of a procedure as an abstract sequence of substitutions, representing a set of sequences of substitutions. <p> However, it cannot handle the examples discussed here and loses too much information for many applications. 3 Overview of the Abstract Interpretation Framework In this section, we briefly review our abstract interpretation framework for the cardinality analysis. The framework is presented in detail in a companion paper <ref> [12] </ref>. Concrete Semantics As is traditional in abstract interpretation [4], the starting point of the analysis is a collecting semantics for the programming language. Our concrete semantics captures the top-down execution of Prolog using a left-to-right computation rule, a depth-first search, and the standard semantics for the cut. <p> Its goal here is to improve the precision of the analysis. In this context, it is more important to detect non-termination than termination and our domain gives reasonable results for this purpose. It gives rather poor results to detect termination. See <ref> [12] </ref> for a more general discussion of this issue. <p> Note however that operation EXTCS initializes the cut information to nocut and that SUBST (C) returns the abstract substitution component of sequence C. Procedure solve procedure does not follow exactly the abstract semantics presented in <ref> [12] </ref> because the domain Pattern is not able to keep track of a finite number of possible functors for a given index. Hence, we have to keep all incompatible abstract sequences separately until the procedure has been fully executed. <p> For space reasons, we only consider a subset of the operations, in particular, unification, upper bound, widening, cut, and the concatenation operation. Operations on abstract sequences use operations on abstract substitutions and we consider those as black-boxes in the following. Consistency of the abstract operations is specified in <ref> [12] </ref>. Unification We first consider operation AI VARS: AS ! ASS which, given an abstract substitution fi with domain fx 1 ; x 2 g, returns an abstract substitution sequence which represents a set of sequences of length 0 or 1 (depending upon the success or failure of the unification). <p> Second, sure success information can be improved by using a more sophisticated type domain (e.g. [9]). Finally, the mode analysis can be improved by generalizing the domain to preserve all abstract substitutions which surely succeed and an additional one to represent all remaining cases as suggested in <ref> [12] </ref>. The tradeoff accuracy/efficiency of these extensions need to be studied carefully. 13
Reference: [13] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental Evaluation of a Generic Abstract Interpretation Algorithm for Prolog. </title> <booktitle> ACM TOPLAS.. </booktitle> <month> January </month> <year> 1994 </year>
Reference-contexts: As a consequence, defining the R-domain amounts essentially to defining a traditional domain on substitutions and its operations. We now describe the various components of the R-domain which can be built as an open product [3]. The Mode Component The mode component was described in <ref> [13] </ref> and associates a mode from the set Modes = fvar,ground,novar,noground,ngv,gv,anyg with each subterm. <p> whose concretization function is given by Cc (mo) = f (t 1 ; : : : ; t n ) j t i 2 Cc (mo (i)) 1 i ng: The Sharing Component The sharing component maintains information about possible sharing between pairs of subterms and was also described in <ref> [13] </ref>. <p> Most of these operations are presented elsewhere (e.g. <ref> [13, 3] </ref>) and their generalizations for the arithmetic and subterm components are omitted for space reasons. <p> The overall strategy as well as the use of dependencies is now well-understood and is used in Bruynooghe's framework [2], in Hermenegildo's PLAI [14], and in GAIA <ref> [11, 13] </ref>. For space reasons, we will not repeat these results and the reader is referred to these papers for a comprehensive presentation. Our algorithm is derived from GAIA, uses normalized program, and is depicted in Figure 1. Procedure solve goal is standard. <p> AI VARS (fi) = hfi out ; m; M; ti where hfi out ; flagi = AI VAR (fi) m = if flag = success then 1 else 0 M = if flag = failure then 0 else 1 t = st. Operation AI VAR on abstract substitutions (see <ref> [11, 13] </ref>) is slightly modified and returns, in addition to the substitution, a flag indicating if the unification always succeeds, always fails, or can both succeed and fail. For instance, unification of two variables will always succeed. <p> Several algorithms are compared: OR is the GAIA algorithm on Pattern <ref> [13] </ref>, PC is the cardinality analysis with Pattern, PCA is PC with the abstraction for arithmetic predicates, and PCAM is PCA with the abstraction for meta-level predicates.
Reference: [14] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-Time Derivation of Variable Dependency Using Abstract Interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2-3):315-347, </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: The overall strategy as well as the use of dependencies is now well-understood and is used in Bruynooghe's framework [2], in Hermenegildo's PLAI <ref> [14] </ref>, and in GAIA [11, 13]. For space reasons, we will not repeat these results and the reader is referred to these papers for a comprehensive presentation. Our algorithm is derived from GAIA, uses normalized program, and is depicted in Figure 1. Procedure solve goal is standard.
Reference: [15] <author> D. Sahlin. </author> <title> Determinacy Analysis for Full Prolog. </title> <booktitle> In PEPM'91, </booktitle> <year> 1991. </year>
Reference-contexts: 1 Introduction Don't know nondeterminism is an appealing feature of logic programming allowing concise statements of many problems. It complicates however sequential and parallel implementation [6, 8], partial evaluation <ref> [15] </ref>, program transformation, and debugging. The number of solutions to a goal is thus useful for many purposes including indexing, cut insertion and elimination [6, 15], dead code elimination, and memory management and scheduling in parallel systems [8, 17]. <p> It complicates however sequential and parallel implementation [6, 8], partial evaluation [15], program transformation, and debugging. The number of solutions to a goal is thus useful for many purposes including indexing, cut insertion and elimination <ref> [6, 15] </ref>, dead code elimination, and memory management and scheduling in parallel systems [8, 17]. The purpose of this paper is to propose a novel analysis, called cardinality analysis, to approximate the number of solutions to a goal. <p> The purpose of this paper is to propose a novel analysis, called cardinality analysis, to approximate the number of solutions to a goal. The analysis subsumes traditional determinacy analysis <ref> [6, 7, 15, 5] </ref> and applies to full Prolog (without dynamic predicates such as assert/retract). The theoretical foundation of the analysis is a novel generic abstract interpretation framework designed especially to deal with issues such as determinacy, termination, and the cut. <p> Uniformity: All aspects of the analysis are captured in a unique abstract interpretation framework, simplifying the proof of correctness and the design of the analysis. This is in contrast to existing determinacy analysis which either resort to special-purpose correctness proofs (e.g. <ref> [6, 15] </ref>) or exclude certain aspects of the analysis (e.g. how input and output patterns are used to detect determinacy) from their framework (e.g. [5]). Wide Applicability: The analysis applies to full Prolog, excluding dynamic predicates such as assert and retract. <p> Note also that Sahlin <ref> [15] </ref> defines a simpler cardinality analysis over a finite domain. His analysis ignores predicate arguments, since this appears to be satisfactory for partial evaluation.
Reference: [16] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog: Advanced Programming Techniques. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Ma, </address> <year> 1986. </year> <month> 14 </month>
Reference-contexts: The number 3 comes from the widening on sequences which is applied when the abstract substitution part stabilizes. Finally, consider the meta-program for unification from <ref> [16] </ref>. Given the input pattern unify (a,a), our analysis returns the abstract sequence hunify (a; a); 0; 1; pti in 0.02 seconds.
Reference: [17] <author> D.H.D Warren. </author> <title> The Andorra Model. Presented at Gigalips Project Workshop, </title> <institution> University of Manchester, </institution> <year> 1987. </year>
Reference-contexts: It complicates however sequential and parallel implementation [6, 8], partial evaluation [15], program transformation, and debugging. The number of solutions to a goal is thus useful for many purposes including indexing, cut insertion and elimination [6, 15], dead code elimination, and memory management and scheduling in parallel systems <ref> [8, 17] </ref>. The purpose of this paper is to propose a novel analysis, called cardinality analysis, to approximate the number of solutions to a goal. The analysis subsumes traditional determinacy analysis [6, 7, 15, 5] and applies to full Prolog (without dynamic predicates such as assert/retract).
References-found: 17

