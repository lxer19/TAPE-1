URL: ftp://cse.ogi.edu/pub/crml/fpca93.ps.Z
Refering-URL: http://www.cse.ogi.edu/PacSoft/publications/bibliograph.html
Root-URL: http://www.cse.ogi.edu
Email: fsheard,fegarasg@cse.ogi.edu  
Title: A Fold for All Seasons addition a generic promotion theorem is identified for each of
Author: Tim Sheard Leonidas Fegaras 
Note: In  
Address: 19600 N.W. von Neumann Drive Beaverton, OR 97006-1999  
Affiliation: Pacific Software Research Center Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Abstract: Generic control operators, such as fold, can be generated from algebraic type definitions. The class of types to which these techniques are applicable is generalized to all algebraic types definable in languages such as Miranda and ML, i.e. mutually recursive sums-of-products with tuples and function types. Several other useful generic operators, also applicable to every type in this class, also are described. A normalization algorithm which automatically calculates improvements to programs expressed in a language based upon folds is described. It reduces programs, expressed using fold as the exclusive control operator, to a canonical form. Based upon a generic promotion theorem, the algorithm is facilitated by the explicit structure of fold programs rather than using an analysis phase to search for implicit structure. Canonical programs are minimal in the sense that they contain the fewest number of fold operations. Because of this property, the normalization algorithm has important applications in program transformation, optimization, and theorem proving. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. Chin. </author> <title> Safe Fusion of Functional Expressions. </title> <booktitle> In Proc. 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <address> San Francisco, Ca., </address> <month> June </month> <year> 1992. </year>
Reference-contexts: In addition, "eureka" steps are not necessary here during folding to a function call as they are incorporated in the general ization part of the normalization algorithm. * Automation of the techniques of listlessness, deforestation and fusion <ref> [15, 1, 8, 14] </ref> for a class of fold programs. These techniques remove unnecessary interme diate data structures produced during nested calls. * Automation of a simple form of partial evaluation. <p> Wadler makes the observation that some intermediate data structures for primitive types, such as integers, characters, etc. do not really take up space, so he developed a method to handle such terms, using a technique he calls blazing. Chin's work on fusion <ref> [1] </ref> extends Wadler's work on deforestation. He generalizes Wadler's techniques to all first order programs, not just treeless ones, by recognizing and skipping over terms to which his techniques do not apply. His work also applies to higher order programs in general.
Reference: [2] <author> J. Cockett and D. Spencer. </author> <title> Strong Categorical Datatypes I. </title> <editor> In R. Seely, editor, </editor> <booktitle> International Meeting on Category Theory 1991, Canadian Mathematical Society Proceedings, </booktitle> <volume> Vol. 13, </volume> <pages> pp 141-169. </pages> <publisher> AMS, </publisher> <address> Mon-treal, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction It has been argued that functional languages are important because they support forms of modularity that are difficult to support in other languages [16, 10]. Recent work by Mal-colm [12], Meijer, Fokkinga, and Paterson [13], and Cockett with the programming language Charity <ref> [2] </ref> has suggested an even higher level of modularity and abstraction may be obtained by the use of generic control structures which capture patterns of recursion for a large class of types in a uniform way. This is important for several reasons: * Abstraction. <p> In Section 2 we review the work of Meijer, et al. [13]. We begin by introducing a different notation which originates from the work of Hagino [9] and is extended by Cockett <ref> [2] </ref>. We feel that this notation makes these ideas more accessible to functional programmers. We conclude this section by using this notation to formally define the familiar fold operator for simple algebraic types.
Reference: [3] <author> J. Cockett and T. </author> <type> Fukushima. </type> <institution> About Charity The University of Calgary, Department of Computer Science, </institution> <note> Research Report No. 92/480/18. </note> <month> June </month> <year> 1992. </year>
Reference-contexts: This makes our canonical term language closed under composition. 6 Other Patterns of Recursion In this section we catalog other patterns of recursion which have appeared in the literature or been investigated by the authors. 6.1 Derivations The Derive operator (anamorphism [13], unfold <ref> [3] </ref>) is the opposite of the fold operator. Rather than traversing an object of type T to produce a result value, it constructs an object of type T from a seed value.
Reference: [4] <author> J. Darlington and R. Burstall. </author> <title> A System which Automatically Improves Programs. </title> <journal> Acta Informatica, </journal> <volume> 6(1) </volume> <pages> 41-60, </pages> <year> 1976. </year>
Reference-contexts: The normalization algorithm exploits the explicit structure of fold programs. Therefore programs in this form can be transformed using fully automated tools. Because canonical programs are minimal, the normalization algo-rithm has important applications in program transforma tion, optimization, and theorem proving. For example: * Automation of the unfold-simplify-fold method <ref> [4] </ref> with out the intervention of explicit laws.
Reference: [5] <author> H. Dybkjr. </author> <title> Category Theory, Types, and Programming Languages. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, University of Copenhagen (DIKU), </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: To be useful, it is necessary to restrict each function type to be covariant in T <ref> [5] </ref>, otherwise K [t] may not be a functor.
Reference: [6] <author> L. Fegaras. </author> <title> A Transformational Approach to Database System Implementation. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, University of Massachusetts, Amherst, </institution> <month> February </month> <year> 1993. </year> <note> Also appeared as CMPSCI Technical Report 92-68. </note>
Reference: [7] <author> L. Fegaras, T. Sheard, and D. Stemple. </author> <title> Uniform Traversal Combinators: Definition, Use and Properties. </title> <booktitle> In Proceedings of the 11th International Conference on Automated Deduction (CADE-11), </booktitle> <address> Saratoga Springs, New York, </address> <pages> pp 148-162. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1992. </year>
Reference: [8] <author> A. Ferguson, and P. Wadler. </author> <title> When will Deforestation Stop. </title> <booktitle> In Proc. of 1988 Glasgow Workshop on Functional Programming (also as research report 89/R4 of Glasgow University), </booktitle> <pages> pp 39-56, </pages> <address> Rothesay, Isle of Bute, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: In addition, "eureka" steps are not necessary here during folding to a function call as they are incorporated in the general ization part of the normalization algorithm. * Automation of the techniques of listlessness, deforestation and fusion <ref> [15, 1, 8, 14] </ref> for a class of fold programs. These techniques remove unnecessary interme diate data structures produced during nested calls. * Automation of a simple form of partial evaluation. <p> His techniques apply only to linear data structures such as lists, vectors, and streams, yet his techniques automatically detect and fuse multiple walks down the same data structure, unlike some of the more general techniques. It is also related to Wadler's work on listlessness, and deforestation <ref> [14, 15, 8] </ref>. Deforestation works on all first order treeless terms. A treeless term is one which is exactly analogous to a potentially normalizable term, but is described in a much different manner due to lack of structure imposed on such terms.
Reference: [9] <author> T. Hagino. </author> <title> A Categorical Programming Language. </title> <type> Ph.D. thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference-contexts: The equality of two programs can be checked by reducing them both to canonical form and comparing the results. In Section 2 we review the work of Meijer, et al. [13]. We begin by introducing a different notation which originates from the work of Hagino <ref> [9] </ref> and is extended by Cockett [2]. We feel that this notation makes these ideas more accessible to functional programmers. We conclude this section by using this notation to formally define the familiar fold operator for simple algebraic types.
Reference: [10] <author> J. Hughes. </author> <title> Why Functional Programming Matters. </title> <journal> The Computer Journal, </journal> <volume> 32(2) </volume> <pages> 98-107, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction It has been argued that functional languages are important because they support forms of modularity that are difficult to support in other languages <ref> [16, 10] </ref>.
Reference: [11] <author> J. Hook, R. Kieburtz, and T. Sheard. </author> <title> Generating Programs by Reflection. </title> <type> Oregon Graduate Institute Technical Report 92-015, </type> <note> submitted to Journal of Functional Programming. </note>
Reference-contexts: In fact every type T which has a zero constructor, C z (a constructor with no arguments, like Nil for list), has a zero replacement function that is associative, and that has the zero, C z , for both a left and right identity <ref> [11] </ref>. The zero replacement for T is defined by: (Zr T y) ffi C z = ():y i (id 1 ; : : : ; id p ; Zr T y) We call (Zr T y x) a zero replacement, since it replaces all zeros in x with y.
Reference: [12] <author> G. Malcolm. </author> <title> Homomorphisms and Promotability. </title> <booktitle> In Mathematics of Program Construction, </booktitle> <pages> pp 335-347. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: 1 Introduction It has been argued that functional languages are important because they support forms of modularity that are difficult to support in other languages [16, 10]. Recent work by Mal-colm <ref> [12] </ref>, Meijer, Fokkinga, and Paterson [13], and Cockett with the programming language Charity [2] has suggested an even higher level of modularity and abstraction may be obtained by the use of generic control structures which capture patterns of recursion for a large class of types in a uniform way. <p> Each pattern is accompanied by a generic promotion theorem. In Section 8 we briefly compare our work to previous results. In the last section we conclude and discuss future work. 2 Background In this section we review previous work <ref> [12, 13] </ref> and introduce an alternative notation that will facilitate extension. 2.1 Simple Types The type definitions considered in this section are the simple sums-of-product types defined by using recursive equations of the form: T (ff 1 ; : : : ; ff p ) = C 1 (t 1;1 ; <p> The normalization algorithm will describe how these new accumulating functions can be calculated. The promotion theorem for folds has appeared in the liter ature using various notations <ref> [12, 13] </ref>: Theorem 1 (The Fold Promotion Theorem) 8i : i ffi E T g ffi fold T (f ) = fold T () Proof: Let = g ffi fold T (f ) and C i a constructor of T .
Reference: [13] <author> E. Meijer, M. Fokkinga, and R. Paterson. </author> <title> Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire. </title> <booktitle> In Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, Massachusetts, </address> <pages> pp 124-144, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: 1 Introduction It has been argued that functional languages are important because they support forms of modularity that are difficult to support in other languages [16, 10]. Recent work by Mal-colm [12], Meijer, Fokkinga, and Paterson <ref> [13] </ref>, and Cockett with the programming language Charity [2] has suggested an even higher level of modularity and abstraction may be obtained by the use of generic control structures which capture patterns of recursion for a large class of types in a uniform way. <p> The equality of two programs can be checked by reducing them both to canonical form and comparing the results. In Section 2 we review the work of Meijer, et al. <ref> [13] </ref>. We begin by introducing a different notation which originates from the work of Hagino [9] and is extended by Cockett [2]. We feel that this notation makes these ideas more accessible to functional programmers. <p> Each pattern is accompanied by a generic promotion theorem. In Section 8 we briefly compare our work to previous results. In the last section we conclude and discuss future work. 2 Background In this section we review previous work <ref> [12, 13] </ref> and introduce an alternative notation that will facilitate extension. 2.1 Simple Types The type definitions considered in this section are the simple sums-of-product types defined by using recursive equations of the form: T (ff 1 ; : : : ; ff p ) = C 1 (t 1;1 ; <p> as they appear on the left hand side of the recursive type equation. 2 Where p is the number of universally quantified type variables in the left hand side of T 's type equation. 2 2.3 Folds With this notation it is now possible to describe the familiar fold (catamorphism <ref> [13] </ref>) operator for any simple sums-of-products type. <p> The normalization algorithm will describe how these new accumulating functions can be calculated. The promotion theorem for folds has appeared in the liter ature using various notations <ref> [12, 13] </ref>: Theorem 1 (The Fold Promotion Theorem) 8i : i ffi E T g ffi fold T (f ) = fold T () Proof: Let = g ffi fold T (f ) and C i a constructor of T . <p> This makes our canonical term language closed under composition. 6 Other Patterns of Recursion In this section we catalog other patterns of recursion which have appeared in the literature or been investigated by the authors. 6.1 Derivations The Derive operator (anamorphism <ref> [13] </ref>, unfold [3]) is the opposite of the fold operator. Rather than traversing an object of type T to produce a result value, it constructs an object of type T from a seed value. <p> Pr int (f z ; f s ) Succ (x) = f s (x; Pr int (f z ; f s ) x) fact n = Pr int (():1; (i; r):i fl r) n We call such a function for a type constructor T a primi tive recursion function (paramorphism <ref> [13] </ref>) for T , since it generalizes the primitive recursion induction scheme of the natural numbers to an arbitrary type. 4 By straight-forward we mean that the codomain of the fold is a simple data type, not a function or a tuple.
Reference: [14] <author> P. Wadler. </author> <title> Listlessness is Better than Laziness: Lazy Evaluation and Garbage Collection at Compile-time. </title> <booktitle> In Proc. of the ACM Symposium on Lisp and Functional Programming, </booktitle> <address> Austin Texas, </address> <month> August, </month> <year> 1984. </year>
Reference-contexts: In addition, "eureka" steps are not necessary here during folding to a function call as they are incorporated in the general ization part of the normalization algorithm. * Automation of the techniques of listlessness, deforestation and fusion <ref> [15, 1, 8, 14] </ref> for a class of fold programs. These techniques remove unnecessary interme diate data structures produced during nested calls. * Automation of a simple form of partial evaluation. <p> His techniques apply only to linear data structures such as lists, vectors, and streams, yet his techniques automatically detect and fuse multiple walks down the same data structure, unlike some of the more general techniques. It is also related to Wadler's work on listlessness, and deforestation <ref> [14, 15, 8] </ref>. Deforestation works on all first order treeless terms. A treeless term is one which is exactly analogous to a potentially normalizable term, but is described in a much different manner due to lack of structure imposed on such terms.
Reference: [15] <author> P. Wadler. </author> <title> Deforestation: Transforming Programs to Eliminate Trees. </title> <booktitle> Proceedings of the 2nd European Symposium on Programming, </booktitle> <address> Nancy, France, </address> <month> March </month> <year> 1988. </year> <note> Lecture Notes in Computer Science 300. </note>
Reference-contexts: In addition, "eureka" steps are not necessary here during folding to a function call as they are incorporated in the general ization part of the normalization algorithm. * Automation of the techniques of listlessness, deforestation and fusion <ref> [15, 1, 8, 14] </ref> for a class of fold programs. These techniques remove unnecessary interme diate data structures produced during nested calls. * Automation of a simple form of partial evaluation. <p> His techniques apply only to linear data structures such as lists, vectors, and streams, yet his techniques automatically detect and fuse multiple walks down the same data structure, unlike some of the more general techniques. It is also related to Wadler's work on listlessness, and deforestation <ref> [14, 15, 8] </ref>. Deforestation works on all first order treeless terms. A treeless term is one which is exactly analogous to a potentially normalizable term, but is described in a much different manner due to lack of structure imposed on such terms.
Reference: [16] <author> P. Wadler. </author> <title> Editorial Lazy Functional Programming The Computer Journal, </title> <journal> Vol. </journal> <volume> 32, No. 2, </volume> <year> 1989, </year> <note> p. 97. </note>
Reference-contexts: 1 Introduction It has been argued that functional languages are important because they support forms of modularity that are difficult to support in other languages <ref> [16, 10] </ref>.
Reference: [17] <author> M. Wand. </author> <title> Continuation-Based Program Transformation Strategies. </title> <journal> Journal of the ACM, </journal> <volume> 27(1) </volume> <pages> 164-180, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Many such functions can be equivalently expressed by functions which use an extra parameter which acts as an accumulator or a continuation <ref> [17] </ref>. Such func tions can be expressed as second-order folds (so called since the accumulating functions return functions as results). These second-order fold computations are often normalizable although their equivalent first-order computation is not.
Reference: [18] <author> R. Waters. </author> <title> Automatic Transformation of Series Expressions into Loops, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 52-98, </pages> <month> January </month> <year> 1991. </year> <month> 10 </month>
Reference-contexts: x Nil We apply the F -1 G transform to get: fold list (():Nil; (a; r):append (Cons (a; Nil); r)) x = fold list (():Nil; (a; r):Cons (a; r)) x which is the list identity function. 8 Relationship to Other Work This work is related to Water's on series expressions <ref> [18] </ref>. His techniques apply only to linear data structures such as lists, vectors, and streams, yet his techniques automatically detect and fuse multiple walks down the same data structure, unlike some of the more general techniques. It is also related to Wadler's work on listlessness, and deforestation [14, 15, 8].
References-found: 18

