URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/modck/pub/www/cv/RR-925-I.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/modck/pub/www/cv/RR-925-I.html
Root-URL: 
Title: Symbolic Model Checking of VHDL Design Entities  
Author: David Deharbe Dominique Borrione 
Date: November 30, 1993  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A.Debreil and D.Jaillet. </author> <title> Synchronous description in VHDL for formal proof and resulting guidelines proposed by BULL. </title> <type> Advanced report, </type> <institution> BULL Produits Systemes Departement Developpement Assiste, </institution> <address> rue Jean Jaures-B.P. 68-Les Clayes-sous-Bois-France, </address> <month> July </month> <year> 1992. </year> <note> BULL/92.0001 rev.A. </note>
Reference-contexts: VHDL, as a complete description language, has the disadvantage of being heavy and complex. A significant subset of this language was defined, by Salem [3], in order to restrict it to a description language for synchronous sequential circuits. Another research group <ref> [1] </ref> followed a similar approach and defined S-VHDL, a synchronous subset and description style for VHDL, whose purpose is to be formally verifiable. <p> This new variable represents the next value of the corresponding state variable. Thus, the transitions can be expressed by the set of equalities fs 0 i = ffi i (s; i), i 2 <ref> [1; ns] </ref>g. <p> This improvement is based on the following remark: 9x 1 ; : : : ; x p : 1in is the general form of the existential quantification of a conjunction. Let us suppose that some variable x k appears in a subset F of ff i ; i 2 <ref> [1; n] </ref>g. <p> : : : a n;j : : : a n;p C C C A where a i;j = 1 if f i depends of x j 0 otherwise Let dep be the function that associates to each variable the number of f i that depends on it; hence: dep : <ref> [1; p] </ref> ! [0; n] P n dep has at least one minimum: m; x m is one of the variables (there might be several) on which the smallest number of functions f i depend. <p> Let N bgroup be the number of groups of variables thus formed, N bgroup p. The algorithm defines a partition I 1 , I 2 , I Nbgroup of the interval <ref> [1; p] </ref> which reflects the variable, or set of variables, selected at each step. Let J k be the set of functions associated with the group of variables I k .
Reference: [2] <author> A.Debreil and P.Oddo. </author> <title> Synchronous designs in VHDL. </title> <booktitle> In EURO-DAC '93: European Design Automation Conference with EURO-VHDL '93, </booktitle> <pages> pages 486-491, </pages> <address> CCH Hamburg, Germany, </address> <month> Sep. </month> <title> 1993. </title> <publisher> IEEE Computer society press. </publisher> <address> ISBN: 0-8186-4350-1. </address>
Reference: [3] <author> A.Salem. </author> <title> Verification formelle des circuits digitaux decrits en VHDL. </title> <type> PhD thesis, </type> <institution> Universite Joseph Fourier, </institution> <address> BP 53-38041 GRENOBLE Cedex 9-France, </address> <month> Oct. </month> <year> 1992. </year> <institution> Lab. IMAG-ARTEMIS. </institution>
Reference-contexts: VHDL, as a complete description language, has the disadvantage of being heavy and complex. A significant subset of this language was defined, by Salem <ref> [3] </ref>, in order to restrict it to a description language for synchronous sequential circuits. Another research group [1] followed a similar approach and defined S-VHDL, a synchronous subset and description style for VHDL, whose purpose is to be formally verifiable. <p> it is not possible to define a purely syntactical subset of VHDL, the descriptions of which being verifiable with the techniques based on a modelisation by means of finite state machines. 5.2 Syntactical restrictions and description rules A first description of the subset together with denotational semantics are presented in <ref> [3] </ref>. Its automatic translation is today completely achieved. We will first present the syntax production rules of the language and comment the restrictions we introduced in comparison with standard VHDL. This presentation follows the structure of the VHDL Language Reference Manual [17].
Reference: [4] <institution> B.Berkane. Verification des systemes materiels numeriques sequentiels synchrones:Application du langage Lustre et de l'outil de verification Lesar. </institution> <type> PhD thesis, </type> <institution> Institut National Polytechnique de Grenoble, </institution> <address> BP 53-38041 GRENOBLE Cedex 9-France, </address> <month> Oct. </month> <year> 1992. </year> <institution> Laboratoire de Genie Informatique. </institution>
Reference-contexts: Our approach is based on a CTL-like TL. The proof principle is the following: given the model, and the properties to check, the model checking is done by the traversal of the model state space. Another solution is possible, that has been chosen within e.g. the Lustre environment [15], <ref> [4] </ref>, [12]): to build a new machine that is equivalent to the formula and merge both machines to produce a product machine with a single output. The proof of the property is then equivalent to the computation of the output on the set of reachable states.
Reference: [5] <author> CLSI Solutions. </author> <title> VFormal user's manual:Formal verification for VHDL designs, </title> <booktitle> 1993. </booktitle> <address> Draft,Version 1.0.0.0. </address>
Reference: [6] <author> D.Borrione, D.Deharbe, H.Eveking, and S.Horeth. </author> <title> Application of a BDD package to the verification of HDL descriptions. </title> <editor> In P.Prinetto and P.Camurati, editors, </editor> <booktitle> Correct Hardware Design Methodologies, </booktitle> <pages> pages 385-400, </pages> <address> Torino, Italy, </address> <month> June </month> <year> 1991. </year> <title> ESPRIT BRA CHARME, </title> <publisher> North-Holland. </publisher>
Reference-contexts: This was, for a first approach, perfectly adapted to be the development basis of a property prover (see [7], <ref> [6] </ref>). The standardization of VHDL, which tends to become a "lingua franca" for hardware descriptions in the western world, and the considerable development of VHDL-based software, lead us to study the formal verification of VHDL descriptions. VHDL, as a complete description language, has the disadvantage of being heavy and complex.
Reference: [7] <author> D.Deharbe. </author> <title> Etude et realisation d' un model checker symbolique dans l' environnement SMAX de preuve de circuits. </title> <type> Dea report, </type> <institution> Lab. IMAG-ARTEMIS-Universite Joseph Fourier, </institution> <address> BP 53-38041 GRENOBLE Cedex 9-France, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: This was, for a first approach, perfectly adapted to be the development basis of a property prover (see <ref> [7] </ref>, [6]). The standardization of VHDL, which tends to become a "lingua franca" for hardware descriptions in the western world, and the considerable development of VHDL-based software, lead us to study the formal verification of VHDL descriptions.
Reference: [8] <author> D.Deharbe. </author> <title> Model Checking on finite state machines: extensions and applications to VHDL designs. </title> <booktitle> In First Asian-Pacific Conference on Harware Description Languages: Standards and Applications, </booktitle> <address> Brisbane, Australia, </address> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: The five last columns refer to the times spent to compute the set of states satisfying each to five TL properties presented in <ref> [8] </ref>. These results show that computations involving past and future operators have the same complexity. This complexity strongly depends on the size of the circuit and on the number of the fixpoint operators (EU , ES, and so forth) present in the property.
Reference: [9] <editor> E.A.Emerson. </editor> <booktitle> Handbook of theoretical computer science, volume 2, chapter Temporal and modal logic, </booktitle> <pages> pages 996-1071. </pages> <publisher> Elsevier Science Publishers B.V., </publisher> <editor> K.G. Larsen and A. </editor> <address> Skou edition, </address> <year> 1990. </year>
Reference-contexts: Our purpose is to define computation procedures associated to the past operators. Therefore, as a basis, we take the logic defined in [40] which is a full-time logic. In Emerson's framework of classification <ref> [9] </ref>, our TL has the following attributes: it is propositional, global, branching, evaluated on points, discrete and has both past-tense and future-tense operators. It is presented in a CTL-like notation, as it is a straightforward extension of CTL. CTL operators define properties on the future behavior. <p> It is presented in a CTL-like notation, as it is a straightforward extension of CTL. CTL operators define properties on the future behavior. New operators are added so that the same expressiveness is now possible on the past behavior. Similar operators have also been defined on linear TL, in <ref> [9] </ref>. <p> Apply iteratively the following steps until the rewriting stops: (a) Apply rewriting system consisting in rules 4.15 to 4.40. (b) Apply rewriting system consisting in rules 4.11 to 4.14, 4.41 to 4.46. 2. Normalisation with the rules 4.1 to 4.10. Expressive power Emerson proved in <ref> [9] </ref> that the propositional linear temporal logic defined globally (see definition 4.2.1) is more expressive with both past and future operators than the one with future operators only. Proposition 4.2.6 As measured to global equivalence, TL is strictly more expressive than CTL. 4.2. <p> expression: K = g ^ EP (K). function CHECK_EH_FORMULA (M: Symbolic_Model, Bddg: BDD) : BDD; -- The function returns the BDD that represents the set of -- reachable valuations where EH (g) is valid. 1 This proof is very similar to the one given by Emerson for linear temporal logic <ref> [9] </ref>. 2 M:BddR and M:BddInit are respectively the BDD's of the set of reachable states and of the initial state of M. 20 CHAPTER 4.
Reference: [10] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions On Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: This approach is the same that the one usually used to define the validity of Computation Tree Logic |CTL| formulas (see e.g. <ref> [10] </ref>, [19]) or fragments of the -calculus [21]. We show that, in this sense, the expressive power of a full logic is strictly bigger than the future-oriented logics. 4.2 Definition Model checking techniques have been so far applied to future-oriented logics.
Reference: [11] <author> H. Eveking. </author> <title> Experience in designing formally verifiable HDL' s. </title> <editor> In D.Borrione and R.Waxman, editors, </editor> <booktitle> 10 th international symposium on computer hardware description languages and their applications, </booktitle> <address> Marseille, France, </address> <month> Apr. </month> <year> 1991. </year> <booktitle> IFIP WG10.2, </booktitle> <publisher> North-Holland. </publisher>
Reference-contexts: These research resulted in the development of symbolic model checkers, where sets of states are kept implicit. 3 4 CHAPTER 1. INTRODUCTION We first experimented these concepts and proof techniques on models written in SMAX. As a "SMall and AXiomatized" hardware description language, defined by Eveking <ref> [11] </ref>, SMAX is a member of the CONLAN family that is dedicated to the register transfer level description of synchronous sequential circuits, with an implicit master clock. This was, for a first approach, perfectly adapted to be the development basis of a property prover (see [7], [6]).
Reference: [12] <author> F.Rocheteau. </author> <title> Extension du langage LUSTRE a la conception de circuits:le langage LUSTRE-V4 et le systeme POLLUX. </title> <type> PhD thesis, </type> <institution> Institut National Polytechnique de Grenoble, </institution> <address> BP 53-38041 GRENOBLE Cedex 9-France, </address> <month> Oct. </month> <year> 1992. </year> <institution> Laboratoire de Genie Informatique. </institution> <type> 40 BIBLIOGRAPHY 41 </type>
Reference-contexts: The proof principle is the following: given the model, and the properties to check, the model checking is done by the traversal of the model state space. Another solution is possible, that has been chosen within e.g. the Lustre environment [15], [4], <ref> [12] </ref>): to build a new machine that is equivalent to the formula and merge both machines to produce a product machine with a single output. The proof of the property is then equivalent to the computation of the output on the set of reachable states.
Reference: [13] <author> G.Cabodi and P.Camurati. </author> <title> Advancements in symbolic traversal techniques. </title> <editor> In G.J.Milne and L.Pierre, editors, </editor> <title> Correct Hardware Design and Verification Methods, </title> <booktitle> volume 683 of Lecture Notes in Computer Science, </booktitle> <pages> pages 155-166, Arles, </pages> <month> May </month> <year> 1993. </year> <booktitle> ESPRIT WG 6018 and IFIP WG10.2, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Traversal algorithms based on the transition vector appear to be much more efficient than the ones based on the transition relation method. Some recent works <ref> [13] </ref> on transition relation-based methods have filled the performance gap betwwen these two approaches. The algorithms of Image and InverseImage will be presented in the chapter 3, for both transition representations.
Reference: [14] <author> G.Thuau and B.Berkane. </author> <title> Using the language LUSTRE for sequential verification. </title> <booktitle> In 2 nd Workshop on designing correct circuits, volume VLSI Design Methods-II, </booktitle> <pages> pages 81-96, </pages> <address> Lyngby-Denmark, </address> <year> 1992. </year>
Reference-contexts: '1') case ST is when A =&gt; if (X = b"11") then ST &lt;= B endif; when B =&gt; if (X = b"00") then ST &lt;= A endif; end case; end process; 5.4.2 Example The bus arbiter of figure 5.3 was initially specified in the synchronous dataflow language Lustre by <ref> [14] </ref>, and a first VHDL description of it was given in [28]. It has been slightly rewritten to fit in the presented subset, and illustrates the application of the VHDL assert statement to specify temporal properties in TL.
Reference: [15] <author> G.Thuau and B.Berkane. </author> <title> A unified framework for describing and verifying hardware synchronous sequential circuits. Formal Methods in System Design, </title> <type> 2(3), </type> <year> 1993. </year> <pages> ISSN: 0925-9856. </pages>
Reference-contexts: Our approach is based on a CTL-like TL. The proof principle is the following: given the model, and the properties to check, the model checking is done by the traversal of the model state space. Another solution is possible, that has been chosen within e.g. the Lustre environment <ref> [15] </ref>, [4], [12]): to build a new machine that is equivalent to the formula and merge both machines to produce a product machine with a single output. The proof of the property is then equivalent to the computation of the output on the set of reachable states.
Reference: [16] <author> H.J.Touati, H.Savoj, B.Lin, R.V.Brayton, and A.Sangiovanni-Vincentelli. </author> <title> Implicite state enumeration using bdd's. </title> <type> Report, </type> <institution> University of California, Berkeley, USA, </institution> <year> 1990. </year>
Reference-contexts: BDD's have also been proposed as a more efficient representation of finite state machines, in relation to state space algorithms [26], [20], <ref> [16] </ref>. These research resulted in the development of symbolic model checkers, where sets of states are kept implicit. 3 4 CHAPTER 1. INTRODUCTION We first experimented these concepts and proof techniques on models written in SMAX. <p> It is clear that intermediate BDD's in this algorithm may become too large to be managable. The explanation is the following: the quantifications, which eliminate variables, are performed after all conjunctions, which add variables. Touati et al. <ref> [16] </ref> introduced a heuristic method based on a reordering of variables and functions that, in some cases, allows to apply some quantifiers before the BDD of the whole transition relation has been built. <p> These algorithms are known as "recursive constraint solving techniques", they are based on a new boolean operator called the generalized cofactor by <ref> [16] </ref> or the constrain operator by [25]. The constraint operator The constraint operator has been defined by Coudert et al. in [25]. Given two predicates f and c, the result of the constraint operator, denoted hf i c , must verify the following properties: 12 CHAPTER 3. <p> The proof of this lemma is given in <ref> [16] </ref>.
Reference: [17] <author> IEEE. </author> <title> IEEE Standard VHDL Language Reference Manual, </title> <booktitle> 1988. </booktitle> <address> Std 1076-1987. </address>
Reference-contexts: Introduction The only standardised digital systems description language is VHDL, upon which many industrial simulation tools have been developed (see <ref> [17] </ref>, [32]). Today, the challenge is to produce highly integrated and completely verified circuits in the shortest time: simulation by exhaustive test sets now cannot take up this challenge. The most recent works on the topic are related to high-level synthesis and formal verification. This report deals with the second. <p> Its automatic translation is today completely achieved. We will first present the syntax production rules of the language and comment the restrictions we introduced in comparison with standard VHDL. This presentation follows the structure of the VHDL Language Reference Manual <ref> [17] </ref>. We recommend to have this book in hand while reading the section 5.2 dedicated to the definition of the subset: only the modified rules are explicitly indicated.
Reference: [18] <author> J.C.Madre. </author> <title> PRIAM Un outil de verification formelle des circuits integres digitaux. </title> <type> PhD thesis, </type> <institution> Ecole nationale superieure des telecommunications, Paris, </institution> <address> France, June 1990. 90 E 007. </address>
Reference-contexts: REPRESENTATION OF BOOLEAN EXPRESSIONS WITH BDD'S 7 a A A A 0 b fl fl fl fl fl fl* H H H Hj 0 A A A AU 1 H H 0 1 False True Another improvement, proposed in <ref> [18] </ref>, is to type BDD edges by a sign "+" or "-", depending on whether the value of the expression represented by the adjacent BDD has to be negated or not.
Reference: [19] <author> J.P.Queille and J.Sifakis. </author> <title> Specification and verification of concurrent systems in CESAR. </title> <booktitle> In 5 th international symposium on programming, volume 137 of Lecture Notes in Computer Science, </booktitle> <pages> pages 244-263, </pages> <address> New York, 1981. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: This approach is the same that the one usually used to define the validity of Computation Tree Logic |CTL| formulas (see e.g. [10], <ref> [19] </ref>) or fragments of the -calculus [21]. We show that, in this sense, the expressive power of a full logic is strictly bigger than the future-oriented logics. 4.2 Definition Model checking techniques have been so far applied to future-oriented logics.
Reference: [20] <author> J.R.Burch, E.M.Clarke, and D.E.Long. </author> <title> Representing circuits more efficiently in symbolic model checking. </title> <type> Internal report, </type> <institution> Carnegie Mellon University, </institution> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: BDD's have also been proposed as a more efficient representation of finite state machines, in relation to state space algorithms [26], <ref> [20] </ref>, [16]. These research resulted in the development of symbolic model checkers, where sets of states are kept implicit. 3 4 CHAPTER 1. INTRODUCTION We first experimented these concepts and proof techniques on models written in SMAX. <p> 1. the algorithm based on the transition relation of the circuit; it follows directly from the definition of this transition relation, 2. the algorithm based on the vector of transition functions (one function per state variable of the model). 3.2 Relational traversal functions 3.2.1 Principles Clarke et al., in e.g. <ref> [20] </ref>, showed how to build the transition relation from the next state function: a new propositional variable s 0 i is introduced for each state variable s i . This new variable represents the next value of the corresponding state variable.
Reference: [21] <author> J.R.Burch, E.M.Clarke, K.L.MacMillan, D.L.Dill, and J.Hwang. </author> <title> 10 20 states and beyond. </title> <booktitle> In LICS'90: 5 th annual IEEE symposium on logic in computer science, </booktitle> <pages> pages 428-439. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Given a finite state machine model M = (S; I; O; ffi; ; I ) and a TL formula f on this machine, our goal is to find the set of reachable states where f is valid. Finite state machines can be efficiently represented with BDD's [37] [26] <ref> [21] </ref> The precise representation we selected is the same as [37]. <p> This approach is the same that the one usually used to define the validity of Computation Tree Logic |CTL| formulas (see e.g. [10], [19]) or fragments of the -calculus <ref> [21] </ref>. We show that, in this sense, the expressive power of a full logic is strictly bigger than the future-oriented logics. 4.2 Definition Model checking techniques have been so far applied to future-oriented logics. Our purpose is to define computation procedures associated to the past operators.
Reference: [22] <author> K.M.Butler, D.E.Ross, R.Kapur, and M.R.Mercer. </author> <title> Heuristics to compute variable orderings for efficient manipulation of ordered binary decision diagrams. </title> <booktitle> In 28 th DAC: Design Automation Conference, </booktitle> <pages> pages 417-420, </pages> <address> San Francisco, California, </address> <month> June </month> <year> 1991. </year> <note> ACM/IEEE. ISBN: 0-89791-395-7. </note>
Reference-contexts: The BDD's were first applied to the proof of equivalence of combinational and synchronous sequential circuits. The representation of boolean formulas with BDD's has been the object of intensive research in order to improve the efficiency of their manipulation in space and computation time <ref> [22] </ref> [35]. BDD's have also been proposed as a more efficient representation of finite state machines, in relation to state space algorithms [26], [20], [16]. These research resulted in the development of symbolic model checkers, where sets of states are kept implicit. 3 4 CHAPTER 1. <p> Bryant proved in [34] that this representation is canonical for a selected order on the variables. The size of the BDD representing an expression is closely related to the chosen variable ordering. The computation of the best order being NP-hard, heuristics are used to choose this order <ref> [22] </ref>. 2.2.1 Definition BDD's are based on Boole's decomposition of boolean expressions [34].
Reference: [23] <author> M.H.A.Newman. </author> <title> On theories with a combinational definition of 'equivalence'. </title> <journal> Annals of mathematics, </journal> <volume> 43(2) </volume> <pages> 223-243, </pages> <year> 1942. </year>
Reference-contexts: Applying rules 4.17 and 4.13: f ! EF (g) _ EF (h) ! EF (g _ h) and the rewriting stops. The system is terminating but is not locally confluent, thus according to the Diamond Lemma <ref> [23] </ref>, it is not confluent. Proposition 4.2.4 The rewrite system consisting in rules 4.15 to 4.40 is confluent. Proposition 4.2.5 The rewrite system consisting in rules 4.11 to 4.14 and 4.41 to 4.46 is confluent. Proof: The system has been proved to be complete, using the automated tool REVE [30].
Reference: [24] <author> O.Coudert, C.Berthet, and J.C.Madre. </author> <title> Verification of sequential machines using functional vectors. </title> <booktitle> In International Workshop on Applied Formal Methods for Correct VLSI Design, volume VLSI Design Methods-II, </booktitle> <pages> pages 179-196, </pages> <address> Houthalen,Belgium, </address> <year> 1989. </year> <booktitle> IFIP WG 10.2/WG 10.5, </booktitle> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: Two algorithms are given in <ref> [24] </ref>, one of which is based on the following equations. Let fy 1 ; : : : ; y n g be a set of variables that stands for the dimensions of B n . 1.
Reference: [25] <author> O.Coudert, C.Berthet, and J.C.Madre. </author> <title> Verification of synchronous sequential machines based on symbolic execution. In J.Sifakis, editor, Workshop on automatic verification methods for finite state systems, </title> <booktitle> number 407 in Lecture Notes in Computer Science, </booktitle> <pages> pages 365-373, </pages> <address> Grenoble, France, June 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Two application examples of machine traversal are the computation of the set of reachable states from I and of the set of states where a TL formula is valid. Most of the algorithms to perform the symbolic traversal of a Mealy machine were published by Berthet, Coudert, Madre (see <ref> [25] </ref>, [24],[18], [26],), Burch, Clarke and al. (see [21],[20]). <p> Madre et al. <ref> [25] </ref> proposed a divide and conquer strategy to solve this problem, that uses the next state functional vector ffi = [ffi 1 ; ffi 2 ; : : : ; ffi ns ] on the characteristic function of the original set of states. <p> These algorithms are known as "recursive constraint solving techniques", they are based on a new boolean operator called the generalized cofactor by [16] or the constrain operator by <ref> [25] </ref>. The constraint operator The constraint operator has been defined by Coudert et al. in [25]. Given two predicates f and c, the result of the constraint operator, denoted hf i c , must verify the following properties: 12 CHAPTER 3. <p> These algorithms are known as "recursive constraint solving techniques", they are based on a new boolean operator called the generalized cofactor by [16] or the constrain operator by <ref> [25] </ref>. The constraint operator The constraint operator has been defined by Coudert et al. in [25]. Given two predicates f and c, the result of the constraint operator, denoted hf i c , must verify the following properties: 12 CHAPTER 3. <p> The definition of such a distance requires the existence of an order on variables. This is not a problem: the use of BDD's already implies the definition of this order. <ref> [25] </ref> presented a deterministic algorithm that computes a solution to this problem. Although, this solution does not give optimal results, the BDD's built have a reasonable size. The algorithm applies the following rules recursively on the structure of the BDD's.
Reference: [26] <author> O.Coudert and J.C.Madre. </author> <title> Symbolic computation of the valid states of a sequential machine: algorithms and discussion. </title> <editor> In P. Edition, editor, </editor> <booktitle> International workshop on formal methods for correct VLSI design, </booktitle> <address> Miami, Florida, </address> <month> Jan. </month> <year> 1991. </year> <note> ACM/IFIP WG10.2. </note>
Reference-contexts: BDD's have also been proposed as a more efficient representation of finite state machines, in relation to state space algorithms <ref> [26] </ref>, [20], [16]. These research resulted in the development of symbolic model checkers, where sets of states are kept implicit. 3 4 CHAPTER 1. INTRODUCTION We first experimented these concepts and proof techniques on models written in SMAX. <p> Given a finite state machine model M = (S; I; O; ffi; ; I ) and a TL formula f on this machine, our goal is to find the set of reachable states where f is valid. Finite state machines can be efficiently represented with BDD's [37] <ref> [26] </ref> [21] The precise representation we selected is the same as [37]. <p> Most of the algorithms to perform the symbolic traversal of a Mealy machine were published by Berthet, Coudert, Madre (see [25], [24],[18], <ref> [26] </ref>,), Burch, Clarke and al. (see [21],[20]).
Reference: [27] <author> O.Lichtenstein, A.Pnueli, and L.Zuck. </author> <title> The glory of the past, </title> <booktitle> volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 196-218. </pages> <publisher> Springer-Verlag, </publisher> <address> Brooklyn, r.parikh edition, </address> <month> June </month> <year> 1985. </year>
Reference-contexts: This definition of equivalence between TL formulas is different from the one usually used [31], <ref> [27] </ref>, which is an equivalence based on the value of the formulas in the initial state only. We claim that our definition is more relevant in the scope of model checking, for two reasons: 1. The semantics of the TL formulas is given for each state of the FSM. 2.
Reference: [28] <author> P.Cavenel and X.Epineuse. </author> <title> Validation de proprietes de circuits digitaux dans un environnement VHDL. Rapport de stage 3 me annee ENSIMAG, </title> <type> INPG, </type> <month> June </month> <year> 1992. </year>
Reference-contexts: then ST &lt;= B endif; when B =&gt; if (X = b"00") then ST &lt;= A endif; end case; end process; 5.4.2 Example The bus arbiter of figure 5.3 was initially specified in the synchronous dataflow language Lustre by [14], and a first VHDL description of it was given in <ref> [28] </ref>. It has been slightly rewritten to fit in the presented subset, and illustrates the application of the VHDL assert statement to specify temporal properties in TL. The bus arbiter controls the access to the bus by three clients, numbered from 0 to 2, with a decreasing priority.
Reference: [29] <author> P.Kission, E.Closse, L.Bergher, and A.Jerraya. </author> <title> Industrial experimentation of high-level synthesis. </title> <booktitle> In EURO-DAC '93: European Design Automation Conference with EURO-VHDL '93, </booktitle> <pages> pages 506-511, </pages> <address> CCH Hamburg, Germany, </address> <month> Sep. </month> <title> 1993. </title> <publisher> IEEE Computer society press. </publisher> <address> ISBN: 0-8186-4350-1. 42 BIBLIOGRAPHY </address>
Reference-contexts: Moreover, process variables and resolved signals have proved to be of wide use among designers. Thus, we are also working to include these features signals in our subset. We should benefit from the experience of high level synthesis <ref> [29] </ref> [33] in order to extract automata from complex process statements. 5.3. SEMANTICS 31 Other proof tools are already applicable to this subset: equivalence checking of sequential circuits, equivalence checking and diagnosis of combinational circuits.
Reference: [30] <author> P.Lescanne. </author> <title> Computer experiments with the REVE term rewriting system generator. </title> <booktitle> In 10th ACM symposium on principles of programming languages, </booktitle> <pages> pages 99-108, </pages> <address> Austin,Texas, </address> <year> 1983. </year>
Reference-contexts: Proposition 4.2.4 The rewrite system consisting in rules 4.15 to 4.40 is confluent. Proposition 4.2.5 The rewrite system consisting in rules 4.11 to 4.14 and 4.41 to 4.46 is confluent. Proof: The system has been proved to be complete, using the automated tool REVE <ref> [30] </ref>. Four new simplification rules have been found. Appendix C contains the whole REVE session. Algorithm: We have chosen the following strategy, which has given satisfying results: 1.
Reference: [31] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In 18 th annual IEEE symposium on foundations in computer science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: For instance, TL (Temporal Logics) are used to study the evolution of the truth of formulas as the time evolves. Pnueli showed the usefulness of TL to check the validity or to specify the behavior of programs or reactive systems <ref> [31] </ref>. <p> This definition of equivalence between TL formulas is different from the one usually used <ref> [31] </ref>, [27], which is an equivalence based on the value of the formulas in the initial state only. We claim that our definition is more relevant in the scope of model checking, for two reasons: 1.
Reference: [32] <author> R.Airiau, J.M.Berge, V.Olive, and J.Rouillard. </author> <title> VHDL du langage a la Modelisation. Collection in-formatique. </title> <note> Presses polytechniques et universitaires romandes, premiere edition edition, 1990. ISBN 2-88074-191-2. </note>
Reference-contexts: Introduction The only standardised digital systems description language is VHDL, upon which many industrial simulation tools have been developed (see [17], <ref> [32] </ref>). Today, the challenge is to produce highly integrated and completely verified circuits in the shortest time: simulation by exhaustive test sets now cannot take up this challenge. The most recent works on the topic are related to high-level synthesis and formal verification. This report deals with the second.
Reference: [33] <author> R.Bergamaschi. </author> <title> High-level synthesis in a production environment: methodology and algorithms. In J.Mermet, editor, Fundamentals and Standards in Hardware Description Language, </title> <address> Il Ciocco, Italy, </address> <month> Sep. </month> <year> 1993. </year> <title> NATO advanced study institute, </title> <publisher> Kluwer. </publisher>
Reference-contexts: Moreover, process variables and resolved signals have proved to be of wide use among designers. Thus, we are also working to include these features signals in our subset. We should benefit from the experience of high level synthesis [29] <ref> [33] </ref> in order to extract automata from complex process statements. 5.3. SEMANTICS 31 Other proof tools are already applicable to this subset: equivalence checking of sequential circuits, equivalence checking and diagnosis of combinational circuits.
Reference: [34] <author> R.E.Bryant. </author> <title> Graph-based algorithm for boolean function manipulation. </title> <journal> IEEE Transactions Computers, </journal> <volume> C(35):1035-1044, </volume> <year> 1986. </year>
Reference-contexts: This became possible with binary decision diagrams, called BDD's, a powerful representation of boolean expressions, invented by Akers [36] and Bryant <ref> [34] </ref>. The BDD's were first applied to the proof of equivalence of combinational and synchronous sequential circuits. The representation of boolean formulas with BDD's has been the object of intensive research in order to improve the efficiency of their manipulation in space and computation time [22] [35]. <p> A recent survey on BDD's can be found in [35]. They are direct acyclic graphs representing binary decision trees, where common subtrees have been merged. (fig. 2.1 shows an example of BDD). Bryant proved in <ref> [34] </ref> that this representation is canonical for a selected order on the variables. The size of the BDD representing an expression is closely related to the chosen variable ordering. <p> The size of the BDD representing an expression is closely related to the chosen variable ordering. The computation of the best order being NP-hard, heuristics are used to choose this order [22]. 2.2.1 Definition BDD's are based on Boole's decomposition of boolean expressions <ref> [34] </ref>.
Reference: [35] <author> R.E.Bryant. </author> <title> Symbolic boolean manipulation with ordered binary-decision diagrams. </title> <journal> IEEE Transactions Computers, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <month> Sep. </month> <year> 1992. </year>
Reference-contexts: The BDD's were first applied to the proof of equivalence of combinational and synchronous sequential circuits. The representation of boolean formulas with BDD's has been the object of intensive research in order to improve the efficiency of their manipulation in space and computation time [22] <ref> [35] </ref>. BDD's have also been proposed as a more efficient representation of finite state machines, in relation to state space algorithms [26], [20], [16]. These research resulted in the development of symbolic model checkers, where sets of states are kept implicit. 3 4 CHAPTER 1. <p> A recent survey on BDD's can be found in <ref> [35] </ref>. They are direct acyclic graphs representing binary decision trees, where common subtrees have been merged. (fig. 2.1 shows an example of BDD). Bryant proved in [34] that this representation is canonical for a selected order on the variables.
Reference: [36] <author> S.B.Akers. </author> <title> Binary Decision Diagram. </title> <journal> IEEE Transactions Computers, </journal> <volume> C(27):509-516, </volume> <month> June </month> <year> 1978. </year>
Reference-contexts: The next step has been to find a powerful data representation to compute proofs on larger circuits than the extensive representation (actual enumeration of the states) is able to process. This became possible with binary decision diagrams, called BDD's, a powerful representation of boolean expressions, invented by Akers <ref> [36] </ref> and Bryant [34]. The BDD's were first applied to the proof of equivalence of combinational and synchronous sequential circuits. The representation of boolean formulas with BDD's has been the object of intensive research in order to improve the efficiency of their manipulation in space and computation time [22] [35].
Reference: [37] <author> S.Bose and A.L.Fisher. </author> <title> Automatic verification of synchronous circuits using symbolic logic simulation and temporal logic. </title> <booktitle> In International Workshop on Applied Formal Methods for Correct VLSI Design, volume VLSI Design Methods-II, </booktitle> <pages> pages 151-158, </pages> <address> Houthalen,Belgium, </address> <year> 1989. </year> <booktitle> IFIP WG 10.2/WG 10.5, </booktitle> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: Bose and Fisher <ref> [37] </ref> defined a model M = (S; I; O; ffi; ; I ) of a deterministic finite state machine, as follows: * S is a power of B, that represents the states of the machine, S = B ns , and s 1 , s 2 ,: : : , s <p> Given a finite state machine model M = (S; I; O; ffi; ; I ) and a TL formula f on this machine, our goal is to find the set of reachable states where f is valid. Finite state machines can be efficiently represented with BDD's <ref> [37] </ref> [26] [21] The precise representation we selected is the same as [37]. <p> Finite state machines can be efficiently represented with BDD's <ref> [37] </ref> [26] [21] The precise representation we selected is the same as [37].
Reference: [38] <author> S.Graf. </author> <title> Logique du temps arborescent pour la specification et la preuve de programmes. </title> <type> PhD thesis, </type> <institution> Institut National Polytechnique de Grenoble, </institution> <address> BP 53-38041 GRENOBLE Cedex 9-France, </address> <month> Feb. </month> <year> 1984. </year>
Reference-contexts: Simplification rules If we restrict ourselves to the future fragment of TL, we get all the properties of CTL. These properties used to simplify the formulas to be proved. The formulas we present are taken from <ref> [38] </ref>. In addition, we present the dual property in the past fragment of TL.
Reference: [39] <author> S.Horeth. </author> <title> Improving the performances of a BDD-based tautology-checker. </title> <editor> In P.Prinetto and P.Camurati, editors, </editor> <booktitle> Correct Hardware Design Methodologies, </booktitle> <pages> pages 377-384, </pages> <address> Torino, Italy, </address> <month> June </month> <year> 1991. </year> <title> ESPRIT BRA CHARME, </title> <publisher> North-Holland. </publisher> <address> ISBN 0-444-89367-9. </address>
Reference-contexts: We had a very efficient BDD package written by Horeth <ref> [39] </ref> at our disposal. <p> LISP-like lists of properties), the description of the circuit. 3. The symbolic model checker is written in Common LISP, and uses a C-version of the BDD package <ref> [39] </ref>. It takes as input the provable-format file (c), and according to the choices of the user, does a customed proof (d).
Reference: [40] <author> Z.Manna and A.Pnueli. </author> <title> A hierarchy of temporal properties. </title> <institution> Research report STAN-CS-87-1186, Stanford University, Stanford,California, </institution> <month> Oct. </month> <year> 1987. </year>
Reference-contexts: Our purpose is to define computation procedures associated to the past operators. Therefore, as a basis, we take the logic defined in <ref> [40] </ref> which is a full-time logic. In Emerson's framework of classification [9], our TL has the following attributes: it is propositional, global, branching, evaluated on points, discrete and has both past-tense and future-tense operators. It is presented in a CTL-like notation, as it is a straightforward extension of CTL.
References-found: 40

