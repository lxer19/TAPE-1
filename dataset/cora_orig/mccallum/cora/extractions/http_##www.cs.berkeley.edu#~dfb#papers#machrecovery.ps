URL: http://www.cs.berkeley.edu/~dfb/papers/machrecovery.ps
Refering-URL: http://www.cs.berkeley.edu/~dfb/publist.html
Root-URL: 
Title: Transparent Recovery of Mach Applications prototype supports message communication via sends and receives, simple port
Author: Arthur Goldberg Ajei Gopal Kong Li Rob Strom David F. Bacon 
Note: The current  
Abstract: We have built a software layer on top of Mach 2.5 that recovers multi-task Mach applications from fail-stop failures. The layer implements Optimistic Recovery (OR), a mechanism for transparent recovery from failing tasks and processors, based on asynchronous checkpointing and logging of inter-task messages. OR recovers from failure by restoring a checkpoint and replaying the logged messages. This paper discusses the issues Mach raised for this implementation, the structure of the OR layer, the design of future enhancements, and comparisons with other recovery techniques.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bacon, D. F. </author> <title> How to log all filesystem operations (while only writing a few to disk). </title> <type> Tech. Rep. RC, </type> <institution> IBM T.J. Watson Research Center, </institution> <year> 1990. </year>
Reference-contexts: Optimizations to reduce the cost of checkpointing and logging are described in other papers <ref> [17, 1, 19, 20] </ref>. OR is based on backwards error recovery [15]. <p> There are optimizations to avoid logging all messages to a file server <ref> [1] </ref>, and to avoid copying the whole file system in order to take a checkpoint [20]. The current implementation does not support recovering the state of the UNIX file system. 8 3.1.4 Piecewise Determinism OR presupposes that each RU is piecewise deterministic. <p> This work's architecture will depend on the implementation of the Unix outside the mach kernel. Before making performance optimizations, we plan to measure the performance of ORM and tune it appropriately. Many performance optimizations will be based on the work in the earlier papers, <ref> [17, 1, 19, 20] </ref>. * Garbage collect checkpoints and message logs * Experiment with different logging mechanisms, such as sender-based log ging, volatile logging, and null logging. * Optimize file system access.
Reference: [2] <author> Bacon, D. F., and Strom, R. E. </author> <title> Optimistic parallelization of communicating sequential processes. </title> <booktitle> In Proceedings of the Third ACM SIG-PLAN Symposium on Principles and Practice of Parallel Programming (April 1991). </booktitle>
Reference: [3] <author> Baron, R. V., Black, D., Bolosky, W., Chew, J., Draves, R. P., Golub, D. B., Rashid, R. F., Avadis Tevanian, J., and Young, M. W. </author> <title> Mach kernel interface manual. </title> <type> Tech. rep., </type> <institution> CS Department, </institution> <address> CMU, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: Second, the fault-tolerant system must produce the same output 1 , even when failures occur, as the original non-recoverable system. We have built a layer on top of Mach <ref> [3, 21] </ref> that makes multi-task Mach applications transparently recoverable from fail-stop processor failures. The layer implements Optimistic Recovery (OR) ([18]), an `optimistic' mechanism for fault-tolerance. A transparent recovery mechanism for Mach applications is desirable for several reasons. <p> There is a third source of non-determinism in Mach which we had not expected, namely the ability of one task to modify the state of another task through a system call <ref> [3] </ref>.
Reference: [4] <author> Cooper, E. C., and Draves, R. P. </author> <title> C threads. </title> <type> Tech. rep., </type> <institution> CS Department, </institution> <address> CMU, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: Another source of non-determinism in Mach is memory sharing between tasks, or between concurrent threads within an address space. On a uniprocessor, a deterministic thread scheduler (such as coroutine threads <ref> [4] </ref>) can be used to make the execution deterministic. We do not have a way of addressing this problem on a true multiprocessor, so ORM will initially be restricted to tasks running on a single cpu and without shared memory between tasks.
Reference: [5] <author> Feldman, S. I., and Brown, C. B. IGOR: </author> <title> A system for program debugging via reversible execution. </title> <booktitle> In SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging (May 1988), </booktitle> <pages> pp. 112-123. </pages>
Reference-contexts: Another application that uses rollback are distributed debuggers of non-deterministic programs <ref> [5, 14, 6] </ref>. 26 We hope to convince the Mach community of the need for services that allow straightforward checkpointing, since we believe it is a critical service for fault-tolerance, migration, and debugging.
Reference: [6] <author> Forin, A. </author> <title> Debugging of heterogeneous parallel systems. </title> <booktitle> In SIG-PLAN/SIGOPS Workshop on Parallel and Distributed Debugging (May 1988), </booktitle> <pages> pp. 130-140. </pages>
Reference-contexts: Another application that uses rollback are distributed debuggers of non-deterministic programs <ref> [5, 14, 6] </ref>. 26 We hope to convince the Mach community of the need for services that allow straightforward checkpointing, since we believe it is a critical service for fault-tolerance, migration, and debugging.
Reference: [7] <author> Goldberg, A. P., and Jefferson, D. </author> <title> Transparent process cloning: A tool for load management of distributed systems. </title> <booktitle> In Proceedings of 1987 International Conference on Parallel Processing (August 1987), </booktitle> <pages> pp. 728 - 734. </pages>
Reference: [8] <author> Haskin, R., Malachi, Y., Sawdon, W., and Chan, G. </author> <booktitle> Recov--ery management in quicksilver. Transactions on Computer Systems 6, </booktitle> <month> 1 </month> <year> (1988). </year>
Reference-contexts: For many, the very word "recovery" carries the implication that the user has specified an atomic unit of work. Many experimental recoverable systems, such as Argus [13], Quicksilver <ref> [8] </ref>, and Avalon/C++[9] assume a transaction model. In transaction models the transactions or units of work must be explicitly defined by the programmer. Transactions run in parallel and share the database; typically the "recovery" mechanism enforces both atomicity and recovery.
Reference: [9] <author> Herlihy, M. P., and Wing, J. M. </author> <title> Avalon: Language support for reliable distributed systems. </title> <type> Tech. Rep. </type> <institution> CMU-CS-86-164, Carnegie Mellon University, </institution> <year> 1986. </year>
Reference: [10] <author> Jefferson, D. </author> <title> Virtual time. </title> <journal> ACM Transactions on Programming Languages and Systems 7, </journal> <month> 3 (July </month> <year> 1985), </year> <month> 404. </month>
Reference: [11] <author> Johnson, D. B., and Zwaenepoel, W. </author> <title> Sender-based message logging. </title> <booktitle> In The Seventeenth International Symposium on Fault-Tolerant Computing (June 1987), IEEE Computer Society, </booktitle> <pages> pp. 14-19. </pages>
Reference-contexts: A message can be viewed as two parts: its content, and its position in the receive sequence at the task. The content can be logged either by the receiving task, as in ORM, or by the sending task, as discussed in <ref> [17, 11] </ref>. 23 The merge position depends on unpredictable message communication delays, so must be determined at the receiver and should probably be logged there. Another source of non-determinism in Mach is memory sharing between tasks, or between concurrent threads within an address space.
Reference: [12] <author> Kenneth P. Birman, R. C., et al. </author> <title> The ISIS system manual, version 2.0. </title> <type> Tech. rep., </type> <institution> CS Department, Cornell, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: a conventional program cannot be transparently made recoverable; (3) at the end of a distributed transaction a two-phase commit is initiated and at least one record must be force-written, whereas OR continuously logs information to stable 24 storage and continuously commits computations whose dependencies are all logged. 6.2 ISIS ISIS <ref> [12] </ref> is a distributed programming environment that has fault-tolerance as one of its goals. It provides the user with a variety of tools, including ones that allow the replication of a user-defined part of the process state, the maintenance of process groups, and so on.
Reference: [13] <author> Liskov, B., Curtis, D., Johnson, P., and Scheifler, R. </author> <title> Implementation of argus. </title> <booktitle> In The Eleventh Symposium on Operating Systems Principles (1987), ACM Special Interest Group on Operating Systems. </booktitle>
Reference-contexts: For many, the very word "recovery" carries the implication that the user has specified an atomic unit of work. Many experimental recoverable systems, such as Argus <ref> [13] </ref>, Quicksilver [8], and Avalon/C++[9] assume a transaction model. In transaction models the transactions or units of work must be explicitly defined by the programmer. Transactions run in parallel and share the database; typically the "recovery" mechanism enforces both atomicity and recovery.
Reference: [14] <author> Pan, D. Z., and Linton, M. A. </author> <title> Supporting reverse execution of parallel programs. </title> <booktitle> In SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging (May 1988), </booktitle> <pages> pp. 124-129. </pages>
Reference-contexts: Another application that uses rollback are distributed debuggers of non-deterministic programs <ref> [5, 14, 6] </ref>. 26 We hope to convince the Mach community of the need for services that allow straightforward checkpointing, since we believe it is a critical service for fault-tolerance, migration, and debugging.
Reference: [15] <author> Randell, B. </author> <title> System structure for software fault tolerance. </title> <journal> IEEE Transactions on Software Engineering SE-1, </journal> <month> 2 (June </month> <year> 1975), </year> <pages> 220-232. </pages>
Reference-contexts: Optimizations to reduce the cost of checkpointing and logging are described in other papers [17, 1, 19, 20]. OR is based on backwards error recovery <ref> [15] </ref>.
Reference: [16] <author> Schneider, F. B. </author> <title> Fail-stop processors. </title> <booktitle> In Digest of Papers from Spring Compcon (March 1983), </booktitle> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: This is a fail-stop failure <ref> [16] </ref>. In particular, a failure does not cause any corrupted data to be written to stable storage or corrupted messages to be sent. A failure in a distributed system consists of the failure of one or more (possibly all) of its RUs.
Reference: [17] <author> Strom, R. E., Bacon, D. F., and Yemini, S. A. </author> <title> Volatile logging in n-fault-tolerant distributed systems. </title> <booktitle> In The Eighteenth Annual International Symposium on Fault-Tolerant Computing: Digest of Papers (June 1988), </booktitle> <pages> pp. 44-49. </pages>
Reference-contexts: Optimizations to reduce the cost of checkpointing and logging are described in other papers <ref> [17, 1, 19, 20] </ref>. OR is based on backwards error recovery [15]. <p> A message can be viewed as two parts: its content, and its position in the receive sequence at the task. The content can be logged either by the receiving task, as in ORM, or by the sending task, as discussed in <ref> [17, 11] </ref>. 23 The merge position depends on unpredictable message communication delays, so must be determined at the receiver and should probably be logged there. Another source of non-determinism in Mach is memory sharing between tasks, or between concurrent threads within an address space. <p> This work's architecture will depend on the implementation of the Unix outside the mach kernel. Before making performance optimizations, we plan to measure the performance of ORM and tune it appropriately. Many performance optimizations will be based on the work in the earlier papers, <ref> [17, 1, 19, 20] </ref>. * Garbage collect checkpoints and message logs * Experiment with different logging mechanisms, such as sender-based log ging, volatile logging, and null logging. * Optimize file system access.
Reference: [18] <author> Strom, R. E., and Yemini, S. A. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Transactions on Computer Systems 3, </journal> <month> 3 (August </month> <year> 1985), </year> <pages> 204-226. </pages>
Reference-contexts: the operating system in each recovery unit such that any application program which behaves correctly in the absence of failure will behave identically (except for stutter) in the presence of failure without having to be rewritten. 2.2 Overview of Algorithm OR is described in detail in Strom and Yemini's paper <ref> [18] </ref>. Optimizations to reduce the cost of checkpointing and logging are described in other papers [17, 1, 19, 20]. OR is based on backwards error recovery [15]. <p> Rather than delaying the sender by requiring logs to be "force-written", optimistic recov 4 ery instead tags each message with the identifiers of the unlogged antecedent messages and proceeds with sending the message, hoping that orphans are rare. These tags are called dependency vectors <ref> [18] </ref> or dependency maps. Each RU updates its local dependency map upon receiving a tagged message. The dependency map defines the set of unlogged messages on which the current state depends.
Reference: [19] <author> Strom, R. E., Yemini, S. A., and Bacon, D. F. </author> <title> Toward self-recovering operating systems. </title> <booktitle> In The International Conference on Parallel Processing and Applications (L'Aquila, </booktitle> <address> Italy, Sept. 1987), </address> <publisher> North-Holland, </publisher> <pages> pp. 475-483. </pages>
Reference-contexts: Optimizations to reduce the cost of checkpointing and logging are described in other papers <ref> [17, 1, 19, 20] </ref>. OR is based on backwards error recovery [15]. <p> This work's architecture will depend on the implementation of the Unix outside the mach kernel. Before making performance optimizations, we plan to measure the performance of ORM and tune it appropriately. Many performance optimizations will be based on the work in the earlier papers, <ref> [17, 1, 19, 20] </ref>. * Garbage collect checkpoints and message logs * Experiment with different logging mechanisms, such as sender-based log ging, volatile logging, and null logging. * Optimize file system access.
Reference: [20] <author> Strom, R. E., Yemini, S. A., and Bacon, D. F. </author> <title> A recoverable object store. </title> <booktitle> In Hawaii International Conference on System Sciences (Kailua-Kona, </booktitle> <address> HI, </address> <month> Jan. </month> <journal> 1988), </journal> <volume> vol. II, </volume> <pages> pp. 215-221. 28 </pages>
Reference-contexts: Optimizations to reduce the cost of checkpointing and logging are described in other papers <ref> [17, 1, 19, 20] </ref>. OR is based on backwards error recovery [15]. <p> There are optimizations to avoid logging all messages to a file server [1], and to avoid copying the whole file system in order to take a checkpoint <ref> [20] </ref>. The current implementation does not support recovering the state of the UNIX file system. 8 3.1.4 Piecewise Determinism OR presupposes that each RU is piecewise deterministic. For a single-threaded Mach task without shared memory, this is straightforward. The computation and most of the system calls are deterministic. <p> This work's architecture will depend on the implementation of the Unix outside the mach kernel. Before making performance optimizations, we plan to measure the performance of ORM and tune it appropriately. Many performance optimizations will be based on the work in the earlier papers, <ref> [17, 1, 19, 20] </ref>. * Garbage collect checkpoints and message logs * Experiment with different logging mechanisms, such as sender-based log ging, volatile logging, and null logging. * Optimize file system access.
Reference: [21] <author> Walmer, L. R., and Thompson, M. R. </author> <title> A programmer's guide to the mach system calls. </title> <type> Tech. rep., </type> <institution> CS Department, </institution> <address> CMU, </address> <month> December </month> <year> 1989. </year> <month> 29 </month>
Reference-contexts: Second, the fault-tolerant system must produce the same output 1 , even when failures occur, as the original non-recoverable system. We have built a layer on top of Mach <ref> [3, 21] </ref> that makes multi-task Mach applications transparently recoverable from fail-stop processor failures. The layer implements Optimistic Recovery (OR) ([18]), an `optimistic' mechanism for fault-tolerance. A transparent recovery mechanism for Mach applications is desirable for several reasons.
References-found: 21

