URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1996/GIT-CC-96-31.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.96.html
Root-URL: 
Title: Exploiting Temporal and Spatial Constraints on Distributed Shared Objects  
Author: Richard West Karsten Schwan Ivan Tacic Mustaque Ahamad 
Note: This work is supported in part by the Engineering and Physical Sciences Research Council grant 92600699 and DARPA contract DABT63-95-C-0125  
Date: October 4, 1996  
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: The advent of gigabit network technologies has made it possible to combine sets of uni- and multiprocessor workstations into a distributed, massively-parallel computer system. Middleware, such as distributed shared objects (DSO), attempts to improve programmability of such systems, by providing globally accessible 'object' abstractions. Early research on distributed shared object systems concerned protocols to maintain consistency across replicated 'memory' objects. Such systems are well suited to scientific applications but have limited support for multimedia or groupware applications. This paper addresses the state sharing needs of complex distributed applications with (1) high-frequency symmetric data accesses to shared objects, (2) unpredictable and limited locality of data access, (3) dynamically changing sharing behavior, and (4) potential data races. We show that a DSO system that exploits application-level temporal and spatial constraints on shared objects can outperform shared object protocols which do not exploit application-level constraints. We describe the features of our S(emantic) DSO and compare three application specific consistency protocols, developed to run on our system against entry consistency for a sample application having the four properties mentioned above. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Sarita V. Adve and Mark D. Hill. </author> <title> Weak ordering anew definition. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 2-14, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: current location in reference to them, not on its past or future ability to access such shared state. * Data races may occur data races occur when two or more processes attempt to access the same memory location, where at least one process is performing a `write' to that location <ref> [1, 2, 4] </ref>. Most existing DSM systems assume that the programs using them are data race free, because this property is easily guaranteed if such programs' synchronization on shared state is implemented correctly.
Reference: [2] <author> Sarita V. Adve and Mark D. Hill. </author> <title> A unified formalization of four shared-memory models. </title> <type> Technical Report 1051, </type> <institution> University of Wisconsin, Madison, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: current location in reference to them, not on its past or future ability to access such shared state. * Data races may occur data races occur when two or more processes attempt to access the same memory location, where at least one process is performing a `write' to that location <ref> [1, 2, 4] </ref>. Most existing DSM systems assume that the programs using them are data race free, because this property is easily guaranteed if such programs' synchronization on shared state is implemented correctly.
Reference: [3] <author> Mustaque Ahamad, Ranjit John, Prince Kohli, and Gil Neiger. </author> <title> Causal memory meets the consistency and performance needs of distributed systems! In SIGOPS, </title> <booktitle> 1994. </booktitle> <pages> 23 </pages>
Reference-contexts: We mention three such prominent protocols, namely causal, entry, and lazy release consistency (LRC), and describe the reasons why these protocols are inadequate for the distributed multimedia applications addressed by our work. Causal consistency. Despite its proven high performance with scientific applications, causal memory <ref> [3] </ref> is not a good candidate for distributed multimedia applications, in part because the overheads of avoiding data races severely curtail the potential levels of asynchrony and concurrency.
Reference: [4] <author> Mustaque Ahamad, Gil Neiger, Prince Kohli, James E. Burns, and Phillip W. Hutto. </author> <title> Causal memory: Definitions, implementation and programming. </title> <journal> Distributed Computing, </journal> <volume> 9(1) </volume> <pages> 37-49, </pages> <month> Aug </month> <year> 1995. </year>
Reference-contexts: Since then, object-based research has moved toward more general representations of shared abstractions, including the support of arbitrary type hierarchies in object access [17, 34]. Furthermore, many researchers have investigated the efficient implementation of DSM, including the development of efficient consistency maintenance protocols <ref> [7, 4, 8, 21, 6, 14, 20, 28] </ref>, experimentation with alternative representations of shared memory pages [22] and with alternative methods for dealing with specific implementation issues, like false sharing [9]). Ongoing DSM research is developing hardware [27, 25] and operating system [23] support for efficient DSM implementations. <p> current location in reference to them, not on its past or future ability to access such shared state. * Data races may occur data races occur when two or more processes attempt to access the same memory location, where at least one process is performing a `write' to that location <ref> [1, 2, 4] </ref>. Most existing DSM systems assume that the programs using them are data race free, because this property is easily guaranteed if such programs' synchronization on shared state is implemented correctly.
Reference: [5] <author> Roberto Baldoni, Achour Mostefaoui, and Michel Raynal. </author> <title> Causal delivery of messages with real-time data in unreliable networks. Real-Time Systems, </title> <journal> The International Journal of Time-Critical Computing Systems, </journal> <volume> 10(3) </volume> <pages> 245-262, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Their system supports a wide range of multicast protocols but they focus on causality amongst process groups, while our work looks at application-specific shared object protocols. <ref> [5, 37] </ref> explores the notion of -causality in unreliable networks, supporting multimedia real-time collaborative applications. -causality is somewhat different from our work in that it deals with the delivery of messages that respect causal ordering only for messages received within their deadline-time, .
Reference: [6] <author> John K. Bennett, John B. Carter, and Willy Zwaenpoel. Munin: </author> <title> Distributed shared memory based on type-specific memory coherence. </title> <booktitle> In Proceedings of the 2nd ACM Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 168-176, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Since then, object-based research has moved toward more general representations of shared abstractions, including the support of arbitrary type hierarchies in object access [17, 34]. Furthermore, many researchers have investigated the efficient implementation of DSM, including the development of efficient consistency maintenance protocols <ref> [7, 4, 8, 21, 6, 14, 20, 28] </ref>, experimentation with alternative representations of shared memory pages [22] and with alternative methods for dealing with specific implementation issues, like false sharing [9]). Ongoing DSM research is developing hardware [27, 25] and operating system [23] support for efficient DSM implementations.
Reference: [7] <author> Brian N. Bershad and Matthew J. Zekauskas. Midway: </author> <title> Shared memory parallel programming with entry consistency for distributed memory multiprocessors. </title> <type> Technical Report CMU-CS-91-170, </type> <institution> Carnegie Mellon University, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Since then, object-based research has moved toward more general representations of shared abstractions, including the support of arbitrary type hierarchies in object access [17, 34]. Furthermore, many researchers have investigated the efficient implementation of DSM, including the development of efficient consistency maintenance protocols <ref> [7, 4, 8, 21, 6, 14, 20, 28] </ref>, experimentation with alternative representations of shared memory pages [22] and with alternative methods for dealing with specific implementation issues, like false sharing [9]). Ongoing DSM research is developing hardware [27, 25] and operating system [23] support for efficient DSM implementations. <p> The Treadmarks [20] system implements LRC, while EC is used in Midway <ref> [7] </ref>. We chose to restrict our protocol comparisons to entry consistency, since entry consistency has explicit associations between locks and objects, ensuring that only data associated with a lock is ever transferred with the lock itself.
Reference: [8] <author> Kenneth Birman, Andre Shiper, and Pat Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <type> Technical Report 91-1192, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> February </month> <year> 1991. </year> <note> To appear in ACM Transactions on Computer Systems. </note>
Reference-contexts: Since then, object-based research has moved toward more general representations of shared abstractions, including the support of arbitrary type hierarchies in object access [17, 34]. Furthermore, many researchers have investigated the efficient implementation of DSM, including the development of efficient consistency maintenance protocols <ref> [7, 4, 8, 21, 6, 14, 20, 28] </ref>, experimentation with alternative representations of shared memory pages [22] and with alternative methods for dealing with specific implementation issues, like false sharing [9]). Ongoing DSM research is developing hardware [27, 25] and operating system [23] support for efficient DSM implementations. <p> In the final version of this paper, we will present measurements evaluating the lookahead vs. the entry consistency protocols, again using the game application. 5 Related Work Birman et al <ref> [8] </ref> have built the ISIS toolkit as a programming platform for group communication.
Reference: [9] <author> William J. Bolosky and Michael L. Scott. </author> <title> False sharing and its effect on shared memory performance. </title> <booktitle> In 4th Symposium on Experimental Distributed and Multiprocessor Systems, </booktitle> <pages> pages 57-71, </pages> <month> September </month> <year> 1993. </year> <note> Also available as MSR-TR-93-1, </note> <institution> Microsoft Res. Lab., </institution> <month> Sep. </month> <year> 1993. </year>
Reference-contexts: Furthermore, many researchers have investigated the efficient implementation of DSM, including the development of efficient consistency maintenance protocols [7, 4, 8, 21, 6, 14, 20, 28], experimentation with alternative representations of shared memory pages [22] and with alternative methods for dealing with specific implementation issues, like false sharing <ref> [9] </ref>). Ongoing DSM research is developing hardware [27, 25] and operating system [23] support for efficient DSM implementations.
Reference: [10] <author> Russell Carter. </author> <title> Nas kernels on the connection machine. </title> <type> Technical Report RND-90-005, </type> <institution> NASA Ames Research Center, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: Evaluations of (1) and (2) are typically performed with application programs similar to those running on shared memory supercomputers <ref> [10] </ref>. Complex high performance applications. This paper considers the state sharing needs of the complex distributed applications targeted by ongoing research in distributed, object-based systems, including distributed groupware applications [16], client-server systems [30], and distributed and interactive high performance codes [32].
Reference: [11] <author> Christian Clemencon, Bodhisattwa Mukherjee, and Karsten Schwan. </author> <title> Distributed shared abstractions (DSA) on large-scale multiprocessors. </title> <booktitle> In Proc. of the Fourth USENIX Symposium on Experiences with Distributed and Multiprocessor Systems, </booktitle> <pages> pages 227-246. </pages> <publisher> USENIX, </publisher> <month> September </month> <year> 1993. </year> <note> Also as TR# GIT-CC-93/25. </note>
Reference-contexts: It is up to object implementors and the underlying run-time system to maintain consistency across distributed object components. Early research on distributed shared objects concerned `memory' objects accessible via `read' and `write' operations (DSM) [26] or `fragmented' objects offering relatively simple operational interfaces <ref> [11, 33] </ref>. Since then, object-based research has moved toward more general representations of shared abstractions, including the support of arbitrary type hierarchies in object access [17, 34].
Reference: [12] <author> Greg Eisenhauer and Karsten Schwan. </author> <title> Design and analysis of a parallel molecular dynamics application. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 35(1) </volume> <pages> 76-90, </pages> <month> May 25 </month> <year> 1996. </year>
Reference-contexts: Even scientific applications exhibit such spatial consistency constraints, as is evident in n-body simulations, where the gravitational effects of bodies on each other are considered only when two bodies are within minimum distance d of each other. Likewise, molecular dynamics simulations <ref> [12] </ref> tend to consider only those interactions of molecules within some known cut-off radius.
Reference: [13] <author> C. Cruz-Neira et al. </author> <title> The cave audio visual experience auto virtual environment. </title> <journal> Communications of the ACM, </journal> <pages> pages 65-72, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The sample applications considered in our research include (1) distributed multimedia games; (2) collaborative applications in which substantial amounts of state may be shared, such as distributed virtual environments <ref> [13] </ref>, shared visualization of 3D datasets manip 1 ulated by multiple end users [32], or distributed design environments [24]; (3) distributed real-time applications in which many entities share common state, such as distributed command and control [29]; and (4) high performance applications exhibiting dynamic data access patterns [36].
Reference: [14] <author> Kourosh Gharachorloo, Daniel Lenoski, James Laudon, Phillip Gibbons, Anoop Gupta, and John Hennessy. </author> <title> Memory consistency and event ordering in scalable shared memory multiprocessors. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 15-26, </pages> <month> May </month> <year> 1990. </year> <month> 24 </month>
Reference-contexts: Since then, object-based research has moved toward more general representations of shared abstractions, including the support of arbitrary type hierarchies in object access [17, 34]. Furthermore, many researchers have investigated the efficient implementation of DSM, including the development of efficient consistency maintenance protocols <ref> [7, 4, 8, 21, 6, 14, 20, 28] </ref>, experimentation with alternative representations of shared memory pages [22] and with alternative methods for dealing with specific implementation issues, like false sharing [9]). Ongoing DSM research is developing hardware [27, 25] and operating system [23] support for efficient DSM implementations. <p> Two particular issues addressed by such work are (1) the levels of concurrency attainable by programs using DSM abstractions [18] and (2) the scalability of DSM implementations in terms of the amounts of memory shared and the number of processors involved in such sharing <ref> [14, 28] </ref>. Evaluations of (1) and (2) are typically performed with application programs similar to those running on shared memory supercomputers [10]. Complex high performance applications.
Reference: [15] <author> James Griffoen, Raj Yavatkar, and Raphael Finkel. </author> <title> Extending the dimensions of con-sistency: Spatial consistency and sequential segments. </title> <type> Technical Report cs248-94, </type> <institution> University of Kentucky, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: We hope to look at shared objects that involve data and methods for manipulating that data. Furthermore, the DSM systems described in [31] are traditional systems that have little or no support for exploiting application-level semantics to improve performance. Finally, <ref> [15] </ref> describes the Unify system for exploring scalable approaches to designing distributed multicomputer systems.
Reference: [16] <author> S. Gronemberg and D. Marwood. </author> <title> Real-time groupware as a distributed system: Con-currency control and its effect on the interface. </title> <booktitle> In Proceedings of the ACM Conference on Cooperative Support for Cooperative Work, </booktitle> <publisher> ACM press, </publisher> <pages> pages 207-217. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: Evaluations of (1) and (2) are typically performed with application programs similar to those running on shared memory supercomputers [10]. Complex high performance applications. This paper considers the state sharing needs of the complex distributed applications targeted by ongoing research in distributed, object-based systems, including distributed groupware applications <ref> [16] </ref>, client-server systems [30], and distributed and interactive high performance codes [32]. Specifically, we focus on the required consistency of the state shared in such applications. Toward that end, this work utilizes the relatively `simple' model of shared state presented by DSM abstractions, accessed with `read' and `write' operations.
Reference: [17] <institution> X Consortium Working Group. </institution> <note> Fresco specification draft version 0.7, </note> <month> April </month> <year> 1994. </year>
Reference-contexts: Since then, object-based research has moved toward more general representations of shared abstractions, including the support of arbitrary type hierarchies in object access <ref> [17, 34] </ref>.
Reference: [18] <author> Phil W. Hutto and Mustaque Ahamad. </author> <title> Slow memory: Weakening consistency to enhance concurrency in distrbuted shared memories. </title> <booktitle> In Proceedings of the International Conference on Distributed Computing Systems, </booktitle> <pages> pages 302-311, </pages> <year> 1990. </year>
Reference-contexts: Ongoing DSM research is developing hardware [27, 25] and operating system [23] support for efficient DSM implementations. Two particular issues addressed by such work are (1) the levels of concurrency attainable by programs using DSM abstractions <ref> [18] </ref> and (2) the scalability of DSM implementations in terms of the amounts of memory shared and the number of processors involved in such sharing [14, 28]. Evaluations of (1) and (2) are typically performed with application programs similar to those running on shared memory supercomputers [10].
Reference: [19] <author> Rakesh Jha, Mustafa Muhammad, Sudharkar Yalamanchili, Karsten Schwan, Daniela Ivan-Rosu, and Chris DeCastro. </author> <title> Adaptive resource allocation for embedded parallel applications. </title> <booktitle> conference submission, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: S-DSO is evaluated with a novel distributed multimedia application implementing a multi-player game and patterned after the complex command and control applications now being developed by companies like Honeywell <ref> [19] </ref> and TRW [29].
Reference: [20] <author> P. Keleher, S. Dwarkadas, A. Cox, and W. Zwaenepoel. Treadmarks: </author> <title> Distributed shared memory on standard workstations and operating systems. </title> <institution> Technical Report Rice COMP TR93-214, Department of Computer Science, Rice University, </institution> <year> 1993. </year>
Reference-contexts: Since then, object-based research has moved toward more general representations of shared abstractions, including the support of arbitrary type hierarchies in object access [17, 34]. Furthermore, many researchers have investigated the efficient implementation of DSM, including the development of efficient consistency maintenance protocols <ref> [7, 4, 8, 21, 6, 14, 20, 28] </ref>, experimentation with alternative representations of shared memory pages [22] and with alternative methods for dealing with specific implementation issues, like false sharing [9]). Ongoing DSM research is developing hardware [27, 25] and operating system [23] support for efficient DSM implementations. <p> To ensure that a process acquiring a lock receives all changes to shared data that were known to the process that released the lock, data dependencies are recorded using vector timestamps, and a history-based mechanism determines what data modifications have to be transferred with the lock. The Treadmarks <ref> [20] </ref> system implements LRC, while EC is used in Midway [7]. We chose to restrict our protocol comparisons to entry consistency, since entry consistency has explicit associations between locks and objects, ensuring that only data associated with a lock is ever transferred with the lock itself.
Reference: [21] <author> Pete Keleher, Alan L. Cox, and Willy Zwaenepoel. </author> <title> Lazy release consistency for software distributed shared memory. </title> <booktitle> In Proceedings of the 19th International Symposium of Computer Architecture, </booktitle> <year> 1992. </year>
Reference-contexts: Since then, object-based research has moved toward more general representations of shared abstractions, including the support of arbitrary type hierarchies in object access [17, 34]. Furthermore, many researchers have investigated the efficient implementation of DSM, including the development of efficient consistency maintenance protocols <ref> [7, 4, 8, 21, 6, 14, 20, 28] </ref>, experimentation with alternative representations of shared memory pages [22] and with alternative methods for dealing with specific implementation issues, like false sharing [9]). Ongoing DSM research is developing hardware [27, 25] and operating system [23] support for efficient DSM implementations.
Reference: [22] <author> Prince Kohli, Mustaque Ahamad, and Karsten Schwan. Indigo: </author> <title> User-level support for building distributed shared abstractions. </title> <booktitle> In Fourth IEEE International Symposium on High-Performance Distributed Computing (HPDC-4), </booktitle> <month> August </month> <year> 1995. </year>
Reference-contexts: Furthermore, many researchers have investigated the efficient implementation of DSM, including the development of efficient consistency maintenance protocols [7, 4, 8, 21, 6, 14, 20, 28], experimentation with alternative representations of shared memory pages <ref> [22] </ref> and with alternative methods for dealing with specific implementation issues, like false sharing [9]). Ongoing DSM research is developing hardware [27, 25] and operating system [23] support for efficient DSM implementations. <p> S-DSO does not offer a single consistency protocol, nor does it implement some particular lock management scheme for use in synchronization (when desired by programmers). Instead, it builds on the generality of the Indigo <ref> [22] </ref> system to present to developers low level primitives with which they may construct exactly the shared object functionality and consistency semantics they desire. In addition, using attributes, consistency maintenance may exploit application-level semantics specified by end users. <p> One way of reducing the number of processes that must synchronize is to explicitly specify which objects are shared in a program at which times, using share (object ) and un-share (object ) calls to the underlying DSM run-time system, as done in Indigo <ref> [22] </ref>. However, for applications where the sharing patterns change frequently, the code would be cluttered with such calls, and frequent calls would result in substantial overheads since for each such call, the system would have to build and rebuild associations of shared objects with different groups of processes. <p> We next describe a framework for building application-specific consistency protocols and show how the lookahead protocols, suitable for our sample application can be built using 10 this framework. 3 S-DSO A Framework for Application-Specific Consistency Protocols 3.1 System Description The S-DSO infrastructure extends the functionality of Indigo <ref> [22] </ref> by allowing users to write application-specific functions that can be invoked by a consistency protocol to minimize message exchanges and to increase asynchrony, concurrency, and scalability in distributed applications that share objects. <p> However, to allow conventional DSM/DSO protocols to run, we plan to add a full set of library calls similar to those described for the Indigo system <ref> [22] </ref>.
Reference: [23] <author> Leonidas I. Kontothanassis and Michael L. Scott. </author> <title> Distributed shared memory for new generation networks. </title> <type> Technical Report TR 578, </type> <institution> University of Rochester, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Ongoing DSM research is developing hardware [27, 25] and operating system <ref> [23] </ref> support for efficient DSM implementations.
Reference: [24] <author> Robin Kravets, Ken Calvert, and Karsten Schwan. </author> <title> Dynamically configurable communication protocols and distributed applications: Motivation and experience. </title> <note> submitted to Multimedia Computing and Networking 1997 (MMCN97). </note>
Reference-contexts: The sample applications considered in our research include (1) distributed multimedia games; (2) collaborative applications in which substantial amounts of state may be shared, such as distributed virtual environments [13], shared visualization of 3D datasets manip 1 ulated by multiple end users [32], or distributed design environments <ref> [24] </ref>; (3) distributed real-time applications in which many entities share common state, such as distributed command and control [29]; and (4) high performance applications exhibiting dynamic data access patterns [36]. <p> For example, in virtual environments used for distributed games, the movement of one 'player' may affect the actions of another player within range of each other. * Dynamic changes in sharing behavior the sharing behavior of these applications may change rapidly. For instance, in distributed design <ref> [24] </ref> or in scientific collaboration via shared 3D data [32], participants may jointly manipulate certain shared state with high frequency, then cease such sharing and operate on private data or instead, begin interacting with other collaborators on related tasks.
Reference: [25] <author> D. Lenoski, J. Laudon, K. Gharachorloo, A. Gupta, and J. Hennessy. </author> <title> The directory-based cache coherence protocol for the DASH multiprocessor. </title> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: Ongoing DSM research is developing hardware <ref> [27, 25] </ref> and operating system [23] support for efficient DSM implementations.
Reference: [26] <author> Kai Li. Ivy: </author> <title> A shared virtual memory system for parallel computing. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages II 94-101, </pages> <month> Aug </month> <year> 1988. </year>
Reference-contexts: It is up to object implementors and the underlying run-time system to maintain consistency across distributed object components. Early research on distributed shared objects concerned `memory' objects accessible via `read' and `write' operations (DSM) <ref> [26] </ref> or `fragmented' objects offering relatively simple operational interfaces [11, 33]. Since then, object-based research has moved toward more general representations of shared abstractions, including the support of arbitrary type hierarchies in object access [17, 34].
Reference: [27] <author> Kai Li and Paul Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM TOCS, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year> <month> 25 </month>
Reference-contexts: Ongoing DSM research is developing hardware <ref> [27, 25] </ref> and operating system [23] support for efficient DSM implementations.
Reference: [28] <author> Richard J. Lipton and Jonathan S. Sandberg. </author> <title> PRAM: A scalable shared memory. </title> <type> Tech--nical Report CS-TR-180-88, </type> <institution> Princeton University, Department of Computer Science, </institution> <month> September </month> <year> 1988. </year>
Reference-contexts: Since then, object-based research has moved toward more general representations of shared abstractions, including the support of arbitrary type hierarchies in object access [17, 34]. Furthermore, many researchers have investigated the efficient implementation of DSM, including the development of efficient consistency maintenance protocols <ref> [7, 4, 8, 21, 6, 14, 20, 28] </ref>, experimentation with alternative representations of shared memory pages [22] and with alternative methods for dealing with specific implementation issues, like false sharing [9]). Ongoing DSM research is developing hardware [27, 25] and operating system [23] support for efficient DSM implementations. <p> Two particular issues addressed by such work are (1) the levels of concurrency attainable by programs using DSM abstractions [18] and (2) the scalability of DSM implementations in terms of the amounts of memory shared and the number of processors involved in such sharing <ref> [14, 28] </ref>. Evaluations of (1) and (2) are typically performed with application programs similar to those running on shared memory supercomputers [10]. Complex high performance applications.
Reference: [29] <author> Jim McDonald and Karsten Schwan. </author> <title> Ada dynamic load control mechanisms for distributed embedded battle management systems. </title> <booktitle> In First Workshop on Real-time Applications, </booktitle> <address> New York, </address> <pages> pages 156-160. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1993. </year>
Reference-contexts: in which substantial amounts of state may be shared, such as distributed virtual environments [13], shared visualization of 3D datasets manip 1 ulated by multiple end users [32], or distributed design environments [24]; (3) distributed real-time applications in which many entities share common state, such as distributed command and control <ref> [29] </ref>; and (4) high performance applications exhibiting dynamic data access patterns [36]. The characteristics of such applications relevant to our work are: * Poor and unpredictable locality distributed processes may read and write shared data with high frequency, thereby making it difficult to cache shared state. <p> S-DSO is evaluated with a novel distributed multimedia application implementing a multi-player game and patterned after the complex command and control applications now being developed by companies like Honeywell [19] and TRW <ref> [29] </ref>.
Reference: [30] <author> J. G. Mitchell, J. G. Gibbons, G. Hamilton, P. B. Kessler, Y. A. Khalidi, P. Kougiouris, P. W. Madany, M. N. Nelson, M. L. Powell, and S. R. Radia. </author> <title> An overview of the spring system. </title>
Reference-contexts: Complex high performance applications. This paper considers the state sharing needs of the complex distributed applications targeted by ongoing research in distributed, object-based systems, including distributed groupware applications [16], client-server systems <ref> [30] </ref>, and distributed and interactive high performance codes [32]. Specifically, we focus on the required consistency of the state shared in such applications. Toward that end, this work utilizes the relatively `simple' model of shared state presented by DSM abstractions, accessed with `read' and `write' operations.
Reference: [31] <author> Mahendra Ramachandran and Mukesh Singhal. </author> <title> On the synchronization in distributed shared memory systems. </title> <type> Technical Report OSU-CISRC-10/94-TR54, </type> <institution> Ohio State University, </institution> <year> 1994. </year>
Reference-contexts: However, this work is primarily focused on synchronizing media streams across networks, and detecting and bounding the levels of asynchrony between streams to meet the quality of service constraints of different media types. <ref> [31] </ref> surveys the various synchronization mechanisms used in distributed shared memory systems. Our work is not restricted to shared memory abstractions but generalizes to shared 22 object systems. We hope to look at shared objects that involve data and methods for manipulating that data. Furthermore, the DSM systems described in [31] <p> <ref> [31] </ref> surveys the various synchronization mechanisms used in distributed shared memory systems. Our work is not restricted to shared memory abstractions but generalizes to shared 22 object systems. We hope to look at shared objects that involve data and methods for manipulating that data. Furthermore, the DSM systems described in [31] are traditional systems that have little or no support for exploiting application-level semantics to improve performance. Finally, [15] describes the Unify system for exploring scalable approaches to designing distributed multicomputer systems.
Reference: [32] <author> Beth Schroeder, Gerg Eisenhauer, Jeremy Heiner, Vernard Martin, Karsten Schwan, and Jeffrey Vetter. </author> <note> From interactive apllications to distribted laboratories. Submitted to the Visual Supercomputing special issue of IEEE Computational Science and Engineering - June 1996, </note> <year> 1996. </year>
Reference-contexts: Complex high performance applications. This paper considers the state sharing needs of the complex distributed applications targeted by ongoing research in distributed, object-based systems, including distributed groupware applications [16], client-server systems [30], and distributed and interactive high performance codes <ref> [32] </ref>. Specifically, we focus on the required consistency of the state shared in such applications. Toward that end, this work utilizes the relatively `simple' model of shared state presented by DSM abstractions, accessed with `read' and `write' operations. <p> The sample applications considered in our research include (1) distributed multimedia games; (2) collaborative applications in which substantial amounts of state may be shared, such as distributed virtual environments [13], shared visualization of 3D datasets manip 1 ulated by multiple end users <ref> [32] </ref>, or distributed design environments [24]; (3) distributed real-time applications in which many entities share common state, such as distributed command and control [29]; and (4) high performance applications exhibiting dynamic data access patterns [36]. <p> For instance, in distributed design [24] or in scientific collaboration via shared 3D data <ref> [32] </ref>, participants may jointly manipulate certain shared state with high frequency, then cease such sharing and operate on private data or instead, begin interacting with other collaborators on related tasks. <p> this integration, we expect to be able to investigate the effects of wide area as well as the effects of high performance communication media on consistency protocols, and on applications like the video game presented here and the large-scale distributed virtual environments now being developed at Georgia Tech and elsewhere <ref> [32] </ref>.
Reference: [33] <author> M. Shapiro. </author> <title> Structure and encapsulation in distributed systems: The proxy principle. </title> <booktitle> In Sixth International Conference on Distributed Computing Systems, </booktitle> <address> Boston, Mass., </address> <pages> pages 198-204. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1986. </year>
Reference-contexts: It is up to object implementors and the underlying run-time system to maintain consistency across distributed object components. Early research on distributed shared objects concerned `memory' objects accessible via `read' and `write' operations (DSM) [26] or `fragmented' objects offering relatively simple operational interfaces <ref> [11, 33] </ref>. Since then, object-based research has moved toward more general representations of shared abstractions, including the support of arbitrary type hierarchies in object access [17, 34].
Reference: [34] <author> Jon Siegel. </author> <title> CORBA Fundamentals and Programming. </title> <publisher> John Wiley and Sons, </publisher> <address> 605 Third Ave, New York, NY 10158. ISBN 0471-12148-7, </address> <year> 1996. </year>
Reference-contexts: Since then, object-based research has moved toward more general representations of shared abstractions, including the support of arbitrary type hierarchies in object access <ref> [17, 34] </ref>.
Reference: [35] <author> Sang Son and Nipun Agarwal. </author> <title> Synchronization of temporal constructs in distributed multimedia systems with controlled accuracy. </title> <type> Technical Report CS-93-57, </type> <institution> University of Virginia, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: Yavatkar has built a Multi-Flow Conversation Protocol (MCP)[37] to support the temporal synchronization of multimedia collaborative applications, with the explicit ability to support causally-ordered message transfers. There has been much work by people such as <ref> [35] </ref> to investigate temporal synchronization in distributed multimedia systems.
Reference: [36] <author> J. Wu, R. Das, J. Saltz, H. Berryman, and S. Hiranandam. </author> <title> Distributed memory compiler design for sparse problems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 44(6) </volume> <pages> 737-753, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: distributed virtual environments [13], shared visualization of 3D datasets manip 1 ulated by multiple end users [32], or distributed design environments [24]; (3) distributed real-time applications in which many entities share common state, such as distributed command and control [29]; and (4) high performance applications exhibiting dynamic data access patterns <ref> [36] </ref>. The characteristics of such applications relevant to our work are: * Poor and unpredictable locality distributed processes may read and write shared data with high frequency, thereby making it difficult to cache shared state. <p> This is exemplified by the dynamic data redistribution necessary for the irregular scientific applications investigated in <ref> [36] </ref>. * Symmetric data access in contrast to distributed programs like World Wide Web browsers where servers occasionally write shared data while clients simply read the data, these applications' distributed processes may behave symmetrically in terms of their read and write operations on shared state.
Reference: [37] <author> Raj Yavatkar. Mcp: </author> <title> A protocol for coordination and temporal synchronization in multimedia collaborative applications. </title> <booktitle> In Proceedings of the 12th IEEE International Conference on Distributed Computing Systems, </booktitle> <pages> pages 606-613. </pages> <publisher> IEEE, </publisher> <year> 1992. </year> <month> 26 </month>
Reference-contexts: Their system supports a wide range of multicast protocols but they focus on causality amongst process groups, while our work looks at application-specific shared object protocols. <ref> [5, 37] </ref> explores the notion of -causality in unreliable networks, supporting multimedia real-time collaborative applications. -causality is somewhat different from our work in that it deals with the delivery of messages that respect causal ordering only for messages received within their deadline-time, .
References-found: 37

