URL: http://www.research.digital.com/SRC/tla/tcs.ps.Z
Refering-URL: http://www.research.digital.com/SRC/tla/papers.html
Root-URL: http://www.research.digital.com
Title: Processes are in the Eye of the Beholder  
Author: Leslie Lamport 
Date: December 25, 1994 revised January 16, 1996  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martn Abadi, Leslie Lamport, and Stephan Merz. </author> <title> Refining specifications. </title> <note> To appear. </note>
Reference-contexts: 6 6 empty : IsNext (pp; i ) ! in ? buf [i ]; pp [i ] := 1 pp [i ] ; full : IsNext (gg; i ) ! out ! buf [i ]; gg [i ] := 1 gg [i ] 7 7 2 p pp [0] pp <ref> [1] </ref> pp [2] pp [3] 1 1 0 0 0 3 1 1 1 0 5 0 1 1 1 . . . . . . . . . is defined by IsNext (r ; i ) = if i = 0 then r [0] = r [N 1] else r <p> A history variable is an auxiliary variable that records information from previous states. It is added by using the following lemma, which can be deduced from the results in <ref> [1] </ref>. Step 2 is easily proved by repeated application of this lemma.
Reference: [2] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: empty : IsNext (pp; i ) ! in ? buf [i ]; pp [i ] := 1 pp [i ] ; full : IsNext (gg; i ) ! out ! buf [i ]; gg [i ] := 1 gg [i ] 7 7 2 p pp [0] pp [1] pp <ref> [2] </ref> pp [3] 1 1 0 0 0 3 1 1 1 0 5 0 1 1 1 . . . . . . . . . is defined by IsNext (r ; i ) = if i = 0 then r [0] = r [N 1] else r [i ] <p> for all i 2 S ; [f except ![i ] = e] is the function b f that is the same as f except b f [i ] = e; angle brackets enclose tuples; t [i ] is the i th component of tuple t, so hv ; w i <ref> [2] </ref> = w ; and S nT is the set of elements in S that are not in T . A TLA formula is an assertion about behaviors, which are sequences of states.
Reference: [3] <author> R. P. Kurshan and Leslie Lamport. </author> <title> Verification of a multiplier: 64 bits and beyond. In Costas Courcoubetis, editor, Computer-Aided Verification, </title> <booktitle> volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 166-179, </pages> <address> Berlin, </address> <month> June </month> <year> 1993. </year> <title> Springer-Verlag. </title> <booktitle> Proceedings of the Fifth International Conference, </booktitle> <address> CAV'93. </address>
Reference-contexts: IsNext (pp; i ) ! in ? buf [i ]; pp [i ] := 1 pp [i ] ; full : IsNext (gg; i ) ! out ! buf [i ]; gg [i ] := 1 gg [i ] 7 7 2 p pp [0] pp [1] pp [2] pp <ref> [3] </ref> 1 1 0 0 0 3 1 1 1 0 5 0 1 1 1 . . . . . . . . . is defined by IsNext (r ; i ) = if i = 0 then r [0] = r [N 1] else r [i ] 6= r <p> Going from the two-process version to the N - 17 process one reduces the internal state of each process from an unbounded number (p or g) to three bits (pp [i ], gg [i ], and ctl [i ]). As explained in <ref> [3] </ref>, such a transformation enables us to apply model checking to unbounded-state systems. In retrospect, it is not surprising that programs with different numbers of processes can be equivalent. Multiprocess programs are routinely executed on single-processor computers by interleaving the execution of their processes.
Reference: [4] <author> Leslie Lamport. </author> <title> How to write a proof. </title> <type> Research Report 94, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> February </month> <year> 1993. </year> <note> To appear in American Mathematical Monthly. </note>
Reference-contexts: It is semantically superfluous, since NotProc (i ) already allows such steps, but the syntax of TLA requires some subscript. 3 The Proof We now give a hierarchically structured proof that 2 and N are equivalent <ref> [4] </ref>. The proof is completely formal, meaning that each step is a mathematical formula. English is used only to explain the low-level reasoning.
Reference: [5] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: We do not know how to write a completely formal proof that two programming-language representations of the ring buffer are equivalent. In Section 2, we represent the program formally in TLA, the Temporal Logic of Actions <ref> [5] </ref>. buf [0] . . . in- out 1 in, out : channel of Value buf array 0 : : N 1 of Value p, g : internal Natural initially 0 Receiver :: fl " p := p +1 jj Sender :: fl " g := g +1 in, out : <p> IsNext (Rep (m); i ) (i = m mod N ) 2. IsNext (Rep (m); i ) ) Rep (m + 1) = [Rep (m) except ![i ] = 1 Rep (m)[i ]] For temporal reasoning, we use the following TLA rules from Figure 5 of <ref> [5] </ref>. 8 Theorem 2 N 1a. 2 u b. <p> 999 999 p; g; pp; gg; ctl : h N step 3 999 999 pp; gg; ctl; p; g : h N simple logic 999 999 pp; gg; ctl : u N step 2b N step 1b and the definition of N (This version of TLA2 generalizes the one in <ref> [5] </ref>.) STL2: ` 2F ) F STL3: ` 22F 2F 2F ) 2G INV1: I ^ [N ] f ) I 0 INV2: ` 2I ) (2 [N ] f 2 [N ^ I ^ I 0 ] f ) 2P ^ (8 i 2 S : 2 [A i ] <p> For weak fairness, the equivalence is a consequence of the following result, which can be derived from the TLA proof rules of <ref> [5] </ref>.
Reference: [6] <author> R. Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1980. </year> <month> 24 </month>
Reference-contexts: In process algebra <ref> [6] </ref>, analogous transformations are performed by applying algebraic laws. It would be interesting to compare a process-algebraic proof of equivalence of the two ring-buffer programs with our TLA proof. A Proof of the Theorem Theorem 2 N 1a. 2 u 1a.1.
References-found: 6

