URL: http://www.cse.ogi.edu/Sparse/paper/gerlek.live.94.ps
Refering-URL: http://www.cse.ogi.edu/Sparse/sparse.live.html
Root-URL: http://www.cse.ogi.edu
Title: A Reference Chain Approach for Live Variables  
Author: Michael P. Gerlek Michael Wolfe, Eric Stoltz 
Keyword: dataflow analysis, static single assignment, sparse evaluation graph, slotwise analysis, live variables, interference graph, dead code elimination  
Note: This research was supported by ARPA under grant F3062-92-C-135.  
Address: P.O. Box 91000 Portland, OR 97291-1000 USA  
Affiliation: Oregon Graduate Institute of Science Technology Department of Computer Science and Engineering  
Email: gerlek@cse.ogi.edu  
Phone: 503-690-1121 x7404  
Date: April 16, 1994  
Abstract: The classical dataflow approach to determine the set of variables that are live at some point in a program entails using an iterative algorithm across the entire program, usually with costly bit-vector data structures. Methods based on sparse evaluation graphs exist, but these are solved on a per-variable basis and are also iterative. Inspired by our group's interest in sparse representations of use-def and def-use reference chains, we are investigating still another approach. In this paper, we present an algorithm for determining liveness of variables based on upwards exposed use information at control flow branch points, analogous to the collection of reaching definition information in the popular Static Single Assignment form. We demonstrate the use of our technique with two applications, building interference graphs and eliminating dead code, and show that this new reference chain approach has important advantages over previous methods. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: 1 Introduction A variable v at some point p in a program is considered live at p if v may be used along some control flow path from p, that is if v has an upwards exposed use <ref> [1] </ref>. If v is used nowhere after p, then v is dead at p. <p> In the next two sections, we present an 1 We will assume the reader is familiar with these concepts; details may be found in most compiler texts <ref> [1, 2] </ref>. 2 algorithm to construct the reference chains and an algorithm to compute liveness using them. In section 4 we show how to construct an interference graph from these chains and discuss other applications such as dead code elimination. <p> returning to block v, only those operations that affected the Live set are undone, so that at the bottom of v the Live set is precisely equal to what it started as. 4 Applications of Liveness 4.1 Interference Graph Construction Most modern compilers perform register assignment with graph coloring algorithms <ref> [1, 11] </ref>. <p> 2 Live The interference graph is represented as a (symmetric) matrix I, such that I rs = 1 if symbol r interferes with symbol s and I rs = 0 otherwise. 2 4.2 Dead Code Elimination An assignment to a variable that is not subsequently used is termed dead code <ref> [1] </ref>. Dead (or useless) code usually occurs as a result of compiler optimization: a branch condition may be determined to be constant, 14 code motion might effectively copy but not move computations, etc. <p> Second, in this paper we have considered the liveness property of variables, a backwards dataflow problem. A related problem is that of busy or anticipatable expressions: an expression e is said to be 21 busy (very busy) at point p if e may (will) be used after p <ref> [1] </ref>. The use of operators similar to -operators, using expressions instead of variables, may be investigated. Finally, the characteristics of the -operators inserted should be examined. In particular, -operators whose lattice value does not contribute to the solution need not be inserted.
Reference: [2] <author> Charles N. Fischer and Richard J. LeBlanc, Jr. </author> <title> Crafting a Compiler. </title> <address> Benjamin-Cummings, Menlo Park, CA, </address> <year> 1988. </year>
Reference-contexts: In the next two sections, we present an 1 We will assume the reader is familiar with these concepts; details may be found in most compiler texts <ref> [1, 2] </ref>. 2 algorithm to construct the reference chains and an algorithm to compute liveness using them. In section 4 we show how to construct an interference graph from these chains and discuss other applications such as dead code elimination.
Reference: [3] <author> Jong-Deok Choi, Ron Cytron, and Jeanne Ferrante. </author> <title> Automatic construction of sparse data flow evaluation graphs. </title> <booktitle> In Conf. Record 18th Annual ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 55-66, </pages> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: If the bit-vectors are sparse, this is not an efficient technique; Choi et al note that "compiler writers generally acknowledge bit-vectors are overly consumptive of space" <ref> [3] </ref>. A preferable approach would be to take advantage of the definition/use information already within the program, avoiding the space required for the def and use sets. <p> In live variables analysis, for example, a given variable will be used or defined only in a small number of places in the program. Sparse evaluation graphs represent a subset of the flow graph for a particular problem, connecting only the nodes effecting the solution <ref> [3] </ref>. A standard solver is then applied to the reduced graph and the solution is mapped back to the original flow graph. Sparse evaluation graphs do not present a new solution technique as such but rather minimize the cost of the standard ones.
Reference: [4] <author> Eric Stoltz, Michael P. Gerlek, and Michael Wolfe. </author> <title> Extended SSA with factored use-def chains to support optimization and parallelism. </title> <booktitle> In Proc. of 27th Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 43-52, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: A preferable approach would be to take advantage of the definition/use information already within the program, avoiding the space required for the def and use sets. Our research group's interest in the advantages of reference chains (representations of factored use-def and def-use chains <ref> [4] </ref>) has led to the investigation of an alternative to the iterative approach. This paper presents a solution to the live variables problem which uses -operators to merge upwards exposed reference information at branch points in the control flow graph.
Reference: [5] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently computing Static Single Assignment form and the control dependence graph. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The idea is derived from the traditional Static Single Assignment (SSA) form in which -operators are placed at flow graph confluence points to merge multiple reaching definitions <ref> [5] </ref>. By using the information embedded within the flow graph at the -operators, we avoid the need for the in and out sets: at each block, the relevant information is determined by the confluence of the upwards exposed references determined by the -operators. <p> An open question is whether the cost of constructing n sparse graphs and solving n small problems is less than the cost of solving n (possibly vectorizable) problems simultaneously. Static Single Assignment Form. SSA form is used to capture reaching definition information at points in the program <ref> [5] </ref>. The program is augmented with -operators which merge reaching definitions at flow graph confluence points. Uses are then linked to the unique reaching definition so that in this form the information (reaching definitions) is available only where required. <p> PDF + (Y ) is computed via a worklist algorithm, and is equivalent to the iterated join set of the reverse control flow graph; we will rely on this in the following algorithms, and the reader is encouraged to refer to the seminal papers by Cytron et al for details <ref> [7, 5] </ref>.
Reference: [6] <author> Dhananjay M. Dhamdhere, Barry K. Rosen, and F. Kenneth Zadeck. </author> <title> How to analyze large programs efficiently and informatively. </title> <booktitle> In Proc. ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 212-223, </pages> <address> San Francisco, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: For dataflow problems requiring only a binary lattice (&gt;and ?), there are only three interesting transfer functions that can occur at a node: either the node will have a known value of &gt;or ?, or the node will propagate the solution of a predecessor node (for forwards problems) <ref> [6] </ref>. Slotwise analysis proceeds by first processing nodes with constant solutions. For nodes with the propagate transfer function, those that are reached any nodes whose solution is ? will have ? as their solution. The remaining nodes will have &gt; as their solution.
Reference: [7] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and Kenneth Zadeck. </author> <title> An efficient method of computing static single assignment form. </title> <booktitle> In Conf. Record 16th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 25-35, </pages> <address> Austin, TX, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: Entry and Exit are distinguished nodes representing the unique entry and exit points in the program; we assume all nodes are reachable from Entry and all nodes reach Exit. We also assume the placement of the so-called technical edge from Entry to Exit, needed for control dependence relations <ref> [7] </ref>. We denote an edge in the CFG from node X to Y as X ! Y . The set Pred (X) represents the predecessors of X in the CFG, that is the set of all nodes v 2 V such that v ! X. <p> PDF + (Y ) is computed via a worklist algorithm, and is equivalent to the iterated join set of the reverse control flow graph; we will rely on this in the following algorithms, and the reader is encouraged to refer to the seminal papers by Cytron et al for details <ref> [7, 5] </ref>. <p> the SSA 5 v ipdom of v PDF (v) def v use v in v out v 0 8 2 7 0,2 i i 4 5 3 i i i 6 2 2 i i 8 Table 1: Post-dominator and liveness for example program construction algorithms of Cytron et al <ref> [7] </ref>. In the placement phase, each symbol in the program is processed separately as in SSA. First, a worklist is initialized to the set of blocks containing at least one reference to the symbol. <p> The post-dominance frontiers are assumed to have already been created. 2 2.2 Correctness The proof of correctness for -chain construction can be directly adapted from the original SSA construction proofs by Cytron et al <ref> [7] </ref>. In the SSA -placement algorithm, a -operator for symbol s is placed at the iterated dominance frontier 2 of the set of blocks containing assignments to s.
Reference: [8] <author> R. Tarjan. </author> <title> Depth-first search and linear graph algorithms. </title> <journal> SIAM J. Comput., </journal> <volume> 1(2) </volume> <pages> 146-160, </pages> <month> June </month> <year> 1972. </year>
Reference-contexts: The lattice value of each link of a -operator encountered during the bottom-up traversal of the flow graph is evaluated using Tarjan's well-known algorithm for detecting strongly connected components (SCCs) in directed graphs <ref> [8] </ref>. This algorithm has the important property that each component in the graph is visited and processed only after each of its descendants have been visited and processed.
Reference: [9] <author> Frank Kenneth Zadeck. </author> <title> Incremental data flow analysis in a structured program editor. </title> <booktitle> In Proc. SIGPLAN '84 Symp. on Compiler Construction, </booktitle> <pages> pages 132-143, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1984. </year>
Reference-contexts: The operations in v serve to add and remove symbols from the live set. 3 This is an example of a cluster partitionable <ref> [9] </ref> or uniformly monotonic [10] problem.
Reference: [10] <author> Michael Wolfe, Michael P. Gerlek, and Eric Stoltz. </author> <title> Demand-driven data flow analysis. </title> <type> (unpublished), </type> <year> 1994. </year>
Reference-contexts: The operations in v serve to add and remove symbols from the live set. 3 This is an example of a cluster partitionable [9] or uniformly monotonic <ref> [10] </ref> problem.
Reference: [11] <author> Preston Briggs. </author> <title> Register allocation via graph coloring. </title> <type> PhD Dissertation COMP TR92-183, </type> <institution> Rice Univ., Dept. Computer Science, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: returning to block v, only those operations that affected the Live set are undone, so that at the bottom of v the Live set is precisely equal to what it started as. 4 Applications of Liveness 4.1 Interference Graph Construction Most modern compilers perform register assignment with graph coloring algorithms <ref> [1, 11] </ref>.
Reference: [12] <author> Jeanne C. Adams, Walter S. Brainerd, Jeanne T. Martin, Brian T. Smith, and Jerrold L. Wagener. </author> <title> Fortran 90 Handbook. </title> <publisher> McGraw-Hill Book Company, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: In certain cases the needed information may be determined trivially by the parser; in general, however, after any transformations have been applied by an optimizing compiler, full dataflow analysis is needed. 4 This type of information may be reflected in some languages, such as the INTENT attribute in Fortran 90 <ref> [12] </ref>. 15 5 Experimental Results Three areas are of interest: the effects of the traditional, bit-vector iterative approach to liveness, the effects of our -chain method, and a time/space comparison of the two. In this section, we present experimental data in these areas.
Reference: [13] <author> George Cybenko, Lyle Kipp, Lynn Pointer, and David Kuck. </author> <title> Supercomputer performance evaluation and the Perfect Benchmarks. </title> <booktitle> In International Conference on Supercomputing, </booktitle> <pages> pages 254 - 266, </pages> <month> March </month> <year> 1990. </year> <month> 22 </month>
Reference-contexts: The algorithms for constructing -chains, determining liveness, and constructing the interference graph have been implemented in Nascent, a prototype high-performance, restructuring Fortran 90/HPF compiler. The programs used to collect the data were taken from two well-known benchmark suites, the Perfect Club <ref> [13] </ref> and the Rice Compiler Evaluation Suite (RiCEPS). Each of these suites is made up of several Fortran 77 programs, representative of actual workloads found in high performance, scientific computation environments. Over 100,000 lines of source code are included. Table 2 characterizes these suites.
References-found: 13

