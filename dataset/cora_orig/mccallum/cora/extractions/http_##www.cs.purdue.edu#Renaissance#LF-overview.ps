URL: http://www.cs.purdue.edu/Renaissance/LF-overview.ps
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fmuckel|russog@cs.purdue.edu  
Title: Structural Subtyping in a Distributed Object System  
Author: Patrick A. Muckelbauer and Vincent F. Russo 
Address: West Lafayette, IN 47907  
Affiliation: Department of Computer Sciences Purdue University  
Abstract: Object-oriented techniques increase program modularity, decrease coupling, and improve data abstraction by supporting encapsulation through narrow, rigidly defined and strongly enforced interfaces to objects. Applying object-oriented techniques to address problems of building scalable and maintainable distributed systems seems an obvious approach since reducing coupling and increasing modularity are of obvious benefit. Unfortunately, object-oriented interfaces and mechanisms are usually only accessible and enforced through programming language mechanisms and support. This severely limits the degree to which disjoint, unrelated components can interact in a multilingual, loosely coupled distributed system. An accepted solution to the language dependence problem is the use of high-level interface description languages (IDLs) to provide a description mechanism for an object's interface that is independent of any programming language. Implementations of these interfaces can be provided by a number of object-oriented or non-object-oriented languages. In this paper we describe an interface description language and runtime support system for a distributed object system that uses structural subtyping rules rather than the traditional inheritance subtyping rules for conformance checking. We argue from both a theoretical and practical perspective that the choice of structural subtyping rather than inheri tance subtyping leads to less coupled and more extensible distributed systems.
Abstract-found: 1
Intro-found: 1
Reference: [AC93] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping Recursive Types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(4) </volume> <pages> 575-631, </pages> <year> 1993. </year>
Reference-contexts: A detailed discussion of a similar algorithm for structural subtyping can also found in <ref> [AC93] </ref>. Briefly, a type is represented at runtime as a node in a directed graph where the edges are pointers to other nodes (types) used in the source node's construction. The nodes contain all the necessary information to perform the structural conformance test.
Reference: [Ame90] <author> Pierre America. </author> <title> A Parallel Object-Oriented Language with Inheritance and Subtyping. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 161-168, </pages> <year> 1990. </year>
Reference-contexts: We address the problem in Lingua Franca by supporting the augmentation of objects with semantic attributes. Semantic attributes are treated as type predicates on the object (for example sorted or FIFO) and are similar in function to brands in Modula-3 [CDG + 89] or properties in POOL <ref> [Ame90] </ref>. In addition to supplying an interface when 24 narrowing an object reference, a client may supply a list of semantic attributes for checking semantic conformance. For example, a client's expected interface for a file object might contain read and write methods.
Reference: [Ben87] <author> John K. Bennett. </author> <title> The Design and Implementation of Distributed Smalltalk. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 318-330, </pages> <year> 1987. </year>
Reference-contexts: This form of type checking is refered to as dynamic type checking and systems that are dynamically type checked are termed dynamically typed systems. For example, in Distributed Smalltalk <ref> [Ben87] </ref>, an untyped distributed object system, a client can invoke the method m on a remote object and if the method is not in the remote object's interface the exception "method not understood " is raised.
Reference: [Ber93] <author> Edward V. Berard. </author> <booktitle> Essays on Object-Oriented Software Engineering, </booktitle> <volume> volume 1. </volume> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1993. </year>
Reference-contexts: For these reasons, we have restricted our work to typed distributed systems. By equating component specification and compatibility to type systems, it is possible to take techniques for reducing module coupling in programming languages and apply them to distributed systems. Object-oriented programming is one such technique <ref> [GJM91, Ber93] </ref>. Object-oriented programming increases program modularity and data abstraction by supporting encapsulation through narrow, rigidly defined and strongly enforced interfaces to objects [Ber93]. An object consists of an encapsulated state and a set of operations, or methods, that modify or access the state. <p> Object-oriented programming is one such technique [GJM91, Ber93]. Object-oriented programming increases program modularity and data abstraction by supporting encapsulation through narrow, rigidly defined and strongly enforced interfaces to objects <ref> [Ber93] </ref>. An object consists of an encapsulated state and a set of operations, or methods, that modify or access the state. The interface of an object is the collection of all its methods.
Reference: [BR94] <author> Gerald Baumgartner and Vincent F. Russo. </author> <title> "Implementing Signatures for C++". </title> <booktitle> In Proceedings of the USENIX C ++ Conference, </booktitle> <year> 1994. </year>
Reference-contexts: A C ++ translator for Lingua Franca has been built which maps Lingua Franca type descriptions into C ++ 26 types. C ++ was chosen due to its availability and our previous work on integrating the signature concept into the language <ref> [GR91, BR94] </ref>. The transport mechanisms used to perform cross-domain messaging are modular and based upon the domain of the client and server. Communication protocols have been designed and built to support machine independent, cross-domain method invocations using shared memory and UDP/IP packet transport.
Reference: [Car85] <author> Luca Cardelli. </author> <title> Amber, </title> <booktitle> Combintors and Functional Programming Languages. In Proceedings of the 13th Summer School of the LITP, </booktitle> <address> Le Val D'Ajol, Vosges (France), </address> <month> May </month> <year> 1985. </year> <booktitle> Lecture notes in computer science, </booktitle> <volume> vol. 242, </volume> <month> Spring-Verlag. </month>
Reference-contexts: The term structural subtyping is used to denote this form of subtyping. Structural subtyping has been used in several distributed and non-distributed programming languages such as Amber <ref> [Car85] </ref>, Emerald [JLHB87] and Obliq [Car94]. These systems, however, restrict the programmer to a single implementation language for building modules. The key contributing feature of our work is the extension of structural subtyping to multilingual, heterogeneous distributed systems.
Reference: [Car94] <author> Luca Cardelli. Obliq: </author> <title> A Lightweight Language for Network Objects. </title> <type> Technical report, </type> <note> DEC SRC, 1994. Available via anonymous ftp from gatekeeper.pa.dec.com as pub/DEC/Modula-3-contrib/Obliq.ps. </note>
Reference-contexts: The term structural subtyping is used to denote this form of subtyping. Structural subtyping has been used in several distributed and non-distributed programming languages such as Amber [Car85], Emerald [JLHB87] and Obliq <ref> [Car94] </ref>. These systems, however, restrict the programmer to a single implementation language for building modules. The key contributing feature of our work is the extension of structural subtyping to multilingual, heterogeneous distributed systems.
Reference: [CDG + 89] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <note> Modula-3 Report (revised). Technical Report 52, DEC SRC, </note> <month> November </month> <year> 1989. </year>
Reference-contexts: We address the problem in Lingua Franca by supporting the augmentation of objects with semantic attributes. Semantic attributes are treated as type predicates on the object (for example sorted or FIFO) and are similar in function to brands in Modula-3 <ref> [CDG + 89] </ref> or properties in POOL [Ame90]. In addition to supplying an interface when 24 narrowing an object reference, a client may supply a list of semantic attributes for checking semantic conformance. For example, a client's expected interface for a file object might contain read and write methods.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, </title> <journal> and poly-morphism. ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Typed distributed systems have several software engineering advantages: they catch errors earlier (during narrowing), they guarantee a sense of correctness to the system by not allowing clients and servers to interact in an inconsistent manner, and they allow better performance to be achieved for remote accesses <ref> [CW85] </ref>. For these reasons, we have restricted our work to typed distributed systems. By equating component specification and compatibility to type systems, it is possible to take techniques for reducing module coupling in programming languages and apply them to distributed systems. Object-oriented programming is one such technique [GJM91, Ber93].
Reference: [GJM91] <author> Carlo Ghezze, Mehdi Jazayeri, and Dino Mandrioli. </author> <title> Fundamentals of Software Engineering. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: Dynamically evolving systems should minimize coupling between interacting components in order to help maintain component compatibility during their evolution. Low coupling decreases interdependencies between components making them easier to separate and understand <ref> [GJM91] </ref>. <p> For these reasons, we have restricted our work to typed distributed systems. By equating component specification and compatibility to type systems, it is possible to take techniques for reducing module coupling in programming languages and apply them to distributed systems. Object-oriented programming is one such technique <ref> [GJM91, Ber93] </ref>. Object-oriented programming increases program modularity and data abstraction by supporting encapsulation through narrow, rigidly defined and strongly enforced interfaces to objects [Ber93]. An object consists of an encapsulated state and a set of operations, or methods, that modify or access the state.
Reference: [GM95] <author> James Gosling and Henry McGilton. </author> <title> The JAVA Language Environment: A White Paper. </title> <type> Technical report, </type> <institution> Sun Microsystems, </institution> <year> 1995. </year> <note> Available from http://www.javasoft.com/whitePaper. </note>
Reference-contexts: Currently there is only support to map Lingua Franca programs into C++[Str86]. However, additional translators to map Lingua Franca to other programming languages are being investigated along with the corresponding support libraries. In particular, a translator to JAVA <ref> [GM95] </ref> to support interpreted applications is actively being implemented. The system and tools provide support for inter-domain object method invocations (transparently) using Lingua Franca object interface descriptions.
Reference: [GR91] <author> Elana D. Granston and Vincent F. Russo. </author> <title> "Signature-Based Polymorphism for C++". </title> <booktitle> In Proceedings of the USENIX C ++ Conference, </booktitle> <year> 1991. </year>
Reference-contexts: A C ++ translator for Lingua Franca has been built which maps Lingua Franca type descriptions into C ++ 26 types. C ++ was chosen due to its availability and our previous work on integrating the signature concept into the language <ref> [GR91, BR94] </ref>. The transport mechanisms used to perform cross-domain messaging are modular and based upon the domain of the client and server. Communication protocols have been designed and built to support machine independent, cross-domain method invocations using shared memory and UDP/IP packet transport.
Reference: [HPM93] <author> G. Hamilton, M. Powell, and J. Mitchell. Subcontract: </author> <title> A Flexible Base for Distributed Programming. </title> <booktitle> In Proceedings of the ACM Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: While our approach is obviously similar in philosophy to a number of other efforts including OMG's CORBA [OMG91], Microsoft's OLE-II [Mic94], IBM's SOM/DSOM [IBM93] and Sun's Spring <ref> [HPM93] </ref>, it differs in one substantial way: the structure of interfaces is used for conformance checking rather than interface names (or hierarchies of names). We argue that this choice is superior both theoretically and practically and leads to less coupled systems.
Reference: [HR94] <author> Graham Hamilton and Sanjay Radia. </author> <title> Using Interface Inheritance to Address Problems in System Software Evolution. </title> <booktitle> In Proceedings of the ACM Workshop on Interface Definition Languages, </booktitle> <month> January </month> <year> 1994. </year> <month> 31 </month>
Reference-contexts: The Spring System uses the names of types to help manage their versions <ref> [HR94] </ref>. Interface changes are categorized into two kinds: major revisions which break compatibility with clients (for instance removing a method) and minor revisions which do not break compatibility (for instance adding a method).
Reference: [IBM93] <institution> IBM. </institution> <note> SOMobjects Developer Toolkit Users Guide Version 2.0, </note> <year> 1993. </year>
Reference-contexts: We argue that this choice is superior to, and leads to less coupled systems than, systems that base compatibility on the names of specifications [Mic94] or hierarchies of names <ref> [OMG91, IBM93] </ref>. 1.1 Types and Conformance in Distributed Systems The roles specification and compatibility play in a distributed system are analogous to the roles types and conformance play in a programming language's type system. <p> While our approach is obviously similar in philosophy to a number of other efforts including OMG's CORBA [OMG91], Microsoft's OLE-II [Mic94], IBM's SOM/DSOM <ref> [IBM93] </ref> and Sun's Spring [HPM93], it differs in one substantial way: the structure of interfaces is used for conformance checking rather than interface names (or hierarchies of names). We argue that this choice is superior both theoretically and practically and leads to less coupled systems.
Reference: [JLHB87] <author> Eric Jul, Henry Levy, Norman Hutchinson, and Andrew Black. </author> <title> Fine-Grained Mobility in the Emerald System. </title> <booktitle> In Proceedings of the ACM Symposium on Operating System Principles, </booktitle> <pages> pages 62-74, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Our work focuses on developing a flexible set of rules for specifying and testing component compatibility in a heterogeneous distributed system. The approach we take is to use object-oriented techniques to separate interface from implementation and to use structural based compatability rules <ref> [JLHB87] </ref> to allow the specification of a client's requirements to be reduced as close as possible to its actual requirements while still maintaining compatibility with its servers. I.e., a client and server are compatible if the server provides at least the operations and data the client needs. <p> The term structural subtyping is used to denote this form of subtyping. Structural subtyping has been used in several distributed and non-distributed programming languages such as Amber [Car85], Emerald <ref> [JLHB87] </ref> and Obliq [Car94]. These systems, however, restrict the programmer to a single implementation language for building modules. The key contributing feature of our work is the extension of structural subtyping to multilingual, heterogeneous distributed systems.
Reference: [JR86] <author> Michael B. Jones and Richard F. Rashid. </author> <title> Mach and Matchmaker: Kernel and Language Support for Object-Oriented Distributed Systems. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 67-86, </pages> <year> 1986. </year>
Reference-contexts: Relying on programming language support would severely limit the degree to which disjoint, unrelated components can interact in a multilingual, loosely coupled distributed system. Instead, we adopt the solution of using high-level interface description languages (IDLs) <ref> [JR86] </ref> to address the language dependency problem. IDLs provide a mechanism for specifying an object's interface independently of any programming language. Translators map these specifications into a target language's notion of objects and interfaces.
Reference: [MGH + 94] <author> James Mitchell, Jonathan Gibbons, Graham Hamilton, Peter Kessler, Yousef Khalidi, Panos Kougiouris, Peter Madany, Michael Nelson, Michael Powell, and Sanjay Radia. </author> <title> An Overview of the Spring System. </title> <booktitle> In Proceedings of Compcon Spring 1994, </booktitle> <month> February </month> <year> 1994. </year>
Reference-contexts: Consider the Spring Distributed Object System <ref> [MGH + 94] </ref> which uses inheritance subtyping based on the CORBA system [OMG91]. CORBA rules for conformance do not support subtyping of non-interface types or re-defining of methods. The following example, taken from the Spring System and rewritten in Lingua Franca and simplified for illustrative purposes, illustrates the problem.
Reference: [Mic94] <author> Microsoft Corporation. </author> <title> OLE2 Programmer's Reference, volume 2. </title> <publisher> Microsoft Press, </publisher> <year> 1994. </year>
Reference-contexts: The compatability between a client's requirements and a server's specification is determined by structurally comparing them when the client is bound to a particular server. We argue that this choice is superior to, and leads to less coupled systems than, systems that base compatibility on the names of specifications <ref> [Mic94] </ref> or hierarchies of names [OMG91, IBM93]. 1.1 Types and Conformance in Distributed Systems The roles specification and compatibility play in a distributed system are analogous to the roles types and conformance play in a programming language's type system. <p> While our approach is obviously similar in philosophy to a number of other efforts including OMG's CORBA [OMG91], Microsoft's OLE-II <ref> [Mic94] </ref>, IBM's SOM/DSOM [IBM93] and Sun's Spring [HPM93], it differs in one substantial way: the structure of interfaces is used for conformance checking rather than interface names (or hierarchies of names). We argue that this choice is superior both theoretically and practically and leads to less coupled systems.
Reference: [MR95] <author> Patrick A. Muckelbauer and Vincent F. Russo. </author> <title> Efficient Remote Method Invocation in a System Utilizing Structural Subtyping. </title> <type> Technical report, </type> <institution> Department of Computer Sciences, Purdue University, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: All operating system's services (kernel, file system, network, devices, etc.) are implemented as separate Renaissance domains. The transport mechanisms used to perform cross-domain messaging are implemented as part of the support libraries and are modular and based upon the domains of the client and server <ref> [MR95] </ref>. Communication protocols have been designed and built to support machine independent, cross-domain method invocations using shared memory and UDP/IP packet transport.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Pointers are built using the pointer to type constructor. Records are built using the record of type constructor. Discriminated unions are built using the case of type constructor and are similar in form to datatypes in ML <ref> [MTH90] </ref>. A tag or discriminate field for a case type is not necessary as it is implicit in the declaration. Field names within the case of and record of type constructors must be unique. An object interface is described using the interface of type constructor.
Reference: [Muc96] <author> Patrick A. Muckelbauer. </author> <title> Structural Subtyping in a Distributed Object System. </title> <type> PhD thesis, </type> <institution> Department of Computer Sciences, Purdue University, </institution> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: ff conforms to the result of fi 9. fi is type Anything (i.e., 8ff; ff : Anything) 9 2.1.4 Implementation and Performance of Structural Subtyping For a complete discussion of the conformance algorithm used in Lingua Franca including its implementation, a worst case cost analysis, and actual measured performance, see <ref> [Muc96] </ref>. A detailed discussion of a similar algorithm for structural subtyping can also found in [AC93]. Briefly, a type is represented at runtime as a node in a directed graph where the edges are pointers to other nodes (types) used in the source node's construction. <p> It can be shown, however, that there are types in Lingua Franca with an infinite number of distinct structural supertypes <ref> [Muc96] </ref>. Furthermore, such types are not confined to a small set of types but rather constitute a broad class of types. Given such types, it is impossible to construct a finite type hierarchy to model their structural subtyping relationships. In [Muc96], a base set of types with an infinite number of <p> Lingua Franca with an infinite number of distinct structural supertypes <ref> [Muc96] </ref>. Furthermore, such types are not confined to a small set of types but rather constitute a broad class of types. Given such types, it is impossible to construct a finite type hierarchy to model their structural subtyping relationships. In [Muc96], a base set of types with an infinite number of distinct structural supertypes is identified. All other types with an infinite number of distinct structural supertypes are constructed from types in this set. <p> Finally, consider recursive types in Lingua Franca. A complete proof that all recursive types have an infinite number of structural supertypes is beyond the scope of this paper and is discussed 14 in detail in <ref> [Muc96] </ref>. Intuitively, however, a recursive type represents an infinitely expanding tree. It can be shown that there exist nodes in this tree than can be replaced by the node for type Anything and the resulting type is a structural supertype of the original type.
Reference: [OMG91] <author> OMG. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <year> 1991. </year>
Reference-contexts: We argue that this choice is superior to, and leads to less coupled systems than, systems that base compatibility on the names of specifications [Mic94] or hierarchies of names <ref> [OMG91, IBM93] </ref>. 1.1 Types and Conformance in Distributed Systems The roles specification and compatibility play in a distributed system are analogous to the roles types and conformance play in a programming language's type system. <p> While our approach is obviously similar in philosophy to a number of other efforts including OMG's CORBA <ref> [OMG91] </ref>, Microsoft's OLE-II [Mic94], IBM's SOM/DSOM [IBM93] and Sun's Spring [HPM93], it differs in one substantial way: the structure of interfaces is used for conformance checking rather than interface names (or hierarchies of names). <p> This assumes inheritance can be used to create subtype relationships for types other than interface types, that multiple inheritance is supported, and that a method can be re-defined with contravariance of arguments and covariance of results. Interestingly, these requirements turn out not to be met in CORBA <ref> [OMG91] </ref> and other similar systems. However, for the sake of argument, these assumptions are made and modeling the structural subtyping relationships for a type t is equivalent to enumerating the distinct structural supertypes of t. <p> Consider the Spring Distributed Object System [MGH + 94] which uses inheritance subtyping based on the CORBA system <ref> [OMG91] </ref>. CORBA rules for conformance do not support subtyping of non-interface types or re-defining of methods. The following example, taken from the Spring System and rewritten in Lingua Franca and simplified for illustrative purposes, illustrates the problem. The original interface for file objects in the system was file 1 0.
Reference: [Sha86] <author> Marc Shapiro. </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <booktitle> In Proceedings of the 6th. International Conference on Distributed Computer Systems, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: Translators map these specifications into a target language's notion of objects and interfaces. The generated language specific modules are used by programmers to implement server objects (usually by inheriting from automatically generated parent classes) and/or to generate typed references to remote objects via proxy objects <ref> [Sha86] </ref>. <p> The implementation assigns all objects a globally unique identifier. These identifiers can be thought of as handles to the objects. Passing an object between domains amounts to passing the object's 10 handle. Transparent use of these handles is achieved through the use of proxy objects <ref> [Sha86] </ref>. As shown in Figure 2, a proxy is a local representation of a remote object and maps the language's notion of procedure call or method invocation transparently into a remote method invocation.
Reference: [Str86] <author> Bjarne Stroustrup. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference: [Sun85] <author> Sun Microsystems. </author> <title> Networking on the SUN Workstation, </title> <booktitle> 1985. </booktitle> <pages> 32 </pages>
Reference-contexts: For example, in many simple remote procedure call (RPC) systems, types are numbers where each number represents a well defined and agreed upon set of procedures <ref> [Sun85] </ref>. Conformance checking is simply a matter of testing whether a server's exported number equals the number expected by a client. In untyped systems clients access server values through untyped references.
References-found: 26

