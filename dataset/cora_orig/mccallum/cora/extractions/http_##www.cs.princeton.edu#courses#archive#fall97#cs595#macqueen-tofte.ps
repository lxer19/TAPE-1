URL: http://www.cs.princeton.edu/courses/archive/fall97/cs595/macqueen-tofte.ps
Refering-URL: http://www.cs.princeton.edu/courses/archive/fall97/cs595/reading.html
Root-URL: http://www.cs.princeton.edu
Phone: 2  
Title: A Semantics for Higher-order Functors  
Author: David B. MacQueen and Mads Tofte 
Note: Jersey and have proved useful in programming practice.  
Address: New Jersey, USA  Denmark  
Affiliation: 1 AT&T Bell Labs,  Dept. of Computer Science, Copenhagen University,  
Abstract: Standard ML has a module system that allows one to define parametric modules, called functors. Functors are "first-order," meaning that func-tors themselves cannot be passed as parameters or returned as results of functor applications. This paper presents a semantics for a higher-order module system which generalizes the module system of Standard ML. The higher-order functors described here are implemented in the current version of Standard ML of New 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Maria-Virginia Aponte. </author> <title> Extending record typing to type parametric modules with sharing. </title> <booktitle> In Twentieth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 465-478, </pages> <address> New York, Jan 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: We also do not deal with elaboration of signature expressions in this paper; this was studied in detail in [14]. In addition to the work on Extended ML and the work of Leroy and Harper and Lillibridge already cited, the work of Aponte <ref> [1] </ref> should also be noted. It provides another approach to semantic representations for ML modules, based on Remy's work on polymorphic records [12].
Reference: 2. <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In Martin Wirs-ing, editor, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, </booktitle> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. (in press). </note>
Reference-contexts: In particular, signature matching is straightforward to check, following the definitions of the semantics. As noted in the introduction, higher order functors behaving in accordance with this semantics have been implemented in the Standard ML of New Jersey compiler <ref> [2] </ref>. The implementation representations differ in detail from the semantic representations presented above, because of various techniques used to optimize space requirements. But taking an abstract view, there are close parallels between the semantics and the implementation.
Reference: 3. <author> Pierre Cregut. </author> <title> Extensions to the sml module system. </title> <institution> Rapport de Stage d'Ingenieur Eleve des Telecommunications, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: Doing so makes the language more symmetrical and supports useful new modes of parameterization. A practical implementation of higher-order functors has recently been provided in the Standard ML of New Jersey compiler <ref> [3] </ref>. The first step toward defining a semantics of higher-order functors was taken in [14], where a semantics for functor signatures is described and a principal signature theorem is proved.
Reference: 4. <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Twenty First Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Alternative module system designs that do not use transparent signature matching have been proposed. For instance, the Extended ML specification language [13], which is based on Standard ML, assumes that signature matching is opaque, and recently Leroy [6] and Harper and Lillibridge <ref> [4] </ref> have described module systems that use opaque signature 2 matching but allow one to override it in the case of types by using type definitions in signatures.
Reference: 5. <author> Robert Harper, John C. Mitchell, and Eugenio Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Seventeenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 341-354, </pages> <address> New York, Jan 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In the original Standard ML module system ([7, 10]), functors were first-order, because their parameters and results could only be structures, and functors could not be components of structures. But the type theoretic analysis of the module system carried out in <ref> [8, 11, 5] </ref> made it clear that it was natural to extend the notion of functors to higher orders by allowing functors as parameters and results (or, equivalently, allowing structures to contain functor components). Doing so makes the language more symmetrical and supports useful new modes of parameterization.
Reference: 6. <author> Xavier Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In Twenty First Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Alternative module system designs that do not use transparent signature matching have been proposed. For instance, the Extended ML specification language [13], which is based on Standard ML, assumes that signature matching is opaque, and recently Leroy <ref> [6] </ref> and Harper and Lillibridge [4] have described module systems that use opaque signature 2 matching but allow one to override it in the case of types by using type definitions in signatures.
Reference: 7. <author> David MacQueen. </author> <title> Modules for Standard ML. </title> <booktitle> In Proc. 1984 ACM Conf. on LISP and Functional Programming, </booktitle> <pages> pages 198-207, </pages> <address> New York, 1984. </address> <publisher> ACM Press. </publisher>
Reference: 8. <author> David MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In Thirteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 277-286, </pages> <address> New York, Jan 1986. </address> <publisher> ACM Press. </publisher> <pages> 15 </pages>
Reference-contexts: In the original Standard ML module system ([7, 10]), functors were first-order, because their parameters and results could only be structures, and functors could not be components of structures. But the type theoretic analysis of the module system carried out in <ref> [8, 11, 5] </ref> made it clear that it was natural to extend the notion of functors to higher orders by allowing functors as parameters and results (or, equivalently, allowing structures to contain functor components). Doing so makes the language more symmetrical and supports useful new modes of parameterization.
Reference: 9. <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference: 10. <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference: 11. <author> John C. Mitchell and Robert Harper. </author> <title> The essence of ML. </title> <booktitle> In Fifteenth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 28-46, </pages> <address> New York, 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In the original Standard ML module system ([7, 10]), functors were first-order, because their parameters and results could only be structures, and functors could not be components of structures. But the type theoretic analysis of the module system carried out in <ref> [8, 11, 5] </ref> made it clear that it was natural to extend the notion of functors to higher orders by allowing functors as parameters and results (or, equivalently, allowing structures to contain functor components). Doing so makes the language more symmetrical and supports useful new modes of parameterization.
Reference: 12. <author> Didier Remy. </author> <title> Typechecking records and variants in a natural extension of ml. </title> <booktitle> In Sixteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 77-88, </pages> <address> New York, Jan 1989. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In addition to the work on Extended ML and the work of Leroy and Harper and Lillibridge already cited, the work of Aponte [1] should also be noted. It provides another approach to semantic representations for ML modules, based on Remy's work on polymorphic records <ref> [12] </ref>. So far, this approach deals with first-order functors only. 2 Semantic objects Our semantic objects are defined informally using a mixture of simple mathematical constructions (e.g. sets of sequences of identifiers) and term structures (e.g. lambda abstractions) over these constructions.
Reference: 13. <author> Donald Sannella and Andrej Tarlecki. </author> <title> Extended ml: Past, present, and future. </title> <type> Technical Report ECS-LFCS-91-138, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <year> 1991. </year>
Reference-contexts: Alternative module system designs that do not use transparent signature matching have been proposed. For instance, the Extended ML specification language <ref> [13] </ref>, which is based on Standard ML, assumes that signature matching is opaque, and recently Leroy [6] and Harper and Lillibridge [4] have described module systems that use opaque signature 2 matching but allow one to override it in the case of types by using type definitions in signatures.
Reference: 14. <author> Mads Tofte. </author> <title> Principal signatures for higher-order program modules. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 189-199, </pages> <address> New York, </address> <month> Jan </month> <year> 1992. </year> <title> ACM Press. (Extended version to appear in Journal of Functional Programming) This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Doing so makes the language more symmetrical and supports useful new modes of parameterization. A practical implementation of higher-order functors has recently been provided in the Standard ML of New Jersey compiler [3]. The first step toward defining a semantics of higher-order functors was taken in <ref> [14] </ref>, where a semantics for functor signatures is described and a principal signature theorem is proved. Here we go most of the way toward completing the semantics of higher-order functors by defining how functors are represented, how higher-order signature matching is performed, and how functor application works. <p> We also do not deal with elaboration of signature expressions in this paper; this was studied in detail in <ref> [14] </ref>. In addition to the work on Extended ML and the work of Leroy and Harper and Lillibridge already cited, the work of Aponte [1] should also be noted. It provides another approach to semantic representations for ML modules, based on Remy's work on polymorphic records [12]. <p> In that sense, sharing specifications can constrain a functor. A more detailed study of sharing, including functor sharing, is given in <ref> [14] </ref>. Formally, we represent sharing specifications by relations on structure paths, as follows. Let s be a tree. A sharing relation (on s) is a relation R satisfying: 1. R is an equivalence relation on SP (s); 7 2. <p> The requirement that a ffi-bound only be "applied" to valid paths of the containing signature is significant for getting a well-defined notion of structure matching. Unfortunately, it also means that there is not a perfect correspondence between the present signatures and the so-called principal signatures inferred in <ref> [14] </ref>. <p> 3 A skeletal programming language In this section we present a grammar and a static semantics for the skeletal language. 3.1 Grammar for programs The grammar defining structure expressions (strexp) and structure-level declarations (strdec) is given below. (A grammar of signature expressions (sigexp) and specifications (spec) may be found in <ref> [14] </ref>). strexp ::= struct strdec end generative j strexp/strid structure selection j strid structure identifier j strexp:sigexp signature constraint j fp (strexp) functor application strdec ::= structure strid = strexp structure declaration j functor funid (strid:sigexp) = strexp functor declaration j empty j strdec; strdec sequential 3.2 Structures and environments An <p> One always has N 0 N . We omit the precise definition, for lack of space, but the process is fairly straightforward, and is justified by the Principal Signatures theorem <ref> [14] </ref>. Let = 1 : 0 1 ; ' 00 1 i be a functor and let ffi = 2 : 0 2 : 00 2 be a functor signature. Write 0 2 in the form hs 0 2 ; R 0 2 ; ffi 0 2 i.
References-found: 14

