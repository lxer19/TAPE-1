URL: http://www.cs.wustl.edu/cs/techreports/1997/wucs-97-10.ps.Z
Refering-URL: http://www.cs.wustl.edu/~gokhale/vita.html
Root-URL: 
Email: gokhale@cs.wustl.edu and schmidt@cs.wustl.edu  
Title: Optimizing the Performance of the CORBA Internet Inter-ORB Protocol Over ATM  
Author: Aniruddha Gokhale and Douglas C. Schmidt 
Keyword: Distributed object computing, CORBA, IIOP, communication middleware protocol optimizations, high-speed networks.  
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science, Washington University  
Abstract: This paper has been submitted for publication. It can be referenced as Washington University technical report #WUCS-97-10. Abstract The Internet Inter-ORB Protocol (IIOP) enables heterogeneous CORBA-compliant Object Request Brokers (ORBs) to interoperate over TCP/IP networks. The IIOP uses the Common Data Representation (CDR) transfer syntax to map CORBA Interface Definition Language (IDL) data types into a bi-canonical wire format. Due to the excessive marshaling/demarshaling overhead, data copying, and high-levels of function call overhead, conventional implementations of IIOP protocols yield poor performance over high-speed networks. To meet the demands of emerging distributed multimedia applications, CORBA-compliant ORBs must support both interoperable and highly efficient IIOP implementations. This paper provides two contributions to the study and design of high performance CORBA IIOP implementations. First, we precisely pinpoint the key sources of overhead in the SunSoft IIOP implementation (which is the standard reference implementation of IIOP written in C++) by measuring its performance for transferring richly-typed data over a high speed ATM network. Second, we empirically demonstrate the benefits that stem from systematically applying protocol optimizations to SunSoft IIOP. These optimizations include: optimizing for the expected case; eliminating obvious waste; replacing general purpose methods with specialized, efficient ones; precomputing values, if possible; storing redundant state to speed up expensive operations; and passing information between layers. The results of applying these optimization principles to SunSoft IIOP improved its performance 1.8 times for doubles, 3.3 times for longs, 3.75 times for shorts, 5 times for chars/octets, and 4.2 times for richly-typed structs over ATM networks. Our optimized implementation is now competitive with existing commercial ORBS using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). Moreover, our optimizations are fully CORBA compliant and we maintain strict interoperability with other IIOP implementations such as Visigenic's VisiBroker and IONA's Orbix.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abbott and L. Peterson. </author> <title> Increasing Network Throughput by Integrating Protocol Layers. </title> <journal> ACM Transactions on Networking, </journal> <volume> 1(5), </volume> <month> October </month> <year> 1993. </year>
Reference-contexts: The optimizations reported in [4] are based on Principle 1, which optimizes for the expected case and Principle 3, which is precompute, if possible. We present 15 the results of applying these principles to optimize IIOP in Sections 3.2.3, 3.2.4, and 3.2.5. <ref> [5, 1, 3] </ref> describe the application of an optimization mechanism called Integrated Layer Processing (ILP). ILP is based on the observation that data manipulation loops that operate on the same protocol data are wasteful and expensive.
Reference: [2] <author> Mary L. Bailey, Burra Gopal, Prasenjit Sarkar, Michael A. Pagels, and Larry L. Peterson. Pathfinder: </author> <title> A pattern-based packet classifier. </title> <booktitle> In Proceedings of the 1 st Symposium on Operating System Design and Implementation. USENIX Association, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: We demonstrate the application of this principle to IIOP in Section 3.2.6 where we eliminated unnecessary calls to the deep free method, which frees primitive data types. [3] cautions against improper use of ILP since this may increase cache misses. Packet filters <ref> [13, 2, 7] </ref> are a classic example of Principle 6, which recommends passing information between layers. A packet filter demultiplexes incoming packets to the appropriate target application (s).
Reference: [3] <author> Torsten Braun and Christophe Diot. </author> <title> Protocol Implementation Using Integrated Layer Processnig. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM). ACM, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: The optimizations reported in [4] are based on Principle 1, which optimizes for the expected case and Principle 3, which is precompute, if possible. We present 15 the results of applying these principles to optimize IIOP in Sections 3.2.3, 3.2.4, and 3.2.5. <ref> [5, 1, 3] </ref> describe the application of an optimization mechanism called Integrated Layer Processing (ILP). ILP is based on the observation that data manipulation loops that operate on the same protocol data are wasteful and expensive. <p> The ILP optimization scheme is based on Principle 2, which gets rid of obvious waste. We demonstrate the application of this principle to IIOP in Section 3.2.6 where we eliminated unnecessary calls to the deep free method, which frees primitive data types. <ref> [3] </ref> cautions against improper use of ILP since this may increase cache misses. Packet filters [13, 2, 7] are a classic example of Principle 6, which recommends passing information between layers. A packet filter demultiplexes incoming packets to the appropriate target application (s).
Reference: [4] <author> David D. Clark, Van Jacobson, John Romkey, and Howard Salwen. </author> <title> An Analysis of TCP Processing Overhead. </title> <journal> IEEE Communications Magazine, </journal> <volume> 27(6) </volume> <pages> 23-29, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: In addition, we discuss related work on CORBA performance measurements and presentation layer marshaling. 4.1 Related Work Based on Optimization Principles <ref> [4] </ref> describes a technique called header prediction that predicts the message header of incoming TCP packets. This technique is based on the observation that many members in the header remaining constant between consecutive packets. This observation led to the creation of a template for the expected packet header. <p> This technique is based on the observation that many members in the header remaining constant between consecutive packets. This observation led to the creation of a template for the expected packet header. The optimizations reported in <ref> [4] </ref> are based on Principle 1, which optimizes for the expected case and Principle 3, which is precompute, if possible.
Reference: [5] <author> David D. Clark and David L. Tennenhouse. </author> <title> Architectural Considerations for a New Generation of Protocols. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), </booktitle> <pages> pages 200-208, </pages> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: The optimizations reported in [4] are based on Principle 1, which optimizes for the expected case and Principle 3, which is precompute, if possible. We present 15 the results of applying these principles to optimize IIOP in Sections 3.2.3, 3.2.4, and 3.2.5. <ref> [5, 1, 3] </ref> describe the application of an optimization mechanism called Integrated Layer Processing (ILP). ILP is based on the observation that data manipulation loops that operate on the same protocol data are wasteful and expensive.
Reference: [6] <author> Peter Druschel and Larry L. Peterson. Fbufs: </author> <title> A High-Bandwidth Cross-Domain Transfer Facility. </title> <booktitle> In Proceedingsof the 14 th Symposium on Operating System Principles (SOSP), </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: We applied Principle 6 for IIOP in Section 3.2.5 where we passed the TypeCode information and size of the element type of a sequence to the TypeCode interpreter. Therefore, the interpreter need not calculate the same quantities repeatedly. <ref> [6] </ref> describes a facility called fast buffers (FBUFS). FBUFS combines virtual page remapping with shared virtual memory to reduce unnecessary data copying and achieve high throughput.
Reference: [7] <author> Dawson R. Engler and M. Frans Kaashoek. DPF: </author> <title> Fast, Flexible Message Demultiplexing using Dynamic Code Generation. </title> <booktitle> In Proceedings of ACM SIGCOMM '96 Conference in Computer Communication Review, </booktitle> <pages> pages 53-59, </pages> <institution> Stanford University, California, USA, </institution> <month> August </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: We demonstrate the application of this principle to IIOP in Section 3.2.6 where we eliminated unnecessary calls to the deep free method, which frees primitive data types. [3] cautions against improper use of ILP since this may increase cache misses. Packet filters <ref> [13, 2, 7] </ref> are a classic example of Principle 6, which recommends passing information between layers. A packet filter demultiplexes incoming packets to the appropriate target application (s).
Reference: [8] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks. </title> <booktitle> In Proceedings of SIGCOMM '96, </booktitle> <pages> pages 306-317, </pages> <address> Stanford, CA, </address> <month> August </month> <year> 1996. </year> <note> ACM. </note>
Reference-contexts: One such mapping is called the Internet Inter-ORB Protocol (IIOP), which is the emerging standard GIOP mapping for distributed object computing over TCP/IP. The latest release of Netscape integrates IIOP into its Web browser, making IIOP the most widely available protocol for interoperability between heterogeneous ORBs. <ref> [8, 9, 10] </ref> show that the performance of CORBA implementations is poor compared to that of the low level implementations using C/C++ since the ORBs incur a significant amount of data copying, marshaling, demarshaling, and demultiplex-ing overhead. <p> In addition, earlier work on measuring CORBA performance does not pro 1 vide solutions for reducing key sources of ORB overhead. In this paper, we measure the performance of the standard reference implementation of IIOP, written by SunSoft, using a CORBA/ATM testbed environment similar to <ref> [8, 9, 10] </ref>. We measure the performance of SunSoft IIOP and precisely pinpoint the performance overhead. In addition, we describe how we applied six principle-driven optimizations [21] to substantially improve the performance of SunSoft IIOP. <p> The results of applying these optimization principles to SunSoft IIOP improved its performance 1.8 times for doubles, 3.3 times for longs, 3.75 times for shorts, 5 times for chars/octets, and 4.2 times for richly-typed structs over ATM networks. Our optimized IIOP implementation is now comparable to existing commercial ORBS <ref> [8, 9, 10] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). <p> We applied these principles for IIOP in Sections 3.2.5 and 3.2.6 where we incorporated the struct traverse logic and some of the decoder logic into the TypeCode interpreter. 4.2 Related Work Based on CORBA Perfor mance Measurements <ref> [8, 9, 10] </ref> show that the performance of CORBA implementations is relatively poor, compared to that of the low level implementations using C/C++. <p> The primary source of ORB-level overhead stems from marshaling and demarshaling. <ref> [8] </ref> measures the performance of the static invocation interface. [9] measures the performance of the dynamic invocation interface and the dynamic skeleton interface. [10] measures performance of CORBA implementations in terms of latency and support for very large number of objects. <p> The results of applying these optimization principles to SunSoft IIOP improved its performance 1.8 times for doubles, 3.3 times for longs, 3.75 times for shorts, 5 times for chars/octets, and 4.2 times for richly-typed 16 structs over ATM networks. Our optimized implemen-tation is now competitive with existing commercial ORBS <ref> [8, 10] </ref> using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) [9].
Reference: [9] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> The Performance of the CORBA Dynamic Invocation Interface and Dynamic Skeleton Interface over High-Speed ATM Networks. </title> <booktitle> In Proceedings of GLOBECOM '96, </booktitle> <pages> pages 50-56, </pages> <address> London, England, </address> <month> November </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: One such mapping is called the Internet Inter-ORB Protocol (IIOP), which is the emerging standard GIOP mapping for distributed object computing over TCP/IP. The latest release of Netscape integrates IIOP into its Web browser, making IIOP the most widely available protocol for interoperability between heterogeneous ORBs. <ref> [8, 9, 10] </ref> show that the performance of CORBA implementations is poor compared to that of the low level implementations using C/C++ since the ORBs incur a significant amount of data copying, marshaling, demarshaling, and demultiplex-ing overhead. <p> In addition, earlier work on measuring CORBA performance does not pro 1 vide solutions for reducing key sources of ORB overhead. In this paper, we measure the performance of the standard reference implementation of IIOP, written by SunSoft, using a CORBA/ATM testbed environment similar to <ref> [8, 9, 10] </ref>. We measure the performance of SunSoft IIOP and precisely pinpoint the performance overhead. In addition, we describe how we applied six principle-driven optimizations [21] to substantially improve the performance of SunSoft IIOP. <p> The results of applying these optimization principles to SunSoft IIOP improved its performance 1.8 times for doubles, 3.3 times for longs, 3.75 times for shorts, 5 times for chars/octets, and 4.2 times for richly-typed structs over ATM networks. Our optimized IIOP implementation is now comparable to existing commercial ORBS <ref> [8, 9, 10] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). <p> We applied these principles for IIOP in Sections 3.2.5 and 3.2.6 where we incorporated the struct traverse logic and some of the decoder logic into the TypeCode interpreter. 4.2 Related Work Based on CORBA Perfor mance Measurements <ref> [8, 9, 10] </ref> show that the performance of CORBA implementations is relatively poor, compared to that of the low level implementations using C/C++. <p> The primary source of ORB-level overhead stems from marshaling and demarshaling. [8] measures the performance of the static invocation interface. <ref> [9] </ref> measures the performance of the dynamic invocation interface and the dynamic skeleton interface. [10] measures performance of CORBA implementations in terms of latency and support for very large number of objects. However, these results were restricted to measuring the performance of communication between homogeneous ORBs. <p> Our optimized implemen-tation is now competitive with existing commercial ORBS [8, 10] using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) <ref> [9] </ref>. In addition, we show that our optimized implementation of IIOP interoperates seamlessly with Visigenic's VisiBroker for C++ ORB which is a commercially available ORB. In addition to our optimizations, we are currently enhancing the SunSoft IIOP implementation to form a complete high-performance ORB [18].
Reference: [10] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Evaluating Latency and Scalability of CORBA Over High-Speed ATM Networks. </title> <booktitle> In Proceedings of the International Conference on Distributed Computing Systems, </booktitle> <address> Baltimore, Maryland, </address> <month> May </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: One such mapping is called the Internet Inter-ORB Protocol (IIOP), which is the emerging standard GIOP mapping for distributed object computing over TCP/IP. The latest release of Netscape integrates IIOP into its Web browser, making IIOP the most widely available protocol for interoperability between heterogeneous ORBs. <ref> [8, 9, 10] </ref> show that the performance of CORBA implementations is poor compared to that of the low level implementations using C/C++ since the ORBs incur a significant amount of data copying, marshaling, demarshaling, and demultiplex-ing overhead. <p> In addition, earlier work on measuring CORBA performance does not pro 1 vide solutions for reducing key sources of ORB overhead. In this paper, we measure the performance of the standard reference implementation of IIOP, written by SunSoft, using a CORBA/ATM testbed environment similar to <ref> [8, 9, 10] </ref>. We measure the performance of SunSoft IIOP and precisely pinpoint the performance overhead. In addition, we describe how we applied six principle-driven optimizations [21] to substantially improve the performance of SunSoft IIOP. <p> The results of applying these optimization principles to SunSoft IIOP improved its performance 1.8 times for doubles, 3.3 times for longs, 3.75 times for shorts, 5 times for chars/octets, and 4.2 times for richly-typed structs over ATM networks. Our optimized IIOP implementation is now comparable to existing commercial ORBS <ref> [8, 9, 10] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). <p> We applied these principles for IIOP in Sections 3.2.5 and 3.2.6 where we incorporated the struct traverse logic and some of the decoder logic into the TypeCode interpreter. 4.2 Related Work Based on CORBA Perfor mance Measurements <ref> [8, 9, 10] </ref> show that the performance of CORBA implementations is relatively poor, compared to that of the low level implementations using C/C++. <p> The primary source of ORB-level overhead stems from marshaling and demarshaling. [8] measures the performance of the static invocation interface. [9] measures the performance of the dynamic invocation interface and the dynamic skeleton interface. <ref> [10] </ref> measures performance of CORBA implementations in terms of latency and support for very large number of objects. However, these results were restricted to measuring the performance of communication between homogeneous ORBs. These tests do not measure the run-time costs of interoperability between ORBs from different vendors. <p> The results of applying these optimization principles to SunSoft IIOP improved its performance 1.8 times for doubles, 3.3 times for longs, 3.75 times for shorts, 5 times for chars/octets, and 4.2 times for richly-typed 16 structs over ATM networks. Our optimized implemen-tation is now competitive with existing commercial ORBS <ref> [8, 10] </ref> using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) [9].
Reference: [11] <author> Phillip Hoschka and Christian Huitema. </author> <title> Automatic Generation of Optimized Code for Marshalling Routines. </title> <booktitle> In IFIP Conference of Upper Layer Protocols, Architectures and Applications ULPAA'94, </booktitle> <address> Barcelona, Spain, 1994. </address> <publisher> IFIP. </publisher>
Reference-contexts: The motivation for using an interpretive design is to reduce the size of the marshaling/demarshaling engine so that it resides within a processor cache. An alternative approach is to use a compiled marshaling/demarshaling engine <ref> [11] </ref>. A compiled approach is possible when the marshaling/demarshaling engine has compile-time knowledge of the structural layout of IDL interfaces and operation parameters. <p> In addition, these papers do not provide solutions to reduce these overheads. In contrast, we have provided solutions that significantly improve performance by reducing marshaling/demarshaling overhead. 4.3 Related Work Based on Interpretive and Compiled Forms of Marshaling <ref> [11] </ref> describes the tradeoffs of using compiled and interpreted marshaling schemes. Although compiled stubs are faster, they are also larger. In contrast, interpretive marshaling is slower, but smaller in size. [11] describes a hybrid scheme that combines compiled and interpretive marshaling to achieve better performance. <p> solutions that significantly improve performance by reducing marshaling/demarshaling overhead. 4.3 Related Work Based on Interpretive and Compiled Forms of Marshaling <ref> [11] </ref> describes the tradeoffs of using compiled and interpreted marshaling schemes. Although compiled stubs are faster, they are also larger. In contrast, interpretive marshaling is slower, but smaller in size. [11] describes a hybrid scheme that combines compiled and interpretive marshaling to achieve better performance. This work was done in the context of the ASN.1/BER encoding [12]. <p> This ORB will be used to compare the impact of using compiled marshaling stubs and skeletons vs. the interpretive scheme currently implemented in SunSoft IIOP. We plan to measure the tradeoffs of using the two marshaling schemes to achieve an optimal hybrid solution <ref> [11] </ref>.
Reference: [12] <author> International Organization for Standardization. </author> <title> Information processing systems Open Systems Interconnection Specification of Basic Encoding Rules for Abstract Syntax No tation One (ASN.1), </title> <month> May </month> <year> 1987. </year>
Reference-contexts: Although compiled stubs are faster, they are also larger. In contrast, interpretive marshaling is slower, but smaller in size. [11] describes a hybrid scheme that combines compiled and interpretive marshaling to achieve better performance. This work was done in the context of the ASN.1/BER encoding <ref> [12] </ref>. According to the SunSoft IIOP implementors, interpretive marshaling is preferable since it decreases code size and increases the likelihood of remaining in the processor cache. Our measurements do not compare the SunSoft IIOP interpretive marshaling scheme with a compiled marshaling scheme.
Reference: [13] <author> Steven McCanne and Van Jacobson. </author> <title> The BSD Packet Filter: </title>
Reference-contexts: We demonstrate the application of this principle to IIOP in Section 3.2.6 where we eliminated unnecessary calls to the deep free method, which frees primitive data types. [3] cautions against improper use of ILP since this may increase cache misses. Packet filters <ref> [13, 2, 7] </ref> are a classic example of Principle 6, which recommends passing information between layers. A packet filter demultiplexes incoming packets to the appropriate target application (s).
References-found: 13

