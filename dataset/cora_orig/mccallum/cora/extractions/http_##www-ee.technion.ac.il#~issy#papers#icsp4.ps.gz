URL: http://www-ee.technion.ac.il/~issy/papers/icsp4.ps.gz
Refering-URL: http://www-ee.technion.ac.il/~issy/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: kaiser@cs.columbia.edu  
Title: A Metalinguistic Approach to Process Enactment Extensibility  
Author: Gail E. Kaiser Israel Z. Ben-Shaul Steven S. Popovich Stephen E. Dossick 
Address: New York, NY 10027, UNITED STATES  
Affiliation: Columbia University Department of Computer Science, MC 0401  
Abstract: We present a model for developing rule-based process servers with extensible syntax and semantics. New process enactment directives can be added to the syntax of the process modeling language, in which the process designer may specify specialized behavior for particular tasks or task segments. The process engine is peppered with callbacks to instance-specific code in order to implement any new directives and to modify the default enactment behavior and the kind of assistance that the process-centered environment provides to process participants. We realized our model in the Amber process server, and describe how we exploited Amber's extensibility to replace Oz's native process engine with Amber and to integrate the result with a mockup of TeamWare. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Balzer and K. Narayanaswamy. </author> <title> Mechanisms for generic process support. </title> <editor> In D. Notkin, editor, </editor> <booktitle> 1st ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 21-32, </pages> <address> Los Angeles CA, </address> <month> December </month> <year> 1993. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 18(5), </volume> <month> December </month> <year> 1993. </year>
Reference-contexts: It is important to note that here we generically extend the process system itself (i.e., the PCE), as opposed to refining, or evolving, a specific process definition (e.g., as in <ref> [1] </ref>). Metalinguistic extensibility introduces difficult technical problems. In particular, the process interpreter must be designed to allow deep insertion of, and a structure for invoking, independently-written code that changes its internal behavior without affecting or conflicting with built-in capabilities or other external extensions.
Reference: [2] <author> S. Bandinelli and A. Fuggetta. </author> <title> Computational reflection in software process modeling: the SLANG approach. </title> <booktitle> In 15th International Conference on Software Engineering, </booktitle> <pages> pages 144-154, </pages> <address> Baltimore MD, May 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Termed process evolution, this concept has also been investigated in recent years in the software process community [22]. Reflection has been one influential language-based approach to evolution <ref> [2] </ref>. Such first- and second-order, fixed-language and fixed-interpreter, extensibility is inherently limited, however, in two major respects: * Language The expressive power of the particular process modeling language and its computation model determines the scope of extensibility, even when in vivo evolution is supported.
Reference: [3] <author> N. S. Barghouti. </author> <title> Concurrency Control in Rule-Based Software Development Environments. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <month> February </month> <year> 1992. </year> <month> CUCS-001-92. </month>
Reference-contexts: Language Overview Amber's PML is based in part on the Marvle Strategy Language (MSL) first developed for the Marvel process-centered environment [18] and later extended in Oz (with mostly semantic changes); most of the syntax, except for the extensible annotations, was previously elaborated in <ref> [3] </ref>. The PML incorporates an object-oriented data definition sublanguage for defining classes whose members represent process state and product artifacts (design documents, source code, test cases, etc.), and a rule sublanguage that specifies the actions that can be taken by a user or by the environment.
Reference: [4] <author> N. S. Barghouti. </author> <title> Supporting cooperation in the MARVEL process-centered SDE. </title> <editor> In H. Weber, editor, </editor> <booktitle> 5th ACM SIG-SOFT Symposium on Software Development Environments, </booktitle> <pages> pages 21-31, </pages> <address> Tyson's Corner VA, </address> <month> December </month> <year> 1992. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 17(5), </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: While some extensions to the basic language paradigm may be done at the time the language is designed (such as extending Marvel rules with control annotations that indicate partial rule chains should be enacted as all-or-nothing transactions <ref> [4] </ref>), clearly not all desirable functionality may be envisioned a priori, when the language and its engine are designed and implemented.
Reference: [5] <author> I. Ben-Shaul and G. E. Kaiser. </author> <title> A Paradigm for Decentralized Process Modeling. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1995. </year>
Reference-contexts: Section 4 illustrates Amber's extensibility with respect to two different kinds of process enactment functionality: one that added multi-server connectivity and process interoperability in the style of Oz <ref> [6, 5] </ref>, and another that added more intuitive process modeling (than plausible with rules) as well as online process visualization by integrating Amber/Oz with a mockup of the TeamWare research prototype from the University of California at Irvine [9]. Section 5 summarizes the contributions of this research. 2.
Reference: [6] <author> I. Z. Ben-Shaul and G. E. Kaiser. </author> <title> A paradigm for decentralized process modeling and its realization in the Oz environment. </title> <booktitle> In 16th International Conference on Software Engineering, </booktitle> <pages> pages 179-188, </pages> <address> Sorrento, Italy, May 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Section 4 illustrates Amber's extensibility with respect to two different kinds of process enactment functionality: one that added multi-server connectivity and process interoperability in the style of Oz <ref> [6, 5] </ref>, and another that added more intuitive process modeling (than plausible with rules) as well as online process visualization by integrating Amber/Oz with a mockup of the TeamWare research prototype from the University of California at Irvine [9]. Section 5 summarizes the contributions of this research. 2.
Reference: [7] <author> I. Z. Ben-Shaul and G. E. Kaiser. </author> <title> An architecture for federation of process-centered environments. </title> <type> Technical Report CUCS-015-96, </type> <institution> Columbia University Department of Computer Science, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: The second approach is based on layers, with translators from higher to lower levels and a process assembly language at the bottom. We have begun investigation of the former approach, see <ref> [7] </ref>, and studied the latter extensively as described in [26, 14, 19].
Reference: [8] <author> I. Z. Ben-Shaul and G. E. Kaiser. </author> <title> Integrating groupware activities into workflow management systems. </title> <booktitle> In 7th Israeli Conference on Computer Systems and Software Engineering, </booktitle> <pages> pages 140-149, </pages> <address> Herzliya, Israel, June 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: there is no roadmap, the user has to know what to do next. (Only simple single-user processes can easily be written as one long forward chain, where the user is told what to do next, although we describe two different experimental extensions that would support this for multiple users in <ref> [19, 8] </ref>.) Amber/Oz, and the original Oz, provide powerful execution facilities (e.g., both goal-driven and event-driven automation), and sophisticated multi-user/context-switching support (with collaborative concurrency control policies achieved through the mediator interface to an external transaction manager [15, 16]).
Reference: [9] <author> G. A. Bolcer and R. N. Taylor. Endeavors: </author> <title> A process system integration infrastructure. </title> <editor> In W. Schafer, editor, </editor> <booktitle> 4th International Conferenceon the Software Process: Software Process Improvement and Practice, </booktitle> <month> December </month> <year> 1996. </year> <note> In press. </note>
Reference-contexts: that added multi-server connectivity and process interoperability in the style of Oz [6, 5], and another that added more intuitive process modeling (than plausible with rules) as well as online process visualization by integrating Amber/Oz with a mockup of the TeamWare research prototype from the University of California at Irvine <ref> [9] </ref>. Section 5 summarizes the contributions of this research. 2. Spectrum of (Rule-based) Metalinguistic Ex tensibility Rules come in many forms. Some kinds have two parts (condition and action, or logical precedent and consequence), while others have three parts (condition, operator and effect, or event, action, postcondition). <p> Thus it seems valuable to integrate TeamWare and Oz, to exploit the advantages of both. We did not integrate Amber/Oz with the real TeamWare, which was temporarily out of order, but instead with our toy version called micro-Teamware (TeamWare). We plan to later integrate Amber/Oz with Endeavors <ref> [9] </ref>, the successor to TeamWare, following the same integration architecture. 4.2.1 micro-TeamWare Integration Approach The gist of the integration, from the process perspective, is to use TeamWare task graphs to model the process topology, the sequencing of tasks, that Amber/Oz users otherwise have to know off the top of their head.
Reference: [10] <author> D. P. Friedman, M. Wand, and C. T. Haynes. </author> <title> Essentials of Programming Languages. </title> <publisher> MIT Press, </publisher> <address> Cambridge MA, </address> <year> 1992. </year>
Reference-contexts: This approach is analogous to metalinguistic abstraction in Scheme <ref> [10] </ref>. Then tailored instances of the PCE can be employed in a great variety of applications, including those not envisioned at the time the system was originally developed.
Reference: [11] <author> W. J. Gail E. Kaiser, Stephen E. Dossick and J. J. Yang. </author> <title> An architecture for www-based hypercode environments. </title> <type> Technical Report CUCS-037-96, </type> <institution> Columbia University Department of Computer Science, </institution> <month> August </month> <year> 1996. </year>
Reference-contexts: For example, process-wide constraint enforcement is readily supported in most rule-based process formalisms via overloaded (data type-specific) pre-conditions on primitive operations (like OzWeb's read and write <ref> [11] </ref>), whereas constraints usually must be specified on a per task basis in Petri nets (e.g., predicates in FUNSOFT nets [12]). On the other hand, modular process hierarchy, which is built-into many (extended) Petri net formalisms, may not be directly supported in rule-based PCEs.
Reference: [12] <author> V. Gruhn and R. Jegelka. </author> <title> An evaluation of FUNSOFT nets. </title> <editor> In J. Derniame, editor, </editor> <booktitle> Software Process Technology Second European Workshop, number 635 in Lecture Notes in Computer Science, </booktitle> <pages> pages 196-214. </pages> <publisher> Springer-Verlag, </publisher> <address> Trondheim, Norway, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: For example, process-wide constraint enforcement is readily supported in most rule-based process formalisms via overloaded (data type-specific) pre-conditions on primitive operations (like OzWeb's read and write [11]), whereas constraints usually must be specified on a per task basis in Petri nets (e.g., predicates in FUNSOFT nets <ref> [12] </ref>). On the other hand, modular process hierarchy, which is built-into many (extended) Petri net formalisms, may not be directly supported in rule-based PCEs.
Reference: [13] <author> D. Heimbigner. </author> <title> The ProcessWall: A process state server approach to process programming. </title> <editor> In H. Weber, editor, </editor> <booktitle> 5th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 159-168, </pages> <address> Tyson's Corner VA, </address> <month> December </month> <year> 1992. </year> <journal> Special issue of Software Engineering Notes, </journal> <volume> 17(5), </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: Multi-lingual extensibility can itself be sub-divided into two different approaches: The first enables multiple languages to co-exist as peers, their independent process engines interfacing to a common process state (or enabled process task) representation, in the style of ProcessWall <ref> [13] </ref>, perhaps but not necessarily with an external task scheduling mechanism [24]. The second approach is based on layers, with translators from higher to lower levels and a process assembly language at the bottom.
Reference: [14] <author> G. T. Heineman. </author> <title> Automatic translation of process modeling formalisms. </title> <booktitle> In 1994 Centre for Advanced Studies Conference (CASCON), </booktitle> <pages> pages 110-120, </pages> <address> Toronto ON, Canada, </address> <month> November </month> <year> 1994. </year> <institution> IBM Canada Ltd. Laboratory. </institution>
Reference-contexts: The second approach is based on layers, with translators from higher to lower levels and a process assembly language at the bottom. We have begun investigation of the former approach, see [7], and studied the latter extensively as described in <ref> [26, 14, 19] </ref>.
Reference: [15] <author> G. T. Heineman. </author> <title> A Transaction Manager Component for Cooperative Transaction Models. </title> <type> PhD thesis, </type> <institution> Columbia University Department of Computer Science, </institution> <month> June </month> <year> 1996. </year> <month> CUCS-010-96. </month>
Reference-contexts: Amber does not use the ancestors for anything, but another component of the environment might, e.g., in our Oz integration the transaction manager treats atomicity implications of a rule as nested subtransactions <ref> [15] </ref>. 10. End Clean up after chaining, e.g., free memory allocated to the rule and its chains. This is done after the rule and its forward and/or backward chaining children have finished, so the data structures are available for reference throughout the full chain. <p> we describe two different experimental extensions that would support this for multiple users in [19, 8].) Amber/Oz, and the original Oz, provide powerful execution facilities (e.g., both goal-driven and event-driven automation), and sophisticated multi-user/context-switching support (with collaborative concurrency control policies achieved through the mediator interface to an external transaction manager <ref> [15, 16] </ref>). But the user interface limitation has been a severe block to serious use of Oz (and Marvel before it) by anyone other than the development group. Thus it seems valuable to integrate TeamWare and Oz, to exploit the advantages of both.
Reference: [16] <author> G. T. Heineman and G. E. Kaiser. </author> <title> An architecture for integrating concurrency control into environment frameworks. </title> <booktitle> In 17th International Conference on Software Engineering, </booktitle> <pages> pages 305-313, </pages> <address> Seattle WA, April 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: For Summit rules (i.e., at the coordinating site), it decrements the site counter used for termination detection. Oz's process engine was directly cognizant of locks and transactions. Although Amber/Oz uses the same transaction management component as the original Oz, described in <ref> [16] </ref>, Amber itself knows nothing at all about locks or transactions; all code concerned with concurrency control and failure recovery of rules and rule chains is located in callback functions (or mediator utilities called by those functions). 4.2. <p> we describe two different experimental extensions that would support this for multiple users in [19, 8].) Amber/Oz, and the original Oz, provide powerful execution facilities (e.g., both goal-driven and event-driven automation), and sophisticated multi-user/context-switching support (with collaborative concurrency control policies achieved through the mediator interface to an external transaction manager <ref> [15, 16] </ref>). But the user interface limitation has been a severe block to serious use of Oz (and Marvel before it) by anyone other than the development group. Thus it seems valuable to integrate TeamWare and Oz, to exploit the advantages of both.
Reference: [17] <author> G. T. Heineman, G. E. Kaiser, N. S. Barghouti, and I. Z. Ben-Shaul. </author> <title> Rule chaining in MARVEL: Dynamic binding of parameters. </title> <journal> IEEE Expert, </journal> <volume> 7(6) </volume> <pages> 26-32, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: To facilitate such modular extensibility, the interpreter is iterative, rather than a recursive one. (This is also the reason why Amber's rule interpreter was largely rewritten although the basic language is similar to the Marvel and Oz rule languages <ref> [17] </ref>). While the latter may be viewed as more natural for implementation of rule-processing due to the recursive nature of chaining, it is far less extensible due to the deeply intertwined and inter-dependent rule phases.
Reference: [18] <author> G. E. Kaiser and P. H. Feiler. </author> <title> An architecture for intelligent assistance in software development. </title> <booktitle> In 9th International Conference on Software Engineering, </booktitle> <pages> pages 180-188, </pages> <address> Monterey CA, March 1987. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: We proceed with an overview of the language followed by the full rule execution algorithm. 3.1. Language Overview Amber's PML is based in part on the Marvle Strategy Language (MSL) first developed for the Marvel process-centered environment <ref> [18] </ref> and later extended in Oz (with mostly semantic changes); most of the syntax, except for the extensible annotations, was previously elaborated in [3].
Reference: [19] <author> G. E. Kaiser, S. S. Popovich, and I. Z. Ben-Shaul. </author> <title> A bi-level language for software process modeling. </title> <editor> In W. F. Tichy, editor, </editor> <booktitle> Configuration Management, number 2 in Trends in Software, chapter 2, </booktitle> <pages> pages 39-72. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference-contexts: The second approach is based on layers, with translators from higher to lower levels and a process assembly language at the bottom. We have begun investigation of the former approach, see [7], and studied the latter extensively as described in <ref> [26, 14, 19] </ref>. <p> there is no roadmap, the user has to know what to do next. (Only simple single-user processes can easily be written as one long forward chain, where the user is told what to do next, although we describe two different experimental extensions that would support this for multiple users in <ref> [19, 8] </ref>.) Amber/Oz, and the original Oz, provide powerful execution facilities (e.g., both goal-driven and event-driven automation), and sophisticated multi-user/context-switching support (with collaborative concurrency control policies achieved through the mediator interface to an external transaction manager [15, 16]).
Reference: [20] <author> M. I. Kellner and H. D. Rombach. </author> <title> Session summary: Com parisons of software process descriptions. </title> <editor> In T. Katayama, editor, </editor> <booktitle> 6th International Software Process Workshop: Sup port for the Software Process, </booktitle> <pages> pages 7-18, </pages> <address> Hakodate, Japan, October 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Such first-order extensibility has been widely investigated for a decade or so, and several major paradigms for process modeling formalisms have been investigated, including rules, Petri nets, grammars, task graphs, and imperative code <ref> [20] </ref>. A related second-order kind of extensibility involves the ability to modify or re-engineer the process, perhaps fl Dr. Ben-Shaul is now at Technion-Israel Institute of Technology, Department of Electrical Engineering, Technion City, Haifa 32000, ISRAEL dynamically while a given process instance is in progress.
Reference: [21] <author> P. S. </author> <title> Lab. Amber Manual, </title> <month> July </month> <year> 1996. </year> <month> ftp://ftp.psl.cs.columbia.edu/pub/psl/oz.1.2.manuals/V.Amber/. </month>
Reference-contexts: Each phase callback is passed a pointer to the current rule instance, and can modify its state field as well as access the tree of parent and child rule instances through Amber's application programming interface (API) <ref> [21] </ref>; the rule also contains a work area where the callbacks can store a block of their own data for use by other callbacks. 3.3. <p> Jack Yang assisted in integrating the Amber process server into Oz and making it practical for our daily use. George Heineman helped with Amber's mediator interface to the Pern transaction manager, and Wenke Lee wrote part of the Amber API manual <ref> [21] </ref>. Dick Taylor and Greg Bolcer provided useful suggestions and feedback regarding our development and integration of TeamWare, based on their TeamWare version 1.0, and its integration with Amber/Oz.
Reference: [22] <author> N. H. Madhavji and M. H. Penedo, </author> <title> editors. Special Section on the Evolution of Software Processes, </title> <journal> volume 19:12 of IEEE Transactions on Software Engineering. </journal> <month> December, </month> <year> 1993. </year>
Reference-contexts: Ben-Shaul is now at Technion-Israel Institute of Technology, Department of Electrical Engineering, Technion City, Haifa 32000, ISRAEL dynamically while a given process instance is in progress. Termed process evolution, this concept has also been investigated in recent years in the software process community <ref> [22] </ref>. Reflection has been one influential language-based approach to evolution [2].
Reference: [23] <author> D. Notkin and W. G. Griswold. </author> <title> Extension and software development. </title> <booktitle> In 10th International Conference on Software Engineering, </booktitle> <pages> pages 274-283, </pages> <address> Raffles City, Singapore, </address> <month> April </month> <year> 1988. </year> <note> IEEE. </note>
Reference-contexts: Process engine extenders can insert/revise/replace their own functionality between phases, using a table-driven call-back mechanism. The callbacks are made to a mediator that tailors the process engine's semantics and interfaces to other environment components, in a similar fashion to <ref> [30, 23] </ref>. The callbacks can interface with other sub-systems, Call-backs can break the sequential execution, and access, in a controlled manner, internal state of the interpreter.
Reference: [24] <author> L. J. Osterweil. </author> <booktitle> Presentation at Software Process Architec tures Workshop, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: Multi-lingual extensibility can itself be sub-divided into two different approaches: The first enables multiple languages to co-exist as peers, their independent process engines interfacing to a common process state (or enabled process task) representation, in the style of ProcessWall [13], perhaps but not necessarily with an external task scheduling mechanism <ref> [24] </ref>. The second approach is based on layers, with translators from higher to lower levels and a process assembly language at the bottom. We have begun investigation of the former approach, see [7], and studied the latter extensively as described in [26, 14, 19].
Reference: [25] <author> M. H. Penedo. </author> <title> Life-cycle (sub) process scenario. </title> <editor> In C. Ghezzi, editor, </editor> <booktitle> 9th International Software Process Work shop, </booktitle> <pages> pages 141-143, </pages> <address> Airlie VA, October 1994. </address> <publisher> IEEE Com puter Society Press. </publisher>
Reference-contexts: forward chaining, as well as backward during forward and forward during chain ing modes, although either of these modes can be altered or removed, either optionally (by introducing rule annotation) or globally (by changing the default behavior). rule is adapted from an Oz demo environment for the ISPW9 example process <ref> [25] </ref>. The rule specifies that the review is performed whenever either of the conditions (a buggy C file has been revised or a bug has been found in a C file) are satisfied.
Reference: [26] <author> S. S. Popovich. </author> <title> An Architecture for Extensible Workflow Pro cess Servers. </title> <type> PhD thesis, </type> <institution> Columbia University Department of Computer Science, </institution> <month> July </month> <year> 1996. </year> <month> CUCS-014-96. </month>
Reference-contexts: The second approach is based on layers, with translators from higher to lower levels and a process assembly language at the bottom. We have begun investigation of the former approach, see [7], and studied the latter extensively as described in <ref> [26, 14, 19] </ref>. <p> To focus our discussion, we ignore many other aspects of the language/interpreter which are not closely related to supporting extensibility (for a complete account of Amber, see <ref> [26] </ref>). Syntactic extensions can be made (only) by means of rule annotations. <p> The set of callback functions are specified in Amber's action array of function pointers. Currently this mediator code is linked into the Amber instance at compile time; an improved version would support dynamic linking. Additional details can be found in <ref> [26] </ref>. 4. Sample Extensions 4.1. Multi-Process Collaboration Oz is a multi-site PCE that enables collaboration between heterogeneous and autonomous process instances running on homogeneous process engines. Each Oz environment has its own process model, data schema, objectbase and tools.
Reference: [27] <author> S. S. Popovich and G. E. Kaiser. </author> <title> Integrating an existing envi ronment with a rule-based process server. </title> <type> Technical Report CUCS-004-95, </type> <institution> Columbia University Department of Com puter Science, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: The power and flexibility of the callbacks mediating between the two systems was particularly critical since ProcessWEAVER is a commercial product and we had no access to its source code or internal documentation; see <ref> [27] </ref>. Acknowledgments Andrew Zhongwei Tong introduced our concept of agendas, which was reimplemented for Amber by Wenyu Jiang. Jack Yang assisted in integrating the Amber process server into Oz and making it practical for our daily use.
Reference: [28] <author> S. M. Sutton, Jr., D. Heimbigner, and L. J. Osterweil. APPL/A: </author> <title> A language for software process programming. </title> <journal> ACM Transactions on Software Engineering and Method ology, </journal> <volume> 4(3) </volume> <pages> 221-286, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Such extensions might be written directly in an imperative process programming language like APPL/A <ref> [28] </ref>, but for most declarative process modeling formalisms adding on such functionality necessarily involves modifying the underlying process enactment engine and/or integration with other (sub)systems, independent of extensions to the language per se.
Reference: [29] <author> A. Z. Tong, G. E. Kaiser, and S. S. Popovich. </author> <title> A flexible rule-chaining engine for process-based software engineering. </title> <booktitle> In 9th Knowledge-Based Software Engineering Conference, </booktitle> <pages> pages 79-88, </pages> <address> Monterey CA, September 1994. </address> <publisher> IEEE Com puter Society Press. </publisher>
Reference-contexts: Adding guidance support, e.g., to notify users when tasks become enabled and allow them to select among currently enabled tasks, may demand addition of an agenda mechanism in which to store some representation of the enabled tasks <ref> [29] </ref>. Such extensions might be written directly in an imperative process programming language like APPL/A [28], but for most declarative process modeling formalisms adding on such functionality necessarily involves modifying the underlying process enactment engine and/or integration with other (sub)systems, independent of extensions to the language per se. <p> For example, we have devised a new chaining type we call guidance, which works like automation except that after instantiating a rule and satisfying its condition, the rule instance is placed into a persistent agenda (to do list), so one argument is whose agenda (user or group) <ref> [29] </ref>. 3.2. Amber Rule Execution Algorithm There are two auxiliary data structures, in addition to basic rules, that are used to manage rule execution: tasks and bulges. A task is a set of rules, together with all of their forward and backward chaining implications. <p> We had previously developed a similar notion of agendas <ref> [29] </ref>, but it had never been integrated in the mainstream version of Oz although we were able to port some of the old code to Amber. The agenda implementation, e.g., persistent maintenance of agendas, is implemented entirely in mediator code, not hard-wired into Amber.
Reference: [30] <author> G. Wiederhold. </author> <booktitle> Mediators in the architecture of future infor mation systems. Computer, </booktitle> <volume> 25(3) </volume> <pages> 38-49, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Process engine extenders can insert/revise/replace their own functionality between phases, using a table-driven call-back mechanism. The callbacks are made to a mediator that tailors the process engine's semantics and interfaces to other environment components, in a similar fashion to <ref> [30, 23] </ref>. The callbacks can interface with other sub-systems, Call-backs can break the sequential execution, and access, in a controlled manner, internal state of the interpreter.
Reference: [31] <author> P. S. Young and R. N. Taylor. </author> <title> Human-executed operations in the teamware process programming system. </title> <editor> In C. Ghezzi, editor, </editor> <booktitle> 9th International Software Process Workshop: The Role of Humans in the Process, </booktitle> <pages> pages 78-81, </pages> <address> Airlie VA, </address> <month> October </month> <year> 1994. </year> <note> IEEE Computer Society Press. Position paper. </note>
Reference-contexts: Integration with micro-TeamWare TeamWare <ref> [31, 32] </ref> represents the process model as a task graph, where nodes in the graph define process steps or tasks.
Reference: [32] <author> P. S. C. Young. </author> <title> Customizable Process Specification and En actment for Technical and Non-Technical Users. </title> <type> PhD thesis, </type> <institution> University of California Irvine, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: Integration with micro-TeamWare TeamWare <ref> [31, 32] </ref> represents the process model as a task graph, where nodes in the graph define process steps or tasks.
References-found: 32

