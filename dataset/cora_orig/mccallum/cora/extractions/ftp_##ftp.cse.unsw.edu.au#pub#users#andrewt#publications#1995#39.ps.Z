URL: ftp://ftp.cse.unsw.edu.au/pub/users/andrewt/publications/1995/39.ps.Z
Refering-URL: http://www.cse.unsw.edu.au/school/publications/1995/SCSE_publications.html
Root-URL: 
Email: Email: ericm@cse.unsw.edu.au  Email: arun@cse.unsw.edu.au  
Phone: Phone: (02)-385-3940 Fax: (02)-663-4576  Phone: (02)-385-3938 Fax: (02)-663-4576  
Title: Extraction of Meta-Knowledge to Restrict the Hypothesis Space for ILP Systems incorporating them in FOIL.
Author: Eric McCreath Arun Sharma 
Note: Empirical evidence for the effectiveness of these algorithms is demonstrated by  Supported by an Australian Postgraduate Research Award. Supported by a grant from the Australian Research Council.  
Address: Sydney NSW 2052, Australia  Sydney NSW 2052, Australia  
Affiliation: Department of Artificial Intelligence School of Computer Science and Engineering The University of New South Wales  Department of Artificial Intelligence School of Computer Science and Engineering The University of New South Wales  
Abstract: Many ILP systems, such as GOLEM, FOIL, and MIS, take advantage of user supplied meta-knowledge to restrict the hypothesis space. This meta-knowledge can be in the form of type information about arguments in the predicate being learned, or it can be information about whether a certain argument in the predicate is functionally dependent on the other arguments (supplied as mode information). This meta knowledge is explicitly supplied to an ILP system in addition to the data. The present paper argues that in many cases the meta knowledge can be extracted directly from the raw data. Three algorithms are presented that learn type, mode, and symmetric meta-knowledge from data. These algorithms can be incorporated in existing ILP systems in the form of a preprocessor that obviates the need for a user to explicitly provide this information. In many cases, the algorithms can extract meta- knowledge that the user is either unaware of, but which information can be used by the ILP system to restrict the hypothesis space. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Bergadano. </author> <title> The problem of induction and machine learning. </title> <booktitle> In Proc. Int. Joint Conf on Artificial Intelligence, </booktitle> <pages> pages 1073-1079, </pages> <address> 1991. Sydney, Australia. </address>
Reference-contexts: This compacts or biases the search space and improves the efficiency of the ILP system. Current ILP systems employ a variety of meta-knowledge to bias the hypothesis space. This extra information includes, rule models [7], functional/mode constraints [2, 12, 8, 14, 6], predicate sets <ref> [1] </ref>, and type constraints [14, 6]. All these systems require that the user explicitly provide this additional information. Table 1 shows the biasing properties employed by different ILP systems. <p> This predicate, which takes three arguments, asserts that the third argument is a sorted list formed by merging the first two arguments that are also sorted lists. So, for example merge ([1; 4; 6]; [3; 6]; <ref> [1; 3; 4; 6; 6] </ref>) is a positive example of the merge predicate and merge ([1; 2]; []; [2; 1]) is a negative example. Suppose the system is also provided with background knowledge about the predicates less, less-eq , and comp. <p> So, for example merge ([1; 4; 6]; [3; 6]; [1; 3; 4; 6; 6]) is a positive example of the merge predicate and merge ([1; 2]; []; <ref> [2; 1] </ref>) is a negative example. Suppose the system is also provided with background knowledge about the predicates less, less-eq , and comp. <p> The three algorithms are sketched in Figure 2. 2.1 Type A type assignment that is consistent with the predicate being learned and the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; <ref> [1] </ref>; [1]): merge ([]; [2]; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; <p> The three algorithms are sketched in Figure 2. 2.1 Type A type assignment that is consistent with the predicate being learned and the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; <ref> [1] </ref>; [1]): merge ([]; [2]; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; <p> Figure 2. 2.1 Type A type assignment that is consistent with the predicate being learned and the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; <p> 2.1 Type A type assignment that is consistent with the predicate being learned and the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge <p> that is consistent with the predicate being learned and the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; <ref> [1] </ref>; [1]): merge ([]; [2]; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; <p> with the predicate being learned and the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; <ref> [1] </ref>; [1]): merge ([]; [2]; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; <p> the predicate being learned and the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; <ref> [1; 1] </ref>): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; <p> the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge <p> background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; <p> can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; <ref> [1; 1; 2] </ref>): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; <p> examples, negative 2 E + merge ([]; []; []): merge ([]; <ref> [1] </ref>; [1]): merge ([]; [2]; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; <p> negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; <p> ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; <p> [1]): merge ([]; [2]; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; <ref> [1; 2; 2] </ref>): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; <p> <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; <p> (<ref> [1] </ref>; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge <p> []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; <ref> [1; 1; 2] </ref>): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; <p> merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; <ref> [1; 2; 2] </ref>): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): <p> ([1]; <ref> [1; 2] </ref>; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; <p> 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; <ref> [1; 1; 2; 2] </ref>): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; <p> merge ([2]; <ref> [1] </ref>; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; <p> [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; <ref> [1] </ref>; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; <p> [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; <ref> [1] </ref>; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge <p> ([2]; <ref> [1; 2] </ref>; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; <p> 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; <ref> [1; 1; 2] </ref>): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; <p> 2]; []; [1; 2]): merge ([1; 2]; <ref> [1] </ref>; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq <p> 2]): merge (<ref> [1; 2] </ref>; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq <p> (<ref> [1; 2] </ref>; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): <p> 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; <ref> [1] </ref>): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp <p> [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; <ref> [2; 1] </ref>): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; <p> 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; <ref> [2; 1] </ref>): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; <p> ([]; []; <ref> [1] </ref>): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; <p> []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; <ref> [1; 2; 1] </ref>): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; <p> ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; <ref> [2; 1] </ref>): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp <p> <ref> [1; 2] </ref>; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp ([1; 1; 1]; 1; [1; <p> [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; <ref> [1; 2] </ref>; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp ([1; 1; 1]; 1; [1; 1]): . <p> ([1; 2]; []; [2; 1]): merge ([1; 2]; <ref> [1] </ref>; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp ([1; 1; 1]; 1; [1; 1]): . . . comp ([2; 2; 2; 1]; 2; [2; 2; 1]): comp ([2; 2; 2; 2]; 2; [2; 2; 2]): Table 2: Raw information for learning merge <p> 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp (<ref> [1] </ref>; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp ([1; 1; 1]; 1; [1; 1]): . . . comp ([2; 2; 2; 1]; 2; [2; 2; 1]): comp ([2; 2; 2; 2]; 2; [2; 2; 2]): Table 2: Raw information for learning merge examples, and the background knowledge (i.e., E + [ E <p> [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp (<ref> [1; 1] </ref>; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp ([1; 1; 1]; 1; [1; 1]): . . . comp ([2; 2; 2; 1]; 2; [2; 2; 1]): comp ([2; 2; 2; 2]; 2; [2; 2; 2]): Table 2: Raw information for learning merge examples, and the background knowledge (i.e., E + [ E [ B). This may proceed as follows. <p> less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp ([1; 1; 1]; 1; [1; 1]): . . . comp ([2; 2; 2; 1]; 2; <ref> [2; 2; 1] </ref>): comp ([2; 2; 2; 2]; 2; [2; 2; 2]): Table 2: Raw information for learning merge examples, and the background knowledge (i.e., E + [ E [ B). This may proceed as follows. <p> For this the merge predicate is scanned for any counterexamples. If a counterexample is found then such a functional dependency does not exist. In this case the first two facts provide a counterexample, as the first fact maps [] to [] and the second maps [] to <ref> [1] </ref>. No such conflict is found for Mode (merge (+; +; )). By repeating this process for other predicates, less, less-eq, and comp, the remaining mode information may be discovered. <p> This test requires two steps. First, a scan of the merge ground facts is made to show there are no examples contrary to merge being symmetric in the pair of arguments under consideration. When the last two arguments are being tested for symmetry the positive example merge (<ref> [1] </ref>; []; [1]) and the negative example merge ([1]; [1]; []) signal that no symmetry exists. Second, some positive confirmation that the symmetry exists is found. When the first two arguments are being tested for symmetry the positive confirmation is first found in the examples merge ([]; [1]; [1]) and merge ([1]; []; <p> When the last two arguments are being tested for symmetry the positive example merge (<ref> [1] </ref>; []; [1]) and the negative example merge ([1]; [1]; []) signal that no symmetry exists. Second, some positive confirmation that the symmetry exists is found. When the first two arguments are being tested for symmetry the positive confirmation is first found in the examples merge ([]; [1]; [1]) and merge ([1]; []; [1]). <p> positive example merge (<ref> [1] </ref>; []; [1]) and the negative example merge ([1]; [1]; []) signal that no symmetry exists. Second, some positive confirmation that the symmetry exists is found. When the first two arguments are being tested for symmetry the positive confirmation is first found in the examples merge ([]; [1]; [1]) and merge ([1]; []; [1]). It is easy to see that the information about symmetry can be used to restrict the hypotheses search space, as only one of the logically equivalent pair of clauses is considered. <p> example merge (<ref> [1] </ref>; []; [1]) and the negative example merge ([1]; [1]; []) signal that no symmetry exists. Second, some positive confirmation that the symmetry exists is found. When the first two arguments are being tested for symmetry the positive confirmation is first found in the examples merge ([]; [1]; [1]) and merge ([1]; []; [1]). It is easy to see that the information about symmetry can be used to restrict the hypotheses search space, as only one of the logically equivalent pair of clauses is considered. <p> and the negative example merge (<ref> [1] </ref>; [1]; []) signal that no symmetry exists. Second, some positive confirmation that the symmetry exists is found. When the first two arguments are being tested for symmetry the positive confirmation is first found in the examples merge ([]; [1]; [1]) and merge ([1]; []; [1]). It is easy to see that the information about symmetry can be used to restrict the hypotheses search space, as only one of the logically equivalent pair of clauses is considered.
Reference: [2] <author> F. Bergadano and D. Gunetti. </author> <title> An interactive system to learn functional logic programs. </title> <booktitle> In Machine Learning, </booktitle> <year> 1994. </year>
Reference-contexts: This compacts or biases the search space and improves the efficiency of the ILP system. Current ILP systems employ a variety of meta-knowledge to bias the hypothesis space. This extra information includes, rule models [7], functional/mode constraints <ref> [2, 12, 8, 14, 6] </ref>, predicate sets [1], and type constraints [14, 6]. All these systems require that the user explicitly provide this additional information. Table 1 shows the biasing properties employed by different ILP systems. <p> This further improves the efficiency of the ILP system by creating a strong bias on the hypothesis space. 1 Mode Type Symmetry Exclusive Opposite MISST [8] p p p p Markus [6] p p p Progol [13] p p p p GOLEM [12] p FOIL [4] p p FLIP <ref> [2] </ref> p SIERES p MOBAL [11] p Table 1 : ILP Systems using meta knowledge property generator Information such as rule models and predicate sets can not be learned by examining the examples of the relation. <p> So, for example merge ([1; 4; 6]; [3; 6]; [1; 3; 4; 6; 6]) is a positive example of the merge predicate and merge ([1; 2]; []; <ref> [2; 1] </ref>) is a negative example. Suppose the system is also provided with background knowledge about the predicates less, less-eq , and comp. <p> algorithms are sketched in Figure 2. 2.1 Type A type assignment that is consistent with the predicate being learned and the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; <ref> [2] </ref>; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge <p> are sketched in Figure 2. 2.1 Type A type assignment that is consistent with the predicate being learned and the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; <ref> [2] </ref>; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; <p> Figure 2. 2.1 Type A type assignment that is consistent with the predicate being learned and the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; <p> 2.1 Type A type assignment that is consistent with the predicate being learned and the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge <p> and the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; <ref> [2] </ref>; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): <p> the predicates in the background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge <p> background knowledge can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; <p> can be found in one pass of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; <ref> [1; 1; 2] </ref>): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; <p> of the positive examples, negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; <ref> [2] </ref>; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; <p> negative 2 E + merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; <p> merge ([]; []; []): merge ([]; [1]; [1]): merge ([]; <ref> [2] </ref>; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; <p> ([]; []; []): merge ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; <ref> [2; 2] </ref>): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): <p> ([]; [1]; [1]): merge ([]; [2]; [2]): merge ([]; <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; <p> [1]): merge ([]; [2]; [2]): merge ([]; [1; 2]; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; <ref> [1; 2; 2] </ref>): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; <p> <ref> [1; 2] </ref>; [1; 2]): merge ([1]; []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; <p> []; [1]): merge ([1]; [1]; [1; 1]): merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; <ref> [1; 1; 2] </ref>): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; <p> 1]): merge ([1]; <ref> [2] </ref>; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; <p> merge ([1]; [2]; [1; 2]): merge ([1]; [1; 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; <ref> [1; 2; 2] </ref>): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): <p> ([1]; <ref> [1; 2] </ref>; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; <p> 2]; [1; 1; 2]): merge ([2]; []; [2]): merge ([2]; [1]; [1; 2]): merge ([2]; [2]; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; <ref> [1; 1; 2; 2] </ref>): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; <p> <ref> [2] </ref>; [2; 2]): merge ([2]; [1; 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): <p> ([2]; <ref> [1; 2] </ref>; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; <p> 2]; [1; 2; 2]): merge ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; <ref> [1; 1; 2] </ref>): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; <p> ([1; 2]; []; [1; 2]): merge ([1; 2]; [1]; [1; 1; 2]): merge ([1; 2]; <ref> [2] </ref>; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): <p> 2]): merge (<ref> [1; 2] </ref>; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq <p> (<ref> [1; 2] </ref>; [1]; [1; 1; 2]): merge ([1; 2]; [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): <p> [2]; [1; 2; 2]): merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; <ref> [2; 1] </ref>): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; <p> merge ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; <ref> [2] </ref>; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; <p> ([1; 2]; [1; 2]; [1; 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; <ref> [2] </ref>; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; <p> 1; 2; 2]): E merge ([]; []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; <ref> [2; 1] </ref>): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; <p> []; [1]): merge ([1]; [1]; []): merge ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; <ref> [1; 2; 1] </ref>): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; <p> merge ([]; <ref> [2] </ref>; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): <p> ([]; [2]; [1]): merge ([]; [1; 2]; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; <ref> [2; 1] </ref>): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp <p> <ref> [1; 2] </ref>; [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; [1; 2]; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp ([1; 1; 1]; 1; [1; <p> [1; 1; 2]): merge ([1]; [2]; [1]): merge ([1]; <ref> [1; 2] </ref>; [1; 2]): merge ([2]; []; []): merge ([2]; [1]; [2; 1]): merge ([2]; [2]; [2]): merge ([1; 2]; []; [2; 1]): merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; [2]; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp ([1; 1; 1]; 1; [1; 1]): . <p> merge ([1; 2]; [1]; [1; 2; 1]): merge ([1; 2]; <ref> [2] </ref>; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp ([1; 1; 1]; 1; [1; 1]): . . . comp ([2; 2; 2; 1]; 2; [2; 2; 1]): comp ([2; 2; 2; 2]; 2; [2; 2; 2]): Table 2: Raw information for learning merge examples, and the background knowledge <p> <ref> [2] </ref>; [2; 1]): merge ([1; 2]; [1; 2]; [1; 2]): B less (1; 2): less-eq (1; 2): less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp ([1; 1; 1]; 1; [1; 1]): . . . comp ([2; 2; 2; 1]; 2; [2; 2; 1]): comp ([2; 2; 2; 2]; 2; [2; 2; 2]): Table 2: Raw information for learning merge examples, and the background knowledge (i.e., E + [ E [ B). <p> less-eq (1; 1): less-eq (2; 2): comp ([1]; 1; []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp ([1; 1; 1]; 1; [1; 1]): . . . comp ([2; 2; 2; 1]; 2; <ref> [2; 2; 1] </ref>): comp ([2; 2; 2; 2]; 2; [2; 2; 2]): Table 2: Raw information for learning merge examples, and the background knowledge (i.e., E + [ E [ B). This may proceed as follows. <p> []): comp ([2]; 2; []): comp ([1; 1]; 1; [1]): comp ([1; 2]; 1; [2]): comp ([2; 1]; 2; [1]): comp ([2; 2]; 2; [2]): comp ([1; 1; 1]; 1; [1; 1]): . . . comp ([2; 2; 2; 1]; 2; [2; 2; 1]): comp ([2; 2; 2; 2]; 2; <ref> [2; 2; 2] </ref>): Table 2: Raw information for learning merge examples, and the background knowledge (i.e., E + [ E [ B). This may proceed as follows. Initially, set the types associated with each argument of each predicate to a different type.
Reference: [3] <author> I. Bratko. </author> <title> Prolog Programming for Artificial Intelligence. </title> <publisher> Addison-Wesley, </publisher> <address> Workingham, </address> <year> 1990. </year> <note> second edition. </note>
Reference-contexts: This predicate, which takes three arguments, asserts that the third argument is a sorted list formed by merging the first two arguments that are also sorted lists. So, for example merge ([1; 4; 6]; <ref> [3; 6] </ref>; [1; 3; 4; 6; 6]) is a positive example of the merge predicate and merge ([1; 2]; []; [2; 1]) is a negative example. Suppose the system is also provided with background knowledge about the predicates less, less-eq , and comp. <p> This predicate, which takes three arguments, asserts that the third argument is a sorted list formed by merging the first two arguments that are also sorted lists. So, for example merge ([1; 4; 6]; [3; 6]; <ref> [1; 3; 4; 6; 6] </ref>) is a positive example of the merge predicate and merge ([1; 2]; []; [2; 1]) is a negative example. Suppose the system is also provided with background knowledge about the predicates less, less-eq , and comp. <p> Two series of experiments were carried out. First, nine target relations from Bratko's Prolog book <ref> [3] </ref> were considered: member , conc, del , sublist1 , sublist2 , permutation, add , gcd , and length. These results, shown in Table 3, contrast learning with generated meta-knowledge and learning with no meta-knowledge.
Reference: [4] <author> R.M. Cameron-Jones and J.R. Quinlan. </author> <title> Efficient top-down induction of logic programs. </title> <journal> SIGART Bulletin, </journal> <volume> 5(1) </volume> <pages> 33-42, </pages> <year> 1994. </year>
Reference-contexts: This further improves the efficiency of the ILP system by creating a strong bias on the hypothesis space. 1 Mode Type Symmetry Exclusive Opposite MISST [8] p p p p Markus [6] p p p Progol [13] p p p p GOLEM [12] p FOIL <ref> [4] </ref> p p FLIP [2] p SIERES p MOBAL [11] p Table 1 : ILP Systems using meta knowledge property generator Information such as rule models and predicate sets can not be learned by examining the examples of the relation. <p> Additionally, addition is symmetric in its first two arguments; this information may be given to an ILP system in the form of a symmetry declaration Symmetry (add (fl; fl; )). The effectiveness of the preprocessor is demonstrated by combining it with FOIL <ref> [4] </ref>. We now proceed as follows. In Section 2, we illustrate the working of the algorithms for extracting type, mode, and symmetric information with the help of an example. <p> This predicate, which takes three arguments, asserts that the third argument is a sorted list formed by merging the first two arguments that are also sorted lists. So, for example merge ([1; 4; 6]; [3; 6]; <ref> [1; 3; 4; 6; 6] </ref>) is a positive example of the merge predicate and merge ([1; 2]; []; [2; 1]) is a negative example. Suppose the system is also provided with background knowledge about the predicates less, less-eq , and comp. <p> Type restriction works well for both top-down (FOIL <ref> [4] </ref>) and bottom-up (GOLEM [12]) learners. We would like to note that type meta knowledge is learned in the MOBAL [11] system. MOBAL optionally generates type information by clustering constant terms which appear in the example set. <p> For example, merge (X 1 ; X 2 ; X 3 ) comp (X 1 ; X 2 ; X 3 ) is not consistent with the functional dependency information induced above, and hence can be removed from the search space. Both GOLEM [12] and FOIL <ref> [4] </ref> can make use of this information, and it plays a central role in restricting the hypothesis space in Progol [13]. 2.3 Symmetry Meta knowledge about symmetry can also be derived from the data about the merge predicate. Clearly, merge is symmetric in its first two arguments. <p> We are aware of only MISST [8], LINUS [9], and mFOIL [5] that are capable of using user supplied symmetry information. 3 Experimental Results The meta-knowledge extraction algorithms have been incorporated into a preprocessor that generates meta-knowledge for Quinlan's FOIL <ref> [4] </ref>.
Reference: [5] <author> S Dzeroski. </author> <title> Handling noise in inductive logic programming. </title> <type> Master's thesis, </type> <institution> Faculty of Electrical Engineering and Computer Science, University of Ljubljana, Ljubljana, Slovenia, </institution> <year> 1991. </year>
Reference-contexts: So, there is no need to include both in the search space. Most ILP system do not make use of information about symmetry. We are aware of only MISST [8], LINUS [9], and mFOIL <ref> [5] </ref> that are capable of using user supplied symmetry information. 3 Experimental Results The meta-knowledge extraction algorithms have been incorporated into a preprocessor that generates meta-knowledge for Quinlan's FOIL [4].
Reference: [6] <author> Marko Grobelnik. </author> <title> Induction of prolog programs with markus. </title> <institution> Jozef Stefan Institute, </institution> <year> 1994. </year>
Reference-contexts: This compacts or biases the search space and improves the efficiency of the ILP system. Current ILP systems employ a variety of meta-knowledge to bias the hypothesis space. This extra information includes, rule models [7], functional/mode constraints <ref> [2, 12, 8, 14, 6] </ref>, predicate sets [1], and type constraints [14, 6]. All these systems require that the user explicitly provide this additional information. Table 1 shows the biasing properties employed by different ILP systems. <p> This compacts or biases the search space and improves the efficiency of the ILP system. Current ILP systems employ a variety of meta-knowledge to bias the hypothesis space. This extra information includes, rule models [7], functional/mode constraints [2, 12, 8, 14, 6], predicate sets [1], and type constraints <ref> [14, 6] </ref>. All these systems require that the user explicitly provide this additional information. Table 1 shows the biasing properties employed by different ILP systems. <p> Additionally, the same preprocessor can be used to learn properties of the background knowledge. This further improves the efficiency of the ILP system by creating a strong bias on the hypothesis space. 1 Mode Type Symmetry Exclusive Opposite MISST [8] p p p p Markus <ref> [6] </ref> p p p Progol [13] p p p p GOLEM [12] p FOIL [4] p p FLIP [2] p SIERES p MOBAL [11] p Table 1 : ILP Systems using meta knowledge property generator Information such as rule models and predicate sets can not be learned by examining the examples <p> This predicate, which takes three arguments, asserts that the third argument is a sorted list formed by merging the first two arguments that are also sorted lists. So, for example merge ([1; 4; 6]; <ref> [3; 6] </ref>; [1; 3; 4; 6; 6]) is a positive example of the merge predicate and merge ([1; 2]; []; [2; 1]) is a negative example. Suppose the system is also provided with background knowledge about the predicates less, less-eq , and comp. <p> This predicate, which takes three arguments, asserts that the third argument is a sorted list formed by merging the first two arguments that are also sorted lists. So, for example merge ([1; 4; 6]; [3; 6]; <ref> [1; 3; 4; 6; 6] </ref>) is a positive example of the merge predicate and merge ([1; 2]; []; [2; 1]) is a negative example. Suppose the system is also provided with background knowledge about the predicates less, less-eq , and comp.
Reference: [7] <author> J. U. Kietz and S. Wrobel. </author> <title> Controlling the complexity of learning in logic through syntatic and task-oriented models. </title> <booktitle> In Proc. Workshop on Inductive Logic Programming, </booktitle> <year> 1991. </year>
Reference-contexts: This compacts or biases the search space and improves the efficiency of the ILP system. Current ILP systems employ a variety of meta-knowledge to bias the hypothesis space. This extra information includes, rule models <ref> [7] </ref>, functional/mode constraints [2, 12, 8, 14, 6], predicate sets [1], and type constraints [14, 6]. All these systems require that the user explicitly provide this additional information. Table 1 shows the biasing properties employed by different ILP systems.
Reference: [8] <author> Marc Kirschenbaum and Leon Sterling. </author> <title> Refinement strategies for inductive learning of simple prolog programs. </title> <booktitle> In Proceedings of the 9th international conference on Artificial Intelligence, </booktitle> <year> 1991. </year>
Reference-contexts: In general, the size of this hypotheses space turns out to be huge. In order to discover a correct hypothesis feasibly, this space must be structured and searched efficiently. Many ILP systems provide extra information or meta-knowledge <ref> [8, 10] </ref> about the relation being learned. This information renders a large number of hypotheses in the search space incompatible, and the system can safely exclude them from the search space. This compacts or biases the search space and improves the efficiency of the ILP system. <p> This compacts or biases the search space and improves the efficiency of the ILP system. Current ILP systems employ a variety of meta-knowledge to bias the hypothesis space. This extra information includes, rule models [7], functional/mode constraints <ref> [2, 12, 8, 14, 6] </ref>, predicate sets [1], and type constraints [14, 6]. All these systems require that the user explicitly provide this additional information. Table 1 shows the biasing properties employed by different ILP systems. <p> Additionally, the same preprocessor can be used to learn properties of the background knowledge. This further improves the efficiency of the ILP system by creating a strong bias on the hypothesis space. 1 Mode Type Symmetry Exclusive Opposite MISST <ref> [8] </ref> p p p p Markus [6] p p p Progol [13] p p p p GOLEM [12] p FOIL [4] p p FLIP [2] p SIERES p MOBAL [11] p Table 1 : ILP Systems using meta knowledge property generator Information such as rule models and predicate sets can not <p> So, there is no need to include both in the search space. Most ILP system do not make use of information about symmetry. We are aware of only MISST <ref> [8] </ref>, LINUS [9], and mFOIL [5] that are capable of using user supplied symmetry information. 3 Experimental Results The meta-knowledge extraction algorithms have been incorporated into a preprocessor that generates meta-knowledge for Quinlan's FOIL [4].
Reference: [9] <author> N. Lavrac and S. Dzeroski. </author> <title> Inductive Logic Programming: Techniques and Applications. </title> <publisher> Ellis Horwood (Simon and Schuster), </publisher> <year> 1994. </year>
Reference-contexts: So, there is no need to include both in the search space. Most ILP system do not make use of information about symmetry. We are aware of only MISST [8], LINUS <ref> [9] </ref>, and mFOIL [5] that are capable of using user supplied symmetry information. 3 Experimental Results The meta-knowledge extraction algorithms have been incorporated into a preprocessor that generates meta-knowledge for Quinlan's FOIL [4].
Reference: [10] <author> Nada Lavrac and Saso Dzeroski. </author> <title> Background knowledge and declarative bias in inductive concept learning. </title> <editor> In K. P. Jantke, editor, </editor> <title> Analogical and Inductive Inference, </title> <booktitle> Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1992. </year>
Reference-contexts: In general, the size of this hypotheses space turns out to be huge. In order to discover a correct hypothesis feasibly, this space must be structured and searched efficiently. Many ILP systems provide extra information or meta-knowledge <ref> [8, 10] </ref> about the relation being learned. This information renders a large number of hypotheses in the search space incompatible, and the system can safely exclude them from the search space. This compacts or biases the search space and improves the efficiency of the ILP system.
Reference: [11] <author> K. Morik. </author> <title> Balanced cooperative modelling. </title> <booktitle> In Proc. First International Workshop on Multistrategy Learning, </booktitle> <pages> pages 65-80, </pages> <institution> George Mason University, Fairfax, VA, </institution> <year> 1991. </year>
Reference-contexts: efficiency of the ILP system by creating a strong bias on the hypothesis space. 1 Mode Type Symmetry Exclusive Opposite MISST [8] p p p p Markus [6] p p p Progol [13] p p p p GOLEM [12] p FOIL [4] p p FLIP [2] p SIERES p MOBAL <ref> [11] </ref> p Table 1 : ILP Systems using meta knowledge property generator Information such as rule models and predicate sets can not be learned by examining the examples of the relation. <p> Type restriction works well for both top-down (FOIL [4]) and bottom-up (GOLEM [12]) learners. We would like to note that type meta knowledge is learned in the MOBAL <ref> [11] </ref> system. MOBAL optionally generates type information by clustering constant terms which appear in the example set.
Reference: [12] <author> S. Muggleton and C. Feng. </author> <title> Efficient induction of logic programs. </title> <booktitle> In Proceedings of the First Conference on Algorithmic Learning Theory, Tokyo, </booktitle> <pages> pages 368-381. </pages> <publisher> Ohmsa Publishers, </publisher> <year> 1990. </year> <note> Reprinted by Ohmsa Springer-Verlag. </note>
Reference-contexts: This compacts or biases the search space and improves the efficiency of the ILP system. Current ILP systems employ a variety of meta-knowledge to bias the hypothesis space. This extra information includes, rule models [7], functional/mode constraints <ref> [2, 12, 8, 14, 6] </ref>, predicate sets [1], and type constraints [14, 6]. All these systems require that the user explicitly provide this additional information. Table 1 shows the biasing properties employed by different ILP systems. <p> This further improves the efficiency of the ILP system by creating a strong bias on the hypothesis space. 1 Mode Type Symmetry Exclusive Opposite MISST [8] p p p p Markus [6] p p p Progol [13] p p p p GOLEM <ref> [12] </ref> p FOIL [4] p p FLIP [2] p SIERES p MOBAL [11] p Table 1 : ILP Systems using meta knowledge property generator Information such as rule models and predicate sets can not be learned by examining the examples of the relation. <p> Type restriction works well for both top-down (FOIL [4]) and bottom-up (GOLEM <ref> [12] </ref>) learners. We would like to note that type meta knowledge is learned in the MOBAL [11] system. MOBAL optionally generates type information by clustering constant terms which appear in the example set. <p> For example, merge (X 1 ; X 2 ; X 3 ) comp (X 1 ; X 2 ; X 3 ) is not consistent with the functional dependency information induced above, and hence can be removed from the search space. Both GOLEM <ref> [12] </ref> and FOIL [4] can make use of this information, and it plays a central role in restricting the hypothesis space in Progol [13]. 2.3 Symmetry Meta knowledge about symmetry can also be derived from the data about the merge predicate. Clearly, merge is symmetric in its first two arguments.
Reference: [13] <author> Stephen Muggleton. </author> <title> Inverse entailment and progol, </title> <month> May </month> <year> 1995. </year>
Reference-contexts: This further improves the efficiency of the ILP system by creating a strong bias on the hypothesis space. 1 Mode Type Symmetry Exclusive Opposite MISST [8] p p p p Markus [6] p p p Progol <ref> [13] </ref> p p p p GOLEM [12] p FOIL [4] p p FLIP [2] p SIERES p MOBAL [11] p Table 1 : ILP Systems using meta knowledge property generator Information such as rule models and predicate sets can not be learned by examining the examples of the relation. <p> Both GOLEM [12] and FOIL [4] can make use of this information, and it plays a central role in restricting the hypothesis space in Progol <ref> [13] </ref>. 2.3 Symmetry Meta knowledge about symmetry can also be derived from the data about the merge predicate. Clearly, merge is symmetric in its first two arguments. The generation of this information involves testing each pair of arguments for symmetry. This test requires two steps.
Reference: [14] <author> E. Shapiro. </author> <title> Inductive inference of theories from facts. </title> <type> Technical Report 192, </type> <institution> Computer Science Department, Yale University, </institution> <year> 1981. </year> <month> 8 </month>
Reference-contexts: This compacts or biases the search space and improves the efficiency of the ILP system. Current ILP systems employ a variety of meta-knowledge to bias the hypothesis space. This extra information includes, rule models [7], functional/mode constraints <ref> [2, 12, 8, 14, 6] </ref>, predicate sets [1], and type constraints [14, 6]. All these systems require that the user explicitly provide this additional information. Table 1 shows the biasing properties employed by different ILP systems. <p> This compacts or biases the search space and improves the efficiency of the ILP system. Current ILP systems employ a variety of meta-knowledge to bias the hypothesis space. This extra information includes, rule models [7], functional/mode constraints [2, 12, 8, 14, 6], predicate sets [1], and type constraints <ref> [14, 6] </ref>. All these systems require that the user explicitly provide this additional information. Table 1 shows the biasing properties employed by different ILP systems.
References-found: 14

