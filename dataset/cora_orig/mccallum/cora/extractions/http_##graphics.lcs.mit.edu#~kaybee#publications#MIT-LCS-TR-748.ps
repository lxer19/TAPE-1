URL: http://graphics.lcs.mit.edu/~kaybee/publications/MIT-LCS-TR-748.ps
Refering-URL: http://graphics.lcs.mit.edu/~kaybee/ips/homepage.html
Root-URL: 
Title: Interactive Ray Tracing  
Author: Kavita Bala Julie Dorsey Seth Teller 
Note: This technical memorandum (TM) has been made available free of charge from the MIT Laboratory for Computer Science, at www.lcs.mit.edu.  
Affiliation: MIT Computer Graphics Group  
Date: Bounded-Error  March, 1998  
Pubnum: MIT LCS TR-748  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> ADELSON, S. J., AND HODGES, L. F. </author> <title> Generating Exact Ray-Traced Animation Frames by Reprojection. </title> <journal> IEEE Computer Graphics and Applications 15, </journal> <month> 3 (May </month> <year> 1995), </year> <pages> 43-52. </pages>
Reference-contexts: Chapman et al. [7, 8] restrict the model to be polygonal, and use the trajectory of the viewpoint through the scene to compute continuous intersection information of rays with the polygons. Badt [5], Adelson and Hodges <ref> [1] </ref>, and Mark et al.[26] reuse pixels from the previous frame to render pixels in the current frame. Adelson and Hodges apply a 3D warp to pixels from reference images to the current image.
Reference: [2] <author> AMANATIDES, J. </author> <title> Ray Tracing with Cones. </title> <note> In Computer Graphics (SIGGRAPH '84 Proceedings) (July 1984), </note> <author> p. </author> <title> ray tracing spheres and polygons with circular conical rays. summary in Graphics Interface '84, </title> <editor> p. </editor> <booktitle> 97-8Published as Computer Graphics (SIGGRAPH '84 Proceedings), </booktitle> <volume> volume 18, number 3. </volume> <pages> 15 </pages>
Reference-contexts: In practice we have not been able to observe any artifacts from screen-space interpolation. Several researchers have accelerated ray tracing by exploiting image coherence <ref> [3, 2, 23] </ref>. The traditional problem with screen-space interpolation is that it is difficult to predict the accuracy of interpolation.
Reference: [3] <author> AMANATIDES, J., AND FOURNIER, A. </author> <title> Ray Casting using Divide and Conquer in Screen Space. </title> <booktitle> In Intl. Conf. on Engineering and Computer Graphics. </booktitle> <address> Beijing, China, </address> <month> Aug. </month> <year> 1984. </year>
Reference-contexts: For ray tracing, several effective techniques have been developed: adaptive 3D spatial hierarchies [15], beam-tracing for polyhedral scenes [22], cone-tracing <ref> [3] </ref>, and ray classification [4]. <p> In practice we have not been able to observe any artifacts from screen-space interpolation. Several researchers have accelerated ray tracing by exploiting image coherence <ref> [3, 2, 23] </ref>. The traditional problem with screen-space interpolation is that it is difficult to predict the accuracy of interpolation.
Reference: [4] <author> ARVO, J., AND KIRK, D. </author> <title> Fast Ray Tracing by Ray Classification. </title> <note> In Computer Graphics (SIGGRAPH '87 Proceedings) (July 1987), </note> <author> p. </author> <title> five dimensional space subdivision. </title> <booktitle> Published as Computer Graphics (SIGGRAPH '87 Proceedings), volume 21, number 4also in Tutorial: Computer Graphics: Image Synthesis, </booktitle> <publisher> Computer Society Press, </publisher> <address> Washington, </address> <year> 1988, </year> <pages> pp. 196-205. </pages>
Reference-contexts: For ray tracing, several effective techniques have been developed: adaptive 3D spatial hierarchies [15], beam-tracing for polyhedral scenes [22], cone-tracing [3], and ray classification <ref> [4] </ref>.
Reference: [5] <author> BADT, JR., S. </author> <title> Two Algorithms for Taking Advantage of Temporal Coherence in Ray Tracing. </title> <booktitle> The Visual Computer 4, </booktitle> <address> 3 (Sept. </address> <year> 1988), </year> <pages> 123-132. </pages>
Reference-contexts: Chapman et al. [7, 8] restrict the model to be polygonal, and use the trajectory of the viewpoint through the scene to compute continuous intersection information of rays with the polygons. Badt <ref> [5] </ref>, Adelson and Hodges [1], and Mark et al.[26] reuse pixels from the previous frame to render pixels in the current frame. Adelson and Hodges apply a 3D warp to pixels from reference images to the current image.
Reference: [6] <author> BRIERE, N., AND POULIN, P. </author> <title> Hierarchical View-dependent Structures for Interactive Scene Manipulation. </title> <booktitle> In Computer Graphics (SIG-GRAPH '96 Proceedings) (Aug. </booktitle> <year> 1996), </year> <pages> pp. 83-90. </pages>
Reference-contexts: One advantage of the linetree representation for radiance is that it explicitly keeps track of the ray trees used to generate the radiance function. These ray trees are very similar to those used for interactive scene manipulation <ref> [31, 6] </ref>. Integrating such systems would allow dynamic editing of the model being viewed while also allowing dynamic viewing.
Reference: [7] <author> CHAPMAN, J., CALVERT, T. W., AND DILL, J. </author> <title> Exploiting Temporal Coherence in Ray Tracing. </title> <booktitle> In Proceedings of Graphics Interface '90 (Toronto, </booktitle> <address> Ontario, </address> <month> May </month> <year> 1990), </year> <booktitle> Canadian Information Processing Society, </booktitle> <pages> pp. 196-204. </pages>
Reference-contexts: Chapman et al. <ref> [7, 8] </ref> restrict the model to be polygonal, and use the trajectory of the viewpoint through the scene to compute continuous intersection information of rays with the polygons.
Reference: [8] <author> CHAPMAN, J., CALVERT, T. W., AND DILL, J. </author> <title> Spatio-Temporal Coherence in Ray Tracing. </title> <booktitle> In Proceedings of Graphics Interface '91 (Calgary, </booktitle> <address> Alberta, </address> <month> June </month> <year> 1991), </year> <booktitle> Canadian Information Processing Society, </booktitle> <pages> pp. 101-8. </pages>
Reference-contexts: Chapman et al. <ref> [7, 8] </ref> restrict the model to be polygonal, and use the trajectory of the viewpoint through the scene to compute continuous intersection information of rays with the polygons.
Reference: [9] <author> CHEN, S. E., RUSHMEIER, H., MILLER, G., AND TURNER, D. </author> <title> A Progressive Multi-Pass Method for Global Illumination. </title> <booktitle> Computer Graphics (SIGGRAPH '91 Proceedings) 25, </booktitle> <month> 4 (July </month> <year> 1991), </year> <pages> 165-174. </pages>
Reference-contexts: At the other end of the spectrum, radiosity algorithms [16] trade scene complexity for interactivity. Radiosity algorithms support interactive viewing, but typically render only diffuse, polygonal environments and require a pre-processing phase. Other hybrid systems <ref> [9, 32, 33, 35, 38] </ref> have tried to bridge the gap between these two extremes. However, the view-dependent component of radiance has been extremely expensive to compute, and ray tracing image quality is traditionally associated with off-line rendering algorithms that are too slow for interactive use.
Reference: [10] <author> COOK, R. L. </author> <title> Stochastic Sampling in Computer Graphics. </title> <journal> ACM Transactions on Graphics 5, </journal> <month> 1 (Jan. </month> <year> 1986), </year> <month> 51-72. </month> <title> also in Tutorial: Computer Graphics: Image Synthesis, </title> <publisher> Computer Society Press, </publisher> <address> Washington, </address> <year> 1988, </year> <pages> pp. 283-304. </pages> <note> Comments on article in ACM TOG, </note> <editor> v. </editor> <volume> 9, </volume> <editor> n. </editor> <volume> 2, </volume> <pages> p 233-243. </pages>
Reference-contexts: Radiosity systems have developed explicit error bounds [20, 25] to make this trade-off. Ray tracing computations typically use super-sampling and stochastic techniques <ref> [28, 10] </ref> to estimate and decrease the error in computed radiance. In this paper, we present analytical error bounds for interpolation error.
Reference: [11] <author> DIEFENBACH, P., AND BADLER, N. </author> <title> Multi-Pass Pipeline Rendering: Realism for Dynamic Environments. </title> <booktitle> In Proceedings of the 1997 Symposium on Interactive 3D Graphics (1997), </booktitle> <pages> pp. </pages> <month> 59-70,186-7. </month>
Reference-contexts: Radiance [38] uses ray tracing and computes diffuse inter-reflection lazily, producing very high quality images by sparsely and non-uniformly sampling the slowly-varying diffuse-interreflections [38]. Radiance also includes an accuracy threshold to guide sampling; gradient information is used to guide sampling density [36]. A recent multi-pass rendering system <ref> [11] </ref> uses multiple passes of the standard graphics hardware to obtain images of higher quality than that ordinarily available using graphics hardware. The drawback of this system is that it approximates pixel assignment by resorting to discretizing the scene into polygons, and has no correctness guarantees.
Reference: [12] <author> DRETTAKIS, G., AND SILLION, F. X. </author> <title> Interactive Update of Global Illumination Using a Line-Space Hierarchy. </title> <booktitle> In Computer Graphics (SIGGRAPH '97 Proceedings) (August 3-8 1997), </booktitle> <pages> pp. 57-64. </pages>
Reference: [13] <author> GLASSNER, A., Ed. </author> <title> Introduction to Ray Tracing. </title> <publisher> Academic Press, </publisher> <address> Palo Alto, CA, </address> <year> 1989. </year>
Reference-contexts: A standard ray tracer uses intersection computations for both these operations, which dominate performance <ref> [13] </ref>. In designing and building an interactive ray-tracing environment we have made several contributions: * Radiance approximation using 4D interpolants: Our system builds interpolants lazily to approximate the radiance computed by a Whitted ray tracer. <p> In Section 7, we discuss the system implementation and other optimizations to improve performance, and present performance results in Section 8. Finally, we present future work and conclude in Section 9. 2 Related Work Several researchers have focused on the problem of improving the performance of global illumination algorithms <ref> [13, 33] </ref>. For ray tracing, several effective techniques have been developed: adaptive 3D spatial hierarchies [15], beam-tracing for polyhedral scenes [22], cone-tracing [3], and ray classification [4]. <p> Lack of space prevents us from referring to all the work that has been done in this field, but a good summary of these algorithms can be found in <ref> [13, 14] </ref>. 2 2.1 Acceleration of radiance computation Systems that accelerate rendering by approximating radiance can be categorized on the basis of the shading models they use, the correctness guarantees provided for computed radiance, and their use of pre-processing. <p> Radiance is computed along the sixteen extremal rays from the leaf's front face to its back face. Additional information about the ray trees along each of the sixteen paths is maintained, as in <ref> [34, 13] </ref>. Using the ray trees, and the computed radiance values, the error predicate determines if the samples collected represent a valid interpolant. If so, the radiance for that pixel is quadrilinearly interpolated from the interpolant. <p> There were a number of such optimizations. To speed up intersect computations, the base ray tracer uses kd-trees for spatial subdivision of the scene <ref> [13] </ref>. Marching rays through the kd-tree is accelerated by associating a quadtree with each face of the kd-tree cell. The quadtrees also cache the path taken by the last ray landing in that quadtree, and this cache has a 85% hit rate.
Reference: [14] <author> GLASSNER, A. </author> <title> Principles of Digital Image Synthesis. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Francisco, CA, </address> <year> 1995. </year>
Reference-contexts: Lack of space prevents us from referring to all the work that has been done in this field, but a good summary of these algorithms can be found in <ref> [13, 14] </ref>. 2 2.1 Acceleration of radiance computation Systems that accelerate rendering by approximating radiance can be categorized on the basis of the shading models they use, the correctness guarantees provided for computed radiance, and their use of pre-processing.
Reference: [15] <author> GLASSNER, A. S. </author> <title> Space Subdivision for Fast Ray Tracing. </title> <journal> IEEE Computer Graphics and Applications 4, </journal> <volume> 10 (1984), </volume> <pages> 15-22. </pages>
Reference-contexts: Finally, we present future work and conclude in Section 9. 2 Related Work Several researchers have focused on the problem of improving the performance of global illumination algorithms [13, 33]. For ray tracing, several effective techniques have been developed: adaptive 3D spatial hierarchies <ref> [15] </ref>, beam-tracing for polyhedral scenes [22], cone-tracing [3], and ray classification [4].
Reference: [16] <author> GORAL, C. M., TORRANCE, K. E., GREENBERG, D. P., AND BATTAILE, B. </author> <title> Modeling the Interaction of Light Between Diffuse Surfaces. </title> <journal> Computer Graphics (Proc. </journal> <volume> Siggraph '84) 18, 3 (1984), </volume> <pages> 213-222. </pages>
Reference-contexts: Ray tracers typically support specular and diffuse reflectance functions, and generalized primitives, but at the expense of viewing the output image from a fixed viewpoint. At the other end of the spectrum, radiosity algorithms <ref> [16] </ref> trade scene complexity for interactivity. Radiosity algorithms support interactive viewing, but typically render only diffuse, polygonal environments and require a pre-processing phase. Other hybrid systems [9, 32, 33, 35, 38] have tried to bridge the gap between these two extremes.
Reference: [17] <author> GORTLER, S., GRZESZCZUK, R., SZELISKI, R., AND COHEN, M. </author> <note> The Lumigraph. In Computer Graphics (SIGGRAPH '96 Proceedings) (August 4-9 1996). </note>
Reference-contexts: Our techniques can be integrated with several other approaches to produce faster and better rendering systems: Interpolants could be built in an off-line rendering phase and re-used in an on-line phase to accelerate walkthroughs. They can also be used to accelerate generation of light fields [24] or Lumigraphs <ref> [17] </ref>. The error predicate, which identifies regions of high radiance variation, could be used to guide intelligent super-sampling. The rest of the paper is organized as follows: In Section 2 related work is presented, with a discussion of how our system is different. <p> The drawback of this system is that it approximates pixel assignment by resorting to discretizing the scene into polygons, and has no correctness guarantees. Image-based rendering (IBR) systems, such as the light field [24] and the Lumigraph <ref> [17] </ref>, have similarities to our system in that they build 4D radiance information that is quadrilinearly interpolated to approximate radiance. However, IBR systems typically have a data acquisition pre-processing phase, and are not intended for interactive rendering. <p> all the rays that intersect some volume of 3D space, then the linetree data structure and the interpolant building mechanism are presented. 4 4.1 Ray parameterization Every ray intersecting an object o, can be parameterized by the ray's four intercepts ha; b; c; di with two parallel faces surrounding o <ref> [34, 24, 17] </ref>, as shown in Figure 2. To cover the entire space of rays that could intersect o, six pairs of parallel faces (called facepairs) surrounding the object are considered. Each facepair is built by expanding the corresponding faces of the object's bounding box appropriately.
Reference: [18] <author> HAINES, E., AND GREENBERG, D. </author> <title> The Light Buffer: A Shadow-Testing Accelerator. </title> <booktitle> IEEE Computer Graphics & Applications 6 (September 1986), </booktitle> <pages> 6-16. </pages>
Reference-contexts: Therefore, marching a ray through the kd-tree structure is very fast. Also, shadow caches associated with objects accelerate shadow computations for shadowed objects. Extensions such as the adaptive shadow testing [37], and Light Buffers <ref> [18] </ref> would improve performance but have not been implemented yet in our ray tracer. 8.2 Test scene The data reported below was obtained for the art-room scene shown in Plate 2.
Reference: [19] <author> HAINES, E. A., AND WALLACE, J. R. </author> <title> Shaft Culling for Efficient Ray-Traced Radiosity. </title> <booktitle> In Photorealistic Rendering in Computer Graphics (Proceedings of the Second Eurographics Workshop on Rendering) (New York, 1994), </booktitle> <publisher> Springer-Verlag, </publisher> <address> p. </address> <note> also in SIGGRAPH '91 Frontiers in Rendering course notes and via FTP from princeton.edu:/pub/Graphics/Papers. </note>
Reference-contexts: The error predicate conservatively determines validity for each possible discontinuity in the following way: Geometry changes and Shadows: If the ray trees of the sixteen extremal rays are not isomorphic, the interpolant is not valid. Occluders: Occluders are detected using a variant of shaft-culling <ref> [19, 34] </ref>. <p> Our algorithm reprojects linetrees from a previous frame to the new viewpoint; for most pixels this quickly determines the linetree that covers the pixel. Our algorithm is conservative: it never incorrectly assigns a linetree to a pixel. To guarantee correct pixel assignment, linetree faces are shaft-culled <ref> [19] </ref> with respect to the current viewpoint. Repro-jection accelerates pixel assignment by replacing multiple intersect operations for pixels by a single shaft cull against the corresponding linetree. <p> In Figure 9, an object that was not visible in the previous frame (the small sphere) occludes objects in the current frame. We conservatively determine visibility by not reprojecting linetrees when they might be occluded. This condition is detected by shaft-culling <ref> [19] </ref> each reprojected linetree cell against the current viewpoint. Only one shaft-cull is required per linetree cell, which for reasonably-sized linetree cells is faster than intersecting a ray for each covered pixel.
Reference: [20] <author> HANRAHAN, P., SALZMAN, D., AND AUPPERLE, L. </author> <title> A Rapid Hierarchical Radiosity Algorithm. </title> <journal> Computer Graphics (Proc. </journal> <volume> Siggraph '91) 25, 4 (1991), </volume> <pages> 197-206. </pages>
Reference-contexts: Radiosity systems have developed explicit error bounds <ref> [20, 25] </ref> to make this trade-off. Ray tracing computations typically use super-sampling and stochastic techniques [28, 10] to estimate and decrease the error in computed radiance. In this paper, we present analytical error bounds for interpolation error.
Reference: [21] <author> HECKBERT, P. </author> <title> The Mathematics of Quadric Surface Rendering and SOID. </title> <type> Tech. Rep. 3-D Technical Memo No. 4, </type> <institution> New York Institute of Technology, </institution> <month> July </month> <year> 1984. </year>
Reference-contexts: M combines an arbitrary rotation matrix , and a scaling matrix S. S scales by s x on the x 0 axis, s y on the y 0 axis, and 1 on the z 0 axis, without loss of generality <ref> [21] </ref>. This scaling and rotation allow the paraboloid to approximate any convex surface near the intersection point. s x and s y are equal to half the reciprocal curvature of the represented surface along the x 0 and y 0 axes respectively.
Reference: [22] <author> HECKBERT, P., AND HANRAHAN, P. </author> <title> Beam Tracing Polygonal Objects. </title> <journal> Computer Graphics (Proc. </journal> <volume> Siggraph '84) 18, 3 (1984), </volume> <pages> 119-127. </pages>
Reference-contexts: Finally, we present future work and conclude in Section 9. 2 Related Work Several researchers have focused on the problem of improving the performance of global illumination algorithms [13, 33]. For ray tracing, several effective techniques have been developed: adaptive 3D spatial hierarchies [15], beam-tracing for polyhedral scenes <ref> [22] </ref>, cone-tracing [3], and ray classification [4]. <p> Using the constraint that ~p xn lies on both the incident ray and the paraboloid we can solve for ~p xn in terms of (a; b; c; d). The constraint equation is a quadratic in z <ref> [22] </ref>, which can be solved to second order.
Reference: [23] <author> KOLB, C. </author> <note> RayShade Homepage http://www-graphics.stanford.edu/ cek/rayshade/. </note>
Reference-contexts: In practice we have not been able to observe any artifacts from screen-space interpolation. Several researchers have accelerated ray tracing by exploiting image coherence <ref> [3, 2, 23] </ref>. The traditional problem with screen-space interpolation is that it is difficult to predict the accuracy of interpolation.
Reference: [24] <author> LEVOY, M., AND HANRAHAN, P. </author> <title> Light Field Rendering. </title> <note> In Computer Graphics (SIGGRAPH '96 Proceedings) (August 4-9 1996). </note>
Reference-contexts: Our techniques can be integrated with several other approaches to produce faster and better rendering systems: Interpolants could be built in an off-line rendering phase and re-used in an on-line phase to accelerate walkthroughs. They can also be used to accelerate generation of light fields <ref> [24] </ref> or Lumigraphs [17]. The error predicate, which identifies regions of high radiance variation, could be used to guide intelligent super-sampling. The rest of the paper is organized as follows: In Section 2 related work is presented, with a discussion of how our system is different. <p> The drawback of this system is that it approximates pixel assignment by resorting to discretizing the scene into polygons, and has no correctness guarantees. Image-based rendering (IBR) systems, such as the light field <ref> [24] </ref> and the Lumigraph [17], have similarities to our system in that they build 4D radiance information that is quadrilinearly interpolated to approximate radiance. However, IBR systems typically have a data acquisition pre-processing phase, and are not intended for interactive rendering. <p> all the rays that intersect some volume of 3D space, then the linetree data structure and the interpolant building mechanism are presented. 4 4.1 Ray parameterization Every ray intersecting an object o, can be parameterized by the ray's four intercepts ha; b; c; di with two parallel faces surrounding o <ref> [34, 24, 17] </ref>, as shown in Figure 2. To cover the entire space of rays that could intersect o, six pairs of parallel faces (called facepairs) surrounding the object are considered. Each facepair is built by expanding the corresponding faces of the object's bounding box appropriately. <p> Therefore, hash tables can be used to avoid storing duplicate ray trees. As a result, virtually all the memory allocated by the system is used to store interpolants. A compression technique similar to that presented by Levoy and Hanrahan <ref> [24] </ref> might be useful to compress inter-polants. However, we do not expect to achieve the same compression rates, because our adaptive subdivision effectively compresses regions of ray space already. Recursive shaft culls The reprojection algorithm shaft-culls linetrees from the previous frame.
Reference: [25] <author> LISCHINSKI, D., SMITS, B., AND GREENBERG, D. P. </author> <title> Bounds and Error Estimates for Radiosity. </title> <booktitle> In Proceedings of SIGGRAPH '94 (Orlando, </booktitle> <address> Florida, </address> <month> July 24-29, </month> <year> 1994) </year> <month> (July </month> <year> 1994), </year> <editor> A. Glassner, Ed., </editor> <booktitle> Computer Graphics Proceedings, Annual Conference Series, ACM SIGGRAPH, </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 67-74. </pages> <note> ISBN 0-89791-667-0. </note>
Reference-contexts: Radiosity systems have developed explicit error bounds <ref> [20, 25] </ref> to make this trade-off. Ray tracing computations typically use super-sampling and stochastic techniques [28, 10] to estimate and decrease the error in computed radiance. In this paper, we present analytical error bounds for interpolation error.
Reference: [26] <author> MARK, W., MCMILLAN, L., AND BISHOP, G. </author> <title> Post-Rendering 3D Warping. </title> <booktitle> In Proceedings of the 1997 Symposium on Interactive 3D Graphics (1997), </booktitle> <pages> pp. </pages> <month> 7-16,180. </month>
Reference-contexts: Each pixel receives the radiance that would be computed at some reprojected point guaranteed to lie inside the pixel (though not necessarily at the center). This algorithm speeds up the first level rays from the eye to the screen but does not accelerate shading computation. Mark et al. <ref> [26] </ref> also apply a 3D warp to pixels, but they treat their reference image as a mesh and warp the mesh triangles to the current image.
Reference: [27] <author> NIMEROFF, J., DORSEY, J., AND RUSHMEIER, H. </author> <title> A Framework for Global Illumination in Animated Environments. </title> <booktitle> In 6th Annual Euro-graphics Workshop on Rendering (June 12-14 1995), </booktitle> <pages> pp. 223-236. </pages>
Reference-contexts: Additionally, these systems do not compute any bounds on error introduced by approximating radiance or pixel assignment, and they constrain the viewer to lie outside the convex hull of the scene. Nimeroff et al. use IBR techniques to warp pre-rendered images in animated environments with moving viewpoints <ref> [27] </ref>, but do not guarantee error. 2.2 Algorithms that approximate pixel assignment Algorithms that exploit temporal coherence to approximate pixel assignment can be categorized by the assumptions they make about the scene, and the correctness guarantees they provide.
Reference: [28] <author> PAINTER, J., AND SLOAN, K. </author> <title> Antialiased Ray Tracing by Adaptive Progressive Refinement. </title> <note> In Computer Graphics (SIGGRAPH '89 Proceedings) (July 1989), </note> <author> p. </author> <title> adaptive stochastic sampling. </title> <booktitle> Published as Computer Graphics (SIGGRAPH '89 Proceedings), </booktitle> <volume> volume 23, number 3. </volume>
Reference-contexts: Radiosity systems have developed explicit error bounds [20, 25] to make this trade-off. Ray tracing computations typically use super-sampling and stochastic techniques <ref> [28, 10] </ref> to estimate and decrease the error in computed radiance. In this paper, we present analytical error bounds for interpolation error.
Reference: [29] <author> PHARR, M., KOLB, C., GERSHBEIN, R., AND HANRAHAN, P. </author> <title> Rendering Complex Scenes with Memory-Coherent Ray Tracing. </title> <booktitle> In Computer Graphics (SIGGRAPH '97 Proceedings) (August 3-8 1997), </booktitle> <pages> pp. 101-8. </pages>
Reference: [30] <author> PHILLIPS, G. M., AND TAYLOR, P. J. </author> <title> Theory and Application of Numerical Analysis. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1996. </year>
Reference-contexts: The constant and linear terms of radiance are approximated well by quadrilinear interpolation, therefore, these terms are not considered in the error computation. Instead, we focus on the contribution of the quadratic term (cubic and higher terms are dominated by the quadratic term <ref> [30] </ref>). The total error bound for a linetree cell is computed by recursively bounding the error at each node of the ray tree and aggregating these node errors, appropriately weighted by the node's weight.
Reference: [31] <author> SEQUIN, C. H., AND SMYRL, E. K. </author> <title> Parameterized Ray Tracing. </title> <note> In Computer Graphics (SIGGRAPH '89 Proceedings) (July 1989), </note> <author> p. </author> <title> store ray tree data to allow quick material changes. </title> <booktitle> Published as Computer Graphics (SIGGRAPH '89 Proceedings), </booktitle> <volume> volume 23, number 3. </volume>
Reference-contexts: In both cases, interpolation would be incorrect (indicated by the cross). 6 Ray trees Ray trees <ref> [31, 34] </ref> keep track of all objects, lights and occluders that contribute to the radiance of a particular ray, both directly and indirectly through reflections and refractions. <p> One advantage of the linetree representation for radiance is that it explicitly keeps track of the ray trees used to generate the radiance function. These ray trees are very similar to those used for interactive scene manipulation <ref> [31, 6] </ref>. Integrating such systems would allow dynamic editing of the model being viewed while also allowing dynamic viewing.
Reference: [32] <author> SILLION, F., AND PUECH, C. </author> <title> A General Two-Pass Method Integrating Specular and Diffuse Reflection. </title> <booktitle> Computer Graphics (SIGGRAPH '89 Proceedings) 23, </booktitle> <month> 3 (July </month> <year> 1989), </year> <pages> 335-344. 16 </pages>
Reference-contexts: At the other end of the spectrum, radiosity algorithms [16] trade scene complexity for interactivity. Radiosity algorithms support interactive viewing, but typically render only diffuse, polygonal environments and require a pre-processing phase. Other hybrid systems <ref> [9, 32, 33, 35, 38] </ref> have tried to bridge the gap between these two extremes. However, the view-dependent component of radiance has been extremely expensive to compute, and ray tracing image quality is traditionally associated with off-line rendering algorithms that are too slow for interactive use.
Reference: [33] <author> SILLION, F., AND PUECH, C. </author> <title> Radiosity and Global Illumination. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Francisco, CA, </address> <year> 1994. </year>
Reference-contexts: At the other end of the spectrum, radiosity algorithms [16] trade scene complexity for interactivity. Radiosity algorithms support interactive viewing, but typically render only diffuse, polygonal environments and require a pre-processing phase. Other hybrid systems <ref> [9, 32, 33, 35, 38] </ref> have tried to bridge the gap between these two extremes. However, the view-dependent component of radiance has been extremely expensive to compute, and ray tracing image quality is traditionally associated with off-line rendering algorithms that are too slow for interactive use. <p> In Section 7, we discuss the system implementation and other optimizations to improve performance, and present performance results in Section 8. Finally, we present future work and conclude in Section 9. 2 Related Work Several researchers have focused on the problem of improving the performance of global illumination algorithms <ref> [13, 33] </ref>. For ray tracing, several effective techniques have been developed: adaptive 3D spatial hierarchies [15], beam-tracing for polyhedral scenes [22], cone-tracing [3], and ray classification [4].
Reference: [34] <author> TELLER, S., BALA, K., AND DORSEY, J. </author> <title> Conservative Radiance Interpolants for Ray Tracing. </title> <booktitle> In Seventh Eurographics Workshop on Rendering (June 15-17 1996). </booktitle>
Reference-contexts: Some of these systems also implicitly approximate pixel assignment by polygonalizing models, or by using images instead of geometry. Teller et al. present an algorithm to speed up shading of a Whitted ray tracer (without texturing) by building 4D interpolants that are reused to satisfy radiance queries <ref> [34] </ref>. While their algorithm identifies radiance discontinuities, it does not correctly deal with radiance non-linearities, nor does it accelerate pixel assignment. Radiance [38] uses ray tracing and computes diffuse inter-reflection lazily, producing very high quality images by sparsely and non-uniformly sampling the slowly-varying diffuse-interreflections [38]. <p> When the user's viewpoint changes, the system renders the scene at the highest speed possible, while guaranteeing that radiance discontinuities are not interpolated over. 4 Radiance Interpolants In this section, we briefly summarize the mechanisms to build and use interpolants (Refer to <ref> [34] </ref> for more details). <p> all the rays that intersect some volume of 3D space, then the linetree data structure and the interpolant building mechanism are presented. 4 4.1 Ray parameterization Every ray intersecting an object o, can be parameterized by the ray's four intercepts ha; b; c; di with two parallel faces surrounding o <ref> [34, 24, 17] </ref>, as shown in Figure 2. To cover the entire space of rays that could intersect o, six pairs of parallel faces (called facepairs) surrounding the object are considered. Each facepair is built by expanding the corresponding faces of the object's bounding box appropriately. <p> Radiance is computed along the sixteen extremal rays from the leaf's front face to its back face. Additional information about the ray trees along each of the sixteen paths is maintained, as in <ref> [34, 13] </ref>. Using the ray trees, and the computed radiance values, the error predicate determines if the samples collected represent a valid interpolant. If so, the radiance for that pixel is quadrilinearly interpolated from the interpolant. <p> Incorrect interpolation arises in two possible ways: * Interpolation over a discontinuity in the radiance function (due to changes in scene geometry, shadows, or oc cluding objects) * Quadrilinear interpolation in regions with higher order radiance terms (due to diffuse or specular peaks) In this section, we discuss results from <ref> [34] </ref>, and then focus on our new contributions, presenting a complete solution for the error predicate. 5.1 Radiance discontinuities An interpolant is invalid if it interpolates radiance over a radiance discontinuity. <p> In both cases, interpolation would be incorrect (indicated by the cross). 6 Ray trees Ray trees <ref> [31, 34] </ref> keep track of all objects, lights and occluders that contribute to the radiance of a particular ray, both directly and indirectly through reflections and refractions. <p> The error predicate conservatively determines validity for each possible discontinuity in the following way: Geometry changes and Shadows: If the ray trees of the sixteen extremal rays are not isomorphic, the interpolant is not valid. Occluders: Occluders are detected using a variant of shaft-culling <ref> [19, 34] </ref>.
Reference: [35] <author> WALLACE, J., COHEN, M., AND GREENBERG, D. </author> <title> A Two-Pass Solution to the Rendering Equation: A Synthesis of Ray Tracing and Radiosity MethodsComputer Graphics (SIGGRAPH '87 Proceedings) 21, </title> <month> 4 (July </month> <year> 1987), </year> <pages> 311-320. </pages>
Reference-contexts: At the other end of the spectrum, radiosity algorithms [16] trade scene complexity for interactivity. Radiosity algorithms support interactive viewing, but typically render only diffuse, polygonal environments and require a pre-processing phase. Other hybrid systems <ref> [9, 32, 33, 35, 38] </ref> have tried to bridge the gap between these two extremes. However, the view-dependent component of radiance has been extremely expensive to compute, and ray tracing image quality is traditionally associated with off-line rendering algorithms that are too slow for interactive use.
Reference: [36] <author> WARD, G., AND HECKBERT, P. </author> <title> Irradience Gradients. </title> <booktitle> In Rendering in Computer Graphics (Proceedings of the Third Eurographics Workshop on Rendering) (Bristol, </booktitle> <address> United Kingdom, May 1992), </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Radiance [38] uses ray tracing and computes diffuse inter-reflection lazily, producing very high quality images by sparsely and non-uniformly sampling the slowly-varying diffuse-interreflections [38]. Radiance also includes an accuracy threshold to guide sampling; gradient information is used to guide sampling density <ref> [36] </ref>. A recent multi-pass rendering system [11] uses multiple passes of the standard graphics hardware to obtain images of higher quality than that ordinarily available using graphics hardware.
Reference: [37] <author> WARD, G. J. </author> <title> Adaptive Shadow Testing for Ray Tracing. </title> <booktitle> In Photorealistic Rendering in Computer Graphics (Proceedings of the Second Eurographics Workshop on Rendering) (New York, 1994), </booktitle> <publisher> Springer-Verlag, </publisher> <editor> p. </editor> <title> avoid shooting rays at lights determined to not affect perception of image. </title>
Reference-contexts: Therefore, marching a ray through the kd-tree structure is very fast. Also, shadow caches associated with objects accelerate shadow computations for shadowed objects. Extensions such as the adaptive shadow testing <ref> [37] </ref>, and Light Buffers [18] would improve performance but have not been implemented yet in our ray tracer. 8.2 Test scene The data reported below was obtained for the art-room scene shown in Plate 2.
Reference: [38] <author> WARD, G. J., RUBINSTEIN, F. M., AND CLEAR, R. D. </author> <title> A Ray Tracing Solution for Diffuse Interreflection. </title> <booktitle> In Computer Graphics (SIG-GRAPH '88 Proceedings) (Aug. </booktitle> <year> 1988), </year> <pages> pp. 85-92. </pages> <booktitle> Published as Computer Graphics (SIGGRAPH '88 Proceedings), </booktitle> <volume> volume 22, number 4. </volume>
Reference-contexts: At the other end of the spectrum, radiosity algorithms [16] trade scene complexity for interactivity. Radiosity algorithms support interactive viewing, but typically render only diffuse, polygonal environments and require a pre-processing phase. Other hybrid systems <ref> [9, 32, 33, 35, 38] </ref> have tried to bridge the gap between these two extremes. However, the view-dependent component of radiance has been extremely expensive to compute, and ray tracing image quality is traditionally associated with off-line rendering algorithms that are too slow for interactive use. <p> While their algorithm identifies radiance discontinuities, it does not correctly deal with radiance non-linearities, nor does it accelerate pixel assignment. Radiance <ref> [38] </ref> uses ray tracing and computes diffuse inter-reflection lazily, producing very high quality images by sparsely and non-uniformly sampling the slowly-varying diffuse-interreflections [38]. Radiance also includes an accuracy threshold to guide sampling; gradient information is used to guide sampling density [36]. <p> While their algorithm identifies radiance discontinuities, it does not correctly deal with radiance non-linearities, nor does it accelerate pixel assignment. Radiance <ref> [38] </ref> uses ray tracing and computes diffuse inter-reflection lazily, producing very high quality images by sparsely and non-uniformly sampling the slowly-varying diffuse-interreflections [38]. Radiance also includes an accuracy threshold to guide sampling; gradient information is used to guide sampling density [36]. A recent multi-pass rendering system [11] uses multiple passes of the standard graphics hardware to obtain images of higher quality than that ordinarily available using graphics hardware. <p> The system interactively renders ray traced images and refines error. There are many opportunities for extending and applying this work. Our system samples the view-dependent base ray tracing component of radiance, while systems such as Radiance <ref> [38] </ref> sample view-independent diffuse inter-reflection. It would be interesting to extend our system to support a more complete shading model, including diffuse inter-reflection and generalized BRDFs. One advantage of the linetree representation for radiance is that it explicitly keeps track of the ray trees used to generate the radiance function.
Reference: [39] <author> WHITTED, T. </author> <title> An Improved Illumination Model for Shaded Display. </title> <journal> CACM 23, </journal> <volume> 6 (1980), </volume> <pages> 343-349. 17 </pages>
Reference-contexts: Global illumination algorithms generate high quality images by evaluating radiance, a five-dimensional function. To achieve reasonable performance, illumination systems trade freedom of viewer motion for both scene complexity and accuracy in different ways. On one end of the spectrum, ray tracers <ref> [39] </ref> compute high quality view-dependent images, while compromising on interactivity. Ray tracers typically support specular and diffuse reflectance functions, and generalized primitives, but at the expense of viewing the output image from a fixed viewpoint. At the other end of the spectrum, radiosity algorithms [16] trade scene complexity for interactivity. <p> However, the view-dependent component of radiance has been extremely expensive to compute, and ray tracing image quality is traditionally associated with off-line rendering algorithms that are too slow for interactive use. In this paper, we present an interactive system that uses interpolants to accelerate classical Whitted ray tracing <ref> [39] </ref>. The goal of our system is to provide an interactive ray tracing environment in which the user moves around freely as the system renders ray-trace quality images. <p> Figure 1 shows a system block diagram. Our ray tracer implements a classical Whitted ray tracing model with texturing <ref> [39] </ref>. For each object surface, there is an associated collection of interpolants representing the radiance from that surface. These interpolants are stored in 4D linetrees, which allow an efficient lookup of an interpolant for any particular ray. <p> To evaluate the speed of the system, we use a simple cost model based on Figure 1. 8.1 Base ray tracer For performance, we compare our system to a ray tracer that implements classical Whitted ray tracing with textures <ref> [39] </ref>. This ray tracer is in fact the same ray tracer that our system uses for non-interpolated pixels. Both our system and 12 the base ray tracer support the same Whitted shading model, augmented with textures. They support convex primitives such as cubes, spheres, cylinders, cones, disks and polygons.
References-found: 39

