URL: ftp://ftp.cs.clemson.edu/techreports/94-109.ps.Z
Refering-URL: http://www.cs.clemson.edu/html/research/techrpt.shtml
Root-URL: http://www.cs.clemson.edu
Title: An Extensible Program Representation for Object-Oriented Software 1  
Author: Brian A. Malloy John D. McGregor Anand Krishnaswamy Murali Medikonda 
Address: Clemson, SC 29634-1906  
Affiliation: Dept. of Computer Science Clemson University  
Abstract: An extensible representation for object-oriented programs is presented. It is based on the concept of a program dependency graph and elaborated to include both control flow and data flow information. The representation takes advantage of the basic incremental philosophy of the object-oriented approach to develop a more compact representation that is useful with practical programs. The basic approach reported here provides a static view of an object-oriented program. The approach can be expanded to provide dynamic information for tools such as interactive debuggers and other runtime tools. The outline of this extension is also presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> The common object request broker: </editor> <title> Architecture and specification. </title> <type> Technical report, </type> <institution> Object Management Group and X/Open, </institution> <year> 1992. </year>
Reference: [2] <author> Hiralal Agrawal and Joseph R. Horgan. </author> <title> Dynamic program slicing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 246-256, </pages> <year> 1990. </year>
Reference: [3] <author> Korel B. </author> <title> The program dependence graph in static program testing. </title> <journal> Information Processing Letters, </journal> <volume> 24(2) </volume> <pages> 103-108, </pages> <month> Jan </month> <year> 1987. </year>
Reference-contexts: Control and data dependence information are used to select test data and determine test set adequacy <ref> [3] </ref>, and to extend data flow testing techniques [10]. Control and data dependence information are also used to generate reduced test sets for programs [11]. Several techniques for regression testing [5][15][20] use control and data dependence information to determine the retesting required after changes are made to a program.
Reference: [4] <author> Ryder B.G. </author> <title> Constructing the call graph of a program. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(3) </volume> <pages> 216-225, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: A call graph is an interprocedural program representation where nodes represent individual procedures and edges represent call sites. Each edge is labeled with the actual parameters associated with that call site. A program's call graph can be constructed efficiently <ref> [4] </ref> and used for many applications such as program maintenance and interprocedural data flow analysis. However, the call graph is a flow-insensitive structure since it does not incorporate control flow information.
Reference: [5] <author> D. Binkley. </author> <title> Using semantic differencing to reduce the cost of regression testing. </title> <booktitle> In Proceedings of the Conference on Software Maintenance '92, </booktitle> <pages> pages 41-50, </pages> <year> 1992. </year>
Reference: [6] <author> Callahan D. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> In Proceedings of SIGPLAN'88 Conf. Programming Language Design and Implementation, </booktitle> <pages> pages 47-56, </pages> <year> 1988. </year>
Reference-contexts: The OPDG is designed to handle interprocedural analysis and at the same time, represent the concepts of the object-oriented paradigm in a clear subtle way. The Unified Interprocedural Graph (UIG) [12] extracts the important information incorporated into previous representations: the call graph, SDG, the Program Summary Graph <ref> [6] </ref>, and the Interprocedural Flow Graph (IFG) [14]. Algorithms developed for the previous representations are adapted to develop the UIG. The UIG provides savings in both storage and access times over the storage and access times required for the individual representations.
Reference: [7] <author> Hiralal Agrawal; Richard A. DeMillo and Eugene H. Spafford. </author> <title> Dynamic slicing in the presence of unconstrained pointers. </title> <booktitle> In Proceedings of the Fourth Symposium on Testing, Analysis and Verification (TAV4). ACM/IEEE-CS, </booktitle> <pages> pages 60-73, </pages> <year> 1991. </year>
Reference: [8] <author> David Duke and Roger Duke. </author> <title> Towards a semantics for object-z. In VDM '90: VDM and Z, </title> <year> 1990. </year>
Reference-contexts: There are several efforts underway to provide more specific representations for object-oriented programs. These efforts include the Interface Definition Language (IDL)[1] defined by the Object Management Group (OMG) and Object Z <ref> [8] </ref>. Object Z is an extension of the formal specification language Z that adds basic object-oriented concepts to the existing language. It can be used to develop program descriptions written in a mathematically manipulable format.
Reference: [9] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C ++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference: [10] <author> E. Duesterwald; R. Gupta and M.L. Soffa. </author> <title> Rigorous data flow testing through output influences. </title> <booktitle> In Proceedings of the 2nd Irvine Software Symposium (ISS'92), </booktitle> <pages> pages 131-145, </pages> <year> 1992. </year>
Reference-contexts: Control and data dependence information are used to select test data and determine test set adequacy [3], and to extend data flow testing techniques <ref> [10] </ref>. Control and data dependence information are also used to generate reduced test sets for programs [11]. Several techniques for regression testing [5][15][20] use control and data dependence information to determine the retesting required after changes are made to a program. The PDG has also proven useful for debugging purposes.
Reference: [11] <author> Rajiv Gupta and Mary Lou Soffa. </author> <title> Automatic generation of a compact test suite. </title> <booktitle> In Proceedings of the Twelfth IFIP World Computer Congress, </booktitle> <year> 1992. </year>
Reference-contexts: Control and data dependence information are used to select test data and determine test set adequacy [3], and to extend data flow testing techniques [10]. Control and data dependence information are also used to generate reduced test sets for programs <ref> [11] </ref>. Several techniques for regression testing [5][15][20] use control and data dependence information to determine the retesting required after changes are made to a program. The PDG has also proven useful for debugging purposes.
Reference: [12] <author> Mary Jean Harrold and Brian Malloy. </author> <title> A unified interprocedural program representation for a maintenance environment. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(6) </volume> <pages> 584-593, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The SDG does not directly incorporate the important object-oriented concepts including inheritance, polymorphism and dynamic binding. The OPDG is designed to handle interprocedural analysis and at the same time, represent the concepts of the object-oriented paradigm in a clear subtle way. The Unified Interprocedural Graph (UIG) <ref> [12] </ref> extracts the important information incorporated into previous representations: the call graph, SDG, the Program Summary Graph [6], and the Interprocedural Flow Graph (IFG) [14]. Algorithms developed for the previous representations are adapted to develop the UIG.
Reference: [13] <author> Mary Jean Harrold and John D. McGregor. </author> <title> Hierarchical incremental testing. </title> <type> Technical Report TR91-111, </type> <institution> Department of Computer Science, Clemson University, </institution> <year> 1991. </year>
Reference-contexts: An object created from that class might be one specific minivan owned by one of the authors. Object-oriented design techniques use an incremental approach to software development which in turn supports an incremental approach to validation <ref> [13] </ref>. This incremental approach results in pieces of code being reused in several class definitions and this in turn results in a smaller source code for a given project. Families of programs can be grown by incrementally adding to the functionality of one system to build another. <p> Subclass representations do not have representations for methods defined in the superclass. This is not a complete static representation since the implementations of the methods are not included; however, certain algorithms such as the Hierarchical Incremental Testing (HIT) <ref> [13] </ref> procedure can provide useful information given this level of representation. The second layer is the Control Dependence Subgraph (CDS). Each method's implementation is included in this representation. Since this is still a static representation, some information cannot be completely resolved.
Reference: [14] <author> Mary Jean Harrold and Mary Lou Soffa. </author> <title> Computation of interprocedural definition and use dependencies. </title> <booktitle> In Proceedings of IEEE Computer Society 1990 Int. Conf. on Comput. Languages, </booktitle> <address> New Orleans, LA, </address> <pages> pages 297-306, </pages> <year> 1990. </year>
Reference-contexts: The Unified Interprocedural Graph (UIG) [12] extracts the important information incorporated into previous representations: the call graph, SDG, the Program Summary Graph [6], and the Interprocedural Flow Graph (IFG) <ref> [14] </ref>. Algorithms developed for the previous representations are adapted to develop the UIG. The UIG provides savings in both storage and access times over the storage and access times required for the individual representations.
Reference: [15] <author> Rajiv Gupta; Mary Jean Harrold and Mary Lou Soffa. </author> <title> An approach to regression testing using slicing. </title> <booktitle> In Proceedings of the Conference on Software Maintenance '92, </booktitle> <pages> pages 299-308, </pages> <year> 1992. </year>
Reference: [16] <author> Ferrante J; Ottenstein K and Warren J.D. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-331, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Any technique proposing to provide a complete representation of such a system must account for this time-sensitive aspect of the system. 2.2 Program Dependency Graphs A program dependency graph (PDG) <ref> [16] </ref> is a graphical representation of a program that encodes both control dependencies and data dependencies into a single structure. The graph contains nodes that repre 2 sent statements or regions of code, and edges that represent either control dependence or data dependence information. <p> Furthermore, the call graph does not express important object-oriented concepts such as inheritance, polymorphism and dynamic binding. The OPDG incorporates these important 13 concepts into the PDG using the edges and vertices described in Figure 2 and discussed in section 3.3. The Program Dependence Graph (PDG) <ref> [16] </ref> has proven to be a valuable tool for program analysis since it encodes both control and data dependence information into a single representation. The PDG has been used for program optimization, parallelization, testing, static and dynamic slicing, debugging and browsing.
Reference: [17] <author> Tim Korson and John McGregor. </author> <title> Object-oriented software design: A tutorial. </title> <journal> Communications of the ACM, </journal> <volume> 33(9):40 | 60, </volume> <year> 1990. </year> <month> 17 </month>
Reference-contexts: introduction here. Korson and McGregor <ref> [17] </ref> provide a survey of basic terms and concepts. We will discuss the special characteristics of object technology that influenced our development of the representation. Classes and objects are central to the development of object-oriented software. <p> Consider the declarations: // C is a class in a hierarchy // c1 and c2 are instance variables C *c1; Both c1 and c2 have a static type of class C. However, c1 can have a different dynamic type <ref> [17] </ref>, if there are subclasses inheriting from C, since c1 can be made to point to an instance of C or any of its subclasses. Whenever a message is sent to an object whose static type is the class C, the Call edge terminates at the Class header for C. <p> a free standing procedure is also represented by a Call edge, but this edge terminates at the Procedure header, since the procedure is not bound to any class. 10 3.4.3 Representing Polymorphism A polymorphic reference in an object-oriented language can, over time, refer to instances of more than one class <ref> [17] </ref>. Thus a polymorphic reference has both a static and a dynamic type associated with it. Polymorphism is associated with dynamic binding since the the binding of a polymorphic message to the code to be executed in response to the call is accomplished dynamically.
Reference: [18] <author> Panos E. Livadas and Stephen Croll. </author> <title> Program slicing. </title> <type> Technical Report SERC-TR-61-F, </type> <institution> University of Florida, Gainesville, </institution> <year> 1992. </year>
Reference-contexts: The main concern in performing interprocedural analysis, is that of handling parameters and preserving the calling context. Parameters are handled with additional edges and vertices in the SDG and in the UIG. Horwitz et al present an algorithm in [24] using linkage grammars. Livadas and Scroll <ref> [18] </ref> present an alternate method to calculate the calling context, based on the call order in the program. The OPDG builds on the work presented in [18] and incorporates information into the Class header to save the calling context of the calls. <p> Horwitz et al present an algorithm in [24] using linkage grammars. Livadas and Scroll <ref> [18] </ref> present an alternate method to calculate the calling context, based on the call order in the program. The OPDG builds on the work presented in [18] and incorporates information into the Class header to save the calling context of the calls. Parameters are handled by redefining the Call edge to engulf the control and data flow between the call site and the called method/procedure.
Reference: [19] <author> Mary Jean Harrold; Brian Malloy and Gregg Rothermel. </author> <title> Efficient construction of program dependence graphs. </title> <booktitle> ACM International Symposium on Software Testing and Analysis, </booktitle> <volume> 18(3) </volume> <pages> 160-70, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The part of the PDG that represents control dependence information is the control dependence subgraph (CDS) and the part that represents data dependence information is the data dependence subgraph (DDS). For the purpose of this work, we use the extended version of the PDG <ref> [19] </ref>, that incorporates control flow information, as well as control dependence (CDS) and data dependence (DDS). The construction of the CDS accepts an abstract syntax tree for a procedure P and outputs the CDS for P [19]. <p> For the purpose of this work, we use the extended version of the PDG <ref> [19] </ref>, that incorporates control flow information, as well as control dependence (CDS) and data dependence (DDS). The construction of the CDS accepts an abstract syntax tree for a procedure P and outputs the CDS for P [19]. Figure 1 depicts a program segment and the corresponding CDS and DDS for this program segment. A CDS contains several types of nodes. In figure 1, nodes such as S1, S3 and S4, represent statements in the program. <p> Its representation is similar to the entry vertex of a procedure as given in <ref> [19] </ref> or [24]. The Method header adds additional meaning to the representation by encapsulating information such as the class to which it belongs, data attributes of the class and parameter translation from actual to formal and vice-versa. <p> A brief description for each type of edge is given below. * Control Edges Flow Edges These are uni-directional edges that depict the explicit flow of control in the program. Implicit flow is denoted using the left-to-right notation of <ref> [19] </ref>. In figure 4, for the example code segment given, implicit flow of control is represented between the statements S20, S21 and S22 using the left-to-right notation. <p> The PDG has been used for program optimization, parallelization, testing, static and dynamic slicing, debugging and browsing. The PDG has been extended to incorporate control flow information <ref> [19] </ref>, expanding the viable applications of the PDG. However, even with this extension, the PDG does not permit interprocedural analysis and therefore does not permit analysis across procedure boundaries. Furthermore, the PDG does not possess the expressiveness to represent such important object-oriented concepts as inheritance, polymorphism and dynamic binding.
Reference: [20] <author> Gregg Rothermel and Mary Jean Harrold. </author> <title> A safe, efficient algorithm for regression test selection. </title> <booktitle> In Proceedings of the Conference on Software Maintenance '93, </booktitle> <pages> pages 358-367, </pages> <year> 1993. </year>
Reference: [21] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: The resulting representation of an object-oriented program is more compact and easier to understand. 15 5.2 Other Representations for Object-Oriented Software Object-oriented analysis and design methods use a number of models with accompanying graphical notations. For example, Rumbaugh et al <ref> [21] </ref> uses three different models, each with its own notation, to represent the software system. These models are at a higher level than the code and do not have sufficient detail to support our goals for this representation.
Reference: [22] <author> E. Schatz and B.G. Ryder. </author> <title> Directed tracing to detect race conditions. </title> <type> Technical Report LCSR-TR-176, </type> <institution> Laboratory for Computer Science Research, Rutgers University, </institution> <year> 1992. </year>
Reference-contexts: Several techniques for regression testing [5][15][20] use control and data dependence information to determine the retesting required after changes are made to a program. The PDG has also proven useful for debugging purposes. Both static [7][2] and dynamic <ref> [22] </ref> slicing techniques require control and data dependence information. (elaborate on this a bit more) Since the region nodes in a PDG summarize control dependence information for all of those statements in the region, the PDG is useful for parallelization of a program.
Reference: [23] <author> Bjarne Stroustrup. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <note> second edition, </note> <year> 1991. </year>
Reference: [24] <author> Horwitz S; Reps T and Binkley D. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> Jan </month> <year> 1990. </year> <pages> 18 19 </pages>
Reference-contexts: Its representation is similar to the entry vertex of a procedure as given in [19] or <ref> [24] </ref>. The Method header adds additional meaning to the representation by encapsulating information such as the class to which it belongs, data attributes of the class and parameter translation from actual to formal and vice-versa. The Method header forms one of the end points of the Class Membership edge. <p> Messages in object-oriented programs contain parameters to transfer information and hence handling of parameters is another problem we solve in this paper. The traditional technique of handling parameter flow is to have additional edges between the call site and the called procedure, connecting the actual and corresponding formal parameters <ref> [24] </ref>. Since a number of messages are exchanged in an object-oriented system, this technique makes the representation cluttered and difficult to manage due to the additional edges. Each message includes the Call edge, and along with it, at least one edge for each parameter (two for a pass-by-reference parameter). <p> However, even with this extension, the PDG does not permit interprocedural analysis and therefore does not permit analysis across procedure boundaries. Furthermore, the PDG does not possess the expressiveness to represent such important object-oriented concepts as inheritance, polymorphism and dynamic binding. The System Dependence Graph (SDG) <ref> [24] </ref> combines PDGs for individual procedures with additional information to permit the computation of an interprocedural slice of the program. To construct the system dependence graph, nodes are added to a procedure's dependence graph to model parameter passing, in a manner similar to the construction of the OPDG. <p> The main concern in performing interprocedural analysis, is that of handling parameters and preserving the calling context. Parameters are handled with additional edges and vertices in the SDG and in the UIG. Horwitz et al present an algorithm in <ref> [24] </ref> using linkage grammars. Livadas and Scroll [18] present an alternate method to calculate the calling context, based on the call order in the program. The OPDG builds on the work presented in [18] and incorporates information into the Class header to save the calling context of the calls.
References-found: 24

