URL: http://www.cs.wustl.edu/~schmidt/C++-USENIX-90.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/ACE-members.html
Root-URL: 
Email: schmidt@cs.wustl.edu  
Phone: (TEL) 314-935-7538, (FAX) 314-935-7302  
Title: GPERF A Perfect Hash Function Generator  
Author: Douglas C. Schmidt 
Address: St. Louis 63130  
Affiliation: Department of Computer Science Washington University,  
Web: http://www.cs.wustl.edu/~schmidt/  
Abstract: An earlier version of this paper appeared in the 2 nd USENIX C++ Conference in San Francisco, California, April 1990. Abstract gperf is a software-tool generating-tool designed to automate the generation of perfect hash functions. This paper describes the features, algorithms, and object-oriented design and implementation strategies incorporated in gperf. It also presents the results from an empirical comparison between gperf-generated recognizers and other popular techniques for reserved word lookup. gperf is distributed with the GNU libg++ library and is used to generate the keyword recognizers for the GNU C and GNU C++ compilers. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Lesk and E. Schmidt, </author> <title> LEX A Lexical Analyzer Generator. </title> <institution> Bell Laboratories, </institution> <address> Murray Hill, N.J., </address> <note> Unix Programmers Manual ed. </note>
Reference-contexts: Keywords are inserted into the set once, usually at compile-time. gperf is a freely available perfect hash function generator written in C++ that automatically constructs perfect hash functions from a user-supplied list of keywords. It was designed in the spirit of utilities like flex, lex <ref> [1] </ref> and yacc [2] to remove the drudgery associated with constructing time and space efficient keyword recognizers by hand. gperf translates an n element user-specified keyword list (called the keyfile) into source code containing a k element lookup table and a pair of functions, phash and in word set. phash uniquely <p> Resolving this collision and generating a perfect hash function for C++ reserved words requires adding an additional character to the keysig via the `-k' command-line option with parameters hash_value = asso_values [keyword [0]] + asso_values [keyword <ref> [1] </ref>] + asso_values [keyword [length - 1]] + length; Users use the `-k' option to control the generated hash function's contents by explicitly specifying the keyword index positions to use as keysig elements. The default is `-k 1,$', where the '$' represents the keyword's final character. <p> 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 2, 9, 5, 1, 11, 0, 12, 2, 12, 5, 0, 0, 12, -; return asso_values [str [2]] + asso_values [str <ref> [1] </ref>]; - const struct months * is_month (const char *str, int len) - static const struct months wordlist [] = - -"september", 9, 30, 30-, -"june", 6, 30, 30-, -"april", 4, 30, 30-, -"january", 1, 31, 31-, -"march", 3, 31, 31-, -"december", 12, 31, 31-, -"july", 7, 31, 31-, -"august", 8, <p> Since the command-line option `-k 2, 3' was enabled, phash returns an unsigned int value 6 - const struct months *rw; switch (key) - case 0: rw = &wordlist [0]; break; case 1: rw = &wordlist <ref> [1] </ref>; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; <p> == *rw-&gt;name && !strcmp (str + 1, rw-&gt;name + 1)) return rw; return 0; - calculated by indexing the keysig characters (in this case ASCII values of the second and third characters) from its str argument into the local static array asso values (C arrays start at 0, so str <ref> [1] </ref> is actually the second character). The two resulting numbers are added together to compute str's hash value. The asso values array is constructed by gperf; it maps the user-defined keywords onto unique hash values (additional details are described in Section 4.1.2).
Reference: [2] <author> S. Johnson, </author> <title> YACC Yet another Compiler Compiler. </title> <institution> Bell Laboratories, </institution> <address> Murray Hill, N.J., </address> <note> Unix Programmers Manual ed. </note>
Reference-contexts: Keywords are inserted into the set once, usually at compile-time. gperf is a freely available perfect hash function generator written in C++ that automatically constructs perfect hash functions from a user-supplied list of keywords. It was designed in the spirit of utilities like flex, lex [1] and yacc <ref> [2] </ref> to remove the drudgery associated with constructing time and space efficient keyword recognizers by hand. gperf translates an n element user-specified keyword list (called the keyfile) into source code containing a k element lookup table and a pair of functions, phash and in word set. phash uniquely maps keywords in <p> 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 2, 9, 5, 1, 11, 0, 12, 2, 12, 5, 0, 0, 12, -; return asso_values [str <ref> [2] </ref>] + asso_values [str [1]]; - const struct months * is_month (const char *str, int len) - static const struct months wordlist [] = - -"september", 9, 30, 30-, -"june", 6, 30, 30-, -"april", 4, 30, 30-, -"january", 1, 31, 31-, -"march", 3, 31, 31-, -"december", 12, 31, 31-, -"july", 7, <p> Since the command-line option `-k 2, 3' was enabled, phash returns an unsigned int value 6 - const struct months *rw; switch (key) - case 0: rw = &wordlist [0]; break; case 1: rw = &wordlist [1]; break; case 2: rw = &wordlist <ref> [2] </ref>; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break;
Reference: [3] <author> R. M. Stallman, </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <publisher> GCC 2.7.2 ed. </publisher>
Reference-contexts: It has been used to generate reserved keyword recognizers in lexical analyzers for several production and research compilers and language processing tools, including GNU C, GNU C++, GNU Pascal, GNU Modula 3, and GNU indent <ref> [3] </ref>. <p> However, a good compiler may generate assembly code implementing a binary-search-of-labels scheme if the switch statement's case labels are sparse compared to the range between the smallest and largest case labels <ref> [3] </ref>. This technique saves a great deal of space by not emitting unnecessary empty array locations or jump-table slots. <p> Since the command-line option `-k 2, 3' was enabled, phash returns an unsigned int value 6 - const struct months *rw; switch (key) - case 0: rw = &wordlist [0]; break; case 1: rw = &wordlist [1]; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist <ref> [3] </ref>; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break;
Reference: [4] <author> D. E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> vol. </volume> <month> 1: </month> <title> Searching and Sorting. </title> <address> Reading, MA: </address> <publisher> Addison Wesley, </publisher> <year> 1973. </year>
Reference-contexts: Common examples include sorted and unsorted arrays and linked lists, AVL trees, optimal binary search trees, digital search tries, deterministic finite-state automata, and various hash table schemes, such as open addressing and bucket chaining <ref> [4] </ref>. Different implementations offer trade-offs between memory utilization and search time efficiency. For example, an n element sorted array is space efficient, though the average-and worst-case time complexity for retrieval operations using binary search on a sorted array is proportional to O (log n) [4]. <p> as open addressing and bucket chaining <ref> [4] </ref>. Different implementations offer trade-offs between memory utilization and search time efficiency. For example, an n element sorted array is space efficient, though the average-and worst-case time complexity for retrieval operations using binary search on a sorted array is proportional to O (log n) [4]. Conversely, chained hash table implementations locate a table entry in constant, i.e., O (1), time on the average. However, they typically impose additional memory overhead for link pointers and/or unused hash table buckets and also exhibit O (n 2 ) worst-case performance [4]. <p> array is proportional to O (log n) <ref> [4] </ref>. Conversely, chained hash table implementations locate a table entry in constant, i.e., O (1), time on the average. However, they typically impose additional memory overhead for link pointers and/or unused hash table buckets and also exhibit O (n 2 ) worst-case performance [4]. <p> Minimal perfect hash functions provide a theoretically optimal time and space efficient solution for static search sets <ref> [4] </ref>. <p> This format style is useful for building keyword set recognizers that do not possess any associated attributes. For example, a perfect hash function for frequently occurring English words efficiently filters out uninformative words such as the, as, and this, etc. from consideration in a key-word-in-context indexing application <ref> [4] </ref>. Again, as with lex and yacc, all text in the optional third auxiliary code section is included verbatim into the generated output file, starting immediately after the final %% and extending to the end of the keyfile. <p> was enabled, phash returns an unsigned int value 6 - const struct months *rw; switch (key) - case 0: rw = &wordlist [0]; break; case 1: rw = &wordlist [1]; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist <ref> [4] </ref>; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist [11]; break; <p> This class has been incorporated into the GNU libg++ stream library [17] and the ACE network programming tookit [18]. * Hash Table: This class provides a search set implemented via double hashing <ref> [4] </ref>. During program initialization gperf uses an instance of this class to detect keyfile entries that are guaranteed to produce duplicate hash values. These duplicates occur whenever keywords possess both identical keysigs and identical lengths, e.g., the double and delete collision described in Section 4.1.2.
Reference: [5] <author> C. R. Cook and R. R. Oldehoeft, </author> <title> A Letter Oriented Minimal Perfect Hashing Function, </title> <journal> SIGPLAN Notices, </journal> <volume> vol. 17, </volume> <pages> pp. 18-27, </pages> <month> Sept. </month> <year> 1982. </year>
Reference-contexts: However, they do possess the perfect property, since at most one string comparison is required to determine if a string is in the table. There are two main reasons for generating non-minimal hash functions: 1. Generating non-minimal perfect functions may be substantially faster than generating minimal perfect hash functions <ref> [5, 6] </ref>. 2. Non-minimal perfect hash functions may also execute faster than minimal ones when searching for elements that are not in the table. <p> In Figure 1 example, this auxiliary code provides a test driver that is conditionally compiled if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Issues Many articles describe perfect hashing [9, 6, 10, 11] and minimal perfect hashing algorithms <ref> [7, 12, 5, 13, 14] </ref>. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail [15]. This section describes the data structures, algorithms, output format, and reusable components. gperf is written in approximately 4,500 lines of C++ source code. <p> After experimenting with gperf on many keyfiles it appears that such worst-case behavior occurs rarely in practice. Many perfect hash function generation algorithms are sensitive to the order that keywords are considered <ref> [5, 6] </ref>. If the `-o' command-line option is enabled, gperf mitigates this effect by optionally reordering the keywords before invoking the main algorithm. This reordering is done in a two stage pre-pass that applies two common heuristics described by Cichelli. <p> value 6 - const struct months *rw; switch (key) - case 0: rw = &wordlist [0]; break; case 1: rw = &wordlist [1]; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist <ref> [5] </ref>; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist [11]; break; default: return 0; - if (*str == <p> generating recognizers for the 15,400 line MEDLINE keyfile input, because the size of the state machine is too large for their internal DFA state tables. 6 Limitations 6.1 Current Compromises Several other hash function generation algorithms utilize some form of backtracking when searching for a perfect or minimal perfect solution <ref> [5, 7, 8] </ref>. For example, Cichelli's algorithm recursively attempts to find an associated values configuration that uniquely maps all n keywords to distinct integers in the range 1::n.
Reference: [6] <author> A. Tharp and M. </author> <title> Brain, Using Tries to Eliminate Pattern Collisions in Perfect Hashing, </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> vol. 6, no. 2, </volume> <pages> pp. 329-347, </pages> <year> 1994. </year>
Reference-contexts: However, they do possess the perfect property, since at most one string comparison is required to determine if a string is in the table. There are two main reasons for generating non-minimal hash functions: 1. Generating non-minimal perfect functions may be substantially faster than generating minimal perfect hash functions <ref> [5, 6] </ref>. 2. Non-minimal perfect hash functions may also execute faster than minimal ones when searching for elements that are not in the table. <p> In Figure 1 example, this auxiliary code provides a test driver that is conditionally compiled if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Issues Many articles describe perfect hashing <ref> [9, 6, 10, 11] </ref> and minimal perfect hashing algorithms [7, 12, 5, 13, 14]. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail [15]. <p> After experimenting with gperf on many keyfiles it appears that such worst-case behavior occurs rarely in practice. Many perfect hash function generation algorithms are sensitive to the order that keywords are considered <ref> [5, 6] </ref>. If the `-o' command-line option is enabled, gperf mitigates this effect by optionally reordering the keywords before invoking the main algorithm. This reordering is done in a two stage pre-pass that applies two common heuristics described by Cichelli. <p> switch (key) - case 0: rw = &wordlist [0]; break; case 1: rw = &wordlist [1]; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist <ref> [6] </ref>; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist [11]; break; default: return 0; - if (*str == *rw-&gt;name && !strcmp (str + 1, rw-&gt;name <p> One approach is to replace gperf's current algorithm with more exhaustive approaches <ref> [8, 6] </ref>. Due to gperf's object-oriented program design, such modifications will not disrupt the overall program structure. The perfect hash function generation module, class Gen Perf, is independent from other program components; it represents only about 10 percent of gperf's overall lines of source code.
Reference: [7] <author> R. J. Cichelli, </author> <title> Minimal Perfect Hash Functions Made Simple, </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 1, </volume> <pages> pp. 17-19, </pages> <year> 1980. </year>
Reference-contexts: Non-minimal perfect hash functions may also execute faster than minimal ones when searching for elements that are not in the table. This situation often occurs when recognizing reserved words in program source code <ref> [7] </ref>. * Near-Perfect Hash Functions : Near-perfect hash functions do not possess the perfect property, since they allow non-unique keyword hash values [8] (they may or may not possess the minimal property, however). This technique is a compromise that trades increased generated-code-execution-time for decreased function-generation-time. <p> In Figure 1 example, this auxiliary code provides a test driver that is conditionally compiled if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Issues Many articles describe perfect hashing [9, 6, 10, 11] and minimal perfect hashing algorithms <ref> [7, 12, 5, 13, 14] </ref>. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail [15]. This section describes the data structures, algorithms, output format, and reusable components. gperf is written in approximately 4,500 lines of C++ source code. <p> Keysigs are multisets since they may contain multiple occurrences of certain characters. This approach differs from other perfect hash function methods, where only the keyword's first and last characters, plus its length, are examined when computing the hash value <ref> [7] </ref>. The generated hash function properly handles keywords shorter than a specified index position by skipping characters that exceed the keyword's length. Users may also instruct gperf to include all of a keyword's characters in its keysig via the `-k*' option. <p> Additional details and rationalizations for these reordering heuristics are discussed in <ref> [7, 8] </ref>. 4.3 Output Format keyfile depicted in Figure 1. Execution time was negligible on a Sun 4/260, i.e., 0.0 user and 0.0 system time. <p> &wordlist [0]; break; case 1: rw = &wordlist [1]; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist <ref> [7] </ref>; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist [11]; break; default: return 0; - if (*str == *rw-&gt;name && !strcmp (str + 1, rw-&gt;name + 1)) return rw; return 0; - <p> generating recognizers for the 15,400 line MEDLINE keyfile input, because the size of the state machine is too large for their internal DFA state tables. 6 Limitations 6.1 Current Compromises Several other hash function generation algorithms utilize some form of backtracking when searching for a perfect or minimal perfect solution <ref> [5, 7, 8] </ref>. For example, Cichelli's algorithm recursively attempts to find an associated values configuration that uniquely maps all n keywords to distinct integers in the range 1::n.
Reference: [8] <author> M. Brain and A. Tharp, </author> <title> Near-perfect Hashing of Large Word Sets, </title> <journal> Software Practice and Experience, </journal> <volume> vol. 19, no. 10, </volume> <pages> pp. 967-978, </pages> <year> 1989. </year>
Reference-contexts: This situation often occurs when recognizing reserved words in program source code [7]. * Near-Perfect Hash Functions : Near-perfect hash functions do not possess the perfect property, since they allow non-unique keyword hash values <ref> [8] </ref> (they may or may not possess the minimal property, however). This technique is a compromise that trades increased generated-code-execution-time for decreased function-generation-time. <p> Additional details and rationalizations for these reordering heuristics are discussed in <ref> [7, 8] </ref>. 4.3 Output Format keyfile depicted in Figure 1. Execution time was negligible on a Sun 4/260, i.e., 0.0 user and 0.0 system time. <p> &wordlist [1]; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist <ref> [8] </ref>; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist [11]; break; default: return 0; - if (*str == *rw-&gt;name && !strcmp (str + 1, rw-&gt;name + 1)) return rw; return 0; - calculated by indexing the keysig characters (in <p> generating recognizers for the 15,400 line MEDLINE keyfile input, because the size of the state machine is too large for their internal DFA state tables. 6 Limitations 6.1 Current Compromises Several other hash function generation algorithms utilize some form of backtracking when searching for a perfect or minimal perfect solution <ref> [5, 7, 8] </ref>. For example, Cichelli's algorithm recursively attempts to find an associated values configuration that uniquely maps all n keywords to distinct integers in the range 1::n. <p> One approach is to replace gperf's current algorithm with more exhaustive approaches <ref> [8, 6] </ref>. Due to gperf's object-oriented program design, such modifications will not disrupt the overall program structure. The perfect hash function generation module, class Gen Perf, is independent from other program components; it represents only about 10 percent of gperf's overall lines of source code.
Reference: [9] <author> R. Sprugnoli, </author> <title> Perfect hashing functions: A single probe retrieving method for static sets, </title> <journal> Communications of the ACM, </journal> <pages> pp. 841-850, </pages> <month> Nov. </month> <year> 1977. </year>
Reference-contexts: In Figure 1 example, this auxiliary code provides a test driver that is conditionally compiled if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Issues Many articles describe perfect hashing <ref> [9, 6, 10, 11] </ref> and minimal perfect hashing algorithms [7, 12, 5, 13, 14]. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail [15]. <p> &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist <ref> [9] </ref>; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist [11]; break; default: return 0; - if (*str == *rw-&gt;name && !strcmp (str + 1, rw-&gt;name + 1)) return rw; return 0; - calculated by indexing the keysig characters (in this case ASCII values of the second
Reference: [10] <author> G. V. Cormack, R. Horspool, and M. Kaiserwerth, </author> <title> Practical Perfect Hashing, </title> <journal> Computer Journal, </journal> <volume> vol. 28, </volume> <pages> pp. 54-58, </pages> <month> Jan. </month> <year> 1985. </year>
Reference-contexts: In Figure 1 example, this auxiliary code provides a test driver that is conditionally compiled if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Issues Many articles describe perfect hashing <ref> [9, 6, 10, 11] </ref> and minimal perfect hashing algorithms [7, 12, 5, 13, 14]. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail [15]. <p> &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist <ref> [10] </ref>; break; case 11: rw = &wordlist [11]; break; default: return 0; - if (*str == *rw-&gt;name && !strcmp (str + 1, rw-&gt;name + 1)) return rw; return 0; - calculated by indexing the keysig characters (in this case ASCII values of the second and third characters) from its str argument
Reference: [11] <author> M. Dietzfelbinger, A. Karlin, K. Mehlhorn, F. M. auf der Heid, H. Rohnert, and R. Tarjan, </author> <title> Dynamic Perfect Hashing: Upper and Lower Bounds, </title> <journal> SIAM Journal of Computing, </journal> <volume> vol. 23, </volume> <pages> pp. 738-761, </pages> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: In Figure 1 example, this auxiliary code provides a test driver that is conditionally compiled if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Issues Many articles describe perfect hashing <ref> [9, 6, 10, 11] </ref> and minimal perfect hashing algorithms [7, 12, 5, 13, 14]. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail [15]. <p> &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist <ref> [11] </ref>; break; default: return 0; - if (*str == *rw-&gt;name && !strcmp (str + 1, rw-&gt;name + 1)) return rw; return 0; - calculated by indexing the keysig characters (in this case ASCII values of the second and third characters) from its str argument into the local static array asso values
Reference: [12] <author> G. Jaeschke, </author> <title> Reciprocal Hashing: A Method for Generating Minimal Perfect Hashing Functions, </title> <journal> Communications of the ACM, </journal> <volume> vol. 24, </volume> <pages> pp. 829-833, </pages> <month> Dec. </month> <year> 1981. </year>
Reference-contexts: In Figure 1 example, this auxiliary code provides a test driver that is conditionally compiled if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Issues Many articles describe perfect hashing [9, 6, 10, 11] and minimal perfect hashing algorithms <ref> [7, 12, 5, 13, 14] </ref>. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail [15]. This section describes the data structures, algorithms, output format, and reusable components. gperf is written in approximately 4,500 lines of C++ source code.
Reference: [13] <author> T. Sager, </author> <title> A Polynomial Time Generator for Minimal Perfect Hash Functions, </title> <journal> Communications of the ACM, </journal> <volume> vol. 28, </volume> <pages> pp. 523-532, </pages> <month> Dec. </month> <year> 1985. </year>
Reference-contexts: In Figure 1 example, this auxiliary code provides a test driver that is conditionally compiled if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Issues Many articles describe perfect hashing [9, 6, 10, 11] and minimal perfect hashing algorithms <ref> [7, 12, 5, 13, 14] </ref>. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail [15]. This section describes the data structures, algorithms, output format, and reusable components. gperf is written in approximately 4,500 lines of C++ source code.
Reference: [14] <author> C. C. Chang, </author> <title> A Scheme for Constructing Ordered Minimal Perfect Hashing Functions, </title> <journal> Information Sciences, </journal> <volume> vol. 39, </volume> <pages> pp. 187-195, </pages> <year> 1986. </year>
Reference-contexts: In Figure 1 example, this auxiliary code provides a test driver that is conditionally compiled if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Issues Many articles describe perfect hashing [9, 6, 10, 11] and minimal perfect hashing algorithms <ref> [7, 12, 5, 13, 14] </ref>. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail [15]. This section describes the data structures, algorithms, output format, and reusable components. gperf is written in approximately 4,500 lines of C++ source code.
Reference: [15] <author> D. C. Schmidt, GPERF: </author> <title> A Perfect Hash Function Generator, </title> <booktitle> in Proceedings of the 2 nd C++ Conference, </booktitle> <address> (San Francisco, California), </address> <pages> pp. 87-102, </pages> <publisher> USENIX, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail <ref> [15] </ref>. This section describes the data structures, algorithms, output format, and reusable components. gperf is written in approximately 4,500 lines of C++ source code.
Reference: [16] <author> Bjarne Stroustrup, </author> <title> The C++ Programming Language, 2 nd Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: This section describes the data structures, algorithms, output format, and reusable components. gperf is written in approximately 4,500 lines of C++ source code. C++ was chosen as the implementation language since it supports data abstraction and information hiding better than C, while still maintaining C's efficiency and expressiveness <ref> [16] </ref>. gperf's three main phases for generating a perfect or near-perfect hash function are: 1. Process command-line options, read keywords and attributes (the input format is described in Section 3), and initialize internal data structures (described in Sec tion 4.1). 2.
Reference: [17] <author> D. Lea, libg++, </author> <title> the GNU C++ Library, </title> <booktitle> in Proceedings of the 1 st C++ Conference, </booktitle> <address> (Denver, </address> <publisher> CO), </publisher> <pages> pp. 243-256, </pages> <publisher> USENIX, </publisher> <month> Oct. </month> <year> 1988. </year>
Reference-contexts: never appear; the check is still useful, however, since it avoids calling the string comparison routine when the str's first letter does not match any of the keywords in the lookup table). 4.4 Reusable Components gperf is constructed from reusable components that also serve as base-classes in a forest-style library <ref> [17] </ref>. Each of these classes evolved bottom-up from special-purpose utilities into reusable software components. Several noteworthy reusable classes include the following abstract data types: * Bool Array: Earlier versions of gperf were instrumented with a run-time code profiler. <p> A recursive auxiliary function, `Read Buffer::rec read, insures only one call is made to the free store allocator per input line read, i.e., there is no need for reallocating and resizing buffers dynamically. This class has been incorporated into the GNU libg++ stream library <ref> [17] </ref> and the ACE network programming tookit [18]. * Hash Table: This class provides a search set implemented via double hashing [4]. During program initialization gperf uses an instance of this class to detect keyfile entries that are guaranteed to produce duplicate hash values. <p> A complete PATRICA trie implementation is available in the GNU libg++ class library distribution <ref> [17] </ref>. * binary.exe: a carefully coded binary search routine that minimizes the number of complete string comparisons. * comp-flex.exe: a flex-generated recognizer created with the default `-cem' options, providing the highest degree of table compression.
Reference: [18] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: This class has been incorporated into the GNU libg++ stream library [17] and the ACE network programming tookit <ref> [18] </ref>. * Hash Table: This class provides a search set implemented via double hashing [4]. During program initialization gperf uses an instance of this class to detect keyfile entries that are guaranteed to produce duplicate hash values.
Reference: [19] <author> J. Kegler, </author> <title> A Polynomial Time Generator for Minimal Perfect Hash Functions, </title> <journal> Communications of the ACM, </journal> <volume> vol. 29, no. 6, </volume> <pages> pp. 556-557, </pages> <year> 1986. </year>
Reference-contexts: However, they are not necessarily advantageous for production-quality applications unless the resulting executable code speed is competitive with typical alternative implementations. In fact, it has been argued that there are no circumstances where perfect hashing proves worthwhile, compared with other common static search set methods <ref> [19] </ref>. To compare the efficacy of the gperf-generated perfect hash functions against other common static search set implementations, seven test programs were developed and executed on six large input files. Each test program implemented the same function: a recognizer for the 71 GNU g++ reserved words.
References-found: 19

