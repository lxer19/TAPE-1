URL: ftp://mancos.cs.utah.edu/papers/typesafety.ps.Z
Refering-URL: ftp://mancos.cs.utah.edu/papers/typesafety.html
Root-URL: 
Title: Type-safe Composition of Object Modules  
Author: Guruduth Banavar, Gary Lindstrom, Douglas Orr 
Address: Salt Lake City, Utah 84112 USA  
Affiliation: Department of Computer Science, University of Utah  
Date: 1994  
Note: International Conference on Computer Systems and Education, IISc, Bangalore,  
Abstract: We describe a facility that enables routine type-checking during the linkage of external declarations and definitions of separately compiled programs in ANSI C. The primary advantage of our server-style type-checked linkage facility is the ability to program the composition of object modules via a suite of strongly typed module combination operators. Such programmability enables one to easily incorporate programmer-defined data format conversion stubs at link-time. In addition, our linkage facility is able to automatically generate safe coercion stubs for compatible encapsulated data. fl This research was sponsored by the Advanced Research Projects Agency (DOD), monitored by the Department of the Navy, Office of the Chief of Naval Research, under Grant number N00014-91-J-4046. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the Advanced Research Projects Agency or the US Government. Contact author: G. Banavar, Computer Science - 3190 MEB, University of Utah, Salt Lake City, UT 84112 USA, email banavar@cs.utah.edu, phone +1-801-581-8378, fax +1-801-581-5843. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4), </volume> <month> September, </month> <year> 1993. </year>
Reference-contexts: For example, structural typing can be applied to languages such as ANSI C with name-based typing. Pure name-based typing becomes a problem in persistent and distributed environments, where data and types could migrate outside the program in which they were originally created <ref> [1] </ref>, and lead to matching of names that may or may not have the same programmer-intended meaning. This argues for structural matching of aggregate types similar to Modula-3 [15], using member order and type significance along with names.
Reference: [2] <author> Guruduth Banavar and Gary Lindstrom. </author> <title> A framework for module-based language processors. </title> <institution> Computer Science Department Technical Report UUCS-93-006, University of Utah, </institution> <month> March 5, </month> <year> 1993. </year>
Reference-contexts: This opens up the possibility of programmer-controlled data evolution and conversion across heterogeneous data formats, e.g. those arising from different languages, hardware architectures, etc.. We provide the ability to support a variety of type systems by designing our type-checking facility as an extension of an object-oriented framework <ref> [2] </ref>. The O-O framework contains generic type system related abstractions such as named types, function types, record types, etc. that are specialized via inheritance to implement the type domain of specific languages. <p> For accessing the sections of the object file that contain debugging information (.stab and .stabstr), we use Cygnus Corporation's Binary File Descriptor (BFD) library [8], and parse the "stabs" format debug strings [13] using a yacc/lex generated parser. We are implementing an O-O framework in C++ <ref> [2] </ref> that embodies the formal module model that was briefly described in Section 2. The abstractions (classes) in the framework implement the type rules discussed in the previous section. For instance, the framework class CPrimType implements the partial order of primitive types introduced before.
Reference: [3] <author> B.N. Bershad, T.E. Anderson, E.D. La-zowska, and H.M. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> Association for Computing Machinery Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 37-55, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: However, the crucial advantage with our approach is that we per form type-checking as a controlled and pro-grammable link-time activity. There is a plethora of literature related to stub generation <ref> [4, 12, 3, 20] </ref>. The Poly-gen system [7] is representative of automatic stub generation for programming in a heterogeneous environment. Polygen packages heterogeneous modules by utilizing a programmer-defined specification of their interfaces and execution environments specified in a common module language.
Reference: [4] <author> A.D. Birrell and B.J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> Association for Computing Machinery Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: However, the crucial advantage with our approach is that we per form type-checking as a controlled and pro-grammable link-time activity. There is a plethora of literature related to stub generation <ref> [4, 12, 3, 20] </ref>. The Poly-gen system [7] is representative of automatic stub generation for programming in a heterogeneous environment. Polygen packages heterogeneous modules by utilizing a programmer-defined specification of their interfaces and execution environments specified in a common module language.
Reference: [5] <author> Gilad Bracha. </author> <title> The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> March </month> <year> 1992. </year> <note> Technical report UUCS-92-007; 143 pp. </note>
Reference-contexts: The notion of type compatibility depends on the particular module combination operation being performed, and is informally described below. Our linker is based upon a formal model of modules proposed in <ref> [5] </ref>, achieving a fine level of control over individual attributes of object modules. Briefly, object modules are combined via a suite of module combination operators that were originally conceived to describe the many facets of inheritance in object-oriented programming.
Reference: [6] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design static typing and semantics. </title> <type> Technical Report CS-92-01, </type> <institution> Williams College, </institution> <month> January 31, </month> <year> 1992. </year>
Reference-contexts: Expressions which are evaluators can only be replaced with expres sions whose types are subtypes of the original, while expressions which are acceptors can only be replaced by expressions whose types are supertypes of the original <ref> [6] </ref>. As a result, subtyping of variables is always restricted to type equivalence. Consider file-level read-only (i.e. const) variables. <p> As a result, subtyping on file-level read-only variables is also restricted to type equivalence. Arguments such as the above can be formulated to show that subtyping on pointer types is also restricted to type equivalence. Consider subtyping of function types. Subtyping of function types is by contravari-ance <ref> [6] </ref>. That is, a function type is a subtype of another with the same number of arguments if its return type is a subtype of the latter's, and its input argument types are su-pertypes of the corresponding ones in the latter.
Reference: [7] <author> John R. Callahan and James M. Purtilo. </author> <title> A packaging system for heterogeneous execution environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(6) </volume> <pages> 626-635, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: However, the crucial advantage with our approach is that we per form type-checking as a controlled and pro-grammable link-time activity. There is a plethora of literature related to stub generation [4, 12, 3, 20]. The Poly-gen system <ref> [7] </ref> is representative of automatic stub generation for programming in a heterogeneous environment. Polygen packages heterogeneous modules by utilizing a programmer-defined specification of their interfaces and execution environments specified in a common module language.
Reference: [8] <author> Steve Chamberlain. libbfd. </author> <title> Free Software Foundation, Inc. Contributed by Cygnus Support, </title> <month> March, </month> <year> 1992. </year> <title> [9] 4.3 Berkeley Software Distribution. UNIX Programmer's Supplementary Documents. </title> <institution> University of California, Berkeley, </institution> <address> Califor-nia 94720, </address> <month> April </month> <year> 1986. </year>
Reference-contexts: To solve this, we modified the back end of gcc to generate debugging information for all symbols. For accessing the sections of the object file that contain debugging information (.stab and .stabstr), we use Cygnus Corporation's Binary File Descriptor (BFD) library <ref> [8] </ref>, and parse the "stabs" format debug strings [13] using a yacc/lex generated parser. We are implementing an O-O framework in C++ [2] that embodies the formal module model that was briefly described in Section 2.
Reference: [10] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Furthermore, the programmability of our linker enables "fine tuning" the compatibility of (possibly heterogeneous) object modules at link time. Use of header files has been a longstanding attempt at type-safety of separate compilation. The Annotated C++ Reference Man ual <ref> [10] </ref> (page 122) explains the inadequacy of header files as follows: "... C tried to ensure the consistency of separately compiled programs by controlling the information given to the compiler in header files. <p> With the objective of enabling type-safe linkage within the constraints of existing linkers, Stroustrup <ref> [19, 10] </ref> describes a mechanism for encoding functions with the types of input arguments. <p> With the objective of enabling type-safe linkage within the constraints of existing linkers, Stroustrup [19, 10] describes a mechanism for encoding functions with the types of input arguments. However, this mechanism is inadequate for our purposes since (i) certain classes of type errors cannot be detected (page 126 of <ref> [10] </ref>) since variable types and function return types are not encoded, (ii) although it could be extended to deal with structural typing of C aggregate types, it does not scale well to arbitrarily large types, e.g. large structs, and (iii) we want to do not only type-checking, but also useful adaptation
Reference: [11] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: This section describes the relevant type system of ANSI C (type domain and type equiv alence) <ref> [11] </ref>, and enhancements made to it for type-checking across compilation units (structural typing, and subsumption).
Reference: [12] <author> B. Lyon. </author> <title> Sun remote procedure call specification. </title> <type> Technical report, </type> <institution> SUN Microsys-tems, </institution> <year> 1984. </year>
Reference-contexts: However, the crucial advantage with our approach is that we per form type-checking as a controlled and pro-grammable link-time activity. There is a plethora of literature related to stub generation <ref> [4, 12, 3, 20] </ref>. The Poly-gen system [7] is representative of automatic stub generation for programming in a heterogeneous environment. Polygen packages heterogeneous modules by utilizing a programmer-defined specification of their interfaces and execution environments specified in a common module language.
Reference: [13] <author> Julia Menapace, Jim Kingdon, and David MacKenzie. </author> <title> The "stabs" debug format. Free Software Foundation, Inc. Contributed by Cygnus Support, </title> <year> 1993. </year>
Reference-contexts: To solve this, we modified the back end of gcc to generate debugging information for all symbols. For accessing the sections of the object file that contain debugging information (.stab and .stabstr), we use Cygnus Corporation's Binary File Descriptor (BFD) library [8], and parse the "stabs" format debug strings <ref> [13] </ref> using a yacc/lex generated parser. We are implementing an O-O framework in C++ [2] that embodies the formal module model that was briefly described in Section 2. The abstractions (classes) in the framework implement the type rules discussed in the previous section.
Reference: [14] <author> Bertrand Meyer. </author> <title> Eiffel, the environment, </title> <month> August </month> <year> 1989. </year>
Reference-contexts: Instead, programs can explicitly declare prototypes for those external (library) functions that are called. A discussion of the disadvantages of header files used in the traditional manner is found below in Section 6. 6 Related Work Integrated Development Environments (IDE's) for strongly typed languages, e.g. Eiffel <ref> [14] </ref>, undoubtedly utilize mechanisms for type-checking separately compiled modules, since they have complete knowledge and control over source and object modules. However, our work differs from IDE's in that we provide a systemwide linkage facility that attempts to typecheck combined modules independent of language processors.
Reference: [15] <author> Ed. Greg Nelson. </author> <title> Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: This argues for structural matching of aggregate types similar to Modula-3 <ref> [15] </ref>, using member order and type significance along with names. Furthermore, our programmable linkage facility enables the incorporation of automatic and user-defined conversion routines for encapsulated data.
Reference: [16] <author> Douglas Orr, John Bonn, Jay Lepreau, and Robert Mecklenburg. </author> <title> Fast and flexible shared libraries. </title> <booktitle> In Proc. USENIX Summer Conference, </booktitle> <pages> pages 237-251, </pages> <address> Cincin-nati, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Clients may directly load named module implementations or generate new modules by combining or modifying existing ones. This facility is used as the basis for system program execution and shared libraries <ref> [16] </ref>, as well as dynamic loading of simple modules. Expressions specifying module combination are encoded in a scripting language with a LISP-like syntax. These expressions consist primarily of operations for manipulating modules and module namespaces, such as those shown in Figure 1. <p> These expressions consist primarily of operations for manipulating modules and module namespaces, such as those shown in Figure 1. Additionally, OMOS supports operations for constructing an object module given program source code, and for specializing the implementation of a given module (e.g. library vs. ordinary module) <ref> [16] </ref>, among others. The operands in module expressions may be executable code or data fragments, other module expressions, or other named meta-objects. Since OMOS is an active entity (a server), it is capable of performing sophisticated module manipulations on each instantiation of a module. <p> The practice of combining a caching linker with the system object loader gives OMOS the flexibility to change implementations as it deems necessary, e.g. to reflect an updated implementation of a shared module across all its clients <ref> [16] </ref>. 4 C's Type System This concludes the general discussion of linkage via module manipulation.
Reference: [17] <author> Douglas B. Orr and Robert W. Mecklen-burg. </author> <title> OMOS | An object server for program execution. </title> <booktitle> In Proc. International Workshop on Object Oriented Operating Systems, </booktitle> <pages> pages 200-209, </pages> <address> Paris, </address> <month> September </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> Also available as technical report UUCS-92-033. </note>
Reference-contexts: The existence of link time type errors does not mean that program source files need to be modified and recompiled, as this may not be possible for pre-compiled libraries. Programmer control for correcting link time type errors is provided via the already existing programming facilities of OMOS <ref> [17] </ref>, our dynamic linker. For instance, consider the case where the type of a declaration in one translation unit does not match with a definition in another. <p> These operators provide control over aspects of visibility, sharing, and rebindability of individual attributes of modules. The power that this model lends to object module linkage is briefly given in Section 3, and is described in more detail in <ref> [17] </ref>, where the original implementation of the type-less OMOS linker is described. The current effort incorporates the rules of the strongly typed module model and illustrates some of its applications. The semantics of common linkage is embodied in the module operator merge. <p> With this, a modified version of O2 is obtained with the module expression (O2 rename f f stub) merge O3, which can then be merge'ed with O1 to get the originally desired effect. 3 The OMOS Linker In this section, we describe our linkage facility, the Object Meta-Object Server OMOS <ref> [17] </ref>. The OMOS linker/loader is designed to provide a dynamic linking and loading facility for client programs via the use of module combination and instantiation. OMOS implements a persistent hierarchical namespace | much like the UNIX directory hierarchy | whose leaf nodes are either object modules (.o files) or meta-objects.
Reference: [18] <author> Douglas B. Orr, Robert W. Mecklenburg, Peter J. Hoogenboom, and Jay Lepreau. </author> <title> Dynamic program monitoring and transformation using the OMOS object server. </title> <booktitle> In Proceedings of the 26th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 232-241, </pages> <month> January </month> <year> 1993. </year> <note> Also available as technical report UUCS-92-034. </note>
Reference-contexts: Since OMOS is an active entity (a server), it is capable of performing sophisticated module manipulations on each instantiation of a module. Evaluation of a module expression could potentially produce different results each time. Some OMOS operations such as those used to implement program monitoring and reordering <ref> [18] </ref> enact program transformations using operations on module expressions. For example, monitoring a program using OMOS might involve extracting and transforming the expression that generates the program so that each defined procedure is transparently wrapped with an outer routine that monitors entry to and exit from the procedure.
Reference: [19] <author> Bjarne Stroustrup. </author> <title> Type-safe linkage for C++. </title> <booktitle> In USENIX C++ Conference, </booktitle> <year> 1988. </year>
Reference-contexts: With the objective of enabling type-safe linkage within the constraints of existing linkers, Stroustrup <ref> [19, 10] </ref> describes a mechanism for encoding functions with the types of input arguments.
Reference: [20] <author> Satish R. Thatte. </author> <title> Automated synthesis of interface adapters for reusable classes. </title> <booktitle> In Symposium on Principles of Programming Languages, </booktitle> <month> January, </month> <year> 1994. </year>
Reference-contexts: However, the crucial advantage with our approach is that we per form type-checking as a controlled and pro-grammable link-time activity. There is a plethora of literature related to stub generation <ref> [4, 12, 3, 20] </ref>. The Poly-gen system [7] is representative of automatic stub generation for programming in a heterogeneous environment. Polygen packages heterogeneous modules by utilizing a programmer-defined specification of their interfaces and execution environments specified in a common module language.
References-found: 19

