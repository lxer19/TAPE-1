URL: http://robotics.eecs.berkeley.edu/~clairet/hytech.ps
Refering-URL: http://robotics.eecs.berkeley.edu/~clairet/hytech.html
Root-URL: http://www.cs.berkeley.edu
Email: clairet@eecs.berkeley.edu  
Title: Verification of an Air Traffic Management Protocol using HyTech  
Author: Claire Tomlin T. A. Henzinger 
Date: Spring, 1996  
Affiliation: Department of Electrical Engineering and Computer Sciences University of California at Berkeley  
Note: Course Project for EE290A, taught by Professor  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Rajeev Alur and Thomas A. Henzinger. </author> <title> Computer-aided verification. </title> <type> preprint. </type>
Reference-contexts: 3], dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turns: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&lt;=40+x2 & x1&gt;=x2 wait -dy2 in <ref> [1, 2] </ref>, dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync speedup1 goto turnf1; when True sync speedup2 goto turnf2; loc joinf1: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & <p> y2 = 0 & x2&gt;=x1 wait -dx2 in [2, 3], dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync slowdown goto joins; loc joins: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x1&lt;=40+x2 & x1&gt;=x2 wait -dx2 in <ref> [1, 2] </ref>, dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync speedup1 goto joinf1; when True sync speedup2 goto joinf2; end -- ac2 automaton controller synclabs: speedup1, speedup2, slowdown; initially fast1 & t=0; loc slow: while x1&lt;=30+x2 & x1&gt;=x2 wait <p> 3.81 sec total ================================================================= Appendix 5 A Finer Abstraction The coarse abstraction of Appendix 3 is made finer by splitting the Approach state of Aircraft 2 into a fast and a slow state: What was... loc appf: while y2&gt;=-100 & y2&lt;=-30 & x2=0 wait -dx2 in [0, 0], dy2 in <ref> [1, 7] </ref>- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; becomes.... loc appf: while y2&gt;=-100 & y2&lt;=-30 & x2=0 & x2&gt;=30+x1 wait -dx2 in [0, 0], dy2 in [5, 7]- when y2 = <p> 7]- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; when True sync slowdown1 goto apps; loc apps: while y2&gt;=-100 & y2&lt;=-30 & x2=0 & x2&lt;=30+x1 wait -dx2 in [0, 0], dy2 in <ref> [1, 1] </ref>- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; when True sync speedup2 goto appf; and a new state is added to the controller... loc slow1: while x2&lt;=x1+30 wait -- when x2=x1
Reference: [2] <author> Pei-Hsin Ho and Howard Wong-Toi. </author> <title> Automated analysis of an audio control protocol. </title> <institution> Department of Computer Science, Cornell University. </institution> <note> 21 and Join; Aircraft 1 remains in the state Cruise 22 </note>
Reference-contexts: The methodology to perform this is complicated however, since if the rates of Aircraft 2 are redefined to be dx2 in [ff; 2ff] for example, then the resulting automaton is no longer a linear hybrid automaton. In order to overcome this, I followed the method of <ref> [2] </ref>, in which a similar problem is solved by considering ff as a constant and applying two transformations which are trace-preserving for every non-zero constant value of ff. <p> x1&lt;=100 wait -10dx1 in [5, 10]- when x1 = 100 do -x1' = -100- goto cruise; end -- ac1 automaton ac2 synclabs: speedup1, speedup2, slowdown; initially turnf1 & x2 = 25 & y2 = -5; loc appf: while y2&gt;=-100 & y2&lt;=-30 & x2=0 wait -dx2 in [0, 0], dy2 in <ref> [2, 3] </ref>- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; loc turnf1: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&gt;=20+x2 wait -dy2 in [2, 3], dx2=dy2-when x2 = 30 & x1&lt;30+x2 <p> wait -dx2 in [0, 0], dy2 in <ref> [2, 3] </ref>- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; loc turnf1: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&gt;=20+x2 wait -dy2 in [2, 3], dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turnf2: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x2&gt;x1 wait -dy2 in [2, 3], <p> in <ref> [2, 3] </ref>, dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turnf2: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x2&gt;x1 wait -dy2 in [2, 3], dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turns: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&lt;=40+x2 & x1&gt;=x2 wait -dy2 in <p> 3], dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turns: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&lt;=40+x2 & x1&gt;=x2 wait -dy2 in <ref> [1, 2] </ref>, dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync speedup1 goto turnf1; when True sync speedup2 goto turnf2; loc joinf1: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & <p> 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync speedup1 goto turnf1; when True sync speedup2 goto turnf2; loc joinf1: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x1&gt;=20+x2 wait -dx2 in <ref> [2, 3] </ref>, dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; 11 when True sync slowdown goto joins; loc joinf2: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x2&gt;=x1 wait -dx2 in [2, 3], dy2 in [0, 0]- when x2 = 100 <p> & y2 = 0 & x1&gt;=20+x2 wait -dx2 in <ref> [2, 3] </ref>, dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; 11 when True sync slowdown goto joins; loc joinf2: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x2&gt;=x1 wait -dx2 in [2, 3], dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync slowdown goto joins; loc joins: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x1&lt;=40+x2 & x1&gt;=x2 wait -dx2 in [1, 2], dy2 in [0, 0]- when x2 = <p> y2 = 0 & x2&gt;=x1 wait -dx2 in [2, 3], dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync slowdown goto joins; loc joins: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x1&lt;=40+x2 & x1&gt;=x2 wait -dx2 in <ref> [1, 2] </ref>, dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync speedup1 goto joinf1; when True sync speedup2 goto joinf2; end -- ac2 automaton controller synclabs: speedup1, speedup2, slowdown; initially fast1 & t=0; loc slow: while x1&lt;=30+x2 & x1&gt;=x2 wait
Reference: [3] <author> Rajeev Alur, Costas Courcoubetis, Thomas A. Henzinger, and Pei-Hsin Ho. </author> <title> Hybrid automata: An algorithmic approach to the specification and verification of hybrid systems. </title> <editor> In Robert L. Grossman, Anil Nerode, Anders P. Ravn, and Hans Rischel, editors, </editor> <booktitle> Hybrid Systems, </booktitle> <pages> pages 366-392. </pages> <publisher> Springer Verlag, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: The material in this section is based on <ref> [3] </ref>, [4], [5], [6], [7] and [8]. A hybrid system may be modeled by a hybrid automaton which is a finite set of control locations, or discrete states, with a differential inclusion (rate condition) associated with each location. <p> of aircraft 1 x2, -- x position of aircraft 2 y2: analog; -- y position of aircraft 2 6 -- alpha: parameter; -- used to determine best control scheme - ---------------------------------------------------------------- *) automaton ac1 synclabs:; initially cruise & x1 = -60; loc cruise: while x1&gt;=-100 & x1&lt;=100 wait -dx1 in <ref> [3, 4] </ref>- when x1 = 100 do -x1' = -100- goto cruise; end -- ac1 automaton ac2 synclabs: speedup1, speedup2, slowdown; initially appf & x2 = 0 & y2 = -100; loc appf: while y2&gt;=-100 & y2&lt;=-30 & x2=0 wait -dx2 in [0, 0], dy2 in [6, 7]- when y2 = <p> x1&lt;=100 wait -10dx1 in [5, 10]- when x1 = 100 do -x1' = -100- goto cruise; end -- ac1 automaton ac2 synclabs: speedup1, speedup2, slowdown; initially turnf1 & x2 = 25 & y2 = -5; loc appf: while y2&gt;=-100 & y2&lt;=-30 & x2=0 wait -dx2 in [0, 0], dy2 in <ref> [2, 3] </ref>- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; loc turnf1: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&gt;=20+x2 wait -dy2 in [2, 3], dx2=dy2-when x2 = 30 & x1&lt;30+x2 <p> wait -dx2 in [0, 0], dy2 in <ref> [2, 3] </ref>- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; loc turnf1: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&gt;=20+x2 wait -dy2 in [2, 3], dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turnf2: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x2&gt;x1 wait -dy2 in [2, 3], <p> in <ref> [2, 3] </ref>, dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turnf2: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x2&gt;x1 wait -dy2 in [2, 3], dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turns: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&lt;=40+x2 & x1&gt;=x2 wait -dy2 in <p> 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync speedup1 goto turnf1; when True sync speedup2 goto turnf2; loc joinf1: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x1&gt;=20+x2 wait -dx2 in <ref> [2, 3] </ref>, dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; 11 when True sync slowdown goto joins; loc joinf2: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x2&gt;=x1 wait -dx2 in [2, 3], dy2 in [0, 0]- when x2 = 100 <p> & y2 = 0 & x1&gt;=20+x2 wait -dx2 in <ref> [2, 3] </ref>, dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; 11 when True sync slowdown goto joins; loc joinf2: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x2&gt;=x1 wait -dx2 in [2, 3], dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync slowdown goto joins; loc joins: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x1&lt;=40+x2 & x1&gt;=x2 wait -dx2 in [1, 2], dy2 in [0, 0]- when x2 =
Reference: [4] <author> Anuj Puri and Pravin Varaiya. </author> <title> Decidability of rectangular differential inclusions. </title> <booktitle> In Proceedings of the 6th International Computer Aided Verification Conference, </booktitle> <address> Stanford, CA, </address> <pages> pages 95-104, </pages> <year> 1994. </year>
Reference-contexts: The material in this section is based on [3], <ref> [4] </ref>, [5], [6], [7] and [8]. A hybrid system may be modeled by a hybrid automaton which is a finite set of control locations, or discrete states, with a differential inclusion (rate condition) associated with each location. <p> of aircraft 1 x2, -- x position of aircraft 2 y2: analog; -- y position of aircraft 2 6 -- alpha: parameter; -- used to determine best control scheme - ---------------------------------------------------------------- *) automaton ac1 synclabs:; initially cruise & x1 = -60; loc cruise: while x1&gt;=-100 & x1&lt;=100 wait -dx1 in <ref> [3, 4] </ref>- when x1 = 100 do -x1' = -100- goto cruise; end -- ac1 automaton ac2 synclabs: speedup1, speedup2, slowdown; initially appf & x2 = 0 & y2 = -100; loc appf: while y2&gt;=-100 & y2&lt;=-30 & x2=0 wait -dx2 in [0, 0], dy2 in [6, 7]- when y2 = <p> 6], dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turns: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&lt;=30+x2 & x1&gt;=x2 wait -dy2 in <ref> [4, 5] </ref>, dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync speedup1 goto turnf1; when True sync speedup2 goto turnf2; 7 loc joinf1: while x2&lt;=100 & x2&gt;=30 & y2 = 0 <p> y2 = 0 & x2&gt;=x1 wait -dx2 in [5, 6], dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync slowdown goto joins; loc joins: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x1&lt;=30+x2 & x1&gt;=x2 wait -dx2 in <ref> [4, 5] </ref>, dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync speedup1 goto joinf1; when True sync speedup2 goto joinf2; end -- ac2 automaton controller synclabs: speedup1, speedup2, slowdown; initially fast2; loc slow: while x1&lt;=30+x2 & x1&gt;=x2 wait -- when
Reference: [5] <author> Anuj Puri and Pravin Varaiya. </author> <title> Verification of hybrid systems using abstractions. In Hybrid Systems II, </title> <publisher> LNCS 999. Springer Verlag, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: The material in this section is based on [3], [4], <ref> [5] </ref>, [6], [7] and [8]. A hybrid system may be modeled by a hybrid automaton which is a finite set of control locations, or discrete states, with a differential inclusion (rate condition) associated with each location. <p> wait -dx2 in [0, 0], dy2 in [6, 7]- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; loc turnf1: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&gt;=30+x2 wait -dy2 in <ref> [5, 6] </ref>, dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turnf2: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x2&gt;x1 wait -dy2 in [5, 6], <p> in <ref> [5, 6] </ref>, dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turnf2: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x2&gt;x1 wait -dy2 in [5, 6], dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turns: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&lt;=30+x2 & x1&gt;=x2 wait -dy2 in <p> 6], dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turns: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&lt;=30+x2 & x1&gt;=x2 wait -dy2 in <ref> [4, 5] </ref>, dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync speedup1 goto turnf1; when True sync speedup2 goto turnf2; 7 loc joinf1: while x2&lt;=100 & x2&gt;=30 & y2 = 0 <p> & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync speedup1 goto turnf1; when True sync speedup2 goto turnf2; 7 loc joinf1: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x1&gt;=30+x2 wait -dx2 in <ref> [5, 6] </ref>, dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync slowdown goto joins; loc joinf2: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x2&gt;=x1 wait -dx2 in [5, 6], dy2 in [0, 0]- when x2 = 100 do <p> x2&gt;=30 & y2 = 0 & x1&gt;=30+x2 wait -dx2 in <ref> [5, 6] </ref>, dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync slowdown goto joins; loc joinf2: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x2&gt;=x1 wait -dx2 in [5, 6], dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync slowdown goto joins; loc joins: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x1&lt;=30+x2 & x1&gt;=x2 wait -dx2 in [4, 5], dy2 in [0, 0]- when x2 = <p> y2 = 0 & x2&gt;=x1 wait -dx2 in [5, 6], dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync slowdown goto joins; loc joins: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x1&lt;=30+x2 & x1&gt;=x2 wait -dx2 in <ref> [4, 5] </ref>, dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync speedup1 goto joinf1; when True sync speedup2 goto joinf2; end -- ac2 automaton controller synclabs: speedup1, speedup2, slowdown; initially fast2; loc slow: while x1&lt;=30+x2 & x1&gt;=x2 wait -- when <p> position of aircraft 1 x2, -- x position of aircraft 2 y2: analog; -- y position of aircraft 2 -- alpha: parameter; -- used to determine best control scheme - ---------------------------------------------------------------- *) automaton ac1 synclabs:; initially cruise & x1 = 60; loc cruise: while x1&gt;=-100 & x1&lt;=100 wait -10dx1 in <ref> [5, 10] </ref>- when x1 = 100 do -x1' = -100- goto cruise; end -- ac1 automaton ac2 synclabs: speedup1, speedup2, slowdown; initially turnf1 & x2 = 25 & y2 = -5; loc appf: while y2&gt;=-100 & y2&lt;=-30 & x2=0 wait -dx2 in [0, 0], dy2 in [2, 3]- when y2 = <p> [0, 0], dy2 in [1, 7]- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; becomes.... loc appf: while y2&gt;=-100 & y2&lt;=-30 & x2=0 & x2&gt;=30+x1 wait -dx2 in [0, 0], dy2 in <ref> [5, 7] </ref>- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; when True sync slowdown1 goto apps; loc apps: while y2&gt;=-100 & y2&lt;=-30 & x2=0 & x2&lt;=30+x1 wait -dx2 in [0, 0], dy2 in
Reference: [6] <author> Thomas A. Henzinger, Peter W. Kopke, Anuj Puri, and Pravin Varaiya. </author> <title> What's decidable about hybrid automata. </title> <booktitle> In Proceedings of the 27th Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1995. </year>
Reference-contexts: The material in this section is based on [3], [4], [5], <ref> [6] </ref>, [7] and [8]. A hybrid system may be modeled by a hybrid automaton which is a finite set of control locations, or discrete states, with a differential inclusion (rate condition) associated with each location. <p> The proof <ref> [6] </ref> is based on translating the initialized rectangular automata into multirate automata, and then translating the multirate automata into timed automata, for which the reachability problem is known to be decidable [9]. Reachability analysis is used to prove that the system is safe. <p> x1&lt;=100 wait -dx1 in [3, 4]- when x1 = 100 do -x1' = -100- goto cruise; end -- ac1 automaton ac2 synclabs: speedup1, speedup2, slowdown; initially appf & x2 = 0 & y2 = -100; loc appf: while y2&gt;=-100 & y2&lt;=-30 & x2=0 wait -dx2 in [0, 0], dy2 in <ref> [6, 7] </ref>- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; loc turnf1: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&gt;=30+x2 wait -dy2 in [5, 6], dx2=dy2-when x2 = 30 & x1&lt;30+x2 <p> wait -dx2 in [0, 0], dy2 in [6, 7]- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; loc turnf1: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&gt;=30+x2 wait -dy2 in <ref> [5, 6] </ref>, dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turnf2: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x2&gt;x1 wait -dy2 in [5, 6], <p> in <ref> [5, 6] </ref>, dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turnf2: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x2&gt;x1 wait -dy2 in [5, 6], dx2=dy2-when x2 = 30 & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync slowdown goto turns; loc turns: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&lt;=30+x2 & x1&gt;=x2 wait -dy2 in <p> & x1&lt;30+x2 & x1&gt;x2 goto joins; when x2 = 30 & x1&gt;=30+x2 goto joinf1; when x2 = 30 & x2&gt;=x1 goto joinf2; when True sync speedup1 goto turnf1; when True sync speedup2 goto turnf2; 7 loc joinf1: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x1&gt;=30+x2 wait -dx2 in <ref> [5, 6] </ref>, dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync slowdown goto joins; loc joinf2: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x2&gt;=x1 wait -dx2 in [5, 6], dy2 in [0, 0]- when x2 = 100 do <p> x2&gt;=30 & y2 = 0 & x1&gt;=30+x2 wait -dx2 in <ref> [5, 6] </ref>, dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync slowdown goto joins; loc joinf2: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x2&gt;=x1 wait -dx2 in [5, 6], dy2 in [0, 0]- when x2 = 100 do -y2' = -100, x2' = 0- goto appf; when True sync slowdown goto joins; loc joins: while x2&lt;=100 & x2&gt;=30 & y2 = 0 & x1&lt;=30+x2 & x1&gt;=x2 wait -dx2 in [4, 5], dy2 in [0, 0]- when x2 =
Reference: [7] <author> Anuj Puri. </author> <title> Theory of Hybrid Systems and Discrete Event Systems. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering, University of California, Berkeley, California, </institution> <year> 1995. </year>
Reference-contexts: The material in this section is based on [3], [4], [5], [6], <ref> [7] </ref> and [8]. A hybrid system may be modeled by a hybrid automaton which is a finite set of control locations, or discrete states, with a differential inclusion (rate condition) associated with each location. <p> x1&lt;=100 wait -dx1 in [3, 4]- when x1 = 100 do -x1' = -100- goto cruise; end -- ac1 automaton ac2 synclabs: speedup1, speedup2, slowdown; initially appf & x2 = 0 & y2 = -100; loc appf: while y2&gt;=-100 & y2&lt;=-30 & x2=0 wait -dx2 in [0, 0], dy2 in <ref> [6, 7] </ref>- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; loc turnf1: while y2&lt;=0 & y2&gt;=-30 & x2&gt;=0 & x2&lt;=30 & x1&gt;=30+x2 wait -dy2 in [5, 6], dx2=dy2-when x2 = 30 & x1&lt;30+x2 <p> 3.81 sec total ================================================================= Appendix 5 A Finer Abstraction The coarse abstraction of Appendix 3 is made finer by splitting the Approach state of Aircraft 2 into a fast and a slow state: What was... loc appf: while y2&gt;=-100 & y2&lt;=-30 & x2=0 wait -dx2 in [0, 0], dy2 in <ref> [1, 7] </ref>- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; becomes.... loc appf: while y2&gt;=-100 & y2&lt;=-30 & x2=0 & x2&gt;=30+x1 wait -dx2 in [0, 0], dy2 in [5, 7]- when y2 = <p> [0, 0], dy2 in [1, 7]- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; becomes.... loc appf: while y2&gt;=-100 & y2&lt;=-30 & x2=0 & x2&gt;=30+x1 wait -dx2 in [0, 0], dy2 in <ref> [5, 7] </ref>- when y2 = -30 & x1&lt;30+x2 & x1&gt;x2 goto turns; when y2 = -30 & x1&gt;=30+x2 goto turnf1; when y2 = -30 & x2&gt;=x1 goto turnf2; when True sync slowdown1 goto apps; loc apps: while y2&gt;=-100 & y2&lt;=-30 & x2=0 & x2&lt;=30+x1 wait -dx2 in [0, 0], dy2 in
Reference: [8] <author> Thomas A. Henzinger. </author> <title> The theory of hybrid automata. </title> <note> to appear in ?, (1996). </note>
Reference-contexts: The material in this section is based on [3], [4], [5], [6], [7] and <ref> [8] </ref>. A hybrid system may be modeled by a hybrid automaton which is a finite set of control locations, or discrete states, with a differential inclusion (rate condition) associated with each location.
Reference: [9] <author> Rajeev Alur and David Dill. </author> <title> A theory of timed automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 126 </volume> <pages> 183-235, </pages> <year> 1994. </year> <title> denote the ones that are labeled; the other labels are similar and are omitted since the diagram was getting too crowded). Also, s2 means the minimum bound on the slow speed; s2 is the maximum bound on the slow speed etc. </title> <type> 24 25 26 </type>
Reference-contexts: The proof [6] is based on translating the initialized rectangular automata into multirate automata, and then translating the multirate automata into timed automata, for which the reachability problem is known to be decidable <ref> [9] </ref>. Reachability analysis is used to prove that the system is safe. Consider a state predicate where where the region of states which satisfy , denoted [], is the set of unsafe states.
References-found: 9

