URL: ftp://ftp.cs.rochester.edu/pub/papers/systems/96.tr621.Briki_a_flexible_java_compiler.ps.gz
Refering-URL: http://www.cs.rochester.edu/u/cierniak/research/papers-short.html
Root-URL: 
Email: fcierniak,weig@cs.rochester.edu  
Title: Briki: a Flexible Java Compiler  
Author: Micha Cierniak Wei Li 
Note: This work was supported in part by an NSF Research Initiation Award (CCR-9409120) and ARPA contract F19628 94-C-0057.  
Date: May 1996  
Address: Rochester, NY 14627  
Affiliation: Department of Computer Science University of Rochester  
Pubnum: Technical Report 621  
Abstract: We present a Java compiler architecture which uses a unique combination of front- and back-ends to deliver great flexibility. Our compiler is designed to use the same optimization passes no matter which pair of front- and back-end is used. The compiler can be configured as a traditional stand-alone compiler (which compiles Java source into Java bytecodes). Another configuration can be used as an on-the-fly optimizer (which optimizes applets as they are loaded from the network). We can also compile Java directly to native code, thus using Java as a replacement for one of the traditional programming languages. Other interesting setups are also possible. This flexibility is achieved by using a common intermediate representation, JavaIR (Java Intermediate Representation). Multiple front-ends convert various input formats (Java source, bytecode) into JavaIR. Once represented as JavaIR an application can be transformed with any of the existing passes. The modified JavaIR form of an application can be written out in one of the supported output formats. Although compilers with multiple front- and back-ends have already existed, our approach is unique in supporting high-level code transformations even on applications which are distributed without the source program. Since Briki is written in Java it can be easily integrated into any Java application (e.g. a WWW browser) which dynamically loads applets from the network to provide capabilities of on-the-fly optimization. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Blume, R. Eigenmann, K. Faigin, J. Grout, J. Hoeflinger, D. Padua, P. Petersen, B. Pottenger, L. Rauchwerger, P. Tu, and S. Weatherford. </author> <title> Polaris: The Next Generation in Parallelizing Compilers. </title> <editor> In K. Pingali, U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing: 7th International Workshop, volume 892 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin/Heidelberg, </address> <year> 1995. </year>
Reference-contexts: After considering the above requirements, we made the following design decisions. We chose to design our intermediate representation to be a syntax tree. Although other representations exist in contemporary compilers, a syntax tree structure is common in the advanced research compilers such as Polaris <ref> [1, 3] </ref>, SUIF [10] or Sage++ [2]. As our intermediate representation for Java, we have designed JavaIR (Java Intermediate Representation) which is a syntax tree whose structure follows the source code as close as possible. JavaIR is discussed in more detail in Section 3.
Reference: [2] <author> F. Bodin. Sage++: </author> <title> An Object-oriented Toolkit and Class Library for Building Fortran and C++ Restructuring Tools. </title> <booktitle> In Proceedings of the Second Annual Object-Oriented Numerics Conference, </booktitle> <year> 1994. </year>
Reference-contexts: We chose to design our intermediate representation to be a syntax tree. Although other representations exist in contemporary compilers, a syntax tree structure is common in the advanced research compilers such as Polaris [1, 3], SUIF [10] or Sage++ <ref> [2] </ref>. As our intermediate representation for Java, we have designed JavaIR (Java Intermediate Representation) which is a syntax tree whose structure follows the source code as close as possible. JavaIR is discussed in more detail in Section 3.
Reference: [3] <author> K. A. Faigin, J. P. Hoeflinger, D. A. Padua, P. M. Petersen, and S. A. Weatherford. </author> <title> The Polaris Internal Representation. </title> <type> Technical Report 1317, </type> <institution> Center for Supercomputing Research and Development, University of Illinois at Urbana-Champaign. </institution>
Reference-contexts: After considering the above requirements, we made the following design decisions. We chose to design our intermediate representation to be a syntax tree. Although other representations exist in contemporary compilers, a syntax tree structure is common in the advanced research compilers such as Polaris <ref> [1, 3] </ref>, SUIF [10] or Sage++ [2]. As our intermediate representation for Java, we have designed JavaIR (Java Intermediate Representation) which is a syntax tree whose structure follows the source code as close as possible. JavaIR is discussed in more detail in Section 3.
Reference: [4] <author> J. Gosling. </author> <title> Java Intermediate Bytecodes. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on Intermediate Representations (IR '95), </booktitle> <pages> pages 111-118, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1995. </year> <journal> In ACM SIGPLAN Notices 30:3 (March 1995). </journal>
Reference-contexts: The definition of Java includes both the definition of the programming language itself [6] and the definition of the virtual machine [7] which can run compiled Java applications distributed in the form of bytecodes <ref> [4] </ref>. An application in the bytecode form can run on any computer with an implementation of the Java virtual machine.
Reference: [5] <author> S. Parthasarathy, M. Cierniak, and W. Li. NetProf: </author> <title> Network-based High-level Profiling of Java Bytecode. </title> <month> May </month> <year> 1996. </year> <note> submitted for publication. </note>
Reference-contexts: All those combinations of front- and back-end can share the same code-transformation passes. One interesting application developed with our compiler uses the bytecode to Java set to instrument .class files. We have developed a profiling tool called NetProf <ref> [5] </ref> which instruments Java applications distributed as bytecode and interactively presents the profiling information in a visualization applet. That way we can profile applets over a network without explicit downloading. The rest of the paper describes our compiler and the status of its implementation. <p> Instrumenting the code with method invocations at the beginning and end of all interesting control-flow blocks is trivial if we do it at the JavaIR level. NetProf <ref> [5] </ref> is a set of tools which can visualize performance information over a network. NetProf first instruments a class that is to be profiled, then the application is executed, and after it terminates a visualization tool presents the performance in the terms of the recovered Java source.
Reference: [6] <author> Sun Microsystems. </author> <title> The Java Language Specification. </title> <note> October 30, 1995. Version 1.0 Beta. 9 </note>
Reference-contexts: One possible use of such applications (called applets) is by including them in HTML pages which can be accessed with World Wide Web browsers, such as Netscape Navigator, HotJava or Internet Explorer. The definition of Java includes both the definition of the programming language itself <ref> [6] </ref> and the definition of the virtual machine [7] which can run compiled Java applications distributed in the form of bytecodes [4]. An application in the bytecode form can run on any computer with an implementation of the Java virtual machine.
Reference: [7] <author> Sun Microsystems. </author> <title> The Java Virtual Machine Specification. </title> <note> August 21, 1995. Release 1.0 Beta. </note>
Reference-contexts: The definition of Java includes both the definition of the programming language itself [6] and the definition of the virtual machine <ref> [7] </ref> which can run compiled Java applications distributed in the form of bytecodes [4]. An application in the bytecode form can run on any computer with an implementation of the Java virtual machine.
Reference: [8] <author> Sun Microsystems. </author> <title> The Java(tm) Developer's Kit. </title> <month> May </month> <year> 1996. </year> <note> Version 1.0. Available at http://java.sun.com/java.sun.com/products/JDK/index.html. </note>
Reference-contexts: Depending on the combination of front- and back-ends the compiler can be used in different ways. The most common combinations that we anticipate are: * Java to bytecode A conventional compiler a replacement for javac <ref> [8] </ref>. * bytecode to bytecode This can be used to optimize applications distributed without source. One could for instance integrate such a compiler with a web browser and perform optimiza tions on-the-fly. 1 * Java to Java Code-cleaning, pretty-printing. <p> Consider the following code fragment of a .class file as disassembled by javap <ref> [8] </ref>. <p> Choosing the bytecode front-end has an additional advantage that we can use any of the publicly available Java to bytecode compilers, such as javac which is distributed as part of the Java Developer's Kit <ref> [8] </ref> to create a virtual Java front-end. Furthermore, if compilers from other languages to the Java bytecode are developed, we can also create virtual front-ends for those languages. One such compiler that is available now is AppletMagic [9] developed by Intermetrics. <p> One such compiler that is available now is AppletMagic [9] developed by Intermetrics. AppletMagic compiles Ada 95 to Java bytecode. 8 Choosing Java source as the back-end has a similar advantage. We can use javac <ref> [8] </ref> to compile the output of our compiler to bytecode. The bytecode can be further compiled into C using j2c [11]. This gives us two additional virtual back-ends. Figure 5 (b) shows those possibilities with the front-ends marked with capital letters and the back-ends marked with numbers.
Reference: [9] <author> S. T. Taft. </author> <booktitle> Programming the Internet in Ada 95. </booktitle> <month> March </month> <year> 1996. </year> <note> submitted for publication. </note>
Reference-contexts: Off-line compilation to native code would let us use Java as a replacement for one of the traditional languages (C, C++, etc.) It is also possible to compile other programming languages <ref> [9] </ref> into JavaIR. This approach has been proposed to allow for distribution of non-Java programs in the bytecode form. It would be of course possible to write a front-end to our compiler for any of the languages which can be compiled into Java bytecode. <p> Furthermore, if compilers from other languages to the Java bytecode are developed, we can also create virtual front-ends for those languages. One such compiler that is available now is AppletMagic <ref> [9] </ref> developed by Intermetrics. AppletMagic compiles Ada 95 to Java bytecode. 8 Choosing Java source as the back-end has a similar advantage. We can use javac [8] to compile the output of our compiler to bytecode. The bytecode can be further compiled into C using j2c [11].
Reference: [10] <author> R. P. Wilson, R. S. French, C. S. Wilson, S. P. Amarasinghe, J. M. Anderson, S. W. K. Tjiang, S.-W. Liao, C.-W. Tseng, M. W. Hall, M. S. Lam, and J. L. Hennessy. </author> <title> SUIF: An Infrastructure for Research on Parallelizing and Optimizing Compilers. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(12) </volume> <pages> 31-37, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: After considering the above requirements, we made the following design decisions. We chose to design our intermediate representation to be a syntax tree. Although other representations exist in contemporary compilers, a syntax tree structure is common in the advanced research compilers such as Polaris [1, 3], SUIF <ref> [10] </ref> or Sage++ [2]. As our intermediate representation for Java, we have designed JavaIR (Java Intermediate Representation) which is a syntax tree whose structure follows the source code as close as possible. JavaIR is discussed in more detail in Section 3.
Reference: [11] <author> J2c/CafeBabe java .class to C translator. </author> <month> January </month> <year> 1996. </year> <note> Available at http://www.webcity.co.jp/ info/andoh/java/j2c.html. 10 </note>
Reference-contexts: AppletMagic compiles Ada 95 to Java bytecode. 8 Choosing Java source as the back-end has a similar advantage. We can use javac [8] to compile the output of our compiler to bytecode. The bytecode can be further compiled into C using j2c <ref> [11] </ref>. This gives us two additional virtual back-ends. Figure 5 (b) shows those possibilities with the front-ends marked with capital letters and the back-ends marked with numbers. All possible letter-number combinations give a valid compiler. There are six such compilers available now (nine if we include AppletMagic).
References-found: 11

