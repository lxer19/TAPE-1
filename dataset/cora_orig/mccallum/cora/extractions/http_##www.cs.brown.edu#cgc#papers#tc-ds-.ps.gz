URL: http://www.cs.brown.edu/cgc/papers/tc-ds-.ps.gz
Refering-URL: http://www.cs.brown.edu/people/rt/papers/recent-papers/recent-papers.html
Root-URL: http://www.cs.brown.edu
Email: frt,bmcg@cs.brown.edu  
Title: Data Structures  
Author: Roberto Tamassia Bryan Cantrill 
Note: Revised version for Chapter 6 of the CRC Handbook of Computer Science and Engineer ing.  
Date: January 27, 1996  
Address: 115 Waterman Street Providence, RI 02912-1910  
Affiliation: Department of Computer Science Brown University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Aggarwal and J. S. Vitter. </author> <title> The input/output complexity of sorting and related problems. </title> <journal> Commun. ACM, </journal> <volume> 31 </volume> <pages> 1116-1127, </pages> <year> 1988. </year>
Reference-contexts: Data structures designed to work for data that fit into internal memory may not perform well for large amounts of data that need to be stored in external memory. For large-scale problems, data structures need to be designed that take into account the two levels of memory <ref> [1] </ref>. For example, two-level indices such as B-trees [6] have been designed to efficiently search in large databases. Space vs. Time Data structures often exhibit a tradeoff between space and time complexity. <p> ). 4.6 Realization with a Hash Table The previous realizations of a dictionary make no assumptions on the structure of the keys, and use comparisons between keys to guide the execution of the various operations. 4.6.1 Bucket Array If the keys of a dictionary D are integers in the range <ref> [1; M ] </ref>, we can implement D with a bucket array B. An element (x; y) of D is represented by setting B [x] = y. If an integer x is not in D, the location B [x] stores a null value. <p> Table 12 shows the performance of a dictionary realized a bucket array. The bucket array method can be extended to keys that are easily mapped to integers. E.g., three-letter airport codes can be mapped to the integers in the range <ref> [1; 26 3 ] </ref>. 36 Operation Time Size O (1) Find O (1) LocatePrev O (M ) LocateNext O (M ) LocateRank O (M ) Next O (M ) Prev O (M ) Min O (M ) Insert O (1) Remove O (1) Modify O (1) Table 12: Performance of a <p> The keys in the dictionary are integers in the range <ref> [1; M ] </ref>. The space complexity is O (M ). 4.6.2 Hashing The bucket array method works well when the range of keys is small. However, it is inefficient when the range of keys is large. <p> However, it is inefficient when the range of keys is large. To overcome this problem, we can use a hash function h that maps the keys of the original dictionary D into integers in the range <ref> [1; M ] </ref>, where M is a parameter of the hash function. Now, we can apply the bucket array method using the hashed value h (x) of the keys. <p> It is interesting to analyze the performance of a hash table from a probabilistic viewpoint. If we assume that the hashed values of the keys are uniformly distributed in the range <ref> [1; M ] </ref>, then each bucket holds on average N=M keys, where N is the size of the dictionary. Hence, when N = O (M ), the average size of the secondary data structures is O (1). Table 13 shows the performance of a dictionary realized a hash table. <p> We denote with N the number of elements in the dictionary at the time the operation is performed. The space complexity is O (N + M ). The average time complexity refers to a probabilistic model where the hashed values of the keys are uniformly distributed in the range <ref> [1; M ] </ref>. bucket array implementation of a dictionary by means of an array indexed by the keys of the dictionary elements; see Section 4.6.1. container abstract data type storing a collection of objects (elements); see Section 1.1. dictionary container storing elements from a sorted universe supporting searches, insertions, and deletions;
Reference: [2] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> Data Structures and Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference: [3] <author> B. Chazelle and L. J. Guibas. Fractional cascading: I. </author> <title> A data structuring technique. </title> <journal> Algorithmica, </journal> <volume> 1 </volume> <pages> 133-162, </pages> <year> 1986. </year>
Reference-contexts: Hash tables provide an efficient implicit re-alization of a dictionary. Efficient explicit implementations include skip lists [30], tries, and balanced search trees (e.g., AVL-trees, red-black trees, 2-3 trees, 2-3-4 trees, weight-balanced trees, biased search trees, splay trees). The technique of fractional cascading <ref> [3] </ref> speeds up searching for the same element in a collection of dictionaries. In external memory, dic tionaries are typically implemented as B-trees and their variations.
Reference: [4] <author> Y.-J. Chiang and R. Tamassia. </author> <title> Dynamic algorithms in computational geometry. </title> <journal> Proc. IEEE, </journal> <volume> 80(9) </volume> <pages> 1412-1434, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: See also, e.g., [12, 22, 34]. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree. See, e.g., <ref> [4, 10, 13, 22, 26, 27, 29] </ref>. 1.5 Organization of the Chapter The rest of this chapter focuses on three fundamental abstract data types: sequences, priority queues, and dictionaries. Examples of efficient data structures and algorithms for implementing them are presented in detail in Sections 2, 3 and 4, respectively. <p> Recent papers surveying the state-of-the art in data structures include <ref> [4, 15, 24, 35] </ref>. The LEDA project [23] aims at developing a C++ library of efficient and reliable implementations of sophisticated data structures.
Reference: [5] <author> R. F. Cohen and R. Tamassia. </author> <title> Dynamic expression trees. </title> <journal> Algorithmica, </journal> <volume> 13 </volume> <pages> 245-265, </pages> <year> 1995. </year>
Reference-contexts: See, e.g., [15]. Examples of fundamental data structures used in three major application domains are mentioned below. Graphs and Networks adjacency matrix, adjacency lists, link-cut tree [33], dynamic expression tree <ref> [5] </ref>, topology tree [14], SPQR-tree [8], sparsifica tion tree [11]. See also, e.g., [12, 22, 34]. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree.
Reference: [6] <author> D. Comer. </author> <title> The ubiquitous B-tree. </title> <journal> ACM Comput. Surv., </journal> <volume> 11 </volume> <pages> 121-137, </pages> <year> 1979. </year>
Reference-contexts: For large-scale problems, data structures need to be designed that take into account the two levels of memory [1]. For example, two-level indices such as B-trees <ref> [6] </ref> have been designed to efficiently search in large databases. Space vs. Time Data structures often exhibit a tradeoff between space and time complexity.
Reference: [7] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference: [8] <author> G. Di Battista and R. Tamassia. </author> <title> On-line graph algorithms with SPQR-trees. </title> <booktitle> In Automata, Languages and Programming (Proc. 17th ICALP), volume 442 of Lecture Notes in Computer Science, </booktitle> <pages> pages 598-611, </pages> <year> 1990. </year>
Reference-contexts: See, e.g., [15]. Examples of fundamental data structures used in three major application domains are mentioned below. Graphs and Networks adjacency matrix, adjacency lists, link-cut tree [33], dynamic expression tree [5], topology tree [14], SPQR-tree <ref> [8] </ref>, sparsifica tion tree [11]. See also, e.g., [12, 22, 34]. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree.
Reference: [9] <author> J. R. Driscoll, N. Sarnak, D. D. Sleator, and R. E. Tarjan. </author> <title> Making data structures persistent. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 38 </volume> <pages> 86-124, </pages> <year> 1989. </year>
Reference-contexts: Static vs. Dynamic A static data structure supports only queries, while a dynamic data structure supports also updates. A dynamic data structure is often more complicated than its static counterpart supporting the same repertory of queries. A persistent data structure (see, e.g., <ref> [9] </ref>) is a dynamic data structure that supports operations on past versions. There are many problems for which no efficient dynamic data structures are known.
Reference: [10] <author> H. Edelsbrunner. </author> <title> Algorithms in Combinatorial Geometry, </title> <booktitle> volume 10 of EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, West Germany, </address> <year> 1987. </year> <month> 40 </month>
Reference-contexts: See also, e.g., [12, 22, 34]. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree. See, e.g., <ref> [4, 10, 13, 22, 26, 27, 29] </ref>. 1.5 Organization of the Chapter The rest of this chapter focuses on three fundamental abstract data types: sequences, priority queues, and dictionaries. Examples of efficient data structures and algorithms for implementing them are presented in detail in Sections 2, 3 and 4, respectively.
Reference: [11] <author> D. Eppstein, Z. Galil, G. F. Italiano, and A. Nissenzweig. </author> <title> Sparsification: A technique for speeding up dynamic graph algorithms. </title> <booktitle> In Proc. 33rd Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 60-69, </pages> <year> 1992. </year>
Reference-contexts: See, e.g., [15]. Examples of fundamental data structures used in three major application domains are mentioned below. Graphs and Networks adjacency matrix, adjacency lists, link-cut tree [33], dynamic expression tree [5], topology tree [14], SPQR-tree [8], sparsifica tion tree <ref> [11] </ref>. See also, e.g., [12, 22, 34]. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree.
Reference: [12] <author> S. </author> <title> Even. Graph Algorithms. </title> <publisher> Computer Science Press, </publisher> <address> Potomac, Maryland, </address> <year> 1979. </year>
Reference-contexts: See, e.g., [15]. Examples of fundamental data structures used in three major application domains are mentioned below. Graphs and Networks adjacency matrix, adjacency lists, link-cut tree [33], dynamic expression tree [5], topology tree [14], SPQR-tree [8], sparsifica tion tree [11]. See also, e.g., <ref> [12, 22, 34] </ref>. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree.
Reference: [13] <author> J. D. Foley, A. van Dam, S. K. Feiner, and J. F. Hughes. </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: See also, e.g., [12, 22, 34]. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree. See, e.g., <ref> [4, 10, 13, 22, 26, 27, 29] </ref>. 1.5 Organization of the Chapter The rest of this chapter focuses on three fundamental abstract data types: sequences, priority queues, and dictionaries. Examples of efficient data structures and algorithms for implementing them are presented in detail in Sections 2, 3 and 4, respectively.
Reference: [14] <author> G. N. Frederickson. </author> <title> A data structure for dynamically maintaining rooted trees. </title> <booktitle> In Proc. 4th ACM-SIAM Symp. Discrete Algorithms, </booktitle> <pages> pages 175-184, </pages> <year> 1993. </year>
Reference-contexts: See, e.g., [15]. Examples of fundamental data structures used in three major application domains are mentioned below. Graphs and Networks adjacency matrix, adjacency lists, link-cut tree [33], dynamic expression tree [5], topology tree <ref> [14] </ref>, SPQR-tree [8], sparsifica tion tree [11]. See also, e.g., [12, 22, 34]. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree.
Reference: [15] <author> Z. Galil and G. F. </author> <title> Italiano. Data structures and algorithms for disjoint set union problems. </title> <journal> ACM Computing Surveys, </journal> <volume> 23(3) </volume> <pages> 319-344, </pages> <year> 1991. </year>
Reference-contexts: There is a simple and optimal union-find data structure (rooted tree with path compression) whose time complexity analysis is very difficult to analyze. See, e.g., <ref> [15] </ref>. Examples of fundamental data structures used in three major application domains are mentioned below. Graphs and Networks adjacency matrix, adjacency lists, link-cut tree [33], dynamic expression tree [5], topology tree [14], SPQR-tree [8], sparsifica tion tree [11]. See also, e.g., [12, 22, 34]. <p> Recent papers surveying the state-of-the art in data structures include <ref> [4, 15, 24, 35] </ref>. The LEDA project [23] aims at developing a C++ library of efficient and reliable implementations of sophisticated data structures.
Reference: [16] <author> G. H. Gonnet and R. Baeza-Yates. </author> <title> Handbook of Algorithms and Data Structures. </title> <publisher> Addison Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Graphs and Networks adjacency matrix, adjacency lists, link-cut tree [33], dynamic expression tree [5], topology tree [14], SPQR-tree [8], sparsifica tion tree [11]. See also, e.g., [12, 22, 34]. Text Processing string, suffix tree, Patricia tree. See, e.g., <ref> [16] </ref>. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree.
Reference: [17] <author> K. Hoffmann, K. Mehlhorn, P. Rosenstiehl, and R. E. Tarjan. </author> <title> Sorting Jordan sequences in linear time using level-linked search trees. </title> <journal> Inform. Control, </journal> <volume> 68 </volume> <pages> 170-184, </pages> <year> 1986. </year>
Reference-contexts: Special types of sequences include stacks and queues, where insertions and deletions can be done only at the head or tail of the sequence. The basic realization of sequences are by means of arrays and linked lists. Concatenable queues (see, e.g., <ref> [17] </ref>) support additional operations such as splitting and splicing, and determining the sequence containing a given element. In external memory, a sequence is typically associated with a file.
Reference: [18] <author> E. Horowitz, S. Sahni, and D. Metha. </author> <title> Fundamentals of Data Structures in C++. </title> <publisher> Computer Science Press, </publisher> <year> 1995. </year>
Reference: [19] <author> D. E. Knuth. </author> <title> Fundamental Algorithms, </title> <booktitle> volume 1 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1968. </year>
Reference: [20] <author> D. E. Knuth. </author> <title> Sorting and Searching, </title> <booktitle> volume 3 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference: [21] <author> H. R. Lewis and L. Denenberg. </author> <title> Data Structures and Their Algorithms. </title> <publisher> Harper Collins, </publisher> <year> 1991. </year>
Reference: [22] <author> K. Mehlhorn. </author> <title> Data Structures and Algorithms. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <pages> Volumes 1-3. </pages>
Reference-contexts: See, e.g., [15]. Examples of fundamental data structures used in three major application domains are mentioned below. Graphs and Networks adjacency matrix, adjacency lists, link-cut tree [33], dynamic expression tree [5], topology tree [14], SPQR-tree [8], sparsifica tion tree [11]. See also, e.g., <ref> [12, 22, 34] </ref>. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree. <p> See also, e.g., [12, 22, 34]. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree. See, e.g., <ref> [4, 10, 13, 22, 26, 27, 29] </ref>. 1.5 Organization of the Chapter The rest of this chapter focuses on three fundamental abstract data types: sequences, priority queues, and dictionaries. Examples of efficient data structures and algorithms for implementing them are presented in detail in Sections 2, 3 and 4, respectively.
Reference: [23] <author> K. Mehlhorn and S. Naher. LEDA: </author> <title> a platform for combinatorial and geometric computing. </title> <journal> CACM, </journal> <volume> 38 </volume> <pages> 96-102, </pages> <year> 1995. </year> <note> http://www.mpi-sb.mpg.de/guide/staff/uhrig/leda.html. </note>
Reference-contexts: Recent papers surveying the state-of-the art in data structures include [4, 15, 24, 35]. The LEDA project <ref> [23] </ref> aims at developing a C++ library of efficient and reliable implementations of sophisticated data structures.
Reference: [24] <author> K. Mehlhorn and A. Tsakalidis. </author> <title> Data structures. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Algorithms and Complexity, volume A of Handbook of Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <address> Amsterdam, </address> <year> 1990. </year> <month> 41 </month>
Reference-contexts: Recent papers surveying the state-of-the art in data structures include <ref> [4, 15, 24, 35] </ref>. The LEDA project [23] aims at developing a C++ library of efficient and reliable implementations of sophisticated data structures.
Reference: [25] <author> P. B. Miltersen, S. Sairam, J. S. Vitter, and R. Tamassia. </author> <title> Complexity models for incremental computation. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 130 </volume> <pages> 203-236, </pages> <year> 1994. </year>
Reference-contexts: It has been observed that there are strong similarities among the classes of problems that are difficult to parallelize and those that are difficult to dynamize (see, e.g., [31]). Further investigations are needed to study the relationship between parallel and incremental complexity <ref> [25] </ref>. Implicit vs. Explicit Two fundamental data organization mechanisms are used in data structures. In an explicit data structure, pointers (i.e., memory addresses) are used to link the elements and access them (e.g., a singly linked list, where each element has a pointer to the next one).
Reference: [26] <author> J. Nievergelt and K. H. Hinrichs. </author> <title> Algorithms and Data Structures: With Applications to Graphics and Geometry. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1993. </year>
Reference-contexts: See also, e.g., [12, 22, 34]. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree. See, e.g., <ref> [4, 10, 13, 22, 26, 27, 29] </ref>. 1.5 Organization of the Chapter The rest of this chapter focuses on three fundamental abstract data types: sequences, priority queues, and dictionaries. Examples of efficient data structures and algorithms for implementing them are presented in detail in Sections 2, 3 and 4, respectively.
Reference: [27] <author> J. O'Rourke. </author> <title> Computational Geometry in C. </title> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference-contexts: See also, e.g., [12, 22, 34]. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree. See, e.g., <ref> [4, 10, 13, 22, 26, 27, 29] </ref>. 1.5 Organization of the Chapter The rest of this chapter focuses on three fundamental abstract data types: sequences, priority queues, and dictionaries. Examples of efficient data structures and algorithms for implementing them are presented in detail in Sections 2, 3 and 4, respectively.
Reference: [28] <author> M. H. Overmars. </author> <title> The design of dynamic data structures, </title> <booktitle> volume 156 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference: [29] <author> F. P. Preparata and M. I. Shamos. </author> <title> Computational Geometry: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1985. </year>
Reference-contexts: See also, e.g., [12, 22, 34]. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree. See, e.g., <ref> [4, 10, 13, 22, 26, 27, 29] </ref>. 1.5 Organization of the Chapter The rest of this chapter focuses on three fundamental abstract data types: sequences, priority queues, and dictionaries. Examples of efficient data structures and algorithms for implementing them are presented in detail in Sections 2, 3 and 4, respectively.
Reference: [30] <author> W. Pugh. </author> <title> Skip lists: a probabilistic alternative to balanced trees. </title> <journal> Commun. ACM, </journal> <volume> 35 </volume> <pages> 668-676, </pages> <year> 1990. </year>
Reference-contexts: Dictionary A dictionary is a container of elements from a totally ordered universe that supports the basic operations of inserting/deleting elements and 3 searching for a given element. Hash tables provide an efficient implicit re-alization of a dictionary. Efficient explicit implementations include skip lists <ref> [30] </ref>, tries, and balanced search trees (e.g., AVL-trees, red-black trees, 2-3 trees, 2-3-4 trees, weight-balanced trees, biased search trees, splay trees). The technique of fractional cascading [3] speeds up searching for the same element in a collection of dictionaries.
Reference: [31] <author> J. H. Reif. </author> <title> A topological approach to dynamic graph connectivity. </title> <journal> Inform. Process. Lett., </journal> <volume> 25 </volume> <pages> 65-70, </pages> <year> 1987. </year>
Reference-contexts: There are many problems for which no efficient dynamic data structures are known. It has been observed that there are strong similarities among the classes of problems that are difficult to parallelize and those that are difficult to dynamize (see, e.g., <ref> [31] </ref>). Further investigations are needed to study the relationship between parallel and incremental complexity [25]. Implicit vs. Explicit Two fundamental data organization mechanisms are used in data structures.
Reference: [32] <author> R. Sedgewick. </author> <title> Algorithms in C++. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1992. </year>
Reference: [33] <author> D. D. Sleator and R. E. Tarjan. </author> <title> A data structure for dynamic trees. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 26(3) </volume> <pages> 362-381, </pages> <year> 1983. </year>
Reference-contexts: There is a simple and optimal union-find data structure (rooted tree with path compression) whose time complexity analysis is very difficult to analyze. See, e.g., [15]. Examples of fundamental data structures used in three major application domains are mentioned below. Graphs and Networks adjacency matrix, adjacency lists, link-cut tree <ref> [33] </ref>, dynamic expression tree [5], topology tree [14], SPQR-tree [8], sparsifica tion tree [11]. See also, e.g., [12, 22, 34]. Text Processing string, suffix tree, Patricia tree. See, e.g., [16].
Reference: [34] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms, </title> <booktitle> volume 44 of CBMS-NSF Regional Conference Series in Applied Mathematics. Society for Industrial Applied Mathematics, </booktitle> <year> 1983. </year>
Reference-contexts: See, e.g., [15]. Examples of fundamental data structures used in three major application domains are mentioned below. Graphs and Networks adjacency matrix, adjacency lists, link-cut tree [33], dynamic expression tree [5], topology tree [14], SPQR-tree [8], sparsifica tion tree [11]. See also, e.g., <ref> [12, 22, 34] </ref>. Text Processing string, suffix tree, Patricia tree. See, e.g., [16]. Geometry and Graphics binary space partition tree, chain tree, trapezoid tree, range tree, segment-tree, interval-tree, priority-search tree, hull-tree, quad-tree, R-tree, grid file, metablock tree.
Reference: [35] <author> J. S. Vitter and P. Flajolet. </author> <title> Average-case analysis of algorithms and data structures. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Algorithms and Complexity, volume A of Handbook of Theoretical Computer Science, </booktitle> <pages> pages 431-524. </pages> <address> Else-vier, Amsterdam, </address> <year> 1990. </year>
Reference-contexts: Recent papers surveying the state-of-the art in data structures include <ref> [4, 15, 24, 35] </ref>. The LEDA project [23] aims at developing a C++ library of efficient and reliable implementations of sophisticated data structures.
Reference: [36] <author> D. Wood. </author> <title> Data Structures, Algorithms, and Performance. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
References-found: 36

