URL: ftp://ftp.cs.washington.edu/tr/1994/07/UW-CSE-94-07-05.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: Hardware and Software Support for Efficient Exception Handling  
Author: Chandramohan A. Thekkath and Henry M. Levy 
Date: October 1994.  
Note: Also appears in the Proceedings of the 6th International Conference on Architectural Support for Programming Languages and Operating Systems,  
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: Technical Report 94-07-05 July 17, 1994 
Abstract-found: 1
Intro-found: 1
Reference: [Abelson & Sussman 85] <author> H. Abelson and G. J. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> The MIT Press, </publisher> <address> Cambridge Massachusetts, </address> <year> 1985. </year>
Reference-contexts: We briefly discuss several of these examples below. 4.2.1 Unbounded Data Structures Potentially unbounded data structures, such as streams, are a valuable computational paradigm in languages such as Scheme <ref> [Abelson & Sussman 85] </ref>. Given a software/hardware architecture that delivers unaligned word access exceptions to user level, it is easy to build data structures that are incrementally augmented on demand.
Reference: [Agarwal et al. 90] <author> A. Agarwal, B.-H. Lim, D. Kranz, and J. Kubiatowicz. </author> <month> April: </month> <title> A processor architecture for multiprocessing. </title> <booktitle> In Proceedings of the 17th International Symposium on Computer Architecture, </booktitle> <pages> pages 104-114, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: One obvious approach is to represent an unresolved future as an unaligned pointer. When the value of the future is available, the pointer is updated and aligned. In fact, the APRIL processor used in the Alewife machine does precisely this <ref> [Agarwal et al. 90] </ref>. With fast user-level exception delivery, similar mechanisms can be exploited in more conventional architectures as well. Another example of the use of unaligned references is to implement synchronization through full/empty bits, as is done on some processors [Alverson et al. 90, Agarwal et al. 90]. <p> With fast user-level exception delivery, similar mechanisms can be exploited in more conventional architectures as well. Another example of the use of unaligned references is to implement synchronization through full/empty bits, as is done on some processors <ref> [Alverson et al. 90, Agarwal et al. 90] </ref>. An attempt to read from an empty location or write to a full location causes the reader or writer to block until the location is filled or emptied, respectively.
Reference: [Alverson et al. 90] <author> R. Alverson, D. Callahan, D. Cummings, B. Koblenz, A. Porterfield, and B. Smith. </author> <title> The Tera computer system. </title> <booktitle> International Conference on Supercomputing, </booktitle> <pages> pages 1-6, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: This paper studies the issues in designing efficient exception mechanisms and their implications for applications. This paper is structured as follows. In the following section, we discuss architectural issues in user-level exception vectoring. We begin by presenting, as an example, the exception architecture of the Tera computer <ref> [Alverson et al. 90] </ref>, which includes user-level exception delivery. We then extend that design to meet the needs of our target applications on more conventional RISC architectures. Section 3 describes a software architecture for fast user-level exception delivery, which we have implemented on the MIPS-based DECstation. <p> We address such issues later in this section. 2.1 The Tera Architecture We briefly describe exception handling in the Tera architecture <ref> [Alverson et al. 90] </ref> as an introduction and example of direct user-mode exception delivery. The Tera supports multi-threading in hardware and each processor contains complete hardware state for 128 threads. The processor cycles through a queue of runnable threads, executing one instruction from each thread on each cycle. <p> With fast user-level exception delivery, similar mechanisms can be exploited in more conventional architectures as well. Another example of the use of unaligned references is to implement synchronization through full/empty bits, as is done on some processors <ref> [Alverson et al. 90, Agarwal et al. 90] </ref>. An attempt to read from an empty location or write to a full location causes the reader or writer to block until the location is filled or emptied, respectively.
Reference: [Anderson et al. 91] <author> T. E. Anderson, H. M. Levy, B. N. Bershad, and E. D. Lazowska. </author> <title> The interaction of architecture and operating system design. </title> <booktitle> In Proceedings of the 4th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 108-120, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Null Handler 31 64 208 136 24 25 Simple Exception Round-Trip 80 2001 256 200 69 175 Delivery and Return Table 1: Performance of basic exception functions on modern systems. have shown that the relative cost of exception handling on modern RISCs has actually increased, when compared to past-generation architectures <ref> [Ousterhout 90, Anderson et al. 91] </ref>. A crucial difference between interrupts and exceptions is that, in the latter case, the information needed to respond typically lies within the application program or run-time system, not within the kernel. <p> in multithreaded environments this optimization may be useful, because it can be made optional under user program control. 3.2.4 Emulating Subpage-Granularity Protection Previous studies have noted that architects are increasing page size at the same time that software wants smaller pages, in order to reduce protection granularity and false sharing <ref> [Anderson et al. 91] </ref>. We demonstrate that with a small amount of kernel support, it is possible to provide subpage granularity protection in a simple way. In our prototype, users can make kernel calls to protect a memory region composed of logical pages that are 1K bytes long.
Reference: [Appel & Li 91] <author> A. W. Appel and K. Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Proceedings of the 4th International Conference on Architecture Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 96-107, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: An application wishing to re-protect the page would then need to make an additional system call; however, applications such as garbage collectors, persistent store manages, and others can benefit from this minor change in semantics, because they don't always need to re-enable protection checks following the exception <ref> [Appel & Li 91] </ref>. This optimization works well in environments such as ours, where address spaces are not multithreaded. <p> We consider two different types of exceptions memory protection faults and unaligned address faults and show uses and performance implications for each. 4.1 Using Memory Protection Faults The use of memory protection faults in applications such as distributed shared memory and garbage collection has received much attention <ref> [Appel & Li 91, Hosking & Moss 93] </ref>. In this section we report on the performance of a garbage collector that uses our software delivery mechanism to handle protection violation exceptions.
Reference: [Appel et al. 88] <author> A. W. Appel, J. R. Ellis, and K. Li. </author> <title> Real-time concurrent collection on stock multiprocessors. </title> <booktitle> In Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 11-20, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: However, applications and run-time systems are using exception mechanisms increasingly and in novel ways; for example, exceptions are being used for garbage collection <ref> [Appel et al. 88] </ref>, conditional watchpoints [Wahbe 92], transaction support [Chang & Mergen 88], persistent storage management [Wilson & Kakkad 92], and distributed virtual memory [Li & Hudak 89]. To compound the problem, several studies y Author's current address: DEC Systems Research Center, 130 Lytton Avenue, Palo Alto, CA 94301. <p> The time to deliver a write protection exception is shown as well, since write protection is often used to detect dirty pages for garbage collection <ref> [Appel et al. 88] </ref>, pointer swizzling [Wilson & Kakkad 92], and other applications. From the bottom row, we see that the delivery to and return from a null user-level exception handler takes 69 seconds in the best case of SunOS, to 2 milliseconds for Mach/UX.
Reference: [Boehm & Weiser 88] <author> H.-J. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: We trivially modified the standard Xerox version to enable generational and incremental collection support for Ultrix. Otherwise, the operation of the collector is similar to that described in <ref> [Boehm & Weiser 88] </ref>. A generational garbage collector separates heap objects as belonging to multiple generations. Empirical evidence has shown that most of the garbage is created in younger (more recently allocated) rather than older generations [Lieberman & Hewitt 83, Ungar 84].
Reference: [Chang & Mergen 88] <author> A. Chang and M. F. Mergen. </author> <title> 801 storage: Architecture and programming. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 28-50, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: However, applications and run-time systems are using exception mechanisms increasingly and in novel ways; for example, exceptions are being used for garbage collection [Appel et al. 88], conditional watchpoints [Wahbe 92], transaction support <ref> [Chang & Mergen 88] </ref>, persistent storage management [Wilson & Kakkad 92], and distributed virtual memory [Li & Hudak 89]. To compound the problem, several studies y Author's current address: DEC Systems Research Center, 130 Lytton Avenue, Palo Alto, CA 94301.
Reference: [Cockshot et al. 84] <author> W. Cockshot, M. Atkinson, K. Chisholm, P. Bailey, and R. Morrison. </author> <title> Persistent object management system. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 14(1) </volume> <pages> 251-272, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: Non-resident objects referenced by those pointers are then assigned virtual address space, and the pointers are swizzled to point to those non-resident virtual pages. Pointers in the loaded object to memory-resident objects are simply swizzled to those objects' memory addresses. In lazy swizzling <ref> [Cockshot et al. 84] </ref>, each pointer within a newly-loaded object remains in unswizzled format until it is first used; at that point the pointer is swizzled.
Reference: [Hosking & Moss 93] <author> A. L. Hosking and J. E. B. Moss. </author> <title> Protection traps and alternatives for memory management of an object-oriented language. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating, </booktitle> <pages> pages 106-119, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: We consider two different types of exceptions memory protection faults and unaligned address faults and show uses and performance implications for each. 4.1 Using Memory Protection Faults The use of memory protection faults in applications such as distributed shared memory and garbage collection has received much attention <ref> [Appel & Li 91, Hosking & Moss 93] </ref>. In this section we report on the performance of a garbage collector that uses our software delivery mechanism to handle protection violation exceptions. <p> Depending on the relative costs of a software check and a exception delivery, a software checking scheme may be preferable to the exception delivery scheme. Hosking and Moss have compared the relative performance of the two approaches on two applications running on the DECstations 3100 under Ultrix <ref> [Hosking & Moss 93] </ref>. Both applications are written in Smalltalk. The first program (Tree) is a synthetic benchmark based on tree creation and destruction. <p> Unlike page faults, memory protection violations are not affected by external, real-time variation, such as the time to fetch data from disk. We can therefore use application characteristics reported in <ref> [Hosking & Moss 93] </ref> to compare the performance of software checks and page protection using our software exception mechanism. Depending on the relative costs of software checks and exceptions, and the number of exceptions, a break-even point can be calculated for the two techniques. <p> reported in <ref> [Hosking & Moss 93] </ref> to compare the performance of software checks and page protection using our software exception mechanism. Depending on the relative costs of software checks and exceptions, and the number of exceptions, a break-even point can be calculated for the two techniques. Following the notation in [Hosking & Moss 93], let x be the number of cycles required for each software check and c the number of software checks needed for a particular application.
Reference: [Kane & Heinrich 92] <author> G. Kane and J. Heinrich. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey 07632, </address> <year> 1992. </year>
Reference-contexts: Thus, our mechanism is no worse than existing ones in this respect. In any case, such looping can be handled in Unix by signals that unconditionally terminate a process. A user process can choose to handle any synchronous exception supported by the MIPS architecture <ref> [Kane & Heinrich 92] </ref>, with the exception of system calls, co-processor unusable exceptions, and page faults. Our system does deliver to the user any TLB faults caused by page protection violations.
Reference: [Kranz et al. 89] <author> D. A. Kranz, R. H. Halstead, and E. Mohr. Mul-T: </author> <title> A high-performance parallel Lisp. </title> <booktitle> In Proceedings of SIGPLAN '89 Symposium on Progamming Languages Design and Implementation, </booktitle> <pages> pages 81-90, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: A program that tries to access the unevaluated part takes an unaligned access fault that extends the list appropriately. The mechanism of unaligned exceptions can be extended in a conceptually similar way to implement constructs such as futures <ref> [Kranz et al. 89] </ref>. One obvious approach is to represent an unresolved future as an unaligned pointer. When the value of the future is available, the pointer is updated and aligned. In fact, the APRIL processor used in the Alewife machine does precisely this [Agarwal et al. 90].
Reference: [Li & Hudak 89] <author> K. Li and P. Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: However, applications and run-time systems are using exception mechanisms increasingly and in novel ways; for example, exceptions are being used for garbage collection [Appel et al. 88], conditional watchpoints [Wahbe 92], transaction support [Chang & Mergen 88], persistent storage management [Wilson & Kakkad 92], and distributed virtual memory <ref> [Li & Hudak 89] </ref>. To compound the problem, several studies y Author's current address: DEC Systems Research Center, 130 Lytton Avenue, Palo Alto, CA 94301. This work was supported in part by the National Science Foundation (Grants No.
Reference: [Lieberman & Hewitt 83] <author> H. Lieberman and C. Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Communications of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: Otherwise, the operation of the collector is similar to that described in [Boehm & Weiser 88]. A generational garbage collector separates heap objects as belonging to multiple generations. Empirical evidence has shown that most of the garbage is created in younger (more recently allocated) rather than older generations <ref> [Lieberman & Hewitt 83, Ungar 84] </ref>. Hence, most of the collection can be performed by scanning the newer generations. Occasionally, there are pointers from outside the collected area, i.e., from older generations back into younger ones. The collector must consider these during a collection.
Reference: [Massalin & Pu 89] <author> H. Massalin and C. Pu. </author> <title> Threads and input/output in the Synthesis kernel. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: In any case, our software prototype allows us to experiment with fast user-level exception delivery and measure or estimate its impact on several simple applications. A key factor in our improved performance is our reduction of state saving and user-kernel boundary crossings, a strategy similar to that used in <ref> [Massalin & Pu 89] </ref> and [Patience 93]. The software mechanism described here was implemented on the DECstation MIPS R3000 processor running the DEC Ultrix 4.2A kernel.
Reference: [Ousterhout 90] <author> J. K. Ousterhout. </author> <booktitle> Why aren't operating systems getting faster as fast as hardware? In Proceedings of the Summer 1990 USENIX Conference, </booktitle> <pages> pages 247-256, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Null Handler 31 64 208 136 24 25 Simple Exception Round-Trip 80 2001 256 200 69 175 Delivery and Return Table 1: Performance of basic exception functions on modern systems. have shown that the relative cost of exception handling on modern RISCs has actually increased, when compared to past-generation architectures <ref> [Ousterhout 90, Anderson et al. 91] </ref>. A crucial difference between interrupts and exceptions is that, in the latter case, the information needed to respond typically lies within the application program or run-time system, not within the kernel.
Reference: [Patience 93] <author> S. Patience. </author> <title> Redirecting system calls in Mach 3.0, an alternative to the emulator. </title> <booktitle> In Proceedings of the USENIX Mach III Symposium, </booktitle> <pages> pages 57-74, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: A key factor in our improved performance is our reduction of state saving and user-kernel boundary crossings, a strategy similar to that used in [Massalin & Pu 89] and <ref> [Patience 93] </ref>. The software mechanism described here was implemented on the DECstation MIPS R3000 processor running the DEC Ultrix 4.2A kernel.
Reference: [Ungar 84] <author> D. M. Ungar. </author> <title> Generation scavenging: A non-disruptive high-performance storage reclamation algorithm. </title> <booktitle> In ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 157-167, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Otherwise, the operation of the collector is similar to that described in [Boehm & Weiser 88]. A generational garbage collector separates heap objects as belonging to multiple generations. Empirical evidence has shown that most of the garbage is created in younger (more recently allocated) rather than older generations <ref> [Lieberman & Hewitt 83, Ungar 84] </ref>. Hence, most of the collection can be performed by scanning the newer generations. Occasionally, there are pointers from outside the collected area, i.e., from older generations back into younger ones. The collector must consider these during a collection.
Reference: [Wahbe 92] <author> R. Wahbe. </author> <title> Efficient data breakpoints. </title> <booktitle> In Proceedings of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 200-212, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: However, applications and run-time systems are using exception mechanisms increasingly and in novel ways; for example, exceptions are being used for garbage collection [Appel et al. 88], conditional watchpoints <ref> [Wahbe 92] </ref>, transaction support [Chang & Mergen 88], persistent storage management [Wilson & Kakkad 92], and distributed virtual memory [Li & Hudak 89]. To compound the problem, several studies y Author's current address: DEC Systems Research Center, 130 Lytton Avenue, Palo Alto, CA 94301.
Reference: [White & DeWitt 92] <author> S. J. White and D. J. DeWitt. </author> <title> A performance study of alternative object faulting and pointer swizzling strategies. </title> <booktitle> In Proceedings of the 18th VLDB Conference, </booktitle> <pages> pages 419-431, </pages> <year> 1992. </year>
Reference-contexts: Persistent systems use several common approaches to handling this transparent data movement and the swizzling of pointers. In the first approach, the compiler inserts software checks at each potential pointer dereference site <ref> [White & DeWitt 92] </ref>. If the user dereferences a pointer that refers to data on stable storage, the check will detect an unswizzled pointer and cause that data to be brought into memory.
Reference: [Wilson & Kakkad 92] <author> P. R. Wilson and S. V. Kakkad. </author> <title> Pointer swizzling at page fault time: Efficiently and compatibly supporting huge address spaces on standard hardware. </title> <booktitle> In Proceedings of the 1992 International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 364-377, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: However, applications and run-time systems are using exception mechanisms increasingly and in novel ways; for example, exceptions are being used for garbage collection [Appel et al. 88], conditional watchpoints [Wahbe 92], transaction support [Chang & Mergen 88], persistent storage management <ref> [Wilson & Kakkad 92] </ref>, and distributed virtual memory [Li & Hudak 89]. To compound the problem, several studies y Author's current address: DEC Systems Research Center, 130 Lytton Avenue, Palo Alto, CA 94301. This work was supported in part by the National Science Foundation (Grants No. <p> The time to deliver a write protection exception is shown as well, since write protection is often used to detect dirty pages for garbage collection [Appel et al. 88], pointer swizzling <ref> [Wilson & Kakkad 92] </ref>, and other applications. From the bottom row, we see that the delivery to and return from a null user-level exception handler takes 69 seconds in the best case of SunOS, to 2 milliseconds for Mach/UX. <p> For our mechanism, software checks pay only in the shaded area. Irrespective of whether swizzling is done using exceptions or software checks, there are two variations of swizzling: eager swizzling and lazy swizzling. In eager swizzling <ref> [Wilson & Kakkad 92] </ref>, when an object is loaded, all the pointers within that object are found. Non-resident objects referenced by those pointers are then assigned virtual address space, and the pointers are swizzled to point to those non-resident virtual pages.
Reference: [Young 89] <author> M. W. Young. </author> <title> Exporting a User Interface to Memory Management from a Communication-Oriented Operating System. </title> <type> Ph.D. dissertation, </type> <institution> Carnegie Mellon University, </institution> <month> November </month> <year> 1989. </year> <note> Technical Report CMU-CS-89-202. </note>
Reference-contexts: The kernel is thus the wrong transfer target for an exception; vectoring to the kernel only adds unnecessary time and complexity to the processing of the exception. On modern systems, the kernel may need user-level knowledge even for page fault handling <ref> [Young 89] </ref>.
References-found: 22

