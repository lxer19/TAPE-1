URL: http://www.cs.uni-bonn.de/~cully/PUBLICATIONS/LPNMR95.ps.gz
Refering-URL: http://www.cs.uni-bonn.de/~cully/research1.html
Root-URL: http://cs.uni-bonn.de
Email: email: cully@cs.uni-bonn.de  
Title: Stable Classes and Operator Pairs for Disjunctive Programs  
Author: Jurgen Kalinski 
Address: 53117 Bonn, Germany  
Affiliation: Institute of Computer Science III University of Bonn, Romerstr. 164  
Abstract: Baral and Subrahmanian introduced the notion of stable classes for normal logic programs. In contrast to stable models stable classes always exist and can be given a constructive characterization. We generalize the Baral-Subrahmanian approach to disjunctive programs and propose mf -stable classes for different functions mf . Such mf -stable classes always exist and are sound with respect to stable model semantics. Operationalizations for approximate but efficient query evaluation are defined in terms of three-valued interpretations and their relation with mf -stable classes is analyzed. Finally, analogous concepts are given for an approach based on states instead of models. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Krzysztof Apt, Howard A. Blair, and Adrian Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of deductive databases and logic programmming, </booktitle> <pages> pages 32-41. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1987. </year>
Reference-contexts: Positive rules specify which facts can be derived from others: prescribe (P; medicine1) diagnosis (P; disease1) Negation allows the derivation of facts based on the absence of information about other facts: prescribe (P; medicine2) diagnosis (P; disease2); :allergic (P; ingredient) This clinical database satisfies the syntactic restriction of stratifiability (see <ref> [1] </ref>). Although we cannot discuss this concept here, we mention that stratifiability may get lost, when a program is rewritten for query-oriented bottom-up evaluation by the magic-sets method (e.g. in r :p; :q; q p; p s).
Reference: 2. <author> Chitta Baral and V. S. Subrahmanian. </author> <title> Dualities between alternative semantics for logic programming and nonmonotonic reasoning. </title> <booktitle> In LPNMR91 [10], </booktitle> <pages> pages 69-86. </pages>
Reference-contexts: Unfortunately, stable models do not necessarily exist, and even when they exist they are hard to compute. Baral and Subrahmanian therefore introduced the notion of stable classes for normal programs (cf. <ref> [2] </ref> and [3]). Essentially, a stable class is a set I of interpretations such that I = f S P (I) j I 2 I g where S P is an antimonotonic operator. <p> When they exist, there might be an exponential number of them. Baral and Subrahmanian have therefore introduced the alternative concept of stable classes for normal programs (cf. <ref> [2] </ref> and [3]). Whereas stable model semantics uses a single assumptive interpretation for the Gelfond-Lifschitz transformation and checks whether this guess can be verified, Baral and Sub-rahmanian start from a whole set of assumptions yielding a set of program transformations and correspondingly a smallest model for each of them. <p> The Baral-Subrahmanian filter has already been mentioned above: mf &gt; (I) := f J j J B P and there is I 2 I such that J is a minimal model of P=I g For normal programs every fixpoint of this filter is a stable class in the sense of <ref> [2] </ref> and every singleton fixpoint is a stable model. <p> The operators S P and S _ P are anti-monotonic. Therefore S 2 P and P are monotonic. It has been observed by Baral and Subrahmanian that lfp (S 2 P ) and gfp (S 2 provide a constructive characterization of certain stable classes for normal programs (see <ref> [2] </ref> and [3]). In the next section Baral and Subrahmanian's constructive characterization will be generalized for disjunctive programs. It will be for mulated in terms of standard operators, such that existing implementations and algorithms can be exploited within query evaluation procedures for disjunctive programs (e.g. [19]). <p> Operator pairs as presented in our paper are a kind of instantiation of Przymusinski's schema. The formulation in terms of standard logic programming operators allows to reuse existing implementation techniques. Baral and Subrahmanian <ref> [2] </ref> present a generalization of their approach for autoepistemic reasoning which is, however, not sound with respect to Moore's Autoepistemic Logic [14]. As proved in [7], mf c can be given a sound general ization in the autoepistemic case.
Reference: 3. <author> Chitta R. Baral and V. S. Subrahmanian. </author> <title> Stable and extension class theory for logic programs and default logics. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 8 </volume> <pages> 345-366, </pages> <year> 1992. </year>
Reference-contexts: Unfortunately, stable models do not necessarily exist, and even when they exist they are hard to compute. Baral and Subrahmanian therefore introduced the notion of stable classes for normal programs (cf. [2] and <ref> [3] </ref>). Essentially, a stable class is a set I of interpretations such that I = f S P (I) j I 2 I g where S P is an antimonotonic operator. <p> When they exist, there might be an exponential number of them. Baral and Subrahmanian have therefore introduced the alternative concept of stable classes for normal programs (cf. [2] and <ref> [3] </ref>). Whereas stable model semantics uses a single assumptive interpretation for the Gelfond-Lifschitz transformation and checks whether this guess can be verified, Baral and Sub-rahmanian start from a whole set of assumptions yielding a set of program transformations and correspondingly a smallest model for each of them. <p> Therefore S 2 P and P are monotonic. It has been observed by Baral and Subrahmanian that lfp (S 2 P ) and gfp (S 2 provide a constructive characterization of certain stable classes for normal programs (see [2] and <ref> [3] </ref>). In the next section Baral and Subrahmanian's constructive characterization will be generalized for disjunctive programs. It will be for mulated in terms of standard operators, such that existing implementations and algorithms can be exploited within query evaluation procedures for disjunctive programs (e.g. [19]). <p> then reads: Only when there is no evidence whatever for someone's guilt, then he can be assumed to be inno cent (p hS _ P ;S P N+ i leaves the status of guilty (a), innocent (a), guilty (b) and innocent (b) undetermined). 8 Related Work As Baral and Subrahmanian <ref> [3] </ref> mention, Van Gelder's `alternating fixpoint construction' [23] is essentially equivalent to their constructive characterization of stable classes. Both approaches confine their attention to normal programs. Fitting [4] has recently studied the connections between extremal models in the broad setting of bilattices.
Reference: 4. <author> Melvin Fitting. </author> <title> The family of stable models. </title> <journal> Journal of Logic Programming, </journal> <volume> 17 </volume> <pages> 197-225, </pages> <year> 1993. </year>
Reference-contexts: Both approaches confine their attention to normal programs. Fitting <ref> [4] </ref> has recently studied the connections between extremal models in the broad setting of bilattices. All these approaches are based a single operator, whereas we pointed out how the application of operator pairs to three-valued interpretations allows to capture disjunctive programs as well.
Reference: 5. <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Proc. of the 5th Int. Conf. and Symp. on Logic Programming, </booktitle> <pages> pages 1070-1080. </pages> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Stable model semantics as proposed by Gelfond and Lifschitz <ref> [5] </ref> is one of the most elegant approaches concerning the semantics of normal logic programs. It generalizes the perfect model semantics and is closely related with Autoepis-temic Logic [14] as a major formalization of nonmonotonic reasoning. <p> We therefore directly introduce the notion of stable models as a generalization of the stratification approach. Let us assume that the Herbrand interpretation I is one of the intended models of P . Negative literals can now be interpreted on the background of I. Definition 2. (Gelfond/Lifschitz <ref> [5] </ref>) Let P be a disjunctive program and I a Herbrand interpretation. The Gelfond-Lifschitz transformation P=I of P modulo I is defined by the following procedure: Remove every rule whose body contains some :A with A 2 I. Delete every expression :A in the remaining rules. <p> Delete every expression :A in the remaining rules. Interpretation I is nothing but an assumption. So we still have to `verify' this guess. Definition 3. (Gelfond/Lifschitz <ref> [5] </ref> [6], Przymusinski [17]) Let P be a disjunctive program. A Herbrand interpretation I is called a stable model of P , if it is a minimal model of P=I. If P is normal, a stable model is the smallest model of P=I.
Reference: 6. <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Classical negation in logic programs and disjunctive databases. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 365-385, </pages> <year> 1991. </year>
Reference-contexts: It generalizes the perfect model semantics and is closely related with Autoepis-temic Logic [14] as a major formalization of nonmonotonic reasoning. Furthermore, stable model semantics could subsequently be extended to disjunctive logic programs (Gelfond and Lifschitz <ref> [6] </ref>, by Przymusinski [17]). Unfortunately, stable models do not necessarily exist, and even when they exist they are hard to compute. Baral and Subrahmanian therefore introduced the notion of stable classes for normal programs (cf. [2] and [3]). <p> Delete every expression :A in the remaining rules. Interpretation I is nothing but an assumption. So we still have to `verify' this guess. Definition 3. (Gelfond/Lifschitz [5] <ref> [6] </ref>, Przymusinski [17]) Let P be a disjunctive program. A Herbrand interpretation I is called a stable model of P , if it is a minimal model of P=I. If P is normal, a stable model is the smallest model of P=I.
Reference: 7. <author> Jurgen Kalinski. </author> <title> Weak Autoepistemic Reasoning | A Study in Autoepistemic Reasoning from a Logic Programming Perspective. </title> <type> PhD thesis, </type> <institution> Universitat Bonn, </institution> <year> 1994. </year>
Reference-contexts: The first one defines the well-founded semantics, whereas the second can be shown to be equivalent with Fitting-Kunen semantics (see <ref> [7] </ref>). <p> Definition 18. A disjunctive state is a set S of ground disjunctions such that ffi 2 S implies ffi 0 2 S for every clause ffi 0 ffi. 5 A more detailed description can be found in <ref> [7] </ref>. 6 The algorithm is essentially an instantiation of Kautz and Selman's knowledge com pilation scheme [20], [8]. 14 For positive programs P we define ST (P ) := f ffi j P ` ffi g to be the set of all ground disjunctions that can be inferred from P . <p> The former interprets the negation as "It is not known that p", whereas the latter reads it as "There is no evidence for p". In fact, stable states are a special case of autoepistemic expansions (see <ref> [7] </ref>). In order to stress this point consider a positive program. In the stable model semantics false means false in every minimal model , whereas in the stable state approach it means false in some minimal model ! Definition 20. <p> In fact, it would be more adequate to study such minimal representations instead of interpretations in the current section (see <ref> [7] </ref>). We prefer to use interpretations just for the sake of brevity. 15 Theorem 22. Let P be a disjunctive program, P N an enriched normal frag- ment and P N+ a weak normalization. <p> The formulation in terms of standard logic programming operators allows to reuse existing implementation techniques. Baral and Subrahmanian [2] present a generalization of their approach for autoepistemic reasoning which is, however, not sound with respect to Moore's Autoepistemic Logic [14]. As proved in <ref> [7] </ref>, mf c can be given a sound general ization in the autoepistemic case.
Reference: 8. <author> Henry Kautz and Bart Selman. </author> <title> An empirical evaluation of knowledge compilation by theory approximation. </title> <booktitle> In Proc. of the 12th National Conf. on Artificial Intelligence (AAAI), </booktitle> <pages> pages 155-161, </pages> <year> 1994. </year>
Reference-contexts: state is a set S of ground disjunctions such that ffi 2 S implies ffi 0 2 S for every clause ffi 0 ffi. 5 A more detailed description can be found in [7]. 6 The algorithm is essentially an instantiation of Kautz and Selman's knowledge com pilation scheme [20], <ref> [8] </ref>. 14 For positive programs P we define ST (P ) := f ffi j P ` ffi g to be the set of all ground disjunctions that can be inferred from P . The Gelfond-Lifschitz transformation is extended from interpretations (i.e. sets of atoms) to sets of disjunctions.
Reference: 9. <author> Jorge Lobo, Jack Minker, and Arcot Rajasekar. </author> <title> Foundations of Disjunctive Logic Programmming. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Note that this is nothing but the complement of the so-called generalized closed world assumption GCWA. As even for positive programs GCWA is hard to compute, the weak generalized closed world assumption WGCWA has been proposed as an efficient alternative (cf. <ref> [9] </ref> and [18] where it is called disjunctive database rule). <p> Let P be a disjunctive program. If A is true in some minimal model of P=I, then A 2 S P N+(I). Proof. For every I B P we have S P N+(I) = lfp (T P N+ =I ) = lfp (T (P=I) N+). Theorem 6.4 of <ref> [9] </ref> then states that lfp (T (P=I) N+ ) J for every minimal model J of P=I. ut Theorem 16. The mapping p hS _ P ;S P N+ i defined by p hS _ P (I 2 ); S P N+(I 1 ) i is a three-valued operator pair.
Reference: 10. <editor> Proc. </editor> <booktitle> of the 1st Int. Workshop on Logic Programming and Non-monotonic Reasoning. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference: 11. <author> Wiktor Marek and Miroslaw Truszczynski. </author> <title> Autoepistemic logic. </title> <journal> Journal of the ACM, </journal> <volume> 38(3) </volume> <pages> 588-619, </pages> <year> 1991. </year>
Reference-contexts: But both J 1 and J 2 are minimal models of P=J 1 = P=J 2 = P=I 1 and thereby stable. 3 Model Filters 3.1 Basic Concepts Stable models must not necessarily exist and it is hard to decide whether there is one (cf. <ref> [11] </ref> and [12]). When they exist, there might be an exponential number of them. Baral and Subrahmanian have therefore introduced the alternative concept of stable classes for normal programs (cf. [2] and [3]). <p> Despite of the fact that the complexity results of <ref> [11] </ref> and [12] seem to rule out precomputations of stable models in large applications, they cannot be interrupted. In our approach, when precom-putation becomes too expensive or when a maximal number of resolvents has been generated, it can simply be stopped. Runtime query evaluation refers to normal programs only.
Reference: 12. <author> Wiktor Marek and Miroslaw Truszczynski. </author> <title> Computing intersection of autoepis-temic expansions. </title> <booktitle> In LPNMR91 [10], </booktitle> <pages> pages 37-50. </pages>
Reference-contexts: But both J 1 and J 2 are minimal models of P=J 1 = P=J 2 = P=I 1 and thereby stable. 3 Model Filters 3.1 Basic Concepts Stable models must not necessarily exist and it is hard to decide whether there is one (cf. [11] and <ref> [12] </ref>). When they exist, there might be an exponential number of them. Baral and Subrahmanian have therefore introduced the alternative concept of stable classes for normal programs (cf. [2] and [3]). <p> Despite of the fact that the complexity results of [11] and <ref> [12] </ref> seem to rule out precomputations of stable models in large applications, they cannot be interrupted. In our approach, when precom-putation becomes too expensive or when a maximal number of resolvents has been generated, it can simply be stopped. Runtime query evaluation refers to normal programs only.
Reference: 13. <author> Jack Minker and Arcot Rajasekar. </author> <title> A fixpoint semantics for disjunctive logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 9 </volume> <pages> 45-74, </pages> <year> 1990. </year>
Reference-contexts: The reader is assumed to be familiar with van Emden and Kowalski's immediate consequence operator T P (cf. [21]). For positive disjunctive programs an appropriate monotonic operator on disjunctions of atoms has been proposed by Minker and Rajasekar (cf. <ref> [13] </ref>): T _ P (I) = f ffi j ffi a disjunction of atoms; fi A 1 ; : : : ; A n 2 P; A i _ fl i 2 I for 1 i n; ffi = fi _ fl 1 _ : : : _ fl n g <p> (I) = f ffi j ffi a disjunction of atoms; fi A 1 ; : : : ; A n 2 P; A i _ fl i 2 I for 1 i n; ffi = fi _ fl 1 _ : : : _ fl n g Theorem 1. (Minker/Rajasekar <ref> [13] </ref>) Let P be a positive disjunctive program and ffi a disjunction of atoms. Then the following are equivalent: 1. ffi is a logical consequence of P . 2. ffi 0 2 lfp (T _ P ) for some subclause ffi 0 ffi. 2 Example 1.
Reference: 14. <author> Robert C. Moore. </author> <title> Semantical considerations on nonmonotonic logic. </title> <journal> Artificial Intelligence, </journal> <volume> 25(4) </volume> <pages> 75-94, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction Stable model semantics as proposed by Gelfond and Lifschitz [5] is one of the most elegant approaches concerning the semantics of normal logic programs. It generalizes the perfect model semantics and is closely related with Autoepis-temic Logic <ref> [14] </ref> as a major formalization of nonmonotonic reasoning. Furthermore, stable model semantics could subsequently be extended to disjunctive logic programs (Gelfond and Lifschitz [6], by Przymusinski [17]). Unfortunately, stable models do not necessarily exist, and even when they exist they are hard to compute. <p> The formulation in terms of standard logic programming operators allows to reuse existing implementation techniques. Baral and Subrahmanian [2] present a generalization of their approach for autoepistemic reasoning which is, however, not sound with respect to Moore's Autoepistemic Logic <ref> [14] </ref>. As proved in [7], mf c can be given a sound general ization in the autoepistemic case.
Reference: 15. <author> Teodor C. Przymusinski. </author> <title> Extended stable semantics for normal and disjunctive programs. </title> <booktitle> In Proc. of the 7th Int. Conf. on Logic Programming, </booktitle> <pages> pages 459-477. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year> <month> 17 </month>
Reference-contexts: The transformation mapping will consist of two components as well: one for the derivation of necessary and another one for the derivation of potential truths. 3 In <ref> [15] </ref> this is called the Fitting-ordering in contrast to the standard ordering. 10 Definition 13. <p> For normal programs the well-founded semantics p hS P ;S P i (see e.g. <ref> [15] </ref>) commutes with mf C . 4 5 Operator Pair Based on WGCWA The best complete model filter mf C refers to the set of all atoms that are true in some minimal model of P=I.
Reference: 16. <author> Teodor C. Przymusinski. </author> <title> Autoepistemic logics of closed beliefs and logic program-ming. </title> <booktitle> In LPNMR91 [10], </booktitle> <pages> pages 3-20. </pages>
Reference-contexts: Fitting [4] has recently studied the connections between extremal models in the broad setting of bilattices. All these approaches are based a single operator, whereas we pointed out how the application of operator pairs to three-valued interpretations allows to capture disjunctive programs as well. Przymusinski <ref> [16] </ref> presents a very general framework for nonmonotonic reasoning which also makes use of two different inference operators. Operator pairs as presented in our paper are a kind of instantiation of Przymusinski's schema. The formulation in terms of standard logic programming operators allows to reuse existing implementation techniques.
Reference: 17. <author> Teodor C. Przymusinski. </author> <title> Stable semantics for disjunctive programs. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 401-424, </pages> <year> 1991. </year>
Reference-contexts: It generalizes the perfect model semantics and is closely related with Autoepis-temic Logic [14] as a major formalization of nonmonotonic reasoning. Furthermore, stable model semantics could subsequently be extended to disjunctive logic programs (Gelfond and Lifschitz [6], by Przymusinski <ref> [17] </ref>). Unfortunately, stable models do not necessarily exist, and even when they exist they are hard to compute. Baral and Subrahmanian therefore introduced the notion of stable classes for normal programs (cf. [2] and [3]). <p> Delete every expression :A in the remaining rules. Interpretation I is nothing but an assumption. So we still have to `verify' this guess. Definition 3. (Gelfond/Lifschitz [5] [6], Przymusinski <ref> [17] </ref>) Let P be a disjunctive program. A Herbrand interpretation I is called a stable model of P , if it is a minimal model of P=I. If P is normal, a stable model is the smallest model of P=I.
Reference: 18. <author> K. A. Ross and R. W. Topor. </author> <title> Inferring negative information from disjunctive databases. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 4 </volume> <pages> 397-424, </pages> <year> 1988. </year>
Reference-contexts: Note that this is nothing but the complement of the so-called generalized closed world assumption GCWA. As even for positive programs GCWA is hard to compute, the weak generalized closed world assumption WGCWA has been proposed as an efficient alternative (cf. [9] and <ref> [18] </ref> where it is called disjunctive database rule).
Reference: 19. <author> Dietmar Seipel. </author> <title> Non-monotonic reasoning based on minimal models and its efficient implementation. </title> <editor> In Bernd Wolfinger, editor, Innovationen bei Rechen- und Kommunikationssystemen, GI-Fachgesprach: </editor> <booktitle> Disjunctive logic programming and disjunctive databases, </booktitle> <pages> pages 53-60. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: In the next section Baral and Subrahmanian's constructive characterization will be generalized for disjunctive programs. It will be for mulated in terms of standard operators, such that existing implementations and algorithms can be exploited within query evaluation procedures for disjunctive programs (e.g. <ref> [19] </ref>).
Reference: 20. <author> Bart Selman and Henry Kautz. </author> <title> Knowledge compilation using Horn approximations. </title> <booktitle> In Proc. of the 9th National Conf. on Artificial Intelligence, </booktitle> <pages> pages 904-909, </pages> <year> 1991. </year>
Reference-contexts: disjunctive state is a set S of ground disjunctions such that ffi 2 S implies ffi 0 2 S for every clause ffi 0 ffi. 5 A more detailed description can be found in [7]. 6 The algorithm is essentially an instantiation of Kautz and Selman's knowledge com pilation scheme <ref> [20] </ref>, [8]. 14 For positive programs P we define ST (P ) := f ffi j P ` ffi g to be the set of all ground disjunctions that can be inferred from P . The Gelfond-Lifschitz transformation is extended from interpretations (i.e. sets of atoms) to sets of disjunctions. <p> As proved in [7], mf c can be given a sound general ization in the autoepistemic case. Knowledge Compilation has been studied by Selman and Kautz in a series of papers (e.g. <ref> [20] </ref>) where they concentrate on the monotonic case. 9 Conclusion We have shown that the notion of stable classes can be naturally extended to disjunctive programs and that stable classes exist for a whole lattice of filter operators. Three-valued interpretations are isomorphic to complete sets of interpretations.
Reference: 21. <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: The set of minimal models of a positive program will be denoted by MIN (P ). The reader is assumed to be familiar with van Emden and Kowalski's immediate consequence operator T P (cf. <ref> [21] </ref>).
Reference: 22. <author> A. Van Gelder, K. A. Ross, and J. S. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> Journal of the ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: They furthermore show that this stable class is equivalent to the well-founded semantics, another (by now) standard formalization of the meaning of normal logic programs <ref> [22] </ref> which is more efficient than the stable model semantics. The goal of this paper is to provide a generalization of stable classes for dis-junctive programs and constructive characterizations for query evaluation pro cedures. The main results are: 1. <p> In our approach, when precom-putation becomes too expensive or when a maximal number of resolvents has been generated, it can simply be stopped. Runtime query evaluation refers to normal programs only. Its complexity in the propositional case is thus quadratic (see <ref> [22] </ref>). 7 State-Based Filters and Pairs The formalism presented above can easily be adapted to alternative concepts. While the definition of model filters refers to models, one might as well consider disjunctive states. We will shortly sketch, how this view can be expressed within our framework. Definition 18.
Reference: 23. <author> Allen Van Gelder. </author> <title> The alternating fixpoint of logic programs with negation. </title> <booktitle> In Proc. of the 8th Symp. on Principles of Database Systems, </booktitle> <pages> pages 1-10, </pages> <year> 1989. </year> <title> This article was processed using the L A T E X macro package with LLNCS style 18 </title>
Reference-contexts: evidence whatever for someone's guilt, then he can be assumed to be inno cent (p hS _ P ;S P N+ i leaves the status of guilty (a), innocent (a), guilty (b) and innocent (b) undetermined). 8 Related Work As Baral and Subrahmanian [3] mention, Van Gelder's `alternating fixpoint construction' <ref> [23] </ref> is essentially equivalent to their constructive characterization of stable classes. Both approaches confine their attention to normal programs. Fitting [4] has recently studied the connections between extremal models in the broad setting of bilattices.
References-found: 23

