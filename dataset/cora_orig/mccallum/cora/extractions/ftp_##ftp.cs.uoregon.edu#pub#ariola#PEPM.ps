URL: ftp://ftp.cs.uoregon.edu/pub/ariola/PEPM.ps
Refering-URL: http://www.cs.uoregon.edu/~ariola/publications.html
Root-URL: http://www.cs.uoregon.edu
Title: A Syntactic Approach to Program Transformations  
Author: Zena M. Ariola Arvind 
Keyword: and phrases: -calculus, Term Rewriting Systems, Contextual Rewriting Systems, Confluence, Optimizations, Correctness, Intermediate Language, Non-strictness.  
Affiliation: Aiken Computational Laboratory Harvard University  Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: Kid, a language for expressing compiler optimizations for functional languages is introduced. The language is -calculus based but treats let-blocks as first class objects. Let-blocks and associated rewrite rules provide the basis to capture the sharing of subexpressions precisely. The language goes beyond -calculus by including I-structures which are essential to express efficient translations of list and array comprehensions. A calculus and a parallel interpreter for Kid are developed. Many commonly known program transformations are also presented. A partial evaluator for Kid is developed and a notion of correctness of Kid transformations based on the syntactic structure of terms and printable answers is presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, J. Ullman, and R. Sethi. </author> <booktitle> Compilers: Principles, Techniques, Tools. </booktitle> <address> London, </address> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: A binding in a CRS block may be viewed as an instruction because its right-hand-side (rhs) consists of an operator followed by variables and constants. When functions have arity 2, this format recalls the three-address-code used as an intermediate language by conventional compilers <ref> [1] </ref>. 2.2 A CRS for Combinatory Logic The signature F for combinatory logic contains two constants S and K, and one function symbol Apply of arity two.
Reference: [2] <author> Z. M. Ariola and Arvind. P-TAC: </author> <title> A Parallel Intermediate Language. </title> <booktitle> In Proc. ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> London, </address> <year> 1989. </year>
Reference-contexts: Kid has also proved to be an extremely useful intermediate language for the Id compiler [3]. Within the compiler, all machine in dependent optimizations are expressed as source-to-source program transformations in Kid. Kid is a much more refined version of the language P-TAC presented earlier by the authors <ref> [2] </ref>. Kid's operational semantics and associated calculus are innovative, and given in terms of a Contextual Rewriting System (CRS) [4]. Since Kid, relative to the -calculus, is a large language, we introduce it in steps, introducing a new feature at each step. <p> Block Flattening rule fX = f SS 1 ; SS 2 ; fX = Y ; S 1 ; S n S 1 ; S n Lemma 2.1 R CRS is Strongly Normalizing and Confluent. Proof: See <ref> [2] </ref>. 2.4 Canonical Forms of terms in a CRS The following two terms have apparently different syntactic structure. fx = 8; t 0 = fy = x; t = x + y In tg In t 0 g and However, we consider the difference between the above two terms merely "syntactic <p> Proof: See <ref> [2] </ref>. 6.2 Printable Values and Answer of a Kid Term We now define the printable information associated with a term. <p> X = + (X 1 ; m) & m &gt; 0 Less (X 1 ; X) ! True X = + (X 1 ; m) & m &gt; 0 Equal? (X 1 ; X) ! False . . . We have shown in <ref> [2] </ref> that Alg 3 rules cause the optimization rules to be non-confluent. However, this is not a serious drawback because the cases where the confluence is lost are the ones where the unoptimized program would have produced no information. <p> It has to be shown that no context can distinguish between optimized and unoptimized term. Definition 8.4 (Observational Congruence) Given two terms M and N, M and N are said to be Observationally Congruent iff 8 C <ref> [2] </ref>; Print fl (C [M ]) Print fl (C [N ]) : If we let (A; R) be a CRS, where A represents the set of terms, and R a set of rules, then correctness can be formu lated as follows: Definition 8.5 (Correctness) An optimizer (A,R o ) for (A,R) <p> It is believed that all optimizations presented in Section 8 preserve correctness, though this has been proven for only a small subset of them so far <ref> [2] </ref>. In general, correctness of an optimization is difficult to prove. However, some optimizations can be proven correct easily because they are derived rules.
Reference: [3] <author> Z. M. Ariola and Arvind. </author> <title> Compilation of Id : a Subset of Id. </title> <type> Technical Report CSG Memo 315, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Kid, a kernel language for Id, has been developed to give precise (though indirect) operational semantics of Id. Kid has also proved to be an extremely useful intermediate language for the Id compiler <ref> [3] </ref>. Within the compiler, all machine in dependent optimizations are expressed as source-to-source program transformations in Kid. Kid is a much more refined version of the language P-TAC presented earlier by the authors [2]. <p> Sub scripts in a function symbol do not necessarily represent the number of values to be returned by the application of the function. By convention, we drop the subscript when its value is one. (Exception Apply 1 6 Apply). A procedure to translate Id into Kid is given in <ref> [3] </ref>. 6.1 Kid Rewrite Rules We now present a set of rewrite rules, R Kid , which give an intuitive understanding of how Kid terms may get evalu ated.
Reference: [4] <author> Z. M. Ariola and Arvind. </author> <title> Contextual Rewriting. </title> <type> Technical Report CSG Memo 323, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1991. </year>
Reference-contexts: Kid is a much more refined version of the language P-TAC presented earlier by the authors [2]. Kid's operational semantics and associated calculus are innovative, and given in terms of a Contextual Rewriting System (CRS) <ref> [4] </ref>. Since Kid, relative to the -calculus, is a large language, we introduce it in steps, introducing a new feature at each step. No prior knowledge of Id or CRS's is assumed on the part of the reader. <p> Intuitively the canonical form of a term corresponds to the graph associated to the term. The reader may refer to <ref> [4] </ref> for a more rigorous definition of term graphs and alpha equivalence as rooted graph isomorphism. Lemma 2.4 Each term has a unique canonical form. 3 B -calculus The same term sharing ideas can be applied to the -calculus; for which we introduce the B -calculus, given in Figure 2. <p> The tree associated to a term is obtained intuitively by repeatetly substituting the rhs of a binding for each occurrence of the lhs. Let F l be the function that given a term produces the corresponding un-ravelled term <ref> [4] </ref>.
Reference: [5] <author> Arvind, R. S. Nikhil, and K. K. Pingali. I-Structures: </author> <title> Data Structures for Parallel Computing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4), </volume> <month> October </month> <year> 1989. </year>
Reference-contexts: 1 Introduction For a number of years at MIT we have been working with an implicit parallel language called Id. Id is a high level functional language [16] augmented with a novel data structuring facility known as I-structures <ref> [5] </ref>. Id, like most modern functional languages, is non-strict, and has higher-order functions and a Milner-style type system. It also has a fairly large syntax to express currying, loops, list and array comprehensions, and pattern matching for all algebraic types. <p> A block in Kid is not treated as syntactic sugar for applications; it is central to expressing the sharing of subexpressions. Kid also embodies the novel idea of multiple values (Section 4). In Section 5, we enrich our language by introducing I-structures <ref> [5] </ref>, which takes us beyond the realm of pure functional languages. Kid without loops is presented in Section 6, where we also introduce the notion of printable value and answer associated with a Kid term. <p> The usual translations [17] are unnecessarily sequential and elude to other implementation tricks to avoid construction of intermediate data structures. We believe I-structures <ref> [5] </ref> are essential to express efficient translation of many constructs in a language such as Haskell [12] and Miranda [20]. I-structures are "write-once" structures and differ from functional data structures in the sense that an I-structure can be defined incrementally. <p> An important fact to realize is that a functional language augmented with I-structures does not preserve "referential transparency" <ref> [5] </ref>. For example: f x = I array (x b ); In (x; x)g 6 (I array (x b ); I array (x b )) It is, therefore, essential to specify rules for sharing of subexpressions to give the semantics of I-structures.
Reference: [6] <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: The problem is usually solved either by making some variable convention, as for example, assuming that all free variables are different from the bound variables, or by adopting a variable-free notation such as that of DeBruijn [11]. According to the variable convention given in <ref> [6] </ref>, the term (x:xx)(x:xx) is a legal term, while the term (y:(x: + (x; y))x is not a legal term, because the variable x appears both free and bound.
Reference: [7] <author> H. P. Barendregt, T. H. Brus, M. C. J. D. van Eeke-len, J. R. W. Glauert, J. R. Kennaway, M. O. van Leer, M. J. Plasmeijer, and M. R. Sleep. </author> <title> Towards an Intermediate Language based on Graph Rewriting. </title> <booktitle> In Proceedings of the PARLE Conference, </booktitle> <address> Eindhoven, The Netherlands, </address> <publisher> Springer-Verlag LNCS 259, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Avoiding repeated evaluation of an expression is a central concern in implementations of non-strict functional languages. Not surprisingly, graph reduction [21], [19], [13], has been one of the popular ways of implementing functional languages, but it is only recently that people have investigated suitable calculii for graph rewriting <ref> [7] </ref>, [8], and [9]. Contextual Rewriting Systems, which we introduce in Section 2, represent another formalism to capture the sharing of subexpressions. The idea of having a calculus that reflects what happens operationally in a sequential implementation goes back to the work of Plotkin [18].
Reference: [8] <author> H. P. Barendregt, M. C. J. D. van Eekelen, J. R. W. Glauert, J. R. Kennaway, M. J. Plasmeijer, and M. R. Sleep. </author> <title> Term Graph Rewriting. </title> <booktitle> In Proceedings of the PARLE Conference, </booktitle> <address> Eindhoven, The Netherlands, </address> <publisher> Springer-Verlag LNCS 259, </publisher> <pages> pages 141-158, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Avoiding repeated evaluation of an expression is a central concern in implementations of non-strict functional languages. Not surprisingly, graph reduction [21], [19], [13], has been one of the popular ways of implementing functional languages, but it is only recently that people have investigated suitable calculii for graph rewriting [7], <ref> [8] </ref>, and [9]. Contextual Rewriting Systems, which we introduce in Section 2, represent another formalism to capture the sharing of subexpressions. The idea of having a calculus that reflects what happens operationally in a sequential implementation goes back to the work of Plotkin [18].
Reference: [9] <author> T. Brus, M. van Eekelen, M. vam Leer, and M. Plasmei-jer. </author> <title> Clean A Language for Functional Graph Rewriting. </title> <booktitle> In Proc. ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Portland, </address> <publisher> Oregon,Springer-Verlag LNCS 274, </publisher> <year> 1987. </year>
Reference-contexts: Not surprisingly, graph reduction [21], [19], [13], has been one of the popular ways of implementing functional languages, but it is only recently that people have investigated suitable calculii for graph rewriting [7], [8], and <ref> [9] </ref>. Contextual Rewriting Systems, which we introduce in Section 2, represent another formalism to capture the sharing of subexpressions. The idea of having a calculus that reflects what happens operationally in a sequential implementation goes back to the work of Plotkin [18].
Reference: [10] <author> B. Courcelle. </author> <title> Fundamentals Properties of Infinite Trees. </title> <address> D. </address> <publisher> Reidel Publishing Company, </publisher> <year> 1982. </year>
Reference-contexts: Theorem 6.3 P V is a complete partial order with respect to v. Proof: <ref> [10] </ref>. Lemma 6.4 Given a term M, M ! N =) Print (M ) v Print (N ): Pictorially: M ! M 1 ! M 2 Print (M ) v Print (M 1 ) v Print (M 2 ) Thus, the answer is the limit of this chain.
Reference: [11] <author> N. de Bruijn. </author> <title> Lambda Calculus Notation with Nameless Dummies: A Tool for Automatic Formula Manipulation, with Application to the Church-Rosser Theorem. </title> <editor> In Koninkijke Nederlandse Akademie van Wetenschap-pen, </editor> <title> Series A, </title> <journal> Mathematical Sciences, </journal> <year> 1972. </year>
Reference-contexts: In the -calculus one has to deal with the problem of free-variable capture. The problem is usually solved either by making some variable convention, as for example, assuming that all free variables are different from the bound variables, or by adopting a variable-free notation such as that of DeBruijn <ref> [11] </ref>. According to the variable convention given in [6], the term (x:xx)(x:xx) is a legal term, while the term (y:(x: + (x; y))x is not a legal term, because the variable x appears both free and bound.
Reference: [12] <author> P. Hudak and P. Wadler. </author> <title> Report on the Programming Language Haskell, A Non-strict Purely Functional Language (Version 1.0). </title> <type> Technical Report YALEU/DCS/RR777, </type> <institution> Yale University, Department of Computer Science, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: The usual translations [17] are unnecessarily sequential and elude to other implementation tricks to avoid construction of intermediate data structures. We believe I-structures [5] are essential to express efficient translation of many constructs in a language such as Haskell <ref> [12] </ref> and Miranda [20]. I-structures are "write-once" structures and differ from functional data structures in the sense that an I-structure can be defined incrementally. It is possible to define an array by giving its bounds only, i.e., I-array (x b ).
Reference: [13] <author> T. Johnsson. </author> <title> Efficient Compilation of Lazy Evaluation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '84 Symposium on Compiler Construction, </booktitle> <pages> pages 58-69, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: One of its primary deficiency is the inability to capture the sharing of subexpressions. Avoiding repeated evaluation of an expression is a central concern in implementations of non-strict functional languages. Not surprisingly, graph reduction [21], [19], <ref> [13] </ref>, has been one of the popular ways of implementing functional languages, but it is only recently that people have investigated suitable calculii for graph rewriting [7], [8], and [9]. Contextual Rewriting Systems, which we introduce in Section 2, represent another formalism to capture the sharing of subexpressions.
Reference: [14] <author> V. Kathail. </author> <title> Optimal Interpreters for Lambda-calculus Based Funtional Languages. </title> <month> May </month> <year> 1990. </year> <type> Ph.D. thesis, </type> <institution> Dept. of Electrical Engineering and Computer Science, MIT. </institution>
Reference-contexts: Thus, sharing aspects of CRS's have not ruled out non-strict implementations. However, the use of the function RB automatically rules out "context sharing", which is needed for optimal interpreters of the -calculus <ref> [14] </ref>.
Reference: [15] <author> J. Klop. </author> <title> Term Rewriting Systems. 1 s t Autumn workshop on Reduction Machines, </title> <address> Italy, </address> <month> September </month> <year> 1985. </year>
Reference-contexts: We solve this problem by requiring some annotations by the user. This additional information is reminiscent of a mechanism, called underlining in term rewriting systems, which has the effect of turning a set of rules into an equivalent strongly-normalizing set of rules <ref> [15] </ref>. There are also cases where we want to postpone the application of a certain Kid rule because it can obscure and, possibly, prohibit the applicability of some other optimizations because of loss of information. The cons-rule in Kid is a good example to illustrate this point.
Reference: [16] <author> R. S. Nikhil. </author> <title> Id (Version 90.0) Reference Manual. </title> <type> Technical Report CSG Memo 284-a, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: 1 Introduction For a number of years at MIT we have been working with an implicit parallel language called Id. Id is a high level functional language <ref> [16] </ref> augmented with a novel data structuring facility known as I-structures [5]. Id, like most modern functional languages, is non-strict, and has higher-order functions and a Milner-style type system.
Reference: [17] <editor> S. L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. Prentice-Hall International, </booktitle> <address> Englewood Cliffs, N.J., </address> <year> 1987. </year>
Reference-contexts: The usual translations <ref> [17] </ref> are unnecessarily sequential and elude to other implementation tricks to avoid construction of intermediate data structures. We believe I-structures [5] are essential to express efficient translation of many constructs in a language such as Haskell [12] and Miranda [20]. <p> A typical translation of a list-comprehension is given in terms of nested map-list operations followed by a list flattening operation <ref> [17] </ref>. In Id, we make use of "open lists" , a type of I-structure, to generate a tail recursive program.
Reference: [18] <author> G. Plotkin. </author> <title> Call-by-name, Call-by-value and the Lambda Calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: Contextual Rewriting Systems, which we introduce in Section 2, represent another formalism to capture the sharing of subexpressions. The idea of having a calculus that reflects what happens operationally in a sequential implementation goes back to the work of Plotkin <ref> [18] </ref>. The core of Kid consists of the -calculus with constants and letrec or block expressions (Section 3). A block in Kid is not treated as syntactic sugar for applications; it is central to expressing the sharing of subexpressions. Kid also embodies the novel idea of multiple values (Section 4).
Reference: [19] <author> D. A. Turner. </author> <title> A New Implemetation Technique for Applicative Languages. </title> <journal> In Software Practice and Experience, </journal> <volume> volume 9, </volume> <pages> pages 31-49, </pages> <year> 1979. </year>
Reference-contexts: One of its primary deficiency is the inability to capture the sharing of subexpressions. Avoiding repeated evaluation of an expression is a central concern in implementations of non-strict functional languages. Not surprisingly, graph reduction [21], <ref> [19] </ref>, [13], has been one of the popular ways of implementing functional languages, but it is only recently that people have investigated suitable calculii for graph rewriting [7], [8], and [9]. Contextual Rewriting Systems, which we introduce in Section 2, represent another formalism to capture the sharing of subexpressions.
Reference: [20] <author> D. A. Turner. Miranda: </author> <title> a non-strict functional language with polymorphic types. </title> <booktitle> In IFIP Int'l Conf. on Functional Programming and Computer Architecture, </booktitle> <address> Nancy, France, </address> <publisher> Springer-Verlag LNCS 201, </publisher> <year> 1985. </year>
Reference-contexts: The usual translations [17] are unnecessarily sequential and elude to other implementation tricks to avoid construction of intermediate data structures. We believe I-structures [5] are essential to express efficient translation of many constructs in a language such as Haskell [12] and Miranda <ref> [20] </ref>. I-structures are "write-once" structures and differ from functional data structures in the sense that an I-structure can be defined incrementally. It is possible to define an array by giving its bounds only, i.e., I-array (x b ).
Reference: [21] <author> C. Wadsworth. </author> <title> Semantics And Pragmatics Of The Lambda-Calculus. </title> <type> Ph.D. thesis, </type> <institution> University of Oxford, </institution> <month> Semtember </month> <year> 1971. </year>
Reference-contexts: One of its primary deficiency is the inability to capture the sharing of subexpressions. Avoiding repeated evaluation of an expression is a central concern in implementations of non-strict functional languages. Not surprisingly, graph reduction <ref> [21] </ref>, [19], [13], has been one of the popular ways of implementing functional languages, but it is only recently that people have investigated suitable calculii for graph rewriting [7], [8], and [9]. Contextual Rewriting Systems, which we introduce in Section 2, represent another formalism to capture the sharing of subexpressions.
Reference: [22] <author> C. Wadsworth. </author> <title> Approximate Reduction and Lambda Calculus Models. </title> <journal> Theoretical Computer Science, </journal> <volume> 7, </volume> <year> 1978. </year>
Reference-contexts: In order for the above definition to make sense we need to show that the limit of the printable reduction graph exists and is unique. Theorem 6.8 8 terms M, PG (M) is directed. Proof: Follows trivially from the confluence of Kid <ref> [22] </ref>.
References-found: 22

