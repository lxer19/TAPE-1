URL: http://www2.cs.cornell.edu/Info/Projects/CAM/hoti-94.ps
Refering-URL: http://www2.cs.cornell.edu/tve/pub.html
Root-URL: http://www.cs.cornell.edu
Title: Low-Latency Communication over ATM Networks using Active Messages  
Author: Thorsten von Eicken, Veena Avula, Anindya Basu, and Vineet Buch 
Address: Ithaca, NY14850  
Affiliation: Department of Computer Science Cornell University  
Note: Presented at Hot Interconnects II, Aug. 1994, Palo Alto, CA, abridged version in IEEE Micro, Feb 1995. hoti-tr.doc 3/7/95 1  http://www.cs.cornell.edu/Info/Projects/ATM/ Authors email:-tve,veena,basu,buch-@cs.cornell.edu This work is supported by an equipment gift from AT&T Copyright 1994 Institute of Electrical and Electronics Engineers. This is an extended version of an article from IEEE Micro Magazine; volume 15, issue 1, pp. 46-64; Feb 95. This material is posted under http://www.cs.cornell.edu/Info/ Projects/ATM/ with permission of the IEEE. Such permission of the IEEE does not in any way imply IEEE endorsement of any of Cornell Universitys products or services. Internal or personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution must be obtained from the IEEE by sending a blank email message to info.pub.permission@ieee.org. By choosing to view this document, you agree to all provisions of the copyright laws protecting it.  
Abstract: Recent developments in communication architectures for parallel machines have made significant progress and reduced the communication overheads and latencies by over an order of magnitude as compared to earlier proposals. This paper examines whether these techniques can carry over to clusters of workstations connected by an ATM network even though clusters use standard operating system software, are equipped with network interfaces optimized for stream communication, do not allow direct protected user-level access to the network, and use networks without reliable transmission or ow control. In a first part, this paper describes the differences in communication characteristics between clusters of workstations built from standard hardware and software components and state-of-the-art multiprocessors. The lack of ow control and of operating system coordination affects the communication layer design significantly and requires larger buffers at each end than on multiprocessors. A second part evaluates a prototype implementation of the low-latency Active Messages communication model on a Sun workstation cluster interconnected by an ATM network. Measurements show application-to-application latencies of about 20 microseconds for small messages which is roughly comparable to the Active Messages implementation on the Thinking Machines CM-5 multiprocessor. This paper and the described software are available at URL 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> CCITT. </author> <title> Recommendation I.150: B-ISDN ATM functional characteristics. </title> <note> (Revised version), Geneva: ITU 1992. </note>
Reference-contexts: As a result, only embarassingly parallel appli cations (i.e., parallel applications that essentially never communicate) can make use of such environments. Net working technologies such as ATM <ref> [1] </ref> offer the opportu nity to close the gap: for example, ATM cells are roughly the same size as messages on multiprocessors, it takes only a few microseconds to send or receive a cell, ATM switches can be configured to provide bisection bandwidths comparable to parallel machine networks, and routing latencies <p> SSAM_req_buf [conn]; out-&gt;src = src; out-&gt;dest = dest; read_cnt++; SSAM_10 (conn, read32_h); while (read_cnt) SSAM_poll (); - /* Read request handler */ static SSAM_reply_handler read32_h (int conn, read32_msg *in, read32_msg *out) - double *src = in-&gt;src; out-&gt;dest = in-&gt;dest; if (((long)src&7) == 0) - out-&gt;data [0] = src [0]; out-&gt;data <ref> [1] </ref> = src [1]; out-&gt;data [2] = src [2]; out-&gt;data [3] = src [3]; - else - /* non double-word aligned code omitted */ return read32_rh; - /* Read reply handler */ static void read32_rh (int conn, read32_msg *in) - double *dest = in-&gt;dest; if (((long)dest&7) == 0) - dest [0] <p> = src; out-&gt;dest = dest; read_cnt++; SSAM_10 (conn, read32_h); while (read_cnt) SSAM_poll (); - /* Read request handler */ static SSAM_reply_handler read32_h (int conn, read32_msg *in, read32_msg *out) - double *src = in-&gt;src; out-&gt;dest = in-&gt;dest; if (((long)src&7) == 0) - out-&gt;data [0] = src [0]; out-&gt;data <ref> [1] </ref> = src [1]; out-&gt;data [2] = src [2]; out-&gt;data [3] = src [3]; - else - /* non double-word aligned code omitted */ return read32_rh; - /* Read reply handler */ static void read32_rh (int conn, read32_msg *in) - double *dest = in-&gt;dest; if (((long)dest&7) == 0) - dest [0] = in-&gt;data [0]; <p> [2] = src [2]; out-&gt;data [3] = src [3]; - else - /* non double-word aligned code omitted */ return read32_rh; - /* Read reply handler */ static void read32_rh (int conn, read32_msg *in) - double *dest = in-&gt;dest; if (((long)dest&7) == 0) - dest [0] = in-&gt;data [0]; dest <ref> [1] </ref> = in-&gt;data [1]; dest [2] = in-&gt;data [2]; dest [3] = in-&gt;data [3]; - else - /* non double-word aligned code omitted */ read_cnt-; - Note that the network interface used is much simpler and closer to multiprocessor NIs than most second-generation ATM interfaces available today. <p> [2]; out-&gt;data [3] = src [3]; - else - /* non double-word aligned code omitted */ return read32_rh; - /* Read reply handler */ static void read32_rh (int conn, read32_msg *in) - double *dest = in-&gt;dest; if (((long)dest&7) == 0) - dest [0] = in-&gt;data [0]; dest <ref> [1] </ref> = in-&gt;data [1]; dest [2] = in-&gt;data [2]; dest [3] = in-&gt;data [3]; - else - /* non double-word aligned code omitted */ read_cnt-; - Note that the network interface used is much simpler and closer to multiprocessor NIs than most second-generation ATM interfaces available today.
Reference: [2] <author> D. E. Culler, A. Dusseau, S. C. Goldstein, A. Krishna-murthy, S. Lumetta, T. von Eicken, and K. Yelick. </author> <title> Introduction to Split-C. </title> <booktitle> In Proc. of Supercomputing '93 </booktitle>
Reference-contexts: out-&gt;dest = dest; read_cnt++; SSAM_10 (conn, read32_h); while (read_cnt) SSAM_poll (); - /* Read request handler */ static SSAM_reply_handler read32_h (int conn, read32_msg *in, read32_msg *out) - double *src = in-&gt;src; out-&gt;dest = in-&gt;dest; if (((long)src&7) == 0) - out-&gt;data [0] = src [0]; out-&gt;data [1] = src [1]; out-&gt;data <ref> [2] </ref> = src [2]; out-&gt;data [3] = src [3]; - else - /* non double-word aligned code omitted */ return read32_rh; - /* Read reply handler */ static void read32_rh (int conn, read32_msg *in) - double *dest = in-&gt;dest; if (((long)dest&7) == 0) - dest [0] = in-&gt;data [0]; dest [1] <p> read_cnt++; SSAM_10 (conn, read32_h); while (read_cnt) SSAM_poll (); - /* Read request handler */ static SSAM_reply_handler read32_h (int conn, read32_msg *in, read32_msg *out) - double *src = in-&gt;src; out-&gt;dest = in-&gt;dest; if (((long)src&7) == 0) - out-&gt;data [0] = src [0]; out-&gt;data [1] = src [1]; out-&gt;data <ref> [2] </ref> = src [2]; out-&gt;data [3] = src [3]; - else - /* non double-word aligned code omitted */ return read32_rh; - /* Read reply handler */ static void read32_rh (int conn, read32_msg *in) - double *dest = in-&gt;dest; if (((long)dest&7) == 0) - dest [0] = in-&gt;data [0]; dest [1] = in-&gt;data [1]; <p> [3] = src [3]; - else - /* non double-word aligned code omitted */ return read32_rh; - /* Read reply handler */ static void read32_rh (int conn, read32_msg *in) - double *dest = in-&gt;dest; if (((long)dest&7) == 0) - dest [0] = in-&gt;data [0]; dest [1] = in-&gt;data [1]; dest <ref> [2] </ref> = in-&gt;data [2]; dest [3] = in-&gt;data [3]; - else - /* non double-word aligned code omitted */ read_cnt-; - Note that the network interface used is much simpler and closer to multiprocessor NIs than most second-generation ATM interfaces available today. <p> [3]; - else - /* non double-word aligned code omitted */ return read32_rh; - /* Read reply handler */ static void read32_rh (int conn, read32_msg *in) - double *dest = in-&gt;dest; if (((long)dest&7) == 0) - dest [0] = in-&gt;data [0]; dest [1] = in-&gt;data [1]; dest <ref> [2] </ref> = in-&gt;data [2]; dest [3] = in-&gt;data [3]; - else - /* non double-word aligned code omitted */ read_cnt-; - Note that the network interface used is much simpler and closer to multiprocessor NIs than most second-generation ATM interfaces available today. <p> Unfortunately, given that the trap cost is dominated by the network interface access time and that the SBA-100 requires all 56 bytes of a cell to be transferred by the processor, it is unlikely that a significant benefit can be realized. 3.4.4 Split-C While a full implementation of Split-C <ref> [2] </ref> is still in progress, timings of the remote memory access primitives show that the round-trip time for a remote read of 32 double-word aligned bytes takes 32 20 and a one-way remote store takes 22 s for the same payload. Remote accesses with smaller payloads are not noticeably cheaper.
Reference: [3] <author> D. E. Culler, A. Dusseau, R. Martin, K. E. Schauser. </author> <title> Fast Parallel Sorting: from LogP to Split-C. </title> <booktitle> In Proc. of WPPP '93, </booktitle> <month> July 93. </month>
Reference-contexts: As an illustration of the difficulties in a parallel computing setting, consider the implementation of a parallel sort. The most efficient parallel sort algorithms <ref> [3] </ref> are based on an alternation of local sorts on the nodes and permutation phases in which all nodes exchange data with all other nodes. <p> (conn, read32_h); while (read_cnt) SSAM_poll (); - /* Read request handler */ static SSAM_reply_handler read32_h (int conn, read32_msg *in, read32_msg *out) - double *src = in-&gt;src; out-&gt;dest = in-&gt;dest; if (((long)src&7) == 0) - out-&gt;data [0] = src [0]; out-&gt;data [1] = src [1]; out-&gt;data [2] = src [2]; out-&gt;data <ref> [3] </ref> = src [3]; - else - /* non double-word aligned code omitted */ return read32_rh; - /* Read reply handler */ static void read32_rh (int conn, read32_msg *in) - double *dest = in-&gt;dest; if (((long)dest&7) == 0) - dest [0] = in-&gt;data [0]; dest [1] = in-&gt;data [1]; dest [2] <p> (read_cnt) SSAM_poll (); - /* Read request handler */ static SSAM_reply_handler read32_h (int conn, read32_msg *in, read32_msg *out) - double *src = in-&gt;src; out-&gt;dest = in-&gt;dest; if (((long)src&7) == 0) - out-&gt;data [0] = src [0]; out-&gt;data [1] = src [1]; out-&gt;data [2] = src [2]; out-&gt;data <ref> [3] </ref> = src [3]; - else - /* non double-word aligned code omitted */ return read32_rh; - /* Read reply handler */ static void read32_rh (int conn, read32_msg *in) - double *dest = in-&gt;dest; if (((long)dest&7) == 0) - dest [0] = in-&gt;data [0]; dest [1] = in-&gt;data [1]; dest [2] = in-&gt;data [2]; <p> else - /* non double-word aligned code omitted */ return read32_rh; - /* Read reply handler */ static void read32_rh (int conn, read32_msg *in) - double *dest = in-&gt;dest; if (((long)dest&7) == 0) - dest [0] = in-&gt;data [0]; dest [1] = in-&gt;data [1]; dest [2] = in-&gt;data [2]; dest <ref> [3] </ref> = in-&gt;data [3]; - else - /* non double-word aligned code omitted */ read_cnt-; - Note that the network interface used is much simpler and closer to multiprocessor NIs than most second-generation ATM interfaces available today. <p> non double-word aligned code omitted */ return read32_rh; - /* Read reply handler */ static void read32_rh (int conn, read32_msg *in) - double *dest = in-&gt;dest; if (((long)dest&7) == 0) - dest [0] = in-&gt;data [0]; dest [1] = in-&gt;data [1]; dest [2] = in-&gt;data [2]; dest <ref> [3] </ref> = in-&gt;data [3]; - else - /* non double-word aligned code omitted */ read_cnt-; - Note that the network interface used is much simpler and closer to multiprocessor NIs than most second-generation ATM interfaces available today.
Reference: [4] <author> T. von Eicken, D. E. Culler, S. C. Goldstein, and K. E. Schauser. </author> <title> Active Messages: A Mechanism for Integrated Communication and Computation. </title> <booktitle> In Proc. of the 19th ISCA, </booktitle> <pages> pages 256-266, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: available such that the prototype cannot provide information neither on how cell losses due to contention within the network affect performance, nor on how the scheduling of processes can be coordinated to improve the overall performance of par allel applications. 3.1 Active Messages Communication Architecture The Active Messages communication architecture <ref> [4] </ref> offers simple, general purpose communication primitives as a thin veneer over the raw hardware. It is intended to serve as a substrate for building libraries that provide higher-level communication abstractions and for generating communication code directly from a parallel-language compiler. <p> A register in the interface indicates the number of cells available in the input FIFO. /* Remote read of 32 bytes */ static volatile int read_cnt = 0; typedef struct - double *src, *dest; double data <ref> [4] </ref>; - read32_msg; /* Read 32 bytes from remote node */ void read32 (int conn, double *src, double *dest) - read32_msg *out = SSAM_req_buf [conn]; out-&gt;src = src; out-&gt;dest = dest; read_cnt++; SSAM_10 (conn, read32_h); while (read_cnt) SSAM_poll (); - /* Read request handler */ static SSAM_reply_handler read32_h (int conn, read32_msg <p> Table 6: Comparison of SSAMs performance with that of recent parallel machines. Machine Peak bandwidth Round-trip latency SP-1 + MPL/p [9] 8.3MB/s 56 m s Paragon CM-5 + Active Mesg <ref> [4] </ref> 10MB/s 12 SS-20 cluster + SSAM 5.6MB/s 32
Reference: [5] <author> A. Geist, A. Beguelin, J. Dongarra, W. Jiang, R. Manchek, and V. Sunderam. </author> <title> PVM 3.0 Users Guide and Reference Manual. </title> <institution> Oak Ridge National Laboratory, </institution> <type> Technical Report ORNL/TM-12187, </type> <month> February </month> <year> 1993. </year>
Reference: [6] <author> K. Li and P. Hudak. </author> <title> Memory Coherence in Shared Vir tual Memory Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference: [7] <author> M. Lin, J. Hsieh, D. H. C. Du, J. P. Thomas, and J. A. MacDonald. </author> <title> Distributed Network Computing over Local ATM Networks. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <note> Special Issue on ATM LANs, to appear, </note> <year> 1995. </year>
Reference-contexts: A bulk write implemented with the current SSAM layer transfers 5.5Mbytes/s, but 1. Note that in a more realistic setting a Fore ASX-100 switch will add roughly 10 s of latency to the write time and 20 to the round-trip read time <ref> [7] </ref>. Table 3: Cost breakdown for SPARCstation Active Messages. <p> The remote reads and writes are directly comparable in that they transfer the same payload per cell. The performance of more traditional communication layers over an ATM network has been evaluated by Lin <ref> [7] </ref> and shows over two orders of magnitude higher communication latencies than SSAM offers. Table 5 summarizes the best round-trip latencies and one-way bandwidths attained on Sun 4/690s and SPARCstation 2s connected by Fore SBA-100 interfaces without switch. <p> Operation SSAM Remote mem access read latency 32 write latency 22 addtl control transfer ovhd none 260 block write 5.5MB/s 4.4MB/s Table 5: Performance of traditional communication layers on Sun4/690s and SPARCstation 2s over ATM <ref> [7] </ref>.
Reference: [8] <author> P. Pierce and G. Regnier. </author> <title> The Paragon Implementation of the NX Message Passing Interface. </title> <booktitle> In Proc. of SHPCC 94, </booktitle> <month> May </month> <year> 1994. </year>
Reference: [9] <author> C. B. Stunkel, D. G. Shea, D. G. Grice, P. H. Hochschild, and M. Tsao. </author> <title> The SP1 High-Performance Switch. </title> <booktitle> Proc. of SHPCC 94, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: While taking care of ow control in software does not dominate performance in this study, the behavior of ATM networks under parallel computing communication loads remains an open question. Table 6: Comparison of SSAMs performance with that of recent parallel machines. Machine Peak bandwidth Round-trip latency SP-1 + MPL/p <ref> [9] </ref> 8.3MB/s 56 m s Paragon CM-5 + Active Mesg [4] 10MB/s 12 SS-20 cluster + SSAM 5.6MB/s 32
Reference: [10] <author> C. A. Thekkath, H. M. Levy, and E. D. Lazowska. </author> <title> Effi cient Support for Multicomputing on ATM Networks. </title> <institution> University of Washington, </institution> <type> Technical Report 93-04-03, </type> <month> April </month> <year> 1993. </year>
Reference: [11] <author> C. A. Thekkath, H. M. Levy, and E. D. Lazowska. </author> <title> Separating Data and Control Transfer in Distributed Operat ing Systems. </title> <booktitle> In Proc. of the 6th Intl Conf. on ASPLOS, To appear, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: Note that a TCP/IP implementation with a well-optimized fast-path should yield sub-millisecond latencies. Table 4: Comparison of SSAM to Remote Memory Accesses between 2 DECstation 5000s over ATM <ref> [11] </ref>. Operation SSAM Remote mem access read latency 32 write latency 22 addtl control transfer ovhd none 260 block write 5.5MB/s 4.4MB/s Table 5: Performance of traditional communication layers on Sun4/690s and SPARCstation 2s over ATM [7].
Reference: [12] <institution> Thinking Machines Corporation, </institution> <address> Cambridge, </address> <month> Massachu setts. </month> <title> Connection Machine CM-5, </title> <type> Technical Summary, </type> <month> November </month> <year> 1992. </year>
Reference-contexts: Specifically, the sender must keep a copy of each cell sent until a corresponding acknowledgment is received, in case the cell must be retransmitted. This means that messages cannot be transferred directly between processor registers and the network interface (as is possible on the CM-5 <ref> [12] </ref>), rather, a memory copy must be made as well. 2.2 User-level access to the network interface Recently, multiprocessor communication architectures have achieved a significant reduction of the communication overhead by eliminating the operating system from the critical path.
References-found: 12

