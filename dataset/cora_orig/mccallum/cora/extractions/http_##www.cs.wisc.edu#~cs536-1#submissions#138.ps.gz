URL: http://www.cs.wisc.edu/~cs536-1/submissions/138.ps.gz
Refering-URL: 
Root-URL: 
Email: frjohnson,schlanskg@hpl.hp.com  
Phone: (415) 857-8612  
Title: Analysis Techniques for Predicated Code  
Author: Richard Johnson and Michael Schlansker 
Address: 1501 Page Mill Road, Building 3L-5 Palo Alto, CA 94304  
Affiliation: Hewlett-Packard Laboratories  
Date: 1 October 20, 1995  
Note: Draft do not distribute.  
Abstract: Predicated execution offers new opportunities to exploit instruction-level parallelism, but it also presents new challenges for analysis and optimization. In predicated code, explicit control flow transfers are replaced by computation of boolean guards that determine at run-time which operations execute. Standard data flow analysis, which ignores the run-time relationships between these guarding predicates, must assume that each operation may or may not execute independent of all other operations in a straight line code sequence; this yields overly-conservative results in crucial areas such as scheduling (data dependence analysis) and register allocation (live-range analysis). We present a predicate-sensitive approach to data flow analysis that yields significantly more accurate results than conventional methods when applied to predicated code.
Abstract-found: 1
Intro-found: 1
Reference: [AKPW83] <author> J. R. Allen, K. Kennedy, C. Portfield, and J. Warren. </author> <title> Conversion of control dependence to data dependence. </title> <booktitle> In Conference Record of the 10th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 177-189, </pages> <address> Austin, Texas, </address> <month> January 24-26, </month> <year> 1983. </year>
Reference-contexts: Predicated execution can be used to generalize the rules for moving code among basic blocks as well as to increase the size of straight line code blocks by eliminating many branches completely. The process of replacing branches with appropriate predicate computations and guards is called if-conversion <ref> [AKPW83, DHB89, PS91, MLC + 92] </ref>. By decreasing the number of branches required to conditionally execute programs, if-conversion can provide substantial benefits to exploiting instruction-level parallelism. In numeric code, predicated execution is used to produce time-efficient schedules with less code expansion by software pipelining loops containing conditionals [DHB89, DT93].
Reference: [DHB89] <author> James C. Dehnert, Peter Y.-T Hsu, and Joseph P. Bratt. </author> <title> Overlapped loop support in the Cydra 5. </title> <booktitle> In Third International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 26-38, </pages> <address> Boston, Massachusetts, </address> <month> April 3-6, </month> <year> 1989. </year>
Reference-contexts: Predicated execution can be used to generalize the rules for moving code among basic blocks as well as to increase the size of straight line code blocks by eliminating many branches completely. The process of replacing branches with appropriate predicate computations and guards is called if-conversion <ref> [AKPW83, DHB89, PS91, MLC + 92] </ref>. By decreasing the number of branches required to conditionally execute programs, if-conversion can provide substantial benefits to exploiting instruction-level parallelism. In numeric code, predicated execution is used to produce time-efficient schedules with less code expansion by software pipelining loops containing conditionals [DHB89, DT93]. <p> By decreasing the number of branches required to conditionally execute programs, if-conversion can provide substantial benefits to exploiting instruction-level parallelism. In numeric code, predicated execution is used to produce time-efficient schedules with less code expansion by software pipelining loops containing conditionals <ref> [DHB89, DT93] </ref>. Predication is also useful for height-reduction of control recurrences in while loops, allowing multiple iterations to execute in parallel [SKA94]. <p> Finally, in Section 6 we describe an extension to data flow analysis that provides more accurate analysis of predicated code. 2 Background 2.1 Architectural model The HPL PlayDoh architecture [KSR93] provides support for predicated execution through an enhanced version of the predication capabilities of the Cydra 5 processor <ref> [DHB89, RYYT89] </ref>. In addition to guarded operations, PlayDoh introduces a family of compare operations which support efficient if-conversion of structured and unstructured control flow graphs, as well as parallel computation of high fan-in logical computations.
Reference: [DT93] <author> James C. Dehnert and Ross A. Towle. </author> <title> Compiling for the Cydra 5. </title> <journal> IEEE Computer, </journal> <volume> 7 </volume> <pages> 181-227, </pages> <year> 1993. </year>
Reference-contexts: By decreasing the number of branches required to conditionally execute programs, if-conversion can provide substantial benefits to exploiting instruction-level parallelism. In numeric code, predicated execution is used to produce time-efficient schedules with less code expansion by software pipelining loops containing conditionals <ref> [DHB89, DT93] </ref>. Predication is also useful for height-reduction of control recurrences in while loops, allowing multiple iterations to execute in parallel [SKA94].
Reference: [HD86] <author> Peter Y. T. Hsu and Edward S. Davidson. </author> <title> Highly concurrent scalar processing. </title> <booktitle> In Proceedings of the 13th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 386-395, </pages> <address> Tokyo, Japan, </address> <month> June 2-5, </month> <year> 1986. </year>
Reference-contexts: 1 Introduction 1.1 Predicated execution Predicated execution <ref> [HD86, RYYT89, KSR93] </ref> is an architectural model in which each operation is guarded by a boolean operand whose value determines whether the operation is executed or nullified.
Reference: [Hew92] <author> Hewlett-Packard Company. </author> <title> PA-RISC 1.1 Architecture and Instruction Set Reference Manual. </title> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: Architectural support for predicated execution is becoming more commonplace. General support has been provided in the Cydra 5 [RYYT89] and in ARM [SA94]. Restricted support is provided by conditional Draft do not distribute. 2 October 20, 1995 skip instructions in the HP PA-RISC architecture <ref> [Hew92] </ref>, by conditional move instructions in the DEC Alpha [Sit92] and SPARC-V9 [WG93], and by vector masks in the CRAY-1 computer [Rus78]. 1.2 Predicate-sensitive analysis To illustrate the need for analysis of predicated code, let's consider a small example. <p> The interested reader is directed to the PlayDoh document for a complete description. * r1 &lt;cond&gt; r2 specifies the actual comparison; the set of comparisons is the same as in the HP PA-RISC architecture <ref> [Hew92] </ref>. * q is a source predicate register operand.
Reference: [JS95] <author> Richard Johnson and Mike Schlansker. </author> <title> Analysis techniques for predicated code. </title> <type> Technical Report HPL-95-??, </type> <institution> Hewlett-Packard Laboratories, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: The approach we've taken is to restrict predicate expressions to a simple normal form that is easy to manipulate, making conservative approximations as necessary to ensure correctness. In our experience, this solution provides a good trade-off between accuracy and efficiency. In the technical report <ref> [JS95] </ref>, we present a more expensive solution (in both time and space) which does not require approximation. The variables of predicate expressions are symbols denoting execution sets for individual predicates, and they are represented explicitly by nodes in the partition graph.
Reference: [KSR93] <author> Vinod Kathail, Mike Schlansker, and Bob Rau. </author> <title> HPL Playdoh architecture specification: Version 1.0. </title> <type> Technical Report HPL-93-80, </type> <institution> Hewlett-Packard Laboratories, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: 1 Introduction 1.1 Predicated execution Predicated execution <ref> [HD86, RYYT89, KSR93] </ref> is an architectural model in which each operation is guarded by a boolean operand whose value determines whether the operation is executed or nullified. <p> Efficient partition graph algorithms appear in Section 5. Finally, in Section 6 we describe an extension to data flow analysis that provides more accurate analysis of predicated code. 2 Background 2.1 Architectural model The HPL PlayDoh architecture <ref> [KSR93] </ref> provides support for predicated execution through an enhanced version of the predication capabilities of the Cydra 5 processor [DHB89, RYYT89].
Reference: [Lin90] <author> David Chu Lin. </author> <title> Compiler support for predictaed execution in superscalar processors. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1990. </year>
Reference-contexts: Draft do not distribute. 14 October 20, 1995 Some early work on understanding predicate relations has been done by Wen-mei Hwu's Impact compiler group at Illinois. They describe a data structure called the predicate hierarchy graph (PHG) <ref> [Lin90] </ref>, which represents the boolean equation under which each predicate is defined. The main use of PHG mentioned in Lin's thesis is to determine if a pair of predicate registers is disjoint. Two predicates are disjoint only if the conjunction of their associated boolean expressions can be simplified to false.
Reference: [Mah95] <author> Scott Mahlke, </author> <year> 1995. </year> <type> personal communication. </type>
Reference-contexts: Two predicates are disjoint only if the conjunction of their associated boolean expressions can be simplified to false. Rather than perform predicate-sensitive live range analysis, the approach adopted in the Impact compiler <ref> [Mah95] </ref> is to apply reverse if-conversion [WMHR93] to predicated code, and then perform standard data flow analysis on the resulting control flow graph. This analysis can yield conservative results because the flow graph constructed by reverse if-conversion will in general contain many paths that cannot be traversed during any execution.
Reference: [MHB + 94] <author> Scott A. Mahlke, Richard E. Hank, Roger A. Bringmann, John C. Gyllenhaal, David M. Gallagher, and Wen-mei Hwu. </author> <title> Characterizing the impact of predicated execution on branch predication. In Proceedings Draft do not distribute. 15 October 20, </title> <booktitle> 1995 of the 27th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 217-227, </pages> <address> San Jose, California, November30-December2, </address> <year> 1994. </year>
Reference-contexts: More recently, predicated execution has been used in scalar code for critical path height reduction [SK95]. Predicated execution is also used to eliminate unpredictable branches which would otherwise cause branch prediction stalls at run-time <ref> [Tys94, MHB + 94] </ref>. A third area where predicates are used is in intermediate representations. Warter et al. introduced reverse if-conversion to reconstitute control flow from predicated code.
Reference: [MLC + 92] <author> S. A. Mahlke, D. C. Lin, W. Y. Chen, R. E. Hank, and R. A. Bringmann. </author> <title> Effective compiler support for predicated execution using the hyperblock. </title> <booktitle> In Proceedings of the 25th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 45-54, </pages> <address> Portland, Oregon, </address> <month> December 1-4, </month> <year> 1992. </year>
Reference-contexts: Predicated execution can be used to generalize the rules for moving code among basic blocks as well as to increase the size of straight line code blocks by eliminating many branches completely. The process of replacing branches with appropriate predicate computations and guards is called if-conversion <ref> [AKPW83, DHB89, PS91, MLC + 92] </ref>. By decreasing the number of branches required to conditionally execute programs, if-conversion can provide substantial benefits to exploiting instruction-level parallelism. In numeric code, predicated execution is used to produce time-efficient schedules with less code expansion by software pipelining loops containing conditionals [DHB89, DT93]. <p> For non-numeric code, if-conversion produces larger straight line code sequences, thereby increasing the scheduling scope without the dramatic increase in code size which may occur when increasing block size through code replication <ref> [MLC + 92] </ref>. More recently, predicated execution has been used in scalar code for critical path height reduction [SK95]. Predicated execution is also used to eliminate unpredictable branches which would otherwise cause branch prediction stalls at run-time [Tys94, MHB + 94]. <p> Intuitively, each branch point is replaced with an unconditional compare operation that computes predicates for the branch's control flow successors, and each merge point is replaced with a parallel-or compare operation that combines predicates corresponding to the control flow predecessors being merged. Detailed algorithms for if-conversion are given in <ref> [PS91, MLC + 92] </ref>. body is a single-entry acyclic region suitable for if-conversion. A predicate is assigned to each basic block, and the control dependences for each block (ignoring cyclic dependences and dependences from branches outside the region being converted) are replaced by appropriate predicate computations. <p> By considering relations between branch conditions, our methods prune the set of values combined in a meet-over-paths data flow solution, yielding less conservative results than is found by considering the many infeasible paths. Definition 1 A hyperblock is an if-converted single-entry multi-exit control flow region <ref> [MLC + 92] </ref>. We use the term in a general way to refer to any single-entry multi-exit straight line sequence of predicated operations, regardless of how the code was produced. The symbols of predicate expressions are names for certain sets of executions, defined as follows.
Reference: [PS91] <author> Joseph C. H. Park and Mike Schlansker. </author> <title> On predicated execution. </title> <type> Technical Report HPL-91-58, </type> <institution> Hewlett-Packard Software and Systems Laboratory, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Predicated execution can be used to generalize the rules for moving code among basic blocks as well as to increase the size of straight line code blocks by eliminating many branches completely. The process of replacing branches with appropriate predicate computations and guards is called if-conversion <ref> [AKPW83, DHB89, PS91, MLC + 92] </ref>. By decreasing the number of branches required to conditionally execute programs, if-conversion can provide substantial benefits to exploiting instruction-level parallelism. In numeric code, predicated execution is used to produce time-efficient schedules with less code expansion by software pipelining loops containing conditionals [DHB89, DT93]. <p> Intuitively, each branch point is replaced with an unconditional compare operation that computes predicates for the branch's control flow successors, and each merge point is replaced with a parallel-or compare operation that combines predicates corresponding to the control flow predecessors being merged. Detailed algorithms for if-conversion are given in <ref> [PS91, MLC + 92] </ref>. body is a single-entry acyclic region suitable for if-conversion. A predicate is assigned to each basic block, and the control dependences for each block (ignoring cyclic dependences and dependences from branches outside the region being converted) are replaced by appropriate predicate computations. <p> Therefore, the second and third assignments to t can execute in either order or concurrently. The if-converted loop body may now be aggressively scheduled, for example via software pipelining. 1 If-conversion as described in <ref> [PS91] </ref> can also make use of conditional compare operations; currently, we restrict our analysis and if-conversion to the use of unconditional and or-style compares. Extension of analysis to conditional and and-style compares is a topic for future work.
Reference: [Rus78] <author> Richard M. Russell. </author> <title> The CRAY-1 computer system. </title> <journal> Communications of the ACM, </journal> <volume> 21(1) </volume> <pages> 63-72, </pages> <month> January </month> <year> 1978. </year>
Reference-contexts: Restricted support is provided by conditional Draft do not distribute. 2 October 20, 1995 skip instructions in the HP PA-RISC architecture [Hew92], by conditional move instructions in the DEC Alpha [Sit92] and SPARC-V9 [WG93], and by vector masks in the CRAY-1 computer <ref> [Rus78] </ref>. 1.2 Predicate-sensitive analysis To illustrate the need for analysis of predicated code, let's consider a small example. Figure 1 (a) shows code for a simple if-then-else statement prior to if-conversion.
Reference: [RYYT89] <author> B. Rau, D. Yen, W. Yen, and R. Towle. </author> <title> The Cydra 5 departmental supercomputer: Design philosophies, decisions, and trade-offs. </title> <journal> IEEE Computer, </journal> <volume> 22(1) </volume> <pages> 12-35, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: 1 Introduction 1.1 Predicated execution Predicated execution <ref> [HD86, RYYT89, KSR93] </ref> is an architectural model in which each operation is guarded by a boolean operand whose value determines whether the operation is executed or nullified. <p> Reverse if-conversion is used to convert the scheduled predicated code into a scheduled acyclic control flow graph. Architectural support for predicated execution is becoming more commonplace. General support has been provided in the Cydra 5 <ref> [RYYT89] </ref> and in ARM [SA94]. <p> Finally, in Section 6 we describe an extension to data flow analysis that provides more accurate analysis of predicated code. 2 Background 2.1 Architectural model The HPL PlayDoh architecture [KSR93] provides support for predicated execution through an enhanced version of the predication capabilities of the Cydra 5 processor <ref> [DHB89, RYYT89] </ref>. In addition to guarded operations, PlayDoh introduces a family of compare operations which support efficient if-conversion of structured and unstructured control flow graphs, as well as parallel computation of high fan-in logical computations.
Reference: [SA94] <author> A. V. Someren and C. Atack. </author> <title> The ARM RISC Chip, A Programmer's Guide. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1994. </year>
Reference-contexts: Reverse if-conversion is used to convert the scheduled predicated code into a scheduled acyclic control flow graph. Architectural support for predicated execution is becoming more commonplace. General support has been provided in the Cydra 5 [RYYT89] and in ARM <ref> [SA94] </ref>.
Reference: [Sit92] <author> R. </author> <title> Sites, editor. Alpha Architecture Reference Manual. </title> <publisher> Digital Press, </publisher> <year> 1992. </year>
Reference-contexts: General support has been provided in the Cydra 5 [RYYT89] and in ARM [SA94]. Restricted support is provided by conditional Draft do not distribute. 2 October 20, 1995 skip instructions in the HP PA-RISC architecture [Hew92], by conditional move instructions in the DEC Alpha <ref> [Sit92] </ref> and SPARC-V9 [WG93], and by vector masks in the CRAY-1 computer [Rus78]. 1.2 Predicate-sensitive analysis To illustrate the need for analysis of predicated code, let's consider a small example. Figure 1 (a) shows code for a simple if-then-else statement prior to if-conversion.
Reference: [SK95] <author> Michael Schlansker and Vinod Kathail. </author> <title> Critical path reduction for scalar programs. </title> <booktitle> In Proceedings of the 28th Annual International Symposium on Microarchitecture, </booktitle> <institution> page ??, Ann Arbor, Michigan, November29-December1, </institution> <year> 1995. </year>
Reference-contexts: More recently, predicated execution has been used in scalar code for critical path height reduction <ref> [SK95] </ref>. Predicated execution is also used to eliminate unpredictable branches which would otherwise cause branch prediction stalls at run-time [Tys94, MHB + 94]. A third area where predicates are used is in intermediate representations. Warter et al. introduced reverse if-conversion to reconstitute control flow from predicated code.
Reference: [SKA94] <author> Michael Schlansker, Vinod Kathail, and Sadun Anik. </author> <title> Height reduction of control recurrences for ILP processors. </title> <booktitle> In Proceedings of the 27th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 40-51, </pages> <address> San Jose, California, November30-December2, </address> <year> 1994. </year>
Reference-contexts: In numeric code, predicated execution is used to produce time-efficient schedules with less code expansion by software pipelining loops containing conditionals [DHB89, DT93]. Predication is also useful for height-reduction of control recurrences in while loops, allowing multiple iterations to execute in parallel <ref> [SKA94] </ref>. For non-numeric code, if-conversion produces larger straight line code sequences, thereby increasing the scheduling scope without the dramatic increase in code size which may occur when increasing block size through code replication [MLC + 92].
Reference: [Tys94] <author> Gary Scott Tyson. </author> <title> The effects of predicated execution on branch prediction. </title> <booktitle> In Proceedings of the 27th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 196-206, </pages> <address> San Jose, California, November30-December2, </address> <year> 1994. </year>
Reference-contexts: More recently, predicated execution has been used in scalar code for critical path height reduction [SK95]. Predicated execution is also used to eliminate unpredictable branches which would otherwise cause branch prediction stalls at run-time <ref> [Tys94, MHB + 94] </ref>. A third area where predicates are used is in intermediate representations. Warter et al. introduced reverse if-conversion to reconstitute control flow from predicated code.
Reference: [WG93] <editor> D. Weaver and T. Germond, editors. </editor> <title> The SPARC Architecture Manual Version 9. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1993. </year>
Reference-contexts: General support has been provided in the Cydra 5 [RYYT89] and in ARM [SA94]. Restricted support is provided by conditional Draft do not distribute. 2 October 20, 1995 skip instructions in the HP PA-RISC architecture [Hew92], by conditional move instructions in the DEC Alpha [Sit92] and SPARC-V9 <ref> [WG93] </ref>, and by vector masks in the CRAY-1 computer [Rus78]. 1.2 Predicate-sensitive analysis To illustrate the need for analysis of predicated code, let's consider a small example. Figure 1 (a) shows code for a simple if-then-else statement prior to if-conversion.
Reference: [WMHR93] <author> Nancy J. Warter, Scott A. Mahlke, Wen-mei W. Hwu, and B. Ramakrishna Rau. </author> <title> Reverse if-conversion. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 290-299, </pages> <address> Albuquerque, New Mexico, </address> <month> June 23-25, </month> <year> 1993. </year>
Reference-contexts: A third area where predicates are used is in intermediate representations. Warter et al. introduced reverse if-conversion to reconstitute control flow from predicated code. Thye apply local scheduling techniques to if-converted acyclic program regions, avoiding the usual complexities of code motion in the control flow domain <ref> [WMHR93] </ref>. Reverse if-conversion is used to convert the scheduled predicated code into a scheduled acyclic control flow graph. Architectural support for predicated execution is becoming more commonplace. General support has been provided in the Cydra 5 [RYYT89] and in ARM [SA94]. <p> Two predicates are disjoint only if the conjunction of their associated boolean expressions can be simplified to false. Rather than perform predicate-sensitive live range analysis, the approach adopted in the Impact compiler [Mah95] is to apply reverse if-conversion <ref> [WMHR93] </ref> to predicated code, and then perform standard data flow analysis on the resulting control flow graph. This analysis can yield conservative results because the flow graph constructed by reverse if-conversion will in general contain many paths that cannot be traversed during any execution.
References-found: 21

