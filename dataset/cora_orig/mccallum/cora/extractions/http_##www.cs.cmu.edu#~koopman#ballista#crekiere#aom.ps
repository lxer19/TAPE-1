URL: http://www.cs.cmu.edu/~koopman/ballista/crekiere/aom.ps
Refering-URL: http://www.cs.cmu.edu/~koopman/ballista/crekiere/index.html
Root-URL: http://www.cs.cmu.edu
Title: Middleware Enabled Fault Management for  
Author: Charlotte A. Rekiere Daniel P. Siewiorek PH: ()- 
Address: 5000 Forbes Ave. 2201 Hamburgh Hall Pittsburgh, PA 15232  5000 Forbes Ave. 1201 Hamburgh Hall Pittsburgh, PA 15232  
Affiliation: Carnegie Mellon University  Carnegie Mellon University  
Note: Commercial Operating Systems  for submission to: Software Reliability and Fault Tolerance Track of the Computer Science Division at the 15th Annual International Conference of the AOM/IAOM Author Information:  
Email: email: crekiere@cs.cmu.edu  email: dps@cs.cmu.edu  
Phone: PH: (412) 621-9406  
Degree: Professor CS/ECE  
Date: May 3, 1997 1  April 29, 1997  
Abstract-found: 0
Intro-found: 0
Reference: [Bach86] <author> M.J. Bach, </author> <title> The Design of the Unix Operating System, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: The microkernel provides enough low-level support so that various servers can be implemented to run on top of it [Russinovich94]. The server implemented for the system call monitor evaluation is UNIX 4.3 (UX) <ref> [Bach86] </ref>. When a system call trap is made, Mach switches control into the emulation library. This library takes the system call parameters and number, and packages a message which is sent to UX. In UX, threads wait for incoming requests and after decoding the message, call the appropriate function.
Reference: [Dingman96] <author> C. P. Dingman, </author> <title> Robustness Benchmarking, </title> <type> CMU Ph.D. Thesis, </type> <month> August </month> <year> 1996. </year>
Reference-contexts: Adding assertions shows the ease of implementing fault-management features to the HP-UX middleware. As a demonstration, assertions are used to protect an application from incorrect kernel behavior exposed in the unmodified operating system through running Robustness Benchmarks <ref> [Dingman96] </ref>. May 3, 1997 3 1.0 Introduction Typically, the expectation and motivation for developing fault management techniques has focused on highly-specialized mission-critical systems. Commercial systems have escaped similar scrutiny and usually do not provide any type of fault management in the general computing environment. <p> The evaluation has produced a taxonomy of the architectural aspects that facilitate implementation of a fault management middleware layer. The HPLR (HP Library Replace) middleware development process is described and analyzed for performance overhead. An assertion policy is evaluated on HP-UX with the execution of Robustness Benchmarks <ref> [Dingman96] </ref>. It is expected that the results of this work will provide a framework for understanding how middleware fault-management techniques can be applied within current operating system architectures. <p> Call diversity is a count of the number of unique call types for a given benchmark. The groupings were established to determine which benchmarks most closely represent a typical user program to use for performance analysis of HPLR. System call diversity and frequency data for typical user programs from <ref> [Dingman96] </ref> is shown in Table 4. TABLE 3. <p> In summary, when logging is enabled to write to main memory only, there is a 1.5 times overhead compared to the standard libc and writing to disk adds a 5 to 10 times overhead the standard libc. TABLE 4. Typical Application Diversity to Frequency Ratios <ref> [Dingman96] </ref> emacs gcc gdb xv bitmap diversity (d) 23 20 23 26 18 frequency (f) 851 434 927 9140 13027 ratio (d/f) .0270 .0461 .0248 .0028 .0014 May 3, 1997 21 FIGURE 14. <p> How the operating system handles those parameters is observed. It is expected that the incorrect system calls are representative of one form of errors made by application designers or corrupted data. The suite of Robust Benchmarks applied to Mach 3.0 in <ref> [Dingman96] </ref> was ported and run on HP-UX. The suite tests the read, write, open, close, stat, fstat, and select calls. These calls were selected because they were the most frequent functions in traces of user sessions 1 [Dingman96]. <p> The suite of Robust Benchmarks applied to Mach 3.0 in <ref> [Dingman96] </ref> was ported and run on HP-UX. The suite tests the read, write, open, close, stat, fstat, and select calls. These calls were selected because they were the most frequent functions in traces of user sessions 1 [Dingman96]. The robust test involving the select call is used to show assertions in HPLR because it resulted in fails on HP-UX. The Robustness Benchmark test is built from the list of values in Table 5. <p> System calls were monitored for multiple user sessions running the following: emacs, gcc, gdb, bitmap, xv [Dingman 96]. 2. <ref> [Dingman96] </ref> defines a six-level classification system of Robust Benchmark fail modes. Class 2 failures are defined as: system reports success when error should have been reported. <p> Benchmarks run on the HPLR method showed the overhead and performance impact of system call monitoring with various logging configurations. Logging to main memory rather than any of the main memory/disk logging combinations added the smallest percentage overhead per system call logged. Robust Benchmarks <ref> [Dingman96] </ref> were run on HP-UX and results for the select call were described. Assertions were added to the HPLR middleware for select to avoid incorrect kernel behavior. The HPLR method proved to be an effective fault-management layer without requiring modification to kernel or application source code.
Reference: [Elnozahy93] <author> E. N. Elnozahy, Manetho: </author> <title> Fault Tolerance in Distributed Systems Using Rollback-Recovery and Process Replication, </title> <type> Rice Technical Report, </type> <institution> Rice COMP TR93-212, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: In Rollback recovery, a process uses information stored to restore a global consistent state and restart execution from that state, instead of restarting the computation from the beginning <ref> [Elnozahy93] </ref> 3.5 HPLR Implementation Summary The HPLR system call monitor mechanism has been shown to be an effective fault-management middleware layer for HP-UX and accomplishes the first goal for HPLR stated in Section 3.0.
Reference: [HPa95] <institution> Hewlett-Packard Company, </institution> <note> HP-UX Reference, HP LaserROM HP-UX Release 10.0, June1995 </note>
Reference-contexts: Three operating systems with monitoring mechanisms were evaluated to develop a taxonomy of operating systems features that facilitate system call monitoring: Mach 3.0 [Rashid89], pSOS [Integrated95] and HP-UX <ref> [HPa95] </ref>. The taxonomy begins with Figure 1 which defines a simple control flow model of a system call request in a generic operating system. Control switches from the application to the kernel when the system call is executed. <p> HP-UX is based on the UNIX System V Release 4 operating system <ref> [HPa95] </ref>. HPLR middleware is designed with two main objectives. First, to generate a log file of monitored system calls, arguments, return values and error codes. Second, to provide sufficient visibility for the implementation of assertions and rollback recovery fault management features.
Reference: [HPb95] <author> Hewlett-Packard Company, </author> <title> HP-UX Memory Management White Paper, HP LaserROM HP-UX Release 10.0, </title> <publisher> June1995 </publisher>
Reference-contexts: Mach Operating System Model with Middleware May 3, 1997 9 contained in the kernel. All system calls are funneled through a single entry point in the system space, which is identified by space register 7 (sr7) <ref> [HPb95] </ref>. To enable middleware for a system call, a custom library containing objects with middle ware functions is linked with the application. This method is called HP Library Replace (HPLR). The control flow for HPLR is shown in Figure 8.
Reference: [HPc95] <author> Hewlett-Packard Company, </author> <title> Programming on HP-UX, HP Part No. </title> <publisher> B2355-90652, Hewlett Packard Company, January1995 </publisher>
Reference-contexts: Global definitions contain the code for a named function, data or procedure. An external reference is the request for a local or global definition of a function, data or procedure in a program <ref> [HPc95] </ref>. System call code in libc is a global definition that an application requests with an external reference. Status information for the local, global and external definitions contained in object files is maintained by a symbol table. Each object file can contain multiple definitions of any or all types.
Reference: [Integrated95] <institution> Integrated Systems Inc., </institution> <note> pSOS System / 386 Release 2.0 Manual, </note> <month> March </month> <year> 1995 </year>
Reference-contexts: A log of system calls generated can be used to debug application or operating system behavior, analyze system performance and trend analysis. Three operating systems with monitoring mechanisms were evaluated to develop a taxonomy of operating systems features that facilitate system call monitoring: Mach 3.0 [Rashid89], pSOS <ref> [Integrated95] </ref> and HP-UX [HPa95]. The taxonomy begins with Figure 1 which defines a simple control flow model of a system call request in a generic operating system. Control switches from the application to the kernel when the system call is executed. <p> To execute a system call, the user application exe cutes an interrupt instruction, and the processor jumps to the location specified in the interrupt vector table <ref> [Integrated95] </ref>. A middleware layer is added by mapping the entry in the interrupt vector table during the boot sequence to point to a routine in the middleware. This change forces all the system calls made by the user application to pass through the middleware prior to entering the kernel.
Reference: [Lee95] <author> R.E. Lee, </author> <title> Middleware on the HP3000, </title> <type> Interact, </type> <month> August </month> <year> 1995, </year>
Reference-contexts: One method to provide fault management policies on commercial systems is the implementation of a middleware layer with the necessary visibility and control for adding fault management techniques. A middleware layer can be described simply as software placed between two existing systems to facilitate their communication and interoperability. <ref> [Lee95] </ref>. This paper evaluates the implementation of four system call monitor middleware layers in three commercial off-the-shelf Operating Systems. Specifically, pSOS (embedded), Mach 3.0 (micro-kernel) and HP-UX (monolithic kernel). The middleware layers evaluated reside between the operating system and an application.
Reference: [Rashid89] <author> R. Rashid, R. Baron, A. Forin, D. Golub, M. Jones, D. Julin, D. Orr and R. Sanzi, </author> <title> Mach: a Foundation for Open Systems, </title> <booktitle> Proc. 2nd Workshop Workstation Operating Syst., </booktitle> <month> Sept. </month> <pages> 27-29, </pages> <year> 1989. </year>
Reference-contexts: A log of system calls generated can be used to debug application or operating system behavior, analyze system performance and trend analysis. Three operating systems with monitoring mechanisms were evaluated to develop a taxonomy of operating systems features that facilitate system call monitoring: Mach 3.0 <ref> [Rashid89] </ref>, pSOS [Integrated95] and HP-UX [HPa95]. The taxonomy begins with Figure 1 which defines a simple control flow model of a system call request in a generic operating system. Control switches from the application to the kernel when the system call is executed.
Reference: [Rekiere97] <author> C. Rekiere, </author> <title> Middleware Enabled Fault Management for Commercial Operating Systems, </title> <type> CMU Masters Thesis Report, </type> <month> April </month> <year> 1997. </year>
Reference-contexts: The tables are split between implementation and fault-management attributes with the preferred attributes in boldface type. Each attribute is described in detail in <ref> [Rekiere97] </ref>. Mach3.0 sentry and HP Trace are designed with all the preferred Application 1 Kernel HP-UX syscall 2 enter exit Middleware Kernel Instrumentation 1a 1b FIGURE 9. HP-UX Operating System model with Middleware (KI) May 3, 1997 11 implementation attributes. HPLR is designed with all the preferred fault-management attributes.
Reference: [Russinovich94] <author> M.E. </author> <title> Russinovich Application-Transparent Fault Management, </title> <type> CMU Ph.D. Thesis, </type> <month> August </month> <year> 1994. </year>
Reference-contexts: The microkernel provides enough low-level support so that various servers can be implemented to run on top of it <ref> [Russinovich94] </ref>. The server implemented for the system call monitor evaluation is UNIX 4.3 (UX) [Bach86]. When a system call trap is made, Mach switches control into the emulation library. This library takes the system call parameters and number, and packages a message which is sent to UX. <p> After the request has been serviced, UX packages a reply message and sends it to the application. The emulation library unpackages the reply parameters from the message and control is returned to the instruction following the trap <ref> [Russinovich94] </ref>. Mach 3.0 Application 1 4 Emulation Library 5 Micro-Kernel UX syscall 3 enter exit FIGURE 5. Mach Operating System Model May 3, 1997 8 The middleware layer implemented for Mach 3.0 introduces the concept of a sentry mechanism. <p> The central idea behind the sentry concept is that operating system entry and exit points provide sufficient visibility and control to support the majority of standard fault detection and tolerance techniques. These points, called sentry points, allow the encapsulation of operating system calls <ref> [Russinovich94] </ref>. This encapsulation of a system call is represented in Figure 6. The same path as in a standard system call is followed until the UX thread receives a system call request message. <p> The second goal, to provide sufficient visibility for the implementation of assertions and rollback recovery, is achieved based on the location of the middleware in the execution process. <ref> [Russinovich94] </ref> defines two data sets necessary to perform rollback recovery: user inputs, and events leading to data request from users. User inputs are visible to HPLR when the application makes a system call request and passes control to HPLR. <p> Capturing events leading to data request from users can be done by enabling the system call monitor. Verifying argument parameters with assertions is possible when HPLR is passed control from the application. If an invalid argument is found, HPLR can 1. <ref> [Russinovich94] </ref> describes a rollback recovery mechanism that logs only user input and events leading to user input. This reduces the number of system calls and arguments logged compared to the system call monitor mechanism. The rollback recovery mechanism was run with 9% total overhead.
References-found: 11

