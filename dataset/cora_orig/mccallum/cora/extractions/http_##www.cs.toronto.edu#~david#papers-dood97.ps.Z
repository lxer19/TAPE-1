URL: http://www.cs.toronto.edu/~david/papers-dood97.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: 
Email: david@cs.toronto.edu  
Title: A Point-based Temporal Extension of SQL  
Author: David Toman 
Address: Toronto, Ontario M5S 1A4, Canada  
Affiliation: Department of Computer Science, University of Toronto  
Abstract: We propose a new approach to temporal extensions of SQL. Unlike the current proposals, e.g., SQL/Temporal, we use point-based references to time as the basis of our approach. The proposed language| SQL/TP|extends the syntax and semantics of SQL/92 in a very natural way: by adding a single data type to represent a linearly ordered universe of individual time instants. Such an extension allows the users to write temporal queries in customary fashion and vastly simplifies the semantics of the proposed language: we merely use the familiar SQL semantics. In this way SQL/TP also fixes many problems present in the semantics of the temporal query languages based on explicit interval-valued temporal attributes. In addition, we propose an efficient query evaluation procedure over a compact interval-based encoding of temporal relations. The algorithm is based on a sophisticated compilation technique that translates SQL/TP queries to SQL/92. In this way existing database systems can be used for managing temporal data. We substantiate this claim by proposing an experimental version of a SQL/TP compiler to serve as a front-end for DB2 1 [13].
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Abiteboul, S., Herr, L., Van den Bussche, J. </author> <title> Temporal versus First-Order Logic to Query Temporal Databases. </title> <booktitle> Proc. ACM PODS 1996, </booktitle> <pages> 49-57, </pages> <year> 1996. </year>
Reference-contexts: First, we argue that a single temporal dimension is not sufficient to formulate general temporal queries. Consider the query "are there two distinct time instants when a given relation contains exactly the same tuples?" <ref> [1] </ref> and [20] have independently shown that this query cannot be formulated in first-order temporal logic. A direct corollary of this result is that this query cannot be expressed in any single-dimensional temporal relational algebra 2 . <p> In this way our approach separates an abstract query language|SQL/TP|defined over a clean model of point-based linearly ordered time from the concrete interval-based encoding of timestamps which is hidden from the user. The approach is based on several recent results in the area of temporal and constraint query languages <ref> [1, 15, 19, 20] </ref>. In addition, a we define a meaningful approach to duplicate semantics and aggregation that is independent of the particular encoding (using the results in [10, 11]). <p> This way we can build a SQL/TP front-end to an existing RDBMS and provide tem poral capabilities without modifying the underlying database system itself. - SQL/TP can express all representation independent SQL/Temporal queries. Moreover, SQL/TP is complete in the sense of [8]. The results in <ref> [1, 20] </ref> show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal relational algebra, e.g., [7]; this issue is not clear for TSQL2-derived languages [5, 17, 18]. <p> It is easy to see that all the relational operations, with the exception of duplicate preserving projection, meet this requirement. However, the duplicate-preserving projection can produce such tables, e.g.: f ("Poland"; <ref> [1945; 1] </ref>)g k:k ! f ("Poland"; n) : n 1945g 1 ! f ("Poland"); : : : ; ("Poland"); : : :g The result of the projection contains infinite duplication of the tuple ("Poland"). <p> We can also express queries shown not to be expressible in TRA [7], e.g., the query "is there a pair of distinct time instants, when exactly the same countries were independent?" <ref> [1, 20] </ref>. 4.3 Examples of Queries In this section we provide illustrative examples of SQL/TP queries. The examples are chosen to highlight the ease and naturality of formulating queries in SQL/TP.
Reference: 2. <author> Allen, J. F. </author> <title> Maintaining knowledge about temporal intervals. </title> <journal> Communications of the ACM, </journal> <volume> 26(11) </volume> <pages> 832-843, </pages> <year> 1983. </year>
Reference-contexts: This is very different from the approaches 3 Other relational languages can be used as well, provided they have sufficient expres sive power. taken in the various interval logics <ref> [2] </ref>, where intervals represent points in a two-dimensional (half-)space.
Reference: 3. <author> Bohlen, M. H., Chomicki, J., Snodgrass, R. T., Toman, D. </author> <title> Querying TSQL2 Databases with Temporal Logic. </title> <booktitle> In Proc. EDBT'96, </booktitle> <volume> LNCS 1057, </volume> <pages> 325-341, </pages> <year> 1996. </year>
Reference-contexts: Using this result we can show that, e.g., the first-order temporal logic queries can be efficiently translated to SQL/TP: all the temporal operators can be translated into small fixed-size subqueries and views with exactly one temporal attribute <ref> [3] </ref>. Similar result holds for all TRA [7] based languages. 6 Conclusion We have shown that a high-level point-based approach to temporal extensions of SQL has many advantages over the common approaches that use interval-based attributes: simple syntax and semantics, meaningful aggregation, and possibilities of advanced query optimization.
Reference: 4. <author> Bohlen, M. H., Jensen, C. S. </author> <title> Seamless Integration of Time into SQL. </title> <institution> University of Aalborg, </institution> <address> http://www.cs.auc.dk/ boehlen/Software/Tiger/atsql.ps.gz, </address> <year> 1996. </year>
Reference-contexts: Instead, compact encodings of sets of time instants (often called periods of validity) associated with a tuple are encoded using intervals [16, 18], bitem-poral elements <ref> [4, 14] </ref>, or other fixed-dimensional products of intervals (hyper-rectangles). The chosen encoding then provides a domain of values for temporal attributes. <p> The data model and the semantics are point-based <ref> [4, 9] </ref>: the intervals are used merely as compact descriptions of large sets of time instants (even in cases when one of the various duplicate semantics is used).
Reference: 5. <author> Bohlen, M. H., Jensen, C. S., Snodgrass, R. T. </author> <title> Evaluating and Enhancing the Completeness of TSQL2. </title> <type> Technical Report TR 95-5, </type> <institution> Computer Science Department, University of Arizona, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: another temporal extension of SQL? The last decade of research in temporal databases has led to the development of several temporal query languages based on extensions of existing relational languages, e.g., TQUEL [16] or various temporal extensions of SQL, most prominent of which are TSQL2 [17] and its variants: ATSQL2 <ref> [5] </ref> and the current proposal of temporal extension of SQL3 to the ISO and ANSI standardization committees|SQL/Temporal [18]. 2.1 Current Proposals All the current proposals recognize that timestamping ordinary tuples with single time instants leads to enormous space requirements: a tuple would have to be repeated for every time instant at <p> Moreover, SQL/TP is complete in the sense of [8]. The results in [1, 20] show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal relational algebra, e.g., [7]; this issue is not clear for TSQL2-derived languages <ref> [5, 17, 18] </ref>. Our language can be easily extended to support the migration requirements [18] that require several levels of temporal upward compatibility with SQL.
Reference: 6. <author> Bohlen, M. H., Snodgrass, R. T., Soo, M. D. </author> <title> Coalescing in Temporal Databases. </title> <booktitle> Proc. 22nd Int. Conf. on Very Large Databases, </booktitle> <pages> 180-191, </pages> <year> 1996. </year>
Reference-contexts: Moreover, this problem cannot be avoided using a different normal form as there is no unique coalescing-based normal form for dimension higher than one (for detailed discussion of coalescing see <ref> [6] </ref>). In addition, in many cases the user has no control over the representation of the intermediate results since the coalescing is performed by the system implic 2 A relational algebra over the universe of single-dimensional temporal relations. itly. <p> This problem goes hand in hand with defining various normal forms <ref> [6, 19] </ref> of temporal relations and enforcing them over updates 13 .
Reference: 7. <author> Clifford J., Croker A., Tuzhilin A. </author> <title> On Completeness of Historical Relational Query Languages. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 19, No. 1, </volume> <pages> 64-116, </pages> <year> 1994. </year>
Reference-contexts: Moreover, SQL/TP is complete in the sense of [8]. The results in [1, 20] show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal relational algebra, e.g., <ref> [7] </ref>; this issue is not clear for TSQL2-derived languages [5, 17, 18]. Our language can be easily extended to support the migration requirements [18] that require several levels of temporal upward compatibility with SQL. <p> Theorem 4.6 The first-order fragment of SQL/TP is expressively equivalent to range restricted two-sorted first order logic (temporal relational calculus). We can also express queries shown not to be expressible in TRA <ref> [7] </ref>, e.g., the query "is there a pair of distinct time instants, when exactly the same countries were independent?" [1, 20]. 4.3 Examples of Queries In this section we provide illustrative examples of SQL/TP queries. The examples are chosen to highlight the ease and naturality of formulating queries in SQL/TP. <p> Using this result we can show that, e.g., the first-order temporal logic queries can be efficiently translated to SQL/TP: all the temporal operators can be translated into small fixed-size subqueries and views with exactly one temporal attribute [3]. Similar result holds for all TRA <ref> [7] </ref> based languages. 6 Conclusion We have shown that a high-level point-based approach to temporal extensions of SQL has many advantages over the common approaches that use interval-based attributes: simple syntax and semantics, meaningful aggregation, and possibilities of advanced query optimization.
Reference: 8. <author> Codd, E. F. </author> <title> Relational completeness of database sublanguages. In Rustin, R.(ed.) </title> <booktitle> Courant Computer Science Symposium 6: Data Base Systems, </booktitle> <pages> 65-98, </pages> <publisher> Prentice-Hall, </publisher> <year> 1972. </year>
Reference-contexts: This way we can build a SQL/TP front-end to an existing RDBMS and provide tem poral capabilities without modifying the underlying database system itself. - SQL/TP can express all representation independent SQL/Temporal queries. Moreover, SQL/TP is complete in the sense of <ref> [8] </ref>. The results in [1, 20] show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal relational algebra, e.g., [7]; this issue is not clear for TSQL2-derived languages [5, 17, 18]. <p> This fact does not affect the generality of our proposal: it is an easy exercise to show that the proposed fragment forms a (first-order) complete query language <ref> [8] </ref>. More--over, all representation independent SQL/Temporal queries, including queries with aggregation and universal subqueries, can be equivalently formulated in this fragment. Syntax. The chosen syntactic subset of SQL/TP uses two basic syntactic constructs: Select block.
Reference: 9. <author> Chomicki J. </author> <title> Temporal Query Languages: a Survey. </title> <booktitle> Proc. International Conference on Temporal Logic, </booktitle> <address> July 1994, Bonn, Germany, </address> <publisher> Springer-Verlag (LNAI 827), </publisher> <pages> 506-534. </pages>
Reference-contexts: The rest of the paper is organized as follows: Section 2 explains the shortcomings of the current proposals of temporal extensions of SQL and sketches out the solution. Section 3 introduces the temporal data model: the abstract and concrete (interval-based) temporal databases (following the terminology introduced in <ref> [9] </ref>). Section 4 defines the syntax and semantics of SQL/TP and gives examples of temporal queries. Section 5 gives a sketch of the proposed compilation technique. <p> The data model and the semantics are point-based <ref> [4, 9] </ref>: the intervals are used merely as compact descriptions of large sets of time instants (even in cases when one of the various duplicate semantics is used). <p> We summarily refer to those data types as the uninter-preted constants. The relationships between the time instants and the uninterpreted constants are captured in a finite set of temporal relations stored in the database. Following the terminology of <ref> [9] </ref> we distinguish the abstract temporal databases from the concrete temporal databases: Definition 3.1 (Abstract Temporal Database) A signature of a predicate symbol R is a tuple (a 1 : t 1 ; : : : ; a k : t k ) where a i are distinct attribute names, t
Reference: 10. <author> Chomicki, J., Kuper, G. M. </author> <title> Measuring Infinite Relations. </title> <booktitle> Proc. ACM PODS 1995, </booktitle> <pages> 78-85, </pages> <year> 1995. </year>
Reference-contexts: The approach is based on several recent results in the area of temporal and constraint query languages [1, 15, 19, 20]. In addition, a we define a meaningful approach to duplicate semantics and aggregation that is independent of the particular encoding (using the results in <ref> [10, 11] </ref>). While we mostly concentrate on evaluation of temporal queries over the interval-based encoding of time, conforming to the above principles allows us to use different encoding for sets of time instants, e.g., the linear repeating points [22] for periodic events, without the need for new syntax and semantics. <p> In addition all data attributes (and point temporal attributes) are mutually independent. For similar reasons we restrict the use of aggregate operations: we require the aggregated attribute to be independent of the group by attributes <ref> [10] </ref>. In addition we also restrict the use of duplicate-preserving projection on all temporal attributes encoded by intervals. We have already seen that duplicate-preserving projection is not possible for unbounded data types. <p> Note that cnt ' G maps concrete tuples to natural numbers. However, if we used a dense model of time then cnt would be a measure on the sets of time instants and could return non-integral counts, e.g., 1.5 years. For details on aggregation and measures see <ref> [10] </ref>. Lemma 5.6 Given fixed E, G E, and ', the function cnt ' G can be defined using an integer expression over the value of x. The cnt function operates on single tuples and thus contributes only a constant to the overall data complexity of queries.
Reference: 11. <author> Chomicki, J., Goldin, D. Q., Kuper, G. M. </author> <title> Variable Independence and Aggregation Closure. </title> <booktitle> Proc. ACM PODS 1996, </booktitle> <pages> 40-48, </pages> <year> 1996. </year>
Reference-contexts: The approach is based on several recent results in the area of temporal and constraint query languages [1, 15, 19, 20]. In addition, a we define a meaningful approach to duplicate semantics and aggregation that is independent of the particular encoding (using the results in <ref> [10, 11] </ref>). While we mostly concentrate on evaluation of temporal queries over the interval-based encoding of time, conforming to the above principles allows us to use different encoding for sets of time instants, e.g., the linear repeating points [22] for periodic events, without the need for new syntax and semantics. <p> To avoid this problem we use the notion of attribute independence. Rather than a semantic definition of attribute independence <ref> [11] </ref> we use a syntactic inference system to detect attribute independence in a SQL/TP expression: Definition 4.3 (Attribute Independence) Let t 1 and t 2 be two temporal attributes in the signature of a SQL/TP expression exp.
Reference: 12. <author> Date, C. J., Drawen, H. </author> <title> A Guide to the SQL Standard (3rd ed.), </title> <address> Addison-Welsley, </address> <year> 1993. </year>
Reference-contexts: following requirements: - SQL/TP can be efficiently implemented on top of an interval-based representation of temporal databases: the performance of a SQL/TP system should be comparable to performance of SQL/Temporal based DBMS on a vast majority of representation independent queries. - SQL/TP statements can be compiled to standard SQL/92 3 <ref> [12] </ref>; the translated queries can be evaluated using an off-shelf database system. This way we can build a SQL/TP front-end to an existing RDBMS and provide tem poral capabilities without modifying the underlying database system itself. - SQL/TP can express all representation independent SQL/Temporal queries.
Reference: 13. <author> IBM Database 2, </author> <title> SQL Reference for common servers. </title> <institution> IBM Corp., </institution> <year> 1995. </year>
Reference: 14. <author> Jensen, C. S., Snodgrass, R. T., Soo, M. J. </author> <title> Unification of Temporal Data Models. </title> <booktitle> Proc. 9th Int. Conf. on Data Engineering, </booktitle> <pages> 262-271, </pages> <year> 1993. </year>
Reference-contexts: Instead, compact encodings of sets of time instants (often called periods of validity) associated with a tuple are encoded using intervals [16, 18], bitem-poral elements <ref> [4, 14] </ref>, or other fixed-dimensional products of intervals (hyper-rectangles). The chosen encoding then provides a domain of values for temporal attributes.
Reference: 15. <author> Kanellakis, P. C., Kuper, G. M., Revesz, </author> <title> P.Z . Constraint Query Languages. </title> <journal> Journal of Computer and System Sciences 51(1) </journal> <pages> 26-52, </pages> <year> 1995. </year>
Reference-contexts: In this way our approach separates an abstract query language|SQL/TP|defined over a clean model of point-based linearly ordered time from the concrete interval-based encoding of timestamps which is hidden from the user. The approach is based on several recent results in the area of temporal and constraint query languages <ref> [1, 15, 19, 20] </ref>. In addition, a we define a meaningful approach to duplicate semantics and aggregation that is independent of the particular encoding (using the results in [10, 11]).
Reference: 16. <author> Snodgrass R. T. </author> <title> The Temporal Query Language TQuel. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 247-298, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: The paper is concluded with several open questions and directions of future research. 2 Why another temporal extension of SQL? The last decade of research in temporal databases has led to the development of several temporal query languages based on extensions of existing relational languages, e.g., TQUEL <ref> [16] </ref> or various temporal extensions of SQL, most prominent of which are TSQL2 [17] and its variants: ATSQL2 [5] and the current proposal of temporal extension of SQL3 to the ISO and ANSI standardization committees|SQL/Temporal [18]. 2.1 Current Proposals All the current proposals recognize that timestamping ordinary tuples with single time <p> Instead, compact encodings of sets of time instants (often called periods of validity) associated with a tuple are encoded using intervals <ref> [16, 18] </ref>, bitem-poral elements [4, 14], or other fixed-dimensional products of intervals (hyper-rectangles). The chosen encoding then provides a domain of values for temporal attributes.
Reference: 17. <author> Snodgrass R.T. </author> <title> (editor). The TSQL2 Temporal Query Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> 674+xxiv pages, </address> <year> 1995. </year>
Reference-contexts: of future research. 2 Why another temporal extension of SQL? The last decade of research in temporal databases has led to the development of several temporal query languages based on extensions of existing relational languages, e.g., TQUEL [16] or various temporal extensions of SQL, most prominent of which are TSQL2 <ref> [17] </ref> and its variants: ATSQL2 [5] and the current proposal of temporal extension of SQL3 to the ISO and ANSI standardization committees|SQL/Temporal [18]. 2.1 Current Proposals All the current proposals recognize that timestamping ordinary tuples with single time instants leads to enormous space requirements: a tuple would have to be repeated <p> Moreover, SQL/TP is complete in the sense of [8]. The results in [1, 20] show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal relational algebra, e.g., [7]; this issue is not clear for TSQL2-derived languages <ref> [5, 17, 18] </ref>. Our language can be easily extended to support the migration requirements [18] that require several levels of temporal upward compatibility with SQL. <p> Poland 1025 Poland 1794 Poland 1918 Poland 1938 Poland 1945 Czech Kingdom 1198 Czech Kingdom 1620 Czechoslovakia 1918 Czechoslovakia 1938 Czechoslovakia 1945 Czechoslovakia 1992 Czech Republic 1995 Slovakia 1940 Slovakia 1944 Slovakia 1993 We do not impose any restrictions on the number of temporal attributes in relations (unlike, e.g., TSQL2 <ref> [17] </ref>).
Reference: 18. <author> Snodgrass, R. T., Bohlen, M. H., Jensen C. S., Steiner, A. </author> <title> Adding Valid Time to SQL/Temporal, ISO/IEC JTC1/SC21/WG3 DBL MAD-146r2 21/11/96, (change proposal). </title>
Reference-contexts: development of several temporal query languages based on extensions of existing relational languages, e.g., TQUEL [16] or various temporal extensions of SQL, most prominent of which are TSQL2 [17] and its variants: ATSQL2 [5] and the current proposal of temporal extension of SQL3 to the ISO and ANSI standardization committees|SQL/Temporal <ref> [18] </ref>. 2.1 Current Proposals All the current proposals recognize that timestamping ordinary tuples with single time instants leads to enormous space requirements: a tuple would have to be repeated for every time instant at which the fact represented by the tuple holds. <p> Instead, compact encodings of sets of time instants (often called periods of validity) associated with a tuple are encoded using intervals <ref> [16, 18] </ref>, bitem-poral elements [4, 14], or other fixed-dimensional products of intervals (hyper-rectangles). The chosen encoding then provides a domain of values for temporal attributes. <p> Moreover, SQL/TP is complete in the sense of [8]. The results in [1, 20] show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal relational algebra, e.g., [7]; this issue is not clear for TSQL2-derived languages <ref> [5, 17, 18] </ref>. Our language can be easily extended to support the migration requirements [18] that require several levels of temporal upward compatibility with SQL. <p> Our language can be easily extended to support the migration requirements <ref> [18] </ref> that require several levels of temporal upward compatibility with SQL. While SQL/TP itself does not literally follow all the requirements, the compatibility can be easily achieved using a very simple syntactic manipulation of the source queries and adding tags to distinguish the particular compati bility modes.
Reference: 19. <author> Toman, D. </author> <title> Point-based vs. Interval-based Temporal Query Languages Proc. </title> <booktitle> ACM PODS 1996, </booktitle> <pages> 58-67, </pages> <year> 1996. </year>
Reference-contexts: In this way our approach separates an abstract query language|SQL/TP|defined over a clean model of point-based linearly ordered time from the concrete interval-based encoding of timestamps which is hidden from the user. The approach is based on several recent results in the area of temporal and constraint query languages <ref> [1, 15, 19, 20] </ref>. In addition, a we define a meaningful approach to duplicate semantics and aggregation that is independent of the particular encoding (using the results in [10, 11]). <p> In the rest of this section we give a sketch of the SQL/TP to SQL/92 translation. The translation is based on an extension of results in <ref> [19] </ref> to duplicate semantics and uses a nouveau normalization technique. 5.1 Data Definition Language The translation of the data definition language statements is fairly simple: we merely convert the abstract signature to its concrete counterpart. <p> All this is achieved while maintaining efficient query evaluation over temporal databases based on interval encoding of timestamps. We have also shown that all representation independent TSQL2 queries are expressible in SQL/TP (follows from <ref> [19] </ref>). Future Work. Our proposal is only a first step towards an implementation of SQL/TP on top of an ordinary RDBMS systems. There are still many open questions: Can we use more complex temporal domains? In our proposal we used a discrete linear order with a limited way of counting. <p> This problem goes hand in hand with defining various normal forms <ref> [6, 19] </ref> of temporal relations and enforcing them over updates 13 .
Reference: 20. <author> Toman, D., Niwinski, D. </author> <title> First-Order Temporal Queries Inexpressible in Temporal Logic Proc. </title> <editor> EDBT'96, Arpes, Bouzeghoub (eds.), </editor> <volume> LNCS 1057, </volume> <pages> 307-324, </pages> <year> 1996. </year>
Reference-contexts: First, we argue that a single temporal dimension is not sufficient to formulate general temporal queries. Consider the query "are there two distinct time instants when a given relation contains exactly the same tuples?" [1] and <ref> [20] </ref> have independently shown that this query cannot be formulated in first-order temporal logic. A direct corollary of this result is that this query cannot be expressed in any single-dimensional temporal relational algebra 2 . Moreover, [20] shows that to express all first-order queries the number of temporal dimensions cannot be <p> distinct time instants when a given relation contains exactly the same tuples?" [1] and <ref> [20] </ref> have independently shown that this query cannot be formulated in first-order temporal logic. A direct corollary of this result is that this query cannot be expressed in any single-dimensional temporal relational algebra 2 . Moreover, [20] shows that to express all first-order queries the number of temporal dimensions cannot be bounded by any constant. Therefore, multiple temporal dimensions cannot be avoided during the bottom-up evaluation of temporal queries even if the final result is a single-dimensional temporal relation or boolean [20]. <p> Moreover, <ref> [20] </ref> shows that to express all first-order queries the number of temporal dimensions cannot be bounded by any constant. Therefore, multiple temporal dimensions cannot be avoided during the bottom-up evaluation of temporal queries even if the final result is a single-dimensional temporal relation or boolean [20]. This fact, combined with the use of explicit interval-valued temporal attributes, leads directly to situations similar to Example 2.1. <p> In this way our approach separates an abstract query language|SQL/TP|defined over a clean model of point-based linearly ordered time from the concrete interval-based encoding of timestamps which is hidden from the user. The approach is based on several recent results in the area of temporal and constraint query languages <ref> [1, 15, 19, 20] </ref>. In addition, a we define a meaningful approach to duplicate semantics and aggregation that is independent of the particular encoding (using the results in [10, 11]). <p> This way we can build a SQL/TP front-end to an existing RDBMS and provide tem poral capabilities without modifying the underlying database system itself. - SQL/TP can express all representation independent SQL/Temporal queries. Moreover, SQL/TP is complete in the sense of [8]. The results in <ref> [1, 20] </ref> show that this is not the case for any of the temporal query languages based on a fixed-dimensional temporal relational algebra, e.g., [7]; this issue is not clear for TSQL2-derived languages [5, 17, 18]. <p> We can also express queries shown not to be expressible in TRA [7], e.g., the query "is there a pair of distinct time instants, when exactly the same countries were independent?" <ref> [1, 20] </ref>. 4.3 Examples of Queries In this section we provide illustrative examples of SQL/TP queries. The examples are chosen to highlight the ease and naturality of formulating queries in SQL/TP.
Reference: 21. <author> Williams, H. P. </author> <title> Fourier-Motzkin Elimination Extension to Integer Programming Problems. </title> <journal> In Journal of Combinatorial Theory (A) 21, </journal> <pages> 118-123, </pages> <year> 1976. </year>
Reference-contexts: The translation utilizes the quantifier elimination procedure for linear order <ref> [21] </ref> to replace references to individual time instants in the queries with references to interval endpoints. In the rest of this section we give a sketch of the SQL/TP to SQL/92 translation.
Reference: 22. <author> Kabanza, F., Stevenne, J.-M., Wolper, P. </author> <title> Handling Infinite Temporal Data. </title> <journal> JCSS 51(1): </journal> <pages> 3-17, </pages> <year> 1995. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: While we mostly concentrate on evaluation of temporal queries over the interval-based encoding of time, conforming to the above principles allows us to use different encoding for sets of time instants, e.g., the linear repeating points <ref> [22] </ref> for periodic events, without the need for new syntax and semantics.
References-found: 22

