URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-51.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-51.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Aggoun and N. Beldiceanu. </author> <title> An Overview of the CHIP compiler. </title> <booktitle> In Eighth International Conference on Logic Programming (ICLP-91), </booktitle> <address> Paris (France), </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Existing CLP languages support backtracking by generalizing traditional Prolog implementations: modifications to the constraint system are trailed (i.e. saved on a special stack which contains pairs haddress; valuei) and restored on backtracking. In addition, techniques such as timestamps (e.g. <ref> [1] </ref>) are used to avoid trailing the same object several times in between two choice points.
Reference: [2] <author> A. Colmerauer. </author> <title> An Introduction to Prolog III. </title> <journal> CACM, </journal> <volume> 28(4) </volume> <pages> 412-418, </pages> <year> 1990. </year>
Reference-contexts: In this paper, we consider an instance of the CLP scheme over the constraint system &lt; Lin . &lt; Lin consists of linear equations, inequalities, and disequations over real numbers 2 and is included in several languages, including CHIP [4, 12], CLP (&lt;) [8, 7, 10], and Prolog III <ref> [2] </ref>. Its implementation maintains the current set of constraints (which is known to be satisfiable) in a solved form and the fundamental operation of these languages is an incremental satisfiability test which checks if the conjunction of a new constraint c and the existing constraints is satisfiable. <p> Sections 5, 6, and 7 discuss the implementation of the new scheme. Section 8 presents some experimental results, while Section 9 contains the conclusion of this research. 2 A Motivating Example To illustrate the functionalities of CLP (&lt; Lin ), we use an example from <ref> [2] </ref>. Consider an infinite sequence of numbers x 1 ; x 2 ; : : : defined by x i+2 = j x i+1 j x i (i 1) where x 1 and x 2 are arbitrary real numbers. <p> See [5] for the details. 8 Experimental Results The Benchmarks Our benchmarks are mainly taken from <ref> [2, 8, 11] </ref> with a couple of additional programs. The first four programs are cryptarithmetic puzzles with two versions for each problem. The two versions correspond to different representations of the constraint (a natural and a carry representation) which lead to very different search spaces. <p> The first four programs are cryptarithmetic puzzles with two versions for each problem. The two versions correspond to different representations of the constraint (a natural and a carry representation) which lead to very different search spaces. SendMory1 is from [8] while Donald is from <ref> [2] </ref>. The programs have the property that backtracking undoes only constraints of the form s = b, where s is a slack variable and b is a value. The next two programs, Investment and Laplace, are deterministic programs. The first program is taken from [2] while the second program is from <p> from [8] while Donald is from <ref> [2] </ref>. The programs have the property that backtracking undoes only constraints of the form s = b, where s is a slack variable and b is a value. The next two programs, Investment and Laplace, are deterministic programs. The first program is taken from [2] while the second program is from [8]. Investment is a program to compute installments with strong relationships between the same values. Laplace computes an approximation method for Laplace's equation. Both programs manipulate large coefficients and produce overflows with finite precision numbers. <p> Note also that, although the programs are deterministic, they produce some choice points (which would lead to failure if tried). The last programs illustrate backtracking over arbitrary constraints. Magic and Permutation solves two problems from combinatory theory [11]. Periodic is the problem described in Section 2. Square <ref> [2] </ref> is a very combinatorial problem which amounts to placing squares, all of different sizes, in a rectangle such that no two squares overlap and no empty space is left.
Reference: [3] <author> G.B. Dantzig. </author> <title> Linear Programming and Extensions. </title> <publisher> Princeton University Press, </publisher> <year> 1963. </year>
Reference-contexts: A constraint is a relation t 1 ffi t 2 with ffi 2 f&gt;; ; =; 6=; ; &lt;g: 2 The constraint system is a generalization of linear programming <ref> [3] </ref> due to the presence of strict inequalities (&gt; and &lt;) and disequations (6=). Implementations of this constraint system use a set of rewriting rules (usually applied dynamically) to consider only equations and disequations.
Reference: [4] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, ~ A. Aggoun, T. Graf, and F. Berthier. </author> <title> The Constraint Logic Programming Language CHIP. </title> <booktitle> In FGCS-88, </booktitle> <address> Tokyo, Japan, </address> <month> Dec. </month> <year> 1988. </year>
Reference-contexts: In this paper, we consider an instance of the CLP scheme over the constraint system &lt; Lin . &lt; Lin consists of linear equations, inequalities, and disequations over real numbers 2 and is included in several languages, including CHIP <ref> [4, 12] </ref>, CLP (&lt;) [8, 7, 10], and Prolog III [2].
Reference: [5] <author> J.L. Imbert and P. Van Hentenryck. </author> <title> Efficient Handling of Disequations in CLP Over Linear Rational Arithmetics. In Constraint Logic Programming: Selected Research. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: All algorithms remain the same except that (1) if dereferencing produces a constraint containing only slack variables, this constraint is transferred from the G-system to the S-system; and (2) if backpropagation leads to a disequation containing only slack variables, it is sent to the S-system. See <ref> [5] </ref> for the details. 8 Experimental Results The Benchmarks Our benchmarks are mainly taken from [2, 8, 11] with a couple of additional programs. The first four programs are cryptarithmetic puzzles with two versions for each problem.
Reference: [6] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In POPL-87, </booktitle> <address> Munich, </address> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Constraint logic programming (CLP) <ref> [6] </ref> is a generalization of logic programming where unification is replaced by constraint solving as the basic operation of the language. The combination of constraint solving and nondeterminism (approximated by backtracking) makes these languages appealing for a variety of combinatorial search problems.
Reference: [7] <author> J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> An Abstract Machine for CLP(&lt;). </title> <booktitle> In PLDI'92, </booktitle> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: In this paper, we consider an instance of the CLP scheme over the constraint system &lt; Lin . &lt; Lin consists of linear equations, inequalities, and disequations over real numbers 2 and is included in several languages, including CHIP [4, 12], CLP (&lt;) <ref> [8, 7, 10] </ref>, and Prolog III [2].
Reference: [8] <author> J. Jaffar, S. Michaylov, P.J. Stuckey, and R. Yap. </author> <title> The CLP(&lt;) Language and System. </title> <journal> ACM Transactions on Programming Languages, </journal> <volume> 14(3) </volume> <pages> 339-395, </pages> <year> 1992. </year>
Reference-contexts: In this paper, we consider an instance of the CLP scheme over the constraint system &lt; Lin . &lt; Lin consists of linear equations, inequalities, and disequations over real numbers 2 and is included in several languages, including CHIP [4, 12], CLP (&lt;) <ref> [8, 7, 10] </ref>, and Prolog III [2]. <p> The engine and the G-and S-systems have their own choice point stacks, since there is no reason to save information in the constraint system if no activity takes place. Design decisions similar in spirit were adopted in CLP (&lt;) <ref> [8] </ref>. The interface and the G- and S-systems can be seen as abstract data types providing seven operations: SolveEqual, SolveGreatereq, SolveGreater, SolveNotEqual and Try, Retry, Trust. The first four operations are used to insert a new constraint and returns a Boolean value. <p> Note that trailing can be further reduced by several techniques such as the reconstruction of some of the data structures at backtracking time (e.g. cross-reference tables in the CLP (&lt;) system <ref> [8] </ref>). <p> See [5] for the details. 8 Experimental Results The Benchmarks Our benchmarks are mainly taken from <ref> [2, 8, 11] </ref> with a couple of additional programs. The first four programs are cryptarithmetic puzzles with two versions for each problem. The two versions correspond to different representations of the constraint (a natural and a carry representation) which lead to very different search spaces. <p> The first four programs are cryptarithmetic puzzles with two versions for each problem. The two versions correspond to different representations of the constraint (a natural and a carry representation) which lead to very different search spaces. SendMory1 is from <ref> [8] </ref> while Donald is from [2]. The programs have the property that backtracking undoes only constraints of the form s = b, where s is a slack variable and b is a value. The next two programs, Investment and Laplace, are deterministic programs. <p> The next two programs, Investment and Laplace, are deterministic programs. The first program is taken from [2] while the second program is from <ref> [8] </ref>. Investment is a program to compute installments with strong relationships between the same values. Laplace computes an approximation method for Laplace's equation. Both programs manipulate large coefficients and produce overflows with finite precision numbers.
Reference: [9] <author> J.R. Schoenfield. </author> <title> Mathematical Logic. </title> <publisher> Addison-Wesley, </publisher> <year> 1967. </year>
Reference-contexts: 9 or, in other words, that the sequences x 1 ; x 2 ; : : : and x 10 ; x 11 ; : : : are always identical. 2 All results described in this paper hold for real and rational numbers since the two structures are elementary equivalent <ref> [9] </ref>. Our implementation uses infinite-precision numbers to guarantee numerical stability.
Reference: [10] <author> P. Stuckey. </author> <title> Incremental Linear Constraint Solving and Detection of Implicit Equalities. </title> <journal> ORSA Journal of Computing, </journal> <volume> 3 </volume> <pages> 269-274, </pages> <year> 1991. </year>
Reference-contexts: In this paper, we consider an instance of the CLP scheme over the constraint system &lt; Lin . &lt; Lin consists of linear equations, inequalities, and disequations over real numbers 2 and is included in several languages, including CHIP [4, 12], CLP (&lt;) <ref> [8, 7, 10] </ref>, and Prolog III [2].
Reference: [11] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> The MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: See [5] for the details. 8 Experimental Results The Benchmarks Our benchmarks are mainly taken from <ref> [2, 8, 11] </ref> with a couple of additional programs. The first four programs are cryptarithmetic puzzles with two versions for each problem. The two versions correspond to different representations of the constraint (a natural and a carry representation) which lead to very different search spaces. <p> Both programs manipulate large coefficients and produce overflows with finite precision numbers. Note also that, although the programs are deterministic, they produce some choice points (which would lead to failure if tried). The last programs illustrate backtracking over arbitrary constraints. Magic and Permutation solves two problems from combinatory theory <ref> [11] </ref>. Periodic is the problem described in Section 2. Square [2] is a very combinatorial problem which amounts to placing squares, all of different sizes, in a rectangle such that no two squares overlap and no empty space is left.
Reference: [12] <author> P. Van Hentenryck and T. Graf. </author> <title> Standard Forms for Rational Linear Arithmetics in Constraint Logic Programming. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <pages> 5(2-4), </pages> <year> 1992. </year>
Reference-contexts: In this paper, we consider an instance of the CLP scheme over the constraint system &lt; Lin . &lt; Lin consists of linear equations, inequalities, and disequations over real numbers 2 and is included in several languages, including CHIP <ref> [4, 12] </ref>, CLP (&lt;) [8, 7, 10], and Prolog III [2]. <p> Constraint solving and backtracking are substantially more complex this case. 6.1 The Solved Form The only difference between the solved forms of the G-system and S-system is a lexicographic requirement imposed on the solved form of the equations. The lexicographic requirement, proposed in <ref> [12] </ref>, assumes a total ordering on the variables (e.g. s 1 &lt; s 2 &lt; : : :) and generalizes the positivity requirement of the simplex algorithm. <p> However, this would entail a time penalty for constraint solving which would need to store coefficients on the trail instead of pointers. 8 made explicit makes it easy to check the disequations, since it is sufficient to check if a disequation does not reduce to 0 6= 0. See <ref> [12] </ref> for complete account on the solved form. Semantic backtracking can also be applied to systems not based on the lexicographic solved form such as CLP (&lt;) and Prolog III. <p> The constraint c itself is also divided by the coefficient of the entering variable to produce the new solved form. Pivoting preserves the solved form provided that a lexicographic pivoting rule is used <ref> [12] </ref>. 9 The case fixed variable is more subtle but does not require the full simplex algorithm. If b 0 is greater than zero, the constraint is unsatisfiable.

References-found: 12

