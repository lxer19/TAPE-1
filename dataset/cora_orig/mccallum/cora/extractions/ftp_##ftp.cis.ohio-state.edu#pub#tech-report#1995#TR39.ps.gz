URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/1995/TR39.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/rsrg/bib-certify.html
Root-URL: 
Email: weide,ogden-@cis.ohio-state.edu  
Title: Using Abstraction Relations to Verify  
Author: W. Weide William F. Ogden 
Date: September 1995  
Address: Columbus, OH 43210  
Affiliation: Department of Computer and Information Science The Ohio State University  
Note: Bruce  Copyright 1995 by the authors. All rights reserved.  
Pubnum: OSU-CISRC-9/95-TR39  
Abstract: Data Type Representations 
Abstract-found: 1
Intro-found: 1
Reference: [Abadi 91] <author> Abadi, M. and Lamport, L., </author> <title> The Existence of Refinement Mappings, </title> <journal> Theoretical Comp. Sci. </journal> <volume> 82, </volume> <month> 2 (May </month> <year> 1991), </year> <pages> pp. 253-284. </pages>
Reference-contexts: Lynch documents the practical utility of multivalued possibilities mappings (the I/O automata counterpart of abstraction relations) [Lynch 90]. However, Abadi and Lamport show that specifications can be transformed to avoid multivalued mappings, under certain conditions; refinement mappings (the counterpart of abstraction functions) always exist <ref> [Abadi 91] </ref>. Abadi and Lamport introduce techniques to avoid abstraction relations which, when adapted to the ADT 16 framework, require changing the specifications of some of the components involved in the proof. Changes to these specifications are ruled out by the modularity requirements we place on ADT correctness proofs.
Reference: [Cook 78] <author> Cook, S.A., </author> <title> Soundness and Completeness of an Axiom System for Program Verification, </title> <journal> SIAM J. Comp. </journal> <volume> 7, </volume> <month> 1 (February </month> <year> 1978), </year> <pages> pp. 70-90. </pages>
Reference-contexts: The Need for Abstraction Relations If a verification system cannot establish the correctness of some valid implementation of an abstraction (for reasons other than the lack of a complete deduction system for the mathematical theories involved), then it is not relatively complete <ref> [Cook 78] </ref>. We show in this section the main technical result of the paper: Theorem:Any relatively complete verification system that allows relational specifications of behavior for operations, must permit expression of abstraction relations and not just abstraction functions.
Reference: [Cormen 90] <author> Cormen, T. H., Leiserson, C. E., and Rivest, R. L., </author> <title> Introduction to Algorithms, </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: The notable feature of the present example is that there is a large and natural class of implementations that serve as exemplars. For instance, implementations that do not keep the edges in input order during the insertion phase, and those that use typical published code for Kruskals algorithm <ref> [Cormen 90] </ref> and are based on sorting algorithms that are not necessarily stable (e.g., quicksort or heapsort), are all examples of actual implementations in B M. 3 . 2 Inadequacy of Abstraction Functions: Proof of the Lemma We wish to prove that if I B (call this proposition p) and I
Reference: [Ehrich 90] <author> Ehrich, H.-D., and Sernadas, A., </author> <title> Algebraic Implementation of Objects over Objects, </title> <booktitle> in Stepwise Refinement of Distributed SystemsLecture Notes in Computer Science 430, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990, </year> <pages> pp. 239-266. </pages>
Reference-contexts: A third approach involves changing the specifications. This has been considered both in the ADT framework [Jones 90] and in related work <ref> [Ehrich 90] </ref> on concurrent processes involving I/O automata and sequences of actions. Lynch documents the practical utility of multivalued possibilities mappings (the I/O automata counterpart of abstraction relations) [Lynch 90].
Reference: [Ernst 91] <author> Ernst, G.W., Hookway, R.J., Menegay, J.A., and Ogden, W.F., </author> <title> Modular Verification of Ada Generics, </title> <journal> Comp. Lang. </journal> <volume> 16, 3/4 (1991), </volume> <pages> pp. 259-280. </pages>
Reference-contexts: Using an abstraction relation considerably simplifies the verification conditions for each of the Spanning_Forest_Machine_Template operations because the correspondence mapping is used separately in the verification of each operation <ref> [Ernst 91, Ernst 94] </ref>. 4. Discussion An noted in the introduction, the literature on verifying ADTs includes at least two conjectures that abstraction relations even if technically required in some circumstances are probably unnecessary in practice, at least where specifications are well-designed.
Reference: [Ernst 94] <author> Ernst, G. W., Hookway, R. J., and Ogden, W. F., </author> <title> Modular Verification of Data Abstractions with Shared Realizations, </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 20, </volume> <month> 4 (April </month> <year> 1994), </year> <pages> pp. 288-307. 18 </pages>
Reference-contexts: It is should be independent of the implementations of the lower-level components and independent of other parts of the system that use the code being verified <ref> [Ernst 94, Weide 92] </ref>. Previous work involving modular verification of ADTs leaves the role of abstraction relations unsettled. Leavens notes the value of simulation relations (essentially abstraction relations) in defining behavioral subtyping [Leavens 91]. <p> First we characterize a set of valid implementations whose members serve as exemplars for the lemma. Next we show why these implementations cannot be proved correct using abstraction functions. Finally, we explain how abstraction relations can be used to verify these implementations in a modular proof system <ref> [Ernst 94] </ref>. 3.1. Non-Monotonic Deterministic Batch-Style Implementations 3.1.1. Deterministic Batch-Style Implementations Let B be the class of valid deterministic batch-style implementations of Spanning_Forest_Machine_Template. The implementations in B are, first, deterministic: the outputs computed by each operation are entirely determined by its inputs. <p> Details are provided in Appendix B. The need for a relational programming language semantics ultimately cannot be avoided if specifications are allowed to be relational which they must be in order to permit specification of behavior such as that desired for Spanning_Forest_Machine_Template <ref> [Nelson 89, Ernst 94] </ref>. Given that a relational semantics is essential, abstraction relations between concrete and abstract values do not increase verification complexity. In fact, in some cases their use (even when not technically required) can simplify verification conditions. <p> Using an abstraction relation considerably simplifies the verification conditions for each of the Spanning_Forest_Machine_Template operations because the correspondence mapping is used separately in the verification of each operation <ref> [Ernst 91, Ernst 94] </ref>. 4. Discussion An noted in the introduction, the literature on verifying ADTs includes at least two conjectures that abstraction relations even if technically required in some circumstances are probably unnecessary in practice, at least where specifications are well-designed. <p> This would be undesirable when, as in this case, the natural intended behavior is inherently relational. Refusing to admit this possibility would leave a class of useful concepts that could not be specified or that could not be easily reused in building other component implementations <ref> [Ernst 94, Jones 90, Leavens 91] </ref>. Moreover, specifying functional behavior for the MSF problem would rule out interesting classes of implementations and would make the specification much harder to understand that specification would have to single out precisely which MSF must be produced, even in case of ties.
Reference: [Harms 91] <author> Harms, D.E., and Weide, B.W., </author> <title> Copying and Swapping: Influences on the Design of Reusable Software Components, </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 17, </volume> <month> 5 (May </month> <year> 1991), </year> <pages> pp. 424-435. </pages>
Reference: [Hoare 72] <author> Hoare, C. A. R., </author> <title> Proof of Correctness of Data Representations, </title> <journal> Acta Informatica 1, </journal> <volume> 1 (1972), </volume> <pages> pp. </pages> <note> 271-281; also in Gries, </note> <editor> D., ed., </editor> <title> Programming Methodology: A Collection of Articles by Members of IFIP WG 2.3, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1978, </year> <pages> pp. 269-281. </pages>
Reference-contexts: The formal verification that a given implementation does meet this conceptual specification then involves a correspondence mapping, traditionally called an abstraction function, between the model used in the implementation (the concrete or representation model) and the model used in the specification (the abstract or conceptual model) <ref> [Hoare 72] </ref>. For some ADT specifications and implementations, the natural connection between concrete and abstract models turns out to be relational, not functional. That is, in some cases a particular concrete value may represent any of several abstract values (see Figure 1).
Reference: [Jones 90] <author> Jones, C. B., </author> <title> Systematic Software Development Using VDM, </title> <booktitle> Prentice-Hall International, </booktitle> <address> Hertfordshire, UK, </address> <year> 1990. </year>
Reference-contexts: Jones summarizes what seems to be the common belief: Technically, abstraction relations might be needed in some cases, e.g., to verify implementations of ADTs whose specifications are biased, or not fully abstract <ref> [Jones 90, p. 219] </ref>; however [Jones 90, p. 182], If different abstract values correspond to one concrete value, 2 it is intuitively obvious that such values could have been merged in the abstraction. <p> Jones summarizes what seems to be the common belief: Technically, abstraction relations might be needed in some cases, e.g., to verify implementations of ADTs whose specifications are biased, or not fully abstract [Jones 90, p. 219]; however <ref> [Jones 90, p. 182] </ref>, If different abstract values correspond to one concrete value, 2 it is intuitively obvious that such values could have been merged in the abstraction. <p> In particular, it must be fully abstract; i.e., every two different conceptual values of the abstract data type being defined must be computationally distinguishable <ref> [Jones 90, Weide 95] </ref>. Otherwise, the relational nature of the correspondence mapping could merely arise from the sloppiness of the conceptual specification. We use as a sample such a well-designed, fully abstract specification. 3 (3) The sample specification must be of a sort that arises in practical areas. <p> This would be undesirable when, as in this case, the natural intended behavior is inherently relational. Refusing to admit this possibility would leave a class of useful concepts that could not be specified or that could not be easily reused in building other component implementations <ref> [Ernst 94, Jones 90, Leavens 91] </ref>. Moreover, specifying functional behavior for the MSF problem would rule out interesting classes of implementations and would make the specification much harder to understand that specification would have to single out precisely which MSF must be produced, even in case of ties. <p> A third approach involves changing the specifications. This has been considered both in the ADT framework <ref> [Jones 90] </ref> and in related work [Ehrich 90] on concurrent processes involving I/O automata and sequences of actions. Lynch documents the practical utility of multivalued possibilities mappings (the I/O automata counterpart of abstraction relations) [Lynch 90].
Reference: [Leavens 91] <author> Leavens, G., </author> <title> Modular Specification and Verification of ObjectOriented Programs, </title> <booktitle> IEEE Software 8, </booktitle> <month> 4 (July </month> <year> 1991), </year> <pages> pp. 72-80. </pages>
Reference-contexts: Previous work involving modular verification of ADTs leaves the role of abstraction relations unsettled. Leavens notes the value of simulation relations (essentially abstraction relations) in defining behavioral subtyping <ref> [Leavens 91] </ref>. In their corrigendum to an earlier paper [Liskov 93], Liskov and Wing acknowledge the possible merit of abstraction relations for this purpose. However, they conjecture [Liskov 94, p. 4] that for most practical purposes, abstraction functions are adequate (compared to relations). <p> This would be undesirable when, as in this case, the natural intended behavior is inherently relational. Refusing to admit this possibility would leave a class of useful concepts that could not be specified or that could not be easily reused in building other component implementations <ref> [Ernst 94, Jones 90, Leavens 91] </ref>. Moreover, specifying functional behavior for the MSF problem would rule out interesting classes of implementations and would make the specification much harder to understand that specification would have to single out precisely which MSF must be produced, even in case of ties.
Reference: [Liskov 93] <author> Liskov, B., and Wing, J.M., </author> <title> A New Definition of the Subtype Relation, </title> <booktitle> in ECOOP 1993 Lecture Notes in Computer Science 707, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1993, </year> <pages> pp. 118-141. </pages>
Reference-contexts: Previous work involving modular verification of ADTs leaves the role of abstraction relations unsettled. Leavens notes the value of simulation relations (essentially abstraction relations) in defining behavioral subtyping [Leavens 91]. In their corrigendum to an earlier paper <ref> [Liskov 93] </ref>, Liskov and Wing acknowledge the possible merit of abstraction relations for this purpose. However, they conjecture [Liskov 94, p. 4] that for most practical purposes, abstraction functions are adequate (compared to relations).
Reference: [Liskov 94] <author> Liskov, B., and Wing, J.M., </author> <title> Corrigenda to ECOOP 93 Paper, </title> <journal> ACM SIGPLAN Notices 29, </journal> <month> 4 (April </month> <year> 1994), </year> <note> p. 4. </note>
Reference-contexts: Leavens notes the value of simulation relations (essentially abstraction relations) in defining behavioral subtyping [Leavens 91]. In their corrigendum to an earlier paper [Liskov 93], Liskov and Wing acknowledge the possible merit of abstraction relations for this purpose. However, they conjecture <ref> [Liskov 94, p. 4] </ref> that for most practical purposes, abstraction functions are adequate (compared to relations).
Reference: [Lynch 90] <author> Lynch, N., </author> <title> Multivalued Possibilities Mappings, </title> <booktitle> in Stepwise Refinement of Distributed SystemsLecture Notes in Computer Science 430, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990, </year> <pages> pp. 519-543. </pages>
Reference-contexts: This has been considered both in the ADT framework [Jones 90] and in related work [Ehrich 90] on concurrent processes involving I/O automata and sequences of actions. Lynch documents the practical utility of multivalued possibilities mappings (the I/O automata counterpart of abstraction relations) <ref> [Lynch 90] </ref>. However, Abadi and Lamport show that specifications can be transformed to avoid multivalued mappings, under certain conditions; refinement mappings (the counterpart of abstraction functions) always exist [Abadi 91].
Reference: [Nelson 89] <author> Nelson, G., </author> <title> A Generalization of Dijkstras Calculus, </title> <journal> ACM Trans. on Prog. Lang. and Systems 11, </journal> <month> 4 (October </month> <year> 1989), </year> <pages> pp. 517-561. 19 </pages>
Reference-contexts: Details are provided in Appendix B. The need for a relational programming language semantics ultimately cannot be avoided if specifications are allowed to be relational which they must be in order to permit specification of behavior such as that desired for Spanning_Forest_Machine_Template <ref> [Nelson 89, Ernst 94] </ref>. Given that a relational semantics is essential, abstraction relations between concrete and abstract values do not increase verification complexity. In fact, in some cases their use (even when not technically required) can simplify verification conditions.
Reference: [Sitaraman 93] <author> Sitaraman, M., Welch, </author> <title> L.R., and Harms, D.E., On Specification of Reusable Software Components, </title> <journal> Intl. J. of Software Eng. and Knowledge Eng. </journal> <volume> 3, </volume> <month> 2 (June </month> <year> 1993), </year> <pages> pp. 207-219. </pages>
Reference-contexts: Furthermore, if one must change specifications for the sake of avoiding abstraction relations in correctness proofs without regard for the impact on understandability to potential component clients <ref> [Sitaraman 93, Wing 90] </ref> then some of the most important software engineering benefits of formal specification may be lost. One contribution of this paper is in noticing that the separation of what computations take place from when they take place leads to the need for abstraction relations in some cases.
Reference: [Sitaraman 94] <author> Sitaraman, M., and Weide, B.W., </author> <title> Special Feature: Component-Based Software Using RESOLVE, </title> <journal> ACM SIGSOFT Software Eng. </journal> <note> Notes 19, </note> <month> 4 (October </month> <year> 1994), </year> <pages> pp. 21-67. </pages>
Reference-contexts: Figure 2 is a reproduction of this specification, as expressed in the model-based specification language RESOLVE <ref> [Sitaraman 94] </ref>. 1 Note, however, that the specification language does not affect the issues discussed in this paper. Any model-based formal specification language [Wing 90] would suffice.
Reference: [Sitaraman 95] <author> Sitaraman, M., </author> <title> Impact of Implementation Considerations on Formal Specification Design, </title> <type> tech. report, </type> <institution> Dept. of Statistics and Computer Science, West Virginia Univ., Morgantown, </institution> <year> 1995. </year>
Reference-contexts: One contribution of this paper is in noticing that the separation of what computations take place from when they take place leads to the need for abstraction relations in some cases. So even if a specification of Spanning_Forest_Machine_Template is devised that avoids the need for abstraction relations <ref> [Sitaraman 95] </ref>, the completeness issue raised in this paper remains. If a specification language permits expression of the specification in in order for the proof system to be considered relatively complete.
Reference: [Weide 94] <author> Weide, B.W., Ogden, W.F., and Sitaraman, M., </author> <title> Recasting Algorithms to Encourage Reuse, </title> <booktitle> IEEE Software 11, </booktitle> <month> 5 (September </month> <year> 1994), </year> <pages> pp. 80-88. </pages>
Reference-contexts: As a sample relational problem specification we use the Spanning_Forest_-Machine_Template from our recent paper on recasting algorithms as objects, since the design rationale and specification are readily available <ref> [Weide 94] </ref>. This specification exhibits the relational behavior we seek because it requires that some minimum spanning forest (MSF) of a given graph must be found; there might be ties and any best answer is acceptable. <p> This operation requires that m be in the extraction phase at the time of the call. 1 A summary of RESOLVE specification notations essential for understanding this paper is given in Appendix A. There are a few minor changes in this specification from the one in <ref> [Weide 94] </ref> to reflect current RESOLVE syntax. The one substantive change is that the Size operation now has a precondition: it cannot be called during the insertion phase (but there is no reason to do so in any case). <p> Giving a component implementer such freedom both in how and in when to do computations (and the performance flexibility of various kinds of cost amortization) is part of the rationale for the recasting technique illustrated by this specification <ref> [Weide 94] </ref>. 5 concept Spanning_Forest_Machine_Template context global context facility Standard_Boolean_Facility facility Standard_Integer_Facility parametric context constant max_vertex: Integer restriction max_vertex &gt; 0 local context math subtype EDGE is ( v1: integer v2: integer w: integer ) exemplar e constraint 1 &lt;= e.v1 &lt;= max_vertex and 1 &lt;= e.v2 &lt;= max_vertex and e.w <p> The abstraction relation problem arises here because an optimization problem with possible ties has been captured not as a single procedure, but by recasting it as an ADT. In light of the advantages of the recasting approach <ref> [Weide 94] </ref>, the abstraction relation issue assumes additional significance. We have argued that there is no reason to avoid abstraction relations. But historically, abstraction functions have been so important and they are so entrenched that the generalization to abstraction relations has met with some 15 resistance. <p> Then for an implementation that mirrors this specification temporally, i.e., for a batch-style one that computes an MSF in Change_To_Extraction_Phase, an abstraction function is sufficient for a proof of correctness. The amortized-cost implementation in <ref> [Weide 94] </ref> (and implementations that defer computation of an MSF to the Extract operation), however, still requires an abstraction relation.
Reference: [Weide 95] <author> Weide, B.W., Edwards, S.H., Heym, W.D., Long, T.J., and Ogden, W.F., </author> <title> Characterizing Observability and Controllability of Software Components, </title> <type> tech. report OSU-CISRC-9/95-TR37, </type> <institution> Dept. of Computer and Information Science, The Ohio State Univ., Columbus, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: In particular, it must be fully abstract; i.e., every two different conceptual values of the abstract data type being defined must be computationally distinguishable <ref> [Jones 90, Weide 95] </ref>. Otherwise, the relational nature of the correspondence mapping could merely arise from the sloppiness of the conceptual specification. We use as a sample such a well-designed, fully abstract specification. 3 (3) The sample specification must be of a sort that arises in practical areas.
Reference: [Wing 90] <author> Wing, J.M., </author> <title> A Specifiers Introduction to Formal Methods, </title> <booktitle> Computer 23, </booktitle> <month> 9 (September </month> <year> 1990), </year> <pages> pp. 8-24. 20 </pages>
Reference-contexts: Figure 2 is a reproduction of this specification, as expressed in the model-based specification language RESOLVE [Sitaraman 94]. 1 Note, however, that the specification language does not affect the issues discussed in this paper. Any model-based formal specification language <ref> [Wing 90] </ref> would suffice. <p> Furthermore, if one must change specifications for the sake of avoiding abstraction relations in correctness proofs without regard for the impact on understandability to potential component clients <ref> [Sitaraman 93, Wing 90] </ref> then some of the most important software engineering benefits of formal specification may be lost. One contribution of this paper is in noticing that the separation of what computations take place from when they take place leads to the need for abstraction relations in some cases.
References-found: 20

