URL: http://www.research.microsoft.com/~hoppe/efficientpm.ps.gz
Refering-URL: http://www.research.microsoft.com/~hoppe/
Root-URL: http://www.research.microsoft.com
Title: Efficient Implementation of Progressive Meshes  
Author: Hugues Hoppe 
Address: One Microsoft Way Redmond, WA 98052  
Affiliation: Microsoft Research Microsoft Corporation  
Date: January 1998  
Abstract: Technical Report MSR-TR-98-02 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Apple Computer, Inc. </author> <title> 3D graphics programming with QuickDraw 3D. </title> <publisher> Addison Wesley, </publisher> <year> 1995. </year>
Reference-contexts: In simple cases, these scalar attributes are associated with vertices of the mesh. However, to represent discontinuities in the scalar fields, and because adjacent faces may have different shading functions, it is necessary to associate scalar attributes not with vertices, but with corners of the mesh <ref> [1] </ref>. A corner is defined as a (vertex,face) tuple. Scalar attributes at a corner (v; f ) specify the shading parameters for face f at vertex v. <p> This function nextA () behaves just like PMeshIter::next (), except that it tracks the ancestral attributes of vertices and wedges using the Ancestry structure shown in Figure 14. Once the PMeshIter has been advanced to M , the current vertex and wedge attributes of PMeshIter::Mesh are copied to vattribs <ref> [1] </ref> and wattribs [1], and the ancestral attributes in Ancestry are copied to vattribs [0] and wattribs [0]. In our current implementation, the creation of a geomorph requires approximately twice as much time as simple iteration through the PM sequence. <p> Once the PMeshIter has been advanced to M , the current vertex and wedge attributes of PMeshIter::Mesh are copied to vattribs <ref> [1] </ref> and wattribs [1], and the ancestral attributes in Ancestry are copied to vattribs [0] and wattribs [0]. In our current implementation, the creation of a geomorph requires approximately twice as much time as simple iteration through the PM sequence.
Reference: [2] <author> Clark, J. </author> <title> Hierarchical geometric models for visible surface algorithms. </title> <journal> Communications of the ACM 19, </journal> <month> 10 (October </month> <year> 1976), </year> <pages> 547-554. </pages>
Reference-contexts: One approach to speed up rendering is to replace a complex mesh by a set of level-of-detail (LOD) approximations; a detailed mesh is used when the object is close to the viewer, and coarser approximations are substituted as the object recedes <ref> [2, 4] </ref>. These LOD approximations can be precomputed automatically using mesh simplification methods (e.g. [5, 8, 9, 10, 11, 12]). For efficient storage and transmission, mesh compression schemes [3, 13] have also been developed. <p> One key element that makes this possible is that all changes to mesh attributes are recorded as deltas, so that they can be applied both forwards and backwards. The edge collapse works in the reverse order of the vertex split struct Geomorph : public Mesh f Array&lt;VertexAttrib&gt; vattribs <ref> [2] </ref>; Array&lt;WedgeAttrib&gt; wattribs [2]; enum Type f WANT NVERTICES, WANT NFACES g; Geomorph (PMeshIter&, Type, int); void evaluate (float); // takes parameter 0 ff 1 g; struct Ancestry f Array&lt;VertexAttrib&gt; anc vattribs; Array&lt;WedgeAttrib&gt; anc wattribs; g; PMeshIter::vertices and PMeshIter::wedges during geomorph construction. transformation. <p> The edge collapse works in the reverse order of the vertex split struct Geomorph : public Mesh f Array&lt;VertexAttrib&gt; vattribs <ref> [2] </ref>; Array&lt;WedgeAttrib&gt; wattribs [2]; enum Type f WANT NVERTICES, WANT NFACES g; Geomorph (PMeshIter&, Type, int); void evaluate (float); // takes parameter 0 ff 1 g; struct Ancestry f Array&lt;VertexAttrib&gt; anc vattribs; Array&lt;WedgeAttrib&gt; anc wattribs; g; PMeshIter::vertices and PMeshIter::wedges during geomorph construction. transformation.
Reference: [3] <author> Deering, M. </author> <title> Geometry compression. </title> <booktitle> Computer Graphics (SIGGRAPH '95 Proceedings) (1995), </booktitle> <pages> 13-20. </pages>
Reference-contexts: These LOD approximations can be precomputed automatically using mesh simplification methods (e.g. [5, 8, 9, 10, 11, 12]). For efficient storage and transmission, mesh compression schemes <ref> [3, 13] </ref> have also been developed. In earlier work [6], we introduced the progressive mesh (PM) representation, a new mesh format that provides a unified solution to these problems. <p> at a wedge/corner Vector normal; // (n x ; n y ; n z ) normal vector UV uv; // (u; v) texture coordinates g; struct Vertex f VertexAttrib attrib; g; struct Wedge f int vertex; // vertex to which wedge belongs WedgeAttrib attrib; g; struct Face f int wedges <ref> [3] </ref>; // wedges at corners of the face int fnei [3]; // 3 face neighbors short matid; // material identifier g; struct Mesh f Array&lt;Vertex&gt; vertices; Array&lt;Wedge&gt; wedges; Array&lt;Face&gt; faces; Array&lt;Material&gt; materials; g; struct PMesh f Mesh base mesh; // base mesh M 0 Array&lt;Vsplit&gt; vsplits; // fvsplit 0 ; : <p> y ; n z ) normal vector UV uv; // (u; v) texture coordinates g; struct Vertex f VertexAttrib attrib; g; struct Wedge f int vertex; // vertex to which wedge belongs WedgeAttrib attrib; g; struct Face f int wedges <ref> [3] </ref>; // wedges at corners of the face int fnei [3]; // 3 face neighbors short matid; // material identifier g; struct Mesh f Array&lt;Vertex&gt; vertices; Array&lt;Wedge&gt; wedges; Array&lt;Face&gt; faces; Array&lt;Material&gt; materials; g; struct PMesh f Mesh base mesh; // base mesh M 0 Array&lt;Vsplit&gt; vsplits; // fvsplit 0 ; : : : ; vsplit n1 g int full nvertices; // <p> To make the comparison fair, we omitted the Face::fnei <ref> [3] </ref> field when computing the memory required for Mesh, since face adjacency information is unnecessary for rendering static models. All coordinates (for points, normals, and texture) are represented as 32-bit floating-point numbers; integers are 32-bit, and shorts are 16-bit. <p> Second, PMesh uses deltas to encode mesh attributes (positions, normals, and texture coordinates). These relative deltas compress better since they tend to be smaller in magnitude than the absolute values. When using arithmetic coding, we use variable-length delta encoding as described in <ref> [3, 6] </ref>. Table 3 shows how many bits are required on average to encode each field of the Vsplit records using arithmetic coding and variable length delta encoding. As noted in the table, only one of our test meshes had non-zero texture coordinates.
Reference: [4] <author> Funkhouser, T., and S equin, C. </author> <title> Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments. </title> <booktitle> Computer Graphics (SIGGRAPH '93 Proceedings) (1993), </booktitle> <pages> 247-254. </pages>
Reference-contexts: One approach to speed up rendering is to replace a complex mesh by a set of level-of-detail (LOD) approximations; a detailed mesh is used when the object is close to the viewer, and coarser approximations are substituted as the object recedes <ref> [2, 4] </ref>. These LOD approximations can be precomputed automatically using mesh simplification methods (e.g. [5, 8, 9, 10, 11, 12]). For efficient storage and transmission, mesh compression schemes [3, 13] have also been developed.
Reference: [5] <author> Garland, M., and Heckbert, P. </author> <title> Surface simplification using quadric error metrics. </title> <booktitle> Computer Graphics (SIGGRAPH '97 Proceedings) (1997). </booktitle>
Reference-contexts: These LOD approximations can be precomputed automatically using mesh simplification methods (e.g. <ref> [5, 8, 9, 10, 11, 12] </ref>). For efficient storage and transmission, mesh compression schemes [3, 13] have also been developed. In earlier work [6], we introduced the progressive mesh (PM) representation, a new mesh format that provides a unified solution to these problems.
Reference: [6] <author> Hoppe, H. </author> <title> Progressive meshes. </title> <booktitle> Computer Graphics (SIG-GRAPH '96 Proceedings) (1996), </booktitle> <pages> 99-108. </pages>
Reference-contexts: These LOD approximations can be precomputed automatically using mesh simplification methods (e.g. [5, 8, 9, 10, 11, 12]). For efficient storage and transmission, mesh compression schemes [3, 13] have also been developed. In earlier work <ref> [6] </ref>, we introduced the progressive mesh (PM) representation, a new mesh format that provides a unified solution to these problems. <p> In addition to defining a continuous sequence of approximations M 0 : : : M n , the PM representation supports smooth visual Email: hhoppe@microsoft.com Web: http://research.microsoft.com/~hoppe/ transitions (geomorphs) between these approximations, allows progressive transmission, and makes an effective mesh compression scheme. Since the original paper <ref> [6] </ref>, we have developed data structures and algorithms allowing the efficient implementation of progressive meshes. In this paper, we detail these data structures and algorithms, and present quantitative results on their performance. The remainder of the paper is organized as follows. We first review the PM representation in Section 2. <p> Section 4 describes the process of traversing the levels of detail within a progressive mesh. Section 5 discusses the creation of geomorphs, Section 6 addresses the issue of compression, and Section 7 summarizes the paper. 2 REVIEW OF PROGRESSIVE MESHES To construct a PM representation <ref> [6] </ref>, an arbitrary triangle mesh ^ M is simplified through a sequence of n edge collapse transformations (ecol in Figure 1) to yield a much simpler base mesh M 0 (see ( ^ M = M ) ecol n1 ! : : : ecol 1 ! M 1 ecol 0 ! <p> a much simpler base mesh M 0 (see ( ^ M = M ) ecol n1 ! : : : ecol 1 ! M 1 ecol 0 ! M : The sequence of ecol transformations is chosen by an optimization process that seeks to preserve the appearance of the model <ref> [6] </ref>. <p> Second, PMesh uses deltas to encode mesh attributes (positions, normals, and texture coordinates). These relative deltas compress better since they tend to be smaller in magnitude than the absolute values. When using arithmetic coding, we use variable-length delta encoding as described in <ref> [3, 6] </ref>. Table 3 shows how many bits are required on average to encode each field of the Vsplit records using arithmetic coding and variable length delta encoding. As noted in the table, only one of our test meshes had non-zero texture coordinates.
Reference: [7] <author> Hoppe, H. </author> <title> View-dependent refinement of progressive meshes. </title> <booktitle> Computer Graphics (SIGGRAPH '97 Proceedings) (1997). </booktitle>
Reference-contexts: The vertex split transformations can be reordered as long as they preserve some dependency conditions <ref> [7, 16] </ref>. We encode these conditions by constructing a dependency graph. We then iteratively select vertex split transformations among the set of legal candidates, and use the dependency graph to update the candidate set.
Reference: [8] <author> Hoppe, H., DeRose, T., Duchamp, T., McDonald, J., and Stuetzle, W. </author> <title> Mesh optimization. </title> <booktitle> Computer Graphics (SIGGRAPH '93 Proceedings) (1993), </booktitle> <pages> 19-26. </pages>
Reference-contexts: These LOD approximations can be precomputed automatically using mesh simplification methods (e.g. <ref> [5, 8, 9, 10, 11, 12] </ref>). For efficient storage and transmission, mesh compression schemes [3, 13] have also been developed. In earlier work [6], we introduced the progressive mesh (PM) representation, a new mesh format that provides a unified solution to these problems.
Reference: [9] <author> Ronfard, R., and Rossignac, J. </author> <title> Full-range approximation of triangulated polyhedra. </title> <booktitle> Computer Graphics Forum (Proceedings of Eurographics '96) 15, 3 (1996), </booktitle> <pages> 67-76. </pages>
Reference-contexts: These LOD approximations can be precomputed automatically using mesh simplification methods (e.g. <ref> [5, 8, 9, 10, 11, 12] </ref>). For efficient storage and transmission, mesh compression schemes [3, 13] have also been developed. In earlier work [6], we introduced the progressive mesh (PM) representation, a new mesh format that provides a unified solution to these problems.
Reference: [10] <author> Rossignac, J., and Borrel, P. </author> <title> Multi-resolution 3D approximations for rendering complex scenes. In Modeling in Computer Graphics, </title> <editor> B. Falcidieno and T. L. Kunii, Eds. </editor> <publisher> Springer-Verlag, </publisher> <year> 1993, </year> <pages> pp. 455-465. </pages>
Reference-contexts: These LOD approximations can be precomputed automatically using mesh simplification methods (e.g. <ref> [5, 8, 9, 10, 11, 12] </ref>). For efficient storage and transmission, mesh compression schemes [3, 13] have also been developed. In earlier work [6], we introduced the progressive mesh (PM) representation, a new mesh format that provides a unified solution to these problems.
Reference: [11] <author> Schaufler, G., and St urzlinger, W. </author> <title> Generating multiple levels of detail from polygonal geometry models. In Virtual Environments '95 (Eurographics Workshop) (January 1995), </title> <editor> M. G obel, Ed., </editor> <publisher> Springer Verlag, </publisher> <pages> pp. 33-41. </pages>
Reference-contexts: These LOD approximations can be precomputed automatically using mesh simplification methods (e.g. <ref> [5, 8, 9, 10, 11, 12] </ref>). For efficient storage and transmission, mesh compression schemes [3, 13] have also been developed. In earlier work [6], we introduced the progressive mesh (PM) representation, a new mesh format that provides a unified solution to these problems.
Reference: [12] <author> Schroeder, W., Zarge, J., and Lorensen, W. </author> <title> Decimation of triangle meshes. </title> <booktitle> Computer Graphics (SIGGRAPH '92 Proceedings) 26, 2 (1992), </booktitle> <pages> 65-70. </pages>
Reference-contexts: These LOD approximations can be precomputed automatically using mesh simplification methods (e.g. <ref> [5, 8, 9, 10, 11, 12] </ref>). For efficient storage and transmission, mesh compression schemes [3, 13] have also been developed. In earlier work [6], we introduced the progressive mesh (PM) representation, a new mesh format that provides a unified solution to these problems.
Reference: [13] <author> Taubin, G., and Rossignac, J. </author> <title> Geometry compression through topological surgery. </title> <institution> Research Report RC-20340, IBM, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: These LOD approximations can be precomputed automatically using mesh simplification methods (e.g. [5, 8, 9, 10, 11, 12]). For efficient storage and transmission, mesh compression schemes <ref> [3, 13] </ref> have also been developed. In earlier work [6], we introduced the progressive mesh (PM) representation, a new mesh format that provides a unified solution to these problems.
Reference: [14] <author> Upstill, S. </author> <title> The RenderMan Companion. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Discrete attributes are usually associated with faces of the mesh. A common discrete attribute, the material identifier, determines the shader function used in rendering each face of the mesh <ref> [14] </ref>. For instance, a trivial shader function may involve simple look-up within a specified texture map. Many scalar attributes are often associated with a mesh, including normals (n x ; n y ; n z ) and texture coordinates (u; v).
Reference: [15] <author> Witten, I., Neal, R., and Cleary, J. </author> <title> Arithmetic coding for data compression. </title> <journal> Communications of the ACM 30, </journal> <month> 6 (June </month> <year> 1987), </year> <pages> 520-540. </pages>
Reference-contexts: The compression is therefore lossy, but these quantization levels seldom result in significant visual artifacts. The first compression scheme, labeled gzip in Table 2, applies Lempel-Ziv coding [17] to the binary data structures, as implemented by GNU gzip. The second scheme, labeled arith., performs arith metic coding <ref> [15] </ref>, where the coding probability distributions are optimized on a per-mesh basis. As shown in Table 2, PMesh compresses significantly better than Mesh. There are two main reasons for this. First, the Face!Wedge!Vertex incidences are more concisely represented in PMesh than in Mesh.
Reference: [16] <author> Xia, J., and Varshney, A. </author> <title> Dynamic view-dependent simplification for polygonal models. </title> <booktitle> In Visualization '96 Proceedings (1996), IEEE, </booktitle> <pages> pp. 327-334. </pages>
Reference-contexts: The vertex split transformations can be reordered as long as they preserve some dependency conditions <ref> [7, 16] </ref>. We encode these conditions by constructing a dependency graph. We then iteratively select vertex split transformations among the set of legal candidates, and use the dependency graph to update the candidate set.
Reference: [17] <author> Ziv, J., and Lempel, A. </author> <title> A universal algorithm for sequential data compression. </title> <journal> IEEE Transactions on Information Theory 23, </journal> <month> 3 (May </month> <year> 1977), </year> <month> 337-343. </month> <title> 13,546 faces; 500 KB 13,546 faces; 37 KB 2,000 faces; 7 KB 17,068 faces; 554 KB 17,068 faces; 68 KB 2,000 faces; 11 KB 1,036,260 faces; 33,147 KB 1,036,260 faces; 2,039 KB 25,000 faces; 78 KB meshes compressed as in Table 4 (PMesh compressed); the right column shows meshes obtained by truncating the original PM sequence and recompressing this approximation (also PMesh compressed). </title>
Reference-contexts: In both compression schemes, we quantize position coordinates to 16-bit, normal coordinates to 8-bit, and texture coordinates to 16-bit. The compression is therefore lossy, but these quantization levels seldom result in significant visual artifacts. The first compression scheme, labeled gzip in Table 2, applies Lempel-Ziv coding <ref> [17] </ref> to the binary data structures, as implemented by GNU gzip. The second scheme, labeled arith., performs arith metic coding [15], where the coding probability distributions are optimized on a per-mesh basis. As shown in Table 2, PMesh compresses significantly better than Mesh. There are two main reasons for this.
References-found: 17

