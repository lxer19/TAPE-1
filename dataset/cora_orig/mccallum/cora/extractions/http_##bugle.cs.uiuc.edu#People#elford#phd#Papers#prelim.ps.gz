URL: http://bugle.cs.uiuc.edu/People/elford/phd/Papers/prelim.ps.gz
Refering-URL: http://bugle.cs.uiuc.edu/People/elford/phd/
Root-URL: http://www.cs.uiuc.edu
Title: Optimizing Parallel Input/Output Using Adaptive File System Policies A Preliminary Examination Statement  
Author: Christopher L. Elford 
Address: 1304 West Springfield Avenue Urbana, Illinois 61801  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: Until recently, parallel system designers largely ignored optimization of parallel input/output as they struggled to provide parallelization tools, messaging libraries, and optimizing compilers needed to make parallel computing feasible. As processor performance continues to rapidly improve, input/output now accounts for a growing fraction of application execution time. In the last few years, there has been an explosion of research on techniques for optimizing parallel input/output and extending parallel file systems to support additional access interfaces. Our experience with parallel file systems and input/output characterization leads us to believe that parallel file systems should dynamically alter their caching, prefetching and write back policies to match the needs of parallel application input/output phases. We propose a closed loop optimization strategy that automatically monitors system input/output performance and refines file system policy parameters as bottlenecks become evident.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bennett, R., Bryant, K., Sussman, A., Das, R., and Saltz, J. Jovian: </author> <title> A Framework for Optimizing Parallel I/O. </title> <booktitle> In Proceedings of the Scalable Parallel Libraries Conference (October 1994), </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 10-20. </pages>
Reference-contexts: The underlying file system library can then modify the prefetch parameters and cache replacement priorities to optimize performance. Other experimental parallel input/output systems assume a fixed model of parallel input/output. These systems then implement performance optimizations for this fixed input/output model. Galley [35], Panda [42], PASSION [2] and Jovian <ref> [1] </ref> support external multi-dimensional arrays. These systems allow for efficient data distribution and access methods for accesses along each array dimension.
Reference: [2] <author> Bordawekar, R., Thakur, R., and Choudhary, A. </author> <title> Efficient Compilation of Out-of-core Data Parallel Programs. </title> <type> Tech. Rep. SCCS-622, </type> <institution> NPAC, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: The underlying file system library can then modify the prefetch parameters and cache replacement priorities to optimize performance. Other experimental parallel input/output systems assume a fixed model of parallel input/output. These systems then implement performance optimizations for this fixed input/output model. Galley [35], Panda [42], PASSION <ref> [2] </ref> and Jovian [1] support external multi-dimensional arrays. These systems allow for efficient data distribution and access methods for accesses along each array dimension. <p> Like the partitioned access pattern, this pattern is often used to generate and consume application checkpoints. This access pattern occurs in the ESCAT, QCRD, and PRISM applications described in Appendix B 4.1.5 Sequential Subfile Access Many parallel input/output systems such as PFS [24], PIOFS [25], Vesta [11], Passion <ref> [2] </ref>, and PPFS [21] implement files as sets of non-parallel files on underlying sequential file systems. The parallel file is then striped or otherwise distributed among these subfiles and a canonical ordering is defined to map the subfiles into a single logical parallel file.
Reference: [3] <author> Brogan, W. L. </author> <title> Modern Control Theory. </title> <publisher> Quantum Publishers Inc., </publisher> <year> 1974. </year>
Reference-contexts: We describe our input/output policy selector model in x6.2. Actuators: Actuators are system hooks which allow dynamic policy parameter choices to be invoked. We discuss these input/output actuators in x6.3. 5.2 Basic Control Theory Concepts Feedback control theory is a discipline that applies mathematical analysis to solve control problems <ref> [3, 7] </ref>. This subject allows rigorous mathematical modeling and design of feedback control systems. The complexity and tractability of the analysis is proportional to the complexity of the system being modeled. We use a few basic feedback control concepts throughout our proposal.
Reference: [4] <author> Corporation, I. B. M. </author> <title> Hypertext Information Base Library. </title> <institution> International Business Machines Corporation, Austin Texas, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: Using this infrastructure, one can track the utilization of processors, disks, memory and the messaging infrastructure. Similarly, the IBM SP/2 RS6000 nodes support kernel AIX tracing extensions that allow the user to dynamically monitor processor, memory, network and file activity <ref> [4] </ref>. In addition to system dependent debuggers and application trace support, there are several portable application monitoring and visualization utilities [26, 16, 50, 22]. These tools support a fixed set of possible instrumentable constructs such as procedure calls, message passing calls, and input/output requests.
Reference: [5] <author> Crandall, P., Aydt, R. A., Chien, A. A., and Reed, D. A. </author> <title> Input/Output Characterization of Scalable Parallel Applications. </title> <booktitle> In Proceedings of Supercomputing 1995 (1996), </booktitle> <pages> pp. </pages> <publisher> CD-ROM. </publisher>
Reference-contexts: Simple caching, prefetching, and write back policies are generally sufficient for these applications. Parallel and supercomputer input/output access patterns, on the other hand, have been classified via several taxonomies [31, 6, 27]. These taxonomies and parallel application characterization <ref> [5, 43] </ref> demonstrate the complex input/output resource requirements of parallel versus sequential application input/output. As part of the Scalable Input/Output Initiative (SIO), the Pablo group has characterized the input/output behavior of several such input/output intensive parallel applications. The SIO application suite is described in detail in Appendix B. <p> A modest sample execution of this 44 application can generate hundreds of megabytes of data. B.3 Hartree-Fock Calculations (HARTREE) This ab initio chemistry code is used to compute the bond strengths and reaction energies for chemical reactions on the Intel Paragon <ref> [5] </ref>. Several different techniques can be used to compute these energies. This implementation consists of three separate programs that cooperate to calculate the non-relativistic interactions between atomic nuclei and electrons using a self consistent field (SCF) technique until the molecular density converges.
Reference: [6] <author> Crockett, T. W. </author> <title> File Concepts for Parallel I/O. </title> <booktitle> In Proceedings of Supercomputing '89 (1989), </booktitle> <pages> pp. 574-579. </pages>
Reference-contexts: Sequential applications tend to exhibit very simple and predictable access patterns [36]. Simple caching, prefetching, and write back policies are generally sufficient for these applications. Parallel and supercomputer input/output access patterns, on the other hand, have been classified via several taxonomies <ref> [31, 6, 27] </ref>. These taxonomies and parallel application characterization [5, 43] demonstrate the complex input/output resource requirements of parallel versus sequential application input/output. As part of the Scalable Input/Output Initiative (SIO), the Pablo group has characterized the input/output behavior of several such input/output intensive parallel applications. <p> Several parallel input/output taxonomies have been defined <ref> [31, 6, 27] </ref>. These taxonomies sometimes attach a cause to input/output requests such as initialization, compulsory, checkpoint or out-of-core. In other cases, such as Crockett [6] and Kotz [27], parallel input/output characterization is given by the relative sizes and spacings of requests within a file. <p> Several parallel input/output taxonomies have been defined [31, 6, 27]. These taxonomies sometimes attach a cause to input/output requests such as initialization, compulsory, checkpoint or out-of-core. In other cases, such as Crockett <ref> [6] </ref> and Kotz [27], parallel input/output characterization is given by the relative sizes and spacings of requests within a file. In x4.1, we present a parallel access pattern taxonomy based on extant taxonomies and the SIO parallel input/output characterization effort.
Reference: [7] <author> Doyle, J. C., Francis, B. A., and Tannenbaum, A. R. </author> <title> Feedback Control Theory. </title> <publisher> Macmillan Publishing Company, </publisher> <year> 1992. </year>
Reference-contexts: We describe our input/output policy selector model in x6.2. Actuators: Actuators are system hooks which allow dynamic policy parameter choices to be invoked. We discuss these input/output actuators in x6.3. 5.2 Basic Control Theory Concepts Feedback control theory is a discipline that applies mathematical analysis to solve control problems <ref> [3, 7] </ref>. This subject allows rigorous mathematical modeling and design of feedback control systems. The complexity and tractability of the analysis is proportional to the complexity of the system being modeled. We use a few basic feedback control concepts throughout our proposal.
Reference: [8] <author> Elford, C. L., Kuszmaul, C., Huber, J., and Madhyastha, T. M. </author> <title> Design of a Portable Parallel File System. </title> <type> Tech. rep., </type> <institution> UIUC-CS, </institution> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: We invested substantial effort to design an extensible infrastructure for portable parallel input/output <ref> [8, 9, 10] </ref>. We adopted a client/server approach where some client nodes act as PPFS input/output servers which are accessed by application clients.
Reference: [9] <author> Elford, C. L., Kuszmaul, C., Huber, J., and Madhyastha, T. M. </author> <title> Portable Parallel File System Detailed Design. </title> <type> Tech. rep., </type> <institution> UIUC-CS, </institution> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: We invested substantial effort to design an extensible infrastructure for portable parallel input/output <ref> [8, 9, 10] </ref>. We adopted a client/server approach where some client nodes act as PPFS input/output servers which are accessed by application clients.
Reference: [10] <author> Elford, C. L., Kuszmaul, C., Huber, J., and Madhyastha, T. M. </author> <title> Scenarios for the Portable Parallel File System. </title> <type> Tech. rep., </type> <institution> UIUC-CS, </institution> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: We invested substantial effort to design an extensible infrastructure for portable parallel input/output <ref> [8, 9, 10] </ref>. We adopted a client/server approach where some client nodes act as PPFS input/output servers which are accessed by application clients.
Reference: [11] <author> Feitelson, D. G., Corbett, P. F., and Prost, J.-P. </author> <title> Performance of the Vesta Parallel File System. </title> <booktitle> In Proceedings of the Ninth International Parallel Processing Symposium (April 1995), </booktitle> <pages> pp. 150-158. </pages>
Reference-contexts: In contrast to commercial parallel file systems, the intuitiveness of the end user interface of these experimental systems is generally of secondary importance. Several companies and many university research programs work with experimental parallel input/output systems. IBM, for example, invested considerable resources to develop and optimize the Vesta <ref> [11] </ref> experimental parallel file system. 1 A host of university research groups develop and use experimental parallel input/output libraries. Many of these projects, such as [27] have used a combination of modeling, simulation, and experimental results to explore parallel input/output issues on a variety of platforms. <p> Like the partitioned access pattern, this pattern is often used to generate and consume application checkpoints. This access pattern occurs in the ESCAT, QCRD, and PRISM applications described in Appendix B 4.1.5 Sequential Subfile Access Many parallel input/output systems such as PFS [24], PIOFS [25], Vesta <ref> [11] </ref>, Passion [2], and PPFS [21] implement files as sets of non-parallel files on underlying sequential file systems. The parallel file is then striped or otherwise distributed among these subfiles and a canonical ordering is defined to map the subfiles into a single logical parallel file.
Reference: [12] <author> Foster, I., and Nieplocha, J. </author> <title> ChemIO: High-Performance I/O for Computational Chemistry Applications. </title> <note> WWW http://www.mcs.anl.gov/chemio/, February 1996. </note>
Reference-contexts: Implementations of this user interface can provide platform dependent optimizations. Unfortunately, these interfaces tend to provide little standardized support for converting files between different systems and application domains. As an example of these domain specific input/output libraries, ChemIO <ref> [12] </ref> is an API that allows the development of portable, high-performance computational chemistry codes without requiring the user to concentrate on making system dependent parallel input/output optimizations.
Reference: [13] <author> Gergeleit, M., Kaiser, J., and Streich, H. </author> <title> DIRECT: Towards a Distributed Object-Oriented Real-Time Control System. </title> <booktitle> In Workshop on Concurrent Object-based Systems (Oct. </booktitle> <year> 1994). </year>
Reference-contexts: then invoke the actuator to split this element onto different processors during the next iteration. 9 3.3.2 Automatic Steering In contrast to interactive steering environments, automatic steering environments do not require that the user be "in the control loop." 2 DIRECT, Falcon, and the Meta Toolkit provide automatic steering interfaces <ref> [13, 14, 33, 48] </ref>. DIRECT is representative of a class of automated steering infrastructures for real time applications such as power plant control and critical embedded systems.
Reference: [14] <author> Gheith, A., Mukherjee, B., Silva, D., and Schwan, K. KTK: </author> <title> Kernel Support for Configurable Objects and Invocations. </title> <type> Tech. Rep. </type> <institution> GIT-CC-94-11, College of Computing, Georgia Institute of Technology, </institution> <month> Feb. </month> <year> 1994. </year> <month> 46 </month>
Reference-contexts: then invoke the actuator to split this element onto different processors during the next iteration. 9 3.3.2 Automatic Steering In contrast to interactive steering environments, automatic steering environments do not require that the user be "in the control loop." 2 DIRECT, Falcon, and the Meta Toolkit provide automatic steering interfaces <ref> [13, 14, 33, 48] </ref>. DIRECT is representative of a class of automated steering infrastructures for real time applications such as power plant control and critical embedded systems.
Reference: [15] <author> Grimshaw, A. S., and Loyot, Jr., E. C. </author> <title> ELFS: Object-Oriented Extensible File Systems. </title> <booktitle> In Proceedings of the First International Conference on Parallel and Distributed Information Systems (December 1991), </booktitle> <address> p. </address> <month> 177. </month>
Reference-contexts: This reorganization can constrain both the choice of algorithm its scalability. We believe that instead of blind, system-wide optimizations, parallel file systems should adapt their policies to individual application resource requirements. Matching file system policies to application resource requirements has proven an effective technique for improving input/output performance <ref> [28, 15] </ref>. Each input/output utilization phase might have different optimal file system policies. In addition, running other applications concurrently may perturb the input/output performance of the first application requiring dynamic repartitioning of the input/output resources. <p> Some experimental parallel input/output systems seek to optimize low level performance within the file system code by selecting data distributions and policies based on user supplied or automatically detected hints. The ELFs system <ref> [15] </ref> defines an extensible set of file types that enable different interface methodologies and optimizations within the underlying file system. TIPs [38] allows the user to specify in advance files and file fragments that will be accessed.
Reference: [16] <author> Gropp, W., and Lusk, E. </author> <title> User's Guide for MPICH, a Portable Implementation of MPI. </title> <type> Tech. Rep. </type> <institution> ANL/MCS-TM-000, Argonne National Lab, </institution> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: Similarly, the IBM SP/2 RS6000 nodes support kernel AIX tracing extensions that allow the user to dynamically monitor processor, memory, network and file activity [4]. In addition to system dependent debuggers and application trace support, there are several portable application monitoring and visualization utilities <ref> [26, 16, 50, 22] </ref>. These tools support a fixed set of possible instrumentable constructs such as procedure calls, message passing calls, and input/output requests. In contrast, Pablo [40] and Paradyn [30] provide an extensible set of instrumentable constructs.
Reference: [17] <author> Gu, W., Eisenhauer, G., Kraemer, E., Schwan, K., Stasko, J., and Vetter, J. </author> <title> Falcon: On-Line Monitoring and Steering of Large-Scale Parallel Programs. </title> <type> Tech. Rep. </type> <institution> GIT-CC-94-21, College of Computing, Georgia Institute of Technology, </institution> <year> 1994. </year>
Reference-contexts: Using a basic feedback system, the Falcon project has produced a general model of computational steering that combines a general set of on-line monitoring options, a "black box" steering selector, and several different classes of steering actions <ref> [46, 18, 17] </ref>. SciChem [37] is another representative example of an interactive steering infrastructure. Interactive steering systems contain three basic components. First, they provide actuators that allow algorithms, system or application parameters to be changed on the fly.
Reference: [18] <author> Gu, W., Vetter, J., and Schwan, K. </author> <title> An Annotated Bibliography of Interactive Program Steering. </title> <type> Tech. Rep. </type> <institution> GIT-CC-94-15, College of Computing, Georgia Institute of Technology, </institution> <year> 1994. </year>
Reference-contexts: Using a basic feedback system, the Falcon project has produced a general model of computational steering that combines a general set of on-line monitoring options, a "black box" steering selector, and several different classes of steering actions <ref> [46, 18, 17] </ref>. SciChem [37] is another representative example of an interactive steering infrastructure. Interactive steering systems contain three basic components. First, they provide actuators that allow algorithms, system or application parameters to be changed on the fly.
Reference: [19] <author> Henderson, R. D., and Karniadakis, G. E. </author> <title> Unstructured Spectral Element Methods for Simulation of Turbulent Flows. </title> <journal> Journal of Computational Physics 122(2) (1995), </journal> <pages> 191-217. </pages>
Reference-contexts: The integrals may be read several times to solve slightly different linear systems. B.2 Incompressible Navier-Stokes (PRISM) This application performs a 3-D numerical simulation of the Navier-Stokes equations for periodic fluid flow <ref> [19] </ref> such as flow past a cylinder or over a step. This application calculates the dynamics of turbulent flow subject to initial velocity conditions and a set of constraints. For each time step, numerical integration is used to solve the advection and momentum diffusion of the fluid.
Reference: [20] <author> Huber, J. V. </author> <title> PPFS An Experimental File System for High Performance Parallel Input/Output. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: This work builds on the Pablo performance instrumentation and analysis infrastructure [40], the Portable Parallel File System (PPFS) user level file system policy testbed <ref> [20, 21] </ref> discussed in Appendix A, and the Scalable Input/Output Initiative (SIO) parallel input/output characterization and optimization effort [39]. In x2, we formally discuss the proposed research area. We describe related projects and research in x3.
Reference: [21] <author> Huber, J. V., Elford, C. L., Reed, D. A., Chien, A. A., and Blumenthal, D. S. </author> <title> PPFS: A High-Performance Portable Parallel File System. </title> <booktitle> In Proceedings of the 9th ACM International Conference on Supercomputing (July 1995), </booktitle> <pages> pp. 385-394. </pages>
Reference-contexts: This work builds on the Pablo performance instrumentation and analysis infrastructure [40], the Portable Parallel File System (PPFS) user level file system policy testbed <ref> [20, 21] </ref> discussed in Appendix A, and the Scalable Input/Output Initiative (SIO) parallel input/output characterization and optimization effort [39]. In x2, we formally discuss the proposed research area. We describe related projects and research in x3. <p> As described in x6.2.2, policy selectors can be created and calibrated by exploring assorted file system policy parameters using access pattern benchmarks. We have prototyped our performance optimization infrastructure using PPFS, a user level portable parallel file system that provides dynamically configurable caching, prefetching and write behind policies <ref> [21] </ref>. We have instrumented the PPFS with an extended version of the Pablo performance instrumentation library to provide performance sensors [40, 41]. <p> This access pattern occurs in the ESCAT, QCRD, and PRISM applications described in Appendix B 4.1.5 Sequential Subfile Access Many parallel input/output systems such as PFS [24], PIOFS [25], Vesta [11], Passion [2], and PPFS <ref> [21] </ref> implement files as sets of non-parallel files on underlying sequential file systems. The parallel file is then striped or otherwise distributed among these subfiles and a canonical ordering is defined to map the subfiles into a single logical parallel file. <p> Similar performance improvements are also evident on the IBM SP/2. 11 The results in Table 8 are representative of the performance improvements that are possible by configuring PPFS policies for a variety of access patterns. In <ref> [21] </ref>, we present performance improvements for several scientific applications as well as the global sequential access pattern of x4.1.2. 6.6.2 Configuring Sensor Window Sizes read time sensor. <p> The user can also explicitly specify lists of records that should be prefetched. With this combination of data distribution, caching, write back, and prefetching controls, we have managed to dramatically improve the input/output performance of several benchmarks and real applications on the Intel Paragon relative to PFS performance <ref> [21] </ref>.
Reference: [22] <author> Intel Corporation. </author> <title> Paragon System Application Tools User's Guide. </title> <publisher> Intel SSD, </publisher> <address> Beaverton, OR, </address> <year> 1995. </year>
Reference-contexts: Similarly, the IBM SP/2 RS6000 nodes support kernel AIX tracing extensions that allow the user to dynamically monitor processor, memory, network and file activity [4]. In addition to system dependent debuggers and application trace support, there are several portable application monitoring and visualization utilities <ref> [26, 16, 50, 22] </ref>. These tools support a fixed set of possible instrumentable constructs such as procedure calls, message passing calls, and input/output requests. In contrast, Pablo [40] and Paradyn [30] provide an extensible set of instrumentable constructs.
Reference: [23] <author> Intel Corporation. </author> <title> Paragon System Performance Visualiation Tool User's Guide. </title> <publisher> Intel SSD, </publisher> <address> Beaverton, OR, </address> <year> 1995. </year>
Reference-contexts: The Intel Paragon supports a trace and monitor (TAM) extension that can run on each node of the parallel application. The TAM daemon collects local data and dynamically forwards it to remote visualization or analysis environments such as Intel's system performance visualization tool (SPV) <ref> [23] </ref>. In addition, the operating system supports ioctl () hooks for polling and clearing operating system event counters. Using this infrastructure, one can track the utilization of processors, disks, memory and the messaging infrastructure.
Reference: [24] <author> Intel Corporation. </author> <title> Paragon System User's Guide. </title> <publisher> Intel SSD, </publisher> <address> Beaverton, OR, </address> <year> 1995. </year>
Reference-contexts: A cautious/reckless mode switch allows users to specify cache consistency requirements. Intel's PFS <ref> [24] </ref>, on the other hand, provides a series of ioctl () calls to specify the striping unit and the number of disks to use. PFS supports a series of input/output modes that enable different types of prefetching and request aggregation. <p> Like the partitioned access pattern, this pattern is often used to generate and consume application checkpoints. This access pattern occurs in the ESCAT, QCRD, and PRISM applications described in Appendix B 4.1.5 Sequential Subfile Access Many parallel input/output systems such as PFS <ref> [24] </ref>, PIOFS [25], Vesta [11], Passion [2], and PPFS [21] implement files as sets of non-parallel files on underlying sequential file systems. The parallel file is then striped or otherwise distributed among these subfiles and a canonical ordering is defined to map the subfiles into a single logical parallel file.
Reference: [25] <author> King, S. M. Installing, </author> <title> Managing, and Using the IBM AIX Parallel I/O File System. </title> <institution> Information Development Department, IBM Kingston, </institution> <address> New York, </address> <year> 1994. </year>
Reference-contexts: In this proposal, we concentrate on the parallel file systems provided for the Intel Paragon and the IBM SP/2; our primary experimentation platforms. Most commercial parallel file systems offer some user control over data distribution and cache consistency. IBM's PIOFS <ref> [25] </ref> allows users to specify the number of cells or logical disks to use for a file, as well as a sophisticated technique for partitioning data among these logical cells so that more than simple data striping can be achieved. <p> These systems allow for efficient data distribution and access methods for accesses along each array dimension. These array based systems can reorder 1 Based on this design and what IBM learned from Vesta, they developed PIOFS for the IBM SP <ref> [25] </ref>. 7 disk data distributions and aggregate collective input/output requests to more effectively utilize disk bandwidth. In addition to providing a user level API, PASSION is also used as a compiler target for compile time input/output optimization. <p> Like the partitioned access pattern, this pattern is often used to generate and consume application checkpoints. This access pattern occurs in the ESCAT, QCRD, and PRISM applications described in Appendix B 4.1.5 Sequential Subfile Access Many parallel input/output systems such as PFS [24], PIOFS <ref> [25] </ref>, Vesta [11], Passion [2], and PPFS [21] implement files as sets of non-parallel files on underlying sequential file systems. The parallel file is then striped or otherwise distributed among these subfiles and a canonical ordering is defined to map the subfiles into a single logical parallel file.
Reference: [26] <author> Kohl, J. A., and Geist, G. A. </author> <title> The PVM 3.4 Tracing Facility and XPVM 1.1. </title> <institution> Oak Ridge National Lab, </institution> <note> Available at http://www.epm.ornl.gov/pvm/trace.ps. </note>
Reference-contexts: Similarly, the IBM SP/2 RS6000 nodes support kernel AIX tracing extensions that allow the user to dynamically monitor processor, memory, network and file activity [4]. In addition to system dependent debuggers and application trace support, there are several portable application monitoring and visualization utilities <ref> [26, 16, 50, 22] </ref>. These tools support a fixed set of possible instrumentable constructs such as procedure calls, message passing calls, and input/output requests. In contrast, Pablo [40] and Paradyn [30] provide an extensible set of instrumentable constructs.
Reference: [27] <author> Kotz, D. </author> <title> Prefetching and Caching Techniques in File Systems for MIMD Multiprocessors. </title> <type> PhD thesis, </type> <institution> Duke University, </institution> <month> April </month> <year> 1991. </year> <note> Available as technical report CS-1991-016. </note>
Reference-contexts: Sequential applications tend to exhibit very simple and predictable access patterns [36]. Simple caching, prefetching, and write back policies are generally sufficient for these applications. Parallel and supercomputer input/output access patterns, on the other hand, have been classified via several taxonomies <ref> [31, 6, 27] </ref>. These taxonomies and parallel application characterization [5, 43] demonstrate the complex input/output resource requirements of parallel versus sequential application input/output. As part of the Scalable Input/Output Initiative (SIO), the Pablo group has characterized the input/output behavior of several such input/output intensive parallel applications. <p> IBM, for example, invested considerable resources to develop and optimize the Vesta [11] experimental parallel file system. 1 A host of university research groups develop and use experimental parallel input/output libraries. Many of these projects, such as <ref> [27] </ref> have used a combination of modeling, simulation, and experimental results to explore parallel input/output issues on a variety of platforms. <p> Several parallel input/output taxonomies have been defined <ref> [31, 6, 27] </ref>. These taxonomies sometimes attach a cause to input/output requests such as initialization, compulsory, checkpoint or out-of-core. In other cases, such as Crockett [6] and Kotz [27], parallel input/output characterization is given by the relative sizes and spacings of requests within a file. <p> Several parallel input/output taxonomies have been defined [31, 6, 27]. These taxonomies sometimes attach a cause to input/output requests such as initialization, compulsory, checkpoint or out-of-core. In other cases, such as Crockett [6] and Kotz <ref> [27] </ref>, parallel input/output characterization is given by the relative sizes and spacings of requests within a file. In x4.1, we present a parallel access pattern taxonomy based on extant taxonomies and the SIO parallel input/output characterization effort.
Reference: [28] <author> Kotz, D., and Ellis, C. S. </author> <title> Prefetching in File Systems for MIMD Multiprocessors. </title> <journal> IEEE Transactions on Parallel and Distributed Systems 1, </journal> <month> 2 (April </month> <year> 1990), </year> <pages> 218-230. 47 </pages>
Reference-contexts: This reorganization can constrain both the choice of algorithm its scalability. We believe that instead of blind, system-wide optimizations, parallel file systems should adapt their policies to individual application resource requirements. Matching file system policies to application resource requirements has proven an effective technique for improving input/output performance <ref> [28, 15] </ref>. Each input/output utilization phase might have different optimal file system policies. In addition, running other applications concurrently may perturb the input/output performance of the first application requiring dynamic repartitioning of the input/output resources.
Reference: [29] <author> Kuppermann, A., and Wu, Y.-S. M. </author> <title> The Quantitative Prediction and Lifetime of a Pronounced Reactive Scattering Resonance. </title> <journal> Chemical Physics Letters 241 (1995), </journal> <pages> 229-240. </pages>
Reference-contexts: Figure 1a shows the performance of one of five input/output intensive phases of an ab initio quantum chemistry (QCRD) code running on 64 nodes of an Intel Paragon <ref> [29, 49] </ref>. Disjoint portions of shared files are read, transformed, and written by each processor during each application phase. Similarly, Figure 1b shows the performance of a 128 node electron scattering application that computes electron-molecule collision cross sections. This application contains three distinct input/output phases. <p> These molecular level details are evident in the state-to-state differential and integral cross sections. The QCRD application solves the Schrodinger equation for the cross section of the scattering of an atom by a diatomic molecule <ref> [29, 49] </ref>. This parallel version of the code runs on the Intel Paragon and decomposes global matrices equally among the different processors to achieve satisfactory load balancing. This application is executed as five separate input/output intensive programs.
Reference: [30] <author> Miller, B. P., Callaghan, M. D., Cargille, J. M., Hollingsworth, J. K., Irvin, R. B., Karavanic, K. L., Kunchithapadam, K., and Newhall, T. </author> <title> The PARADYN Parallel Performance Measurement Tools. </title> <journal> IEEE Computer 28 (Nov. </journal> <year> 1995), </year> <pages> 37-46. </pages>
Reference-contexts: In addition to system dependent debuggers and application trace support, there are several portable application monitoring and visualization utilities [26, 16, 50, 22]. These tools support a fixed set of possible instrumentable constructs such as procedure calls, message passing calls, and input/output requests. In contrast, Pablo [40] and Paradyn <ref> [30] </ref> provide an extensible set of instrumentable constructs.
Reference: [31] <author> Miller, E. L., and Katz, R. H. </author> <title> Input/Output Behavior of Supercomputer Applications. </title> <booktitle> In Proceedings of Supercomputing '91 (November 1991), </booktitle> <pages> pp. 567-576. </pages>
Reference-contexts: Sequential applications tend to exhibit very simple and predictable access patterns [36]. Simple caching, prefetching, and write back policies are generally sufficient for these applications. Parallel and supercomputer input/output access patterns, on the other hand, have been classified via several taxonomies <ref> [31, 6, 27] </ref>. These taxonomies and parallel application characterization [5, 43] demonstrate the complex input/output resource requirements of parallel versus sequential application input/output. As part of the Scalable Input/Output Initiative (SIO), the Pablo group has characterized the input/output behavior of several such input/output intensive parallel applications. <p> Several parallel input/output taxonomies have been defined <ref> [31, 6, 27] </ref>. These taxonomies sometimes attach a cause to input/output requests such as initialization, compulsory, checkpoint or out-of-core. In other cases, such as Crockett [6] and Kotz [27], parallel input/output characterization is given by the relative sizes and spacings of requests within a file.
Reference: [32] <author> Moyer, S. A., and Sunderam, V. S. </author> <title> Characterizing Concurrency Control Performance for the PIOUS Parallel File System. </title> <type> Tech. Rep. </type> <institution> CSTR-950601, Emory University, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: In addition to ChemIO, several of the array based libraries discussed above are evolving into domain specific libraries. 3.1.4 Programming Model Parallel Input/Output Input/output libraries have been designed to support applications written for several popular message passing libraries such as PVM and MPI. PIOUS for PVM <ref> [32] </ref> supports multidimensional arrays, logical files, collective input/output and data declustering. Similarly, the emerging MPI-IO [44] for MPI provides an extensive set of independent and collective input/output routines as well as user defined data partitioning for MPI.
Reference: [33] <author> Mukherjee, B., and Schwan, K. </author> <title> Improving Performance by Use of Adaptive Objects: Experimentation with a Configurable Multiprocessor Thread Package. </title> <type> Tech. Rep. </type> <institution> GIT-CC-93-17, College of Computing, Georgia Institute of Technology, </institution> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: then invoke the actuator to split this element onto different processors during the next iteration. 9 3.3.2 Automatic Steering In contrast to interactive steering environments, automatic steering environments do not require that the user be "in the control loop." 2 DIRECT, Falcon, and the Meta Toolkit provide automatic steering interfaces <ref> [13, 14, 33, 48] </ref>. DIRECT is representative of a class of automated steering infrastructures for real time applications such as power plant control and critical embedded systems. <p> Automated run time steering is used in Falcon to select different mutual exclusion lock configurations based on the number of threads blocked on the lock <ref> [33] </ref>. An adaptation module executes code that examines sensor variables and sets the lock parameters. For example, if the number of threads waiting on a lock exceeds some threshold, the lock manager changes the number of iterations that a given thread should spin on the lock before sleeping.
Reference: [34] <author> Nickolayev, O. </author> <title> Performance Data Reduction Using Dynamic Statistical Clustering. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Rather than requiring a cooperating socket application that accepts sensor metrics, we have added a SWAVE interface option 18 that allows windows to directly invoke selectors. This SDDF function interface, shown in <ref> [34] </ref>. At the end of each sensor window, the SWAVE module invokes our steering selector mechanism. Table 1 shows the PPFS sensor metrics that we currently extract.
Reference: [35] <author> Nieuwejaar, N., and Kotz, D. </author> <title> The Galley Parallel File System. </title> <booktitle> In Proceedings of the 10th ACM International Conference on Supercomputing (May 1996). To appear. </booktitle>
Reference-contexts: The underlying file system library can then modify the prefetch parameters and cache replacement priorities to optimize performance. Other experimental parallel input/output systems assume a fixed model of parallel input/output. These systems then implement performance optimizations for this fixed input/output model. Galley <ref> [35] </ref>, Panda [42], PASSION [2] and Jovian [1] support external multi-dimensional arrays. These systems allow for efficient data distribution and access methods for accesses along each array dimension.
Reference: [36] <author> Ousterhout, J. K., et al. </author> <title> A Trace-Driven Analysis of the UNIX 4.2 BSD File System. </title> <booktitle> In Proceedings of the Tenth Symposium on Operating System Principles (Dec. 1985), Association For Computing Machinery, </booktitle> <pages> pp. 35-50. </pages>
Reference-contexts: Malleable file system policies are needed by parallel applications more than by their sequential counterparts because of the richer variety of access patterns that occur. Sequential applications tend to exhibit very simple and predictable access patterns <ref> [36] </ref>. Simple caching, prefetching, and write back policies are generally sufficient for these applications. Parallel and supercomputer input/output access patterns, on the other hand, have been classified via several taxonomies [31, 6, 27].
Reference: [37] <author> Parker, S. G., and Johnson, C. R. SCIRun: </author> <title> A Scientific Programming Environment for Computational Steering. </title> <booktitle> In Proceedings of Supercomputing '95 (December 1995). </booktitle>
Reference-contexts: Using a basic feedback system, the Falcon project has produced a general model of computational steering that combines a general set of on-line monitoring options, a "black box" steering selector, and several different classes of steering actions [46, 18, 17]. SciChem <ref> [37] </ref> is another representative example of an interactive steering infrastructure. Interactive steering systems contain three basic components. First, they provide actuators that allow algorithms, system or application parameters to be changed on the fly.
Reference: [38] <author> Patterson, R. H., Gibson, G. A., Ginting, E., Stodolsky, D., and Zelenka, J. </author> <title> Informed Prefetching and Caching. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles (December 1995), </booktitle> <pages> pp. 79-95. </pages>
Reference-contexts: The ELFs system [15] defines an extensible set of file types that enable different interface methodologies and optimizations within the underlying file system. TIPs <ref> [38] </ref> allows the user to specify in advance files and file fragments that will be accessed. The underlying file system library can then modify the prefetch parameters and cache replacement priorities to optimize performance. Other experimental parallel input/output systems assume a fixed model of parallel input/output. <p> Patterson and Gibson <ref> [38] </ref> explore this problem by developing an intelligent prefetch mechanism for allocating buffer resources between application demand accesses and informed prefetching contexts. Consider an interleaved access pattern such as that in x4.1.4 with eight processors, four kilobyte requests, and a uniformly distributed interaccess interval with a mean of 175 milliseconds.
Reference: [39] <author> Poole, J. T. </author> <title> Scalable I/O Initiative. </title> <institution> California Institute of Technology, </institution> <note> Available at http://www.ccsf.caltech.edu/SIO/, 1996. </note>
Reference-contexts: This work builds on the Pablo performance instrumentation and analysis infrastructure [40], the Portable Parallel File System (PPFS) user level file system policy testbed [20, 21] discussed in Appendix A, and the Scalable Input/Output Initiative (SIO) parallel input/output characterization and optimization effort <ref> [39] </ref>. In x2, we formally discuss the proposed research area. We describe related projects and research in x3. In x4 we present a taxonomy of parallel access patterns that provides a target for our optimization experiments. We outline our closed loop optimization infrastructure in x5.
Reference: [40] <author> Reed, D. A., Aydt, R. A., Noe, R. J., Roth, P. C., Shields, K. A., Schwartz, B. W., and Tavera, L. F. </author> <title> Scalable Performance Analysis: The Pablo Performance Analysis Environment. </title> <booktitle> In Proceedings of the Scalable Parallel Libraries Conference, </booktitle> <editor> A. Skjellum, Ed. </editor> <publisher> IEEE Computer Society, </publisher> <year> 1993, </year> <pages> pp. 104-113. 48 </pages>
Reference-contexts: This work builds on the Pablo performance instrumentation and analysis infrastructure <ref> [40] </ref>, the Portable Parallel File System (PPFS) user level file system policy testbed [20, 21] discussed in Appendix A, and the Scalable Input/Output Initiative (SIO) parallel input/output characterization and optimization effort [39]. In x2, we formally discuss the proposed research area. We describe related projects and research in x3. <p> We have prototyped our performance optimization infrastructure using PPFS, a user level portable parallel file system that provides dynamically configurable caching, prefetching and write behind policies [21]. We have instrumented the PPFS with an extended version of the Pablo performance instrumentation library to provide performance sensors <ref> [40, 41] </ref>. <p> In addition to system dependent debuggers and application trace support, there are several portable application monitoring and visualization utilities [26, 16, 50, 22]. These tools support a fixed set of possible instrumentable constructs such as procedure calls, message passing calls, and input/output requests. In contrast, Pablo <ref> [40] </ref> and Paradyn [30] provide an extensible set of instrumentable constructs. <p> Figure 6 shows the interaction of an application code with these three libraries. 6.1 PPFS Sensors To capture input/output performance data, we augmented PPFS with a set of performance sensors that are periodically sampled using the Pablo <ref> [40] </ref> instrumentation library. At the end of each sensor window, performance statistics are summarized and forwarded to the policy selectors. Pablo's sliding window average extension (SWAVE) allows an application to register a set of metric dimensions and provide event values to these dimensions.
Reference: [41] <author> Reed, D. A., Shields, K. A., Tavera, L. F., Scullin, W. H., and Elford, C. L. </author> <title> Virtual Reality and Parallel Systems Performance Analysis. </title> <journal> IEEE Computer (Nov. </journal> <year> 1995), </year> <pages> 57-67. </pages>
Reference-contexts: We have prototyped our performance optimization infrastructure using PPFS, a user level portable parallel file system that provides dynamically configurable caching, prefetching and write behind policies [21]. We have instrumented the PPFS with an extended version of the Pablo performance instrumentation library to provide performance sensors <ref> [40, 41] </ref>. <p> These actuators provide a rich variety of controls to our dynamic steering infrastructure. In addition to invoking these actuator functions from our selector library, we have tested these controls by interactively steering application behavior using a virtual reality display of the sensor metrics <ref> [41] </ref>. 6.4 Infrastructure in Action To clarify how our infrastructure dynamically selects file system policies, Figure 8 tracks the execution of a simple sequential application on the Intel Paragon XP/S using our infrastructure to select prefetch policy parameters.
Reference: [42] <author> Seamons, K. E., Chen, Y., Jones, P., Jozwiak, J., and Winslett, M. </author> <title> Server-Directed Collective I/O in Panda. </title> <booktitle> In Proceedings of Supercomputing '95 (December 1995). </booktitle>
Reference-contexts: The underlying file system library can then modify the prefetch parameters and cache replacement priorities to optimize performance. Other experimental parallel input/output systems assume a fixed model of parallel input/output. These systems then implement performance optimizations for this fixed input/output model. Galley [35], Panda <ref> [42] </ref>, PASSION [2] and Jovian [1] support external multi-dimensional arrays. These systems allow for efficient data distribution and access methods for accesses along each array dimension.
Reference: [43] <author> Smirni, E., Aydt, R. A., Chien, A. A., and Reed, D. A. </author> <title> I/O Requirements of Scientific Applications: An Evolutionary View. In High Performance Distributed Computing (1996), </title> <note> p. to appear. </note>
Reference-contexts: Simple caching, prefetching, and write back policies are generally sufficient for these applications. Parallel and supercomputer input/output access patterns, on the other hand, have been classified via several taxonomies [31, 6, 27]. These taxonomies and parallel application characterization <ref> [5, 43] </ref> demonstrate the complex input/output resource requirements of parallel versus sequential application input/output. As part of the Scalable Input/Output Initiative (SIO), the Pablo group has characterized the input/output behavior of several such input/output intensive parallel applications. The SIO application suite is described in detail in Appendix B.
Reference: [44] <author> The MPI-IO Committee. </author> <title> MPI-IO: A Parallel File I/O Interface for MPI, </title> <month> April </month> <year> 1996. </year> <note> Version 0.5. </note>
Reference-contexts: PIOUS for PVM [32] supports multidimensional arrays, logical files, collective input/output and data declustering. Similarly, the emerging MPI-IO <ref> [44] </ref> for MPI provides an extensive set of independent and collective input/output routines as well as user defined data partitioning for MPI. MPI-IO allows the user to specify file access hints that the underlying implementation can use for optimization.
Reference: [45] <author> Vengroff, D. E., and Vitter, J. S. </author> <title> I/O-Efficient Scientific Computation Using TPIE. </title> <type> Tech. Rep. </type> <institution> CS-1995-18, Dept. of Computer Science, Duke University, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: In addition to providing a user level API, PASSION is also used as a compiler target for compile time input/output optimization. TPIE <ref> [45] </ref> provides an inverted approach to parallel input/output by attaching user computation callbacks to file data streams rather than invoking input/output calls in computation threads.
Reference: [46] <author> Vetter, J., and Schwan, K. </author> <title> Models for Computational Steering. </title> <booktitle> In Proceedings International Conference on Configurable Distributed Systems Annapolis (May 1996). </booktitle>
Reference-contexts: Using a basic feedback system, the Falcon project has produced a general model of computational steering that combines a general set of on-line monitoring options, a "black box" steering selector, and several different classes of steering actions <ref> [46, 18, 17] </ref>. SciChem [37] is another representative example of an interactive steering infrastructure. Interactive steering systems contain three basic components. First, they provide actuators that allow algorithms, system or application parameters to be changed on the fly. <p> In this section, we discuss our conceptual framework for exploring performance sensor based closed loop file system policy optimization. 5.1 Simple Feedback Control Model Using the basic feedback system shown in Figure 3 as a model, we now describe closed loop control <ref> [46] </ref>. As shown in the figure, an application transforms input into output. A feedback control framework can be divided into three components that interact with an executing application.
Reference: [47] <author> Winstead, C., and McKoy, V. </author> <title> Studies of Electron-Molecule Collisions on Massively Parallel Computers. In Modern Electronic Structure Theory, </title> <editor> D. R. Yarkony, Ed., </editor> <volume> vol. 2. </volume> <publisher> World Scientific, </publisher> <year> 1994. </year>
Reference-contexts: The SIO application suite provides a set of real test cases with which to explore the efficacy of parallel file system optimizations. In this appendix, we describe four of the primary SIO applications. B.1 SMC Electron Scattering (ESCAT) This code is used to study low-energy electron-molecule collisions <ref> [47] </ref>. This application is important for certain types of aerospace research, atmospheric sciences and to explore semiconductor fabrication issues. ESCAT is a parallel implementation of the Schwinger Multichannel method and generates electron scattering probabilities that result from molecular collisions.
Reference: [48] <author> Wood, M. D. </author> <title> Fault-Tolerant Management of Distributed Applications Using the Reactive System Architecture. </title> <type> PhD thesis, </type> <institution> Cronell University, </institution> <month> January </month> <year> 1992. </year> <note> Available as technical report TR91-1252. </note>
Reference-contexts: then invoke the actuator to split this element onto different processors during the next iteration. 9 3.3.2 Automatic Steering In contrast to interactive steering environments, automatic steering environments do not require that the user be "in the control loop." 2 DIRECT, Falcon, and the Meta Toolkit provide automatic steering interfaces <ref> [13, 14, 33, 48] </ref>. DIRECT is representative of a class of automated steering infrastructures for real time applications such as power plant control and critical embedded systems. <p> The Meta Toolkit provides a framework of guards for maintaining mutual exclusion of critical state variables <ref> [48] </ref>. When an actuator is invoked, the appropriate guards are executed before the system module is modified. The Meta Toolkit also defines the NPL Expression language for expressing mappings of sensors to actuators.
Reference: [49] <author> Wu, Y.-S. M., Cuccaro, S. A., Hipes, P. G., and Kuppermann, A. </author> <title> Quantum Chemical Reaction Dynamics on a Highly Parallel Supercomputer. </title> <journal> Theoretica Chimica Acta 79 (1991), </journal> <pages> 225-239. </pages>
Reference-contexts: Figure 1a shows the performance of one of five input/output intensive phases of an ab initio quantum chemistry (QCRD) code running on 64 nodes of an Intel Paragon <ref> [29, 49] </ref>. Disjoint portions of shared files are read, transformed, and written by each processor during each application phase. Similarly, Figure 1b shows the performance of a 128 node electron scattering application that computes electron-molecule collision cross sections. This application contains three distinct input/output phases. <p> These molecular level details are evident in the state-to-state differential and integral cross sections. The QCRD application solves the Schrodinger equation for the cross section of the scattering of an atom by a diatomic molecule <ref> [29, 49] </ref>. This parallel version of the code runs on the Intel Paragon and decomposes global matrices equally among the different processors to achieve satisfactory load balancing. This application is executed as five separate input/output intensive programs.
Reference: [50] <author> Yan, J., Hontalas, P., and Listgarten, S. </author> <title> The Automated Instrumentation and Monitoring System (AIMS) Reference Manual. </title> <type> Tech. Rep. 108795, </type> <institution> NASA Ames, </institution> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Similarly, the IBM SP/2 RS6000 nodes support kernel AIX tracing extensions that allow the user to dynamically monitor processor, memory, network and file activity [4]. In addition to system dependent debuggers and application trace support, there are several portable application monitoring and visualization utilities <ref> [26, 16, 50, 22] </ref>. These tools support a fixed set of possible instrumentable constructs such as procedure calls, message passing calls, and input/output requests. In contrast, Pablo [40] and Paradyn [30] provide an extensible set of instrumentable constructs.
References-found: 50

