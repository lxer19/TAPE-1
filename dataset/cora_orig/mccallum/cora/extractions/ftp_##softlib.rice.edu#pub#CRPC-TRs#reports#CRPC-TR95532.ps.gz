URL: ftp://softlib.rice.edu/pub/CRPC-TRs/reports/CRPC-TR95532.ps.gz
Refering-URL: http://www.crpc.rice.edu/CRPC/softlib/TRs_online.html
Root-URL: 
Email: bodin@irisa.fr granston@cs.rice.edu montaut@irisa.fr  
Title: Page-level Affinity Scheduling for Eliminating False Sharing  
Author: Fran~cois Bodin Elana D. Granston Thierry Montaut 
Date: June 28-30, 1995  
Note: To appear in the 5th Workshop on Compilers for Parallel Computers, Malaga, Spain,  
Address: 35042 Rennes, Cedex 6100 South Main Street 35042 Rennes, Cedex France Houston, Texas 77005, USA France  
Affiliation: IRISA Rice University IRISA Campus de Beaulieu Center for Research on Parallel Computation Campus de Beaulieu  
Abstract: To date, page management in distributed shared memory (DSM) systems has been primarily the responsibility of the run time system. However, there are some problems that are difficult to resolve efficiently at run time. Chief among these is false sharing. In this paper, we present a general technique for applying page-level affinity scheduling to eliminate false sharing resulting from regular references in numerical applications with loop-level parallelism. This a generalization of our previous work which was applied to one and two dimensional loops. We demonstrate the potential of these transformations experimentally.
Abstract-found: 1
Intro-found: 1
Reference: [AALT94] <author> Saman P. Ammarsinghe, Jennifer M. Anderson, Monica S. Lam, and Chau-Wen Tseng. </author> <title> Design and Evaluation of Compiler Optimizations for Scalable Address Space Machines, </title> <note> 1994. To be published. </note>
Reference-contexts: Because of the smaller working set of the optimized version, it performed much better. 7 Related Research The potential performance degradation that can be caused by false sharing of array data has been studied by several researchers. Based on this research, data layout optimizations padding <ref> [BFS89, LP92, TLH92, AL93, AALT94, Mon95] </ref> have been proposed.
Reference: [ACIK93] <author> Corinne Ancourt, Fabien Coelho, Fran~cois Irigoin, and Ronan Keryell. </author> <title> A Linear Algebra Framework for Static HPF Code Distribution. </title> <booktitle> In Proceedings of the Fourth Workshop on Compilers for Parallel Computers, </booktitle> <address> Delft, The Netherlands, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: This transformation is simpler to implement and can be applied in more cases than the transformation described here, but yields a smaller performance improvement and only when the amount of parallelism is moderate. Other researchers, for example <ref> [CGL + 93, ACIK93, KNS94, AFMP95] </ref>, have looked at using a block-cyclic owner computes rule to compile data-parallel languages such as HPF [KLS + 94]. Some of these techniques are also based on generating and solving sets of inequalities.
Reference: [AFMP95] <author> A. Andre, M. Le Fur, Y. Maheo, and J.-L. Pazat. </author> <title> The Pandore Data Parallel Compiler and its Portable Runtime. </title> <booktitle> In HPCN Europe'95, </booktitle> <address> Milan, Italy, </address> <month> May </month> <year> 1995. </year> <note> To appear in LNCS, Springer Verlag. </note>
Reference-contexts: In some cases, however, our transformation exposes opportunities to eliminate this synchronization (Section 5). When the loop nest does contain flow or anti-dependences, the above elimination order may not be legal. This problem is similar to that which arises when compiling languages such as HPF <ref> [KLS + 94, BCZ92, AFMP95, FSHK + 91] </ref>. Suppose that innermost loop that carries a flow or input dependence is the I J loop. <p> This transformation is simpler to implement and can be applied in more cases than the transformation described here, but yields a smaller performance improvement and only when the amount of parallelism is moderate. Other researchers, for example <ref> [CGL + 93, ACIK93, KNS94, AFMP95] </ref>, have looked at using a block-cyclic owner computes rule to compile data-parallel languages such as HPF [KLS + 94]. Some of these techniques are also based on generating and solving sets of inequalities.
Reference: [AHD93] <author> Bill Appelbe, Charles Hardnett, and Sri Doddapaneni. </author> <title> Program Transformation for Locality Using Affinity Regions. </title> <booktitle> In the Sixth Annual Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, Oregon, </address> <month> August </month> <year> 1993. </year> <title> Published in Languages and Compilers for Parallel Computing, </title> <editor> Banerjee et al. (Eds.), </editor> <publisher> LNCS 768, Springer-Verlag, </publisher> <year> 1994, </year> <pages> pages 290-300. </pages>
Reference-contexts: These include transformations such as loop interchanging that increase locality within an individual loop nest [BEJW92, KM92, WL91] as well as transformations that increase locality across loops, for example <ref> [HA90, AHD93] </ref>. Unfortunately, these transformations achieve affinity at the data-level only. When the coherency unit becomes larger, such techniques no longer suffice. An alternate compile-time approach that we explored attacks ping-pong effects only [BGM94].
Reference: [AI91] <author> C. Ancourt and F. Irigoin. </author> <title> Scanning Polyhedra with Do Loops. </title> <booktitle> In Third ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 39-50, </pages> <address> Williamsburg, Virginia, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: The consequence of this is that the resulting code may contain empty iterations, namely for one or more iterations of an outer loop, an inner loop has zero trips. Ancourt and Irigoin <ref> [AI91] </ref> and Le Fur [Fur95] have focused on addressing the first concern by developing techniques for eliminating redundant constraints, key source of inefficiency in the basic algorithm. Our approach is to precompute solutions for commonly occurring cases. An example of precomputation is given in Figure 2 3 .
Reference: [AL93] <author> Jennifer Anderson and Monica Lam. </author> <title> Global Optimizations for Parallelism and Locality on Scalable Parallel Machines. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Languages Design and Implementation. </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: Because of the smaller working set of the optimized version, it performed much better. 7 Related Research The potential performance degradation that can be caused by false sharing of array data has been studied by several researchers. Based on this research, data layout optimizations padding <ref> [BFS89, LP92, TLH92, AL93, AALT94, Mon95] </ref> have been proposed.
Reference: [BCZ92] <author> S. Benkner, B. Chapman, and H. Zima. </author> <title> Vienna Fortran 90. </title> <booktitle> In Scalable High Performance Computing Conference, </booktitle> <pages> pages 51-59. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> April </month> <year> 1992. </year>
Reference-contexts: In some cases, however, our transformation exposes opportunities to eliminate this synchronization (Section 5). When the loop nest does contain flow or anti-dependences, the above elimination order may not be legal. This problem is similar to that which arises when compiling languages such as HPF <ref> [KLS + 94, BCZ92, AFMP95, FSHK + 91] </ref>. Suppose that innermost loop that carries a flow or input dependence is the I J loop.
Reference: [BEJW92] <author> Fran~cois Bodin, Christine Eisenbeis, William Jalby, and Daniel Windheiser. </author> <title> A Quantitative Algorithm for Data Locality Optimization. In Code Generation-Concepts, Tools, Techniques. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: We would like to solve the inequalities in the order that will maximize data locality subject to dependence constraints. We assume that standard loop level transformations for increasing parallelism, temporal locality and spatial locality <ref> [BEJW92, KM92, WL91] </ref> have already been applied. Therefore, we assume the loops I 1 ; : : : ; I M must remain in the same order with respect to each other. The simplest case arises when the loop nest contains no flow or anti-dependence. <p> In many cases, when coherency units are small, compiler-directed program transformations that increase temporal and spatial locality without directly considering the size of the coherency unit alleviate much of the problem. These include transformations such as loop interchanging that increase locality within an individual loop nest <ref> [BEJW92, KM92, WL91] </ref> as well as transformations that increase locality across loops, for example [HA90, AHD93]. Unfortunately, these transformations achieve affinity at the data-level only. When the coherency unit becomes larger, such techniques no longer suffice. An alternate compile-time approach that we explored attacks ping-pong effects only [BGM94].
Reference: [BFS89] <author> William J. Bolosky, Robert P. Fitzgerald, and Michael L. Scott. </author> <title> Simple But Effective Techniques for NUMA Memory Management. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 19-31. </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: Because of the smaller working set of the optimized version, it performed much better. 7 Related Research The potential performance degradation that can be caused by false sharing of array data has been studied by several researchers. Based on this research, data layout optimizations padding <ref> [BFS89, LP92, TLH92, AL93, AALT94, Mon95] </ref> have been proposed.
Reference: [BGM94] <author> Fran~cois Bodin, Elana D. Granston, and Thierry Montaut. </author> <title> Evaluating Two Loop Transformations for Reducing Multiple-Writer False Sharing. </title> <booktitle> In the Seventh Annual Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Ithaca, New York, </address> <month> August </month> <year> 1994. </year> <note> Published as LNCS 892, pages 423-439, </note> <editor> Pingali et al. (Eds.), </editor> <booktitle> 1995. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg. </address>
Reference-contexts: In this paper, we present a technique for eliminating false sharing by applying page-level affinity scheduling. This technique is a generalization of our earlier work <ref> [Gra93, BGM94] </ref> which handled certain cases of one and two dimensional loops. The remainder of this paper is organized as follows. Section 2 presents an example of our technique. Section 3 presents the basic algorithm. <p> For the remainder, we can reduce the number of page migrations that page-level sharing causes by reducing ping-pong effects (i.e., the repetitive bouncing of a falsely shared page between processors) using a loop transformation that we developed specifically for this purpose <ref> [BGM94] </ref>. Depending on the coherency protocol, most of the page migrations attributed to false sharing may actually be caused by ping-pong effects. Consequently, we have found that this hybrid strategy works well in practice [BGM94]. 10 Loop Nest 4 /* Key loop nest from Lawrence Livermore Kernel 18 */ DO I <p> falsely shared page between processors) using a loop transformation that we developed specifically for this purpose <ref> [BGM94] </ref>. Depending on the coherency protocol, most of the page migrations attributed to false sharing may actually be caused by ping-pong effects. Consequently, we have found that this hybrid strategy works well in practice [BGM94]. 10 Loop Nest 4 /* Key loop nest from Lawrence Livermore Kernel 18 */ DO I 1 = 2 TO 6 R ZU : ZU [I 2 ,I 1 ] = ZU [I 2 ,I 1 ] + S * (ZA [I 2 ,I 1 ] * (ZZ [I 2 <p> Unfortunately, these transformations achieve affinity at the data-level only. When the coherency unit becomes larger, such techniques no longer suffice. An alternate compile-time approach that we explored attacks ping-pong effects only <ref> [BGM94] </ref>. This approach alleviates ping-pong effects by batching up write requests which encourages processors to perform multiple writes to a page before relinquishing the page.
Reference: [BKP93] <author> F. Bodin, L. Kervella, and T. Priol. Fortran-S: </author> <title> A Fortran Interface for Shared Virtual Memory Architectures. </title> <booktitle> In Supercomputing '93, </booktitle> <pages> pages 274-283. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> November </month> <year> 1993. </year>
Reference-contexts: Both the source and sink of the dependence are now executed on the same processor, so the dependence is enforced without synchronization. 13 6 Experimental Results Page-level affinity scheduling (PLAS), except for the precomputation, has been implemented in the Fortran-S compiler <ref> [BKP93] </ref>. The Fortran-S compiler generates SPMD-style code that runs on the iPSC/2 under the KOAN software DSM [LP92]. The KOAN DSM system is embedded in the operating system of the iPSC/2. Pages of size 4 KB are physically distributed across processors' local memories.
Reference: [BLSS93] <author> Mauricio Breternitz, Jr., Michael Lai, Vivek Sarkar, and Barbara Simons. </author> <title> Compiler Solutions for the Stale-Data and False-Sharing Problems. </title> <type> Technical Report 03.466, </type> <institution> IBM Santa Teresa Laboratory, </institution> <month> April </month> <year> 1993. </year> <month> 21 </month>
Reference-contexts: In contrast, on systems where no hardware or run-time support for coherence is provided, false sharing must be eliminated to ensure correctness. Breternitz et al. <ref> [BLSS93] </ref> study this problem. Consequently, their techniques are more general but likely to be less efficient. 8 Conclusions In this paper, we have presented a transformation for eliminating false sharing within loop nests by applying a page-based owner-computes rule.
Reference: [CF78] <author> L.M. Censier and P. Feautrier. </author> <title> A New Solution to Coherence Problems in Multicache Systems. </title> <journal> IEEE Transactions on Computers, </journal> <pages> pages 1112-1118, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: The KOAN DSM system is embedded in the operating system of the iPSC/2. Pages of size 4 KB are physically distributed across processors' local memories. KOAN uses a distributed-manager algorithm based on [Li86], with an invalidation protocol that ensures that the shared memory is coherent at all times <ref> [CF78] </ref>. Under this protocol, pages can have one of three access modes: read-only , write-exclusive and invalid. Multiple copies of a page are permitted only when all copies are in read-only mode.
Reference: [CGL + 93] <author> Siddhartha Chatterjee, John R. Gilbert, Fred J. E. Long, Robert Schreiber, and Shun-Hua Teng. </author> <title> Generating Local Address Communication Sets for Data-Parallel Programs. </title> <booktitle> In Proceedings of the Fourth ACM SIGPLAN Symposium on Principles and Practice Of Parallel Programming, </booktitle> <pages> pages 149-158, </pages> <address> San Diego, California, </address> <year> 1993. </year>
Reference-contexts: This transformation is simpler to implement and can be applied in more cases than the transformation described here, but yields a smaller performance improvement and only when the amount of parallelism is moderate. Other researchers, for example <ref> [CGL + 93, ACIK93, KNS94, AFMP95] </ref>, have looked at using a block-cyclic owner computes rule to compile data-parallel languages such as HPF [KLS + 94]. Some of these techniques are also based on generating and solving sets of inequalities.
Reference: [DBMS79] <author> J. Dongarra, J. Bunch, C. Moler, and G. Stewart. </author> <title> LINPACK User's Guide, </title> <year> 1979. </year>
Reference-contexts: Barriers were inserted when necessary. 6.1 DMXPY Loop Nest 8 depicts the Fortran kernel DMXPY from LINPACKD <ref> [DBMS79] </ref> which performs matrix-vector multiplication. For this experiment, we assumed that N 1 was small. Therefore, to maximize parallelism and locality, we stripmined the I 2 loop and then interchanged with the I 1 loop. The result is shown in Loop Nest 9.
Reference: [EJ91] <author> Susan J. Eggers and Tor E. Jeremiassen. </author> <title> Eliminating false sharing. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <pages> pages 377-381. </pages> <publisher> CRC Press, Inc., </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: 0.5 2 10 50 200 ORIG PLAS Number of Processors (d) Problem Size: N=15000 Execu tion Time (sec) 0.1 0.5 2 10 50 200 ORIG PLAS declared with different dimensions, so that Loop Nest 4 would contain references from two distinct reference groups. sharing in languages with structures and pointers <ref> [EJ91] </ref>. In many cases, when coherency units are small, compiler-directed program transformations that increase temporal and spatial locality without directly considering the size of the coherency unit alleviate much of the problem.
Reference: [Fea89] <author> P. Feautrier. </author> <title> Semantical Analysis and Mathematical Programming, Application to Paralleliza-tion and Vectorization. </title> <editor> In M. Cosnard et al., editor, </editor> <booktitle> Parallel and Distributed Algorithms, </booktitle> <pages> pages 309-320. </pages> <publisher> Elsevier Science Publishers, </publisher> <year> 1989. </year>
Reference-contexts: For completeness sake, however, we note that there are several techniques for eliminating them should they become problematic [Pug91, Mon95]. An alternative to Fourier-Motzkin has been proposed by Feautrier <ref> [Fea89] </ref>. He handles systems of linear inequalities using the simplex method [Sch86]. He proposes a parametrized simplex algorithm (PIP) which can be used to compute the loop bounds. The advantage of the simplex method is that it does not introduce redundant constraints in the system.
Reference: [FSHK + 91] <author> G. Fox, K. Kennedy S. Hiranandi, C. Koebel, U. Kremer, C. Tseng, and M. Wu. </author> <title> Fortran D Language Specification. </title> <type> Technical Report TR-90079, </type> <institution> Department of Computer Science, Rice University, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: In some cases, however, our transformation exposes opportunities to eliminate this synchronization (Section 5). When the loop nest does contain flow or anti-dependences, the above elimination order may not be legal. This problem is similar to that which arises when compiling languages such as HPF <ref> [KLS + 94, BCZ92, AFMP95, FSHK + 91] </ref>. Suppose that innermost loop that carries a flow or input dependence is the I J loop.
Reference: [Fur95] <author> Marc Le Fur. </author> <title> Scanning Parameterized Polyhedron using Fourier-Motzkin Elimination. </title> <booktitle> In HPCS'95, </booktitle> <address> Montreal, Canada, </address> <month> July </month> <year> 1995. </year> <note> (to appear). </note>
Reference-contexts: The consequence of this is that the resulting code may contain empty iterations, namely for one or more iterations of an outer loop, an inner loop has zero trips. Ancourt and Irigoin [AI91] and Le Fur <ref> [Fur95] </ref> have focused on addressing the first concern by developing techniques for eliminating redundant constraints, key source of inefficiency in the basic algorithm. Our approach is to precompute solutions for commonly occurring cases. An example of precomputation is given in Figure 2 3 .
Reference: [Gra93] <author> Elana D. Granston. </author> <title> Toward a Compile-Time Methodology for Reducing False Sharing and Communication Traffic in Shared Virtual Memory Systems. </title> <booktitle> In the Proceedings of the Sixth Annual Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, Oregon, </address> <month> August </month> <year> 1993. </year> <note> Published as LNCS 768, pages 273-289, </note> <editor> Banerjee et al. (Eds.), </editor> <booktitle> 1994. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg. </address>
Reference-contexts: In this paper, we present a technique for eliminating false sharing by applying page-level affinity scheduling. This technique is a generalization of our earlier work <ref> [Gra93, BGM94] </ref> which handled certain cases of one and two dimensional loops. The remainder of this paper is organized as follows. Section 2 presents an example of our technique. Section 3 presents the basic algorithm.
Reference: [HA90] <author> David E. Hudak and Santosh G. Abraham. </author> <title> Compiler Techniques for Data Partitioning of Sequentially Iterated Loops. </title> <booktitle> In Proceedings of the International Conference on Supercomputing, </booktitle> <pages> pages 187-200. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: These include transformations such as loop interchanging that increase locality within an individual loop nest [BEJW92, KM92, WL91] as well as transformations that increase locality across loops, for example <ref> [HA90, AHD93] </ref>. Unfortunately, these transformations achieve affinity at the data-level only. When the coherency unit becomes larger, such techniques no longer suffice. An alternate compile-time approach that we explored attacks ping-pong effects only [BGM94].
Reference: [JC93] <author> T. Risset J.F. Collard, P. Feautrier. </author> <title> Construction of DO Loops from Systems of Affine Constraints. </title> <note> In LIP Research Report 93-15, </note> <month> May </month> <year> 1993. </year>
Reference-contexts: The advantage of the simplex method is that it does not introduce redundant constraints in the system. However the algorithm has to be applied for each loop bound and a simplification of the loop bounds must be performed before the results can be used <ref> [JC93] </ref>. 2 The lack of convexity arises from the integer division. 3 sign (t) = 1 if t &gt; 0, 1 if t &lt; 0, and 0 otherwise. t + = max (t; 0). t = max (t; 0). 7 DO I 1 =0 TO N 1 1 R : A
Reference: [KDCZ94] <author> P. Keleher, S. Dwarkadas, A. Cox, and W. Zwaenepoel. Treadmarks: </author> <title> Distributed Shared Memory On Standard Workstations and and Operating Systems. </title> <booktitle> In Winter Usenix Conference, </booktitle> <year> 1994. </year>
Reference-contexts: False sharing is particularly problematic in software DSMs where coherency is maintained at the granularity of a page. Because software DSMs are typically implemented on top of or embedded into systems which were tuned for uniprocessor environments, page sizes are typically 4K or larger <ref> [LP92, KDCZ94] </ref>. In this paper, we present a technique for eliminating false sharing by applying page-level affinity scheduling. This technique is a generalization of our earlier work [Gra93, BGM94] which handled certain cases of one and two dimensional loops. The remainder of this paper is organized as follows. <p> However, none of them have considered the 19 approach of precomputing solutions to reduce compile-time overhead. Run-time solutions for eliminating ping-pong effects have also been proposed. One approach is to relax the consistency model. For example, systems such as Treadmarks <ref> [KDCZ94] </ref> (by default) and KOAN [LP92] (as an option) allow multiple copies of writable pages to exist and merge modifications only at synchronization points.
Reference: [KLS + 94] <author> Charles H. Koelbel, David B. Loveman, Robert S. Schreiber, Guy L. Steele Jr., and Mary E. Zosel. </author> <title> The High Performance Fortran handbook. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: In some cases, however, our transformation exposes opportunities to eliminate this synchronization (Section 5). When the loop nest does contain flow or anti-dependences, the above elimination order may not be legal. This problem is similar to that which arises when compiling languages such as HPF <ref> [KLS + 94, BCZ92, AFMP95, FSHK + 91] </ref>. Suppose that innermost loop that carries a flow or input dependence is the I J loop. <p> Other researchers, for example [CGL + 93, ACIK93, KNS94, AFMP95], have looked at using a block-cyclic owner computes rule to compile data-parallel languages such as HPF <ref> [KLS + 94] </ref>. Some of these techniques are also based on generating and solving sets of inequalities. However, none of them have considered the 19 approach of precomputing solutions to reduce compile-time overhead. Run-time solutions for eliminating ping-pong effects have also been proposed.
Reference: [KM92] <author> Ken Kennedy and Katheryn S. McKinley. </author> <title> Optimizing for Parallelism and Data Locality. </title> <booktitle> In International Conference on Supercomputing, </booktitle> <pages> pages 323-334. </pages> <publisher> ACM Press, </publisher> <month> July </month> <year> 1992. </year>
Reference-contexts: We would like to solve the inequalities in the order that will maximize data locality subject to dependence constraints. We assume that standard loop level transformations for increasing parallelism, temporal locality and spatial locality <ref> [BEJW92, KM92, WL91] </ref> have already been applied. Therefore, we assume the loops I 1 ; : : : ; I M must remain in the same order with respect to each other. The simplest case arises when the loop nest contains no flow or anti-dependence. <p> In many cases, when coherency units are small, compiler-directed program transformations that increase temporal and spatial locality without directly considering the size of the coherency unit alleviate much of the problem. These include transformations such as loop interchanging that increase locality within an individual loop nest <ref> [BEJW92, KM92, WL91] </ref> as well as transformations that increase locality across loops, for example [HA90, AHD93]. Unfortunately, these transformations achieve affinity at the data-level only. When the coherency unit becomes larger, such techniques no longer suffice. An alternate compile-time approach that we explored attacks ping-pong effects only [BGM94].
Reference: [KNS94] <author> Ken Kennedy, Nenad Nedeljkovic, and Ajay Sethi. </author> <title> Efficient Address Generation for Block-Cyclic Distributions. </title> <type> Technical report, </type> <institution> Center for Research on Parallel Computation, Rice University, </institution> <type> Technical Report No. </type> <institution> CRPC-TR94487-S, Houston, Texas, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: This transformation is simpler to implement and can be applied in more cases than the transformation described here, but yields a smaller performance improvement and only when the amount of parallelism is moderate. Other researchers, for example <ref> [CGL + 93, ACIK93, KNS94, AFMP95] </ref>, have looked at using a block-cyclic owner computes rule to compile data-parallel languages such as HPF [KLS + 94]. Some of these techniques are also based on generating and solving sets of inequalities.
Reference: [Li86] <author> Kai Li. </author> <title> Shared Virtual Memory on Loosely Coupled Multiprocessors. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <month> September </month> <year> 1986. </year>
Reference-contexts: The Fortran-S compiler generates SPMD-style code that runs on the iPSC/2 under the KOAN software DSM [LP92]. The KOAN DSM system is embedded in the operating system of the iPSC/2. Pages of size 4 KB are physically distributed across processors' local memories. KOAN uses a distributed-manager algorithm based on <ref> [Li86] </ref>, with an invalidation protocol that ensures that the shared memory is coherent at all times [CF78]. Under this protocol, pages can have one of three access modes: read-only , write-exclusive and invalid. Multiple copies of a page are permitted only when all copies are in read-only mode.
Reference: [LP92] <author> Z. Lahjoumri and T. Priol. KOAN: </author> <title> A Shared-Memory for the iPSC/2 Hypercube. In CON-PAR/VAPP92, </title> <publisher> LNCS 634. Springer-Verlag, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: False sharing is particularly problematic in software DSMs where coherency is maintained at the granularity of a page. Because software DSMs are typically implemented on top of or embedded into systems which were tuned for uniprocessor environments, page sizes are typically 4K or larger <ref> [LP92, KDCZ94] </ref>. In this paper, we present a technique for eliminating false sharing by applying page-level affinity scheduling. This technique is a generalization of our earlier work [Gra93, BGM94] which handled certain cases of one and two dimensional loops. The remainder of this paper is organized as follows. <p> The Fortran-S compiler generates SPMD-style code that runs on the iPSC/2 under the KOAN software DSM <ref> [LP92] </ref>. The KOAN DSM system is embedded in the operating system of the iPSC/2. Pages of size 4 KB are physically distributed across processors' local memories. KOAN uses a distributed-manager algorithm based on [Li86], with an invalidation protocol that ensures that the shared memory is coherent at all times [CF78]. <p> Because of the smaller working set of the optimized version, it performed much better. 7 Related Research The potential performance degradation that can be caused by false sharing of array data has been studied by several researchers. Based on this research, data layout optimizations padding <ref> [BFS89, LP92, TLH92, AL93, AALT94, Mon95] </ref> have been proposed. <p> However, none of them have considered the 19 approach of precomputing solutions to reduce compile-time overhead. Run-time solutions for eliminating ping-pong effects have also been proposed. One approach is to relax the consistency model. For example, systems such as Treadmarks [KDCZ94] (by default) and KOAN <ref> [LP92] </ref> (as an option) allow multiple copies of writable pages to exist and merge modifications only at synchronization points.
Reference: [Mon95] <institution> Thierry Montaut. Methodes pour l'elimination du faux-partage et l'optimisation de la localite pour memoire virtuelle partagee. </institution> <type> PhD thesis, </type> <institution> IRISA, Campus de Beaulieu, </institution> <year> 1995. </year> <note> In preparation. 22 </note>
Reference-contexts: Moreover, the extra loop overhead per empty iteration is also very small, especially after applying standard optimizations to the loop bound expressions. For completeness sake, however, we note that there are several techniques for eliminating them should they become problematic <ref> [Pug91, Mon95] </ref>. An alternative to Fourier-Motzkin has been proposed by Feautrier [Fea89]. He handles systems of linear inequalities using the simplex method [Sch86]. He proposes a parametrized simplex algorithm (PIP) which can be used to compute the loop bounds. <p> Hence this option was not considered. Alternate 9 approaches to eliminating false sharing from loops with innermost sequential loops, for example by modifying data layout, is addressed in Montaut <ref> [Mon95] </ref>. 4 Optimizing Loop Nests with Multiple Write References In practice, programs often contain loop nests with more than one static write reference. This section describes techniques for applying page-level affinity scheduling to loops with multiple write references. <p> Because of the smaller working set of the optimized version, it performed much better. 7 Related Research The potential performance degradation that can be caused by false sharing of array data has been studied by several researchers. Based on this research, data layout optimizations padding <ref> [BFS89, LP92, TLH92, AL93, AALT94, Mon95] </ref> have been proposed.
Reference: [OKB] <author> M.F.P. O'Boyle, L. Kervella, and F. Bodin. </author> <title> Synchronization Minimization in a SPMD Execution Model. </title> <note> To appear in the Journal of Parallel and Distributed Computing. </note>
Reference-contexts: This type of dependence is known as a cross-loop dependence. For efficiency, however, we wish to minimize the number of barriers that we insert. To do this, we rely on the technique presented in O'Boyle et al. <ref> [OKB] </ref>. We describe this technique briefly here. By using the same mapping between pages and processors across loops, our transformation to eliminate false sharing achieves page-level affinity scheduling.
Reference: [Pug91] <author> William Pugh. </author> <title> The Omega Test: A Fast and Practical Integer Programming Algorithm for Dependence Analysis. </title> <booktitle> In Supercomputing, </booktitle> <year> 1991. </year>
Reference-contexts: Moreover, the extra loop overhead per empty iteration is also very small, especially after applying standard optimizations to the loop bound expressions. For completeness sake, however, we note that there are several techniques for eliminating them should they become problematic <ref> [Pug91, Mon95] </ref>. An alternative to Fourier-Motzkin has been proposed by Feautrier [Fea89]. He handles systems of linear inequalities using the simplex method [Sch86]. He proposes a parametrized simplex algorithm (PIP) which can be used to compute the loop bounds.
Reference: [Sch86] <author> Alexander Schrijver. </author> <title> Theory of Linear and Integer Programming. </title> <publisher> Wiley-Interscience, </publisher> <year> 1986. </year>
Reference-contexts: : ::: ::: ::: b fl (n fl P + pid) K b fl (n fl P + pid + 1) 1 ~ sizeof (A) + o (A) b fl m fl P 1 3.2 Solving Systems of Integer Inequalities We currently solve the system of inequalities using Fourier-Motzkin elimination <ref> [Sch86] </ref>. In general, given a matrix A and a vector b, standard Fourier-Motzkin finds a rational solution to Ax b, if one exists. <p> For completeness sake, however, we note that there are several techniques for eliminating them should they become problematic [Pug91, Mon95]. An alternative to Fourier-Motzkin has been proposed by Feautrier [Fea89]. He handles systems of linear inequalities using the simplex method <ref> [Sch86] </ref>. He proposes a parametrized simplex algorithm (PIP) which can be used to compute the loop bounds. The advantage of the simplex method is that it does not introduce redundant constraints in the system.
Reference: [TLH92] <author> Josep Torrellas, Monica S. Lam, and John L. Hennessy. </author> <title> False Sharing and Spatial Locality in Multiprocessor Caches, </title> <month> August </month> <year> 1992. </year> <note> Submitted to IEEE Transactions on Computers. </note>
Reference-contexts: Because of the smaller working set of the optimized version, it performed much better. 7 Related Research The potential performance degradation that can be caused by false sharing of array data has been studied by several researchers. Based on this research, data layout optimizations padding <ref> [BFS89, LP92, TLH92, AL93, AALT94, Mon95] </ref> have been proposed.
Reference: [WL91] <author> Michael E. Wolf and Monica S. Lam. </author> <title> A Data Locality Optimizing Algorithm. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 30-44. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year> <month> 23 </month>
Reference-contexts: We would like to solve the inequalities in the order that will maximize data locality subject to dependence constraints. We assume that standard loop level transformations for increasing parallelism, temporal locality and spatial locality <ref> [BEJW92, KM92, WL91] </ref> have already been applied. Therefore, we assume the loops I 1 ; : : : ; I M must remain in the same order with respect to each other. The simplest case arises when the loop nest contains no flow or anti-dependence. <p> In many cases, when coherency units are small, compiler-directed program transformations that increase temporal and spatial locality without directly considering the size of the coherency unit alleviate much of the problem. These include transformations such as loop interchanging that increase locality within an individual loop nest <ref> [BEJW92, KM92, WL91] </ref> as well as transformations that increase locality across loops, for example [HA90, AHD93]. Unfortunately, these transformations achieve affinity at the data-level only. When the coherency unit becomes larger, such techniques no longer suffice. An alternate compile-time approach that we explored attacks ping-pong effects only [BGM94].
References-found: 34

