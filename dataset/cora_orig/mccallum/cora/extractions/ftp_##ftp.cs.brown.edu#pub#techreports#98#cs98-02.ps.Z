URL: ftp://ftp.cs.brown.edu/pub/techreports/98/cs98-02.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-98-02.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Borning. </author> <title> The Programming Language Aspects of ThingLab, a Constraint-Oriented Simulation Laboratory. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 3(4) </volume> <pages> 353-387, </pages> <year> 1981. </year>
Reference-contexts: The existence of a suitable ordering is guaranteed by the restrictions imposed on the invariants by the system. Note also that planning/execution models are often in graphical constraint systems (e.g., <ref> [1] </ref>). 23 This section describes static invariants which impose a static restriction. Although this restriction may seem strong, it accommodates many models for applications such as satisfiability and graph coloring to name a few.
Reference: [2] <author> R. Fourer, D. Gay, and B.W. Kernighan. AMPL: </author> <title> A Modeling Language for Mathematical Programming. </title> <publisher> The Scientific Press, </publisher> <address> San Francisco, CA, </address> <year> 1993. </year>
Reference-contexts: The two approaches have complementary strengths, weaknesses, and application areas. The design of global search algorithms is now supported by a variety of tools, ranging from modeling languages such as AMPL <ref> [2] </ref> and Numerica [10] to constraint programming languages such CHIP, Ilog Solver, CLP (&lt;), Prolog-IV, and Oz to name only a few.
Reference: [3] <author> D. Johnson, C. Aragon, L. McGeoch, and C. Schevon. </author> <title> Optimization by Simulated Annealing: An Experimental Evaluation; Part I, Graph Partitioning. </title> <journal> Operations Research, </journal> <volume> 37(6) </volume> <pages> 865-893, </pages> <year> 1989. </year>
Reference-contexts: However, there are many applications in scheduling or resource allocation where such invariants occur naturally. For instance, a scheduling application may be modeled in terms of an invariant start <ref> [3] </ref> := max (end [prec [3]]; end [disj [3]]); where start [i] represents the starting date of task i, prec [i] the predecessor of the task in the job and disj [i], the predecessor of task i in the disjunction. <p> However, there are many applications in scheduling or resource allocation where such invariants occur naturally. For instance, a scheduling application may be modeled in terms of an invariant start <ref> [3] </ref> := max (end [prec [3]]; end [disj [3]]); where start [i] represents the starting date of task i, prec [i] the predecessor of the task in the job and disj [i], the predecessor of task i in the disjunction. <p> However, there are many applications in scheduling or resource allocation where such invariants occur naturally. For instance, a scheduling application may be modeled in terms of an invariant start <ref> [3] </ref> := max (end [prec [3]]; end [disj [3]]); where start [i] represents the starting date of task i, prec [i] the predecessor of the task in the job and disj [i], the predecessor of task i in the disjunction. <p> 250 90 1 49.32 8.89 5.54 random 500 90 1 162.7 29.6 4.88 cooked 125 4 22.09 4.18 5.28 cooked 250 1 37.22 7.79 4.77 cooked 500 2 240.3 49.9 4.80 average 4.82 Table 3: Graph Coloring: Efficiency of Localizer 5.3 Graph Partitioning The problem has been studied experimentally in <ref> [3] </ref> and, once again, the experiments reported here are based on a similar setting. Table 4 depicts the experimental results of Localizer. <p> The first row gives the setting of our parameters: T is the starting temperature, T F is the percentage of reduction of the temperature, SF is the size factor and the remaining two were described previously. Table 5 compares Localizer with the results reported in <ref> [3] </ref>. 5.4 Job-Shop Scheduling To conclude, we report some preliminary results on job-shop scheduling. Localizer has been evaluated on a set of 28 classic benchmarks.
Reference: [4] <author> D. Johnson, C. Aragon, L. McGeoch, and C. Schevon. </author> <title> Optimization by Simulated Annealing: An Experimental Evaluation; Part II, Graph Coloring and Number Partitioning. </title> <journal> Operations Research, </journal> <volume> 39(3) </volume> <pages> 378-406, </pages> <year> 1991. </year>
Reference-contexts: The design of local search algorithms is not an easy task however. The same problem can be modeled in many different ways (see for instance <ref> [4] </ref>), making the design process an inherently experimental enterprise. In addition, efficient implementations of local search algorithms often require maintaining complex data structures incrementally, which is a tedious and error-prone activity. <p> & select j from C [k] where A [i; j] g; f : int = sum (i in 1..n) (2fisize (C [i])fisize (B [i]) size (C [i]) 2 ) countB : int = sum (i in 1..n) size (B [i]); is taken from a graph-coloring model implementing an algorithm in <ref> [4] </ref>. The graph-coloring problem amounts to finding the smallest number of colors to label a graph such that that adjacent vertices have different colors. For a graph with n vertices, the algorithm considers n colors which are the integers between 1 and n. <p> Note that this comparison is not perfect (e.g., the randomization may be different) but it is sufficient for showing that Localizer can be implemented efficiently. 5.2 Graph Coloring Graph coloring was the object of an extensive experimental evaluation in <ref> [4] </ref> and this section reports on experimental results along the same lines. The experiments were conducted on graphs of densities 10, 50, and 90 and of sizes 125, 250, and 500. They were also conducted on so-called "cooked" graphs. Because of the nature of the experimental results reported in [4], it <p> in <ref> [4] </ref> and this section reports on experimental results along the same lines. The experiments were conducted on graphs of densities 10, 50, and 90 and of sizes 125, 250, and 500. They were also conducted on so-called "cooked" graphs. Because of the nature of the experimental results reported in [4], it is not easy to compare the efficiency of Localizer to the efficiency of their algorithm. As a consequence, a very efficient C implementation of their algorithm was built from scratch by a graduate student who was closely supervised to obtain a very efficient incremental algorithm. <p> can judge, the timings and the quality of this algorithm seem 29 V C I L G R 2 120 516 600 40.73 14.00 2.91 4 150 645 1500 154.68 45.00 3.44 6 250 1062 2500 823.06 246.00 3.35 Av. 3.38 Table 1: GSAT: Experimental Results consistent with those in <ref> [4] </ref>. In addition, this algorithm is the most efficient implementation built by a graduate student in the combinatorial optimization class at Brown (CS-258) in the last three years (for the given model of course). <p> The Localizer model is about one page long. Quality of the Solutions Table 2 describes the quality of the coloring found by Lo-calizer. These results agree with those of the C implementation and with those reported in <ref> [4] </ref>. Each set of rows corresponds to a class of graphs and to 100 executions of Local-izer on graphs from this class. The rows in each set report on the various values found by Localizer on these graphs and their frequencies.
Reference: [5] <author> L. Michel, P. Van Hentenryck. Localizer: </author> <title> A Modeling Language for Local Search. </title> <booktitle> In Second International Conference on Principles and Practice of Constraint Programming (CP'97), </booktitle> <address> Linz, Austria, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: The same problem can be modeled in many different ways (see for instance [4]), making the design process an inherently experimental enterprise. In addition, efficient implementations of local search algorithms often require maintaining complex data structures incrementally, which is a tedious and error-prone activity. Localizer <ref> [5] </ref> is a domain-specific language for the implementation of local search algorithms, combining aspects of declarative and imperative programming, since both are 1 important in local search algorithms. <p> To substantiate this claim, we presented a progress report on the domain-specific language Localizer, introduced in <ref> [5] </ref>. Localizer statements are organized around the traditional concepts of local search and may exploit the special structure of the problem at hand.
Reference: [6] <author> Marco Trubian Mauro Dell'Amico. </author> <title> Applying tabu search to the job-shop scheduling problem. </title> <journal> Annals of Operations Research, </journal> <volume> 41 </volume> <pages> 231-252, </pages> <year> 1993. </year>
Reference-contexts: The experiments were conducted in a fashion similar to what is reported in <ref> [6] </ref>. The parameters were defined as follow: * The maximal number of searches (maxSearches) is 1 * The maximal number of iterations for the inner loop (maxTrials) is 12000. * The tabu list has a varying length constrained in between 5 and 30. <p> Moreover, the length is varied according to the rule of <ref> [6] </ref>. * Contrary to [6], the model does not use a restarting strategy. 32 Graph Results (T=10,TF=0.95,SF=16,chPerc=2%,Cutoff=10%) Class V ertices Density SB F req: Localizer random 124 2 11-13 14-16 17-19 33 38 29 2.22 random 4 55-59 60-65 66-77 30 34 36 2.40 random 8 159-174 175-190 191- 23 53 <p> Moreover, the length is varied according to the rule of <ref> [6] </ref>. * Contrary to [6], the model does not use a restarting strategy. 32 Graph Results (T=10,TF=0.95,SF=16,chPerc=2%,Cutoff=10%) Class V ertices Density SB F req: Localizer random 124 2 11-13 14-16 17-19 33 38 29 2.22 random 4 55-59 60-65 66-77 30 34 36 2.40 random 8 159-174 175-190 191- 23 53 24 3.24 random 16 <p> These results cannot be really compared with the results of <ref> [6] </ref>, since the neighborhood used in their experiment is (RN 1 [ RN 2) while the model used here relies on N 1 alone.
Reference: [7] <author> C.H. Papadimitriou and K. Steiglitz. </author> <title> Combinatorial Optimization: Algorithms and Complexity. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1982. </year> <month> 36 </month>
Reference-contexts: Experimental results indicate that Localizer can be implemented to run with an efficiency comparable to specific implementations. Our current research focuses on building higher-level data structures to simplify the design of invariants which are the cornerstone of the language. Extending the strategies to accommodate dynamic k-opt <ref> [7] </ref>, genetic algorithms, constraint techniques are also contemplated. Longer term research will explore how Localizer can be turned into a programming language library to guarantee extensibility and wide applicability for expert users, while preserving the right level of abstraction. Acknowledgments This paper is dedicated to the memory of Paris C.
Reference: [8] <author> B. Selman, H. Levesque, and D. Mitchell. </author> <title> A New Method for Solving Hard Satisfiability Problems. </title> <booktitle> In AAAI-92, </booktitle> <pages> pages 440-446, </pages> <year> 1992. </year>
Reference-contexts: A clause is satisfied as soon as at least one of its positive atoms is true or at least one of its negative atoms is false. The local search model considered for Boolean satisfiability is based on the GSAT algorithm by Selman et al. in <ref> [8] </ref>, where the local search moves consist of flipping the truth value of an atom. A local improvement model for Boolean satisfiability is described in Figure 3. <p> To demonstrate practicability, we experimented with Localizer on several problems: GSAT, graph coloring, graph partitioning, and job-shop scheduling. 5.1 GSAT GSAT is generally recognized as a fast and very well implemented system. The experimental results were carried out as specified in <ref> [8] </ref>. Table 1 gives the number of variables (V ), the number of clauses (C), and MaxTrials (I) for each size of benchmarks as well as the CPU times in seconds of Localizer (L), the CPU times in seconds of GSAT (G) as reported in [8], and the ratio L=G. <p> carried out as specified in <ref> [8] </ref>. Table 1 gives the number of variables (V ), the number of clauses (C), and MaxTrials (I) for each size of benchmarks as well as the CPU times in seconds of Localizer (L), the CPU times in seconds of GSAT (G) as reported in [8], and the ratio L=G. The times of GSAT are given on a SGI Challenge with a 70 MHz MIPS R4400 processor. The times of Localizer were obtained on a SUN SPARC-10 40MHz and scaled by a factor 1.5 to account for the speed difference between the two machines.
Reference: [9] <author> P. Stuckey and V. Tam. </author> <title> Models for Using Stochastic Constraint Solvers in Constraint Logic Programming. </title> <booktitle> In PLILP-96, </booktitle> <address> Aachen, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: In contrast, little attention has been devoted to the support of local search, despite the increasing interest in these algorithms in recent years. (Note however there are various efforts to integrate local search in CLP languages, e.g., <ref> [9] </ref>). The design of local search algorithms is not an easy task however. The same problem can be modeled in many different ways (see for instance [4]), making the design process an inherently experimental enterprise.
Reference: [10] <author> P. Van Hentenryck, L. Michel, and Y. Deville. </author> <title> Numerica: a Modeling Language for Global Optimization. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1997. </year> <month> 37 </month>
Reference-contexts: The two approaches have complementary strengths, weaknesses, and application areas. The design of global search algorithms is now supported by a variety of tools, ranging from modeling languages such as AMPL [2] and Numerica <ref> [10] </ref> to constraint programming languages such CHIP, Ilog Solver, CLP (&lt;), Prolog-IV, and Oz to name only a few. <p> The second set is matched with the second field of the record and denotes the negative atoms of the clause. 3.2.3 Generic Data Localizer also supports the concepts of generic data which was introduced in Numerica <ref> [10] </ref>. The basic idea here is to initialize the data using an expression which may depend on parameters of the declaration. Genericity is especially attractive to define derived data which are then used to simplify the model.
References-found: 10

