URL: http://www.cs.washington.edu/education/courses/548/CurrentQtr/atom/atom2.ps
Refering-URL: http://www.cs.washington.edu/education/courses/548/CurrentQtr/
Root-URL: 
Title: M A R C H  ATOM: A System for Building Customized Program Analysis Tools  
Author: Amitabh Srivastava Alan Eustace 
Date: 94/2  
Pubnum: 1 9 9 4 Research Report  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Anant Agarwal, Richard Sites, and Mark Horwitz. ATUM: </author> <title> A New Technique for Capturing Address Traces Using Microcode. </title> <booktitle> Proceedings of the 13th International Symposium on Computer Architecture, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: Tracing and analysis on the WRL Titan [3] communicated via shared memory but required operating system modifications. MPTRACE [6] is also similar to Pixie but it collects traces for multiprocessors by instrumenting assembly code. ATUM <ref> [1] </ref> generates address traces by modifying microcode and saves a compressed trace in a file that is analyzed offline. The third class of tools consists of simulators. Tango Lite [7] supports multiprocessor simulation by instrumenting assembly language code.
Reference: [2] <author> Robert Bedichek. </author> <title> Some Efficient Architectures Simulation Techniques. </title> <booktitle> Winter 1990 USENIX Conference, </booktitle> <month> January </month> <year> 1990. </year>
Reference-contexts: The third class of tools consists of simulators. Tango Lite [7] supports multiprocessor simulation by instrumenting assembly language code. PROTEUS [4] also supports multiprocessor simulation but instrumentation is done by the compiler. g88 <ref> [2] </ref> simulates Motorola 88000 using threaded interpreter techniques. Shade [5] attempts to address the problem of large address traces by allowing selective generation of traces but has to resort to instruction-level simulation. These existing tools have several limitations.
Reference: [3] <author> Anita Borg, R.E. Kessler, Georgia Lazana, and David Wall. </author> <title> Long Address Traces from RISC Machines: Generation and Analysis, </title> <booktitle> Proceedings of the 17th Annual Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1990, </year> <note> also available as WRL Research Report 89/14, </note> <month> Sep </month> <year> 1989. </year>
Reference-contexts: The second class consists of address tracing tools that generate data and instruction traces. Pixie and QPT also generate address traces and communicate trace data to analysis routines through inter-process communication. Tracing and analysis on the WRL Titan <ref> [3] </ref> communicated via shared memory but required operating system modifications. MPTRACE [6] is also similar to Pixie but it collects traces for multiprocessors by instrumenting assembly code. ATUM [1] generates address traces by modifying microcode and saves a compressed trace in a file that is analyzed offline.
Reference: [4] <author> Eric A. Brewer, Chrysanthos N. Dellarocas, Adrian Colbrook, and William E. Weihl. PROTEUS: </author> <title> A High-Performance Parallel-Architecture Simulator. </title> <publisher> MIT/LCS/TR-516, MIT, </publisher> <year> 1991. </year>
Reference-contexts: ATUM [1] generates address traces by modifying microcode and saves a compressed trace in a file that is analyzed offline. The third class of tools consists of simulators. Tango Lite [7] supports multiprocessor simulation by instrumenting assembly language code. PROTEUS <ref> [4] </ref> also supports multiprocessor simulation but instrumentation is done by the compiler. g88 [2] simulates Motorola 88000 using threaded interpreter techniques. Shade [5] attempts to address the problem of large address traces by allowing selective generation of traces but has to resort to instruction-level simulation.
Reference: [5] <author> Robert F. Cmelik and David Keppel, Shade: </author> <title> A Fast Instruction-Set Simulator for Execution Profiling. </title> <type> Technical Report UWCSE 93-06-06, </type> <institution> University of Washington. </institution>
Reference-contexts: The third class of tools consists of simulators. Tango Lite [7] supports multiprocessor simulation by instrumenting assembly language code. PROTEUS [4] also supports multiprocessor simulation but instrumentation is done by the compiler. g88 [2] simulates Motorola 88000 using threaded interpreter techniques. Shade <ref> [5] </ref> attempts to address the problem of large address traces by allowing selective generation of traces but has to resort to instruction-level simulation. These existing tools have several limitations. First, most tools are designed to perform a single specific type of instrumentation, typically block counting or address tracing.
Reference: [6] <author> Susan J. Eggers, David R. Keppel, Eric J. Koldinger, and Henry M. Levy. </author> <title> Techniques for Efficient Inline Tracing on a Shared-Memory Multiprocessor. </title> <booktitle> SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <volume> vol 8, no 1, </volume> <month> May </month> <year> 1990. </year> <title> 17 ATOM: A SYSTEM FOR BUILDING CUSTOMIZED PROGRAM ANALYSIS TOOLS </title>
Reference-contexts: The second class consists of address tracing tools that generate data and instruction traces. Pixie and QPT also generate address traces and communicate trace data to analysis routines through inter-process communication. Tracing and analysis on the WRL Titan [3] communicated via shared memory but required operating system modifications. MPTRACE <ref> [6] </ref> is also similar to Pixie but it collects traces for multiprocessors by instrumenting assembly code. ATUM [1] generates address traces by modifying microcode and saves a compressed trace in a file that is analyzed offline. The third class of tools consists of simulators.
Reference: [7] <author> Stephen R. Goldschmidt and John L. Hennessy, </author> <title> The Accuracy of Trace-Driven Simulations of Multiprocessors. </title> <institution> CSL-TR-92-546, Computer Systems Laboratory, Stanford University, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: MPTRACE [6] is also similar to Pixie but it collects traces for multiprocessors by instrumenting assembly code. ATUM [1] generates address traces by modifying microcode and saves a compressed trace in a file that is analyzed offline. The third class of tools consists of simulators. Tango Lite <ref> [7] </ref> supports multiprocessor simulation by instrumenting assembly language code. PROTEUS [4] also supports multiprocessor simulation but instrumentation is done by the compiler. g88 [2] simulates Motorola 88000 using threaded interpreter techniques.
Reference: [8] <author> James R. Larus and Thomas Ball. </author> <title> Rewriting executable files to measure program behavior. </title> <journal> Software, Practice and Experience, </journal> <volume> vol 24, no. 2, </volume> <pages> pp 197-218, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Over the past decade three classes of tools for different machines and applications have been developed. The first class consists of basic block counting tools like Pixie [9], Epoxie [14] and QPT <ref> [8] </ref> that count the number of times each basic block is executed. The second class consists of address tracing tools that generate data and instruction traces. Pixie and QPT also generate address traces and communicate trace data to analysis routines through inter-process communication.
Reference: [9] <institution> MIPS Computer Systems, Inc. Assembly Language Programmer's Guide, </institution> <year> 1986. </year>
Reference-contexts: Over the past decade three classes of tools for different machines and applications have been developed. The first class consists of basic block counting tools like Pixie <ref> [9] </ref>, Epoxie [14] and QPT [8] that count the number of times each basic block is executed. The second class consists of address tracing tools that generate data and instruction traces. Pixie and QPT also generate address traces and communicate trace data to analysis routines through inter-process communication.
Reference: [10] <author> Richard L. Sites, ed. </author> <title> Alpha Architecture Reference Manual Digital Press, </title> <year> 1992. </year>
Reference-contexts: Pixie maintains three memory locations that have the values of these three registers, and replaces the use of these registers by uses of the memory locations. 7 Alpha <ref> [10] </ref> has a signed 21-bit pc-relative subroutine branch instruction. 8 The application may contain hand-crafted assembly language code that often does not follow standard conven tions.
Reference: [11] <author> Amitabh Srivastava and David W. Wall. </author> <title> A Practical System for Intermodule Code Optimization at Link-Time. </title> <journal> Journal of Programming Language, </journal> <volume> 1(1), </volume> <pages> pp 1-18, </pages> <month> March </month> <year> 1993. </year> <note> Also available as WRL Research Report 92/6, </note> <month> December </month> <year> 1992. </year>
Reference-contexts: More importantly, the analysis routine is always presented with the information (data and text addresses) about the application program as if it was executing uninstrumented. Section 4 describes how the system guarantees the precise information. ATOM, built using OM <ref> [11] </ref>, is independent of any compiler and language system because it operates on object-modules. <p> bstats [n].taken++; else bstats [n].notTaken++; g void PrintBranch (int n, long pc)f fprintf (file, 0x%lx nt %d nt %dnn, pc, bstats [n].taken, bstats [n].notTaken); g void CloseFile ()f fclose (file); g 8 ATOM: A SYSTEM FOR BUILDING CUSTOMIZED PROGRAM ANALYSIS TOOLS 4 Implementation of ATOM ATOM is built using OM <ref> [11] </ref>, a link-time code modification system. OM takes as input a collection of object files and libraries that make up a complete program, builds a symbolic intermediate representation, applies instrumentation and optimizations [12, 13] to the intermediate representation, and finally outputs an executable. <p> It uses OM's infrastructure to build symbolic representations of the application program and the analysis routines. The traversal and query primitives interface with the intermediate representation of the program to provide the information requested. More details of OM's intermediate representation and how it is built are described in <ref> [11] </ref>. We extended the OM's representation so it can be conveniently annotated for procedure call insertions. OM's code generation pass builds the instrumented executable from the intermediate representation. <p> This optimization is available in the current implementation. The number of registers that need to be saved may be further reduced by computing live registers in the application program. OM can do interprocedural live variable analysis <ref> [11] </ref> and compute all registers live at a point. Only the live registers need to be saved and restored to preserve the state of the program execution. Optimizations such as inlining further reduce the overhead of procedure calls at the cost of increasing the code size.
Reference: [12] <author> Amitabh Srivastava and David W. Wall. </author> <title> Link-Time Optimization of Address Calculation on a 64-bit Architecture. Proceedings of the SIGPLAN'94 Conference on Programming Language Design and Implementation, </title> <note> to appear. Also available as WRL Research Report 94/1, </note> <month> February </month> <year> 1994. </year>
Reference-contexts: OM takes as input a collection of object files and libraries that make up a complete program, builds a symbolic intermediate representation, applies instrumentation and optimizations <ref> [12, 13] </ref> to the intermediate representation, and finally outputs an executable. ATOM starts by linking the user's instrumentation routines with OM using the standard linker to produce a custom tool. This tool is given as input the application program and the analysis routines.
Reference: [13] <author> Amitabh Srivastava. </author> <title> Unreachable procedures in object-oriented programming, </title> <journal> ACM LOPLAS, </journal> <volume> Vol 1, #4, </volume> <pages> pp 355-364, </pages> <month> December </month> <year> 1992. </year> <note> Also available as WRL Research Report 93/4, </note> <month> August </month> <year> 1993. </year>
Reference-contexts: OM takes as input a collection of object files and libraries that make up a complete program, builds a symbolic intermediate representation, applies instrumentation and optimizations <ref> [12, 13] </ref> to the intermediate representation, and finally outputs an executable. ATOM starts by linking the user's instrumentation routines with OM using the standard linker to produce a custom tool. This tool is given as input the application program and the analysis routines.

References-found: 13

