URL: http://www.csc.ncsu.edu/faculty/riely/papers/97TR-loc-fail.ps.gz
Refering-URL: http://www.csc.ncsu.edu/faculty/riely/papers.html
Root-URL: http://www.csc.ncsu.edu
Title: Distributed Processes and Location Failures  
Author: James Riely and Matthew Hennessy 
Address: Brighton BN1 9QH ISSN 13503170  
Date: 2/97 25 April 1997  
Affiliation: UNIVERSITY OF SUSSEX COMPUTER SCIENCE  Computer Science School of Cognitive and Computing Sciences University of Sussex  
Pubnum: Report  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Samson Abramsky. </author> <title> The lazy lambda calculus. </title> <editor> In David Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, UT Year of Programming Series, </booktitle> <pages> pages 65117. </pages> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The use of ccs for CCS has been justified in [29] by the fact that it coincides with the congruence obtained from a simple notion of observation called barbed bisimulation. Similar results have been obtained for lazy and eager functional languages <ref> [1, 18, 7] </ref>, giving further evidence for the reasonableness of this approach.
Reference: [2] <author> Luca Aceto. </author> <title> A static view of localities. </title> <journal> Formal Aspects of Computing, </journal> <pages> pages 201222, </pages> <year> 1994. </year>
Reference-contexts: C Comparison with other equivalences In this appendix we show that LF-equivalence differs from all of the location- and cause-based equivalences that we are aware of. The equivalences we discuss have been characterized in many ways. The location-based equivalences have been studied, for example, in <ref> [8, 2, 9, 25, 27, 11] </ref>; the cause-based equivalences have appeared, for example, in [12, 13]. Comparisons between these approaches appear in [21, 25, 14]. Most of these equivalences are defined for CCS, which does not have explicitly located processes.
Reference: [3] <author> R. Amadio and S. Prasad. </author> <title> Localities and failures. </title> <booktitle> In Proc. 14th Foundations of Software Technology and Theoretical Computer Science, volume 880 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Our work is motivated by the papers <ref> [3, 16] </ref>. In these papers, distributed languages with location failures are defined and shown to be very expressive. In both of these papers, the semantics is based on barbed equivalence, which requires quantification over all program contexts and thus is difficult to use directly. <p> While these translations provide theoretical results about the relative expressiveness of distributed and interleaving calculi, they are sufficiently complicated to make reasoning about examples, even simple ones, very difficult. By restricting attention to an asynchronous language, Amadio [4] has recently improved on the results of <ref> [3] </ref>, providing simpler translations. Although our work developed independently of [4], the language we study has much in common with the language developed there. <p> The syntax of processes is parameterized with respect to several syntactic sets. We assume a set Loc of locations k, `, m and a set PConst of process constants A, used to define recursive processes. As in <ref> [3] </ref>, we presume that the set of locations includes a distinguished element ? 2 Loc, which represents an unfailing or immortal location; this location behaves differently from all others in that it cannot be killed. <p> For example P Q if for every context C [] such that C [P] and C [Q] are configurations, C [P] : Distributed Processes and Location Failures 10 Although some results concerning translations between languages have been obtained using the definition of barbed equivalence directly <ref> [3, 16] </ref>, the relation is obscure and difficult to use in practice because it requires quantification over all contexts. To show processes are distinguished it is neccessary to find a live set and a context for which the resulting configurations are not barbed bisimular. <p> It is also unchanged if one removes the spawn operator but retains the conditional. Neither does it change if we disallow terms of the form kill k:p where p 6= nil. Further it is unaffected if one allows distributed choices, using a syntax closer to that of <ref> [3] </ref>. Distributed Processes and Location Failures 35 Related work.. Site failure has also played a role in languages studied in [3, 4, 16]. In these papers abstract languages based on Facile [17] or the pi-calculus [24, 5] are studied. <p> Further it is unaffected if one allows distributed choices, using a syntax closer to that of [3]. Distributed Processes and Location Failures 35 Related work.. Site failure has also played a role in languages studied in <ref> [3, 4, 16] </ref>. In these papers abstract languages based on Facile [17] or the pi-calculus [24, 5] are studied. The original motivation for this paper was to provide an alternative characterization of barbed equivalence for languages such as these. <p> Although we have not treated value passing or references, we postulate that our results can be extended in a straightforward way to value-passing languages which retain the assumption that all failures are independent, such as the languages in <ref> [3, 4] </ref>. More delicate is the extension to languages such as the distributed join-calculus [16] in which the independence assumption is dropped. In this case the logical language used for symbolic bisimulations must be extended to allow statements about the interdependence of locations; we leave this to future work.
Reference: [4] <author> Roberto Amadio. </author> <title> An asynchronous model of locality, failure, and process mobility. </title> <type> Technical report, </type> <institution> Laboratoire d'Informatique de Marseille, </institution> <year> 1997. </year> <month> February. </month>
Reference-contexts: While these translations provide theoretical results about the relative expressiveness of distributed and interleaving calculi, they are sufficiently complicated to make reasoning about examples, even simple ones, very difficult. By restricting attention to an asynchronous language, Amadio <ref> [4] </ref> has recently improved on the results of [3], providing simpler translations. Although our work developed independently of [4], the language we study has much in common with the language developed there. <p> By restricting attention to an asynchronous language, Amadio <ref> [4] </ref> has recently improved on the results of [3], providing simpler translations. Although our work developed independently of [4], the language we study has much in common with the language developed there. The main difference is that our language has no value-passing, allowing us to concentrate on the effects of location failure and simplifying the statement of many of our results. <p> Further it is unaffected if one allows distributed choices, using a syntax closer to that of [3]. Distributed Processes and Location Failures 35 Related work.. Site failure has also played a role in languages studied in <ref> [3, 4, 16] </ref>. In these papers abstract languages based on Facile [17] or the pi-calculus [24, 5] are studied. The original motivation for this paper was to provide an alternative characterization of barbed equivalence for languages such as these. <p> Although we have not treated value passing or references, we postulate that our results can be extended in a straightforward way to value-passing languages which retain the assumption that all failures are independent, such as the languages in <ref> [3, 4] </ref>. More delicate is the extension to languages such as the distributed join-calculus [16] in which the independence assumption is dropped. In this case the logical language used for symbolic bisimulations must be extended to allow statements about the interdependence of locations; we leave this to future work.
Reference: [5] <author> Roberto Amadio, Ilaria Castellani, and Davide Sangiorgi. </author> <title> On bisimulations for the asynchronous p-calculus. </title> <editor> In U. Montanari and V. Sassone, editors, </editor> <booktitle> CONCUR: Proceedings of the International Conference on Concurrency Theory, volume 1119 of Lecture Notes in Computer Science, </booktitle> <pages> pages 147162, </pages> <address> Pisa, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: Our terminology is inspired by that of <ref> [29, 5] </ref>, in which barbed equivalence is defined by closing over static contexts (that is, those contexts built up using only parallel composition, restriction and renaming) and barbed congruence is defined by closing over all contexts, including dynamic contexts such as [] + a. <p> Distributed Processes and Location Failures 35 Related work.. Site failure has also played a role in languages studied in [3, 4, 16]. In these papers abstract languages based on Facile [17] or the pi-calculus <ref> [24, 5] </ref> are studied. The original motivation for this paper was to provide an alternative characterization of barbed equivalence for languages such as these.
Reference: [6] <author> J. C. M. Baeten and W. P. Weijland. </author> <title> Process Algebra, </title> <booktitle> volume 18 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Many semantic theories have been proposed for concurrent processes <ref> [23, 20, 6] </ref>. Although these theories have been fruitfully applied to the analysis of some distributed systems, for the most part they ignore an essential feature of such systems, namely their distribution.
Reference: [7] <author> G. Boudol. </author> <title> A lambda calculus for (strict) parallel functions. </title> <journal> Information and Control, </journal> <volume> 108:51127, </volume> <year> 1994. </year>
Reference-contexts: The use of ccs for CCS has been justified in [29] by the fact that it coincides with the congruence obtained from a simple notion of observation called barbed bisimulation. Similar results have been obtained for lazy and eager functional languages <ref> [1, 18, 7] </ref>, giving further evidence for the reasonableness of this approach.
Reference: [8] <author> G. Boudol, I. Castellani, M. Hennessy, and A. Kiehn. </author> <title> A theory of processes with localities. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6:165200, </volume> <year> 1994. </year>
Reference-contexts: Using the semantic theories mentioned above it would be difficult to distinguish between these implementations, as the only difference between them is the location at which activity occurs. We aim to develop a useful extensional theory of systems which would take this type of property into account. In <ref> [8, 25, 11] </ref> such theories have been proposed. All of these theories, however, are based on a very strong assumption: that an observer, or user, can determine the location at which every action is performed. <p> In this case the logical language used for symbolic bisimulations must be extended to allow statements about the interdependence of locations; we leave this to future work. A number of location-based equivalences already exist in the literature <ref> [8, 9, 25, 27, 11] </ref>; however, none of these theories addresses the possible failure of sites. Their emphasis, rather, is to define a measure of the concurrency or distribution of a process: two processes are deemed equivalent only if, informally, they have the same degree of concurrency. <p> C Comparison with other equivalences In this appendix we show that LF-equivalence differs from all of the location- and cause-based equivalences that we are aware of. The equivalences we discuss have been characterized in many ways. The location-based equivalences have been studied, for example, in <ref> [8, 2, 9, 25, 27, 11] </ref>; the cause-based equivalences have appeared, for example, in [12, 13]. Comparisons between these approaches appear in [21, 25, 14]. Most of these equivalences are defined for CCS, which does not have explicitly located processes. <p> Below, we list the equivalences we consider; the interested reader should refer to the original papers for further information. * CCS interleaving equivalence [23] was defined in Section 2.3. * Causal (C) equivalence [12] distinguishes processes based on the causality of actions. * Locations (L) equivalence <ref> [8] </ref> distinguishes processes based on the local causality of actions. * Local/Global (LG) equivalence [21] distinguishes processes based on a combination of their local and global causes; it is strictly finer than the intersection of the C- and L-equivalences. * Located Action (LA) equivalence [27, 11] is a finer form of
Reference: [9] <author> I. Castellani. </author> <title> Observing distribution in processes: static and dynamic localities. </title> <journal> International Journal of Foundations of Computer Science, </journal> <volume> 6(6):353393, </volume> <year> 1995. </year>
Reference-contexts: In this case the logical language used for symbolic bisimulations must be extended to allow statements about the interdependence of locations; we leave this to future work. A number of location-based equivalences already exist in the literature <ref> [8, 9, 25, 27, 11] </ref>; however, none of these theories addresses the possible failure of sites. Their emphasis, rather, is to define a measure of the concurrency or distribution of a process: two processes are deemed equivalent only if, informally, they have the same degree of concurrency. <p> C Comparison with other equivalences In this appendix we show that LF-equivalence differs from all of the location- and cause-based equivalences that we are aware of. The equivalences we discuss have been characterized in many ways. The location-based equivalences have been studied, for example, in <ref> [8, 2, 9, 25, 27, 11] </ref>; the cause-based equivalences have appeared, for example, in [12, 13]. Comparisons between these approaches appear in [21, 25, 14]. Most of these equivalences are defined for CCS, which does not have explicitly located processes.
Reference: [10] <author> R. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The concurrency workbench: A semantics-based tool for the verification of finite-state systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1):3672, </volume> <month> January </month> <year> 1993. </year>
Reference-contexts: Since both strong and weak LF-equivalence are defined using bisimulations, the problem of deciding that two systems are semantically congruent can, in principle, be solved using standard proof techniques associated with bisimulation <ref> [23, 10] </ref>. However, constructing an LF-bisimulation requires that one consider the behavior of the systems under all possible sequences of kills, by both the systems themselves and the environment. The number of states that must be explored may be exponentially larger than the number needed to construct a CCS bisimulation. <p> In Appendix C we give a series of counterexamples which show that u is incomparable with all of the equivalences proposed in these papers. Implementation issues.. For finite-state processes, one can check LF-bisimulation automatically, either by using the concrete semantics and a tool such as the Concurrency Workbench <ref> [10] </ref>, or by using the symbolic semantics and adapting the algorithm given by Hennessy and Lin [19]. In implementing the symbolic techniques, it would be convenient to have a decision procedure for entailment between formulae. In the strong case, where the formulae are Boolean, such decision procedures are well known.
Reference: [11] <author> Flavio Corradini. </author> <title> Space, Time and Nondeterminism in Process Algebras. </title> <type> PhD thesis, </type> <institution> UniversitOEa Degli Studi di Roma La Sapienza, </institution> <year> 1996. </year> <title> Distributed Processes and Location Failures 42 </title>
Reference-contexts: Using the semantic theories mentioned above it would be difficult to distinguish between these implementations, as the only difference between them is the location at which activity occurs. We aim to develop a useful extensional theory of systems which would take this type of property into account. In <ref> [8, 25, 11] </ref> such theories have been proposed. All of these theories, however, are based on a very strong assumption: that an observer, or user, can determine the location at which every action is performed. <p> In this case the logical language used for symbolic bisimulations must be extended to allow statements about the interdependence of locations; we leave this to future work. A number of location-based equivalences already exist in the literature <ref> [8, 9, 25, 27, 11] </ref>; however, none of these theories addresses the possible failure of sites. Their emphasis, rather, is to define a measure of the concurrency or distribution of a process: two processes are deemed equivalent only if, informally, they have the same degree of concurrency. <p> C Comparison with other equivalences In this appendix we show that LF-equivalence differs from all of the location- and cause-based equivalences that we are aware of. The equivalences we discuss have been characterized in many ways. The location-based equivalences have been studied, for example, in <ref> [8, 2, 9, 25, 27, 11] </ref>; the cause-based equivalences have appeared, for example, in [12, 13]. Comparisons between these approaches appear in [21, 25, 14]. Most of these equivalences are defined for CCS, which does not have explicitly located processes. <p> of actions. * Locations (L) equivalence [8] distinguishes processes based on the local causality of actions. * Local/Global (LG) equivalence [21] distinguishes processes based on a combination of their local and global causes; it is strictly finer than the intersection of the C- and L-equivalences. * Located Action (LA) equivalence <ref> [27, 11] </ref> is a finer form of locations equivalence in which location names appear in the syntax of the language, as they do in our language. * Located Failure (LF) equivalence is the relation studied in this paper. * Located Failure/Located Action (LF/LA) is defined to be the intersection of the
Reference: [12] <author> P. Darondeau and P. Degano. </author> <title> Causal trees. </title> <editor> In G. Ausiello, M. Dezani-Ciancaglini, and S. Ronchi della Rocca, editors, </editor> <booktitle> Proceedings of the International Colloquium on Automata, Languages and Programming, volume 317 of Lecture Notes in Computer Science, </booktitle> <pages> pages 234248, </pages> <address> Stresa, Italy, July 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The equivalences we discuss have been characterized in many ways. The location-based equivalences have been studied, for example, in [8, 2, 9, 25, 27, 11]; the cause-based equivalences have appeared, for example, in <ref> [12, 13] </ref>. Comparisons between these approaches appear in [21, 25, 14]. Most of these equivalences are defined for CCS, which does not have explicitly located processes. <p> Below, we list the equivalences we consider; the interested reader should refer to the original papers for further information. * CCS interleaving equivalence [23] was defined in Section 2.3. * Causal (C) equivalence <ref> [12] </ref> distinguishes processes based on the causality of actions. * Locations (L) equivalence [8] distinguishes processes based on the local causality of actions. * Local/Global (LG) equivalence [21] distinguishes processes based on a combination of their local and global causes; it is strictly finer than the intersection of the C- and
Reference: [13] <author> P. Degano, R. De Nicola, and U. Montanari. </author> <title> Partial orderings descriptions and observations of nondeterministic concurrent processes. </title> <editor> In J.W. de Bakker, W.- P de Roever, and G. Rozenberg, editors, </editor> <title> Linear Time, Branching Time, and Partial Order in Logics and Models for Concurrency, </title> <booktitle> volume 354 of Lecture Notes in Computer Science, </booktitle> <pages> pages 438466. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1988. </year> <title> School/Workshop on Linear Time, Branching Time, and Partial Order in Logics and Models for Concurrency (1988: </title> <address> Noordwijkerhout, Netherlands). </address>
Reference-contexts: The equivalences we discuss have been characterized in many ways. The location-based equivalences have been studied, for example, in [8, 2, 9, 25, 27, 11]; the cause-based equivalences have appeared, for example, in <ref> [12, 13] </ref>. Comparisons between these approaches appear in [21, 25, 14]. Most of these equivalences are defined for CCS, which does not have explicitly located processes.
Reference: [14] <author> P. Degano and C. Priami. </author> <title> Causal trees. </title> <editor> In W. Kuich, editor, </editor> <booktitle> Proceedings of the International Colloquium on Automata, Languages and Programming, volume 623 of Lecture Notes in Computer Science, </booktitle> <pages> pages 629640. </pages> <publisher> Springer-Verlag, Wien, </publisher> <address> Austria, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: The equivalences we discuss have been characterized in many ways. The location-based equivalences have been studied, for example, in [8, 2, 9, 25, 27, 11]; the cause-based equivalences have appeared, for example, in [12, 13]. Comparisons between these approaches appear in <ref> [21, 25, 14] </ref>. Most of these equivalences are defined for CCS, which does not have explicitly located processes. To apply these definitions to terms in our language, we Distributed Processes and Location Failures 39 first perform an implicit syntactic transformation that removes explict location references from the terms.
Reference: [15] <author> Zohar Manna et al. </author> <title> STeP: The stanford temporal prover. </title> <type> Technical report, </type> <month> June </month> <year> 1994. </year>
Reference-contexts: One way to approach the implementation would be to marry a tool for temporal logic, such as the StEP prover <ref> [15] </ref>, to the existing implementation of Hennessy and Lin's algorithm. Other models of failure.. We have assumed a simple model in which failures are permanent and independent and the number of failures that can occur is unbounded. Our approach can also be adapted to other models of failure.
Reference: [16] <author> C. Fournet, G. Gonthier, J.J. Levy, L. Marganget, and D. Remy. </author> <title> A calculus of mobile agents. </title> <editor> In U. Montanari and V. Sassone, editors, </editor> <booktitle> CONCUR: Proceedings of the International Conference on Concurrency Theory, volume 1119 of Lecture Notes in Computer Science, </booktitle> <pages> pages 406421, </pages> <address> Pisa, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: Our work is motivated by the papers <ref> [3, 16] </ref>. In these papers, distributed languages with location failures are defined and shown to be very expressive. In both of these papers, the semantics is based on barbed equivalence, which requires quantification over all program contexts and thus is difficult to use directly. <p> For example P Q if for every context C [] such that C [P] and C [Q] are configurations, C [P] : Distributed Processes and Location Failures 10 Although some results concerning translations between languages have been obtained using the definition of barbed equivalence directly <ref> [3, 16] </ref>, the relation is obscure and difficult to use in practice because it requires quantification over all contexts. To show processes are distinguished it is neccessary to find a live set and a context for which the resulting configurations are not barbed bisimular. <p> Further it is unaffected if one allows distributed choices, using a syntax closer to that of [3]. Distributed Processes and Location Failures 35 Related work.. Site failure has also played a role in languages studied in <ref> [3, 4, 16] </ref>. In these papers abstract languages based on Facile [17] or the pi-calculus [24, 5] are studied. The original motivation for this paper was to provide an alternative characterization of barbed equivalence for languages such as these. <p> More delicate is the extension to languages such as the distributed join-calculus <ref> [16] </ref> in which the independence assumption is dropped. In this case the logical language used for symbolic bisimulations must be extended to allow statements about the interdependence of locations; we leave this to future work.
Reference: [17] <author> A. Giacalone, P. Mishra, and S. Prasad. </author> <title> A symmetric integration of concurrent and functional programming. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 18(2):121160, </volume> <year> 1989. </year>
Reference-contexts: Further it is unaffected if one allows distributed choices, using a syntax closer to that of [3]. Distributed Processes and Location Failures 35 Related work.. Site failure has also played a role in languages studied in [3, 4, 16]. In these papers abstract languages based on Facile <ref> [17] </ref> or the pi-calculus [24, 5] are studied. The original motivation for this paper was to provide an alternative characterization of barbed equivalence for languages such as these.
Reference: [18] <author> Andrew D. Gordon. </author> <title> Bisimilarity as a theory of functional programming. </title> <booktitle> In Mathematical Foundations of Programming Semantics, volume 1 of Electronic Notes in Theoretical Computer Science http://pigeon.elsevier.nl/mcs/tcs/pc/Menu.html. Elsevier, </booktitle> <year> 1995. </year>
Reference-contexts: The use of ccs for CCS has been justified in [29] by the fact that it coincides with the congruence obtained from a simple notion of observation called barbed bisimulation. Similar results have been obtained for lazy and eager functional languages <ref> [1, 18, 7] </ref>, giving further evidence for the reasonableness of this approach.
Reference: [19] <author> M. C. B. Hennessy and H. Lin. </author> <title> Symbolic bisimulations. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 138:353389, </address> <year> 1995. </year>
Reference-contexts: The number of states that must be explored may be exponentially larger than the number needed to construct a CCS bisimulation. Distributed Processes and Location Failures 4 In Section 4 we use the ideas of <ref> [19] </ref> to give alternative symbolic characterizations of LF-equivalence that can be decided using a much smaller state space. The idea is to replace the operational judgments L . P a 7! L 0 . <p> In the weak case, however, we require a more complicated logic that can express statements of the form site ` was alive at some point in the past. Using these symbolic transitions, the standard definition of symbolic bisimulation <ref> [19] </ref> requires only minor modification to capture ' and u; hence the symbolic proof techniques and tools of [19] may be used to check the new semantic equivalences proposed in this paper. Up to now the paper has concentrated on a semantic theory for located processes. <p> Using these symbolic transitions, the standard definition of symbolic bisimulation <ref> [19] </ref> requires only minor modification to capture ' and u; hence the symbolic proof techniques and tools of [19] may be used to check the new semantic equivalences proposed in this paper. Up to now the paper has concentrated on a semantic theory for located processes. <p> As one should expect, the weak case is quite a bit more subtle than the strong. By adapting the algorithms in <ref> [19] </ref>, one could derive an alternative method for automatically checking LF-equivalence on finite state processes. But the symbolic characterizations are not only useful for automated proof; they also greatly simplify reasoning by hand. To begin with, the symbolic graphs are typically an order of magnitude smaller than their concrete counterparts. <p> By rule induction in both directions. fl NOTATION. We use sets of locations L in logical formulae to denote the conjunction of the literals in L. Similarly, L represents the formula V As usual ff is shorthand for W 4.2 Strong symbolic bisimulation The standard definition of symbolic bisimulation <ref> [19] </ref> requires that we define entailment between formulae, which we do in the standard way: p fl r if and only if 8L : L * p implies L * r Note that entailment is a preorder on formulae. <p> The new semantic equivalences are justified in terms of barbed bisimulations [29]. We also give symbolic characterizations of the new equivalences which means that the equivalence can be investigated using the symbolic methods of <ref> [19] </ref>. The equivalences we have defined are quite robust in the sense that for many variations of the operators in our language, barbed equivalence and LF-equivalence coincide. <p> Implementation issues.. For finite-state processes, one can check LF-bisimulation automatically, either by using the concrete semantics and a tool such as the Concurrency Workbench [10], or by using the symbolic semantics and adapting the algorithm given by Hennessy and Lin <ref> [19] </ref>. In implementing the symbolic techniques, it would be convenient to have a decision procedure for entailment between formulae. In the strong case, where the formulae are Boolean, such decision procedures are well known. In the weak case, in which we use a linear-time temporal logic, more work is required.
Reference: [20] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: 1 Introduction Many semantic theories have been proposed for concurrent processes <ref> [23, 20, 6] </ref>. Although these theories have been fruitfully applied to the analysis of some distributed systems, for the most part they ignore an essential feature of such systems, namely their distribution.
Reference: [21] <author> A. Kiehn. </author> <title> Comparing locality and causality based equivalences. </title> <journal> Acta Informatica, </journal> <volume> 31(8):697718, </volume> <year> 1994. </year> <title> Distributed Processes and Location Failures 43 </title>
Reference-contexts: The equivalences we discuss have been characterized in many ways. The location-based equivalences have been studied, for example, in [8, 2, 9, 25, 27, 11]; the cause-based equivalences have appeared, for example, in [12, 13]. Comparisons between these approaches appear in <ref> [21, 25, 14] </ref>. Most of these equivalences are defined for CCS, which does not have explicitly located processes. To apply these definitions to terms in our language, we Distributed Processes and Location Failures 39 first perform an implicit syntactic transformation that removes explict location references from the terms. <p> should refer to the original papers for further information. * CCS interleaving equivalence [23] was defined in Section 2.3. * Causal (C) equivalence [12] distinguishes processes based on the causality of actions. * Locations (L) equivalence [8] distinguishes processes based on the local causality of actions. * Local/Global (LG) equivalence <ref> [21] </ref> distinguishes processes based on a combination of their local and global causes; it is strictly finer than the intersection of the C- and L-equivalences. * Located Action (LA) equivalence [27, 11] is a finer form of locations equivalence in which location names appear in the syntax of the language, as
Reference: [22] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent System: Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: To capture such possible worlds, our logic must capture properties of sequences of livesets. Our solution is to define weak symbolic edges using a past-time temporal logic <ref> [22, 30] </ref>. Our notion of time is quite restrictive: time passes only when a site fails; in addition, any two site failures must be temporally ordered that is, failures occur one at a time. This intuition is formalized in the notion of a live sequence. <p> It also uses the fact that j fl y implies jf k =`g fl yf k =`g, the proof of which can be found in, for example, <ref> [22] </ref>. fl As an immediate corollary we have the following: COROLLARY 5.3. If ` and k are different from ? and neither appear in the basic processes p; q then `JpK u L `JqK implies kJpK u L kJqK. Proof. <p> In the weak case, in which we use a linear-time temporal logic, more work is required. Since we allow only a restricted class of models for our temporal formulae, the usual axiomatizations of linear-time temporal logic <ref> [22] </ref> do not directly apply.
Reference: [23] <author> Robin Milner. </author> <title> Communication and concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Many semantic theories have been proposed for concurrent processes <ref> [23, 20, 6] </ref>. Although these theories have been fruitfully applied to the analysis of some distributed systems, for the most part they ignore an essential feature of such systems, namely their distribution. <p> In Section 2, we consider a simple language for located processes based on pure CCS <ref> [23] </ref>, with which we assume familiarity. For example `Ja:p 1 + b:p 2 K j kJa:q 1 + c:q 2 K is a system consisting of two processes, one located at ` and the other at k. As in CCS, communication is binary. <p> Note that the operational semantics does not record the location at which actions are performed. Based on this labelled transition system, we wish to define an equivalence between process terms which is appropriate for the language. It is immediately apparent that standard equivalences, such as CCS bisimulation <ref> [23] </ref> are no longer appropriate. For example the terms `JaK j kJbK and kJaK j `JbK would not be differentiated by these equivalences although they can easily be distinguished by an observer that has the capability of killing ` or k. <p> Since both strong and weak LF-equivalence are defined using bisimulations, the problem of deciding that two systems are semantically congruent can, in principle, be solved using standard proof techniques associated with bisimulation <ref> [23, 10] </ref>. However, constructing an LF-bisimulation requires that one consider the behavior of the systems under all possible sequences of kills, by both the systems themselves and the environment. The number of states that must be explored may be exponentially larger than the number needed to construct a CCS bisimulation. <p> An obvious possibility is to adapt the bisimulation equivalences of CCS <ref> [23] </ref>. (Strong) CCS bisimulation is the largest symmetric relation : ccs on configurations such that whenever C : C a 7! C 0 there exists a D 0 such that D a 7! D 0 and C 0 : ccs D 0 . <p> This theory is an adaptation of standard bisimulation based theories <ref> [23] </ref> based on an operational semantics for located processes. The new semantic equivalences are justified in terms of barbed bisimulations [29]. We also give symbolic characterizations of the new equivalences which means that the equivalence can be investigated using the symbolic methods of [19]. <p> Below, we list the equivalences we consider; the interested reader should refer to the original papers for further information. * CCS interleaving equivalence <ref> [23] </ref> was defined in Section 2.3. * Causal (C) equivalence [12] distinguishes processes based on the causality of actions. * Locations (L) equivalence [8] distinguishes processes based on the local causality of actions. * Local/Global (LG) equivalence [21] distinguishes processes based on a combination of their local and global causes; it
Reference: [24] <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A calculus of mobile processes. </title> <journal> Information and Computation, </journal> <volume> 100(1), </volume> <month> September </month> <year> 1992. </year>
Reference-contexts: Distributed Processes and Location Failures 35 Related work.. Site failure has also played a role in languages studied in [3, 4, 16]. In these papers abstract languages based on Facile [17] or the pi-calculus <ref> [24, 5] </ref> are studied. The original motivation for this paper was to provide an alternative characterization of barbed equivalence for languages such as these.
Reference: [25] <author> Ugo Montanari and Daniel Yankelovich. </author> <title> Partial order localities. </title> <editor> In W. Kuich, editor, </editor> <booktitle> Proceedings of the International Colloquium on Automata, Languages and Programming, volume 623 of Lecture Notes in Computer Science, </booktitle> <pages> pages 617628, </pages> <address> Wien, Austria, July 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Using the semantic theories mentioned above it would be difficult to distinguish between these implementations, as the only difference between them is the location at which activity occurs. We aim to develop a useful extensional theory of systems which would take this type of property into account. In <ref> [8, 25, 11] </ref> such theories have been proposed. All of these theories, however, are based on a very strong assumption: that an observer, or user, can determine the location at which every action is performed. <p> In this case the logical language used for symbolic bisimulations must be extended to allow statements about the interdependence of locations; we leave this to future work. A number of location-based equivalences already exist in the literature <ref> [8, 9, 25, 27, 11] </ref>; however, none of these theories addresses the possible failure of sites. Their emphasis, rather, is to define a measure of the concurrency or distribution of a process: two processes are deemed equivalent only if, informally, they have the same degree of concurrency. <p> C Comparison with other equivalences In this appendix we show that LF-equivalence differs from all of the location- and cause-based equivalences that we are aware of. The equivalences we discuss have been characterized in many ways. The location-based equivalences have been studied, for example, in <ref> [8, 2, 9, 25, 27, 11] </ref>; the cause-based equivalences have appeared, for example, in [12, 13]. Comparisons between these approaches appear in [21, 25, 14]. Most of these equivalences are defined for CCS, which does not have explicitly located processes. <p> The equivalences we discuss have been characterized in many ways. The location-based equivalences have been studied, for example, in [8, 2, 9, 25, 27, 11]; the cause-based equivalences have appeared, for example, in [12, 13]. Comparisons between these approaches appear in <ref> [21, 25, 14] </ref>. Most of these equivalences are defined for CCS, which does not have explicitly located processes. To apply these definitions to terms in our language, we Distributed Processes and Location Failures 39 first perform an implicit syntactic transformation that removes explict location references from the terms.
Reference: [26] <author> Ben Moszkowski. </author> <title> Executing Temporal Logic Programs. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: An alternative is to use the chop operator of <ref> [26] </ref>. We have decided to use the standard operators precisely because they are standard; they may also allow for more efficient decision procedures [28].
Reference: [27] <author> David Murphy. </author> <title> Observing located concurrency. </title> <booktitle> In Proceedings of the Symposium on Mathematical Foundations of Computer Science, volume 711 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In this case the logical language used for symbolic bisimulations must be extended to allow statements about the interdependence of locations; we leave this to future work. A number of location-based equivalences already exist in the literature <ref> [8, 9, 25, 27, 11] </ref>; however, none of these theories addresses the possible failure of sites. Their emphasis, rather, is to define a measure of the concurrency or distribution of a process: two processes are deemed equivalent only if, informally, they have the same degree of concurrency. <p> C Comparison with other equivalences In this appendix we show that LF-equivalence differs from all of the location- and cause-based equivalences that we are aware of. The equivalences we discuss have been characterized in many ways. The location-based equivalences have been studied, for example, in <ref> [8, 2, 9, 25, 27, 11] </ref>; the cause-based equivalences have appeared, for example, in [12, 13]. Comparisons between these approaches appear in [21, 25, 14]. Most of these equivalences are defined for CCS, which does not have explicitly located processes. <p> of actions. * Locations (L) equivalence [8] distinguishes processes based on the local causality of actions. * Local/Global (LG) equivalence [21] distinguishes processes based on a combination of their local and global causes; it is strictly finer than the intersection of the C- and L-equivalences. * Located Action (LA) equivalence <ref> [27, 11] </ref> is a finer form of locations equivalence in which location names appear in the syntax of the language, as they do in our language. * Located Failure (LF) equivalence is the relation studied in this paper. * Located Failure/Located Action (LF/LA) is defined to be the intersection of the
Reference: [28] <author> Y. S. Ramakrishna, P. M. Melliar-Smith, L. E. Moser, L. K. Dillon, and G. Kutty. </author> <title> Interval logics and their decision procedures: Part i: An interval logic. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 166:147, </address> <year> 1996. </year>
Reference-contexts: An alternative is to use the chop operator of [26]. We have decided to use the standard operators precisely because they are standard; they may also allow for more efficient decision procedures <ref> [28] </ref>.
Reference: [29] <author> Davide Sangiorgi. </author> <title> Expressing Mobility in Process Algebras: First-Order and Higher-Order Paradigms. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1992. </year>
Reference-contexts: In short, the standard semantic equivalences are no longer preserved by all contexts in our language. To decide on an appropriate equivalence we follow the approach advocated in <ref> [29] </ref>. We define both strong and weak barbed equivalence between processes, : and . These definitions are defined in terms of the reduction relation t basic observation predicate. <p> P 3 ccs f`; kg . Q 3 , but these processes can be distinguished by a context that kills location ` so long as the kill action is performed after the initial communication on a. The use of ccs for CCS has been justified in <ref> [29] </ref> by the fact that it coincides with the congruence obtained from a simple notion of observation called barbed bisimulation. Similar results have been obtained for lazy and eager functional languages [1, 18, 7], giving further evidence for the reasonableness of this approach. <p> Our terminology is inspired by that of <ref> [29, 5] </ref>, in which barbed equivalence is defined by closing over static contexts (that is, those contexts built up using only parallel composition, restriction and renaming) and barbed congruence is defined by closing over all contexts, including dynamic contexts such as [] + a. <p> ASSUMPTION 3.12. To simplify the exposition, we will assume that Loc is finite. The Theorem also holds if Loc is infinite, as we explain in Remark 3.14. fl The contexts are based on those of Sangiorgi <ref> [29] </ref>. We assume that the set of action names is partitioned into sets Act 1 and Act 2 with all actions that appear in process terms coming from Act 1 . <p> This is achieved by making observable via barbs any change in the state of the context processes. The processes ACount and ASensor are taken directly from <ref> [29, Theorem 3.3.2] </ref>. In C [P], ASensor identifies the communication actions performed by P, whereas ACount controls the number of these actions that P can perform. We refer the reader to [29] for more details on the use of these contexts. <p> The processes ACount and ASensor are taken directly from [29, Theorem 3.3.2]. In C [P], ASensor identifies the communication actions performed by P, whereas ACount controls the number of these actions that P can perform. We refer the reader to <ref> [29] </ref> for more details on the use of these contexts. To these Distributed Processes and Location Failures 17 we add three new processes, LKiller, LSensor and LCount. <p> This theory is an adaptation of standard bisimulation based theories [23] based on an operational semantics for located processes. The new semantic equivalences are justified in terms of barbed bisimulations <ref> [29] </ref>. We also give symbolic characterizations of the new equivalences which means that the equivalence can be investigated using the symbolic methods of [19]. The equivalences we have defined are quite robust in the sense that for many variations of the operators in our language, barbed equivalence and LF-equivalence coincide.
Reference: [30] <author> Colin Stirling. </author> <title> Modal and temporal logics. </title> <editor> In Samson Abramsky, Dov M. Gabbay, and T.S.E. Maibaum, editors, </editor> <booktitle> Handbook of logic in computer science, volume 2 Background: Computational Structures, </booktitle> <pages> pages 477563. </pages> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: To capture such possible worlds, our logic must capture properties of sequences of livesets. Our solution is to define weak symbolic edges using a past-time temporal logic <ref> [22, 30] </ref>. Our notion of time is quite restrictive: time passes only when a site fails; in addition, any two site failures must be temporally ordered that is, failures occur one at a time. This intuition is formalized in the notion of a live sequence.
References-found: 30

