URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-94-29.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: Scalable Visualization of Parallel Systems  
Author: Jorge Garca Richard Hughey 
Keyword: Parallel Computers, Visualization, Parallel Debuggers, Performance Evaluation, Animation, Scalability  
Note: This work was supported in part by a NASA Graduate Student Research Program Fellowship.  
Address: Santa Cruz, CA 95064 USA  
Affiliation: Baskin Center for Computer Engineering Information Sciences University of California, Santa Cruz  
Date: 31 August 1994  
Pubnum: UCSC-CRL-94-29  
Abstract: As parallel systems become larger and more complex, they become harder to understand. The vast amount of information produced by these systems can quickly overwhelm a person. In many cases, researchers have turned to the use of visualization techniques as an aid to understanding the inner workings of parallel systems. By converting the information to images, a visualization system can take advantage of the human ability to recognize patterns that would not seem obvious otherwise. There are several existing systems for visualizing parallel programs. But most of them present fixed views of data, and will not scale to the thousands of processors available on massively parallel computers. In this paper we present a proposal for research in developing visualizations that scale with the number of processors. The methods used to create these views will make visualization systems useful in understanding computers with any number of processors. 
Abstract-found: 1
Intro-found: 1
Reference: [Apg92] <author> Scott W. Apgar. </author> <title> Interactive animation of fault tolerant parallel algorithms. </title> <booktitle> In Proceedings of the 1992 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 11-17, </pages> <year> 1992. </year>
Reference-contexts: The views created for algorithm animation are extremely specific and are usually used for teaching purposes. Some of the algorithm animations that have been created are specific to certain kinds of algorithms (sorting, searching, etc.). One example of this is the Robust Animator of Fault Tolerant algorithms (RAFT) <ref> [Apg92] </ref>. This system allows the user to interact with the executing animation. The only drawback of the system is that you can only animate the selected algorithms, and creating new animations involves lots of work.
Reference: [BH92] <author> Marc H. Brown and John Hershberger. </author> <title> Color and sound in algorithm animation. </title> <journal> Computer, </journal> <volume> 25(12) </volume> <pages> 52-63, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: The system is written in C and uses X windows, which makes it portable to other architectures. Zeus The Zeus algorithm animation system <ref> [BH92] </ref> is the new system proposed by Marc Brown, the creator of Balsa-II [Bro88b] and one of the original proponents of algorithm animation [Bro88a]. The system expands on the available algorithm animation techniques by adding color and sound as new dimensions for conveying information.
Reference: [Bro88a] <author> Marc H. Brown. </author> <title> Algorithm Animation. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year>
Reference-contexts: The system is written in C and uses X windows, which makes it portable to other architectures. Zeus The Zeus algorithm animation system [BH92] is the new system proposed by Marc Brown, the creator of Balsa-II [Bro88b] and one of the original proponents of algorithm animation <ref> [Bro88a] </ref>. The system expands on the available algorithm animation techniques by adding color and sound as new dimensions for conveying information.
Reference: [Bro88b] <author> Marc H. Brown. </author> <title> Exploring algorithms using Balsa-II. </title> <journal> Computer, </journal> <volume> 21(5) </volume> <pages> 14-36, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: The system is written in C and uses X windows, which makes it portable to other architectures. Zeus The Zeus algorithm animation system [BH92] is the new system proposed by Marc Brown, the creator of Balsa-II <ref> [Bro88b] </ref> and one of the original proponents of algorithm animation [Bro88a]. The system expands on the available algorithm animation techniques by adding color and sound as new dimensions for conveying information.
Reference: [CFH + 93] <author> Janice Cuny, George Forman, Alfred Hough, Joydip Kundu, Calvin Lin, Lawrence Snyder, and David Stemple. </author> <title> The Ariadne debugger: scalable application of event-based abstraction. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 85-95, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Visualizations in Belvedere are limited to small size programs. The views shown in the paper would not scale with an increase in the number of processes. To allow the creation of abstract behaviors for large programs, the authors have introduced a new system, called Ariadne <ref> [CFH + 93] </ref>. This system was designed for "scalable application of event-based abstractions." This new system does not include graphical displays, probably due to the difficulty of displaying scalable data.
Reference: [Cou93a] <author> Alva L. Couch. </author> <title> Categories and context in scalable execution visualization. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18(2) </volume> <pages> 195-204, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: This problem is critical with the arrival of systems with thousands of processors. There are some systems that have presented ideas about the creation of scalable views. A good description of the problem of scalability in visualization systems is presented by Couch <ref> [Cou93a, Cou93b] </ref>. He defines a scalable view as "one whose format, clarity, meaning, and size are independent of the number of processing elements involved in computation." The author presents some guidelines that are needed to ensure that the views created are scalable. These guidelines are incorporated into Couch's Seeplex system.
Reference: [Cou93b] <author> Alva L. Couch. </author> <title> Locating performance problems in massively parallel executions. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 81(8) </volume> <pages> 1116-1125, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: This problem is critical with the arrival of systems with thousands of processors. There are some systems that have presented ideas about the creation of scalable views. A good description of the problem of scalability in visualization systems is presented by Couch <ref> [Cou93a, Cou93b] </ref>. He defines a scalable view as "one whose format, clarity, meaning, and size are independent of the number of processing elements involved in computation." The author presents some guidelines that are needed to ensure that the views created are scalable. These guidelines are incorporated into Couch's Seeplex system.
Reference: [CR91] <author> Kenneth C. Cox and Gruia-Catalin Roman. </author> <title> Visualizing concurrent computations. </title> <booktitle> In Proceedings of the 1991 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 18-24, </pages> <year> 1991. </year> <note> 24 References </note>
Reference-contexts: The visualizations created using PARADISE will not easily scale to larger systems. Since the system is used for visualizing whatever trace file is given, there should be no requirement for the system to be parallel. The goal of the Pavane system <ref> [CR91] </ref> is to develop a methodology for selecting the proper visualization of a concurrent computation. The method they use focus on the abstract formal properties of the computation. A visualization in Pavane is a mapping from a computational state to an image on the screen.
Reference: [EC88] <author> Bradley R. Engstrom and Peter R. Capello. </author> <title> The SDEF systolic programming language. </title> <booktitle> In Concurrent Computations, </booktitle> <pages> pages 263-301, </pages> <year> 1988. </year>
Reference-contexts: They execute synchronously. 2. A grid is a good abstraction for their execution. 3. The interprocess communication is regular. 4. All processors execute the same program. There are several systems that deal with the coding, execution and visualization of systolic algorithms. Both SDEF <ref> [EC88] </ref> and Hearts [Sny87] provide different environments for the definition of the algorithm, and for visualizing the execution of the implementation. NSL [Hug92] is a language for the implementation of systolic algorithms.
Reference: [Fer93] <author> Robert Ferraro. </author> <type> Personal Communication, </type> <year> 1993. </year>
Reference-contexts: Ultimately, the visualization systems should control the program execution, generating visualizations on-the-fly. Ties to source code One of the biggest complaints of users of visualization systems is the lack of information available to determine which sections of code produced the data being visualized <ref> [Fer93] </ref>. Ties to source code could help the users trace some abnormality to the sections of code that may have caused it. This can initially be done by adding a line to the trace indicating the file and line of code being executed.
Reference: [FJA91] <author> Joan M. Francioni, Jay Alan Jackson, and Larry Albright. </author> <title> The sounds of parallel programs. </title> <booktitle> In Proceedings of the Sixth Distributed Memory Computing Conference, </booktitle> <pages> pages 570-577. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1991. </year>
Reference-contexts: And finally, it can be used sparingly as decoration for generated visualizations. Use of sound Sound can be used as an alternative to visualizations to portray the behavior of parallel programs. Francioni et al. present three experiments where execution behavior is mapped to sound <ref> [FJA91] </ref>. The first study tracks processor loads, and can be used to determine load balance. The second study is related to the flow-of-control of the program, and produces sounds when selected sections of code are executed on each processor.
Reference: [FLK + 91] <author> Mark Friedell, Mark LaPolla, Sandeep Kochhar, Steve Sistare, and Janusz Juda. </author> <title> Visualizing the behavior of massively parallel programs. </title> <booktitle> In Supercomputing '91, </booktitle> <pages> pages 472-480, </pages> <year> 1991. </year>
Reference-contexts: This visualization will probably only be useful for this particular algorithm. One of the main drawbacks of Polka is the amount of intervention that is required from the animator in order to create the application-specific views. Other systems The Integrated Visualization Environment (IVE) system <ref> [FLK + 91] </ref> is a system for visualizing parallel programs executing in SIMD machines. The system allows for 3 kinds of visualizations: Program visualization (eg. calling diagrams and dependency graphs), process visualization (eg. description of the state of the program) and application visualization (eg. specific abstractions for applications). 16 3.
Reference: [GHPW90] <author> G. A. Geist, M. T. Heath, B. W. Peyton, and P. H. Worley. </author> <title> A user's guide to PICL: A portable instrumented communications library. </title> <type> Technical Report ORNL/TM-11616, </type> <institution> Oak Ridge National Laboratory, </institution> <year> 1990. </year>
Reference-contexts: ParaGraph The ParaGraph system [HE91] has a large number of predefined views for performance visualization. The goal of the system is to provide several ways of easily visualizing performance data. The system relies on the Portable Instrumented Communication Library (PICL) for data collection <ref> [GHPW90] </ref>. PICL is available in several vendors' parallel message-passing architectures (Thinking Machines, nCUBE, Cogent, Intel, Meiko, Symult). This is one of the advantages of the ParaGraph system: it can handle data produced by several different architectures.
Reference: [HC89] <author> Alfred A. Hough and Janice E. Cuny. </author> <title> Initial experiences with a pattern-oriented parallel debugger. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 195-205, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Belvedere and Perspective Views The major idea in the Belvedere system is that parallel programs are best understood by examining the patterns of interprocess communication <ref> [HC89] </ref>. Belvedere can be used to visualize information from an execution trace file and uses animation to display user defined communication events. The user can then detect bugs in the program by observing deviations from the expected pattern of communication.
Reference: [HC90] <author> Alfred A. Hough and Janice E. Cuny. </author> <title> Perspective Views: A technique for enhancing parallel program visualization. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing, </booktitle> <volume> volume II, </volume> <pages> pages 124-132, </pages> <year> 1990. </year>
Reference-contexts: After using Belvedere on several different programs, the authors observed that animating the communication patterns is helpful, but that restricting the animation to different perspectives can make the information more meaningful. This led the authors to study a technique they call Perspective Views <ref> [HC90] </ref>. They found that sometimes the information displayed by animated views can be enhanced by reordering events in ways that closely match the user's mental model of the program.
Reference: [HE91] <author> Michael T. Heath and Jennifer A. Etheridge. </author> <title> Visualizing the performance of parallel programs. </title> <journal> IEEE Software, </journal> <volume> 8(5) </volume> <pages> 29-39, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Previous work 7 Performance data is quantifyable, so graphs, charts and similar diagrams work well for displaying it. These displays are supplied with most systems, so generating a new view of the data is very simple. ParaGraph The ParaGraph system <ref> [HE91] </ref> has a large number of predefined views for performance visualization. The goal of the system is to provide several ways of easily visualizing performance data. The system relies on the Portable Instrumented Communication Library (PICL) for data collection [GHPW90].
Reference: [Hug92] <author> Richard Hughey. </author> <title> Programming systolic arrays. </title> <editor> In Edward Lee and Teresa Meng, editors, </editor> <booktitle> Proceedings of the International Conference on Application Specific Array Processors, </booktitle> <pages> pages 604-618. </pages> <publisher> IEEE Computer Society, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: All processors execute the same program. There are several systems that deal with the coding, execution and visualization of systolic algorithms. Both SDEF [EC88] and Hearts [Sny87] provide different environments for the definition of the algorithm, and for visualizing the execution of the implementation. NSL <ref> [Hug92] </ref> is a language for the implementation of systolic algorithms. As part of the compilation, hooks are created to a visualization system (implemented using Xtango [Sta90]) that will animate the execution of the algorithm while highlighting the line of code being executed.
Reference: [KC91] <author> James Arthur Kohl and Thomas L. Casavant. </author> <title> Use of PARADISE: A meta-tool for visualizing parallel systems. </title> <booktitle> In Proceedings of the 5th International Parallel Processing Symposium, </booktitle> <pages> pages 561-567, </pages> <year> 1991. </year>
Reference-contexts: While the relative automation of the views is a step in the right direction, the user still has to be significantly involved, so it is not automatic. The approach taken by the Parallel Animated Debugging and Simulation Environment (PARADISE) <ref> [KC91] </ref> is to create a tool for aiding the user to develop visualizations of the given trace data. They assume that the trace data will be collected using other methods, and it will be available in the form they require.
Reference: [Kim90] <author> Doug Kimelman. </author> <title> Environments for visualization of program execution. </title> <booktitle> In Simmons and Koskela [SK90], </booktitle> <pages> pages 135-146. </pages>
Reference-contexts: The RP3 (Research Parallel Processor Prototype) system from IBM is important because they added a performance monitoring chip (PMC) to each of the processors in the system [WCC90]. As part of the RP3 system, a prototype visualization system <ref> [Kim90] </ref> was developed to display some of the data collected by the monitoring system. The goal of the visualization system was to give programmers a set of tools that they could use to find problems in their programs.
Reference: [KS92] <author> Eileen Kraemer and John T. Stasko. </author> <title> The visualization of parallel systems: An overview. </title> <type> Technical report, </type> <institution> Georgia Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: of each of these issues to the goal of the visualization system, and see how some of the available systems have dealt with these issues. 2.1 Requirements for visualization of parallel systems The creation of views involves several tasks that can be implemented as separate modules of a visualization system <ref> [KS92] </ref>. These tasks can be classified as collection, storage, analysis and display of the data generated by the parallel system. Figure 2.1 shows the typical setup for visualization of parallel systems. There are different issues involved in each of these tasks: 4 2.
Reference: [Kun93] <author> Thomas Kunz. </author> <title> Process clustering for distributed debugging. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 75-84, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The simplest way to join processors together in scalable views is to use physical proximity. It would be more desirable to have automatic ways to group together processors according to what they are doing. Some work in this area has been done by Kunz <ref> [Kun93] </ref>, but there is still much to be done. 4.3 Ties to program Future visualization systems should have strong ties to the actual program being visualized, not just to the execution trace generated by the program.
Reference: [LMC87] <author> Thomas J LeBlanc and John M. Mellor-Crummey. </author> <title> Debugging parallel programs with Instant Replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(4):471-482, </volume> <month> April </month> <year> 1987. </year>
Reference-contexts: Instant Replay is a way of gathering data from a program execution to ensure that future runs will produce the same behavior <ref> [LMC87] </ref>. The main observation is that process communication and interaction is the cause of non-reproducible behavior, because a different sequence of interactions may cause a different result. Instant Replay models all process interactions as operations on shared data.
Reference: [Mas91] <institution> MasPar Computer Corporation. MasPar Programming Environment (MPPE) User Guide, </institution> <year> 1991. </year>
Reference-contexts: This system was designed for "scalable application of event-based abstractions." This new system does not include graphical displays, probably due to the difficulty of displaying scalable data. MPPE - MasPar Programming Environment The MPPE system is a tool for debugging and optimizing data-parallel programs for the MasPar MP-1 computer <ref> [Mas91] </ref>. This system uses a graphical user interface to allow the user to debug programs written for the MasPar. It also allows the user to animate the updating of variable values during execution and create some visualizations of selected data using a data visualizer window (see figure 3.2).
Reference: [MH89] <author> Charles E. McDowell and David P. Helmbold. </author> <title> Debugging concurrent programs. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(4) </volume> <pages> 593-622, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: The amount of data can be overwhelming for a person to comprehend. A good survey on debuggers for parallel programs was presented by McDowell and Helmbold <ref> [MH89] </ref>. Pancake and Utter give an in-depth look at visualization models for parallel debuggers [PU89]. 10 3. Previous work The data collection for debugging systems has to include interprocess communication information as well as information about the behavior of each process.
Reference: [PU89] <author> Cherri M. Pancake and Sue Utter. </author> <title> Models for visualization in parallel debuggers. </title> <booktitle> In Supercomputing '89, </booktitle> <pages> pages 627-636, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: The amount of data can be overwhelming for a person to comprehend. A good survey on debuggers for parallel programs was presented by McDowell and Helmbold [MH89]. Pancake and Utter give an in-depth look at visualization models for parallel debuggers <ref> [PU89] </ref>. 10 3. Previous work The data collection for debugging systems has to include interprocess communication information as well as information about the behavior of each process.
Reference: [RAM + 92] <author> Daniel A. Reed, Ruth A. Aydt, Tara M. Madhyastha, Roger J. Noe, Keith A. Shields, and Bradley W. Schwartz. </author> <title> An Overview of the Pablo Performance Analysis Environment. </title> <institution> Department of Computer Science, University of Illinois, Urbana, Illinois 61801, </institution> <month> November 7 </month> <year> 1992. </year> <note> References 25 </note>
Reference-contexts: We liked the fact that the learning curve is low and the amount of expected user intervention is minimal. Pablo The Pablo performance analysis environment is a system for the collection, analysis and presentation of performance data from parallel computer systems <ref> [ROA + 91, RAM + 92] </ref>. The environment includes a collection mechanism that generates self-documenting trace files where no data types or sizes are assumed. The analysis is done by connecting trace flows graphically to statistical data transformation modules.
Reference: [ROA + 91] <author> Daniel A. Reed, Robert D. Olson, Ruth A. Aydt, Tara M. Madhyastha, Thomas Birkett, David W. Jensen, Bobby A. A. Nazief, and Brian K. Totty. </author> <title> Scalable performance environments for parallel systems. </title> <booktitle> In Proceedings of the Sixth Distributed Memory Computing Conference, </booktitle> <pages> pages 562-569. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1991. </year>
Reference-contexts: We liked the fact that the learning curve is low and the amount of expected user intervention is minimal. Pablo The Pablo performance analysis environment is a system for the collection, analysis and presentation of performance data from parallel computer systems <ref> [ROA + 91, RAM + 92] </ref>. The environment includes a collection mechanism that generates self-documenting trace files where no data types or sizes are assumed. The analysis is done by connecting trace flows graphically to statistical data transformation modules.
Reference: [RRZ89] <author> Robert V. Rubin, Larry Rudolph, and Dror Zernik. </author> <title> Debugging parallel programs in parallel. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 216-225, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Changes in icon color will indicate the section of the code being executed. The visualization of parallel machines is so important that there was a system that proposed the use of a parallel machine exclusively for monitoring and debugging a similar machine <ref> [RRZ89] </ref>. The proposed machine, called Makbilan, was a MIMD shared-memory machine. The goal of the Monitoring, Animating and Debugging (MAD) system was to do the monitoring in a non-intrusive, interactive and user-friendly way.
Reference: [SBN89] <author> David Socha, Mary L. Bailey, and David Notkin. Voyeur: </author> <title> Graphical views of parallel programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 206-215, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Much of the research in this area involves the simplification of creating the views, as well as the reusability of the building blocks used to create the views. Voyeur The Voyeur system was created to improve the trace facility of the Poker programming environment <ref> [SBN89] </ref>. The emphasis of Voyeur was to facilitate the creation of application-specific views of parallel programs. It was used to create views that were close to the programmer's mental model of the problem.
Reference: [SK90] <editor> Margaret Simmons and Rebecca Koskela, editors. </editor> <title> Performance Instrumentation and Visualization. </title> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: They can assist programmers in finding bottlenecks or areas of the program where the performance can be improved. For an in-depth discussion of the issues involved in the creation of performance evaluation tools for parallel systems, the reader is directed to the two conference proceedings on the subject <ref> [SKB89, SK90] </ref>. Performance evaluation tools do not need to know the functionality of the program being executed. They just give information about the usage of the architecture or the balancing of loads. This means that the same displays can be reused with the execution of different programs.
Reference: [SK92] <author> John T. Stasko and Eileen Kraemer. </author> <title> A methodology for building application-specific visualizations of parallel programs. </title> <type> Technical Report GIT-GVU-92-10, </type> <institution> Georgia Institute of Technology, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Even though the techniques discussed in the Zeus paper seem very valuable, their effectiveness has not been formally evaluated. It would be interesting to see how much each of these techniques helps in clarifying the behavior of algorithms. Polka Polka <ref> [SK92] </ref> is the successor of Tango [Sta90], and it is a system for creating animations for specific algorithms. The system emphasizes the simplification of creating views by giving several primitives that, though not extremely easy to learn, are much simpler than the equivalent X windows programming primitives.
Reference: [SKB89] <editor> Margaret Simmons, Rebecca Koskela, and Ingrid Bucher, editors. </editor> <title> Instrumentation for Future Parallel Computing Systems. </title> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: They can assist programmers in finding bottlenecks or areas of the program where the performance can be improved. For an in-depth discussion of the issues involved in the creation of performance evaluation tools for parallel systems, the reader is directed to the two conference proceedings on the subject <ref> [SKB89, SK90] </ref>. Performance evaluation tools do not need to know the functionality of the program being executed. They just give information about the usage of the architecture or the balancing of loads. This means that the same displays can be reused with the execution of different programs.
Reference: [Sny87] <author> Lawrence Snyder. </author> <title> Hearts: A dialect of the Poker programming environment specialised to systolic computation. </title> <editor> In W. Moore, A. McCabe, and R. Urquhart, editors, </editor> <booktitle> Systolic Arrays, </booktitle> <pages> pages 71-80. </pages> <address> Adam Hilger, Boston, MA, </address> <year> 1987. </year>
Reference-contexts: They execute synchronously. 2. A grid is a good abstraction for their execution. 3. The interprocess communication is regular. 4. All processors execute the same program. There are several systems that deal with the coding, execution and visualization of systolic algorithms. Both SDEF [EC88] and Hearts <ref> [Sny87] </ref> provide different environments for the definition of the algorithm, and for visualizing the execution of the implementation. NSL [Hug92] is a language for the implementation of systolic algorithms.
Reference: [SP92] <author> John T. Stasko and Charles Patterson. </author> <title> Understanding and characterizing software visualization systems. </title> <booktitle> In Proceedings of the IEEE 1992 Workshop on Visual Languages, </booktitle> <pages> pages 3-10, </pages> <year> 1992. </year>
Reference-contexts: The views created are designed for a particular program or algorithm, and different views are required for different algorithms. Stasko and Patterson present a discussion on some of the issues related to software visualization systems <ref> [SP92] </ref>. Algorithm animation can be considered part of program visualization, since the purpose is to give very intuitive displays of data. The views created for algorithm animation are extremely specific and are usually used for teaching purposes.
Reference: [Sta90] <author> John T. Stasko. </author> <title> TANGO: A framework and system for algorithm animation. </title> <journal> Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Even though the techniques discussed in the Zeus paper seem very valuable, their effectiveness has not been formally evaluated. It would be interesting to see how much each of these techniques helps in clarifying the behavior of algorithms. Polka Polka [SK92] is the successor of Tango <ref> [Sta90] </ref>, and it is a system for creating animations for specific algorithms. The system emphasizes the simplification of creating views by giving several primitives that, though not extremely easy to learn, are much simpler than the equivalent X windows programming primitives. <p> Both SDEF [EC88] and Hearts [Sny87] provide different environments for the definition of the algorithm, and for visualizing the execution of the implementation. NSL [Hug92] is a language for the implementation of systolic algorithms. As part of the compilation, hooks are created to a visualization system (implemented using Xtango <ref> [Sta90] </ref>) that will animate the execution of the algorithm while highlighting the line of code being executed.
Reference: [Tuf90] <author> Edward R. Tufte. </author> <title> Envisioning Information. </title> <publisher> Graphics Press, </publisher> <address> Cheshire, CT, </address> <year> 1990. </year>
Reference-contexts: The result is computer visualizations that look very attractive, with many bright colors, but are not very informative. Usually, the visualizations end up looking like video games. In his book Envisioning Information, Tufte gives some guidelines on using color in displays of information <ref> [Tuf90] </ref>.
Reference: [UHP91] <author> Sue Utter-Honig and Cherri M. Pancake. </author> <title> Graphical animation of parallel Fortran programs. </title> <booktitle> In Supercomputing '91, </booktitle> <pages> pages 491-498, </pages> <year> 1991. </year>
Reference-contexts: Replaying the program consists of resetting the state to the last checkpoint and executing the trace entries since that point. The PF-View system is a graphical debugger created to take advantage of the massive amounts of information produced by the IBM's Parallel Fortran Trace Facility (PF-Trace) <ref> [UHP91] </ref>. The PF-View system reads and processes program traces, using the resulting data to present a multi-level view of the execution of the program, which can be used for 3. Previous work 13 debugging or for performance tuning.
Reference: [WCC90] <author> Brantley William C and Henry Y. Chang. </author> <title> Support environment for RP3 performance monitor. </title> <booktitle> In Simmons and Koskela [SK90], </booktitle> <pages> pages 117-134. </pages>
Reference-contexts: The execution can be animated using the View Kernel tool, or statistics about the execution can be observed using the Tally tool. The RP3 (Research Parallel Processor Prototype) system from IBM is important because they added a performance monitoring chip (PMC) to each of the processors in the system <ref> [WCC90] </ref>. As part of the RP3 system, a prototype visualization system [Kim90] was developed to display some of the data collected by the monitoring system. The goal of the visualization system was to give programmers a set of tools that they could use to find problems in their programs.
Reference: [Wit89] <author> Larry D. Wittie. </author> <title> Debugging distributed C programs by real time replay. </title> <journal> SIG-PLAN Notices, </journal> <volume> 24(1) </volume> <pages> 57-67, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The main problem is that it is only available for the MasPar, so it is not portable. The ideas are tailored for SIMD machines, where synchronous execution simplifies many of the animation issues. Other systems Bugnet is a system for debugging distributed programs running on a Unix network <ref> [Wit89] </ref>. It uses a monitoring facility to record interprocess communication and input/output for all the executing processes.
Reference: [WL91] <author> Edward M. Williams and Gary B. Lamont. </author> <title> A real-time parallel algorithm animation system. </title> <booktitle> In Proceedings of the Sixth Distributed Memory Computing Conference, </booktitle> <pages> pages 551-561. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1991. </year>
Reference-contexts: Aside from these models, there is no obvious way of creating new models or for studying the behavior of a particular program. The system presented by Williams and Lamont <ref> [WL91] </ref> integrates two systems developed at the Air Force Institute of Technology | AAARF and PRASE. The major emphasis of this system is the animation of parallel algorithms for improving the understanding of the algorithms. It also includes some limited capabilities for performance data display.
Reference: [WR93] <author> Abdul Waheed and Diane T. </author> <title> Rover. Performance visualization of parallel programs. </title> <booktitle> In Visualization '93, </booktitle> <pages> pages 174-181, </pages> <year> 1993. </year>
Reference-contexts: Need for scalable visualization available data sorted by value. The range of values is shown in the Y axis. The rectangle on the graph indicates a section of data selected for further inspection. This data is shown in the figure on the right. Waheed and Rover <ref> [WR93] </ref> use techniques from the area of image processing to visualize performance data from massively parallel systems. These techniques are scalable to thousands of processors. They also use general purpose visualization tools like AVS and Matlab to analyze the data and create new visualizations.
Reference: [YHL + 93] <author> Jerry Yan, Philip Hontalas, Sherry Listgarten, Charles Fineman, Melisa Schmidt, Pankaj Mehra, Sekhar Sarukkai, and Cathy Schulbach. </author> <title> The automated instrumentation and monitoring system (AIMS) reference manual. </title> <type> Technical Report TM-108795, </type> <institution> NASA, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Other systems The Automated Instrumentation and Monitoring System (AIMS) provides facilities for the automatic insertion of instrumentation code <ref> [YHL + 93] </ref>. The system has a monitoring facility that will save performance data, and two tools that process and display the data. The execution can be animated using the View Kernel tool, or statistics about the execution can be observed using the Tally tool.
References-found: 42

