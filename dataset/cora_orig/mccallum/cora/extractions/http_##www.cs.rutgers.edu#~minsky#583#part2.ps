URL: http://www.cs.rutgers.edu/~minsky/583/part2.ps
Refering-URL: http://www.cs.rutgers.edu/~minsky/583/coord.html
Root-URL: http://www.cs.rutgers.edu
Title: Law-Governed Regularities in Object Systems; Part 2: A Concrete Implementation  
Author: Naftaly H. Minsky and Partha pratim Pal 
Address: New Brunswick, NJ 08903 USA  
Affiliation: Department of Computer Science, Rutgers University,  
Abstract: Regularities, or the conformity to unifying principles, are essential to the comprehensibility, manageability and reliability of large software systems, and should, therefore, be considered an important element of their architecture. But the inherent globality of regularities makes them very hard to implement in traditional methods. We have argued in a previously published companion paper that this difficulty can be alleviated by means of law-governed architecture (LGA), under which a system designers can establish a desired regularity (of a certain kind) simply by declaring it formally and explicitly as the law of the system. Once such a law-governed regularity is declared, it is enforced by the environment in which the system is developed. This paper discusses the application of LGA to traditional, class-based, object oriented languages, using the Eiffel language for specificity. We introduce here the formalism for specifying laws that govern systems written in this language, and give a sample of regularities that can be efficiently established by such laws. As a case study, we show how one can establish a kernelized architecture suitable for the construction of critical embedded software, such as the software embedded in an intensive care unit.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Birtwistle G., O. Dahl, B. Myhrtag, and K. Mygaard. </author> <title> Simula Begin. </title> <publisher> Auerbach Press, </publisher> <year> 1973. </year>
Reference-contexts: Prohibition of assignments to private attributes of class C by any other class. R37. cannot call ( ,C1,F,C) :- private (F)@C, C1=/C. Prohibition of calls to private attributes of class C from any other class. This useful notion is supported by both Simula 67 <ref> [1] </ref> and C++ [3], but unfortunately not by Eiffel, in which features of a class are automatically visible in all the descendants of this class. This limitation of Eiffel can be easily rectified under Darwin-E.
Reference: [2] <author> Karl J. Lieberherr. </author> <title> Adaptive Object-Oriented Software: The Demeter Method with Propagation Patterns. </title> <publisher> PWS Publishing Company, </publisher> <address> Boston, </address> <year> 1996. </year> <note> ISBN 0-534-94602-X. </note>
Reference-contexts: For additional applications of law-governed regularities under Darwin-E the reader is referred to the following papers: The use of laws to provide firm support for various design patterns is discussed in [9]; a very flexible support for the "law of Demeter" <ref> [2] </ref> is presented in [10]; the creation of multiple views for a single object, which can evolve independently of each other, is discussed in [8]; the concept of auditable system has been introduced in [6].
Reference: [3] <author> Stanley B. Lippman. </author> <title> C++ Primer. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Prohibition of assignments to private attributes of class C by any other class. R37. cannot call ( ,C1,F,C) :- private (F)@C, C1=/C. Prohibition of calls to private attributes of class C from any other class. This useful notion is supported by both Simula 67 [1] and C++ <ref> [3] </ref>, but unfortunately not by Eiffel, in which features of a class are automatically visible in all the descendants of this class. This limitation of Eiffel can be easily rectified under Darwin-E.
Reference: [4] <author> B. Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: But part 1 described only an abstract|language independent| model of LGA. In this paper we specialize this model to deal with traditional inheritance based object-oriented languages. More specifically, we describe here a layer of Darwin/2 called Darwin-E that supports law-governed architecture for systems written in the Eiffel language <ref> [4] </ref>. <p> We distinguish here between two kinds of such interactions: any semantics with such grouping <ref> [4] </ref>. 2 In general, B may have several objects with the same class names, which may represent several versions of the same class. But for simplicity we shall assume in this paper that all class names are unique, and identical to the identifier of the objects representing them. 4 1. <p> For example, there are good reason to keep the encryption key of a class encryption completely hidden. Second, a decrease in the visibility of f1 would make compile-time type checking impossible, giving rise to a phenomenon called in Eiffel system-level validity failure <ref> [4] </ref>. To provide some control over this capability of Eiffel we introduce the following interaction: Definition 6 ((changeExp interaction)) Let c1 be a class, f1 be one of the features effectively defined in c1, and c2 be a descendant of c1. <p> This rule would prevent any assignment to a variable defined in a class C2 by code written in any proper descended of it, while not disturbing the read and call access provided by Eiffel. 4.7 Reverse Assignment Reverse assignment is a type-safe means provided by Eiffel <ref> [4] </ref> to "resurrect" a pointer stored in variable of more general type then the object being pointed to, making this object usable for what it really is.
Reference: [5] <author> N.H. Minsky. </author> <title> Law-governed systems. </title> <journal> The IEE Software Engineering Journal, </journal> <month> September </month> <year> 1991. </year>
Reference-contexts: Interactions between the component-parts of the system being developed. The rules that regulate the former kind of interactions, thus governing the process of evolution of P, are enforced dynamically, when the regulated operations are invoked. The structure of these rules has been described in <ref> [5] </ref>, and its knowledge will not be required for the rest of this paper.
Reference: [6] <author> N.H. Minsky. </author> <title> Independent on-line monitoring of evolving systems. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering (ICSE), </booktitle> <pages> pages 134-143, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: The former set of rules is given in Figure 5; the other two are not given here, but an interested reader will find analogous rules in <ref> [6] </ref>. 4 Interactions Regulated Under Darwin-E This sections discusses some of the interactions regulated under Darwin-E. Besides defining each of these interactions, we motivate the need for regulating it, and illustrate such regulation by means of few examples. <p> These audit-classes should be allowed to observe the status of the rest of the system, but not to effect its status in any way. In other words, an audit class should be allowed to call only SEF-routines defined in the rest of the system. (see <ref> [6] </ref> for a detailed discussion of such a system). But how do we know which routines are SEF? Of course, one can program any given routine carefully to be SEF and then allow it to be used by the audit-classes. <p> various design patterns is discussed in [9]; a very flexible support for the "law of Demeter" [2] is presented in [10]; the creation of multiple views for a single object, which can evolve independently of each other, is discussed in [8]; the concept of auditable system has been introduced in <ref> [6] </ref>. Finally, it should be pointed out that although Darwin-E deals with systems written in Eiffel, the general idea of law-governed regularities, and most of the specifics in this paper, are applicable to many other object-oriented languages, such as C++, Ada and Modula-3.
Reference: [7] <author> N.H. Minsky. </author> <title> Law-governed regularities in object systems; part 1: An abstract model. </title> <journal> Theory and Practice of Object Systems (TAPOS), </journal> <volume> 2(1), </volume> <year> 1996. </year>
Reference-contexts: 1 Introduction This is the second of two papers about the role of regularities in software systems, where by "regularity" we mean the conformity to some unifying principle. The first of these papers <ref> [7] </ref> (henceforth to be called "Part 1") argued that regularities are critical to the comprehensibility and maintainability of large, evolving, software systems|but that they are inherently hard to implement reliably under conventional approaches to programming and to software development.

Reference: [9] <author> P. Pal. </author> <title> Law-governed support for realizing design patterns. </title> <booktitle> In Proceedings of the 17th Conference on Technology of Object-Oriented Languages and Systems(TOOLS-17), </booktitle> <pages> pages 25-34, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: For additional applications of law-governed regularities under Darwin-E the reader is referred to the following papers: The use of laws to provide firm support for various design patterns is discussed in <ref> [9] </ref>; a very flexible support for the "law of Demeter" [2] is presented in [10]; the creation of multiple views for a single object, which can evolve independently of each other, is discussed in [8]; the concept of auditable system has been introduced in [6].
Reference: [10] <author> P. Pal and N.H. Minsky. </author> <title> Imposing the law of demeter and its variations. </title> <booktitle> In Proceedings of the 18th Conference on Technology of Object-Oriented Languages and Systems(TOOLS-18), </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: For additional applications of law-governed regularities under Darwin-E the reader is referred to the following papers: The use of laws to provide firm support for various design patterns is discussed in [9]; a very flexible support for the "law of Demeter" [2] is presented in <ref> [10] </ref>; the creation of multiple views for a single object, which can evolve independently of each other, is discussed in [8]; the concept of auditable system has been introduced in [6].
Reference: [11] <author> A. Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proceedings of the OOPSLA'86 Conference, </booktitle> <pages> pages 38-45, </pages> <month> September-October </month> <year> 1986. </year> <month> 23 </month>
Reference-contexts: The potentially negative implications of these aspects of inheritance to encapsulation have been pointed out by Snyder <ref> [11] </ref>. The conflict between inheritance and selective export in Eiffel is due to the fact that anything exported to a class is automatically accessible to all its descendants. To explain why this may be undesirable, consider a class account with features deposit and withdraw. <p> While this may simplify the code in the heir class, it compromises the encapsulation provided by the parent classes, in the general manner discussed in <ref> [11] </ref>. We can fortify encapsulation in Eiffel, without giving up much of the ease of access provided by it, by allowing a heir only read access to the attributes it inherits.
References-found: 10

