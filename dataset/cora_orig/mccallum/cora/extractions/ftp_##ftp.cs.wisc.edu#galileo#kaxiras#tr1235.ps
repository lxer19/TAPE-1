URL: ftp://ftp.cs.wisc.edu/galileo/kaxiras/tr1235.ps
Refering-URL: 
Root-URL: 
Title: Hierarchical Extensions to SCI  
Author:  James R. Goodman, Stefanos Kaxiras 
Note: 1 This work is supported in part by National Science Foundation grant #CCR-9207971  
Date: July 12, 1994  
Address: 1210 W. Dayton Street Madison, WI 53706  
Affiliation: University of Wisconsin Madison Computer Sciences Department University of Wisconsin Madison  
Abstract-found: 0
Intro-found: 0
Reference: [1] <institution> IEEE Standard for Scalable Coherent Interface (SCI) 1596-1992, </institution> <note> IEEE 1993. </note>
Reference-contexts: StoreUpdate with Bimodal Behavior ............. 34 APPENDIX I. Short Pointer Conversions ....................... 36 APPENDIX II. Guidelines for the use of Multiple Types of Tags ........ 41 Acknowledgments ...................................... 43 References ........................................... 43 1. Motivation The current proposal for Kiloprocessor Extensions to Scalable Coherent Interface <ref> [1] </ref>, which we will refer to as STEM [2], has achieved its goal of a logarithmic-time algorithm to build, maintain and invalidate a sharing binary tree without taking into account the topology of the interconnect network. The complexity of the algorithm however, is very high. <p> We can also implement the tags as multiple tag entries in an agent. The central idea is to have multiple tag entries (instead of one) to implement a k-ary tree. This idea is described by R. Simoni and M. Horowitz <ref> [1] </ref>. The multiple tag entries (instead of one with many pointers) can be linked together and form a linear list. Alternatively they can be unrelated (not linked) in which case they can be searched and found individually. 4.3.1.
Reference: [2] <author> Ross E. Johnson. </author> <title> "Extending the Scalable Coherent Interface for large-Scale Shard-Memory Multiprocessors," </title> <type> PhD Thesis, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1993. </year>
Reference-contexts: Short Pointer Conversions ....................... 36 APPENDIX II. Guidelines for the use of Multiple Types of Tags ........ 41 Acknowledgments ...................................... 43 References ........................................... 43 1. Motivation The current proposal for Kiloprocessor Extensions to Scalable Coherent Interface [1], which we will refer to as STEM <ref> [2] </ref>, has achieved its goal of a logarithmic-time algorithm to build, maintain and invalidate a sharing binary tree without taking into account the topology of the interconnect network. The complexity of the algorithm however, is very high. It requires complex transactions that generate a lot of traffic. <p> For cases where our tree is longer than STEM we believe our scheme will still out perform STEM because of the shorter paths of individual links. 3.2 OMEGA/FLIP Topologies In his thesis Ross Johnson suggested building butterfly topologies with rings <ref> [2] </ref>. A disadvantage of the topologies he suggested, is that the rings have a varying number of nodes. We propose two variations of these topologies, the Omega [7] and the Flip. The important characteristic of these two topologies is that they are built of rings of the same size.
Reference: [3] <author> Gregory F. Pfister and V. Alan Norton, </author> <title> "'Hot Spot' Contention and Combining in Multistage Interconnection Networks", </title> <booktitle> Proceedings of the 1985 International Conference on Parallel Processing, </booktitle> <pages> pp. 790-797, </pages> <month> August 20-23 </month> <year> 1985. </year>
Reference-contexts: This is not true in a real system. When we take into account the increase of message latencies as a function of system size, it is not clear if the logarithmic nature of the algorithm can be translated into logarithmic performance, regardless of topology and system size. Combining <ref> [3] </ref> has been proposed to reduce the bandwidth requirements of the STEM algorithm and possibly capture some geographical locality. Combining takes two requests that happen to be at the same time in a queue, and generates a single new request and a response to one of the original requests.
Reference: [4] <author> Marvin H. Solomon and Raphael A. Finkel, </author> <title> "Processor interconnection strategies," </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. C-29, </volume> <pages> pp. 360-371, </pages> <month> May </month> <year> 1980. </year>
Reference-contexts: Examples In trying to come up with examples of topologies we skipped the obvious topologies where our scheme would be an obvious fit. These include trees, snowflakes, dense snowflakes and star topologies <ref> [4] </ref>, the lens [5], and various other topologies. Although these are interesting topologies, we think that they are not mainstream and some of them also give an "unfair" advantage to our proposals by being so hierarchical in nature.
Reference: [5] <author> Raphael A. Finkel and Marvin H. Solomon, </author> <title> "The lens interconnection strategy," </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. C-30, no. 12, </volume> <month> December </month> <year> 1981. </year>
Reference-contexts: Examples In trying to come up with examples of topologies we skipped the obvious topologies where our scheme would be an obvious fit. These include trees, snowflakes, dense snowflakes and star topologies [4], the lens <ref> [5] </ref>, and various other topologies. Although these are interesting topologies, we think that they are not mainstream and some of them also give an "unfair" advantage to our proposals by being so hierarchical in nature.
Reference: [6] <author> William J. Dally and Charles L. Seitz, </author> <title> "Deadlock-Free Routing in Multiprocessor Interconnection Networks," </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. C-36, no. 5, </volume> <pages> pp. 547-553, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: In several cases, our schemes in the two example topologies outperform STEM. More details about performance will be given in the appropriate sections. 3.1. k-ary n-cube In this example the routing of requests is fixed in order to have deadlock free routing <ref> [6] </ref>. For example, in a k-ary 3-cube the request messages are routed first along x, then y and finally z dimensions 7 .
Reference: [7] <author> Duncan H. Lawrie, </author> <title> "Access and Alignment of Data in an Array Processor", </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 24, no. 12, </volume> <pages> pp. 1145-1155, </pages> <month> December </month> <year> 1975. </year>
Reference-contexts: A disadvantage of the topologies he suggested, is that the rings have a varying number of nodes. We propose two variations of these topologies, the Omega <ref> [7] </ref> and the Flip. The important characteristic of these two topologies is that they are built of rings of the same size. The ring-based Omega topology, has R rings per node, S stages, and N nodes per stage.
Reference: [8] <author> R. Simoni and M. Horowitz. </author> <title> Dynamic Pointer Allocation for Scalable Cache Coherence Directories. </title> <booktitle> Proceedings of the International Symposium on Shared Memory Multiprocessing, </booktitle> <year> 1991. </year>
Reference-contexts: Depending on the scheme used, it may be desirable that the amount of directory information stored vary over time. The problem of dynamically allocating space for directory information was nicely solved by Simoni and Horowitz <ref> [8] </ref> for a conventional directory scheme, where space is allocated at a centralized location. We propose that such techniques might also be applied at other, critical points in the system, where directory information might be strategically placed to minimize the distance necessary to acquire the information.
Reference: [9] <author> Steve L. Scott and James R. Goodman, </author> <title> "Performance of Pruning-Cache Directories for Large-Scale Multiprocessors," </title> <journal> IEEE Transaction on Parallel and Distributed Systems, </journal> <volume> Vol. 4, no. 5, </volume> <month> May </month> <year> 1993. </year>
Reference-contexts: Storing the information as a bitmap opens up a range of alternative algorithms, many using broadcast, and in particular, permits a pruning cache implementation in the style of that proposed by Scott and Goodman <ref> [9] </ref>. 3. Examples In trying to come up with examples of topologies we skipped the obvious topologies where our scheme would be an obvious fit. These include trees, snowflakes, dense snowflakes and star topologies [4], the lens [5], and various other topologies. <p> Finally, it may be useful to store information about nearby nodes that contain data using boolean variables to indicate which nodes contain data. Techniques similar to those proposed for pruning caches <ref> [9] </ref> can then be applied to store the critical directory information. In general, there are many possibilities. In this section we discuss various aspects of tag storage. We first present a simple implementation of the tags needed for k-ary trees.
Reference: [10] <author> J. L. Baer and W. H. Wang. </author> <title> "Architectural choices for multi level cache hierarchies," </title> <booktitle> Proc. 16th International Conference on Parallel Processing, </booktitle> <pages> pp. 258-261, </pages> <year> 1987. </year>
Reference-contexts: Destructive Rollout The simple solution, borrowed from hierarchical caches, is to maintain multilevel inclusion <ref> [10] </ref>. When a node rolls out it invalidates all of its descendents. In this case we should try to reduce conflict misses in the caches to a minimum. Tags of Type 2 TND and Type 3 TOD help minimize conflict misses.
Reference: [11] <author> John Carter, John Bennet and Willy Zwaenopoel, "Munin: </author> <title> Distributed Shared Memory Based on TypeSpecific Memory Coherence," </title> <booktitle> Proceedings of the Conference on the Principles and Practices of Parallel Programming, </booktitle> <year> 1990. </year> <month> 43 </month>
Reference-contexts: Protocols Current trends in research for distributed shared-memory parallel machines, favor the use of specialized protocols for different classes of shared data <ref> [11] </ref>. Several classes of shared data have being identified, including migratory, read-only, etc. [11,12]. This approach to shared memory assumes that the programmer and/or the compiler can identify the type of a datum. Subsequently, the underlying hardware or software layer is instructed to apply the proper protocol for the datum.
Reference: [12] <author> Wolf-Dietrich Weber and Anoop Gupta, </author> <title> "Analysis of Cache Invalidation Patterns in Multiprocessors," </title> <booktitle> ASPLOS III, </booktitle> <pages> pp. 243-256, </pages> <year> 1989. </year> <month> 44 </month>
References-found: 12

