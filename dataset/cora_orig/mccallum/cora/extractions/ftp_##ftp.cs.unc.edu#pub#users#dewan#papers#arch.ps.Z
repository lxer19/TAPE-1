URL: ftp://ftp.cs.unc.edu/pub/users/dewan/papers/arch.ps.Z
Refering-URL: http://www.cs.unc.edu/Research/cse.html
Root-URL: http://www.cs.unc.edu
Email: Email: dewan@cs.unc.edu  
Phone: Telephone: 919 962 1823 Fax: 919 962 1799  
Title: Multiuser architectures  
Author: P. Dewan 
Keyword: CSCW, collaborative systems, groupware, user interface tools, software architecture  
Address: Chapel Hill, N.C. 27599, U.S.A  
Affiliation: University of North Carolina Department of Computer Science  
Abstract: We hav e developed a framework for characterizing the design space of architectures of multiuser applications. It includes a generic multiuser architecture that captures properties common to the points in this design space, a set of issues that arise in the design of an instance of this architecture, a discussion of alternate approaches to resolving these issues, and several criteria for comparing the approaches. The generic architecture divides the (programmer-defined and system-provided) modules of an application into multiple layers, some of which interact with a single user while others are shared among all users. The design issues include the nature of these layers, replication, concurrency, and distribution of the layers, the nature of collaboration events exchanged among the layers, and how collaboration modules are added to existing single-user layers. The approaches make different tradeoffs in providing a balance between exibility, automation, code reuse, and performance. In this paper, we discuss the evaluation criteria, generic architecture, design issues, approaches, and tradeoffs. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Hussein Abdel-Wahab and Kevin Jeffay, </author> <title> Issues, Problems and Solutions in Sharing X Clients on Multiple Displays, Internetworking: </title> <journal> Research and Experience 5 pp. </journal> <pages> 1-15 (94). </pages>
Reference-contexts: Window-based: assumes that the bottom-most software layer is a window system [28] providing a specific window interface. It makes no assumptions regarding higher-level layers, which together form the window client. It is a popular architecture supported by shared window systems [24] such as VConf [23], Rapport [14], and XTV <ref> [1] </ref>. Widget-based: assumes that the layer above the window s ystem is a user-interface toolkit [28] managing toolkit widgets. The higher-level layers together form the toolkit client. It makes no assumption about the window layer but assumes one exists. <p> Thus it supports increased modifiability since a pseudo layer does not have to be changed in response to changes in the implementations of the original, single-user layers. This approach is supported in XTV <ref> [1] </ref>, which inserts a pseudo layer between an X server and client, and COLA [37], which provides a general mechanism, called adapters, for adding pseudo layers between layers of an object-oriented implementation of a single-user architecture. <p> For instance, in XTV, all communication between an X server and client must pass through a pseudo server process <ref> [1] </ref>. Second, a pseudo layer may need to duplicate the data structures and code of the original layers. For instance, an X pseudo server that allows only certain windows to be shared [26] must recreate the window tree hierarchy maintained by the X server.
Reference: 2. <author> Len Bass, </author> <title> Architectures for Interactive Software System: Rationale and Design, Tr ends in Software: Issue on User Interface Software 1 pp. </title> <publisher> 31-44 Wiley, </publisher> <year> (1993). </year>
Reference-contexts: 1 INTRODUCTION An important issue in the design of a software application is its overall architecture, that is, the nature of the components of the application and the communication among these components. While there has been much work done in characterizing architectures of single--user software <ref> [2, 21, 28, 29, 31] </ref>, there has been relatively little research addressing architectures of multiuser or collaborative software. We r efer to the former as single-user architectures and the latter as multiuser or collaboration architectures.
Reference: 3. <author> Thomas Berlage and Andreas Genau, </author> <title> A Framework for Shared Applications with Replicated Architecture, </title> <booktitle> Proceedings of Conference on User Interface Systems and Technology, </booktitle> <month> (November </month> <year> 1993). </year>
Reference-contexts: Access grant event: sent from concurrency control/access control modules to grant access to a user and triggered by an access request or release event. Command event: associated with a peer coupling event and sent to a peer layer to indicate the command invoked by the local user <ref> [3, 5, 33] </ref>. This event is used to insert the command into the remote history of undoable commands. The event is not sent if the peer coupling event contains enough information to reconstruct the command. <p> The event is not sent if the peer coupling event contains enough information to reconstruct the command. Remote undo event: sent to a remote layer to undo its actions in response to a local undo command <ref> [3, 5, 33] </ref>, and in an optimistic implementation of access/concurrency control, to undo actions that have later been found to be unauthorized or inconsistent. It is to be distinguished from an event sent to a layer to undo an action in response to a local command.
Reference: 4. <author> Eric A. Bier and Steve Freeman, MMM: </author> <title> A User Interface Architecture for Shared Editors on a Single Screen, </title> <booktitle> Proceedings of the 4th ACM SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <pages> pp. </pages> <month> 79-87 (November </month> <year> 1991). </year>
Reference-contexts: We will often refer to a collaboration-aware module as simply a collaboration module. The `generic' architecture described above does not capture properties of all current or possible multiuser architectures. For instance, its assumption that the hardware level is replicated does not apply to the MMM architecture <ref> [4] </ref>, which allows a single hardware layer to be shared by multiple users concurrently manipulating the same screen using different input devices.
Reference: 5. <author> Rajiv Choudhary and Prasun Dewan, </author> <title> A General Multi-User Undo/Redo Model, </title> <booktitle> Proceedings of European Conference on Computer Supported Work, </booktitle> <month> (October </month> <year> 1995). </year>
Reference-contexts: Access grant event: sent from concurrency control/access control modules to grant access to a user and triggered by an access request or release event. Command event: associated with a peer coupling event and sent to a peer layer to indicate the command invoked by the local user <ref> [3, 5, 33] </ref>. This event is used to insert the command into the remote history of undoable commands. The event is not sent if the peer coupling event contains enough information to reconstruct the command. <p> The event is not sent if the peer coupling event contains enough information to reconstruct the command. Remote undo event: sent to a remote layer to undo its actions in response to a local undo command <ref> [3, 5, 33] </ref>, and in an optimistic implementation of access/concurrency control, to undo actions that have later been found to be unauthorized or inconsistent. It is to be distinguished from an event sent to a layer to undo an action in response to a local command.
Reference: 6. <author> Terrence Crowley, Paul Milazzo, Ellie Baker, H arry Forsdick, and Raymond Tomlinson, MMConf: </author> <title> An Infrastructure for Building Shared Multimedia Applications, </title> <booktitle> Proc. of ACM Conference on Computer Supported Cooperative Work, </booktitle> <pages> pp. </pages> <month> 329-342 (October </month> <year> 1990). </year>
Reference-contexts: It allows a user to decide for each event whether it should trigger a potential collaboration event. It gives the user complete exibility but provides very low-level support. It is supported by the MMConf toolkit <ref> [6] </ref>, which allows programmers to choose whether a local input event should trigger a remote input event, and also by the Rendezvous constraint system, which allows users to define arbitrary constraints between peer objects.
Reference: 7. <author> Prasun Dewan and Marvin Solomon, </author> <title> An Approach to Support Automatic Generation of User Interfaces, </title> <journal> ACM Transactions on Programming Languages and Systems 12(4) pp. </journal> <month> 566-609 (October </month> <year> 1990). </year>
Reference-contexts: We leave it t o the reader to combine the properties of the different aspects of a specific architecture. 3 GENERIC ARCHITECTURE a hierarchy of layers. Together, these layers, support the editing model of user interaction <ref> [7, 11] </ref>. According to this model, each user interacts with an application by manipulating or editing visual representations of semantic objects in the application. Changes to semantic objects are triggered by user input, and in turn trigger output that causes the visual representations to change.
Reference: 8. <author> Prasun Dewan, </author> <title> A Tour of the Suite User Interface Software, </title> <booktitle> Proceedings of the 3rd ACM SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <pages> pp. </pages> <month> 57-65 (October </month> <year> 1990). </year>
Reference-contexts: It is implemented in Suite <ref> [8, 11] </ref>. We refer to the last two a rchitectures as UIMS-based architectures since they distinguish between the top-level semantic abstractions (active variables or models) and their interactors (views or interaction variables). Systems that make this distinction are referred to as User Interface Management Systems [31]. <p> Remote output events are automated in TeamWorkstation [19], which sends a workstation's RGB video signals to remote workstations, centralized shared window system such as XTV, which sends remote X output events, and Suite, which sends remote output events of the Suite UIMS <ref> [8] </ref>. Now consider an action in a layer that is triggered by the input received by a peer layer. There are many ways in which an action may be triggered in peer layers. Remote operation.
Reference: 9. <author> Prasun Dewan and Rajiv Choudhary, </author> <title> Experience with the Suite Distributed Object Model, </title> <booktitle> Proceedings of IEEE Workshop on Experimental Distributed Systems, </booktitle> <pages> pp. </pages> <month> 57-63 (October </month> <year> 1990). </year>
Reference-contexts: The distributed approach does not force the branch to execute on the local workstation since, depending on the workstation and network speed, it may in fact be sometimes advantageous to execute code on a fast remote workstation <ref> [9] </ref>. Moreover, this approach may not be possible if the file system and other parts of the computer environment accessed by the replicated layers are different on the different hosts.
Reference: 10. <author> Prasun Dewan and Rajiv Choudhary, </author> <title> Flexible User Interface Coupling in Collaborative Systems, </title> <booktitle> Proceedings of the ACM CHI'91 Conference, </booktitle> <pages> pp. </pages> <month> 41-49 (April </month> <year> 1991). </year>
Reference-contexts: The user simply expresses these choices, and the system automatically controls the triggering of access request, release, and check events to implement these choices. It is taken for coupling <ref> [10] </ref> and access control [35] by Suite, which defines a variety of high-level parameters controlling how these functions are performed.
Reference: 11. <author> Prasun Dewan and Rajiv Choudhary, </author> <title> A High-Level and Flexible Framework for Implementing Multiuser User Interfaces, </title> <journal> ACM Transactions on Information Systems 10(4) pp. </journal> <month> 345-380 (October </month> <year> 1992). </year>
Reference-contexts: Previous work on multiuser architectures has mainly consisted of identifying specific multiuser architectures such as the replicated and centralized window architectures [23], the Rendezvous abstraction-view architecture [18], and the Suite hybrid distributed architecture <ref> [11] </ref>. We hav e extended this research by developing a framework for characterizing the design space of these architectures. <p> Ideally an architecture should support arbitrary functionality, but, so far, it is has not been possible to attain this goal. For instance, architectures supported by shared window systems [24] do not support the asynchronous collaboration modes supported by the Suite architecture <ref> [11] </ref>, while the Suite architecture does not support arbitrary graphical user interfaces supported by the window system architectures. Thus the choice of an application architecture often constrains its functionality. <p> We leave it t o the reader to combine the properties of the different aspects of a specific architecture. 3 GENERIC ARCHITECTURE a hierarchy of layers. Together, these layers, support the editing model of user interaction <ref> [7, 11] </ref>. According to this model, each user interacts with an application by manipulating or editing visual representations of semantic objects in the application. Changes to semantic objects are triggered by user input, and in turn trigger output that causes the visual representations to change. <p> It is implemented in Suite <ref> [8, 11] </ref>. We refer to the last two a rchitectures as UIMS-based architectures since they distinguish between the top-level semantic abstractions (active variables or models) and their interactors (views or interaction variables). Systems that make this distinction are referred to as User Interface Management Systems [31]. <p> Extending single-user layers: One approach to including collaboration support in a multiuser architecture is to extend the layers of the single-user architecture by making them collaboration-aware [24]. This is the approach used in many multiuser architectures including Shared X [15], which extends the X window server, and Suite <ref> [11] </ref> which extends the layers managing interaction and active variables. However, it s upports limited reuse of existing software since it requires changes to the collaboration-aware layers. It also supports limited modifiability in that a single-layer implements both the interaction and collaboration functionality.
Reference: 12. <author> Prasun Dewan, </author> <title> Tools for Implementing Multiuser User Interfaces , Tr ends in Software: Issue on User Interface Software 1 pp. </title> <publisher> 149-172 Wiley, </publisher> <year> (1993). </year>
Reference-contexts: Similarly, its assumption that a layer interacting with a user is either shared or has peer layers interacting with other users does not apply to multiuser applications composed of arbitrary single-user modules communicating via remote procedure calls, a database management system, or a message server <ref> [12] </ref>. However, it d oes describe a large variety of multiuser architectures that have been developed in the CSCW area to explicitly support collaboration and serves as a `reference model' for these architectures.
Reference: 13. <author> Prasun Dewan, Rajiv Choudhary, and HongHai Shen, </author> <title> An Editing-based Characterization of the Design Space of Collaborative Applications, </title> <journal> Journal of Organizational Computing 4(3) pp. </journal> <month> 219-240 </month> <year> (1994). </year>
Reference-contexts: In <ref> [13] </ref> we survey some of the possible choices for performing some of these functions. We will evaluate the exibility of an architecture by determining which of these choices can be supported by it.
Reference: 14. <author> J.R. Ensor, S.R. Ahuja, D.N. Horn, and S.E. Lucco, </author> <title> The Rapport Multimedia Conferencing System: A Software Overview, </title> <booktitle> Proceedings of the 2nd IEEE Conference on Computer Workstations, </booktitle> <pages> pp. </pages> <month> 52-58 (March </month> <year> 1988). </year>
Reference-contexts: Window-based: assumes that the bottom-most software layer is a window system [28] providing a specific window interface. It makes no assumptions regarding higher-level layers, which together form the window client. It is a popular architecture supported by shared window systems [24] such as VConf [23], Rapport <ref> [14] </ref>, and XTV [1]. Widget-based: assumes that the layer above the window s ystem is a user-interface toolkit [28] managing toolkit widgets. The higher-level layers together form the toolkit client. It makes no assumption about the window layer but assumes one exists.
Reference: 15. <author> Daniel Garfinkel, Bruce Welti, and Thomas Yip, </author> <title> HP Shared X: A Tool for Real-Time Collaboration, </title> <journal> Hewlett-Packard Journal, </journal> <pages> pp. </pages> <month> 23-24 (April </month> <year> 1994). </year>
Reference-contexts: Extending single-user layers: One approach to including collaboration support in a multiuser architecture is to extend the layers of the single-user architecture by making them collaboration-aware [24]. This is the approach used in many multiuser architectures including Shared X <ref> [15] </ref>, which extends the X window server, and Suite [11] which extends the layers managing interaction and active variables. However, it s upports limited reuse of existing software since it requires changes to the collaboration-aware layers.
Reference: 16. <author> T. C. Nicholas Graham and Tore Urnes, </author> <title> Relational Views as a Model for Automatic Distributed Implementation of Multi-User Applications, </title> <booktitle> Proceedings of the ACM Conference on Computer Supported Cooperative Work, </booktitle> <pages> pp. </pages> <month> 59-66 (November </month> <year> 1992). </year>
Reference-contexts: For instance, the Smalltalk view layer has been implemented on top of different window systems, the architecture makes no assumption about the nature of the window system. This architecture is implemented in the Rendezvous [18] and Weasel <ref> [16] </ref> systems. Active Variable: assumes that there are two layers managing active variables and interaction variables, respectively.
Reference: 17. <author> Irene Greif, Robert Seliger, and William Weihl, </author> <title> Atomic Data Abstractions in a Distributed Collaborative Editing System, </title> <booktitle> ACM C onference record of POPL, </booktitle> <month> (January </month> <year> 1986). </year>
Reference-contexts: Access release event: triggered by a user's explicit request to release a lock, or implicitly by an input command implying access release, or by a timer event (to implement tickle locks <ref> [17] </ref> ). Access grant event: sent from concurrency control/access control modules to grant access to a user and triggered by an access request or release event.
Reference: 18. <author> Ralph Hill, Tom Brinck, Steven Rohall, John Patterson, and Wayne Wilner, </author> <title> The Rendezvous Architecture and Language for Constructing Multiuser Applications, </title> <booktitle> ACM Tr ansactions on Computer Human Interaction 1(2)(June 1994). </booktitle>
Reference-contexts: We r efer to the former as single-user architectures and the latter as multiuser or collaboration architectures. Previous work on multiuser architectures has mainly consisted of identifying specific multiuser architectures such as the replicated and centralized window architectures [23], the Rendezvous abstraction-view architecture <ref> [18] </ref>, and the Suite hybrid distributed architecture [11]. We hav e extended this research by developing a framework for characterizing the design space of these architectures. <p> For instance, the Smalltalk view layer has been implemented on top of different window systems, the architecture makes no assumption about the nature of the window system. This architecture is implemented in the Rendezvous <ref> [18] </ref> and Weasel [16] systems. Active Variable: assumes that there are two layers managing active variables and interaction variables, respectively.
Reference: 19. <author> Hirsoshi Ishii and Masaaki Ohkubo, </author> <title> Design of a Team Workstation, </title> <booktitle> Multi-User Interfaces and Applications, </booktitle> <pages> pp. </pages> <address> 131-142 North Holland, </address> (). 
Reference-contexts: Workstation-based: assumes that the hardware layer is a specific workstation. It makes no assumptions regarding higher-level layers, it only assumes that they interact with the hardware using a specific hardware interface. This approach is supported by Team Workstation <ref> [19] </ref>. Window-based: assumes that the bottom-most software layer is a window system [28] providing a specific window interface. It makes no assumptions regarding higher-level layers, which together form the window client. <p> A remote output event can be automated by a system that can trap local output events and invoke output events in remote layers. The system is bound to the protocol used for trapping and invoking these events. Remote output events are automated in TeamWorkstation <ref> [19] </ref>, which sends a workstation's RGB video signals to remote workstations, centralized shared window system such as XTV, which sends remote X output events, and Suite, which sends remote output events of the Suite UIMS [8].
Reference: 20. <author> E. Jul, H. Levy, N. Hutchinson, and A. Black, </author> <title> Fine-Grained Mobility in the Emerald System, </title> <booktitle> ACM TOCS, (). Originally presented at the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <address> Austin, TX, </address> <month> 8-11 November </month> <year> 1987 </year>
Reference-contexts: Like the maximal-concurrent approach, it is possible to imagine a maximal-distributed approach that dynamically assigns an application module to the workstation accessing it the `most'. However, such an approach is still a subject of research <ref> [20] </ref>. A p ractical compromise that is easier to automate is the distributed approach which is analogous to the concurrent approach. It allows the branches and the stem of a multiuser application to execute on separate address spaces and hosts.
Reference: 21. <author> Rick Kazman, Len Bass, Gregory Abowd, and Mike Webb, SAAM: </author> <title> A Method for Analyzing the Properties of Software Architectures, </title> <booktitle> Proc. of International Conference on Software Engineering, </booktitle> <pages> pp. </pages> <month> 81-90 (May </month> <year> 1994). </year>
Reference-contexts: 1 INTRODUCTION An important issue in the design of a software application is its overall architecture, that is, the nature of the components of the application and the communication among these components. While there has been much work done in characterizing architectures of single--user software <ref> [2, 21, 28, 29, 31] </ref>, there has been relatively little research addressing architectures of multiuser or collaborative software. We r efer to the former as single-user architectures and the latter as multiuser or collaboration architectures. <p> Future work is also necessary to determine if it is possible to develop a ``collaboration kernel'' that provides implementation of some of these events (such as multicasting remote output) for a variety of systems. This work is related to the SAAM model for describing architectures of software systems <ref> [21] </ref>.
Reference: 22. <author> Glenn E. Krasner and Stephen T. Pope, </author> <title> A Cookbook for Using the Model-View-Controller User Interface Paradigm in Smalltalk-80, </title> <journal> Journal of Object-Oriented Programming 1(3) pp. </journal> <month> 26-49 (August/September </month> <year> 1988 </year> ). 
Reference-contexts: A model is a semantic object and a view is an interactor that transforms the semantic object into a representation of it. The usage of the term model and view here is consistent with the model/view/controller terminology of Smalltalk <ref> [22] </ref> except that in this terminology a view is a combination of a Smalltalk view and controller.
Reference: 23. <author> Keith A. Lantz, </author> <title> An Experiment in Integrated Multimedia Conferencing, </title> <booktitle> Proceedings of Conference on Computer-Supported Cooperative Work, </booktitle> <pages> pp. </pages> <month> 267-275 (December </month> <year> 1986). </year>
Reference-contexts: We r efer to the former as single-user architectures and the latter as multiuser or collaboration architectures. Previous work on multiuser architectures has mainly consisted of identifying specific multiuser architectures such as the replicated and centralized window architectures <ref> [23] </ref>, the Rendezvous abstraction-view architecture [18], and the Suite hybrid distributed architecture [11]. We hav e extended this research by developing a framework for characterizing the design space of these architectures. <p> Window-based: assumes that the bottom-most software layer is a window system [28] providing a specific window interface. It makes no assumptions regarding higher-level layers, which together form the window client. It is a popular architecture supported by shared window systems [24] such as VConf <ref> [23] </ref>, Rapport [14], and XTV [1]. Widget-based: assumes that the layer above the window s ystem is a user-interface toolkit [28] managing toolkit widgets. The higher-level layers together form the toolkit client. It makes no assumption about the window layer but assumes one exists. <p> This approach can be automatically supported by a system that can trap input events of a layer. Howev er, the automating system is bound to the protocol followed in the transmission of the input events. This approach is supported in the replicated window systems such as VConf <ref> [23] </ref>, which sends a user's input to all replicas of the application. Extended input: It is not always possible to implement remote input between arbitrary layers since it may not be possible to change some layers or trap input events sent/received by them.
Reference: 24. <author> J.C. Lauwers and K.A. Lantz, </author> <title> Collaboration Awareness in Support of Collaboration Transparency: Requirements for the Next Generation of Shared Window Systems, </title> <booktitle> Proceedings of ACM CHI'90, </booktitle> <pages> pp. </pages> <month> 303-312 (April </month> <year> 1990). </year>
Reference-contexts: Perhaps the most important of these is the the functionality that can be supported by the architecture. Ideally an architecture should support arbitrary functionality, but, so far, it is has not been possible to attain this goal. For instance, architectures supported by shared window systems <ref> [24] </ref> do not support the asynchronous collaboration modes supported by the Suite architecture [11], while the Suite architecture does not support arbitrary graphical user interfaces supported by the window system architectures. Thus the choice of an application architecture often constrains its functionality. <p> This approach is supported by Team Workstation [19]. Window-based: assumes that the bottom-most software layer is a window system [28] providing a specific window interface. It makes no assumptions regarding higher-level layers, which together form the window client. It is a popular architecture supported by shared window systems <ref> [24] </ref> such as VConf [23], Rapport [14], and XTV [1]. Widget-based: assumes that the layer above the window s ystem is a user-interface toolkit [28] managing toolkit widgets. The higher-level layers together form the toolkit client. It makes no assumption about the window layer but assumes one exists. <p> We consider below some of the constraints that have been put on them to support automation and reuse. Extending single-user layers: One approach to including collaboration support in a multiuser architecture is to extend the layers of the single-user architecture by making them collaboration-aware <ref> [24] </ref>. This is the approach used in many multiuser architectures including Shared X [15], which extends the X window server, and Suite [11] which extends the layers managing interaction and active variables. However, it s upports limited reuse of existing software since it requires changes to the collaboration-aware layers.
Reference: 25. <author> Mark A. Linton, John M. Vlissides, and Paul R. Calder, </author> <title> Composing User Interfaces with InterViews, </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. </pages> <month> 8-24 (February </month> <year> 1989). </year>
Reference-contexts: The higher-level layers together form the toolkit client. It makes no assumption about the window layer but assumes one exists. It has been implemented in GroupKit [34], which was initially based on the InterViews toolkit <ref> [25] </ref> is now based on the TK toolkit [30]. Model/View: assumes that the existence of two layers managing models and views, respectively. A model is a semantic object and a view is an interactor that transforms the semantic object into a representation of it.
Reference: 26. <author> John Menges and Kevin Jeffay, </author> <title> Inverting X: An Archictecture for a Shared Distribyed Window System, </title> <booktitle> Proceedings of the Third Workshop on Enabling Technogies: Infrastructure for Collaborative Enterprises, </booktitle> <pages> pp. </pages> <month> 53-64 (April </month> <year> 1994). </year>
Reference-contexts: It allows users to think in terms of high-level state changes rather than low-level events and procedures that trigger these changes. This approach is supported in Suite, which allows attributes of interaction variables to be coupled, and Concur <ref> [26] </ref>, which allows window attributes to be coupled. It could also be applied to a toolkit-based system to allow peer widgets to share selected resources. We refer to events sent between peers to implement coupling as peer coupling events. <p> Second, a pseudo layer may need to duplicate the data structures and code of the original layers. For instance, an X pseudo server that allows only certain windows to be shared <ref> [26] </ref> must recreate the window tree hierarchy maintained by the X server. A related issue is which levels of the architecture must be made collaboration-aware, that is, at which levels are collaboration modules added to existing layers or new pseudo layers introduced.
Reference: 27. <author> Jon Munson and Prasun Dewan, </author> <title> A Flexible Object Merging Framework, </title> <booktitle> Proceedings of the ACM Conference on Computer Supported Cooperative Work, </booktitle> <pages> pp. </pages> <month> 231-242 (Octo-ber </month> <year> 1994). </year>
Reference-contexts: For instance, a toolkit can undo an X display by redrawing it instead of sending an undo event to the display.) Merge event: sent to merge modules to ask them to merge peer layers <ref> [27] </ref>. It may trigger other events (such as remote input events) that change the state of the abstractions in the peer layers. Join/leave event: Sent to conference management modules in response to a user request to join/leave a conference.
Reference: 28. <author> Brad Myers, </author> <title> User Interface Software Tools, </title> <journal> ACM Transactions on Computer-Human Interaction 2(1) pp. </journal> <month> 64-103 (March </month> <year> 1995). </year>
Reference-contexts: 1 INTRODUCTION An important issue in the design of a software application is its overall architecture, that is, the nature of the components of the application and the communication among these components. While there has been much work done in characterizing architectures of single--user software <ref> [2, 21, 28, 29, 31] </ref>, there has been relatively little research addressing architectures of multiuser or collaborative software. We r efer to the former as single-user architectures and the latter as multiuser or collaboration architectures. <p> It makes no assumptions regarding higher-level layers, it only assumes that they interact with the hardware using a specific hardware interface. This approach is supported by Team Workstation [19]. Window-based: assumes that the bottom-most software layer is a window system <ref> [28] </ref> providing a specific window interface. It makes no assumptions regarding higher-level layers, which together form the window client. It is a popular architecture supported by shared window systems [24] such as VConf [23], Rapport [14], and XTV [1]. <p> It makes no assumptions regarding higher-level layers, which together form the window client. It is a popular architecture supported by shared window systems [24] such as VConf [23], Rapport [14], and XTV [1]. Widget-based: assumes that the layer above the window s ystem is a user-interface toolkit <ref> [28] </ref> managing toolkit widgets. The higher-level layers together form the toolkit client. It makes no assumption about the window layer but assumes one exists. It has been implemented in GroupKit [34], which was initially based on the InterViews toolkit [25] is now based on the TK toolkit [30].
Reference: 29. <author> Laurence Nigay and Joelle Coutaz, </author> <title> A Design Space for Multimodal Systems: Concurrent Processing and Data Fusion, </title> <booktitle> Proceedings of INTERCHI'93, </booktitle> <pages> pp. </pages> <month> 172-178 (April </month> <year> 1993). </year>
Reference-contexts: 1 INTRODUCTION An important issue in the design of a software application is its overall architecture, that is, the nature of the components of the application and the communication among these components. While there has been much work done in characterizing architectures of single--user software <ref> [2, 21, 28, 29, 31] </ref>, there has been relatively little research addressing architectures of multiuser or collaborative software. We r efer to the former as single-user architectures and the latter as multiuser or collaboration architectures. <p> does the architecture look like from the point of view of a single-user, that is, what is the nature of the various levels in the architecture, the abstractions at each level, and the interaction events communicated up/down these levels? This dimension corresponds to the `levels of abstraction' dimension defined in <ref> [29] </ref>, which classifies architecture levels into `meaning' and `no meaning' levels based on whether they capture the semantics of the application. The single-user architecture dimension is more specific and describes the nature of the various levels of the architec ture. <p> The single-user architecture dimension is more specific and describes the nature of the various levels of the architec ture. Concurrency : Which layers execute in separate threads? The concurrency dimension corresponds to the `modalities' dimension defined in <ref> [29] </ref>, which classifies systems into serial and parallel. The concurrency dimension is more specific and defines multiple levels of parallelism. <p> Unlike the maximal-concurrent approach, this approach does not allow the actions in a stem invoked by different users to be processed concurrently. Moreover, it d oes not address concurrent execution of independent actions invoked by a single-user, which may be usedful, for instance, to support multimodal interaction <ref> [29] </ref>. However, it d oes allow the computation of the local feedback by different users to be performed concurrently. More important, it can be completely automated by a system that knows about the branches and stem of the architecture. However, not all systems assume this information.
Reference: 30. <author> John K. Ousterhout, </author> <title> Tcl and the Tk Toolkit, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass. </address> <year> (1994). </year>
Reference-contexts: The higher-level layers together form the toolkit client. It makes no assumption about the window layer but assumes one exists. It has been implemented in GroupKit [34], which was initially based on the InterViews toolkit [25] is now based on the TK toolkit <ref> [30] </ref>. Model/View: assumes that the existence of two layers managing models and views, respectively. A model is a semantic object and a view is an interactor that transforms the semantic object into a representation of it.
Reference: 31. <author> G. Pfaff, </author> <title> User Interface Management Systems, </title> <publisher> Springer Verlag, </publisher> <address> Englewood Cliffs, NJ (1985). </address>
Reference-contexts: 1 INTRODUCTION An important issue in the design of a software application is its overall architecture, that is, the nature of the components of the application and the communication among these components. While there has been much work done in characterizing architectures of single--user software <ref> [2, 21, 28, 29, 31] </ref>, there has been relatively little research addressing architectures of multiuser or collaborative software. We r efer to the former as single-user architectures and the latter as multiuser or collaboration architectures. <p> We refer to the last two a rchitectures as UIMS-based architectures since they distinguish between the top-level semantic abstractions (active variables or models) and their interactors (views or interaction variables). Systems that make this distinction are referred to as User Interface Management Systems <ref> [31] </ref>. The assumptions made by these different architectures are not mutually exclusive. For instance, it is possible to combine the assumptions of the object-based and window-based architecture in an architecture that encapsulates all abstractions as objects and provides a predefined layer supporting window objects.
Reference: 32. <author> Rob Pike, </author> <title> 81/2, The Plan 9 Window System, </title> <booktitle> Proceedings of the Summer 1990 Usenix Conference, </booktitle> <pages> pp. </pages> <month> 257-265 (June </month> <year> 1991). </year>
Reference-contexts: For instance, the set of approaches used in XTV can be used to develop a shared window system based on a different network single-user window system such as the Plan 9 window system <ref> [32] </ref>. A more novel use of the framework would be to use to choose a new set of these approaches. For instance, a new version of Suite can be developed that supports a fully replicated architecture.
Reference: 33. <author> Atul Prakash and Michael J. Knister, </author> <title> Undoing Actions in Collaborative Work, </title> <booktitle> Proceedings of the ACM Conference on Computer Supported Cooperative Work, </booktitle> <pages> pp. </pages> <month> 273-280 (November </month> <year> 1992). </year>
Reference-contexts: Access grant event: sent from concurrency control/access control modules to grant access to a user and triggered by an access request or release event. Command event: associated with a peer coupling event and sent to a peer layer to indicate the command invoked by the local user <ref> [3, 5, 33] </ref>. This event is used to insert the command into the remote history of undoable commands. The event is not sent if the peer coupling event contains enough information to reconstruct the command. <p> The event is not sent if the peer coupling event contains enough information to reconstruct the command. Remote undo event: sent to a remote layer to undo its actions in response to a local undo command <ref> [3, 5, 33] </ref>, and in an optimistic implementation of access/concurrency control, to undo actions that have later been found to be unauthorized or inconsistent. It is to be distinguished from an event sent to a layer to undo an action in response to a local command.
Reference: 34. <author> Mark Roseman and Saul Greenberg, GroupKit: </author> <title> A Groupware Toolkit for Building Real-Time Conferencing Applications, </title> <booktitle> Proceedings of the ACM Conference on Computer Supported Cooperative Work, </booktitle> <month> (November </month> <year> 1992). </year>
Reference-contexts: Widget-based: assumes that the layer above the window s ystem is a user-interface toolkit [28] managing toolkit widgets. The higher-level layers together form the toolkit client. It makes no assumption about the window layer but assumes one exists. It has been implemented in GroupKit <ref> [34] </ref>, which was initially based on the InterViews toolkit [25] is now based on the TK toolkit [30]. Model/View: assumes that the existence of two layers managing models and views, respectively. <p> These problem may be reduced but not eliminated if these layers are coded in an object-oriented programming language, since the changes may be localized in high-level classes and automatically inherited by unchanged lower-level classes <ref> [34, 37] </ref>. Moreover, it s upports limited automation since it requires changes to each implementation of a layer to be changed, ev en if all of these implementations provide the same interface. Finally, it is not viable if the source code of the layer to be changed is not available.
Reference: 35. <author> Honghai Shen and Prasun Dewan, </author> <title> Access Control for Collaborative Environments, </title> <booktitle> Proceedings of the ACM Conference on Computer Supported Cooperative Work, </booktitle> <pages> pp. </pages> <month> 51-58 (November </month> <year> 1992). </year>
Reference-contexts: The user simply expresses these choices, and the system automatically controls the triggering of access request, release, and check events to implement these choices. It is taken for coupling [10] and access control <ref> [35] </ref> by Suite, which defines a variety of high-level parameters controlling how these functions are performed.
Reference: 36. <author> Mark Stefik, Gregg Foster, Daniel G. Bobrow, Kenneth Kahn, Stan Lanning, and Lucy Suchman, </author> <title> Beyond the Chalkboard: Computer Support for Collaboration and Problem Solving in Meetings, </title> <journal> CACM 30(1) pp. </journal> <month> 32-47 (January </month> <year> 1987). </year>
Reference-contexts: Object-based: assumes that an application consists of arbitrary objects described by some object-based programming language [38]. It makes no assumptions regarding the layers and abstractions of the application. This architecture is supported by the Xerox Colab programming environment <ref> [36] </ref> and the COLA platform [37]. Workstation-based: assumes that the hardware layer is a specific workstation. It makes no assumptions regarding higher-level layers, it only assumes that they interact with the hardware using a specific hardware interface. This approach is supported by Team Workstation [19]. <p> The system can be fairly general in that it does not need to be bound to a specific set of abstractions. This approach is supported by the Colab programming environment <ref> [36] </ref> which remotely invokes methods of an object described by the Colab object oriented language. Remote input: An input event sent to a layer in response to an action of its user is also sent as an input event to a peer of the layer. <p> Such an approach would automatically support WYSI-WIS coupling in a replicated architecture, but it is not clear what the impact of increasing the overhead of executing every call would be. It is perhaps for this reason that the Colab programming environment <ref> [36] </ref> requires programmers to specify which operations must be invoked remotely. So far, we hav e considered only events that implement coupling.
Reference: 37. <author> Jonathon Trev or, Tom Rodden, and John Mariani, </author> <title> The Use of Adapters to Support Cooperative Sharing, </title> <booktitle> Proceedings of the ACM Conference on Computer Supported Cooperative Work, </booktitle> <pages> pp. </pages> <month> 219-230 (October </month> <year> 1994). </year>
Reference-contexts: Object-based: assumes that an application consists of arbitrary objects described by some object-based programming language [38]. It makes no assumptions regarding the layers and abstractions of the application. This architecture is supported by the Xerox Colab programming environment [36] and the COLA platform <ref> [37] </ref>. Workstation-based: assumes that the hardware layer is a specific workstation. It makes no assumptions regarding higher-level layers, it only assumes that they interact with the hardware using a specific hardware interface. This approach is supported by Team Workstation [19]. <p> These problem may be reduced but not eliminated if these layers are coded in an object-oriented programming language, since the changes may be localized in high-level classes and automatically inherited by unchanged lower-level classes <ref> [34, 37] </ref>. Moreover, it s upports limited automation since it requires changes to each implementation of a layer to be changed, ev en if all of these implementations provide the same interface. Finally, it is not viable if the source code of the layer to be changed is not available. <p> Thus it supports increased modifiability since a pseudo layer does not have to be changed in response to changes in the implementations of the original, single-user layers. This approach is supported in XTV [1], which inserts a pseudo layer between an X server and client, and COLA <ref> [37] </ref>, which provides a general mechanism, called adapters, for adding pseudo layers between layers of an object-oriented implementation of a single-user architecture.

References-found: 37

