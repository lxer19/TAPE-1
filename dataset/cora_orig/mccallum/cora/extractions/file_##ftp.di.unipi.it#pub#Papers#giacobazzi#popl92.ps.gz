URL: file://ftp.di.unipi.it/pub/Papers/giacobazzi/popl92.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: (barbuti,codish,giaco,levi)@dipisa.di.unipi.it  
Title: Modelling Prolog Control  
Author: Roberto Barbuti, Michael Codish, Roberto Giacobazzi, Giorgio Levi 
Note: This work has been supported by "Progetto Finalizzato Sis-temi Informatici  under grant n. 9100880.PF69 and by the Esprit Basic Research Action 3012 Compulog. In proceedings of ACM POPL'92.  
Address: Corso Italia 40, 56125 Pisa  
Affiliation: Dipartimento di Informatica Universita di Pisa  e Calcolo Parallelo" of C.N.R.  
Abstract: The goal of this paper is to construct a semantic basis for the abstract interpretation of Prolog programs. Prolog is a well-known logic programming language which applies a depth-first search strategy in order to provide a practical approximation of Horn clause logic. While pure logic programming has clean fix-point, model-theoretic and operational semantics the situation for Prolog is different. Difficulties in capturing the declarative meaning of Prolog programs have led to various semantic definitions which attempt to encode the search strategy in different mathematical frameworks. However semantic based analyses of Pro-log are typically achieved by abstracting the more simple but less precise declarative semantics of pure logic Programs. We propose instead to model Prolog control in a simple constraint logic language which is presented together with its declarative and operational semantics. This enables us to maintain the usual approach to declarative semantics of logic programs while capturing control aspects such as search strategy and selection rule. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics. </booktitle> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: Section 6 describes related work and concludes. Full proofs, not included due to space limitations, are present in the full version of this paper. 2 Preliminaries In the following we assume familiarity with constraint logic programming (CLP) [16] and logic programming theory <ref> [1, 19] </ref>. Let and Var be denumerable sets of function symbols, and variables respectively; T () and T (; Var) denote the corresponding ground and non-ground term algebras respectively.
Reference: [2] <author> K. R. Apt and D. Pedreschi. </author> <title> Proving Termination of General Prolog Programs. </title> <booktitle> In Proc. of Int. Conf. on Theoretical Aspects of Computer Software, Sendai, </booktitle> <address> Japan, </address> <year> 1991. </year>
Reference-contexts: Define: resolve : Atom fl fi Clause ! 2 Atom fl by: resolve (G ; H Body ) = (Body :: B)fH = Ag if G = A j B, ; otherwise. The following definition is motivated by the observation (e.g. <ref> [2] </ref>) that when reasoning about termination of all solutions for a goal with a Prolog program, it is possible to ignore depth first search and hence to consider the corresponding SLD tree (with a left-to-right selection rule). The proof of this observation is straightforward. <p> Because the declarative semantics of t is both simple and in the usual T P style it provides a suitable basis for abstract interpretation of Prolog via the defined transformation. The required termination theory can be approximated either by integrating results on Prolog termination (e.g. <ref> [2, 7, 21, 23] </ref>) or by extending the t language so as to model termination from within and applying abstract interpretation.
Reference: [3] <author> B. Arbab and D.M. Berry. </author> <title> Operational and De-notational Semantics of Prolog. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 309-330, </pages> <year> 1987. </year>
Reference-contexts: The semantics of Prolog is usually specified by encoding its (sequential) control within different frameworks such as dynamic algebras [6], deterministic transition systems [12] or denotational semantics <ref> [17, 3, 13] </ref>. However, (semantics-based) analyses of Prolog are usually achieved by abstracting the more simple but less precise semantics of pure logic programs. Unfortunately, it is not straightforward to encode Prolog control directly in terms of pure logic programs.
Reference: [4] <author> F. Bancilhon, D. Maier, Y. Sagiv, J. D, Ullman. </author> <title> Magic Sets and Other Strange Ways to Implement Logic Programs. </title> <booktitle> Proccedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> Cambridge, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: The key idea is to enhance a program P by a transformation M so that the standard meaning of M (P ) reflects the control information required for the analysis of P. So for example, the declarative meaning of a logic program P enhanced by a "magic set" transformation <ref> [4] </ref> is shown to reflect the call patterns of P enabling bottom-up analysis (e.g.[5, 10, 20]).
Reference: [5] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs. </title> <type> Technical Report TR 12/91, </type> <institution> Dipartimento di Infor-matica, Universita di Pisa, </institution> <year> 1991. </year> <note> Submitted for publication. </note>
Reference: [6] <author> E. Borger. </author> <title> A logical operational semantics of full Prolog. </title> <editor> In E.Borger, H. Kleine, H. Buning, and M. Richter, editors, </editor> <booktitle> CSL 89. 3rd workshop on Computer Science Logic, volume 440 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: In this paper we apply the idea of modelling control to define a declarative semantics for Prolog with the intention of providing a semantic basis for program analysis. The semantics of Prolog is usually specified by encoding its (sequential) control within different frameworks such as dynamic algebras <ref> [6] </ref>, deterministic transition systems [12] or denotational semantics [17, 3, 13]. However, (semantics-based) analyses of Prolog are usually achieved by abstracting the more simple but less precise semantics of pure logic programs. Unfortunately, it is not straightforward to encode Prolog control directly in terms of pure logic programs.
Reference: [7] <author> A. Bossi, N. Cocco, and M. Fabris. </author> <title> Proving Termination of Logic Programs by Exploiting Term Properties. </title> <editor> In S. Abramsky T.S.E. Maibaum, editor, </editor> <booktitle> Proc. TAPSOFT'91, volume 494 of Lecture Notes in Computer Science, </booktitle> <pages> pages 153-180. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: Because the declarative semantics of t is both simple and in the usual T P style it provides a suitable basis for abstract interpretation of Prolog via the defined transformation. The required termination theory can be approximated either by integrating results on Prolog termination (e.g. <ref> [2, 7, 21, 23] </ref>) or by extending the t language so as to model termination from within and applying abstract interpretation.
Reference: [8] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Contributions to the Semantics of Open Logic Programs. </title> <type> Technical report, </type> <institution> Dipartimento di In-formatica, Universita di Pisa, </institution> <year> 1991. </year>
Reference-contexts: 2 p (y ) T ! P htrue : y = 0i 2: The success set of P with respect to T is fp (0); p (s (0)); p (s (s (0))); : : :g: 3.3 Declarative semantics We now define a declarative semantics for t programs which is open <ref> [8] </ref> with respect to the interpretation of ask constraints. It is defined in terms of unfoldings of clauses [18] which contain uninterpreted ask conditions. This approach facilitates separation of termination from computation when applied to modelling Prolog control.
Reference: [9] <author> M. Bruynooghe, G. Janssens, B. Demoen, and A. Callebaut. </author> <title> Abstract Interpretation: Towards the Global Optimization of Prolog Programs. </title> <booktitle> In Proc Fourth IEEE Symp. Logic Programming, </booktitle> <pages> pages 192-204. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1987. </year>
Reference-contexts: It is no coincidence that in most cases practical abstract interpretations of logic programs approximate top-down semantics based on SLD resolution (e.g. <ref> [9] </ref>). The information concerning control and textual details of a program are more naturally recovered (and collected) from such semantics. An alternative approach is taken in [10] and further pursued in this paper.
Reference: [10] <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, The Weizmann Institute, Rehovot, </institution> <year> 1990. </year> <note> Submitted for publication. </note>
Reference-contexts: It is no coincidence that in most cases practical abstract interpretations of logic programs approximate top-down semantics based on SLD resolution (e.g. [9]). The information concerning control and textual details of a program are more naturally recovered (and collected) from such semantics. An alternative approach is taken in <ref> [10] </ref> and further pursued in this paper. Instead of enhancing the semantic basis for analysis to capture control | the program itself is enhanced so that its standard meaning reflects the required control.
Reference: [11] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. Fourth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: The meaning of a Prolog program is constructed by composing the meaning of the appropriate t program (the "logic component") with a corresponding termination theory (the "control component"). This approach supports the analysis of Pro-log programs based on the abstract interpretation <ref> [11] </ref> of t programs consisting of two corresponding components: (1) a standard analysis for the logic component of the program; and (2) a termination analysis for the control component. An approximate model for termination can be provided either by applying techniques of abstract interpretation or by applying proof procedures.
Reference: [12] <author> A. de Bruin and E. de Vink. </author> <title> Continuation semantics for Prolog with cut. </title> <editor> In J. Diaz and F. Ore-jas, editors, </editor> <booktitle> Proc. CAAP 89, volume 351 of Lecture Notes in Computer Science, </booktitle> <pages> pages 178-192. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference-contexts: The semantics of Prolog is usually specified by encoding its (sequential) control within different frameworks such as dynamic algebras [6], deterministic transition systems <ref> [12] </ref> or denotational semantics [17, 3, 13]. However, (semantics-based) analyses of Prolog are usually achieved by abstracting the more simple but less precise semantics of pure logic programs. Unfortunately, it is not straightforward to encode Prolog control directly in terms of pure logic programs.
Reference: [13] <author> S. K. Debray and P. Mishra. </author> <title> Denotational and Operational Semantics for Prolog. </title> <editor> In M. Wirs-ing, editor, </editor> <booktitle> Formal Description of Programming Concepts III, </booktitle> <pages> pages 245-269. </pages> <publisher> North-Holland, </publisher> <address> Am-sterdam, </address> <year> 1987. </year>
Reference-contexts: The semantics of Prolog is usually specified by encoding its (sequential) control within different frameworks such as dynamic algebras [6], deterministic transition systems [12] or denotational semantics <ref> [17, 3, 13] </ref>. However, (semantics-based) analyses of Prolog are usually achieved by abstracting the more simple but less precise semantics of pure logic programs. Unfortunately, it is not straightforward to encode Prolog control directly in terms of pure logic programs.
Reference: [14] <author> S.K. Debray and N.W. Lin. </author> <title> Automatic Complexity Analysis of Logic Programs. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 599-613. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: from below: T b T Prolog (P ) ) F (P t )[T b ](fl) F (P t )[T Prolog (P )](fl) hence providing an approximation from below of the (Prolog) success set for P which can be useful for example in the context of the complexity analysis described in <ref> [14] </ref>.
Reference: [15] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: The (non-ground) success set of a t program is specified (similar to the case of logic programs, e.g. <ref> [15] </ref>) in terms of the atomic goals of the form htrue : truei 2 p (x ) which have successful computations as specified by the transitive closure of the transition relation (given a termination theory T ).
Reference: [16] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: Section 5 discusses the interpretation of the termination conditions. Section 6 describes related work and concludes. Full proofs, not included due to space limitations, are present in the full version of this paper. 2 Preliminaries In the following we assume familiarity with constraint logic programming (CLP) <ref> [16] </ref> and logic programming theory [1, 19]. Let and Var be denumerable sets of function symbols, and variables respectively; T () and T (; Var) denote the corresponding ground and non-ground term algebras respectively. <p> A t program consists of ask-tell constrained clauses as in the cc paradigm [22]. However in contrast with the cc framework, ask and tell constraints will be interpreted over different algebraic structures: * Tell constraints are interpreted over the usual Herbrand system, H <ref> [16] </ref>. * Ask constraints correspond to semi-decidable tests which are intended to specify termination conditions (applied below to model termination of Prolog goals). <p> A pair in the relation corresponds to the reduction of a goal with a renamed clause from the program. The conditions on the tell parts of the goal and clause are the standard ones (e.g. CLP (H) <ref> [16] </ref>). At each step the ask conditions of the chosen clause are tested with respect to a "current" store and resolvent. Ask constraints are not collected since downward closure of T implies that any test sat isfied in a store will be continuously satisfied in subsequent (updated) stores.
Reference: [17] <author> N. D. Jones and A. Mycroft. </author> <title> Stepwise Development of Operational and Denotational Semantics for Prolog. </title> <editor> In Sten -Ake Tarnlund, editor, </editor> <booktitle> Proc. Second Int'l Conf. on Logic Programming, </booktitle> <pages> pages 281-288, </pages> <year> 1984. </year>
Reference-contexts: The semantics of Prolog is usually specified by encoding its (sequential) control within different frameworks such as dynamic algebras [6], deterministic transition systems [12] or denotational semantics <ref> [17, 3, 13] </ref>. However, (semantics-based) analyses of Prolog are usually achieved by abstracting the more simple but less precise semantics of pure logic programs. Unfortunately, it is not straightforward to encode Prolog control directly in terms of pure logic programs.
Reference: [18] <author> G. Levi. </author> <title> Models, Unfolding Rules and Fixpoint Semantics. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1649-1665. </pages> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1988. </year>
Reference-contexts: It is defined in terms of unfoldings of clauses <ref> [18] </ref> which contain uninterpreted ask conditions. This approach facilitates separation of termination from computation when applied to modelling Prolog control. Unfoldings of clauses with ask and tell constraints result in sequences of constraints which we term constrained atoms.
Reference: [19] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: Section 6 describes related work and concludes. Full proofs, not included due to space limitations, are present in the full version of this paper. 2 Preliminaries In the following we assume familiarity with constraint logic programming (CLP) [16] and logic programming theory <ref> [1, 19] </ref>. Let and Var be denumerable sets of function symbols, and variables respectively; T () and T (; Var) denote the corresponding ground and non-ground term algebras respectively. <p> Note that under this interpretation term 1 p is vacuously true. By SLD reduction we mean usual resolution with a left-to-right selection rule <ref> [19] </ref>. An SLD reduction is captured by: Definition 4.2 (resolve) Let Clause denote the set of Horn clauses. Define: resolve : Atom fl fi Clause ! 2 Atom fl by: resolve (G ; H Body ) = (Body :: B)fH = Ag if G = A j B, ; otherwise.
Reference: [20] <author> K. Marriott and H. Stndergaard. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 733-748. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference: [21] <author> L. Plumer. </author> <title> Termination Proofs for Logic Programs, </title> <booktitle> volume 446 of Lecture Notes in Artificial Intelligence subseries of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year> <type> Ph.D. Thesis. </type>
Reference-contexts: Because the declarative semantics of t is both simple and in the usual T P style it provides a suitable basis for abstract interpretation of Prolog via the defined transformation. The required termination theory can be approximated either by integrating results on Prolog termination (e.g. <ref> [2, 7, 21, 23] </ref>) or by extending the t language so as to model termination from within and applying abstract interpretation.
Reference: [22] <author> V. A. Saraswat and M. Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proc. Seventeenth Annual ACM Symp. on Principles of Programming Languages. ACM, </booktitle> <year> 1990. </year>
Reference-contexts: A transformation from Prolog to t is defined to describe the meaning of a Prolog program P in terms of the declarative semantics of the corresponding t program P t . The target language t is an instance of the cc class of concurrent constraint languages <ref> [22] </ref>. Constraints are used to specify that a clause may be chosen for reduction only if computation with the preceding (Prolog) clauses terminates. We present a semantics for t which is open with respect to the interpretation of these (termination) constraints. <p> A declarative semantics is given in terms of an immediate consequence operator and in combination with the transformation proposed in the next section provides the basis for bottom-up abstract interpretations of Prolog programs. A t program consists of ask-tell constrained clauses as in the cc paradigm <ref> [22] </ref>.
Reference: [23] <author> K. Vershaetse and D. De Shreye. </author> <title> Deriving Termination Proofs for Logic Programs, Using Abstract Procedures. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 301-315. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: Because the declarative semantics of t is both simple and in the usual T P style it provides a suitable basis for abstract interpretation of Prolog via the defined transformation. The required termination theory can be approximated either by integrating results on Prolog termination (e.g. <ref> [2, 7, 21, 23] </ref>) or by extending the t language so as to model termination from within and applying abstract interpretation.
References-found: 23

