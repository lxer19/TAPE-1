URL: http://www.icsi.berkeley.edu/~luby/PAPERS/permkklll.ps
Refering-URL: http://www.icsi.berkeley.edu/~luby/monte.html
Root-URL: http://www.icsi.berkeley.edu
Title: A Monte-Carlo Algorithm for Estimating the Permanent  
Author: N. Karmarkar R. Karp R. Lipton L. Lovasz M. Luby 
Address: Murray Hill, N.J.  Berkeley, Calif.  
Affiliation: Bell Labs,  University of California, Berkeley and International Computer Science Institute, Berkeley, Calif.  Princeton University  Hungarian Academy of Sciences and Princeton University  International Computer Science Institute,  
Abstract: Let A be an nfin matrix with 0-1 valued entries, and let per(A) be the permanent of A. We describe a Monte-Carlo algorithm which produces a "good in the relative sense" estimate of per(A) and has running time poly(n)2 n=2 , where poly(n) denotes a function that grows polynomially with n.
Abstract-found: 1
Intro-found: 1
Reference: [ACGS] <author> Alexi, W., Chor, B., Goldreich, O., Schnorr, </author> <title> C.P., "RSA Rabin Functions: Certain Parts Are As Hard As the Whole", </title> <journal> SIAM J. on Computing, </journal> <volume> Vol. 17, </volume> <year> 1988, </year> <pages> pp. 194-209. </pages> <note> A preliminary version appeared in 25 th FOCS, </note> <year> 1984, </year> <pages> pp. 449-457. </pages>
Reference-contexts: This can be reduced to O (n 3 ) random bits per phase using standard methods of generating pairwise independent unbiased random bits <ref> [ACGS] </ref>, [CG], [Luby]. 9 Open Questions (1) Is there an (*; ffi) approximation algorithm for per (A) which runs in poly (n) time? One possible approach to solving this problem is based on the observation that the trials within a phase need only be pairwise independent, rather than completely independent. <p> Similar ideas have been used successfully in other contexts <ref> [ACGS] </ref>, [Bach], [CG], [CW], [KR], [Luby]. (2) Is there a deterministic algorithm with running time o (2 n ) which accepts as 12 input A and * and which outputs Y such that (1 *)per (A) Y (1 + *)per (A)?
Reference: [Bach] <author> E. Bach, </author> <title> "Realistic Analysis of Some Randomized Algorithms", </title> <booktitle> 19 th STOC, </booktitle> <year> 1987, </year> <pages> pp. 453-461. </pages>
Reference-contexts: Similar ideas have been used successfully in other contexts [ACGS], <ref> [Bach] </ref>, [CG], [CW], [KR], [Luby]. (2) Is there a deterministic algorithm with running time o (2 n ) which accepts as 12 input A and * and which outputs Y such that (1 *)per (A) Y (1 + *)per (A)?
Reference: [Broder] <author> A. Broder, </author> <title> "How hard is it to marry at random (On the approximation of the permanent)", </title> <booktitle> 18 th STOC, </booktitle> <year> 1986, </year> <pages> pp. 50-58. </pages>
Reference-contexts: For fixed * and ffi the running time of the approximation algorithm is essentially the square root of the running time for the fastest known algorithm that computes per (A) exactly. In <ref> [Broder] </ref>, [JS1], [JS2] (*; ffi) approximation algorithms for per (A) are given which run in poly (n) time in the special case when each row and column in A contains at least n=2 1 0 s.
Reference: [Chernoff] <author> H. Chernoff, </author> <title> "A Measure of Asymptotic Efficiency for Tests of a Hypothesis Based on the Sum of Observations", </title> <journal> Annals of Math. Stat., </journal> <volume> Vol. 23, </volume> <pages> pp. 493-509, </pages> <year> 1952. </year>
Reference-contexts: Using the fact that the outcomes are independent and identically distributed, and that each outcome has probability at least 3=4 of being good, standard bounds on the tail of the binomial distribution <ref> [Chernoff] </ref> reveal that the median is good with probability at least 1 ffi.
Reference: [CG] <author> B. Chor and O. Goldreich, </author> <title> "On the Power of Two-Points Based Sampling", </title> <note> to appear in Journal of Complexity. </note>
Reference-contexts: This can be reduced to O (n 3 ) random bits per phase using standard methods of generating pairwise independent unbiased random bits [ACGS], <ref> [CG] </ref>, [Luby]. 9 Open Questions (1) Is there an (*; ffi) approximation algorithm for per (A) which runs in poly (n) time? One possible approach to solving this problem is based on the observation that the trials within a phase need only be pairwise independent, rather than completely independent. <p> Similar ideas have been used successfully in other contexts [ACGS], [Bach], <ref> [CG] </ref>, [CW], [KR], [Luby]. (2) Is there a deterministic algorithm with running time o (2 n ) which accepts as 12 input A and * and which outputs Y such that (1 *)per (A) Y (1 + *)per (A)?
Reference: [CW] <author> J. Carter and M. Wegman, </author> <title> "Universal classes of hash functions", </title> <journal> J. Com-put. System Sci., </journal> <volume> 18, </volume> <year> 1979, </year> <pages> pp. 143-154. </pages>
Reference-contexts: Similar ideas have been used successfully in other contexts [ACGS], [Bach], [CG], <ref> [CW] </ref>, [KR], [Luby]. (2) Is there a deterministic algorithm with running time o (2 n ) which accepts as 12 input A and * and which outputs Y such that (1 *)per (A) Y (1 + *)per (A)?
Reference: [GG] <author> Godsil, C.D., and Gutman, I., </author> <title> "On the matching polynomial of a graph", Algebraic Methods in Graph Theory, I, L Lovasz and V.T. Sos, editors, Colloq. </title> <journal> Math. Soc. Janos Bolyai, </journal> <volume> 25, </volume> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1981, </year> <pages> pp. 241-249. </pages>
Reference-contexts: The rest of the paper is devoted to studying two particular stochastic experiments for estimating per (A). The first of these, which we call the Godsil/Gutman estimator, was suggested in <ref> [GG] </ref>; the second one is a variant of the Godsil/Gutman estimator which has a smaller second moment and thus leads to a more efficient algorithm.
Reference: [JS1] <author> M. Jerrum and A. Sinclair, </author> <title> "Conductance and the rapid mixing property for Markov Chains: the approximation of the permanent resolved", </title> <booktitle> STOC 1988, </booktitle> <pages> pp. 235-243. </pages>
Reference-contexts: For fixed * and ffi the running time of the approximation algorithm is essentially the square root of the running time for the fastest known algorithm that computes per (A) exactly. In [Broder], <ref> [JS1] </ref>, [JS2] (*; ffi) approximation algorithms for per (A) are given which run in poly (n) time in the special case when each row and column in A contains at least n=2 1 0 s.
Reference: [JS2] <author> M. Jerrum and A. Sinclair, </author> <title> "Approximating the permanent", </title> <type> Internal Report CSR-275-88, </type> <institution> Department of Computer Science, University of Ed-inburgh, </institution> <note> Submitted to SIAM J. on Computing. 13 </note>
Reference-contexts: For fixed * and ffi the running time of the approximation algorithm is essentially the square root of the running time for the fastest known algorithm that computes per (A) exactly. In [Broder], [JS1], <ref> [JS2] </ref> (*; ffi) approximation algorithms for per (A) are given which run in poly (n) time in the special case when each row and column in A contains at least n=2 1 0 s.
Reference: [JVV] <author> M. Jerrum, L. Valiant and V. Vazirani, </author> <title> "Random generation of combi-natorial structures from a uniform distribution", </title> <journal> Theoretical Computer Science, </journal> <volume> 43, </volume> <year> 1986, </year> <pages> pp. 169-188. </pages>
Reference-contexts: The output of the algorithm is an estimate Y of per (A) which satisfies Pr [(1 *)per (A) Y (1 + *)per (A)] 1 ffi: The papers <ref> [JVV] </ref>, [KL], [KLM] discuss (*; ffi) approximation algorithms for counting problems in greater detail. We develop an (*; ffi) approximation algorithm for per (A) which runs in 2 n=2 1 * 2 log ( 1 ffi )poly (n) time.
Reference: [KL] <author> R. Karp and M. Luby, </author> <title> "Monte-Carlo algorithms for enumeration and reliability problems", </title> <booktitle> 24 th FOCS, </booktitle> <year> 1983, </year> <pages> pp. 56-64. </pages>
Reference-contexts: The output of the algorithm is an estimate Y of per (A) which satisfies Pr [(1 *)per (A) Y (1 + *)per (A)] 1 ffi: The papers [JVV], <ref> [KL] </ref>, [KLM] discuss (*; ffi) approximation algorithms for counting problems in greater detail. We develop an (*; ffi) approximation algorithm for per (A) which runs in 2 n=2 1 * 2 log ( 1 ffi )poly (n) time.
Reference: [KLM] <author> R. Karp, M. Luby and N. </author> <title> Madras, "Monte-Carlo Approximation Algorithms for Enumeration Problems", </title> <journal> J. of Algorithms, </journal> <volume> Vol. 10., No. 3, </volume> <month> Sept. </month> <year> 1989, </year> <pages> pp. 429-448. </pages>
Reference-contexts: The output of the algorithm is an estimate Y of per (A) which satisfies Pr [(1 *)per (A) Y (1 + *)per (A)] 1 ffi: The papers [JVV], [KL], <ref> [KLM] </ref> discuss (*; ffi) approximation algorithms for counting problems in greater detail. We develop an (*; ffi) approximation algorithm for per (A) which runs in 2 n=2 1 * 2 log ( 1 ffi )poly (n) time.
Reference: [KR] <author> H. Karloff and P. Raghavan, </author> <title> "Randomized Algorithms and Pseudorandom Numbers", </title> <booktitle> 20 th STOC, </booktitle> <year> 1988, </year> <pages> pp. 310-321. </pages>
Reference-contexts: Similar ideas have been used successfully in other contexts [ACGS], [Bach], [CG], [CW], <ref> [KR] </ref>, [Luby]. (2) Is there a deterministic algorithm with running time o (2 n ) which accepts as 12 input A and * and which outputs Y such that (1 *)per (A) Y (1 + *)per (A)?
Reference: [Lovasz] <author> L. Lovasz, </author> <title> "Combinatorial Problems and Exercises", </title> <publisher> North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: It follows from these properties that P P P n! 2P 2 d () But it follows from <ref> [Lovasz] </ref> (solution to Exercise 3.12, p. 203) that P 2 and 2P 2 d () (n + 1)!.
Reference: [Luby] <author> M. Luby, </author> <title> "A Simple Parallel Algorithm for the Maximal Independent Set Problem", </title> <journal> SIAM J. Computing, </journal> <volume> Vol. 15, No. 4, </volume> <month> November </month> <year> 1986, </year> <pages> pp. 1036-1053. </pages>
Reference-contexts: This can be reduced to O (n 3 ) random bits per phase using standard methods of generating pairwise independent unbiased random bits [ACGS], [CG], <ref> [Luby] </ref>. 9 Open Questions (1) Is there an (*; ffi) approximation algorithm for per (A) which runs in poly (n) time? One possible approach to solving this problem is based on the observation that the trials within a phase need only be pairwise independent, rather than completely independent. <p> Similar ideas have been used successfully in other contexts [ACGS], [Bach], [CG], [CW], [KR], <ref> [Luby] </ref>. (2) Is there a deterministic algorithm with running time o (2 n ) which accepts as 12 input A and * and which outputs Y such that (1 *)per (A) Y (1 + *)per (A)?
Reference: [Ryser] <author> H. Ryser, </author> <title> "Combinatorial Mathematics", </title> <journal> The Carus Mathematical Monographs, </journal> <volume> No. 14, </volume> <booktitle> the Mathematical Association of America, </booktitle> <year> 1963. </year>
Reference-contexts: The quantity per (A) is exactly the number of perfect matchings in H. It is well known that det (A) can be computed in poly (n) time. On the other hand, the fastest algorithm known for computing per (A) runs in n2 n time <ref> [Ryser] </ref>. Solid grounds for arguing that computing per (A) is an inherently difficult problem were first provided in [Valiant], which shows that the problem is #P -complete. One implication of this result is that if P 6= NP then there is no poly (n) time algorithm for computing per (A).
Reference: [Valiant] <author> L. Valiant, </author> <title> "The complexity of computing the permanent", </title> <journal> Theoretical Computer Science, </journal> <volume> 8, </volume> <year> 1979, </year> <pages> pp. 189-201. 14 </pages>
Reference-contexts: It is well known that det (A) can be computed in poly (n) time. On the other hand, the fastest algorithm known for computing per (A) runs in n2 n time [Ryser]. Solid grounds for arguing that computing per (A) is an inherently difficult problem were first provided in <ref> [Valiant] </ref>, which shows that the problem is #P -complete. One implication of this result is that if P 6= NP then there is no poly (n) time algorithm for computing per (A).
References-found: 17

