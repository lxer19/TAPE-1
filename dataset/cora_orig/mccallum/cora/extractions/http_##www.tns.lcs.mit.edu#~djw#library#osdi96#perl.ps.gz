URL: http://www.tns.lcs.mit.edu/~djw/library/osdi96/perl.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/osdi96/index.html
Root-URL: 
Email: Email: office@usenix.org  
Title: Studies of Windows NT Performance using Dynamic Execution Traces  
Phone: 1. Phone: 510 528-8649 2. FAX: 510 548-5738 3.  4.  
Author: Sharon E. Perl and Richard L. Sites 
Affiliation: Digital Systems Research Center  
Web: WWW URL: http://www.usenix.org  
Date: October 1996  
Note: The following paper was originally published in the Proceedings of the USENIX 2nd Symposium on Operating Systems Design and Implementation Seattle, Washington,  For more information about USENIX Association contact:  
Abstract-found: 0
Intro-found: 1
Reference: [AH90] <author> Anant Agarwal and M. Huffman. </author> <title> Blocking: Exploiting spatial locality for trace compaction. Performance Evaluation Review, </title> <address> 18(1):4857, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: The log buffer holds about 5.9 million eight-byte log entries, which is enough for 520 seconds of real time. There is so much information in a single reconstructed trace that we have not been motivated to try stitching multiple traces together <ref> [CHRG95, AH90] </ref>; a single reconstructed trace contains about 650 MB of dynamic i-stream with instruction and data addresses. Recording the log in main memory is much faster than recording on disk or tape.
Reference: [ASH86] <author> Anant Agarwal, Richard L. Sites, and Mark Horowitz. ATUM: </author> <title> A new technique for capturing address traces using microcode. </title> <booktitle> In Proc. of the 13th International Symposium on Computer Architecture, </booktitle> <pages> pages 119127, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: With loads and stores patched in the operating system and applications, the worst slowdown we've seen is about 1/8 of normal speed. Patched images are 30-50% larger than the originals. PatchWrx is an offshoot of the ATUM work in tracing using microcode <ref> [ASH86] </ref>, and work with binary translation [SCK + 93]. Our approach is similar to other inline tracing efforts, but differs significantly in at least one dimension.
Reference: [B + 92] <author> David S. Blickstein et al. </author> <title> The GEM optimizing compiler system. </title> <journal> Digital Technical Journal, </journal> <volume> 4(4), </volume> <year> 1992. </year> <note> Also available as http://ftp.digital.com/pub/Digital /DECinfo/DTJ/axp-gem.ps. </note>
Reference-contexts: Microsoft SQL Server, October 1994 beta version, a commercial database server, running the TPC-B [Gra91] benchmark. The trace contains 64.5 million instructions, spanning several hundred transac tions. 2. GEM compiler <ref> [B + 92] </ref> back-end, from Digital's commercially available optimizing C compiler, compiling a 3000 line C program. The trace con tains 29 million instructions. 3. tomcatv, from the SPEC92 floating point benchmarks [SPE]. The trace contains 47 million instruc tions. 5 System Appl.
Reference: [BKW90] <author> Anita K. Borg, R. E. Kessler, and David W. Wall. </author> <title> Generation and analysis of very long address traces. </title> <booktitle> In Proc. of the 17th Annual Symposium on Computer Architecture, </booktitle> <pages> pages 270279, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Our approach is similar to other inline tracing efforts, but differs significantly in at least one dimension. Most published studies are of user code only [EKKL90, LB94], or are done on a single processor <ref> [BKW90, CB93] </ref>, or require rebuilding source code [SJF92], or trace only cache misses, not all instructions [CHRG95, TGH92]. None use Windows NT. The excellent Shade paper [CK94] summarizes about thirty previous tools.
Reference: [CB93] <author> Brad J. Chen and B. Bershad. </author> <title> The impact of operating system structure on memory system performance. </title> <booktitle> In Proc. of the 16th International Symposium on Operating Systems Principles, </booktitle> <pages> pages 120133, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Our approach is similar to other inline tracing efforts, but differs significantly in at least one dimension. Most published studies are of user code only [EKKL90, LB94], or are done on a single processor <ref> [BKW90, CB93] </ref>, or require rebuilding source code [SJF92], or trace only cache misses, not all instructions [CHRG95, TGH92]. None use Windows NT. The excellent Shade paper [CK94] summarizes about thirty previous tools.
Reference: [CB94] <author> Zarka Cvetanovic and Dileep Bhandarkar. </author> <title> Characterization of Alpha AXP performance using TP and SPEC workloads. </title> <booktitle> In Proc. of the 21st Annual Symposium on Computer Architecture, </booktitle> <pages> pages 6070, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Using realistic times for early Alpha computer systems, the SQL i-stream and d-stream hits beyond 96KB each total about 1.8 CPI. Combined with a 100%-hits execution rate of about 1 CPI, these total about 4.6 CPI. This is roughly consistent with the measurements in <ref> [CB94] </ref> of 4.3 CPI, and 20-25% operating system time, and 39%+36% i-stream plus d-stream stall time, on the TP1 database workload on an older AlphaSystem 7000 computer. 3.5 Discussion We conclude from these experiments that processor pin bandwidth is a bottleneck for some applications.
Reference: [CHRG95] <author> John Chapin, Stephen A. Herrod, Mendel Rosenblum, and Anoop Gupta. </author> <title> Memory system performance of UNIX on CC-NUMA multiprocessors. </title> <booktitle> In ACM SIGMET-RICS, </booktitle> <pages> pages 113, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Most published studies are of user code only [EKKL90, LB94], or are done on a single processor [BKW90, CB93], or require rebuilding source code [SJF92], or trace only cache misses, not all instructions <ref> [CHRG95, TGH92] </ref>. None use Windows NT. The excellent Shade paper [CK94] summarizes about thirty previous tools. Using that paper's classification, Patch-Wrx, like ATUM, traces executables, user and system code, multiple domains, multiple processors, signals, dynamic linking, and bugs, with performance similar to Shade. <p> The log buffer holds about 5.9 million eight-byte log entries, which is enough for 520 seconds of real time. There is so much information in a single reconstructed trace that we have not been motivated to try stitching multiple traces together <ref> [CHRG95, AH90] </ref>; a single reconstructed trace contains about 650 MB of dynamic i-stream with instruction and data addresses. Recording the log in main memory is much faster than recording on disk or tape.
Reference: [CK94] <author> Robert F. Cmelik and David Keppel. Shade: </author> <title> A fast instruction-set simulator for execution profiling. </title> <booktitle> In ACM SIGMETRICS, </booktitle> <pages> pages 128137, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Most published studies are of user code only [EKKL90, LB94], or are done on a single processor [BKW90, CB93], or require rebuilding source code [SJF92], or trace only cache misses, not all instructions [CHRG95, TGH92]. None use Windows NT. The excellent Shade paper <ref> [CK94] </ref> summarizes about thirty previous tools. Using that paper's classification, Patch-Wrx, like ATUM, traces executables, user and system code, multiple domains, multiple processors, signals, dynamic linking, and bugs, with performance similar to Shade.
Reference: [EKKL90] <author> Susan J. Eggers, David Keppel, Eric J. Koldinger, and Henry M. Levy. </author> <title> Techniques 14 for efficient inline tracing on a shared--memory multiprocessor. </title> <booktitle> In ACM SIGMET-RICS, </booktitle> <pages> pages 3747, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: PatchWrx is an offshoot of the ATUM work in tracing using microcode [ASH86], and work with binary translation [SCK + 93]. Our approach is similar to other inline tracing efforts, but differs significantly in at least one dimension. Most published studies are of user code only <ref> [EKKL90, LB94] </ref>, or are done on a single processor [BKW90, CB93], or require rebuilding source code [SJF92], or trace only cache misses, not all instructions [CHRG95, TGH92]. None use Windows NT. The excellent Shade paper [CK94] summarizes about thirty previous tools.
Reference: [Gra91] <author> Jim Gray, </author> <title> editor. The Benchmark Handbook, </title> <booktitle> chapter 2, </booktitle> <pages> pages 79117. </pages> <publisher> Morgan Kauf-mann, </publisher> <address> San Mateo, California, </address> <year> 1991. </year>
Reference-contexts: For our study, full speed is 1 CPI. The answers are interesting because, as we'll see, processor pin bandwidth is a first-order bottleneck for important applications. 3.1 Configuration We looked at four applications: 1. Microsoft SQL Server, October 1994 beta version, a commercial database server, running the TPC-B <ref> [Gra91] </ref> benchmark. The trace contains 64.5 million instructions, spanning several hundred transac tions. 2. GEM compiler [B + 92] back-end, from Digital's commercially available optimizing C compiler, compiling a 3000 line C program. The trace con tains 29 million instructions. 3. tomcatv, from the SPEC92 floating point benchmarks [SPE].
Reference: [Gra95] <author> Jim Gray, </author> <month> December </month> <year> 1995. </year> <title> Private communication. </title>
Reference-contexts: In fact, 13 the Microsoft SQL Server 95 and Windows NT 3.51 and 4.0 products contain performance improvements 5 that resulted from our studies <ref> [Gra95] </ref> . However, the same techniques and tools can be used to look for performance problems in the new versions and the traces still provide valuable input for testing future chip designs.
Reference: [LB94] <author> James R. Larus and Thomas Ball. </author> <title> Rewriting executable files to measure program behavior. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 24(2):197218, </volume> <month> February </month> <year> 1994. </year>
Reference-contexts: PatchWrx is an offshoot of the ATUM work in tracing using microcode [ASH86], and work with binary translation [SCK + 93]. Our approach is similar to other inline tracing efforts, but differs significantly in at least one dimension. Most published studies are of user code only <ref> [EKKL90, LB94] </ref>, or are done on a single processor [BKW90, CB93], or require rebuilding source code [SJF92], or trace only cache misses, not all instructions [CHRG95, TGH92]. None use Windows NT. The excellent Shade paper [CK94] summarizes about thirty previous tools.
Reference: [MDO94] <author> Ann Marie Grizzaffi Maynard, Colette M. Donnelly, and Bret R. Olszewski. </author> <title> Contrasting characteristics and cache performance of technical and multi-user commercial work-loads. </title> <booktitle> In Proc. of the 6th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 145155, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: This large footprint is why the SQL i-stream puts such a bandwidth load on the processor pins. This result is roughly consistent with the i-cache miss rates measured by <ref> [MDO94] </ref> for TPC-A and TPC-C (although they had a larger percentage of time in operating system code than we observed). The GEM footprint produces a large bandwidth load with an 8KB on-chip cache but a small load with a 96KB cache. The tomcatv footprint presents very little off-chip bandwidth load.
Reference: [NBC + 94] <author> Chris Nyberg, Tom Barclay, Zarka Cve-tanovic, Jim Gray, and David B. Lomet. Al-phaSort: </author> <title> A RISC machine sort. </title> <booktitle> In SIGMOD Conference, </booktitle> <pages> pages 233242, </pages> <year> 1994. </year>
Reference-contexts: Our experiments also suggest that it is increasingly important for algorithm designers to pay attention to memory structure and cache parameters if they want their code to run fast. One example of such an effort is the AlphaSort work <ref> [NBC + 94] </ref>, where careful attention to these memory details paid off handsomely. 4 Multiprocessor Study Our second study examines the locking behavior of SQL Server running the TPC-B benchmark on a four-processor AlphaServer 2100 symmetric multiprocessor. 11 The traces were taken for SQL Server version 6.00.85a (March 1995 beta release),
Reference: [SCK + 93] <author> Richard L. Sites, Anton Chernoff, Matthew B. Kirk, Maurice P. Marks, and Scott G. Robinson. </author> <title> Binary translation. </title> <journal> Communications of the ACM, </journal> <volume> 36(2):6981, </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: With loads and stores patched in the operating system and applications, the worst slowdown we've seen is about 1/8 of normal speed. Patched images are 30-50% larger than the originals. PatchWrx is an offshoot of the ATUM work in tracing using microcode [ASH86], and work with binary translation <ref> [SCK + 93] </ref>. Our approach is similar to other inline tracing efforts, but differs significantly in at least one dimension.
Reference: [SE94] <author> Amitabh Srivastava and Alan Eustace. </author> <title> ATOM: A system for building customized program analysis tools. </title> <booktitle> In Proc. of the ACM Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 11, </pages> <year> 1994. </year>
Reference-contexts: The excellent Shade paper [CK94] summarizes about thirty previous tools. Using that paper's classification, Patch-Wrx, like ATUM, traces executables, user and system code, multiple domains, multiple processors, signals, dynamic linking, and bugs, with performance similar to Shade. We chose to produce traces rather than do on-the-fly data analysis <ref> [SE94] </ref> because of the difficulty of recreating complex execution environments months after the original investigation. With a detailed trace, questions asked a year or more later can still be investigated.
Reference: [SJF92] <author> Craig B. Stunkel, Bob Janssens, and W. Kent Fuchs. </author> <title> Address tracing of parallel systems via TRAPEDS. </title> <journal> Microprocessors and Mi-crosystems, </journal> <volume> 16(5):249261, </volume> <year> 1992. </year>
Reference-contexts: Our approach is similar to other inline tracing efforts, but differs significantly in at least one dimension. Most published studies are of user code only [EKKL90, LB94], or are done on a single processor [BKW90, CB93], or require rebuilding source code <ref> [SJF92] </ref>, or trace only cache misses, not all instructions [CHRG95, TGH92]. None use Windows NT. The excellent Shade paper [CK94] summarizes about thirty previous tools.
Reference: [SPE] <institution> SPEC CPU92 benchmarks. </institution> <note> World Wide Web URL: http://www.specbench.org/osg /cpu92/. </note>
Reference-contexts: The trace contains 64.5 million instructions, spanning several hundred transac tions. 2. GEM compiler [B + 92] back-end, from Digital's commercially available optimizing C compiler, compiling a 3000 line C program. The trace con tains 29 million instructions. 3. tomcatv, from the SPEC92 floating point benchmarks <ref> [SPE] </ref>. The trace contains 47 million instruc tions. 5 System Appl. Synthetic Ld/st Ld/st data Application #instr. patched patched addr.
Reference: [SW95] <author> Richard L. Sites and Richard T. Witek. </author> <title> Alpha AXP Architecture Reference Manual. </title> <publisher> Digital Press, </publisher> <address> Newton MA, 2nd edition edition, </address> <year> 1995. </year>
Reference-contexts: 1 Introduction This work was triggered by two performance puzzles (circa 1995) related to Microsoft's SQL Server running on Alpha <ref> [SW95] </ref> PCs under the Windows NT operating system: how could we speed up the uniprocessor ver sion, and how could we get closer to linear scaling for the multiprocessor version? To answer these questions we found that we needed to look at the detailed behavior of the system under load.
Reference: [TCS93] <author> Charles P. Thacker, David G. Conroy, and Lawrence C. Stewart. </author> <title> The Alpha Demonstration Unit: A high-performance multiprocessor. </title> <journal> Communications of the ACM, </journal> <volume> 36(2):5567, </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: A better cache coherence protocol for this workload would be a hardware design that writes through for shared blocks, having recipients update or invalidate depending on how recently they had touched the line. Such a design was used in the Alpha Demonstration Unit <ref> [TCS93] </ref>. 4.3 Discussion The Windows NT 3.5 operating system code holds the dispatcher lock for so long because it is doing a full context switch while holding the lock.
Reference: [TGH92] <author> J. Torrellas, A. Gupta, and John Hennessy. </author> <title> Characterizing the cache performance and synchronization behavior of a multiprocessor operating system. </title> <booktitle> In Proc. of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 162174, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Most published studies are of user code only [EKKL90, LB94], or are done on a single processor [BKW90, CB93], or require rebuilding source code [SJF92], or trace only cache misses, not all instructions <ref> [CHRG95, TGH92] </ref>. None use Windows NT. The excellent Shade paper [CK94] summarizes about thirty previous tools. Using that paper's classification, Patch-Wrx, like ATUM, traces executables, user and system code, multiple domains, multiple processors, signals, dynamic linking, and bugs, with performance similar to Shade.
References-found: 21

