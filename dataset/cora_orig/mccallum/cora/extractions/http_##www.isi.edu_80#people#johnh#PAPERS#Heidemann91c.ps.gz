URL: http://www.isi.edu:80/people/johnh/PAPERS/Heidemann91c.ps.gz
Refering-URL: http://www.isi.edu:80/people/johnh/PAPERS/Heidemann91c.html
Root-URL: http://www.isi.edu
Title: An Architecture for File System Development  
Degree: A thesis submitted in partial satisfaction of the requirements for the degree Master of Science in Computer Science by John Shelby Heidemann  
Date: 1991  
Note: Stackable Layers:  
Address: Los Angeles  
Affiliation: University of California  
Abstract-found: 0
Intro-found: 1
Reference: [ABG + 86] <author> Mike Accetta, Robert Baron, David Golub, Richard Rashid, Avadis Tevanian, and Michael Young. </author> <title> "Mach: A New Kernel Foundation for UNIX Development." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 93-113. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: While individual vendors have adopted new kernel technologies such as Streams [Rit84], new virtual memory approaches, and new file systems, such additions have only come slowly and at great expense. Micro-kernel designs are one approach to kernel modularity. Kernels such as Mach <ref> [ABG + 86] </ref> and Chorus [RAA + 90] divide the operating system into two parts: a core of memory management, process control, and simple inter-process communication; and a server (or servers) supporting the remainder of the traditional operating system, including accounting, protection, file system and network services, and backwards compatibility.
Reference: [App85] <author> Apple Computer, Inc. </author> <title> Inside Macintosh. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1985. </year>
Reference-contexts: Current layers handle this in an ad hoc fashion, typically transparently stealing some space from the beginning of file data storage. A more general solution is clearly needed, providing general purpose per-file attribute functionality similar to file resource forks in the Macintosh operating system <ref> [App85] </ref>. 6.2.4 Large scale example The previous section discussed our experiences in stackable development of several prototype layers. This section concludes with the the results of developing a replicated file system suitable in practice for daily use. Ficus is a "real" system, both in terms of size and use.
Reference: [App88] <institution> Apple Computer, Inc. </institution> <note> HyperCard User's Guide. </note> <institution> Apple Computer, Inc., Cupertino, California, </institution> <year> 1988. </year>
Reference-contexts: Furthermore, the services offered by third party modules should not have any undue penalty for being developed independently. Extensible operating system services have been uncommon, but user level programs supporting extensibility have proven effective. The Internet File Transfer Protocol [Bus71] and Apple Computer's HyperCard <ref> [App88] </ref> illustrate the benefits of extensibility in gradual software evolution and rapid support of new technology. The flexible design of the Internet File Transfer Protocol, FTP, has allowed its gradual evolution with the addition of new commands (for example, [PR85]).
Reference: [Bac86] <author> Maurice J. Bach. </author> <title> The Design of the Unix Operating System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Madnick and Alsop [MA69], and later Madnick and Donovan [MD74] discuss modular and layered approaches to file system design, concluding with a six-layer design. The design of Unix adopted simpler approaches, resulting in a two layer design (file system and physical devices) <ref> [Bac86] </ref>. To provide for multiple file systems, several "file system switch" mechanisms have been developed [Kle86, RKH86, KM86]. These typically found quick use in the support of network file access [SGK + 85, RFH + 86] and have since been applied to the support of other file systems [Koe87].
Reference: [Bus71] <author> A. K. Bushan. </author> <title> "File Transfer Protocol." </title> <type> Technical Report RFC-114, </type> <institution> Internet Request For Comments, </institution> <month> April </month> <year> 1971. </year>
Reference-contexts: Furthermore, the services offered by third party modules should not have any undue penalty for being developed independently. Extensible operating system services have been uncommon, but user level programs supporting extensibility have proven effective. The Internet File Transfer Protocol <ref> [Bus71] </ref> and Apple Computer's HyperCard [App88] illustrate the benefits of extensibility in gradual software evolution and rapid support of new technology. The flexible design of the Internet File Transfer Protocol, FTP, has allowed its gradual evolution with the addition of new commands (for example, [PR85]).
Reference: [Cat90] <author> Vince Cate. </author> <title> "Two Levels of Filesystem Hierarchy on One Disk." </title> <type> Technical Report CMU-CS-90-129, </type> <institution> Carnegie-Mellon University, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: Several layers have been prototyped at UCLA as class projects: file versioning This layer provides storage and creation of file version as they are edited, similar to file versioning services in VMS. compression File compression has the potential to significantly increase effective storage <ref> [Cat90] </ref>. Compression and decompression in a layer make this savings possible without explicit user intervention. encryption The entire Unix file system must be accessible to administrative personnel, if only to do file system backups.
Reference: [CBB + 91] <author> Marc Campbell, Richard Barton, Jim Browning, Dennis Cervenka, Ben Curry, Todd Davis, Tracy Edmonds, Russ Holt, John Slice, Tucker Smith, and Rich Wescott. </author> <title> "The Parallelization of UNIX System V Release 4.0." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 307-323. </pages> <publisher> USENIX, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: In fact, stack locking overhead is a problem with current implementations of dynamic stacking [Ros90]. Since a top-of-stack pointer is not required in the 405 interface, no locking is required for the stack as a whole, and currently successful vnode locking techniques <ref> [LPLF91, CBB + 91, LBLM90] </ref> can be used within each layer of the stack in multiprocessor implementations. The most significant problem with this method of dynamic stacking is that for many stacks there is no well defined notion of "top-of-stack". Stacks with fan-in have multiple stack tops.
Reference: [Cla85] <author> David D. Clark. </author> <title> "The Strucutring of Systems Using Upcalls." </title> <booktitle> In Proceedings of the Tenth Symposium on Operating Systems Principles, </booktitle> <pages> pp. 171-180. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1985. </year>
Reference-contexts: Rather than wait for the physical disk read to complete, the executing process can suspend itself, allowing other processing to be done. When the read completes, an interrupt will signal the original process that it may resume. This interrupt is a form of "upcall" <ref> [Cla85] </ref>, an operation which begins at a lower level of system software and proceeds towards the user. A more general term for upcalls is non-linear flow of control 2 , since one can also imagine need to call services at "parallel" levels. Upcalls are often needed in distributed file systems. <p> For many reasons, layers in a distributed system frequently require a more general flow of control. Upcalls begin at lower layers of the system and proceed upwards to higher layers <ref> [Cla85] </ref>. More generally, operations can be invoked between two unrelated stacks. Figure 3.8 illustrates these cases. An RPC service provides this sort of generality, typically allowing communication with any object on any machine on a network.
Reference: [Dij67] <author> Edsgar W. Dijkstra. </author> <title> "The structure of the THE multiprogramming system." </title> <booktitle> In Proceedings of the Symposium on Operating Systems Principles. ACM, </booktitle> <month> October </month> <year> 1967. </year>
Reference-contexts: Using a symmetric interface for all kernel services ("everything is a protocol"), great flexibility in protocol selection and combination is provided. Run-time protocol selection also allows use of the most efficient method available. 1.2.2 File system structuring Dijkstra describes early approaches to modular operating system design <ref> [Dij67, Dij68] </ref>. Madnick and Alsop [MA69], and later Madnick and Donovan [MD74] discuss modular and layered approaches to file system design, concluding with a six-layer design. The design of Unix adopted simpler approaches, resulting in a two layer design (file system and physical devices) [Bac86].
Reference: [Dij68] <author> Edsgar W. Dijkstra. </author> <title> "Complexity controlled by hierarchical ordering of function and variability." </title> <booktitle> Working paper for the NATO conference on computer software engineering at Garmisch, </booktitle> <address> Germany, </address> <month> October </month> <year> 1968. </year>
Reference-contexts: Using a symmetric interface for all kernel services ("everything is a protocol"), great flexibility in protocol selection and combination is provided. Run-time protocol selection also allows use of the most efficient method available. 1.2.2 File system structuring Dijkstra describes early approaches to modular operating system design <ref> [Dij67, Dij68] </ref>. Madnick and Alsop [MA69], and later Madnick and Donovan [MD74] discuss modular and layered approaches to file system design, concluding with a six-layer design. The design of Unix adopted simpler approaches, resulting in a two layer design (file system and physical devices) [Bac86].
Reference: [Flo86a] <author> Rick Floyd. </author> <title> "Directory Reference Patterns in a UNIX Environment." </title> <type> Technical Report TR-179, </type> <institution> University of Rochester, </institution> <month> August </month> <year> 1986. </year>
Reference-contexts: Because of these problems, file system performance analysis has been typically reserved to a few research labs and systems software houses. Even there, the effort required to take quality measurements has resulted in the publishing of only a few performance studies based upon real environments <ref> [Flo86b, Flo86a, OCH + 85] </ref>. Stackable layers offers an alternative to this approach. A measurements layer can cleanly separate instrumentation from the subject being measured.
Reference: [Flo86b] <author> Rick Floyd. </author> <title> "Short-Term File Reference Patterns in a UNIX Environment." </title> <type> Technical Report TR-177, </type> <institution> University of Rochester, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: Because of these problems, file system performance analysis has been typically reserved to a few research labs and systems software houses. Even there, the effort required to take quality measurements has resulted in the publishing of only a few performance studies based upon real environments <ref> [Flo86b, Flo86a, OCH + 85] </ref>. Stackable layers offers an alternative to this approach. A measurements layer can cleanly separate instrumentation from the subject being measured.
Reference: [GHM + 90] <author> Richard G. Guy, John S. Heidemann, Wai Mak, Thomas W. Page, Jr., Gerald J. Popek, and Dieter Rothmeier. </author> <title> "Implementation of the Ficus Replicated File System." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 63-71. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: This modularity has also proven useful in the support of other filing services. For example, DEC's GFS was used to support several different file system formats [Koe87]. Ficus is a distributed file system supporting file replication for reliability, performance, and scale <ref> [GHM + 90, Guy91] </ref>. Development of Ficus begin in 1989 at UCLA, where it has served as a testbed for a number of new file system concepts. For reasons of modularity and portability, Ficus was built with a standard file system interface. <p> This allows mount-time choice between inexpensive caching algorithms with poor consistency and more sophisticated algorithms provided completely transparent semantics. Section 5.6 describes our cache consistency layer in detail. 5.4 Ficus: replicated file services Ficus is a distributed file system supporting replication with optimistic concur-rency control <ref> [GHM + 90, Guy91] </ref>. It is also one of the most ambitious uses of stackable layering to date, using two cooperating layers in its implementation. Ficus is an example of cooperating layers, being composed of two separate layers (logical and physical) with an optional transport layer in-between for remote access.
Reference: [Guy91] <author> Richard G. Guy. Ficus: </author> <title> A Very Large Scale Reliable Distributed File System. </title> <type> Ph.D. dissertation, </type> <institution> University of California, </institution> <address> Los Angeles, </address> <month> June </month> <year> 1991. </year> <note> Also published as CSD-910018. </note>
Reference-contexts: This modularity has also proven useful in the support of other filing services. For example, DEC's GFS was used to support several different file system formats [Koe87]. Ficus is a distributed file system supporting file replication for reliability, performance, and scale <ref> [GHM + 90, Guy91] </ref>. Development of Ficus begin in 1989 at UCLA, where it has served as a testbed for a number of new file system concepts. For reasons of modularity and portability, Ficus was built with a standard file system interface. <p> This allows mount-time choice between inexpensive caching algorithms with poor consistency and more sophisticated algorithms provided completely transparent semantics. Section 5.6 describes our cache consistency layer in detail. 5.4 Ficus: replicated file services Ficus is a distributed file system supporting replication with optimistic concur-rency control <ref> [GHM + 90, Guy91] </ref>. It is also one of the most ambitious uses of stackable layering to date, using two cooperating layers in its implementation. Ficus is an example of cooperating layers, being composed of two separate layers (logical and physical) with an optional transport layer in-between for remote access.
Reference: [Hen90] <author> David Hendricks. </author> <title> "A Filesystem for Software Development." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 333-340. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: An alternative to the NFS protocol for remote access, NeFS allows remote execution of PostScript-like programs for file access. 1.2.3 Stackable file systems Sun Microsystems applied the vnode interface to build two layer file system stacks in their loopback and translucent file systems <ref> [Hen90] </ref>. Internal to the operating system, stacking is used to support device special files. More recently, Rosenthal has experimented with a modified vnode interface to provide dynamic file system stacking [Ros90]. <p> This approach is identical to that typically used to implement C ++ virtual class methods [Str86]. Some file system stacking is possible with the standard vnode interface us 23 ing the mount mechanism. Sun Microsystems' NFS [SGK + 85], loopback, and translucent <ref> [Hen90] </ref> file systems take this approach.
Reference: [HKM + 88] <author> John Howard, Michael Kazar, Sherri Menees, David Nichols, Ma-hadev Satyanarayanan, Robert Sidebotham, and Michael West. </author> <title> "Scale and Performance in a Distributed File System." </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 51-81, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Our first goal was to compare a kernel supporting only the 405 interface with a standard kernel. To examine overall performance, we consider two benchmarks: the modified Andrew benchmark <ref> [Ous90, HKM + 88] </ref> and recursive copy and remove of large subdirectory trees. In addition, we examined the effect of adding multiple layers in the new interface. The Andrew benchmark has several phases, each of which examines different file system activities.
Reference: [HP88] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <booktitle> "Design of the x-Kernel." In Proceedings of the 1988 Symposium on Commmunica-tions Architectures and Protocols, </booktitle> <pages> pp. 65-75. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1988. </year>
Reference-contexts: Ritchie applies symmetric layering to the terminal and network subsystems of research versions of AT&T Unix. Such work has since been adopted by a number of Unix flavors. 1 In fact, commercial systems such as Novell's Netware-386 have adopted the Streams framework, presumably for similar reasons. 4 The x-kernel <ref> [HP88, HPAO89] </ref> is a new kernel designed originally to provide customized network protocols. Using a symmetric interface for all kernel services ("everything is a protocol"), great flexibility in protocol selection and combination is provided. <p> For example, all vnodes share a common set of possible operations. This would be undesirable with a general purpose interface because only a small fraction of operations would be needed by any one class. 7.4 The x-kernel The x-kernel <ref> [HP88, HPAO89] </ref> is an operating system kernel designed to simplify network protocol implementations. Designed to provide easy configuration and efficient execution, an original goal was to provide unobtrusive customized kernels for several distributed languages.
Reference: [HP91] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> "The x-Kernel: An Architecture for Implementing Network Protocols." </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: These characteristics should be provided without arbitrary limitations while still supporting excellent performance. The next chapter will discuss a prototype interface designed with these issues in mind. 3 This term was first coined by Hutchinson and Peterson in <ref> [HP91] </ref>. 18 CHAPTER 3 Interface Implementation 19 The previous chapter described a number of new ideas about how file systems should be constructed. Chief among these is the idea that stackable file system design can promote file system development.
Reference: [HPAO89] <author> Norman C. Hutchinson, Larry L. Peterson, Mark B. Abbott, and Sean O'Malley. </author> <title> "RPC in the x-Kernel: Evaluating New Design Techniques." </title> <booktitle> In Proceedings of the Twelfth Symposium on Operating Systems Principles, </booktitle> <pages> pp. 91-101. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: Ritchie applies symmetric layering to the terminal and network subsystems of research versions of AT&T Unix. Such work has since been adopted by a number of Unix flavors. 1 In fact, commercial systems such as Novell's Netware-386 have adopted the Streams framework, presumably for similar reasons. 4 The x-kernel <ref> [HP88, HPAO89] </ref> is a new kernel designed originally to provide customized network protocols. Using a symmetric interface for all kernel services ("everything is a protocol"), great flexibility in protocol selection and combination is provided. <p> For example, all vnodes share a common set of possible operations. This would be undesirable with a general purpose interface because only a small fraction of operations would be needed by any one class. 7.4 The x-kernel The x-kernel <ref> [HP88, HPAO89] </ref> is an operating system kernel designed to simplify network protocol implementations. Designed to provide easy configuration and efficient execution, an original goal was to provide unobtrusive customized kernels for several distributed languages.
Reference: [IEE90] <author> IEEE. </author> <title> "Standaard for Information technology|Portable Operating System Interface (POSIX)|Part 1: System Application Programming Interface (API)." </title> <note> Technical Report IEEE Std. 1003.1-1990, IEEE, 1990. Also available as ISO/IEC 9945-1: </note> <year> 1990s. </year>
Reference-contexts: By providing a common protocol between two subsystems, such an interface allows either or both systems to be replaced without change to the other. Improved modules can therefore be independently developed and added as desired, improving the computing environment. Interfaces such as Posix.1 <ref> [IEE90] </ref> and NFS [SGK + 85] are examples of interfaces widely used to provide operating system and remote filing services. Because operating systems represent such a widely used service, the development of modular systems interfaces there is particularly important.
Reference: [JR89] <author> Daniel P. Julin and Richard F. Rashid. </author> <title> MachObjects Reference Manual. </title> <institution> Carnegie-Mellon University, </institution> <month> August </month> <year> 1989. </year> <month> 96 </month>
Reference-contexts: Requirements of source code access and change will greatly restrict layer stacking combinations without bypass capabilities. 7.3 MachObjects MachObjects <ref> [JR89] </ref> is an object-oriented package for designing general purpose operating system interfaces. MachObjects is a macro and library package in C, running on top of the Mach operating system. MachObjects uses object-oriented techniques to enable code reuse. Single inheritance is supported, allowing automatic reuse of routines.
Reference: [Kle86] <author> S. R. Kleiman. "Vnodes: </author> <title> An Architecture for Multiple File System Types in Sun Unix." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 238-247. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: Adoption of these new filing services has been slow in part because file systems are large, monolithic pieces of code with limited internal modularity. Although recent approaches to file system modularity such as Sun's VFS interface <ref> [Kle86] </ref> allow easy substitution of entire file systems, they do little to support modularity within file systems themselves. As a result, it is not easy to replace or enhance separate portions of the file system, for example, keeping the physical disk management and installing a new directory layer. <p> The design of Unix adopted simpler approaches, resulting in a two layer design (file system and physical devices) [Bac86]. To provide for multiple file systems, several "file system switch" mechanisms have been developed <ref> [Kle86, RKH86, KM86] </ref>. These typically found quick use in the support of network file access [SGK + 85, RFH + 86] and have since been applied to the support of other file systems [Koe87]. None of these approaches provide explicit support for stacking or extensibility, but all provide basic modularity. <p> The benefits of file system modularity have resulted in the adoption of a several different file system interfaces. Several are now available commercially, including Sun Microsystems' Virtual File System interface (VFS, <ref> [Kle86] </ref>), Digital Equipment Corporation's Generic File System (GFS, [RKH86]), and AT&T's File System Switch (FSS). Each separate the implementation of the file system from the remainder of the kernel, allowing different abstractions to be accessed through a standard interface. <p> Sun's vnode interface <ref> [Kle86] </ref> is a good example of this approach, separating file systems from the remainder of the kernel with an object-oriented interface 2 . Versions of the vnode interface are provided in several variants of Unix, including SunOS, System V Release 4, and 4.3-Reno BSD. <p> These areas are more closely examined in the following sections. 7.1 The Vnode Interface To separate file system implementations from the rest of the kernel, Sun Mi-crosystems developed the virtual file system interface <ref> [Kle86] </ref>. Similar to work at DEC [RKH86] and AT&T, the vnode interface has the goal to support several file systems within the same kernel. These approaches each concentrate on providing multiple file system types in the same kernel. To this end, they have been fairly successful.
Reference: [KM86] <author> Michael J. Karels and Marshall Kirk McKusick. </author> <title> "Toward a Compatible Filesystem Interface." </title> <booktitle> In Proceedings of the European Unix User's Group, </booktitle> <address> p. 15. EUUG, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: The design of Unix adopted simpler approaches, resulting in a two layer design (file system and physical devices) [Bac86]. To provide for multiple file systems, several "file system switch" mechanisms have been developed <ref> [Kle86, RKH86, KM86] </ref>. These typically found quick use in the support of network file access [SGK + 85, RFH + 86] and have since been applied to the support of other file systems [Koe87]. None of these approaches provide explicit support for stacking or extensibility, but all provide basic modularity.
Reference: [Koe87] <author> Matt Koehler. </author> <title> "GFS Revisited or How I Lived with Four Different Local File Systems." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 291-305. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: To provide for multiple file systems, several "file system switch" mechanisms have been developed [Kle86, RKH86, KM86]. These typically found quick use in the support of network file access [SGK + 85, RFH + 86] and have since been applied to the support of other file systems <ref> [Koe87] </ref>. None of these approaches provide explicit support for stacking or extensibility, but all provide basic modularity. NeFS describes one approach to an extensible file system interface [Sun90], focusing exclusively on remote file access. <p> This modularity has also proven useful in the support of other filing services. For example, DEC's GFS was used to support several different file system formats <ref> [Koe87] </ref>. Ficus is a distributed file system supporting file replication for reliability, performance, and scale [GHM + 90, Guy91]. Development of Ficus begin in 1989 at UCLA, where it has served as a testbed for a number of new file system concepts. <p> These approaches each concentrate on providing multiple file system types in the same kernel. To this end, they have been fairly successful. DEC's GFS has been successful in supporting several very different physical file systems <ref> [Koe87] </ref>. Sun's virtual file system has been successful in providing a number of file-system related features in the SVR4 kernel.
Reference: [KP84] <author> Brian W. Kernighan and Rob Pike. </author> <title> The Unix Programming Environment. </title> <publisher> Prentice-Hall, </publisher> <year> 1984. </year>
Reference-contexts: Pike and Kernighan describe this work for software development [PK84]; other applications are as rich as text formatting <ref> [KP84] </ref> and music processing [Lan90]. Ritchie's Streams paper [Rit84] is the classic application of these principles to kernel structuring. Ritchie applies symmetric layering to the terminal and network subsystems of research versions of AT&T Unix.
Reference: [Kue91] <author> Geoff Kuenning. </author> <title> "Comments on CS239 Class Projects." </title> <type> Personal communication, </type> <month> June </month> <year> 1991. </year>
Reference-contexts: It also considered how 79 layering can improve the file system development by allowing code reuse and out--of-kernel development. To summarize the development environment, consider the comments of one of the students who developed a file system layer <ref> [Kue91] </ref>: For me, the really big advantage of the stackable layers was the ease of development. Combined with the ook [out-of-kernel] development, the testing cycle was vastly shorter than other kernel work I've done.
Reference: [Lan90] <author> Peter S. Langston. </author> <title> "Unix Music Tools at Bellcore." </title> <journal> Software | Pratice and Experience, </journal> <volume> 20(S1):47-61, </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: Pike and Kernighan describe this work for software development [PK84]; other applications are as rich as text formatting [KP84] and music processing <ref> [Lan90] </ref>. Ritchie's Streams paper [Rit84] is the classic application of these principles to kernel structuring. Ritchie applies symmetric layering to the terminal and network subsystems of research versions of AT&T Unix.
Reference: [LBLM90] <author> Alan Langerman, Joseph Boykin, Susan LoVerso, and Sashi Man-galat. </author> <title> "A Highly-Parallelized Mach-based Vnode Filesystem." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 297-312. </pages> <publisher> USENIX, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: In fact, stack locking overhead is a problem with current implementations of dynamic stacking [Ros90]. Since a top-of-stack pointer is not required in the 405 interface, no locking is required for the stack as a whole, and currently successful vnode locking techniques <ref> [LPLF91, CBB + 91, LBLM90] </ref> can be used within each layer of the stack in multiprocessor implementations. The most significant problem with this method of dynamic stacking is that for many stacks there is no well defined notion of "top-of-stack". Stacks with fan-in have multiple stack tops.
Reference: [LPLF91] <author> Susan LoVerso, Noemi Paciorek, Alan Langerman, and George Fein-berg. </author> <title> "The OSF/1 Unix File System (UFS)." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 207-218. </pages> <publisher> USENIX, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: In fact, stack locking overhead is a problem with current implementations of dynamic stacking [Ros90]. Since a top-of-stack pointer is not required in the 405 interface, no locking is required for the stack as a whole, and currently successful vnode locking techniques <ref> [LPLF91, CBB + 91, LBLM90] </ref> can be used within each layer of the stack in multiprocessor implementations. The most significant problem with this method of dynamic stacking is that for many stacks there is no well defined notion of "top-of-stack". Stacks with fan-in have multiple stack tops.
Reference: [MA69] <author> Stuart E. Madnick and Joseph W. Alsop, </author> <title> II. "A modular approach to file system design." </title> <booktitle> In AFIPS Conference Proceedings Spring Joint Computer Conference, </booktitle> <pages> pp. 1-13. </pages> <publisher> AFIPS Press, </publisher> <month> May </month> <year> 1969. </year>
Reference-contexts: Run-time protocol selection also allows use of the most efficient method available. 1.2.2 File system structuring Dijkstra describes early approaches to modular operating system design [Dij67, Dij68]. Madnick and Alsop <ref> [MA69] </ref>, and later Madnick and Donovan [MD74] discuss modular and layered approaches to file system design, concluding with a six-layer design. The design of Unix adopted simpler approaches, resulting in a two layer design (file system and physical devices) [Bac86].
Reference: [MD74] <author> Stuart E. Madnick and John J. Donovan. </author> <title> Operating Systems. </title> <publisher> McGraw-Hill Book Company, </publisher> <year> 1974. </year>
Reference-contexts: Run-time protocol selection also allows use of the most efficient method available. 1.2.2 File system structuring Dijkstra describes early approaches to modular operating system design [Dij67, Dij68]. Madnick and Alsop [MA69], and later Madnick and Donovan <ref> [MD74] </ref> discuss modular and layered approaches to file system design, concluding with a six-layer design. The design of Unix adopted simpler approaches, resulting in a two layer design (file system and physical devices) [Bac86].
Reference: [MJLF84] <author> Michael McKusick, William Joy, Samuel Le*er, and R. Fabry. </author> <title> "A Fast File System for UNIX." </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 181-197, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Traditional Unix supported what is today the System V file system [RT74]. Berkeley developed the Fast File System to a very similar interface (long names and symbolic links being the primary interface modifications, <ref> [MJLF84] </ref>), and recent work in log-structured physical file 42 replica. The right stack shows the addition of a transport layer to allow remote replica access. 43 systems appears promising [OD88].
Reference: [Neu89] <author> B. Clifford Neuman. </author> <title> "Workstations and the Virtual System Model." </title> <booktitle> In Proceedings of the Second Workshop on Workstation Operating Systems, </booktitle> <pages> pp. 91-95. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> September </month> <year> 1989. </year> <month> 97 </month>
Reference-contexts: User-centered naming A number of recent proposals have advocated "user-centered naming" <ref> [Neu89, PHOR90] </ref>. Such a service could be naturally constructed as a naming layer relying on access to many existing file systems through lower layers. Disk quotas The original Berkeley implementation of disk quotas was tightly integrated with the Berkeley Fast File System.
Reference: [OCH + 85] <author> John K. Ousterhout, Herve Da Costa, David Harrison, John A. Kunze, Mike Kupfer, and James G. Thompson. </author> <title> "A Trace-Driven Analysis of the Unix 4.2 BSD File System." </title> <type> Technical Report UCB/CSD 85/230, UCB, </type> <year> 1985. </year>
Reference-contexts: Because of these problems, file system performance analysis has been typically reserved to a few research labs and systems software houses. Even there, the effort required to take quality measurements has resulted in the publishing of only a few performance studies based upon real environments <ref> [Flo86b, Flo86a, OCH + 85] </ref>. Stackable layers offers an alternative to this approach. A measurements layer can cleanly separate instrumentation from the subject being measured.
Reference: [OD88] <author> John Ousterhout and Fred Douglis. </author> <title> "Beating the I/O Bottleneck: A Case for Log-Structured File Systems." </title> <type> Technical Report UCB/CSD 88/467, </type> <institution> Unviversity of California, Berkeley, </institution> <month> October </month> <year> 1988. </year>
Reference-contexts: The right stack shows the addition of a transport layer to allow remote replica access. 43 systems appears promising <ref> [OD88] </ref>. Because of its interactions with other kernel mechanisms, porting a physical file system from one machine or Unix variant to another can be difficult.
Reference: [Ous90] <author> John K. Ousterhout. </author> <booktitle> "Why Aren't Operating Systems Geting Faster As Fast as Hardware?" In USENIX Conference Proceedings, </booktitle> <pages> pp. 247-256. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Our first goal was to compare a kernel supporting only the 405 interface with a standard kernel. To examine overall performance, we consider two benchmarks: the modified Andrew benchmark <ref> [Ous90, HKM + 88] </ref> and recursive copy and remove of large subdirectory trees. In addition, we examined the effect of adding multiple layers in the new interface. The Andrew benchmark has several phases, each of which examines different file system activities.
Reference: [Pag91] <author> Tom Page. </author> <title> "The Umap Layer." </title> <type> Personal communication, </type> <month> July </month> <year> 1991. </year>
Reference-contexts: As a result, NFS communication between two sites can result in improper file ownership and access when user-id allocation conflicts. To allow bilateral sharing between different administrative domains, a user-id mapping layer (umap) was developed by Tom Page <ref> [Pag91] </ref>. Developed in about a week, such a layer illustrates the power of stacking to address new problems rapidly. 5.6 A Consistency Layer Remote filing systems are a part of the daily lives of nearly every workstation user today.
Reference: [PGP + 91] <author> Thomas W. Page, Jr., Richard G. Guy, Gerald J. Popek, John S. Heidemann, Wai Mak, and Dieter Rothmeier. </author> <title> "Management of Replicated Volume Location Data in the Ficus Replicated File System." </title> <booktitle> In USENIX Conference Proceedings. USENIX, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Figure 5.4 illustrates all layers used in consistency layer operation. The unusual figure-eight mounting pattern shown in Figure 5.4 is required for bi-directional RPC flow. It also requires a careful mounting sequence for correct operation. As such, this represents an ideal opportunity to apply on-demand "automounting" as described in <ref> [PGP + 91] </ref>. The consistency layer has proven to be an exceptional demonstration of the benefits of file system layering. It cleanly separates remote access methods from the cache consistency protocol of a distributed file system, allowing either to be substituted. <p> These tools do not scale to handle the explosion of entries resulting from per-file configuration. While recent efforts have 83 be a device special file, or perhaps just an ordinary file. been made to divide file system mount information into more manageable chunks (Ficus autografting <ref> [PGP + 91] </ref>, for example), these approaches typically require special purpose underlying file systems or file system layers. A file system with extensible file attributes could conceivably also serve to store stack construction information, but no such systems are currently available.
Reference: [PHOR90] <author> Larry L. Peterson, Norman C. Hutchinson, Sean W. O'Malley, and Herman C. Rao. </author> <title> "The x-Kernel: A Platform for Accessing Internet Resources." </title> <journal> IEEE Computer, </journal> <volume> 23(5) </volume> <pages> 23-33, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: User-centered naming A number of recent proposals have advocated "user-centered naming" <ref> [Neu89, PHOR90] </ref>. Such a service could be naturally constructed as a naming layer relying on access to many existing file systems through lower layers. Disk quotas The original Berkeley implementation of disk quotas was tightly integrated with the Berkeley Fast File System. <p> Since then, the x-kernel has used as a general purpose tool to explore network and RPC protocol design and configuration. Recent work has applied the x-kernel ideas to filing environments <ref> [PHOR90] </ref>, proposing a user-customizable filing name space supporting several file systems protocols underneath. The x-kernel's strengths derive from a uniform, powerful development environment. Protocols are the central x-kernel concept. The x-kernel implements all operating system services as layered protocols.
Reference: [PK84] <author> Rob Pike and Brian Kernighan. </author> <title> "Program Design in the UNIX Environment." </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1595-1605, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: A more detailed study and comparison to this work can be found in Chapter 7. 1.2.1 Symmetric interfaces Unix shell programming with pipes [RT74] is now the widest use of a symmetric interface. Pike and Kernighan describe this work for software development <ref> [PK84] </ref>; other applications are as rich as text formatting [KP84] and music processing [Lan90]. Ritchie's Streams paper [Rit84] is the classic application of these principles to kernel structuring. Ritchie applies symmetric layering to the terminal and network subsystems of research versions of AT&T Unix.
Reference: [PR85] <author> J. B. Postel and J. K. Renolds. </author> <title> "File Transfer Protocol." </title> <type> Technical Report RFC-959, </type> <institution> Internet Request For Comments, </institution> <month> October </month> <year> 1985. </year>
Reference-contexts: The Internet File Transfer Protocol [Bus71] and Apple Computer's HyperCard [App88] illustrate the benefits of extensibility in gradual software evolution and rapid support of new technology. The flexible design of the Internet File Transfer Protocol, FTP, has allowed its gradual evolution with the addition of new commands (for example, <ref> [PR85] </ref>). The scope of the Internet, where hundreds of computer architectures support thousands of software revisions across hundreds of thousands of hosts, makes the concept of "one consistent software version" an impossibility. In such an environment, gradual extensibility is a requirement.
Reference: [RAA + 90] <author> Marc Rozier, Vadim Abrossimov, Francois Armand, Ivan Boule, Michel Gien, Marc Guillemont, Frederic Herrmann, Claude Kaiser, Sylvain Langlois, Pierre Leonard, and Will Neuhauser. </author> <title> "Overview of the CHORUS Distributed Operating System." </title> <type> Technical Report CS/TR-90-25, </type> <institution> Chorus systemes, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: While individual vendors have adopted new kernel technologies such as Streams [Rit84], new virtual memory approaches, and new file systems, such additions have only come slowly and at great expense. Micro-kernel designs are one approach to kernel modularity. Kernels such as Mach [ABG + 86] and Chorus <ref> [RAA + 90] </ref> divide the operating system into two parts: a core of memory management, process control, and simple inter-process communication; and a server (or servers) supporting the remainder of the traditional operating system, including accounting, protection, file system and network services, and backwards compatibility.
Reference: [RFH + 86] <author> Andrew P. Rifkin, Michael P. Forbes, Richard L. Hamilton, Michael Sabrio, Suryakanta Shah, and Kang Yueh. </author> <title> "RFS Architectural Overview." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 248-259. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: The design of Unix adopted simpler approaches, resulting in a two layer design (file system and physical devices) [Bac86]. To provide for multiple file systems, several "file system switch" mechanisms have been developed [Kle86, RKH86, KM86]. These typically found quick use in the support of network file access <ref> [SGK + 85, RFH + 86] </ref> and have since been applied to the support of other file systems [Koe87]. None of these approaches provide explicit support for stacking or extensibility, but all provide basic modularity. <p> The initial impetus for the adoption of modular file systems was often remote file access. The VFS interface was created to support Sun's Network File System (NFS, [SGK + 85]), and AT&T's FSS was joined by their Remote File Sharing <ref> [RFH + 86] </ref> package. This modularity has also proven useful in the support of other filing services. For example, DEC's GFS was used to support several different file system formats [Koe87]. Ficus is a distributed file system supporting file replication for reliability, performance, and scale [GHM + 90, Guy91].
Reference: [Rit84] <author> Dennis M. Ritchie. </author> <title> "A Stream Input-Output System." </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1897-1910, </pages> <month> October </month> <year> 1984. </year> <month> 98 </month>
Reference-contexts: Because of the exacting nature of software, and because of the lack of modular interfaces within the operating system itself, the Unix kernel has been slow to evolve to new software technologies. While individual vendors have adopted new kernel technologies such as Streams <ref> [Rit84] </ref>, new virtual memory approaches, and new file systems, such additions have only come slowly and at great expense. Micro-kernel designs are one approach to kernel modularity. <p> Pike and Kernighan describe this work for software development [PK84]; other applications are as rich as text formatting [KP84] and music processing [Lan90]. Ritchie's Streams paper <ref> [Rit84] </ref> is the classic application of these principles to kernel structuring. Ritchie applies symmetric layering to the terminal and network subsystems of research versions of AT&T Unix. <p> For detailed comparison of development and performance of the interfaces, see sections 6.2.1 and 6.1. 7.2 Rosenthal's Stackable Vnode Interface Rosenthal of Sun Microsystems developed a stackable vnode interface similar in concept to the 405 interface [Ros90]. Although both were inspired by Ritchie's Streams work <ref> [Rit84] </ref>, differences in focus have resulted in quite different designs and capabilities. Differences in the two interfaces fall broadly into differences in stacking and extensibility. Rosenthal constructs stacks on a file-by-file granularity, and all users of his system are guaranteed to see identical views of a stack.
Reference: [RKH86] <author> R. Rodriguez, M. Koehler, and R. Hyde. </author> <title> "The Generic File System." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 260-269. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: The design of Unix adopted simpler approaches, resulting in a two layer design (file system and physical devices) [Bac86]. To provide for multiple file systems, several "file system switch" mechanisms have been developed <ref> [Kle86, RKH86, KM86] </ref>. These typically found quick use in the support of network file access [SGK + 85, RFH + 86] and have since been applied to the support of other file systems [Koe87]. None of these approaches provide explicit support for stacking or extensibility, but all provide basic modularity. <p> The benefits of file system modularity have resulted in the adoption of a several different file system interfaces. Several are now available commercially, including Sun Microsystems' Virtual File System interface (VFS, [Kle86]), Digital Equipment Corporation's Generic File System (GFS, <ref> [RKH86] </ref>), and AT&T's File System Switch (FSS). Each separate the implementation of the file system from the remainder of the kernel, allowing different abstractions to be accessed through a standard interface. The initial impetus for the adoption of modular file systems was often remote file access. <p> These areas are more closely examined in the following sections. 7.1 The Vnode Interface To separate file system implementations from the rest of the kernel, Sun Mi-crosystems developed the virtual file system interface [Kle86]. Similar to work at DEC <ref> [RKH86] </ref> and AT&T, the vnode interface has the goal to support several file systems within the same kernel. These approaches each concentrate on providing multiple file system types in the same kernel. To this end, they have been fairly successful.
Reference: [Ros88] <author> David Rosenthal. </author> <title> "A Simple X11 Client Program or How hard can it really be to write "Hello, </title> <booktitle> World"?" In USENIX Conference Proceedings, </booktitle> <pages> pp. 229-242. </pages> <publisher> USENIX, </publisher> <month> February </month> <year> 1988. </year>
Reference-contexts: Such a basic program illustrates the fundamental constructs of the language. Unnecessary complexity at this level is often a sign of an inappropriate level of abstraction <ref> [Ros88] </ref>. Like a "Hello, World" program, the first layer we sought to develop under the 405 interface was the minimal layer. While the minimum program prints output, the minimal interesting layer is a "pass-through" layer.
Reference: [Ros90] <author> David S. H. Rosenthal. </author> <title> "Evolving the Vnode Interface." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 107-118. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Internal to the operating system, stacking is used to support device special files. More recently, Rosenthal has experimented with a modified vnode interface to provide dynamic file system stacking <ref> [Ros90] </ref>. This work is discussed extensively in Section 7.2. 1.3 Overview of the Thesis Central to a layered design is the interface connecting the layers. Chapter 2 discusses the design of such an interface, and the following chapter describes the implementation 405 interface, a stackable interface developed at UCLA. <p> space. 8 Release Vnode fields Vnode bytes Operation count SunOS 2.0 (1985) 11 32 24 SunOS 4.0 (1988) 14 40 29 SVR4/no fill (1989) 11 40 37 SVR4/with fill (1989) 19 72 69 Rosenthal's prototype (1990) 6 20 39 Table 2.1: Rosenthal's evaluation of vnode interface evolution in SunOS (from <ref> [Ros90] </ref>). Fill indicates space left in SVR4 for future expansion; Rosen-thal's prototype is discussed in Section 7.2. 2.1 Extensibility An interface must be extensible, allowing addition of new operations as needed. <p> In addition, new features of a software system will often require additions to existing interfaces. Both of these problems are aspects of extensibility. Examples of these problems abound in software design. Rosenthal examined the gradual evolution of the SunOS file system interface in <ref> [Ros90] </ref>. He found significant changes to the interface in every major operating system release. Table 2.1 shows his comparison of changes. Rosenthal's example shows the reality of change in software development. In spite of the inevitability of change, a number of barriers to change exist, making evolution difficult. <p> This success has not come without cost, however. The constant evolution of these interfaces has caused problems in maintenance and third party support. Rosenthal <ref> [Ros90] </ref> documents this evolution well. The method of interface defi 82 nition is an important difference between the vnode and the 405 interfaces. The vnode interface has also been used to do some file system stacking. <p> For detailed comparison of development and performance of the interfaces, see sections 6.2.1 and 6.1. 7.2 Rosenthal's Stackable Vnode Interface Rosenthal of Sun Microsystems developed a stackable vnode interface similar in concept to the 405 interface <ref> [Ros90] </ref>. Although both were inspired by Ritchie's Streams work [Rit84], differences in focus have resulted in quite different designs and capabilities. Differences in the two interfaces fall broadly into differences in stacking and extensibility. <p> This adds to overhead and complicates implementation in symmetric multiprocessing implementations, because each stack must be protected by a readers/writer lock. In fact, stack locking overhead is a problem with current implementations of dynamic stacking <ref> [Ros90] </ref>. Since a top-of-stack pointer is not required in the 405 interface, no locking is required for the stack as a whole, and currently successful vnode locking techniques [LPLF91, CBB + 91, LBLM90] can be used within each layer of the stack in multiprocessor implementations.
Reference: [RT74] <author> Dennis M. Ritchie and Ken Thompson. </author> <title> "The UNIX Time-sharing System." </title> <journal> Communications of the ACM, </journal> <volume> 17(7) </volume> <pages> 365-375, </pages> <month> October </month> <year> 1974. </year>
Reference-contexts: Large portions of an operating system are hardware independent and should run equally well on any computer. Such portability has been largely achieved, as exemplified by portable operating systems such as Unix <ref> [RT74] </ref>. What has not been achieved to the same extent is portability of major kernel subsystems. Because of the exacting nature of software, and because of the lack of modular interfaces within the operating system itself, the Unix kernel has been slow to evolve to new software technologies. <p> A more detailed study and comparison to this work can be found in Chapter 7. 1.2.1 Symmetric interfaces Unix shell programming with pipes <ref> [RT74] </ref> is now the widest use of a symmetric interface. Pike and Kernighan describe this work for software development [PK84]; other applications are as rich as text formatting [KP84] and music processing [Lan90]. Ritchie's Streams paper [Rit84] is the classic application of these principles to kernel structuring. <p> Layer substitution can be used to promote compatibility and improve performance. As example of several layers built to a similar interface, consider the various flavors of physical file systems. Traditional Unix supported what is today the System V file system <ref> [RT74] </ref>. Berkeley developed the Fast File System to a very similar interface (long names and symbolic links being the primary interface modifications, [MJLF84]), and recent work in log-structured physical file 42 replica.
Reference: [SGK + 85] <author> Russel Sandberg, David Goldberg, Steve Kleiman, Dan Walsh, and Bob Lyon. </author> <title> "Design and Implementation of the Sun Network File System." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 119-130. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1985. </year>
Reference-contexts: By providing a common protocol between two subsystems, such an interface allows either or both systems to be replaced without change to the other. Improved modules can therefore be independently developed and added as desired, improving the computing environment. Interfaces such as Posix.1 [IEE90] and NFS <ref> [SGK + 85] </ref> are examples of interfaces widely used to provide operating system and remote filing services. Because operating systems represent such a widely used service, the development of modular systems interfaces there is particularly important. <p> The design of Unix adopted simpler approaches, resulting in a two layer design (file system and physical devices) [Bac86]. To provide for multiple file systems, several "file system switch" mechanisms have been developed [Kle86, RKH86, KM86]. These typically found quick use in the support of network file access <ref> [SGK + 85, RFH + 86] </ref> and have since been applied to the support of other file systems [Koe87]. None of these approaches provide explicit support for stacking or extensibility, but all provide basic modularity. <p> The initial impetus for the adoption of modular file systems was often remote file access. The VFS interface was created to support Sun's Network File System (NFS, <ref> [SGK + 85] </ref>), and AT&T's FSS was joined by their Remote File Sharing [RFH + 86] package. This modularity has also proven useful in the support of other filing services. For example, DEC's GFS was used to support several different file system formats [Koe87]. <p> This approach is identical to that typically used to implement C ++ virtual class methods [Str86]. Some file system stacking is possible with the standard vnode interface us 23 ing the mount mechanism. Sun Microsystems' NFS <ref> [SGK + 85] </ref>, loopback, and translucent [Hen90] file systems take this approach. <p> We have implemented two transport layers. The first is a general transport layer capable of moving operations between any address spaces on machines connected by Internet network protocols. This layer uses a modified version of Sun's NFS protocol for internal communication <ref> [SGK + 85] </ref>. Our second transport layer is much more specialized. The utok layer maps user-level vnode operations to operations on kernel-level vnodes of the same machine. This layer uses one new system call and an XDR package to move data in and out of the kernel address space.
Reference: [SKS90] <author> David C. Steere, James J. Kistler, and M. Satyanarayanan. </author> <title> "Efficient User-Level File Cache Management on the Sun Vnode Interface." </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 325-332. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Another transport service, the utok (user to kernel) layer, allows user-level calls on lower-level vnodes which exist inside the kernel. As a result, layers may be developed and executed as user code. Although this RPC has real cost, careful caching can provide acceptable performance for an out-of-kernel file system <ref> [SKS90] </ref>. But stackable layering offers a valuable complement to this approach. Because file system layers each interact only through the layer interface, the transport layers can be removed from this configuration without affecting a layer's implementation. The file system can then run in the kernel, avoiding all RPC overhead.
Reference: [Str86] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: In C, this is implemented as an indirect function call through the correct element of the vector. This approach is identical to that typically used to implement C ++ virtual class methods <ref> [Str86] </ref>. Some file system stacking is possible with the standard vnode interface us 23 ing the mount mechanism. Sun Microsystems' NFS [SGK + 85], loopback, and translucent [Hen90] file systems take this approach.
Reference: [Sun87] <author> Sun Microsystems. "XDR: </author> <title> External Data Representation standard." </title> <type> Technical Report RFC-1014, </type> <institution> Internet Request For Comments, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: Detailed interface information is needed at several different places throughout 32 the layers. Rather than require that the interface designer keep this information consistent in several different places, operation definitions are combined into an interface definition file. Similar to the data description language used by Sun's rpcgen compiler <ref> [Sun87, Sun88] </ref> and also Hewlett-Packard's NIDL data description language [ZDL + 90], this file lists each operation and its arguments 6 . 3.7 Flow of Control Traditional layered services have had a strictly linear behavior. A user would request a service.
Reference: [Sun88] <author> Sun Microsystems. </author> <title> "RPC: Remote Procedure Call Protocol specification version 2." </title> <type> Technical Report RFC-1057, </type> <institution> Internet Request For Comments, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Detailed interface information is needed at several different places throughout 32 the layers. Rather than require that the interface designer keep this information consistent in several different places, operation definitions are combined into an interface definition file. Similar to the data description language used by Sun's rpcgen compiler <ref> [Sun87, Sun88] </ref> and also Hewlett-Packard's NIDL data description language [ZDL + 90], this file lists each operation and its arguments 6 . 3.7 Flow of Control Traditional layered services have had a strictly linear behavior. A user would request a service.
Reference: [Sun89] <author> Sun Microsystems. "NFS: </author> <title> Network File System Protocol Specification." </title> <type> Technical Report RFC-1094, </type> <institution> Internet Request For Comments, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: In the past, a well defined RPC protocol enumerating a fixed set of operations insured compatibility <ref> [Sun89] </ref>. This approach is incompatible with the principles of extensibility required by new file system development. Instead of a fixed set of operations, each operation in the 405 interface is assigned a universally unique identifier when it is defined.
Reference: [Sun90] <author> Sun Microsystems. </author> <title> "Network Extensible File System Protocol Specification, </title> <type> draft." </type> <note> Available for anonymous ftp on titan.rice.edu as public/nefs.doc.ps, February 1990. 99 </note>
Reference-contexts: None of these approaches provide explicit support for stacking or extensibility, but all provide basic modularity. NeFS describes one approach to an extensible file system interface <ref> [Sun90] </ref>, focusing exclusively on remote file access.
Reference: [Wu91] <author> Yuguang Wu. </author> <title> "The Measurement Layer." </title> <type> Personal communication, </type> <month> July </month> <year> 1991. </year>
Reference-contexts: The ease-of-use of a measurements layer raises the potential for systems administrators to examine their configuration for possible tuning. At UCLA, Yuguang Wu has built a prototype measurements layer <ref> [Wu91] </ref>. A modification to the null layer, the measurements layer records the entry and 52 exit times of operations, as well as interesting operation arguments. With a post-processor, the layer can examine working set size. The measurements layer is a particularly interesting stackable layer because it is completely semantics free.
Reference: [ZDL + 90] <author> Lisa Zahn, Terence H. Dineen, Paul J. Leach, Elizabeth A. Martin, Nathaniel W. Mishkin, Joseph N. Pato, and Geoffrey L. Wyant. </author> <title> Network Computing Architecture. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year> <month> 100 </month>
Reference-contexts: Rather than require that the interface designer keep this information consistent in several different places, operation definitions are combined into an interface definition file. Similar to the data description language used by Sun's rpcgen compiler [Sun87, Sun88] and also Hewlett-Packard's NIDL data description language <ref> [ZDL + 90] </ref>, this file lists each operation and its arguments 6 . 3.7 Flow of Control Traditional layered services have had a strictly linear behavior. A user would request a service.
References-found: 57

