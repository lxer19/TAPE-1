URL: http://www.tns.lcs.mit.edu/~djw/library/mpid.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/
Root-URL: 
Email: e-mail: dimarzo@cui.unige.ch  
Phone: Phone: +41 22 705 76 43, Fax: +41 22 705 77 80  
Title: The Messenger Paradigm and its Implications on Distributed Systems  
Author: Giovanna Di Marzo, Murhimanya Muhugusa, Christian Tschudin Jurgen Harms 
Address: 24, rue General Dufour, CH-1211 Geneve 4  
Affiliation: Centre Universitaire d'Informatique, University of Geneva  
Note: To be published in the proceedings of ICC'95 workshop on Intelligent Computer Communication  
Abstract: Most distributed systems are built on top of a message exchange infrastructure. Processes coordinate their execution by exchanging messages which are interpreted according to a pre-established set of protocols. We present in this paper a novel way of communicating which does not require the preconfiguration of protocol entities. The host initiating the communication has the ability to instruct the other host how the data exchange has to take place. We call this communication by messengers. The host that initiates the data exchange sends to the recipient a program called messenger which contains all or parts of the protocol logic. After it has been received by the recipient, the messenger is executed and can, if necessary, deliver its payload. Communication by messengers will change the way distributed systems are built. This paper discusses the impact of the messenger paradigm in various fields such as communication protocols, distributed operating systems and intelligent agents. Keywords: communication by messengers, distributed operating systems, intelligent agents, protocol design and implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Agha. </author> <title> Actors: A model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: The possibility for a messenger process to replace its behavior with the chain primitive can be compared with the change of behavior of actors in the actor model of Agha <ref> [1] </ref>. The difference resides in the fact that the behavior change is a fundamental part of the actor model: actors are seen as abstract machines dedicated to process one incoming communication. Actors always change explicitly or not their behavior before processing the next communication. <p> Actors communicate by message-passing, also called communication or task, and carry out their actions concurrently. The behavior of an actor consists in processing a communication, which can result in the creation of new actors, new tasks and a replacement behavior enabling the current actor to process the next communication <ref> [1] </ref>. An actor, in a given configuration, can work with external actors, but an actor always waits for an incoming communication and interprets this message according to its current behavior.
Reference: [2] <author> M. Betz. </author> <title> Omg's corba. </title> <journal> Dr. Dobb's Special Report, </journal> (225):8-12, Winter 1994/1995. 
Reference-contexts: Such an infrastructure resembles very much type systems e.g., the one found in the distributed object execution environment CORBA <ref> [2] </ref>.
Reference: [3] <author> D. Clark. </author> <title> The structuring of systems using upcalls. </title> <booktitle> In Tenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 171180. SigOps, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: This decomposition of the protocol's logic is related to a software structuring technique called upcalls: this technique is not new, but it is not always intuitive to produce <ref> [3] </ref>. Thus, at long term it would be interesting to have automated tools that take a PDU-based protocol as input and produce a set of equivalent messengers.
Reference: [4] <author> O. Etzioni, N. Lesh, and R. Segal. </author> <title> Building sofbots for unix. </title> <type> Technical report, </type> <institution> University of Washington, </institution> <year> 1993. </year>
Reference-contexts: They interact with the environment either by the means of effectors i.e., commands used to change the external environ ment's state and sensors or commands providing the softbot with information about the environment [5], <ref> [4] </ref>. Telescript In the TELESCRIPT technology, agents occupy virtual locations, called places. They are mobile processes able to communicate (exchange messages) with one another and to move from one place to another. The moving of agents is realized by sending their program to another place where it is executed.
Reference: [5] <author> O. Etzioni and D. Weld. </author> <title> A softbot-based interface to the internet. </title> <journal> CACM, </journal> <volume> 37(7) </volume> <pages> 72-76, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Softbots are agents interacting with a software environment by issuing commands and interpreting the environment's feedback. They interact with the environment either by the means of effectors i.e., commands used to change the external environ ment's state and sensors or commands providing the softbot with information about the environment <ref> [5] </ref>, [4]. Telescript In the TELESCRIPT technology, agents occupy virtual locations, called places. They are mobile processes able to communicate (exchange messages) with one another and to move from one place to another. The moving of agents is realized by sending their program to another place where it is executed.
Reference: [6] <author> M. R. Genesereth and S. P. Ketchpel. </author> <title> Software agents. </title> <journal> CACM, </journal> <volume> 37(7) </volume> <pages> 48-53, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: approaches for agent communication languages: (1) the procedural approach where the communication between software agents is modeled as the exchange of entire programs that are directly executable; (2) the declarative approach where the communication is modeled as the exchange of data together with the commands useful for interpreting the data <ref> [6] </ref>. In our opinion, the messenger paradigm sits at a lower level with respect to these two approaches. <p> retrieving the information where it resides. 5.3 Multi-agent Architectures Different architectures realize software interoperation: (1) a direct communication between software agents, where agents handle themselves their own collaboration; (2) an indirect communication where agents communicate with intermediary and local system programs, the facilitators, which in turn communicate with one another <ref> [6] </ref>. The messenger paradigm provides a homogeneous framework for realizing the direct as well as the indirect communication. As we said before, messengers are completely responsible for their coordination inside a platform. This is also true for a set of messengers executing in different platforms.
Reference: [7] <author> P. Maes. </author> <title> Agents that reduce work and information overload. </title> <journal> CACM, </journal> <volume> 37(7) </volume> <pages> 30-40, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Maes proposes an alternative approach to the knowledge-based approach where the agents are provided with a background knowledge concerning the user and the application <ref> [7] </ref>. Her approach relies on machine-learning techniques and consists in giving the interface agents the minimum knowledge: the agents will then learn their appropriate behavior from other agents and from the user.
Reference: [8] <author> M. Muhugusa, G. Di Marzo, C. Tschudin, E. Solana, and J. Harms. Comscript: </author> <title> An environment for the implementation of protocol stacks and their dynamic reconfiguration. </title> <booktitle> In International Symposium on Applied Corporate Computing ISACC 94. </booktitle> <institution> ITESM Monterrey and Texas A&M University, </institution> <year> 1994. </year>
Reference-contexts: We can make here a parallel with the area of communication protocol architecture. One topic of interest in this area is the configuration of flexible protocol stacks which also requires an interpreted language and some kind of platform (see e.g., COMSCRIPT <ref> [8] </ref>. As messengers can move freely from platform to platform without the need of protocols between hosts, a micro- kernel for a distributed operating system can be protocol- free. This is possible because there is no longer the abstraction of data exchange in a messenger based operating system.
Reference: [9] <author> M. Rozier, V Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> Overview of the chorus distributed operating sys-tems. </title> <type> Technical Report CS/TR-90-25, </type> <institution> Chorus Systemes, </institution> <year> 1990. </year>
Reference-contexts: Moreover, management decisions and policies were directly hard wired in the heart of the system making it difficult to evolve. To overcome the drawbacks of this monolithic architecture, modern operating systems e.g., Amoeba [10] and Chorus <ref> [9] </ref> use a micro-kernel architecture. Only a minimal set of services is confined in the kernel, other services are provided by special processes external to the kernel called servers. With this approach, management decisions and policies are shifted from the kernel to the servers.
Reference: [10] <author> A. S. Tanenbaum, , M. F. Kaashoek, R. van Renesse, and H. Bal. </author> <title> The amoeba distributed operating system-a status report. </title> <journal> Computer Communications, </journal> <volume> 14 </volume> <pages> 324-335, </pages> <month> July/August </month> <year> 1991. </year>
Reference-contexts: Moreover, management decisions and policies were directly hard wired in the heart of the system making it difficult to evolve. To overcome the drawbacks of this monolithic architecture, modern operating systems e.g., Amoeba <ref> [10] </ref> and Chorus [9] use a micro-kernel architecture. Only a minimal set of services is confined in the kernel, other services are provided by special processes external to the kernel called servers. With this approach, management decisions and policies are shifted from the kernel to the servers.
Reference: [11] <author> A. S. Tanenbaum. </author> <title> Modern Operating Systems. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: That is what is discussed in this section. 4.1 Modern Operating Systems Most operating systems <ref> [11] </ref> are designed as a monolithic piece of software structured in modules or layers, each module being responsible for a well defined service. Examples for the services offered are process management and memory management.
Reference: [12] <author> C. Tschudin. </author> <title> An introduction to the m0 messenger language. </title> <type> Technical Report No 86 (Cahier du CUI), </type> <institution> University of Geneva, </institution> <year> 1994. </year>
Reference-contexts: the following, we briefly describe our two messenger platforms. 2.3.1 The M messenger Platform The M (M-Zero) project started in december 1993; a first version of the M platform that runs on various UNIX systems and that contains a full interpreter of the M language was distributed in June 1994 <ref> [12] </ref> and can be fetched by FTP at cui.unige.ch under pub/m0. The M language is ASCII-based and closely resembles POSTSCRIPT although it does not contain any graphics related operators. Op- erators usually have single-character names, thus making messenger programs very compact.
Reference: [13] <author> C. F. Tschudin. </author> <title> On the Structuring of Computer Communications. </title> <type> PhD thesis, </type> <institution> Universite de Geneve, </institution> <year> 1993. </year> <note> These No 2632. </note>
Reference-contexts: Finally, we conclude this paper in section 6. 2 The Messenger Paradigm The messenger paradigm is born from a new way of thinking computer communications. Instead of the classical sender/receiver model based on protocol entities that exchange and interpret protocol specific messages, Tschudin proposed in <ref> [13] </ref> a communication model based on the exchange of protocol unspecific programs, called the messengers.
Reference: [14] <author> C. F. Tschudin, G. Di Marzo, M. Muhugusa, and J. Harms. </author> <title> Messenger-based operating systems. </title> <type> Technical Report No 90 (Cahier du CUI), </type> <institution> University of Geneva, </institution> <year> 1994. </year>
Reference-contexts: We are currently implementing a first prototype of a messenger based operating system where a currency mechanism is investigated to be used as a unified approach for controlling all system resources <ref> [14] </ref>. 5 Messengers for Intelligent Agents Intelligent Agents, being at the heart of Artificial Intelli- gence (AI), are now widely used in several others domains like human computer interactions, robotics, knowledge representation, etc. Agents are autonomous mobile entities able to interact with other agents and to react to their environment.
Reference: [15] <author> R. Lino Valverde. Msgr-s: </author> <title> Un environnement d'execution de messagers base sur un interpreteur scheme parallele. </title> <type> Diploma thesis, </type> <institution> University of Geneva, </institution> <year> 1994. </year>
Reference-contexts: It resulted in a SCHEME interpreter named MSGR-S <ref> [15] </ref> that supports parallel interpreter processes. The new functions setglob and getglob enable the access to the common variable space, the function exist? can be used to check if a name already is in use. Most notable is the way new messengers are generated and submitted.
Reference: [16] <author> J. E. White. </author> <title> Telescript technology: The foundation for the elec-tronic marketplace. White paper, General Magic, </title> <publisher> Inc., </publisher> <address> 2465 Latham Stree, Mountain View, CA 94040, </address> <year> 1994. </year>
Reference-contexts: They are mobile processes able to communicate (exchange messages) with one another and to move from one place to another. The moving of agents is realized by sending their program to another place where it is executed. In electronic marketplace applications, agents are providers and consumers of goods <ref> [16] </ref>, [17]. 6 Conclusion The messenger paradigm is a communication model relying on instruction-passing instead of message-passing. Messengers are mobile threads of execution that can travel across a network.
Reference: [17] <author> M. Wooldridge and N. R. Jennings. </author> <title> Agent theories, architectures, and languages: A survey. </title> <editor> In Jennings Wooldridge, editor, </editor> <booktitle> Intelligent Agents, ECAI-94, workshop on Agent theories, Architectures, and Languages, LNAI 890, </booktitle> <pages> pages 1-39. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1994. </year>
Reference-contexts: Agents are autonomous mobile entities able to interact with other agents and to react to their environment. Intelligent agents are then agents whose behaviors can be compared with those of humans <ref> [17] </ref>. The specific criteria applied above to agents can also be applied to messengers. However, messengers are not necessarily agents, but they may be used to implement them. Poten- tially, the messenger paradigm offers alternatives and new opportunities in the way of thinking high-level distributed applications using intelligent agents. <p> They are mobile processes able to communicate (exchange messages) with one another and to move from one place to another. The moving of agents is realized by sending their program to another place where it is executed. In electronic marketplace applications, agents are providers and consumers of goods [16], <ref> [17] </ref>. 6 Conclusion The messenger paradigm is a communication model relying on instruction-passing instead of message-passing. Messengers are mobile threads of execution that can travel across a network.
References-found: 17

