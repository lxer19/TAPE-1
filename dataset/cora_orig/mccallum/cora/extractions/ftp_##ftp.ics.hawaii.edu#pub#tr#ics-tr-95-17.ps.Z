URL: ftp://ftp.ics.hawaii.edu/pub/tr/ics-tr-95-17.ps.Z
Refering-URL: ftp://ftp.ics.hawaii.edu/pub/tr/INDEX.html
Root-URL: 
Email: corbett@hawaii.edu  
Phone: (808) 956-6107  
Title: A Method for Timing Analysis of Ada Tasking Programs  
Author: James C. Corbett 
Keyword: timing analysis, real-time systems, hybrid systems, Ada tasking.  
Note: Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE. This research was supported by National Science Foundation grant CCR-9308067.  
Address: Honolulu, HI 96822  
Affiliation: Department of Information and Computer Science University of Hawai`i at Manoa  
Abstract: Concurrent real-time software is increasingly used in safety-critical embedded systems. Assuring the quality of such software requires the rigor of formal methods. In order to analyze a program formally, we must first construct a mathematical model of its behavior. In this paper, we consider the problem of constructing such models for concurrent real-time software. In particular, we provide a method for building mathematical models of real-time Ada tasking programs that are accurate enough to verify interesting timing properties, and yet abstract enough to yield a tractable analysis on nontrivial programs. Our approach differs from schedulability analysis in that we do not assume that the software has a highly restricted structure (e.g., a set of periodic tasks). Also, unlike most abstract models of real-time systems, we account for essential properties of real implementations, such as resource constraints and run-time overhead. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, C. Courcoubetis, N. Halbwachs, T. Henzinger, P. Ho, X. Nicollin, A. Olivero, J. Sifakis, and S. Yovine. </author> <title> The algorithmic analysis of hybrid systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 138 </volume> <pages> 3-34, </pages> <year> 1995. </year>
Reference-contexts: In order to insure that our model is a conservative abstraction of the program's timing properties, we also discuss how to account for various common source of run-time overhead. 27 4.1 Hybrid Automata We chose constant slope linear hybrid automaton <ref> [1] </ref> as our timed model. Hybrid automata combine a finite-state control with a set of real-valued variables. The values of the variables change continuously while the automaton remains at a control location, and may change discretely with an instantaneous transition from one control location to another. <p> We give the formal definition for hybrid automata below. These definitions are a combination of those from <ref> [1] </ref> and [23]. 4.1.1 Syntax A hybrid automaton (HA) M is a 6-tuple (Loc; V ar; Lab; Edg; Act; Inv) where * Loc is a set of locations. * V ar is a set of real-valued variables. <p> In a continuous time model, we could represent this region with a millisecond delay in the real interval [1027; 1937]. By changing the time unit to seconds and sacrificing some accuracy, we could instead represent the code region using a second delay in the real interval <ref> [1; 2] </ref>. Note that both of these representations are conservative abstractions|every program behavior is represented. <p> The analysis automaton is analyzed using the standard method for reachability analysis of hybrid systems, which is described in detail in <ref> [1] </ref>. The method determines the set of reachable states of a hybrid automaton 34 Signal z := 0 z := 0 Robot Example Fire Fire Push Push z := 0 z := 0 Example using the fixpoint technique we sketch below. <p> For example, an upper bound on the value of a variable z can be obtained by solving for the parameter ff in post fl (I) " (z ff). The state reachability problem for hybrid automata is undecidable <ref> [1] </ref>. It follows that the above analysis algorithm provides only a semidecision procedure|there may be no fixpoint and thus the algorithm may not terminate.
Reference: [2] <author> R. Alur and D. Dill. </author> <title> Automata for modeling real-time systems. </title> <booktitle> In Proc. 17th Int. Colloq. </booktitle> <address> Aut. Lang. Prog., </address> <year> 1990. </year>
Reference-contexts: Before developers of certifiably safe software can take advantage of the concurrent and real-time constructs of Ada, rigorous analysis techniques to analyze their timing properties must be developed. Many formal models have been proposed for general concurrent real-time systems. These include timed Petri nets [7, 15], timed automata <ref> [2, 28] </ref>, timed process algebras [13, 14, 31], and real-time logics [16, 24]. For the most part, these models are intended to represent specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software. <p> Such constraints are awkward to represent in most real-time specification languages, which provide mechanisms in which time advances uniformly for all components (e.g., timed automata <ref> [2] </ref>, which are hybrid automata in which all clocks advance at rate one in all locations). Whether real-time systems should be modeled with continuous or discrete time is still a topic of debate. Our second reson for choosing hybrid automata was to use a continuous model of time. <p> In a continuous time model, we could represent this region with a millisecond delay in the real interval [1027; 1937]. By changing the time unit to seconds and sacrificing some accuracy, we could instead represent the code region using a second delay in the real interval <ref> [1; 2] </ref>. Note that both of these representations are conservative abstractions|every program behavior is represented.
Reference: [3] <author> R. Alur and R. Kurshan. </author> <title> Timing verification by successive approximation. </title> <journal> Information and Computation, </journal> <volume> 118(1) </volume> <pages> 142-157, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: A variable representing an alarm is relevant only while the alarm is pending and is thus set to unknown when the timer signal occurs. Second, we polish <ref> [3] </ref> all the timing constraints in the program automaton so that all constants appearing in the constraints are multiples of some fixed value m.
Reference: [4] <author> E. Ashcroft and Z. Manna. </author> <title> Formalization of properties of parallel programs. </title> <journal> Machine Intelligence, </journal> <volume> 6 </volume> <pages> 17-41, </pages> <year> 1971. </year>
Reference-contexts: In this section, we reduce the size of the transition system by applying virtual coarsening <ref> [4] </ref>, a well-known technique for reducing the size of concurrency models by collapsing invisible actions into adjacent visible actions.
Reference: [5] <author> G. S. Avrunin, U. A. Buy, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Time Iterations Time Robot 303 558 11 5 37 43 Target 289 715 8 6 48 2,486 Table 3: Performance of Tools on Case Studies Duration/Delay Range/Value ReadFrame [100; 200] CameraPeriod 4,000 Bodies of Image entries [100; 200] ImageExpire 4,000 AimInitial [400; 1100] AimRefine [400; 700] Bodies of Command entries <ref> [5; 10] </ref> AimAndFire [100; 300] Table 4: Durations Used in Target Example time from the integrator task to cause it to miss its deadline on the second Signal. <p> For example, the delay statement need not be modeled at all in a concurrency analysis, and most rendezvous can be modeled with a single transition <ref> [5] </ref>.
Reference: [6] <author> G. S. Avrunin, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automatic derivation of time bounds in uniprocessor concurrent systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 20(9) </volume> <pages> 708-719, </pages> <year> 1994. </year>
Reference-contexts: Since then, however, advances in concurrent systems analysis (e.g., symbolic model checking, state space reductions) have greatly extended the size of the programs to which that basic modeling/analysis technique can be applied [8]. Indeed, several symbolic/approximate analysis techniques have already been proposed for simpler models of real-time programs <ref> [6, 11, 27] </ref>. 6 Conclusion We have presented a method for constructing mathematical models of general real-time Ada tasking programs suitable for verifying their timing properties, and have demonstrated the feasibility of our method by constructing and analyzing models of two nontrivial programs.
Reference: [7] <author> B. Berthomieu and M. Diaz. </author> <title> Modeling and verification of time dependent systems using time Petri nets. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17 </volume> <pages> 259-273, </pages> <year> 1991. </year>
Reference-contexts: Before developers of certifiably safe software can take advantage of the concurrent and real-time constructs of Ada, rigorous analysis techniques to analyze their timing properties must be developed. Many formal models have been proposed for general concurrent real-time systems. These include timed Petri nets <ref> [7, 15] </ref>, timed automata [2, 28], timed process algebras [13, 14, 31], and real-time logics [16, 24]. For the most part, these models are intended to represent specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software.
Reference: [8] <author> J. C. Corbett. </author> <title> An empirical evaluation of three methods for deadlock analysis of Ada tasking programs. </title> <editor> In T. Ostrand, editor, </editor> <booktitle> Proceedings of the 1994 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 204-215. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1994. </year>
Reference-contexts: Since then, however, advances in concurrent systems analysis (e.g., symbolic model checking, state space reductions) have greatly extended the size of the programs to which that basic modeling/analysis technique can be applied <ref> [8] </ref>.
Reference: [9] <author> J. C. Corbett. </author> <title> Modeling and analysis of real-time Ada tasking programs. </title> <booktitle> In Ramamritham [30], </booktitle> <pages> pages 132-141. </pages>
Reference-contexts: The resulting hybrid automaton is then analyzed automatically. We use the HyTech verifier for hybrid systems [22] to analyze the hybrid automata produces by our method. This work extends that of <ref> [9] </ref> and [10] in several ways. First, we model several new constructs introduced in Ada 95 2 , including protected types, the delay until statement, and asynchronous transfer of control. Second, we explicitly represent the run-time system in the model. <p> These two programs will be analyzed in Section 5.3. 2.3.1 Robot Example The first example is a robot controller analyzed in <ref> [9, 21] </ref> and based on the distributed robot system of [14]. The program collects sensor data and integrates this data to periodically send a command to a robot. There are two sensor tasks and one integrator task. <p> In <ref> [9, 10] </ref>, the composition operator was used to combine hybrid automata representing each task into a hybrid automaton representing the program. <p> This run can help the analyst understand how the program can violate the timing requirement, and perhaps suggest ways to modify the program in order to meet the requirement. For a version of this example, we showed in <ref> [9] </ref> that, if the integrator task is given the highest priority, then the timing requirement is met. The performance of the model building tool and HyTech on the case studies is given in Table 3.
Reference: [10] <author> J. C. Corbett. </author> <title> Constructing abstract models of concurrent real-time software. </title> <editor> In S. Ziel, editor, </editor> <booktitle> Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA). </booktitle> <publisher> ACM Press, </publisher> <month> January </month> <year> 1996. </year>
Reference-contexts: The resulting hybrid automaton is then analyzed automatically. We use the HyTech verifier for hybrid systems [22] to analyze the hybrid automata produces by our method. This work extends that of [9] and <ref> [10] </ref> in several ways. First, we model several new constructs introduced in Ada 95 2 , including protected types, the delay until statement, and asynchronous transfer of control. Second, we explicitly represent the run-time system in the model. <p> For example, the statement select when X &gt; 0 =&gt; accept Decrement; X := X - 1; when X &lt; 10 =&gt; accept Increment; X := X + 1; end select; will not accept calls that cause X to go out of the range <ref> [0; 10] </ref>. 2.1.3 Timed/Conditional Rendezvous Additional forms of the select statement can be used to bound the time that a task will wait for a rendezvous; these are useful for real-time programs. <p> A behavior of the transition system is a sequence of T fl -points reached during one of its possible 7 T fl -points are a formal characterization of the S-points used informally in <ref> [10] </ref>. 26 _x 1 = 0 _x 1 = 1 _x 2 = 0 _x 1 = 1 x 2 := 0 In all locations: n _ow = 1 x 2 := 0 _x 1 = 0 _x 2 = 1 x 2 U c _x 1 = 0 x 2 <p> In <ref> [9, 10] </ref>, the composition operator was used to combine hybrid automata representing each task into a hybrid automaton representing the program. <p> For example, we write (call T E) rather than T.E. 35 Construct Duration/Delay Range/Value Rendezvous Code to queue/pend call in caller (before blocking) [60; 80] Code to complete call in caller (after being signaled) <ref> [10; 20] </ref> Code to begin rendezvous in acceptor (before body) [25; 50] Code to complete rendezvous in acceptor (after body) [25; 50] Protected Code to queue/pend call in caller [25; 50] Object Code to complete call in caller [25; 50] Delay Code to set timer request [25; 50] Code to process <p> Time Iterations Time Robot 303 558 11 5 37 43 Target 289 715 8 6 48 2,486 Table 3: Performance of Tools on Case Studies Duration/Delay Range/Value ReadFrame [100; 200] CameraPeriod 4,000 Bodies of Image entries [100; 200] ImageExpire 4,000 AimInitial [400; 1100] AimRefine [400; 700] Bodies of Command entries <ref> [5; 10] </ref> AimAndFire [100; 300] Table 4: Durations Used in Target Example time from the integrator task to cause it to miss its deadline on the second Signal.
Reference: [11] <author> J. C. Corbett and G. S. Avrunin. </author> <title> A practical method for bounding the time between events in concurrent real-time systems. </title> <editor> In T. Ostrand and E. Weyuker, editors, </editor> <booktitle> Proceedings of the 1993 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 110-116, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Since then, however, advances in concurrent systems analysis (e.g., symbolic model checking, state space reductions) have greatly extended the size of the programs to which that basic modeling/analysis technique can be applied [8]. Indeed, several symbolic/approximate analysis techniques have already been proposed for simpler models of real-time programs <ref> [6, 11, 27] </ref>. 6 Conclusion We have presented a method for constructing mathematical models of general real-time Ada tasking programs suitable for verifying their timing properties, and have demonstrated the feasibility of our method by constructing and analyzing models of two nontrivial programs.
Reference: [12] <author> P. Cousot and N. Halbwachs. </author> <title> Automatic discovery of linear restraints among variables of a program. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1978. </year>
Reference-contexts: Further, existential quantification can be used to perform a parametric analysis in which the required constraints on one or more parameters can be derived automatically <ref> [12] </ref>. For example, an upper bound on the value of a variable z can be obtained by solving for the parameter ff in post fl (I) " (z ff). The state reachability problem for hybrid automata is undecidable [1].
Reference: [13] <author> A. N. Fredette and R. Cleaveland. RTSL: </author> <title> a formal language for real-time schedulability analysis. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <pages> pages 274-283, </pages> <year> 1993. </year>
Reference-contexts: Many formal models have been proposed for general concurrent real-time systems. These include timed Petri nets [7, 15], timed automata [2, 28], timed process algebras <ref> [13, 14, 31] </ref>, and real-time logics [16, 24]. For the most part, these models are intended to represent specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software.
Reference: [14] <author> R. Gerber and I. Lee. </author> <title> A layered approach to automating the verification of real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 18(9) </volume> <pages> 768-784, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Many formal models have been proposed for general concurrent real-time systems. These include timed Petri nets [7, 15], timed automata [2, 28], timed process algebras <ref> [13, 14, 31] </ref>, and real-time logics [16, 24]. For the most part, these models are intended to represent specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software. <p> These two programs will be analyzed in Section 5.3. 2.3.1 Robot Example The first example is a robot controller analyzed in [9, 21] and based on the distributed robot system of <ref> [14] </ref>. The program collects sensor data and integrates this data to periodically send a command to a robot. There are two sensor tasks and one integrator task. The program's structure is shown in Figure 4 and its source code is shown in Figure 5.
Reference: [15] <author> C. Ghezzi, D. Mandriolli, S. Morasca, and M. Pezze. </author> <title> A unified high-level Petri net model for time-critical systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(2), </volume> <month> Feb. </month> <year> 1991. </year> <month> 39 </month>
Reference-contexts: Before developers of certifiably safe software can take advantage of the concurrent and real-time constructs of Ada, rigorous analysis techniques to analyze their timing properties must be developed. Many formal models have been proposed for general concurrent real-time systems. These include timed Petri nets <ref> [7, 15] </ref>, timed automata [2, 28], timed process algebras [13, 14, 31], and real-time logics [16, 24]. For the most part, these models are intended to represent specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software.
Reference: [16] <author> C. Ghezzi, D. Mandriolli, and A. Morzenti. </author> <title> Trio: A logic language for executable specifications of real-time systems. </title> <journal> Journal of Systems and Software, </journal> <volume> 12(2) </volume> <pages> 107-123, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Many formal models have been proposed for general concurrent real-time systems. These include timed Petri nets [7, 15], timed automata [2, 28], timed process algebras [13, 14, 31], and real-time logics <ref> [16, 24] </ref>. For the most part, these models are intended to represent specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software. For example, resource constraints are absent in most of these models and are awkward to represent within them.
Reference: [17] <author> E. W. Giering and T. P. Baker. </author> <title> Using POSIX threads to implement Ada tasking: Description of work in progress. </title> <booktitle> In Proceedings of TriAda'92, </booktitle> <pages> pages 518-529, </pages> <year> 1992. </year>
Reference: [18] <author> E. W. Giering and T. P. Baker. </author> <title> The Gnu Ada runtime library (GNARL): </title> <booktitle> Design and implementation. In Proceedings of the Eleventh Annual Washington Ada Symposium and Summer ACM SIGAda Meeting (WAdaS '94), </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: The details of the data structures used to hold this information, as well the code used to implement the constructs, varies from compiler to compiler. In order to understand how an Ada run-time system could be implemented, we looked at the GNU Ada Run-time Library (GNARL) <ref> [18] </ref>, the run-time system of the GNU Ada Translator (GNAT). The design and implementation of GNARL is described in several papers [17-19] and its source code is freely available. <p> If awakened by the caller, the task cancels the pending timer signal. A delay (until) alternative can also be used in a timed entry call to bound the time the caller will wait for the entry to be accepted. We use the simple soure transformation suggested in <ref> [18] </ref> to implement a timed entry call in terms of an asynchronous transfer of control. <p> code is straightforward: we simply treat this code like any other code executed by the task and include its execution time in the bounds of the corresponding code region. 4.3.2 Timer Services Our representation of the overhead of timer services is based on the implementation of those services in GNARL <ref> [18] </ref>. We give a brief overview of this implementation and then describe how to account for the resulting overhead.
Reference: [19] <author> E. W. Giering, F. Mueller, and T. P. Baker. </author> <title> Implementing Ada 9X features using POSIX threads: </title> <booktitle> Design issues. In Proceedings of TriAda'93, </booktitle> <year> 1993. </year>
Reference-contexts: This is the expected implementation of protected objects on a uniprocessor, called the proxy model in <ref> [19] </ref> (when an entry is closed, another task executes the entry body by proxy; this generally reduces the number of context switches). <p> Abortion may be deferred while a code segment executes by calling the primitives Defer Abortion (T) and Undefer Abortion (T) before and after the segment (e.g., as we did in Figure 13). Like GNARL, we implement abortion deferral with a software flag <ref> [19] </ref>.
Reference: [20] <author> M. G. Harbour, M. H. Klein, and J. P. Lehoczky. </author> <title> Timing analysis for fixed-priority scheduling of hard real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 20(1) </volume> <pages> 13-28, </pages> <year> 1994. </year>
Reference-contexts: For sequential code, tools to bound the worst case execution time have already been constructed [29] and some now account for the effects of caching and pipelining [25]. Timing analysis of concurrent software, however, is far less developed. In practice, schedulability analysis <ref> [20] </ref> is used to guarantee real-time requirements for programs comprising highly structured units of computation with limited interaction (e.g., periodic tasks with precedence constraints). <p> For example, we write (call T E) rather than T.E. 35 Construct Duration/Delay Range/Value Rendezvous Code to queue/pend call in caller (before blocking) [60; 80] Code to complete call in caller (after being signaled) <ref> [10; 20] </ref> Code to begin rendezvous in acceptor (before body) [25; 50] Code to complete rendezvous in acceptor (after body) [25; 50] Protected Code to queue/pend call in caller [25; 50] Object Code to complete call in caller [25; 50] Delay Code to set timer request [25; 50] Code to process
Reference: [21] <author> T. Henzinger and P.-H. Ho. HyTech: </author> <title> The Cornell Hybrid Technology Tool. </title> <booktitle> In Proceedings of the 1994 Workshop on Hybrid Systems and Autonomous Control, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: These two programs will be analyzed in Section 5.3. 2.3.1 Robot Example The first example is a robot controller analyzed in <ref> [9, 21] </ref> and based on the distributed robot system of [14]. The program collects sensor data and integrates this data to periodically send a command to a robot. There are two sensor tasks and one integrator task.
Reference: [22] <author> T. A. Henzinger, P.-H. Ho, and H. Wong-Toi. HyTech: </author> <title> the next generation. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1995. </year>
Reference-contexts: The resulting hybrid automaton is then analyzed automatically. We use the HyTech verifier for hybrid systems <ref> [22] </ref> to analyze the hybrid automata produces by our method. This work extends that of [9] and [10] in several ways. First, we model several new constructs introduced in Ada 95 2 , including protected types, the delay until statement, and asynchronous transfer of control. <p> The reduced transition system is generated directly (i.e., the original transition system is never constructed) by collapsing sequences of invisible transitions as they are encountered in the search. We analyze the program automaton constructed by our tool using the HyTech verifier for hybrid systems (version 1.02a) <ref> [22, 23] </ref>. Our tool outputs the program automaton as a HyTech input file. The property automaton is specified by hand in HyTech's input format, and also included in this file, along with a series of analysis commands.
Reference: [23] <author> T. A. Henzinger, P.-H. Ho, and H. Wong-Toi. </author> <title> A user guide to HyTech. </title> <type> Technical Report CSD-TR-95-1532, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1995. </year>
Reference-contexts: We give the formal definition for hybrid automata below. These definitions are a combination of those from [1] and <ref> [23] </ref>. 4.1.1 Syntax A hybrid automaton (HA) M is a 6-tuple (Loc; V ar; Lab; Edg; Act; Inv) where * Loc is a set of locations. * V ar is a set of real-valued variables. <p> For the target example, we are interested in the time between the button being pushed (Push event) and the device firing (Fire event). Figures 20-21 show the property automata we use for our case studies. Hints for specifying other kinds of commonly occurring properties are given in <ref> [23] </ref>. The synchronization labels in the property automaton identify events in the program that are mentioned in the timing requirement. We label each transition in the program automaton that represents the occurrence of one of these events with the appropriate label. <p> The state reachability problem for hybrid automata is undecidable [1]. It follows that the above analysis algorithm provides only a semidecision procedure|there may be no fixpoint and thus the algorithm may not terminate. Nevertheless, Henzinger reports <ref> [23] </ref> that the algorithm usually does terminate in practice, and our own experience supports this. 5.2 Analysis Tools In order to use our modeling technique on nontrivial programs, we implemented a prototype tool in COMMON Lisp that takes an Ada-like specification of a program 8 and constructs a hybrid automaton representing <p> The reduced transition system is generated directly (i.e., the original transition system is never constructed) by collapsing sequences of invisible transitions as they are encountered in the search. We analyze the program automaton constructed by our tool using the HyTech verifier for hybrid systems (version 1.02a) <ref> [22, 23] </ref>. Our tool outputs the program automaton as a HyTech input file. The property automaton is specified by hand in HyTech's input format, and also included in this file, along with a series of analysis commands. <p> HyTech composes the program and property automata, and then performs the analysis specified by the commands. We examine the output of HyTech to determine the result of the analysis. In order to improve the efficiency of the analysis, we use two techniques recommended in <ref> [23] </ref>. First, we explicitly set the values of variables that are no longer relevant to unknown.
Reference: [24] <author> F. Jahanian and A. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 12(5) </volume> <pages> 890-904, </pages> <year> 1986. </year>
Reference-contexts: Many formal models have been proposed for general concurrent real-time systems. These include timed Petri nets [7, 15], timed automata [2, 28], timed process algebras [13, 14, 31], and real-time logics <ref> [16, 24] </ref>. For the most part, these models are intended to represent specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software. For example, resource constraints are absent in most of these models and are awkward to represent within them.
Reference: [25] <author> S. Lim, Y. Bae, G. T. Jang, B. Rhee, S. Min, C. Y. Park, H. Shin, K. Park, and C. S. Kim. </author> <title> An accurate worst case timing analysis technique for RISC processors. </title> <booktitle> In Ramamritham [30], </booktitle> <pages> pages 97-108. </pages>
Reference-contexts: For sequential code, tools to bound the worst case execution time have already been constructed [29] and some now account for the effects of caching and pipelining <ref> [25] </ref>. Timing analysis of concurrent software, however, is far less developed. In practice, schedulability analysis [20] is used to guarantee real-time requirements for programs comprising highly structured units of computation with limited interaction (e.g., periodic tasks with precedence constraints). <p> The second kind constrains the actual time that a task waits for a timer signal. We discuss each in turn. As noted in Section 1, timing analysis of sequential code is a difficult problem that we do not address in this paper. We assume that existing techniques (e.g., <ref> [25, 29] </ref>) can be used to obtain upper and lower bounds on the execution time of a sequential code region between two T fl -points. <p> The time bounds of the code regions are specified using special computation events embedded in this specification; in a real timing analysis tool, these durations would be derived from the sequential code comprising these regions using techniques like <ref> [25, 29] </ref>. The model building tool first constructs the (reduced) transition system with a standard depth-first search of the state space, and then annotates the transitions with the appropriate timing constraints. <p> For example, we write (call T E) rather than T.E. 35 Construct Duration/Delay Range/Value Rendezvous Code to queue/pend call in caller (before blocking) [60; 80] Code to complete call in caller (after being signaled) [10; 20] Code to begin rendezvous in acceptor (before body) <ref> [25; 50] </ref> Code to complete rendezvous in acceptor (after body) [25; 50] Protected Code to queue/pend call in caller [25; 50] Object Code to complete call in caller [25; 50] Delay Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Upper <p> (call T E) rather than T.E. 35 Construct Duration/Delay Range/Value Rendezvous Code to queue/pend call in caller (before blocking) [60; 80] Code to complete call in caller (after being signaled) [10; 20] Code to begin rendezvous in acceptor (before body) <ref> [25; 50] </ref> Code to complete rendezvous in acceptor (after body) [25; 50] Protected Code to queue/pend call in caller [25; 50] Object Code to complete call in caller [25; 50] Delay Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Upper bound on atomic code segments (ffi) 80 Table 1: Durations <p> Range/Value Rendezvous Code to queue/pend call in caller (before blocking) [60; 80] Code to complete call in caller (after being signaled) [10; 20] Code to begin rendezvous in acceptor (before body) <ref> [25; 50] </ref> Code to complete rendezvous in acceptor (after body) [25; 50] Protected Code to queue/pend call in caller [25; 50] Object Code to complete call in caller [25; 50] Delay Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Upper bound on atomic code segments (ffi) 80 Table 1: Durations used for Run-Time Overhead (microseconds) Duration/Delay Range/Value ReadSensor1 [500; <p> blocking) [60; 80] Code to complete call in caller (after being signaled) [10; 20] Code to begin rendezvous in acceptor (before body) <ref> [25; 50] </ref> Code to complete rendezvous in acceptor (after body) [25; 50] Protected Code to queue/pend call in caller [25; 50] Object Code to complete call in caller [25; 50] Delay Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Upper bound on atomic code segments (ffi) 80 Table 1: Durations used for Run-Time Overhead (microseconds) Duration/Delay Range/Value ReadSensor1 [500; 800] Sensor1Expire 4,000 ReadSensor2 [1500; 1700] Sensor2Expire 8,000 PeriodLength <p> caller (after being signaled) [10; 20] Code to begin rendezvous in acceptor (before body) <ref> [25; 50] </ref> Code to complete rendezvous in acceptor (after body) [25; 50] Protected Code to queue/pend call in caller [25; 50] Object Code to complete call in caller [25; 50] Delay Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Upper bound on atomic code segments (ffi) 80 Table 1: Durations used for Run-Time Overhead (microseconds) Duration/Delay Range/Value ReadSensor1 [500; 800] Sensor1Expire 4,000 ReadSensor2 [1500; 1700] Sensor2Expire 8,000 PeriodLength 6,000 ProximityExpire 10,000 Compute [3100; 4800] Signal [500; <p> to begin rendezvous in acceptor (before body) <ref> [25; 50] </ref> Code to complete rendezvous in acceptor (after body) [25; 50] Protected Code to queue/pend call in caller [25; 50] Object Code to complete call in caller [25; 50] Delay Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Upper bound on atomic code segments (ffi) 80 Table 1: Durations used for Run-Time Overhead (microseconds) Duration/Delay Range/Value ReadSensor1 [500; 800] Sensor1Expire 4,000 ReadSensor2 [1500; 1700] Sensor2Expire 8,000 PeriodLength 6,000 ProximityExpire 10,000 Compute [3100; 4800] Signal [500; 600] Table 2: Durations Used in Robot
Reference: [26] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> J. ACM, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <year> 1973. </year>
Reference-contexts: Restricting the structure of a program allows special purpose scheduling algorithms/techniques (e.g., rate monotonic scheduling) to guarantee the program's timing constraints, either statically (at compile time) <ref> [26] </ref> or dynamically (at run-time) [35]. Control software for concurrent real-time embedded systems (e.g., avionics software) is often written in Ada. In fact, Ada was specifically designed for this application domain and contains constructs for creating multiple threads of control (tasks) and controlling their execution.
Reference: [27] <author> X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> Compiling real-time specifications into extended automata. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 18(9) </volume> <pages> 794-804, </pages> <year> 1992. </year>
Reference-contexts: Since then, however, advances in concurrent systems analysis (e.g., symbolic model checking, state space reductions) have greatly extended the size of the programs to which that basic modeling/analysis technique can be applied [8]. Indeed, several symbolic/approximate analysis techniques have already been proposed for simpler models of real-time programs <ref> [6, 11, 27] </ref>. 6 Conclusion We have presented a method for constructing mathematical models of general real-time Ada tasking programs suitable for verifying their timing properties, and have demonstrated the feasibility of our method by constructing and analyzing models of two nontrivial programs.
Reference: [28] <author> J. S. Ostroff. </author> <title> Deciding properties of timed transition models. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(2) </volume> <pages> 170-183, </pages> <year> 1990. </year>
Reference-contexts: Before developers of certifiably safe software can take advantage of the concurrent and real-time constructs of Ada, rigorous analysis techniques to analyze their timing properties must be developed. Many formal models have been proposed for general concurrent real-time systems. These include timed Petri nets [7, 15], timed automata <ref> [2, 28] </ref>, timed process algebras [13, 14, 31], and real-time logics [16, 24]. For the most part, these models are intended to represent specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software.
Reference: [29] <author> C. Y. Park and A. C. Shaw. </author> <title> Experiments with a program timing tool based on source-level timing schema. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 48-57, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Verification of the timing requirements of software is especially tedious to perform by hand and will require analysis tools to manage the overwhelming detail of implementations. For sequential code, tools to bound the worst case execution time have already been constructed <ref> [29] </ref> and some now account for the effects of caching and pipelining [25]. Timing analysis of concurrent software, however, is far less developed. <p> The second kind constrains the actual time that a task waits for a timer signal. We discuss each in turn. As noted in Section 1, timing analysis of sequential code is a difficult problem that we do not address in this paper. We assume that existing techniques (e.g., <ref> [25, 29] </ref>) can be used to obtain upper and lower bounds on the execution time of a sequential code region between two T fl -points. <p> The time bounds of the code regions are specified using special computation events embedded in this specification; in a real timing analysis tool, these durations would be derived from the sequential code comprising these regions using techniques like <ref> [25, 29] </ref>. The model building tool first constructs the (reduced) transition system with a standard depth-first search of the state space, and then annotates the transitions with the appropriate timing constraints.
Reference: [30] <author> K. Ramamritham, </author> <title> editor. </title> <booktitle> Proceedings of the Real-Time Systems Symposium. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> Dec. </month> <year> 1994. </year>
Reference: [31] <author> G. M. Reed and A. W. Roscoe. </author> <title> A timed model for communicating sequential processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 58 </volume> <pages> 249-261, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Many formal models have been proposed for general concurrent real-time systems. These include timed Petri nets [7, 15], timed automata [2, 28], timed process algebras <ref> [13, 14, 31] </ref>, and real-time logics [16, 24]. For the most part, these models are intended to represent specifications, not implementations. As such, they do not address the difficult issues that arise in representing real software.
Reference: [32] <author> A. C. Shaw. </author> <title> Reasoning about time in higher-level language software. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 15(7) </volume> <pages> 875-889, </pages> <year> 1989. </year>
Reference-contexts: This overhead, though small, must be accounted for in a conservative abstraction. We use the technique described in <ref> [32] </ref>, which uses bounds on the interrupt frequency and handler execution time to inflate the upper bounds of all task code regions.
Reference: [33] <author> R. N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent programs. </title> <journal> Commun. ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Nevertheless, we have shown the technique can still be useful on programs that are far too difficult to analyze by hand. Further, additional abstractions/reductions should extend the range of applicability to larger programs in the future. When reachability analysis was first proposed for concurrent Ada programs <ref> [33] </ref>, it too was infeasible for most programs of realistic size. Since then, however, advances in concurrent systems analysis (e.g., symbolic model checking, state space reductions) have greatly extended the size of the programs to which that basic modeling/analysis technique can be applied [8].
Reference: [34] <author> U. S. </author> <title> Department of Defense, Washington, </title> <editor> D. C. </editor> <title> Reference Manual for the Ada Programming Language, </title> <address> ANSI/MIL-STD-1815A edition, </address> <month> January </month> <year> 1983. </year>
Reference-contexts: Readers familiar with Ada may skim or skip this section. Details of the constructs described here can be obtained from the Ada Language Reference Manual <ref> [34] </ref>. 2.1.1 Tasks and Rendezvous An Ada program unit may declare one or more tasks, which are threads of control sharing the program's address space. Tasks execute concurrently and independently between points where they interact with other tasks. <p> An example of the use of an entry call as the triggering statement is given by this example from <ref> [34] </ref> of a command line processor: loop select Terminal.Wait_for_Interrupt; -- Accepted when user presses ^C Put_Line ("Interrupted"); then abort Put_Line ("-&gt; "); Get_Line (Command,Last); Process_Command (Command (1..Last)); end select; end loop; If the abortable part completes before the triggering statement, then an attempt is made to cancel the triggering statement; only
Reference: [35] <author> W. Zhao, K. Ramamritham, and J. A. Stankovic. </author> <title> Scheduling tasks with resource requirements in hard real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 12(5), </volume> <year> 1987. </year> <month> 40 </month>
Reference-contexts: Restricting the structure of a program allows special purpose scheduling algorithms/techniques (e.g., rate monotonic scheduling) to guarantee the program's timing constraints, either statically (at compile time) [26] or dynamically (at run-time) <ref> [35] </ref>. Control software for concurrent real-time embedded systems (e.g., avionics software) is often written in Ada. In fact, Ada was specifically designed for this application domain and contains constructs for creating multiple threads of control (tasks) and controlling their execution.
References-found: 35

