URL: http://www.cs.nmsu.edu/lldap/download/jicslp/lindgren.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/jicslp/lind.html
Root-URL: http://www.cs.nmsu.edu
Email: e-mail: thomasl@csd.uu.se  
Phone: Phone: +46 18 18 10 54  
Title: Compilation for Nested Recursion-Parallelism  
Author: Thomas Lindgren 
Date: September 9, 1996  
Address: Uppsala University  
Affiliation: Computing Science Dept.,  
Abstract: In this paper, we show that compilation for nested recursion-parallel execution can be accomodated by extending the existing analyses of Reform Prolog, a recursion-parallel Prolog implementation. Second, we show how to translate control-parallel code into equivalent recursion-parallel programs, thus extending the class of programs handled by the proposed system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Bevemyr, </author> <title> A scheme for executing nested recursion parallelism, </title> <booktitle> in JICSLP'96 Post-Conference Workshop on Implementation Techniques. </booktitle>
Reference-contexts: Scheduling A traditional problem in and-parallel systems is which goal to run next. A simple and cheap solution for Reform Prolog has been proposed by Bevemyr <ref> [1] </ref>. 6 1996 Compulog Net Meeting on Parallelism and Implementation Technology 4. From control-parallelism to recursion-parallelism In this section, we propose Nested Reform Prolog, a language unifying control- and recursion-parallel execution, and show how to convert control-parallelism into recursion-parallelism. We extend Reform Prolog into Nested Reform Prolog as follows. <p> M is local to each process and used briefly. N is used to set the loop bounds, then discarded. Furthermore note that the compiler could simplify this code somewhat. For instance, the computation of the loop bound is unnecessary: both X [0] and X <ref> [1] </ref> are known at compile-time.
Reference: [2] <author> J. Bevemyr, </author> <title> A Recursion Parallel Prolog Engine, </title> <booktitle> Licentiate of Philosophy Thesis, Uppsala Theses in Computer Science 16/93, </booktitle> <year> 1993. </year>
Reference-contexts: Further details, e.g., on handling predicates with side-effects, can be found in Refs. <ref> [2, 12] </ref>. By making the first restriction, we ensure that parallel and sequential execution yields the same answer.
Reference: [3] <author> J. Bevemyr, T. Lindgren, H. Millroth, </author> <title> Reform Prolog: the language and its implementation, </title> <booktitle> in Proc. </booktitle> <address> ICLP'93. </address>
Reference-contexts: 1. Introduction The first implementation of Reform Prolog <ref> [14, 4, 3, 13, 11] </ref> featured only parallel execution of a single parallel loop at a time: parallel computations could not themselves start parallel loops. While this lead to a simple and efficient execution model, it also restricted the programs that could be parallelized.
Reference: [4] <author> J. Bevemyr, T. Lindgren, H. Millroth, </author> <title> Exploiting recursion-parallelism in Prolog, </title> <booktitle> in Proc. </booktitle> <address> PARLE'93. </address>
Reference-contexts: 1. Introduction The first implementation of Reform Prolog <ref> [14, 4, 3, 13, 11] </ref> featured only parallel execution of a single parallel loop at a time: parallel computations could not themselves start parallel loops. While this lead to a simple and efficient execution model, it also restricted the programs that could be parallelized.
Reference: [5] <author> T. Chikayama, T. Fujise, D. Sekita, </author> <title> A portable and efficient implementation of KL1, </title> <booktitle> in Proc. </booktitle> <address> PLILP'94. </address>
Reference: [6] <author> G. Gupta, E. Pontelli, M. Hermenegildo, V. Santos Costa, </author> <title> ACE: And/Or-parallel copying-based execution of logic programs, </title> <booktitle> in Proc. </booktitle> <address> ICLP'94. </address>
Reference-contexts: The authors do not consider support for dependent and-parallelism. Unfolding to increase parallelism was also proposed by Tarnlund in his thesis [20], and has been a mainstay of fine-grained parallel compilers for Fortran or C for many years. Implementations such as &-Prolog [9] and &ACE <ref> [6] </ref> access the shared variables through an environment. The closest equivalent in Nested Reform Prolog is the set of shared arguments to the generated parallel predicate.
Reference: [7] <author> G. Gupta, V. Santos Costa, R. Yang, M. Hermenegildo, IDIOM: </author> <title> Integrating dependent and-, independent and-, and or-parallelism, </title> <booktitle> in Proc. </booktitle> <address> ILPS'91. </address>
Reference: [8] <author> M. Hermenegildo, D. Cabeza, M. Carro, </author> <title> Using attributed variables in the implementation of concurrent and parallel logic programming languages, </title> <booktitle> in Proc. </booktitle> <address> ICLP'95. </address>
Reference: [9] <author> M. Hermenegildo, </author> <title> An abstract machine for restricted AND-parallel execution of logic programs, </title> <booktitle> in Proc. </booktitle> <address> ICLP'86. </address>
Reference-contexts: The authors do not consider support for dependent and-parallelism. Unfolding to increase parallelism was also proposed by Tarnlund in his thesis [20], and has been a mainstay of fine-grained parallel compilers for Fortran or C for many years. Implementations such as &-Prolog <ref> [9] </ref> and &ACE [6] access the shared variables through an environment. The closest equivalent in Nested Reform Prolog is the set of shared arguments to the generated parallel predicate.
Reference: [10] <author> M. Hermenegildo, M. Carro, </author> <title> Relating data-parallelism and (And-)parallelism in logic programs, </title> <journal> Computer Languages Journal, </journal> <note> to appear. </note>
Reference-contexts: Related work Hermenegildo and Carro propose transforming Reform Prolog into &-Prolog <ref> [10] </ref>. Rather than generating parallel loop code, they use source-to-source transformation to express various strategies for task creation, including unfolding by k (to provide k independent loop bodies) and using a split/4 predicate to separating the list traversal from task creation, task scheduling and task execution.
Reference: [11] <author> T. Lindgren, J. Bevemyr, H. Millroth, </author> <title> Compiler optimizations in Reform Prolog: experiments on the KSR-1 multiprocessor, </title> <booktitle> in Proc. </booktitle> <address> EURO-PAR'95. </address>
Reference-contexts: 1. Introduction The first implementation of Reform Prolog <ref> [14, 4, 3, 13, 11] </ref> featured only parallel execution of a single parallel loop at a time: parallel computations could not themselves start parallel loops. While this lead to a simple and efficient execution model, it also restricted the programs that could be parallelized. <p> The compiler inserts suspension and locking operations to ensure that these conditions hold. Experiments indicate that the compiler rarely classifies local data as robust or fragile, and that we can expect high speedups (using emulated SICStus Prolog as the reference system) for realistic programs fitting the flat execution model <ref> [11] </ref>. 4 1996 Compulog Net Meeting on Parallelism and Implementation Technology 3. Nested recursion-parallelism The main drawback of the previous execution model is that it does not allow nested parallel loops. In this section, we show how to extend the flat execution model to encompass nested parallel execution.
Reference: [12] <author> T. Lindgren, </author> <title> The compilation and execution of recursion-parallel Prolog on shared-memory multiprocessors, </title> <booktitle> Licentiate of Philosophy Thesis, Uppsala Theses in Computer Science 18/93, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: Further details, e.g., on handling predicates with side-effects, can be found in Refs. <ref> [2, 12] </ref>. By making the first restriction, we ensure that parallel and sequential execution yields the same answer. <p> Future work This paper has laid the groundwork for how to extend Reform Prolog to run nested parallel computations. At the time of writing, a source-to-source compiler translates control-parallel code into recursion-parallel code and generates code for recurrences. (The latter an extension of the scheme described in Ref. <ref> [12] </ref>.) The extensions to the compiler to allow nested recursion-parallelism (in particular the locality analysis) have not been implemented, nor has the runtime system necessary to support it. Future work is to implement and evaluate these systems. 7.
Reference: [13] <author> H. Millroth, SLDR-Resolution: </author> <title> parallelizing structural recursion in logic programs, </title> <journal> Journal of Logic Programming. </journal>
Reference-contexts: 1. Introduction The first implementation of Reform Prolog <ref> [14, 4, 3, 13, 11] </ref> featured only parallel execution of a single parallel loop at a time: parallel computations could not themselves start parallel loops. While this lead to a simple and efficient execution model, it also restricted the programs that could be parallelized.
Reference: [14] <author> H. Millroth, </author> <title> Reforming compilation of logic programs, </title> <booktitle> in Proc. </booktitle> <address> ILPS'91. </address>
Reference-contexts: 1. Introduction The first implementation of Reform Prolog <ref> [14, 4, 3, 13, 11] </ref> featured only parallel execution of a single parallel loop at a time: parallel computations could not themselves start parallel loops. While this lead to a simple and efficient execution model, it also restricted the programs that could be parallelized. <p> p (Xs), &lt;right body&gt; Consider a call to a list recursive predicate. p ([T1,...,Tn],...) We can unfold the call into the following, equivalent query. &lt;left body 1&gt;,...,&lt;left body n&gt;, p ([],...), &lt;right body n&gt;,...,&lt;right body 1&gt; 1 2 1996 Compulog Net Meeting on Parallelism and Implementation Technology In his thesis <ref> [15, 14] </ref>, Millroth developed a method for compiling this unfolding process and subsequent execution into parallel loop code, yielding a schematic form shown below. p/n: compute the length of the input list as n; build all instances of left and right body as a collection of vectors; /* each instance accesses
Reference: [15] <author> H. Millroth, </author> <title> Reforming the compilation of logic programs, </title> <type> Ph.D. Thesis, </type> <institution> Uppsala Theses in Computer Science 10, </institution> <year> 1991. </year> <booktitle> 10 1996 Compulog Net Meeting on Parallelism and Implementation Technology </booktitle>
Reference-contexts: p (Xs), &lt;right body&gt; Consider a call to a list recursive predicate. p ([T1,...,Tn],...) We can unfold the call into the following, equivalent query. &lt;left body 1&gt;,...,&lt;left body n&gt;, p ([],...), &lt;right body n&gt;,...,&lt;right body 1&gt; 1 2 1996 Compulog Net Meeting on Parallelism and Implementation Technology In his thesis <ref> [15, 14] </ref>, Millroth developed a method for compiling this unfolding process and subsequent execution into parallel loop code, yielding a schematic form shown below. p/n: compute the length of the input list as n; build all instances of left and right body as a collection of vectors; /* each instance accesses
Reference: [16] <author> L. Naish, </author> <title> Parallelizing NU-Prolog, </title> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: In particular, we allow A and B to share variables and to communicate using these variables (e.g., producer/consumer parallelism). Nested Reform Prolog retains recursion-parallel execution and sequential conjunction, and tolerates local nondeterminism. We could thus view it as an extension of Parallel NU-Prolog <ref> [16] </ref>. 4.1. Transformation algorithm In order to reuse the machinery of nested recursion-parallel execution, we transform a parallel conjunction (B 1 &B 2 & : : : &B n ) into a recursion parallel predicate pfl/k as follows. 1.
Reference: [17] <author> V. Santos Costa, D.H.D. Warren, R. Yang, </author> <title> The Andorra-I engine: a parallel implementation of the basic Andorra model, </title> <booktitle> in Proc. </booktitle> <address> ICLP'91. </address>
Reference: [18] <author> K. Shen, </author> <title> Studies of And-Or Parallelism, </title> <type> Ph.D. Thesis, </type> <institution> Cambridge University, rev. </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: By making the first restriction, we ensure that parallel and sequential execution yields the same answer. By making the second and third restrictions, we can guarantee that no costly `rollback-on-failure' operations need to be supported. (See for instance Shen's DDAS for a design where such rollbacks are supported <ref> [19, 18] </ref>.) The final restriction means the runtime system can be kept simple and efficient. All workers share a single parallel loop, which makes scheduling and leftmostness checking straightforward. Obviously, nested parallel execution is not allowed, so we call this the flat execution model. 2.2.
Reference: [19] <author> K. Shen, </author> <title> Exploiting dependent and-parallelism in Prolog: the dynamic dependent and-parallel scheme (DDAS), </title> <booktitle> in Proc. </booktitle> <address> JICSLP'92. </address>
Reference-contexts: By making the first restriction, we ensure that parallel and sequential execution yields the same answer. By making the second and third restrictions, we can guarantee that no costly `rollback-on-failure' operations need to be supported. (See for instance Shen's DDAS for a design where such rollbacks are supported <ref> [19, 18] </ref>.) The final restriction means the runtime system can be kept simple and efficient. All workers share a single parallel loop, which makes scheduling and leftmostness checking straightforward. Obviously, nested parallel execution is not allowed, so we call this the flat execution model. 2.2.
Reference: [20] <editor> S.- A. Tarnlund, </editor> <booktitle> Logic information processing, TRITA-IBADB 1034, </booktitle> <institution> Department of Information Processing and Computer Science, Royal Institute of Technology and University of Stockholm, </institution> <year> 1975. </year>
Reference-contexts: The main means are to add low-level support for traversing lists, creating vectors and tasks, while retaining the standard &-Prolog engine. The authors do not consider support for dependent and-parallelism. Unfolding to increase parallelism was also proposed by Tarnlund in his thesis <ref> [20] </ref>, and has been a mainstay of fine-grained parallel compilers for Fortran or C for many years. Implementations such as &-Prolog [9] and &ACE [6] access the shared variables through an environment. The closest equivalent in Nested Reform Prolog is the set of shared arguments to the generated parallel predicate.
References-found: 20

