URL: http://www.research.digital.com/SRC/tla/src137.ps.Z
Refering-URL: http://www.research.digital.com/SRC/tla/papers.html
Root-URL: http://www.research.digital.com
Title: Proving Possibility Properties  
Author: Leslie Lamport 
Date: July 4, 1995  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martn Abadi and Leslie Lamport. </author> <title> An old-fashioned recipe for real time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1543-1571, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: For M = N , Proposition 3 is a special case of Proposition 2 of <ref> [1] </ref>. A formula of the form Init ^ 2 [N ] v ^ F is called machine closed [1] if its closure equals Init ^ 2 [N ] v . <p> For M = N , Proposition 3 is a special case of Proposition 2 of <ref> [1] </ref>. A formula of the form Init ^ 2 [N ] v ^ F is called machine closed [1] if its closure equals Init ^ 2 [N ] v . <p> For real time specifications, an important possibility property is nonZenoness, which asserts that it is always possible for time to advance. The relation between possibility and closure was first observed for nonZenoness in <ref> [1] </ref>. Our method generalizes a method described there for proving nonZenoness. Propositions 1 and 2 are independent of TLA. They can be used for proving possibility properties in any trace-based specification method for which closures can be computed.
Reference: [2] <author> Bowen Alpern and Fred B. Schneider. </author> <title> Recognizing safety and liveness. </title> <journal> Distributed Computing, </journal> <volume> 2(3) </volume> <pages> 117-126, </pages> <year> 1987. </year>
Reference-contexts: They can be used for proving possibility properties in any trace-based specification method for which closures can be computed. It is easy to compute closures when specifications are written as certain kinds of transition systems. For example, the closure of (the temporal-logic formula corresponding to) a Buchi automaton <ref> [2] </ref> with a strongly connected state graph is the automaton obtained by making every state an accepting state. The closure of a specification written as a state transition system [5, 9] is obtained by removing the fairness properties, if those properties are expressed as fairness conditions on transitions.
Reference: [3] <author> Krzysztof R. Apt. </author> <title> Ten years of Hoare's logic: A survey|part one. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(4) </volume> <pages> 431-483, </pages> <month> October </month> <year> 1981. </year>
Reference-contexts: Proposition 4 is essentially the TLA version of the classical completeness results for Hoare logics <ref> [3] </ref>. We use it to show completeness of our method for proving possibility properties: Proposition 5 If 1. Every valid expressible action formula is provable. 2.
Reference: [4] <author> E. Allen Emerson. </author> <title> Temporal and modal logic. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B, chapter 16, </booktitle> <pages> pages 995-1072. </pages> <publisher> Elsevier and MIT Press, </publisher> <address> Amsterdam and Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: We first describe the general approach, which applies to any formalism with a linear-time semantics. We then show how the method is used with TLA, the Temporal Logic of Actions [8], and prove a relative completeness result. Possibility properties pose no problem in formalisms based on branching-time semantics <ref> [4] </ref>. However, it is impossible to assert in linear-time temporal logic that something is always possible [6].
Reference: [5] <author> Simon S. Lam and A. Udaya Shankar. </author> <title> Specifying modules to satisfy interfaces: A state transition system approach. </title> <journal> Distributed Computing, </journal> <volume> 6(1) </volume> <pages> 39-63, </pages> <year> 1992. </year>
Reference-contexts: For example, the closure of (the temporal-logic formula corresponding to) a Buchi automaton [2] with a strongly connected state graph is the automaton obtained by making every state an accepting state. The closure of a specification written as a state transition system <ref> [5, 9] </ref> is obtained by removing the fairness properties, if those properties are expressed as fairness conditions on transitions. We do not know of any practical method for computing the closure of arbitrary temporal-logic formulas, or of transition systems with arbitrary temporal formulas as fairness requirements.
Reference: [6] <author> Leslie Lamport. </author> <title> `Sometime' is sometimes `not never': A tutorial on the temporal logic of programs. </title> <booktitle> In Proceedings of the Seventh Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-185. </pages> <publisher> ACM SIGACT-SIGPLAN, </publisher> <month> January </month> <year> 1980. </year>
Reference-contexts: We then show how the method is used with TLA, the Temporal Logic of Actions [8], and prove a relative completeness result. Possibility properties pose no problem in formalisms based on branching-time semantics [4]. However, it is impossible to assert in linear-time temporal logic that something is always possible <ref> [6] </ref>. It is therefore not obvious how to prove possibility properties in the formalisms that we consider, which are based on linear-time semantics. 2 Possibility and Closure 2.1 Closure and Safety We begin by reviewing some basic concepts of linear-time temporal logic [10]. <p> The properties are of the form always possibly P , meaning that at all times during an execution of the system, it is possible for P eventually to become true. In linear-time temporal logic, it is impossible to write a formula whose meaning is always possibly P <ref> [6] </ref>. However, for any particular system, we 2 can write a formula asserting that always possibly P holds for behaviors of that system. More precisely, we can define a formula P (P ) such that always possibly P holds for the system specified by iff P (P ) is valid.
Reference: [7] <author> Leslie Lamport. </author> <title> win and sin: Predicate transformers for concur-rency. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 396-428, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: We assume that expressible terms and formulas are closed under the operations of first-order logic (conjunction, quantification, etc.), priming, and forming tuples. Relative completeness results for programming logics are generally based on some form of predicate transformer analogous to the sin operator of <ref> [7] </ref>. For any action A and state predicate P , the state predicate sin (A; P ) can be defined by [[sin (A; P )]](s) = (6) for all states s. We first show completeness of the TLA rules for proving invariance properties.
Reference: [8] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: This seems to be the most useful class of possibility properties. We first describe the general approach, which applies to any formalism with a linear-time semantics. We then show how the method is used with TLA, the Temporal Logic of Actions <ref> [8] </ref>, and prove a relative completeness result. Possibility properties pose no problem in formalisms based on branching-time semantics [4]. However, it is impossible to assert in linear-time temporal logic that something is always possible [6]. <p> One can write TLA specifications in a way that makes computing the closure easy. We now give a thumbnail review of TLA; see <ref> [8] </ref> for a real explanation of the logic. In TLA, behaviors are infinite sequences of states, where a state is an assignment of variables to values. We let S be the set of all states. Formulas are built from actions, Boolean operators, and the temporal operator 2. <p> = 17), we take M = _ ^ ((x &gt; 0) ^ (x 0 = x 1)) _ ((x &lt; 0) ^ (x 0 = x + 1)) _ ^ x = x 0 = 0 To prove (4), we use the TLA rules from Figure 5 (page 888) of <ref> [8] </ref>. We now show that this proof method is complete relative to non-temporal reasoning about actions. This means that if all the necessary valid action 5 formulas can be proved, then every valid formula P (P ) is provable. <p> This means that if all the necessary valid action 5 formulas can be proved, then every valid formula P (P ) is provable. We write ` to mean that formula is provable from Propositions 1, 2, and 3 and the rules in <ref> [8] </ref>. Our results assume only that valid actions in some class of expressible formulas are provable. We assume that expressible terms and formulas are closed under the operations of first-order logic (conjunction, quantification, etc.), priming, and forming tuples.
Reference: [9] <author> Nancy Lynch and Mark Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the Sixth Symposium on the Principles of Distributed Computing, </booktitle> <pages> pages 137-151. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1987. </year>
Reference-contexts: For example, the closure of (the temporal-logic formula corresponding to) a Buchi automaton [2] with a strongly connected state graph is the automaton obtained by making every state an accepting state. The closure of a specification written as a state transition system <ref> [5, 9] </ref> is obtained by removing the fairness properties, if those properties are expressed as fairness conditions on transitions. We do not know of any practical method for computing the closure of arbitrary temporal-logic formulas, or of transition systems with arbitrary temporal formulas as fairness requirements.
Reference: [10] <author> Zohar Manna and Amir Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year> <month> 8 </month>
Reference-contexts: It is therefore not obvious how to prove possibility properties in the formalisms that we consider, which are based on linear-time semantics. 2 Possibility and Closure 2.1 Closure and Safety We begin by reviewing some basic concepts of linear-time temporal logic <ref> [10] </ref>. A behavior is an infinite sequence of states or of events|for now, it doesn't matter which. The meaning [[]] of a temporal-logic formula is a Boolean-valued function on behaviors. We say that the behavior satisfies iff (if and only if) [[]]() equals true. <p> We do not know of any practical method for computing the closure of arbitrary temporal-logic formulas, or of transition systems with arbitrary temporal formulas as fairness requirements. We do not know how to prove possibility properties for traditional temporal-logic specifications <ref> [10] </ref>. Acknowledgments Martn Abadi and Stephan Merz pointed out mistakes in the text of an earlier version. Fred Schneider suggested some improvements to the presentation. 7
References-found: 10

