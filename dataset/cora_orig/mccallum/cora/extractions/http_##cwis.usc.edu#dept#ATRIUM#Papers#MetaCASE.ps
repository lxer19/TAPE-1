URL: http://cwis.usc.edu/dept/ATRIUM/Papers/MetaCASE.ps
Refering-URL: http://cwis.usc.edu/dept/ATRIUM/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: META-ENVIRONMENTS FOR SOFTWARE PRODUCTION  
Author: ANTHONY S. KARRER WALT SCACCHI 
Date: December 1994  
Address: Los Angeles, CA 90045-2699 USA  Los Angeles, CA 90089-1421, USA  
Affiliation: Computer Science Department, Loyola-Marymount University  Information and Operations Management Department and Center for Software Engineering University of Southern California  
Abstract: Researchers who create software production environments face considerable problems. Software production environments are large systems that are costly to develop. Furthermore, software production environments which support particular software engineering methods may not be applicable to a large number of software production projects. These conditions have formed a trend towards research into ways which will lessen the cost of developing software production environments. In particular, the trend has been towards the construction of meta-environments from which specific software production environments can be created. In this paper, we attempt to categorize more than 60 meta-environment efforts. For each of the categories, we review research efforts which illustrate different approaches within that category. We conclude by presenting an emerging common thread of requirements which links this field together.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. W. Adams, M. Honda, and T.C. Miller. </author> <title> Object management in a CASE environment. </title> <booktitle> In 11th Int. Conf. Software Engineering, </booktitle> <pages> pages 154-162, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Monitoring of process execution is also available. PCTE has defined a set of user-interface management primitives, as well as extensions to support production of real-time software through the PCTE+ and PACT versions of PCTE. The Sun Network Software Environment (NSE) <ref> [1] </ref> is a network-based object manager and tool integration facility. NSE is primarily a Unix environment with additional support for object management, configuration management, version management, distribution, environment management, 4 target generation, and environment front-ends.
Reference: [2] <author> R. Adomeit, W. Dieters, B. Holtkamp, F. Schulke, and H. Weber. K/2r: </author> <title> a kernel for the Eureka Software Factory support environment. </title> <booktitle> In Proc. 2nd. Int. Conf. Systems Integration, </booktitle> <pages> pages 325-336. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: The EUREKA Software Factory (ESF) [28] is a large-scale pan-European research effort aiming at the development of an integration framework for a meta-environment that can accomodate the interoperation of various tools and the interactions of people working together with these tools according to a process meta-model <ref> [2] </ref>. The heart of the ESF architecture is a Software Bus (SWB), which is an abstract communication channel hiding distribution and supporting the exchange of data and control information using abstract data type interfaces. User-interaction components (UIC) and service components (SC) communicate across the SWB. <p> UIC, which have no persistent data, communicate with the user and make requests on service components across the SWB. SC may not have a user-interface. One UIC and one SC taken together are essentially a tool in current environments. The ESF kernel, K/2r <ref> [2] </ref>, is not tied to the use of a central OMS as the basis of integration. 5 Rather, the ESF project uses process models as the basis of tool integration, although different schemes [19, 30] and modeling formalisms [21, 27] are being investigated.
Reference: [3] <author> V. Ambriola, P. Ciancarini, and C. Montangero. </author> <title> Software process enactment in OIKOS. </title> <booktitle> In Proc. Fourth ACM SIGSOFT Symp. Software Development Environments, </booktitle> <pages> pages 183-192, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: However, the SMART environment [31] can semi-automatically generate SynerVision process program code via transformations on Articulator-based software process models [57], while Process WEAVER allows modeled process states to be attributed with Unix shell commands, which can subsequently be executed under user direction. Last, both OIKOS <ref> [3] </ref> and OPM [85] propose object-oriented approaches to process programming. The idea in these two efforts is to show how object-oriented views of process programming and software development environments can be united into a single view in which both the process model and programming environment can be dynamically modified.
Reference: [4] <author> R. Balzer. </author> <title> A 15 year perspective on automatic programming. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 11(11) </volume> <pages> 1257-1267, </pages> <month> November </month> <year> 1985. </year>
Reference-contexts: DRACO, Popart, KIDS, and Centaur are designed to support the development of domain language definitions using either (a) patterns, transformations, rules, or annotations for DRACO, Popart, and KIDS, or (b) algebraic and syntactic specification formalisms for Centaur. In addition, Popart is used in conjunction with Common Lisp Framework <ref> [4] </ref> and a generic process engine developed at USC/ISI [5], which accomodates the generation of rule-based programming and transformational implementation environments. The DRACO and KIDS environments provide similar capabilities, although they lack integration with a process engine. <p> Forest [35] has extended the Field communication mechanism with an additional decision mechanism based on policies. Policies are rules that determine how and when tools are invoked. This approach represents a hybrid between process modeling mechanisms and frameworks. The Common Lisp Framework (CLF) <ref> [4] </ref> is an incremental integration, development, and evolution environment. Tools and applications are programs written in an extension of Common Lisp called AP5. AP5 provides a persistent virtual database of relations, objects, and rules. The rules connect tools through triggering upon detection of changes to data or calling procedures.
Reference: [5] <author> R. Balzer and K. Narayanaswamy. </author> <title> Mechanisms for generic process support. </title> <booktitle> In Proc. First ACM SIGSOFT Symp. Foundations Software Engineering, </booktitle> <pages> pages 21-32. </pages> <booktitle> ACM Software Engineering Notes, </booktitle> <volume> Vol. 18(5), </volume> <month> December </month> <year> 1993. </year>
Reference-contexts: In addition, Popart is used in conjunction with Common Lisp Framework [4] and a generic process engine developed at USC/ISI <ref> [5] </ref>, which accomodates the generation of rule-based programming and transformational implementation environments. The DRACO and KIDS environments provide similar capabilities, although they lack integration with a process engine. However, DRACO also supports the integration and composition of reusable components or tools, as described later. <p> Finally, the Articulator has similarly been integrated with the generic process engine developed at USC/ISI <ref> [5] </ref>, 9 which supports the refinement of generic process descriptions into concrete instantiations during its enactment. Thus, the Articulator environment successfully demonstrates the power of software process meta-models as a basis for integrating and interoperating independently developed tools within generated process-driven environments.
Reference: [6] <author> S.C. Bandinelli, A. Fuggetta, and C. Ghezzi. </author> <title> Software process model evolution in the SPADE environment. </title> <journal> IEEE Trans. Software Engineering, </journal> 19(12) 1128-1145, 1993. 
Reference-contexts: Thus, the Articulator environment successfully demonstrates the power of software process meta-models as a basis for integrating and interoperating independently developed tools within generated process-driven environments. Last, the SPADE environment <ref> [6] </ref> is similar in scope to the Articulator in that it supports the design, analysis, and enactment of software process models. Its process representation is based on extended Petri-nets, and the environment includes functional mechanisms for accommodating dynamic changes to a process description during its enactment.
Reference: [7] <author> V.R. Basili and H.D. Rombach. </author> <title> The TAME project: Towards improvement-oriented software environments. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 14(6) </volume> <pages> 758-773, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Many software engineering methods, such as structured design and object-oriented analysis, have emerged to ease these problems. Recently, there has been considerable attention paid to the application of these methods through software production environments in order to evaluate the effectiveness of each method <ref> [7, 43, 67] </ref>. A software production environment (SPE) is a system consisting of a software infrastructure providing a common operating environment for software tools, a set of tools, and an interface which provides users with access to the environment's capabilities.
Reference: [8] <author> D.S. Batory, J.R. Bennett, et al. </author> <title> GENESIS: An extensible database management system. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 14(11) </volume> <pages> 1711-1731, </pages> <year> 1988. </year>
Reference-contexts: A single reusable component corresponds directly to each object and operation in the domain language. Given the domain of software production environment construction, DRACO effectively provides a tool composition language based on a module interconnection language paradigm. GENESIS (from UT Austin) <ref> [8] </ref> is similar in purpose to DRACO, but specialized to a domain for constructing and generating of special-purpose database management systems. Toolpack [67], and later Odin [17], support the construction of an environment based on the 13 specification of software objects, tools, and relationships between objects and tools.
Reference: [9] <author> H.R. Beyer, K. Chapman, and C. Nolan. </author> <title> The ATIS Reference Model. </title> <type> draft, </type> <month> June </month> <year> 1990. </year>
Reference-contexts: The other path is to build technology which can use tools developed prior to or outside of the standards. In the remainder of this section, we will consider examples of both approaches. 2.5.1 Standards A Tool Integration Standard (ATIS) <ref> [9] </ref> and its more recent name, a Component Integration Standard (CIS), is a proposal for an object-oriented approach to the integration of tools that provides a set of interfaces that support schema-driven dispatching of behavior.
Reference: [10] <author> B.W. Boehm. </author> <title> Software engineering environments in the United States (Plenary Talk). </title> <booktitle> In Fourth ACM SIGSOFT Symp. on Software Development Environments, </booktitle> <month> December </month> <year> 1990. </year>
Reference-contexts: Worse yet, each software production project may have different requirements for an SPE <ref> [10] </ref>. These factors imply that in order to research the requirements for SPEs and to support the requirements of individual projects we must reduce the cost of creating SPEs. Because SPEs are themselves software products, we can consider the software production process used to construct SPEs.
Reference: [11] <author> G. Boloix, P.G. Sorenson, and J.P. Tremblay. </author> <title> On transformations using a metasystem approach to software development. </title> <journal> Software Engineering J., </journal> <volume> 7 </volume> <pages> 425-437, </pages> <year> 1992. </year>
Reference-contexts: However, the META/GA user, the environment constructor, is able to specify the type of information which will be processed. This customizable environment attempts to help standardize the type of information and leave the life-cycle as general as possible. The Metaview project <ref> [11, 82] </ref> takes an approach that is a hybrid of framework approaches and customizable environments. The models provided are based on an ERA model extended with constraints, transformations, and a graphical interaction model.
Reference: [12] <author> R. F. Bruynooghe, J. Parker, and J.S. </author> <title> Rowles. PSS: A system for process enactment. </title> <booktitle> In Proc. First Int. Conf. Software Process, </booktitle> <pages> pages 128-141, </pages> <year> 1991. </year>
Reference-contexts: Environment construction using these systems consists of specifying the production rules for all of the activities or events which the environment should support. PRISM [56], IPSE 2.5 [91], and its successor, PSS <ref> [12] </ref>, provide process meta-models similar to Marvel and GENESIS. However, these efforts suggest a particular execution of the process models, which provides the environment to the user. In these environments, a process model execution facility serves as the means of invoking tools and presenting choices to environment users.
Reference: [13] <author> M. Cagan. </author> <title> The HP SoftBench environment: an architecture for a new generation of software tools. </title> <journal> Hewlett-Packard J., </journal> <pages> pages 36-47, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The resulting composite environment is called SMART [31]. SMART supports the modeling, analysis, enactment, measurement, and improvement of software processes utilizing encapsulated CASE tools that communicate messages and tool invocations across the SoftBench BMS <ref> [13] </ref>, and that manipulate data stored in networked repositories. Since SMART can configure commercially available CASE tools, and as most Unix-based CASE tools have SoftBench encapsulations, then the number and configuration of process-based CASE environments that can be generated using SMART is very large. <p> Environments integrated through the use of Odin can be thought of as collections of tools which are satellites around a large structured repository of software data. Both Toolpack and Odin are ancestral predecessors to the Arcadia environment described earlier. The Hewlett-Packard SoftBench product <ref> [13] </ref> is a tool integration framework comprised of several components including the Broadcast Message Server (BMS) that functions as a software bus, a Motif-based user-interface, the Encapsulator [20], and some integrated CASE tools.
Reference: [14] <author> S.C. Choi and W. Scacchi. </author> <title> Assuring the correctness of configured software descriptions. </title> <booktitle> Proc. 2nd. Int. Work. Software Configuration Management, ACM Software Engineering Notes, </booktitle> <volume> 17(7) </volume> <pages> 67-76, </pages> <year> 1989. </year>
Reference-contexts: However, the primary tools in a SOFTMAN environment are customizable structure editors interfaced to a constraint-based OMS. The combination of the tools and the object repository can then track and verify the correctness attributes of objects that have been created or modified <ref> [14] </ref>. ISHYS [33] provides an interface to a hypertext-based information storage structure and to a structured documentation process. ISHYS supports the specification of the type, attributes, and composition of hypertext-based life-cycle documents based on the DIF software hypertext system [34].
Reference: [15] <author> S.C. Choi and W. Scacchi. </author> <title> Extracting and restructuring the design of large systems. </title> <journal> IEEE Software, </journal> <volume> 7(1) </volume> <pages> 66-73, </pages> <month> January </month> <year> 1990. </year> <month> 20 </month>
Reference-contexts: The component builder is responsible for creating this technology, as well as the other software components which may be incorporated into them. This may entail selecting from existing components available within some reusable component repository, or extracting (and restructuring if necessary) candidate components from existing software systems <ref> [15, 59] </ref>. Note that there can be many component builders building products which are completely incompatible. The fact that they assume the same role does not imply that they work together.
Reference: [16] <author> S.C. Choi and W. Scacchi. SOFTMAN: </author> <title> An environment for forward and reverse computer--aided software engineering. </title> <journal> Information and Software Technology, </journal> <volume> 33(9) </volume> <pages> 664-674, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: The DSF infrastructure provides a distributed hypertext (DHT) framework to integrate heterogeneous software object repositories (e.g., those with different data models) [63] with forward and reverse software engineering tools <ref> [16] </ref>, graph-based editors and user interfaces [49], process-driven user interfaces with partially order tool invocation sequences [59], and a knowledge-based process modeling and simulation environment [58]. <p> This specification is then combined with the core capabilities to form an environment. This approach is very similar to the approach used in most tool generators, such as those used for parser generators [92], language-directed editor generators <ref> [16, 64, 76] </ref>, or extensible graph editors [47, 69, 79]. Customizable environments differ from frameworks in that they trade ease of instantiation for less generality. In other words, customizable environments will support a model which can be used to describe only a small portion of the entire environment. <p> This syntax tree can be annotated by means of other abstract syntax trees in specialized languages. By allowing arbitrary annotations of nodes in the syntax tree, Mentor allows the extension of the environment. GANDALF [64], the Synthesizer Generator [76], and SOFTMAN <ref> [16] </ref> provide customizable structure/text editors which allow an environment to be constructed as a suite of tightly integrated editors. Editors are customized through the specification of (a) the grammars of the languages which they edit, and (b) the attributes or action routines which support incremental semantic checking. <p> However, DRACO also supports the integration and composition of reusable components or tools, as described later. Another approach to customizable environments is to provide a model which supports the specification of the objects to be manipulated during a software life-cycle process. The SOFTMAN environment <ref> [16] </ref> provides core capabilities which enforce a particular model of incremental software development and verification across life-cycle activity boundaries. It allows customization based on the specification of the formal attributes of life-cycle objects and specification of tools which operate on these objects. <p> Finally, TGE, VSF, and GEDL have specification-level interfaces which allow them or their derived editors to be integrated with one or more repositories and environments, such as SOFTMAN's use of TGE-based graph editors <ref> [16, 77] </ref>. Subsequently, this provides another dimension for the extension of resulting meta-environments. Overall, the primary advantage of customizable environments is the speed and relative ease of constructing high functionality environments. However, most customizable environments have lessened the burden of environment construction by adopting a particular approach to software development. <p> When the process models specify tool bindings to process pre- or postconditions, data objects, and object repositories, then process-driven software environments can be automatically produced. In one study [59], the SOFTMAN environment <ref> [16] </ref> was used as the base environment, and a software life-cycle process model that guides a user in their invocation of SOFTMAN tools was developed using the Articulator. The SOFTMAN process model was then transformed and loaded into the PBI process interpreter.
Reference: [17] <author> G. Clemm and L. Osterweil. </author> <title> A mechanism for environment integration. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 1-25, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: GENESIS (from UT Austin) [8] is similar in purpose to DRACO, but specialized to a domain for constructing and generating of special-purpose database management systems. Toolpack [67], and later Odin <ref> [17] </ref>, support the construction of an environment based on the 13 specification of software objects, tools, and relationships between objects and tools. Environments integrated through the use of Odin can be thought of as collections of tools which are satellites around a large structured repository of software data.
Reference: [18] <institution> Common ADA Programming Support Environment (APSE) Interface Set. </institution> <note> Introduction to CAIS, </note> <month> September </month> <year> 1989. MIL-STD-1938A. </year>
Reference-contexts: Gaia [90] embodies an approach similar to the Software Backplane by providing an object-oriented OMS as its cornerstone. It lacks some of the integration techniques present in the Software Backplane. It also lacks a plan for using object-oriented technology to instantiate an environment. CAIS-A <ref> [60, 18, 71] </ref>, the latest version of CAIS, is defined in the military standard report MIL-STD-1838A, under the control of the Ada Joint Program Office (AJPO) within the U.S. Department of Defense. CAIS-A is a set of Ada interfaces which are designed to act like a high-level virtual operating system.
Reference: [19] <author> J. Cramer, H. Hunnekens, W. Schafer, and S. Wolf. </author> <title> A process-oriented approach to the reuse of software components. </title> <type> Technical Report 43, </type> <institution> Dortmund University, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: The ESF kernel, K/2r [2], is not tied to the use of a central OMS as the basis of integration. 5 Rather, the ESF project uses process models as the basis of tool integration, although different schemes <ref> [19, 30] </ref> and modeling formalisms [21, 27] are being investigated. In this way, the ESF and DSF projects share many common goals, although their approaches differ. Each of these environment frameworks provides services which are needed in virtually all software production environments.
Reference: [20] <author> H. Davidson. Encapsulator: </author> <title> The plug-in Compatibility tool for SoftBench. SoftBench Technical Note Series SESD-89-11 Revision 1.1, </title> <institution> Hewlett-Packard, Software Engineering Systems Division, 3404 E. </institution> <address> Harmony Road, Fort Collins, Colorado 80525, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Both Toolpack and Odin are ancestral predecessors to the Arcadia environment described earlier. The Hewlett-Packard SoftBench product [13] is a tool integration framework comprised of several components including the Broadcast Message Server (BMS) that functions as a software bus, a Motif-based user-interface, the Encapsulator <ref> [20] </ref>, and some integrated CASE tools. In the HP integration model, each tool makes changes to global information and informs other tools about its actions via the BMS. The BMS uses a broadcast paradigm via the software bus which is different from the point-to-point paradigm offered by object-oriented systems. <p> The broadcast nature of the BMS communication allows the set of tools managed by a BMS and interested in a particular message to be extended without requiring any change in the tools that send the messages. The Encapsulator <ref> [20] </ref> provides a means of integrating tools into the HP SoftBench user-interface and BMS. The encapsulation consists of the Encapsulation Description Language (EDL) which describes a user-interface and corresponding communication across the BMS.
Reference: [21] <author> W. Dieters and V. Gruhn. </author> <title> Managing software processes in the environment MELMAC. </title> <booktitle> In Proc. Fourth ACM SIGSOFT Symp. Software Development Environments, </booktitle> <pages> pages 193-205, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: The ESF kernel, K/2r [2], is not tied to the use of a central OMS as the basis of integration. 5 Rather, the ESF project uses process models as the basis of tool integration, although different schemes [19, 30] and modeling formalisms <ref> [21, 27] </ref> are being investigated. In this way, the ESF and DSF projects share many common goals, although their approaches differ. Each of these environment frameworks provides services which are needed in virtually all software production environments. Access to an implementation of these services assists environment construction. <p> However, these efforts suggest a particular execution of the process models, which provides the environment to the user. In these environments, a process model execution facility serves as the means of invoking tools and presenting choices to environment users. MELMAC <ref> [21] </ref> is a software process management environment based on the execution of high-level Petri-net representations of software process models [26].
Reference: [22] <author> V. Donzeau-Gouge et al. </author> <title> Programming Environments Based on Structured Editors: </title> <journal> the Mentor Experience, </journal> <pages> pages 128-140. </pages> <publisher> McGraw Hill Book Co., </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: These customizable environments provide a construction model which can be used to describe the grammars for the languages which will be manipulated in the environment. The fixed part of the environment is the process of using a series of editors. For example, the Mentor programming environment <ref> [22] </ref> is founded on an abstract syntax tree representation of the program as the common information base. This syntax tree can be annotated by means of other abstract syntax trees in specialized languages. By allowing arbitrary annotations of nodes in the syntax tree, Mentor allows the extension of the environment.
Reference: [23] <author> A. Earl. </author> <title> A Reference Model for Computer Assisted Software Engineering Environment Frameworks. </title> <institution> Hewlett-Packard Laboratories, </institution> <address> Fort Collins, CO. USA, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: Much of this work has been done by creating reference models including the Conceptual Environment Architecture Reference Model (CEARM) [70], the ECMA Reference Model <ref> [23] </ref>, and the NIST Reference Model [94]. [48] used one of these reference models to survey current environment framework research. This survey showed the usefulness of a reference model as a conceptual framework for comparing the capabilities of frameworks. Much of this section is derived from that study. <p> Much of this section is derived from that study. These reference models suggest that frameworks should address Object Management Services, User-Interface Management Services, and Life-cycle Process Management Services (also called Environment Management [70] and Task Management <ref> [23] </ref>). The Object Management Services (OMS) provide for persistent objects and relationships as opposed to files and directories traditionally supported by operating systems. The Life-Cycle Process Management Services (LCPMS) provide a means for enacting change upon the current state of life-cycle objects.
Reference: [24] <author> EIA. </author> <title> CDIF Organization and Procedure Manual, </title> <address> cdif-doc-n2-v1 edition, </address> <month> January </month> <year> 1990. </year> <title> Electronics Industry Association Project No.: </title> <address> EIA/PN-2329, USA. </address>
Reference-contexts: Information is stored at two levels, the definition level and the IRD level. The definition level defines the tables and the functions which manipulate the tables. The IRD level contains the application data. This is analogous to class and instance levels of an object-oriented model. CDIF <ref> [24] </ref> is a definition of a common data transfer format which supports many data models and the transfer of data between CASE tools or frameworks. The CDIF approach is based upon the concept of a Meta-Meta-Model.
Reference: [25] <author> R.J. Ellison. </author> <title> Software development environments: research to practice. </title> <booktitle> In Int. Work. Advanced Programming Environments. </booktitle> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: Meta-environments [53, 55, 80] are emerging as a means of constructing SPEs with significantly more powerful constructs than are generally available in programming languages. Meta-environments have also been called generic environments [36] and environment generators <ref> [25, 31, 95] </ref>. The distinction between these terms is somewhat vague. As such, we will use the term meta-environment to include generic environments, environment generators, and other approaches to environment construction.
Reference: [26] <author> W. Emmerich and V. Gruhn. </author> <title> Software process modeling with FUNSOFT nets. </title> <type> Technical Report Technical Report 47, </type> <institution> University of Dortmund, </institution> <year> 1990. </year>
Reference-contexts: In these environments, a process model execution facility serves as the means of invoking tools and presenting choices to environment users. MELMAC [21] is a software process management environment based on the execution of high-level Petri-net representations of software process models <ref> [26] </ref>. The MELMAC research effort has led to the development of a prototype capable of enacting a software process model on top of a framework similar to the ones described in subsection 2.1.
Reference: [27] <author> W. Emmerich, G. Junkerman, et al. Merlin: </author> <title> knowledge-based process modeling. </title> <booktitle> In Proc. First European Work. Software Process Modeling, </booktitle> <pages> pages 181-186, </pages> <address> Milan, Italy, </address> <year> 1991. </year>
Reference-contexts: The ESF kernel, K/2r [2], is not tied to the use of a central OMS as the basis of integration. 5 Rather, the ESF project uses process models as the basis of tool integration, although different schemes [19, 30] and modeling formalisms <ref> [21, 27] </ref> are being investigated. In this way, the ESF and DSF projects share many common goals, although their approaches differ. Each of these environment frameworks provides services which are needed in virtually all software production environments. Access to an implementation of these services assists environment construction. <p> Instances of a meta-model describe active and inactive objects in an environment. Further, an instance of a meta-model allows the execution of a process-centered environment. The GENESIS (from UC Berkeley) [73], Marvel [46], and Merlin <ref> [27] </ref> environments are among those that provide production rules and rule interpreters as the means for specifying and enacting software processes.
Reference: [28] <institution> ESF Eureka Software Factory. </institution> <note> ESF Technical Reference Guide, </note> <year> 1989. </year>
Reference-contexts: Using these mechanisms and components, it is possible to semi-automatically generate multirole, process-driven software production environments for a hierarchy of concurrent production processes [31, 59]. The EUREKA Software Factory (ESF) <ref> [28] </ref> is a large-scale pan-European research effort aiming at the development of an integration framework for a meta-environment that can accomodate the interoperation of various tools and the interactions of people working together with these tools according to a process meta-model [2].
Reference: [29] <author> C. Fernstrom. </author> <title> Process WEAVER: adding process support to Unix. </title> <booktitle> In Proc. 2nd. Int. Conf. Software Process, </booktitle> <pages> pages 12-26. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: Adele-2 provides 10 support for multiple work environments (i.e., tool, policy, and method configurations) that are coordinated and coupled through an activity manager and a task manager. Coordination and coupling, as well as activity and task specification, are all realized using the Adele-2 language. Process WEAVER <ref> [29] </ref> and SynerVision [42] are commercially available process execution engines. Each provides a process programming language based on the Unix shell command lan-gugage. Their use is similar in scope to Adele-2, but they both lack support for a persistent object store, other than the underlying file system.
Reference: [30] <author> C. Fernstrom and L. Ohlsson. </author> <title> Integration needs in process enacted environments. </title> <booktitle> In Proc. First Int. Conf. Software Process, </booktitle> <pages> pages 142-158, </pages> <year> 1991. </year>
Reference-contexts: The ESF kernel, K/2r [2], is not tied to the use of a central OMS as the basis of integration. 5 Rather, the ESF project uses process models as the basis of tool integration, although different schemes <ref> [19, 30] </ref> and modeling formalisms [21, 27] are being investigated. In this way, the ESF and DSF projects share many common goals, although their approaches differ. Each of these environment frameworks provides services which are needed in virtually all software production environments.
Reference: [31] <author> P.K. Garg, P. Mi, T. Pham, W. Scacchi, and G. Thunquest. </author> <title> The SMART approach to software process engineering. </title> <booktitle> In 16th. Int. Conf. Software Engineering, </booktitle> <pages> pages 341-350. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1994. </year> <month> 21 </month>
Reference-contexts: Meta-environments [53, 55, 80] are emerging as a means of constructing SPEs with significantly more powerful constructs than are generally available in programming languages. Meta-environments have also been called generic environments [36] and environment generators <ref> [25, 31, 95] </ref>. The distinction between these terms is somewhat vague. As such, we will use the term meta-environment to include generic environments, environment generators, and other approaches to environment construction. <p> Using these mechanisms and components, it is possible to semi-automatically generate multirole, process-driven software production environments for a hierarchy of concurrent production processes <ref> [31, 59] </ref>. The EUREKA Software Factory (ESF) [28] is a large-scale pan-European research effort aiming at the development of an integration framework for a meta-environment that can accomodate the interoperation of various tools and the interactions of people working together with these tools according to a process meta-model [2]. <p> The Articulator has also been integrated with the Matisse team programming environment [32] and the SynerVision process execution engine [42] in place of PBI. The resulting composite environment is called SMART <ref> [31] </ref>. SMART supports the modeling, analysis, enactment, measurement, and improvement of software processes utilizing encapsulated CASE tools that communicate messages and tool invocations across the SoftBench BMS [13], and that manipulate data stored in networked repositories. <p> Each provides a process programming language based on the Unix shell command lan-gugage. Their use is similar in scope to Adele-2, but they both lack support for a persistent object store, other than the underlying file system. However, the SMART environment <ref> [31] </ref> can semi-automatically generate SynerVision process program code via transformations on Articulator-based software process models [57], while Process WEAVER allows modeled process states to be attributed with Unix shell commands, which can subsequently be executed under user direction.
Reference: [32] <author> P.K. Garg, T. Pham, et al. Matisse: </author> <title> a knowledge-based team programming environment. </title> <journal> Int. J. Software Engineering and Knowledge Engineering, </journal> <note> to appear, </note> <year> 1994. </year>
Reference-contexts: In this way, we can say that a process integration interpreter and user interface enable knowledge-based process models to guide user invocation of tools within a software production environment, such as PBI-SOFTMAN [59]. The Articulator has also been integrated with the Matisse team programming environment <ref> [32] </ref> and the SynerVision process execution engine [42] in place of PBI. The resulting composite environment is called SMART [31]. <p> This approach is different from the previous approaches in that it primarily addresses the use of a tool integration technology based on the module interconnection language rather than addressing the integration technology itself. Last, the Matisse team programming environment <ref> [32] </ref> builds upon concepts previously demonstrated in the CLF and Odin. Matisse provides a multiuser programming support environment where user functionality and data object representation are managed by an intepreted, rule-based, persistent programming language.
Reference: [33] <author> P.K. Garg and W. Scacchi. ISHYS: </author> <title> Designing an intelligent software hypertext system. </title> <journal> IEEE Expert, </journal> <volume> 4(3) </volume> <pages> 52-63, </pages> <month> Fall </month> <year> 1989. </year>
Reference-contexts: However, the primary tools in a SOFTMAN environment are customizable structure editors interfaced to a constraint-based OMS. The combination of the tools and the object repository can then track and verify the correctness attributes of objects that have been created or modified [14]. ISHYS <ref> [33] </ref> provides an interface to a hypertext-based information storage structure and to a structured documentation process. ISHYS supports the specification of the type, attributes, and composition of hypertext-based life-cycle documents based on the DIF software hypertext system [34].
Reference: [34] <author> P.K. Garg and W. Scacchi. </author> <title> A hypertext system to manage software life-cycle documents. </title> <journal> IEEE Software, </journal> <volume> 7(3) </volume> <pages> 90-99, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: ISHYS [33] provides an interface to a hypertext-based information storage structure and to a structured documentation process. ISHYS supports the specification of the type, attributes, and composition of hypertext-based life-cycle documents based on the DIF software hypertext system <ref> [34] </ref>. It also supports the specification of a process model which describes the production and use of the documents by collaborating agents. The document formats and process model support multiple forms of group-based or team-based interaction and communication structures within a project and support multiple simultaneous projects.
Reference: [35] <author> D. Garlan and E. Ilias. </author> <title> Low-cost, adaptable tool integration policies for integrated environments. </title> <booktitle> In Proc. Fourth ACM SIGSOFT Symp. Software Development Environments, </booktitle> <pages> pages 1-10, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Field has extended the HP Softbench approach by passing all data through the message server rather than relying on a common database. Additionally, Field supplies an editor which provides consistent access to source code in multiple contexts and a set of analysis tools. Forest <ref> [35] </ref> has extended the Field communication mechanism with an additional decision mechanism based on policies. Policies are rules that determine how and when tools are invoked. This approach represents a hybrid between process modeling mechanisms and frameworks.
Reference: [36] <author> J.L. Giavitto, A. Devarenne, G. Rosuel, and Y. Holvoet. </author> <title> Adage: New trends in CASE environments. </title> <booktitle> In Proc. Int. Conf. Systems Development Environments and Factories, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: Meta-environments [53, 55, 80] are emerging as a means of constructing SPEs with significantly more powerful constructs than are generally available in programming languages. Meta-environments have also been called generic environments <ref> [36] </ref> and environment generators [25, 31, 95]. The distinction between these terms is somewhat vague. As such, we will use the term meta-environment to include generic environments, environment generators, and other approaches to environment construction.
Reference: [37] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: We conclude by presenting the common thread which links this field together. 2 Related Research Software engineering environments were initially constructed as monolithic systems, using a programming language as the construction model. Two of the more notable examples of this approach are the programming support environments for Smalltalk <ref> [37] </ref> and Interlisp [88]. Both environments support a single method of software production: interpretive, incremental program development.
Reference: [38] <author> A. V. Goldberg and K. J. Lieberherr. </author> <title> GEM: a generator of environments for metaprogramming. </title> <booktitle> In COMPSAC 85, </booktitle> <pages> pages 86-95, </pages> <year> 1985. </year>
Reference-contexts: This grammar is used to encode process information as well as syntax information. The grammar is used by TRIAD to construct various portions of the environment including a syntax-directed editor. DRACO [62], Popart [92], GEM <ref> [38] </ref>, KIDS [78], and Centaur [53] are generators of grammar-based or notation-based meta-programming environments. A meta-programming environment is an environment which assists in the creation of parsers and related tools which manipulate a particular language.
Reference: [39] <author> A. Goldfine and P. Konig. </author> <title> A technical overview of the information resource dictionary system. </title> <type> Technical Report NBSIR 88-3700 (Supersedes NBSIR 85-3164), U.S. </type> <institution> Department of Commerce, National Bureau of Standards, Institute for Computer Sciences and Technology, Gaithersburg, MD 20899, </institution> <month> January </month> <year> 1988. </year>
Reference-contexts: In other words, ATIS/CIS proposes an instance of an object-oriented model which defines a set of classes and their properties. This model is designed to provide services to tools which promote integration and make tool development easier. 11 The IRDS <ref> [39] </ref> is an ANSI Standard (ANSI X3.138). The IRDS standard defines a meta-model using an ERA model. Instances of the meta-model are models which describe data. IRDS allows access to schema definitions through access to instances of meta-entities. The meta-entities define the types of entities, relationships, and attributes.
Reference: [40] <author> M.L. Griss. </author> <title> Software reuse from library to factory. </title> <journal> IBM Systems Journal, </journal> <volume> 34(4) </volume> <pages> 548-566, </pages> <year> 1993. </year>
Reference-contexts: The number of possible software production methods and environment specifications which provide support for these methods is likely to be very large. A meta-environment should assist users in the selection of desired software production methods and corresponding environment specifications. Meta-environments might include reusable or extensible "starter kits" <ref> [40] </ref>, or complete working examples of the kinds of environments that can be readily produced. * Automatic error checking. A meta-environment should support automatic error checking in order to prevent the creation of environments with significant bugs in compilation, execution, or execution semantics.
Reference: [41] <author> D. Heimbigner. </author> <title> Triton reference manual. </title> <type> Technical Report CU-CS-483-90, </type> <institution> Department of Computer Science, University of Colorado, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: The UIMS is based on Chiron [50], an Ada UIMS based on a very strong separation of functionality from interaction. The OMS in Arcadia is viewed as possibly many different object managers combined through a common underlying type model where data is combined through interoperability mechanisms. Triton <ref> [41] </ref> and PGraphite [93] are two OMSs which have been used as a basis of object management in the Arcadia project. APPL/A [86] is a process programming language which consists of extensions to Ada that include the notion of persistent relations associated with the OMS.
Reference: [42] <author> Hewlett-Packard. </author> <title> Developing SynerVision Processes. </title> <address> HP Palo ALto, CA, part number: b3261-90003 edition, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The Articulator has also been integrated with the Matisse team programming environment [32] and the SynerVision process execution engine <ref> [42] </ref> in place of PBI. The resulting composite environment is called SMART [31]. SMART supports the modeling, analysis, enactment, measurement, and improvement of software processes utilizing encapsulated CASE tools that communicate messages and tool invocations across the SoftBench BMS [13], and that manipulate data stored in networked repositories. <p> Adele-2 provides 10 support for multiple work environments (i.e., tool, policy, and method configurations) that are coordinated and coupled through an activity manager and a task manager. Coordination and coupling, as well as activity and task specification, are all realized using the Adele-2 language. Process WEAVER [29] and SynerVision <ref> [42] </ref> are commercially available process execution engines. Each provides a process programming language based on the Unix shell command lan-gugage. Their use is similar in scope to Adele-2, but they both lack support for a persistent object store, other than the underlying file system.
Reference: [43] <author> M. Heym and H. Osterle. </author> <title> Computer-aided methodology engineering. </title> <journal> Information and Software Technology, </journal> 35(6/7):345-354, 1993. 
Reference-contexts: Many software engineering methods, such as structured design and object-oriented analysis, have emerged to ease these problems. Recently, there has been considerable attention paid to the application of these methods through software production environments in order to evaluate the effectiveness of each method <ref> [7, 43, 67] </ref>. A software production environment (SPE) is a system consisting of a software infrastructure providing a common operating environment for software tools, a set of tools, and an interface which provides users with access to the environment's capabilities. <p> So both the environment framework as well as tools which operate over the environment are specified using this model. There is growing interest in developing structure- or language-based editors for manipulating graph-based or graphic software specification notations. EDGE [69], TGE [49], MetaEdit [79], VSF <ref> [43, 72] </ref>, and GEDL [47] are recent examples. <p> In contrast to structured-text editors and related functionality generated by GANDALF or Synthesizer Generator, these graphic meta-editors provide multiple layouts of graphic information [47, 69], allow the specification or redefinition of user interface functionality [49, 47], and support a variety of object modeling, software process [49, 47] and method notations <ref> [43, 72, 79] </ref>. Each meta-editor employs a language-based specification notation for describing the iconic syntax and composition semantics to be supported in the target editors that are generated or instantiated.
Reference: [44] <institution> IEEE Computer Society's Task Force on Professional Computing Tools. </institution> <note> A Standard Reference Model for Computing System Tool Interconnections, p1175/d6 edition, February 1990. Draft. </note>
Reference-contexts: In addition, DHT implements a persistent hypertext-based object management service using a persistent programming language, while CDIF lacks such a service and programming language. The P1175 reference model for interconnections between computing system tools <ref> [44] </ref> is a tool-integration standard being developed by the IEEE Computer Society's Task Force on Professional Computing Tools. The approach taken in P1175 is to define reference models for tool-to-organization and tool-to-platform interconnections, and a language for the transfer of data between tools.
Reference: [45] <author> B.T. Jenings. </author> <title> The HP SoftBench Message Model: Concepts and conventions used by the HP SoftBench Tools. SoftBench Technical Note Series SESD-89-21 Revision 1.2, </title> <institution> Hewlett-Packard, Software Engineering Systems Division, </institution> <address> Fort Collins, C), USA, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: The encapsulation consists of the Encapsulation Description Language (EDL) which describes a user-interface and corresponding communication across the BMS. The communication information consists of messages which it will respond to and messages it will generate in response to user-interface events. The message model <ref> [45] </ref> which is suggested as a basis of the environment definition is very primitive and will be too limited for environments consisting of a very large number of tools. A "multi-cast" messaging paradigm which transmits strongly typed messages may provide an alternative.
Reference: [46] <author> G.E. Kaiser and P. Feiler. </author> <title> An architecture for intelligent assistance in software development. </title> <booktitle> In Proceedings of the 9th International Conference on Software Engineering, </booktitle> <pages> pages 180-188, </pages> <month> February </month> <year> 1987. </year> <month> 22 </month>
Reference-contexts: Instances of a meta-model describe active and inactive objects in an environment. Further, an instance of a meta-model allows the execution of a process-centered environment. The GENESIS (from UC Berkeley) [73], Marvel <ref> [46] </ref>, and Merlin [27] environments are among those that provide production rules and rule interpreters as the means for specifying and enacting software processes.
Reference: [47] <author> A.S. Karrer. </author> <title> Generating Graph Editors. </title> <type> PhD thesis, </type> <institution> Computer Science Department, University of Southern California, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: This specification is then combined with the core capabilities to form an environment. This approach is very similar to the approach used in most tool generators, such as those used for parser generators [92], language-directed editor generators [16, 64, 76], or extensible graph editors <ref> [47, 69, 79] </ref>. Customizable environments differ from frameworks in that they trade ease of instantiation for less generality. In other words, customizable environments will support a model which can be used to describe only a small portion of the entire environment. <p> So both the environment framework as well as tools which operate over the environment are specified using this model. There is growing interest in developing structure- or language-based editors for manipulating graph-based or graphic software specification notations. EDGE [69], TGE [49], MetaEdit [79], VSF [43, 72], and GEDL <ref> [47] </ref> are recent examples. <p> EDGE [69], TGE [49], MetaEdit [79], VSF [43, 72], and GEDL [47] are recent examples. In contrast to structured-text editors and related functionality generated by GANDALF or Synthesizer Generator, these graphic meta-editors provide multiple layouts of graphic information <ref> [47, 69] </ref>, allow the specification or redefinition of user interface functionality [49, 47], and support a variety of object modeling, software process [49, 47] and method notations [43, 72, 79]. <p> EDGE [69], TGE [49], MetaEdit [79], VSF [43, 72], and GEDL [47] are recent examples. In contrast to structured-text editors and related functionality generated by GANDALF or Synthesizer Generator, these graphic meta-editors provide multiple layouts of graphic information [47, 69], allow the specification or redefinition of user interface functionality <ref> [49, 47] </ref>, and support a variety of object modeling, software process [49, 47] and method notations [43, 72, 79]. Each meta-editor employs a language-based specification notation for describing the iconic syntax and composition semantics to be supported in the target editors that are generated or instantiated. <p> In contrast to structured-text editors and related functionality generated by GANDALF or Synthesizer Generator, these graphic meta-editors provide multiple layouts of graphic information [47, 69], allow the specification or redefinition of user interface functionality <ref> [49, 47] </ref>, and support a variety of object modeling, software process [49, 47] and method notations [43, 72, 79]. Each meta-editor employs a language-based specification notation for describing the iconic syntax and composition semantics to be supported in the target editors that are generated or instantiated.
Reference: [48] <author> A.S. Karrer and M. Penedo. </author> <title> A survey of native environment framework architectures. TRW Corporation Note Arcadia-TRW-90-002, </title> <address> El Segundo, CA, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Much of this work has been done by creating reference models including the Conceptual Environment Architecture Reference Model (CEARM) [70], the ECMA Reference Model [23], and the NIST Reference Model [94]. <ref> [48] </ref> used one of these reference models to survey current environment framework research. This survey showed the usefulness of a reference model as a conceptual framework for comparing the capabilities of frameworks. Much of this section is derived from that study.
Reference: [49] <author> A.S. Karrer and W. Scacchi. </author> <title> Requirements for an extensible object-oriented tree/graph editor. </title> <booktitle> In ACM SIGGRAPH Symposium on User-Interface Software and Technology, </booktitle> <pages> pages 84-92, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The DSF infrastructure provides a distributed hypertext (DHT) framework to integrate heterogeneous software object repositories (e.g., those with different data models) [63] with forward and reverse software engineering tools [16], graph-based editors and user interfaces <ref> [49] </ref>, process-driven user interfaces with partially order tool invocation sequences [59], and a knowledge-based process modeling and simulation environment [58]. Using these mechanisms and components, it is possible to semi-automatically generate multirole, process-driven software production environments for a hierarchy of concurrent production processes [31, 59]. <p> So both the environment framework as well as tools which operate over the environment are specified using this model. There is growing interest in developing structure- or language-based editors for manipulating graph-based or graphic software specification notations. EDGE [69], TGE <ref> [49] </ref>, MetaEdit [79], VSF [43, 72], and GEDL [47] are recent examples. <p> EDGE [69], TGE [49], MetaEdit [79], VSF [43, 72], and GEDL [47] are recent examples. In contrast to structured-text editors and related functionality generated by GANDALF or Synthesizer Generator, these graphic meta-editors provide multiple layouts of graphic information [47, 69], allow the specification or redefinition of user interface functionality <ref> [49, 47] </ref>, and support a variety of object modeling, software process [49, 47] and method notations [43, 72, 79]. Each meta-editor employs a language-based specification notation for describing the iconic syntax and composition semantics to be supported in the target editors that are generated or instantiated. <p> In contrast to structured-text editors and related functionality generated by GANDALF or Synthesizer Generator, these graphic meta-editors provide multiple layouts of graphic information [47, 69], allow the specification or redefinition of user interface functionality <ref> [49, 47] </ref>, and support a variety of object modeling, software process [49, 47] and method notations [43, 72, 79]. Each meta-editor employs a language-based specification notation for describing the iconic syntax and composition semantics to be supported in the target editors that are generated or instantiated.
Reference: [50] <author> R.K. Keller, M. Cameron, R.N. Taylor, and D.B. Troup. Chiron-1: </author> <title> a user interface development system tailored to software environments. </title> <type> Technical Report UCI-90-06, </type> <institution> Department of Information and Computer Science, University of California, Irvine, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: Arcadia is currently a collection of many partially integrated components including a UIMS, an OMS, an Ada-based Process Programming Language (APPL/A), a Measurement and Evaluation (M&E) system, and a Process Administration System. The UIMS is based on Chiron <ref> [50] </ref>, an Ada UIMS based on a very strong separation of functionality from interaction. The OMS in Arcadia is viewed as possibly many different object managers combined through a common underlying type model where data is combined through interoperability mechanisms.
Reference: [51] <author> J.D. Kiper. </author> <title> The ergonomic, efficient, and economic integration of existing tools into a software engineering environment. </title> <type> PhD thesis, </type> <institution> Ohio State University, USA, </institution> <year> 1985. </year>
Reference-contexts: GANDALF also provides for the specification of commands which invoke external tools integrated around centralized parse tree representations, while SOFTMAN provides for the integration of 6 generated multilanguage editors with an OMS. TRIAD <ref> [51] </ref> is a customizable environment which supports a set of form-based, methodology-driven tools designed to operate over an extendible attribute grammar. This grammar is used to encode process information as well as syntax information.
Reference: [52] <author> K. Kishida, T. Katayama, M. Matsuo, I. Miyamoto, K. Ochimizu, M. Saito, J. Saylet, K. Torii, and L. Williams. SDA: </author> <title> a novel approach to software environment design and construction. </title> <booktitle> In Int. Conf. Software Engineering, </booktitle> <pages> pages 69-79, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: A major part of this prototype is the graphical user-interface, which depicts the Petri-nets and allows both the specification of process models and the enaction of process models. The Software Designer's Associate (SDA) project <ref> [52] </ref> is a software design environment in which 8 the executable process descriptions are specified as a process model consisting of activities, com-posite activities, products and tools.
Reference: [53] <author> P. Klint. </author> <title> A meta-environment for generating programming environments. </title> <journal> ACM Trans. Software Engineering and Methodology, </journal> <volume> 2(2) </volume> <pages> 176-201, </pages> <year> 1993. </year>
Reference-contexts: Because SPEs are themselves software products, we can consider the software production process used to construct SPEs. SPE construction processes have taken many forms, with early SPEs being constructed using a simple program-debug-test process based on a single programming language. Meta-environments <ref> [53, 55, 80] </ref> are emerging as a means of constructing SPEs with significantly more powerful constructs than are generally available in programming languages. Meta-environments have also been called generic environments [36] and environment generators [25, 31, 95]. The distinction between these terms is somewhat vague. <p> This grammar is used to encode process information as well as syntax information. The grammar is used by TRIAD to construct various portions of the environment including a syntax-directed editor. DRACO [62], Popart [92], GEM [38], KIDS [78], and Centaur <ref> [53] </ref> are generators of grammar-based or notation-based meta-programming environments. A meta-programming environment is an environment which assists in the creation of parsers and related tools which manipulate a particular language.
Reference: [54] <author> J.W. Krueger. </author> <title> Application Object Model for Engineering Information Systems. </title> <institution> Honeywell Systems and Research Center, Minneapolis, MN, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: STEP is a neutral mechanism capable of completely representing product data throughout the life-cycle of a product. This representation is suitable for neutral file exchange and as the basis for sharing product databases and archiving. The Engineering Information System (EIS) <ref> [54] </ref> is a vast undertaking addressing heterogeneity of hardware and software platforms, data formats, tools, site-specific policies and methodologies, 12 and interfaces primarily oriented around the computer-aided engineering (CAE) domain.
Reference: [55] <author> A. Van Lamsweerde et al. </author> <title> Generic lifecycle support in the ALMA environment. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 14(6) </volume> <pages> 720-740, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Because SPEs are themselves software products, we can consider the software production process used to construct SPEs. SPE construction processes have taken many forms, with early SPEs being constructed using a simple program-debug-test process based on a single programming language. Meta-environments <ref> [53, 55, 80] </ref> are emerging as a means of constructing SPEs with significantly more powerful constructs than are generally available in programming languages. Meta-environments have also been called generic environments [36] and environment generators [25, 31, 95]. The distinction between these terms is somewhat vague. <p> Thus, RDPE3 focuses on a smaller component size as compared to PCTE, CAIS-A, etc. Furthermore, RDPE3 suggests a different integration scheme than those suggested by other frameworks, one in which the function of the integrated components must be accessible. The ALMA <ref> [55] </ref> generic environment provides the capability to define a life-cycle support database schema based on the entity-relationship model. While the ALMA environment has capabilities similar to other frameworks, it specifically presents a plan for the use of the framework as both a meta-environment and a software production environment.
Reference: [56] <editor> N.H. Madhavji et al. </editor> <title> Prism = methodology + process-oriented environment. </title> <booktitle> In Proc. 12th Int. Conf. Software Engineering, </booktitle> <pages> pages 277-289, </pages> <year> 1990. </year>
Reference-contexts: Environment construction using these systems consists of specifying the production rules for all of the activities or events which the environment should support. PRISM <ref> [56] </ref>, IPSE 2.5 [91], and its successor, PSS [12], provide process meta-models similar to Marvel and GENESIS. However, these efforts suggest a particular execution of the process models, which provides the environment to the user.
Reference: [57] <author> P. Mi and W. Scacchi. </author> <title> A knowledge-based environment for modeling and simulating software engineering processes. </title> <journal> IEEE Trans Knowledge and Data Engineering, </journal> <volume> 2(3) </volume> <pages> 283-294, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: SDA is unique in that it only addresses the early phase of design and that it uses a model-based approach to the design and construction of an environment. The DSF project has been developing and using the Articulator <ref> [57] </ref>, which is a knowledge-based environment for modeling, analyzing, and simulating software production processes. The Articulator uses a hierarchical object-oriented representation of agent roles, products (or resources), and tasks, which can be either partially ordered or triggered through rule-based mechanisms. <p> Their use is similar in scope to Adele-2, but they both lack support for a persistent object store, other than the underlying file system. However, the SMART environment [31] can semi-automatically generate SynerVision process program code via transformations on Articulator-based software process models <ref> [57] </ref>, while Process WEAVER allows modeled process states to be attributed with Unix shell commands, which can subsequently be executed under user direction. Last, both OIKOS [3] and OPM [85] propose object-oriented approaches to process programming.
Reference: [58] <author> P. Mi and W. Scacchi. </author> <title> Modeling articulation work in software engineering processes. </title> <booktitle> In Proc. First Int. Conf. Software Process, </booktitle> <pages> pages 188-201, </pages> <year> 1991. </year>
Reference-contexts: a distributed hypertext (DHT) framework to integrate heterogeneous software object repositories (e.g., those with different data models) [63] with forward and reverse software engineering tools [16], graph-based editors and user interfaces [49], process-driven user interfaces with partially order tool invocation sequences [59], and a knowledge-based process modeling and simulation environment <ref> [58] </ref>. Using these mechanisms and components, it is possible to semi-automatically generate multirole, process-driven software production environments for a hierarchy of concurrent production processes [31, 59]. <p> In addition, the environment maintains persistent information about the state of enacted processes as process transitions occur. This information is used to track the execution history of planned activities, and to facilitate incremental process rescheduling and replanning when unplanned or dynamic changes in the process occur <ref> [58] </ref>. The Articulator has been integrated with a process-based user interface and a process model interpreter (together called PBI) to provide a framework for developing process model-driven environments [59].
Reference: [59] <author> P. Mi and W. Scacchi. </author> <title> Process integration for CASE environments. </title> <journal> IEEE Software, </journal> <volume> 9(2) </volume> <pages> 45-53, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: The DSF infrastructure provides a distributed hypertext (DHT) framework to integrate heterogeneous software object repositories (e.g., those with different data models) [63] with forward and reverse software engineering tools [16], graph-based editors and user interfaces [49], process-driven user interfaces with partially order tool invocation sequences <ref> [59] </ref>, and a knowledge-based process modeling and simulation environment [58]. Using these mechanisms and components, it is possible to semi-automatically generate multirole, process-driven software production environments for a hierarchy of concurrent production processes [31, 59]. <p> Using these mechanisms and components, it is possible to semi-automatically generate multirole, process-driven software production environments for a hierarchy of concurrent production processes <ref> [31, 59] </ref>. The EUREKA Software Factory (ESF) [28] is a large-scale pan-European research effort aiming at the development of an integration framework for a meta-environment that can accomodate the interoperation of various tools and the interactions of people working together with these tools according to a process meta-model [2]. <p> The Articulator has been integrated with a process-based user interface and a process model interpreter (together called PBI) to provide a framework for developing process model-driven environments <ref> [59] </ref>. The Articulator, PBI, and an open software environment or set of software tools can the be used to construct and instantiate process-driven software production environments. That is, process models created with the Articulator are automatically transformed into process programs that can be enacted by PBI's process interpreter. <p> When the process models specify tool bindings to process pre- or postconditions, data objects, and object repositories, then process-driven software environments can be automatically produced. In one study <ref> [59] </ref>, the SOFTMAN environment [16] was used as the base environment, and a software life-cycle process model that guides a user in their invocation of SOFTMAN tools was developed using the Articulator. The SOFTMAN process model was then transformed and loaded into the PBI process interpreter. <p> Users can then select the next process task or action to perform. In this way, we can say that a process integration interpreter and user interface enable knowledge-based process models to guide user invocation of tools within a software production environment, such as PBI-SOFTMAN <ref> [59] </ref>. The Articulator has also been integrated with the Matisse team programming environment [32] and the SynerVision process execution engine [42] in place of PBI. The resulting composite environment is called SMART [31]. <p> The component builder is responsible for creating this technology, as well as the other software components which may be incorporated into them. This may entail selecting from existing components available within some reusable component repository, or extracting (and restructuring if necessary) candidate components from existing software systems <ref> [15, 59] </ref>. Note that there can be many component builders building products which are completely incompatible. The fact that they assume the same role does not imply that they work together.
Reference: [60] <author> R. Munck, P. Oberndorf, E. Ploedereder, and R. Thall. </author> <title> An Overview of DOD-STD-1838A (proposed), The Common APSE Interface Set, Revision A. </title> <type> Technical report, </type> <institution> Dept. of Defense, USA, </institution> <year> 1988. </year>
Reference-contexts: Gaia [90] embodies an approach similar to the Software Backplane by providing an object-oriented OMS as its cornerstone. It lacks some of the integration techniques present in the Software Backplane. It also lacks a plan for using object-oriented technology to instantiate an environment. CAIS-A <ref> [60, 18, 71] </ref>, the latest version of CAIS, is defined in the military standard report MIL-STD-1838A, under the control of the Ada Joint Program Office (AJPO) within the U.S. Department of Defense. CAIS-A is a set of Ada interfaces which are designed to act like a high-level virtual operating system.
Reference: [61] <author> W.L. Melo N. Belkhatir, J. Estublier and L.G.I. France. Adele-2: </author> <title> A support to large software development processes. </title> <booktitle> In Proc. First Int. Conf. Software Process, </booktitle> <pages> pages 159-171, </pages> <year> 1991. </year> <month> 23 </month>
Reference-contexts: This mechanism would not be part of the Arcadia infrastructure, but it would be part of the virtual environment created by the definition of the process which allows user-role specification. In contrast, the Adele-2 environment <ref> [61] </ref> utilizes a special-purpose persistent database and programming language, Adele, to describe and implement enactable processes. Adele-2 provides 10 support for multiple work environments (i.e., tool, policy, and method configurations) that are coordinated and coupled through an activity manager and a task manager.
Reference: [62] <author> J.M. Neighbors. </author> <title> The DRACO approach to constructing software from reusable components. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 10(5) </volume> <pages> 564-573, </pages> <month> September </month> <year> 1984. </year>
Reference-contexts: This grammar is used to encode process information as well as syntax information. The grammar is used by TRIAD to construct various portions of the environment including a syntax-directed editor. DRACO <ref> [62] </ref>, Popart [92], GEM [38], KIDS [78], and Centaur [53] are generators of grammar-based or notation-based meta-programming environments. A meta-programming environment is an environment which assists in the creation of parsers and related tools which manipulate a particular language. <p> The Unix pipe facility allows the combination of tools into larger tools through the interconnection of tool outputs to tool inputs through standard typeless I/O facilities. However useful this simple piping mechanism may be, it falls short of the kind of tool integration that other efforts have demonstrated. DRACO <ref> [62] </ref> is an approach to the construction of software by organizing reusable software components or tools according to a specific problem area or domain. DRACO uses a domain language for describing programs in each domain.
Reference: [63] <author> J. Noll and W. Scacchi. </author> <title> Integrating diverse information repositories: the Distributed Hypertext approach. </title> <journal> Computer, </journal> <volume> 24(12) </volume> <pages> 38-45, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: The DSF infrastructure provides a distributed hypertext (DHT) framework to integrate heterogeneous software object repositories (e.g., those with different data models) <ref> [63] </ref> with forward and reverse software engineering tools [16], graph-based editors and user interfaces [49], process-driven user interfaces with partially order tool invocation sequences [59], and a knowledge-based process modeling and simulation environment [58]. <p> In contrast, the DHT approach noted earlier also incorporates modeling formalism similar in power to a meta-meta-data model, but does not require transformation of data sets to support access to heterogeneous data repositories <ref> [63] </ref>. In addition, DHT implements a persistent hypertext-based object management service using a persistent programming language, while CDIF lacks such a service and programming language.
Reference: [64] <author> D. Notkin. </author> <title> The GANDALF project. </title> <journal> J. Systems and Software, </journal> <volume> 5(5) </volume> <pages> 91-105, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: This specification is then combined with the core capabilities to form an environment. This approach is very similar to the approach used in most tool generators, such as those used for parser generators [92], language-directed editor generators <ref> [16, 64, 76] </ref>, or extensible graph editors [47, 69, 79]. Customizable environments differ from frameworks in that they trade ease of instantiation for less generality. In other words, customizable environments will support a model which can be used to describe only a small portion of the entire environment. <p> This syntax tree can be annotated by means of other abstract syntax trees in specialized languages. By allowing arbitrary annotations of nodes in the syntax tree, Mentor allows the extension of the environment. GANDALF <ref> [64] </ref>, the Synthesizer Generator [76], and SOFTMAN [16] provide customizable structure/text editors which allow an environment to be constructed as a suite of tightly integrated editors.
Reference: [65] <author> H. Ossher and W. Harrison. </author> <title> Support for change in RDPE3. </title> <booktitle> In Proc. Fourth ACM SIGSOFT Symp. Software Development Environments, </booktitle> <pages> pages 218-228, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: The 2167A model is based on the waterfall model of software production based primarily on the production of documents after each step in the life-cycle. The SLCSE framework also supports specification of alternative schemata and alternate life-cycles. RDPE3 <ref> [65] </ref> is a programming environment which is primarily oriented around the support of adaptation and extension of environments. RDPE3 uses an extended object-oriented, fine-grained programming paradigm to represent program fragments. Thus, RDPE3 focuses on a smaller component size as compared to PCTE, CAIS-A, etc.
Reference: [66] <author> L. Osterweil. </author> <title> Software environment research: directions for the next five years. </title> <journal> IEEE Computer, </journal> <volume> 14(4) </volume> <pages> 35-43, </pages> <month> April </month> <year> 1981. </year>
Reference-contexts: Thus, to present this trend, we will attempt to give further insight into the problem area and, in particular, to the functional requirements which form the common thread. Considerable work has been done in the area of defining the requirements for software production environments <ref> [66, 82, 83] </ref>. That is, a meta-environment must be capable of producing environments which satisfy these requirements. In this section, we will first present the kinds of roles environment builders must play and the processes they must perform which are the basis for meta-environment technology. <p> Furthermore, a constructed environment must have the characteristics of a "good" environment: it must be fast, provide a high level of functionality in a consistent and coherent manner, provide a consistent "look and feel" graphical user interface, etc. <ref> [66, 82, 83] </ref>. A meta-environment should provide a construction model able to express policies or methods for dealing with security, integrity, reuse, process, etc. Furthermore, the construction model should be general enough to express any of the mechanisms which can be chosen within any of these categories.
Reference: [67] <author> L. Osterweil. </author> <title> TOOLPACK an experimental software development environment research project. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 9(6) </volume> <pages> 673-685, </pages> <month> November </month> <year> 1983. </year>
Reference-contexts: Many software engineering methods, such as structured design and object-oriented analysis, have emerged to ease these problems. Recently, there has been considerable attention paid to the application of these methods through software production environments in order to evaluate the effectiveness of each method <ref> [7, 43, 67] </ref>. A software production environment (SPE) is a system consisting of a software infrastructure providing a common operating environment for software tools, a set of tools, and an interface which provides users with access to the environment's capabilities. <p> Unfortunately, such 1 an evolutionary approach will be costly because of the time and effort required for creating new SPEs, and because as better SPEs are developed, users are likely to change the manner in which they use the SPE <ref> [67] </ref>. Worse yet, each software production project may have different requirements for an SPE [10]. These factors imply that in order to research the requirements for SPEs and to support the requirements of individual projects we must reduce the cost of creating SPEs. <p> Given the domain of software production environment construction, DRACO effectively provides a tool composition language based on a module interconnection language paradigm. GENESIS (from UT Austin) [8] is similar in purpose to DRACO, but specialized to a domain for constructing and generating of special-purpose database management systems. Toolpack <ref> [67] </ref>, and later Odin [17], support the construction of an environment based on the 13 specification of software objects, tools, and relationships between objects and tools.
Reference: [68] <author> W. Paseman. </author> <title> The Atherton Software BackPlane an architecture for tool integration. Unix Review, </title> <month> April </month> <year> 1989. </year>
Reference-contexts: The examples that we present next show a variety of data and control models. Atherton Technology's Software BackPlane <ref> [68] </ref> is an integration and portability framework designed to assist in building SPEs independent of tools, methodology, or languages. It provides a generic operating system, an object-oriented OMS and a Macintosh-like user interface.
Reference: [69] <author> F. Newbury Paulisch and W. Tichy. </author> <title> EDGE: an extendible graph editor. </title> <journal> Software Practice and Experience, </journal> <volume> 20(S1), </volume> <month> June </month> <year> 1991. </year>
Reference-contexts: This specification is then combined with the core capabilities to form an environment. This approach is very similar to the approach used in most tool generators, such as those used for parser generators [92], language-directed editor generators [16, 64, 76], or extensible graph editors <ref> [47, 69, 79] </ref>. Customizable environments differ from frameworks in that they trade ease of instantiation for less generality. In other words, customizable environments will support a model which can be used to describe only a small portion of the entire environment. <p> So both the environment framework as well as tools which operate over the environment are specified using this model. There is growing interest in developing structure- or language-based editors for manipulating graph-based or graphic software specification notations. EDGE <ref> [69] </ref>, TGE [49], MetaEdit [79], VSF [43, 72], and GEDL [47] are recent examples. <p> EDGE [69], TGE [49], MetaEdit [79], VSF [43, 72], and GEDL [47] are recent examples. In contrast to structured-text editors and related functionality generated by GANDALF or Synthesizer Generator, these graphic meta-editors provide multiple layouts of graphic information <ref> [47, 69] </ref>, allow the specification or redefinition of user interface functionality [49, 47], and support a variety of object modeling, software process [49, 47] and method notations [43, 72, 79].
Reference: [70] <author> M. Penedo and W.E. Riddle. </author> <title> Guest editors' introduction to software engineering environment architectures. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 14(6), </volume> <month> June </month> <year> 1988. </year>
Reference-contexts: Much of this work has been done by creating reference models including the Conceptual Environment Architecture Reference Model (CEARM) <ref> [70] </ref>, the ECMA Reference Model [23], and the NIST Reference Model [94]. [48] used one of these reference models to survey current environment framework research. This survey showed the usefulness of a reference model as a conceptual framework for comparing the capabilities of frameworks. <p> Much of this section is derived from that study. These reference models suggest that frameworks should address Object Management Services, User-Interface Management Services, and Life-cycle Process Management Services (also called Environment Management <ref> [70] </ref> and Task Management [23]). The Object Management Services (OMS) provide for persistent objects and relationships as opposed to files and directories traditionally supported by operating systems. The Life-Cycle Process Management Services (LCPMS) provide a means for enacting change upon the current state of life-cycle objects.
Reference: [71] <author> E. Ploedereder, T.C. Harrison, P. Oberndorf, C. Roby, F. Belz, J.F. Kramer, and J. Clouse. </author> <title> Rationale for DOD-STD-1838 (CAIS). </title> <type> Technical report, </type> <institution> Dept. of Defense, USA, </institution> <month> August </month> <year> 1988. </year>
Reference-contexts: Gaia [90] embodies an approach similar to the Software Backplane by providing an object-oriented OMS as its cornerstone. It lacks some of the integration techniques present in the Software Backplane. It also lacks a plan for using object-oriented technology to instantiate an environment. CAIS-A <ref> [60, 18, 71] </ref>, the latest version of CAIS, is defined in the military standard report MIL-STD-1838A, under the control of the Ada Joint Program Office (AJPO) within the U.S. Department of Defense. CAIS-A is a set of Ada interfaces which are designed to act like a high-level virtual operating system.
Reference: [72] <author> J.N. Popcock. </author> <title> VSF and its relationship to open systems and standard repositories. </title> <booktitle> In Software Development Environments and CASE Environments, </booktitle> <pages> pages 53-68. </pages> <address> Springer Verlag, </address> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 509, </volume> <year> 1991. </year>
Reference-contexts: So both the environment framework as well as tools which operate over the environment are specified using this model. There is growing interest in developing structure- or language-based editors for manipulating graph-based or graphic software specification notations. EDGE [69], TGE [49], MetaEdit [79], VSF <ref> [43, 72] </ref>, and GEDL [47] are recent examples. <p> In contrast to structured-text editors and related functionality generated by GANDALF or Synthesizer Generator, these graphic meta-editors provide multiple layouts of graphic information [47, 69], allow the specification or redefinition of user interface functionality [49, 47], and support a variety of object modeling, software process [49, 47] and method notations <ref> [43, 72, 79] </ref>. Each meta-editor employs a language-based specification notation for describing the iconic syntax and composition semantics to be supported in the target editors that are generated or instantiated.
Reference: [73] <author> C.V. Ramamoorthy, Y. Usuda, et al. </author> <title> GENESIS: an integrated environment for supporting development and evolution of software. </title> <booktitle> In COMPSAC '85, </booktitle> <pages> pages 472-479, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: Instances of a meta-model describe active and inactive objects in an environment. Further, an instance of a meta-model allows the execution of a process-centered environment. The GENESIS (from UC Berkeley) <ref> [73] </ref>, Marvel [46], and Merlin [27] environments are among those that provide production rules and rule interpreters as the means for specifying and enacting software processes.
Reference: [74] <author> S.P. Reiss. </author> <title> Connecting tools using message passing in the field environment. </title> <journal> IEEE Software, </journal> <volume> 7(4) </volume> <pages> 57-66, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Accordingly, a combination of SoftBench and SUN's ToolTalk tool integration mechanisms have been proposed as the basis of a new "standard" for open tool integration, as part of the Common Development Environment (CDE) now being investigated by the Open Software Foundation (OSF). Field <ref> [74, 75] </ref> provides an integration framework very similar to the BMS using a communication mechanism called selective broadcasting. Field has extended the HP Softbench approach by passing all data through the message server rather than relying on a common database.
Reference: [75] <author> S.P. Reiss. </author> <title> Interacting with the field environment. </title> <journal> Software Practice and Experience, </journal> <volume> 20(S1):89-115, </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: Accordingly, a combination of SoftBench and SUN's ToolTalk tool integration mechanisms have been proposed as the basis of a new "standard" for open tool integration, as part of the Common Development Environment (CDE) now being investigated by the Open Software Foundation (OSF). Field <ref> [74, 75] </ref> provides an integration framework very similar to the BMS using a communication mechanism called selective broadcasting. Field has extended the HP Softbench approach by passing all data through the message server rather than relying on a common database.
Reference: [76] <author> T. Reps and T. Teitelbaum. </author> <title> The Synthesizer Generator. </title> <booktitle> In Proc. ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <month> April </month> <year> 1984. </year>
Reference-contexts: This specification is then combined with the core capabilities to form an environment. This approach is very similar to the approach used in most tool generators, such as those used for parser generators [92], language-directed editor generators <ref> [16, 64, 76] </ref>, or extensible graph editors [47, 69, 79]. Customizable environments differ from frameworks in that they trade ease of instantiation for less generality. In other words, customizable environments will support a model which can be used to describe only a small portion of the entire environment. <p> This syntax tree can be annotated by means of other abstract syntax trees in specialized languages. By allowing arbitrary annotations of nodes in the syntax tree, Mentor allows the extension of the environment. GANDALF [64], the Synthesizer Generator <ref> [76] </ref>, and SOFTMAN [16] provide customizable structure/text editors which allow an environment to be constructed as a suite of tightly integrated editors. Editors are customized through the specification of (a) the grammars of the languages which they edit, and (b) the attributes or action routines which support incremental semantic checking.
Reference: [77] <author> W. Scacchi. </author> <title> The Software infrastructure for a Distributed Software Factory. </title> <journal> Software Engineering Journal, </journal> <volume> 6(5) </volume> <pages> 355-369, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: The Distributed System Factory (DSF) project is developing a multilayer infrastructure of software services which can integrate multiple data, control, presentation, and process models that can span a distributed wide-area network <ref> [77] </ref>. <p> Finally, TGE, VSF, and GEDL have specification-level interfaces which allow them or their derived editors to be integrated with one or more repositories and environments, such as SOFTMAN's use of TGE-based graph editors <ref> [16, 77] </ref>. Subsequently, this provides another dimension for the extension of resulting meta-environments. Overall, the primary advantage of customizable environments is the speed and relative ease of constructing high functionality environments. However, most customizable environments have lessened the burden of environment construction by adopting a particular approach to software development.
Reference: [78] <author> D. Smith. KIDS: </author> <title> A semi-automatic program development system. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 16(9) </volume> <pages> 1024-1044, </pages> <year> 1990. </year> <month> 24 </month>
Reference-contexts: This grammar is used to encode process information as well as syntax information. The grammar is used by TRIAD to construct various portions of the environment including a syntax-directed editor. DRACO [62], Popart [92], GEM [38], KIDS <ref> [78] </ref>, and Centaur [53] are generators of grammar-based or notation-based meta-programming environments. A meta-programming environment is an environment which assists in the creation of parsers and related tools which manipulate a particular language.
Reference: [79] <author> K. Smolander, P. Marttiin, K. Lyytinen, and V-P. </author> <title> Tahvanainen. MetaEdit a flexible graphical environment for methodology modelling. </title> <booktitle> In Advanced Information Systems Engineering, </booktitle> <pages> pages 168-193. </pages> <address> Springer Verlag, </address> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 498, </volume> <year> 1991. </year>
Reference-contexts: This specification is then combined with the core capabilities to form an environment. This approach is very similar to the approach used in most tool generators, such as those used for parser generators [92], language-directed editor generators [16, 64, 76], or extensible graph editors <ref> [47, 69, 79] </ref>. Customizable environments differ from frameworks in that they trade ease of instantiation for less generality. In other words, customizable environments will support a model which can be used to describe only a small portion of the entire environment. <p> So both the environment framework as well as tools which operate over the environment are specified using this model. There is growing interest in developing structure- or language-based editors for manipulating graph-based or graphic software specification notations. EDGE [69], TGE [49], MetaEdit <ref> [79] </ref>, VSF [43, 72], and GEDL [47] are recent examples. <p> In contrast to structured-text editors and related functionality generated by GANDALF or Synthesizer Generator, these graphic meta-editors provide multiple layouts of graphic information [47, 69], allow the specification or redefinition of user interface functionality [49, 47], and support a variety of object modeling, software process [49, 47] and method notations <ref> [43, 72, 79] </ref>. Each meta-editor employs a language-based specification notation for describing the iconic syntax and composition semantics to be supported in the target editors that are generated or instantiated.
Reference: [80] <author> R. Snodgrass and K. Shannon. </author> <title> Fine grained data management to achieve evolution resilience in a software development environment. </title> <booktitle> In Proc. Fourth ACM SIGSOFT Symp. Software Development Environments, </booktitle> <pages> pages 144-156, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Because SPEs are themselves software products, we can consider the software production process used to construct SPEs. SPE construction processes have taken many forms, with early SPEs being constructed using a simple program-debug-test process based on a single programming language. Meta-environments <ref> [53, 55, 80] </ref> are emerging as a means of constructing SPEs with significantly more powerful constructs than are generally available in programming languages. Meta-environments have also been called generic environments [36] and environment generators [25, 31, 95]. The distinction between these terms is somewhat vague. <p> Tools and applications are programs written in an extension of Common Lisp called AP5. AP5 provides a persistent virtual database of relations, objects, and rules. The rules connect tools through triggering upon detection of changes to data or calling procedures. The Scorpion Meta-Environment <ref> [80] </ref> uses a specification of tool topology using a module interconnection language and a specification of the level of trade-off between evolution support and efficiency.
Reference: [81] <author> R.M. Soley. </author> <title> Object Management Group Standards Manual. Draft 0.1 OMG TC Document 90.5.4, </title> <month> May </month> <year> 1990. </year>
Reference-contexts: These interconnections consist of the Data Base Manager, Communication Network Manager, O/S Service Manager, and the User Interface Manager interfaces. The Object Management Group (OMG) <ref> [81] </ref> is an international organization of more than 50 information systems vendors, users, and research organizations with diverse backgrounds. The basic technical approach being followed in OMG is an object-oriented layer of services which exists above various implementations of object managers, user-interface facilities, and environment managers.
Reference: [82] <author> P.G. Sorenson, J.P. Tremblay, and A.J. McAllister. </author> <title> The Metaview system for many specification environments. </title> <journal> IEEE Software, </journal> <volume> 5 </volume> <pages> 30-38, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: However, the META/GA user, the environment constructor, is able to specify the type of information which will be processed. This customizable environment attempts to help standardize the type of information and leave the life-cycle as general as possible. The Metaview project <ref> [11, 82] </ref> takes an approach that is a hybrid of framework approaches and customizable environments. The models provided are based on an ERA model extended with constraints, transformations, and a graphical interaction model. <p> Thus, to present this trend, we will attempt to give further insight into the problem area and, in particular, to the functional requirements which form the common thread. Considerable work has been done in the area of defining the requirements for software production environments <ref> [66, 82, 83] </ref>. That is, a meta-environment must be capable of producing environments which satisfy these requirements. In this section, we will first present the kinds of roles environment builders must play and the processes they must perform which are the basis for meta-environment technology. <p> Furthermore, a constructed environment must have the characteristics of a "good" environment: it must be fast, provide a high level of functionality in a consistent and coherent manner, provide a consistent "look and feel" graphical user interface, etc. <ref> [66, 82, 83] </ref>. A meta-environment should provide a construction model able to express policies or methods for dealing with security, integrity, reuse, process, etc. Furthermore, the construction model should be general enough to express any of the mechanisms which can be chosen within any of these categories.
Reference: [83] <author> Vic Stennig. </author> <title> On the Role of an Environment. </title> <journal> Communications of the ACM, </journal> <year> 1987. </year>
Reference-contexts: Thus, to present this trend, we will attempt to give further insight into the problem area and, in particular, to the functional requirements which form the common thread. Considerable work has been done in the area of defining the requirements for software production environments <ref> [66, 82, 83] </ref>. That is, a meta-environment must be capable of producing environments which satisfy these requirements. In this section, we will first present the kinds of roles environment builders must play and the processes they must perform which are the basis for meta-environment technology. <p> Furthermore, a constructed environment must have the characteristics of a "good" environment: it must be fast, provide a high level of functionality in a consistent and coherent manner, provide a consistent "look and feel" graphical user interface, etc. <ref> [66, 82, 83] </ref>. A meta-environment should provide a construction model able to express policies or methods for dealing with security, integrity, reuse, process, etc. Furthermore, the construction model should be general enough to express any of the mechanisms which can be chosen within any of these categories.
Reference: [84] <author> Tom Strelich. </author> <title> The Software Life Cycle Support Environment (SLCSE): a computer based framework for developing software systems. </title> <booktitle> In Proc. ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 35-44, </pages> <month> Novem-ber </month> <year> 1988. </year>
Reference-contexts: It provides no extensibility of the base classes. It does support an extension to Unix process management by allowing triggers associated with NSE commands to perform some of the environment tasks. The Software Life-Cycle Support Environment (SLCSE) <ref> [84] </ref> is a framework which provides a common database, a set of common schemata, and tools. The common schemata and tools are designed to support a MIL-STD 2167A model for documenting the software production life-cycle.
Reference: [85] <author> Y. Sugiyama and E. Horowitz. </author> <title> Building your own software development environment. </title> <journal> Software Engineering Journal, </journal> <volume> 6(5) </volume> <pages> 317-331, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: However, the SMART environment [31] can semi-automatically generate SynerVision process program code via transformations on Articulator-based software process models [57], while Process WEAVER allows modeled process states to be attributed with Unix shell commands, which can subsequently be executed under user direction. Last, both OIKOS [3] and OPM <ref> [85] </ref> propose object-oriented approaches to process programming. The idea in these two efforts is to show how object-oriented views of process programming and software development environments can be united into a single view in which both the process model and programming environment can be dynamically modified.
Reference: [86] <author> S.M. Sutton, D. Heimbigner, and L. Osterweil. </author> <title> Programmable relations for managing change during software development. </title> <type> Technical Report CU-CS-418-88, </type> <institution> University of Colorado, Boulder, </institution> <address> CO 80309-0430, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: The OMS in Arcadia is viewed as possibly many different object managers combined through a common underlying type model where data is combined through interoperability mechanisms. Triton [41] and PGraphite [93] are two OMSs which have been used as a basis of object management in the Arcadia project. APPL/A <ref> [86] </ref> is a process programming language which consists of extensions to Ada that include the notion of persistent relations associated with the OMS. The Process Administration System is a run-time support interface for executing processes based on a corporate metaphor.
Reference: [87] <editor> R. Taylor et al. </editor> <booktitle> Foundations for the Arcadia environment architecture. In Proc 3rd ACM Symp. Software Development Environments, </booktitle> <month> November </month> <year> 1988. </year>
Reference-contexts: Process programming differs from process modeling in the form of the meta-model provided for environment construction. However, we can view process programming as process modeling where the meta-model is a programming language. The Arcadia Research Project <ref> [87] </ref> consists of a collection of loosely coordinated research and development projects conducted by the Arcadia Consortium. Like ESF, Arcadia could also be categorized as an environment framework, but the architecture of the Arcadia framework is centered on the capability to execute process programs.
Reference: [88] <author> W. Teitelman and L. Masinter. </author> <title> The Interlisp programming environment. </title> <journal> IEEE Computer, </journal> <volume> 14(4) </volume> <pages> 25-33, </pages> <month> April </month> <year> 1981. </year>
Reference-contexts: Two of the more notable examples of this approach are the programming support environments for Smalltalk [37] and Interlisp <ref> [88] </ref>. Both environments support a single method of software production: interpretive, incremental program development. While the monolithic approach can be applied to construct environments which support virtually any software production method and programming language, the cost of productng an environment using this approach is generally prohibitive for most research organizations.
Reference: [89] <author> I. Thomas. </author> <title> PCTE interfaces: supporting tools in software engineering environments. </title> <journal> IEEE Software, </journal> <volume> 6(11) </volume> <pages> 15-23, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: The node model is used to formalize the structures and capabilities of the OMS. Processes in CAIS-A form a tree of parent-child processes. All process information is kept in the OMS. Processes can communicate through special OMS-based queues. The Portable Common Tool Environment (PCTE) <ref> [89] </ref> is a Public Tool Interface (PTI) which can be used as a basis for integrating tools as part of the development of an SPE. The PCTE PTI consists of software interfaces to services of an OMS, LCPMS, and UIMS.
Reference: [90] <author> D. Vines and T. King. </author> <title> Gaia: an object-oriented framework for an Ada environment. </title> <booktitle> In Third Int. IEEE Conf. Ada Applications and Environments, </booktitle> <pages> pages 81-90, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Atherton has also provided a high-level specification of an environment construction process called the "Environment Customization Plan". This process suggests the creation of user-defined methods as a form of process programming, tool definition, data definition, and user/role definition. Gaia <ref> [90] </ref> embodies an approach similar to the Software Backplane by providing an object-oriented OMS as its cornerstone. It lacks some of the integration techniques present in the Software Backplane. It also lacks a plan for using object-oriented technology to instantiate an environment.
Reference: [91] <author> B. Warboys. </author> <title> The IPSE 2.5 project : process modeling as the basis for a support environment. </title> <institution> University of Manchester, </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: Environment construction using these systems consists of specifying the production rules for all of the activities or events which the environment should support. PRISM [56], IPSE 2.5 <ref> [91] </ref>, and its successor, PSS [12], provide process meta-models similar to Marvel and GENESIS. However, these efforts suggest a particular execution of the process models, which provides the environment to the user.
Reference: [92] <author> D. Wile. </author> <title> Program development: formal explanations of implementations. </title> <journal> Communications ACM, </journal> <volume> 26(11) </volume> <pages> 902-911, </pages> <month> November </month> <year> 1983. </year>
Reference-contexts: This specification is then combined with the core capabilities to form an environment. This approach is very similar to the approach used in most tool generators, such as those used for parser generators <ref> [92] </ref>, language-directed editor generators [16, 64, 76], or extensible graph editors [47, 69, 79]. Customizable environments differ from frameworks in that they trade ease of instantiation for less generality. <p> This grammar is used to encode process information as well as syntax information. The grammar is used by TRIAD to construct various portions of the environment including a syntax-directed editor. DRACO [62], Popart <ref> [92] </ref>, GEM [38], KIDS [78], and Centaur [53] are generators of grammar-based or notation-based meta-programming environments. A meta-programming environment is an environment which assists in the creation of parsers and related tools which manipulate a particular language.
Reference: [93] <author> A. Wolf, J. Wileden, C. Fisher, and P. Tarr. Pgraphite: </author> <title> an experiment in persistent typed object management. </title> <booktitle> In Proc. ACM SIGSOFT/SIGPLAN Software Engineering Symp. Practical Software Development Environments, </booktitle> <pages> pages 130-142, </pages> <month> Novemeber </month> <year> 1988. </year> <month> 25 </month>
Reference-contexts: The OMS in Arcadia is viewed as possibly many different object managers combined through a common underlying type model where data is combined through interoperability mechanisms. Triton [41] and PGraphite <ref> [93] </ref> are two OMSs which have been used as a basis of object management in the Arcadia project. APPL/A [86] is a process programming language which consists of extensions to Ada that include the notion of persistent relations associated with the OMS.
Reference: [94] <author> W. Wong and M.V. Zelkowitz. </author> <title> A preliminary description of an Integrated Software Engineer--ing Environment (ISEE) reference Model. </title> <institution> National Institute of Standards and Technology, </institution> <month> February </month> <year> 1990. </year>
Reference-contexts: Much of this work has been done by creating reference models including the Conceptual Environment Architecture Reference Model (CEARM) [70], the ECMA Reference Model [23], and the NIST Reference Model <ref> [94] </ref>. [48] used one of these reference models to survey current environment framework research. This survey showed the usefulness of a reference model as a conceptual framework for comparing the capabilities of frameworks. Much of this section is derived from that study.
Reference: [95] <author> Y. Yamamoto. </author> <title> An approach to the generation of software life-cycle support systems. </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <year> 1981. </year> <month> 26 </month>
Reference-contexts: Meta-environments [53, 55, 80] are emerging as a means of constructing SPEs with significantly more powerful constructs than are generally available in programming languages. Meta-environments have also been called generic environments [36] and environment generators <ref> [25, 31, 95] </ref>. The distinction between these terms is somewhat vague. As such, we will use the term meta-environment to include generic environments, environment generators, and other approaches to environment construction. <p> It also supports the specification of a process model which describes the production and use of the documents by collaborating agents. The document formats and process model support multiple forms of group-based or team-based interaction and communication structures within a project and support multiple simultaneous projects. META/GA <ref> [95] </ref> is a Life-Cycle Support System generator based on the specification of the format of information which must be processed in the generated environment. META/GA generated environments support a specific life-cycle approach to the creation of information processing systems.
References-found: 95

