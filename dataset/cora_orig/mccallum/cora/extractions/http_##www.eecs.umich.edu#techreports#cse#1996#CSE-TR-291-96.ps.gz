URL: http://www.eecs.umich.edu/techreports/cse/1996/CSE-TR-291-96.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse96.html
Root-URL: http://www.eecs.umich.edu
Email: fzaher, ashaikh, farnam, kgshing@eecs.umich.edu  
Title: RTCAST: Lightweight Multicast for Real-Time Process Groups  
Author: Tarek Abdelzaher, Anees Shaikh, Farnam Jahanian, and Kang Shin 
Keyword: Key Words real-time process groups, membership protocol, atomic multicast, real-time schedu-lability  
Address: Ann Arbor, Michigan 48109-2122  
Affiliation: Real-time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: We propose a lightweight fault-tolerant multicast and membership service for real-time process groups which may exchange periodic and aperiodic messages. The service supports bounded-time message transport, atomicity, and order for multicasts within a group of communicating processes in the presence of processor crashes and communication failures. It guarantees agreement on membership among the communicating processors, and ensures that membership changes (e.g., resulting from processor joins or departures) are atomic and ordered with respect to multicast messages. We separate the mechanisms for maintaining consistency in a distributed system from those of maintaining real-time guarantees. The multicast and membership service may be used alone to support service that is not time-critical. An additional, separate real-time admission control layer provides on-line schedulability analysis of application traffic to guarantee hard real-time deadlines in a system with dynamically-changing loads. Moreover, we separate the concerns of processor fault-tolerance and link fault-tolerance by providing a protocol for supporting the former, regardless of the actual network topology and technology used to implement the latter. We provide the flexibility of an event-triggered approach with the fast message delivery time of time-triggered protocols, such as TTP [1], where messages are delivered to the application immediately upon reception. This is achieved without compromising agreement, order and atomicity properties. In addition to the design and details of the algorithm, we describe our implementation of the protocol using the x-Kernel protocol architecture running under RT Mach 3.0. The work reported in this paper was supported in part by the Advanced Research Projects Agency, monitored by the US Air Force Rome Laboratory under Grant F30602-95-1-0044. Any opinions, findings, and conclusions or recommendations are those of the authors and do not necessarily reflect the views of the funding agency. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Kopetz and G. Grunsteidl, </author> <title> "TTP a protocol for fault-tolerant real-time systems," </title> <journal> IEEE Computer, </journal> <volume> vol. 27, </volume> <pages> pp. 14-23, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous [2-5] and synchronous <ref> [1, 6, 7] </ref> environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. A process group may be used, for example, to provide active replication of system state so that it is available even when a process fails. <p> The abstraction hides a portable, analyzable, scalable and efficient mechanism for group communication. However, it does not attempt to guarantee atomicity and order in the presence of failures, which may compromise consistency. TTP <ref> [1] </ref> is similar to the protocol presented in this paper in many respects. It uses a time-triggered scheme to provide predictable immediate message delivery, membership service, and redundancy management in fault-tolerant real-time systems. <p> N1 N n N4 N6 of token rotation. showing direction The logical ring The token (indicates current sender) Arbitrary network with bounded delay for every source-destination pair. Some sent message m1 real-time systems is to employ hardware redundancy, for example, as in TTP <ref> [1] </ref> or suggested in [18]. In this scenario at least one operational link will remain and prevent a partition in the case of link failure.
Reference: [2] <author> K. P. Birman, </author> <title> "The process group approach to reliable distributed computing," </title> <journal> Communications of the ACM, </journal> <volume> vol. 36, </volume> <pages> pp. 37-53, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The failure of the current token site will delay a destination's message reception even if both the source and destination are operational. By contrast, RTCast does not acknowledge each message, and need not involve an intermediate node on the path of each message. ISIS <ref> [2, 9] </ref> introduced the concept of virtual synchrony, and integrated a membership protocol into the multicast communication subsystem, whereby membership changes take place in response to communication failure. ISIS implements a causal multicast service, CBCAST using vector clocks [10].
Reference: [3] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki, "Transis: </author> <title> A communication sub-system for high availability," </title> <type> Tech. Rep. TR CS91-13, </type> <institution> Dept. of Computer Science, Hebrew University, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: The ordering task, however, is significantly simplified by assuming a token ring network. In addition to ISIS, several other systems have adopted the notion of fault-tolerant process groups, using similar abstractions to support distributed applications. Some of these include Consul [5], Transis <ref> [3] </ref>, and Horus [4]. A number of systems choose to separate the group membership service from the fault-tolerant multicast service. As a result, the group membership service is concerned only with support for maintaining consistency regarding the membership view.
Reference: [4] <author> R. van Renesse, T. Hickey, and K. Birman, </author> <title> "Design and performance of Horus: A lightweight group communications system," </title> <type> Tech. Rep. </type> <institution> TR94-1442, Dept. of Computer Science, Cornell University, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: The ordering task, however, is significantly simplified by assuming a token ring network. In addition to ISIS, several other systems have adopted the notion of fault-tolerant process groups, using similar abstractions to support distributed applications. Some of these include Consul [5], Transis [3], and Horus <ref> [4] </ref>. A number of systems choose to separate the group membership service from the fault-tolerant multicast service. As a result, the group membership service is concerned only with support for maintaining consistency regarding the membership view.
Reference: [5] <author> S. Mishra, L. Peterson, and R. Schlichting, </author> <title> "Consul: A communication substrate for fault-tolerant distributed programs," </title> <journal> Distributed Systems Engineering Journal, </journal> <volume> vol. 1, </volume> <pages> pp. 87-103, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The ordering task, however, is significantly simplified by assuming a token ring network. In addition to ISIS, several other systems have adopted the notion of fault-tolerant process groups, using similar abstractions to support distributed applications. Some of these include Consul <ref> [5] </ref>, Transis [3], and Horus [4]. A number of systems choose to separate the group membership service from the fault-tolerant multicast service. As a result, the group membership service is concerned only with support for maintaining consistency regarding the membership view.
Reference: [6] <author> Y. Amir, L. Moser, P. Melliar-Smith, D. Agarwal, and P. Ciarfella, </author> <title> "The Totem single-ring ordering and membership protocol," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 13, </volume> <pages> pp. 311-342, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous [2-5] and synchronous <ref> [1, 6, 7] </ref> environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. A process group may be used, for example, to provide active replication of system state so that it is available even when a process fails. <p> There are, however, several protocols that integrate reliable multicast and group membership and also target real-time applications. Some of these protocols are briefly described below. Totem <ref> [6] </ref> bears closer resemblance to the proposed protocol. It is based on a token ring, and guarantees safe delivery of messages within two token rounds (in the absence of message loss). <p> Each processor in the group either receives each multicast, or crashes. It is no longer required for a processor to know that every other processor has received the message before it can deliver it to the application (for example, as done in Totem's safe delivery <ref> [6] </ref>). Instead, each receiver may deliver the message immediately upon receipt, and be guaranteed that processors which do not receive that message will leave the group, thus preserving atomicty among (remaining) group members. Membership changes are communicated exclusively by membership change messages using our multicast mechanism.
Reference: [7] <author> F. Cristian, B. Dancy, and J. Dehn, </author> <title> "Fault-tolerance in the advanced automation system," </title> <booktitle> in Proc. of Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 6-17, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Process groups are a widely-studied paradigm for designing dependable distributed systems in both asynchronous [2-5] and synchronous <ref> [1, 6, 7] </ref> environments. In this approach, a distributed system is structured as a group of cooperating processes which provide service to the application. A process group may be used, for example, to provide active replication of system state so that it is available even when a process fails.
Reference: [8] <author> J.-M. Chang and N. Maxemchuk, </author> <title> "Reliable broadcast protocols," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 2, </volume> <pages> pp. 251-273, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: One of the earliest of these was the work done by Chang and Maxemchuk <ref> [8] </ref>. They proposed a token based algorithm for a group of communicating processes where each sender sends its messages to a token site which orders the received messages and broadcasts acknowledgments. Destinations receive the acknowledgments and deliver the corresponding messages in the order specified by the current token site.
Reference: [9] <author> K. Birman, A. Schiper, and P. Stephenson, </author> <title> "Lightweight causal and atomic group multicast," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 9, </volume> <pages> pp. 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The failure of the current token site will delay a destination's message reception even if both the source and destination are operational. By contrast, RTCast does not acknowledge each message, and need not involve an intermediate node on the path of each message. ISIS <ref> [2, 9] </ref> introduced the concept of virtual synchrony, and integrated a membership protocol into the multicast communication subsystem, whereby membership changes take place in response to communication failure. ISIS implements a causal multicast service, CBCAST using vector clocks [10].
Reference: [10] <author> L. Lamport, </author> <title> "Time, clocks, and the ordering of events in a distributed system," </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, </volume> <pages> pp. 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: ISIS [2, 9] introduced the concept of virtual synchrony, and integrated a membership protocol into the multicast communication subsystem, whereby membership changes take place in response to communication failure. ISIS implements a causal multicast service, CBCAST using vector clocks <ref> [10] </ref>. On top of CBCAST, an ordered atomic multicast, ABCAST, is implemented using an idea similar to that of Chang and Maxemchuk. A token holder orders received ABCAST messages and has the other members of the group deliver them in the same order. <p> If this number matches M j in the current receiver's message sequence vector then the receiver is assured that all messages sent by N j before it was eliminated have been 3 This is different from using vector clocks <ref> [10] </ref> where a vector is communicated in each message. In our scheme, the message carries only its sequence number and sender id. 4 We know who the sender is because we know from whom a message is missing 10 received, and hence the receiver remains in the group.
Reference: [11] <author> F. Jahanian, S. Fakhouri, and R. Rajkumar, </author> <title> "Processor group membership protocols: Specification, </title> <booktitle> design, and implementation," in Proc. 12th Symposium on Reliable Distributed Systems, </booktitle> <pages> pp. 2-11, </pages> <year> 1993. </year>
Reference-contexts: Our approach, along with several others described later, however, closely integrates the fault-tolerant ordered multicast and the group membership protocols. Achieving consistent membership when the group changes, is therefore no different than achieving consistent state in each of the processes. The Strong Group Membership protocol <ref> [11] </ref>, for example, performs atomic ordered group membership changes using a two phase commit protocol whereby a leader first multicasts a prepare to commit message, and then multicasts a commit message to install the change after receiving an acknowledgment from each group member.
Reference: [12] <author> L. Rodrigues, P. Ver issimo, and J. Rufino, </author> <title> "A low-level processor group membership protocol for LANs," </title> <booktitle> in Proc. Int. Conf. on Distributed Computer Systems, </booktitle> <pages> pp. 541-550, </pages> <year> 1993. </year>
Reference-contexts: The MGS protocol <ref> [12] </ref> for processor group membership performs atomic ordered membership updates on three phases.
Reference: [13] <author> Y. Amir, D. Dolev, and S. K. aned D. Malki, </author> <title> "Membership algorithms for multicast communication groups," </title> <booktitle> in Proc. 6th International Workshop on Distributed Algorithms, no. 647 in Lecture Notes in Computer Science, (Haifa, Israel), </booktitle> <pages> pp. 292-312, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: The first phase requests/acquires a lock (by the group leader) on the membership state table of each member, the next sends the new data and collects acknowledgments, and the third phase retransmits changes to processors from which acknowledgments are missing. Additional work on group membership protocols appears in <ref> [13] </ref>, [14], and [15]. Common to the above mentioned protocols, whether strictly group membership or combining multicast and group membership, is that they do not explicitly consider the needs of hard real 4 time applications.
Reference: [14] <author> F. Cristian, </author> <title> "Reaching agreement on processor-group membership in synchronous distributed systems," </title> <journal> Distributed Computing, </journal> <volume> vol. 4, </volume> <pages> pp. 175-187, </pages> <year> 1991. </year>
Reference-contexts: The first phase requests/acquires a lock (by the group leader) on the membership state table of each member, the next sends the new data and collects acknowledgments, and the third phase retransmits changes to processors from which acknowledgments are missing. Additional work on group membership protocols appears in [13], <ref> [14] </ref>, and [15]. Common to the above mentioned protocols, whether strictly group membership or combining multicast and group membership, is that they do not explicitly consider the needs of hard real 4 time applications.
Reference: [15] <author> A. M. Ricciardi and K. P. Birman, </author> <title> "Process membership in asynchronous environments," </title> <type> Tech. Rep. </type> <institution> TR93-1328, Dept. of Computer Science, Cornell University, </institution> <month> February </month> <year> 1993. </year> <month> 22 </month>
Reference-contexts: Additional work on group membership protocols appears in [13], [14], and <ref> [15] </ref>. Common to the above mentioned protocols, whether strictly group membership or combining multicast and group membership, is that they do not explicitly consider the needs of hard real 4 time applications.
Reference: [16] <author> L. Moser and P. Melliar-Smith, </author> <title> "Probabalistic bounds on message delivery for the totem single-ring protocol," </title> <booktitle> in Proc. IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 238-248, </pages> <year> 1994. </year>
Reference-contexts: Totem addresses timing constraints by providing probabilistic bounds on message delay through analysis based on message loss probability. When message loss probability is very low, safe delivery within a predictable time is probable <ref> [16] </ref>. RTCast, on the other hand, achieves atomicity and order within a single phase. Messages are delivered to the application as soon as they are received in order. They may also convey membership changes for use by the protocol. No acknowledgments are needed.
Reference: [17] <author> R. Rajkumar, M. Gagliardi, and L. Sha, </author> <title> "The real-time publisher/subscriber inter-process communication model for distributed real-time systems: </title> <booktitle> Design and implementation," in Proc. Real Time Technology and Applications Symposium, </booktitle> <address> (Chicago, IL), </address> <pages> pp. 66-75, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: A more formal argument is given in the Appendix. Rajkumar et. al. <ref> [17] </ref> present an elegant publisher/subscriber model for distributed real-time systems. It provides a simple user interface for publishing messages on some logical "channel" (identified by a corresponding logical handle), as well as for subscription to selected channels as needed by each application.
Reference: [18] <author> B. Chen, S. Kamat, and W. Zhao, </author> <title> "Fault-tolerant real-time communication in FDDI-based networks," </title> <booktitle> in Proc. 16th IEEE Real-Time Systems Symposium, (Pisa, Italy), </booktitle> <pages> pp. 141-150, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: This might occur in the case of receiver buffer overflow, or message corruption on one of many links in an arbitrary topology network. Finally, a research effort complementary to our efforts is reported in <ref> [18] </ref>. While we consider fault tolerance with respect to processor failure, we do not suggest any particular mechanism for implementing fault-tolerant message communication. For example, we do not specify whether or not some form of redundancy is used to tolerate link failures. <p> N1 N n N4 N6 of token rotation. showing direction The logical ring The token (indicates current sender) Arbitrary network with bounded delay for every source-destination pair. Some sent message m1 real-time systems is to employ hardware redundancy, for example, as in TTP [1] or suggested in <ref> [18] </ref>. In this scenario at least one operational link will remain and prevent a partition in the case of link failure.
Reference: [19] <author> D. Dolev, C. Dwork, and L. Stockmeyer, </author> <title> "On the minimal synchronism needed for distributed consensus," </title> <journal> Journal of the ACM, </journal> <volume> vol. 34, </volume> <pages> pp. 77-97, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: However, since we allow both message loss and processor crashes, solving the consensus problem is impossible even in the presence of synchronized clocks <ref> [19, 20] </ref>. Instead, we formulate the problem as one of group membership. We employ a (deterministic) processor crash detection algorithm which occasionally eliminates a correct processor from the group so that agreement is reached in finite time among those remaining.
Reference: [20] <author> J. Turek and D. Shasha, </author> <title> "The many faces of consensus in distributed systems," </title> <journal> IEEE Computer, </journal> <volume> vol. 25, </volume> <pages> pp. 8-17, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: However, since we allow both message loss and processor crashes, solving the consensus problem is impossible even in the presence of synchronized clocks <ref> [19, 20] </ref>. Instead, we formulate the problem as one of group membership. We employ a (deterministic) processor crash detection algorithm which occasionally eliminates a correct processor from the group so that agreement is reached in finite time among those remaining.
Reference: [21] <author> N. C. Hutchinson and L. L. Peterson, </author> <title> "The x-Kernel: An architecture for implementing network protocols," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, </volume> <pages> pp. 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: hardware we presently circumvent this problem by preventing simultaneous joins. 17 RTCast RTCast ClockSync Application Level Retransmission ACSA x-kernel transport layer x-kernel transport layer Full Configuration (a) Minimal Configuration. (b) 6.1 Protocol stack layers We implement the communication service as a protocol developed with x -Kernel 3.2 protocol implementation environment <ref> [21] </ref>. The protocol stack is shown in Figure 8. Each box represents a separate protocol layer. The primary advantage of using x -Kernel is the ability to easily reconfigure the protocol stack according to application needs by adding or removing corresponding protocols.

References-found: 21

