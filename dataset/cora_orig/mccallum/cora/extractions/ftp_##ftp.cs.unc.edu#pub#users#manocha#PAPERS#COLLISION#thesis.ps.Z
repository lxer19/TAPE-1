URL: ftp://ftp.cs.unc.edu/pub/users/manocha/PAPERS/COLLISION/thesis.ps.Z
Refering-URL: http://www.cs.unc.edu/~lin/papers.html
Root-URL: http://www.cs.unc.edu
Title: Efficient Collision Detection for Animation and Robotics  
Author: Ming C. Lin 
Address: Berkeley, CA,  
Affiliation: Department of Electrical Engineering and Computer Science University of California, Berkeley  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> L. E. Andersson and N. F. Steward. </author> <title> Maximal distance for robotic simulation: the convex case. </title> <journal> Journal of Optimization Theory and Applications, 57(No. </journal> 2):215-222, 1988. 
Reference-contexts: Cameron and Culley further discussed the problem of interpenetration and 8 provided the intersection measurement for the use in a penalty function for robot motion planning [13]. The classical non-linear programming approaches for this problem are presented in <ref> [1] </ref> and [9]. <p> The Bezout bound for the first three equations is N = n 2 (2n 2). * Boundary Intersection : Such intersections lie on the boundary curve of one of the two surfaces. Say we are given a Bezier surface, defined over the domain, (s; t) 2 <ref> [0; 1] </ref> fi [0; 1], we obtain the boundary curves by substituting s or t to be 0 or 1. The resulting problem reduces to solving the equations: F (s; 1) = G (u; v) (4:7) Other possible boundary intersections can be computed in a similar manner. <p> The Bezout bound for the first three equations is N = n 2 (2n 2). * Boundary Intersection : Such intersections lie on the boundary curve of one of the two surfaces. Say we are given a Bezier surface, defined over the domain, (s; t) 2 <ref> [0; 1] </ref> fi [0; 1], we obtain the boundary curves by substituting s or t to be 0 or 1. The resulting problem reduces to solving the equations: F (s; 1) = G (u; v) (4:7) Other possible boundary intersections can be computed in a similar manner.
Reference: [2] <author> C. Bajaj and T. Dey. </author> <title> Convex decomposition of polyhedra and robustness. </title> <journal> SIAM J. of Comput., </journal> <volume> (No. </volume> 2):339-364, 1992. 
Reference-contexts: nonconvex objects, we rely on subdivision into convex pieces, which unfortunately, may take O ((n + r 2 )logr) time to partition a nondegenerate simple polytope of genus 0, where n is the number of vertices and r is the number of reflex edges of the original 23 nonconvex object <ref> [23, 2] </ref>. In general, a polytope of n vertices can always be partitioned into O (n 2 ) convex pieces [22].
Reference: [3] <author> D. Baraff. </author> <title> Curved surfaces and coherence for non-penetrating rigid body simulation. </title> <journal> ACM Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 19-28, </pages> <year> 1990. </year>
Reference-contexts: Collision detection is usually coupled with an appropriate response to the collision. The collision response is generally application dependent and many algorithms have been proposed for different environments like motion control in animation by Moore and Wilhelm [63], physical simulations by Baraff, Hahn, Pentland and Williams <ref> [3, 43, 70] </ref> or molecular modeling by Turk [85]. Since simplicity and ease of implementation is considered as one of the important factors for any practical algorithm in the computer graphics community, most collision detection algorithms used for computer animation are rather simple but not necessary efficient. <p> The im 4 portance of collision detection extends to several areas like robot motion planning, dynamic simulation, virtual reality applications and it has been extensively studied in robotics, computational geometry, and computer graphics for more than a decade <ref> [3, 4, 11, 13, 17, 41, 43, 45, 51, 53, 63] </ref>. Yet, there is no practical, efficient algorithm available yet for general geometric models to perform collision detection in real time. Recently, Pentland has listed collision detection as one of the major bottlenecks towards real time virtual environment simulations [69]. <p> The performance of these algorithms shows great promise for real-time robotics simulation and computer animation. 1.1 Previous Work Collision detection and the related problem of determining minimum distance has a long history. It has been considered in both static and dynamic (moving objects) versions in <ref> [3] </ref>, [11], [13], [17], [26], [27], [39], [40], [41], [65]. One of the earlier survey on "clash detection" was presented by Cameron [12]. He mentioned three different approaches for dynamic collision detection. <p> In applications involving dynamic simulations and physical motion, geomet 7 ric coherence has been utilized to devise algorithms based on local features <ref> [3] </ref>. This has significantly improved the performance of collision detection algorithms in dynamic environments. Baraff uses cached edges and faces to find a separating plane between two convex polytopes [3]. <p> applications involving dynamic simulations and physical motion, geomet 7 ric coherence has been utilized to devise algorithms based on local features <ref> [3] </ref>. This has significantly improved the performance of collision detection algorithms in dynamic environments. Baraff uses cached edges and faces to find a separating plane between two convex polytopes [3]. <p> Besides its restriction to implicits only, this algorithm has a drawback in terms of robustness, as it uses point samples. A detailed explanation of these problems are described in [29]. Baraff has also presented an algorithm for finding closest points between two convex closed objects only <ref> [3] </ref>. In the related problem of computing the minimum separation between two objects, Gilbert and his collaborators computed the minimum distance between two convex objects with an expected linear time algorithm and used it for collision detection. <p> However, we are only interested in the solutions in the domain of interest (since each surface is defined on a subset of the real plane). Baraff has used a formulation similar to (4.1)to keep track of closest points between closed convex surfaces <ref> [3] </ref> based on local optimization routines. The main problem is finding a solution to these equations for the initial configuration.
Reference: [4] <author> D. Baraff. </author> <title> Issues on computing contact forces for non-penetrating rigid bodies. </title> <journal> Algorithmica, </journal> <volume> Vol. 10(2-4):292-352, </volume> <month> Aug/Sept/Oct </month> <year> 1993. </year>
Reference-contexts: The im 4 portance of collision detection extends to several areas like robot motion planning, dynamic simulation, virtual reality applications and it has been extensively studied in robotics, computational geometry, and computer graphics for more than a decade <ref> [3, 4, 11, 13, 17, 41, 43, 45, 51, 53, 63] </ref>. Yet, there is no practical, efficient algorithm available yet for general geometric models to perform collision detection in real time. Recently, Pentland has listed collision detection as one of the major bottlenecks towards real time virtual environment simulations [69]. <p> It contributes to realistic portrayal of autonomous movements of all virtual objects in the synthetic environments. Most dynamic simulators <ref> [4, 7, 25, 88, 89] </ref> make simplification of models in simulating the physics of translating and rotating objects, and mostly on frictionless impacts. Recently, Keller applied Routh's frictional impact equations [75] to a few simplified cases with numerous assumptions [49].
Reference: [5] <author> David Baraff and Andrew Witkin. </author> <title> Dynamic simulation of non-penetrating flexible bodies. </title> <journal> Computer Graphics, </journal> <volume> 26(2) </volume> <pages> 303-308, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: However, this approach is computationally too expensive. Unless we use specialized parallel machines to simulate the motions, its speed is not satisfactory. Baraff and Witkin use polyhedral approximation to handle the deformable objects <ref> [5] </ref> for the purpose of collision detection. If the model is very refined, this approach may yield reasonable results; however, even with the use of coherence based on a culling step to reduce the number of the polygon-polygon intersection tests, the resulting algorithm still takes longer than linear time.
Reference: [6] <author> J. Barraquand, B. Langlois, and J-C. Latombe. </author> <title> Robot motion planning with many degrees of freedom and dynamic constraints. </title> <booktitle> In Proceedings 5th Int. Symp Robotics Research, </booktitle> <address> Tokyo, Japan, </address> <year> 1989. </year>
Reference-contexts: This work builds on a considerable volume of work in both global motion planning methods [18] [54], [73], [78], and local planners, [50]. Our method shares a common theme with the work of Barraquand and Latombe <ref> [6] </ref> in that it attempts to use a local potential field planner for speed with some procedure for escaping local maxima. <p> But whereas Barraquand and Latombe's method is a local method made global, we have taken a global method (the Roadmap Algorithm) and found a local opportunistic way to compute it. Although our starting point was completely different, there are some other similarities with <ref> [6] </ref>. Our "freeways" resemble the valleys intuitively described in [6]. But the main difference between our method and the method in [6] is that we have a guaranteed (and reasonably efficient) method of escaping local potential extremal points and that our potential function is computed in the configuration space. <p> Although our starting point was completely different, there are some other similarities with <ref> [6] </ref>. Our "freeways" resemble the valleys intuitively described in [6]. But the main difference between our method and the method in [6] is that we have a guaranteed (and reasonably efficient) method of escaping local potential extremal points and that our potential function is computed in the configuration space. <p> Although our starting point was completely different, there are some other similarities with <ref> [6] </ref>. Our "freeways" resemble the valleys intuitively described in [6]. But the main difference between our method and the method in [6] is that we have a guaranteed (and reasonably efficient) method of escaping local potential extremal points and that our potential function is computed in the configuration space. The chapter is organized as follows: Section 6.2 contains a simple and general description of roadmaps. <p> But n k may still be too large for many applications, and in many cases the free space is much simpler than its worst case complexity, which is O (n k ). We would like to exploit this simplicity to the maximum extent possible. The results of <ref> [6] </ref> suggest that in practice free space is usually much simpler than the worst case bounds. What we will describe is a method aimed at getting a minimal description of the connectivity of a particular free space. The original description of roadmaps is quite technical and intricate.
Reference: [7] <author> R. Barzel and A. Barr. </author> <title> A modeling system based on dynamic constraints. </title> <journal> ACM Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 31-39, </pages> <year> 1988. </year>
Reference-contexts: It contributes to realistic portrayal of autonomous movements of all virtual objects in the synthetic environments. Most dynamic simulators <ref> [4, 7, 25, 88, 89] </ref> make simplification of models in simulating the physics of translating and rotating objects, and mostly on frictionless impacts. Recently, Keller applied Routh's frictional impact equations [75] to a few simplified cases with numerous assumptions [49].
Reference: [8] <author> D. N. Bernstein. </author> <title> The number of roots of a system of equations. </title> <journal> Funktsional'nyi Analiz i Ego Prilozheniya, </journal> <volume> 9(3) </volume> <pages> 1-4, </pages> <month> Jul-Sep </month> <year> 1975. </year> <month> 128 </month>
Reference-contexts: Therefore, the Bezout bound of the resulting system can be as high as N = (2n 2) 2 n 4 . In general, if the system of equations is sparse, we can get a tight bound with Bernstein bound <ref> [8] </ref>. The Bernstein bound for Eqn. 4.4 is n 2 (n 2 + 3)(n 1) 2 . Canny and Emiris calculate the Bernstein bounds efficiently by using sparse mixed resultant formulation [16].
Reference: [9] <author> J. E. Bobrow. </author> <title> A direct minimization approach for obtaining distance between convex polyhedra. </title> <journal> International Journal of Robotics Research, 8(No. </journal> 3):65-67, 1989. 
Reference-contexts: Cameron and Culley further discussed the problem of interpenetration and 8 provided the intersection measurement for the use in a penalty function for robot motion planning [13]. The classical non-linear programming approaches for this problem are presented in [1] and <ref> [9] </ref>.
Reference: [10] <author> W. Bouma and Jr. G. Vanecek. </author> <title> Collision detection and analysis in a physically based simulation. </title> <booktitle> In Proceeding of the Seconde Eurographics Workshop on Animation and Simulation, 1992. </booktitle> <address> Vienna Austria. </address>
Reference-contexts: Each cube can be divided into 8 smaller cubes if necessary. So, each node in the tree has 8 children (leaves). 87 Another modified version of BSP-Tree proposed by Vanecek [37] is a multidimensional space partitioning tree called Brep-Index. This tree structure is used for collision detection <ref> [10] </ref> between moving objects in a system called Proxima developed at Prudue University. The problem with tree structures is similar to that of using 2-d interval tree that its update (insertion and deletion) is inflexible and cumbersome, especially for a large tree.
Reference: [11] <author> J. W. Boyse. </author> <title> Interference detection among solids and surfaces. </title> <journal> Comm. ACM, </journal> <volume> 22(1) </volume> <pages> 3-9, </pages> <year> 1979. </year>
Reference-contexts: The im 4 portance of collision detection extends to several areas like robot motion planning, dynamic simulation, virtual reality applications and it has been extensively studied in robotics, computational geometry, and computer graphics for more than a decade <ref> [3, 4, 11, 13, 17, 41, 43, 45, 51, 53, 63] </ref>. Yet, there is no practical, efficient algorithm available yet for general geometric models to perform collision detection in real time. Recently, Pentland has listed collision detection as one of the major bottlenecks towards real time virtual environment simulations [69]. <p> The performance of these algorithms shows great promise for real-time robotics simulation and computer animation. 1.1 Previous Work Collision detection and the related problem of determining minimum distance has a long history. It has been considered in both static and dynamic (moving objects) versions in [3], <ref> [11] </ref>, [13], [17], [26], [27], [39], [40], [41], [65]. One of the earlier survey on "clash detection" was presented by Cameron [12]. He mentioned three different approaches for dynamic collision detection. <p> The capability of determining possible contacts in dynamic domains is important for computer animation of moving objects. We would like an animator to perform impact determination by itself without high computational costs or much coding efforts. Some algorithms (such as Boyse's <ref> [11] </ref> and Canny's [17]) solve the problem in more generality than is necessary for computer animation; while others do not easily produce the exact collision points and contact normal direction for collision response [34].
Reference: [12] <author> S. A. Cameron. </author> <title> A study of the clash detection problem in robotics. </title> <booktitle> Proc. IEEE ICRA, </booktitle> <pages> pages pp. 488-493, </pages> <year> 1985. </year>
Reference-contexts: It has been considered in both static and dynamic (moving objects) versions in [3], [11], [13], [17], [26], [27], [39], [40], [41], [65]. One of the earlier survey on "clash detection" was presented by Cameron <ref> [12] </ref>. He mentioned three different approaches for dynamic collision detection. One of them is to perform static collision detection repetitively at each discrete time steps, 5 but it is possible to miss a collision between time steps if the step size is too large.
Reference: [13] <author> S. A. Cameron and R. K. Culley. </author> <title> Determining the minimum translational distance between two convex polyhedra. </title> <booktitle> Proc. IEEE ICRA, </booktitle> <pages> pages pp. 591-596, </pages> <year> 1986. </year>
Reference-contexts: The im 4 portance of collision detection extends to several areas like robot motion planning, dynamic simulation, virtual reality applications and it has been extensively studied in robotics, computational geometry, and computer graphics for more than a decade <ref> [3, 4, 11, 13, 17, 41, 43, 45, 51, 53, 63] </ref>. Yet, there is no practical, efficient algorithm available yet for general geometric models to perform collision detection in real time. Recently, Pentland has listed collision detection as one of the major bottlenecks towards real time virtual environment simulations [69]. <p> The performance of these algorithms shows great promise for real-time robotics simulation and computer animation. 1.1 Previous Work Collision detection and the related problem of determining minimum distance has a long history. It has been considered in both static and dynamic (moving objects) versions in [3], [11], <ref> [13] </ref>, [17], [26], [27], [39], [40], [41], [65]. One of the earlier survey on "clash detection" was presented by Cameron [12]. He mentioned three different approaches for dynamic collision detection. <p> Cameron and Culley further discussed the problem of interpenetration and 8 provided the intersection measurement for the use in a penalty function for robot motion planning <ref> [13] </ref>. The classical non-linear programming approaches for this problem are presented in [1] and [9]. <p> By comparing the number of arithmetic operations in the previous implemented algorithms, we believe that our implementation gives better performance and probably is the fastest implemented collision detection algorithm. (Please see [65], <ref> [13] </ref>, [17], [40], [39], [38], [72], and [90].) This is especially true in a dynamic environment where the trajectories are not known (nor are they in closed form even between impacts, but are given by elliptic integrals).
Reference: [14] <author> J. Canny. </author> <title> Computing roadmaps of general semi-algebraic sets. </title> <booktitle> In AAECC-91, </booktitle> <pages> pages 94-107, </pages> <year> 1991. </year>
Reference-contexts: are described in some detail in [18] where it is shown that they can be computed in time O (n k log n (d O (n 2 ) )) for a robot with k degrees of freedom, and where free space is defined by n polynomial constraints of degree d <ref> [14] </ref>. But n k may still be too large for many applications, and in many cases the free space is much simpler than its worst case complexity, which is O (n k ). We would like to exploit this simplicity to the maximum extent possible. <p> This is certainly always the case for any practical robot working in a confined environment, such as industrial robot manipulators, mobile robots, etc. If it is not bounded, there are technical ways to reduce to a bounded problem, see for example <ref> [14] </ref>. The set of free configurations is also assumed to be closed. The closed and bounded assumptions ensure that the distance function will attain locally maximal values on every connected component of free space.
Reference: [15] <author> J. Canny and B. Donald. </author> <title> Simplified voronoi diagrams. </title> <journal> Discret Comput. Geometry, </journal> <pages> pages 219-236, </pages> <year> 1988. </year>
Reference-contexts: Therefore, the Voronoi diagram contains all the information necessary to solve the proximity problems given a set of points in R 2 . A similar idea applies to the same problem in three-dimensional or higher dimensional space <ref> [15, 32] </ref>. The extension of the Voronoi diagram to higher dimensional features (instead of points) is called the generalized Voronoi diagram, i.e. the set of points closest to a feature, e.g. that of a polyhedron. In general, the generalized Voronoi diagram has quadratic surface boundaries in it.
Reference: [16] <author> J. Canny and I. Emiris. </author> <title> An efficient algorithm for the sparse mixed resultant. </title> <editor> In G. Cohen, T. Mora, and O. Moreno, editors, </editor> <booktitle> Proc. 10th Intern. Symp. on Applied Algebra, Algebraic Algorithms and Error-Correcting Codes, </booktitle> <pages> pages 89-104. </pages> <publisher> Springer Verlag, </publisher> <month> May </month> <year> 1993. </year> <note> Lect. Notes in Comp. Science 263. </note>
Reference-contexts: In general, if the system of equations is sparse, we can get a tight bound with Bernstein bound [8]. The Bernstein bound for Eqn. 4.4 is n 2 (n 2 + 3)(n 1) 2 . Canny and Emiris calculate the Bernstein bounds efficiently by using sparse mixed resultant formulation <ref> [16] </ref>. For example, the Bernstein bounds 2 for the case of n = 2; 3; 4; 5; 6; 7; 8; 9 are 28; 432; 2736; 11200; 35100; 91728; 210112; 435456, while the Bezout bounds are 64; 1296; 9216; 40000; 129600; 345744; respectively.
Reference: [17] <author> J. F. Canny. </author> <title> Collision detection for moving polyhedra. </title> <journal> IEEE Trans. PAMI, </journal> <volume> 8:pp. </volume> <pages> 200-209, </pages> <year> 1986. </year>
Reference-contexts: The im 4 portance of collision detection extends to several areas like robot motion planning, dynamic simulation, virtual reality applications and it has been extensively studied in robotics, computational geometry, and computer graphics for more than a decade <ref> [3, 4, 11, 13, 17, 41, 43, 45, 51, 53, 63] </ref>. Yet, there is no practical, efficient algorithm available yet for general geometric models to perform collision detection in real time. Recently, Pentland has listed collision detection as one of the major bottlenecks towards real time virtual environment simulations [69]. <p> The performance of these algorithms shows great promise for real-time robotics simulation and computer animation. 1.1 Previous Work Collision detection and the related problem of determining minimum distance has a long history. It has been considered in both static and dynamic (moving objects) versions in [3], [11], [13], <ref> [17] </ref>, [26], [27], [39], [40], [41], [65]. One of the earlier survey on "clash detection" was presented by Cameron [12]. He mentioned three different approaches for dynamic collision detection. <p> The capability of determining possible contacts in dynamic domains is important for computer animation of moving objects. We would like an animator to perform impact determination by itself without high computational costs or much coding efforts. Some algorithms (such as Boyse's [11] and Canny's <ref> [17] </ref>) solve the problem in more generality than is necessary for computer animation; while others do not easily produce the exact collision points and contact normal direction for collision response [34]. <p> By comparing the number of arithmetic operations in the previous implemented algorithms, we believe that our implementation gives better performance and probably is the fastest implemented collision detection algorithm. (Please see [65], [13], <ref> [17] </ref>, [40], [39], [38], [72], and [90].) This is especially true in a dynamic environment where the trajectories are not known (nor are they in closed form even between impacts, but are given by elliptic integrals). <p> Please refer to <ref> [17] </ref> for more details. If the path that each object travels is not known in advance, then we can calculate a lower bound on collision time.
Reference: [18] <author> J. F. Canny. </author> <title> The Complexity of Robot Motion Planning. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year> <month> 129 </month>
Reference-contexts: 90 curves (or bridges) are constructed. 6.1 Background There have been two major approaches to motion planning for manipulators, (i) local methods, such as artificial potential field methods [50], which are usually fast but are not guaranteed to find a path, and (ii) global methods, like the first Roadmap Algorithm <ref> [18] </ref>, which is guaranteed to find a path but may spend a long time doing it. In this chapter, we present an algorithm which has characteristics of both. Our method is an incremental construction of a skeleton of free-space. <p> The skeleton we define here is a subset of a roadmap (in the sense of <ref> [18] </ref>) of this hypersurface. This work builds on a considerable volume of work in both global motion planning methods [18] [54], [73], [78], and local planners, [50]. <p> The skeleton we define here is a subset of a roadmap (in the sense of <ref> [18] </ref>) of this hypersurface. This work builds on a considerable volume of work in both global motion planning methods [18] [54], [73], [78], and local planners, [50]. Our method shares a common theme with the work of Barraquand and Latombe [6] in that it attempts to use a local potential field planner for speed with some procedure for escaping local maxima. <p> The set of configurations where the robot overlaps some obstacle is the configuration space obstacle CO, and the complement of CO is the set of free (non-overlapping) configurations F P . As described in <ref> [18] </ref>, F P is bounded by algebraic hypersurfaces in the parameters t i after the standard substitution t i = tan ( i 2 ). This result is needed for the complexity bounds in [18] but we will not need it here. <p> As described in <ref> [18] </ref>, F P is bounded by algebraic hypersurfaces in the parameters t i after the standard substitution t i = tan ( i 2 ). This result is needed for the complexity bounds in [18] but we will not need it here. A roadmap is a one-dimensional subset of F P that is guaranteed to be connected within each connected component of F P . Roadmaps are described in some detail in [18] where it is shown that they can be computed in time O <p> This result is needed for the complexity bounds in <ref> [18] </ref> but we will not need it here. A roadmap is a one-dimensional subset of F P that is guaranteed to be connected within each connected component of F P . Roadmaps are described in some detail in [18] where it is shown that they can be computed in time O (n k log n (d O (n 2 ) )) for a robot with k degrees of freedom, and where free space is defined by n polynomial constraints of degree d [14]. <p> A maximal connected set Cj (a;b) F P j (a;b) is a channel if every subset Cj (e;f) is connected for (e; f ) (a; b). 6.2.2 The General Roadmap Now to the heart of the method. A roadmap has two components: (i) Freeways (called silhouette curves in <ref> [18] </ref>) and (ii) Bridges (called linking curves in [18]). A freeway is a connected one-dimensional subset of a channel that forms a backbone for the channel. The key properties of a freeway are that it should span the channel, and be continuable into adjacent channels. <p> A roadmap has two components: (i) Freeways (called silhouette curves in <ref> [18] </ref>) and (ii) Bridges (called linking curves in [18]). A freeway is a connected one-dimensional subset of a channel that forms a backbone for the channel. The key properties of a freeway are that it should span the channel, and be continuable into adjacent channels. <p> In the original roadmap algorithm, linking curves had to be defined recursively, because it is not possible to hill-climb to a maximum with an algebraic curve. Another difference is that the freeways do not necessarily lie near the boundary of free space as they did in <ref> [18] </ref>. In our present implementation we are in fact using maximum clearance freeways. But the most important difference is that we now only enumerate true split or join points. <p> This is true for almost all practical situations: most obstacles have a reasonably large interior space that a small perturbation will not affect much of the obstacle configuration space. Based on the transversality condition of general position assumptions in <ref> [18] </ref>, the interesting critical points can be computed as follows. Let S be the set of equations used to calculate the critical points. The set S is defined by inequalities, and its boundary is a union of surfaces of various dimensions. <p> g = 0 (6:2) where l is the number of equations which are zero on S ff , the x 2 ; : : : ; x k are coordinates which are orthogonal to x 1 , and * is an infinitesimal that is used to simplify the computation (see <ref> [18] </ref>). It can be shown [21] that the solutions of interest can be recovered from the lowest degree coefficient in * of the resultant of this system. This normally involves 99 computing a symbolic determinant which is a polynomial in * [57]. <p> Let u and v denote two coordinate axes, the Roadmap 101 Algorithm fixes v and then follows the extremal points in direction u as the value of v varies. But, the new algorithm differs from the original roadmap algorithm <ref> [18] </ref> in the following respects: * It does not always construct the entire roadmap * In the new algorithm, v = x i , where x i is one of the CS coordinates while u = h, where h is the height of the potential function. <p> After several iterations of computing the gradient of the summation in Eqn.6.4, the solution path will eventually be smooth and locally optimal. 6.5 Proof of Completeness for an Opportunistic Global Path Planner Careful completeness proofs for the roadmap algorithm are given in <ref> [18] </ref> and [19]. These proofs apply with very slight modification to the roadmap algorithm that we describe in this paper. The roadmap of [18] is the set of extremal points in a certain direction in free space. Therefore it hugs the boundary of free space. <p> will eventually be smooth and locally optimal. 6.5 Proof of Completeness for an Opportunistic Global Path Planner Careful completeness proofs for the roadmap algorithm are given in <ref> [18] </ref> and [19]. These proofs apply with very slight modification to the roadmap algorithm that we describe in this paper. The roadmap of [18] is the set of extremal points in a certain direction in free space. Therefore it hugs the boundary of free space. The roadmap described in this paper follows extrema of the distance function, and therefore stays well clear of obstacles (except at critical points). <p> This is a surface S in R (n+1) and if we follow the extrema of distance on this surface, the roadmap of this paper is exactly a roadmap in the sense of <ref> [18] </ref> and [19]. The silhouette curves of [18] correspond to the freeway curves of this paper, and the linking curves correspond to bridges. <p> This is a surface S in R (n+1) and if we follow the extrema of distance on this surface, the roadmap of this paper is exactly a roadmap in the sense of <ref> [18] </ref> and [19]. The silhouette curves of [18] correspond to the freeway curves of this paper, and the linking curves correspond to bridges. Recall the basic property required of roadmaps: Definition A subset of R of a set S satisfies the roadmap condition if every connected component of S contains a single connected component of R. <p> As mentioned earlier, the algorithm is no longer recursive in calculating the critical points and linking curves (bridges) as in <ref> [18] </ref>, the complexity bound calculated in [18] does not apply here. 6.7 Geometric Relations between Critical Points and Contact Constraints Let n be the number of obstacle features in the environment and the robot has constant complexity. Free space F P is bordered by O (n) constraint surfaces. <p> As mentioned earlier, the algorithm is no longer recursive in calculating the critical points and linking curves (bridges) as in <ref> [18] </ref>, the complexity bound calculated in [18] does not apply here. 6.7 Geometric Relations between Critical Points and Contact Constraints Let n be the number of obstacle features in the environment and the robot has constant complexity. Free space F P is bordered by O (n) constraint surfaces. <p> See <ref> [18] </ref> for the definition of O e i ;f j . For a fixed robot complexity, the number of branches for the disjunctive tree grows linearly w.r.t. the environment complexity. Each O e i ;f j has constant size, if the polyhedron is preprocessed (described in Chapter 3).
Reference: [19] <author> J. F. Canny. </author> <title> Constructing roadmaps of semi-algebraic sets I: Completeness. </title> <journal> Artificial Intelligence, </journal> <volume> 37 </volume> <pages> 203-222, </pages> <year> 1988. </year>
Reference-contexts: After several iterations of computing the gradient of the summation in Eqn.6.4, the solution path will eventually be smooth and locally optimal. 6.5 Proof of Completeness for an Opportunistic Global Path Planner Careful completeness proofs for the roadmap algorithm are given in [18] and <ref> [19] </ref>. These proofs apply with very slight modification to the roadmap algorithm that we describe in this paper. The roadmap of [18] is the set of extremal points in a certain direction in free space. Therefore it hugs the boundary of free space. <p> This is a surface S in R (n+1) and if we follow the extrema of distance on this surface, the roadmap of this paper is exactly a roadmap in the sense of [18] and <ref> [19] </ref>. The silhouette curves of [18] correspond to the freeway curves of this paper, and the linking curves correspond to bridges. <p> A silhouette point is a locally maximal point of the function h (:) on some slice Sj a of S. The silhouette (S) of S is the set of all such points for all a. The key properties of the silhouette are ([18], <ref> [19] </ref>): (i) Within each slice of S, each connected component of Sj a must contain at least one silhouette point. (ii) The silhouette should be one-dimensional. (iii) The critical points of the silhouette w.r.t the function x 1 (:) should include the critical points of the set S.
Reference: [20] <author> J. F. Canny and M. C. Lin. </author> <title> An opportunistic global path planner. </title> <journal> Algorithmica, Special Issue on Computational Robotics, </journal> <volume> Vol. 10(2-4):102-120, </volume> <month> Aug/Sept/Oct </month> <year> 1993. </year>
Reference: [21] <author> J.F. Canny. </author> <title> Generalized characteristic polynomials. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 9(3) </volume> <pages> 241-250, </pages> <year> 1990. </year>
Reference-contexts: It can be shown <ref> [21] </ref> that the solutions of interest can be recovered from the lowest degree coefficient in * of the resultant of this system. This normally involves 99 computing a symbolic determinant which is a polynomial in * [57].
Reference: [22] <author> B. Chazelle. </author> <title> Convex partitions of polyhedra: A lower bound and worst-case optimal algorithm. </title> <journal> SIAM J. Comput., </journal> <volume> 13 </volume> <pages> 488-507, </pages> <year> 1984. </year>
Reference-contexts: In general, a polytope of n vertices can always be partitioned into O (n 2 ) convex pieces <ref> [22] </ref>. Given the object representation and data structure for convex polyhedra described in Chapter 2, here we will define the term closest feature pair which we quote frequently in our description of the distance computation algorithm for convex polyhedra. <p> However, if we are given a set of faces describing the non-convex object without any special format, we can use 123 a convex decomposition module which does not necessarily give us an optimal convex decomposition of the non-convex objects, since the problem itself is NP-complete <ref> [52, 67, 22, 76] </ref>. Therefore, applying our sub-part hierarchical tree representation directly to the output of a non-optimal convex decomposition routine may not yield satisfactory results for the purpose of collision detection, especially if we have numerous number of convex pieces.
Reference: [23] <author> B. Chazelle and L. Palios. </author> <title> Triangulating a non-convex polytope. </title> <journal> Discrete & Comput. Geom., </journal> (5):505-526, 1990. 
Reference-contexts: nonconvex objects, we rely on subdivision into convex pieces, which unfortunately, may take O ((n + r 2 )logr) time to partition a nondegenerate simple polytope of genus 0, where n is the number of vertices and r is the number of reflex edges of the original 23 nonconvex object <ref> [23, 2] </ref>. In general, a polytope of n vertices can always be partitioned into O (n 2 ) convex pieces [22]. <p> Though sub-part hierarchical tree representation is an intuitive and natural approach, we have run into the problem of extending this 122 approach for any general input of models. This is due to the fact that there is no optimal convex decomposition algorithm, but near-optimal algorithm <ref> [23] </ref>. A simple convex decomposition does not necessarily give us the decomposition characterizing the geometry structure of the object. Thus, it is hard to exploit the strength of this methodology.
Reference: [24] <author> J. Cohen, M. Lin, D. Manocha, and M. Ponamgi. </author> <title> Exact collision detection for interactive, large-scaled environments. </title> <type> Tech Report #TR94-005, </type> <institution> 1994. University of North Carolina, Chapel Hill. </institution>
Reference-contexts: At the same time, the algorithm described in Sec. 5.2.2 is currently under testing to be eventually integrated into a Walk-Through environment developed at the University of North Carolina, Chapel Hill on their in-house Pixel Plane machine <ref> [24] </ref>. In a virtual world like "walk-through environment" where a human needs to interact with his/her surrounding, it is important that the computer can simulate the interactions of the human participants with the passively or actively changing environment.
Reference: [25] <author> James F. Cremer and A. James Stewart. </author> <title> The architecture of newton, a general-purpose dynamics simulator. </title> <booktitle> In IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 1806-1811, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: It contributes to realistic portrayal of autonomous movements of all virtual objects in the synthetic environments. Most dynamic simulators <ref> [4, 7, 25, 88, 89] </ref> make simplification of models in simulating the physics of translating and rotating objects, and mostly on frictionless impacts. Recently, Keller applied Routh's frictional impact equations [75] to a few simplified cases with numerous assumptions [49].
Reference: [26] <author> D. P. Dobkin and D. G. Kirkpatrick. </author> <title> A linear algorithm for determining the separation of convex polyhedra. </title> <journal> J. Algorithms, </journal> <volume> 6(3):pp. </volume> <pages> 381-392, </pages> <year> 1985. </year>
Reference-contexts: The performance of these algorithms shows great promise for real-time robotics simulation and computer animation. 1.1 Previous Work Collision detection and the related problem of determining minimum distance has a long history. It has been considered in both static and dynamic (moving objects) versions in [3], [11], [13], [17], <ref> [26] </ref>, [27], [39], [40], [41], [65]. One of the earlier survey on "clash detection" was presented by Cameron [12]. He mentioned three different approaches for dynamic collision detection. <p> This approach uses a hierarchical description of the convex objects and extension of their previous work <ref> [26] </ref>. This is one of the best known theoretical bounds. The capability of determining possible contacts in dynamic domains is important for computer animation of moving objects. We would like an animator to perform impact determination by itself without high computational costs or much coding efforts.
Reference: [27] <author> D. P. Dobkin and D. G. Kirkpatrick. </author> <title> Determining the separation of preprocessed polyhedra a unified approach. </title> <booktitle> In Proc. 17th Internat. Colloq. Automata Lang. Program, Lecture Notes in Computer Science 443, </booktitle> <pages> pages 400-413. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: It has been considered in both static and dynamic (moving objects) versions in [3], [11], [13], [17], [26], <ref> [27] </ref>, [39], [40], [41], [65]. One of the earlier survey on "clash detection" was presented by Cameron [12]. He mentioned three different approaches for dynamic collision detection. <p> Using linear-time preprocessing, Dobkin and Kirkpatrick were able to solve the collision detection problem as well as compute the separation between two convex 6 polytopes in O (logjAj logjBj) where A and B are polyhedra and j j denotes the total number of faces <ref> [27] </ref>. This approach uses a hierarchical description of the convex objects and extension of their previous work [26]. This is one of the best known theoretical bounds. The capability of determining possible contacts in dynamic domains is important for computer animation of moving objects.
Reference: [28] <author> B. R. Donald. </author> <title> Motion planning with six degrees of freedom. </title> <type> Master's thesis, </type> <institution> MIT Artificial Intelligence Lab., </institution> <year> 1984. </year> <note> AI-TR-791. 130 </note>
Reference-contexts: If two objects are both moving, the intersection of two sweeping volume does not necessarily indicate an actual "clash" between two objects. Local properties have been used in the earlier motion planning algorithms by Donald, Lozano-Perez and Wesley <ref> [28, 53] </ref> when two features come into contact. In [53], Lozano-Perez and Wesley characterized the collision free motion planning problem by using a point robot navigating in the configuration space by growing the stationary obstacles with the size of the robot.
Reference: [29] <author> Tom Duff. </author> <title> Interval arithmetic and recursive subdivision for implicit functions and constructive solid geometry. </title> <journal> ACM Computer Graphics, </journal> <volume> 26(2) </volume> <pages> 131-139, </pages> <year> 1992. </year>
Reference-contexts: It treats time as an extra dimension and also assumes bounds on derivatives. The algorithm uses subdivision technique in the resulting space and can therefore be slow. A similar method using interval arithmetic and subdivision has been presented for collision detection by Duff <ref> [29] </ref>. Duff has extended it to dynamic environments as well. However, for commonly used spline patches computing and representing the implicit representations is computationally expensive as stated by Hoffmann [46]. Both algorithms, [29, 46], expect a closed form expression of motion as a function of time. <p> A similar method using interval arithmetic and subdivision has been presented for collision detection by Duff [29]. Duff has extended it to dynamic environments as well. However, for commonly used spline patches computing and representing the implicit representations is computationally expensive as stated by Hoffmann [46]. Both algorithms, <ref> [29, 46] </ref>, expect a closed form expression of motion as a function of time. In [70], Pentland and Williams proposes using implicit functions to represent shape and the property of the "inside-outside" functions for collision detection. <p> Besides its restriction to implicits only, this algorithm has a drawback in terms of robustness, as it uses point samples. A detailed explanation of these problems are described in <ref> [29] </ref>. Baraff has also presented an algorithm for finding closest points between two convex closed objects only [3]. <p> Purely symbolic methods based on resultants and Gr-obner bases are rather slow in practice and require multiprecision arithmetic for accurate computations. In the context of finite precision arithmetic, the main approaches are based on resultant and matrix computations [55], continua 20 tion methods [64] and interval arithmetic <ref> [29, 81] </ref>. The recently developed algorithm based on resultants and matrix computations has been shown to be very fast and accurate on many geometric problems and is reasonably simple to implement using linear algebra routines by Manocha [55].
Reference: [30] <author> M. E. Dyer. </author> <title> Linear algorithms for two and three-variable linear programs. </title> <journal> SIAM J. on Computing, </journal> <volume> 13:pp. </volume> <pages> 31-45, </pages> <year> 1984. </year>
Reference-contexts: Megiddo and Dyers work <ref> [30] </ref>, [58], [59] showed that linear programming is solvable in linear time for any fixed number of variables. More recent work by Seidel [79] has shown that linear time linear programming algorithms are quite practical for a small number of variables.
Reference: [31] <author> H. Edelsbrunner. </author> <title> A new approach to rectangle intersections, part i&ii. </title> <journal> Intern. J. Computer Math., </journal> <volume> 13:pp. </volume> <pages> 209-229, </pages> <year> 1983. </year>
Reference-contexts: on the real intervals to reduce the number of pairwise comparison. 84 5.2.2 One-Dimensional Sort and Sweep In computational geometry, there are several algorithms which can solve the overlapping problem for d-dimensional bounding boxes in O (nlog d1 n + s) time where s is the number of pairwise overlaps <ref> [31, 47, 80] </ref>. This bound can be improved using coherence. Let a one-dimensional bounding box be [b; e] where b and e are the real numbers representing the beginning and ending points.
Reference: [32] <author> H. Edelsbrunner. </author> <title> Algorithms in Combinatorial Geometry. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, London, Paris, Tokyo, </address> <year> 1988. </year>
Reference-contexts: Therefore, the Voronoi diagram contains all the information necessary to solve the proximity problems given a set of points in R 2 . A similar idea applies to the same problem in three-dimensional or higher dimensional space <ref> [15, 32] </ref>. The extension of the Voronoi diagram to higher dimensional features (instead of points) is called the generalized Voronoi diagram, i.e. the set of points closest to a feature, e.g. that of a polyhedron. In general, the generalized Voronoi diagram has quadratic surface boundaries in it.
Reference: [33] <author> I. Emiris and J. Canny. </author> <title> A general approach to removing degeneracies. </title> <booktitle> In IEEE FOCS, </booktitle> <pages> pages 405-413, </pages> <year> 1991. </year>
Reference-contexts: This normally involves 99 computing a symbolic determinant which is a polynomial in * [57]. But a more practical approach is to recover only the lowest coefficient in * by using straight line program representations and differentiating <ref> [33] </ref>. To enumerate all the interesting critical points is computationally expensive, since we have to solve O (n (k1) ) systems of non-linear equations. Thus, we also plan to experiment with randomly chosen slice values in some bounded ranges, alternating with slices taken at true split or join points.
Reference: [34] <author> S. F. Fahlman. </author> <title> A planning system for robot construction tasks. </title> <booktitle> Artifical Intel-lignece, 5:pp. </booktitle> <pages> 1-49, </pages> <year> 1974. </year>
Reference-contexts: Some algorithms (such as Boyse's [11] and Canny's [17]) solve the problem in more generality than is necessary for computer animation; while others do not easily produce the exact collision points and contact normal direction for collision response <ref> [34] </ref>.
Reference: [35] <author> G. Farin. </author> <title> Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide. </title> <publisher> Academic Press Inc., </publisher> <year> 1990. </year>
Reference-contexts: The class of parametric and implicit surfaces described in terms of piecewise polynomial equations is currently considered the state of the art for modeling applications <ref> [35, 46] </ref>. These include free-form surfaces described using spline patches, primitive objects like polyhedra, quadrics surfaces (like cones, ellipsoids), 18 torus and their combinations obtained using CSG operations. <p> Our contact determination algorithms for curved objects are applicable on objects described using spline representations (Bezier and B-spline patches) and algebraic surfaces. These representations can be used as primitives for CSG operations as well. Typically spline patches are described geometrically by their control points, knot vectors and order continuity <ref> [35] </ref>. The control points have the property that the entire patch lies in the convex hull of these points. The spline patches are represented as piecewise Bezier patches. <p> The initial estimate to the variables in the equations in (4.2) is obtained by finding the intersection of the line L A;B with the surfaces, F (s; t) and G (u; v). This corresponds to a line-surface intersection problem and can be solved using subdivision or algebraic methods <ref> [35, 55] </ref>. As the surfaces move along, the coefficients of the equations in (4.2) are updated according to the rigid motion. The closest points between the resulting surfaces are updated using Gauss Newton routines. Finally, when these closest points coincide, there is a collision.
Reference: [36] <author> D. Filip, R. Magedson, and R. Markot. </author> <title> Surface algorithms using bounds on derivatives. </title> <booktitle> Computer Aided Geometric Design, </booktitle> <volume> 3 </volume> <pages> 295-311, </pages> <year> 1986. </year>
Reference-contexts: An *-polytope approximation is obtained using either a simple mesh generation algorithm or an adaptive subdivision of the surfaces. Given a user defined *, algorithms for generating such meshes are highlighted for parametric B-spline surfaces in <ref> [36] </ref> and for algebraic surfaces in [44]. In our implementation we used an inscribed polygonal approximation to the surface boundary. We use the *-polytope approximations for convex surfaces only. In such cases the resulting polytope is convex as well.
Reference: [37] <author> Jr. G. Vanecek. Brep-index: </author> <title> A multi-dimensional space partitioning tree. </title> <booktitle> ACM/SIGGRAPH Symposium on Solid Modeling Foundations and CAD Applications, </booktitle> <pages> pages 35-44, </pages> <year> 1991. </year> <institution> Austin Texas. </institution>
Reference-contexts: Each cube can be divided into 8 smaller cubes if necessary. So, each node in the tree has 8 children (leaves). 87 Another modified version of BSP-Tree proposed by Vanecek <ref> [37] </ref> is a multidimensional space partitioning tree called Brep-Index. This tree structure is used for collision detection [10] between moving objects in a system called Proxima developed at Prudue University.
Reference: [38] <author> E. G. Gilbert and C. P. Foo. </author> <title> Computing the distance between general convex objects in three dimensional space. </title> <journal> IEEE Trans. Robotics Automat., </journal> <volume> 6(1), </volume> <year> 1990. </year>
Reference-contexts: In the related problem of computing the minimum separation between two objects, Gilbert and his collaborators computed the minimum distance between two convex objects with an expected linear time algorithm and used it for collision detection. Our work shares with <ref> [38] </ref>, [39], and [41] the calculation and maintenance of closest points during incremental motion. But whereas [38], [39], and [41] require expected linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. <p> Our work shares with <ref> [38] </ref>, [39], and [41] the calculation and maintenance of closest points during incremental motion. But whereas [38], [39], and [41] require expected linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. <p> By comparing the number of arithmetic operations in the previous implemented algorithms, we believe that our implementation gives better performance and probably is the fastest implemented collision detection algorithm. (Please see [65], [13], [17], [40], [39], <ref> [38] </ref>, [72], and [90].) This is especially true in a dynamic environment where the trajectories are not known (nor are they in closed form even between impacts, but are given by elliptic integrals).
Reference: [39] <author> E. G. Gilbert and S. M. Hong. </author> <title> A new algorithm for detecting the collision of moving objects. </title> <booktitle> Proc. IEEE ICRA, </booktitle> <pages> pages pp. 8-14, </pages> <year> 1989. </year>
Reference-contexts: It has been considered in both static and dynamic (moving objects) versions in [3], [11], [13], [17], [26], [27], <ref> [39] </ref>, [40], [41], [65]. One of the earlier survey on "clash detection" was presented by Cameron [12]. He mentioned three different approaches for dynamic collision detection. <p> In the related problem of computing the minimum separation between two objects, Gilbert and his collaborators computed the minimum distance between two convex objects with an expected linear time algorithm and used it for collision detection. Our work shares with [38], <ref> [39] </ref>, and [41] the calculation and maintenance of closest points during incremental motion. But whereas [38], [39], and [41] require expected linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. <p> Our work shares with [38], <ref> [39] </ref>, and [41] the calculation and maintenance of closest points during incremental motion. But whereas [38], [39], and [41] require expected linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. <p> By comparing the number of arithmetic operations in the previous implemented algorithms, we believe that our implementation gives better performance and probably is the fastest implemented collision detection algorithm. (Please see [65], [13], [17], [40], <ref> [39] </ref>, [38], [72], and [90].) This is especially true in a dynamic environment where the trajectories are not known (nor are they in closed form even between impacts, but are given by elliptic integrals).
Reference: [40] <author> E. G. Gilbert and D. W. Johnson. </author> <title> Distance functions and their application to robot path planning in the presence of obstacles. </title> <journal> IEEE J. Robotics Automat., </journal> <volume> RA-1:pp. </volume> <pages> 21-30, </pages> <year> 1985. </year> <month> 131 </month>
Reference-contexts: It has been considered in both static and dynamic (moving objects) versions in [3], [11], [13], [17], [26], [27], [39], <ref> [40] </ref>, [41], [65]. One of the earlier survey on "clash detection" was presented by Cameron [12]. He mentioned three different approaches for dynamic collision detection. <p> By comparing the number of arithmetic operations in the previous implemented algorithms, we believe that our implementation gives better performance and probably is the fastest implemented collision detection algorithm. (Please see [65], [13], [17], <ref> [40] </ref>, [39], [38], [72], and [90].) This is especially true in a dynamic environment where the trajectories are not known (nor are they in closed form even between impacts, but are given by elliptic integrals).
Reference: [41] <author> E. G. Gilbert, D. W. Johnson, and S. S. Keerthi. </author> <title> A fast procedure for computing the distance between objects in three-dimensional space. </title> <journal> IEEE J. Robotics and Automation, </journal> <volume> vol RA-4:pp. </volume> <pages> 193-203, </pages> <year> 1988. </year>
Reference-contexts: The im 4 portance of collision detection extends to several areas like robot motion planning, dynamic simulation, virtual reality applications and it has been extensively studied in robotics, computational geometry, and computer graphics for more than a decade <ref> [3, 4, 11, 13, 17, 41, 43, 45, 51, 53, 63] </ref>. Yet, there is no practical, efficient algorithm available yet for general geometric models to perform collision detection in real time. Recently, Pentland has listed collision detection as one of the major bottlenecks towards real time virtual environment simulations [69]. <p> It has been considered in both static and dynamic (moving objects) versions in [3], [11], [13], [17], [26], [27], [39], [40], <ref> [41] </ref>, [65]. One of the earlier survey on "clash detection" was presented by Cameron [12]. He mentioned three different approaches for dynamic collision detection. <p> In the related problem of computing the minimum separation between two objects, Gilbert and his collaborators computed the minimum distance between two convex objects with an expected linear time algorithm and used it for collision detection. Our work shares with [38], [39], and <ref> [41] </ref> the calculation and maintenance of closest points during incremental motion. But whereas [38], [39], and [41] require expected linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time. <p> Our work shares with [38], [39], and <ref> [41] </ref> the calculation and maintenance of closest points during incremental motion. But whereas [38], [39], and [41] require expected linear time to verify the closest points, we use the properties of convex sets to reduce this check to constant time.
Reference: [42] <author> G.H. Golub and C.F. Van Loan. </author> <title> Matrix Computations. </title> <publisher> John Hopkins Press, </publisher> <address> Baltimore, </address> <year> 1989. </year>
Reference-contexts: As a result, the new set of roots can be computed using local methods only. We can either use Newton's method to compute the roots of the new set of algebraic equations or inverse power iterations <ref> [42] </ref> to compute the eigenvalues of the new matrix obtained using resultant formulation. 21 Chapter 3 An Incremental Distance Computation Algorithm In this chapter we present a simple and efficient method to compute the distance between two convex polyhedra by finding and tracking the closest points.
Reference: [43] <author> J. K. Hahn. </author> <title> Realistic animation of rigid bodies. </title> <journal> ACM Computer Graphics, </journal> <volume> 22(4):pp. </volume> <pages> 299-308, </pages> <year> 1988. </year>
Reference-contexts: Collision detection is usually coupled with an appropriate response to the collision. The collision response is generally application dependent and many algorithms have been proposed for different environments like motion control in animation by Moore and Wilhelm [63], physical simulations by Baraff, Hahn, Pentland and Williams <ref> [3, 43, 70] </ref> or molecular modeling by Turk [85]. Since simplicity and ease of implementation is considered as one of the important factors for any practical algorithm in the computer graphics community, most collision detection algorithms used for computer animation are rather simple but not necessary efficient. <p> Furthermore the convergence to the solution corresponding to the contact point is linear. Repeating these steps at each time instant makes the overall algorithm very slow. The run time impact of a subdivision based collision detection algorithm on the physical simulation has been highlighted by Hahn <ref> [43] </ref>. As interest in dynamic simulations has been rising in computer graphics and robotics, collision detection has also received a great deal of attention. <p> The im 4 portance of collision detection extends to several areas like robot motion planning, dynamic simulation, virtual reality applications and it has been extensively studied in robotics, computational geometry, and computer graphics for more than a decade <ref> [3, 4, 11, 13, 17, 41, 43, 45, 51, 53, 63] </ref>. Yet, there is no practical, efficient algorithm available yet for general geometric models to perform collision detection in real time. Recently, Pentland has listed collision detection as one of the major bottlenecks towards real time virtual environment simulations [69]. <p> This approach along with special case treatments is reasonably reliable. But, the computation runs in O (n 2 ) time where n is the number of vertices per polyhedron. Hahn <ref> [43] </ref> used a hierarchical method involving bounding boxes for intersection tests which run in O (n 2 ) time for each pair of polyhedra where n is the number of vertices for each polyhedron.
Reference: [44] <author> Mark Hall and Joe Warren. </author> <title> Adaptive polygonalization of implicitly defined surfaces. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 10(6) </volume> <pages> 33-42, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: An *-polytope approximation is obtained using either a simple mesh generation algorithm or an adaptive subdivision of the surfaces. Given a user defined *, algorithms for generating such meshes are highlighted for parametric B-spline surfaces in [36] and for algebraic surfaces in <ref> [44] </ref>. In our implementation we used an inscribed polygonal approximation to the surface boundary. We use the *-polytope approximations for convex surfaces only. In such cases the resulting polytope is convex as well. Often a curved model can be represented as a union of convex objects.
Reference: [45] <author> B. V. Herzen, A. H. Barr, and H. R. Zatz. </author> <title> Geometric collisions for time-dependent parametric surfaces. </title> <journal> ACM Computer Graphics, </journal> <volume> 24(4), </volume> <month> August </month> <year> 1990. </year>
Reference-contexts: The im 4 portance of collision detection extends to several areas like robot motion planning, dynamic simulation, virtual reality applications and it has been extensively studied in robotics, computational geometry, and computer graphics for more than a decade <ref> [3, 4, 11, 13, 17, 41, 43, 45, 51, 53, 63] </ref>. Yet, there is no practical, efficient algorithm available yet for general geometric models to perform collision detection in real time. Recently, Pentland has listed collision detection as one of the major bottlenecks towards real time virtual environment simulations [69]. <p> As for curved objects, Herzen and etc. <ref> [45] </ref> have described a general algorithm based on time dependent parametric surfaces. It treats time as an extra dimension and also assumes bounds on derivatives. The algorithm uses subdivision technique in the resulting space and can therefore be slow. <p> Therefore, the problem of collision detection becomes rather complex and almost impossible to solve interactively. Some work has been done for time-dependent parametric surfaces <ref> [45] </ref>. Herzen and etc. use a hierarchical algorithm which first finds the potential collision over large 124 volumes and then refines the solution to smaller volumes. The bound on these volumes are derived from the derivatives with respect to time and the parameters of the surfaces.
Reference: [46] <author> C. Hoffmann. </author> <title> Geometric & Solid Modeling. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1989. </year>
Reference-contexts: A similar method using interval arithmetic and subdivision has been presented for collision detection by Duff [29]. Duff has extended it to dynamic environments as well. However, for commonly used spline patches computing and representing the implicit representations is computationally expensive as stated by Hoffmann <ref> [46] </ref>. Both algorithms, [29, 46], expect a closed form expression of motion as a function of time. In [70], Pentland and Williams proposes using implicit functions to represent shape and the property of the "inside-outside" functions for collision detection. <p> A similar method using interval arithmetic and subdivision has been presented for collision detection by Duff [29]. Duff has extended it to dynamic environments as well. However, for commonly used spline patches computing and representing the implicit representations is computationally expensive as stated by Hoffmann [46]. Both algorithms, <ref> [29, 46] </ref>, expect a closed form expression of motion as a function of time. In [70], Pentland and Williams proposes using implicit functions to represent shape and the property of the "inside-outside" functions for collision detection. <p> Some of the materials presented in this chapter can be found in the books by Hoffmann, Preparata and Shamos <ref> [46, 71] </ref>. The set of models we used include rigid polyhedra and objects with surfaces described by rational spline or piecewise algebraic functions. No deformation of the objects is assumed under motion or external forces. (This may seem a restrictive constraint. <p> The boundary of a face is the set of edges in the closure of the face. We also adapt the winged edge representation. For those readers who are not familiar with this terminology, please refer to <ref> [46] </ref>. Here we give a brief description of the winged edge representation: The edge is oriented by giving two incident vertices (the head and tail). The edge points from tail to head. It has two adjacent faces cobounding it as well. <p> The class of parametric and implicit surfaces described in terms of piecewise polynomial equations is currently considered the state of the art for modeling applications <ref> [35, 46] </ref>. These include free-form surfaces described using spline patches, primitive objects like polyhedra, quadrics surfaces (like cones, ellipsoids), 18 torus and their combinations obtained using CSG operations. <p> In particular, we present algebraic formulations corresponding to closest points determination and geometric contacts. 4.2.1 Collision Detection and Surface Intersection In geometric and solid modeling, the problem of computing the intersection of surfaces represented as spline surfaces or algebraic surfaces has received a great deal of attention <ref> [46] </ref>. Given two surfaces, the problem corresponds to computing all components of the intersection curve robustly and accurately. However, for collision detection we are actually dealing with a restricted version of this problem. That is, given two surfaces we want to know whether they intersect.
Reference: [47] <author> J.E. Hopcroft, J.T. Schwartz, and M. Sharir. </author> <title> Efficient detection of intersections among spheres. </title> <journal> The International Journal of Robotics Research, </journal> <volume> 2(4) </volume> <pages> 77-80, </pages> <year> 1983. </year>
Reference-contexts: on the real intervals to reduce the number of pairwise comparison. 84 5.2.2 One-Dimensional Sort and Sweep In computational geometry, there are several algorithms which can solve the overlapping problem for d-dimensional bounding boxes in O (nlog d1 n + s) time where s is the number of pairwise overlaps <ref> [31, 47, 80] </ref>. This bound can be improved using coherence. Let a one-dimensional bounding box be [b; e] where b and e are the real numbers representing the beginning and ending points.
Reference: [48] <author> Kass, Witkin, Baraff, and Barr. </author> <title> An introduction to physically based modeling. </title> <booktitle> Course Notes 60, </booktitle> <year> 1993. </year>
Reference-contexts: This "pre-filtering" process to eliminate the pairs of objects not likely to collide will run essentially in linear time. A similar approach has been mentioned by Baraff in <ref> [48] </ref>. This approach is especially suitable for an environment where only a few objects are moving while most of objects are stationary, e.g. a virtual walk-through environment. 5.2.3 Interval Tree for 2D Intersection Tests Another approach is to extend the one-dimensional sorting and sweeping technique to higher dimensional space.
Reference: [49] <author> J. B. Keller. </author> <title> Impact with friction. </title> <journal> Journal of Applied Mathematics, </journal> <volume> Vol. 53, </volume> <month> March </month> <year> 1986. </year>
Reference-contexts: Most dynamic simulators [4, 7, 25, 88, 89] make simplification of models in simulating the physics of translating and rotating objects, and mostly on frictionless impacts. Recently, Keller applied Routh's frictional impact equations [75] to a few simplified cases with numerous assumptions <ref> [49] </ref>. Wang and Mason also characterize frictional impacts for the two-dimensional impacts [86].
Reference: [50] <author> O. Khatib. </author> <title> Real-time obstable avoidance for manipulators and mobile robots. </title> <journal> IJRR, </journal> <volume> 5(1) </volume> <pages> 90-98, </pages> <year> 1986. </year>
Reference-contexts: local method (Chapter 3) to build up the one-dimensional skeleton (or freeway) and global computation to find the critical points where linking 90 curves (or bridges) are constructed. 6.1 Background There have been two major approaches to motion planning for manipulators, (i) local methods, such as artificial potential field methods <ref> [50] </ref>, which are usually fast but are not guaranteed to find a path, and (ii) global methods, like the first Roadmap Algorithm [18], which is guaranteed to find a path but may spend a long time doing it. In this chapter, we present an algorithm which has characteristics of both. <p> The skeleton we define here is a subset of a roadmap (in the sense of [18]) of this hypersurface. This work builds on a considerable volume of work in both global motion planning methods [18] [54], [73], [78], and local planners, <ref> [50] </ref>. Our method shares a common theme with the work of Barraquand and Latombe [6] in that it attempts to use a local potential field planner for speed with some procedure for escaping local maxima.
Reference: [51] <author> J.C. Latombe. </author> <title> Robot Motion Planning. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year> <month> 132 </month>
Reference-contexts: The im 4 portance of collision detection extends to several areas like robot motion planning, dynamic simulation, virtual reality applications and it has been extensively studied in robotics, computational geometry, and computer graphics for more than a decade <ref> [3, 4, 11, 13, 17, 41, 43, 45, 51, 53, 63] </ref>. Yet, there is no practical, efficient algorithm available yet for general geometric models to perform collision detection in real time. Recently, Pentland has listed collision detection as one of the major bottlenecks towards real time virtual environment simulations [69].
Reference: [52] <author> A. Lingas. </author> <title> The power of non-rectilinear holes. </title> <booktitle> In Proc. 9th Internat. Colloq. Automata Lang. Program., volume 140 of Lecture Notes in Computer Science, </booktitle> <pages> pages 369-383. </pages> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: However, if we are given a set of faces describing the non-convex object without any special format, we can use 123 a convex decomposition module which does not necessarily give us an optimal convex decomposition of the non-convex objects, since the problem itself is NP-complete <ref> [52, 67, 22, 76] </ref>. Therefore, applying our sub-part hierarchical tree representation directly to the output of a non-optimal convex decomposition routine may not yield satisfactory results for the purpose of collision detection, especially if we have numerous number of convex pieces.
Reference: [53] <author> T. Lozano-Perez and M. Wesley. </author> <title> An algorithm for planning collision-free paths among polyhedral obstacles. </title> <journal> Comm. ACM, </journal> <volume> 22(10):pp. </volume> <pages> 560-570, </pages> <year> 1979. </year>
Reference-contexts: The im 4 portance of collision detection extends to several areas like robot motion planning, dynamic simulation, virtual reality applications and it has been extensively studied in robotics, computational geometry, and computer graphics for more than a decade <ref> [3, 4, 11, 13, 17, 41, 43, 45, 51, 53, 63] </ref>. Yet, there is no practical, efficient algorithm available yet for general geometric models to perform collision detection in real time. Recently, Pentland has listed collision detection as one of the major bottlenecks towards real time virtual environment simulations [69]. <p> If two objects are both moving, the intersection of two sweeping volume does not necessarily indicate an actual "clash" between two objects. Local properties have been used in the earlier motion planning algorithms by Donald, Lozano-Perez and Wesley <ref> [28, 53] </ref> when two features come into contact. In [53], Lozano-Perez and Wesley characterized the collision free motion planning problem by using a point robot navigating in the configuration space by growing the stationary obstacles with the size of the robot. <p> If two objects are both moving, the intersection of two sweeping volume does not necessarily indicate an actual "clash" between two objects. Local properties have been used in the earlier motion planning algorithms by Donald, Lozano-Perez and Wesley [28, 53] when two features come into contact. In <ref> [53] </ref>, Lozano-Perez and Wesley characterized the collision free motion planning problem by using a point robot navigating in the configuration space by growing the stationary obstacles with the size of the robot. As long as the point robot does not enter a forbidden zone, a collision does not take place.
Reference: [54] <author> T. Lozano-Perez and M. Wesley. </author> <title> An algorithm for planning collision-free paths among polyhedral obstacles. </title> <journal> Comm. ACM, </journal> <volume> 22(10) </volume> <pages> 560-570, </pages> <year> 1979. </year>
Reference-contexts: The skeleton we define here is a subset of a roadmap (in the sense of [18]) of this hypersurface. This work builds on a considerable volume of work in both global motion planning methods [18] <ref> [54] </ref>, [73], [78], and local planners, [50]. Our method shares a common theme with the work of Barraquand and Latombe [6] in that it attempts to use a local potential field planner for speed with some procedure for escaping local maxima.
Reference: [55] <author> D. Manocha. </author> <title> Algebraic and Numeric Techniques for Modeling and Robotics. </title> <type> PhD thesis, </type> <institution> Computer Science Division, Department of Electrical Engineering and Computer Science, University of California, Berkeley, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Purely symbolic methods based on resultants and Gr-obner bases are rather slow in practice and require multiprecision arithmetic for accurate computations. In the context of finite precision arithmetic, the main approaches are based on resultant and matrix computations <ref> [55] </ref>, continua 20 tion methods [64] and interval arithmetic [29, 81]. The recently developed algorithm based on resultants and matrix computations has been shown to be very fast and accurate on many geometric problems and is reasonably simple to implement using linear algebra routines by Manocha [55]. <p> resultant and matrix computations <ref> [55] </ref>, continua 20 tion methods [64] and interval arithmetic [29, 81]. The recently developed algorithm based on resultants and matrix computations has been shown to be very fast and accurate on many geometric problems and is reasonably simple to implement using linear algebra routines by Manocha [55]. In particular, given a polynomial system the algorithm in [55] reduces the problem of root finding to an eigenvalue problem. Based on the eigenvalue and eigenvectors, all the solutions of the original system are computed. For large systems the matrix tends to be sparse. <p> The recently developed algorithm based on resultants and matrix computations has been shown to be very fast and accurate on many geometric problems and is reasonably simple to implement using linear algebra routines by Manocha <ref> [55] </ref>. In particular, given a polynomial system the algorithm in [55] reduces the problem of root finding to an eigenvalue problem. Based on the eigenvalue and eigenvectors, all the solutions of the original system are computed. For large systems the matrix tends to be sparse. <p> One such example is shown for two cylinders in Fig.4.4. In this case the geometric contact corresponds to a curve on each surface, as opposed to a point. These cases can be detected using resultant methods as well <ref> [55] </ref>. 71 4.3 Coherence for Collision Detection between Curved Ob jects In most dynamic environments, the closest features or points between two moving objects change infrequently between two time frames. <p> The initial estimate to the variables in the equations in (4.2) is obtained by finding the intersection of the line L A;B with the surfaces, F (s; t) and G (u; v). This corresponds to a line-surface intersection problem and can be solved using subdivision or algebraic methods <ref> [35, 55] </ref>. As the surfaces move along, the coefficients of the equations in (4.2) are updated according to the rigid motion. The closest points between the resulting surfaces are updated using Gauss Newton routines. Finally, when these closest points coincide, there is a collision. <p> A real solution in the domain to those equations implies a geometric collision and a precise contact between the models. The algebraic method based on resultants and eigenvalues is used to find all the solutions to the equations (4.5) and (4.7) <ref> [55] </ref>. This global root finder is used when the control polytopes of two Bezier surfaces collide. At that instant the two surfaces may or may not have a geometric contact. It is possible that all the solutions to these equations are complex.
Reference: [56] <author> D. Manocha. </author> <title> Solving polynomial systems for curve, surface and solid modeling. </title> <booktitle> In ACM/SIGGRAPH Symposium on Solid Modeling, </booktitle> <pages> pages 169-178, </pages> <year> 1993. </year> <note> Revised version to appear in IEEE Computer Graphics and Applications. </note>
Reference-contexts: This corresponds to finding selected eigenvalues of the matrix corresponding to the domain. Algorithms combining this with the sparsity of the matrix are presented in <ref> [56] </ref> and they work very well in practice. The global root finders are used in the preprocessing stage. As the objects undergo motion, the problem of collision detection and contact determination is posed in terms of a new algebraic system.
Reference: [57] <author> D. Manocha and J. F. Canny. </author> <title> Efficient teniques for multipolynomial resultant algorithms. </title> <booktitle> Proceedings of ISSAC'91, 1991. </booktitle> <address> Bonn, Germany. </address>
Reference-contexts: It can be shown [21] that the solutions of interest can be recovered from the lowest degree coefficient in * of the resultant of this system. This normally involves 99 computing a symbolic determinant which is a polynomial in * <ref> [57] </ref>. But a more practical approach is to recover only the lowest coefficient in * by using straight line program representations and differentiating [33]. To enumerate all the interesting critical points is computationally expensive, since we have to solve O (n (k1) ) systems of non-linear equations.
Reference: [58] <author> N. Megiddo. </author> <title> Linear-time algorithms for linear programming in R 3 and related problems. </title> <journal> SIAM J. Computing, </journal> <volume> 12:pp. </volume> <pages> 759-776, </pages> <year> 1983. </year>
Reference-contexts: Megiddo and Dyers work [30], <ref> [58] </ref>, [59] showed that linear programming is solvable in linear time for any fixed number of variables. More recent work by Seidel [79] has shown that linear time linear programming algorithms are quite practical for a small number of variables. <p> In fact, these techniques are used by researchers Karel Zikan [91], Richard Mastro, etc. at the Boeing Virtual Reality Research Laboratory as a mean of computing the distance between two objects. Meggido's result in <ref> [58] </ref> stated that we can solve the problem of minimizing a convex quadratic function, subject to linear constraints in R 3 in linear time by transforming the quadratic programming using an appropriate affine transformation of R 3 (found in constant time) to a linear programming problem.
Reference: [59] <author> N. Megiddo. </author> <title> Linear programming in linear time when the dimension is fixed. </title> <journal> Jour. ACM, </journal> <volume> 31:pp. </volume> <pages> 114-127, </pages> <year> 1984. </year>
Reference-contexts: Megiddo and Dyers work [30], [58], <ref> [59] </ref> showed that linear programming is solvable in linear time for any fixed number of variables. More recent work by Seidel [79] has shown that linear time linear programming algorithms are quite practical for a small number of variables.
Reference: [60] <author> N. Megiddo and A. Tamir. </author> <title> Linear time algorithms for some separable quadratic programming problems. </title> <journal> Operations Research letters, </journal> <volume> 13(4) </volume> <pages> 203-211, </pages> <year> 1993. </year>
Reference-contexts: In <ref> [60] </ref>, Megiddo and Tamir have further shown that a large class of separable convex quadratic transportation problems with a fixed number of sources and separable convex quadratic programming with nonnegativity constraints and a fixed number of linear equality constraints can be solved in linear time. <p> According to the result on separable quadratic programming in <ref> [60] </ref>, this QP problem can be solved in O (n 1 + n 2 ) time. Overall, no good collision detection algorithms or distance computation methods are known for general geometric models.
Reference: [61] <author> J. Milnor. </author> <title> On the betti numbers of real varieties. </title> <journal> Proc. Amer. Math. Soc., </journal> <volume> 15 </volume> <pages> 275-280, </pages> <year> 1964. </year>
Reference-contexts: This is an upper bound on the number of critical points from <ref> [61] </ref> and [84]. <p> we have seen that there are O ((2d) k n (k1) ) candidates; or they may lie on higher dimensional intersection surfaces, but these are certainly defined by fewer than k equations, and the number of possible critical points is not more than O ((2d) k n (k1) ) [84], <ref> [61] </ref>.
Reference: [62] <author> B. Mirtich and J. Canny. Impusle-based, </author> <title> real time dynamic simulation. </title> <note> Submitted to ACM SIGGRAPH, 1994. </note> <institution> University of California, Berkeley. </institution> <month> 133 </month>
Reference-contexts: These applications attest for the practicality of the algorithms and the importance of the problem natures. The algorithm described in Sec. 5.1 and the distance computation algorithm described in Chapter 3 have been used in the dynamics simulator written by Mirtich 88 <ref> [62] </ref>. It reduces the frequency of the collision checks significantly and helps to speed up the calculations of the dynamic simulator considerably. Our vision of this dynamic simulator is the ability to to simulate thousands of small mechanical parts on a vibrating parts feeder in real time.
Reference: [63] <author> M. Moore and J. Wilhelms. </author> <title> Collision detection and response for computer animation. </title> <journal> ACM Computer Graphics, </journal> <volume> 22(4):pp. </volume> <pages> 289-298, </pages> <year> 1988. </year>
Reference-contexts: Collision detection is usually coupled with an appropriate response to the collision. The collision response is generally application dependent and many algorithms have been proposed for different environments like motion control in animation by Moore and Wilhelm <ref> [63] </ref>, physical simulations by Baraff, Hahn, Pentland and Williams [3, 43, 70] or molecular modeling by Turk [85]. <p> The im 4 portance of collision detection extends to several areas like robot motion planning, dynamic simulation, virtual reality applications and it has been extensively studied in robotics, computational geometry, and computer graphics for more than a decade <ref> [3, 4, 11, 13, 17, 41, 43, 45, 51, 53, 63] </ref>. Yet, there is no practical, efficient algorithm available yet for general geometric models to perform collision detection in real time. Recently, Pentland has listed collision detection as one of the major bottlenecks towards real time virtual environment simulations [69]. <p> In one of the earlier animation papers addressing the issue of collision detection, Moore and Wilhelms <ref> [63] </ref> mentioned the method based on the Cyrus-Beck clipping algorithm [74], which provides a simple, robust alternative but runs in O (n 2 m 2 ) time for m polyhedra and n vertices per polyhedron.
Reference: [64] <author> A. P. Morgan. </author> <title> Polynomial continuation and its relationship to the symbolic reduction of polynomial systems. </title> <booktitle> In Symbolic and Numerical Computation for Artificial Intelligence, </booktitle> <pages> pages 23-45, </pages> <year> 1992. </year>
Reference-contexts: Purely symbolic methods based on resultants and Gr-obner bases are rather slow in practice and require multiprecision arithmetic for accurate computations. In the context of finite precision arithmetic, the main approaches are based on resultant and matrix computations [55], continua 20 tion methods <ref> [64] </ref> and interval arithmetic [29, 81]. The recently developed algorithm based on resultants and matrix computations has been shown to be very fast and accurate on many geometric problems and is reasonably simple to implement using linear algebra routines by Manocha [55]. <p> All the roots of the new set of equations are updated using Newton's method. The previous set of roots are used as initial guesses. The overall approach is like homotopy methods <ref> [64] </ref>, This procedure represents an algebraic analog of the geometric coherence exploited in the earlier section. As the two objects move closer to each other, the imaginary components of some of the roots start decreasing.
Reference: [65] <author> M. Orlowski. </author> <title> The computation of the distance between polyhedra in 3-space. </title> <booktitle> Presented SIAM Conf. on Geometric Modeling and Robotics, 1985. Albany, </booktitle> <address> NY. </address>
Reference-contexts: It has been considered in both static and dynamic (moving objects) versions in [3], [11], [13], [17], [26], [27], [39], [40], [41], <ref> [65] </ref>. One of the earlier survey on "clash detection" was presented by Cameron [12]. He mentioned three different approaches for dynamic collision detection. <p> By comparing the number of arithmetic operations in the previous implemented algorithms, we believe that our implementation gives better performance and probably is the fastest implemented collision detection algorithm. (Please see <ref> [65] </ref>, [13], [17], [40], [39], [38], [72], and [90].) This is especially true in a dynamic environment where the trajectories are not known (nor are they in closed form even between impacts, but are given by elliptic integrals).
Reference: [66] <author> J. O'Rourke, C.-B Chien, T. Olson, and D. Naddor. </author> <title> A new linear algorithm for intersecting convex polygons. </title> <journal> Computer Graphics and Image Processing, </journal> <volume> 19 </volume> <pages> 384-391, </pages> <year> 1982. </year>
Reference-contexts: This approach runs in O (N 2 ) time where N is the number of edges of each polygon. 38 An elegant approach which runs in O (M + N ) can be found in <ref> [66, 71] </ref>, where the two polygons A and B each has M , N vertices respectively. This approach not only determines whether two convex polygon intersect or not, it also finds the intersections between them. <p> This approach not only determines whether two convex polygon intersect or not, it also finds the intersections between them. The basic approach is to "advance" along the edges of A and B to find the "internal chain" of vertices which form the intersection polygon. Please refer to <ref> [66, 71] </ref> for all the details. 3.3.3 Analysis of the Algorithm A careful study of all of the above checks shows that they all take time in proportion to the size of the boundary and coboundary of each feature.
Reference: [67] <author> J. O'Rourke and K. J. Supowit. </author> <title> Some NP-hard polygon decomposition problems. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT-30:181-190, </volume> <year> 1983. </year>
Reference-contexts: However, if we are given a set of faces describing the non-convex object without any special format, we can use 123 a convex decomposition module which does not necessarily give us an optimal convex decomposition of the non-convex objects, since the problem itself is NP-complete <ref> [52, 67, 22, 76] </ref>. Therefore, applying our sub-part hierarchical tree representation directly to the output of a non-optimal convex decomposition routine may not yield satisfactory results for the purpose of collision detection, especially if we have numerous number of convex pieces.
Reference: [68] <author> M. H. Overmars. </author> <title> Point location in fat subdivisions. </title> <journal> Inform. Proc. Lett., </journal> <volume> 44 </volume> <pages> 261-265, </pages> <year> 1992. </year>
Reference-contexts: Consider an environment where most of objects are elongated and only a few objects (probably just the robot manipulators in most situations) are moving, then rectangular bounding boxes are preferable. In a more dynamic environment like a vibrating parts feeder where all objects are rather "fat" <ref> [68] </ref> and bouncing around, then spherical bounding boxes are more desirable. If the objects are concave or articulated, then a subpart-hierarchical bounding box representation (similar to subpart-hierarchical tree representation, with each node storing a bounding box) should be employed. <p> The tree structures also cannot capture the temporal and spatial coherence well. 5.3.2 Uniform Spatial Subdivision We can divide the space into unit cells (or volumes) and place each object (or bounding box) in some cell (s) <ref> [68] </ref>. To check for collisions, we have to examine the cell (s) occupied by each box to verify if the cell (s) is (are) shared by other objects. But, it is difficult to set a near-optimal size for each cell and it requires tremendous amount of allocated memory. <p> If the size of the cell is not properly chosen, the computation can be rather expensive. For an environment where almost all objects are of uniform size, like a vibrating parts feeder bowl or molecular modeling <ref> [85, 68] </ref>, this is a rather ideal algorithm, especially to run on a parallel-computing machine. <p> In fact, Overmars has shown that using a hash table to look up an enetry, we can use a data structure of O (n) storage space to perform the point location queries in constant time <ref> [68] </ref>. 5.4 Applications in Dynamic Simulation and Vir tual Environment The algorithms presented in this chapter have been utilized in dynamic simulation as well as in a walk-through environment. These applications attest for the practicality of the algorithms and the importance of the problem natures.
Reference: [69] <author> A. Pentland. </author> <title> Computational complexity versus simulated environment. </title> <journal> Computer Graphics, </journal> <volume> 22(2) </volume> <pages> 185-192, </pages> <year> 1990. </year>
Reference-contexts: Yet, there is no practical, efficient algorithm available yet for general geometric models to perform collision detection in real time. Recently, Pentland has listed collision detection as one of the major bottlenecks towards real time virtual environment simulations <ref> [69] </ref>. In this thesis, we present an efficient algorithm for collision detection between objects with linear and curved boundaries, undergoing rigid motion. No assumption is made on the motion of the object to be expressed as a closed form function of time.
Reference: [70] <author> A. Pentland and J. Williams. </author> <title> Good vibrations: Modal dynamics for graphics and animation. </title> <journal> Computer Graphics, </journal> <volume> 23(3) </volume> <pages> 185-192, </pages> <year> 1990. </year>
Reference-contexts: Collision detection is usually coupled with an appropriate response to the collision. The collision response is generally application dependent and many algorithms have been proposed for different environments like motion control in animation by Moore and Wilhelm [63], physical simulations by Baraff, Hahn, Pentland and Williams <ref> [3, 43, 70] </ref> or molecular modeling by Turk [85]. Since simplicity and ease of implementation is considered as one of the important factors for any practical algorithm in the computer graphics community, most collision detection algorithms used for computer animation are rather simple but not necessary efficient. <p> Duff has extended it to dynamic environments as well. However, for commonly used spline patches computing and representing the implicit representations is computationally expensive as stated by Hoffmann [46]. Both algorithms, [29, 46], expect a closed form expression of motion as a function of time. In <ref> [70] </ref>, Pentland and Williams proposes using implicit functions to represent shape and the property of the "inside-outside" functions for collision detection. Besides its restriction to implicits only, this algorithm has a drawback in terms of robustness, as it uses point samples. <p> In many interactive environments, the derivatives of the surface with respect to time are not obtainable and this approach cannot work under such a circumstance. Another commonly used method is to model the deformable objects by finite element methods and nodal analysis <ref> [70] </ref>. However, this approach is computationally too expensive. Unless we use specialized parallel machines to simulate the motions, its speed is not satisfactory. Baraff and Witkin use polyhedral approximation to handle the deformable objects [5] for the purpose of collision detection.
Reference: [71] <author> F. P. Preparata and M. I. Shamos. </author> <title> Computational Geometry. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: Some of the materials presented in this chapter can be found in the books by Hoffmann, Preparata and Shamos <ref> [46, 71] </ref>. The set of models we used include rigid polyhedra and objects with surfaces described by rational spline or piecewise algebraic functions. No deformation of the objects is assumed under motion or external forces. (This may seem a restrictive constraint. <p> But, if they are parallel yet not overlapping, then we use a linear time procedure <ref> [71] </ref> to find the closest pair of edges, say E A and E B between F A and F B , then invoke the algorithm again with this new pair of candidates (E A ; E B ). <p> This approach runs in O (N 2 ) time where N is the number of edges of each polygon. 38 An elegant approach which runs in O (M + N ) can be found in <ref> [66, 71] </ref>, where the two polygons A and B each has M , N vertices respectively. This approach not only determines whether two convex polygon intersect or not, it also finds the intersections between them. <p> This approach not only determines whether two convex polygon intersect or not, it also finds the intersections between them. The basic approach is to "advance" along the edges of A and B to find the "internal chain" of vertices which form the intersection polygon. Please refer to <ref> [66, 71] </ref> for all the details. 3.3.3 Analysis of the Algorithm A careful study of all of the above checks shows that they all take time in proportion to the size of the boundary and coboundary of each feature.
Reference: [72] <author> W. E. </author> <title> Red. Minimum distances for robot task simulation. </title> <journal> Robotics, </journal> <volume> 1:pp. </volume> <pages> 231-238, </pages> <year> 1983. </year>
Reference-contexts: By comparing the number of arithmetic operations in the previous implemented algorithms, we believe that our implementation gives better performance and probably is the fastest implemented collision detection algorithm. (Please see [65], [13], [17], [40], [39], [38], <ref> [72] </ref>, and [90].) This is especially true in a dynamic environment where the trajectories are not known (nor are they in closed form even between impacts, but are given by elliptic integrals).
Reference: [73] <author> J. Reif. </author> <title> Complexity of the Mover's Problem and Generalizations, </title> <booktitle> chapter 11, </booktitle> <pages> pages pp. 267-281. </pages> <publisher> Ablex publishing corp., </publisher> <address> New Jersey, </address> <year> 1987. </year> <note> edited by J.T. </note> <author> Schwartz and M. Sharir and J. Hopcroft. </author> <month> 134 </month>
Reference-contexts: The skeleton we define here is a subset of a roadmap (in the sense of [18]) of this hypersurface. This work builds on a considerable volume of work in both global motion planning methods [18] [54], <ref> [73] </ref>, [78], and local planners, [50]. Our method shares a common theme with the work of Barraquand and Latombe [6] in that it attempts to use a local potential field planner for speed with some procedure for escaping local maxima.
Reference: [74] <author> D. F. Rogers. </author> <title> Procedural Elements for Computer Graphics. </title> <publisher> McGraw-Hill Book Company, </publisher> <year> 1985. </year>
Reference-contexts: In one of the earlier animation papers addressing the issue of collision detection, Moore and Wilhelms [63] mentioned the method based on the Cyrus-Beck clipping algorithm <ref> [74] </ref>, which provides a simple, robust alternative but runs in O (n 2 m 2 ) time for m polyhedra and n vertices per polyhedron. The method works by checking whether a point lies inside a polygon or polyhedron by using a inner product calculation test.
Reference: [75] <author> Edward J. Routh. </author> <title> Elementary Rigid Dynamics. </title> <year> 1905. </year>
Reference-contexts: It contributes to realistic portrayal of autonomous movements of all virtual objects in the synthetic environments. Most dynamic simulators [4, 7, 25, 88, 89] make simplification of models in simulating the physics of translating and rotating objects, and mostly on frictionless impacts. Recently, Keller applied Routh's frictional impact equations <ref> [75] </ref> to a few simplified cases with numerous assumptions [49]. Wang and Mason also characterize frictional impacts for the two-dimensional impacts [86].
Reference: [76] <author> J. Ruppert and R. Seidel. </author> <title> On the difficulty of tetrahedralizing 3-dimensional non-convex polyhedra. </title> <booktitle> In Proc. of the Fifth Annual Symposium on Computational Geometry, </booktitle> <pages> pages 380-392. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: However, if we are given a set of faces describing the non-convex object without any special format, we can use 123 a convex decomposition module which does not necessarily give us an optimal convex decomposition of the non-convex objects, since the problem itself is NP-complete <ref> [52, 67, 22, 76] </ref>. Therefore, applying our sub-part hierarchical tree representation directly to the output of a non-optimal convex decomposition routine may not yield satisfactory results for the purpose of collision detection, especially if we have numerous number of convex pieces.
Reference: [77] <author> N. Sancheti and S. Keerthi. </author> <title> Computation of certain measures of proximity between convex polytopes: A complexity viewpoint. </title> <journal> Proceedings of IEEE ICRA'92, </journal> <volume> 3 </volume> <pages> 2508-2513, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: As long as the point robot does not enter a forbidden zone, a collision does not take place. A fact that has often been overlooked is that collision detection for convex polyhedra can be done in linear time in the worst case by Sancheti and Keerthi <ref> [77] </ref>. The proof is by reduction to linear programming. If two point sets have disjoint convex hulls, then there is a plane which separates the two sets. <p> Cameron and Culley further discussed the problem of interpenetration and 8 provided the intersection measurement for the use in a penalty function for robot motion planning [13]. The classical non-linear programming approaches for this problem are presented in [1] and [9]. More recently, Sancheti and Keerthi <ref> [77] </ref> discussed the computation of proximity between two convex polytopes from a complexity viewpoint, in which the use of quadratic programming is proposed as an alternative to compute the separation and detection problem between two convex objects in O (n) time in a fixed dimension d, where n is the number
Reference: [78] <author> J.T. Schwartz and M. Sharir. </author> <title> On the `Piano Movers' Problem, II. General Techniques for Computing Topological Properties of Real Algebraic Manifolds, </title> <booktitle> chapter 5, </booktitle> <pages> pages 154-186. </pages> <publisher> Ablex publishing corp., </publisher> <address> New Jersey, </address> <year> 1987. </year>
Reference-contexts: The skeleton we define here is a subset of a roadmap (in the sense of [18]) of this hypersurface. This work builds on a considerable volume of work in both global motion planning methods [18] [54], [73], <ref> [78] </ref>, and local planners, [50]. Our method shares a common theme with the work of Barraquand and Latombe [6] in that it attempts to use a local potential field planner for speed with some procedure for escaping local maxima.
Reference: [79] <author> R. Seidel. </author> <title> Linear programming and convex hulls made easy. </title> <booktitle> In Proc. 6th Ann. ACM Conf. on Computational Geometry, </booktitle> <pages> pages 211-215, </pages> <address> Berkeley, California, </address> <year> 1990. </year>
Reference-contexts: Megiddo and Dyers work [30], [58], [59] showed that linear programming is solvable in linear time for any fixed number of variables. More recent work by Seidel <ref> [79] </ref> has shown that linear time linear programming algorithms are quite practical for a small number of variables. The algorithm of [79] has been implemented, and seems fast in practice. <p> Megiddo and Dyers work [30], [58], [59] showed that linear programming is solvable in linear time for any fixed number of variables. More recent work by Seidel <ref> [79] </ref> has shown that linear time linear programming algorithms are quite practical for a small number of variables. The algorithm of [79] has been implemented, and seems fast in practice.
Reference: [80] <author> H. W. Six and D. Wood. </author> <title> Counting and reporting intersections of d-ranges. </title> <journal> IEEE Trans. on Computers, C-31(No. </journal> <volume> 3), </volume> <month> March </month> <year> 1982. </year>
Reference-contexts: on the real intervals to reduce the number of pairwise comparison. 84 5.2.2 One-Dimensional Sort and Sweep In computational geometry, there are several algorithms which can solve the overlapping problem for d-dimensional bounding boxes in O (nlog d1 n + s) time where s is the number of pairwise overlaps <ref> [31, 47, 80] </ref>. This bound can be improved using coherence. Let a one-dimensional bounding box be [b; e] where b and e are the real numbers representing the beginning and ending points.
Reference: [81] <author> J. Snyder, A. Woodbury, K Fleischer, B. Currin, and A. Barr. </author> <title> Interval methods for multi-point collisions between time-dependent curved surfaces. </title> <booktitle> Computer Graphics, Proceedings of ACM SIGGRAPH'93, </booktitle> <pages> pages 321-334, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Purely symbolic methods based on resultants and Gr-obner bases are rather slow in practice and require multiprecision arithmetic for accurate computations. In the context of finite precision arithmetic, the main approaches are based on resultant and matrix computations [55], continua 20 tion methods [64] and interval arithmetic <ref> [29, 81] </ref>. The recently developed algorithm based on resultants and matrix computations has been shown to be very fast and accurate on many geometric problems and is reasonably simple to implement using linear algebra routines by Manocha [55]. <p> For low resolution of the polyhedral model, the visual effect generated by this algorithm would be very disconcerting (the viewer may see intersecting facets frequently) and the numerical solution will be rather poor for the purpose of simulating dynamics and robust integration. Snyder and etc. <ref> [81] </ref> present a general collision detection algorithm for any type of surface by using interval arithmetics, optimization routines, and many other numerical methods. Although the algorithm can be used for a large class of various models, it is extremely slow.
Reference: [82] <author> D. Sturman. </author> <title> A discussion on the development of motion control systems. In SigGraph Course Notes: Computer Animation: 3-D Motion Specification and Control, number 10, </title> <year> 1987. </year>
Reference: [83] <author> W. Thibault and B. Naylor. </author> <title> Set operations on polyhedra using binary space partitioning trees. </title> <journal> Computer Graphics - SIGGRAPH'87, </journal> <volume> (4), </volume> <year> 1987. </year> <month> 135 </month>
Reference-contexts: rectangles. 5.3 Other Approaches Here we will also briefly mention a few different approaches which can be used in other environments or applications. 5.3.1 BSP-Trees and Octrees One of the commonly used tree structure is BSP-tree (binary space partitioning tree) to speed up intersection tests in CSG (constructive solid geometry) <ref> [83] </ref>. This approach construct a tree from separating planes at each node recursively. It partitions each object into groups of parts which are close together in binary space.
Reference: [84] <author> R. Thom. Sur l'homologie des varietes algebriques reelles. </author> <booktitle> Differential and Combinatorial Topology, </booktitle> <pages> pages 255-265, </pages> <year> 1965. </year>
Reference-contexts: This is an upper bound on the number of critical points from [61] and <ref> [84] </ref>. <p> and we have seen that there are O ((2d) k n (k1) ) candidates; or they may lie on higher dimensional intersection surfaces, but these are certainly defined by fewer than k equations, and the number of possible critical points is not more than O ((2d) k n (k1) ) <ref> [84] </ref>, [61].
Reference: [85] <author> G. Turk. </author> <title> Interactive collision detection for molecular graphics. </title> <type> Master's thesis, </type> <institution> Computer Science Department, University of North Carolina at Chapel Hill, </institution> <year> 1989. </year>
Reference-contexts: The collision response is generally application dependent and many algorithms have been proposed for different environments like motion control in animation by Moore and Wilhelm [63], physical simulations by Baraff, Hahn, Pentland and Williams [3, 43, 70] or molecular modeling by Turk <ref> [85] </ref>. Since simplicity and ease of implementation is considered as one of the important factors for any practical algorithm in the computer graphics community, most collision detection algorithms used for computer animation are rather simple but not necessary efficient. <p> If the size of the cell is not properly chosen, the computation can be rather expensive. For an environment where almost all objects are of uniform size, like a vibrating parts feeder bowl or molecular modeling <ref> [85, 68] </ref>, this is a rather ideal algorithm, especially to run on a parallel-computing machine.
Reference: [86] <author> Yu Wang and Matthew T. Mason. </author> <title> Modeling impact dynamics for robotic operations. </title> <booktitle> In IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 678-685, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Recently, Keller applied Routh's frictional impact equations [75] to a few simplified cases with numerous assumptions [49]. Wang and Mason also characterize frictional impacts for the two-dimensional impacts <ref> [86] </ref>. Currently Mirtich and Canny are investigating a better approach to model the three-dimensional frictional impact, which will be extremely useful for a general-purpose dynamics simulator in computer generated virtual environment or robotics simulation for manufacturing purposes. 126 Many open problems are still left to be addressed.
Reference: [87] <author> C. G. Gibson K. Wirthmuller and A. A. du Plessis E. J. N. Looijenga. </author> <title> Topological Stability of Smooth Mappings. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin . Heidelberg . New York, </address> <year> 1976. </year>
Reference-contexts: This is all the better because it means that local maxima that do not occur where the function is smooth are all the more sharply defined. The graph of the distance function certainly has a stratification into a finite number of smooth pieces <ref> [87] </ref>. Its maxima will be the union of certain local maxima of these smooth pieces. So we can still use the system of equations defined earlier to find them. With this scheme, a manipulator moves in such a way to maximize the artificial potential field U art (x). <p> If we have chosen a general direction x 1 , the set Sj a 1 consists of a single point which will also be part of the roadmap. For the inductive step we start with some basic results from Chapter 2 in <ref> [87] </ref>, which state that we can smoothly deform or retract a manifold (or union of manifolds like the surface S) in the absence of critical points.
Reference: [88] <author> Andrew Witkin, Michael Gleicher, and William Welch. </author> <title> Interactive dynamics. </title> <journal> Computer Graphics, </journal> <volume> 24(2) </volume> <pages> 11-22, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: It contributes to realistic portrayal of autonomous movements of all virtual objects in the synthetic environments. Most dynamic simulators <ref> [4, 7, 25, 88, 89] </ref> make simplification of models in simulating the physics of translating and rotating objects, and mostly on frictionless impacts. Recently, Keller applied Routh's frictional impact equations [75] to a few simplified cases with numerous assumptions [49].
Reference: [89] <author> Andrew Witkin and William Welch. </author> <title> Fast animation and control of nonrigid structures. </title> <journal> Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 243-252, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: It contributes to realistic portrayal of autonomous movements of all virtual objects in the synthetic environments. Most dynamic simulators <ref> [4, 7, 25, 88, 89] </ref> make simplification of models in simulating the physics of translating and rotating objects, and mostly on frictionless impacts. Recently, Keller applied Routh's frictional impact equations [75] to a few simplified cases with numerous assumptions [49].
Reference: [90] <author> P. Wolfe. </author> <title> Finding the nearest points in a polytope. </title> <journal> Math. Programming, </journal> <volume> 11:pp. </volume> <pages> 128-149, </pages> <year> 1976. </year>
Reference-contexts: By comparing the number of arithmetic operations in the previous implemented algorithms, we believe that our implementation gives better performance and probably is the fastest implemented collision detection algorithm. (Please see [65], [13], [17], [40], [39], [38], [72], and <ref> [90] </ref>.) This is especially true in a dynamic environment where the trajectories are not known (nor are they in closed form even between impacts, but are given by elliptic integrals).
Reference: [91] <author> K. Zikan and W. D. Curtis. </author> <title> Intersection and separations of polytopes. </title> <institution> Boeing Computer Services Technology, BCSTECH-93-031, </institution> <year> 1993. </year> <title> A note on collision and interference detection. </title> <type> 136 </type>
Reference-contexts: In fact, these techniques are used by researchers Karel Zikan <ref> [91] </ref>, Richard Mastro, etc. at the Boeing Virtual Reality Research Laboratory as a mean of computing the distance between two objects.
References-found: 91

