URL: http://www.cs.colostate.edu/~ftppub/TechReports/1993/tr-111.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Affiliation: Department of Computer Science Colorado State University  
Abstract: C-Patrol: Design and Usage Hwei Yin and James M. Bieman Technical Report CS-93-111 August 20, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [BY92] <author> James M. Bieman and Hwei Yin. </author> <title> Designing for software testability using automated oracles. </title> <booktitle> International Test Conference, </booktitle> <pages> pages 900-907, </pages> <year> 1992. </year>
Reference-contexts: Thus, it is difficult to identify sources for related work. We briefly discuss work that we are aware of and work that influenced C-patrol design. 11 Our original objective was to bring abstract concepts from an earlier project, Prosper [Yin91] <ref> [BY92] </ref> [LB89], into the highly pragmatic world of C. Prosper is an experimental pre- and post-condition enforcement language designed for a purely functional language.
Reference: [CL90] <author> Marshall P. Cline and Doug Lea. </author> <title> The behavior of C++ classes. </title> <booktitle> Proc. Symp. on Object Oriented Programming Emphasizing Practical Applications, </booktitle> <address> Marist College, </address> <year> 1990. </year>
Reference-contexts: This problem can be circumvented by performing checks only at function boundaries essentially, adding the checks to the operation's pre- and post-conditions. This is the approach favored by Eiffel [Mey92] and A++ <ref> [CL90] </ref>: any function that operates on the object has the object's invariants enforced as an additional pre- and post-condition constraint, with special pre-condition exceptions made for initialization routines. The main factor facilitating this approach for Eiffel and A++ is that the underlying languages support object-oriented programming. <p> Eiffel also has a system for selectively activating insertions, a feature that will eventually have to be implemented in C-patrol. The object-oriented nature of C++ also simplified the task of the Annotated C++ project, A++ <ref> [CL90] </ref>, which seeks to do for C++ what Anna does for Ada. A++ exploits the object-oriented nature of C++ to explicitly provide more advanced object-oriented concepts, such as encapsulation and inheritance. Such features may be the subject of future C-patrol research. <p> All desired functions of the virtual code must be coded explicitly by the user. Tools such as A++ <ref> [CL90] </ref> and APP [Ros92] demonstrate that such features may be necessary to make C-patrol practical for industrial use; however, the flexibility of C-patrol makes determining the sort of primitives required difficult because of the unpredicatably wide spectrum of future applications.
Reference: [Hay87] <author> Ian Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Cambridge, London, </address> <year> 1987. </year>
Reference-contexts: A full discussion of the advantages and disadvantages of using C as a virtual language appears in a later section. Checking code can also be used as a method of specification. Efforts such as VDM [Jon86] and Z <ref> [Hay87] </ref> use pre- and post-condition checks to specify the actions of functions. C-patrol goes a step farther by providing invariants that can be applied to data structures. <p> The merits and disadvantages of each of these approaches will be discussed in detail. 4.1.1 Meta-Languages as Virtual Code One common approach to expressing executable specifications or oracle constraints is to implement powerful, high level constructs, such as those found in VDM [Jon86] or Z <ref> [Hay87] </ref>, in virtual code. The clear syntax and high level primitives of such languages allow the user to express complex requirements in a clear and abstract manner. Furthermore, a language can be designed that inherently protects the underlying program from the actions of virtual code.
Reference: [HJ89] <author> Ian Hayes and C. B. Jones. </author> <title> Specifications are not (necessarily) executable. </title> <journal> Software Engineering Journal, </journal> <pages> pages 330-338, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: Most high level primitives are specialized toward particular applications: the types of high level operations needed vary with paradigms of use. When used outside of its intended application, the language becomes awkward to use. Furthermore, a computational argument posed by Hayes and Jones <ref> [HJ89] </ref> shows that there are classes of high level primitives that are impractical or impossible to implement. We chose to open C-patrol to as many applications and uses as possible rather than attempt to anticipate the primitives that will be of service to the user.
Reference: [Jon86] <author> Cliff B. Jones. </author> <title> Systematic Software Development using VDM. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Cambridge, London, </address> <year> 1986. </year>
Reference-contexts: A full discussion of the advantages and disadvantages of using C as a virtual language appears in a later section. Checking code can also be used as a method of specification. Efforts such as VDM <ref> [Jon86] </ref> and Z [Hay87] use pre- and post-condition checks to specify the actions of functions. C-patrol goes a step farther by providing invariants that can be applied to data structures. <p> The merits and disadvantages of each of these approaches will be discussed in detail. 4.1.1 Meta-Languages as Virtual Code One common approach to expressing executable specifications or oracle constraints is to implement powerful, high level constructs, such as those found in VDM <ref> [Jon86] </ref> or Z [Hay87], in virtual code. The clear syntax and high level primitives of such languages allow the user to express complex requirements in a clear and abstract manner. Furthermore, a language can be designed that inherently protects the underlying program from the actions of virtual code.
Reference: [LB89] <author> Jacek Leszczylowski and James M. Bieman. PROSPER, </author> <title> a language for specification by prototyping. </title> <journal> Computer Languages, </journal> <volume> 14(3) </volume> <pages> 165-180, </pages> <year> 1989. </year>
Reference-contexts: Thus, it is difficult to identify sources for related work. We briefly discuss work that we are aware of and work that influenced C-patrol design. 11 Our original objective was to bring abstract concepts from an earlier project, Prosper [Yin91] [BY92] <ref> [LB89] </ref>, into the highly pragmatic world of C. Prosper is an experimental pre- and post-condition enforcement language designed for a purely functional language.
Reference: [LvH85] <author> Donald C. Luckham and Friedrich W. von Henke. </author> <title> An overview of ANNA, a specification language for Ada. </title> <journal> IEEE Software, </journal> <pages> pages 9-22, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: C-patrol design concepts are independent of C itself; thus, major portions of the implementation are likely to be portable to other languages. This independence also makes compatibility with other software tools likely. Like its inspiration, Anna <ref> [LvH85] </ref>, C-patrol consists of a system of comments that can be Address correspondence to Dr. James M. Bieman, Department of Computer Science, Colorado State University, Fort Collins, CO 80523. Voice: (303)491-7096, Fax: (303) 491-6639, Email: bieman@cs.colostate.edu Research partially supported by the Colorado Advanced Software Institute (CASI) and Storage Technology Inc. <p> With functional languages, side effects are not a factor; however, the industrial C code we analyzed showed a heavily object-oriented style of programming, prompting us to create the labeled code system. One inspiration for C-patrol work comes from Annotated Ada, or Anna <ref> [LvH85] </ref>. It is from Anna that the method of using comments to hide insertions was derived. C-patrol extends Anna work by adding the labeled code system; however, it does not provide the Anna primitives that make expressing constraints more intuitive (see Design Decisions in C-Patrol).
Reference: [Mey92] <author> Bertrand Meyer. </author> <title> Eiffel the Language. </title> <publisher> Prentice Hall Intl., </publisher> <year> 1992. </year>
Reference-contexts: A limited form of automatic insertion is currently being considered (see Future Work); however, problems relating to stability <ref> [Mey92] </ref> were the predominant force in shaping the current system of labeled code. Stability is defined relative to an object, its invariant, and a point in program control flow. An unstable state is a program state where the object's invariant is temporarily violated. <p> This problem can be circumvented by performing checks only at function boundaries essentially, adding the checks to the operation's pre- and post-conditions. This is the approach favored by Eiffel <ref> [Mey92] </ref> and A++ [CL90]: any function that operates on the object has the object's invariants enforced as an additional pre- and post-condition constraint, with special pre-condition exceptions made for initialization routines. The main factor facilitating this approach for Eiffel and A++ is that the underlying languages support object-oriented programming. <p> The use of pure C for virtual code makes C-patrol execution more efficient, reducing the need for such measures. The labeled code system began as an attempt to imitate the methods of Eiffel <ref> [Mey92] </ref>. Eiffel object invariants are inserted as additional pre- and post-conditions to all operations on the object. Such methods are difficult to execute in C due to the lack of language support in identifying the operations of an object.
Reference: [RAO92] <author> Debra J. Richardson, Stephanie L. Aha, and T. Owen O'Malley. </author> <title> Specification-based test oracles for reactive systems. </title> <booktitle> 14th Intl. Conf. on Software Engineering, </booktitle> <address> Melbourne, Australia, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: The power of C-patrol undoubtably leads to many applications; however, C-patrol was designed as a system for implementing automated oracles and specifications, so it is important to consider it in that context. An oracle is a method of determining whether a program has performed according to specification <ref> [RAO92] </ref>. For most systems, the oracle is human: users determine from system and debug output whether the program worked correctly. C-patrol is a tool that can help automate aspects of this process.
Reference: [Ros92] <author> David S. Rosenblum. </author> <title> Toward a method of programming with assertions. </title> <booktitle> Proc. 14th Intl. Conf. on Software Engineering, </booktitle> <address> Melbourne, Australia, </address> <pages> pages 92-104, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: A++ exploits the object-oriented nature of C++ to explicitly provide more advanced object-oriented concepts, such as encapsulation and inheritance. Such features may be the subject of future C-patrol research. Anna also inspired another cousin, APP, or the Annotation Pre-Processor for C <ref> [Ros92] </ref>. APP, like all Anna cousins, closely echos C-patrol its highly pragmatic philosophy. Unlike C-patrol, APP has been operational for some time, although testing has been limited to relatively private experiments by the researcher. <p> All desired functions of the virtual code must be coded explicitly by the user. Tools such as A++ [CL90] and APP <ref> [Ros92] </ref> demonstrate that such features may be necessary to make C-patrol practical for industrial use; however, the flexibility of C-patrol makes determining the sort of primitives required difficult because of the unpredicatably wide spectrum of future applications.
Reference: [Rub90] <author> Ronitt Rubinfeld. </author> <title> A mathematical theory of self-checking, self-testing and self-correcting programs. </title> <booktitle> Intl. </booktitle> <institution> Computer Science Inst., </institution> <month> October </month> <year> 1990. </year> <note> Technical Report TR-90-054. </note>
Reference-contexts: C-patrol flexibility makes is quite possible that the features of tools such as APP can be organized and inserted into code by the C-patrol labeled code system, resulting in a combined power beyond that of either tool. In his PhD thesis, Rubinfeld <ref> [Rub90] </ref> demonstrated a form of parallel programming called self-checking code.
Reference: [SM93] <author> Sriram Sankar and Manas Mandal. </author> <title> Concurrent runtime monitoring of formally specified programs. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 32-41, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: C-patrol extends Anna work by adding the labeled code system; however, it does not provide the Anna primitives that make expressing constraints more intuitive (see Design Decisions in C-Patrol). Executing checking code can be expensive, and one Anna implementation <ref> [SM93] </ref> relies on concurrency to o*oad checking overhead. The use of pure C for virtual code makes C-patrol execution more efficient, reducing the need for such measures. The labeled code system began as an attempt to imitate the methods of Eiffel [Mey92].
Reference: [Yin91] <author> H. Yin. </author> <title> Automatic enforcement of invariants: The implementation of prosper. </title> <institution> Colorado State University, </institution> <year> 1991. </year> <month> 15 </month>
Reference-contexts: Thus, it is difficult to identify sources for related work. We briefly discuss work that we are aware of and work that influenced C-patrol design. 11 Our original objective was to bring abstract concepts from an earlier project, Prosper <ref> [Yin91] </ref> [BY92] [LB89], into the highly pragmatic world of C. Prosper is an experimental pre- and post-condition enforcement language designed for a purely functional language.
References-found: 13

