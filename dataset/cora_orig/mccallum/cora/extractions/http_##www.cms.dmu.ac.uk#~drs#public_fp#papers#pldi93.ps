URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/pldi93.ps
Refering-URL: http://www.cms.dmu.ac.uk/~drs/public_fp/papers/
Root-URL: 
Email: peterson-john@cs.yale.edu, jones-mark@cs.yale.edu.  
Title: Implementing Type Classes  
Author: John Peterson and Mark Jones 
Note: Electronic mail:  
Address: P.O. Box 2158 Yale Station, New Haven, CT 06520-2158, USA.  
Affiliation: Department of Computer Science, Yale University,  
Abstract: We describe the implementation of a type checker for the functional programming language Haskell that supports the use of type classes. This extends the type system of ML to support overloading (ad-hoc polymorphism) and can be used to implement features such as equality types and numeric overloading in a simple and general way. The theory of type classes is well understood, but the practical issues involved in the implementation of such systems have not received a great deal of attention. In addition to the basic type checking algorithm, an implementation of type classes also requires some form of program transformation. In all current Haskell compilers this takes the form of dictionary conversion, using functions as hidden parameters to overloaded values. We present efficient techniques for type checking and dictionary conversion. A number of optimizations and extensions to the basic type class system are also described. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.W. Appel. </author> <title> A critique of Standard ML. </title> <institution> Princeton University CS-TR-364-92, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: This is undesirable because it forces the programmer to accept a particular structural definition of equality one which tests for equality of representation rather than equality of represented value. In addition, Appel <ref> [1] </ref> reports that "Equality types add significant complex ity to the language and its implementation". <p> In this example, we could evaluate member 2 [1,2,3] by rewriting it as member' primEqInt 2 [1,2,3] and evaluating that expression instead. For a more interesting example, if xs is a list of lists of integers, then we could evaluate member <ref> [1] </ref> xs in a similar way, rewriting it as member' (eqList primEqInt) [1] xs, where: eqList :: (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; [a] -&gt; Bool eqList eq [] [] = True eqList eq (x:xs) (y:ys) = eq x y && eqList eq xs ys eqList eq _ _ <p> For a more interesting example, if xs is a list of lists of integers, then we could evaluate member <ref> [1] </ref> xs in a similar way, rewriting it as member' (eqList primEqInt) [1] xs, where: eqList :: (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; [a] -&gt; Bool eqList eq [] [] = True eqList eq (x:xs) (y:ys) = eq x y && eqList eq xs ys eqList eq _ _ = False The definition of eqList can be obtained directly from the
Reference: [2] <author> A.W. Appel. </author> <title> Compiling with continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Many schemes exist for the encoding of tags to make the tag dispatch efficient. This is essentially the method used to deal with the equality function in Standard ML of New Jersey <ref> [2] </ref>. One of the benefits of static type checking is that it provides a compile-time check which ensures that the the equality function will never be applied to an object for which there is no corresponding definition of equality.
Reference: [3] <author> L. Augustsson. </author> <title> Implementing Haskell overloading. </title> <booktitle> To appear in Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Copenhagen, Den-mark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Further ideas, mostly at a fairly abstract level, were presented in the static semantics for Haskell [10] and also, concentrating on the problems of repeated dictionary construction, in [8]. Some of the techniques used to improve the performance of Haskell overloading in the Chalmers Haskell compiler are described in <ref> [3] </ref>. In summary, experience with the use and development of Haskell systems has done much to reduce the costs of type class overloading. 11 Acknowledgments This work was supported by grants from DARPA, contract number N00014-91-J-4043, and from NSF, contract number CCR-9104987.
Reference: [4] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In 8th Annual ACM Symposium on Principles of Programming languages, </booktitle> <year> 1982. </year>
Reference-contexts: The use and implementation of ML style type inference is well documented and we will not repeat this here (see <ref> [4] </ref> for example). Instead, we concentrate on the relatively minor changes that are needed to extend ML style type inference with support for type classes. As in ordinary ML typechecking, type variables and unification play a central role. Type variables are initially unbound, corresponding to `unknown' types.
Reference: [5] <author> K. Hammond and S. Blott. </author> <title> Implementing Haskell type classes. </title> <booktitle> Proceedings of the 1989 Glasgow Workshop on Functional Programming, Fraserburgh, Scotland. Workshops in computing series, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: The basis for a translation from the Haskell syntax for declaring and using type classes was set out by Wadler and Blott [11] and some results from an early implementation based directly on these ideas have been presented by Hammond and Blott <ref> [5] </ref>. Further ideas, mostly at a fairly abstract level, were presented in the static semantics for Haskell [10] and also, concentrating on the problems of repeated dictionary construction, in [8].
Reference: [6] <editor> P. Hudak, S.L. Peyton Jones and P. Wadler (eds.). </editor> <title> Report on the programming language Haskell, version 1.2. </title> <journal> ACM SIGPLAN notices, </journal> <volume> 27, 5, </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Type classes are most widely known for their use in the functional programming language Haskell <ref> [6] </ref> where they are used mostly to deal with standard primitive functions such as + and ==. In addition, we have also found that type classes can be useful in more specific application areas where they can help to produce clear and modular programs [7]. <p> Our example programs will be written using the concrete syntax of Haskell with explanatory comments where necessary. Further details may be found in <ref> [6] </ref>. We will also use the following terms while describing the class system: method A primitive overloaded operator such as == will be called a method. Methods are found in expressions. class A group of related methods is packaged into a class. <p> The compiler must be aware of any interface for the module being compiled and use that signature to determine the dictionary ordering during generalization. 8.7 The Monomorphism Restriction The Haskell report <ref> [6] </ref> imposes a constraint known as the monomorphism restriction on the generalization of overloaded variables. This is intended to avoid problems with the loss of laziness that can occur when an overloaded variable is translated to a function with one or more dictionary parameters.
Reference: [7] <author> M.P. Jones. </author> <title> Computing with lattices: An application of type classes. </title> <journal> Journal of Functional Programming, </journal> <volume> Volume 2, Part 4, </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: In addition, we have also found that type classes can be useful in more specific application areas where they can help to produce clear and modular programs <ref> [7] </ref>. We should also mention that there does not appear to be any significant reason why the use of type classes should be limited to non-strict, purely functional languages: in principle, any language based on the basic Hindley/Milner/Damas type system could be extended to support the use of type classes.
Reference: [8] <author> M.P. Jones. </author> <title> Qualified types: Theory and Practice. D. </title> <type> Phil. Thesis. </type> <institution> Programming Research Group, Oxford University Computing Laboratory. </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: Further ideas, mostly at a fairly abstract level, were presented in the static semantics for Haskell [10] and also, concentrating on the problems of repeated dictionary construction, in <ref> [8] </ref>. Some of the techniques used to improve the performance of Haskell overloading in the Chalmers Haskell compiler are described in [3].
Reference: [9] <author> S.L. Peyton Jones and D. Lester. </author> <title> A modular fully-lazy lambda lifter in Haskell. </title> <journal> Software Practice and Experience, </journal> <volume> 21(5), </volume> <month> May </month> <year> 1991. </year>
Reference-contexts: Note that these problems will not occur in an implementation that supports full laziness. Indeed, in each of the examples above, the improved translation can be obtained from the original version using a translation to fully-lazy form as described in <ref> [9] </ref>. 9 Performance Issues How do type classes affect the compiler? Our observation is that they increase compilation time only slightly. A minor increase in the cost of unification and the placement and resolution of placeholders make up the majority of the extra processing required for type classes.
Reference: [10] <author> S.L. Peyton Jones and P. Wadler. </author> <title> A static semantics for Haskell (draft). </title> <type> Manuscript, </type> <institution> Department of Computing Science, University of Glasgow, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: Further ideas, mostly at a fairly abstract level, were presented in the static semantics for Haskell <ref> [10] </ref> and also, concentrating on the problems of repeated dictionary construction, in [8]. Some of the techniques used to improve the performance of Haskell overloading in the Chalmers Haskell compiler are described in [3].
Reference: [11] <author> P. Wadler and S. Blott. </author> <title> How to make ad-hoc polymor-phism less ad-hoc. </title> <booktitle> In ACM Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: In addition, Appel [1] reports that "Equality types add significant complex ity to the language and its implementation". An alternative approach to the treatment of overloading was introduced by Wadler and Blott <ref> [11] </ref> based on the notion of a type class and is intended to provide a uniform and general framework for solving exactly these kinds of problems. <p> The algorithm presented here may repeatedly reconstruct identical copies of overloaded dictionaries if the underlying implementation is not fully-lazy. To illustrate how this problem can occur, consider the following implementation of the equality on lists in essentially the same form given by <ref> [11] </ref>: eqList d [] [] = True eqList d (x:xs) (y:ys) = eq d x y && eq (eqDList d) xs ys eqList d _ _ = False The eqDList function constructs a dictionary for equality on lists of type [a] given a dictionary d for equality on values of type <p> The addition of type classes does not severely impact either compiler or program performance. The basis for a translation from the Haskell syntax for declaring and using type classes was set out by Wadler and Blott <ref> [11] </ref> and some results from an early implementation based directly on these ideas have been presented by Hammond and Blott [5]. Further ideas, mostly at a fairly abstract level, were presented in the static semantics for Haskell [10] and also, concentrating on the problems of repeated dictionary construction, in [8].
References-found: 11

