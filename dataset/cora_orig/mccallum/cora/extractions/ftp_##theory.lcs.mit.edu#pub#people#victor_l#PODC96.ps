URL: ftp://theory.lcs.mit.edu/pub/people/victor_l/PODC96.ps
Refering-URL: http://theory.lcs.mit.edu/~victor_l/papers/PODC96.html
Root-URL: 
Title: Eventually-Serializable Data Services  
Author: Alan Fekete David Gupta Victor Luchangco Nancy Lynch Alex Shvartsman 
Abstract: We present a new specification for distributed data services that trade-off immediate consistency guarantees for improved system availability and efficiency, while ensuring the long-term consistency of the data. An eventually-serializable data service maintains the operations requested in a partial order that gravitates over time towards a total order. It provides clear and unambiguous guarantees about the immediate and long-term behavior of the system. To demonstrate its utility, we present an algorithm, based on one of Ladin, Liskov, Shrira, and Ghemawat [12], that implements this specification. Our algorithm provides the interface of the abstract service, and generalizes their algorithm by allowing general operations and greater flexibility in specifying consistency requirements. We also describe how to use this specification as a building block for applications such as directory services. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Alsberg and J. Day. </author> <title> A principle for resilient sharing of distributed resources. </title> <booktitle> In Proceedings of the 2nd International Conference on Software Engineering, </booktitle> <pages> pages 627-644, </pages> <month> Oct. </month> <year> 1976. </year>
Reference-contexts: The strongest and simplest notion of consistency is atomicity, which requires the replicas to collectively emulate a single centralized object. Methods to achieve atomicity include write-all/read-one [4], primary copy <ref> [1, 21, 18] </ref>, majority consensus [22], and quorum consensus [8, 9]. Because achieving atomicity often has a high performance cost, some applications, such as directory services, are willing to tolerate some transient inconsistencies. This gives rise to different notions of consistency.
Reference: [2] <author> H. Attiya and J. Welch. </author> <title> Sequential consistency versus linearizability. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12(2), </volume> <year> 1994. </year>
Reference-contexts: Sequential consistency [13], guaranteed by systems such as Orca [3], allows operations to be reordered as long as they remain consistent with the view of individual clients. An inherent disparity in the performance of atomic and sequentially consistent objects has been established <ref> [2] </ref>. Other systems provide even weaker guarantees to the clients [6, 5, 7] in order to get better performance. Improving performance by providing weaker guarantees results in more complicated semantics.
Reference: [3] <author> H. Bal, M. Kaashoek, and A. Tanenbaum. Orca: </author> <title> A language for parallel programming of distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(3) </volume> <pages> 190-205, </pages> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: Because achieving atomicity often has a high performance cost, some applications, such as directory services, are willing to tolerate some transient inconsistencies. This gives rise to different notions of consistency. Sequential consistency [13], guaranteed by systems such as Orca <ref> [3] </ref>, allows operations to be reordered as long as they remain consistent with the view of individual clients. An inherent disparity in the performance of atomic and sequentially consistent objects has been established [2].
Reference: [4] <author> P. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Con-currency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: The strongest and simplest notion of consistency is atomicity, which requires the replicas to collectively emulate a single centralized object. Methods to achieve atomicity include write-all/read-one <ref> [4] </ref>, primary copy [1, 21, 18], majority consensus [22], and quorum consensus [8, 9]. Because achieving atomicity often has a high performance cost, some applications, such as directory services, are willing to tolerate some transient inconsistencies. This gives rise to different notions of consistency.
Reference: [5] <author> A. Birrell, R. Levin, R. Needham, and M. Schroeder. Grapevine: </author> <title> An exercise in distributed computing. </title> <journal> Communications of the ACM, </journal> <volume> 25(4) </volume> <pages> 260-274, </pages> <year> 1982. </year>
Reference-contexts: An inherent disparity in the performance of atomic and sequentially consistent objects has been established [2]. Other systems provide even weaker guarantees to the clients <ref> [6, 5, 7] </ref> in order to get better performance. Improving performance by providing weaker guarantees results in more complicated semantics. Even when the behavior of the replicated objects is specified unambiguously, it is more difficult to understand and to reason about the correctness of implementations. <p> In a distributed computing enterprise, naming and directory are important and basic services used to make distributed resources accessible transparently to the locations or the physical addresses of users and resources. Such services include Grapevine <ref> [5] </ref>, DECdns [14], DCE GDS (Global Directory Service) and CDS (Cell Directory Service) [19], ISO/OSI X.500 [11], and the Internet's DNS (Domain Name System) [10]. A directory service must be robust and it must have good response time for name lookup and translation requests in a geographically distributed setting.
Reference: [6] <author> M. Fischer and A. Michael. </author> <title> Sacrificing serializability to attain high availability of data in an unreliable network. </title> <booktitle> In Proceedings of the ACM Symposium on Database Systems, </booktitle> <pages> pages 70-75, </pages> <month> Mar. </month> <year> 1982. </year>
Reference-contexts: An inherent disparity in the performance of atomic and sequentially consistent objects has been established [2]. Other systems provide even weaker guarantees to the clients <ref> [6, 5, 7] </ref> in order to get better performance. Improving performance by providing weaker guarantees results in more complicated semantics. Even when the behavior of the replicated objects is specified unambiguously, it is more difficult to understand and to reason about the correctness of implementations.
Reference: [7] <author> H. Garcia-Molina, N. Lynch, B. Blaustein, C. Kaufman, and O. Schmueli. </author> <title> Notes on a reliable broadcast protocol. </title> <type> Technical memorandum, </type> <institution> Computer Corporation America, </institution> <month> Oct. </month> <year> 1985. </year>
Reference-contexts: An inherent disparity in the performance of atomic and sequentially consistent objects has been established [2]. Other systems provide even weaker guarantees to the clients <ref> [6, 5, 7] </ref> in order to get better performance. Improving performance by providing weaker guarantees results in more complicated semantics. Even when the behavior of the replicated objects is specified unambiguously, it is more difficult to understand and to reason about the correctness of implementations.
Reference: [8] <author> D. Gifford. </author> <title> Weighted voting for replicated data. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Principles of Operating Systems Principles, </booktitle> <pages> pages 150-162, </pages> <month> Dec. </month> <year> 1979. </year>
Reference-contexts: The strongest and simplest notion of consistency is atomicity, which requires the replicas to collectively emulate a single centralized object. Methods to achieve atomicity include write-all/read-one [4], primary copy [1, 21, 18], majority consensus [22], and quorum consensus <ref> [8, 9] </ref>. Because achieving atomicity often has a high performance cost, some applications, such as directory services, are willing to tolerate some transient inconsistencies. This gives rise to different notions of consistency.
Reference: [9] <author> M. Herlihy. </author> <title> A quorum-consensus replication method for abstract data types. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 4(1) </volume> <pages> 32-53, </pages> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: The strongest and simplest notion of consistency is atomicity, which requires the replicas to collectively emulate a single centralized object. Methods to achieve atomicity include write-all/read-one [4], primary copy [1, 21, 18], majority consensus [22], and quorum consensus <ref> [8, 9] </ref>. Because achieving atomicity often has a high performance cost, some applications, such as directory services, are willing to tolerate some transient inconsistencies. This gives rise to different notions of consistency.
Reference: [10] <author> IETF. </author> <title> RFC 1034 and RFC 1035 Domain Name System, </title> <year> 1990. </year>
Reference-contexts: Such services include Grapevine [5], DECdns [14], DCE GDS (Global Directory Service) and CDS (Cell Directory Service) [19], ISO/OSI X.500 [11], and the Internet's DNS (Domain Name System) <ref> [10] </ref>. A directory service must be robust and it must have good response time for name lookup and translation requests in a geographically distributed setting. Access to a directory service is dominated by queries and it is unnecessary for the updates to be atomic in all cases.
Reference: [11] <institution> International Standard 9594-1, </institution> <note> Information Processing Systems|Open Systems Interconnection|The Directory, </note> <author> ISO and IEC, </author> <year> 1988. </year>
Reference-contexts: Such services include Grapevine [5], DECdns [14], DCE GDS (Global Directory Service) and CDS (Cell Directory Service) [19], ISO/OSI X.500 <ref> [11] </ref>, and the Internet's DNS (Domain Name System) [10]. A directory service must be robust and it must have good response time for name lookup and translation requests in a geographically distributed setting.
Reference: [12] <author> R. Ladin, B. Liskov, L. Shrira, and S. Ghemawat. </author> <title> Lazy replication: Exploiting the semantics of distributed services. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(4) </volume> <pages> 360-391, </pages> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: In practice, replicated systems are often incompletely or ambiguously specified. 1.1 Background of our Work As it is important that our specification be applicable for real systems, we build heavily on the work of Ladin, Liskov, Shrira, and Ghemawat <ref> [12] </ref> on highly available replicated data services. They specify general conditions for such a service, and present an algorithm based on lazy replication, in which operations received by each replica are gossiped in the background. <p> As long as most of the operations are of the weakest variety, their algorithm is very efficient. The specification in <ref> [12] </ref> is tuned for their algorithm, and exposes some of the implementation details to the clients. This makes it difficult to decompose the algorithm into modules with clear benefits and costs that can be easily understood. <p> We provide two types of operations: (a) strict operations, that are required to be stable at the time of the response, i.e., all operations that precede it must be totally ordered, and (b) operations that may be reordered after the response is issued. As in <ref> [12] </ref>, clients may also specify constraints on the order in which operations are applied to the data object. Our specification omits implementation details, allowing users to ignore the issues of replication and distribution, while giving implementors the freedom to design the system to best satisfy the performance requirements. <p> Particular system implementations, of course, may exploit the semantics of the specific data objects to improve performance. The algorithm we present is based on the lazy replication algorithm from <ref> [12] </ref>. We present a high-level formal description of the algorithm, which takes into account the replication of the data, and maintains consistency by propagating operations and bookkeeping information amongst replicas via gossip messages. <p> It provides a smooth combination of fast service with weak causality requirements and slower service with stronger requirements. It does not use the multipart timestamps of <ref> [12] </ref>, which we view as an optimization of the basic algorithm. By viewing the abstract algorithm as a specification for more detailed implementations, we indicate how to incorporate this, and other optimizations, may be incorporated into the framework of this paper, and we demonstrate this with some examples. <p> For example, if the identifiers included the date of request, and all operations are guaranteed to be stable within one day, then all identifiers more than a day old may be expunged from the memory. A more sophisticated approach might involve logical timestamps, such as the multipart timestamps of <ref> [12] </ref>. 4.3 Exploiting Commutativity Assumptions The algorithm of [12] is intended to be used when most of the operations require only causal ordering, but it allows two other types of operations which provide stronger ordering constraints. <p> A more sophisticated approach might involve logical timestamps, such as the multipart timestamps of <ref> [12] </ref>. 4.3 Exploiting Commutativity Assumptions The algorithm of [12] is intended to be used when most of the operations require only causal ordering, but it allows two other types of operations which provide stronger ordering constraints. The ordering constraints on an operation are determined by the application developer, not the client, based on "permissible concur-rency". <p> However, a weaker variation may be sufficient for the algorithm of <ref> [12] </ref> since updates and queries are handled differently, and operations may not simul taneously read and write the data.
Reference: [13] <author> L. Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 28(9) </volume> <pages> 690-691, </pages> <month> Sept. </month> <year> 1979. </year>
Reference-contexts: Because achieving atomicity often has a high performance cost, some applications, such as directory services, are willing to tolerate some transient inconsistencies. This gives rise to different notions of consistency. Sequential consistency <ref> [13] </ref>, guaranteed by systems such as Orca [3], allows operations to be reordered as long as they remain consistent with the view of individual clients. An inherent disparity in the performance of atomic and sequentially consistent objects has been established [2].
Reference: [14] <author> B. Lampson. </author> <title> Desiging a global name service. </title> <booktitle> In Proceedings of the 5th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 1-10, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: In a distributed computing enterprise, naming and directory are important and basic services used to make distributed resources accessible transparently to the locations or the physical addresses of users and resources. Such services include Grapevine [5], DECdns <ref> [14] </ref>, DCE GDS (Global Directory Service) and CDS (Cell Directory Service) [19], ISO/OSI X.500 [11], and the Internet's DNS (Domain Name System) [10]. A directory service must be robust and it must have good response time for name lookup and translation requests in a geographically distributed setting.
Reference: [15] <author> N. Lynch and F. Vaandrager. </author> <title> Forward and backward simulations Part I: </title> <journal> Untimed systems. Information and Computation, </journal> <volume> 121(2) </volume> <pages> 214-233, </pages> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: We also present an algorithm that implements the abstract specification, which we prove using invariants and a forward simulation <ref> [15] </ref>. By making simple assumptions about the timing of message-based communication, we also provide time bounds for the data service. The eventually-serializable data service specification uses a partial order on operations that gravitates to a total order over time. <p> As information about the operations is gossiped, the system converges on certain constraints. We denote this by system cons = T r local cons r " T T m2channel r 0 ;r msg cons (m). To show that this system meets the specification, we establish a simulation <ref> [15] </ref> from the algorithm automaton to the specification. Let AbsAlg be the composition of all the frontend, channel, and replica automata, with the send and receive actions hidden.
Reference: [16] <author> N. A. Lynch and M. R. Tuttle. </author> <title> An introduction to Input/Output automata. </title> <journal> CWI-Quarterly, </journal> <volume> 2(3) </volume> <pages> 219-246, </pages> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: The clients must also ensure that prev sets contain only identifiers of operations that have already been requested by some client. To formally describe the system and its requirements, we use the I/O automaton model <ref> [16] </ref>. The system is defined by Spec in Figure 1, where O is the set of all operation descriptors. We denote the set of identifiers of the operations in X O by X:id.
Reference: [17] <institution> Object Management Group, Framingham, MA. Common Object Request Broker Architecture, </institution> <year> 1992. </year>
Reference-contexts: In our implementation this is accomplished by including the identifier of the name creation operation in the prev sets of the attribute creation and initialization operations. 5.2 Distributed Information Repository Another application of the data service is in implementing distributed information repositories for coarse-grained distributed object frameworks such as CORBA <ref> [17] </ref>. Important components of a framework is its distributed type system used to define object types, and its module implementation repository used for dynamic object dispatching [20].
Reference: [18] <author> B. Oki and B. Liskov. </author> <title> Viewstamp replication: A new primary copy method to support highly-available distributed systems. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Principles of Distributed Computing, </booktitle> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: The strongest and simplest notion of consistency is atomicity, which requires the replicas to collectively emulate a single centralized object. Methods to achieve atomicity include write-all/read-one [4], primary copy <ref> [1, 21, 18] </ref>, majority consensus [22], and quorum consensus [8, 9]. Because achieving atomicity often has a high performance cost, some applications, such as directory services, are willing to tolerate some transient inconsistencies. This gives rise to different notions of consistency.
Reference: [19] <institution> Open Software Foundation, </institution> <address> Cambridge, MA. </address> <note> Introduction to OSF DCE, </note> <year> 1992. </year>
Reference-contexts: By making all the assumptions and guarantees explicit, the formal framework allows us to reason carefully about the system. Together with the abstract algorithm, the specification can guide the implementation of distributed system building blocks layered on general-purpose distributed platforms (middleware) such as DCE <ref> [19] </ref>, and the specification of the middle-ware components themselves. We provide an example of this, using a distributed directory service. 2 Specification of an Eventually-Serializable Data Service The memory system manages data whose serial behavior is defined by some data object, and a collection of operators on that object. <p> In a distributed computing enterprise, naming and directory are important and basic services used to make distributed resources accessible transparently to the locations or the physical addresses of users and resources. Such services include Grapevine [5], DECdns [14], DCE GDS (Global Directory Service) and CDS (Cell Directory Service) <ref> [19] </ref>, ISO/OSI X.500 [11], and the Internet's DNS (Domain Name System) [10]. A directory service must be robust and it must have good response time for name lookup and translation requests in a geographically distributed setting.
Reference: [20] <author> A. Shvartsman and C. Strutt. </author> <title> Distributed object management and generic applications. </title> <institution> Computer Science TR 94-176, Brandeis University, </institution> <year> 1994. </year>
Reference-contexts: Important components of a framework is its distributed type system used to define object types, and its module implementation repository used for dynamic object dispatching <ref> [20] </ref>. In this setting the access patterns are again dominated by queries, while infrequent update requests can be propagated lazily with the guarantee of eventual consistency. We plan to specify such service using our framework.
Reference: [21] <author> M. Stonebraker. </author> <title> Concurrency control and consistency of multiple copies of data in distributed INGRES. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 5(3) </volume> <pages> 188-194, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: The strongest and simplest notion of consistency is atomicity, which requires the replicas to collectively emulate a single centralized object. Methods to achieve atomicity include write-all/read-one [4], primary copy <ref> [1, 21, 18] </ref>, majority consensus [22], and quorum consensus [8, 9]. Because achieving atomicity often has a high performance cost, some applications, such as directory services, are willing to tolerate some transient inconsistencies. This gives rise to different notions of consistency.
Reference: [22] <author> R. Thomas. </author> <title> A majority consensus approach to concur-rency control for multiple copy databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(2) </volume> <pages> 180-209, </pages> <month> June </month> <year> 1979. </year>
Reference-contexts: The strongest and simplest notion of consistency is atomicity, which requires the replicas to collectively emulate a single centralized object. Methods to achieve atomicity include write-all/read-one [4], primary copy [1, 21, 18], majority consensus <ref> [22] </ref>, and quorum consensus [8, 9]. Because achieving atomicity often has a high performance cost, some applications, such as directory services, are willing to tolerate some transient inconsistencies. This gives rise to different notions of consistency.
References-found: 22

