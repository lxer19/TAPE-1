URL: http://www.cs.unc.edu/~anderson/papers/scp95.ps.Z
Refering-URL: http://www.cs.unc.edu/~anderson/papers.html
Root-URL: http://www.cs.unc.edu
Title: Wait-Free Algorithms for Fast, Long-Lived Renaming  
Author: Mark Moir and James H. Anderson 
Date: August 1994  
Address: Chapel Hill, North Carolina 27599-3175, USA  
Affiliation: Department of Computer Science The University of North Carolina at Chapel Hill  
Abstract: We consider wait-free solutions to the renaming problem for shared-memory multiprocessing systems [3, 5]. In the renaming problem, processes are required to choose new names in order to reduce the size of their name space. Previous solutions to the renaming problem have time complexity that is dependent on the size of the original name space, and allow processes to acquire names only once. In this paper, we present several new renaming algorithms. Most of our algorithms have time complexity that is independent of the size of the original name space, and some of our algorithms solve a new, more general version of the renaming problem called long-lived renaming. In long-lived renaming algorithms, processes may repeatedly acquire and release names.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Anderson and M. Moir, </author> <title> "Using k-Exclusion to Implement Resilient, Scalable Shared Objects", </title> <booktitle> to appear in Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing </booktitle> . 
Reference-contexts: This is the essence of an approach for the implementation of resilient, scalable shared objects presented by us in <ref> [1] </ref>. Note that this approach only restricts the number of processes that access the implementation concurrently. Over time, many processes may access the implementation. <p> Over time, many processes may access the implementation. Thus, it is not sufficient to simply acquire a name once and retain that name for future use: a process must be able to release its name so that another process may later acquire the same name. In <ref> [1] </ref>, we presented a simple long-lived renaming algorithm. To our knowledge, this is the only previous work on long-lived renaming. In this paper, we present several new long-lived renaming algorithms, one of which is a generalization of the algorithm we presented in [1]. <p> In <ref> [1] </ref>, we presented a simple long-lived renaming algorithm. To our knowledge, this is the only previous work on long-lived renaming. In this paper, we present several new long-lived renaming algorithms, one of which is a generalization of the algorithm we presented in [1]. In the first part of the paper, we present three renaming algorithms that use only atomic read and write instructions. It has been shown that if M &lt; 2k 1, then M -renaming cannot be implemented in a wait-free manner using only atomic reads and writes [7]. <p> An example is shown in Figure 7 for b = 4 and k = 10. In this figure, process p releases name 1 by executing clear bit (X [0]; 1) and process q acquires name 5 by executing set first zero (X <ref> [1] </ref>). 18 shared variable X : array [0::bk=bc] of array [0::b 1] of boolean =fl b-bit "segments" of the name space fl= initially (8i; j : 0 i bk=bc ^ 0 j &lt; b :: :X [i][j]) process p =fl 0 p &lt; N fl= private variable h : 0::bk=bc + <p> For process q, q@1 ^ q:h = 1 holds, so q is about to execute set first zero (X <ref> [1] </ref>). As X [1][1] is the first clear bit in X [1], q:1 will establish q@2 ^ q:h = 2 ^ q:v = 1, and will therefore acquire name 5. (b) Process p has released name 1 and process q has acquired name 5. invariant (A1) ^ (A2) (I34) Proof: Initially <p> For process q, q@1 ^ q:h = 1 holds, so q is about to execute set first zero (X <ref> [1] </ref>). As X [1][1] is the first clear bit in X [1], q:1 will establish q@2 ^ q:h = 2 ^ q:v = 1, and will therefore acquire name 5. (b) Process p has released name 1 and process q has acquired name 5. invariant (A1) ^ (A2) (I34) Proof: Initially (8p :: p@0) ^ :X [i][j] holds, so (I34) holds.
Reference: [2] <author> H. Attiya, A. Bar-Noy, D. Dolev, D. Koller, D. Peleg, and R. Reischuk, </author> <title> "Achievable Cases in an Asynchronous Environment", </title> <booktitle> Proceedings of the 28th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1987, </year> <pages> pp. 337-346. </pages>
Reference-contexts: 1 Introduction In the M renaming problem <ref> [2] </ref>, each of k processes is required to choose a distinct value, called a name, that ranges over f0; :::; M 1g. Each process is assumed to have a unique process identifier ranging over f0::N 1g. It is further required that k M &lt; N . <p> By first using an efficient renaming algorithm to reduce the size of the name space, the time complexity of that computation can be made independent of the size of the original name space. The renaming problem has been studied previously for both message-passing <ref> [2] </ref> and shared-memory multiprocessing systems [3, 5]. In this paper, we consider wait-free implementations of renaming in asynchronous, shared-memory systems. A renaming algorithm is wait-free iff each process is guaranteed to acquire a name after a finite number of that process's steps, regardless of the execution speeds of other processes.
Reference: [3] <author> A. Bar-Noy and D. Dolev, </author> <title> "Shared Memory versus Message-Passing in an Asynchronous Distributed Environment", </title> <booktitle> Proceedings of the 8th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1989, </year> <pages> pp. 307-318. </pages>
Reference-contexts: By first using an efficient renaming algorithm to reduce the size of the name space, the time complexity of that computation can be made independent of the size of the original name space. The renaming problem has been studied previously for both message-passing [2] and shared-memory multiprocessing systems <ref> [3, 5] </ref>. In this paper, we consider wait-free implementations of renaming in asynchronous, shared-memory systems. A renaming algorithm is wait-free iff each process is guaranteed to acquire a name after a finite number of that process's steps, regardless of the execution speeds of other processes. <p> For such implementations, performance can fl Work supported, in part, by NSF Contract CCR-9216421. Authors' e-mail addresses: fmoir,andersong@cs.unc.edu. Preliminary version to be presented at the Eighth International Workshop on Distributed Algorithms, Terschelling, The Netherlands, September, 1994. 1 Reference M Time Complexity Long-Lived? <ref> [3] </ref> k (k + 1)=2 fi (N k) No [5] 2k 1 fi (N k 2 ) No Thm. 2 2k 1 fi (k 4 ) No Table 1: A comparison of wait-free M -renaming algorithms that employ only atomic reads and writes. be improved by restricting the number of processes <p> It has been shown that if M &lt; 2k 1, then M -renaming cannot be implemented in a wait-free manner using only atomic reads and writes [7]. Some of the previous wait-free, read/write algorithms for one-time renaming <ref> [3, 5] </ref> yield an optimal name space of M = 2k 1. However, in all of these algorithms, the time complexity of choosing a name is dependent on N .
Reference: [4] <institution> BBN Advanced Computers, Inside the TC2000 Computer, </institution> <month> February, </month> <year> 1990. </year>
Reference-contexts: fi (log k) bounded decrement and atomic add Thm. 6 fi (log (k=b)) fi (log k) above, set first zero, and clr bit Table 2: A comparison of wait-free long-lived k-renaming algorithms. b &gt; 1 can be implemented, for example, using the atomff0andset operation available on the BBN TC2000 multiprocessor <ref> [4] </ref>. The clr bit (X; i) operation clears the ith bit of X. For b = 1, clr bit is a simple write operation. For b &gt; 1, clr bit can be implemented, for example, using the fetch and and operation available on the BBN TC2000. <p> The first algorithm uses set first zero and clr bit and has time complexity fi (k=b). As discussed in Section 1, these operations can be implemented, for example, using operations available on the BBN TC2000 <ref> [4] </ref>. The second algorithm in this section has time complexity fi (log k) | a significant improvement over the first algorithm. To achieve this improvement, this algorithm uses the bounded decrement operation.
Reference: [5] <author> E. Borowsky and E. Gafni, </author> <title> "Immediate Atomic Snapshots and Fast Renaming", </title> <booktitle> Proceedings of the 12th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1993, </year> <pages> pp. 41-50. </pages>
Reference-contexts: By first using an efficient renaming algorithm to reduce the size of the name space, the time complexity of that computation can be made independent of the size of the original name space. The renaming problem has been studied previously for both message-passing [2] and shared-memory multiprocessing systems <ref> [3, 5] </ref>. In this paper, we consider wait-free implementations of renaming in asynchronous, shared-memory systems. A renaming algorithm is wait-free iff each process is guaranteed to acquire a name after a finite number of that process's steps, regardless of the execution speeds of other processes. <p> Authors' e-mail addresses: fmoir,andersong@cs.unc.edu. Preliminary version to be presented at the Eighth International Workshop on Distributed Algorithms, Terschelling, The Netherlands, September, 1994. 1 Reference M Time Complexity Long-Lived? [3] k (k + 1)=2 fi (N k) No <ref> [5] </ref> 2k 1 fi (N k 2 ) No Thm. 2 2k 1 fi (k 4 ) No Table 1: A comparison of wait-free M -renaming algorithms that employ only atomic reads and writes. be improved by restricting the number of processes that concurrently access the implementation, and by using long-lived <p> It has been shown that if M &lt; 2k 1, then M -renaming cannot be implemented in a wait-free manner using only atomic reads and writes [7]. Some of the previous wait-free, read/write algorithms for one-time renaming <ref> [3, 5] </ref> yield an optimal name space of M = 2k 1. However, in all of these algorithms, the time complexity of choosing a name is dependent on N . <p> We start by presenting a (k (k + 1)=2)-renaming algorithm that has fi (k) time complexity. We then describe how this algorithm can be combined with previous results <ref> [5] </ref> to obtain a (2k 1)-renaming algorithm with fi (k 4 ) time complexity. It has been shown that renaming is impossible for fewer than 2k 1 names when using only reads and writes, so with respect to the size of the resulting name space, this algorithm is optimal. <p> Using the algorithm presented in <ref> [5] </ref>, k processes can reduce the size of their name space from N to 2k 1 with time complexity fi (N k 2 ).
Reference: [6] <author> C. A. R. Hoare, </author> <title> "An Axiomatic Basis for Computer Programming", </title> <journal> Communications of the ACM 12, </journal> <month> October </month> <year> 1969, </year> <pages> pp. </pages> <address> 576-580,583. </address> <month> 29 </month>
Reference-contexts: Symbols in parentheses have the same binding power. We sometimes use parentheses to override these binding rules. In our proofs, we sometimes use Hoare triples <ref> [6] </ref> to denote the effects of a statement execution. 2 In the one-time M -renaming problem, each of k processes, with distinct process identifiers ranging over f0; :::; N 1g, chooses a distinct value ranging over f0; :::; M 1g.
Reference: [7] <author> M. Herlihy and N. Shavit, </author> <title> "The Asynchronous Computability Theorem for t-Resilient Tasks", </title> <booktitle> Proceed--ings of the 25th ACM Symposium on Theory of Computing, </booktitle> <year> 1993, </year> <pages> pp. 111-120. </pages>
Reference-contexts: In the first part of the paper, we present three renaming algorithms that use only atomic read and write instructions. It has been shown that if M &lt; 2k 1, then M -renaming cannot be implemented in a wait-free manner using only atomic reads and writes <ref> [7] </ref>. Some of the previous wait-free, read/write algorithms for one-time renaming [3, 5] yield an optimal name space of M = 2k 1. However, in all of these algorithms, the time complexity of choosing a name is dependent on N . <p> Combining the two algorithms, k processes can reduce the size of their name space from N to 2k 1 with time complexity fi (k) + fi ((k (k + 1)=2)k 2 ) = fi (k 4 ). Thus, we have the following result. By the results of <ref> [7] </ref>, this algorithm is optimal with respect to the size of the name space. <p> By using read-modify-write operations, these algorithms significantly improve upon the performance of the algorithms in the previous section. Furthermore, these algorithms yield a name space of size k, which is clearly optimal (the lower bound results of <ref> [7] </ref> do not apply to algorithms that employ read-modify-write operations). The first algorithm uses set first zero and clr bit and has time complexity fi (k=b). As discussed in Section 1, these operations can be implemented, for example, using operations available on the BBN TC2000 [4].
Reference: [8] <author> L. Lamport, </author> <title> "A Fast Mutual Exclusion Algorithm", </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 5, No. 1, </volume> <month> February </month> <year> 1987, </year> <pages> pp. 1-11. 30 </pages>
Reference-contexts: In contrast to prior algorithms, our one-time renaming algorithms have time complexity that depends only on k, the number of participating processes. These algorithms employ a novel technique that uses "building blocks" based on the "fast path" mechanism employed by Lamport's fast mutual exclusion algorithm <ref> [8] </ref>. We also present a read/write algorithm for long-lived renaming that yields a name space of size k (k + 1)=2. This algorithm uses a modified version of the one-time building block that allows processes to "reset" the building block, so that it may be used repeatedly. <p> The code fragment shown in Figure 2 shows how the building block can be implemented using atomic read and write operations. The technique employed is essentially that of the "fast path" mechanism used in Lamport's fast mutual exclusion algorithm <ref> [8] </ref>. A process that stops corresponds to a process successfully "taking the fast path" in Lamport's algorithm. <p> All of our wait-free algorithms, except the one shown in Figure 8, have the desirable property that time complexity is proportional to contention. This is an important practical advantage because contention should be low in most well-designed applications <ref> [8] </ref>. The algorithm in Figure 8 has time complexity that is logarithmic in k, regardless of the level of contention. There are several questions left open by our research.
References-found: 8

