URL: http://www.cs.iastate.edu/tech-reports/TR97-12a.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Executing Formal Specifications with Constraint Programming  
Author: Tim Wahls, Gary T. Leavens, and Albert L. Baker TR #-a Tim Wahls, Gary T. Leavens and Albert L. Baker. 
Keyword: Executable specifications, constraint programming, SPECS-C++ AKL, behavioral interface specification, C++, model-based specification, precondition, postcondition, formal specification, prototyp-ing, constraint solving, constraint satisfaction, sets, unions, sequences, tuples, objects, first-order predicate calculus. 1997 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications Languages, reliability, theory, tools, SPECS-C++; D.2.7 [Software Engineering] Distribution and Maintenance Documentation; D.2.m [Software Engineering] Miscellaneous Rapid prototyping; D.3.2 [Programming Languages] Language Classifications Nonprocedural languages, Very high-level languages; D.3.4 [Programming Languages] Processors Interpreters; Very high-level languages; F.3.1 [Logics and Meanings of Programs] Specifying and Verifying and Reasoning about Programs Assertions, pre- and post-conditions, specification techniques.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: An earlier version of this report was titled "Executing Formal Specifications with Constraint Satisfaction."  Submitted for publication. Copyright c 1997, 1998 by  
Date: August 1997, revised June 1998  
Abstract-found: 0
Intro-found: 1
Reference: [Andersen et al., 1992] <author> Andersen, M., Elmstrtm, R., Lassen, P. B., and Larsen, P. G. </author> <year> (1992). </year> <title> Making specifications executable using IPTES Meta-IV. </title> <booktitle> In Euromicro '92. </booktitle>
Reference-contexts: 1 Introduction Executable specifications <ref> [Andersen et al., 1992] </ref> [Hekmatpour and Ince, 1988] [Kamin and Kraus, 1993] [Tyszberowicz and Yehudai, 1992] [Terwilliger and Campbell, 1989] [Henderson, 1986] [O'Neill, 1992a] have advantages over nonexecutable specifications as tools for validating specifications against informal requirements, for prototyping, and for testing that implementations satisfy specifications. <p> This is the most prevalent approach, and examples include SMLVIEW [O'Neill, 1992a] [O'Neill, 1992b], me too [Henderson, 1986], EPROL [Hekmatpour and Ince, 1988] [Hekmatpour and Ince, 1986], and the technique used for executing IPTES mini-specifications [Elmstrtm et al., 1993] [Larsen and Lassen, 1991] <ref> [Andersen et al., 1992] </ref>.
Reference: [Andrews et al., 1993] <author> Andrews, D. et al. </author> <year> (1993). </year> <title> Information technology programming languages - VDM-SL: First committee draft standard CD1387-1. Document ISO/IEC JTC1/SC22/WG19 N-20, International Standards Organization. </title> <publisher> ftp://gatekeeper.dec.com/pub/standards/vdmsl/. </publisher>
Reference-contexts: Our approach makes little use of the C++ specific features of SPECS-C++ except as described in Section 3, and so should be suitable for executing specifications written in other model-based specification languages such as VDM [Jones, 1990] <ref> [Andrews et al., 1993] </ref>, Z [Hayes, 1993] [Spivey, 1989] [Spivey, 1992] and JML [Leavens et al., 1998] with only straightforward modifications. We execute SPECS-C++ specifications by translating them to Agents Kernel Language (AKL) [Janson and Haridi, 1994], and then executing the resulting AKL program. <p> The most prominent examples are VDM [Jones, 1990] <ref> [Andrews et al., 1993] </ref> and Z [Hayes, 1993] [Spivey, 1989] [Spivey, 1992], although many other model-based specification languages have been developed. The model typically includes primitive types such as integers and characters, as well as more structured types such as finite sets, sequences, tuples, and functions.
Reference: [Borgida et al., 1995] <author> Borgida, A., Mylopoulos, J., and Reiter, R. </author> <year> (1995). </year> <title> On the frame problem in procedure specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(10) </volume> <pages> 785-798. </pages>
Reference-contexts: The formal parameters of the agent are the parameters of the member function definition and the three additional parameters previously discussed. The modifies clause specifies which objects can change from the pre-state to the post-state [Guttag et al., 1993] [Wing, 1987] <ref> [Borgida et al., 1995] </ref>, and so this clause is used to construct the post-state store that will be passed to the agent.
Reference: [Clocksin and Mellish, 1984] <author> Clocksin, W. F. and Mellish, C. S. </author> <year> (1984). </year> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <note> second edition. </note>
Reference-contexts: AKL is described in Section 2, so here we simply note that we selected AKL as a translation target after evaluating a number of other possibilities, including Prolog <ref> [Clocksin and Mellish, 1984] </ref> [Colmerauer, 1985] [Cohen, 1985], clp (FD) [Diaz, 1994] and DFKI Oz [Mehl et al., 1998]. AKL works well as a translation target largely because it has a simple syntax and because it supports constraint programming cleanly.
Reference: [Cohen, 1985] <author> Cohen, J. </author> <year> (1985). </year> <title> Describing Prolog by its interpretation and compilation. </title> <journal> Communications of the ACM, </journal> <volume> 28(12) </volume> <pages> 1311-1324. </pages>
Reference-contexts: AKL is described in Section 2, so here we simply note that we selected AKL as a translation target after evaluating a number of other possibilities, including Prolog [Clocksin and Mellish, 1984] [Colmerauer, 1985] <ref> [Cohen, 1985] </ref>, clp (FD) [Diaz, 1994] and DFKI Oz [Mehl et al., 1998]. AKL works well as a translation target largely because it has a simple syntax and because it supports constraint programming cleanly.
Reference: [Colmerauer, 1985] <author> Colmerauer, A. </author> <year> (1985). </year> <title> Prolog in 10 figures. </title> <journal> Communications of the ACM, </journal> <volume> 28(12):1296 - 1310. </volume>
Reference-contexts: AKL is described in Section 2, so here we simply note that we selected AKL as a translation target after evaluating a number of other possibilities, including Prolog [Clocksin and Mellish, 1984] <ref> [Colmerauer, 1985] </ref> [Cohen, 1985], clp (FD) [Diaz, 1994] and DFKI Oz [Mehl et al., 1998]. AKL works well as a translation target largely because it has a simple syntax and because it supports constraint programming cleanly.
Reference: [Dhara and Leavens, 1996] <author> Dhara, K. K. and Leavens, G. T. </author> <year> (1996). </year> <title> Forcing behavioral subtyping through specification inheritance. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <pages> pages 258-267. </pages> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In terms of inheritance (and subtyping), our experience is that these relationships in most specifications of C++ classes are easily implemented by syntactic changes to the specification for example, copying the specification of an operation from the specification of the base class to the specification of the derived class <ref> [Dhara and Leavens, 1996] </ref>. Hence, our execution technique assumes that such changes are made before the specification is executed, and so does not deal with inheritance and subtyping directly. Besides objects, other domains of SPECS-C++ (and many other model-based specification languages) include the booleans, integers, tuples, sets and sequences.
Reference: [Diaz, 1994] <author> Diaz, D. </author> <year> (1994). </year> <note> clp(FD) 2.21 User's Manual. </note> <institution> INRIA-Rocquencourt, Domaine de Voluceau, 78153 Le Chesnay, France. </institution>
Reference-contexts: AKL is described in Section 2, so here we simply note that we selected AKL as a translation target after evaluating a number of other possibilities, including Prolog [Clocksin and Mellish, 1984] [Colmerauer, 1985] [Cohen, 1985], clp (FD) <ref> [Diaz, 1994] </ref> and DFKI Oz [Mehl et al., 1998]. AKL works well as a translation target largely because it has a simple syntax and because it supports constraint programming cleanly. The rest of this paper elaborates the idea of executing formal specifications by translating them to constraint programs. <p> For example, if the domain of X is 1 through 10 and the finite domain constraint X &lt; 5 is told, then the domain of X is restricted to 1 through 4. Many constraint languages (including CHIP [Van Hentenryck, 1989], clp (FD) <ref> [Diaz, 1994] </ref> and DFKI Oz [Mehl et al., 1998]) use a similar notion of finite domains, and the theory is well established. However, we have not yet been able to generate reliable AKL programs using such constraints.
Reference: [Dick et al., 1990] <author> Dick, A., Krause, P., and Cozens, J. </author> <year> (1990). </year> <title> Computer aided transformation of Z into Prolog. </title> <editor> In Nicholls, J., editor, </editor> <booktitle> Z User Workshop, Oxford 1989, Workshops in Computing, </booktitle> <pages> pages 71-85, </pages> <address> Berlin. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Use Prolog syntax or code in the specification language, and execute specifications via Prolog. PLEASE [Terwilliger and Campbell, 1989] and OBSERV [Tyszberowicz and Yehudai, 1992] are rep resentative examples. 3. Explicitly translate specifications to Prolog programs. Researchers have experimented with this approach <ref> [Dick et al., 1990] </ref> [West and Eaglestone, 1992], but to the authors' knowledge, no com pletely automated translator exists.
Reference: [Donnelly and Stallman, 1995] <author> Donnelly, C. and Stallman, R. </author> <year> (1995). </year> <title> Bison TheYACC-compatible Parser Generator. Free Software Foundation, </title> <address> Cambridge, MA. </address>
Reference-contexts: top level, we execute SPECS-C++ specifications by the following process: 1. translate the SPECS-C++ specification and code for testing the specification (declarations of in stances of the class and other variables, and calls to the member functions) to a syntax tree using standard compiler techniques (Flex [Paxson, 1990] and Bison <ref> [Donnelly and Stallman, 1995] </ref>), 2. typecheck the syntax tree and make some small modifications to ease code generation, 3. replace all variables bound by quantifiers with fresh variables to prevent capture of free variables during code generation, 4. generate an AKL program, 5. and finally, load the AKL program and the
Reference: [Elmstrtm et al., 1993] <author> Elmstrtm, R., Lassen, P., and Andersen, M. </author> <year> (1993). </year> <title> An executable subset of VDM-SL, in an SA/RT framework. </title> <note> Submitted for publication in Real-Time Systems Journal. </note>
Reference-contexts: This is the most prevalent approach, and examples include SMLVIEW [O'Neill, 1992a] [O'Neill, 1992b], me too [Henderson, 1986], EPROL [Hekmatpour and Ince, 1988] [Hekmatpour and Ince, 1986], and the technique used for executing IPTES mini-specifications <ref> [Elmstrtm et al., 1993] </ref> [Larsen and Lassen, 1991] [Andersen et al., 1992].
Reference: [Gurski and Baker, 1994] <author> Gurski, M. and Baker, A. L. </author> <year> (1994). </year> <title> Testing SPECS-C++: A first step in validating distributed systems specifications. </title> <booktitle> In Proceedings of the ISMM International Conference on Intelligent Information Management Systems, </booktitle> <pages> pages 105 - 108, </pages> <address> Washington, D.C. </address> <month> 14 </month>
Reference-contexts: The idea is to provide a "drag-and-drop" environment for building pre-state values of the SPECS-C++ model types, a convenient interface for using these values as inputs to the generated AKL programs, and a nicely formatted display of the resulting post-state. A similar environment has already been developed <ref> [Gurski and Baker, 1994] </ref> for a previous version of our translator. Another possible addition is support for calling the AKL code generated directly from a C++ program. <p> Finally, our technique is ideal for using specifications as test oracles, since it allows outputs from a specification and an implementation to be compared directly <ref> [Gurski and Baker, 1994] </ref>. In fact, our technique can even test whether a deterministic implementation satisfies a nondeterministic specification in a much more efficient way than backtracking through all results from the specification and comparing them to the result from the implementation.
Reference: [Guttag et al., 1993] <author> Guttag, J. V., Horning, J. J., Garland, S. J., Jones, K. D., Modet, A., and Wing, J. M. </author> <year> (1993). </year> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York. </address>
Reference-contexts: The formal parameters of the agent are the parameters of the member function definition and the three additional parameters previously discussed. The modifies clause specifies which objects can change from the pre-state to the post-state <ref> [Guttag et al., 1993] </ref> [Wing, 1987] [Borgida et al., 1995], and so this clause is used to construct the post-state store that will be passed to the agent.
Reference: [Hayes, 1993] <author> Hayes, I., </author> <title> editor (1993). Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition. </note>
Reference-contexts: Our approach makes little use of the C++ specific features of SPECS-C++ except as described in Section 3, and so should be suitable for executing specifications written in other model-based specification languages such as VDM [Jones, 1990] [Andrews et al., 1993], Z <ref> [Hayes, 1993] </ref> [Spivey, 1989] [Spivey, 1992] and JML [Leavens et al., 1998] with only straightforward modifications. We execute SPECS-C++ specifications by translating them to Agents Kernel Language (AKL) [Janson and Haridi, 1994], and then executing the resulting AKL program. <p> The most prominent examples are VDM [Jones, 1990] [Andrews et al., 1993] and Z <ref> [Hayes, 1993] </ref> [Spivey, 1989] [Spivey, 1992], although many other model-based specification languages have been developed. The model typically includes primitive types such as integers and characters, as well as more structured types such as finite sets, sequences, tuples, and functions.
Reference: [Hayes and Jones, 1989] <author> Hayes, I. J. and Jones, C. B. </author> <year> (1989). </year> <title> Specifications are not (necessarily) executable. </title> <journal> IEE, Software Engineering Journal, </journal> <volume> 4(6) </volume> <pages> 320-338. </pages>
Reference-contexts: However, as Hayes and Jones have pointed out <ref> [Hayes and Jones, 1989] </ref>, executable specifications are usually inferior to nonexecutable ones in a number of important ways, including: * executable specifications typically suffer from implementation bias and overspecification. A specification that includes an algorithm implementing the specified functionality can influence developers to use that algorithm in an implementation. <p> This is accomplished in the specification by passing an existentially quantified variable as the vertex set argument. "Running backward" in this manner is equivalent to "specification by inverse" <ref> [Hayes and Jones, 1989] </ref>, and so is another way in which our technique can execute specifications that other techniques can not. Function maxclique also shows a constructive use of negation in its last conjunct (used for finding a largest clique). <p> Function maxclique also shows a constructive use of negation in its last conjunct (used for finding a largest clique). This use of negation is similar to examples used by Hayes and Jones <ref> [Hayes and Jones, 1989] </ref> to argue that many specifications using negation are inherently nonexecutable. <p> Explicitly translate specifications to Prolog programs. Researchers have experimented with this approach [Dick et al., 1990] [West and Eaglestone, 1992], but to the authors' knowledge, no com pletely automated translator exists. Clearly, all of these approaches that are automated suffer from the criticisms leveled by Hayes and Jones <ref> [Hayes and Jones, 1989] </ref>, as they either force overspecification (e.g., by requiring "extra" informa 13 tion used for execution as in Prolog programs), or greatly restrict the specification language constructs available to the specifier. 8 Conclusion Although our approach requires the specifier to make some concessions to executability, it does execute
Reference: [Hekmatpour and Ince, 1986] <author> Hekmatpour, S. and Ince, D. C. </author> <year> (1986). </year> <title> A formal specification-based prototyping system. </title> <editor> In Barnes, D. and Brown, P., editors, </editor> <booktitle> Software Engineering 86, </booktitle> <pages> pages 317 - 335. </pages> <publisher> Peter Peregrinus Ltd., </publisher> <address> London, UK. </address>
Reference-contexts: This is the most prevalent approach, and examples include SMLVIEW [O'Neill, 1992a] [O'Neill, 1992b], me too [Henderson, 1986], EPROL [Hekmatpour and Ince, 1988] <ref> [Hekmatpour and Ince, 1986] </ref>, and the technique used for executing IPTES mini-specifications [Elmstrtm et al., 1993] [Larsen and Lassen, 1991] [Andersen et al., 1992].
Reference: [Hekmatpour and Ince, 1988] <author> Hekmatpour, S. and Ince, D. C. </author> <year> (1988). </year> <title> Software Prototyping, Formal Methods, and VDM. </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England. </address>
Reference-contexts: 1 Introduction Executable specifications [Andersen et al., 1992] <ref> [Hekmatpour and Ince, 1988] </ref> [Kamin and Kraus, 1993] [Tyszberowicz and Yehudai, 1992] [Terwilliger and Campbell, 1989] [Henderson, 1986] [O'Neill, 1992a] have advantages over nonexecutable specifications as tools for validating specifications against informal requirements, for prototyping, and for testing that implementations satisfy specifications. <p> This is the most prevalent approach, and examples include SMLVIEW [O'Neill, 1992a] [O'Neill, 1992b], me too [Henderson, 1986], EPROL <ref> [Hekmatpour and Ince, 1988] </ref> [Hekmatpour and Ince, 1986], and the technique used for executing IPTES mini-specifications [Elmstrtm et al., 1993] [Larsen and Lassen, 1991] [Andersen et al., 1992].
Reference: [Henderson, 1986] <author> Henderson, P. </author> <year> (1986). </year> <title> Functional programming, formal specification, and rapid pro-totyping. </title> <journal> IEEE Transactions on Software Engineering, SE-12(2). </journal>
Reference-contexts: 1 Introduction Executable specifications [Andersen et al., 1992] [Hekmatpour and Ince, 1988] [Kamin and Kraus, 1993] [Tyszberowicz and Yehudai, 1992] [Terwilliger and Campbell, 1989] <ref> [Henderson, 1986] </ref> [O'Neill, 1992a] have advantages over nonexecutable specifications as tools for validating specifications against informal requirements, for prototyping, and for testing that implementations satisfy specifications. <p> This is the most prevalent approach, and examples include SMLVIEW [O'Neill, 1992a] [O'Neill, 1992b], me too <ref> [Henderson, 1986] </ref>, EPROL [Hekmatpour and Ince, 1988] [Hekmatpour and Ince, 1986], and the technique used for executing IPTES mini-specifications [Elmstrtm et al., 1993] [Larsen and Lassen, 1991] [Andersen et al., 1992].
Reference: [Jackson and Damon, 1996] <author> Jackson, D. and Damon, C. A. </author> <year> (1996). </year> <title> Elements of style: Analyzing a software design feature with a counterexample detector. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(7). </volume>
Reference-contexts: Otherwise, only small inputs can be used. However, even small "test cases" are helpful in debugging <ref> [Jackson and Damon, 1996] </ref> and in demonstrating the functionality of specifications. Long execution times are a direct consequence of the level of abstraction of the specifications being executed. 5 Examples In this section, we present two example specifications that our technique can execute.
Reference: [Janson and Haridi, 1994] <author> Janson, S. and Haridi, S. </author> <year> (1994). </year> <title> An introduction to AKL amultiparadigm programming language. </title> <booktitle> In Constraint Programming (NATO-ASI Series vol. </booktitle> <volume> 131). </volume> <publisher> Springer Verlag. </publisher>
Reference-contexts: We execute SPECS-C++ specifications by translating them to Agents Kernel Language (AKL) <ref> [Janson and Haridi, 1994] </ref>, and then executing the resulting AKL program. <p> Section 5 provides some example SPECS-C++ specifications and describes their execution. Section 6 outlines future work, and Section 7 briefly describes related work. Finally, we summarize the contributions of this work in Section 8. 2 Agents Kernel Language (AKL) AKL <ref> [Janson and Haridi, 1994] </ref> is based on concurrent constraint programming. A computation state consists of a set of concurrent agents that operate on a shared set of constraints called a constraint store.
Reference: [Jones, 1990] <author> Jones, C. B. </author> <year> (1990). </year> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition. </note>
Reference-contexts: Our approach makes little use of the C++ specific features of SPECS-C++ except as described in Section 3, and so should be suitable for executing specifications written in other model-based specification languages such as VDM <ref> [Jones, 1990] </ref> [Andrews et al., 1993], Z [Hayes, 1993] [Spivey, 1989] [Spivey, 1992] and JML [Leavens et al., 1998] with only straightforward modifications. We execute SPECS-C++ specifications by translating them to Agents Kernel Language (AKL) [Janson and Haridi, 1994], and then executing the resulting AKL program. <p> The most prominent examples are VDM <ref> [Jones, 1990] </ref> [Andrews et al., 1993] and Z [Hayes, 1993] [Spivey, 1989] [Spivey, 1992], although many other model-based specification languages have been developed. The model typically includes primitive types such as integers and characters, as well as more structured types such as finite sets, sequences, tuples, and functions.
Reference: [Kamin and Kraus, 1993] <author> Kamin, S. and Kraus, T. </author> <year> (1993). </year> <title> Executable specifications of C++ classes. </title> <note> submitted for publication. </note>
Reference-contexts: 1 Introduction Executable specifications [Andersen et al., 1992] [Hekmatpour and Ince, 1988] <ref> [Kamin and Kraus, 1993] </ref> [Tyszberowicz and Yehudai, 1992] [Terwilliger and Campbell, 1989] [Henderson, 1986] [O'Neill, 1992a] have advantages over nonexecutable specifications as tools for validating specifications against informal requirements, for prototyping, and for testing that implementations satisfy specifications. <p> Many other executable specification languages allow quantified assertions over finite domains to be executed, but almost all of these languages simply evaluate such assertions for their truth value, rather than using them directly in building post-state values. The fase3 system <ref> [Kamin and Kraus, 1993] </ref> is the only other execution technique that the authors are aware of that can use quantified assertions directly in defining the post-state, but fase3 can only use one restricted form of existential quantification in this way. <p> The fase3 execution technique <ref> [Kamin and Kraus, 1993] </ref> [Kraus, 1988] can execute a much larger set of assertions than any of the others mentioned here, but can not execute universally quantified assertions that refer to post-state values, and can only execute one very limited form of existentially quantified assertions that refer to post-state values. 2.
Reference: [Kraus, 1988] <author> Kraus, T. </author> <year> (1988). </year> <title> The fase3 system for executable data type specification. </title> <type> Master's thesis, </type> <institution> University of Illinois, Urbana, Illinois. </institution> <type> Technical Report 87-1789. </type>
Reference-contexts: The fase3 execution technique [Kamin and Kraus, 1993] <ref> [Kraus, 1988] </ref> can execute a much larger set of assertions than any of the others mentioned here, but can not execute universally quantified assertions that refer to post-state values, and can only execute one very limited form of existentially quantified assertions that refer to post-state values. 2.
Reference: [Larsen and Lassen, 1991] <author> Larsen, P. G. and Lassen, P. B. </author> <year> (1991). </year> <title> An Executable Subset of Meta-IV with Loose Specification. In VDM '91: Formal Software Development Methods, </title> <publisher> Berlin. VDM Europe, Springer-Verlag. </publisher>
Reference-contexts: This is the most prevalent approach, and examples include SMLVIEW [O'Neill, 1992a] [O'Neill, 1992b], me too [Henderson, 1986], EPROL [Hekmatpour and Ince, 1988] [Hekmatpour and Ince, 1986], and the technique used for executing IPTES mini-specifications [Elmstrtm et al., 1993] <ref> [Larsen and Lassen, 1991] </ref> [Andersen et al., 1992].
Reference: [Leavens et al., 1998] <author> Leavens, G. T., Baker, A. L., and Ruby, C. </author> <year> (1998). </year> <title> Preliminary design of JML: A behavioral interface specification language for Java. </title> <type> Technical Report TR98-06, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa 50011. </institution> <note> Available by anonymous ftp from ftp.cs.iastate.edu and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Our approach makes little use of the C++ specific features of SPECS-C++ except as described in Section 3, and so should be suitable for executing specifications written in other model-based specification languages such as VDM [Jones, 1990] [Andrews et al., 1993], Z [Hayes, 1993] [Spivey, 1989] [Spivey, 1992] and JML <ref> [Leavens et al., 1998] </ref> with only straightforward modifications. We execute SPECS-C++ specifications by translating them to Agents Kernel Language (AKL) [Janson and Haridi, 1994], and then executing the resulting AKL program.
Reference: [Mehl et al., 1998] <author> Mehl, M. et al. </author> <year> (1998). </year> <note> DFKI Oz User's Manual. </note> <institution> Programming Systems Lab, German Research Center for Artificial Intelligence (DFKI) and Universitat des Saarlandes, </institution> <type> Postfach 15 11 50, </type> <institution> D-66041 Saarbrucken, Germany. </institution>
Reference-contexts: AKL is described in Section 2, so here we simply note that we selected AKL as a translation target after evaluating a number of other possibilities, including Prolog [Clocksin and Mellish, 1984] [Colmerauer, 1985] [Cohen, 1985], clp (FD) [Diaz, 1994] and DFKI Oz <ref> [Mehl et al., 1998] </ref>. AKL works well as a translation target largely because it has a simple syntax and because it supports constraint programming cleanly. The rest of this paper elaborates the idea of executing formal specifications by translating them to constraint programs. <p> For example, if the domain of X is 1 through 10 and the finite domain constraint X &lt; 5 is told, then the domain of X is restricted to 1 through 4. Many constraint languages (including CHIP [Van Hentenryck, 1989], clp (FD) [Diaz, 1994] and DFKI Oz <ref> [Mehl et al., 1998] </ref>) use a similar notion of finite domains, and the theory is well established. However, we have not yet been able to generate reliable AKL programs using such constraints.
Reference: [Montelius, 1997] <author> Montelius, J. </author> <year> (1997). </year> <title> Exploiting Fine-grain Parallelism in Concurrent Constraint Languages. </title> <type> PhD thesis, </type> <institution> Swedish Institute of Computer Science (SICS) and Uppsala University. </institution>
Reference-contexts: This approach allows enumeration of the variable, but is less efficient in both time and space than using true finite domain constraints. Exploiting parallelism is another method of improving constraint propagation. The Penny language [Montelius and Haridi, 1997] <ref> [Montelius, 1997] </ref> is a parallel version of AKL that does not require the programmer to indicate parallelism explicitly. However, Penny is not source code compatible with AKL, and so using Penny would require retargeting the specification compiler and porting the agent library.
Reference: [Montelius and Haridi, 1997] <author> Montelius, J. and Haridi, S. </author> <year> (1997). </year> <title> An evaluation of Penny: a system for fine-grain implicit parallelism. </title> <booktitle> In Second International Symposium on Parallel Symbolic Computation (PASCO'97). </booktitle>
Reference-contexts: This approach allows enumeration of the variable, but is less efficient in both time and space than using true finite domain constraints. Exploiting parallelism is another method of improving constraint propagation. The Penny language <ref> [Montelius and Haridi, 1997] </ref> [Montelius, 1997] is a parallel version of AKL that does not require the programmer to indicate parallelism explicitly. However, Penny is not source code compatible with AKL, and so using Penny would require retargeting the specification compiler and porting the agent library.
Reference: [O'Neill, 1992a] <author> O'Neill, G. </author> <year> (1992a). </year> <title> Automatic translation of VDM specifications into Standard ML programs. </title> <journal> The Computer Journal, </journal> <volume> 35(6) </volume> <pages> 623-624. </pages>
Reference-contexts: 1 Introduction Executable specifications [Andersen et al., 1992] [Hekmatpour and Ince, 1988] [Kamin and Kraus, 1993] [Tyszberowicz and Yehudai, 1992] [Terwilliger and Campbell, 1989] [Henderson, 1986] <ref> [O'Neill, 1992a] </ref> have advantages over nonexecutable specifications as tools for validating specifications against informal requirements, for prototyping, and for testing that implementations satisfy specifications. <p> This is the most prevalent approach, and examples include SMLVIEW <ref> [O'Neill, 1992a] </ref> [O'Neill, 1992b], me too [Henderson, 1986], EPROL [Hekmatpour and Ince, 1988] [Hekmatpour and Ince, 1986], and the technique used for executing IPTES mini-specifications [Elmstrtm et al., 1993] [Larsen and Lassen, 1991] [Andersen et al., 1992].
Reference: [O'Neill, 1992b] <author> O'Neill, G. </author> <year> (1992b). </year> <title> Automatic translation of VDM specifications into Standard ML programs. </title> <type> Technical Report DITC 196/92, </type> <institution> National Physical Laboratory, Teddington, </institution> <address> Middlesex TW11 OLW, United Kingdom. </address>
Reference-contexts: This is the most prevalent approach, and examples include SMLVIEW [O'Neill, 1992a] <ref> [O'Neill, 1992b] </ref>, me too [Henderson, 1986], EPROL [Hekmatpour and Ince, 1988] [Hekmatpour and Ince, 1986], and the technique used for executing IPTES mini-specifications [Elmstrtm et al., 1993] [Larsen and Lassen, 1991] [Andersen et al., 1992].
Reference: [Paxson, 1990] <author> Paxson, V. </author> <year> (1990). </year> <title> Flex User's Manual. Free Software Foundation, </title> <address> Cambridge, MA. </address>
Reference-contexts: Model-Based Specifications At the top level, we execute SPECS-C++ specifications by the following process: 1. translate the SPECS-C++ specification and code for testing the specification (declarations of in stances of the class and other variables, and calls to the member functions) to a syntax tree using standard compiler techniques (Flex <ref> [Paxson, 1990] </ref> and Bison [Donnelly and Stallman, 1995]), 2. typecheck the syntax tree and make some small modifications to ease code generation, 3. replace all variables bound by quantifiers with fresh variables to prevent capture of free variables during code generation, 4. generate an AKL program, 5. and finally, load the
Reference: [Schmidt, 1986] <author> Schmidt, D. A. </author> <year> (1986). </year> <title> Denotational Semantics | A Methodology for Language Development. Wm. </title> <address> C. </address> <publisher> Brown Publishers, </publisher> <address> Dubuque, Iowa. </address>
Reference-contexts: j range binary-op ::= + j - j * j / j mod j "union j "intersection j || test ::= c++-type identifier; j identifier.memfun-name (terms); j identifier = identifier.memfun-name (terms); empty ::= represent either literals of SPECS-C++ types (if ending in -literal) or identifiers in the specification. 5 semantics <ref> [Schmidt, 1986] </ref>. The pre-state value of an object is extracted by the postfix function ^, and the post-state value by the postfix function '. Thus, x^ is the pre-state value of x, and x' is its post-state value.
Reference: [Spivey, 1989] <author> Spivey, J. M. </author> <year> (1989). </year> <title> An introduction to Z and formal specifications. </title> <journal> Software Engineering Journal, </journal> <pages> pages 40 - 50. </pages>
Reference-contexts: Our approach makes little use of the C++ specific features of SPECS-C++ except as described in Section 3, and so should be suitable for executing specifications written in other model-based specification languages such as VDM [Jones, 1990] [Andrews et al., 1993], Z [Hayes, 1993] <ref> [Spivey, 1989] </ref> [Spivey, 1992] and JML [Leavens et al., 1998] with only straightforward modifications. We execute SPECS-C++ specifications by translating them to Agents Kernel Language (AKL) [Janson and Haridi, 1994], and then executing the resulting AKL program. <p> The most prominent examples are VDM [Jones, 1990] [Andrews et al., 1993] and Z [Hayes, 1993] <ref> [Spivey, 1989] </ref> [Spivey, 1992], although many other model-based specification languages have been developed. The model typically includes primitive types such as integers and characters, as well as more structured types such as finite sets, sequences, tuples, and functions.
Reference: [Spivey, 1992] <author> Spivey, J. M. </author> <year> (1992). </year> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <note> second edition. ISBN 013983768X. 15 </note>
Reference-contexts: Our approach makes little use of the C++ specific features of SPECS-C++ except as described in Section 3, and so should be suitable for executing specifications written in other model-based specification languages such as VDM [Jones, 1990] [Andrews et al., 1993], Z [Hayes, 1993] [Spivey, 1989] <ref> [Spivey, 1992] </ref> and JML [Leavens et al., 1998] with only straightforward modifications. We execute SPECS-C++ specifications by translating them to Agents Kernel Language (AKL) [Janson and Haridi, 1994], and then executing the resulting AKL program. <p> The most prominent examples are VDM [Jones, 1990] [Andrews et al., 1993] and Z [Hayes, 1993] [Spivey, 1989] <ref> [Spivey, 1992] </ref>, although many other model-based specification languages have been developed. The model typically includes primitive types such as integers and characters, as well as more structured types such as finite sets, sequences, tuples, and functions.
Reference: [Stroustrup, 1991] <author> Stroustrup, B. </author> <year> (1991). </year> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <note> second edition. </note>
Reference-contexts: The specification language that we execute is SPECS-C++ [Wahls et al., 1994], a model-based formal specification language designed for specifying the interfaces of C++ <ref> [Stroustrup, 1991] </ref> classes. This language was not designed with executability in mind, and in fact our approach can not execute all SPECS-C++ specifications. <p> The execution technique described in the next section was developed in the context of the specification language SPECS-C++ [Wahls et al., 1994], which is a formal and model-based language specialized for specifying the interfaces of C++ classes <ref> [Stroustrup, 1991] </ref>. However, the execution technique is not limited to SPECS-C++, as it depends only on first order assertions over a fixed set of model types, as found in all model-based specification languages. In fact, the addition of C++ specific features only complicates the execution of specifications.
Reference: [Terwilliger and Campbell, 1989] <author> Terwilliger, R. and Campbell, R. </author> <year> (1989). </year> <title> Please: Executable specifications for incremental software development. </title> <journal> Journal of Systems and Software, </journal> <volume> 10(2):97 - 112. </volume>
Reference-contexts: 1 Introduction Executable specifications [Andersen et al., 1992] [Hekmatpour and Ince, 1988] [Kamin and Kraus, 1993] [Tyszberowicz and Yehudai, 1992] <ref> [Terwilliger and Campbell, 1989] </ref> [Henderson, 1986] [O'Neill, 1992a] have advantages over nonexecutable specifications as tools for validating specifications against informal requirements, for prototyping, and for testing that implementations satisfy specifications. <p> Use Prolog syntax or code in the specification language, and execute specifications via Prolog. PLEASE <ref> [Terwilliger and Campbell, 1989] </ref> and OBSERV [Tyszberowicz and Yehudai, 1992] are rep resentative examples. 3. Explicitly translate specifications to Prolog programs. Researchers have experimented with this approach [Dick et al., 1990] [West and Eaglestone, 1992], but to the authors' knowledge, no com pletely automated translator exists.
Reference: [Tsang, 1993] <author> Tsang, E. </author> <year> (1993). </year> <title> Foundations of Constraint Satisfaction. </title> <booktitle> Computation in Cognitive Science. </booktitle> <publisher> Academic Press, London. </publisher>
Reference-contexts: The worst-case size of the search tree explored is O (a n ), where n is the number of variables in the problem and a is the maximum domain size for any of the variables. This analysis is precisely the same as that for standard constraint satisfaction problems (CSPs) <ref> [Tsang, 1993, p. 37] </ref>. In a SPECS-C++ postcondition, any post-state value is equivalent to a variable in a CSP, and existentially quantifying over the m indices of a post-state sequence value introduces m additional CSP variables.
Reference: [Tyszberowicz and Yehudai, 1992] <author> Tyszberowicz, S. and Yehudai, A. </author> <year> (1992). </year> <title> Observ a prototying language and environment. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(3):269 - 309. </volume>
Reference-contexts: 1 Introduction Executable specifications [Andersen et al., 1992] [Hekmatpour and Ince, 1988] [Kamin and Kraus, 1993] <ref> [Tyszberowicz and Yehudai, 1992] </ref> [Terwilliger and Campbell, 1989] [Henderson, 1986] [O'Neill, 1992a] have advantages over nonexecutable specifications as tools for validating specifications against informal requirements, for prototyping, and for testing that implementations satisfy specifications. <p> Use Prolog syntax or code in the specification language, and execute specifications via Prolog. PLEASE [Terwilliger and Campbell, 1989] and OBSERV <ref> [Tyszberowicz and Yehudai, 1992] </ref> are rep resentative examples. 3. Explicitly translate specifications to Prolog programs. Researchers have experimented with this approach [Dick et al., 1990] [West and Eaglestone, 1992], but to the authors' knowledge, no com pletely automated translator exists.
Reference: [Van Hentenryck, 1989] <author> Van Hentenryck, P. </author> <year> (1989). </year> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts. </address>
Reference-contexts: For example, if the domain of X is 1 through 10 and the finite domain constraint X &lt; 5 is told, then the domain of X is restricted to 1 through 4. Many constraint languages (including CHIP <ref> [Van Hentenryck, 1989] </ref>, clp (FD) [Diaz, 1994] and DFKI Oz [Mehl et al., 1998]) use a similar notion of finite domains, and the theory is well established. However, we have not yet been able to generate reliable AKL programs using such constraints.
Reference: [Wahls et al., 1994] <author> Wahls, T., Baker, A. L., and Leavens, G. T. </author> <year> (1994). </year> <title> The direct execution of SPECS-C++: A model-based specification language for C++ classes. </title> <type> Technical Report TR94-02, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa 50011. </institution> <note> Available by anonymous ftp from ftp.cs.iastate.edu and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: The specification language that we execute is SPECS-C++ <ref> [Wahls et al., 1994] </ref>, a model-based formal specification language designed for specifying the interfaces of C++ [Stroustrup, 1991] classes. This language was not designed with executability in mind, and in fact our approach can not execute all SPECS-C++ specifications. <p> Hence, for our purposes, execution of such specifications means checking that the pre-state satisfies the precondition, and then finding post-state values that satisfy the postcondition. The execution technique described in the next section was developed in the context of the specification language SPECS-C++ <ref> [Wahls et al., 1994] </ref>, which is a formal and model-based language specialized for specifying the interfaces of C++ classes [Stroustrup, 1991].
Reference: [West and Eaglestone, 1992] <author> West, M. and Eaglestone, B. </author> <year> (1992). </year> <title> Software development: two approaches to animation of Z specifications using Prolog. </title> <journal> Software Engineering Journal, </journal> <volume> 7(4) </volume> <pages> 264-276. </pages>
Reference-contexts: Use Prolog syntax or code in the specification language, and execute specifications via Prolog. PLEASE [Terwilliger and Campbell, 1989] and OBSERV [Tyszberowicz and Yehudai, 1992] are rep resentative examples. 3. Explicitly translate specifications to Prolog programs. Researchers have experimented with this approach [Dick et al., 1990] <ref> [West and Eaglestone, 1992] </ref>, but to the authors' knowledge, no com pletely automated translator exists.
Reference: [Wing, 1987] <author> Wing, J. M. </author> <year> (1987). </year> <title> Writing Larch interface language specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24. 16 </pages>
Reference-contexts: The formal parameters of the agent are the parameters of the member function definition and the three additional parameters previously discussed. The modifies clause specifies which objects can change from the pre-state to the post-state [Guttag et al., 1993] <ref> [Wing, 1987] </ref> [Borgida et al., 1995], and so this clause is used to construct the post-state store that will be passed to the agent.
References-found: 42

