URL: http://www.cs.wustl.edu/cs/techreports/1997/wucs-97-46.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: 
Title: Using Snapshot Streams to Support Visual Exploration  
Author: Delbert Hart Eileen Kraemer Gruia-Catalin Roman 
Address: Campus Box 1045 One Brookings Drive Saint Louis, MO 63130-4899  
Affiliation: Department of Computer Science Washington University  
Date: October 12, 1997  
Pubnum: WUCS97-46  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: A matching send/receive event pair is called a communication. In addition, the events init, start and stop (special instances of the events send, receive and mark) denote a request to create a process, the start of a process, and the termination of a process, respectively. The happened-before relation <ref> [1] </ref> over events is a partial order where an event x happened-before an event y if and only if 1) x and y are in the same process and ffi.x &lt; ffi.y, 2) x is a send event that matches y, or 3) there exists an event z such that x
Reference: [2] <author> Delbart Hart, Eileen Kraemer, and Gruia-Catalin Roman. </author> <title> Query-based visualization of distributed computations. </title> <booktitle> In Proceedings of the 11th International Parallel Processing Symposium, </booktitle> <address> Geneva, Switzerland, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: The trade-off in deciding when to run the snapshot algorithms is between how quickly the user learns about fine-grained transactions and in how much network overhead is incurred. 4 Global Surveyor Our current prototype is Global Surveyor, an exploratory tool based on the Query-Based Visualization (QBV) model <ref> [2] </ref>. Global Surveyor was designed to demonstrate the ability to interactively observe running distributed computations. This first prototype focuses on the general use of exploration and how evolving global snapshots can be efficiently collected to support exploration.
Reference: [3] <author> V.S. Sunderam. </author> <title> PVM: A framework for parallel distributed computing. </title> <journal> Concurrency: Practice & Experience, </journal> <volume> 2(4):315 - 339, </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: Monitoring can begin at any time while the computation is running. There is little perturbation of the computation while the computation is not being monitored. Global Surveyor is able to monitor running distributed computations that use the PVM <ref> [3] </ref> library for message passing. The Surveyor's monitoring libraries can be used in C, C++, and Fortran programs. We do not need to modify the PVM library to support Surveyor; instead, Surveyor's monitoring library intercepts calls made to the PVM library.
Reference: [4] <author> Weiming Gu, Jeffrey Vetter, and Karsten Schwan. </author> <title> An Annotated Bibliography of Interactive Program Steering. </title> <type> Technical report, </type> <institution> Georgia Institute of Technology, </institution> <month> November </month> <year> 1994 1994. </year>
Reference-contexts: Monitoring Library: Data about a program can be extracted in many ways. It is possible to extract data from the runtime system, a custom library or through debugging hooks. An overview of data collection methods can be found in <ref> [4] </ref>. Two types of attributes are made available by Surveyor's monitoring library: common attributes and application-specific attributes. Common attributes are characteristics of the application process that are possessed by all processes.
Reference: [5] <author> Gruia-Catalin Roman, Kenneth C. Cox, Donald Wilcox, and Jerome Y. Plun. Pavane: </author> <title> a system for declarative visualization of concurrent computations. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 3(2) </volume> <pages> 161-193, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The user interface is written in Java to allow viewers to monitor distributed computations remotely from a variety of platforms. Visualizations can be any program visualization system that can use a stream of snapshots. We have written an adaptor so that Pavane <ref> [5] </ref> visualizations can be used. Some visualizations have also been integrated into the user interface. Surveyor can support an arbitrary number of visualization displays. <p> The visualization is updated as each pixel is computed. Application-specific visualizations are available in a large number of systems, such as Pavane <ref> [5] </ref>, Polka [9], and Zeus [10]. Many visualization systems provide the ability to use both application-specific and prepackaged visualizations. Regardless of what visualizations are used, obtaining a consistent global view of the computation is important to prevent unnecessary misunderstandings or confusion.
Reference: [6] <institution> Pvmpov www site. </institution> <type> Technical report, </type> <note> http://www.geocities.com/CapeCanaveral/Lab/6386/PVMPOV.html. </note>
Reference-contexts: Since the computation of each pixel is independent, ray tracing can be distributed for performance benefits. The only coordination needed between processes is to decide which process computes which pixels and to reassemble the image. The ray tracer we explore is the PVMPOV <ref> [6] </ref> ray tracer. Persistence of Vision Ray-Tracer (POV-Ray) is a popular ray tracer available for a wide variety of platforms. PVMPOV is an extension to POV-Ray that allows a group of processes to cooperate in computing the POV-Ray scene using the PVM message passing library. <p> The master then assembles the image and allows the display of blocks as they arrive. Figure 7 shows an example of a POV scene that is partially rendered. For more information on POV-Ray see the reference manual [7]; or for more information on PVMPOV see <ref> [6] </ref>. 16 allows users to name sets of processes. The set ALL is predefined by the system. The attribute panel has a similar layout. 4.2.2 Initial Survey We want to minimize the number of annotations needed for viewers to start exploring an unfamiliar computation with Surveyor.
Reference: [7] <institution> Persistence of vision ray-tracer www site. </institution> <type> Technical report, </type> <note> http://www.povray.org/. 24 </note>
Reference-contexts: The master then assembles the image and allows the display of blocks as they arrive. Figure 7 shows an example of a POV scene that is partially rendered. For more information on POV-Ray see the reference manual <ref> [7] </ref>; or for more information on PVMPOV see [6]. 16 allows users to name sets of processes. The set ALL is predefined by the system.
Reference: [8] <author> Daniel A. Reed, Robert D. Olson, Ruth A. Aydt, Tara M. Madhyastha, Thomas Birkett, David W. Jensen, Bobby A. A. Nazief, and Brian K. Totty. </author> <title> Scalable performance environments for parallel systems. </title> <booktitle> In Proceedings of the Sixth Distributed Memory Computing Conference, </booktitle> <pages> pages 562-569, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: The starting point when using an exploratory tool is often a prepackaged visualization. Prepackaged visualizations are available in a wide variety of visualization systems, for example the Pablo system <ref> [8] </ref> uses presentation modules for visualizations. Each presentation module provides a prepackaged visualization for inspecting data at various points in a data analysis graph. Performance information is often visualized with prepackaged visualizations, since there are many performance characteristics that are common to all computations.
Reference: [9] <author> John T. Stasko and Eileen Kraemer. </author> <title> A methodology for building application-specific visualizations of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18(2) </volume> <pages> 258-264, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The visualization is updated as each pixel is computed. Application-specific visualizations are available in a large number of systems, such as Pavane [5], Polka <ref> [9] </ref>, and Zeus [10]. Many visualization systems provide the ability to use both application-specific and prepackaged visualizations. Regardless of what visualizations are used, obtaining a consistent global view of the computation is important to prevent unnecessary misunderstandings or confusion.
Reference: [10] <author> M. H. Brown. Zeus: </author> <title> A System for Algorithm Animation and Multi-View Editing. </title> <booktitle> In 1991 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 4-9, </pages> <address> Kobe, Japan, 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The visualization is updated as each pixel is computed. Application-specific visualizations are available in a large number of systems, such as Pavane [5], Polka [9], and Zeus <ref> [10] </ref>. Many visualization systems provide the ability to use both application-specific and prepackaged visualizations. Regardless of what visualizations are used, obtaining a consistent global view of the computation is important to prevent unnecessary misunderstandings or confusion. One way to obtain global data is to execute a checkpoint algorithm.
Reference: [11] <author> K.M. Chandy and L. Lamport. </author> <title> Distributed snapshots: determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <year> 1985. </year>
Reference-contexts: One way to obtain global data is to execute a checkpoint algorithm. A checkpoint is a representation of the state of a single process at a given time. A collection of checkpoints can be used to form a global snapshot <ref> [11] </ref> if there are checkpoints for each process in the computation and if there are no causal dependencies between the checkpoints. Surveys of checkpoint and snapshot algorithms can be found in [12] and, respectively.
Reference: [12] <author> E. N. Elnozahy, D. B. Johnson, and Y. M. Wang. </author> <title> A Survey of Rollback-Recovery Protocols in Message-Passing Systems. </title> <type> Technical Report CMU-CS-96-181, </type> <institution> Carnegie Mellon University, </institution> <month> October 3, </month> <year> 1996 1996. </year> <note> (submitted to ACM Computing Surveys). </note>
Reference-contexts: A collection of checkpoints can be used to form a global snapshot [11] if there are checkpoints for each process in the computation and if there are no causal dependencies between the checkpoints. Surveys of checkpoint and snapshot algorithms can be found in <ref> [12] </ref> and, respectively. Without any modifications, snapshot and checkpointing algorithms are too expensive, in terms of perturbation, to be used for the continuous monitoring of distributed computations needed by exploratory tools.
Reference: [13] <author> Eileen T. Kraemer. </author> <title> A Framework, Tools, and Methodology for the Visualization of Parallel and Distributed Systems. </title> <type> PhD thesis, </type> <institution> Georgia Institute of Technology, </institution> <address> Atlanta, GA, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: An alternative approach to achieve continuous monitoring of computations is to have each process produce a stream of events. When merging the events of these streams into a single event stream, the events can be ordered to meet consistency criteria needed by the exploratory tool. The Animation Choreographer <ref> [13] </ref>, part of the PARADE system [14], is a graphical, interactive tool that supports the calculation of alternate feasible event orderings of the program execution under study. This allows visualization of the program under a variety of temporal perspectives.
Reference: [14] <author> John T. Stasko. </author> <title> The PARADE environment for visualizing parallel program executions: A progress report. </title> <type> Technical Report GIT-GVU-95-03, </type> <institution> Graphics, Visualization, and Usability Center, Georgia Institute of Technology, </institution> <address> Atlanta, GA, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: When merging the events of these streams into a single event stream, the events can be ordered to meet consistency criteria needed by the exploratory tool. The Animation Choreographer [13], part of the PARADE system <ref> [14] </ref>, is a graphical, interactive tool that supports the calculation of alternate feasible event orderings of the program execution under study. This allows visualization of the program under a variety of temporal perspectives.
Reference: [15] <author> Alfred A. Hough and Janice E. Cuny. </author> <title> Perspective views: A technique for enhancing parallel program visualization. </title> <booktitle> In Proceedings of 1991 International Conference on Parallel Processing, </booktitle> <pages> pages II 124-132, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: This allows visualization of the program under a variety of temporal perspectives. A different approach to viewing different possible orderings is taken by Perspective Views, implemented in the Belvedere system <ref> [15] </ref>. Perspective Views has the user choose a subset of the causal relationship and user defined orderings, to base the total ordering on. This allows the user flexibility in how the computation is visualized.
Reference: [16] <author> Weiming Gu, Greg Eisenhauer, Eileen Kraemer, Karsten Schwan, John Stasko, Jeffrey Vet-ter, and Nirupama Mallavarupu. </author> <title> Falcon: on-line monitoring and steering of large-scale parallel programs. </title> <booktitle> In Proceedings of the Fifth Symposium on the Frontiers of Massively Parallel Computation, </booktitle> <pages> pages 422-429, </pages> <address> McClean, VA, </address> <month> February </month> <year> 1995. </year>
Reference-contexts: Care must be taken when using this approach, because while it may be useful to do this to make visualizations more understandable, the resulting visualizations may communicate misleading or inaccurate information. The Falcon 23 system for interactive program steering <ref> [16] </ref> relies on the existence of an ordering filter placed at the point at which the event streams are merged to ensure a valid ordering of events collected by the monitoring system. This causality filter [17] is based on the causal relationships between the events in the program.
Reference: [17] <author> Eileen Kraemer. </author> <title> Causality filters: A tool for the online visualization and steering of parallel and distributed programs. </title> <booktitle> In Proceedings of the 11th International Parallel Processing Symposium, </booktitle> <address> Geneva, Switzerland, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: The Falcon 23 system for interactive program steering [16] relies on the existence of an ordering filter placed at the point at which the event streams are merged to ensure a valid ordering of events collected by the monitoring system. This causality filter <ref> [17] </ref> is based on the causal relationships between the events in the program. Event streams can also be used to detect higher level events. This extraction of higher level events is a form of temporal abstraction.
Reference: [18] <author> Sameer Shende, Janice Cuny, Lars Hansen, Joydip Kundu, Stephen McLaughry, and Odile Wolf. </author> <title> Event and state-based debugging in TAU: A prototype. </title> <booktitle> In Proceedings of SPDT'96: SIGMETRICS Symposium on Parallel and Distributed Tools, </booktitle> <pages> pages 21-30, </pages> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: This causality filter [17] is based on the causal relationships between the events in the program. Event streams can also be used to detect higher level events. This extraction of higher level events is a form of temporal abstraction. A system based on this approach is the Ariadne debugger <ref> [18] </ref> for the pC++ language. The low level events for Ariadne are communication actions between processes, language specific events, and user defined events. The events are then matched against the expected behavior of the program, that the user specified in terms of both low and high level events.
Reference: [19] <author> G. A. Geist, J. A. Kohl, and P. M. Papadopoulos. </author> <title> CUMULVS: Providing fault-tolerance, visualization, and steering of parallel applications. </title> <publisher> SIAM, </publisher> <month> August </month> <year> 1996. </year> <month> 25 </month>
Reference-contexts: Steering tools, in addition to monitoring an application, allow feedback to be sent to the computation. Because of this, these tools need visualizations based on accurate global information, so users can make well informed decisions about what steering commands to invoke. The CU-MULVS system <ref> [19] </ref> for the steering of PVM programs assumes that the application is structured around a main simulation loop. A data transfer routine is placed in this loop. When this routine is executed, the equivalent of a local snapshot is collected, and marked with an iteration number.
References-found: 19

