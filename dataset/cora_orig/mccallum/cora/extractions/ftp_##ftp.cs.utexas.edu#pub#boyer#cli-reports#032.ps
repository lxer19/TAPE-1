URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/032.ps
Refering-URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/index.html
Root-URL: 
Phone: (512) 322-9951  
Title: A Mechanically Verified Proof System for Concurrent Programs  
Author: David M. Goldschlag 
Note: This work was supported in part at Computational Logic, Inc., by the Defense Advanced Research Projects Agency, ARPA Orders 6082 and 9151. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency or the U.S. Government.  
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic Inc.  
Date: 32 January, 1989  
Pubnum: Technical Report  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Bowen Alpern and Fred B. Schneider. </author> <title> "Defining Liveness". </title> <booktitle> Information Processing Letters 21 (1985), </booktitle> <pages> 181-185. </pages>
Reference-contexts: Specification Predicates The interesting properties of concurrent programs are safety and liveness (progress). Safety properties are those which state that something bad will never happen [2]; examples are invariant properties such as mutual exclusion and freedom from deadlock. Liveness properties guarantee that something good will eventually happen <ref> [1] </ref>; examples are termination and freedom from starvation. Unity defines predicates which specify subsets of these properties. Stable properties, a subset of safety properties, are specified using UNLESS; progress properties, a subset of liveness properties, are specified using ENSURES and LEADS-TO.
Reference: 2. <author> Bowen Alpern, Alan J. Demers, and Fred B. Schneider. </author> <title> "Safety Without Stuttering". </title> <booktitle> Information Processing Letters 23 (1986), </booktitle> <pages> 177-180. </pages>
Reference-contexts: So theorems in which PRG is a free variable are really proof rules, and this is the focus of the next sections. 4. Specification Predicates The interesting properties of concurrent programs are safety and liveness (progress). Safety properties are those which state that something bad will never happen <ref> [2] </ref>; examples are invariant properties such as mutual exclusion and freedom from deadlock. Liveness properties guarantee that something good will eventually happen [1]; examples are termination and freedom from starvation. Unity defines predicates which specify subsets of these properties.
Reference: 3. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: This question, which may be difficult to answer, need be answered only once for all proofs validated by the theorem prover. The theorem prover used in this work is the Boyer-Moore prover <ref> [3, 5] </ref>. This prover has been carefully coded and extensively tested. The Boyer-Moore logic, which is mechanized by the Boyer-Moore prover, has been proved sound [10, 4]. The rest of this paper requires some familiarity with the Boyer-Moore logic and its theorem prover.
Reference: 4. <author> R. S. Boyer and J S. Moore. Metafunctions: </author> <title> Proving Them Correct and Using Them Efficiently as New Proof Procedures. In The Correctness Problem in Computer Science, </title> <editor> R. S. Boyer and J S. Moore, Eds., </editor> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: The theorem prover used in this work is the Boyer-Moore prover [3, 5]. This prover has been carefully coded and extensively tested. The Boyer-Moore logic, which is mechanized by the Boyer-Moore prover, has been proved sound <ref> [10, 4] </ref>. The rest of this paper requires some familiarity with the Boyer-Moore logic and its theorem prover. The following sections informally describe the logic and the various enhancements to the logic and prover that were used in this work.
Reference: 5. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: This question, which may be difficult to answer, need be answered only once for all proofs validated by the theorem prover. The theorem prover used in this work is the Boyer-Moore prover <ref> [3, 5] </ref>. This prover has been carefully coded and extensively tested. The Boyer-Moore logic, which is mechanized by the Boyer-Moore prover, has been proved sound [10, 4]. The rest of this paper requires some familiarity with the Boyer-Moore logic and its theorem prover. <p> A lemma is accepted if the prover can prove it, using the logic's inference rules, from axioms, definitions and previously proved lemmas. 2 2.1 The Boyer-Moore Logic This proof system is specified in the Nqthm version of the Boyer-Moore logic <ref> [5, 6] </ref>. Nqthm is a quantifier free first order logic that permits recursive definitions. It also defines an interpreter function for the quotation of terms in the logic. Nqthm uses a prefix syntax similar to pure Lisp.
Reference: 6. <author> R. S. Boyer and J S. Moore. </author> <title> The Addition of Bounded Quantification and Partial Functions to A Computational Logic and Its Theorem Prover. </title> <type> Tech. </type> <institution> Rept. ICSCA-CMP-52, Institute for Computer Science, University of Texas at Austin, </institution> <month> January, </month> <year> 1988. </year> <note> To appear in the Journal of Automated Reasoning, 1988. Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703.. </address>
Reference-contexts: A lemma is accepted if the prover can prove it, using the logic's inference rules, from axioms, definitions and previously proved lemmas. 2 2.1 The Boyer-Moore Logic This proof system is specified in the Nqthm version of the Boyer-Moore logic <ref> [5, 6] </ref>. Nqthm is a quantifier free first order logic that permits recursive definitions. It also defines an interpreter function for the quotation of terms in the logic. Nqthm uses a prefix syntax similar to pure Lisp. <p> For example, the function APPEND, which appends two lists, is defined as: 1 Actually, the quote mechanism is a facility of the Lisp reader [16]. 2 This simple definition is only true for total functions but is sufficient for this paper <ref> [6] </ref>. 3 Definition. (APPEND X Y) = (IF (LISTP X) (CONS (CAR X) (APPEND (CDR X) Y)) Y) This function terminates because measure (LENGTH X) decreases in each recursive call. 2.2 Eval$ EVAL$ is an interpreter function in Nqthm.
Reference: 7. <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley, </publisher> <address> Massachusetts, </address> <year> 1988. </year>
Reference-contexts: The proof system for concurrent programs presented in this paper is based on Unity <ref> [7] </ref>, which has two important characteristics: Unity provides predicates for specifications, and proof rules to derive specifications directly from the program text. This type of proof strategy is often clearer and more succinct than an argument about a program's operational behavior. Unity separates the concerns of algorithm and architecture. <p> Finally, the meaning of the skolemized formula is the same as the original definition because of the correctness of skolemization. 3. The Operational Semantics The first level of this proof system formalizes an operational definition of concurrency based on the transition system model <ref> [14, 15, 7] </ref>. A transition system is a set of statements that effect transitions on the system state. A computation is the sequence of states generated by the composition of an infinite sequence of transitions on an initial state. <p> A computation is the sequence of states generated by the composition of an infinite sequence of transitions on an initial state. Fair computations are computations where every statement is responsible for an infinite number of transitions. This type of fairness is often called weak fairness <ref> [7] </ref>; the corresponding computations are often called just computations [14]. We are only interested in fair computations, since those permit the proof of liveness properties (if a statement is ignored forever, certain properties may not be provable). <p> Insert-Into-Leads-To (IMPLIES (IMPLIES (EVAL P (S PRG IN (ILEADS IN (LIST 'AND P Q) PRG R))) (LEADS-TO Q R PRG IN)) (LEADS-TO (LIST 'AND P Q) R PRG IN)) The last theorem of this section, the PSP theorem, combines a progress and a safety property to yield a progress property <ref> [7] </ref>. PSP (IMPLIES (AND (LEADS-TO P Q PRG IN) (UNLESS R B PRG) (LISTP PRG)) (LEADS-TO (LIST 'AND P R) (LIST 'OR (LIST 'AND Q R) B) PRG IN)) This theorem is proved by induction on the computation.
Reference: 8. <author> C. A. R. Hoare. </author> <title> "An Axiomatic Basis for Computer Programming". </title> <booktitle> CACM 12 (1969), </booktitle> <pages> 271-281. </pages>
Reference-contexts: This conjunct is used to prove LEADS-TO. 4.4 Comparison with Unity Predicates The definitions of UNLESS, ENSURES, and LEADS-TO presented here differ from Unity's definitions. In Unity, using Hoare triples <ref> [8] </ref>, the definition of UNLESS for a program PRG is: P UNLESS Q "S : S IN PRG :: -PQ- S -PQ Unity's definition strengthens the precondition. However, the two definitions are interchangeable.
Reference: 9. <author> Charanjit S. Jutla, Edgar Knapp, and Josyula R. Rao. </author> <title> Extensional Semantics of Parallel Programs. </title> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <month> November, </month> <year> 1988. </year>
Reference-contexts: In this way, Unity avoids formalizing an operational semantics that may be used to define LEADS-TO. Furthermore, Unity's method for defining LEADS-TO allows one to use induction on the length of proof (structural induction) to prove theorems about LEADS-TO. The soundness and completeness of Unity's LEADS-TO are discussed in <ref> [9] </ref>. However, if an operational semantics is formalized, and LEADS-TO is correctly defined using those functions, then the definition is sound and completely captures the intuitively desired meaning.
Reference: 10. <author> M. Kaufmann. </author> <title> A Formal Semantics and Proof of Soundness for the Logic of the NQTHM Version of the Boyer-Moore Theorem Prover. </title> <institution> Institute for Computing Science, University of Texas at Austin, Austin, </institution> <address> TX 78712, </address> <year> 1986. </year> <note> ICSCI Internal Note 229. </note>
Reference-contexts: The theorem prover used in this work is the Boyer-Moore prover [3, 5]. This prover has been carefully coded and extensively tested. The Boyer-Moore logic, which is mechanized by the Boyer-Moore prover, has been proved sound <ref> [10, 4] </ref>. The rest of this paper requires some familiarity with the Boyer-Moore logic and its theorem prover. The following sections informally describe the logic and the various enhancements to the logic and prover that were used in this work.
Reference: 11. <author> M. Kaufmann. </author> <title> A User's Manual for an Interactive Enhancement to the Boyer-Moore Theorem Prover. </title> <type> Tech. </type> <institution> Rept. ICSCA-CMP-60, Institute for Computing Science, University of Texas at Austin, Austin, </institution> <address> TX 78712, </address> <year> 1987. </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. </address>
Reference-contexts: Sometimes, it is easier to direct the proof process at a lower level. The Kaufmann Proof Checker <ref> [11] </ref> is an interactive enhancement to the Boyer-Moore prover. It allows the user to manipulate a formula (the original goal) using sound operations; once all remaining goals have been proved, the original formula has been proved.
Reference: 12. <author> M. Kaufmann. </author> <title> Skolemization Explained Simply. Computational Logic, </title> <publisher> Inc., </publisher> <address> Austin, Texas 78703, </address> <year> 1987. </year> <note> CLI Internal Note 27. </note>
Reference-contexts: Since the Boyer-Moore logic does not define quantifiers, this cannot be done directly. However, using a technique called skolemization <ref> [12] </ref>, one can derive an equivalent quantifier free formula from a definition. If the definition is not recursive, the formula can be added as an axiom, while maintaining the theory's consistency. For example, suppose we wish to define: Definition. (P X X . . .
Reference: 13. <author> Leslie Lamport. </author> <title> A Simple Approach to Specifying Concurrent Systems. </title> <type> Tech. </type> <institution> Rept. Research Report 15, DEC Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: Since atomicity is implementation dependent, we will not be concerned with the atomicity of statements here. 5 3.1 A Concurrent Program 4 To permit non-deterministic program statements, each statement is a relation from previous states to next states <ref> [13] </ref>. We define the function N so the term (N OLD NEW E) is true if and only if NEW is a possible successor state to OLD under the transition specified by E.
Reference: 14. <author> Zohar Manna and Amir Pnueli. </author> <title> "Adequate Proof Principles for Invariance and Liveness Properties of Concurrent Programs". </title> <booktitle> Science of Computer Programming 4 (1984), </booktitle> <pages> 257-289. </pages>
Reference-contexts: Finally, the meaning of the skolemized formula is the same as the original definition because of the correctness of skolemization. 3. The Operational Semantics The first level of this proof system formalizes an operational definition of concurrency based on the transition system model <ref> [14, 15, 7] </ref>. A transition system is a set of statements that effect transitions on the system state. A computation is the sequence of states generated by the composition of an infinite sequence of transitions on an initial state. <p> Fair computations are computations where every statement is responsible for an infinite number of transitions. This type of fairness is often called weak fairness [7]; the corresponding computations are often called just computations <ref> [14] </ref>. We are only interested in fair computations, since those permit the proof of liveness properties (if a statement is ignored forever, certain properties may not be provable). Notice however, that fairness is a very weak restriction on the scheduling of statements.
Reference: 15. <author> Z. Manna and A. Pnueli. </author> <title> Verification of Concurrent Programs: The Temporal Framework. In The Correctness Problem in Computer Science, </title> <editor> R. S. Boyer and J S. Moore, Eds., </editor> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: Finally, the meaning of the skolemized formula is the same as the original definition because of the correctness of skolemization. 3. The Operational Semantics The first level of this proof system formalizes an operational definition of concurrency based on the transition system model <ref> [14, 15, 7] </ref>. A transition system is a set of statements that effect transitions on the system state. A computation is the sequence of states generated by the composition of an infinite sequence of transitions on an initial state.
Reference: 16. <author> G. L. Steele, Jr.. </author> <title> Common Lisp The Language. </title> <publisher> Digital Press, </publisher> <address> 30 North Avenue, Burlington, MA 01803, </address> <year> 1984. </year> <title> Table of Contents </title>
Reference-contexts: For example, (APPLY$ 'PLUS (LIST 1 2)) is (PLUS 1 2) which is 3. Recursive definitions are permitted, provided termination can be proved. For example, the function APPEND, which appends two lists, is defined as: 1 Actually, the quote mechanism is a facility of the Lisp reader <ref> [16] </ref>. 2 This simple definition is only true for total functions but is sufficient for this paper [6]. 3 Definition. (APPEND X Y) = (IF (LISTP X) (CONS (CAR X) (APPEND (CDR X) Y)) Y) This function terminates because measure (LENGTH X) decreases in each recursive call. 2.2 Eval$ EVAL$ is <p> For instance, (EVAL$ T (LIST 'PLUS 'X (LIST 'QUOTE Y)) (LIST (CONS 'X 5))) is (PLUS 5 Y). Unfortunately, (EVAL$ T (LIST 'PLUS 'X (LIST 'QUOTE Y)) (LIST (CONS 'X 5))) is somewhat difficult to read. 3 The Lisp backquote syntax <ref> [16] </ref> can be used to write an equivalent expression. Backquote (`) is similar to quote (') except that under backquote, terms preceded by a comma are not evaluated, which is precisely the desired effect. Therefore, the terms `(PLUS X (QUOTE ,Y)) and (LIST 'PLUS 'X (LIST 'QUOTE Y)) are equal.
Reference: 1. <institution> Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 </institution>
Reference-contexts: Specification Predicates The interesting properties of concurrent programs are safety and liveness (progress). Safety properties are those which state that something bad will never happen [2]; examples are invariant properties such as mutual exclusion and freedom from deadlock. Liveness properties guarantee that something good will eventually happen <ref> [1] </ref>; examples are termination and freedom from starvation. Unity defines predicates which specify subsets of these properties. Stable properties, a subset of safety properties, are specified using UNLESS; progress properties, a subset of liveness properties, are specified using ENSURES and LEADS-TO.





References-found: 17

