URL: http://www.cs.gatech.edu/computing/Database/students/vibby/papers/icde97.ps.Z
Refering-URL: http://www.cs.gatech.edu/computing/Database/students/vibby/vibby.html
Root-URL: 
Email: fvibby,anant,srpg@watson.ibm.com  
Title: Interfacing Parallel Applications and Parallel Databases  
Author: Vibby Gottemukkala Anant Jhingran Sriram Padmanabhan 
Address: P.0.Box 704, Yorktown Heights, NY 10598  
Affiliation: IBM T. J. Watson Research Center  
Abstract: The use of parallel database systems to deliver high performance has become quite common. Although queries submitted to these database systems are executed in parallel, the interaction between applications and current parallel database systems is serial. As the complexity of the applications and the amount of data they access increases, the need to parallelize applications also increases. In this parallel application environment, a serial interface to the database could become the bottleneck in the performance of the application. Hence, parallel database systems should support interfaces that allow the applications to interact with the database system in parallel. In this paper we present a taxonomy of such parallel interfaces, namely, the Single Coordinator, Multiple Coordinator, Hybrid Parallel, and Pure Parallel interfaces. Furthermore, we discuss how each of these interfaces can be realized and in the process introduce new constructs that enable the implementation of the interfaces. We also qualitatively evaluate each of the interfaces with respect to their restrictiveness and performance impact. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal and K. Shim. </author> <title> Developing Tightly-Coupled Data Mining Applications on a Relational Database System. </title> <booktitle> In Proceedings of the 2nd Int'l Conference on Knowledge Discovery in Databases and Data Mining, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: As mentioned in Section 3, in HPI the application processing logic is driven by the database. We use UDFs as the mechanism that allows the database system to drive application logic during query processing <ref> [1] </ref>. Thus, in order to implement HPI, the application first incorporates the data processing logic into a user-defined function (shown as the Application Stub in Figure 5. <p> Another option to avoid the UDF return value overhead is to use the UDF in the WHERE clause of the query as suggested in <ref> [1] </ref>. However, since this technique imposes several restrictions, we recommend that the application always use the select-list UDF as the method for implementing HPI. The application passes the execution control to the database by executing the SQL statement (Step 2 in Figure 5).
Reference: [2] <author> G.M. </author> <title> Amdahl. Validity of the Single Processor Ap proach to Achieving Large Scale Computing Capabilities. </title> <booktitle> In AFIPS Conference, </booktitle> <volume> volume 30, </volume> <year> 1967. </year>
Reference-contexts: If all these applications can only interact with the database via a single thread, then the funneling of the entire result set through a single thread could become a bottleneck. According to Amdahl's law <ref> [2] </ref>, the maximum speedup that parallelism can provide is bounded by the inverse of the fraction that represents the serial portion of the task.
Reference: [3] <author> C. K. Baru et al. </author> <title> DB2 Parallel Edition. </title> <journal> IBM Systems Journal, </journal> <volume> 34(2) </volume> <pages> 292-322, </pages> <year> 1995. </year>
Reference-contexts: Parallel database model: In order to simplify our discussion, we assume that the underlying database architecture is a Shared-Nothing (SN) architecture [18] based on a Massively Parallel Processing (MPP) system. In the SN parallel database model <ref> [3, 4, 6] </ref>, each table is partitioned and declustered across a number of nodes. DBMS perspective, the application starts by connecting to a database which results in the creation of a database coordinator (dbcoord). The application can issue queries on the database, typically through cursor-based select statements. <p> The discussion includes both the usage of existing parallel database technology and proposed extensions and enhancements. These discussions are mostly based on the IBM DB2 Parallel Edition (DB2 PE) parallel database system <ref> [3, 8] </ref>. Implementing SCI does not require any database system support because the database-application interface does not change. However, the application structure must change so that the appcoord retrieves the data from the database and distributes it to the appslaves in a partitioned manner.
Reference: [4] <author> H. Boral et al. </author> <title> Prototyping Bubba, A Highly Parallel Database System. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 4-23, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Parallel database model: In order to simplify our discussion, we assume that the underlying database architecture is a Shared-Nothing (SN) architecture [18] based on a Massively Parallel Processing (MPP) system. In the SN parallel database model <ref> [3, 4, 6] </ref>, each table is partitioned and declustered across a number of nodes. DBMS perspective, the application starts by connecting to a database which results in the creation of a database coordinator (dbcoord). The application can issue queries on the database, typically through cursor-based select statements.
Reference: [5] <author> D. DeWitt and J. Gray. </author> <title> Parallel Database Systems: The Future of High Performance Database Systems. </title> <journal> Communications of the ACM, </journal> <volume> 35(6) </volume> <pages> 85-98, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Parallel database systems have become very attractive because of their ability to manipulate multi-gigabyte and terabyte databases very efficiently <ref> [5, 12] </ref>. Several commercial parallel database products are currently available including IBM's DB2 products, Informix XPS, Oracle, Sybase MPP, Tandem, and Teradata. All these products employ intra-query parallelism techniques to speed up the performance of complex queries, which makes manipulation of large data sets feasible and manageable.
Reference: [6] <author> D. J. DeWitt et al. </author> <title> The Gamma Database Machine Project. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 44-61, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Parallel database model: In order to simplify our discussion, we assume that the underlying database architecture is a Shared-Nothing (SN) architecture [18] based on a Massively Parallel Processing (MPP) system. In the SN parallel database model <ref> [3, 4, 6] </ref>, each table is partitioned and declustered across a number of nodes. DBMS perspective, the application starts by connecting to a database which results in the creation of a database coordinator (dbcoord). The application can issue queries on the database, typically through cursor-based select statements.
Reference: [7] <author> IBM. </author> <title> Database 2: Application Programming Guide for Common Servers Version 2, </title> <month> May </month> <year> 1995. </year> <title> Product Manual S20H-4643-00. </title>
Reference-contexts: UDFs allow users to extend SQL for purposes of customization, flexibility, standardization, and object-relational support <ref> [7] </ref>. The advantage of implementing a function as an UDF is that it allows the same function to be used by several applications and interactive users. Furthermore, implementing an action as an UDF has performance advantages because the action is performed closer to the data within the database. <p> This mode of keeping state is decidedly inelegant however, most database systems provide mechanisms that support such state maintenance (e.g., the scratchpad facility in DB2 <ref> [7] </ref>). We have to note here that HPI requires an application to generate UDFs for each (distinct) query in the application.
Reference: [8] <author> IBM. </author> <title> DB2 Parallel Edition for AIX, Administration Guide and Reference, </title> <month> September </month> <year> 1995. </year> <title> Product Manual SC09-1982-00. </title>
Reference-contexts: The discussion includes both the usage of existing parallel database technology and proposed extensions and enhancements. These discussions are mostly based on the IBM DB2 Parallel Edition (DB2 PE) parallel database system <ref> [3, 8] </ref>. Implementing SCI does not require any database system support because the database-application interface does not change. However, the application structure must change so that the appcoord retrieves the data from the database and distributes it to the appslaves in a partitioned manner. <p> This is accomplished through a new construct which is an additional clause in the OPEN CURSOR call. OPEN CURSOR C ON NODEGROUP x Here NODEGROUP is a named set of nodes whose members were previously defined (this construct is supported in DB2 PE <ref> [8] </ref>). When a cursor is opened, the database sets up the nodes on which the dbouts need to be established, and the routing table for the pipe leading into the dbouts. <p> One of the major problems with any parallel database that has several threads executing on behalf of a transaction is the error flow. Traditionally, in SCI and MCI, error flow happens from dbslaves to dbcoord, and is returned to the application on the next request associated with the cursor <ref> [8] </ref>. In addition, the dbcoord propagates the error to all the other dbslaves. Thus, errors are communicated as soon as possible. However, in a PPI model the same is not possible because the appcoord does not issue a call to the dbcoord until it is ready to close the cursor.
Reference: [9] <author> W. H. Inmon. </author> <title> Data Warehouse and Software Develop ment. </title> <booktitle> Management Systems Development, </booktitle> <volume> 15(2), </volume> <year> 1995. </year>
Reference-contexts: One class of such applications are those that retrieve moderate to large amounts of data from the database after posing simple to moderately complex queries. Such applications include mailing list generation for direct marketing, and extract applications to populate other databases (e.g. an OLAP database) <ref> [9] </ref>, where simple classifying queries are used to retrieve significant portions of the underlying data. Another class of applications that are well suited for parallel execution are those that repeatedly scan a data set or different data sets and perform analysis.
Reference: [10] <author> V. Linnemann et al. </author> <title> Design and Implementation of an Extensible Database Management System Supporting User Defined Data Types and Functions. </title> <booktitle> In Proceedings of the VLDB Conference, </booktitle> <year> 1988. </year>
Reference-contexts: FOR SELECT sel_cols FROM T1 WHERE -predicates- AND NODENUMBER (T1.a) = CURRENT NODE; open_file (F.i); while (!end-of-tuples) FETCH FROM c.i INTO host-vars; fprintf (F.i,host-vars); -close_file (F.i); close (c.i); connect reset; -4.2 Hybrid parallel interface Before we discuss the realization of HPI, we briefly discuss the concept of user-defined functions (UDFs) <ref> [10, 11] </ref>. UDFs allow users to extend SQL for purposes of customization, flexibility, standardization, and object-relational support [7]. The advantage of implementing a function as an UDF is that it allows the same function to be used by several applications and interactive users.
Reference: [11] <author> G. Lohman et al. </author> <title> Extensions to Starburst: Objects, Types, Functions, and Rules. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <year> 1991. </year>
Reference-contexts: FOR SELECT sel_cols FROM T1 WHERE -predicates- AND NODENUMBER (T1.a) = CURRENT NODE; open_file (F.i); while (!end-of-tuples) FETCH FROM c.i INTO host-vars; fprintf (F.i,host-vars); -close_file (F.i); close (c.i); connect reset; -4.2 Hybrid parallel interface Before we discuss the realization of HPI, we briefly discuss the concept of user-defined functions (UDFs) <ref> [10, 11] </ref>. UDFs allow users to extend SQL for purposes of customization, flexibility, standardization, and object-relational support [7]. The advantage of implementing a function as an UDF is that it allows the same function to be used by several applications and interactive users.
Reference: [12] <author> C. Mohan, H. Pirahesh, W. Tang, and Y. Wang. </author> <title> Paral lelism in relational database management systems. </title> <journal> IBM System Journal, </journal> <volume> 33(2), </volume> <year> 1994. </year>
Reference-contexts: 1 Introduction Parallel database systems have become very attractive because of their ability to manipulate multi-gigabyte and terabyte databases very efficiently <ref> [5, 12] </ref>. Several commercial parallel database products are currently available including IBM's DB2 products, Informix XPS, Oracle, Sybase MPP, Tandem, and Teradata. All these products employ intra-query parallelism techniques to speed up the performance of complex queries, which makes manipulation of large data sets feasible and manageable.
Reference: [13] <author> R. W. </author> <title> Moore.High Performance Data Assimilation. </title> <note> Unpublished. Available at http://www.sdsc.edu/ En-ablingTech/InfoServers/HPDA.html, </note> <year> 1995. </year>
Reference-contexts: Yet another class of applications suited for parallel execution and retrieval are scientific applications that perform data assimilation where large, distinct sets of scientific, image, and observational data are searched, retrieved and analyzed to find correlations in the data <ref> [13, 19] </ref>. If all these applications can only interact with the database via a single thread, then the funneling of the entire result set through a single thread could become a bottleneck.
Reference: [14] <author> S. Padmanabhan. </author> <title> Extracting Large Data Sets using DB2 PE. </title> <booktitle> In Proceedings of the 22nd VLDB, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: New SQL function based retrieval: The other approach to providing parallel retrieval of data is to provide new functionality in the query language as in DB2 PE <ref> [14] </ref>. Currently, DB2 PE does not support user-controlled partition functions. However, it supports two new SQL functions, namely, CURRENT NODE and NODENUMBER (column). CURRENT NODE is a value function, similar to CURRENT DATE, that returns the identity of the node on which the query is executed.
Reference: [15] <author> J.C. Shafer, R. Agrawal, and M. Mehta. SPRINT: </author> <title> A Scalable Parallel Classifier for Data Mining. </title> <booktitle> In Proceedings of the 22nd VLDB, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: Another class of applications that are well suited for parallel execution are those that repeatedly scan a data set or different data sets and perform analysis. An example of such an application would be data mining applications <ref> [15, 16, 17] </ref>. Yet another class of applications suited for parallel execution and retrieval are scientific applications that perform data assimilation where large, distinct sets of scientific, image, and observational data are searched, retrieved and analyzed to find correlations in the data [13, 19].
Reference: [16] <author> V. Singh et al. </author> <title> A Highly Scalable Parallel Classifier. </title> <note> In preparation, </note> <month> September </month> <year> 1996. </year>
Reference-contexts: Another class of applications that are well suited for parallel execution are those that repeatedly scan a data set or different data sets and perform analysis. An example of such an application would be data mining applications <ref> [15, 16, 17] </ref>. Yet another class of applications suited for parallel execution and retrieval are scientific applications that perform data assimilation where large, distinct sets of scientific, image, and observational data are searched, retrieved and analyzed to find correlations in the data [13, 19].
Reference: [17] <author> R. Srikant and R. Agrawal. </author> <title> Mining Quantitative Associ ation Rules in Large Relational Tables. </title> <booktitle> In Proceedings of the ACM SIGMOD, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: Another class of applications that are well suited for parallel execution are those that repeatedly scan a data set or different data sets and perform analysis. An example of such an application would be data mining applications <ref> [15, 16, 17] </ref>. Yet another class of applications suited for parallel execution and retrieval are scientific applications that perform data assimilation where large, distinct sets of scientific, image, and observational data are searched, retrieved and analyzed to find correlations in the data [13, 19].
Reference: [18] <author> M. Stonebraker. </author> <title> The Case for Shared Nothing. </title> <journal> IEEE Database Engineering, </journal> <volume> 9(1), </volume> <month> March </month> <year> 1986. </year>
Reference-contexts: Parallel database model: In order to simplify our discussion, we assume that the underlying database architecture is a Shared-Nothing (SN) architecture <ref> [18] </ref> based on a Massively Parallel Processing (MPP) system. In the SN parallel database model [3, 4, 6], each table is partitioned and declustered across a number of nodes. DBMS perspective, the application starts by connecting to a database which results in the creation of a database coordinator (dbcoord).
Reference: [19] <author> J. Turek et al. </author> <title> Search and Retrieval in Large Image Archives. </title> <type> Technical Report RC-20214, </type> <institution> IBM Research Division, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: Yet another class of applications suited for parallel execution and retrieval are scientific applications that perform data assimilation where large, distinct sets of scientific, image, and observational data are searched, retrieved and analyzed to find correlations in the data <ref> [13, 19] </ref>. If all these applications can only interact with the database via a single thread, then the funneling of the entire result set through a single thread could become a bottleneck.
References-found: 19

