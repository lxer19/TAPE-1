URL: http://www.cs.iastate.edu/~lutz/p1.ps
Refering-URL: http://www.cs.iastate.edu/~lutz/papers.html
Root-URL: http://www.cs.iastate.edu
Title: Recursive Computational Depth  
Author: James I. Lathrop and Jack H. Lutz 
Note: This research was supported in part by National Science Foundation Grant CCR-9157382, with matching funds from Rockwell, Microware Systems Corporation, and Amoco Foundation.  
Address: Ames, Iowa 50011 U.S.A.  
Affiliation: Department of Computer Science Iowa State University  
Abstract: In the 1980's, Bennett introduced computational depth as a formal measure of the amount of computational history that is evident in an object's structure. In particular, Bennett identified the classes of weakly deep and strongly deep sequences, and showed that the halting problem is strongly deep. Juedes, Lath-rop, and Lutz subsequently extended this result by defining the class of weakly useful sequences, and proving that every weakly useful sequence is strongly deep. The present paper investigates refinements of Bennett's notions of weak and strong depth, called recursively weak depth (introduced by Fenner, Lutz and Mayordomo) and recursively strong depth (introduced here). It is argued that these refinements naturally capture Bennett's idea that deep objects are those which "contain internal evidence of a nontrivial causal history." The fundamental properties of recursive computational depth are developed, and it is shown that the recursively weakly (respectively, strongly) deep sequences form a proper subclass of the class of weakly (respectively, strongly) deep sequences. The above-mentioned theorem of Juedes, Lathrop, and Lutz is then strengthened by proving that every weakly useful sequence is recursively strongly deep. It follows from these results that not every strongly deep sequence is weakly useful, thereby answering a question posed by Juedes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Ambos-Spies and Y. Wang. </author> <title> Algorithmic randomness concepts: a comparison. Talk by K. Ambos-Spies at the Workshop on Information and Randomness in Complexity Classes, </title> <address> Schloss Dagstuhl, Germany, </address> <month> July 17, </month> <year> 1996. </year>
Reference-contexts: We now show that a rec-random sequence can be ultracompressible. Similar results have been proven by Wang [29] and Ambos-Spies and Wang <ref> [1] </ref> for the monotone Kolmogorov complexities of rec-random sequences. The present result is slightly stronger than these results in that it gives a single rec-random sequence S that has property (3.1) for every computable, nondecreasing, unbounded function g.
Reference: [2] <author> J. L. Balcazar, J. Daz, and J. Gabarro. </author> <title> Structural Complexity I (second edition). </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: Using standard techniques <ref> [2, 8] </ref>, it is easy to show that, for every computable function r : N ! N , there is a strictly increasing, time-constructible function s : N ! N such that, for all n 2 N , r (n) s (n). Lemma 3.11 (Slow Growth Lemma, version I).
Reference: [3] <author> C. H. Bennett. </author> <title> Dissipation, information, computational complexity and the definition of organization. </title> <editor> In D. Pines, editor, </editor> <booktitle> Emerging Syntheses in Science, Proceedings of the Founding Workshops of the Santa Fe Institute, </booktitle> <pages> pages 297-313, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction Computational depth was introduced by Bennett <ref> [3, 4] </ref> as a formal measure of the amount of computational history that is evident in the structure of a computational, physical, or biological object. <p> depth of an object x at significance level c is the time required for a computation to derive x from a binary description that is itself compressible by no more than c bits. (That is, every description of consists of at least jj c bits.) For (infinite, binary) sequences, Bennett <ref> [3, 4] </ref> introduced two interesting depth conditions, strong depth and weak depth.
Reference: [4] <author> C. H. Bennett. </author> <title> Logical depth and physical complexity. </title> <editor> In R. Herken, editor, </editor> <booktitle> The Universal Turing Machine: A Half-Century Survey, </booktitle> <pages> pages 227-257. </pages> <publisher> Oxford University Press, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Computational depth was introduced by Bennett <ref> [3, 4] </ref> as a formal measure of the amount of computational history that is evident in the structure of a computational, physical, or biological object. <p> Bennett thus says that a deep object is "one whose most plausible origin, via an effective process, entails a lengthy computation," and, more succinctly, that a deep object is one that contains "internal evidence of a nontrivial causal history" <ref> [4] </ref>. In order to avoid undue sensitivity to the underlying computational model, Ben-nett's definition of depth refers not only to an object's shortest description, but to all descriptions of the object that have nearly minimal length. This is achieved by adding a significance parameter to the definition. <p> depth of an object x at significance level c is the time required for a computation to derive x from a binary description that is itself compressible by no more than c bits. (That is, every description of consists of at least jj c bits.) For (infinite, binary) sequences, Bennett <ref> [3, 4] </ref> introduced two interesting depth conditions, strong depth and weak depth. <p> A strongly deep sequence is thus analogous to a great work of literature for which no number of readings suffices to exhaust its value. 2 It was shown by Bennett <ref> [4] </ref> (and also in [10]) that no sequence that is either decidable or random (i.e., algorithmically random in the sense of Martin-Lof [19]) can be strongly deep. However, strongly deep sequences do exist. For example, Bennett [4] noted that K, the diagonal halting problem, is strongly deep. <p> number of readings suffices to exhaust its value. 2 It was shown by Bennett <ref> [4] </ref> (and also in [10]) that no sequence that is either decidable or random (i.e., algorithmically random in the sense of Martin-Lof [19]) can be strongly deep. However, strongly deep sequences do exist. For example, Bennett [4] noted that K, the diagonal halting problem, is strongly deep. This is because K, unlike a decidable or random sequence, can be used (as an oracle) to decide any decidable sequence within a computable (in fact, polynomial) time bound that does not depend on the sequence. <p> First, as noted above, rec-strongly deep sequences show evidence of a "nontrivial causal history" in a natural, constructive, incremental sense. Second, as we show in this paper, rec-strong 4 depth enjoys the same useful slow-growth property (and consequent upward closure under truth-table reductions) that Bennett <ref> [4] </ref> proved for strong depth. Third, as we show in this paper, rec-strong depth can be used to separate weak usefulness from strong depth, thereby answering Juedes's question. <p> This paper is largely self-contained. It can be read independently of <ref> [4, 10] </ref>, but we assume that [10] is at hand for reference. In section 2 we introduce basic terminology and notation and summarize those elements of recursive measure, randomness, Kol-mogorov complexity, and computational depth that are used in this paper. <p> Theorem 2.8 (Lutz [18]). For every computable time bound t : N ! N and every real number ff &lt; 1, K t fi fi REC = 0: 2.3 Computational Depth Following Bennett <ref> [4] </ref>, we define the computational depth of a string w 2 f0; 1g fl significance level c 2 N to be depth c (w) = min n fi fi 9 2 PROG t (w) o That is, depth c (w) is the minimum amount of time required to obtain w from <p> 2 N , define the sets D t n fi fi depth g (n) (S [0::n 1]) &gt; t (n) o D t n fi fi (8 1 n)S 2 D t o Note that D t n fi fi 8 2 PROG t (S [0::n 1]) o Definition (Bennett <ref> [4] </ref>). A sequence S 2 C is strongly deep, and we write S 2 strDEEP, if for every computable time bound t : N ! N and every constant c 2 N , S 2 D t c . <p> A proof also appears in [10]. Theorem 2.9. RAND " strDEEP = ;. In fact, there exist a computable function t (n) = O (n log n) and a constant c 2 N such that RAND " D t c = ;. Bennett <ref> [4] </ref> gave useful characterizations of strong depth in terms of the time bounded Kolmogorov complexities and algorithmic probabilities of prefixes. <p> A proof also appears in [10]. Theorem 2.10 (Bennett <ref> [4] </ref>). <p> Bennett defined weak depth as follows. Definition. A sequence S 2 C is weakly deep, and we write S 2 wkDEEP, if there is no sequence R 2 RAND such that S tt R. Bennett <ref> [4] </ref> proved that strDEEP $ wkDEEP. Juedes, Lathrop, and Lutz [10] subsequently proved the stronger fact that, in the sense of Baire category (defined in section 3.3 below), almost every sequence in C is weakly deep, but not strongly deep. The reader is referred to [4], [10], or [15] for further <p> Bennett <ref> [4] </ref> proved that strDEEP $ wkDEEP. Juedes, Lathrop, and Lutz [10] subsequently proved the stronger fact that, in the sense of Baire category (defined in section 3.3 below), almost every sequence in C is weakly deep, but not strongly deep. The reader is referred to [4], [10], or [15] for further discussion of computational depth. 3 Recursive Computational Depth As noted in section 2.3, the value depth c (w) the computational depth of a string w at significance level c is not computable from w and c. <p> this section, we use the quantity depth l c (w) to define recursively strong depth; we review the notion of recursively weak depth introduced by Fenner, Lutz, and Mayordomo [6]; and we investigate the relationships of these notions to each other, to the strong and weak depth notions of Bennett <ref> [4] </ref> (defined in section 2.3), and to the notion of weak usefulness introduced by Juedes, Lathrop, and Lutz [10]. 3.1 Recursive Depth Classes We begin by defining the recursive analogs of the depth classes D t g (n) and D t g discussed in section 2.3. Definition. <p> That is, rec-strDEEP = " t2rec c : We first note that every rec-strongly deep sequence is strongly deep. Observation 3.1. rec-strDEEP strDEEP. Proof. This follows immediately from the fact that each D t; rec c D t Since REC " strDEEP = ; <ref> [4] </ref> (see also [10]), it follows immediately from Observation 3.1 that no recursive sequence can be rec-strongly deep. <p> D t; l n fi fi (8 1 n) S 2 e D t; l o e D t; rec n fi fi (9l 2 rec) S 2 e D t; l o 17 The following lemma is exactly analogous to Lemma 5.3 of [10], which is due to Bennett <ref> [4] </ref>. The proof is a straightforward adaptation of the proof in [10]. Lemma 3.5. <p> This result, called the deterministic slow-growth law for recursive computational depth, places a quantitative upper bound on the ability of a time-bounded oracle Turing machine to amplify the depth of its oracle. The first slow-growth laws were proven by Bennett <ref> [4] </ref>. The slow-growth law here is a refinement of Lemma 5.5 of [10]. As in [10], we need two special notations. <p> The following theorem gives the inclusion relations that hold among the weak, strong, rec-weak, and rec-strong depth classes defined in sections 2.3 and 3.1. Theorem 3.14. The following diagram of inclusions holds. rec-wkDEEP rec-strDEEP wkDEEP strDEEP Proof. It was shown by Bennett <ref> [4] </ref> (see also [10]) that strDEEP wkDEEP, and Observations 3.1 and 3.9 tell us that rec-strDEEP strDEEP and rec-wkDEEP wkDEEP. All that remains, then, is to show that rec-strDEEP rec-wkDEEP. Let S 2 rec-strDEEP, and let F be a uniform reducibility. <p> We can now answer this question negatively. 38 Corollary 3.28. wkUSEFUL $ strDEEP Proof. This follows immediately from Theorems 3.23 and 3.27. fl 4 Conclusion The results of this paper, together with earlier results of Bennett <ref> [4] </ref>, Juedes, Lath-rop, and Lutz [10], and Fenner, Lutz, and Mayordomo [6], establish the following relationships. rec-wkDEEP $ strUSEFUL $ wkUSEFUL rec-strDEEP wkDEEP $ strDEEP We conjecture that the inclusion wkUSEFUL rec-strDEEP is also proper, i.e., that rec-strong depth is not a sufficient condition for weak usefulness.
Reference: [5] <author> G. J. Chaitin. </author> <title> A theory of program size formally identical to information theory. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 22 </volume> <pages> 329-340, </pages> <year> 1975. </year>
Reference-contexts: These notions are also developed in the text by Li and Vitanyi [15]. We write K (n) for K (s n ), where s n is the n th string in the standard enumeration of f0; 1g fl Lemma 2.5 (Chaitin <ref> [5] </ref>). There is a constant c 2 N such that, for all n; k 2 N , fi fi x 2 f0; 1g n fi o fi fi &lt; 2 n+ck : We also use the following result on the noncomputability of K (n). Theorem 2.6 (Kolmogorov, reported in [30]).
Reference: [6] <author> S. A. Fenner, J. H. Lutz, and E. Mayordomo. </author> <title> Weakly useful sequences. </title> <booktitle> In Proceedings of the 22 nd International Colloquium on Automata, Languages, and Programming, </booktitle> <pages> pages 393-404. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: By the above remark, K is strongly useful. It is evident that every strongly useful sequence is weakly useful, and Fenner, Lutz, and Mayordomo <ref> [6] </ref> have shown that the converse does not hold, so the set of strongly useful sequences is properly contained in the set of weakly useful sequences. Juedes, Lathrop, and Lutz [10] proved that every weakly useful sequence is strongly deep. <p> Fifth, and perhaps most compelling, we show that the relationships among rec-strong depth, the notion of rec-weak depth introduced by Fenner, Lutz and May-ordomo <ref> [6] </ref>, and the notion of rec-randomness that has been investigated by Schnorr [24, 25], van Lambalgen [28], Lutz [18], Wang [29], and others correspond closely to the relationships among strong depth, weak depth and algorithmic randomness. This paper is largely self-contained. <p> Section 3 is divided into a preamble and four (sub-)sections. In the preamble, we develop the above-mentioned recursive depth function, depth l c (w). In section 3.1 we use this function to define rec-strong depth; we review the notion of rec-weak depth introduced by Fenner, Lutz, and Mayordomo <ref> [6] </ref>; and we introduce the most basic properties of these notions. <p> In this section, we use the quantity depth l c (w) to define recursively strong depth; we review the notion of recursively weak depth introduced by Fenner, Lutz, and Mayordomo <ref> [6] </ref>; and we investigate the relationships of these notions to each other, to the strong and weak depth notions of Bennett [4] (defined in section 2.3), and to the notion of weak usefulness introduced by Juedes, Lathrop, and Lutz [10]. 3.1 Recursive Depth Classes We begin by defining the recursive analogs <p> For every computable time bound t : N ! N and every constant c 2 N , S 2 e D t; rec We now turn to recursively weak depth, which was introduced by Fenner, Lutz, and Mayordomo <ref> [6] </ref>. Recall from section 2.1 the definitions of tt-reductions and the set TTC of all tt-conditions. Definition. A uniform reducibility is a computable function F : N fi N ! TTC. <p> If F is a uniform reducibility and A 2 C, then the upper F span of A is the set n fi fi A F B : Definition (Fenner, Lutz, and Mayordomo <ref> [6] </ref>). Let F be a uniform reducibility. A sequence S 2 C is recursively F deep (briefly, rec-F deep), and we write S 2 rec-F -DEEP, if rec (F 1 (S)) = 0. Definition (Fenner, Lutz, and Mayordomo [6]). <p> n fi fi A F B : Definition (Fenner, Lutz, and Mayordomo <ref> [6] </ref>). Let F be a uniform reducibility. A sequence S 2 C is recursively F deep (briefly, rec-F deep), and we write S 2 rec-F -DEEP, if rec (F 1 (S)) = 0. Definition (Fenner, Lutz, and Mayordomo [6]). A sequence S 2 C is recursively weakly deep (briefly, rec-weakly deep), and we write S 2 rec-wkDEEP, if, for every uniform reducibility F , S is rec-F -deep. <p> As it is, however, Observation 3.8, together with the fact that RAND RAND (rec), tells us that every rec-weakly deep sequence is weakly deep. Observation 3.9 (Fenner, Lutz, and Mayordomo <ref> [6] </ref>). rec-wkDEEP wkDEEP. If F is any uniform reducibility such that the relation F is reflexive, then by the proof of Observation 3.8, the set rec-F -DEEP must be disjoint from RAND (rec), and hence must have measure 0 in C. <p> However, the measure of rec-F -DEEP in REC is a different matter. Theorem 3.10 (Fenner, Lutz, and Mayordomo <ref> [6] </ref>). <p> Fenner, Lutz, and Mayordomo <ref> [6] </ref> subsequently proved that every weakly useful sequence is rec-weakly deep. In this section, we strengthen both these results by proving that every weakly useful sequence is rec-strongly deep. Our argument closely follows that of [10], but it is short and central, so we present it in full. <p> It is well-known that K is polynomial-time many-one complete for the set of all recursively enumerable subsets of N , so K is strongly useful. It is clear that every strongly useful sequence is weakly useful. Fenner, Lutz, and Mayordomo <ref> [6] </ref> used martingale diagonalization to construct a sequence that is weakly useful but not strongly useful, so strUSEFUL $ wkUSEFUL. Our proof that every weakly useful sequence is rec-strongly deep uses the following theorem, which is a recursive strengthening of Theorem 5.8 of [10]. <p> We can now answer this question negatively. 38 Corollary 3.28. wkUSEFUL $ strDEEP Proof. This follows immediately from Theorems 3.23 and 3.27. fl 4 Conclusion The results of this paper, together with earlier results of Bennett [4], Juedes, Lath-rop, and Lutz [10], and Fenner, Lutz, and Mayordomo <ref> [6] </ref>, establish the following relationships. rec-wkDEEP $ strUSEFUL $ wkUSEFUL rec-strDEEP wkDEEP $ strDEEP We conjecture that the inclusion wkUSEFUL rec-strDEEP is also proper, i.e., that rec-strong depth is not a sufficient condition for weak usefulness.
Reference: [7] <author> W. I. Gasarch and J. H. Lutz. </author> <type> Unpublished manuscript, </type> <year> 1991. </year>
Reference-contexts: The present result is slightly stronger than these results in that it gives a single rec-random sequence S that has property (3.1) for every computable, nondecreasing, unbounded function g. The proof is based in part on a simpler, unpublished construction by Gasarch and Lutz <ref> [7] </ref> of a rec-random sequence that is not algorithmically random. Theorem 3.16. There is a rec-random sequence that is ultracompressible. Proof.
Reference: [8] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Using standard techniques <ref> [2, 8] </ref>, it is easy to show that, for every computable function r : N ! N , there is a strictly increasing, time-constructible function s : N ! N such that, for all n 2 N , r (n) s (n). Lemma 3.11 (Slow Growth Lemma, version I).
Reference: [9] <author> D. W. Juedes. </author> <title> The Complexity and Distribution of Computationally Useful Problems. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Iowa State University, </institution> <year> 1994. </year>
Reference-contexts: Juedes, Lathrop, and Lutz [10] proved that every weakly useful sequence is strongly deep. This generalized Bennett's observation that K is strongly deep and gave formal support to Bennett's informal arguments relating depth and usefulness. Strong depth is a necessary condition for weak usefulness. Juedes <ref> [9] </ref> subsequently asked whether the converse is true, i.e., whether strong depth actually characterizes weak usefulness. In this paper, we show that weakly useful sequences have a strictly stronger depth property than strong depth, thereby answering Juedes's question negatively. <p> It follows by Lemma 3.12 that A 2 D t; rec c . fl Juedes <ref> [9] </ref> asked whether every strongly deep sequence is weakly useful. We can now answer this question negatively. 38 Corollary 3.28. wkUSEFUL $ strDEEP Proof.
Reference: [10] <author> D. W. Juedes, J. I. Lathrop, and J. H. Lutz. </author> <title> Computational depth and reducibility. </title> <journal> Theoretical Computer Science, </journal> <volume> 132 </volume> <pages> 37-70, </pages> <year> 1994. </year>
Reference-contexts: A strongly deep sequence is thus analogous to a great work of literature for which no number of readings suffices to exhaust its value. 2 It was shown by Bennett [4] (and also in <ref> [10] </ref>) that no sequence that is either decidable or random (i.e., algorithmically random in the sense of Martin-Lof [19]) can be strongly deep. However, strongly deep sequences do exist. For example, Bennett [4] noted that K, the diagonal halting problem, is strongly deep. <p> This relationship between depth and usefulness (as an oracle) was investigated more explicitly and generally by Juedes, Lathrop, and Lutz <ref> [10] </ref>, who defined strong and weak usefulness conditions for sequences. <p> It is evident that every strongly useful sequence is weakly useful, and Fenner, Lutz, and Mayordomo [6] have shown that the converse does not hold, so the set of strongly useful sequences is properly contained in the set of weakly useful sequences. Juedes, Lathrop, and Lutz <ref> [10] </ref> proved that every weakly useful sequence is strongly deep. This generalized Bennett's observation that K is strongly deep and gave formal support to Bennett's informal arguments relating depth and usefulness. Strong depth is a necessary condition for weak usefulness. <p> This paper is largely self-contained. It can be read independently of <ref> [4, 10] </ref>, but we assume that [10] is at hand for reference. In section 2 we introduce basic terminology and notation and summarize those elements of recursive measure, randomness, Kol-mogorov complexity, and computational depth that are used in this paper. <p> This paper is largely self-contained. It can be read independently of [4, 10], but we assume that <ref> [10] </ref> is at hand for reference. In section 2 we introduce basic terminology and notation and summarize those elements of recursive measure, randomness, Kol-mogorov complexity, and computational depth that are used in this paper. <p> We write RAND for the set of all random sequences. It is well-known [19] that Pr (RAND) = 1, i.e., almost every sequence is random. We refer the reader to section 4 of <ref> [10] </ref> for a concise presentation of our terminology and notation on Kolmogorov complexity, including (self-delimiting) Turing machines, the efficient universal Turing machine U , the program sets PROG t (x) and PROG t , the Kolmogorov complexity K (x), the time-bounded Kolmogorov complexity K t (x), the algorithmic probability m (x), <p> Theorem 2.7 (Levin [13, 14], Schnorr [26]). A sequence S 2 C is random if and only if there is a constant c 2 N such that, for all n 2 N , K (S [0::n 1]) n c. As in <ref> [10] </ref>, for t; g : N ! N , we use the notation K t n fi fi (9 1 n)K t (S [0::n 1]) &lt; g (n) and the following result on measure in REC. Theorem 2.8 (Lutz [18]). <p> That is, strDEEP = " t2rec c : The following theorem due to Bennett shows that random sequences are very shallow. A proof also appears in <ref> [10] </ref>. Theorem 2.9. RAND " strDEEP = ;. In fact, there exist a computable function t (n) = O (n log n) and a constant c 2 N such that RAND " D t c = ;. <p> Bennett [4] gave useful characterizations of strong depth in terms of the time bounded Kolmogorov complexities and algorithmic probabilities of prefixes. As in <ref> [10] </ref>, we state these characterizations in terms of the following classes, which turn out to be "minor variants" of the classes D t g (n) and D t 12 Definition. <p> A proof also appears in <ref> [10] </ref>. Theorem 2.10 (Bennett [4]). <p> Bennett defined weak depth as follows. Definition. A sequence S 2 C is weakly deep, and we write S 2 wkDEEP, if there is no sequence R 2 RAND such that S tt R. Bennett [4] proved that strDEEP $ wkDEEP. Juedes, Lathrop, and Lutz <ref> [10] </ref> subsequently proved the stronger fact that, in the sense of Baire category (defined in section 3.3 below), almost every sequence in C is weakly deep, but not strongly deep. The reader is referred to [4], [10], or [15] for further discussion of computational depth. 3 Recursive Computational Depth As noted <p> Bennett [4] proved that strDEEP $ wkDEEP. Juedes, Lathrop, and Lutz <ref> [10] </ref> subsequently proved the stronger fact that, in the sense of Baire category (defined in section 3.3 below), almost every sequence in C is weakly deep, but not strongly deep. The reader is referred to [4], [10], or [15] for further discussion of computational depth. 3 Recursive Computational Depth As noted in section 2.3, the value depth c (w) the computational depth of a string w at significance level c is not computable from w and c. <p> notion of recursively weak depth introduced by Fenner, Lutz, and Mayordomo [6]; and we investigate the relationships of these notions to each other, to the strong and weak depth notions of Bennett [4] (defined in section 2.3), and to the notion of weak usefulness introduced by Juedes, Lathrop, and Lutz <ref> [10] </ref>. 3.1 Recursive Depth Classes We begin by defining the recursive analogs of the depth classes D t g (n) and D t g discussed in section 2.3. Definition. <p> That is, rec-strDEEP = " t2rec c : We first note that every rec-strongly deep sequence is strongly deep. Observation 3.1. rec-strDEEP strDEEP. Proof. This follows immediately from the fact that each D t; rec c D t Since REC " strDEEP = ; [4] (see also <ref> [10] </ref>), it follows immediately from Observation 3.1 that no recursive sequence can be rec-strongly deep. <p> S 2 C fi o e D t; l n fi fi (8 1 n) S 2 e D t; l o e D t; rec n fi fi (9l 2 rec) S 2 e D t; l o 17 The following lemma is exactly analogous to Lemma 5.3 of <ref> [10] </ref>, which is due to Bennett [4]. The proof is a straightforward adaptation of the proof in [10]. Lemma 3.5. <p> e D t; l o e D t; rec n fi fi (9l 2 rec) S 2 e D t; l o 17 The following lemma is exactly analogous to Lemma 5.3 of <ref> [10] </ref>, which is due to Bennett [4]. The proof is a straightforward adaptation of the proof in [10]. Lemma 3.5. <p> The first slow-growth laws were proven by Bennett [4]. The slow-growth law here is a refinement of Lemma 5.5 of <ref> [10] </ref>. As in [10], we need two special notations. <p> The first slow-growth laws were proven by Bennett [4]. The slow-growth law here is a refinement of Lemma 5.5 of <ref> [10] </ref>. As in [10], we need two special notations. <p> N ! N by s fl (n) = 2 s (dlog ne)+1 : Second, for any unbounded, nondecreasing function f : N ! N , we define the special-purpose "inverse" function f 1 : N ! N by f 1 (n) = max m fi o 20 Also as in <ref> [10] </ref>, say that a function s : N ! N is time-constructible if there exist a constant c s 2 N and a Turing machine that, given the standard binary representation w of a natural number n, computes the standard binary representation of s (n) in at most c s s <p> Proof. To save space, we refer to the proof of Lemma 5.5 in <ref> [10] </ref>. Let s and M be as in the statement of the lemma. Let M 0 ; M 0 ; c M 0 ; M 00 , and M 00 be as in [10]. <p> Proof. To save space, we refer to the proof of Lemma 5.5 in <ref> [10] </ref>. Let s and M be as in the statement of the lemma. Let M 0 ; M 0 ; c M 0 ; M 00 , and M 00 be as in [10]. <p> Claim 2. For all m m 1 and all 2 PROG t (A [0::m 1]), K 21 where n = (s fl ) 1 (m). Claim 1 was proven in <ref> [10] </ref>. To prove Claim 2, we again follow the proof in [10]. Let m; ; n, and fl be as in [10]. <p> Claim 2. For all m m 1 and all 2 PROG t (A [0::m 1]), K 21 where n = (s fl ) 1 (m). Claim 1 was proven in <ref> [10] </ref>. To prove Claim 2, we again follow the proof in [10]. Let m; ; n, and fl be as in [10]. <p> For all m m 1 and all 2 PROG t (A [0::m 1]), K 21 where n = (s fl ) 1 (m). Claim 1 was proven in <ref> [10] </ref>. To prove Claim 2, we again follow the proof in [10]. Let m; ; n, and fl be as in [10]. <p> An easy consequence of the Slow Growth Lemma is the fact that the class of rec-strongly deep sequences is (like the class of strongly deep sequences <ref> [10] </ref>) closed upwards under tt-reductions. Theorem 3.13. Let A; B 2 C. If B tt A and B is rec-strongly deep, then A is rec-strongly deep. The proof of Theorem 3.13 is identical to the proof of Theorem 5.6 in [10], except that Lemma 3.12 above is used in place of <p> deep sequences is (like the class of strongly deep sequences <ref> [10] </ref>) closed upwards under tt-reductions. Theorem 3.13. Let A; B 2 C. If B tt A and B is rec-strongly deep, then A is rec-strongly deep. The proof of Theorem 3.13 is identical to the proof of Theorem 5.6 in [10], except that Lemma 3.12 above is used in place of Lemma 5.5 in [10]. We now come to the main result of section 3.2. The following theorem gives the inclusion relations that hold among the weak, strong, rec-weak, and rec-strong depth classes defined in sections 2.3 and 3.1. <p> Theorem 3.13. Let A; B 2 C. If B tt A and B is rec-strongly deep, then A is rec-strongly deep. The proof of Theorem 3.13 is identical to the proof of Theorem 5.6 in <ref> [10] </ref>, except that Lemma 3.12 above is used in place of Lemma 5.5 in [10]. We now come to the main result of section 3.2. The following theorem gives the inclusion relations that hold among the weak, strong, rec-weak, and rec-strong depth classes defined in sections 2.3 and 3.1. Theorem 3.14. The following diagram of inclusions holds. rec-wkDEEP rec-strDEEP wkDEEP strDEEP Proof. <p> The following theorem gives the inclusion relations that hold among the weak, strong, rec-weak, and rec-strong depth classes defined in sections 2.3 and 3.1. Theorem 3.14. The following diagram of inclusions holds. rec-wkDEEP rec-strDEEP wkDEEP strDEEP Proof. It was shown by Bennett [4] (see also <ref> [10] </ref>) that strDEEP wkDEEP, and Observations 3.1 and 3.9 tell us that rec-strDEEP strDEEP and rec-wkDEEP wkDEEP. All that remains, then, is to show that rec-strDEEP rec-wkDEEP. Let S 2 rec-strDEEP, and let F be a uniform reducibility. <p> The following known theorem says that the set of strongly deep sequences is small in the sense of Baire category. Theorem 3.19 (Juedes, Lathrop, and Lutz <ref> [10] </ref>). The class strDEEP is meager. We show that rec-wkDEEP * strDEEP by showing that rec-wkDEEP is comea-ger. Our proof of this fact is somewhat more involved than the proof by Juedes, Lathrop, and Lutz [10] that wkDEEP is comeager. Theorem 3.20. <p> Theorem 3.19 (Juedes, Lathrop, and Lutz <ref> [10] </ref>). The class strDEEP is meager. We show that rec-wkDEEP * strDEEP by showing that rec-wkDEEP is comea-ger. Our proof of this fact is somewhat more involved than the proof by Juedes, Lathrop, and Lutz [10] that wkDEEP is comeager. Theorem 3.20. For each uniform reducibility F , the class rec-F -deep is rec-comeager, hence comeager in REC. Proof. Let F be a uniform reducibility. <p> By Theorems 3.10 and 3.20, rec-F -DEEP is large in REC in the senses of both measure and category. The class rec-F -DEEP is thus one concerning which measure and category agree in REC, but disagree in C. 35 3.4 Weakly Useful Sequences Juedes, Lathrop, and Lutz <ref> [10] </ref> defined the class of weakly useful sequences and proved that every weakly useful sequence is strongly deep. Fenner, Lutz, and Mayordomo [6] subsequently proved that every weakly useful sequence is rec-weakly deep. <p> Fenner, Lutz, and Mayordomo [6] subsequently proved that every weakly useful sequence is rec-weakly deep. In this section, we strengthen both these results by proving that every weakly useful sequence is rec-strongly deep. Our argument closely follows that of <ref> [10] </ref>, but it is short and central, so we present it in full. Definition (Juedes, Lathrop, and Lutz [10]). <p> In this section, we strengthen both these results by proving that every weakly useful sequence is rec-strongly deep. Our argument closely follows that of <ref> [10] </ref>, but it is short and central, so we present it in full. Definition (Juedes, Lathrop, and Lutz [10]). A sequence A 2 C is strongly useful, and we write A 2 strUSEFUL, if there is a computable time bound s : N ! N such that REC DTIME A (s). <p> Fenner, Lutz, and Mayordomo [6] used martingale diagonalization to construct a sequence that is weakly useful but not strongly useful, so strUSEFUL $ wkUSEFUL. Our proof that every weakly useful sequence is rec-strongly deep uses the following theorem, which is a recursive strengthening of Theorem 5.8 of <ref> [10] </ref>. Recall the class K t [&lt; g (n)] defined in section 2.2. Theorem 3.24. If t : N ! N is computable and 0 &lt; ff &lt; fi &lt; 1, then REC b D t; rec i.o. [&lt; fin]: Proof. <p> We can now answer this question negatively. 38 Corollary 3.28. wkUSEFUL $ strDEEP Proof. This follows immediately from Theorems 3.23 and 3.27. fl 4 Conclusion The results of this paper, together with earlier results of Bennett [4], Juedes, Lath-rop, and Lutz <ref> [10] </ref>, and Fenner, Lutz, and Mayordomo [6], establish the following relationships. rec-wkDEEP $ strUSEFUL $ wkUSEFUL rec-strDEEP wkDEEP $ strDEEP We conjecture that the inclusion wkUSEFUL rec-strDEEP is also proper, i.e., that rec-strong depth is not a sufficient condition for weak usefulness.
Reference: [11] <author> D. W. Juedes and J. H. Lutz. </author> <title> Weak completeness in E and E 2 . Theoretical Computer Science, </title> <booktitle> 143 </booktitle> <pages> 149-158, </pages> <year> 1995. </year>
Reference-contexts: The following lemma gives a convenient sufficient condition for rec-randomness. It follows immediately from the definition of rec-randomness, the recursive equivalence of martingale success and strong martingale success [28], and the Exact Computation Lemma <ref> [11, 20] </ref>. Lemma 2.4. Let S 2 C.
Reference: [12] <author> J. I. Lathrop. </author> <title> Compression depth and the behavior of cellular automata. </title> <journal> Complex Systems, </journal> <note> 1997. To appear. </note>
Reference-contexts: Fourth, as developed below, rec-strong depth is based on a recursive depth function (with an additional latency parameter), and therefore provide a useful model for the design and analysis of implementable depth measures such as the compression depth introduced by Lathrop <ref> [12] </ref>.
Reference: [13] <author> L. A. Levin. </author> <title> On the notion of a random sequence. </title> <journal> Soviet Mathematics Doklady, </journal> <volume> 14 </volume> <pages> 1413-1416, </pages> <year> 1973. </year>
Reference-contexts: Theorem 2.6 (Kolmogorov, reported in [30]). If g : N ! N is partial recursive and unbounded, then there exist infinitely many n 2 N such that K (n) &lt; g (n). Randomness is characterized in terms of Kolmogorov complexity as follows. Theorem 2.7 (Levin <ref> [13, 14] </ref>, Schnorr [26]). A sequence S 2 C is random if and only if there is a constant c 2 N such that, for all n 2 N , K (S [0::n 1]) n c.
Reference: [14] <author> L. A. Levin. </author> <title> Laws of information conservation (nongrowth) and aspects of the foundation of probability theory. </title> <journal> Problems of Information Transmission, </journal> <volume> 10 </volume> <pages> 206-210, </pages> <year> 1974. </year>
Reference-contexts: Theorem 2.6 (Kolmogorov, reported in [30]). If g : N ! N is partial recursive and unbounded, then there exist infinitely many n 2 N such that K (n) &lt; g (n). Randomness is characterized in terms of Kolmogorov complexity as follows. Theorem 2.7 (Levin <ref> [13, 14] </ref>, Schnorr [26]). A sequence S 2 C is random if and only if there is a constant c 2 N such that, for all n 2 N , K (S [0::n 1]) n c.
Reference: [15] <author> M. Li and P. M. B. Vitanyi. </author> <title> An Introduction to Kolmogorov Complexity and its Applications. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: These notions are also developed in the text by Li and Vitanyi <ref> [15] </ref>. We write K (n) for K (s n ), where s n is the n th string in the standard enumeration of f0; 1g fl Lemma 2.5 (Chaitin [5]). <p> Bennett [4] proved that strDEEP $ wkDEEP. Juedes, Lathrop, and Lutz [10] subsequently proved the stronger fact that, in the sense of Baire category (defined in section 3.3 below), almost every sequence in C is weakly deep, but not strongly deep. The reader is referred to [4], [10], or <ref> [15] </ref> for further discussion of computational depth. 3 Recursive Computational Depth As noted in section 2.3, the value depth c (w) the computational depth of a string w at significance level c is not computable from w and c.
Reference: [16] <author> L. R. Lisagor. </author> <title> The Banach-Mazur Game. </title> <journal> Translated in Math. USSR Sbornik, </journal> <volume> 38 </volume> <pages> 201-206, </pages> <year> 1981. </year>
Reference-contexts: Definition (Lutz [17]). Let X C. 1. X is rec-meager if there is a winning strategy for player II in the Banach-Mazur game G [X; all; rec]. 2. X is rec-comeager if X c is rec-meager. Definition (Lisagor <ref> [16] </ref>, Lutz [17]). Let X C. 1. X is meager in REC if X " REC is rec-meager. 2. X is comeager in REC if X c is meager in REC. <p> Thus, if a set X C is comeager, we say that X contains almost every sequence in the sense of Baire category. The situation is analogous for sets that are meager in REC. Every subset of a set that is meager in REC is clearly meager in REC. Lisagor <ref> [16] </ref> has also shown that every recursive union (a natural, effective notion of countable union) of sets that are meager in REC is meager in REC and, more importantly, that no cylinder is meager in REC. <p> Similarly, if X is comeager in REC, then X contains almost every sequence in REC in the sense of Baire category. It is well-known <ref> [21, 16] </ref> that a set may be large in the sense of measure but small in the sense of Baire category, or vice versa. The following known theorem says that the set of strongly deep sequences is small in the sense of Baire category.
Reference: [17] <author> J. H. Lutz. </author> <title> Category and measure in complexity classes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 19 </volume> <pages> 1100-1131, </pages> <year> 1990. </year>
Reference-contexts: X is comeager if X c is meager. A meager set is sometimes called a set of first category, or a set of first category in the sense of Baire. Definition (Lutz <ref> [17] </ref>). Let X C. 1. X is rec-meager if there is a winning strategy for player II in the Banach-Mazur game G [X; all; rec]. 2. X is rec-comeager if X c is rec-meager. Definition (Lisagor [16], Lutz [17]). Let X C. 1. <p> Definition (Lutz <ref> [17] </ref>). Let X C. 1. X is rec-meager if there is a winning strategy for player II in the Banach-Mazur game G [X; all; rec]. 2. X is rec-comeager if X c is rec-meager. Definition (Lisagor [16], Lutz [17]). Let X C. 1. X is meager in REC if X " REC is rec-meager. 2. X is comeager in REC if X c is meager in REC.
Reference: [18] <author> J. H. Lutz. </author> <title> Almost everywhere high nonuniform complexity. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 44 </volume> <pages> 220-258, </pages> <year> 1992. </year>
Reference-contexts: fixed computable time bound t : N ! N such that the set DTIME S (t) does not have measure 0 in REC, i.e., DTIME S (t) " REC is a nonnegligible subset of REC in the sense of the recursive case of the resource-bounded measure theory developed by Lutz <ref> [18] </ref>. That is, S is weakly useful if a nonnegligible set of decidable sequences can be decided within a computable time bound that may depend on S but does not depend on the sequence being decided. By the above remark, K is strongly useful. <p> Fifth, and perhaps most compelling, we show that the relationships among rec-strong depth, the notion of rec-weak depth introduced by Fenner, Lutz and May-ordomo [6], and the notion of rec-randomness that has been investigated by Schnorr [24, 25], van Lambalgen [28], Lutz <ref> [18] </ref>, Wang [29], and others correspond closely to the relationships among strong depth, weak depth and algorithmic randomness. This paper is largely self-contained. It can be read independently of [4, 10], but we assume that [10] is at hand for reference. <p> Both directions of the incomparability proof are nontrivial. One direction yields the stronger fact that rec-random sequences can be strongly deep, while the other direction uses the recursive version of the first Borel-Cantelli lemma <ref> [18] </ref> in a Baire category argument. In section 3.4 we prove that every weakly useful sequence is rec-strongly deep, thereby answering Juedes's question. <p> As in <ref> [18] </ref>, we effectivize this characterization to obtain a notion of measure in REC. A rec-martingale (recursive martingale) is a martingale that is computable in the sense defined in section 2.1. Definition (Lutz [18]). Let X C. 1. <p> As in <ref> [18] </ref>, we effectivize this characterization to obtain a notion of measure in REC. A rec-martingale (recursive martingale) is a martingale that is computable in the sense defined in section 2.1. Definition (Lutz [18]). Let X C. 1. X has rec-measure 0, and we write rec (X) = 0, if there is a rec-martingale d such that X S 1 [d]. 2. X has rec-measure 1, and we write rec (X) = 1, if rec (X c ) = 0. 3. <p> X has measure 0 in REC, and we write (XjREC) = 0, if rec (X " REC) = 0. 4. X has measure 1 in REC, and we write (XjREC) = 1, if (X c jREC) = 0. Results proven in <ref> [18] </ref> justify the intuition that (XjREC) = 0 if and only if X " REC is a negligibly small subset of REC. Accordingly, if (XjREC) = 1, we say that X contains almost every sequence in REC. <p> Accordingly, if (XjREC) = 1, we say that X contains almost every sequence in REC. The unitary success set of a martingale d is S 1 [d] = d (w)1 In section 3.3 we use the following uniform, recursive version of the first Borel-Cantelli lemma. Theorem 2.2 (Lutz <ref> [18] </ref>). <p> Then rec 1 [ 1 " 1 [ S 1 [d k;n ] = 0: Recursive randomness has been investigated by Schnorr [24, 25], van Lambalgen [28], Lutz <ref> [18] </ref>, Wang [29], and others. A sequence S 2 C is rec-random (recursively random), and we write S 2 RAND (rec), if there is no rec-martingale that succeeds on S. The following easy consequence of Theorem 2.2 is also used in section 3.3. Corollary 2.3 (Lutz [18]). <p> van Lambalgen [28], Lutz <ref> [18] </ref>, Wang [29], and others. A sequence S 2 C is rec-random (recursively random), and we write S 2 RAND (rec), if there is no rec-martingale that succeeds on S. The following easy consequence of Theorem 2.2 is also used in section 3.3. Corollary 2.3 (Lutz [18]). <p> As in [10], for t; g : N ! N , we use the notation K t n fi fi (9 1 n)K t (S [0::n 1]) &lt; g (n) and the following result on measure in REC. Theorem 2.8 (Lutz <ref> [18] </ref>).
Reference: [19] <author> P. Martin-Lof. </author> <title> On the definition of random sequences. </title> <journal> Information and Control, </journal> <volume> 9 </volume> <pages> 602-619, </pages> <year> 1966. </year>
Reference-contexts: deep sequence is thus analogous to a great work of literature for which no number of readings suffices to exhaust its value. 2 It was shown by Bennett [4] (and also in [10]) that no sequence that is either decidable or random (i.e., algorithmically random in the sense of Martin-Lof <ref> [19] </ref>) can be strongly deep. However, strongly deep sequences do exist. For example, Bennett [4] noted that K, the diagonal halting problem, is strongly deep. <p> Lemma 2.4. Let S 2 C. If for every exact rec-martingale d satisfying d () = 1 there exist c d 2 N and infinitely many prefixes w v S such that d (w) c d , then S is rec-random. 10 Algorithmic randomness, introduced by Martin-Lof <ref> [19] </ref>, is a stronger condition than rec-randomness that can be defined in several equivalent ways. The definition in terms of martingales, introduced by Schnorr [24], states that a sequence S 2 C is (algorithmically) random if no lower semicomputable martingale succeeds on S. <p> The definition in terms of martingales, introduced by Schnorr [24], states that a sequence S 2 C is (algorithmically) random if no lower semicomputable martingale succeeds on S. We write RAND for the set of all random sequences. It is well-known <ref> [19] </ref> that Pr (RAND) = 1, i.e., almost every sequence is random.
Reference: [20] <author> E. Mayordomo. </author> <title> Contributions to the study of resource-bounded measure. </title> <type> PhD thesis, </type> <institution> Universitat Politecnica de Catalunya, </institution> <year> 1994. </year>
Reference-contexts: The following lemma gives a convenient sufficient condition for rec-randomness. It follows immediately from the definition of rec-randomness, the recursive equivalence of martingale success and strong martingale success [28], and the Exact Computation Lemma <ref> [11, 20] </ref>. Lemma 2.4. Let S 2 C.
Reference: [21] <author> J. C. Oxtoby. </author> <title> Measure and Category. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1980. </year>
Reference-contexts: A winning strategy for player II in a Banach-Mazur game G [X; S I ; S II ] is a strategy fi 2 S II such that, for every strategy ff 2 S I ,R (ff; fi) 62 X. Definition (Mazur and Banach <ref> [21] </ref>). Let X C. 1. X is meager if there is a winning strategy for player II in the Banach-Mazur game G [X]. 2. X is comeager if X c is meager. <p> It is also clear that every subset of a meager set is meager and that every countable set X C is meager. In fact, it is well known that every countable union of meager sets is meager <ref> [21] </ref>. On the other hand, the Baire Category Theorem [21] says that no cylinder is meager. These facts justify the intuition that meager sets are negligibly small in the sense of Baire category. <p> It is also clear that every subset of a meager set is meager and that every countable set X C is meager. In fact, it is well known that every countable union of meager sets is meager <ref> [21] </ref>. On the other hand, the Baire Category Theorem [21] says that no cylinder is meager. These facts justify the intuition that meager sets are negligibly small in the sense of Baire category. Thus, if a set X C is comeager, we say that X contains almost every sequence in the sense of Baire category. <p> Similarly, if X is comeager in REC, then X contains almost every sequence in REC in the sense of Baire category. It is well-known <ref> [21, 16] </ref> that a set may be large in the sense of measure but small in the sense of Baire category, or vice versa. The following known theorem says that the set of strongly deep sequences is small in the sense of Baire category.
Reference: [22] <author> H. Rogers, Jr. </author> <title> Theory of Recursive Functions and Effective Computability. </title> <address> Mc-Graw Hill, New York, </address> <year> 1967. </year>
Reference-contexts: For A 2 C and s : N ! N , we write DTIME A (s) = n fi fi B DTIME (s) T A : (Note that the time bound is sharp; there is no "big-O.") As in <ref> [22] </ref>, we define a truth-table condition (briefly, a tt-condition) to be an ordered pair t = ((n 1 ; : : : n k ); g), where k; n 1 ; : : : n k 2 N and g : f0; 1g k ! f0; 1g.
Reference: [23] <author> H. L. Royden. </author> <title> Real Analysis, third edition. </title> <publisher> Macmillan Publishing Company, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: f0; 1g , the cylinder C w = A 2 C fi o is assigned the probability (C w ) = Pr (C w ) = 2 jwj : For each event (measurable set) E C, the probability (E ) = Pr (E) is then defined in the standard way <ref> [23] </ref>. We write Pr ['(A)] or Pr A ['(A)] for Pr (fAj'(A)g). A martingale is a function d : f0; 1g fl ! [0; 1) such that, for all w 2 f0; 1g fl d (w) 2 The following inequality of Kolmogorov is easily verified. Lemma 2.1.
Reference: [24] <author> C. P. Schnorr. </author> <title> A unified approach to the definition of random sequences. </title> <journal> Mathematical Systems Theory, </journal> <volume> 5 </volume> <pages> 246-258, </pages> <year> 1971. </year>
Reference-contexts: Fifth, and perhaps most compelling, we show that the relationships among rec-strong depth, the notion of rec-weak depth introduced by Fenner, Lutz and May-ordomo [6], and the notion of rec-randomness that has been investigated by Schnorr <ref> [24, 25] </ref>, van Lambalgen [28], Lutz [18], Wang [29], and others correspond closely to the relationships among strong depth, weak depth and algorithmic randomness. This paper is largely self-contained. It can be read independently of [4, 10], but we assume that [10] is at hand for reference. <p> Then rec 1 [ 1 " 1 [ S 1 [d k;n ] = 0: Recursive randomness has been investigated by Schnorr <ref> [24, 25] </ref>, van Lambalgen [28], Lutz [18], Wang [29], and others. A sequence S 2 C is rec-random (recursively random), and we write S 2 RAND (rec), if there is no rec-martingale that succeeds on S. The following easy consequence of Theorem 2.2 is also used in section 3.3. <p> The definition in terms of martingales, introduced by Schnorr <ref> [24] </ref>, states that a sequence S 2 C is (algorithmically) random if no lower semicomputable martingale succeeds on S. We write RAND for the set of all random sequences. It is well-known [19] that Pr (RAND) = 1, i.e., almost every sequence is random.
Reference: [25] <author> C. P. Schnorr. </author> <title> Zufalligkeit und Wahrscheinlichkeit. </title> <booktitle> Lecture Notes in Mathematics, </booktitle> <volume> 218, </volume> <year> 1971. </year>
Reference-contexts: Fifth, and perhaps most compelling, we show that the relationships among rec-strong depth, the notion of rec-weak depth introduced by Fenner, Lutz and May-ordomo [6], and the notion of rec-randomness that has been investigated by Schnorr <ref> [24, 25] </ref>, van Lambalgen [28], Lutz [18], Wang [29], and others correspond closely to the relationships among strong depth, weak depth and algorithmic randomness. This paper is largely self-contained. It can be read independently of [4, 10], but we assume that [10] is at hand for reference. <p> Then rec 1 [ 1 " 1 [ S 1 [d k;n ] = 0: Recursive randomness has been investigated by Schnorr <ref> [24, 25] </ref>, van Lambalgen [28], Lutz [18], Wang [29], and others. A sequence S 2 C is rec-random (recursively random), and we write S 2 RAND (rec), if there is no rec-martingale that succeeds on S. The following easy consequence of Theorem 2.2 is also used in section 3.3.
Reference: [26] <author> C. P. Schnorr. </author> <title> Process complexity and effective random tests. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 7 </volume> <pages> 376-388, </pages> <year> 1973. </year>
Reference-contexts: Theorem 2.6 (Kolmogorov, reported in [30]). If g : N ! N is partial recursive and unbounded, then there exist infinitely many n 2 N such that K (n) &lt; g (n). Randomness is characterized in terms of Kolmogorov complexity as follows. Theorem 2.7 (Levin [13, 14], Schnorr <ref> [26] </ref>). A sequence S 2 C is random if and only if there is a constant c 2 N such that, for all n 2 N , K (S [0::n 1]) n c.
Reference: [27] <author> R. J. Solomonoff. </author> <title> A formal theory of inductive inference. </title> <journal> Information and Control, </journal> <volume> 7 </volume> <pages> 1-22, 224-254, </pages> <year> 1964. </year>
Reference-contexts: a natural way | in which case we identify x with its encoding | then the computational depth of x is the amount of time required for a computation to derive x from its shortest binary description. (Precise definitions appear in sections 2 and 3 of this paper.) Like Solomonoff <ref> [27] </ref>, Bennett regards a description of x as a formal analog of a scientific explanation of x.
Reference: [28] <author> M. van Lambalgen. </author> <title> Random Sequences. </title> <type> PhD thesis, </type> <institution> Department of Mathematics, University of Amsterdam, </institution> <year> 1987. </year>
Reference-contexts: Fifth, and perhaps most compelling, we show that the relationships among rec-strong depth, the notion of rec-weak depth introduced by Fenner, Lutz and May-ordomo [6], and the notion of rec-randomness that has been investigated by Schnorr [24, 25], van Lambalgen <ref> [28] </ref>, Lutz [18], Wang [29], and others correspond closely to the relationships among strong depth, weak depth and algorithmic randomness. This paper is largely self-contained. It can be read independently of [4, 10], but we assume that [10] is at hand for reference. <p> Then rec 1 [ 1 " 1 [ S 1 [d k;n ] = 0: Recursive randomness has been investigated by Schnorr [24, 25], van Lambalgen <ref> [28] </ref>, Lutz [18], Wang [29], and others. A sequence S 2 C is rec-random (recursively random), and we write S 2 RAND (rec), if there is no rec-martingale that succeeds on S. The following easy consequence of Theorem 2.2 is also used in section 3.3. Corollary 2.3 (Lutz [18]). <p> The following lemma gives a convenient sufficient condition for rec-randomness. It follows immediately from the definition of rec-randomness, the recursive equivalence of martingale success and strong martingale success <ref> [28] </ref>, and the Exact Computation Lemma [11, 20]. Lemma 2.4. Let S 2 C.
Reference: [29] <author> Y. Wang. </author> <title> Randomness and Complexity. </title> <type> PhD thesis, </type> <institution> Department of Mathematics, University of Heidelberg, </institution> <year> 1996. </year> <month> 41 </month>
Reference-contexts: Fifth, and perhaps most compelling, we show that the relationships among rec-strong depth, the notion of rec-weak depth introduced by Fenner, Lutz and May-ordomo [6], and the notion of rec-randomness that has been investigated by Schnorr [24, 25], van Lambalgen [28], Lutz [18], Wang <ref> [29] </ref>, and others correspond closely to the relationships among strong depth, weak depth and algorithmic randomness. This paper is largely self-contained. It can be read independently of [4, 10], but we assume that [10] is at hand for reference. <p> Then rec 1 [ 1 " 1 [ S 1 [d k;n ] = 0: Recursive randomness has been investigated by Schnorr [24, 25], van Lambalgen [28], Lutz [18], Wang <ref> [29] </ref>, and others. A sequence S 2 C is rec-random (recursively random), and we write S 2 RAND (rec), if there is no rec-martingale that succeeds on S. The following easy consequence of Theorem 2.2 is also used in section 3.3. Corollary 2.3 (Lutz [18]). <p> We now show that a rec-random sequence can be ultracompressible. Similar results have been proven by Wang <ref> [29] </ref> and Ambos-Spies and Wang [1] for the monotone Kolmogorov complexities of rec-random sequences. The present result is slightly stronger than these results in that it gives a single rec-random sequence S that has property (3.1) for every computable, nondecreasing, unbounded function g.
Reference: [30] <author> A. K. Zvonkin and L. A. Levin. </author> <title> The complexity of finite objects and the devel-opment of the concepts of information and randomness by means of the theory of algorithms. </title> <journal> Russian Mathematical Surveys, </journal> <volume> 25 </volume> <pages> 83-124, </pages> <year> 1970. </year> <month> 42 </month>
Reference-contexts: There is a constant c 2 N such that, for all n; k 2 N , fi fi x 2 f0; 1g n fi o fi fi &lt; 2 n+ck : We also use the following result on the noncomputability of K (n). Theorem 2.6 (Kolmogorov, reported in <ref> [30] </ref>). If g : N ! N is partial recursive and unbounded, then there exist infinitely many n 2 N such that K (n) &lt; g (n). Randomness is characterized in terms of Kolmogorov complexity as follows. Theorem 2.7 (Levin [13, 14], Schnorr [26]).
References-found: 30

