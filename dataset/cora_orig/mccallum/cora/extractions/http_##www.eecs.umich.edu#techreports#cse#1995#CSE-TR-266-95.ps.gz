URL: http://www.eecs.umich.edu/techreports/cse/1995/CSE-TR-266-95.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse95.html
Root-URL: http://www.eecs.umich.edu
Email: alexe,davidson@eecs.umich.edu  
Phone: (313) 936-2917  
Title: A Reduced Multipipeline Machine Description that Preserves Scheduling Constraints  
Author: Alexandre E. Eichenberger and Edward S. Davidson 
Address: 1301 Beal Ave, Ann Arbor, MI 48109-2122  
Affiliation: Advanced Computer Architecture Laboratory EECS Department, University of Michigan  
Abstract: High performance compilers increasingly rely on accurate modeling of the machine resources to efficiently exploit the instruction level parallelism of an application. In this paper, we propose a reduced machine description that results in faster detection of resource contentions while preserving the scheduling constraints present in the original machine description. The proposed approach reduces a machine description in an automated, error-free, and efficient fashion. Moreover, it fully supports schedulers that backtrack and process operations in arbitrary order. Reduced descriptions for the DEC Alpha 21064, MIPS R3000/R3010, and Cydra 5 result in 4 to 7 times faster detection of resource contentions and require 22 to 90% of the memory storage used by the original machine descriptions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. C. Dehnert and R. A. Towle. </author> <title> Compiling for the Cydra 5. </title> <journal> In The Journal of Supercomputing, </journal> <volume> volume 7, </volume> <pages> pages 181-227, </pages> <year> 1993. </year>
Reference-contexts: Unrestricted scheduling is essential to accommodate the elaborate scheduling techniques used by today's high performance compilers. The Cydra 5 compiler, for example, uses an operation-driven scheduler that reduces the schedule length of a basic block by scheduling operations along the critical path first <ref> [1] </ref>. Operation-driven schedulers consider operations in topological order, not in order of monotonically increasing (or decreasing) schedule time. Also, both the Cydra 5 and the IMPACT compilers use software pipelining techniques to achieve loop schedules with high throughput [1][2]. <p> The machine configuration investigated has 7 functional units: 2 memory port units, 2 address generation units, 1 FP adder unit, 1 FP multiplier unit, and 1 branch unit. The original machine description used by the Cydra 5 Fortran77 compiler models 56 resources and 152 distinct patterns of resource usages <ref> [1] </ref>. Note that the original machine description was already manually optimized, i.e. some of the physical resources of the Cydra 5 were eliminated from the machine description as they did not introduce any new forbidden latencies [24]. <p> Table 1 presents data for 4 reduced machine descriptions of the Cydra 5 machine and the original description used by the Cydra 5 Fortran77 compiler <ref> [1] </ref>. The second column corresponds to a reduced discrete-representation machine description that attempts to minimize min-uses. The three remaining columns correspond to reduced bitvector-representation machine descriptions that attempts to minimize min-k-cycles and maximize min-uses. Underlined numbers correspond to the entries minimized by the respective objective 10 functions.
Reference: [2] <author> N. J. Warter, G. E. Haab, and J. W. Bockhaus. </author> <title> Enhanced Modulo Scheduling for loops with conditional branches. </title> <booktitle> Proceedings of the 25th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 170-179, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Each entry contains a flag indicating whether the corresponding resource has been reserved by an operation in the current partial schedule. Entries may contain additional fields, such as the predicate under which a resource is reserved, as proposed in the Enhanced Modulo Scheduling scheme <ref> [2] </ref>. The contention query module checks whether operation X can be scheduled in cycle j by checking each usage in the reduced reservation table for X (offset by j) against the corresponding entry in the reserved table.
Reference: [3] <author> B. R. Rau. </author> <title> Iterative Modulo Scheduling: An algorithm for software pipelining loops. </title> <booktitle> Proceedings of the 27th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 63-74, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Moreover, experimental results indicate that software pipelined loops can achieve higher throughput in less compilation time when some limited number of scheduling decisions can be reversed, as shown by Rau <ref> [3] </ref>, and used in numerous compilers [1][2][3][4][18]. The Multifow compiler also uses a backtracking mechanism to improve scalar code schedules [7]. The proposed approach also precisely handles basic block boundary conditions, i.e. the dangling resource requirements from predecessor basic blocks.
Reference: [4] <author> R. A. Huff. </author> <title> Lifetime-sensitive modulo scheduling. </title> <booktitle> Proceedings of the ACM SIGPLAN'93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 258-267, </pages> <month> June </month> <year> 1993. </year>
Reference: [5] <author> J. R. Goodman and W.-C. Hsu. </author> <title> Code scheduling and register allocation in large basic blocs. </title> <booktitle> Proceedings of the International Conference on Supercomputing, </booktitle> <pages> pages 442-452, </pages> <year> 1988. </year>
Reference: [6] <author> K. Ebcioglu, R. D. Groves, K.-C. Kim, G. M. Silberman, and I. Ziv. </author> <title> Vliw compilation techniques in a superscalar environment. </title> <booktitle> In Proceedings of the ACM SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 36-48. </pages> <year> 1994. </year>
Reference: [7] <author> G. P. Lowney et al. </author> <title> The multiflow trace scheduling compiler. </title> <journal> In The Journal of Supercomputing, </journal> <volume> volume 7, </volume> <pages> pages 51-142, </pages> <year> 1993. </year>
Reference-contexts: The Multifow compiler also uses a backtracking mechanism to improve scalar code schedules <ref> [7] </ref>. The proposed approach also precisely handles basic block boundary conditions, i.e. the dangling resource requirements from predecessor basic blocks. In general, the resource requirements at the beginning of a basic block consists of the union of all the resource requirements dangling from predecessor basic blocks.
Reference: [8] <author> P. P. Chang, N. J. Warter, S. A. Mahlke, W. Y. Chen, and W. W. Hwu. </author> <title> Three architectural models for compiler-controlled speculative execution. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 44(4) </volume> <pages> 481-494, </pages> <month> April </month> <year> 1995. </year>
Reference: [9] <author> D. Bernstein and M. Rodeh. </author> <title> Global instruction scheduling for superscalar machines. </title> <booktitle> In Proceedings of the ACM SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 241-255, </pages> <month> June </month> <year> 1991. </year>
Reference: [10] <author> S.-M. Moon and K. Ebcioglu. </author> <title> An efficient resource-constrained global scheduling technique for superscalar and vliw processors. </title> <booktitle> Proceedings of the 25th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 55-71, </pages> <month> September </month> <year> 1992. </year>
Reference: [11] <author> P. P. Chang, S. A. Mahlke, W. Y. Chen, N. J. Warter, and W. W. Hwu. </author> <title> Impact: An architectural framework for multiple-instruction-issue processors. </title> <booktitle> In Proceedings of the Eighteenth Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 266-275, </pages> <month> May </month> <year> 1991. </year>
Reference: [12] <author> J. C. Gyllenhaal. </author> <title> A machine description language for compilation. </title> <type> Master's thesis, </type> <institution> Department of Electrical and Computer Engineering, University of Illinois, Urbana, IL, </institution> <year> 1994. </year>
Reference-contexts: in this cycle without resource contention?" Typically, this functionality has been provided by a contention query module that processes the machine description of a target machine, generates an internal representation of the resource requirements, and provides for a querying mechanism [1][3][7][11]<ref> [12] </ref>[13]. The IMPACT compiler, for example, implemented such a module [12] to produce high performance schedules for a wide range of machines, from existing architectures such as X86, PA-RISC, and Sparc to research architectures such as PlayDoh [14].
Reference: [13] <author> J. A. Fisher. </author> <title> Trace scheduling: a technique for global microcode compaction. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 30(7) </volume> <pages> 478-490, </pages> <month> July </month> <year> 1981. </year>
Reference: [14] <author> V. Kathail, M. S. Schlansker, and B. R. Rau. </author> <title> HPL PlayDoh architecture specification: Version 1.0. </title> <type> Technical Report HPL-93-80, </type> <institution> HP Laboratories, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: The IMPACT compiler, for example, implemented such a module [12] to produce high performance schedules for a wide range of machines, from existing architectures such as X86, PA-RISC, and Sparc to research architectures such as PlayDoh <ref> [14] </ref>. With the recent emphasis on exploiting instruction level parallelism, compile time is increasingly spent in the contention query module as several cycles of a schedule, possibly in several basic blocks [9][10], are queried per operation in order to achieve good schedules.
Reference: [15] <author> T. A. Proebsting and C. W. Fraser. </author> <title> Detecting pipeline structural hazards quickly. </title> <booktitle> Twenty-First Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 280-286, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: As a result, recent advances favor finite-state automata approaches. In this paper, however, we propose a reduced reservation table approach that eliminates much of the redundancy and does not suffer from the weaknesses of the automata approaches, as detailed below. Proebsting and Frazer <ref> [15] </ref> as well as Muller [16] proposed a contention query module using a finite state automaton that recognizes all contention-free schedules. This approach was recently extended for unrestricted scheduling models by Bala and Rubin using a forward and reverse pair of automata [17]. <p> This issue is addressed in the literature in three ways. First, operations of a target machine 3 can be combined into classes of operations that have compatible resource contentions <ref> [15] </ref>. Second, large automata can be factored into sets of smaller ones [16][17], reducing the size of the automata, but increasing the number of table lookups necessary to process a contention query. <p> Figure 1b illustrates this matrix computed for our example machine. While these sets are computed for each operation of the target machine, we need list these sets only for each operation class, as presented by Proebsting and Fraser <ref> [15] </ref>, where two operations belong to the same operation class if they have compatible 1 sets of forbidden latencies. Note two properties of the forbidden latency matrix. <p> The Cydra 5 machine description results in 52 distinct operation types and 10223 forbidden latencies. Compared to the most complex machine description handled in papers on finite state automaton <ref> [15] </ref>, the Cydra 5 has 3.5 times more operation types and 2.4 times more forbidden latencies. For each internal representation, our algorithm reduces the Cydra 5 machine description in less than 11 minutes on a Sparc-20. <p> Table 3 shows the results of our technique for the MIPS R3000/R3010 [20], using the machine description in Proebsting and Frazer <ref> [15] </ref>. Comparing the original description to the 64 bit word bitvector representation, the reduced machine description decreases the average number of words to test by a factor of 6.9 (from 11.0 to 1.6 words). <p> Proebsting and Frazer reported for this processor a finite state automaton of 6175 states, an automaton that does not handle the boundary conditions <ref> [15] </ref>.
Reference: [16] <author> T. Muller. </author> <title> Employing finite automata for resource scheduling. </title> <booktitle> Proceedings of the 26th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 12-20, </pages> <year> 1993. </year>
Reference-contexts: As a result, recent advances favor finite-state automata approaches. In this paper, however, we propose a reduced reservation table approach that eliminates much of the redundancy and does not suffer from the weaknesses of the automata approaches, as detailed below. Proebsting and Frazer [15] as well as Muller <ref> [16] </ref> proposed a contention query module using a finite state automaton that recognizes all contention-free schedules. This approach was recently extended for unrestricted scheduling models by Bala and Rubin using a forward and reverse pair of automata [17].
Reference: [17] <author> V. Bala and N. Rubin. </author> <title> Efficient instruction scheduling using finite state automata. </title> <booktitle> To appear in the Proceedings of the 28th Annual International Symposium on Microarchitecture, </booktitle> <month> November </month> <year> 1995. </year>
Reference-contexts: Proebsting and Frazer [15] as well as Muller [16] proposed a contention query module using a finite state automaton that recognizes all contention-free schedules. This approach was recently extended for unrestricted scheduling models by Bala and Rubin using a forward and reverse pair of automata <ref> [17] </ref>. In their approach, operations considered in order of monotonically increasing (or decreasing) schedule time are quickly scheduled using a forward automaton. Additional operations are then inserted in the schedule in cycles recognized as contention-free by the forward and reverse automata. <p> Their approach also addresses the handling of basic block boundary conditions at the cost of introducing up to O (s 2 ) new states in the automata, where s is the number of cycle-advancing states in the original automata <ref> [17] </ref>. The principal advantage of automaton-based approaches is that the next contention-free cycle can be determined in a single table lookup. <p> Second, large automata can be factored into sets of smaller ones [16]<ref> [17] </ref>, reducing the size of the automata, but increasing the number of table lookups necessary to process a contention query. Third, the number of additional states introduced in the automata to handle boundary conditions can be reduced [17], at the cost of making conservative approximations, potentially resulting in schedules with lower performance. Another problem arises when supporting unrestricted scheduling models, as the state of the forward and reverse automaton must be saved after each scheduled operation. <p> Another problem arises when supporting unrestricted scheduling models, as the state of the forward and reverse automaton must be saved after each scheduled operation. As a result, two states per operation must be stored in addition to the two automata <ref> [17] </ref>, which may result in a large memory overhead per cycle of the schedule, especially for wide-issue machines. Supporting unrestricted scheduling models also requires the consistency of the stored state to be maintained when scheduling additional operations [17], as inserted operations introduce additional resource requirements. <p> two states per operation must be stored in addition to the two automata <ref> [17] </ref>, which may result in a large memory overhead per cycle of the schedule, especially for wide-issue machines. Supporting unrestricted scheduling models also requires the consistency of the stored state to be maintained when scheduling additional operations [17], as inserted operations introduce additional resource requirements. <p> Table 2 shows the results of our technique for the DEC Alpha 21064 [19], using the machine description in Bala and Rubin <ref> [17] </ref>. Comparing the original description to the 64 bit word bitvector representation, the reduced machine description decreases the average number of words to test by a factor of 5.8 (from 11.6 to 2.0 words). <p> Bala and Rubin presented a factored finite state automaton for this processor with 469 states ignoring boundary conditions and with 3666 states when boundary conditions with forbidden latencies dangling by up to 7 cycles are precisely modeled and approximated otherwise (between 8 and 58 cycles) <ref> [17] </ref>. Encoding the 3666 states in 12 bits, the state automata requires 4x12 bits of memory per schedule cycle, when caching the states of the forward and reverse automata for this dual issue microprocessor, compared to 7 bits per schedule cycle for bitvector representation.
Reference: [18] <author> M. Lam. </author> <title> Software pipelining: An effective scheduling technique for VLIW machines. </title> <booktitle> Proceedings of the ACM SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 318-328, </pages> <month> June </month> <year> 1988. </year>
Reference: [19] <institution> Digital Equipment Corp., Maynard, </institution> <address> MA. </address> <note> DecChip 21064 Microprocessor Hardware Reference Manual EC-N0079-72. </note>
Reference-contexts: Using our approach, the resource requirements can be expressed in terms close to the actual hardware structure of the target machine and the reduced machine description used by the compiler is generated in an error-free and automated fashion. Experiments with the DEC Alpha 21064 <ref> [19] </ref>, the MIPS R3000/R3010 [20], the and Cydra 5 [21] machines indicate 4 to 7 times faster contention queries and require 22 to 90% of the memory storage used by the original machine descriptions. <p> Table 2 shows the results of our technique for the DEC Alpha 21064 <ref> [19] </ref>, using the machine description in Bala and Rubin [17]. Comparing the original description to the 64 bit word bitvector representation, the reduced machine description decreases the average number of words to test by a factor of 5.8 (from 11.6 to 2.0 words).
Reference: [20] <author> G. Kane and J. Heinrich. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Using our approach, the resource requirements can be expressed in terms close to the actual hardware structure of the target machine and the reduced machine description used by the compiler is generated in an error-free and automated fashion. Experiments with the DEC Alpha 21064 [19], the MIPS R3000/R3010 <ref> [20] </ref>, the and Cydra 5 [21] machines indicate 4 to 7 times faster contention queries and require 22 to 90% of the memory storage used by the original machine descriptions. These improvements are obtained by using highly reduced machine descriptions instead of the original or manually optimized machine descriptions. <p> Table 3 shows the results of our technique for the MIPS R3000/R3010 <ref> [20] </ref>, using the machine description in Proebsting and Frazer [15]. Comparing the original description to the 64 bit word bitvector representation, the reduced machine description decreases the average number of words to test by a factor of 6.9 (from 11.0 to 1.6 words).
Reference: [21] <author> G. R. Beck, D. W. L. Yen, and T. L. Anderson. </author> <title> The Cydra 5 mini-supercomputer: Architecture and implementation. </title> <journal> In The Journal of Supercomputing, </journal> <volume> volume 7, </volume> <pages> pages 143-180, </pages> <year> 1993. </year>
Reference-contexts: Experiments with the DEC Alpha 21064 [19], the MIPS R3000/R3010 [20], the and Cydra 5 <ref> [21] </ref> machines indicate 4 to 7 times faster contention queries and require 22 to 90% of the memory storage used by the original machine descriptions. These improvements are obtained by using highly reduced machine descriptions instead of the original or manually optimized machine descriptions. <p> This number, referred to as word usages, is averaged over all operation types and possible alignments. As a proof of concept, we investigated our technique on the Cydra 5 machine <ref> [21] </ref> which has the most complex resource requirements of the three machines. The machine configuration investigated has 7 functional units: 2 memory port units, 2 address generation units, 1 FP adder unit, 1 FP multiplier unit, and 1 branch unit.
Reference: [22] <author> E. S. Davidson, L. E. Shar, A. T. Thomas, and J. H. Patel. </author> <title> Effective control for pipelined computers. </title> <booktitle> Spring COMPCON-75 digest of papers, </booktitle> <pages> pages 181-184, </pages> <month> February </month> <year> 1975. </year>
Reference-contexts: Reduced machine and benchmark examples are presented in Section 6 and conclusions in Section 7. 2 Related Work Resource contention in multipipeline scheduling may be based directly on reservation tables, or on the forbidden latency sets or contention-recognizing state machines derived from them, as introduced by Davidson et al <ref> [22] </ref>. Traditionally, reservation tables contain much redundant information that consumes memory and increases query response time. As a result, recent advances favor finite-state automata approaches.
Reference: [23] <author> J. H. Patel and E. S. Davidson. </author> <title> Improving the throughput of a pipeline by insertion of delays. </title> <booktitle> Proceedings of the Third Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 159-164, </pages> <year> 1976. </year>
Reference-contexts: Querying for resource contentions using either the original or reduced machine descriptions yields the same answer, as both descriptions enforces the same forbidden latencies. Step 2: We build the generating set of maximal resources which contains all maximal resources associated with the target machine <ref> [23] </ref>.
Reference: [24] <author> M. S. Schlansker. </author> <type> Personal communication. </type> <month> June </month> <year> 1995. </year>
Reference-contexts: Note that the original machine description was already manually optimized, i.e. some of the physical resources of the Cydra 5 were eliminated from the machine description as they did not introduce any new forbidden latencies <ref> [24] </ref>. The Cydra 5 machine description results in 52 distinct operation types and 10223 forbidden latencies. Compared to the most complex machine description handled in papers on finite state automaton [15], the Cydra 5 has 3.5 times more operation types and 2.4 times more forbidden latencies.
Reference: [25] <author> A. E. Eichenberger, E. S. Davidson, and S. G. Abraham. </author> <title> Optimum modulo schedules for minimum register requirements. </title> <booktitle> Proceedings of the International Conference on Supercomputing, </booktitle> <pages> pages 31-40, </pages> <month> July </month> <year> 1995. </year>

References-found: 25

