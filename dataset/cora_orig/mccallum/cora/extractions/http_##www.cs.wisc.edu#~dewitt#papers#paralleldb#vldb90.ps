URL: http://www.cs.wisc.edu/~dewitt/papers/paralleldb/vldb90.ps
Refering-URL: http://www.cs.wisc.edu/~dewitt/paralleldb.html
Root-URL: 
Title: Tradeoffs in Processing Multi-Way Join Queries via Hashing in Multiprocessor Database Machines  
Author: Donovan A. Schneider David J. DeWitt 
Note: This research was partially supported by the Defense Advanced Research Projects Agency under contract N00039-86-C-0578, by the National Science Foundation under grant DCR-8512862, by a Digital Equipment Corporation External Research Grant, and by a research grant from the Tandem Computer Corporation. Funding was also provided by a DARPA/NASA sponsored Graduate Research Assistantship in Parallel Processing.  
Address: Wisconsin  
Affiliation: Computer Sciences Department University of  
Abstract-found: 0
Intro-found: 1
Reference: [BARU87] <author> Baru, C., O. Frieder, D. Kandlur, and M. Segal, </author> <title> Join on a Cube: Analysis, Simulation, and Implementation, Database Machines and Knowledge Base Machines, </title> <editor> M. Kitsuregawa and H. Tanaka (eds), </editor> <publisher> Kluwer Academic Publishers, </publisher> <year> 1987. </year>
Reference-contexts: Because the join operator is critical to the operation of any relational DBMS, a number of papers have addressed parallel implementations of the join operation including <ref> [BARU87, BRAT87, DEWI85, DEWI88, KITS88, LU85, SCHN89a] </ref>. However, these papers have not addressed the processing of queries with more than one or two joins. Also, the performance impact of alternative formats for representing multi-way join queries has received little attention in the context of this new environment.
Reference: [BITT83] <author> Bitton, D., D.J. DeWitt, and C. Turbyfill, </author> <title> Benchmarking Database Systems A Systematic Approach, </title> <booktitle> Proceedings of the 1983 Very Large Database Conference, </booktitle> <month> October, </month> <year> 1983. </year>
Reference-contexts: To validate the simulation model we present the performance of both a 10% selection query and a join query in a system with 1-30 processors with disks. Expanded versions of the Wisconsin Benchmark relations <ref> [BITT83] </ref> serve as the test database. The selection query retrieves 100,000 tuples from a 1,000,000 tuple relation and stores the resulting tuples back into the database. As shown in Figure 11, the simulation model matches with observed Gamma performance very closely for this query.
Reference: [BRAT87] <author> Bratbergsengen, Kjell, </author> <title> Algebra Operations on a Parallel Computer Performance Evaluation, Database Machines and Knowledge Base Machines, </title> <editor> M. Kitsuregawa and H. Tanaka (eds), </editor> <publisher> Kluwer Academic Publishers, </publisher> <year> 1987. </year>
Reference-contexts: Because the join operator is critical to the operation of any relational DBMS, a number of papers have addressed parallel implementations of the join operation including <ref> [BARU87, BRAT87, DEWI85, DEWI88, KITS88, LU85, SCHN89a] </ref>. However, these papers have not addressed the processing of queries with more than one or two joins. Also, the performance impact of alternative formats for representing multi-way join queries has received little attention in the context of this new environment. <p> In this paper we examine the tradeoffs imposed by left-deep, right-deep and bushy query trees in a multiprocessor environment. We focussed on hash-based join methods because their performance has been demonstrated bo be superior in systems with large memories <ref> [BRAT87, DEWI84, SCHN89a, SHAP86] </ref>, although we include a brief discussion of the sort-merge join algorithm. The tradeoffs we consider include the potential for exploiting intra-query parallelism (and its corresponding effect on performance), resource consumption (primarily memory), support for dataflow processing, and the cost of optimization.
Reference: [COPE88] <author> Copeland, G., W. Alexander, E. Boughter, and T. Keller, </author> <title> "Data Placement in Bubba", </title> <booktitle> Proceedings of the 1988 SIGMOD Conference, </booktitle> <address> Chicago, IL, </address> <month> June </month> <year> 1988. </year> <month> 29 </month>
Reference-contexts: However, in a large database machine, it is not likely that relations will be declustered over all available storage sites <ref> [COPE88] </ref>. Further declustering eventually becomes detrimental to performance because the costs of controlling the execution of a query eventually outweigh the benefits of adding additional disk resources [GERB87, COPE88, DEWI88]. In Section 4 we present experimental results which illustrate the performance implications of the data declustering strategy. <p> However, in a large database machine, it is not likely that relations will be declustered over all available storage sites [COPE88]. Further declustering eventually becomes detrimental to performance because the costs of controlling the execution of a query eventually outweigh the benefits of adding additional disk resources <ref> [GERB87, COPE88, DEWI88] </ref>. In Section 4 we present experimental results which illustrate the performance implications of the data declustering strategy. <p> Low Resource Contention Environment In this next set of experiments we wanted to demonstrate the performance tradeoffs between the two query representation strategies in a configuration with more processors. In such a machine, it is likely that relations will be declustered over a subset of nodes <ref> [GERB87, COPE88] </ref> and hence, resource contention will be reduced when executing several operators concurrently. The system was configured in the following manner. Each of the nine 1,000,000 tuple relations was declustered over 10 distinct, non-overlapping nodes. Each join was also processed at 10 nodes.
Reference: [DEWI84] <author> DeWitt, D. J., Katz, R., Olken, F., Shapiro, L., Stonebraker, M. and D. Wood, </author> <title> Implementation Techniques for Main Memory Database Systems, </title> <booktitle> Proceedings of the 1984 SIGMOD Conference, </booktitle> <address> Boston, MA, </address> <month> June, </month> <year> 1984. </year>
Reference-contexts: In this paper we examine the tradeoffs imposed by left-deep, right-deep and bushy query trees in a multiprocessor environment. We focussed on hash-based join methods because their performance has been demonstrated bo be superior in systems with large memories <ref> [BRAT87, DEWI84, SCHN89a, SHAP86] </ref>, although we include a brief discussion of the sort-merge join algorithm. The tradeoffs we consider include the potential for exploiting intra-query parallelism (and its corresponding effect on performance), resource consumption (primarily memory), support for dataflow processing, and the cost of optimization. <p> This improves performance by simplifying scheduling and eliminating the need to store temporary results. Also, different formats dictate different maximum memory requirements. This is important because the performance of several of the join algorithms depends heavily on the amount of available memory <ref> [DEWI84, SCHN89a, SHAP86] </ref>. Finally, the format of the query plan is one determinant of the amount of parallelism that can be applied to the query. Left-deep trees and right-deep trees represent the two extreme options of restricted format query trees. <p> If insufficient memory is available, three techniques can be used to reduce memory requirements. First, a fragment can be decomposed into sequential fragments. This requires the spooling of data to temporary files. If further decomposition is not possible, the number of batches used for the Hybrid join algorithm <ref> [DEWI84] </ref> can be increased. Finally, the level of parallelism applied to the fragment can be reduced. 3. <p> In this paper, we consider two different hash-join methods, Simple hash-join and Hybrid hash-join <ref> [DEWI84] </ref>. It is assumed that the reader is familiar with these join methods although a brief description of them is included here. For this description, consider the join of relations R and S, where R is the smaller joining relation. <p> This was accomplished by making all relations the same size and by setting the join "probe-ability" factor to 1 for every join in the query tree. That is, each probing tuple joins with exactly one building tuple. A parallel version of the Simple hash-join algorithm <ref> [DEWI84, SCHN89a] </ref> was used as the join method and, unless otherwise stated, it was assumed that enough main memory exists such that hash table overflow never occurs, regardless of the number of concurrent join operations.
Reference: [DEWI85] <author> DeWitt, D., and R. Gerber, </author> <title> Multiprocessor Hash-Based Join Algorithms, </title> <booktitle> Proceedings of the 1985 VLDB Conference, </booktitle> <address> Stockholm, Sweden, </address> <month> August, </month> <year> 1985. </year>
Reference-contexts: Because the join operator is critical to the operation of any relational DBMS, a number of papers have addressed parallel implementations of the join operation including <ref> [BARU87, BRAT87, DEWI85, DEWI88, KITS88, LU85, SCHN89a] </ref>. However, these papers have not addressed the processing of queries with more than one or two joins. Also, the performance impact of alternative formats for representing multi-way join queries has received little attention in the context of this new environment.
Reference: [DEWI86] <author> DeWitt, D., Gerber, B., Graefe, G., Heytens, M., Kumar, K. and M. Muralikrishna, </author> <title> GAMMA A High Performance Dataflow Database Machine, </title> <booktitle> Proceedings of the 1986 VLDB Conference, </booktitle> <address> Japan, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: Rather, the analysis will serve 20 to show the feasibility of the strategies proposed for processing multi-way join queries. As the experimental vehicle for our analysis we chose the shared-nothing database machine Gamma <ref> [DEWI86, DEWI90] </ref>. Gamma currently runs on a 32 processor iPSC/2 Intel hypercube [INTE88] with one 330 megabyte MAXTOR 4380 (5 1/4") disk directly attached to each Intel 80386 processor. One deficiency of the iPSC/2's I/O system is that it does not provide DMA support for disk transfers.
Reference: [DEWI88] <author> DeWitt, D., Ghandeharizadeh, S., and D. Schneider, </author> <title> A Performance Analysis of the Gamma Database Machine, </title> <booktitle> Proceedings of the 1988 SIGMOD Conference, </booktitle> <address> Chicago, IL, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: Because the join operator is critical to the operation of any relational DBMS, a number of papers have addressed parallel implementations of the join operation including <ref> [BARU87, BRAT87, DEWI85, DEWI88, KITS88, LU85, SCHN89a] </ref>. However, these papers have not addressed the processing of queries with more than one or two joins. Also, the performance impact of alternative formats for representing multi-way join queries has received little attention in the context of this new environment. <p> However, in a large database machine, it is not likely that relations will be declustered over all available storage sites [COPE88]. Further declustering eventually becomes detrimental to performance because the costs of controlling the execution of a query eventually outweigh the benefits of adding additional disk resources <ref> [GERB87, COPE88, DEWI88] </ref>. In Section 4 we present experimental results which illustrate the performance implications of the data declustering strategy.
Reference: [DEWI90] <author> DeWitt, D., Ghandeharizadeh, S., Schneider, D., Bricker, A., Hsiao, H., and R. Rasmussen, </author> <title> The Gamma Database Machine Project, </title> <journal> to appear IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March, </month> <year> 1990. </year>
Reference-contexts: Rather, the analysis will serve 20 to show the feasibility of the strategies proposed for processing multi-way join queries. As the experimental vehicle for our analysis we chose the shared-nothing database machine Gamma <ref> [DEWI86, DEWI90] </ref>. Gamma currently runs on a 32 processor iPSC/2 Intel hypercube [INTE88] with one 330 megabyte MAXTOR 4380 (5 1/4") disk directly attached to each Intel 80386 processor. One deficiency of the iPSC/2's I/O system is that it does not provide DMA support for disk transfers.
Reference: [GERB86] <author> Gerber, R., </author> <title> Dataflow Query Processing using Multiprocessor Hash-Partitioned Algorithms, </title> <type> PhD Thesis and Computer Sciences Technical Report #672, </type> <institution> University of Wisconsin-Madison, </institution> <month> October, </month> <year> 1986. </year>
Reference-contexts: Second, we assume the existence of sufficient main-memory to support as many concurrent join operations as required. We also assume that the optimizer has perfect knowledge of scan and join selectivities. In later portions of this paper we relax these assumptions. 2. Survey of Related Work <ref> [GERB86] </ref> describes many of the issues involved in processing hash-based join operations in multiprocessor database machines. Both inter-operator and intra-operator concurrency issues are discussed. <p> Both inter-operator and intra-operator concurrency issues are discussed. In the discussion of intra-query/inter-operator parallelism, the tradeoffs of left-deep, right-deep and bushy query tree representations with regard to parallelism, pipelined data flow, and resource utilization (primarily memory) are addressed. However, while <ref> [GERB86] </ref> defines the basic issues involved in processing complex queries in a multiprocessor environment, it does not explore the tradeoffs between the alternative query tree representation strategies in great depth.
Reference: [GERB87] <author> Gerber, R. and D. DeWitt, </author> <title> The Impact of Hardware and Software Alternatives on the Performance of the Gamma Database Machine, </title> <type> Computer Sciences Technical Report #708, </type> <institution> University of Wisconsin-Madison, </institution> <month> July, </month> <year> 1987. </year>
Reference-contexts: However, in a large database machine, it is not likely that relations will be declustered over all available storage sites [COPE88]. Further declustering eventually becomes detrimental to performance because the costs of controlling the execution of a query eventually outweigh the benefits of adding additional disk resources <ref> [GERB87, COPE88, DEWI88] </ref>. In Section 4 we present experimental results which illustrate the performance implications of the data declustering strategy. <p> Low Resource Contention Environment In this next set of experiments we wanted to demonstrate the performance tradeoffs between the two query representation strategies in a configuration with more processors. In such a machine, it is likely that relations will be declustered over a subset of nodes <ref> [GERB87, COPE88] </ref> and hence, resource contention will be reduced when executing several operators concurrently. The system was configured in the following manner. Each of the nine 1,000,000 tuple relations was declustered over 10 distinct, non-overlapping nodes. Each join was also processed at 10 nodes.
Reference: [GHAN90] <author> Ghandeharizadeh, S., and D.J. DeWitt, </author> <title> A Multiuser Performance Analysis of Alternative Declustering Strategies, </title> <booktitle> Proceedings of the 6th International Conference on Data Engineering, </booktitle> <year> 1990. </year>
Reference: [GRAE87] <author> Graefe, G., </author> <title> Rule-Based Query Optimization in Extensible Database Systems, </title> <type> Ph.D. </type> <institution> Thesis and Computer Sciences Technical Report #724, University of Wisconsin-Madison, </institution> <month> November, </month> <year> 1987. </year>
Reference-contexts: Although [GRAE89a] also supports the three alternative query tree formats in the shared-memory database machine 4 Volcano, the tradeoffs are not discussed in detail. In this paper we will demonstrate that several interesting algorithms can be developed for scheduling query trees under the alternative tree formats. <ref> [GRAE87] </ref> considers some of the tradeoffs between left-deep and bushy execution trees in a single processor environment. Analytic cost functions for hash-join, index join, nested loops join, and sort-merge join are developed and used to compare the average plan execution costs for the different query tree formats.
Reference: [GRAE89a] <author> Graefe, G., Volcano: </author> <title> A Compact, Extensible, Dynamic, and Parallel Dataflow Query Evaluation System, </title> <type> Working Paper, </type> <institution> Oregon Graduate Center, </institution> <address> Portland, OR, </address> <month> February </month> <year> 1989. </year>
Reference-contexts: However, while [GERB86] defines the basic issues involved in processing complex queries in a multiprocessor environment, it does not explore the tradeoffs between the alternative query tree representation strategies in great depth. Although <ref> [GRAE89a] </ref> also supports the three alternative query tree formats in the shared-memory database machine 4 Volcano, the tradeoffs are not discussed in detail.
Reference: [GRAE89b] <author> Graefe, G. and K. Ward, </author> <title> Dynamic Query Evaluation Plans, </title> <booktitle> Proceedings of the 1989 SIGMOD Conference, </booktitle> <address> Portland, OR., </address> <month> May </month> <year> 1989. </year>
Reference-contexts: If memory is extremely scarce, sufficient memory may not exist to hold even one of these hash tables. Thus, even though only two join operators are active at any point in time, many issues must be addressed in order to achieve optimal performance. <ref> [GRAE89b] </ref> proposes a solution to this general problem by having the optimizer generate multiple query plans and then having the runtime system choose the plan most appropriate to the current system environment. A similar mechanism was proposed for Starburst [HAAS89]. <p> If memory is extremely scarce, sufficient memory may not exist to hold even one of these hash tables. Thus, even though only two join operators are active at any point in time, many issues must be addressed in order to achieve optimal performance. <ref> [GRAE89b] </ref> proposes a solution to this general problem by having the optimizer generate multiple query plans and then having the runtime system choose the plan most appropriate to the current system environment. A similar mechanism was proposed for Starburst [HAAS89].
Reference: [HAAS89] <author> Haas, L., Freytag, J.C., Lohman, G.M., and H. Pirahesh, </author> <title> Extensible Query Processing in Starburst, </title> <booktitle> Proceedings of the 1989 SIGMOD Conference, </booktitle> <address> Portland, OR., </address> <month> May </month> <year> 1989. </year> <title> [INTE88], Intel Corporation, iPSC/2 User's Guide, </title> <publisher> Intel Corporation Order No. </publisher> <pages> 311532-002, </pages> <month> March, </month> <year> 1988. </year>
Reference-contexts: A similar mechanism was proposed for Starburst <ref> [HAAS89] </ref>. One possible problem with this strategy is that the number of feasible plans may be quite large for the complex join queries we envision. Besides having to generate plans which incorporate the memory requirements of each individual join operator, an optimizer must recognize the consequences of intra-query parallelism. <p> A similar mechanism was proposed for Starburst <ref> [HAAS89] </ref>. One possible problem with this strategy is that the number of feasible plans may be quite large for the complex join queries we envision. Besides having to generate plans which incorporate the memory requirements of each individual join operator, an optimizer must recognize the consequences of intra-query parallelism.
Reference: [KITS88] <author> Kitsuregawa, M., Nakano, M., and M. Takagi, </author> <title> Query Execution for Large Relations On Functional Disk System, </title> <booktitle> Proceedings of the 5th International Conference on Data Engineering, </booktitle> <year> 1989. </year>
Reference-contexts: Because the join operator is critical to the operation of any relational DBMS, a number of papers have addressed parallel implementations of the join operation including <ref> [BARU87, BRAT87, DEWI85, DEWI88, KITS88, LU85, SCHN89a] </ref>. However, these papers have not addressed the processing of queries with more than one or two joins. Also, the performance impact of alternative formats for representing multi-way join queries has received little attention in the context of this new environment.
Reference: [LIPT90] <author> Lipton, R., J. Naughton, and D. Schneider, </author> <title> Practical Selectivity Estimation through Adaptive Sampling, </title> <booktitle> Proceedings of the 1990 SIGMOD Conference, </booktitle> <address> Atlantic City, New Jersey, </address> <month> May, </month> <year> 1990. </year>
Reference: [LIVN88] <author> Livny, M., </author> <note> DeNet User's Guide, Version 1.0, </note> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI, </institution> <year> 1988. </year>
Reference-contexts: Each node in the multiprocessor system consists of a Disk module, a CPU module, a Query Scheduler module, and multiple instances of an Operator module. Additionally, three stand-alone modules are provided: a Network module, a File Manager module, and a Terminal module. The DeNet simulation language <ref> [LIVN88] </ref> was used to construct the simulator. The Disk module schedules disk requests according to an elevator algorithm.
Reference: [LU85] <author> Lu, H. and M. Carey, </author> <title> Some Experimental Results on Distributed Join Algorithms in a Local Network, </title> <booktitle> Proceedings of the 1985 VLDB Conference, </booktitle> <address> Stockholm, Sweden, </address> <month> August, </month> <year> 1985. </year>
Reference-contexts: Because the join operator is critical to the operation of any relational DBMS, a number of papers have addressed parallel implementations of the join operation including <ref> [BARU87, BRAT87, DEWI85, DEWI88, KITS88, LU85, SCHN89a] </ref>. However, these papers have not addressed the processing of queries with more than one or two joins. Also, the performance impact of alternative formats for representing multi-way join queries has received little attention in the context of this new environment.
Reference: [SCHN89a] <author> Schneider, D. and D. DeWitt, </author> <title> A Performance Evaluation of Four Parallel Join Algorithms in a Shared-Nothing Multiprocessor Environment, </title> <booktitle> Proceedings of the 1989 SIGMOD Conference, </booktitle> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Because the join operator is critical to the operation of any relational DBMS, a number of papers have addressed parallel implementations of the join operation including <ref> [BARU87, BRAT87, DEWI85, DEWI88, KITS88, LU85, SCHN89a] </ref>. However, these papers have not addressed the processing of queries with more than one or two joins. Also, the performance impact of alternative formats for representing multi-way join queries has received little attention in the context of this new environment. <p> In this paper we examine the tradeoffs imposed by left-deep, right-deep and bushy query trees in a multiprocessor environment. We focussed on hash-based join methods because their performance has been demonstrated bo be superior in systems with large memories <ref> [BRAT87, DEWI84, SCHN89a, SHAP86] </ref>, although we include a brief discussion of the sort-merge join algorithm. The tradeoffs we consider include the potential for exploiting intra-query parallelism (and its corresponding effect on performance), resource consumption (primarily memory), support for dataflow processing, and the cost of optimization. <p> This improves performance by simplifying scheduling and eliminating the need to store temporary results. Also, different formats dictate different maximum memory requirements. This is important because the performance of several of the join algorithms depends heavily on the amount of available memory <ref> [DEWI84, SCHN89a, SHAP86] </ref>. Finally, the format of the query plan is one determinant of the amount of parallelism that can be applied to the query. Left-deep trees and right-deep trees represent the two extreme options of restricted format query trees. <p> The reader should keep in mind that intra-operator parallelism issues are being ignored in this paper. That is, when we discuss executing two operators concurrently, we have assumed implicitly that each operator will be computed using multiple processors. See <ref> [SCHN89a] </ref> for a description of parallel implementations of these hash-join algorithms. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 The smaller relation is always used as the building or inner relation in a hash join algorithm in order to minimize the number of times the outer relation must be read from disk. <p> This was accomplished by making all relations the same size and by setting the join "probe-ability" factor to 1 for every join in the query tree. That is, each probing tuple joins with exactly one building tuple. A parallel version of the Simple hash-join algorithm <ref> [DEWI84, SCHN89a] </ref> was used as the join method and, unless otherwise stated, it was assumed that enough main memory exists such that hash table overflow never occurs, regardless of the number of concurrent join operations.
Reference: [SCHN89b] <author> Schneider, D. and D. DeWitt, </author> <title> Design Tradeoffs of Alternative Query Tree Representations for Multiprocessor Database Machines, </title> <type> Computer Sciences Technical Report #869, </type> <institution> University of Wisconsin-Madison, </institution> <month> August, </month> <year> 1989. </year>
Reference-contexts: This is in contrast to the strictly serial execution of the two scans in order for a hash join algorithm to work properly. The modifications to the operator dependency graphs required to support the sort-merge join method can be found in <ref> [SCHN89b] </ref>. These modifications are very simple but are not presented here due to space limitations. <p> This is in contrast to the strictly serial execution of the two scans in order for a hash join algorithm to work properly. The modifications to the operator dependency graphs required to support the sort-merge join method can be found in <ref> [SCHN89b] </ref>. These modifications are very simple but are not presented here due to space limitations.
Reference: [SHAP86] <author> Shapiro, L., </author> <title> Join Processing in Database Systems with Large Main Memories, </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 11, No. 3, </volume> <month> September, </month> <year> 1986. </year>
Reference-contexts: In this paper we examine the tradeoffs imposed by left-deep, right-deep and bushy query trees in a multiprocessor environment. We focussed on hash-based join methods because their performance has been demonstrated bo be superior in systems with large memories <ref> [BRAT87, DEWI84, SCHN89a, SHAP86] </ref>, although we include a brief discussion of the sort-merge join algorithm. The tradeoffs we consider include the potential for exploiting intra-query parallelism (and its corresponding effect on performance), resource consumption (primarily memory), support for dataflow processing, and the cost of optimization. <p> This improves performance by simplifying scheduling and eliminating the need to store temporary results. Also, different formats dictate different maximum memory requirements. This is important because the performance of several of the join algorithms depends heavily on the amount of available memory <ref> [DEWI84, SCHN89a, SHAP86] </ref>. Finally, the format of the query plan is one determinant of the amount of parallelism that can be applied to the query. Left-deep trees and right-deep trees represent the two extreme options of restricted format query trees.
Reference: [STON89] <author> Stonebraker, M., P. Aoki, and M. Seltzer, </author> <note> Parallelism in XPRS, Memorandum No. UCB/ERL M89/16, February 1, </note> <year> 1989. </year>
Reference-contexts: However, when the queries contain 10 or more joins, execution costs for the left-deep trees can become up to an order of magnitude more expensive. <ref> [STON89] </ref> describes how the XPRS project plans on utilizing parallelism in a shared-memory database machine. Optimization during query compilation assumes the entire buffer pool is available, but in order to aid optimization at runtime, the query tree is divided into fragments.
References-found: 24

