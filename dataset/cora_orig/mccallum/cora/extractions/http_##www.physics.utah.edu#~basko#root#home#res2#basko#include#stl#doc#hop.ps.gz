URL: http://www.physics.utah.edu/~basko/root/home/res2/basko/include/stl/doc/hop.ps.gz
Refering-URL: http://www.physics.utah.edu/~basko/root/home/res2/basko/include/stl/doc/
Root-URL: 
Title: Higher Order Imperative Programming driven by abstraction from real algorithms, rather than attempting to work
Author: Aaron Kershenbaum David Musser Alexander Stepanov 
Note: it is  
Abstract: It is argued that a programming style based on higher order techniques|the use of procedures that have other procedures as arguments and/or results|can be most effectively employed if A sequence of examples is presented illustrating a number of higher order techniques| operators, iterators, accumulation, reduction, parallel reduction|and their effective use in conjunction with mutative procedures. The examples culminate with an interesting family of sorting algorithms, illustrating how higher order techniques can lead naturally to new algorithms.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Backus, </author> <title> "Can Programming Be Liberated from the von Neumann Style," </title> <journal> Communications of ACM, </journal> <volume> Vol. 21, No.8, </volume> <month> August </month> <year> 1978. </year>
Reference-contexts: APL especially promotes the notion that higher order techniques give the programmer significantly greater power, in terms of conciseness of expression, than most other languages. The functional programming community has also been using higher order techniques (e.g., in languages such as FP <ref> [1] </ref>, ML [5], and Miranda [12]). However, as with APL, there is an widespread emphasis in functional programming on working with a fixed, predefined set of functional forms. There is usually a further restriction to a purely applicative (no side-effects) style of programming.
Reference: [2] <author> R. W. Floyd, </author> <title> "Treesort (Algorithm 113)", </title> <journal> Communications of ACM, </journal> <month> December </month> <year> 1964, </year> <month> 701. </month>
Reference-contexts: By remembering the results of previous comparisons, tournament trees help to create highly efficient sorting procedures. The algorithms that will be presented were discovered while attempting to find a higher order representation of Floyd's Treesort algorithm <ref> [2] </ref>. A tournament tree is an ordered tree whose nodes satisfy the relation parent child An example is given in Figure 1. <p> If we pass it parallel-reduce! and right-reduce! (in that order), it creates a sorting procedure which does exactly the same comparisons (in the same order) as Floyd's Treesort <ref> [2] </ref>, but using a different data structure. 17 1 3 2 1 2 3 5 2 5 4 2 3 5 4 3 4 5 4 1 1, 2 1, 2, 3 1, 2, 3, 4 1, 2, 3, 4, 5 2 3 5 3 5 4 5 4 5 4
Reference: [3] <author> K. E. Iverson, </author> <title> "Operators," </title> <type> TOPLAS 1 (2), </type> <month> October </month> <year> 1979. </year>
Reference-contexts: This independence also would permit us to implement copy-top-level as (compose reverse! reverse). 12 7 Reduction Reduction operators were first introduced in APL <ref> [3] </ref>. Given a binary operation and a structure, we define the reduction of that operation over the structure as the result of successively combining all elements of the structure with the operation.
Reference: [4] <author> B. Liskov, et al., </author> <title> "CLU Reference Manual," </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: This style increases the possibilities for compile time evaluation of higher order procedures and allows our techniques to be applicable to languages that do not treat procedures as first class objects, but do have generics (e.g., Ada) or type polymorphism (e.g., CLU <ref> [4] </ref>). 4 Iterators Until is an example of one kind of operator called an iterator; i.e., a procedure that allows us to repeat another procedure. Another example of an iterator is the procedure for-each-pair given below.
Reference: [5] <author> R. Milner, </author> <title> "A Proposal for Standard ML," </title> <booktitle> 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <address> Austin, Texas, </address> <month> August </month> <year> 1984. </year>
Reference-contexts: APL especially promotes the notion that higher order techniques give the programmer significantly greater power, in terms of conciseness of expression, than most other languages. The functional programming community has also been using higher order techniques (e.g., in languages such as FP [1], ML <ref> [5] </ref>, and Miranda [12]). However, as with APL, there is an widespread emphasis in functional programming on working with a fixed, predefined set of functional forms. There is usually a further restriction to a purely applicative (no side-effects) style of programming.
Reference: [6] <author> D. Kapur, D. R. Musser, and A. A. Stepanov, </author> <title> "Operators and Algebraic Structures," </title> <booktitle> Proceedings of Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Portsmouth, New Hampshire, </address> <month> October </month> <year> 1981. </year>
Reference-contexts: Note that when list has only one element, new-procedure always returns that element. 5 To the best of our knowledge, the notion of parallel reduction as an operator was introduced in <ref> [6] </ref>. 13 In order to define parallel reduction, we first define the following combinator which, given a binary procedure combine, returns a procedure which replaces the first element of a non-empty list by the result of applying combine to the first two elements of the list; the second element is eliminated.
Reference: [7] <author> D.R. Musser and A.A. Stepanov, </author> <title> "A Library of Generic Algorithms in Ada," </title> <booktitle> Proc. ACM SIGAda Conference, </booktitle> <address> Boston, </address> <month> December 9-11, </month> <year> 1987. </year>
Reference-contexts: These techniques are particularly suitable as the basis for development of generic software libraries <ref> [7] </ref>. Acknowledgements. Earlier drafts of this paper were written while the second author was at General Electric Research and Development Center, Schenectady, NY. We are grateful to Leon Levy and Martin Shannon of AT&T Bell Labs for insightful comments and suggestions.
Reference: [8] <institution> Reference Manual for the Ada Programming Language, ANSI/MIL-STD-1815A, U. S. Department of Defense, </institution> <month> January </month> <year> 1983. </year> <title> 7 "In principle" because currently many Ada compilers do not handle complex combinations of layered generics and inlining directives at all. </title> <type> 20 </type>
Reference-contexts: Most of our work to date has been carried out in Scheme [9], Ada <ref> [8] </ref>, and C++ [11]. We will use Scheme for the examples in this paper, since Scheme supports higher order techniques in a simple, natural way, and since readers with a modest familiarity with Lisp should be able to read the subset of Scheme used in the examples.
Reference: [9] <editor> J.A. Rees and W. Clinger, eds., </editor> <title> "The Revised 3 Report on the Algorithmic Language Scheme," </title> <journal> SIGPLAN Notices 21, </journal> <volume> 12, </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: Most of our work to date has been carried out in Scheme <ref> [9] </ref>, Ada [8], and C++ [11]. We will use Scheme for the examples in this paper, since Scheme supports higher order techniques in a simple, natural way, and since readers with a modest familiarity with Lisp should be able to read the subset of Scheme used in the examples.
Reference: [10] <author> A. Stepanov and A. Kershenbaum, </author> <title> "Using Tournament Trees to Sort," </title> <type> Technical Report 86-13, </type> <institution> Center for Advanced Technology In Telecommunications, Polytechnic University. </institution>
Reference-contexts: In Figure 3 we show the sequence of tournament-trees generated and the way in which the original tournament tree is transformed into a linear list with the elements in order. By passing parallel-reduce! for both reduction parameters, we obtain an entirely new sorting algorithm <ref> [10] </ref>: (define parallel-tournament-sort! (make-tournament-sort! parallel-reduce! parallel-reduce!)) which sorts N elements by making slightly more than N log N comparisons when the elements are randomly ordered and only slightly more than 2N comparisons when they start 18 out nearly in order or nearly in reverse order.
Reference: [11] <author> B. Stoustrup, </author> <title> The C++ Programming Language, </title> <publisher> Addison-Wesley, </publisher> <month> December </month> <year> 1986. </year>
Reference-contexts: Most of our work to date has been carried out in Scheme [9], Ada [8], and C++ <ref> [11] </ref>. We will use Scheme for the examples in this paper, since Scheme supports higher order techniques in a simple, natural way, and since readers with a modest familiarity with Lisp should be able to read the subset of Scheme used in the examples.
Reference: [12] <author> D. A. Turner, "Miranda: </author> <title> A non-strict functional language with polymorphic types," </title> <editor> in J.-P. Jouannaud (ed.), </editor> <booktitle> Functional Programming Languages and Computer Architecture, Lecture Notes in Computer Science 201, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1985. </year> <month> 21 </month>
Reference-contexts: APL especially promotes the notion that higher order techniques give the programmer significantly greater power, in terms of conciseness of expression, than most other languages. The functional programming community has also been using higher order techniques (e.g., in languages such as FP [1], ML [5], and Miranda <ref> [12] </ref>). However, as with APL, there is an widespread emphasis in functional programming on working with a fixed, predefined set of functional forms. There is usually a further restriction to a purely applicative (no side-effects) style of programming.
References-found: 12

