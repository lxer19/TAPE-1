URL: http://www.cs.mu.oz.au/tr_db/mu_96_45.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Abstract  
Abstract: We demonstrate how a purely declarative language, with the help of strict typing, precise moding, and determinism declarations, can be used to concisely and declaratively express database transactions, including updates. We have begun incorporating transactions into the Aditi deductive database system using an extended form of Mercury as the database programming and query language. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Bancilhon, D. Maier, Y. Sagiv and J.D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the Fifth ACM PODS Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <year> 1986. </year>
Reference-contexts: The mode information is a superset of the bound /free adornments [21] used in many deductive database systems that play an important role in many database rule transformation techniques, such as magic sets (for example, see <ref> [1] </ref>). The modes can also specify that an argument should be unique, that is that there should be only one live reference to the data object passed in that argument.
Reference: [2] <author> Anthony J. Bonner and Michael Kifer. </author> <title> Transaction logic programming. </title> <booktitle> In Proceedings of the Tenth International Conference on Logic Programming, </booktitle> <pages> pages 257 - 279, </pages> <address> Budapest, </address> <year> 1993. </year>
Reference-contexts: Indeed, the semantics varies from one implementation to another [14]. Attempts have been made at devising more declarative semantics for updates in logic programming. Some have approached the problem by using alternative logics such as modal temporal logic (e.g. [23]), and transaction logic <ref> [2] </ref>. These are valid approaches. However, these logics are more complex than the simpler and more familiar predicate calculus. Since our approach is based on predicate calculus, we believe that it is more natural to express transactions in our language than these other approaches.
Reference: [3] <author> Danette Chimenti, Tony O'Hare, Ravi Kr-ishnamurthy, Shamim Naqvi, Shalom Tsur, Carolyn West and Carlo Zaniolo. </author> <title> An overview of the LDL system. </title> <journal> IEEE Data Engineering, </journal> <volume> Volume 10, Number 4, </volume> <pages> pages 52-62, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: In the case of relational systems, the part that queries the database system is written in SQL while the code that decides what updates to apply is written in a imperative "host" language such as C. Even deductive database systems such as LDL <ref> [3] </ref>, CORAL [18], SDS [12] and Glue-Nail [4] make this distinction. For example, in the Glue-Nail system, the Nail declarative query language is complemented by the Glue imperative update language.
Reference: [4] <author> M. A. Derr, S. Morishita and G. Phipps. </author> <title> The Glue-Nail deductive database system. </title> <journal> The VLDB Journal, </journal> <volume> Volume 3, Number 2, </volume> <pages> pages 123-160, </pages> <year> 1994. </year>
Reference-contexts: Even deductive database systems such as LDL [3], CORAL [18], SDS [12] and Glue-Nail <ref> [4] </ref> make this distinction. For example, in the Glue-Nail system, the Nail declarative query language is complemented by the Glue imperative update language. We have shown that this rigid separation is not necessary; our approach allows all of the code of the transaction to be written in one language.
Reference: [5] <author> K. P. Eswaran, J. Gray, R. Lorie and I. L. Traiger. </author> <title> The notions of consistency and predicate locks in a database system. </title> <journal> Communications of the ACM, </journal> <volume> Volume 19, Number 11, </volume> <pages> pages 624-633, </pages> <year> 1976. </year>
Reference-contexts: That is, at the language level we support the classical "flat" transaction model introduced in <ref> [5] </ref>. We discuss supporting other transaction models in Section 6. In the examples in this paper, the only values returned by a transaction are a db__result value and a new database state. In practice, it is necessary for a transaction to return values resulting from queries.
Reference: [6] <author> J. Gray and A. Reuter. </author> <title> Transaction processing: Concepts and techniques. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: Mercury in two important ways: by adding a transaction predicate; and by adding predicates to update (insert, delete and modify) each database relation. 4.1 The transaction predicate Our transaction predicate provides a declarative semantics for a transaction which has the required ACID properties 1 of atomicity, consistency, isolation and durability <ref> [6] </ref>. It is defined as follows: :- pred db__transaction ( pred (db__state, db__state), db__result, io__state, io__state ). :- mode db__transaction ( pred (di, uo) is det, out, di, uo ) is det.
Reference: [7] <author> T. Harder and A. Reuter. </author> <title> Principles of transaction-oriented database recovery. </title> <journal> ACM Computing Surveys, </journal> <volume> Volume 15, Number 2, </volume> <pages> pages 287-317, </pages> <year> 1983. </year>
Reference-contexts: If the updates specified by the transaction cause integrity constraint violations, then the transaction will make no changes to the database state, and will return a constraint violation message in Result. This ensures that the database remains consistent. 1 The term "ACID" was first used in <ref> [7] </ref>. 2 In practice, a more sophisticated db result is used | one that distinguishes between different modes of failure such as integrity constraint violations, user requested aborts, deadlocks, crashes, and so on. db transaction is a deterministic predicate containing io state arguments moded as di and uo.
Reference: [8] <author> James Harland and Kotagiri Ramamoha-narao. </author> <title> Constraint propagation for linear recursive rules. </title> <booktitle> In Proceedings of the Tenth International Conference on Logic Programming, </booktitle> <pages> pages 683-699, </pages> <year> 1993. </year>
Reference-contexts: Since a pure language is not dependent on a particular execution strategy, they are very useful for programming deductive databases. Many program transformation and optimization techniques (such as constraint propagation, and deforestation, see <ref> [8, 10, 11, 20] </ref> for examples) can be applied without changing the observed operational semantics. Such transformations can result in dramatic performance improvements. While Mercury is based on first order predicate logic, it supports higher-order programming.
Reference: [9] <author> David B. Kemp, Thomas Conway, Evan P. Harris, Fergus Henderson, Kotagiri Ramamo-hanarao and Zoltan Somogyi. </author> <title> Database transactions in a purely declarative logic programming language. </title> <type> Technical report 96/5, </type> <institution> Department of Information Systems, The University of Melbourne, </institution> <year> 1996. </year>
Reference-contexts: This is achieved by adding an extra output argument to the db__transaction predicate and using a type variable in the type declaration of db__transaction to ensure that it is the same type as that returned by the higher-order term. See <ref> [9] </ref> for more details. 4 io state db state db state db state io state 4.2 Update predicates For each relation in the database, there is a predicate of the same name, for retrieving tuples from that relation. The predicate has one more attribute than the relation. <p> We avoid this by restricting modifications to non-primary key attributes, and allowing at most one modification for each instance of the primary-key. Refer to <ref> [9] </ref> for more details on the modification predicates. Our approach to database updates can be extended to allow for hypothetical queries. These are queries computed with respect to a database that is modified temporarily.
Reference: [10] <author> David B. Kemp, Kotagiri Ramamohanarao, Isaac Balbin and Krishnamurthy Meenakshi. </author> <title> Propagating constraints in recursive deductive databases. </title> <booktitle> In Proceedings of the First North American Conference on Logic Programming, </booktitle> <pages> pages 981-998, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Since a pure language is not dependent on a particular execution strategy, they are very useful for programming deductive databases. Many program transformation and optimization techniques (such as constraint propagation, and deforestation, see <ref> [8, 10, 11, 20] </ref> for examples) can be applied without changing the observed operational semantics. Such transformations can result in dramatic performance improvements. While Mercury is based on first order predicate logic, it supports higher-order programming.
Reference: [11] <author> David B. Kemp and Peter J. Stuckey. </author> <title> Analysis based constraint query optimization. </title> <booktitle> In Proceedings of the Tenth International Conference on Logic Programming, </booktitle> <pages> pages 666-682, </pages> <year> 1993. </year>
Reference-contexts: Since a pure language is not dependent on a particular execution strategy, they are very useful for programming deductive databases. Many program transformation and optimization techniques (such as constraint propagation, and deforestation, see <ref> [8, 10, 11, 20] </ref> for examples) can be applied without changing the observed operational semantics. Such transformations can result in dramatic performance improvements. While Mercury is based on first order predicate logic, it supports higher-order programming.
Reference: [12] <author> W. Kieling, H. Schmidt and W. Strau. DECLARE and SDS: </author> <title> Early efforts to commercialize deductive database technology. </title> <journal> The VLDB Journal, </journal> <volume> Volume 3, Number 2, </volume> <pages> pages 211-244, </pages> <year> 1994. </year>
Reference-contexts: In the case of relational systems, the part that queries the database system is written in SQL while the code that decides what updates to apply is written in a imperative "host" language such as C. Even deductive database systems such as LDL [3], CORAL [18], SDS <ref> [12] </ref> and Glue-Nail [4] make this distinction. For example, in the Glue-Nail system, the Nail declarative query language is complemented by the Glue imperative update language.
Reference: [13] <author> C. Mohan, D. Haderle, B. Lindsay, H. Pira-hesh and P. Schwarz. </author> <title> ARIES: A transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Volume 17, Number 1, </volume> <pages> pages 94-162, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: One area of future work is to support a more general transaction model. The underlying database engine can be implemented using any compatible transaction model. For example, to facilitate high performance B-tree index updates, the ARIES method <ref> [13] </ref> uses a nested top-level transaction model. The additional features, over the flat transaction model, are not visible to the programmer, so need not be expressed in the language.
Reference: [14] <author> C. Moss. </author> <title> Cut and paste defining the impure primitives of Prolog. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming, </booktitle> <pages> pages 686-694, </pages> <address> London, </address> <year> 1986. </year>
Reference-contexts: Not only do assert and retract make compiler optimizations difficult, but their semantics can become very unin-tuitive, especially in the presence of back-tracking. Indeed, the semantics varies from one implementation to another <ref> [14] </ref>. Attempts have been made at devising more declarative semantics for updates in logic programming. Some have approached the problem by using alternative logics such as modal temporal logic (e.g. [23]), and transaction logic [2]. These are valid approaches.
Reference: [15] <author> J. E. B. Moss. </author> <title> Nested transactions: An approach to reliable distributed computing. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: The additional features, over the flat transaction model, are not visible to the programmer, so need not be expressed in the language. One possible approach is to provide support for the nested transaction model <ref> [15] </ref> by defining a db subtransaction predicate as follows: :- pred db__subtransaction ( pred (db__state, db__state), db__result, db__state, db__state ). :- mode db__subtransaction ( pred (di, uo) is det, out, di, uo ) is det. However, this predicate only supports a limited nested transaction model.
Reference: [16] <author> Alan Mycroft and Richard A. O'Keefe. </author> <title> A polymorphic type system for Prolog. </title> <journal> Artificial Intelligence, </journal> <volume> Volume 23, </volume> <pages> pages 295-307, </pages> <year> 1984. </year> <month> 9 </month>
Reference-contexts: Similarly, the prefix db denotes a predicate which is defined in our proposed database transaction library. Mercury is a strongly typed language whose type system is quite similar to that of ML and the Mycroft-O'Keefe type system for Prolog <ref> [16] </ref>. It requires that types be defined, and that predicates have a declaration that describes the intended type of each argument. Strong typing has long been recognized as a valuable mechanism for making software more reliable and more maintainable, both in the database community and in the general programming community.
Reference: [17] <author> Lee Naish, James A. Thom and Kotagiri Ra--mamohanarao. </author> <title> Concurrent database updates in Prolog. </title> <booktitle> In Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <pages> pages 178 - 195, </pages> <address> Melbourne, </address> <year> 1987. </year>
Reference-contexts: Other attempts to work within the framework of predicate calculus have only partially succeeded. For example, a transaction primitive is used for transforming database states in <ref> [17] </ref>. Under this proposal, until a transaction commits, database updates are not visible even to the process performing the updates. Our work demonstrates that this restriction is unnecessary. Another drawback of [17] is that there is no mechanism to stop a program from back-tracking over a committed transaction (the semantics of <p> For example, a transaction primitive is used for transforming database states in <ref> [17] </ref>. Under this proposal, until a transaction commits, database updates are not visible even to the process performing the updates. Our work demonstrates that this restriction is unnecessary. Another drawback of [17] is that there is no mechanism to stop a program from back-tracking over a committed transaction (the semantics of which is unclear). This is avoided in our proposal by insisting that transactions only occur in deterministic rules containing the unique state of the world variables.
Reference: [18] <author> Raghu Ramakrishnan, Divesh Srivastava, S. Sudarshan and Praveen Seshadri. </author> <title> The CORAL deductive system. </title> <journal> The VLDB Journal, </journal> <volume> Volume 3, Number 2, </volume> <pages> pages 161-210, </pages> <year> 1994. </year>
Reference-contexts: In the case of relational systems, the part that queries the database system is written in SQL while the code that decides what updates to apply is written in a imperative "host" language such as C. Even deductive database systems such as LDL [3], CORAL <ref> [18] </ref>, SDS [12] and Glue-Nail [4] make this distinction. For example, in the Glue-Nail system, the Nail declarative query language is complemented by the Glue imperative update language.
Reference: [19] <author> Zoltan Somogyi, Fergus Henderson and Thomas Conway. </author> <title> The execution algorithm of Mercury: an efficient purely declarative logic programming language. </title> <journal> Journal of Logic Programming, </journal> <volume> Volume 29, </volume> <pages> Number 1-3, pages 17-64, </pages> <year> 1996. </year>
Reference-contexts: The current release of Aditi has only limited support for concurrency and multiple users, because it has no support for transactions at the language level. In the next release of Aditi, we are using Mercury <ref> [19] </ref> as both the database programming and query language because it is a purely declarative logic programming language with strong typing and strong modes. As it is a general purpose logic programming language, it was not designed with the requirements of a database transaction processing system in mind. <p> Space limitations do not allow us to describe most of the details of the language, so we will limit our description to an overview in this section, and more detailed descriptions where necessary in the remainder of the paper. We refer the reader to <ref> [19] </ref> for more detail. Mercury is intended for the construction of large software systems and is thus quite different to other logic programming languages. Many aspects of the language make it a good base language for developing deductive database applications.
Reference: [20] <author> Divesh Srivastava and Raghu Ramakrishnan. </author> <title> Pushing constraint selections. </title> <booktitle> In Proceedings of the Eleventh ACM PODS Symposium on Principles of Database Systems, </booktitle> <pages> pages 301-315, </pages> <year> 1992. </year>
Reference-contexts: Since a pure language is not dependent on a particular execution strategy, they are very useful for programming deductive databases. Many program transformation and optimization techniques (such as constraint propagation, and deforestation, see <ref> [8, 10, 11, 20] </ref> for examples) can be applied without changing the observed operational semantics. Such transformations can result in dramatic performance improvements. While Mercury is based on first order predicate logic, it supports higher-order programming.
Reference: [21] <author> Jeffrey D. Ullman. </author> <title> Implementation of logical query languages for databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Volume 10, Number 3, </volume> <pages> pages 289-321, </pages> <year> 1985. </year>
Reference-contexts: The compiler checks that there is an ordering of the literals in the clause that satisfies the constraints of the mode declarations and reports an error if there is not. The mode information is a superset of the bound /free adornments <ref> [21] </ref> used in many deductive database systems that play an important role in many database rule transformation techniques, such as magic sets (for example, see [1]).
Reference: [22] <author> Jayen Vaghani, Kotagiri Ramamohanarao, David B. Kemp, Zoltan Somogyi, Peter J. Stuckey, Tim S. Leask and James Harland. </author> <title> The Aditi deductive database system. </title> <journal> The VLDB Journal, </journal> <volume> Volume 3, Number 2, </volume> <pages> pages 245-288, </pages> <year> 1994. </year>
Reference-contexts: Our motivation is a desire to incorporate such a declarative language as the query and update language of the next release of the Aditi deductive database system <ref> [22] </ref>, which is currently under development. An aim of the Aditi project is to produce a database system with programming facilities that are more general than those provided by relational database systems, while not compromising its performance.
Reference: [23] <author> D. S. Warren. </author> <title> Database updates in pure Prolog. </title> <booktitle> In Proceedings of the 1984 International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 244 - 253, </pages> <address> Tokyo, </address> <year> 1984. </year>
Reference-contexts: Indeed, the semantics varies from one implementation to another [14]. Attempts have been made at devising more declarative semantics for updates in logic programming. Some have approached the problem by using alternative logics such as modal temporal logic (e.g. <ref> [23] </ref>), and transaction logic [2]. These are valid approaches. However, these logics are more complex than the simpler and more familiar predicate calculus. Since our approach is based on predicate calculus, we believe that it is more natural to express transactions in our language than these other approaches.
Reference: [24] <author> Carlo Zaniolo and Resa Sadri. </author> <title> A simple model for active rules and their behaviour in deductive databases. </title> <booktitle> In The Proceedings of the Second ICLP-Workshop on Deductive Databases, </booktitle> <pages> pages 13-26, </pages> <year> 1994. </year> <month> 10 </month>
Reference-contexts: This is avoided in our proposal by insisting that transactions only occur in deterministic rules containing the unique state of the world variables. A more recent approach that also attempts to stay within the framework of predicate calculus is given in <ref> [24] </ref>. Under this approach, the sequence of database state changes resulting from a sequence of database updates is captured by giving all predicates an extra argument representing the sequence number.
References-found: 24

