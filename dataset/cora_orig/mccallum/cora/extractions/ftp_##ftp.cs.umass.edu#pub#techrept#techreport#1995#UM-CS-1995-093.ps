URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1995/UM-CS-1995-093.ps
Refering-URL: http://www-ccs.cs.umass.edu/db/publications/
Root-URL: 
Title: Efficient Transaction Management Query Processing in Massive Digital Databases  
Keyword: Concurrency Control, Transaction Management, Query Processing, Digital Libraries, Multimedia Databases, Information Retrieval, Hierarchical Storage, Optimization, Performance  
Affiliation: Sun Microsystems Lab  
Note: Supported by the National Science Foundation under grant IRI 9314376 and a grant from  
Abstract: Mohan Kamath and Krithi Ramamritham Computer Science Technical Report 95-93 Department of Computer Science University of Massachusetts Amherst MA 01003 fkamath,krithig@cs.umass.edu Abstract We address several important issues that arise in the development of Massive Digital Database Systems (MDDSs) in which data is being added continuously and on which users pose queries on the fly. News-on-demand and document retrieval systems are examples of systems that have these characteristics. Given the size of data, metadata such as index structures become even more important in these systems | data is accessed only after processing the metadata, both of which will reside on tertiary storage. The focus of this paper is on query and transaction processing in such systems, with emphasis on metadata management. The performance in these systems can be measured in terms of the response time for the queries and the recency or age of the items retrieved. Both need to be minimized. The key to satisfying the performance requirements is to exploit the characteristics of the metadata as well as of the queries and updates that access the metadata. After analyzing the functionality and correctness properties of updates, we develop an efficient scheme for executing queries concurrently with updates such that the queries have short response times and are guaranteed to return the most recent articles. Secondly, we address logging and recovery issues and propose techniques for efficiently migrating metadata updates from disk to tape. Thirdly, considering the tape access needs of queries, we develop new tape scheduling techniques for multiple queries such that the response time of queries is reduced. Results of the performance tests on a prototype system show the superior performance of the developed algorithms and reveal that to build high performance MDDSs it is imperative that we adopt approaches that exploit the data and transaction characteristics. 
Abstract-found: 1
Intro-found: 1
Reference: [ACF + 94] <author> M. Arya, W. Cody, C. Faloutsos, J. Richardson, and A. Toga. QBISM: </author> <title> Extending a DBMS to support 3D medical images. </title> <booktitle> In Proc. IEEE Int'l. Conf. on Data Eng., </booktitle> <pages> page 314, </pages> <address> Houston, TX, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: Textual articles are typically indexed based on keywords. An article can then be retrieved from a huge collection by specifying a set of keywords and the predicates joining them 2 [Fal85, Cro89]. An image can be retrieved by specifying various properties like color, texture, shapes and sizes <ref> [ACF + 94, Chi94, CLP94] </ref>. The query processor in both these cases refers to several indexes and determines the articles/images that are appropriate for a query.
Reference: [BCC94] <author> E.W. Brown, J.P. Callan, and W.B. Croft. </author> <title> Fast incremental indexing for full-text information retrieval. </title> <booktitle> In Proc. of Intl. Conference on Very Large Databases (VLDB), </booktitle> <address> Santiago, Chile, </address> <year> 1994. </year>
Reference-contexts: The cost of accessing the indexes are high, and the locking costs will be high. Hence the new articles are analyzed first in a batch and the metadata extracted, and all the article ID-sets are updated at the end in an incremental fashion <ref> [BCC94, TGMS94] </ref> as shown in figure 1. A query consists of a set of keywords signifying the articles of interest. To process such queries, first, the list of metadata to be read is identified. The article IDs corresponding to these keywords are then extracted from this metadata.
Reference: [BHG87] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Recall that our concurrency control scheme uses latching, exploits information about the read sets of queries and write sets of updates, makes use of the commutativity of appends and increments, and benefits from the ability to reorder update operations. Thus, whereas in static locking (conservative 2PL) <ref> [BHG87] </ref> a transaction obtains all locks before it submits any of its operations and as soon as the last operations is done all the locks may be released, our locks are of short duration and our scheme is non two-phase.
Reference: [Chi94] <author> T. Chiueh. </author> <title> Content-Based Image Indexing. </title> <booktitle> In Proc. of Intl. Conference on Very Large Databases (VLDB), </booktitle> <pages> pages 583-593, </pages> <address> Santiago, Chile, </address> <year> 1994. </year>
Reference-contexts: Textual articles are typically indexed based on keywords. An article can then be retrieved from a huge collection by specifying a set of keywords and the predicates joining them 2 [Fal85, Cro89]. An image can be retrieved by specifying various properties like color, texture, shapes and sizes <ref> [ACF + 94, Chi94, CLP94] </ref>. The query processor in both these cases refers to several indexes and determines the articles/images that are appropriate for a query.
Reference: [CHL93] <author> M. Carey, L. Haas, and M. Livny. </author> <title> Tapes Hold Data, Too: Challenges of Tuples on Tertiary Store. </title> <booktitle> In Proc. of SIGMOD Intl. Conference on Management of Data, </booktitle> <pages> pages 413-419, </pages> <year> 1993. </year>
Reference-contexts: such a way that query results are based on the most recent state of the database. * Since the time to mount a tape and seek data within a tape is in the order of few tens of seconds, access to tapes must be even better optimized than to disks <ref> [SSU90, CHL93] </ref>. We develop novel approaches to scheduling the tape access requests of dynamically arriving concurrent queries such that the average response time of queries is minimized. Our approaches minimize the number of tape mounts by reading/writing data from/to a mounted tape opportunistically.
Reference: [CLP94] <author> T. Chua, S. Lim, and H. Pung. </author> <title> Content Based Retrieval of Segmented Images. </title> <booktitle> In Proc. of ACM Multimedia, </booktitle> <pages> pages 211-218, </pages> <year> 1994. </year>
Reference-contexts: Textual articles are typically indexed based on keywords. An article can then be retrieved from a huge collection by specifying a set of keywords and the predicates joining them 2 [Fal85, Cro89]. An image can be retrieved by specifying various properties like color, texture, shapes and sizes <ref> [ACF + 94, Chi94, CLP94] </ref>. The query processor in both these cases refers to several indexes and determines the articles/images that are appropriate for a query.
Reference: [CRH95] <author> L.F. Cabrera, R. Rees, and W. Hineman. </author> <title> Applying Database Technology in the ADSM Mass Storage System. </title> <booktitle> In Proc. of Intl. Conference on Very Large Databases (VLDB), </booktitle> <address> Zurich, </address> <year> 1995. </year>
Reference-contexts: Recently database technology, specifically transaction management, has been applied for mass storage management in the context of ADSM (IBM's ADSTAR Distributed Storage Manager <ref> [CRH95] </ref>). The nature of their applications and requirements are quite different from ours. While we focus on exploiting metadata and update semantics for metadata management, they try to achieve transactional semantics for archiving and transferring files between storage devices. <p> Since metadata keeps growing, and there are multiple metadata on a single tape, strategies are needed to handle spills, 21 i:e:; updates to metadata that cannot fit onto the same tape. Although some simple strategy is discussed in <ref> [CRH95] </ref> additional study is needed. If the updates are stored on a new tape then query optimization will become more complicated. An alternative is to reorganize the metdata such that the whole metadata fits on a single tape. The tradeoffs here have to be investigated thoroughly.
Reference: [Cro89] <author> W. B. Croft. </author> <title> Research and development in information retrieval. </title> <journal> ACM Trans. on Inf. Sys., </journal> <volume> 7(3):181, </volume> <year> 1989. </year>
Reference-contexts: Metadata in MDDSs primarily consists of indexes. Textual articles are typically indexed based on keywords. An article can then be retrieved from a huge collection by specifying a set of keywords and the predicates joining them 2 <ref> [Fal85, Cro89] </ref>. An image can be retrieved by specifying various properties like color, texture, shapes and sizes [ACF + 94, Chi94, CLP94]. The query processor in both these cases refers to several indexes and determines the articles/images that are appropriate for a query.
Reference: [Fal85] <author> C. Faloutsos. </author> <title> Access Methods for Text. </title> <journal> ACM Computing Survey, </journal> <volume> 17 </volume> <pages> 50-74, </pages> <year> 1985. </year>
Reference-contexts: Metadata in MDDSs primarily consists of indexes. Textual articles are typically indexed based on keywords. An article can then be retrieved from a huge collection by specifying a set of keywords and the predicates joining them 2 <ref> [Fal85, Cro89] </ref>. An image can be retrieved by specifying various properties like color, texture, shapes and sizes [ACF + 94, Chi94, CLP94]. The query processor in both these cases refers to several indexes and determines the articles/images that are appropriate for a query.
Reference: [FR94] <author> C. Federighi and L. Rowe. </author> <title> A distributed hierarchical storage manager for a video-on-demand system. </title> <booktitle> In IS&T/SPIE Symposium on Electronic Imaging Science and Technology, </booktitle> <address> San Jose, CA, </address> <month> February </month> <year> 1994. </year> <pages> SPIE. </pages>
Reference-contexts: The online index building technique described in [MN92] concentrates mainly on consistently handling duplicates and deletions of keys from the index as the index is being built. However in our environment such situations do not arise. Issues related to hierarchical storage systems are discussed in <ref> [FR94, G + 95] </ref> but they mainly focus on storage design for supporting continuous delivery of multimedia data. Recently database technology, specifically transaction management, has been applied for mass storage management in the context of ADSM (IBM's ADSTAR Distributed Storage Manager [CRH95]).
Reference: [G + 95] <author> S. Ghandeharizadeh et al. </author> <title> On configuring hierarchical storage managers. </title> <type> Technical Report 95-601, </type> <institution> Computer Science Department, University of Southern California, </institution> <address> Los Angeles, CA, </address> <year> 1995. </year>
Reference-contexts: The online index building technique described in [MN92] concentrates mainly on consistently handling duplicates and deletions of keys from the index as the index is being built. However in our environment such situations do not arise. Issues related to hierarchical storage systems are discussed in <ref> [FR94, G + 95] </ref> but they mainly focus on storage design for supporting continuous delivery of multimedia data. Recently database technology, specifically transaction management, has been applied for mass storage management in the context of ADSM (IBM's ADSTAR Distributed Storage Manager [CRH95]).
Reference: [GR93] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kauf-mann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Since updates are in the form of appends and appends to a set can be considered to be idempotent, we can perform forward recovery upon a failure. To handle failures that may occur during a long update, the update can be programmed as a mini-batch <ref> [GR93] </ref>. Since there no dependencies between data items and no operations that can lead to logical errors, logical failures are rare. Because update transactions can be of long duration we should be concerned about the isolation properties of these updates especially since queries are typically of short duration. <p> This way the waiting time for queries is minimized and they also see the most recent articles. While several read latches can be issued concurrently, only one write latch is issued at a time. The latching mechanisms and data structures are similar to the locking data structures described in <ref> [GR93] </ref>. The main data structure is a hash table and each hash chain contains a number of latched items. The latch header for each item contains a list of transactions for whom a latches have been granted and a waiting queue for transactions that need a latch on that item.
Reference: [ML92] <author> C. Mohan and F. Levine. ARIES/IM: </author> <title> An efficient and high-concurrency index management method using write-ahead logging. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> page 371, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Even though we are exploiting the structure and semantics of metadata which are akin to index structures, it should be clear that simpler solutions than those developed for concurrency control of B-tree based index structures <ref> [Moh90, ML92] </ref> suffice because of the independence of different metadata items. The compensation based techniques discussed in [SC92] to handle queries or make changes to access structures concurrently with ongoing updates is not suited for our environment.
Reference: [MN92] <author> C. Mohan and I. Narang. </author> <title> Algorithms for creating indexes for very large tables without quiescing updates. </title> <booktitle> In ACM SIGMOD Conf. on the Management of Data, </booktitle> <address> San Diego, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: As we mentioned in section 4 the additional payoffs from adding such a compensation to our latching with reordering approach is negligible. The online index building technique described in <ref> [MN92] </ref> concentrates mainly on consistently handling duplicates and deletions of keys from the index as the index is being built. However in our environment such situations do not arise.
Reference: [Moh90] <author> C. Mohan. ARIES/KVL: </author> <title> A key-value locking method for concurrencty control of multi-action transactions operating on BTree indexes. </title> <booktitle> In Proceedings of the 16th Conference on Very Large Databases, </booktitle> <publisher> Morgan Kaufman pubs. </publisher> <address> (Los Altos CA), Brisbane, </address> <month> August </month> <year> 1990. </year> <note> Also published in/as: </note> <institution> IBM Almaden Res.Ctr, Res.R. No.RJ7008, Mar.1990, 27pp. </institution>
Reference-contexts: Even though we are exploiting the structure and semantics of metadata which are akin to index structures, it should be clear that simpler solutions than those developed for concurrency control of B-tree based index structures <ref> [Moh90, ML92] </ref> suffice because of the independence of different metadata items. The compensation based techniques discussed in [SC92] to handle queries or make changes to access structures concurrently with ongoing updates is not suited for our environment.
Reference: [SB94] <author> A. Strawman and F. Bretherton. </author> <title> A Reference Model for Metadata. </title> <note> In http://www.llnl.gov/liv comp/metadata/papers/whitepaper-bretherton.html, </note> <institution> University of Wisconsin, </institution> <month> March </month> <year> 1994. </year> <month> 24 </month>
Reference-contexts: Making sure that the indices are updated and maintained in such a way that queries return the most recently added documents requires careful concurrency control of accesses to the metadata. Modifications and deletions to data are very rare in such environments <ref> [SB94] </ref>. 2.2 Query and Update Processing When an article is added to the database, the metadata must be modified to reflect the addition of this article to the database. For example, consider a new article. It is first analyzed to determine the keywords in it. <p> Finally, scheduling tape accesses to minimize query response times is the subject of Section 6. In the above discussion we assumed that there are no deletions or revisions to articles. This is the case most of the time <ref> [SB94] </ref>. However if for some reason deletions/revisions occur then additional steps must be taken.
Reference: [SC92] <author> V. Srinivasan and M. J. Carey. </author> <title> Compensation-based on-line query processing. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> page 331, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: The compensation based techniques discussed in <ref> [SC92] </ref> to handle queries or make changes to access structures concurrently with ongoing updates is not suited for our environment.
Reference: [SGMS94] <author> K. Salem, H. Garcia-Molina, and J. Shands. </author> <title> Altruistic locking. </title> <journal> ACM Trans. on Database Sys., </journal> <volume> 19(1):117, </volume> <month> March </month> <year> 1994. </year>
Reference-contexts: Our scheme is different from altruistic locking <ref> [SGMS94] </ref> since we do not 19 use any long-term locks and we exploit update and query semantics to reorder update operations. This allows the updates to perform the operations and release the write locks early.
Reference: [SS95] <author> S. Sarawagi and M. Stonebraker. </author> <title> Query Processing in Tertiary Memory Databases. </title> <booktitle> In Proc. of Intl. Conference on Very Large Databases (VLDB), </booktitle> <address> Zurich, </address> <year> 1995. </year>
Reference-contexts: The nature of their applications and requirements are quite different from ours. While we focus on exploiting metadata and update semantics for metadata management, they try to achieve transactional semantics for archiving and transferring files between storage devices. In the context of the POSTGRES system, <ref> [SS95] </ref> discusses multiple query optimization for data residing on tertiary storage. It primarily concentrates on caching and scheduling strategies for efficiently processing relational two-way joins.
Reference: [SSU90] <author> A. Silberschatz, M. Stonebraker, and J. Ullman. </author> <title> Database systems: Achievements and opportunities. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 19(4) </volume> <pages> 6-22, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: such a way that query results are based on the most recent state of the database. * Since the time to mount a tape and seek data within a tape is in the order of few tens of seconds, access to tapes must be even better optimized than to disks <ref> [SSU90, CHL93] </ref>. We develop novel approaches to scheduling the tape access requests of dynamically arriving concurrent queries such that the average response time of queries is minimized. Our approaches minimize the number of tape mounts by reading/writing data from/to a mounted tape opportunistically.
Reference: [TGMS94] <author> A. Thomasic, H. Garcia-Molina, and K. Shoens. </author> <title> Incremental Updates of Inverted Lists for Text Document Retrieval. </title> <booktitle> In Proc. of SIGMOD Intl. Conference on Management of Data, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: The cost of accessing the indexes are high, and the locking costs will be high. Hence the new articles are analyzed first in a batch and the metadata extracted, and all the article ID-sets are updated at the end in an incremental fashion <ref> [BCC94, TGMS94] </ref> as shown in figure 1. A query consists of a set of keywords signifying the articles of interest. To process such queries, first, the list of metadata to be read is identified. The article IDs corresponding to these keywords are then extracted from this metadata.
Reference: [TGNO92] <author> D. Terry, D. Goldberg, D. Nichols, and B. </author> <title> Oki. Continuous queries over append-only databases. </title> <booktitle> In Proc ACM SIGMOD Conf., </booktitle> <pages> pages 321-330, </pages> <address> San Diego, California, </address> <year> 1992. </year>
Reference-contexts: Here new articles are constantly added to the database and the articles retrieved by the dynamic queries must ideally include the most recent additions. Thus the articles of interest to a user are known only when a query arrives. This is unlike systems like SIFT [YGM95a] and Tapestry <ref> [TGNO92] </ref> which are geared to continuously respond to statically specified queries or filters. In these systems, a user is informed about a new article if it passes the filtering criterion. Even though we are interested in on-the-fly queries, our techniques do find applicability in such situations also.
Reference: [VCC95] <author> S.R. Vasanthakumar, J. Callan, and W.B. Croft. </author> <title> Integrating INQUERY with an RDBMS to Support Text Retrieval. </title> <booktitle> In ACM SIGIR Conference on Research and Development in Information Retrieval Post-Conference Workshop on Information Retrieval and Databases, </booktitle> <address> Seattle, WA, </address> <year> 1995. </year>
Reference-contexts: Hence issues addressed in this paper to achieve good performance become important given the current trend to used DBMSs for managing metadata <ref> [VCC95] </ref>. The rest of the paper is organized as follows. Section 2 discusses the data and transaction characteristics. Section 3 presents the system architecture and some of the details of our prototype system. Section 4 describes our concurrency control technique and locking scheme.
Reference: [Wor94] <editor> MDDS Workgroup. </editor> <booktitle> Proceedings of the Massive Digital Data Systems Workshop, </booktitle> <month> February </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Massive Digital Database Systems (MDDSs) store peta-bytes of data with tera-bytes being added every day <ref> [Wor94] </ref>. Examples of such applications include digital libraries for news, office article management systems and earth observation satellite systems. To store, retrieve and manage such massive amounts of digital data, there is a need to develop efficient MDDSs. MDDSs use hierarchical storage systems [Wor94] consisting of primary, secondary and tertiary storage <p> data with tera-bytes being added every day <ref> [Wor94] </ref>. Examples of such applications include digital libraries for news, office article management systems and earth observation satellite systems. To store, retrieve and manage such massive amounts of digital data, there is a need to develop efficient MDDSs. MDDSs use hierarchical storage systems [Wor94] consisting of primary, secondary and tertiary storage devices to handle the huge amounts of data while achieving a better price-performance ratio. In such a hierarchical storage system, the tertiary device holds all the data and metadata while the secondary and primary act as a two level cache.
Reference: [YGM95a] <author> T. W. Yan and H. Garcia-Molina. </author> <title> SIFT AToll for Wide-Area Information Dissemination. </title> <booktitle> In In Proc. of 1995 USENIX Technical Conference, </booktitle> <pages> pages 177-186, </pages> <year> 1995. </year>
Reference-contexts: Here new articles are constantly added to the database and the articles retrieved by the dynamic queries must ideally include the most recent additions. Thus the articles of interest to a user are known only when a query arrives. This is unlike systems like SIFT <ref> [YGM95a] </ref> and Tapestry [TGNO92] which are geared to continuously respond to statically specified queries or filters. In these systems, a user is informed about a new article if it passes the filtering criterion. Even though we are interested in on-the-fly queries, our techniques do find applicability in such situations also.
Reference: [YGM95b] <author> T.W. Yan and H. Garcia-Molina. </author> <title> Information Finding in a Digital Library: the Stanford Perspective. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 24(3), </volume> <month> September </month> <year> 1995. </year> <month> 25 </month>
Reference-contexts: The age of the articles retrieved is an indication of the recency metric. To improve performance of a query with respect to both metrics, query processing must be cognizant of concurrent updates. Another situation where concurrent updates must be tracked occurs during text-database discovery <ref> [YGM95b] </ref>. Here, each site maintains metadata related to articles at other sites such that a query can be directed to a site that has the relevant articles. If concurrent updates are not tracked, then the query could be directed to an inappropriate site when there are better sites in reality.
References-found: 26

