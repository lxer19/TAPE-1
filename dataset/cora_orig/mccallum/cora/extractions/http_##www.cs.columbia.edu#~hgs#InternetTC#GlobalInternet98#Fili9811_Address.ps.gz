URL: http://www.cs.columbia.edu/~hgs/InternetTC/GlobalInternet98/Fili9811_Address.ps.gz
Refering-URL: http://www.cs.columbia.edu/~hgs/InternetTC/GlobalInternet98/
Root-URL: http://www.cs.columbia.edu
Title: ADDRESS LOOKUP SOLUTIONS FOR GIGABIT SWITCH/ROUTER  
Author: E. Filippi, V. Innocenti and V. Vercellone 
Address: Via Reiss Romoli 274 Torino, 10148 ITALY  
Affiliation: CSELT (Centro Studi e Laboratori Telecomunicazioni)  
Abstract: The Internet continuous growth and its widespread applications require adequate solutions for scaling routing performance. A number of approaches have been recently proposed by different vendors to prepare for the next generation Internet, and new router architectures, capable of processing millions of packets per second, are starting to appear. The efficient processing of IP addresses in such high performance internetworking equipment is one of the most challenging problems to solve. This paper focuses on the available technological solutions for the implementation of the address lookup unit in new generation IP switches and routers. Address lookup algorithms are discussed, and two fast, cheap and flexible hardware-assisted implementations are proposed and evaluated. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Pei e C. Zukowski: </author> <title> Putting Routing Tables in Silicon, </title> <journal> IEEE Network Magazine, </journal> <month> Jan </month> <year> 1992 </year>
Reference-contexts: In this paper we propose some enhancements to the well-known PATRICIA [2] and TRIE <ref> [1] </ref> retrieval schemes which make them particularly attractive for hardware assisted IP lookups. <p> The lookup time has an upper bound proportional to N/K and can be reduced by increasing K, which in turns increases the storage complexity. The timespace tradeoff is extensively analyzed in <ref> [1] </ref>. Memory usage for a specific table may be reduced if a variable number of bits are used to address each level or node in the trie, as suggested in [6]. <p> The number of rows that are required to store a given routing table is highly dependent on the prefix distribution. According to <ref> [1] </ref>, the maximum number of rows required to store 2 E prefixes of length N with a K-bit trie is (assuming N&gt;E&gt;K): 12 2R - K E K K K This bound is very pessimistic.
Reference: [2] <author> Wright, W.R. Stevens: </author> <title> TCP/IP illustrated, vol.2 - The implementation, </title> <publisher> Addison Wesley Publishing Co., </publisher> <year> 1995 </year>
Reference-contexts: In this paper we propose some enhancements to the well-known PATRICIA <ref> [2] </ref> and TRIE [1] retrieval schemes which make them particularly attractive for hardware assisted IP lookups. <p> An example is the Radix Tree algorithm in the NetBSD kernel. As described in <ref> [2] </ref>, support for longest matching prefixes is provided by means of a recursive backtracking mechanism, which worsen the search time upper bound to N 2 , where N is the maximum length of the stored prefixes.
Reference: [3] <editor> Doeringer et al., </editor> <booktitle> "Routing on longest-matching prefix" IEEE trans. on Networking, vol.4, </booktitle> <address> no.1, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: A PATRICIA with a non-recursive backtracking mechanism called dynamic prefix (DP) trie is presented in <ref> [3] </ref>. In a DP- trie, the search algorithm starts from the root, moves downward to a leaf and then backtracks only once to the first node with a matching prefix. <p> A survey of existing algorithms (see the previous sections) showed that none of them meets all our requirements: for example, [4,5] assume quasi-static forwarding database; [5,6,7] use some form of in place optimization; efficient memory allocation is hard in [5,6], performance of <ref> [3] </ref> is not adequate. THE hwdp-Trie First of all, we decided to optimize the DP- trie proposed in [3], exploiting the natural concurrent behavior of a hardware implementation. <p> that none of them meets all our requirements: for example, [4,5] assume quasi-static forwarding database; [5,6,7] use some form of in place optimization; efficient memory allocation is hard in [5,6], performance of <ref> [3] </ref> is not adequate. THE hwdp-Trie First of all, we decided to optimize the DP- trie proposed in [3], exploiting the natural concurrent behavior of a hardware implementation. In our implementation: --- Backtracking is avoided, resulting in a better worst case bound (N instead of 2N, where N is the address length). <p> The additional comparisons required during the forwarding phase have no impact on hardware implementations. --- Only one half (one cell) of a basic data row must be retrieved at each step. This means that our implementation requires one half of the memory throughput required, for instance, by <ref> [3] </ref>. Like in the DP- trie case, the maximum storage complexity is directly proportional to the number of entries, insert and delete operations have strictly local effects, and the resulting data structure is invariant to the particular sequence of insert/delete operations.
Reference: [4] <author> Waldvogel et al. </author> <title> Scalable high speed IP routing Lookups, </title> <booktitle> Proceedings of ACM SIGCOMM, </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: Hence, significant performance improvements can only be achieved with multiple-bit-at-a-time search algorithms. Some interesting algorithms have recently been proposed, which have demonstrated the feasibility of fast software IP lookups, and will be quickly described in the following. Binary search on hash tables : the algorithm described in <ref> [4] </ref> is based on binary search on a series of hash tables organized by prefix length. Due to the longest match problem, markers have to be added in the hash tables to ensure that a search operation requires at most log (N) hash lookups, where N is the address length. <p> Reported data are purely indicative. They are referred to a 300 MHz generic microprocessor and to the Mae-East routing table. Data for the Radix Trie and the Binary search on hash tables are taken from <ref> [4] </ref> and [6]. Data for the Variablestride trie are taken from [6]. Data for the Degenmarks algorithm are taken from [5]. Data for the LC- trie are taken from [7]. The number of average memory references may be assumed as a performance index for a HW implementation.
Reference: [5] <author> Degenmark et al.: </author> <title> Small forwarding tables for fast routing lookups, </title> <booktitle> Proceedings of ACM SIGCOMM, </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: Also, building and maintaining the whole data structure is slow and complex (the paper suggests to batch a number of changes and do a complete build of the search structure). Degenmarks algorithm : another interesting algorithm is proposed in <ref> [5] </ref>. Here the forwarding table is represented as a tree with three levels. <p> Data for the Radix Trie and the Binary search on hash tables are taken from [4] and [6]. Data for the Variablestride trie are taken from [6]. Data for the Degenmarks algorithm are taken from <ref> [5] </ref>. Data for the LC- trie are taken from [7]. The number of average memory references may be assumed as a performance index for a HW implementation. It is important to note that the comparison is limited to the search performance.
Reference: [6] <author> Srinivasan, Varghese, </author> <title> Faster IP lookups using controlled prefix expansion, </title> <booktitle> Proceedings of ACM SIGMETRICS, </booktitle> <month> May </month> <year> 1998. </year>
Reference-contexts: The timespace tradeoff is extensively analyzed in [1]. Memory usage for a specific table may be reduced if a variable number of bits are used to address each level or node in the trie, as suggested in <ref> [6] </ref>. Multibit tries (K&gt;1) require some extensions if they must be used with variable length overlapping prefixes (as it is the case for IP lookups). <p> Both problems may be solved a priori by strongly restructuring the prefix set before building the forwarding table, as proposed for example in [5,7] and partially in <ref> [6] </ref>. In this case (named leaf pushing by [6]) only the leaves of the tree can store target information, simplifying the lookup algorithms at the cost of slow, complex table updates. <p> Both problems may be solved a priori by strongly restructuring the prefix set before building the forwarding table, as proposed for example in [5,7] and partially in <ref> [6] </ref>. In this case (named leaf pushing by [6]) only the leaves of the tree can store target information, simplifying the lookup algorithms at the cost of slow, complex table updates. <p> Reported data are purely indicative. They are referred to a 300 MHz generic microprocessor and to the Mae-East routing table. Data for the Radix Trie and the Binary search on hash tables are taken from [4] and <ref> [6] </ref>. Data for the Variablestride trie are taken from [6]. Data for the Degenmarks algorithm are taken from [5]. Data for the LC- trie are taken from [7]. The number of average memory references may be assumed as a performance index for a HW implementation. <p> Reported data are purely indicative. They are referred to a 300 MHz generic microprocessor and to the Mae-East routing table. Data for the Radix Trie and the Binary search on hash tables are taken from [4] and <ref> [6] </ref>. Data for the Variablestride trie are taken from [6]. Data for the Degenmarks algorithm are taken from [5]. Data for the LC- trie are taken from [7]. The number of average memory references may be assumed as a performance index for a HW implementation. It is important to note that the comparison is limited to the search performance.
Reference: [7] <author> Nilsson, Karlsson, </author> <title> Fast address lookup for Internet Routers, </title> <booktitle> Proceedings of IFIP Workshop on Broadband Communication, </booktitle> <month> April </month> <year> 1998. </year>
Reference-contexts: Data for the Radix Trie and the Binary search on hash tables are taken from [4] and [6]. Data for the Variablestride trie are taken from [6]. Data for the Degenmarks algorithm are taken from [5]. Data for the LC- trie are taken from <ref> [7] </ref>. The number of average memory references may be assumed as a performance index for a HW implementation. It is important to note that the comparison is limited to the search performance. It does not take into account other parameters, like insertion/deletion performance, algorithmic complexity, flexibility. Memory
Reference: [8] <author> Gupta, Lin, McKeown, </author> <title> Routing lookups in hardware at memory access speeds, </title> <booktitle> Proceeding of IEEE INFOCOM, </booktitle> <month> April </month> <year> 1998. </year>
References-found: 8

