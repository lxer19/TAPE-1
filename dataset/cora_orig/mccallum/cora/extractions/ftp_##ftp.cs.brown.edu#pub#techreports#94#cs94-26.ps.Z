URL: ftp://ftp.cs.brown.edu/pub/techreports/94/cs94-26.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-94-26.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S. Abiteboul and C. Beeri. </author> <title> On the Power of Languages for the Manipulation of Complex Objects. </title> <note> INRIA Research Report 846, </note> <year> 1988. </year>
Reference-contexts: ONR Contracts N00014-94-1-1153 and N00014-91-J-4052, ARPA Order 8225. 1 It also corrects an error in an earlier version of this paper [26], where we claimed PTIME membership. 1 Extensions of this logical framework, based on high-order formulas over finite structures, have been proposed in order to manipulate complex-object databases e.g., <ref> [1] </ref>. Despite some success of these extensions, the resulting query languages do not capture all the features of object-oriented database (oodb) languages, a research area of much current practical interest. <p> In [25], we examine both the "pure" TLC and the "impure" TLC = and show that: (a) TLC (or TLC = ) expresses exactly the elementary queries and, thus, is a functional language for the complex-object queries of <ref> [1] </ref>. (b) Every PTIME-query can be PTIME-embedded in TLC (or TLC = ), i.e., its evaluation can be performed in polynomial time with a simple reduction strategy. (c) Similar PTIME-embeddings exist for every FO-query using terms of order at most 3 in TLC = or order at most 4 in TLC.
Reference: [2] <author> S. Abiteboul, R. Hull, V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Most importantly, as shown in [28, 46], every PTIME-query can be expressed using Datalog : on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics. We refer to <ref> [2] </ref> for a complete exposition of the logical framework and for the definitions of FO-and PTIME-queries. fl A preliminary summary of the work presented here appeared in [26]. y Research supported by ONR Contract N00014-91-J-4052, ARPA Order 8225, and by an ERCIM fellowship. z Research supported by ONR Contracts N00014-94-1-1153 and <p> The database active domain D is the set of constants in (r 1 : : : r l ). 3.2 Query Languages We first provide definitions for the FO- and PTIME-queries. These are like the definitions in <ref> [2] </ref>, but over list-represented databases.
Reference: [3] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog Extensions for Database Queries and Updates. </title> <journal> J. Comput. System Sci., </journal> <volume> 43 (1991), </volume> <pages> pp. 62-124. </pages>
Reference-contexts: The main motivation has been that common relational database queries are expressible in relational calculus or algebra [16], Datalog : and various fixpoint logics <ref> [3, 4, 12, 13, 34] </ref>. Most importantly, as shown in [28, 46], every PTIME-query can be expressed using Datalog : on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics. <p> Most importantly, as shown in [28, 46], every PTIME-query can be expressed using Datalog : on ordered structures; and, as shown in <ref> [3] </ref>, it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics.
Reference: [4] <author> S. Abiteboul and V. Vianu. </author> <title> Generic Computation and its Complexity. </title> <booktitle> In Proceedings of the 23rd ACM Symposium on the Theory of Computing (STOC) (1991), </booktitle> <pages> pp. 209-219. </pages>
Reference-contexts: The main motivation has been that common relational database queries are expressible in relational calculus or algebra [16], Datalog : and various fixpoint logics <ref> [3, 4, 12, 13, 34] </ref>. Most importantly, as shown in [28, 46], every PTIME-query can be expressed using Datalog : on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics.
Reference: [5] <author> H. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics (revised edition). </title> <publisher> North Holland, </publisher> <year> 1984. </year>
Reference-contexts: In our definitions, we use the "Curry style" of TLC terms without type annotations and reconstruct types. For clarity of exposition we often provide the annotations in "Church style". The expressive power of TLC was originally analyzed in terms of computations on simply typed Church numerals (see, e.g., <ref> [5, 18, 42] </ref>). Unfortunately, the simply-typed Church numeral input-output convention imposes severe limitations on expressive power. Only a fragment of PTIME is expressible this way (i.e., the extended polynomials). This does not illustrate the full capabilities of TLC. <p> e 0 (fi-reduction) when e 0 can be derived from e by replacing a subterm in e of the form (x: E) E 0 , called a redex , by E [x := E 0 ], E with E 0 substituted for all free occurrences of x in E; see <ref> [5] </ref> for standard definitions of substitution and ff- and fi-reduction. The operational semantics of TLC are defined using reduction. Let &gt; be the reflexive, transitive closure of &gt; ff and &gt; fi . Note that, reduction preserves types. <p> Let &gt; be the reflexive, transitive closure of &gt; ff , &gt; fi and &gt; ffi . Once again, reduction preserves types. A -term from which no reduction is possible, i.e., it contains no redex, is in normal form. TLC and TLC = enjoy the following properties, see <ref> [5, 21] </ref>: 1. Church-Rosser property: If e &gt; e 0 and e &gt; e 00 , then there exists a -term e 000 such that e 0 &gt; e 000 and e 00 &gt; e 000 . 2. <p> They work with or without type annotations and with or without constants in the 's). TLC and TLC = type reconstruction is linear-time in the size of the program analyzed. For many semantic properties of TLC we refer to [21, 44, 45]. Finally, we refer to <ref> [5] </ref> for other reduction notions such as the -reduction, (x: M x) &gt; M , where x is not free in M . We sometimes use properties of -reduction in the proofs of this paper, but do not use &gt; as part of &gt;. <p> Note that an encoding with duplicate tuples is possible. 2 Remark 3.3 Since the two terms c: c o 1;1 : : : o 1;k and c: n: c o 1;1 : : : o 1;k n, -convert (see <ref> [5] </ref>) to each other, they cannot be distinguished at the type level. For this reason, we allow both forms as valid representations of relations containing just one tuple. Note that an encoding of r inherently orders the tuples of r. <p> Q can be effectively determined from P . Proof: Fix some canonical typing fl of P . We obtain Q from P by a series of -expansions <ref> [5] </ref>, where a complete subterm x 1 : ff 1 : : : x k : ff k : M with type (M ) = ff k+1 ! ! ff m ! o or type (M ) = ff k+1 ! ! ff m ! t is replaced by x 1 <p> We have a reduction path (Q r 1 : : : r l ) ! ! (P r 1 : : : r l ) ! ! r: It is known that in a fi-reduction sequence, -reductions can always be pushed to the end <ref> [5, Theorem 15.1.6] </ref>. This remains true even if Eq-reductions are added, because Eq- and -reductions commute for typed terms, as a case analysis shows.
Reference: [6] <author> S. Bellantoni and S. Cook. </author> <title> A New Recursion-Theoretic Characterization of the Polytime Functions. </title> <booktitle> In Proceedings of the 24th ACM Symposium on the Theory of Computing (STOC) (1992), </booktitle> <pages> pp. 283-293. </pages>
Reference-contexts: With this addition, Leivant and Marion obtain various calculi in which there exist simple characterizations of PTIME. (Note that, since Cobham's early work there have been a number of interesting functional characterizations of PTIME, e.g., <ref> [6, 15, 20, 22] </ref>, which are not directly related to the TLC). It seems that to exhibit the power of the TLC one must add features as in [36] and/or modify the input-output conventions. <p> With the embedding of PTIME-queries into TLC = given in [25], this implies that TLI = 1 - queries = MLI = 1 -queries = FO-queries. One consequence of this analysis is a functional characterization of PTIME that differs from those of <ref> [6, 15, 20, 22, 36] </ref> in the sense of having the fewest additions to TLC|just equality over atomic constants. 3. We derive an NP-hardness lower bound for the complexity of type reconstruction in fixed order fragments of ML, such as MLI = 1 .
Reference: [7] <author> V. Breazu-Tannen, P. Buneman, and S. Naqvi. </author> <title> Structural Recursion as a Query Language. </title> <booktitle> In Proceedings of the 3rd Workshop on Database Programming Languages (DBPL3), </booktitle> <pages> pp. 9-19. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: Thus, there is a growing body of work on functional query languages, from the early FQL language of [10] to the more recent work on structural recursion as a query language for complex-objects <ref> [7, 8, 9, 30, 47] </ref>. In this context, it is natural to ask: "Is there a functional analogue of the logical framework of first-order and fixpoint formulas over finite structures?" In [25] we partly answered this question by computing on finite structures with the typed -calculus. <p> A number of other interesting open problems are raised from the framework of this paper: (1) Study the use of optimal reduction strategies [37] for the evaluation of TLI = i queries. (2) Study languages that combine list iterators and set iterators ala <ref> [7, 8, 9, 30, 47] </ref>. (3) Study the expressive power and the complexity of type reconstruction for fixed-order fragments of other typed calculi, e.g., System F [19, 41]. 34 Appendix: Relational Algebra in TLI = 0 and Copy in TLI = The following encodings are based on the ones given in
Reference: [8] <author> V. Breazu-Tannen, P. Buneman, and L. Wong. </author> <title> Naturally Embedded Query Languages. </title> <booktitle> In Proceedings of the 4th International Conference on Database Theory (ICDT), </booktitle> <pages> pp. 140-154. </pages> <booktitle> Lecture Notes in Computer Science 646, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Thus, there is a growing body of work on functional query languages, from the early FQL language of [10] to the more recent work on structural recursion as a query language for complex-objects <ref> [7, 8, 9, 30, 47] </ref>. In this context, it is natural to ask: "Is there a functional analogue of the logical framework of first-order and fixpoint formulas over finite structures?" In [25] we partly answered this question by computing on finite structures with the typed -calculus. <p> A number of other interesting open problems are raised from the framework of this paper: (1) Study the use of optimal reduction strategies [37] for the evaluation of TLI = i queries. (2) Study languages that combine list iterators and set iterators ala <ref> [7, 8, 9, 30, 47] </ref>. (3) Study the expressive power and the complexity of type reconstruction for fixed-order fragments of other typed calculi, e.g., System F [19, 41]. 34 Appendix: Relational Algebra in TLI = 0 and Copy in TLI = The following encodings are based on the ones given in
Reference: [9] <author> V. Breazu-Tannen and R. Subrahmanyam. </author> <title> Logical and Computational Aspects of Programming with Sets/Bags/Lists. </title> <booktitle> In Proceedings of the 18th International Conference on Automata, Languages, and Programming (ICALP), </booktitle> <pages> pp. 60-75. </pages> <booktitle> Lecture Notes in Computer Science 510, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Thus, there is a growing body of work on functional query languages, from the early FQL language of [10] to the more recent work on structural recursion as a query language for complex-objects <ref> [7, 8, 9, 30, 47] </ref>. In this context, it is natural to ask: "Is there a functional analogue of the logical framework of first-order and fixpoint formulas over finite structures?" In [25] we partly answered this question by computing on finite structures with the typed -calculus. <p> A number of other interesting open problems are raised from the framework of this paper: (1) Study the use of optimal reduction strategies [37] for the evaluation of TLI = i queries. (2) Study languages that combine list iterators and set iterators ala <ref> [7, 8, 9, 30, 47] </ref>. (3) Study the expressive power and the complexity of type reconstruction for fixed-order fragments of other typed calculi, e.g., System F [19, 41]. 34 Appendix: Relational Algebra in TLI = 0 and Copy in TLI = The following encodings are based on the ones given in
Reference: [10] <author> P. Buneman, R. Frankel, and R. Nikhil. </author> <title> An Implementation Technique for Database Query Languages. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 7 (1982), </volume> <pages> pp. 164-186. </pages>
Reference-contexts: Functional programming, with its emphasis on abstraction and on data types, might provide more insight into oodb query languages; and is the paradigm of choice in many oodbs. Thus, there is a growing body of work on functional query languages, from the early FQL language of <ref> [10] </ref> to the more recent work on structural recursion as a query language for complex-objects [7, 8, 9, 30, 47].
Reference: [11] <author> A. Chandra and D. Harel. </author> <title> Computable Queries for Relational Databases. </title> <journal> J. Comput. System Sci., </journal> <volume> 21 (1980), </volume> <pages> pp. 156-178. </pages>
Reference-contexts: 1 Introduction Database Query Languages: The logical framework of first-order (FO) and fixpoint formulas over finite structures has been the principal vehicle of theoretical research in database query languages; see <ref> [11, 12, 16, 17] </ref> for some of its earlier formulations. This framework has greatly influenced the design and analysis of relational and complex-object database query languages and has facilitated the integration of logic programming techniques in databases.
Reference: [12] <author> A. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <journal> J. Comput. System Sci., </journal> <volume> 25 (1982), </volume> <pages> pp. 99-128. </pages>
Reference-contexts: 1 Introduction Database Query Languages: The logical framework of first-order (FO) and fixpoint formulas over finite structures has been the principal vehicle of theoretical research in database query languages; see <ref> [11, 12, 16, 17] </ref> for some of its earlier formulations. This framework has greatly influenced the design and analysis of relational and complex-object database query languages and has facilitated the integration of logic programming techniques in databases. <p> The main motivation has been that common relational database queries are expressible in relational calculus or algebra [16], Datalog : and various fixpoint logics <ref> [3, 4, 12, 13, 34] </ref>. Most importantly, as shown in [28, 46], every PTIME-query can be expressed using Datalog : on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics.
Reference: [13] <author> A. Chandra and D. Harel. </author> <title> Horn Clause Queries and Generalizations. </title> <journal> J. Logic Programming, </journal> <volume> 2 (1985), </volume> <pages> pp. 1-15. </pages>
Reference-contexts: The main motivation has been that common relational database queries are expressible in relational calculus or algebra [16], Datalog : and various fixpoint logics <ref> [3, 4, 12, 13, 34] </ref>. Most importantly, as shown in [28, 46], every PTIME-query can be expressed using Datalog : on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics.
Reference: [14] <author> A. Church. </author> <title> The Calculi of Lambda-Conversion. </title> <publisher> Princeton University Press, </publisher> <year> 1941. </year>
Reference-contexts: We show that these fragments are functional analogues of the relational calculus/algebra and of fixpoint characterizations of PTIME. TLC Expressibility and Finite Model Theory: The simply typed -calculus <ref> [14] </ref> (typed - calculus or TLC for short) with its syntax and beta-reduction strategies can be viewed as a framework for database query languages which is between the declarative calculi and the procedural algebras. <p> Thus, in [25] we examine the expressive power of the typed - calculus, but over appropriately typed encodings of input-output finite structures. We also use TLC = , the typed -calculus with atomic constants and an equality on them, and the associated delta-reduction of <ref> [14] </ref>.
Reference: [15] <author> A. Cobham. </author> <title> The Intrinsic Computational Difficulty of Functions. </title> <editor> In Y. Bar-Hillel, editor, </editor> <booktitle> International Conference on Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pp. 24-30. </pages> <publisher> North Holland, </publisher> <year> 1964. </year>
Reference-contexts: With this addition, Leivant and Marion obtain various calculi in which there exist simple characterizations of PTIME. (Note that, since Cobham's early work there have been a number of interesting functional characterizations of PTIME, e.g., <ref> [6, 15, 20, 22] </ref>, which are not directly related to the TLC). It seems that to exhibit the power of the TLC one must add features as in [36] and/or modify the input-output conventions. <p> With the embedding of PTIME-queries into TLC = given in [25], this implies that TLI = 1 - queries = MLI = 1 -queries = FO-queries. One consequence of this analysis is a functional characterization of PTIME that differs from those of <ref> [6, 15, 20, 22, 36] </ref> in the sense of having the fewest additions to TLC|just equality over atomic constants. 3. We derive an NP-hardness lower bound for the complexity of type reconstruction in fixed order fragments of ML, such as MLI = 1 .
Reference: [16] <author> E. Codd. </author> <title> Relational Completeness of Database Sublanguages. </title> <editor> In R. Rustin, editor, </editor> <booktitle> Database Systems, </booktitle> <pages> pp. 65-98. </pages> <publisher> Prentice Hall, </publisher> <year> 1972. </year>
Reference-contexts: 1 Introduction Database Query Languages: The logical framework of first-order (FO) and fixpoint formulas over finite structures has been the principal vehicle of theoretical research in database query languages; see <ref> [11, 12, 16, 17] </ref> for some of its earlier formulations. This framework has greatly influenced the design and analysis of relational and complex-object database query languages and has facilitated the integration of logic programming techniques in databases. <p> This framework has greatly influenced the design and analysis of relational and complex-object database query languages and has facilitated the integration of logic programming techniques in databases. The main motivation has been that common relational database queries are expressible in relational calculus or algebra <ref> [16] </ref>, Datalog : and various fixpoint logics [3, 4, 12, 13, 34].
Reference: [17] <author> R. Fagin. </author> <title> Generalized First-Order Spectra and Polynomial-Time Recognizable Sets. </title> <booktitle> SIAM-AMS Proceedings, 7 (1974), </booktitle> <pages> pp. 43-73. </pages>
Reference-contexts: 1 Introduction Database Query Languages: The logical framework of first-order (FO) and fixpoint formulas over finite structures has been the principal vehicle of theoretical research in database query languages; see <ref> [11, 12, 16, 17] </ref> for some of its earlier formulations. This framework has greatly influenced the design and analysis of relational and complex-object database query languages and has facilitated the integration of logic programming techniques in databases.
Reference: [18] <author> S. Fortune, D. Leivant, and M. O'Donnell. </author> <title> The Expressiveness of Simple and Second-Order Type Structures. </title> <journal> J. of the ACM, </journal> <volume> 30 (1983), </volume> <pages> pp. 151-185. </pages>
Reference-contexts: In our definitions, we use the "Curry style" of TLC terms without type annotations and reconstruct types. For clarity of exposition we often provide the annotations in "Church style". The expressive power of TLC was originally analyzed in terms of computations on simply typed Church numerals (see, e.g., <ref> [5, 18, 42] </ref>). Unfortunately, the simply-typed Church numeral input-output convention imposes severe limitations on expressive power. Only a fragment of PTIME is expressible this way (i.e., the extended polynomials). This does not illustrate the full capabilities of TLC. <p> This does not illustrate the full capabilities of TLC. That more expressive power is possible follows from the fact that hard decision problems can be embedded in TLC, see [38, 39, 43], and that different typings allow exponentiation <ref> [18] </ref>. However, very few connections have been established between complexity theory and the -calculus. One such connection was recently demonstrated by Leivant and Marion [36], who express all of PTIME while avoiding the anomalies associated with representations over Church numerals. <p> This mapping is defined by a TLI = i (MLI = query term Q , where (Q r 1 : : : r l ) reduces to an encoding (with duplicates) of r. 9 Types of Inputs and Outputs: Note that, unlike <ref> [18, 42] </ref>, we allow the input and output type of a query to differ. <p> Both the difference between o and t and the treatment of duplicates are significant. For example, if we allow duplicates in the input-output conventions and use Church numeral input-output instead of list-represented databases it is possible to build exponentiators of low functionality order, see <ref> [18] </ref>. For another example, in [26], we demonstrate how various non-FO-queries can be expressed with a slight variation of the framework.
Reference: [19] <author> J.-Y. Girard. </author> <title> Interpretation Fonctionelle et Elimination des Coupures de l'Arithmetique d'Ordre Su-perieur. </title> <institution> These de Doctorat d'Etat, Universite de Paris VII, </institution> <year> 1972. </year> <month> 36 </month>
Reference-contexts: of optimal reduction strategies [37] for the evaluation of TLI = i queries. (2) Study languages that combine list iterators and set iterators ala [7, 8, 9, 30, 47]. (3) Study the expressive power and the complexity of type reconstruction for fixed-order fragments of other typed calculi, e.g., System F <ref> [19, 41] </ref>. 34 Appendix: Relational Algebra in TLI = 0 and Copy in TLI = The following encodings are based on the ones given in [25], adapted to the input-output format used in this paper. For a detailed explanation of their workings, consult [25].
Reference: [20] <author> J.-Y. Girard, A. Scedrov, P. J. Scott. </author> <title> Bounded Linear Logic: a Modular Approach to Polynomial Time Computability Theoretical Comp. </title> <journal> Sci., </journal> <volume> 97 (1992), </volume> <pages> pp. 1-66. </pages>
Reference-contexts: With this addition, Leivant and Marion obtain various calculi in which there exist simple characterizations of PTIME. (Note that, since Cobham's early work there have been a number of interesting functional characterizations of PTIME, e.g., <ref> [6, 15, 20, 22] </ref>, which are not directly related to the TLC). It seems that to exhibit the power of the TLC one must add features as in [36] and/or modify the input-output conventions. <p> With the embedding of PTIME-queries into TLC = given in [25], this implies that TLI = 1 - queries = MLI = 1 -queries = FO-queries. One consequence of this analysis is a functional characterization of PTIME that differs from those of <ref> [6, 15, 20, 22, 36] </ref> in the sense of having the fewest additions to TLC|just equality over atomic constants. 3. We derive an NP-hardness lower bound for the complexity of type reconstruction in fixed order fragments of ML, such as MLI = 1 .
Reference: [21] <author> C. Gunter. </author> <title> Semantics of Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Let &gt; be the reflexive, transitive closure of &gt; ff , &gt; fi and &gt; ffi . Once again, reduction preserves types. A -term from which no reduction is possible, i.e., it contains no redex, is in normal form. TLC and TLC = enjoy the following properties, see <ref> [5, 21] </ref>: 1. Church-Rosser property: If e &gt; e 0 and e &gt; e 00 , then there exists a -term e 000 such that e 0 &gt; e 000 and e 00 &gt; e 000 . 2. <p> They work with or without type annotations and with or without constants in the 's). TLC and TLC = type reconstruction is linear-time in the size of the program analyzed. For many semantic properties of TLC we refer to <ref> [21, 44, 45] </ref>. Finally, we refer to [5] for other reduction notions such as the -reduction, (x: M x) &gt; M , where x is not free in M . <p> The value of a typed term t is given by a function [[t]], which is defined below. (Given interpretations of the base types and constants, the meaning of terms is defined in a standard way, see e.g. <ref> [21] </ref>.) Let T be the set of types over base types o and t , i.e., the set of types given by the grammar T := o j t j T ! T . <p> Then [[M ; e]] = [[N ; e]]. Proof: See, e.g., <ref> [21, Theorem 2.10] </ref>. 2 The next lemma says that [[:]] is the "right" valuation map for our purpose: Lemma 5.9 Let r be the relation encoded with duplicates by the normal form of (Q r 1 : : : r l ).
Reference: [22] <author> Y. Gurevich. </author> <title> Algebras of Feasible Functions. </title> <booktitle> In Proceedings of the 24th IEEE Conference on the Foundations of Computer Science (FOCS) (1983), </booktitle> <pages> pp. 210-214. </pages>
Reference-contexts: With this addition, Leivant and Marion obtain various calculi in which there exist simple characterizations of PTIME. (Note that, since Cobham's early work there have been a number of interesting functional characterizations of PTIME, e.g., <ref> [6, 15, 20, 22] </ref>, which are not directly related to the TLC). It seems that to exhibit the power of the TLC one must add features as in [36] and/or modify the input-output conventions. <p> With the embedding of PTIME-queries into TLC = given in [25], this implies that TLI = 1 - queries = MLI = 1 -queries = FO-queries. One consequence of this analysis is a functional characterization of PTIME that differs from those of <ref> [6, 15, 20, 22, 36] </ref> in the sense of having the fewest additions to TLC|just equality over atomic constants. 3. We derive an NP-hardness lower bound for the complexity of type reconstruction in fixed order fragments of ML, such as MLI = 1 .
Reference: [23] <author> R. Harper, R. Milner, M. Tofte. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Contributions: In this paper we analyze fixed order fragments of TLC = and core-ML = . By core-ML = we mean TLC = with let-polymorphism. This is the core part of Milner's ML language <ref> [23, 40] </ref>, which combines the convenience of type reconstruction and the flexibility of polymorphism. More specifically we use: atomic constants of order 0, equality among these atomic constants, variables, application, lambda abstraction, and let abstraction; all typed using at most order 4 functionalities.
Reference: [24] <author> G. Hillebrand. </author> <title> Finite Model Theory in the Simply Typed Lambda Calculus. </title> <type> Ph.D. thesis, </type> <institution> Brown University, </institution> <year> 1994. </year>
Reference-contexts: Determining the exact expressive power of TLI = i for i &gt; 2 is open; the case i = 2 was resolved in <ref> [24] </ref> and corresponds to PSPACE. With respect to type reconstruction in core-ML, the order 3 case is open. For orders of 4 and above there is a gap between the best current upper bound (EXPTIME) and the NP-hardness lower bound.
Reference: [25] <author> G. Hillebrand, P. Kanellakis, and H. Mairson. </author> <title> Database Query Languages Embedded in the Typed Lambda Calculus. </title> <booktitle> In Proceedings of the 8th IEEE Conference on Logic in Computer Science (LICS) (1993), </booktitle> <pages> pp. 332-343. </pages>
Reference-contexts: In this context, it is natural to ask: "Is there a functional analogue of the logical framework of first-order and fixpoint formulas over finite structures?" In <ref> [25] </ref> we partly answered this question by computing on finite structures with the typed -calculus. In this paper, we continue our investigation with a focus on fixed order fragments of the typed -calculus, where (functional) order is a measure of the nesting of type functionalities. <p> It seems that to exhibit the power of the TLC one must add features as in [36] and/or modify the input-output conventions. Thus, in <ref> [25] </ref> we examine the expressive power of the typed - calculus, but over appropriately typed encodings of input-output finite structures. We also use TLC = , the typed -calculus with atomic constants and an equality on them, and the associated delta-reduction of [14]. In [25], we examine both the "pure" TLC <p> Thus, in <ref> [25] </ref> we examine the expressive power of the typed - calculus, but over appropriately typed encodings of input-output finite structures. We also use TLC = , the typed -calculus with atomic constants and an equality on them, and the associated delta-reduction of [14]. In [25], we examine both the "pure" TLC and the "impure" TLC = and show that: (a) TLC (or TLC = ) expresses exactly the elementary queries and, thus, is a functional language for the complex-object queries of [1]. (b) Every PTIME-query can be PTIME-embedded in TLC (or TLC = ), i.e., <p> The embeddings in (c-d) above, which minimized functionality order, were the starting point 2 for the work reported here. In particular, the embeddings in (d) presented some problems. Even if they expressed PTIME-queries, most reduction strategies required an exponential number of steps for evaluation. Unlike the reduction strategies of <ref> [25] </ref>, the strategies presented here make critical use of auxiliary data structures to force a PTIME number of steps. Contributions: In this paper we analyze fixed order fragments of TLC = and core-ML = . By core-ML = we mean TLC = with let-polymorphism. <p> List-represented means that each relation is given as an ordered list of tuples instead of a set. Our results are as follows: 1. We show: TLI = 0 -queries MLI = 0 -queries FO-queries, over list-represented databases. With the embedding of FO-queries into TLC = given in <ref> [25] </ref>, this implies that TLI = 0 -queries = MLI = 0 -queries = FO-queries. 2. We show: TLI = 1 -queries MLI = 1 -queries PTIME-queries, over list-represented databases. With the embedding of PTIME-queries into TLC = given in [25], this implies that TLI = 1 - queries = MLI <p> With the embedding of FO-queries into TLC = given in <ref> [25] </ref>, this implies that TLI = 0 -queries = MLI = 0 -queries = FO-queries. 2. We show: TLI = 1 -queries MLI = 1 -queries PTIME-queries, over list-represented databases. With the embedding of PTIME-queries into TLC = given in [25], this implies that TLI = 1 - queries = MLI = 1 -queries = FO-queries. <p> In Section 3, we show how to represent relational databases as -terms and we define families TLI = i of query languages acting on such representations. In Section 4, we establish lower bounds on their expressive power. Since the techniques here are variants of those in <ref> [25] </ref>, we only sketch the proofs. (For completeness we provide all related lambda terms in an Appendix). In Section 5, we present the main analytic results of this paper. <p> List iteration is a powerful programming technique, which can be used in the context of TLC and TLC = to encode any elementary recursion [38, 43]. However, some care is needed if one is to maintain well-typedness (cf. the "type-laundering" technique of <ref> [25] </ref>). 3 Representing Databases and Queries 3.1 Databases as Lambda Terms Relations are represented in our setting as simple generalizations of Church numerals. Let O = fo 1 ; o 2 ; : : :g be the set of constants of the TLC = calculus. <p> We begin by coding relational operators in TLI = 0 . The techniques are presented in full detail (albeit under slightly different input-output conventions) in <ref> [25] </ref> and we just give the Intersection k operator as an example here, for relations of arity k. For reference, the coding of the other relational operators is given in the Appendix. <p> : x k z 1 : : : z k u (Equal k y 1 : : : y k z 1 : : : z k v T )) v These encodings, together with Codd's equivalence theorem for relational algebra and calculus, establish the following theorem (first shown in <ref> [25] </ref>): Theorem 4.1 Every FO-query, over list-represented databases, is a TLI = 0 (MLI = 0 )-query. As a next step, we illustrate how to encode fixpoint queries in TLI = 1 . The technique is presented in detail in [25] and we just review the main steps here. <p> algebra and calculus, establish the following theorem (first shown in <ref> [25] </ref>): Theorem 4.1 Every FO-query, over list-represented databases, is a TLI = 0 (MLI = 0 )-query. As a next step, we illustrate how to encode fixpoint queries in TLI = 1 . The technique is presented in detail in [25] and we just review the main steps here. <p> The construction of the Copy i operator is described in detail in <ref> [25] </ref> and its code is in the Appendix. <p> Over ordered databases (in particular list-represented databases), fixpoint queries are sufficient to express all PTIME queries [28, 46], so we have the following theorem (first shown in <ref> [25] </ref>): Theorem 4.2 Every PTIME-query, over list-represented databases, is a TLI = 1 (MLI = 1 )-query. 12 5 Upper Bounds on Expressibility In this section, we show that the converses of Theorems 4.1 and 4.2 also hold: Theorem 5.1 Every TLI = 0 (MLI = 0 )-query is a FO-query, <p> 8, 9, 30, 47]. (3) Study the expressive power and the complexity of type reconstruction for fixed-order fragments of other typed calculi, e.g., System F [19, 41]. 34 Appendix: Relational Algebra in TLI = 0 and Copy in TLI = The following encodings are based on the ones given in <ref> [25] </ref>, adapted to the input-output format used in this paper. For a detailed explanation of their workings, consult [25]. Note that, if inputs are encodings without duplicates then so are outputs. <p> of other typed calculi, e.g., System F [19, 41]. 34 Appendix: Relational Algebra in TLI = 0 and Copy in TLI = The following encodings are based on the ones given in <ref> [25] </ref>, adapted to the input-output format used in this paper. For a detailed explanation of their workings, consult [25]. Note that, if inputs are encodings without duplicates then so are outputs.
Reference: [26] <author> G. Hillebrand and P. Kanellakis. </author> <title> Functional Database Query Languages as Typed Lambda Calculi of Fixed Order. </title> <booktitle> In Proceedings of the 13th ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pp. 222-231, </pages> <year> 1994. </year>
Reference-contexts: We refer to [2] for a complete exposition of the logical framework and for the definitions of FO-and PTIME-queries. fl A preliminary summary of the work presented here appeared in <ref> [26] </ref>. y Research supported by ONR Contract N00014-91-J-4052, ARPA Order 8225, and by an ERCIM fellowship. z Research supported by ONR Contracts N00014-94-1-1153 and N00014-91-J-4052, ARPA Order 8225. 1 It also corrects an error in an earlier version of this paper [26], where we claimed PTIME membership. 1 Extensions of this <p> preliminary summary of the work presented here appeared in <ref> [26] </ref>. y Research supported by ONR Contract N00014-91-J-4052, ARPA Order 8225, and by an ERCIM fellowship. z Research supported by ONR Contracts N00014-94-1-1153 and N00014-91-J-4052, ARPA Order 8225. 1 It also corrects an error in an earlier version of this paper [26], where we claimed PTIME membership. 1 Extensions of this logical framework, based on high-order formulas over finite structures, have been proposed in order to manipulate complex-object databases e.g., [1]. <p> Theorem 5.2 is complete. 6 ML Type Reconstruction for Fixed Order Functionalities In this section, we extend previous results on the complexity of ML typing by showing that ML type reconstruction for terms of bounded order is NP-hard. (This also corrects an erroneous claim of PTIME-membership that we made in <ref> [26] </ref>.) ML type reconstruction in general is EXPTIME-complete, but the known proofs [31, 32] use terms of unbounded order. We do not know whether EXPTIME completeness holds also for terms of bounded order. <p> Both the difference between o and t and the treatment of duplicates are significant. For example, if we allow duplicates in the input-output conventions and use Church numeral input-output instead of list-represented databases it is possible to build exponentiators of low functionality order, see [18]. For another example, in <ref> [26] </ref>, we demonstrate how various non-FO-queries can be expressed with a slight variation of the framework.
Reference: [27] <author> R. Hull and J. Su. </author> <title> On the Expressive Power of Database Queries with Intermediate Types. </title> <journal> J. Comput. System Sci., </journal> <volume> 43 (1991), </volume> <pages> pp. 219-267. </pages>
Reference-contexts: Questions: There are open issues regarding both variations of the input-output conventions (see above) and orders above 4. Beyond order 4 we believe (although we have not worked out the details here) that it should be possible to combine our basic machinery with the reductions of <ref> [27, 33, 35] </ref> to express various exponential time and space classes. Determining the exact expressive power of TLI = i for i &gt; 2 is open; the case i = 2 was resolved in [24] and corresponds to PSPACE.
Reference: [28] <author> N. Immerman. </author> <title> Relational Queries Computable in Polynomial Time. </title> <journal> Info. and Comp., </journal> <volume> 68 (1986), </volume> <pages> pp. 86-104. </pages>
Reference-contexts: The main motivation has been that common relational database queries are expressible in relational calculus or algebra [16], Datalog : and various fixpoint logics [3, 4, 12, 13, 34]. Most importantly, as shown in <ref> [28, 46] </ref>, every PTIME-query can be expressed using Datalog : on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics. <p> Over ordered databases (in particular list-represented databases), fixpoint queries are sufficient to express all PTIME queries <ref> [28, 46] </ref>, so we have the following theorem (first shown in [25]): Theorem 4.2 Every PTIME-query, over list-represented databases, is a TLI = 1 (MLI = 1 )-query. 12 5 Upper Bounds on Expressibility In this section, we show that the converses of Theorems 4.1 and 4.2 also hold: Theorem 5.1
Reference: [29] <author> N. </author> <title> Immerman. </title> <journal> Expressibility and Parallel Complexity SIAM J. Comp., </journal> <volume> 18 (1986), </volume> <pages> pp. 625-638. </pages>
Reference-contexts: Interestingly, iterations of this kind are not truly sequential|instead, all their stages can be evaluated in parallel, producing the output of the query in constant parallel time, or equivalently <ref> [29] </ref>, in first-order logic. The intuition behind this is the following. It is impossible for a TLC = term to distinguish between any two arguments of type t .
Reference: [30] <author> N. Immerman, S. Patnaik, and D. Stemple. </author> <title> The Expressiveness of a Family of Finite Set Languages. </title> <booktitle> In Proceedings of the 10th ACM Symposium on the Principles of Database Systems (PODS) (1991), </booktitle> <pages> pp. 37-52. </pages>
Reference-contexts: Thus, there is a growing body of work on functional query languages, from the early FQL language of [10] to the more recent work on structural recursion as a query language for complex-objects <ref> [7, 8, 9, 30, 47] </ref>. In this context, it is natural to ask: "Is there a functional analogue of the logical framework of first-order and fixpoint formulas over finite structures?" In [25] we partly answered this question by computing on finite structures with the typed -calculus. <p> A number of other interesting open problems are raised from the framework of this paper: (1) Study the use of optimal reduction strategies [37] for the evaluation of TLI = i queries. (2) Study languages that combine list iterators and set iterators ala <ref> [7, 8, 9, 30, 47] </ref>. (3) Study the expressive power and the complexity of type reconstruction for fixed-order fragments of other typed calculi, e.g., System F [19, 41]. 34 Appendix: Relational Algebra in TLI = 0 and Copy in TLI = The following encodings are based on the ones given in
Reference: [31] <author> P. Kanellakis, H. Mairson, and J. Mitchell. </author> <title> Unification and ML-type Reconstruction. </title> <booktitle> In Computational Logic: Essays in Honor of Alan Robinson, </booktitle> <pages> pp. 444-478. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: We derive an NP-hardness lower bound for the complexity of type reconstruction in fixed order fragments of ML, such as MLI = 1 . This complements the EXPTIME-completeness results in <ref> [31, 32] </ref>, which use terms of unbounded order. Overview: The paper is organized as follows. We begin with a review of the simply typed - calculus in Section 2. <p> In Section 6 we investigate the complexity of ML type reconstruction for terms of fixed order and derive an NP-hardness bound. The proof is a modification of the one given in <ref> [31] </ref>. It is based on the construction of terms with low functionality order, but high arity. <p> ML-typedness: This involves the same monomorphic types and inference rules for TLC and the constants used for TLC = , with one additional rule that captures some polymorphism (see <ref> [31] </ref>): (Let) ` let x = E in B : t We call a -term E ML-typed if ` E : t 0 is derivable by the inference rules (Var), (Abs), (App), and (Let) for some and t 0 . <p> Note that, core-ML = (core-ML) has all the properties of TLC = (TLC), i.e., Church-Rosser, Strong Normalization, Principal Type and Type Reconstruction. There is only one difference: Type reconstruction is no longer in linear-time but EXPTIME-complete <ref> [31, 32] </ref>. 2.3 List Iteration We briefly review how list iteration works. <p> In this section, we extend previous results on the complexity of ML typing by showing that ML type reconstruction for terms of bounded order is NP-hard. (This also corrects an erroneous claim of PTIME-membership that we made in [26].) ML type reconstruction in general is EXPTIME-complete, but the known proofs <ref> [31, 32] </ref> use terms of unbounded order. We do not know whether EXPTIME completeness holds also for terms of bounded order. Our result is the following: Theorem 6.1 For each fixed k 4, type reconstruction in order k core-ML is NP-hard in the program size.
Reference: [32] <author> A. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> An Analysis of ML Typability. </title> <booktitle> In Proceedings of the 17th Colloquium on Trees, Algebra and Programming, </booktitle> <pages> pp. 206-220. </pages> <booktitle> Lecture Notes in Computer Science 431, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We derive an NP-hardness lower bound for the complexity of type reconstruction in fixed order fragments of ML, such as MLI = 1 . This complements the EXPTIME-completeness results in <ref> [31, 32] </ref>, which use terms of unbounded order. Overview: The paper is organized as follows. We begin with a review of the simply typed - calculus in Section 2. <p> Note that, core-ML = (core-ML) has all the properties of TLC = (TLC), i.e., Church-Rosser, Strong Normalization, Principal Type and Type Reconstruction. There is only one difference: Type reconstruction is no longer in linear-time but EXPTIME-complete <ref> [31, 32] </ref>. 2.3 List Iteration We briefly review how list iteration works. <p> In this section, we extend previous results on the complexity of ML typing by showing that ML type reconstruction for terms of bounded order is NP-hard. (This also corrects an erroneous claim of PTIME-membership that we made in [26].) ML type reconstruction in general is EXPTIME-complete, but the known proofs <ref> [31, 32] </ref> use terms of unbounded order. We do not know whether EXPTIME completeness holds also for terms of bounded order. Our result is the following: Theorem 6.1 For each fixed k 4, type reconstruction in order k core-ML is NP-hard in the program size.
Reference: [33] <author> A. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> The Hierarchy of Finitely Typed Functional Programs. </title> <booktitle> In Proceedings of the 2nd IEEE Conference on Logic in Computer Science (LICS) (1987), </booktitle> <pages> pp. 225-235. </pages>
Reference-contexts: Questions: There are open issues regarding both variations of the input-output conventions (see above) and orders above 4. Beyond order 4 we believe (although we have not worked out the details here) that it should be possible to combine our basic machinery with the reductions of <ref> [27, 33, 35] </ref> to express various exponential time and space classes. Determining the exact expressive power of TLI = i for i &gt; 2 is open; the case i = 2 was resolved in [24] and corresponds to PSPACE.
Reference: [34] <author> P. Kolaitis and C. Papadimitriou. </author> <title> Why Not Negation By Fixpoint? J. </title> <journal> Comput. System Sci., </journal> <volume> 43 (1991), </volume> <pages> pp. 125-144. </pages>
Reference-contexts: The main motivation has been that common relational database queries are expressible in relational calculus or algebra [16], Datalog : and various fixpoint logics <ref> [3, 4, 12, 13, 34] </ref>. Most importantly, as shown in [28, 46], every PTIME-query can be expressed using Datalog : on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics.
Reference: [35] <author> G. Kuper and M. Vardi. </author> <title> On the Complexity of Queries in the Logical Data Model. </title> <journal> Theoretical Comput. Sci., </journal> <volume> 116 (1993), </volume> <pages> pp. 33-57. </pages>
Reference-contexts: Questions: There are open issues regarding both variations of the input-output conventions (see above) and orders above 4. Beyond order 4 we believe (although we have not worked out the details here) that it should be possible to combine our basic machinery with the reductions of <ref> [27, 33, 35] </ref> to express various exponential time and space classes. Determining the exact expressive power of TLI = i for i &gt; 2 is open; the case i = 2 was resolved in [24] and corresponds to PSPACE.
Reference: [36] <author> D. Leivant and J.-Y. Marion. </author> <title> Lambda Calculus Characterizations of Poly-Time. </title> <booktitle> In Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <address> Utrecht 1993. </address> <note> (To appear in Fundamenta Informaticae.) </note>
Reference-contexts: However, very few connections have been established between complexity theory and the -calculus. One such connection was recently demonstrated by Leivant and Marion <ref> [36] </ref>, who express all of PTIME while avoiding the anomalies associated with representations over Church numerals. In [36], the simply typed lambda calculus is augmented with a pairing operator and a "bottom tier" consisting of the free algebra of words over f0; 1g with associated constructor, destructor, and discriminator functions. <p> However, very few connections have been established between complexity theory and the -calculus. One such connection was recently demonstrated by Leivant and Marion <ref> [36] </ref>, who express all of PTIME while avoiding the anomalies associated with representations over Church numerals. In [36], the simply typed lambda calculus is augmented with a pairing operator and a "bottom tier" consisting of the free algebra of words over f0; 1g with associated constructor, destructor, and discriminator functions. <p> It seems that to exhibit the power of the TLC one must add features as in <ref> [36] </ref> and/or modify the input-output conventions. Thus, in [25] we examine the expressive power of the typed - calculus, but over appropriately typed encodings of input-output finite structures. <p> With the embedding of PTIME-queries into TLC = given in [25], this implies that TLI = 1 - queries = MLI = 1 -queries = FO-queries. One consequence of this analysis is a functional characterization of PTIME that differs from those of <ref> [6, 15, 20, 22, 36] </ref> in the sense of having the fewest additions to TLC|just equality over atomic constants. 3. We derive an NP-hardness lower bound for the complexity of type reconstruction in fixed order fragments of ML, such as MLI = 1 .
Reference: [37] <author> J.-J. Levy. </author> <title> Optimal Reductions in the Lambda-Calculus. </title> <editor> In J. Seldin and J. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays in Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pp. 159-191. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: For orders of 4 and above there is a gap between the best current upper bound (EXPTIME) and the NP-hardness lower bound. A number of other interesting open problems are raised from the framework of this paper: (1) Study the use of optimal reduction strategies <ref> [37] </ref> for the evaluation of TLI = i queries. (2) Study languages that combine list iterators and set iterators ala [7, 8, 9, 30, 47]. (3) Study the expressive power and the complexity of type reconstruction for fixed-order fragments of other typed calculi, e.g., System F [19, 41]. 34 Appendix: Relational
Reference: [38] <author> H. Mairson. </author> <title> A Simple Proof of a Theorem of Statman. </title> <journal> Theoretical Comput. Sci., </journal> <volume> 103 (1992), </volume> <pages> pp. 387-394. </pages>
Reference-contexts: Only a fragment of PTIME is expressible this way (i.e., the extended polynomials). This does not illustrate the full capabilities of TLC. That more expressive power is possible follows from the fact that hard decision problems can be embedded in TLC, see <ref> [38, 39, 43] </ref>, and that different typings allow exponentiation [18]. However, very few connections have been established between complexity theory and the -calculus. One such connection was recently demonstrated by Leivant and Marion [36], who express all of PTIME while avoiding the anomalies associated with representations over Church numerals. <p> List iteration is a powerful programming technique, which can be used in the context of TLC and TLC = to encode any elementary recursion <ref> [38, 43] </ref>. However, some care is needed if one is to maintain well-typedness (cf. the "type-laundering" technique of [25]). 3 Representing Databases and Queries 3.1 Databases as Lambda Terms Relations are represented in our setting as simple generalizations of Church numerals.
Reference: [39] <author> A. R. Meyer. </author> <title> The Inherent Computational Complexity of Theories of Ordered Sets. </title> <booktitle> In Proceedings of the International Congress of Mathematicians, </booktitle> <pages> pp. 477-482, </pages> <year> 1975. </year>
Reference-contexts: Only a fragment of PTIME is expressible this way (i.e., the extended polynomials). This does not illustrate the full capabilities of TLC. That more expressive power is possible follows from the fact that hard decision problems can be embedded in TLC, see <ref> [38, 39, 43] </ref>, and that different typings allow exponentiation [18]. However, very few connections have been established between complexity theory and the -calculus. One such connection was recently demonstrated by Leivant and Marion [36], who express all of PTIME while avoiding the anomalies associated with representations over Church numerals.
Reference: [40] <author> R. Milner. </author> <title> A Theory of Type Polymorphism in Programming. </title> <journal> J. Comput. System Sci., </journal> <volume> 17 (1978), </volume> <pages> pp. 348-375. </pages>
Reference-contexts: Contributions: In this paper we analyze fixed order fragments of TLC = and core-ML = . By core-ML = we mean TLC = with let-polymorphism. This is the core part of Milner's ML language <ref> [23, 40] </ref>, which combines the convenience of type reconstruction and the flexibility of polymorphism. More specifically we use: atomic constants of order 0, equality among these atomic constants, variables, application, lambda abstraction, and let abstraction; all typed using at most order 4 functionalities.
Reference: [41] <author> J. Reynolds. </author> <title> Towards a Theory of Type Structure. </title> <booktitle> In Proceedings of the Paris Colloquium on Programming, </booktitle> <pages> pp. 408-425. </pages> <booktitle> Lecture Notes in Computer Science 19, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1974. </year>
Reference-contexts: of optimal reduction strategies [37] for the evaluation of TLI = i queries. (2) Study languages that combine list iterators and set iterators ala [7, 8, 9, 30, 47]. (3) Study the expressive power and the complexity of type reconstruction for fixed-order fragments of other typed calculi, e.g., System F <ref> [19, 41] </ref>. 34 Appendix: Relational Algebra in TLI = 0 and Copy in TLI = The following encodings are based on the ones given in [25], adapted to the input-output format used in this paper. For a detailed explanation of their workings, consult [25].
Reference: [42] <author> H. Schwichtenberg. </author> <title> Definierbare Funktionen im -Kalkul mit Typen. </title> <journal> Archiv fur mathematische Logik und Grundlagenforschung, </journal> <volume> 17 (1976), </volume> <pages> pp. 113-114. </pages>
Reference-contexts: In our definitions, we use the "Curry style" of TLC terms without type annotations and reconstruct types. For clarity of exposition we often provide the annotations in "Church style". The expressive power of TLC was originally analyzed in terms of computations on simply typed Church numerals (see, e.g., <ref> [5, 18, 42] </ref>). Unfortunately, the simply-typed Church numeral input-output convention imposes severe limitations on expressive power. Only a fragment of PTIME is expressible this way (i.e., the extended polynomials). This does not illustrate the full capabilities of TLC. <p> This mapping is defined by a TLI = i (MLI = query term Q , where (Q r 1 : : : r l ) reduces to an encoding (with duplicates) of r. 9 Types of Inputs and Outputs: Note that, unlike <ref> [18, 42] </ref>, we allow the input and output type of a query to differ. <p> We would like to note that our characterization of FO-queries has some similarities with the extended polynomials characterization of <ref> [42] </ref>. Namely, the inputs and outputs have the same types. The only significant addition to TLC, with respect to [42], is equality. Although we present a syntactically simple, functional characterization of FO- and PTIME-queries, our characterizations do depend on the input-output conventions. <p> We would like to note that our characterization of FO-queries has some similarities with the extended polynomials characterization of <ref> [42] </ref>. Namely, the inputs and outputs have the same types. The only significant addition to TLC, with respect to [42], is equality. Although we present a syntactically simple, functional characterization of FO- and PTIME-queries, our characterizations do depend on the input-output conventions. Different conventions might lead to other characterizations that might be of interest. Both the difference between o and t and the treatment of duplicates are significant.
Reference: [43] <author> R. Statman. </author> <title> The Typed -Calculus is not Elementary Recursive. </title> <journal> Theoretical Computer Sci., </journal> <volume> 9 (1979), </volume> <pages> pp. 73-81. </pages>
Reference-contexts: Only a fragment of PTIME is expressible this way (i.e., the extended polynomials). This does not illustrate the full capabilities of TLC. That more expressive power is possible follows from the fact that hard decision problems can be embedded in TLC, see <ref> [38, 39, 43] </ref>, and that different typings allow exponentiation [18]. However, very few connections have been established between complexity theory and the -calculus. One such connection was recently demonstrated by Leivant and Marion [36], who express all of PTIME while avoiding the anomalies associated with representations over Church numerals. <p> List iteration is a powerful programming technique, which can be used in the context of TLC and TLC = to encode any elementary recursion <ref> [38, 43] </ref>. However, some care is needed if one is to maintain well-typedness (cf. the "type-laundering" technique of [25]). 3 Representing Databases and Queries 3.1 Databases as Lambda Terms Relations are represented in our setting as simple generalizations of Church numerals.
Reference: [44] <author> R. Statman. </author> <title> Completeness, Invariance, and -Definability. </title> <journal> J. Symbolic Logic, </journal> <volume> 47 (1982), </volume> <pages> pp. 17-26. </pages>
Reference-contexts: They work with or without type annotations and with or without constants in the 's). TLC and TLC = type reconstruction is linear-time in the size of the program analyzed. For many semantic properties of TLC we refer to <ref> [21, 44, 45] </ref>. Finally, we refer to [5] for other reduction notions such as the -reduction, (x: M x) &gt; M , where x is not free in M .
Reference: [45] <author> R. Statman. </author> <title> Equality between Functionals, Revisited. </title> <booktitle> In Harvey Friedman's Research on the Foundations of Mathematics, </booktitle> <pages> pp. 331-338. </pages> <publisher> North-Holland, </publisher> <year> 1985. </year>
Reference-contexts: They work with or without type annotations and with or without constants in the 's). TLC and TLC = type reconstruction is linear-time in the size of the program analyzed. For many semantic properties of TLC we refer to <ref> [21, 44, 45] </ref>. Finally, we refer to [5] for other reduction notions such as the -reduction, (x: M x) &gt; M , where x is not free in M .
Reference: [46] <author> M.Y. Vardi. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> In Proceedings of the 14th ACM Symposium on the Theory of Computing (STOC) (1982), </booktitle> <pages> pp. 137-146. </pages>
Reference-contexts: The main motivation has been that common relational database queries are expressible in relational calculus or algebra [16], Datalog : and various fixpoint logics [3, 4, 12, 13, 34]. Most importantly, as shown in <ref> [28, 46] </ref>, every PTIME-query can be expressed using Datalog : on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics. <p> Over ordered databases (in particular list-represented databases), fixpoint queries are sufficient to express all PTIME queries <ref> [28, 46] </ref>, so we have the following theorem (first shown in [25]): Theorem 4.2 Every PTIME-query, over list-represented databases, is a TLI = 1 (MLI = 1 )-query. 12 5 Upper Bounds on Expressibility In this section, we show that the converses of Theorems 4.1 and 4.2 also hold: Theorem 5.1
Reference: [47] <author> L. Wong. </author> <title> Normal Forms and Conservative Properties for Query Languages over Collection Types. </title> <booktitle> In Proceedings of the 12th ACM Symposium on the Principles of Database Systems (PODS) (1993), </booktitle> <pages> pp. 26-36. </pages>
Reference-contexts: Thus, there is a growing body of work on functional query languages, from the early FQL language of [10] to the more recent work on structural recursion as a query language for complex-objects <ref> [7, 8, 9, 30, 47] </ref>. In this context, it is natural to ask: "Is there a functional analogue of the logical framework of first-order and fixpoint formulas over finite structures?" In [25] we partly answered this question by computing on finite structures with the typed -calculus. <p> A number of other interesting open problems are raised from the framework of this paper: (1) Study the use of optimal reduction strategies [37] for the evaluation of TLI = i queries. (2) Study languages that combine list iterators and set iterators ala <ref> [7, 8, 9, 30, 47] </ref>. (3) Study the expressive power and the complexity of type reconstruction for fixed-order fragments of other typed calculi, e.g., System F [19, 41]. 34 Appendix: Relational Algebra in TLI = 0 and Copy in TLI = The following encodings are based on the ones given in
References-found: 47

