URL: ftp://wilma.cs.brown.edu/u/mfc/translate.ps.Z
Refering-URL: http://www.cs.brown.edu/software/cokokola/
Root-URL: http://www.cs.brown.edu
Email: email: mfc@cs.brown.edu  
Phone: Phone: (401) 863-7673 FAX: (401) 863-7657  
Title: Translating Queries into Combinators  
Author: Mitch Cherniack 
Date: December 17, 1996  
Address: Providence, RI 02912  
Affiliation: Brown University,  
Abstract: In [CZ96], we argue that a combinator (i.e., variable-free) query algebra simplifies correctness proofs and implementations of query optimizers. But combinators make for poor query languages, and therefore translations from standard query languages (such as OQL [Cat93]) into some combinator form is required. In this paper, we present our translator that maps queries written in a variant of OQL (OQL deB ) into KOLA [Che95a]; our combinator-based query algebra. We introduce a denotational semantics for OQL deB and define KOLA using an operational semantics that rewrites KOLA queries into OQL deB . We then proceed to show the correctness of our translator by showing that translation produces a KOLA query whose OQL deB equivalent has the same semantics as the original query. The significance of our work lies in its implications for the design of efficient and simply formalized query optimizers. With respect to formalization, we have used the Larch [GHG + 92] specification tool LSL to formally specify KOLA and its associated rule language, and have used these specifications within the Larch theorem prover LP to verify the correctness of over 300 transformation rules. (For details of this work see [Che95a]). We were not the first to recognize the potential benefits of a combinator-based internal query algebra. But by introducing a translation technique to map OQL queries into their combinator forms, these benefits become realizable in practice.
Abstract-found: 1
Intro-found: 1
Reference: [Bac78] <author> J. W. Backus. </author> <title> Can programming be liberated from the von Neumann style? A functional style and its algebra of programs. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 613-641, </pages> <month> August </month> <year> 1978. </year>
Reference: [BF79] <author> Peter Buneman and Robert E. Frankel. </author> <title> FQL a functional query language. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <year> 1979. </year>
Reference-contexts: We believe the translation technique described in this paper provides insight as to how this can be accomplished. <ref> [BF79] </ref> and [BK90] both propose an FP-style language to be used as an internal algebra of queries manipulated by an optimizer. Like [BG84], neither [BF79] nor [BK90] describe translation techniques to map queries expressed in query languages with variables into their formalism. <p> We believe the translation technique described in this paper provides insight as to how this can be accomplished. <ref> [BF79] </ref> and [BK90] both propose an FP-style language to be used as an internal algebra of queries manipulated by an optimizer. Like [BG84], neither [BF79] nor [BK90] describe translation techniques to map queries expressed in query languages with variables into their formalism. Since Turner's seminal paper [Tur79], combinators have been used within functional language compilers as internal representations of -expressions.
Reference: [BG84] <author> A. Bossi and C. Ghezzi. </author> <title> Using FP as a query language for relational data-bases. </title> <journal> Computer Languages, </journal> <volume> 9(1) </volume> <pages> 25-37, </pages> <year> 1984. </year>
Reference-contexts: But combinator-style languages are difficult for users to master and thus ill-suited as query languages. <ref> [BG84] </ref> consider the benefits of FP-style languages with respect to formalization but provide no means of mapping query expressions into their FP-style algebra. <p> We believe the translation technique described in this paper provides insight as to how this can be accomplished. [BF79] and [BK90] both propose an FP-style language to be used as an internal algebra of queries manipulated by an optimizer. Like <ref> [BG84] </ref>, neither [BF79] nor [BK90] describe translation techniques to map queries expressed in query languages with variables into their formalism. Since Turner's seminal paper [Tur79], combinators have been used within functional language compilers as internal representations of -expressions.
Reference: [BK90] <author> Catriel Beeri and Yoram Kornatzky. </author> <title> Algebraic optimization of object-oriented query languages. </title> <editor> In S. Abiteboul and P. C. Kanellakis, editors, </editor> <booktitle> Proceedings of the Third International Conference on Database Theory, number 470 in Lecture Notes in Computer Science, </booktitle> <pages> pages 72-88, </pages> <address> Paris, France, </address> <month> December </month> <year> 1990. </year> <title> EATCS, </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We believe the translation technique described in this paper provides insight as to how this can be accomplished. [BF79] and <ref> [BK90] </ref> both propose an FP-style language to be used as an internal algebra of queries manipulated by an optimizer. Like [BG84], neither [BF79] nor [BK90] describe translation techniques to map queries expressed in query languages with variables into their formalism. <p> We believe the translation technique described in this paper provides insight as to how this can be accomplished. [BF79] and <ref> [BK90] </ref> both propose an FP-style language to be used as an internal algebra of queries manipulated by an optimizer. Like [BG84], neither [BF79] nor [BK90] describe translation techniques to map queries expressed in query languages with variables into their formalism. Since Turner's seminal paper [Tur79], combinators have been used within functional language compilers as internal representations of -expressions.
Reference: [BTBN91] <author> Val Breazu-Tannen, Peter Buneman, and Shamim Naqvi. </author> <title> Structural recursion as a query language. </title> <editor> In Paris Kanellakis and Joachim W. Schmidt, editors, </editor> <title> Bulk Types & Persistent Data: </title> <booktitle> The Third International Workshop on Database Programming Languages, </booktitle> <pages> pages 9-19, </pages> <address> Nafplion, Greece, August 1991. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher> <pages> 66 </pages>
Reference-contexts: Effectively, fold applies f to each member of A and combines the results with . x defines the identity value returned when A is empty. (Note that must be commutative and associative for fold to be well-defined. Unlike <ref> [BTBN91] </ref>, we do not demand that also be idempotent, and instead define the semantics of fold in terms of minimally represented sets.) Table 1 shows how OQL's partial and total aggregate functions are expressed in KOLA. fold is inexpressible in OQL deB .
Reference: [Cat93] <author> R.G.G. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <address> Morgan-Kaufman, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Query languages use variables to name and relate data objects held in collections. For example, the OQL <ref> [Cat93] </ref> query of Figure 1 pairs people in the set P with children who live with them. This query uses the variable x 0 to denote people in P, and x 1 to denote children of people in P. <p> In Section 5, we compare our work with related work in databases concerning querying with combinators, and related work in functional programming concerning translations into combinator forms. 2 A Denotational Semantics of OQL deB In this section, we describe our variant of the query language OQL <ref> [Cat93] </ref>, which serves as the source language for translation. Hereafter we refer to our OQL variant as OQL deB (or deBruijn-OQL). We begin in Section 2.1 by describing how OQL deB differs from OQL. In short, 1. OQL deB includes constants (the empty tuple) and fg (the empty set), 2. <p> anticipated future work.) Note: Because sets are the only collection type supported in OQL deB , all select queries will be written with select distinct, even though this may not be necessary in all cases. * queries that construct new mutable objects (The semantics of this is unclear, even in <ref> [Cat93] </ref>. This is anticipated future work.) * query naming, class indication, queries with the having operator, inclusion predicates and type casting (These should require straightforward extensions to the translator. This is anticipated future work.) 5. OQL deB assumes a normalizing scheme to simplify the translation of variables and tuples. <p> We provide a formal (denotational) semantics for OQL deB in Section 2.2 and in the same section discuss the well-formedness property of meaningful OQL deB queries. 2.1 OQL deB : A Variant of OQL 2.1.1 Variable Normalization OQL deB deviates from the language definition of <ref> [Cat93] </ref> by assuming a deBruijn-like [DeB72] notation for all variables appearing within queries. Using this notation, variables are named uniformly (V i for some i 0), thus facilitating translation. <p> We leave this as an exercise for the reader. grp generalizes OQL's <ref> [Cat93] </ref> "group by" operator. grp (p; f; g) ! A returns a set of values, f ! t x; F x for each x 2 A. <p> Our work is motivated by the difficulties that variables introduce into optimization, both in terms of an optimizer's efficiency and in terms of its formalization. We have described the technique by showing an example translator that maps queries written in a variant of OQL <ref> [Cat93] </ref> into queries written in KOLA [Che95a]; our combinator-based algebra. We have also presented proofs that establish the correctness of our translator.
Reference: [Che95a] <author> Mitch Cherniack. </author> <title> Form(ers) over function(s): The KOLA query algebra. </title> <type> Technical report, </type> <institution> Brown University Department of Computer Science, </institution> <month> May </month> <year> 1995. </year> <note> In preparation. </note>
Reference-contexts: The third through fifth sections of Table 2 define the subset of KOLA's function and predicate formers that are necessary for the translation of OQL deB . (The description of the full algebra can be found in <ref> [Che95a] </ref> and its formal specification (written in Larch [GHG + 92]) is available at [Che95b].) General function formers (third section) include function composition ( ffi ), function pairing (h ; i), constant functions (K f ( )), curried functions (C f ( ; )), pairwise function application ( fi ), and <p> We have described the technique by showing an example translator that maps queries written in a variant of OQL [Cat93] into queries written in KOLA <ref> [Che95a] </ref>; our combinator-based algebra. We have also presented proofs that establish the correctness of our translator. The proofs rely on a denotational semantics for our OQL variant and establish that translation produces a KOLA query whose OQL equivalent has the same semantics as the original query. <p> With respect to formalization, we have used the Larch [GHG + 92] specification tool LSL to formally specify KOLA and its associated rule language, and have used these specifications within the Larch theorem prover LP to verify the correctness of over 300 transformation rules. (For details of this work see <ref> [Che95a] </ref>). We were not the first to recognize the potential benefits of a combinator-based internal query algebra with respect to efficiency and formalization of query optimizers. But by the introduction of a translation technique to map queries into their combinator forms, these benefits become realizable in practice.
Reference: [Che95b] <author> Mitch Cherniack. </author> <title> A Larch specification of KOLA. </title> <note> Available at http://www.cs.brown.edu/software/cokokola/kola.tar.Z, 1995. </note>
Reference-contexts: third through fifth sections of Table 2 define the subset of KOLA's function and predicate formers that are necessary for the translation of OQL deB . (The description of the full algebra can be found in [Che95a] and its formal specification (written in Larch [GHG + 92]) is available at <ref> [Che95b] </ref>.) General function formers (third section) include function composition ( ffi ), function pairing (h ; i), constant functions (K f ( )), curried functions (C f ( ; )), pairwise function application ( fi ), and conditional functions (con ( ; ; )).
Reference: [Che96] <author> Mitch Cherniack. </author> <note> An OQL ! KOLA translator. Available at http://www.cs.brown.edu/software/cokokola/oqltrans.tar.Z, 1996. </note>
Reference-contexts: This semantics provide not only a precise definition of the language, but also allow us to prove that certain OQL deB expressions are equal, and also to prove that our translation of OQL deB into KOLA is correct. 3 In fact our translator <ref> [Che96] </ref> skips the translation into OQL deB to make translation into KOLA more efficient. 6 2.2.1 D: A Semantic Domain To give a semantics to OQL deB expressions we assume a semantic domain, D that includes base values (integers and booleans), objects (whose interface is determined by their class), pairs and
Reference: [Cur93] <author> Pierre-Louis Curien. </author> <title> Categorical Combinators, Sequential Algorithms, and Functional Programming. </title> <publisher> Birkhauser, </publisher> <year> 1993. </year>
Reference: [CZ96] <author> Mitch Cherniack and Stanley B. Zdonik. </author> <title> Rule languages and internal algebras for rule-based op-timizers. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <address> Montreal, Quebec, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Children") select distinct struct (Par : x 0 ; SAC : 0 select distinct x 1 from x 1 in (x 0 ! child) where (x 0 ! addr) == (x 1 ! addr) 1 from x 0 in P 1 environment analysis to decide when optimizations can be applied <ref> [CZ96] </ref>. Environment analysis adds ineffiency to optimization and complicates formalization. Optimizers stand to benefit from having queries expressed in a variable-free (combinator-based) form. But combinators are not easy for query writers to use and so a translation into this form is required. <p> The problem addressed in this paper is to how to perform such translations. We introduce a technique that we have used to implement translators from both the AQUA [LMS + 93] and OQL query languages into KOLA <ref> [CZ96] </ref>; our combinator-based algebra. We describe the technique by presenting the OQL ! KOLA translator. The significance of our work lies in its implications for query optimizer design. <p> The exclusion of variables from function and predicate definitions simplifies their composition and decomposition and makes code supplements to rules unnecessary <ref> [CZ96] </ref>. 35 Every KOLA function and predicate can be thought of as an OQL deB macro. The invocation of the function or predicate on an object (via invocation operators ! (for functions) and ? (for predicates)) has a semantics expressible in OQL deB . <p> As we showed in <ref> [CZ96] </ref>, this is useful for expressing nested queries as x can denote an OQL deB expression that evaluates to an environment and that is evaluated in the body of an outer loop but used within the body of an inner loop.
Reference: [CZLK96] <author> Mitch Cherniack, Stan Zdonik, Joon-Suk Lee, and Kee-Eung Kim. </author> <title> Grouping rules the COKO-KOLA way: It's the real thing. </title> <note> Submitted to SIGMOD '97, </note> <year> 1996. </year>
Reference-contexts: As we showed in [CZ96], this is useful for expressing nested queries as x can denote an OQL deB expression that evaluates to an environment and that is evaluated in the body of an outer loop but used within the body of an inner loop. As we showed in <ref> [CZLK96] </ref>, iter is also useful for expressing code motion transformations that move constant computations outside of loops. KOLA includes generalized set operator formers, int (eq), uni (eq) and dif (eq).
Reference: [CZN95] <author> Mitch Cherniack, Stanley B. Zdonik, and Marian H. Nodine. </author> <title> To form a more perfect union (intersection, difference). </title> <booktitle> In Proc. 5th Int'l Workshop on Database Programming Languages, </booktitle> <address> Gubbio, Italy, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: A prototypical equivalence 36 difference respectively that are relative to eq. When instantiated with the equality primitive (eq), these formers generate standard intersection, union and difference functions. A full description of, and motivation for these formers is given in <ref> [CZN95] </ref>. bound is a former of partial aggregate functions and therefore is purposely underspecified. bound (p) generates functions that compute least upper or greatest lower bounds (wrt the partial order predicate, p 5 ) of non-empty sets.
Reference: [DeB72] <author> N.G. DeBruijn. </author> <title> Lambda calculus notation with nameless dummies. </title> <journal> Indagationes Mathematicae, </journal> <volume> 34 </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: We provide a formal (denotational) semantics for OQL deB in Section 2.2 and in the same section discuss the well-formedness property of meaningful OQL deB queries. 2.1 OQL deB : A Variant of OQL 2.1.1 Variable Normalization OQL deB deviates from the language definition of [Cat93] by assuming a deBruijn-like <ref> [DeB72] </ref> notation for all variables appearing within queries. Using this notation, variables are named uniformly (V i for some i 0), thus facilitating translation. <p> V 0 therefore refers to the most "recently" declared variable (relative to the point in the parse where V 0 appears). The translation of a query from OQL into OQL deB is straightforward and resembles the deBruijn translation of the -calculus <ref> [DeB72] </ref>. The process is in two phases. Firstly, every subexpression is associated with a scope list; a list of all variables (from first to most recently declared) defined within the scope of the subex-pression. Scope lists are propagated downward through the parse tree of the query.
Reference: [EL91] <author> Martin Erwig and Udo W. Lipeck. </author> <title> A functional DBPL revealing high level optimizations. </title> <editor> In Paris Kanellakis and Joachim W. Schmidt, editors, </editor> <title> Bulk Types & Persistent Data: </title> <booktitle> The Third International Workshop on Database Programming Languages, pages 306-, </booktitle> <address> Nafplion, Greece, August 1991. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: deB wfq Q, Eval JT JQK ? K * = Eval JQK *: Proof: Established trivially by setting Q 0 = and = * in Theorem 4.1. 5 Related Work We are not the first to suggest that a combinator-style for queries facilitates optimizer formalization and makes optimization more efficient. <ref> [EL91] </ref> consider the benefits of an FP-style ([Bac78]) query language from the perspective of optimization, but by proposing an FP-style query language.
Reference: [FH88] <author> Anthony J. Field and Peter G. Harrison. </author> <title> Functional Programming. </title> <publisher> International Computer Science Press. Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Since Turner's seminal paper [Tur79], combinators have been used within functional language compilers as internal representations of -expressions. The purpose of this is to make evaluation by graph reduction more efficient, as -expressions with free variables force unnecessary copying of potentially large function bodies <ref> [FH88] </ref>. Approaches to combinator translations can be classified according to whether the combinator set is fixed or variable. Fixed combinator sets consist of a finite set of combinators that are used as the target for all -expression translations.
Reference: [GHG + 92] <author> J.V. Guttag, J.J. Hornung, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specifications. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The third through fifth sections of Table 2 define the subset of KOLA's function and predicate formers that are necessary for the translation of OQL deB . (The description of the full algebra can be found in [Che95a] and its formal specification (written in Larch <ref> [GHG + 92] </ref>) is available at [Che95b].) General function formers (third section) include function composition ( ffi ), function pairing (h ; i), constant functions (K f ( )), curried functions (C f ( ; )), pairwise function application ( fi ), and conditional functions (con ( ; ; )). <p> The significance of our work lies in its implications for the design of efficient and simply formalized query optimizers. With respect to formalization, we have used the Larch <ref> [GHG + 92] </ref> specification tool LSL to formally specify KOLA and its associated rule language, and have used these specifications within the Larch theorem prover LP to verify the correctness of over 300 transformation rules. (For details of this work see [Che95a]).
Reference: [Hug84] <author> R. J. M. Hughes. </author> <title> The design and implementation of programming languages. </title> <type> PhD thesis, </type> <institution> University of Oxford, </institution> <year> 1984. </year>
Reference-contexts: all of the combinator translations we found described in the literature, KOLA most closely resembles Curien's combinator set, but adjusted to account for sets, and avoiding the overly powerful combinators (App and fl) that are expressive but difficult to optimize prior to their application to arguments. -lifting [Joh85] and supercombinators <ref> [Hug84] </ref> are translation techniques that use variable sets of com-binators. These techniques construct new combinators during each translation. The goal of this technique is 65 to keep the number of combinators in the result small (the combinators generated tend to be fairly compli-cated).
Reference: [Joh85] <author> T. Johnsson. </author> <title> Lambda lifting: transforming programs to recursive equations. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architecture, </booktitle> <publisher> LNCS. Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Of all of the combinator translations we found described in the literature, KOLA most closely resembles Curien's combinator set, but adjusted to account for sets, and avoiding the overly powerful combinators (App and fl) that are expressive but difficult to optimize prior to their application to arguments. -lifting <ref> [Joh85] </ref> and supercombinators [Hug84] are translation techniques that use variable sets of com-binators. These techniques construct new combinators during each translation. The goal of this technique is 65 to keep the number of combinators in the result small (the combinators generated tend to be fairly compli-cated).
Reference: [JRSB85] <author> M.S. Joy, V.J. Rayward-Smith, and F.W. Burton. </author> <title> Efficient combinator code. </title> <journal> Computer Languages, </journal> <volume> 10 </volume> <pages> 211-224, </pages> <year> 1985. </year>
Reference-contexts: It has been shown that this small set is sufficient to translate all of -calculus (in fact I is superfluous), but the size of the resulting code is too large to be of practical use <ref> [JRSB85] </ref>. Variations of the SKI combinator sets add additional, redundant combinators (e.g. B and Y) to reduce the size of the translated code. Curien proposed a set of Category Theory-inspired Combinators ([Cur93]) which he used to provide an alternative semantics for the -calculus.
Reference: [Kim82] <author> Won Kim. </author> <title> On optimizing an SQL-like nested query. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(3) </volume> <pages> 443-469, </pages> <month> September </month> <year> 1982. </year>
Reference-contexts: attributes g, h and k while objects in B have attributes f and j. select distinct (V 0 ! g) from A where (V 0 ! h) in 0 select distinct (V 0 ! f ) from B where (V 1 ! k) == (V 0 ! j) 1 Kim <ref> [Kim82] </ref> identified this query as a Type J nested query and illustrated that it was subject to a transfor mation into the form shown below: select distinct (V 1 ! g) from A; B where ((V 1 ! h) == (V 0 ! f )) and ((V 1 ! k) ==
Reference: [LMS + 93] <author> Theodore W. Leung, Gail Mitchell, Bharathi Subramanian, Bennet Vance, Scott L. Vandenberg, and Stanley B. Zdonik. </author> <title> The AQUA data model and algebra. </title> <booktitle> In Proc. 4th Int'l Workshop on Database Programming Languages, </booktitle> <address> New York, New York, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: But combinators are not easy for query writers to use and so a translation into this form is required. The problem addressed in this paper is to how to perform such translations. We introduce a technique that we have used to implement translators from both the AQUA <ref> [LMS + 93] </ref> and OQL query languages into KOLA [CZ96]; our combinator-based algebra. We describe the technique by presenting the OQL ! KOLA translator. The significance of our work lies in its implications for query optimizer design.
Reference: [Sch24] <author> M. Schonfinkel. </author> <title> Uber die bausteine der mathematischen logik. </title> <journal> Math. Annalen, </journal> <volume> 92 </volume> <pages> 305-316, </pages> <year> 1924. </year>
Reference-contexts: Fixed combinator sets consist of a finite set of combinators that are used as the target for all -expression translations. The best known of the fixed sets of combinators are the SKI combinator set, first introduced by Schonfinkel <ref> [Sch24] </ref>. It has been shown that this small set is sufficient to translate all of -calculus (in fact I is superfluous), but the size of the resulting code is too large to be of practical use [JRSB85]. Variations of the SKI combinator sets add additional, redundant combinators (e.g.

References-found: 23

