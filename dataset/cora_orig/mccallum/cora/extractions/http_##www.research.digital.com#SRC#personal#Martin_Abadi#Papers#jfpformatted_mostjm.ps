URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/jfpformatted_mostjm.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Title: 95 Baby Modula-3 and a theory of objects  d i g i t a l  
Author: Martin Abadi 
Address: 130 Lytton Avenue Palo Alto, California 94301  
Affiliation: Systems Research Center  
Date: February 2, 1993; revised December 2, 1992  
Abstract-found: 0
Intro-found: 1
Reference: <author> Abadi, M. and Plotkin, G. </author> <year> 1990. </year> <title> A per model of polymorphism and recursive types. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic In Computer Science Conference, </booktitle> <pages> pages 355-365. </pages> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: Here we sketch the modifications necessary for obtaining a per semantics, and then discuss the result. As Amadio and Cardone, we take a metric approach. Finding a per semantics along the lines of <ref> (Abadi and Plotkin, 1990) </ref> remains a challenge.
Reference: <author> Amadio, R. and Cardelli, L. </author> <year> 1991. </year> <title> Subtyping recursive types. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 104-118. </pages> <publisher> ACM. </publisher>
Reference-contexts: type of all objects that contain a field f of type Nat and a binary method m of return type Nat is the solution to the equation: X = [f : Nat; m : X!Nat] There has been interesting recent literature on the interaction between subtyping and recursive types (e.g., <ref> (Amadio and Cardelli, 1991) </ref>). In our language this interaction remains simple, and in particular it does not give rise to any special rules. The result that connects reduction and typing is the subject-reduction theorem. <p> This proof does not rely on any special rules for subtyping recursive types. However, in a more general context, rules for subtyping recursive types would be wanted (as in <ref> (Amadio and Cardelli, 1991) </ref>).
Reference: <author> Amadio, R. </author> <year> 1991. </year> <title> Recursion over realizability structures. </title> <journal> Information and Computation, </journal> <volume> 91(1) </volume> <pages> 55-85. </pages>
Reference-contexts: type of all objects that contain a field f of type Nat and a binary method m of return type Nat is the solution to the equation: X = [f : Nat; m : X!Nat] There has been interesting recent literature on the interaction between subtyping and recursive types (e.g., <ref> (Amadio and Cardelli, 1991) </ref>). In our language this interaction remains simple, and in particular it does not give rise to any special rules. The result that connects reduction and typing is the subject-reduction theorem. <p> This proof does not rely on any special rules for subtyping recursive types. However, in a more general context, rules for subtyping recursive types would be wanted (as in <ref> (Amadio and Cardelli, 1991) </ref>).
Reference: <author> Bainbridge, E. S., Freyd, P. J., Scedrov, A. and Scott, P. J. </author> <year> 1990. </year> <title> Functorial polymorphism. </title> <journal> Theoretical Computer Science, </journal> <volume> 70(1) </volume> <pages> 35-64. </pages> <note> Corrigendum in (3)71, </note> <month> April </month> <year> 1990, </year> <pages> page 431. </pages>
Reference-contexts: For example, we might expect that a function in Root!Nat be constant, but it need not be in the ideal semantics. A stronger semantics may be based on per models (e.g., (Amadio, 1991; Cardone, 1989; Abadi and Plotkin, 1990)) or, perhaps better, on parametric per models (e.g., <ref> (Bainbridge et al., 1990) </ref>). 32 For the sake of simplicity, we do not use pers in the body of this paper. Here we sketch the modifications necessary for obtaining a per semantics, and then discuss the result. As Amadio and Cardone, we take a metric approach.
Reference: <author> Bruce, K. </author> <year> 1993. </year> <title> Safe type checking in a statically-typed object-oriented programming language. </title> <booktitle> In Proceedings of the Twentieth Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 285-298. </pages> <publisher> ACM. </publisher>
Reference: <author> Cardelli, L. </author> <year> 1986. </year> <title> Amber. </title> <editor> In Cousineau, G., Curien, P.-L. and Robinet, B., editors, </editor> <booktitle> Com-binators and Functional Programming Languages. Lecture Notes in Computer Science No. </booktitle> <volume> 242. </volume> <publisher> Springer-Verlag. </publisher>
Reference: <author> Cardelli, L., Donahue, J., Glassman, L., Jordan, M., Kalsow, B. and Nelson, G. </author> <year> 1988. </year> <type> Modula-3 report. Research Report 31, </type> <institution> Digital Equipment Corporation Systems Research Center. </institution>
Reference-contexts: The methods ce, : : : , cj could be arbitrary 7 expressions in the original Modula-3 <ref> (Cardelli et al., 1988) </ref>. They must be top-level procedure constants in the current Modula-3. The Modula-3 syntax for reading a field and for assignment to a field is the same as here; the method invocation a:m is written a:m ().
Reference: <author> Cardelli, L. </author> <year> 1992. </year> <title> Extensible records in a pure calculus of subtyping. </title> <editor> In Gunter, C. and Mitchell, J. C., editors, </editor> <booktitle> Theoretical Aspects of Object-oriented Programming: Types, Semantics and Language Design. </booktitle> <address> MIT Press, </address> <note> to appear. A preliminary version has appeared as SRC Research Report No. 81. </note>
Reference: <author> Cardelli, L. and Nelson, G. </author> <year> 1993. </year> <title> Structured command semantics. </title> <type> Draft. </type>
Reference: <author> Cardone, F. </author> <year> 1989. </year> <title> Relational semantics for recursive types and bounded quantification. </title> <editor> In Ausiello, G., Dezani-Ciancaglini, M. and Ronchi Della Rocca, S., editors, </editor> <booktitle> Automata, Languages and Programming. Lecture Notes in Computer Science No. </booktitle> <volume> 372, </volume> <pages> pages 164-178. </pages> <publisher> Springer-Verlag. </publisher>
Reference: <author> Castagna, G., Ghelli, G. and Longo, G. </author> <year> 1992. </year> <title> A calculus for overloaded functions with subtyping. </title> <type> Technical Report LIENS-92-4, </type> <institution> Ecole Normale Superieure. </institution>
Reference: <author> Castagna, G. </author> <year> 1992. </year> <title> Strong typing in object-oriented paradigms. </title> <type> Technical Report LIENS-92-11, </type> <institution> Ecole Normale Superieure. </institution>
Reference: <author> Cook, W. R. </author> <year> 1989. </year> <title> A denotational semantics of inheritance. </title> <type> PhD thesis, </type> <institution> Brown University. </institution>
Reference: <author> Cook, W. R., Hill, W. L. and Canning, P. S. </author> <year> 1990. </year> <title> Inheritance is not subtyping. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135. </pages> <publisher> ACM. </publisher>
Reference-contexts: Bruce (1993) treats a class-based language called TOOPL. The language includes a rich object system. It does not allow explicit recursion; rather, some recursion is obtained through the class mechanisms. Bruce's technique draws on a fairly long line of previous papers, such as <ref> (Cook et al., 1990) </ref>. The method is essentially semantic, but parts of the constructions can be seen as translations into a language with recursion and F-bounded universal quantifiers. The result is rather complicated.
Reference: <author> Girard, J.-Y. </author> <year> 1972. </year> <institution> Interpretation Fonctionnelle et Elimination des Coupures de l'Arith-metique d'Ordre Superieur. These de doctorat d'etat, Universite Paris VII. </institution>
Reference-contexts: It seems somewhat remarkable that such a simple solution does not introduce any new problems. Its only apparent disadvantage is that it may be hard to formulate the modified interpretation of object types within a usual typed language such as System F <ref> (Girard, 1972) </ref>; and perhaps this is why it was not previously noticed. The modified definition can be given in our semantic framework.
Reference: <author> Gunter, C. </author> <year> 1992. </year> <title> Semantics of Programming Languages: Structures and Techniques. </title> <booktitle> Foundations of Computing Series. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts. </address>
Reference-contexts: These subsets are ideals (MacQueen et al., 1986). Ideals suffice for our purpose|studying type rules. However, they do not yield a proper model of typed lambda calculi, because they do not validate one of the standard equational rules for typed lambda calculi, the rule (see for example <ref> (Gunter, 1992, pp. 44, 265) </ref>). We discuss the rule and alternatives to ideals in Subsection 4.4. After some preliminaries, we define the ideal interpretation and then use it to prove the soundness of the type rules of Baby Modula-3. <p> The main results follow. The advantages of pers over ideals in the semantics of typed lambda calculi are well known (see for example <ref> (Gunter, 1992, p. 266) </ref>). Basically, pers validate the rule, according to which if b and b 0 are equal as elements of B for all x in A then fun (x : A)b and fun (x : A)b 0 are equal as elements of A!B.
Reference: <author> Guttag, J. V. and Horning, J. J., editors. </author> <year> 1993. </year> <title> Larch: Languages and Tools for Formal Specification. Texts and monographs in computer science. </title> <publisher> Springer-Verlag. </publisher>
Reference: <author> MacQueen, D., Plotkin, G. and Sethi, R. </author> <year> 1986. </year> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> <volume> 71 </volume> <pages> 95-130. </pages>
Reference-contexts: Subsection 4.1.3 relates this interpretation with the reduction rules of Section 3. The preliminary material on the untyped model is rather technical. It contains details not necessary for understanding most of the rest of the paper. 4.1.1 Preliminaries The underlying assumptions on the untyped model are much as in <ref> (MacQueen et al., 1986) </ref>; we assume a complete partial order (D; v) such that: * There is an increasing sequence p n : D!D of continuous projections with least upper bound the identity. <p> We postpone the study of these issues. 4.2 Semantics of types Having given the semantics in an untyped model, we view the types as certain subsets of this untyped model. These subsets are ideals <ref> (MacQueen et al., 1986) </ref>. Ideals suffice for our purpose|studying type rules. However, they do not yield a proper model of typed lambda calculi, because they do not validate one of the standard equational rules for typed lambda calculi, the rule (see for example (Gunter, 1992, pp. 44, 265)). <p> Proof First we check the claim for S. For R S (f : R), this holds because R S (f : R) does not depend on S. For R S (m : T ), this follows from the contractiveness of ! (proved in <ref> (MacQueen et al., 1986) </ref>), since R S (m : T ) uses S as argument to !.
Reference: <author> Mitchell, J. C. </author> <year> 1990. </year> <title> Toward a typed foundation for method specialization and inheritance. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-124. </pages> <publisher> ACM. </publisher>
Reference: <author> Mitchell, J. C., Honsell, F. and Fisher, K. </author> <year> 1993. </year> <title> A lambda calculus of objects and method specialization. </title> <booktitle> In Proceedings of the Eight IEEE Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 26-38. </pages> <publisher> IEEE Computer Society. </publisher>
Reference: <editor> Nelson, G., editor. </editor> <year> 1991. </year> <title> Systems Programming in Modula-3. </title> <publisher> Prentice Hall. 36 Pierce, </publisher> <editor> B. C. and Turner, D. N. </editor> <year> 1992. </year> <title> Statically typed multi-methods via partially abstract types. </title> <type> Draft. </type>
Reference-contexts: 1 Introduction Baby Modula-3 is a small, functional, object-oriented programming language with a static type system. It is intended as a distillation and an explanation of the core of Modula-3 <ref> (Nelson, 1991) </ref>, from a biased perspective: Baby Modula-3 includes the main features of Modula-3 related to objects, but not much else. To the theoretician, Baby Modula-3 provides a tractable, concrete example of an object-oriented language, and we use it to study the formal semantics of objects.
Reference: <author> Pierce, B. C. and Turner, D. N. </author> <year> 1993. </year> <title> Object-oriented programming without recursive types. </title> <booktitle> In Proceedings of the Twentieth Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 299-312. </pages> <publisher> ACM. </publisher>
Reference: <author> Plotkin, G. </author> <year> 1981. </year> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, Aarhus, Denmark. </institution>
Reference: <author> Steele, G. L. </author> <year> 1990. </year> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Bedford, Massachusetts, </address> <note> second edition. </note>
Reference-contexts: Overriding at the type level means declaring a type with a new default.) Overriding at the value level does appear in other languages (e.g., <ref> (Steele, 1990) </ref>) and it is noticeably absent from the class-based languages discussed in Section 5. We include it for completeness and because its formal treatment remains simple, perhaps surprisingly so. 3.2 Type rules Subsections 3.2.1 to 3.2.5 introduce the type rules of Baby Modula-3. <p> Castagna, Ghelli, and Longo (1992; 1992) suggest a very different view of object-oriented programming languages. They present a core calculus, with classes, sub-typing, and overloaded functions. It leads to an original treatment of constructs such as multiple dispatch in the CLOS style <ref> (Steele, 1990) </ref>. (All the other papers discussed here deal only with single dispatch.) Modula-3 is a rather traditional language, with no classes, and so is Baby Modula-3. We present a semantic definition, but not a translation into a standard typed lambda calculus.
Reference: <author> Wand, M. </author> <year> 1987. </year> <title> Complete type inference for simple objects. </title> <booktitle> In Proceedings of the Second Symposium on Logic in Computer Science, </booktitle> <pages> pages 37-44. </pages> <booktitle> IEEE Computer Society. Corrigendum in Proceedings of the Third Symposium on Logic in Computer Science, </booktitle> <pages> page 132, </pages> <year> 1988. </year>
References-found: 25

