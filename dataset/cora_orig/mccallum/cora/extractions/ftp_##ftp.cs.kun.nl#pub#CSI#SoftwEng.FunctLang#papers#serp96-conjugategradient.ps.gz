URL: ftp://ftp.cs.kun.nl/pub/CSI/SoftwEng.FunctLang/papers/serp96-conjugategradient.ps.gz
Refering-URL: http://www.cs.kun.nl/~clean/Clean.Papers.html
Root-URL: 
Title: A Clean Conjugate Gradient Algorithm  
Author: P.R. Serrarens 
Address: Nijmegen, The Netherlands  
Affiliation: Computer Science Institute, University of Nijmegen  
Abstract: This paper shows the usage of functional programming in the area of scientific computing. It is an important area because time and space efficiency are crucial: many scientific programs work with large data sets and run for a long time. The paper shows that functional programming can be a real alternative to imperative methods. The example used in this paper is the conjugate gradient algorithm. It will show that the functional way is cleaner, easier to adapt and almost as quick and lean as imperative implementations. We are in the middle of a functional programming revolution. After years of relative silence, the late 1980's brought new interest in functional programming. This lead to the development of a large number of compilers with often remarkable achievements. Nowadays many problems of functional languages have been tackled, and it seems to be that functional programming is a real universal programming paradigm that can replace the traditional imperative languages. As said, many problems have been tackled, but there are still some doubts about the usability of functional programming languages in a number of area's. One of these is the Formula One of computer science: scientific computing, setting extreme requirements on speed and memory usage, two topics which are traditionally weak points of functional programming. Though, even this is being tackled at the moment. Sisal has already gained quite some success on sequential and parallel architectures, being even faster than Fortran [Can92]. In this paper we want to show that a general purpose lazy functional language can also perform well in scientific computing, being as quick as C. An algorithm used many times in scientific computing is the conjugate gradient algorithm. It's an iterative method to solve the equation Ax = b, for a given matrix A and vector b. The paper does not explain the algorithm itself; it's about implementing it in Clean, a lazy functional programming language [PvE93], in a way that results in a well build and efficient program. One of the nice things about functional programming is that one can write good specifications with it. We will use this property to build up our implementation of the conjugate gradient algorithm. Beginning with a specification of the algorithm, we will look what parts are lacking and design those parts. Hereafter we will look at the performance of the program. Next, in section 3 and 4, two ways will be discussed to achieve better performance, namely map fusion and array update. The new, more efficient, Clean program will be compared with C again in section 5. Lastly, the results will be discussed in 6 and current and future research will be described. 
Abstract-found: 1
Intro-found: 1
Reference: [BS93] <author> E. Barendsen and J.E.W. Smetsers. </author> <title> Conventional and uniqueness typing in graph rewrite systems. </title> <type> Technical Report CSI-R9328, </type> <institution> Computer Science Institute, Faculty of Mathematics and Informatics, University of Nijmegen, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Nowadays we can do update-in-place through of a number of techniques like uniqueness typing <ref> [BS93] </ref>, monads [LJ94] and copy elimination [GH89]. In our implementation of the conjugate gradient algorithm, we didn't use the uniqueness typing system of Clean. Instead of update-in-place, new vectors were created everywhere.
Reference: [Can92] <author> D. Cann. </author> <title> Retire fortran? a debate rekindled. </title> <journal> Communications of the ACM, </journal> <volume> 35(8) </volume> <pages> 81-89, </pages> <month> Aug </month> <year> 1992. </year>
Reference-contexts: In table below the effect of using uniqueness can be seen. We were able to halve the heap size without loss of efficiency, the garbage collection times are even lower than without update-in-place. The average performance increase is 40%. So in contrary to results from Sisal <ref> [Can92] </ref>, we don't suffer heavily when not using update-in-place. This is because strict functional languages create much more closures than lazy functional languages, because they lack sharing.
Reference: [GH89] <author> K. Gopinath and J.L. Hennesy. </author> <title> Copy elimination in functional languages. </title> <booktitle> In Proceedings of POPL'89, </booktitle> <year> 1989. </year> <month> 10 </month>
Reference-contexts: Nowadays we can do update-in-place through of a number of techniques like uniqueness typing [BS93], monads [LJ94] and copy elimination <ref> [GH89] </ref>. In our implementation of the conjugate gradient algorithm, we didn't use the uniqueness typing system of Clean. Instead of update-in-place, new vectors were created everywhere.
Reference: [GLJ93] <author> A. Gill, J. Launchbury, and S.L. Peyton Jones. </author> <title> A short cut to deforestation. </title> <booktitle> In Functional Programming and Computer Architecture (FPCA'93), </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: The technique for doing such transformations is usually called deforestation and many work has already been done on that topic, with the paper of Wadler [Wad90] begin one of the first. However, only one usable implementation of it exists <ref> [GLJ93] </ref>, which is only applicable in a subset of cases. It only works for functions which take one list. It cannot deforest operations like addition for both arguments. 4 Array updates Functional languages used to be rejected because they couldn't do update-in-place.
Reference: [KGGK94] <author> V. Kumar, A. Grama, A. Gupta, and G. Karypis. </author> <title> Introduction to Parallel Computing, Design and Analysis of Algorithms. </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <address> California, </address> <year> 1994. </year>
Reference-contexts: delta1 d` where h = a #* d tau = delta0 / InnerProd d h x` = x + tau .* d delta1 = InnerProd g` g` beta = delta1 / delta0 d` = beta .* d - g` A more detailed description of the algorithm can be found in <ref> [KGGK94] </ref>. For this paper it's sufficient to say that the algorithm approximates the equation Ax = b, with x being an unknown vector, A a given matrix and b a given vector. 1.1 The Vectors Vectors can be implemented easily in Clean, since we have arrays.
Reference: [LJ94] <author> J. Launchbury and S.L. Peyton Jones. </author> <title> Lazy functional state threads. </title> <booktitle> In Programming Languages Design and Implementation, </booktitle> <address> Orlando, 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Nowadays we can do update-in-place through of a number of techniques like uniqueness typing [BS93], monads <ref> [LJ94] </ref> and copy elimination [GH89]. In our implementation of the conjugate gradient algorithm, we didn't use the uniqueness typing system of Clean. Instead of update-in-place, new vectors were created everywhere.
Reference: [PvE93] <author> M.J. Plasmeijer and M.C.J.D. van Eekelen. </author> <title> Functional Programming and Parallel Graph Rewriting. </title> <publisher> Addison-Wesley Publishers Ltd., </publisher> <year> 1993. </year>
Reference: [Wad90] <author> P. Wadler. </author> <title> Deforestation: Transforming programs to eliminate trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 73 </volume> <pages> 231-248, </pages> <year> 1990. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: The technique for doing such transformations is usually called deforestation and many work has already been done on that topic, with the paper of Wadler <ref> [Wad90] </ref> begin one of the first. However, only one usable implementation of it exists [GLJ93], which is only applicable in a subset of cases. It only works for functions which take one list.
References-found: 8

