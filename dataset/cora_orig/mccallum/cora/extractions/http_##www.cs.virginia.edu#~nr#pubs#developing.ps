URL: http://www.cs.virginia.edu/~nr/pubs/developing.ps
Refering-URL: http://www.cs.virginia.edu/~nr/activities.html
Root-URL: http://www.cs.virginia.edu
Phone: 08544  
Title: Developing Formally Verified Ada Programs grams. The next step in improving the prototype editor is
Author: Norman Ramsey 
Address: Princeton, New Jersey  
Note: The program editor is designed to be used on program fragments, not just complete pro This research has been sponsored by the USAF, Rome Air Development Center, under contract number F30602-86-C-0071. Current address:  
Date: October 10, 1988  
Affiliation: Odyssey Research Associates  Department of Computer Science, Princeton University,  
Abstract: Odyssey Research Associates has undertaken a study of the feasibility of developing formally verified Ada programs. We have designed a specification language for sequential Ada programs. It is a member of the Larch family of specification languages. We have built a prototype program editor that is intended to help programmers develop programs and proofs from specifications, as advocated by Di-jkstra and Gries [1, 2]. It contains predicate transformers, which compute wp (an approximation to the weakest precondition of a program), and it generates verification conditions. The semantics of the specification language and the definition of the predicate transformers are derivable from a denotational definition of sequential Ada. The predicate transformers can be proved sound with respect to these definitions by structural induction on programs. The denotational-style definition of the predicate transformers is well suited to an implementation as an attribute grammar. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. W. Dijsktra, </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: Edsger Dijkstra and David Gries have stressed that a program should not face verification as a hurdle after development, but should be developed in such a way as to ensure its correctness <ref> [1, 2] </ref>. One should begin with a formal specification, and the development of the program and its proof should follow from that specification. Gries, in his Science of Programming, suggests ways to use a specification to guide the development of a program and its proof.
Reference: [2] <editor> D. Gries, </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Edsger Dijkstra and David Gries have stressed that a program should not face verification as a hurdle after development, but should be developed in such a way as to ensure its correctness <ref> [1, 2] </ref>. One should begin with a formal specification, and the development of the program and its proof should follow from that specification. Gries, in his Science of Programming, suggests ways to use a specification to guide the development of a program and its proof. <p> A user of Penelope begins by writing down a formal specification of an Ada subprogram using Larch/Ada. (The formal specification takes the form of an Ada "specification" augmented with subprogram annotations.) He or she then builds the subprogram body, working backwards as described by Gries <ref> [2] </ref>. Pene-lope can be instructed to display weakest preconditions at any point, and also to display any verification conditions that may be generated. <p> The proving component is primitive; the proof of a program like binary search takes up many pages. Formal foundations The formal foundation of Larch/Ada has two parts, one dealing with assertions and another dealing with annotations. The assertion part covers the seman 2 Actually, as in Gries <ref> [2] </ref>, the system works with an approximation to the weakest precondition, called wp. tics of the Larch/Ada assertion language as defined using Larch Shared Language specifications. This semantics is determined entirely by the semantics of the Larch Shared Language, and is therefore independent of Ada.
Reference: [3] <author> J. V. Guttag, J. J. Horning, and J. M. Wing, </author> <title> "Larch in five easy pieces," </title> <type> Tech. Rep. TR 5, </type> <institution> DEC/SRC, </institution> <month> July </month> <year> 1985. </year>
Reference-contexts: The prototype implementation supports a subset of Ada that is roughly "PASCAL with exceptions." We have completed some of the mathematics that supports the Larch/Ada-88 definition and the Penelope implementation. Specification language The Larch/Ada-88 specification language is part of the Larch family of two-tiered specification languages <ref> [3, 4] </ref>. 1 The two-tiered approach separates the specification of individual program modules from the specification of underlying abstractions. The Larch Shared Language is used to specify the underlying abstractions; for example, it can be used to define the notions of array, list, set, bag, and so on.
Reference: [4] <author> J. M. Wing, </author> <title> "Writing Larch interface language specifications," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 9, </volume> <pages> pp. 1-24, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: The prototype implementation supports a subset of Ada that is roughly "PASCAL with exceptions." We have completed some of the mathematics that supports the Larch/Ada-88 definition and the Penelope implementation. Specification language The Larch/Ada-88 specification language is part of the Larch family of two-tiered specification languages <ref> [3, 4] </ref>. 1 The two-tiered approach separates the specification of individual program modules from the specification of underlying abstractions. The Larch Shared Language is used to specify the underlying abstractions; for example, it can be used to define the notions of array, list, set, bag, and so on. <p> Using Larch/Ada As an example, here is a Larch/Ada specification for some set operations. Jeannette Wing used these operators in her presentation of a Larch interface language for CLU <ref> [4] </ref>. As she did, we will use a Larch Shared Language description of sets and set operations. The trait describing these operations, called SetOfE, is shown in Figure 1. 3 These are called "ghost variables" by Gries and Dijkstra; the name "virtual variable" is from Luck-ham [5]. <p> In the IN annotation, all variables are implicitly modified by IN.) Because no side effect annotation is present, choose may not modify or read any global variables. for a set package. This package specifies the same operators as the similar example in Wing <ref> [4] </ref>. Formal foundation of Larch/Ada and Penelope Connecting Ada to a denotational model Formal verification of Ada programs must be based on a formal definition of the Ada language itself, but at this time there is no official formal definition of Ada.
Reference: [5] <author> D. C. Luckham et al., "Anna: </author> <title> A language for annotating Ada programs," </title> <type> tech. rep., </type> <institution> Stanford University, </institution> <year> 1986. </year> <title> The Anna reference manual. </title>
Reference-contexts: Ada programs by attaching assertions at certain points, like the entry and exit points of subprograms. The specification constructs of Larch/Ada are called annotations, since most of them are derived from similar constructs in Anna <ref> [5] </ref>. Implementation Most verification sofware works in batch mode [6, 7]. The user writes a program, supplies a specification and appropriate assertions, and then submits it all to a verification condition generator. The resulting verification conditions must be shown to hold. <p> As she did, we will use a Larch Shared Language description of sets and set operations. The trait describing these operations, called SetOfE, is shown in Figure 1. 3 These are called "ghost variables" by Gries and Dijkstra; the name "virtual variable" is from Luck-ham <ref> [5] </ref>. We begin our example with the specification of a "choose" procedure that selects a member of a set, removes it from the set, and returns it. <p> The most important contribution of the Stanford Pascal Verifier project was probably the Nelson-Oppen method of combining decision procedures [13]. The Anna project is an effort to introduce formal specification to Ada programmers by providing specification constructs which can be checked at run time <ref> [5] </ref>. The aim of AVA project is to define a verifiable subset of Ada and to give it a formal semantics using Boyer-Moore logic [19, 20]. The AVA language is essentially a subset of that implemented in the Penelope prototype; it omits exception handlers and raise statements.
Reference: [6] <author> D. I. Good, R. L. Akers, and L. M. Smith, </author> <title> "Report on Gypsy 2.05," </title> <type> tech. rep., </type> <institution> Computational Logic Inc., </institution> <year> 1986. </year>
Reference-contexts: Ada programs by attaching assertions at certain points, like the entry and exit points of subprograms. The specification constructs of Larch/Ada are called annotations, since most of them are derived from similar constructs in Anna [5]. Implementation Most verification sofware works in batch mode <ref> [6, 7] </ref>. The user writes a program, supplies a specification and appropriate assertions, and then submits it all to a verification condition generator. The resulting verification conditions must be shown to hold. A verification condition for a program is an assertion whose truth guarantees that the program satisfies its specification. <p> AFFIRM, built at USC-ISI, was the first verification system to use both algebraic specifications and a rewrite rule prover [17]. The Gypsy system was the first verification system to handle a form of concurrency <ref> [6] </ref>. The Stanford Pascal Verifier was the first verification system to handle a real programming language [18]. The most important contribution of the Stanford Pascal Verifier project was probably the Nelson-Oppen method of combining decision procedures [13].
Reference: [7] <author> J. Crow, S. Jefferson, R. Lee, M. Melliar-Smith, J. Rushby, R. Schwartz, R. Shostak, and F. von Henke, </author> <title> "Preliminary definition of the revised SPECIAL specification language," </title> <type> tech. rep., </type> <institution> SRI International, </institution> <year> 1986. </year>
Reference-contexts: Ada programs by attaching assertions at certain points, like the entry and exit points of subprograms. The specification constructs of Larch/Ada are called annotations, since most of them are derived from similar constructs in Anna [5]. Implementation Most verification sofware works in batch mode <ref> [6, 7] </ref>. The user writes a program, supplies a specification and appropriate assertions, and then submits it all to a verification condition generator. The resulting verification conditions must be shown to hold. A verification condition for a program is an assertion whose truth guarantees that the program satisfies its specification.
Reference: [8] <author> T. Reps and T. Teitelbaum, </author> <title> The Synthesizer Generator Reference Manual. </title> <institution> Department of Computer Science, Cornell University, </institution> <year> 1987. </year>
Reference-contexts: Using Penelope, programmers can examine weakest preconditions as they are computed and can use them to guide program development. Program fragments can be proved correct, then picked up and placed in larger contexts. We have built the Penelope editor by using the Cornell Synthesizer Generator <ref> [8, 9] </ref>. Penelope can be used to create and edit abstract syntax trees that represent parts of an annotated Ada program. The interface is that of a traditional syntax-directed editor in which the user may use a mouse or an EMACS-like command set to manipulate trees. <p> We plan to extend the Penelope prototype to read definitions of extensions to the assertion language. We plan to supplement it with a tool that will help prove Penelope verification conditions. Status of the implementation Penelope is implemented using the Cornell synthesizer generator <ref> [8] </ref>. The Cornell synthesizer generator accepts as input a description of an attribute grammar and compiles this description into a syntax-directed editor which can compute 8 and display the values of attributes.
Reference: [9] <author> T. Reps, </author> <title> Generating Language-Based Environments. </title> <publisher> MIT Press, </publisher> <year> 1984. </year>
Reference-contexts: Using Penelope, programmers can examine weakest preconditions as they are computed and can use them to guide program development. Program fragments can be proved correct, then picked up and placed in larger contexts. We have built the Penelope editor by using the Cornell Synthesizer Generator <ref> [8, 9] </ref>. Penelope can be used to create and edit abstract syntax trees that represent parts of an annotated Ada program. The interface is that of a traditional syntax-directed editor in which the user may use a mouse or an EMACS-like command set to manipulate trees. <p> The heart of this editor is an algorithm which, when the edited tree is changed, computes and propagates the changes in attribute values <ref> [9] </ref>. We think of Penelope as having three components: predicate transformation, proving, and simplification. Predicate transformation is central. That component reads and interprets the Larch/Ada annotations, computes wp, and generates verification conditions. The user controls which intermediate values of wp are displayed and which verification conditions are displayed.
Reference: [10] <author> W. Polak, </author> <title> "A technique for writing predicate transformers." </title> <type> Unpublished manuscript. </type>
Reference-contexts: The predicate transformers define a function from a Larch/Ada specification and an annotated Ada program to a set of verification conditions. The transformers are based on a continuation semantics for the sequential part of Ada. As part of this work, Polak <ref> [10] </ref> has shown how to establish a formal connection between a continuation semantics and predicate transformers. To define the predicate transformers, he lets the denotation of a program be a function on terms of the Larch/Ada assertion language. <p> Second, the semantics of the Ada types is not part of the definition; instead, the semantics of Ada types is defined by Larch Shared Language specifications. The technique used for deriving predicate transformers from a denotational semantics is one developed by Polak <ref> [12, 10] </ref>. The current definition of the predicate transformers used in Penelope does not provide for proofs of termination. Here we give an example that shows what we mean when we say that Larch/Ada and Penelope are formally based. <p> The truth of a verification condition must be independent of state, so the function vcgen is sound if, for any v 2 V , 8x 2 X (M A (vcgen (v))) ) M S (v)(M P (v)): Polak <ref> [10] </ref> goes into more detail, giving a complete definition of vcgen for a small programming language P . He describes a way of deriving vcgen from the semantics of P and sketches a proof of soundness that uses structural induction on programs.
Reference: [11] <author> C. A. R. Hoare, </author> <title> "Proof of correctness of data representations," </title> <journal> Acta Informatica, </journal> <volume> vol. 1, </volume> <pages> pp. 271-281, </pages> <year> 1972. </year>
Reference-contexts: Thus, a user writing an arbitrary-precision arithmetic package might implement registers using arrays, and would then define an abstraction function from arrays to registers. The proofs of correctness of implementations of abstract data types are as described by Hoare <ref> [11] </ref>; the abstraction function is used to rewrite a specification that was in terms of an abstract type to a new specification in terms of a concrete type. Using Larch/Ada As an example, here is a Larch/Ada specification for some set operations.
Reference: [12] <author> W. Polak, </author> <title> "Program verification based on denotational semantics," </title> <booktitle> in Principles of Programming Languages, </booktitle> <year> 1981. </year>
Reference-contexts: Second, the semantics of the Ada types is not part of the definition; instead, the semantics of Ada types is defined by Larch Shared Language specifications. The technique used for deriving predicate transformers from a denotational semantics is one developed by Polak <ref> [12, 10] </ref>. The current definition of the predicate transformers used in Penelope does not provide for proofs of termination. Here we give an example that shows what we mean when we say that Larch/Ada and Penelope are formally based.
Reference: [13] <author> G. Nelson and D. C. Oppen, </author> <title> "Simplification by cooperating decision procedures," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 1, </volume> <pages> pp. 245-257, </pages> <month> Oct. </month> <year> 1979. </year>
Reference-contexts: Simplifying such terms is the next step in improving our implementation. Rather than build an arithmetic simplifier from scratch, we plan to connect an existing simplifier to the Penelope editor. The simplifier that we plan to use is based on the Nelson-Oppen procedure for combining decision procedures <ref> [13, 14] </ref>. <p> The Stanford Pascal Verifier was the first verification system to handle a real programming language [18]. The most important contribution of the Stanford Pascal Verifier project was probably the Nelson-Oppen method of combining decision procedures <ref> [13] </ref>. The Anna project is an effort to introduce formal specification to Ada programmers by providing specification constructs which can be checked at run time [5].
Reference: [14] <author> T. </author> <title> Redmond, "Simplifier description," </title> <type> Tech. Rep. </type> <institution> ATR-85 (8354)-8, Aerospace, </institution> <month> Nov. </month> <year> 1985. </year>
Reference-contexts: Simplifying such terms is the next step in improving our implementation. Rather than build an arithmetic simplifier from scratch, we plan to connect an existing simplifier to the Penelope editor. The simplifier that we plan to use is based on the Nelson-Oppen procedure for combining decision procedures <ref> [13, 14] </ref>.
Reference: [15] <author> S. Garland and J. V. Guttag, </author> <title> "An overview of LP, the Larch prover," </title> <booktitle> in Third International Conference on Rewriting Techniques and Applications, </booktitle> <year> 1988. </year>
Reference-contexts: Related work Researchers at MIT and DEC SRC have developed several tools that manipulate Larch Shared Language traits. The Larch prover, LP, can read a description of an equational theory and attempt to prove sentences in that theory, primarily by term rewriting <ref> [15] </ref>.
Reference: [16] <author> S. </author> <title> Garland. </title> <type> Private communication. </type>
Reference-contexts: for input to LP: an axiomatization of the trait and a command script for discharging the proof obligations associated with that trait. (Not all of the proof obligations described in the reference manual for the shared language have been implemented yet.) LC supports the shared language's mixfix and overloaded operators <ref> [16] </ref>. AFFIRM, built at USC-ISI, was the first verification system to use both algebraic specifications and a rewrite rule prover [17]. The Gypsy system was the first verification system to handle a form of concurrency [6].
Reference: [17] <author> D. R. Musser, </author> <title> "Abstract data type specifications in the AFFIRM system," </title> <booktitle> in Proceedings of the Specifications of Reliable Software, </booktitle> <pages> pp. 47-57, </pages> <publisher> IEEE Computer Society, </publisher> <month> Apr. </month> <year> 1979. </year>
Reference-contexts: AFFIRM, built at USC-ISI, was the first verification system to use both algebraic specifications and a rewrite rule prover <ref> [17] </ref>. The Gypsy system was the first verification system to handle a form of concurrency [6]. The Stanford Pascal Verifier was the first verification system to handle a real programming language [18].
Reference: [18] <author> D. C. Luckham et al., </author> <title> "Stanford Pascal Verifier user manual," </title> <type> Tech. Rep. </type> <institution> STAN-CS-79-731, Stanford University, </institution> <month> Mar. </month> <year> 1979. </year> <month> 13 </month>
Reference-contexts: The Gypsy system was the first verification system to handle a form of concurrency [6]. The Stanford Pascal Verifier was the first verification system to handle a real programming language <ref> [18] </ref>. The most important contribution of the Stanford Pascal Verifier project was probably the Nelson-Oppen method of combining decision procedures [13]. The Anna project is an effort to introduce formal specification to Ada programmers by providing specification constructs which can be checked at run time [5].
Reference: [19] <author> M. K. Smith, </author> <title> "A verifiable Ada," </title> <journal> Ada Letters, </journal> <volume> vol. 8, </volume> <pages> pp. 136-142, </pages> <note> July/August 1988. In the Formal Methods Committee report. </note>
Reference-contexts: The Anna project is an effort to introduce formal specification to Ada programmers by providing specification constructs which can be checked at run time [5]. The aim of AVA project is to define a verifiable subset of Ada and to give it a formal semantics using Boyer-Moore logic <ref> [19, 20] </ref>. The AVA language is essentially a subset of that implemented in the Penelope prototype; it omits exception handlers and raise statements. Acknowledgements The work described herein was done at Odyssey Research Associates with Wolfgang Polak, Carla Marceau, David Guaspari, C. Douglas Harper, and Doug Weber.

References-found: 19

