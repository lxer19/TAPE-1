URL: ftp://ftp.cs.umass.edu/pub/osl/papers/tse92.ps.Z
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Title: Working with Persistent Objects: To Swizzle or Not to Swizzle 1  
Author: J. Eliot B. Moss 
Keyword: Index terms: Mneme (persistent object store), object store, performance measurement, performance modeling, persistent programming, pointer swizzling, work session.  
Date: July 19, 1991  
Note: Submitted to IEEE Transactions on Computers  
Address: Amherst, Massachusetts 01003  
Affiliation: Computer and Information Science University of Massachusetts  
Abstract: Pointer swizzling 3 is the conversion of database objects between an external form (object identifiers) and an internal form (direct memory pointers). Swizzling is used in some object-oriented databases, persistent object stores, and persistent and database programming language implementations to speed manipulation of memory resident data. Here we describe a simplifying model of application behavior, revealing those aspects where swizzling is most relevant in both benefits and costs. The model has a number of parameters, which we have measured for a particular instance of the Mneme persistent object store, varying the swizzling technique used. The results confirm most of the intuitive, qualitative tradeoffs, with the quantitative data showing that some performance differences between schemes are smaller than might be expected. However, there are some interesting effects that run counter to naive intuition, most of which we explain using deeper analysis of the algorithms and data structures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. N. Khoshafian and G. P. Copeland, </author> <title> Object identity, </title> <booktitle> in OOPSLA [50], </booktitle> <pages> pp. 406-416. </pages>
Reference-contexts: 1 Introduction We are concerned with programs that read and write persistent objects maintained in a database or object store. Any given persistent object can refer to other persistent objects within the same database. Such references are expressed via unique object identifiers (oids), as in (for example) <ref> [1] </ref>. We are specifically concerned with systems in which oids are not virtual memory addresses. The central question we explore is whether it is profitable to replace oid references between memory resident persistent objects with direct pointers.
Reference: [2] <author> T. Kaehler and G. Krasner, </author> <title> LOOMlarge object-oriented memory for Smalltalk-80 systems, in Smalltalk-80: Bits of History, Words of Advice (G. </title> <editor> Krasner, ed.), ch. </editor> <volume> 14, </volume> <pages> pp. 251-270, </pages> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: We are specifically concerned with systems in which oids are not virtual memory addresses. The central question we explore is whether it is profitable to replace oid references between memory resident persistent objects with direct pointers. Such conversion is called pointer swizzling; similar techniques were used in LOOM <ref> [2, 3] </ref>. The basic tradeoff in swizzling is obvious: the conversion costs something up front (and at the end of the program, to convert pointers back to oids), but saves a little each time a reference is followed. <p> POSs and storage managers include the Exodus storage manager [23, 32], O 2 [29], and Mneme 4 [33, 34, 35]. Mneme is the POS used for this study. There have also been a number of designs related to virtual memory such as <ref> [2, 3, 36, 37, 38] </ref>. Object servers include ObServer [39] and Gemstone [40]. We know of no prior studies of swizzling performance, and hence can offer no comparison with directly related work.
Reference: [3] <author> T. Kaehler, </author> <title> Virtual memory on a narrow machine for an object-oriented language, </title> <booktitle> in OOPSLA [50], </booktitle> <pages> pp. 87-106. </pages>
Reference-contexts: We are specifically concerned with systems in which oids are not virtual memory addresses. The central question we explore is whether it is profitable to replace oid references between memory resident persistent objects with direct pointers. Such conversion is called pointer swizzling; similar techniques were used in LOOM <ref> [2, 3] </ref>. The basic tradeoff in swizzling is obvious: the conversion costs something up front (and at the end of the program, to convert pointers back to oids), but saves a little each time a reference is followed. <p> POSs and storage managers include the Exodus storage manager [23, 32], O 2 [29], and Mneme 4 [33, 34, 35]. Mneme is the POS used for this study. There have also been a number of designs related to virtual memory such as <ref> [2, 3, 36, 37, 38] </ref>. Object servers include ObServer [39] and Gemstone [40]. We know of no prior studies of swizzling performance, and hence can offer no comparison with directly related work.
Reference: [4] <author> M. Atkinson, K. Chisolm, and P. Cockshott, </author> <title> PS-algol: an Algol with a persistent heap, </title> <journal> ACM SIGPLAN Not., </journal> <volume> vol. 17, </volume> <pages> pp. 24-31, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: A persistent programming language (PPL) is a programming language that includes a persistent memory area (e.g., a heap of objects) that outlives the execution of any individual program. PPLs have most often been designed as extensions of non-persistent programming languages. PS-Algol <ref> [4] </ref> introduced the concept of a PPL. The E language [5, 6, 7, 8] is a more recent PPL based on C++; Alltalk [9, 10] is one based on Smalltalk [11].
Reference: [5] <author> J. E. Richardson and M. J. Carey, </author> <title> Programming constructs for database system implementations in EXODUS, </title> <booktitle> in SIGMOD [51], </booktitle> <pages> pp. 208-219. </pages>
Reference-contexts: PPLs have most often been designed as extensions of non-persistent programming languages. PS-Algol [4] introduced the concept of a PPL. The E language <ref> [5, 6, 7, 8] </ref> is a more recent PPL based on C++; Alltalk [9, 10] is one based on Smalltalk [11]. A database programming language (DBPL) is similar to a PPL but adds database features such as bulk data (sets or relations) and attribute based retrieval (queries).
Reference: [6] <author> J. E. Richardson and M. J. Carey, </author> <title> Persistence in the E language: Issues and implementation, </title> <type> Computer Sciences Technical Report 791, </type> <institution> University of Wisconsin, Madison, WI, </institution> <year> 1988. </year>
Reference-contexts: PPLs have most often been designed as extensions of non-persistent programming languages. PS-Algol [4] introduced the concept of a PPL. The E language <ref> [5, 6, 7, 8] </ref> is a more recent PPL based on C++; Alltalk [9, 10] is one based on Smalltalk [11]. A database programming language (DBPL) is similar to a PPL but adds database features such as bulk data (sets or relations) and attribute based retrieval (queries). <p> While it would take us too far off the subject here, we note that it may be possible to use compiler techniques and program annotations to substantially reduce the number of object residency checks performed at run time <ref> [47, 48, 6, 7, 8] </ref>. This suggests that software-versus hardware-mediated object residency checks may not be a substantial performance issue, and that the strongest argument in favor of page trapping techniques for object faulting is that they do not require compiler support to be transparent to the programmer.
Reference: [7] <author> J. E. Richardson, E: </author> <title> A Persistent Systems Implementation Language. </title> <type> PhD thesis, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI, </institution> <month> Aug. </month> <year> 1989. </year> <note> Available as Computer Sciences Technical Report #868. </note>
Reference-contexts: PPLs have most often been designed as extensions of non-persistent programming languages. PS-Algol [4] introduced the concept of a PPL. The E language <ref> [5, 6, 7, 8] </ref> is a more recent PPL based on C++; Alltalk [9, 10] is one based on Smalltalk [11]. A database programming language (DBPL) is similar to a PPL but adds database features such as bulk data (sets or relations) and attribute based retrieval (queries). <p> While it would take us too far off the subject here, we note that it may be possible to use compiler techniques and program annotations to substantially reduce the number of object residency checks performed at run time <ref> [47, 48, 6, 7, 8] </ref>. This suggests that software-versus hardware-mediated object residency checks may not be a substantial performance issue, and that the strongest argument in favor of page trapping techniques for object faulting is that they do not require compiler support to be transparent to the programmer.
Reference: [8] <author> J. E. Richardson, </author> <title> Compiled item faulting: A new technique for managing I/O in a persistent language, </title> <editor> in Dearle et al. </editor> <volume> [52], </volume> <pages> pp. 3-16. </pages>
Reference-contexts: PPLs have most often been designed as extensions of non-persistent programming languages. PS-Algol [4] introduced the concept of a PPL. The E language <ref> [5, 6, 7, 8] </ref> is a more recent PPL based on C++; Alltalk [9, 10] is one based on Smalltalk [11]. A database programming language (DBPL) is similar to a PPL but adds database features such as bulk data (sets or relations) and attribute based retrieval (queries). <p> While it would take us too far off the subject here, we note that it may be possible to use compiler techniques and program annotations to substantially reduce the number of object residency checks performed at run time <ref> [47, 48, 6, 7, 8] </ref>. This suggests that software-versus hardware-mediated object residency checks may not be a substantial performance issue, and that the strongest argument in favor of page trapping techniques for object faulting is that they do not require compiler support to be transparent to the programmer.
Reference: [9] <author> S. Riegel, F. Mellender, and A. Straw, </author> <title> Integration of database management with an object-oriented programming language, </title> <booktitle> in Dittrich [53], </booktitle> <pages> pp. 317-322. </pages>
Reference-contexts: PPLs have most often been designed as extensions of non-persistent programming languages. PS-Algol [4] introduced the concept of a PPL. The E language [5, 6, 7, 8] is a more recent PPL based on C++; Alltalk <ref> [9, 10] </ref> is one based on Smalltalk [11]. A database programming language (DBPL) is similar to a PPL but adds database features such as bulk data (sets or relations) and attribute based retrieval (queries).
Reference: [10] <author> A. Straw, F. Mellender, and S. Riegel, </author> <title> Object management in a persistent smalltalk system, </title> <journal> Software: Practice and Experience, </journal> <volume> vol. 19, </volume> <pages> pp. 719-737, </pages> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: PPLs have most often been designed as extensions of non-persistent programming languages. PS-Algol [4] introduced the concept of a PPL. The E language [5, 6, 7, 8] is a more recent PPL based on C++; Alltalk <ref> [9, 10] </ref> is one based on Smalltalk [11]. A database programming language (DBPL) is similar to a PPL but adds database features such as bulk data (sets or relations) and attribute based retrieval (queries).
Reference: [11] <author> A. Goldberg and D. Robson, </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: PPLs have most often been designed as extensions of non-persistent programming languages. PS-Algol [4] introduced the concept of a PPL. The E language [5, 6, 7, 8] is a more recent PPL based on C++; Alltalk [9, 10] is one based on Smalltalk <ref> [11] </ref>. A database programming language (DBPL) is similar to a PPL but adds database features such as bulk data (sets or relations) and attribute based retrieval (queries).
Reference: [12] <author> J. W. Schmidt and M. </author> <title> Mall, </title> <type> Pascal/R report, Report 66, </type> <institution> Fachbereich Automatik, University of Hamburg, Hamburg, Federal Republic of Germany, </institution> <month> Jan. </month> <year> 1980. </year>
Reference-contexts: A database programming language (DBPL) is similar to a PPL but adds database features such as bulk data (sets or relations) and attribute based retrieval (queries). Pascal-R <ref> [12] </ref> is an early DBPL effort based on Pascal that has since moved on to Modula and is now called DBPL [13, 14]. Other DBPLs include O++ [15, 16], ADABTPL [17], FAD [18], Gemstone [19], and CO 2 [20].
Reference: [13] <author> J. W. Schmidt, H. Eckhardt, and F. </author> <title> Matthes, </title> <type> DBPL report, Tech. Rep. </type> <institution> DBPL-Memo 111-88, Fachbereich Informatik, Johann Wolfgang Goethe-Universitat, Frankfurt, Germany, </institution> <year> 1988. </year>
Reference-contexts: A database programming language (DBPL) is similar to a PPL but adds database features such as bulk data (sets or relations) and attribute based retrieval (queries). Pascal-R [12] is an early DBPL effort based on Pascal that has since moved on to Modula and is now called DBPL <ref> [13, 14] </ref>. Other DBPLs include O++ [15, 16], ADABTPL [17], FAD [18], Gemstone [19], and CO 2 [20]. E might also be called a DBPL since it has some support for bulk data management; the dividing line between PPLs and DBPLs is fuzzy.
Reference: [14] <author> F. Matthes and J. W. Schmidt, </author> <title> The type system of DBPL, </title> <editor> in Hull et al. </editor> <volume> [34], </volume> <pages> pp. 255-260. </pages>
Reference-contexts: A database programming language (DBPL) is similar to a PPL but adds database features such as bulk data (sets or relations) and attribute based retrieval (queries). Pascal-R [12] is an early DBPL effort based on Pascal that has since moved on to Modula and is now called DBPL <ref> [13, 14] </ref>. Other DBPLs include O++ [15, 16], ADABTPL [17], FAD [18], Gemstone [19], and CO 2 [20]. E might also be called a DBPL since it has some support for bulk data management; the dividing line between PPLs and DBPLs is fuzzy.
Reference: [15] <author> R. Agrawal and N. H. Gehani, </author> <title> ODE (Object Database and Environment): The language and the data model, </title> <booktitle> in Proceedings of the 1989 ACM SIGMOD International Conference on Management of Data, </booktitle> <address> (Portland, Oregon, </address> <month> June </month> <year> 1989), </year> <pages> pp. 36-45, </pages> <booktitle> ACM SIGMOD Rec. </booktitle> <volume> 18, </volume> <month> 2 (May </month> <year> 1989). </year> <month> 36 </month>
Reference-contexts: Pascal-R [12] is an early DBPL effort based on Pascal that has since moved on to Modula and is now called DBPL [13, 14]. Other DBPLs include O++ <ref> [15, 16] </ref>, ADABTPL [17], FAD [18], Gemstone [19], and CO 2 [20]. E might also be called a DBPL since it has some support for bulk data management; the dividing line between PPLs and DBPLs is fuzzy.
Reference: [16] <author> R. Agrawal and N. H. Gehani, </author> <title> Rationale for the design of persistence and query processing facilities in the database language O++, </title> <editor> in Hull et al. </editor> <volume> [34], </volume> <pages> pp. 25-40. </pages>
Reference-contexts: Pascal-R [12] is an early DBPL effort based on Pascal that has since moved on to Modula and is now called DBPL [13, 14]. Other DBPLs include O++ <ref> [15, 16] </ref>, ADABTPL [17], FAD [18], Gemstone [19], and CO 2 [20]. E might also be called a DBPL since it has some support for bulk data management; the dividing line between PPLs and DBPLs is fuzzy.
Reference: [17] <author> D. Stemple, A. Socorro, and T. Sheard, </author> <title> Formalizing objects for databases using ADABTPL, </title> <booktitle> in Dittrich [53], </booktitle> <pages> pp. 110-128. </pages>
Reference-contexts: Pascal-R [12] is an early DBPL effort based on Pascal that has since moved on to Modula and is now called DBPL [13, 14]. Other DBPLs include O++ [15, 16], ADABTPL <ref> [17] </ref>, FAD [18], Gemstone [19], and CO 2 [20]. E might also be called a DBPL since it has some support for bulk data management; the dividing line between PPLs and DBPLs is fuzzy.
Reference: [18] <author> F. Bancilhon, T. Briggs, S. Khoshafian, and P. Valduriez, </author> <title> FAD: A powerful and simple database language, </title> <booktitle> in Proceedings of the Thirteenth International Conference on Very Large Data Bases, </booktitle> <address> (Brighton, England, </address> <month> Sept. </month> <year> 1987), </year> <pages> pp. 97-105, </pages> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Pascal-R [12] is an early DBPL effort based on Pascal that has since moved on to Modula and is now called DBPL [13, 14]. Other DBPLs include O++ [15, 16], ADABTPL [17], FAD <ref> [18] </ref>, Gemstone [19], and CO 2 [20]. E might also be called a DBPL since it has some support for bulk data management; the dividing line between PPLs and DBPLs is fuzzy.
Reference: [19] <author> G. Copeland and D. Maier, </author> <title> Making Smalltalk a database system, </title> <booktitle> in Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, </booktitle> <address> (Boston, Massachusetts, </address> <month> June </month> <year> 1984), </year> <pages> pp. 316-325, </pages> <booktitle> ACM SIGMOD Rec. </booktitle> <volume> 14, </volume> <month> 2 </month> <year> (1984). </year>
Reference-contexts: Pascal-R [12] is an early DBPL effort based on Pascal that has since moved on to Modula and is now called DBPL [13, 14]. Other DBPLs include O++ [15, 16], ADABTPL [17], FAD [18], Gemstone <ref> [19] </ref>, and CO 2 [20]. E might also be called a DBPL since it has some support for bulk data management; the dividing line between PPLs and DBPLs is fuzzy. <p> Swizzling might also benefit execution of compiled queries in object-oriented databases (OODBs), distinguished from traditional databases in that they manage objects having identity, 1 etc. OODBs described in the literature include Exodus [23], DAMOKLES [24], CACTIS [25], VBase [26], Gemstone <ref> [19, 27] </ref>, O 2 [28, 29], Orion [30], and Iris [31]. OODBs generally include a data manipulation language; such a language may be classified as a DBPL if it is rich enough in programming constructs.
Reference: [20] <author> F. Bancilhon, G. Barbedette, V. Benzaken, C. Delobel, S. Gamerman, C. Lecluse, P. Pfeffer, P. Richard, and F. Velez, </author> <title> The design and implementation of O 2 , an object-oriented database system, </title> <booktitle> in Dittrich [53], </booktitle> <pages> pp. 1-22. </pages>
Reference-contexts: Pascal-R [12] is an early DBPL effort based on Pascal that has since moved on to Modula and is now called DBPL [13, 14]. Other DBPLs include O++ [15, 16], ADABTPL [17], FAD [18], Gemstone [19], and CO 2 <ref> [20] </ref>. E might also be called a DBPL since it has some support for bulk data management; the dividing line between PPLs and DBPLs is fuzzy.
Reference: [21] <author> T. Bloom and S. B. Zdonik, </author> <booktitle> Issues in the design of object-oriented database programming languages, in OOPSLA [54], </booktitle> <pages> pp. 441-451. </pages>
Reference-contexts: E might also be called a DBPL since it has some support for bulk data management; the dividing line between PPLs and DBPLs is fuzzy. General issues of DBPL design for object-oriented languages are discussed in <ref> [21] </ref>, and issues of types and persistence are discussed in [22], which includes a survey of database and persistent programming languages. Swizzling is directly relevant to the implementation of PPLs and DBPLs since such languages support general computation with persistent objects.
Reference: [22] <author> M. P. Atkinson and O. P. Buneman, </author> <title> Types and persistence in database programming languages, </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 19, </volume> <pages> pp. 105-190, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: E might also be called a DBPL since it has some support for bulk data management; the dividing line between PPLs and DBPLs is fuzzy. General issues of DBPL design for object-oriented languages are discussed in [21], and issues of types and persistence are discussed in <ref> [22] </ref>, which includes a survey of database and persistent programming languages. Swizzling is directly relevant to the implementation of PPLs and DBPLs since such languages support general computation with persistent objects.
Reference: [23] <author> M. J. Carey, D. J. DeWitt, J. E. Richardson, and E. J. Shekita, </author> <title> Object and file management in the EXODUS extensible database system, </title> <booktitle> in Proceedings of the Twelfth International Conference on Very Large Data Bases, </booktitle> <address> (Kyoto, Japan, </address> <month> Aug. </month> <year> 1986), </year> <pages> pp. 91-100, </pages> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Swizzling might also benefit execution of compiled queries in object-oriented databases (OODBs), distinguished from traditional databases in that they manage objects having identity, 1 etc. OODBs described in the literature include Exodus <ref> [23] </ref>, DAMOKLES [24], CACTIS [25], VBase [26], Gemstone [19, 27], O 2 [28, 29], Orion [30], and Iris [31]. OODBs generally include a data manipulation language; such a language may be classified as a DBPL if it is rich enough in programming constructs. <p> Swizzling is also relevant to persistent object stores (POSs) and object servers, since applications using a store or server might benefit from converting objects from the store/server format to a faster in-memory format. POSs and storage managers include the Exodus storage manager <ref> [23, 32] </ref>, O 2 [29], and Mneme 4 [33, 34, 35]. Mneme is the POS used for this study. There have also been a number of designs related to virtual memory such as [2, 3, 36, 37, 38]. Object servers include ObServer [39] and Gemstone [40].
Reference: [24] <author> K. R. Dittrich, W. Gotthard, and P. C. Lockemann, </author> <title> DAMOKLES a database system for software engineering environments, </title> <booktitle> in Proceedings of the International Workshop on Advanced Programming Environments, </booktitle> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: Swizzling might also benefit execution of compiled queries in object-oriented databases (OODBs), distinguished from traditional databases in that they manage objects having identity, 1 etc. OODBs described in the literature include Exodus [23], DAMOKLES <ref> [24] </ref>, CACTIS [25], VBase [26], Gemstone [19, 27], O 2 [28, 29], Orion [30], and Iris [31]. OODBs generally include a data manipulation language; such a language may be classified as a DBPL if it is rich enough in programming constructs.
Reference: [25] <author> S. Hudson and R. King, CACTIS: </author> <title> A database system for specifying functionally-defined data, </title> <booktitle> in Dittrich and Dayal [55], </booktitle> <pages> pp. 26-37. </pages>
Reference-contexts: Swizzling might also benefit execution of compiled queries in object-oriented databases (OODBs), distinguished from traditional databases in that they manage objects having identity, 1 etc. OODBs described in the literature include Exodus [23], DAMOKLES [24], CACTIS <ref> [25] </ref>, VBase [26], Gemstone [19, 27], O 2 [28, 29], Orion [30], and Iris [31]. OODBs generally include a data manipulation language; such a language may be classified as a DBPL if it is rich enough in programming constructs.
Reference: [26] <author> T. Andrews and C. Harris, </author> <title> Combining language and database advances in an object-oriented development environment, </title> <booktitle> in OOPSLA [54], </booktitle> <pages> pp. 430-440. </pages>
Reference-contexts: Swizzling might also benefit execution of compiled queries in object-oriented databases (OODBs), distinguished from traditional databases in that they manage objects having identity, 1 etc. OODBs described in the literature include Exodus [23], DAMOKLES [24], CACTIS [25], VBase <ref> [26] </ref>, Gemstone [19, 27], O 2 [28, 29], Orion [30], and Iris [31]. OODBs generally include a data manipulation language; such a language may be classified as a DBPL if it is rich enough in programming constructs.
Reference: [27] <author> D. Maier, J. Stein, A. Otis, and A. Purdy, </author> <title> Development of an object-oriented DBMS, </title> <booktitle> in OOPSLA [50], </booktitle> <pages> pp. 472-482. </pages>
Reference-contexts: Swizzling might also benefit execution of compiled queries in object-oriented databases (OODBs), distinguished from traditional databases in that they manage objects having identity, 1 etc. OODBs described in the literature include Exodus [23], DAMOKLES [24], CACTIS [25], VBase [26], Gemstone <ref> [19, 27] </ref>, O 2 [28, 29], Orion [30], and Iris [31]. OODBs generally include a data manipulation language; such a language may be classified as a DBPL if it is rich enough in programming constructs.
Reference: [28] <author> C. Lecluse, P. Richard, and F. Velez, </author> <title> O 2 , an object-oriented data model, </title> <booktitle> in Proceedings of the 1988 ACM SIGMOD International Conference on Management of Data, </booktitle> <address> (Chicago, Illinois, </address> <month> May </month> <year> 1988), </year> <pages> pp. 424-433, </pages> <booktitle> ACM SIGMOD Rec. </booktitle> <volume> 17, </volume> <month> 3 (Sept. </month> <year> 1988). </year>
Reference-contexts: Swizzling might also benefit execution of compiled queries in object-oriented databases (OODBs), distinguished from traditional databases in that they manage objects having identity, 1 etc. OODBs described in the literature include Exodus [23], DAMOKLES [24], CACTIS [25], VBase [26], Gemstone [19, 27], O 2 <ref> [28, 29] </ref>, Orion [30], and Iris [31]. OODBs generally include a data manipulation language; such a language may be classified as a DBPL if it is rich enough in programming constructs.
Reference: [29] <author> F. Velez, G. Bernard, and V. Darnis, </author> <title> The O 2 object manager, an overview, </title> <editor> in Hull et al. </editor> <volume> [34]. </volume>
Reference-contexts: Swizzling might also benefit execution of compiled queries in object-oriented databases (OODBs), distinguished from traditional databases in that they manage objects having identity, 1 etc. OODBs described in the literature include Exodus [23], DAMOKLES [24], CACTIS [25], VBase [26], Gemstone [19, 27], O 2 <ref> [28, 29] </ref>, Orion [30], and Iris [31]. OODBs generally include a data manipulation language; such a language may be classified as a DBPL if it is rich enough in programming constructs. <p> Swizzling is also relevant to persistent object stores (POSs) and object servers, since applications using a store or server might benefit from converting objects from the store/server format to a faster in-memory format. POSs and storage managers include the Exodus storage manager [23, 32], O 2 <ref> [29] </ref>, and Mneme 4 [33, 34, 35]. Mneme is the POS used for this study. There have also been a number of designs related to virtual memory such as [2, 3, 36, 37, 38]. Object servers include ObServer [39] and Gemstone [40].
Reference: [30] <author> W. Kim, N. Ballou, J. Banerjee, H. Chou, J. F. Garza, and D. Woelk, </author> <title> Integrating an object-oriented programming system with a database system, </title> <booktitle> in OOPSLA [56], </booktitle> <pages> pp. 142-152. </pages>
Reference-contexts: Swizzling might also benefit execution of compiled queries in object-oriented databases (OODBs), distinguished from traditional databases in that they manage objects having identity, 1 etc. OODBs described in the literature include Exodus [23], DAMOKLES [24], CACTIS [25], VBase [26], Gemstone [19, 27], O 2 [28, 29], Orion <ref> [30] </ref>, and Iris [31]. OODBs generally include a data manipulation language; such a language may be classified as a DBPL if it is rich enough in programming constructs.
Reference: [31] <author> D. H. Fishman, D. Beech, H. P. Cate, E. C. Chow, T. Connors, J. W. Davis, N. Derrett, C. G. Hoch, W. Kent, P. Lyngbaek, B. Mahbod, M. A. Neimat, T. A. Ryan, and M. C. Shan, </author> <title> Iris: An object-oriented database management system, </title> <journal> ACM Trans. Office Information Systems, </journal> <volume> vol. 5, </volume> <pages> pp. 48-69, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: OODBs described in the literature include Exodus [23], DAMOKLES [24], CACTIS [25], VBase [26], Gemstone [19, 27], O 2 [28, 29], Orion [30], and Iris <ref> [31] </ref>. OODBs generally include a data manipulation language; such a language may be classified as a DBPL if it is rich enough in programming constructs.
Reference: [32] <author> M. J. Carey, D. J. DeWitt, J. E. Richardson, and E. J. Shekita, </author> <title> Storage management for objects in EXODUS, in Object-Oriented Concepts, Databases, </title> <editor> and Applications (W. Kim and F. H. Lochovsky, eds.), ch. </editor> <volume> 14, </volume> <pages> pp. 341-369, </pages> <address> New York, New York: </address> <publisher> ACM Press/Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Swizzling is also relevant to persistent object stores (POSs) and object servers, since applications using a store or server might benefit from converting objects from the store/server format to a faster in-memory format. POSs and storage managers include the Exodus storage manager <ref> [23, 32] </ref>, O 2 [29], and Mneme 4 [33, 34, 35]. Mneme is the POS used for this study. There have also been a number of designs related to virtual memory such as [2, 3, 36, 37, 38]. Object servers include ObServer [39] and Gemstone [40].
Reference: [33] <author> J. E. B. Moss and S. Sinofsky, </author> <title> Managing persistent data with Mneme: Designing a reliable, shared object interface, </title> <booktitle> in Dittrich [53], </booktitle> <pages> pp. 298-316. </pages>
Reference-contexts: POSs and storage managers include the Exodus storage manager [23, 32], O 2 [29], and Mneme 4 <ref> [33, 34, 35] </ref>. Mneme is the POS used for this study. There have also been a number of designs related to virtual memory such as [2, 3, 36, 37, 38]. Object servers include ObServer [39] and Gemstone [40].
Reference: [34] <author> R. Hull, R. Morrison, and D. </author> <title> Stemple, </title> <editor> eds., </editor> <booktitle> Proceedings of the Second International Workshop on Database Programming Languages, </booktitle> <address> (Gleneden Beach, Oregon, June 1989), </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: POSs and storage managers include the Exodus storage manager [23, 32], O 2 [29], and Mneme 4 <ref> [33, 34, 35] </ref>. Mneme is the POS used for this study. There have also been a number of designs related to virtual memory such as [2, 3, 36, 37, 38]. Object servers include ObServer [39] and Gemstone [40].
Reference: [35] <author> J. E. B. Moss, </author> <title> Design of the Mneme persistent object store, </title> <journal> ACM Trans. Inf. Syst., </journal> <volume> vol. 8, </volume> <pages> pp. 103-139, </pages> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: POSs and storage managers include the Exodus storage manager [23, 32], O 2 [29], and Mneme 4 <ref> [33, 34, 35] </ref>. Mneme is the POS used for this study. There have also been a number of designs related to virtual memory such as [2, 3, 36, 37, 38]. Object servers include ObServer [39] and Gemstone [40]. <p> In Mneme parlance, the physical unit is a physical segment, and what we called segments above are termed logical segments. Physical segment layout is illustrated in Figure 3. For more information on Mneme see <ref> [35] </ref>. 6 Turning to swizzling, Figure 4 (a) sketches the code for eager in-place swizzling. The Swizzled and MarkSwizzled actions test and set a field containing two bits, encoded as shown in Table 1.
Reference: [36] <author> P. Cockshott, </author> <title> Stable virtual memory, </title> <booktitle> in Proceedings of the Second International Workshop on Persistent Object Systems: Their Design, Implementation, and Use, </booktitle> <address> (St. Andrews, Scotland, </address> <month> Aug. </month> <year> 1987), </year> <pages> pp. 470-476, </pages> <institution> University of St. Andrews, Department of Computational Science. </institution>
Reference-contexts: POSs and storage managers include the Exodus storage manager [23, 32], O 2 [29], and Mneme 4 [33, 34, 35]. Mneme is the POS used for this study. There have also been a number of designs related to virtual memory such as <ref> [2, 3, 36, 37, 38] </ref>. Object servers include ObServer [39] and Gemstone [40]. We know of no prior studies of swizzling performance, and hence can offer no comparison with directly related work.
Reference: [37] <author> R. Connor, A. Brown, R. Carrick, A. Dearle, and R. Morrison, </author> <title> The persistent abstract machine, </title> <booktitle> in Rosenberg and Koch [57], </booktitle> <pages> pp. 353-366. </pages>
Reference-contexts: POSs and storage managers include the Exodus storage manager [23, 32], O 2 [29], and Mneme 4 [33, 34, 35]. Mneme is the POS used for this study. There have also been a number of designs related to virtual memory such as <ref> [2, 3, 36, 37, 38] </ref>. Object servers include ObServer [39] and Gemstone [40]. We know of no prior studies of swizzling performance, and hence can offer no comparison with directly related work.
Reference: [38] <author> J. L. Keedy and J. Rosenberg, </author> <title> Support for objects in the MONADS architecture, </title> <booktitle> in Rosenberg and Koch [57], </booktitle> <pages> pp. 392-405. </pages>
Reference-contexts: POSs and storage managers include the Exodus storage manager [23, 32], O 2 [29], and Mneme 4 [33, 34, 35]. Mneme is the POS used for this study. There have also been a number of designs related to virtual memory such as <ref> [2, 3, 36, 37, 38] </ref>. Object servers include ObServer [39] and Gemstone [40]. We know of no prior studies of swizzling performance, and hence can offer no comparison with directly related work.
Reference: [39] <author> A. Skarra, S. B. Zdonik, and S. P. Reiss, </author> <title> An object server for an object oriented database system, </title> <booktitle> in Dittrich and Dayal [55], </booktitle> <pages> pp. 196-204. </pages>
Reference-contexts: Mneme is the POS used for this study. There have also been a number of designs related to virtual memory such as [2, 3, 36, 37, 38]. Object servers include ObServer <ref> [39] </ref> and Gemstone [40]. We know of no prior studies of swizzling performance, and hence can offer no comparison with directly related work.
Reference: [40] <author> A. Purdy, B. Schuchardt, and D. Maier, </author> <title> Integrating an object server with other worlds, </title> <journal> ACM Trans. Office Information Systems, </journal> <volume> vol. 5, </volume> <pages> pp. 27-47, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: Mneme is the POS used for this study. There have also been a number of designs related to virtual memory such as [2, 3, 36, 37, 38]. Object servers include ObServer [39] and Gemstone <ref> [40] </ref>. We know of no prior studies of swizzling performance, and hence can offer no comparison with directly related work.
Reference: [41] <author> W. R. Rubinstein, M. S. Kubicar, and R. G. G. Cattell, </author> <title> Benchmarking simple database operations, </title> <booktitle> in SIGMOD [51], </booktitle> <pages> pp. 387-394. </pages>
Reference-contexts: Object servers include ObServer [39] and Gemstone [40]. We know of no prior studies of swizzling performance, and hence can offer no comparison with directly related work. Published OODB benchmarks and performance studies include <ref> [41, 42, 43, 44, 45, 46] </ref>. 1.2 Simplifying assumptions To study swizzling and obtain clear results, we focus on application behavior patterns most affected by swizzling, i.e., where swizzling is on the critical path. Consider a CAD design tool as an example. <p> We designed this new benchmark so that we could control the collection variables and disentangle the results to estimate the model parameters for swizzling. Existing benchmarks such as the Sun Engineering Database Benchmark <ref> [41] </ref>, its more recent simplification [42], and the HyperModel benchmark [45] are designed to test overall object-oriented DBMS (or PPL or DBPL) performance, and do not vary some of the variables significant for our model. In short, we needed tests specialized to our task.
Reference: [42] <author> R. G. G. Cattell, </author> <title> Object-oriented DBMS performance measurement, </title> <booktitle> in Dittrich [53], </booktitle> <pages> pp. 364-367. </pages>
Reference-contexts: Object servers include ObServer [39] and Gemstone [40]. We know of no prior studies of swizzling performance, and hence can offer no comparison with directly related work. Published OODB benchmarks and performance studies include <ref> [41, 42, 43, 44, 45, 46] </ref>. 1.2 Simplifying assumptions To study swizzling and obtain clear results, we focus on application behavior patterns most affected by swizzling, i.e., where swizzling is on the critical path. Consider a CAD design tool as an example. <p> We designed this new benchmark so that we could control the collection variables and disentangle the results to estimate the model parameters for swizzling. Existing benchmarks such as the Sun Engineering Database Benchmark [41], its more recent simplification <ref> [42] </ref>, and the HyperModel benchmark [45] are designed to test overall object-oriented DBMS (or PPL or DBPL) performance, and do not vary some of the variables significant for our model. In short, we needed tests specialized to our task.
Reference: [43] <author> J. Duhl and C. Damon, </author> <title> A performance comparison of object and relational databases using the Sun benchmark, </title> <booktitle> in OOPSLA [56], </booktitle> <pages> pp. 153-163. 38 </pages>
Reference-contexts: Object servers include ObServer [39] and Gemstone [40]. We know of no prior studies of swizzling performance, and hence can offer no comparison with directly related work. Published OODB benchmarks and performance studies include <ref> [41, 42, 43, 44, 45, 46] </ref>. 1.2 Simplifying assumptions To study swizzling and obtain clear results, we focus on application behavior patterns most affected by swizzling, i.e., where swizzling is on the critical path. Consider a CAD design tool as an example.
Reference: [44] <author> V. Benzaken and C. Delobel, </author> <title> Enhancing performance in a persistent object store: Clustering strategies in O 2 , in Dearle et al. </title> <booktitle> [52], </booktitle> <pages> pp. 403-412. </pages>
Reference-contexts: Object servers include ObServer [39] and Gemstone [40]. We know of no prior studies of swizzling performance, and hence can offer no comparison with directly related work. Published OODB benchmarks and performance studies include <ref> [41, 42, 43, 44, 45, 46] </ref>. 1.2 Simplifying assumptions To study swizzling and obtain clear results, we focus on application behavior patterns most affected by swizzling, i.e., where swizzling is on the critical path. Consider a CAD design tool as an example.
Reference: [45] <author> T. L. Anderson, A. J. Berre, M. Mallison, H. Porter, and B. Schneider, </author> <title> The Tektronix HyperModel benchmark specification, </title> <type> Technical Report 89-05, </type> <institution> Computer Research Laboratory, Tektronix Laboratories, </institution> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: Object servers include ObServer [39] and Gemstone [40]. We know of no prior studies of swizzling performance, and hence can offer no comparison with directly related work. Published OODB benchmarks and performance studies include <ref> [41, 42, 43, 44, 45, 46] </ref>. 1.2 Simplifying assumptions To study swizzling and obtain clear results, we focus on application behavior patterns most affected by swizzling, i.e., where swizzling is on the critical path. Consider a CAD design tool as an example. <p> We designed this new benchmark so that we could control the collection variables and disentangle the results to estimate the model parameters for swizzling. Existing benchmarks such as the Sun Engineering Database Benchmark [41], its more recent simplification [42], and the HyperModel benchmark <ref> [45] </ref> are designed to test overall object-oriented DBMS (or PPL or DBPL) performance, and do not vary some of the variables significant for our model. In short, we needed tests specialized to our task.
Reference: [46] <author> D. J. DeWitt, P. Futtersack, D. Maier, and F. Velez, </author> <title> A study of three alternative workstation-server architectures for object oriented database systems, </title> <booktitle> in Proceedings of the Sixteenth International Conference on Very Large Data Bases, </booktitle> <address> (Brisbane, Australia, </address> <month> Aug. </month> <year> 1990), </year> <pages> pp. 107-121, </pages> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Object servers include ObServer [39] and Gemstone [40]. We know of no prior studies of swizzling performance, and hence can offer no comparison with directly related work. Published OODB benchmarks and performance studies include <ref> [41, 42, 43, 44, 45, 46] </ref>. 1.2 Simplifying assumptions To study swizzling and obtain clear results, we focus on application behavior patterns most affected by swizzling, i.e., where swizzling is on the critical path. Consider a CAD design tool as an example.
Reference: [47] <author> A. L. Hosking and J. E. B. Moss, </author> <title> Towards compile-time optimisations for persistence, </title> <editor> in Dearle et al. </editor> <volume> [52], </volume> <pages> pp. 17-27. </pages> <note> Also available as University of Massachusetts, Department of Computer and Information Science Technical Report 90-74. </note>
Reference-contexts: While it would take us too far off the subject here, we note that it may be possible to use compiler techniques and program annotations to substantially reduce the number of object residency checks performed at run time <ref> [47, 48, 6, 7, 8] </ref>. This suggests that software-versus hardware-mediated object residency checks may not be a substantial performance issue, and that the strongest argument in favor of page trapping techniques for object faulting is that they do not require compiler support to be transparent to the programmer.
Reference: [48] <author> A. L. Hosking and J. E. B. Moss, </author> <title> Compiler support for persistent programming, </title> <type> COINS Technical Report 91-25, </type> <institution> Department of Computer and Information Science, University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> Mar. </month> <year> 1991. </year>
Reference-contexts: While it would take us too far off the subject here, we note that it may be possible to use compiler techniques and program annotations to substantially reduce the number of object residency checks performed at run time <ref> [47, 48, 6, 7, 8] </ref>. This suggests that software-versus hardware-mediated object residency checks may not be a substantial performance issue, and that the strongest argument in favor of page trapping techniques for object faulting is that they do not require compiler support to be transparent to the programmer.
Reference: [49] <author> C. Schaffert, T. Cooper, B. Bullis, M. Kilian, and C. Wilpolt, </author> <title> An introduction to Trellis/Owl, </title> <booktitle> in OOPSLA [50], </booktitle> <pages> pp. 9-16. </pages>
Reference-contexts: We can, however, extrapolate from existing object systems such as Smalltalk and Trellis 9 <ref> [49] </ref>. In Smalltalk the average object size exclusive of headers is about 40 bytes, half of which are devoted to slots. This suggests that about half of object contents are pointers, but that would be an overestimate since many slots in Smalltalk objects contain integers.
Reference: [50] <institution> Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, (Portland, Oregon, </institution> <month> Sept. </month> <year> 1986), </year> <journal> ACM SIGPLAN Not. </journal> <volume> 21, </volume> <month> 11 (Nov. </month> <year> 1986). </year>
Reference: [51] <institution> Proceedings of the 1987 ACM SIGMOD International Conference on Management of Data, </institution> <address> (San Francisco, California, </address> <month> May </month> <year> 1987), </year> <booktitle> ACM SIGMOD Rec. </booktitle> <volume> 16, </volume> <month> 3 (Dec. </month> <year> 1987). </year>
Reference: [52] <editor> A. Dearle, G. M. Shaw, and S. B. Zdonik, eds., </editor> <booktitle> Proceedings of the Fourth International Workshop on Persistent Object Systems, </booktitle> <address> (Martha's Vineyard, Massachusetts, </address> <month> Sept. </month> <year> 1990), </year> <title> published as Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference: [53] <editor> K. R. Dittrich, ed., </editor> <booktitle> Proceedings of the Second International Workshop on Object-Oriented Database Systems, vol. 334 of Lecture Notes in Computer Science, </booktitle> <address> (Bad Munster am Stein-Ebernburg, Federal Republic of Germany, </address> <month> Sept. </month> <year> 1988), </year> <title> Advances in Object-Oriented Database Systems, </title> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference: [54] <institution> Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </institution> <address> (Orlando, Florida, </address> <month> Oct. </month> <year> 1987), </year> <journal> ACM SIGPLAN Not. </journal> <volume> 22, </volume> <month> 11 (Nov. </month> <year> 1987). </year>
Reference: [55] <editor> K. Dittrich and U. Dayal, eds., </editor> <booktitle> Proceedings of the International Workshop on Object-Oriented Database Systems, </booktitle> <address> (Pacific Grove, California, Sept. 1986), </address> <publisher> IEEE Computer Society Press, </publisher> <address> Washington, D.C. </address>
Reference: [56] <institution> Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </institution> <address> (San Diego, California, </address> <month> Sept. </month> <year> 1988), </year> <journal> ACM SIGPLAN Not. </journal> <volume> 23, </volume> <month> 11 (Nov. </month> <year> 1988). </year>
Reference: [57] <author> J. Rosenberg and D. </author> <title> Koch, </title> <editor> eds., </editor> <booktitle> Proceedings of the Third International Workshop on Persistent Object Systems, (Newcastle, </booktitle> <address> Australia, Jan. 1989), </address> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <month> 39 </month>
References-found: 57

