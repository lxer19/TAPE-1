URL: ftp://ftp.cs.uoregon.edu/pub/ariola/lics.ps
Refering-URL: http://www.cs.uoregon.edu/~ariola/publications.html
Root-URL: http://www.cs.uoregon.edu
Email: ariola@cs.uoregon.edu jwk@cwi.nl  
Title: Cyclic Lambda Graph Rewriting  
Author: Zena M. Ariola Jan Willem Klop 
Address: Eugene, OR 97401 Amsterdam, The Netherlands  
Affiliation: Computer Information Science Dept. Dept. of Software Technology, CWI University of Oregon Dept. of Computer Science, Free University  
Abstract: This paper is concerned with the study of cyclic - graphs. The starting point is to treat a -graph as a system of recursion equations involving -terms, and to manipulate such systems in an unrestricted manner, using equational logic, just as is possible for first-order term rewriting. Surprisingly, now the confluence property breaks down in an essential way. Confluence can be restored by introducing a restraining mechanism on the `copying' operation. This leads to a family of -graph calculi, which are inspired by the family of -calculi (-calculi with explicit substitution). However, these concern acyclic expressions only. In this paper we are not concerned with optimality questions for acyclic -reduction. We also indicate how Wadsworth's interpreter can be simulated in the -graph rewrite rules that we propose. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. Levy. </author> <title> Explicit Substitutions. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(1) </volume> <pages> 375-416, </pages> <year> 1991. </year>
Reference-contexts: The restraints are in the fact that the `copying' operation is more controlled than in the naive or unrestricted version for which we demonstrate non-confluence. The restrained -graph calculi that we discuss are inspired by the family of -calculi (-calculi with explicit substitution) <ref> [11, 1, 7, 22] </ref>. However, these concern acyclic expressions only. A related system for `explicit cyclic substitutions' has been given by Rose [25]. In this paper we are not concerned with optimality questions for acyclic -reduction as in the work of [21, 15, 10, 9]. <p> As in Rose [25] inspiration comes from the family of -calculi (-calculi with explicit substitution), see <ref> [11, 1, 7, 22] </ref>. We now in a sequence of extensions develop a series of calculi, leading to a very general and flexible calculus which incorporates -calculus, ordinary first-order term rewriting, -graph rewriting with vertical and horizontal sharing. <p> For example, we can read the expression hff:fffi j fi = F0i, as being the term ff:fffi, where fi is bound to F0, or equivalently in terms of the Let expression: Let fi = F0 in ff:fffi end The above expression in the calculus <ref> [1] </ref> is ff:fffi [(F (0)=fi):id]. However, the fl 0 -calculus differs from the -calculi in that it allows `cyclic substitutions' also.
Reference: [2] <author> Z. M. Ariola. </author> <title> An Algebraic Approach to the Compilation and Operational Semantics of Functional Languages with I-structures. </title> <type> PhD thesis, </type> <institution> Harvard University, </institution> <year> 1992. </year>
Reference-contexts: Thus, the fl-calculi follow the tradition of providing `enriched -calculi' to capture more precisely the operational semantics of functional languages <ref> [2, 24, 23] </ref>. We will still assume the variable convention, that is, both free and bound variables have to be distinct. So for example, we will write hff:fiff j fi = Fffii instead of hff:fiff j fi = Fffi. Definition 9.1 Let be a first-order signature.
Reference: [3] <author> Z. M. Ariola and J. W. Klop. </author> <title> Equational Term Graph Rewriting. </title> <type> Technical Report Draft, </type> <year> 1993. </year>
Reference-contexts: The starting point is to treat a -graph as a system of recursion equations involving -terms, and to manipulate such systems in an unrestricted manner, using equational logic, just as is possible for first-order term rewriting <ref> [3] </ref>. Surprisingly, now the confluence property breaks down in an essential way. To understand this phenomenon better, the infini-tary version of -calculus, called 1 , that we intro duce here turns out to be of great value. <p> Namely, suppose we allow the re-introduction of names (recursion variables). Then we can restore hff j ff = S (S (ff))i to hff j ff = S (fi); fi = S (ff)i and converge again. In <ref> [3] </ref> we have elaborated this matter distinguishing some simple operations like ! s on recursion systems over a first-order signature; with reintroduction of names a confluence result holds there, but not without, due to `cyclic substitutions' as above. <p> Furthermore, a - step in will correspond to a `copying' step (! c ) in . Copying is the well-known transformation on graphs that is the inverse of a rooted graph homomorphism (see Ariola and Klop <ref> [3] </ref>), also referred to as unsharing or unwinding. Substitution (! s ) is a particular form of copying. In view of these connections between and it is somewhat paradoxical that the former is confluent while the latter is not. <p> Studying the overlaps between the rules thus far, we are led moreover to include the explicit operation of copying (! c ). For a precise definition see Ariola and Klop <ref> [3] </ref>. Copying consists of creating some new names and using these to expand the box-construct in an arbitrary way, by simple use of Equational Logic.
Reference: [4] <author> Z. M. Ariola, J. W. Klop, J. R. Kennaway, F. J. de Vries, and M. R. Sleep. </author> <title> Syntactic Definitions of Undefined: On Defining the Undefined. </title> <booktitle> In Proc. TACS 94, Sendai, </booktitle> <address> Japan, </address> <year> 1994. </year>
Reference-contexts: For a comparison of notions of un-definedness in orthogonal term (graph) rewriting, see <ref> [4] </ref>. Also in the present setting we need the introduction of the singularity point *. E.g., , consider the -graph: ff = (x:fi)A; fi = (x:ff)B: Contracting the ff-redex yields ff = fi; fi = (x:ff)B, which is equivalent to ff = (x:ff)B.
Reference: [5] <author> Arvind, V. Kathail, and K. Pingali. </author> <title> Sharing of Computation in Functional Language Implementations. </title> <booktitle> In Proc. Internal Workshop on High-Level Computer Architecture, </booktitle> <year> 1984. </year>
Reference-contexts: In other words, an unnecessary copy of M has been performed; no occurrence of the bound variable fi can occur in M , therefore, M can be safely shared between the two applications. In fact, this is the essence of lazy and fully lazy interpreters <ref> [12, 28, 27, 5] </ref>. This leads us to add the flattening rules displayed in Table 3; the new system is called fl 2 . The proviso in Table 3 is necessary for confluence. <p> The trick is played by the fi-rule and the above flattening rules: a redex (ff:M )A will be reduced to hM j ff = Ai, that is, A is put in the environment, as in [12] or, following the terminology of <ref> [5] </ref>, A is "flagged" so that it will not be copied in case the re-dex is shared. This suggests that in order to avoid the extra complication of detecting mfe's at run time as in [28], an expression can be first pre-processed by well-known techniques [13, 14].
Reference: [6] <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: We will express -graphs as systems of recursion equations. Thus we may write: ff = x:xff: This is an object whose unwinding is an `infinite normal form', also known as Bohm-tree <ref> [6] </ref>. We also may consider mutual recursion as in ff = (x:fixx)ff; fi = (y:ffy)fi: We will always use ff; fi; , for recursion variables. <p> A classical lemma in -calculus is the Finite Developments Lemma, stating that any development must terminate (see Barendregt <ref> [6] </ref>). Of course, we cannot have that for 1 -calculus, since we admit infinitely many redexes to be developed.
Reference: [7] <author> P.-L. Curien. </author> <title> Categorical Combinators, Sequential algorithms, </title> <booktitle> and Functional Programming. </booktitle> <address> Birkhauser Boston. </address> <note> Second Edition, </note> <year> 1993. </year>
Reference-contexts: The restraints are in the fact that the `copying' operation is more controlled than in the naive or unrestricted version for which we demonstrate non-confluence. The restrained -graph calculi that we discuss are inspired by the family of -calculi (-calculi with explicit substitution) <ref> [11, 1, 7, 22] </ref>. However, these concern acyclic expressions only. A related system for `explicit cyclic substitutions' has been given by Rose [25]. In this paper we are not concerned with optimality questions for acyclic -reduction as in the work of [21, 15, 10, 9]. <p> As in Rose [25] inspiration comes from the family of -calculi (-calculi with explicit substitution), see <ref> [11, 1, 7, 22] </ref>. We now in a sequence of extensions develop a series of calculi, leading to a very general and flexible calculus which incorporates -calculus, ordinary first-order term rewriting, -graph rewriting with vertical and horizontal sharing.
Reference: [8] <author> N. Dershowitz and J. P. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> volume B, </volume> <pages> pages 243-320. </pages> <publisher> Elsevier The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Introduction As shown in recent years, first-order orthogonal term rewriting <ref> [8, 19] </ref> has quite pleasant confluent extensions to the case where cycles are admitted (term graph rewriting [26]) and to the case where infinite terms and transfinitely long rewrite sequences are admitted (infinitary term rewriting [17]).
Reference: [9] <author> J. </author> <title> Field. On Laziness and Optimality in Lambda Interpreters: Tools for Specification and Analysis. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <year> 1990. </year>
Reference-contexts: However, these concern acyclic expressions only. A related system for `explicit cyclic substitutions' has been given by Rose [25]. In this paper we are not concerned with optimality questions for acyclic -reduction as in the work of <ref> [21, 15, 10, 9] </ref>.
Reference: [10] <author> G. Gonthier, M. Abadi, and J.-J. Levy. </author> <title> The geometry of optimal lambda reduction. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <year> 1992. </year>
Reference-contexts: However, these concern acyclic expressions only. A related system for `explicit cyclic substitutions' has been given by Rose [25]. In this paper we are not concerned with optimality questions for acyclic -reduction as in the work of <ref> [21, 15, 10, 9] </ref>.
Reference: [11] <author> T. Hardin and J.-J. Levy. </author> <title> A confluent calculus of substitutions. </title> <booktitle> In France-Japan Artificial Intelligence and Computer Science Symposium, </booktitle> <year> 1989. </year>
Reference-contexts: The restraints are in the fact that the `copying' operation is more controlled than in the naive or unrestricted version for which we demonstrate non-confluence. The restrained -graph calculi that we discuss are inspired by the family of -calculi (-calculi with explicit substitution) <ref> [11, 1, 7, 22] </ref>. However, these concern acyclic expressions only. A related system for `explicit cyclic substitutions' has been given by Rose [25]. In this paper we are not concerned with optimality questions for acyclic -reduction as in the work of [21, 15, 10, 9]. <p> As in Rose [25] inspiration comes from the family of -calculi (-calculi with explicit substitution), see <ref> [11, 1, 7, 22] </ref>. We now in a sequence of extensions develop a series of calculi, leading to a very general and flexible calculus which incorporates -calculus, ordinary first-order term rewriting, -graph rewriting with vertical and horizontal sharing.
Reference: [12] <author> P. Henderson and J. Morris. </author> <title> A lazy evaluator. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <year> 1976. </year>
Reference-contexts: In other words, an unnecessary copy of M has been performed; no occurrence of the bound variable fi can occur in M , therefore, M can be safely shared between the two applications. In fact, this is the essence of lazy and fully lazy interpreters <ref> [12, 28, 27, 5] </ref>. This leads us to add the flattening rules displayed in Table 3; the new system is called fl 2 . The proviso in Table 3 is necessary for confluence. <p> The trick is played by the fi-rule and the above flattening rules: a redex (ff:M )A will be reduced to hM j ff = Ai, that is, A is put in the environment, as in <ref> [12] </ref> or, following the terminology of [5], A is "flagged" so that it will not be copied in case the re-dex is shared.
Reference: [13] <author> R. J. M. Hughes. Super-combinators. </author> <booktitle> In Proc. of Lisp and Functional Programming, </booktitle> <year> 1982. </year>
Reference-contexts: This suggests that in order to avoid the extra complication of detecting mfe's at run time as in [28], an expression can be first pre-processed by well-known techniques <ref> [13, 14] </ref>. Then doing sharing of arguments is enough to capture the amount of sharing offered by Wadsworth's interpreter. Acknowledgements This work was done at the Dept. of Software Technology of CWI, and at the Dept. of Computer Science of the Free University. Z.
Reference: [14] <author> T. Johnsson. </author> <title> Lambda Lifting: Transforming Programs to Recursive Equations. </title> <booktitle> In Proc. of Functional Programming Languages and Computer Architecture Conference, </booktitle> <address> Nancy, France, </address> <publisher> Springer-Verlag LNCS 201, </publisher> <year> 1985. </year>
Reference-contexts: This suggests that in order to avoid the extra complication of detecting mfe's at run time as in [28], an expression can be first pre-processed by well-known techniques <ref> [13, 14] </ref>. Then doing sharing of arguments is enough to capture the amount of sharing offered by Wadsworth's interpreter. Acknowledgements This work was done at the Dept. of Software Technology of CWI, and at the Dept. of Computer Science of the Free University. Z.
Reference: [15] <author> V. K. Kathail. </author> <title> Optimal Interpreters for Lambda-calculus Based Funtional Languages. </title> <type> PhD thesis, </type> <institution> Dept. of Electrical Engineering and Computer Science, MIT, </institution> <year> 1990. </year>
Reference-contexts: However, these concern acyclic expressions only. A related system for `explicit cyclic substitutions' has been given by Rose [25]. In this paper we are not concerned with optimality questions for acyclic -reduction as in the work of <ref> [21, 15, 10, 9] </ref>.
Reference: [16] <author> J. R. Kennaway, J. W. Klop, M. R. Sleep, and F. J. de Vries. </author> <title> An Infinitary Church-Rosser property for Non-collapsing Orthogonal Term Rewriting Systems. </title> <booktitle> In [26], </booktitle> <pages> pages 47-59. </pages>
Reference-contexts: Our notions of fi-reduction on -graphs all satisfy this criterion; also the various transformations in the final sections 9, 10 are sound. Remark 5.4 A noteworthy difference between orthogonal infinitary term rewriting as developed in <ref> [16] </ref> and 1 -calculus is that in the former the infini-tary version of the well-known Parallel Moves Lemma (PML 1 ) holds, whereas it fails in the latter. <p> This example moreover shows that the infinitary non-confluence of 1 cannot be restored by putting all infinitary collapsing terms (trees), called `hyper-collapsing' in <ref> [16] </ref>, equal to *. (In orthogonal infinitary term rewriting this is sufficient for obtaining infinitary confluence.) However, identifying the larger class of terms without head normal form does restore confluence as the next theorem states. 5.2 Head normal forms A term M has a head normal form it it reduces to
Reference: [17] <author> J. R. Kennaway, J. W. Klop, M. R. Sleep, and F. J. de Vries. </author> <title> Transfinite Reductions in Orthogonal Term Rewriting Systems. </title> <editor> In R. Book, editor, </editor> <booktitle> Proc. RTA '91, </booktitle> <publisher> Springer-Verlag LNCS 488, </publisher> <pages> pages 1-12, </pages> <year> 1991. </year>
Reference-contexts: Introduction As shown in recent years, first-order orthogonal term rewriting [8, 19] has quite pleasant confluent extensions to the case where cycles are admitted (term graph rewriting [26]) and to the case where infinite terms and transfinitely long rewrite sequences are admitted (infinitary term rewriting <ref> [17] </ref>). This paper is concerned with similar questions for -calculus, and attempts to formulate a confluent calculus for possibly cyclic -graphs. <p> any set of operations on -graphs that is `sound' in a sense that we will elaborate now. 5 Infinitary lambda calculus: the 1 - calculus We will now give a short exposition of the infinitary version of -calculus, analogous to the infinitary version of orthogonal term rewriting as developed in <ref> [17] </ref>. We will need infinitary -calculus as the `semantics' of -graph rewriting, providing us with a notion of correctness of proposed definitions of fi-reduction of - graphs, and explaining the counterexamples for (fini-tary) confluence of -reduction of such graphs. <p> In transfinite orthogonal term rewriting there is a single source of failure of infinitary confluence: the presence of collapsing operators, such as the I or K combinators, enabling one to build trees that consist of an infinite tower of collapsing operators, or rather collapsing contexts. This is proved in <ref> [17] </ref>. In the present case, that is also a source of non-confluence. But here the matter is more complicated, and there is another phenomenon that causes infinitary non-confluence, not due to collapsing contexts.
Reference: [18] <author> J. W. Klop. </author> <title> Combinatory Reduction Systems. </title> <type> PhD thesis, </type> <institution> Mathematical Center, </institution> <address> Amsterdam, </address> <year> 1980. </year>
Reference-contexts: Confluence follows at once since it is an orthogonal CRS (Combinatory Reduction System) <ref> [18, 20] </ref>. The -calculus obviously is already a form of cyclic -graph rewriting; it is straightforward how to assign a -graph to a -term. A -term however can only express `vertical sharing'; and not also `horizontal sharing' as present in .
Reference: [19] <author> J. W. Klop. </author> <title> Term Rewriting Systems. </title> <editor> In Abram-sky, Gabbay and Maibaum, editor, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 2, </volume> <pages> pages 1-116. </pages> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: Introduction As shown in recent years, first-order orthogonal term rewriting <ref> [8, 19] </ref> has quite pleasant confluent extensions to the case where cycles are admitted (term graph rewriting [26]) and to the case where infinite terms and transfinitely long rewrite sequences are admitted (infinitary term rewriting [17]).
Reference: [20] <author> J. W. Klop, V. van Oostrom, and F. van Raams-donk. </author> <title> Combinatory reduction systems: Introduction and survey. </title> <booktitle> In Theoretical Computer Science, </booktitle> <volume> Vol. 121, Nrs. </volume> <pages> 1-2, pages 279-308, </pages> <year> 1993. </year>
Reference-contexts: Confluence follows at once since it is an orthogonal CRS (Combinatory Reduction System) <ref> [18, 20] </ref>. The -calculus obviously is already a form of cyclic -graph rewriting; it is straightforward how to assign a -graph to a -term. A -term however can only express `vertical sharing'; and not also `horizontal sharing' as present in .
Reference: [21] <author> J. Lamping. </author> <title> An algorithm for optimal lambda calculus reduction. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> San Fran-cisco, </address> <year> 1990. </year>
Reference-contexts: However, these concern acyclic expressions only. A related system for `explicit cyclic substitutions' has been given by Rose [25]. In this paper we are not concerned with optimality questions for acyclic -reduction as in the work of <ref> [21, 15, 10, 9] </ref>.
Reference: [22] <author> P. Lescanne. </author> <title> From to a Journey Through Calculi of Explicit Substitutions. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> Portland, </address> <year> 1993. </year>
Reference-contexts: The restraints are in the fact that the `copying' operation is more controlled than in the naive or unrestricted version for which we demonstrate non-confluence. The restrained -graph calculi that we discuss are inspired by the family of -calculi (-calculi with explicit substitution) <ref> [11, 1, 7, 22] </ref>. However, these concern acyclic expressions only. A related system for `explicit cyclic substitutions' has been given by Rose [25]. In this paper we are not concerned with optimality questions for acyclic -reduction as in the work of [21, 15, 10, 9]. <p> As in Rose [25] inspiration comes from the family of -calculi (-calculi with explicit substitution), see <ref> [11, 1, 7, 22] </ref>. We now in a sequence of extensions develop a series of calculi, leading to a very general and flexible calculus which incorporates -calculus, ordinary first-order term rewriting, -graph rewriting with vertical and horizontal sharing.
Reference: [23] <author> A. Meyer, L. Justin, and B. </author> <title> So. Substitution model: formal definitions. Handout for Computability, Programming and Logic. </title> <institution> MIT Laboratory for Computer Science. </institution> <year> 1993. </year>
Reference-contexts: Thus, the fl-calculi follow the tradition of providing `enriched -calculi' to capture more precisely the operational semantics of functional languages <ref> [2, 24, 23] </ref>. We will still assume the variable convention, that is, both free and bound variables have to be distinct. So for example, we will write hff:fiff j fi = Fffii instead of hff:fiff j fi = Fffi. Definition 9.1 Let be a first-order signature.
Reference: [24] <editor> S. L. Peyton Jones. </editor> <booktitle> The implementation of Functional Programming Languages. Prentice-Hall International, </booktitle> <address> Englewood Cliffs, N.J., </address> <year> 1987. </year>
Reference-contexts: Thus, the fl-calculi follow the tradition of providing `enriched -calculi' to capture more precisely the operational semantics of functional languages <ref> [2, 24, 23] </ref>. We will still assume the variable convention, that is, both free and bound variables have to be distinct. So for example, we will write hff:fiff j fi = Fffii instead of hff:fiff j fi = Fffi. Definition 9.1 Let be a first-order signature.
Reference: [25] <author> K. H. Rose. </author> <title> Explicit Cyclic Substitution. </title> <type> Technical Report D-166, </type> <institution> DIKU, </institution> <year> 1993. </year>
Reference-contexts: The restrained -graph calculi that we discuss are inspired by the family of -calculi (-calculi with explicit substitution) [11, 1, 7, 22]. However, these concern acyclic expressions only. A related system for `explicit cyclic substitutions' has been given by Rose <ref> [25] </ref>. In this paper we are not concerned with optimality questions for acyclic -reduction as in the work of [21, 15, 10, 9]. <p> however, we are able to reduce spine-cyclic redexes. 8 The -calculus: a paradox An interesting calculus arises by extending `pure' -calculus with the -rule: fi : (x:Z (x))Z 0 ! Z (Z 0 ) : x:Z (x) ! Z (x:Z (x)) This -calculus was also introduced and analyzed in Rose <ref> [25] </ref>. Confluence follows at once since it is an orthogonal CRS (Combinatory Reduction System) [18, 20]. The -calculus obviously is already a form of cyclic -graph rewriting; it is straightforward how to assign a -graph to a -term. <p> Modular lambda graph rewriting The last observation gives rise to the following question: how can we extend -calculus, with its lack of horizontal sharing, to include this feature that is indispensable for efficient graph rewriting, while retaining confluence? Such a confluent extension is also proposed in the work of Rose <ref> [25] </ref>. As in Rose [25] inspiration comes from the family of -calculi (-calculi with explicit substitution), see [11, 1, 7, 22]. <p> The last observation gives rise to the following question: how can we extend -calculus, with its lack of horizontal sharing, to include this feature that is indispensable for efficient graph rewriting, while retaining confluence? Such a confluent extension is also proposed in the work of Rose <ref> [25] </ref>. As in Rose [25] inspiration comes from the family of -calculi (-calculi with explicit substitution), see [11, 1, 7, 22].
Reference: [26] <author> M. R. Sleep, M. J. Plasmeijer, and M. C. D. J. van Eekelen, </author> <title> editors. Term Graph Rewriting: Theory and Practice. </title> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: Introduction As shown in recent years, first-order orthogonal term rewriting [8, 19] has quite pleasant confluent extensions to the case where cycles are admitted (term graph rewriting <ref> [26] </ref>) and to the case where infinite terms and transfinitely long rewrite sequences are admitted (infinitary term rewriting [17]). This paper is concerned with similar questions for -calculus, and attempts to formulate a confluent calculus for possibly cyclic -graphs. <p> Now we want to prove confluence of in analogy with the situation for orthogonal term graph rewriting involving cycles. However, there are some nasty surprises. 4 A counterexample to confluence Remarkably, orthogonal term graph rewriting is confluent <ref> [26] </ref>, while -graph rewriting is not, as shown in the following example.
Reference: [27] <author> D. A. Turner. </author> <title> A new implementation technique for applicative languages. </title> <journal> Software Practice and Experience, </journal> <volume> 9 </volume> <pages> 31-49, </pages> <year> 1979. </year>
Reference-contexts: In other words, an unnecessary copy of M has been performed; no occurrence of the bound variable fi can occur in M , therefore, M can be safely shared between the two applications. In fact, this is the essence of lazy and fully lazy interpreters <ref> [12, 28, 27, 5] </ref>. This leads us to add the flattening rules displayed in Table 3; the new system is called fl 2 . The proviso in Table 3 is necessary for confluence.
Reference: [28] <author> C. Wadsworth. </author> <title> Semantics And Pragmatics Of The Lambda-Calculus. </title> <type> Ph.D. thesis, </type> <institution> University of Oxford, </institution> <month> September </month> <year> 1971. </year>
Reference-contexts: However, these concern acyclic expressions only. A related system for `explicit cyclic substitutions' has been given by Rose [25]. In this paper we are not concerned with optimality questions for acyclic -reduction as in the work of [21, 15, 10, 9]. We conclude with an indication that Wadsworth's interpreter <ref> [28] </ref> can be simulated in the -graph rewrite rules that we propose. 1 Lambda graphs as systems of recur sion equations In the first and most extensive part of the paper (Sections 1-7) we will consider -graph rewriting in a `naive' or `unrestricted' format. <p> So the occurrence of x in question should not be considered bound by x. Indeed, this convention is consistent with other ways of introducing cyclic -graphs (or as we will say interchangeably, systems of recursion equations). (One alternative way, introduced in <ref> [28] </ref>, is to render cyclic -graphs with pointers to binding 's instead of using variables x; y; z. But this way is convenient for pictures, not for linear textual representation.) It is not hard now to give a precise definition of free and bound variables x; y; . <p> In other words, an unnecessary copy of M has been performed; no occurrence of the bound variable fi can occur in M , therefore, M can be safely shared between the two applications. In fact, this is the essence of lazy and fully lazy interpreters <ref> [12, 28, 27, 5] </ref>. This leads us to add the flattening rules displayed in Table 3; the new system is called fl 2 . The proviso in Table 3 is necessary for confluence. <p> This suggests that in order to avoid the extra complication of detecting mfe's at run time as in <ref> [28] </ref>, an expression can be first pre-processed by well-known techniques [13, 14]. Then doing sharing of arguments is enough to capture the amount of sharing offered by Wadsworth's interpreter.
References-found: 28

