URL: http://simon.cs.cornell.edu/Info/People/pientka/KI97_final.ps
Refering-URL: http://simon.cs.cornell.edu/Info/People/pientka/
Root-URL: 
Email: fstefan,pientkag@inferenzsysteme.informatik.th-darmstadt.de  
Title: Structured Incremental Proof Planning  
Author: Stefan Gerberding and Brigitte Pientka 
Affiliation: Technical University of Darmstadt  
Abstract: We extend our framework of incremental proof planning. By employing nested sets of meta-rules the formulation of strategies may be structured. By switching to another meta-rule set the planner can adjust to a new situation within the proof. The new meta-rule set represents a more specialized strategy better suited for the current situation. We define the semantics of our framework by an inference system. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Robert S. Boyer and J Strother Moore. </author> <title> A Computational Logic. </title> <booktitle> ACM Monograph Series. </booktitle> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: An automated induction theorem prover has various techniques at its disposal. Some are general purpose calculi. Others are specially tailored for certain situations within a proof: Rippling for the rewrite of the conclusion in the step-cases of an induction to make the induction hypothesis applicable [3], generalization, fertilization <ref> [1] </ref>, the computation of induction axioms to choose an appropriate induction relation [5], or symbolic evaluation, case-splits, etc. Those techniques are modeled as tactics [4]. Different approaches are known to control the application of tactics. Some systems apply certain tactics in a fixed order (waterfall), e.g. nqthm [1]. <p> [3], generalization, fertilization <ref> [1] </ref>, the computation of induction axioms to choose an appropriate induction relation [5], or symbolic evaluation, case-splits, etc. Those techniques are modeled as tactics [4]. Different approaches are known to control the application of tactics. Some systems apply certain tactics in a fixed order (waterfall), e.g. nqthm [1]. Any heuristics to control the application of the different inference mechanisms are hard-coded into the order of application. Other systems leave the control mostly to the user.
Reference: 2. <author> Alan Bundy. </author> <title> A science of reasoning. </title> <editor> In J.-L. Lassez and G. Plotkin, editors, </editor> <booktitle> Computational Logic: Essays in Honor of Alan Robinson, </booktitle> <pages> pages 178-198. </pages> <publisher> MIT press, </publisher> <year> 1991. </year>
Reference-contexts: Other systems leave the control mostly to the user. This is either done implicitly by inserting hints or appropriate lemmata into the problem description or the user explicitly calls the desired tactic. To overcome the control problem for tactics Bundy proposes the use of proof plans <ref> [2] </ref>. Proof plans can be generated automatically if meta-reasoning about tactics is possible. In Bundy's framework the proof plan is computed prior to any proof attempt, i.e. before executing any tactic. The result of the tactics are estimated or simulated for the computation of the new subgoals during proof planning. <p> Experimental Results. 4 Conclusion, Related and Future Work While our technique is forward chaining, a mixed forward/backward chaining technique is presented in [7]. There the tactic knowledge is split into a declarative part and a procedural part. The latter can be interpreted during proof checking. Similar to <ref> [2] </ref> (higher order) formula schemes are used to represent tactics' pre-and postconditions. A method similar to incremental proof planning has been introduced in [12], but a meta-reasoning step consists of speculating lemmata (new goals) which in turn are verified by other automated theorem provers.
Reference: 3. <author> Alan Bundy, Andrew Stevens, Frank van Harmelen, Alan Smaill, and Andrew Ireland. Rippling: </author> <title> A heuristic for guiding inductive proofs. </title> <journal> Artificial Intelligence, </journal> <volume> 62(2) </volume> <pages> 185-253, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: An automated induction theorem prover has various techniques at its disposal. Some are general purpose calculi. Others are specially tailored for certain situations within a proof: Rippling for the rewrite of the conclusion in the step-cases of an induction to make the induction hypothesis applicable <ref> [3] </ref>, generalization, fertilization [1], the computation of induction axioms to choose an appropriate induction relation [5], or symbolic evaluation, case-splits, etc. Those techniques are modeled as tactics [4]. Different approaches are known to control the application of tactics.
Reference: 4. <author> R. L. Constable, T. B. Knoblock, and J. L. Bates. </author> <title> Writing programs that construct proofs. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 1 </volume> <pages> 285-326, </pages> <year> 1985. </year>
Reference-contexts: Those techniques are modeled as tactics <ref> [4] </ref>. Different approaches are known to control the application of tactics. Some systems apply certain tactics in a fixed order (waterfall), e.g. nqthm [1]. Any heuristics to control the application of the different inference mechanisms are hard-coded into the order of application.
Reference: 5. <author> Stefan Gerberding and Axel Noltemeier. </author> <title> Choosing induction relations within the INKA system (extended abstract). </title> <booktitle> In Proceedings of the 19th German Annual Conference on Artificial Intelligence, </booktitle> <address> Bielefeld, Germany, </address> <pages> pages 329-331, </pages> <year> 1995. </year>
Reference-contexts: Some are general purpose calculi. Others are specially tailored for certain situations within a proof: Rippling for the rewrite of the conclusion in the step-cases of an induction to make the induction hypothesis applicable [3], generalization, fertilization [1], the computation of induction axioms to choose an appropriate induction relation <ref> [5] </ref>, or symbolic evaluation, case-splits, etc. Those techniques are modeled as tactics [4]. Different approaches are known to control the application of tactics. Some systems apply certain tactics in a fixed order (waterfall), e.g. nqthm [1].
Reference: 6. <author> Stefan Gerberding and Axel Noltemeier. </author> <title> Incremental proof planning by meta-rules. </title> <booktitle> In Proceedings of the 10th FLAIRS Conference, </booktitle> <address> Daytona Beach, Fa., </address> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: The proof plan is passed to the proof checker to verify that its execution yields a valid proof. 2 Incremental Proof Planning These drawbacks are obsolete for incremental proof planning <ref> [6] </ref>. The knowledge about the domain of application, i.e. the strategy, and about tactics is declaratively represented by meta-rules: triples consisting of a precondition, an action, and a persistence condition. The knowledge about the partial proof and the proof plan is located in the proof-tree. <p> Since the complete strategy information used by the proof planner is declaratively represented by the sets of meta-rules, the user may easily modify the strategy by supplying new sets of meta-rules. In x2.1 we will briefly explain the framework of incremental proof planning introduced in <ref> [6] </ref>. We will extend our presentation by specifying a set of inference rules defining the semantics of incremental proof planning. In the remainder of this paper we will then focus on incremental proof planning with meta-rule sets. <p> A meta-variable may be bound to positions, symbols, terms, formulae, proof-tree nodes, etc. depending on the type 2 of the formal parameter of the corresponding meta-predicate. Using pql the user is able to specify appropriate meta-predicates, which are needed to express the desired strategy. For details we refer to <ref> [6, 9] </ref>. The condition C C 1 (x fl 1 )^: : :^C n (x fl n ) is satisfiable (for the given proof-tree representing the current situation) iff a consistent binding for the meta-variables x fl n exists, s.t. all meta-predicates are satisfied.
Reference: 7. <author> Xiaorong Huang, Manfred Kerber, Jorn Richts, and Arthur Sehn. </author> <title> Planning math-ematical proofs with methods. </title> <type> SEKI Report SR-94-08, </type> <institution> Universitat Kaiserslautern, </institution> <year> 1994. </year>
Reference-contexts: Experimental Results. 4 Conclusion, Related and Future Work While our technique is forward chaining, a mixed forward/backward chaining technique is presented in <ref> [7] </ref>. There the tactic knowledge is split into a declarative part and a procedural part. The latter can be interpreted during proof checking. Similar to [2] (higher order) formula schemes are used to represent tactics' pre-and postconditions.
Reference: 8. <author> Andrew Ireland and Alan Bundy. </author> <title> Productive use of failure in inductive proofs. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 16 </volume> <pages> 79-111, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: For other examples a case-split is used first, followed by an induction to verify the step-case. So we combine non-inductive case-splits and induction on demand, which is the key idea of lazy induction. Examples 7-10 are taken from <ref> [8] </ref>. We observe that we need less lemmata. In [8] exploiting the failure of an inductive proof is proposed. Lemmata are speculated or an inappropriate induction scheme is revised, in order to succeed. <p> For other examples a case-split is used first, followed by an induction to verify the step-case. So we combine non-inductive case-splits and induction on demand, which is the key idea of lazy induction. Examples 7-10 are taken from <ref> [8] </ref>. We observe that we need less lemmata. In [8] exploiting the failure of an inductive proof is proposed. Lemmata are speculated or an inappropriate induction scheme is revised, in order to succeed. Utilizing the additional information of the partial proof resp. proof plan we are able to prove these theorems merely by case analysis and induction.
Reference: 9. <author> Axel Noltemeier. Inkrementelle Beweisplanung mit Metaregeln. </author> <type> Diploma Thesis, </type> <institution> University of Darmstadt, </institution> <year> 1996. </year>
Reference-contexts: A meta-variable may be bound to positions, symbols, terms, formulae, proof-tree nodes, etc. depending on the type 2 of the formal parameter of the corresponding meta-predicate. Using pql the user is able to specify appropriate meta-predicates, which are needed to express the desired strategy. For details we refer to <ref> [6, 9] </ref>. The condition C C 1 (x fl 1 )^: : :^C n (x fl n ) is satisfiable (for the given proof-tree representing the current situation) iff a consistent binding for the meta-variables x fl n exists, s.t. all meta-predicates are satisfied. <p> P [cur] ambiguously identifies cur as some leaf of the tree P . We use sub-calculi ` c resp. ` a to model the evaluation of conditions resp. actions. Conditions: The notion of satisfiability of a meta-predicate atom mp (v fl ) is defined by pql <ref> [9] </ref>, see also x2.1. The ` c -calculus operates on triples consisting of a proof-tree, a meta-variable binding, and a condition. A c-derivation is a sequence of triples : : : ; T i1 ; T i ; : : :, s.t. <p> The strategy knowledge is structured in several sets of meta-rules. Switching the active meta-rule set adopts the strategy to the current situation. We demonstrated our approach with a solution to the control problem for proofs requiring case analysis and induction. Our technique is implemented in the Tiger proof planner <ref> [9, 10] </ref>.
Reference: 10. <author> Brigitte Pientka. Strukturierung der Beweisplanung durch Metaregelmengen. </author> <type> Diploma Thesis, </type> <institution> University of Darmstadt, </institution> <year> 1997. </year>
Reference-contexts: The inference rules operate on triples consisting of a stack of meta-rule sets, a stack of meta-variable bindings, and the proof-tree. The inference rules treat a meta-rule set M as unordered set. The meta-strategy deciding which meta-rule to apply as well as the backtracking behavior (cf. x2.3 and <ref> [10] </ref>) is not defined by the inference system. <p> The strategy knowledge is structured in several sets of meta-rules. Switching the active meta-rule set adopts the strategy to the current situation. We demonstrated our approach with a solution to the control problem for proofs requiring case analysis and induction. Our technique is implemented in the Tiger proof planner <ref> [9, 10] </ref>.
Reference: 11. <author> Martin Protzen. </author> <title> Lazy generation of induction hypotheses. </title> <booktitle> In Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <address> Nancy, France, </address> <publisher> LNAI 814, </publisher> <pages> pages 42-56. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: In the remainder of this paper we will then focus on incremental proof planning with meta-rule sets. To demonstrate the power of the extended framework, we will model a strategy for induction theorem proving similar to lazy induction <ref> [11] </ref> by meta-rule sets. 2.1 Overview The partial proof and the proof plan is represented by the proof-tree. All information in the proof-tree is available to the planner. A proof-tree is a labeled and-or-tree. The nodes' labels are closed first-order formulae. The root is labeled by the conjecture. <p> Fig. 1 presents the meta-rule set eval, which is the initial meta-rule set for the strategy outlined above. We iterate over eval and apply special techniques for nested cases, symbolic evaluation, and case analysis. This strategy is similar to lazy induction <ref> [11] </ref>. meta-rule-set eval nested-case: nested-case (Hyp) ) meta-rule-set manipulate-hypo (Hyp) until solved (Goal) _ sym-eval-p (Term) sym-eval: sym-eval-p (Term) ) sym-eval (current,Term) csp: need-case-split (Term) ) case-split (F,current), if base-case (Term) then meta-rule-set eval until solved (Goal) else meta-rule-set eval-step until no-meta-rule-applicable (S) Fig. 1.
Reference: 12. <author> Inger Sonntag and Jorg Denzinger. </author> <title> Extending automated theorem proving by planning. </title> <type> SEKI Report SR-93-02, </type> <institution> Universitat Kaiserslautern, </institution> <year> 1993. </year>
Reference-contexts: There the tactic knowledge is split into a declarative part and a procedural part. The latter can be interpreted during proof checking. Similar to [2] (higher order) formula schemes are used to represent tactics' pre-and postconditions. A method similar to incremental proof planning has been introduced in <ref> [12] </ref>, but a meta-reasoning step consists of speculating lemmata (new goals) which in turn are verified by other automated theorem provers. As with our technique meta-level and object-level reasoning are interleaved.
References-found: 12

