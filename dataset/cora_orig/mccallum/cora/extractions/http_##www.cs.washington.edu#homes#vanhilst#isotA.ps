URL: http://www.cs.washington.edu/homes/vanhilst/isotA.ps
Refering-URL: http://www.cs.washington.edu/homes/vanhilst/research.html
Root-URL: 
Email: fvanhilst,notking@cs.washington.edu  
Title: Using C++ Templates to Implement Role-Based Designs  
Author: Michael VanHilst and David Notkin 
Address: Box 352350 Seattle, WA 98195-2350 USA  
Affiliation: Department of Computer Science Engineering University of Washington  
Abstract: Within the object-oriented technology community, much recent work on design reuse has focused on role-based collaborations distributed across multiple objects. Many benefits can be derived by mapping role-based designs directly into implementations, including greater ease in maintaining the connection between designs and implementations under change, and the opportunity for code reuse along with design reuse. Current efforts in role-based designs do not generally provide these benefits. We provide a method for mapping role-based designs into implementation, preserving the design without unnecessary constraints on the design structures. Roles are represented as parameterized classes, where the parameters represent the types of the participants in the collaboration. Composition of roles is implicit in the binding of parameters to classes in the implementation. The bindings are created at compile time by class definitions that are separate from the role implementations. In this paper we focus on the use of templates in the C++ language as the supporting mechanism.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. S. Batory and S. O'Malley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Class and type definitions to compose multiple refinements and traversals. 5 Related Work A variety of research has addressed either the composition of parts of objects to form the objects of an application, or the use of type parameters to achieve flexible implementations. Batory et al. <ref> [1, 2] </ref> have developed a number of code generators that compose sets of object features, called factors, to form complete classes. Batory's type equations compose the factors into classes in much the same way our class definition statements compose the roles of a participant to form its type.
Reference: [2] <author> Don Batory, Vivek Singhal, Marty Sirkin, and Jeff Thomas. </author> <title> Scalable software libraries. </title> <booktitle> In Proceedings of the First ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 191-199, </pages> <year> 1993. </year>
Reference-contexts: We separate composition from role implementation using a series of class definitions. The specifications contained in the class definitions are analogous to the type equations used by Batory <ref> [2] </ref> to specify the composition of classes in his data structure generator. In addition, they form a kind of textual description of the structure of the entire design of the application, analogous to a class dictionary in Demeter [14]. <p> Class and type definitions to compose multiple refinements and traversals. 5 Related Work A variety of research has addressed either the composition of parts of objects to form the objects of an application, or the use of type parameters to achieve flexible implementations. Batory et al. <ref> [1, 2] </ref> have developed a number of code generators that compose sets of object features, called factors, to form complete classes. Batory's type equations compose the factors into classes in much the same way our class definition statements compose the roles of a participant to form its type.
Reference: [3] <author> Kent Beck and Ward Cunningham. </author> <title> A laboratory for teaching object-oriented thinking. </title> <booktitle> In Proceedings of the 1989 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 1-6, </pages> <year> 1989. </year>
Reference-contexts: Successful design reuse is characterized by the ability to construct new applications by composing new parts with reused parts sculpted to fit the new context. Within the object-oriented technology community, much recent work on design reuse has focused on collaborations of responsibilities distributed across multiple objects <ref> [3, 6, 9, 17] </ref>. "[N]o object is an island" [3, p. 2]: instead, each object has roles that it plays in collaboration with other objects. Designs are composed from groups of these collaborations, where each collaboration abstracts a task or concern in the design that may be appropriate for reuse. <p> Within the object-oriented technology community, much recent work on design reuse has focused on collaborations of responsibilities distributed across multiple objects [3, 6, 9, 17]. "[N]o object is an island" <ref> [3, p. 2] </ref>: instead, each object has roles that it plays in collaboration with other objects. Designs are composed from groups of these collaborations, where each collaboration abstracts a task or concern in the design that may be appropriate for reuse. <p> Current efforts in role-based designs do not provide this benefit. Some approaches encourage implementation structures in which the design-level structures are not visible, weakening the connection between the two levels. Beck and Cunningham <ref> [3] </ref> and Reenskaug, et al. [18], for example, each allow an object's multiple roles to be combined at the design level, but, once combined, lose the identity of individual roles.
Reference: [4] <author> Gilad Bracha. </author> <title> The programming language JIGSAW: Mixins, Modularity and Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1992. </year>
Reference-contexts: They do not use parameterized inheritance (or any inheritance, for that matter) and have not considered using templates as a structuring mechanism for entire applications. But some of the ways in which they use template programming could be applied alongside those suggested here. Bracha <ref> [4, 5] </ref> addressed the use of types with parameterized superclasses, which he called mixins. 5 His work dealt largely with extending languages to support mixins, but also addressed merge semantics and module composition.
Reference: [5] <author> Gilad Bracha and William Cooke. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 303-311, </pages> <year> 1990. </year>
Reference-contexts: They do not use parameterized inheritance (or any inheritance, for that matter) and have not considered using templates as a structuring mechanism for entire applications. But some of the ways in which they use template programming could be applied alongside those suggested here. Bracha <ref> [4, 5] </ref> addressed the use of types with parameterized superclasses, which he called mixins. 5 His work dealt largely with extending languages to support mixins, but also addressed merge semantics and module composition.
Reference: [6] <author> Eric Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Successful design reuse is characterized by the ability to construct new applications by composing new parts with reused parts sculpted to fit the new context. Within the object-oriented technology community, much recent work on design reuse has focused on collaborations of responsibilities distributed across multiple objects <ref> [3, 6, 9, 17] </ref>. "[N]o object is an island" [3, p. 2]: instead, each object has roles that it plays in collaboration with other objects. Designs are composed from groups of these collaborations, where each collaboration abstracts a task or concern in the design that may be appropriate for reuse.
Reference: [7] <author> William Harrison and Harold Ossher. </author> <title> Subject-oriented programming (a critique of pure objects). </title> <booktitle> In Proceedings of the 1993 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 411-428, </pages> <year> 1993. </year>
Reference-contexts: While we also separate the implementation code from the specification structure, we have chosen to use a more traditional object oriented model and restrict ourselves to using the features found in a widely used language. Harrison and Ossher <ref> [7, 8] </ref> have been working on composing fragments of object-oriented programs under the name subject-oriented programming. Their approach uses a special dispatcher that "merges" classes by rerouting method calls. Their system allows a variety of merging semantics.
Reference: [8] <author> William Harrison, Harold Ossher, Randall B. Smith, and David Ungar. </author> <booktitle> Subjectivity in object-oriented systems workshop summary. In Addendum to the Proceedings of the 1993 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 131-136, </pages> <year> 1994. </year>
Reference-contexts: While we also separate the implementation code from the specification structure, we have chosen to use a more traditional object oriented model and restrict ourselves to using the features found in a widely used language. Harrison and Ossher <ref> [7, 8] </ref> have been working on composing fragments of object-oriented programs under the name subject-oriented programming. Their approach uses a special dispatcher that "merges" classes by rerouting method calls. Their system allows a variety of merging semantics.
Reference: [9] <author> Richard Helm, Ian M. Holland, and Dipayan Gangopadhyay. </author> <title> Contracts: Specifying behavioral compositions in object-oriented systems. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 169-180, </pages> <year> 1990. </year>
Reference-contexts: Successful design reuse is characterized by the ability to construct new applications by composing new parts with reused parts sculpted to fit the new context. Within the object-oriented technology community, much recent work on design reuse has focused on collaborations of responsibilities distributed across multiple objects <ref> [3, 6, 9, 17] </ref>. "[N]o object is an island" [3, p. 2]: instead, each object has roles that it plays in collaboration with other objects. Designs are composed from groups of these collaborations, where each collaboration abstracts a task or concern in the design that may be appropriate for reuse.
Reference: [10] <author> Ian M. Holland. </author> <title> The Design and Representation of Object-Oriented Components. </title> <type> PhD thesis, </type> <institution> Northeastern University, </institution> <year> 1992. </year>
Reference-contexts: Holland's framework implementation required a "lens" mechanism | a kind of modal filter | that added an extra layer of indirection to support two separate traversals <ref> [10] </ref>. In concurrent applications, only one mode could be active at a time.
Reference: [11] <author> Ian M. Holland. </author> <title> Specifying reusable components using contracts. </title> <booktitle> In Proceedings of the 1992 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 287-308, </pages> <year> 1992. </year>
Reference-contexts: Other approaches may maintain a clear association between design and implementation for the roles of one or two collaborations, but are difficult to apply to designs consisting of many collaborations. An example of this is Holland's use of frameworks <ref> [11] </ref>. In practice, approaches such as frameworks may constrain the designs that are used because developers often restrict themselves to designs that they believe can be implemented in a reasonably straightforward way. <p> Section 5 discusses related work, while Section 6 presents our discussion. Our conclusion appears in Section 7. 2 Role-Based Design: An Example Holland's <ref> [11] </ref> design for graph traversal is a simple but useful example of role-based design. It provides a foundation for understanding and comparing the implementation structures defined using the framework approach as well as our template-based approach.
Reference: [12] <author> Ralph Johnson and Brian Foote. </author> <title> Designing reusable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(2) </volume> <pages> 22-35, </pages> <month> June/July </month> <year> 1988. </year>
Reference-contexts: The participant view captures conventional notions of object-oriented design; without it, connections to implementation would be difficult. The collaborative view captures cross-cutting aspects of designs, such as DepthFirstTraver-sal; without it, the relationships across objects are lost. 3 The Framework Implementation Holland uses a framework <ref> [12] </ref> to implement the basic collaborations from the design. The participants in the collaborations are implemented as classes, while roles from a refinement are added to these participants by subclassing. <p> Holland's design level description of DepthFirstTraversal reflected this specificity by including the details that the graph was undirected and used adjacency lists. As Johnson and Foote point out, "reusing the edifice that ties the components together is usually possible only by copying and editing it" <ref> [12, p. 26] </ref>. A more serious problem is that it is difficult to apply more than one refinement to a given framework.
Reference: [13] <author> Karl J. Lieberherr and Arthur J. Riel. </author> <title> Demeter: A CASE study of software growth through parameterized classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(3) </volume> <pages> 8-22, </pages> <month> August/September </month> <year> 1988. </year>
Reference-contexts: Batory's work has focused on broadly used domains, such as data structures. The general-purpose nature of these domains encourages both careful domain analysis and also the development of specialized generators. With comparatively low overhead, our approach provides much of the same flexibility for arbitrary applications. Lieberherr's Demeter <ref> [13, 14, 15] </ref> is a system that also addresses extensible structures in object-oriented development, and combines design reuse with source code reuse. Like our approach, Demeter minimizes and localizes dependencies on the class structure, and separates the specification of behavior from the specification of structure.
Reference: [14] <author> Karl J. Lieberherr and Cun Xiao. </author> <title> Minimizing dependency on class structures with adaptive programs. </title> <booktitle> In Object Technologies for Advanced Software: Proceedings of the First JSSST International Symposium, </booktitle> <pages> pages 424-441, </pages> <year> 1993. </year>
Reference-contexts: In addition, they form a kind of textual description of the structure of the entire design of the application, analogous to a class dictionary in Demeter <ref> [14] </ref>. The details of this aspect of the approach, as presented in this paper, depend on some C++-specifics about class naming and templates. <p> Batory's work has focused on broadly used domains, such as data structures. The general-purpose nature of these domains encourages both careful domain analysis and also the development of specialized generators. With comparatively low overhead, our approach provides much of the same flexibility for arbitrary applications. Lieberherr's Demeter <ref> [13, 14, 15] </ref> is a system that also addresses extensible structures in object-oriented development, and combines design reuse with source code reuse. Like our approach, Demeter minimizes and localizes dependencies on the class structure, and separates the specification of behavior from the specification of structure.
Reference: [15] <author> Karl J. Lieberherr and Cun Xiao. </author> <title> Object-oriented software evolution. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(4) </volume> <pages> 313-343, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Batory's work has focused on broadly used domains, such as data structures. The general-purpose nature of these domains encourages both careful domain analysis and also the development of specialized generators. With comparatively low overhead, our approach provides much of the same flexibility for arbitrary applications. Lieberherr's Demeter <ref> [13, 14, 15] </ref> is a system that also addresses extensible structures in object-oriented development, and combines design reuse with source code reuse. Like our approach, Demeter minimizes and localizes dependencies on the class structure, and separates the specification of behavior from the specification of structure.
Reference: [16] <author> D. R. Musser and A. A. Stepanov. </author> <title> Algorithm-oriented generic libraries. </title> <journal> Software Practice and Experience, </journal> <volume> 24(7) </volume> <pages> 623-642, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Their approach uses a special dispatcher that "merges" classes by rerouting method calls. Their system allows a variety of merging semantics. Our approach stays within the semantics of inheritance and aggregation and does not require any special, extra-language mechanisms. Musser, Stepanov and Lee <ref> [16] </ref> have recently gained attention in the C++ community for their work on libraries of generic container classes and iterators. Their work has helped push builders of compilers for C++ to provide better support for parameterized types.
Reference: [17] <author> Trygve Reenskaug and Egil P. Anderson. </author> <title> System design by composing structures of interacting objects. </title> <booktitle> In Proceedings of the 1992 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 133-152, </pages> <year> 1992. </year>
Reference-contexts: Successful design reuse is characterized by the ability to construct new applications by composing new parts with reused parts sculpted to fit the new context. Within the object-oriented technology community, much recent work on design reuse has focused on collaborations of responsibilities distributed across multiple objects <ref> [3, 6, 9, 17] </ref>. "[N]o object is an island" [3, p. 2]: instead, each object has roles that it plays in collaboration with other objects. Designs are composed from groups of these collaborations, where each collaboration abstracts a task or concern in the design that may be appropriate for reuse.
Reference: [18] <author> Trygve Reenskaug, Egil P. Anderson, Arne Jorgen Berre, Anne Hurlen, Anton Landmark, Odd Arild Lehne, Else Nordhagen, Erik Ness-Ulseth, Gro Oftedal, Anne Lise Skaar, and Pal Stenslet. OORASS: </author> <title> Seamless support for the creation and maintenance of object-oriented systems. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 5(6) </volume> <pages> 27-41, </pages> <month> October </month> <year> 1992. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Current efforts in role-based designs do not provide this benefit. Some approaches encourage implementation structures in which the design-level structures are not visible, weakening the connection between the two levels. Beck and Cunningham [3] and Reenskaug, et al. <ref> [18] </ref>, for example, each allow an object's multiple roles to be combined at the design level, but, once combined, lose the identity of individual roles.
References-found: 18

