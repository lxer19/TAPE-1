URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1008/CS-TR-91-1008.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1008/
Root-URL: http://www.cs.wisc.edu
Email: srinivas@cs.wisc.edu  
Title: On-Line Index Construction Algorithms  
Author: V. Srinivasan Michael J. Carey 
Address: Madison, WI 53706  
Affiliation: Department of Computer Sciences University of Wisconsin  
Abstract: In this paper, we present several algorithms for on-line index construction. These algorithms each permit an index to be built while the corresponding data is concurrently accessed for reads and writes. The algorithms work incrementally, producing a consistent index in the end. They differ in the data structures used for storing concurrent updates as well as in the degree of concurrency allowed during index construction. We provide proofs that the algorithms presented here indeed create a consistent index in the presence of concurrent updates.
Abstract-found: 1
Intro-found: 1
Reference: [Baye72] <author> Bayer, R. and McCreight, </author> <title> E.M. "Organization and Maintainance of Large Ordered Indices", </title> <journal> Acta Informatica, </journal> <month> 1(3) 173-189 </month> <year> (1972). </year>
Reference: [Come79] <author> Comer, D. </author> <title> "The Ubiquitous B-Tree", </title> <journal> ACM Computing Surveys, </journal> <volume> 11(4) 412 (1979). </volume>
Reference-contexts: Thus, a B-tree is a multi-level index with the topmost level being the single root page 1 By B-tree we mean the variant in which all keys are stored at the leaves, often called B + -trees <ref> [Come79] </ref>. 2 A key is usually meant to imply that associated information for that value exists in the index. A separator value defines a search path to leaf pages that contain the actual keys and associated information. 2 and the lowest level consisting of the set of leaf pages.
Reference: [Dewi90] <author> DeWitt, D. J. and Gray, J. </author> <title> "Parallel Database Systems: The Future of Database Processing or a Passing Fad?", </title> <booktitle> SIGMOD Record, </booktitle> <month> 19(4) December </month> <year> 1990. </year>
Reference-contexts: In fact, leading researchers have identified the problem of on-line index construction for very large databases as an important open research This research was partially supported by the National Science Foundation under grant IRI-8657323 and by a University of Wisconsin Vilas Fellowship. 1 problem <ref> [Dewi90, Silb90] </ref>. In this paper, we present several algorithms for on-line index construction.
Reference: [Gray79] <author> Gray, J. </author> <title> "Notes On Database Operating Systems", Operating Systems: An Advanced Course, </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Updaters are assumed to hold an Intention-exclusive lock on the relation while modifying a page of the relation (a la the hierarchical locking scheme of <ref> [Gray79] </ref>) and would therefore be unable to execute concurrently with the index building process. On the other hand, readers (which only acquire an Intention-share lock on the relation) can access the relation's pages concurrently with the building process. The pseudo code for this algorithm is given in Figure 4.
Reference: [John89] <author> Johnson, T. and Shasha, D. </author> <title> "Utilization of B-trees with Inserts, Deletes and Searches", </title> <booktitle> ACM Symposium on Principles of Database Systems, </booktitle> <pages> 235-246, </pages> <year> 1989. </year>
Reference-contexts: A B-link tree page split is illustrated in Figure 1. B-trees in real database systems usually perform merges only when pages becomes empty; nodes are not required to contain at least d entries, since this does not decrease occupancy by much in practical workloads <ref> [John89] </ref>. We therefore assume this approach to B-tree merges for this study. 2.2 Supporting Concurrent Tree Operations Concurrent operations on a B-tree can be supported using the following variation of the B-link algorithm. This variation was shown to perform very well in a recent comparative performance study [Srin91].
Reference: [John90] <author> Johnson, T. and Shasha, D. </author> <title> "A Framework for the Performance Analysis of Concurrent B-Tree Algorithms", </title> <booktitle> Proceedings of the 9th Symposium on Principles of Database Systems, </booktitle> <year> (1990). </year>
Reference-contexts: The rest of the paper is organized as follows. Section 2 briefly reviews the B-tree index structure and describes the B-link concurrency control algorithm [Lehm81] for supporting concurrent B-tree operations. Earlier studies <ref> [John90, Srin91] </ref> have shown that the B-link algorithm provides the most concurrency among B-tree concurrency control algorithms proposed in the literature (see [Srin91] for details). In Section 3, we describe the basic steps involved in building a B-tree index. We describe a simple off-line index construction algorithm in Section 4.
Reference: [Lani86] <author> Lanin, V. and Shasha, D. </author> <title> "A Symmetric Concurrent B-tree Algorithm", </title> <booktitle> Proceedings of the Fall Joint Computer Conference , 380-389. </booktitle> <year> (1986) </year>
Reference-contexts: After a half-split, and before the &lt;key, pointer&gt; pair corresponding to the new page has been inserted into the parent page, the new page is reachable through the right link of the old page. Merges can also be done in two steps <ref> [Lani86] </ref>, via a half-merge followed by entry deletion at the next higher level. A B-link tree page split is illustrated in Figure 1.
Reference: [Lehm81] <author> Lehman, P., and Yao, S. </author> <title> "Efficient Locking for Concurrent Operations on B-trees", </title> <journal> ACM Transactions on Database Systems, </journal> <month> 6(4) December </month> <year> 1981. </year>
Reference-contexts: However, the techniques presented here are also likely to be useful in designing on-line algorithms for other types of index structures. The rest of the paper is organized as follows. Section 2 briefly reviews the B-tree index structure and describes the B-link concurrency control algorithm <ref> [Lehm81] </ref> for supporting concurrent B-tree operations. Earlier studies [John90, Srin91] have shown that the B-link algorithm provides the most concurrency among B-tree concurrency control algorithms proposed in the literature (see [Srin91] for details). In Section 3, we describe the basic steps involved in building a B-tree index. <p> All nodes at a level are linked from left to right; that is, we assume the B-link tree structure described in <ref> [Lehm81] </ref>. Each page in a B-link tree contains a high key (the highest key in the subtree rooted at the page) and a link to the right sibling of the page. A B-link tree node is illustrated in Figure 1a. <p> When an updater tries to insert into a full leaf page or to delete from a leaf page with only d entries, a page split or page merge occurs. The right link enables a page split to occur in two phases <ref> [Lehm81] </ref>: a half-split followed by the insertion of an index entry into the appropriate parent. After a half-split, and before the &lt;key, pointer&gt; pair corresponding to the new page has been inserted into the parent page, the new page is reachable through the right link of the old page.
Reference: [Moha91] <author> Mohan, C. and Narang, I. </author> <title> "Algorithms for Creating Indexes for Very Large Tables Without Quiescing Updates", IBM Research Report, </title> <address> RJ 8016 March 1991. </address>
Reference: [Pu85] <author> Pu, C. </author> <title> "On-the-Fly, Incremental, Consistent Reading of Entire Databases", </title> <booktitle> Proceedings of the International Conference on Very Large Data Bases, </booktitle> <month> 369-375 </month> <year> (1985). </year>
Reference-contexts: We know of only one commercial DBMS (from Synapse) that used an on-line algorithm for index construction [Wood91]. The full details of this algorithm have not been published; we only know that it used a strategy similar to an incremental dump <ref> [Pu85] </ref> to collect the index entries from the relation, after which it built an index using these entries and then applied the concurrent updates recorded in the system log to the new index, to make it consistent. <p> It therefore appears that there is a smaller chance of a concurrency problem arising here as compared to the list case. If the requirement of immediate index updates is considered undesirable, it can be relaxed by employing the page coloring technique of <ref> [Pu85] </ref>. In this strategy, all relation pages are colored "white" when the build process starts. As soon as a relation page is scanned in the scan phase, it is colored "black.".
Reference: [Seli79] <author> Selinger, P., </author> <title> et al "Access Path Selection in a Relational Database Management System", </title> <booktitle> Proceedings of the SIGMOD Conference, </booktitle> <month> June </month> <year> 1979. </year>
Reference: [Shap86] <author> Shapiro, L. </author> <title> "Join Processing in Database Systems with Large Main Memories", </title> <journal> ACM Transactions on Database Systems, </journal> <month> 11(3) September </month> <year> 1986. </year>
Reference-contexts: The appropriate (key, rid) entries from a page are copied into a heap file which is the output of this function. Sort: This procedure sorts a heap file of (key, rid) entries into increasing key order using a method like the (two-phase) sort-merge algorithm described in <ref> [Shap86] </ref>. A heap file is scanned producing runs of size p N pages, where N is the number of pages in the heap file. Next, these runs are concurrently merged. <p> Next, these runs are concurrently merged. This causes at most 4N I/Os (2N I/Os more than that for an in-memory sort), and it works as long as p N pages of memory are available for use by the sort <ref> [Shap86] </ref>.
Reference: [Silb90] <author> Silberschatz, A., Stonebraker, M. and Ullman, J. D. </author> <title> "Database Systems: Achievements and Opportunities", </title> <booktitle> SIGMOD Record, </booktitle> <month> 19(4) December </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Database sizes are growing rapidly, and future databases are expected to be several orders of magnitude larger than the largest databases in operation today. Databases on the order of terabytes (10 12 bytes) will soon be in active use <ref> [Silb90] </ref>. This explosion in database sizes will necessitate the scaling up of all the algorithms used in a DBMS, including the class of database utilities. These utilities are typically used for re-organization of data and for construction and maintenance of hidden data structures like indices. <p> In fact, leading researchers have identified the problem of on-line index construction for very large databases as an important open research This research was partially supported by the National Science Foundation under grant IRI-8657323 and by a University of Wisconsin Vilas Fellowship. 1 problem <ref> [Dewi90, Silb90] </ref>. In this paper, we present several algorithms for on-line index construction.
Reference: [Srin91] <author> Srinivasan, V. and Carey, M. J. </author> <title> "Performance of B-tree Concurrency Control Algorithms", </title> <booktitle> To Appear in Proceedings of the SIGMOD Conference, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: The rest of the paper is organized as follows. Section 2 briefly reviews the B-tree index structure and describes the B-link concurrency control algorithm [Lehm81] for supporting concurrent B-tree operations. Earlier studies <ref> [John90, Srin91] </ref> have shown that the B-link algorithm provides the most concurrency among B-tree concurrency control algorithms proposed in the literature (see [Srin91] for details). In Section 3, we describe the basic steps involved in building a B-tree index. We describe a simple off-line index construction algorithm in Section 4. <p> Section 2 briefly reviews the B-tree index structure and describes the B-link concurrency control algorithm [Lehm81] for supporting concurrent B-tree operations. Earlier studies [John90, Srin91] have shown that the B-link algorithm provides the most concurrency among B-tree concurrency control algorithms proposed in the literature (see <ref> [Srin91] </ref> for details). In Section 3, we describe the basic steps involved in building a B-tree index. We describe a simple off-line index construction algorithm in Section 4. After describing index updates in Section 5, we discuss various on-line index construction algorithms in Sections 6, 7 and 8. <p> We therefore assume this approach to B-tree merges for this study. 2.2 Supporting Concurrent Tree Operations Concurrent operations on a B-tree can be supported using the following variation of the B-link algorithm. This variation was shown to perform very well in a recent comparative performance study <ref> [Srin91] </ref>. A reader descends the tree from the root to a leaf using Share locks.
Reference: [Wood91] <author> Wood, D. </author> <type> "Personal Communication", </type> , <month> February, </month> <year> 1991. </year>
Reference-contexts: To the best of our knowledge, this is how most commercial database systems operate today. We know of only one commercial DBMS (from Synapse) that used an on-line algorithm for index construction <ref> [Wood91] </ref>. <p> For example, it is possible that a transaction undoing a record delete operation may obtain a different record id, in which case the abort-time index update will be an insert with the same key but a different record id <ref> [Wood91] </ref>. 6 List-Based Algorithms The list-based algorithms, like all on-line algorithms described in this paper, allow updaters to concurrently operate on the relation during the scan phase. Updaters that execute concurrently with an index construction process store index updates (corresponding to their relation updates) in a special update-list. <p> The code for the updaters is also the same here (Figure 8). 17 6.7 System Log Versus Update-List Instead of using a special update-list to store concurrent updates, the system log can be used for this purpose (as was done in a commercial DBMS from Synapse <ref> [Wood91] </ref>). The advantage of using the log would be that no changes are needed to the logic for concurrent updates, just as in the off-line algorithm. There are several disadvantages to using a log-based strategy to build an index on a large relation, however.
Reference: [Yao78] <author> Yao, A. C. </author> " <title> On Random 2-3 Trees", </title> <journal> Acta Informatica, </journal> <month> 9 159-170 </month> <year> (1978). </year> <title> 11 We recently learned of a newly-available technical report, which appeared while this paper was being finished up, that also proposes solutions to the problem of on-line index construction [Moha91]. A comparison of these two independently-developed approaches is another important topic for future work. </title> <type> 27 </type>
Reference-contexts: This strategy could be further optimized by grouping together all inserts from the sorted list that can be accom modated in a leaf page before making the next index traversal from the root page. 6 The expected leaf page occupancy of a B-tree built with random inserts is about 69% <ref> [Yao78] </ref>. 10 Build process begin R: Input relation A: Attribute of R on which to build index H: Heap file step 1: U [R,A] = empty, Phase [R, A] = scan step 2: H = Extract keys (R) step 3: H = Sort (H) step 4: Index [R, A] = Make
References-found: 16

