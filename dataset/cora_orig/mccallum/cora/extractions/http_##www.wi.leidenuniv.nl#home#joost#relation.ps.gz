URL: http://www.wi.leidenuniv.nl/home/joost/relation.ps.gz
Refering-URL: http://www.wi.leidenuniv.nl/home/joost/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: On the Relation Between Unity Properties and Sequences of States  
Author: R.T. Udink J.N. Kok 
Keyword: Semantic models, Unity, program refinement.  
Note: CONTENTS  
Address: P.O. Box 80.089, 3508 TB Utrecht, the Netherlands  P.O. Box 80.089, 3508 TB Utrecht, the Netherlands  
Affiliation: Utrecht University, Department of Computer Science,  Utrecht University, Department of Computer Science,  
Abstract: Stepwise refinement of programs has proven to be a suitable method for developing parallel and distributed programs. We examine and compare a number of different notions of program refinement for Unity. Two of these notions are based on execution sequences. Refinement corresponds to the reduction of the set of execution sequences, i.e. reducing the amount of nondeterminism. The other refinement notions are based on Unity properties as introduced by Chandy and Misra. The Unity approach is to refine specifications. Although it has proven a suitable formalism for deriving algorithms, it seems less suitable for handling implementation details. Following Sanders and Singh, we formalize program refinement in the Unity framework as the preservation of Unity properties. We show that Unity properties are not powerful enough to characterize execution sequences. As a consequence, the notion of property-preserving refinement differs from the notion of reducing the set of execution sequences. 
Abstract-found: 1
Intro-found: 1
Reference: [AL88] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <booktitle> In Proc. of the 3rd Annual IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 165-175, </pages> <address> Washington D.C., July 1988. </address> <publisher> Computer Society Press. </publisher>
Reference-contexts: We will first define some preliminaries. Let be the set of states and Seq = P ( fl ) be the domain of sets of state sequences. We use the hh:ii-brackets to denote sequences. For sequences an operator " is defined by Abadi and Lamport in <ref> [AL88] </ref> that removes stut-terings from a sequence, i.e., it replaces all maximal (finite or infinite) segments of identical states with the single state . E.g., ":hh 1 2 2 3 3 3 ii = hh 1 2 3 ii, if 1 , 2 , and 3 are different states. <p> Now we define these notions for all models. We use the connective in to indicate the model. For O 1 , the sets of sequences, we use a notion that corresponds to the idea of implementation as defined by Abadi and Lamport in <ref> [AL88] </ref>; a specification S 1 is implemented by a specification S 2 if every behavior of S 2 is allowed by S 1 . Going from specification to implementation, the set of execution sequences reduces.
Reference: [Bac90] <author> R.-J.R. </author> <title> Back. Refinement calculus, part II: Parallel and reactive programs. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </booktitle> <pages> pages 67-93. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference: [BKPR91] <author> F.S. de Boer, J.N. Kok, C Palamidessi, and J.J.M.M. Rutten. </author> <title> The failure of failures in a paradigm of asynchronous communication. </title> <editor> In J.C.M. Baeten and J.F. Groote, editors, </editor> <booktitle> CONCUR '91, Proceedings of the 2nd International Conference on Concurrency Theory, </booktitle> <pages> pages 111-126. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: If x &lt; 0, x can be decreased by the second statement of F . No statement of G has the same effect. Hence, for some compositional semantics it is not sufficient to have all execution sequences: we need a semantic model that allows for interleaving. Like <ref> [BKPR91] </ref>, we use an extended notion of sequences to make the model compositional. Extended sequences have holes and the intuition is that the holes can be filled by the environment (that is, another Unity program). Extended sequences are sequences of pairs of states. <p> We want to abstract from stuttering in the compositional model also. However, it is not possible to remove all stuttering from each extended sequence. Then, it would not be possible to derive the set of connected sequences. Like <ref> [BKPR91] </ref>, we only remove connected stutterings, and to make the model more abstract it is allowed to add stutterings. To remove connected stutterings, we define the operator ".
Reference: [CM88] <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design A Foundation. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction to Unity In this section a brief overview of Unity is given. Unity was introduced by Chandy and Misra in <ref> [CM88] </ref>. First, the Unity programming language is presented. Then, two logics for the language are discussed: a variation of the logic in [CM88] and a logic given by Sanders in [San91]. <p> 1 Introduction to Unity In this section a brief overview of Unity is given. Unity was introduced by Chandy and Misra in <ref> [CM88] </ref>. First, the Unity programming language is presented. Then, two logics for the language are discussed: a variation of the logic in [CM88] and a logic given by Sanders in [San91]. <p> The operational interpretation of p 7! CM q is that whenever p is true, q will become true within finite time. The definition of the leadsto CM property is slightly different from the definition given in <ref> [CM88] </ref>. It is a definition of Pachl given in [Pac90]. We use this notion because of its correspondence to the operational intuition of the leadsto property. We will discuss this in section 3. Using the three basic properties some "derived" properties can be defined. <p> In <ref> [CM88] </ref>, Chandy and Misra give many theorems to combine Unity properties and derive new properties from them, e.g., the Simple Conjunction Theorem p unless CM q p 0 unless CM q 0 p ^ p 0 unless CM q _ q 0 : They also propose a substitution axiom. <p> E CM [[F ]] ~ [] IU E CM [[G ]] = (I F " I G ; U F " U G ; (E F " U G ) [ (E G " U F )): The following theorem follows directly from the properties of program union given in <ref> [CM88] </ref>: Theorem 2.9 For Unity programs F and G IU E CM [[F ]] ~ [] IU E CM [[G ]] = IU E CM [[F []G ]]: We have defined a number of semantic models for Unity programs. Each semantic model induces a notion of refinement of programs.
Reference: [DS90] <author> E.W. Dijkstra and C.S. Scholten. </author> <title> Predicate Calculus and Program Semantics. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: The semantics of a single assignment statement can be given by its weakest liberal precondition wlp or strongest postcondition sp predicate transformers, as shown in <ref> [DS90] </ref>. Definition 1.2 Let (x := E ) be an assignment statement. The weakest liberal precondition and the strongest postcondition are defined as wlp:(x := E ):p b= p (E =x ); The predicate p (E/x) is the predicate p in which x is substituted by E . <p> They are defined in terms of the statements of the program. Because we will introduce a second logic later we subscript the properties by CM . A state of a Unity programs is a function from program variables to values. Following Dijkstra and Scholten <ref> [DS90] </ref>, we use square brackets to denote universal quantification over all states. Definition 1.4 (Chandy-Misra Logic) Let p; q be arbitrary predicates and F a Unity program.
Reference: [Liu89] <author> Z. Liu. </author> <title> A semantic model for UNITY. </title> <type> Technical Report Research report 144, </type> <institution> Computer Science Department, University of Warwick, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: We use the operational view that only states can be observed. This means that it is not visible which statement is executed and no stutterings are observed. This corresponds with the idea of the Unity properties that also abstract from stutterings. In <ref> [Liu89] </ref>, Liu gives the semantics of Unity programs in terms of fair execution sequences. This model resembles our first operational semantics. We start with two operational semantics for Unity programs. The first model gives a set of stutter-free sequences of states that may occur during an execution of the program.
Reference: [Mis90] <author> J. Misra. </author> <title> The importance of ensuring. </title> <booktitle> Notes on UNITY, </booktitle> <pages> 11-90, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Theorem 3.9 O 1 ! IU L S : However, the reverse arrow does not hold. Theorem 3.10 IU L S 6! O 1 : In fact, the counter-example of theorem 3.3 is a counter-example for this theorem also. However, this is not the only cause of trouble. In <ref> [Mis90] </ref>, Misra shows that the notion of ensuring is essential when program composition is examined. The following theorem shows that the ensures also provides a really finer distinction of sequences than the leadsto when programs are examined in isolation.
Reference: [Pac90] <author> J. Pachl. </author> <title> Three definitions of leads-to for UNITY. </title> <booktitle> Notes on UNITY, </booktitle> <pages> 23-90, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: The operational interpretation of p 7! CM q is that whenever p is true, q will become true within finite time. The definition of the leadsto CM property is slightly different from the definition given in [CM88]. It is a definition of Pachl given in <ref> [Pac90] </ref>. We use this notion because of its correspondence to the operational intuition of the leadsto property. We will discuss this in section 3. Using the three basic properties some "derived" properties can be defined.
Reference: [Pac92] <author> J. Pachl. </author> <title> A simple proof of a completeness result for leads-to in the UNITY logic. </title> <journal> Information Processing Letters, </journal> <volume> 41 </volume> <pages> 35-38, </pages> <year> 1992. </year>
Reference-contexts: unless S q in F h8z ; i : z = hh 0 ; 1 ; ii 2 O 1 [[F ]] :: (p ^ :q)( i ) ) (p _ q)( i+1 )i: Also, the leadsto property can be characterized in terms of sequences, as shown by Pachl in <ref> [Pac92] </ref>: Lemma 3.8 For a Unity program F p 7! S q in F h8z ; i : z = hh 0 ; 1 ; ii 2 O 1 [[F ]] :: p ( i ) ) h9j : j i :: q ( j )ii: The arrow O 1 !
Reference: [San90] <author> B.A. Sanders. </author> <title> Stepwise refinement of mixed specifications of concurrent programs. </title> <editor> In M. Broy and Jones C.B., editors, </editor> <booktitle> Proc. IFIP Working Conf. on Programming and Methods, </booktitle> <pages> pages 1-25. </pages> <publisher> Elsevier Science Publishers B.V. (North Holland), </publisher> <month> May </month> <year> 1990. </year>
Reference: [San91] <author> B.A. Sanders. </author> <title> Eliminating the substitution axiom from UNITY logic. </title> <journal> Formal Aspects of Computing, </journal> <volume> 3(2) </volume> <pages> 189-205, </pages> <year> 1991. </year>
Reference-contexts: Unity was introduced by Chandy and Misra in [CM88]. First, the Unity programming language is presented. Then, two logics for the language are discussed: a variation of the logic in [CM88] and a logic given by Sanders in <ref> [San91] </ref>. A Unity program has several parts that are called sections. (In the sequel Unity programs are denoted by F or G.) We will only consider a subset of Unity programs, namely, programs that are made up of the following sections. * An initially-section defining the initial values of variables. <p> This is because Unity properties also say something about the behavior of the program in states that are never reached during any program execution, e.g., the states where x &lt; 0 for program F . Sanders introduced a new logic to eliminate this problem in <ref> [San91] </ref>. The properties are changed in such a way that unreachable states are disregarded. This results in weaker properties than the properties as defined by Chandy and Misra. Before defining Sanders's properties we give predicate transformers wst and sst (weakest and strongest stable predicates) as given in [San91]. <p> this problem in <ref> [San91] </ref>. The properties are changed in such a way that unreachable states are disregarded. This results in weaker properties than the properties as defined by Chandy and Misra. Before defining Sanders's properties we give predicate transformers wst and sst (weakest and strongest stable predicates) as given in [San91]. Definition 1.5 1. The predicate wst :F :p is the weakest solution for q such that [q ) wlp:F :q ^ q ) p]: 2.
Reference: [Sin91] <author> A.K. Singh. </author> <title> Parallel programming: Achieving portability through abstraction. </title> <booktitle> In 11th International Conference on Distributed Computing Systems, </booktitle> <month> May </month> <year> 1991. </year>
Reference: [UK92] <author> R.T. Udink and J.N. Kok. </author> <title> On the relation between unity properties and sequences of states. </title> <type> Technical report, </type> <institution> Utrecht University, </institution> <year> 1992. </year>
Reference-contexts: Theorem 2.4 For Unity programs F ; G , (O 2 [[F ]] ~ [] O 2 [[G ]]) = O 2 [[F []G]]: Proofs of the theorems can be found in <ref> [UK92] </ref>. Next, we define an abstraction function fi that relates the two operational models. The idea is to take all the connected extended sequences.
References-found: 13

