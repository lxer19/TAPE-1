URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-90-58.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: Computing Reachable States of Parallel Programs  
Author: David P. Helmbold Charles E. McDowell 
Keyword: parallel processing, debugging, static program analysis  
Address: Santa Cruz, CA 95064  
Affiliation: Board of Studies in Computer and Information Sciences University of California at Santa Cruz  
Date: July 8, 1992  
Abstract: A concurrency history graph is a representation of the reachable states of a parallel program, A new abstraction for representing the state of a parallel program is presented. This new abstraction is more general than previous work by the authors. At the same time, the new abstraction makes it possible to produce concurrency history graphs that require much less storage than that suggested by a simple worst case complexity analysis. Concurrency history graphs based on this new abstraction form the foundation upon which a static analysis tool capable of detecting race conditions in parallel programs is being built. 
Abstract-found: 1
Intro-found: 1
Reference: [CKS90] <author> D. Callahan, K. Kennedy, and J. Subhlok. </author> <title> Analysis of event synchronization in a parallel programming tool. </title> <booktitle> In Proceedings of Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPOPP), SIGPLAN Notices, </booktitle> <pages> pages 21-30, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The need to identify access races in parallel programs is a well recognized problem. Current approaches to solving this difficult problem include compile time analysis <ref> [CKS90, McD89, YT88] </ref>, run time detection [HL85, DS90] and post mortem trace analysis [HMW90, EP88, EGP89, NM89]. No single approach has yet been developed that is clearly superior under all conditions.
Reference: [DS90] <author> A. Dinning and E. Schonberg. </author> <title> An empirical comparison of monitoring algorithms for access anomaly detection. </title> <booktitle> In Proceedings of Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPOPP), </booktitle> <year> 1990. </year>
Reference-contexts: 1 Introduction The need to identify access races in parallel programs is a well recognized problem. Current approaches to solving this difficult problem include compile time analysis [CKS90, McD89, YT88], run time detection <ref> [HL85, DS90] </ref> and post mortem trace analysis [HMW90, EP88, EGP89, NM89]. No single approach has yet been developed that is clearly superior under all conditions.
Reference: [EGP89] <author> P. A. Emrath, S. Ghosh, and D. A. Padua. </author> <title> Event synchronization analysis for debugging parallel programs. </title> <booktitle> In Supercomputing '89, </booktitle> <month> November </month> <year> 1989. </year> <title> Reno, </title> <address> NV. </address>
Reference-contexts: 1 Introduction The need to identify access races in parallel programs is a well recognized problem. Current approaches to solving this difficult problem include compile time analysis [CKS90, McD89, YT88], run time detection [HL85, DS90] and post mortem trace analysis <ref> [HMW90, EP88, EGP89, NM89] </ref>. No single approach has yet been developed that is clearly superior under all conditions. Furthermore, it is our belief that a program development system will include aspects of all three applying them in combination and separately as dictated by the application (and further research).
Reference: [EP88] <author> P. A. Emrath and D. A. Padua. </author> <title> Automatic detection of nondeterminacy in parallel programs. </title> <booktitle> In Proc. Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 89-99, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: 1 Introduction The need to identify access races in parallel programs is a well recognized problem. Current approaches to solving this difficult problem include compile time analysis [CKS90, McD89, YT88], run time detection [HL85, DS90] and post mortem trace analysis <ref> [HMW90, EP88, EGP89, NM89] </ref>. No single approach has yet been developed that is clearly superior under all conditions. Furthermore, it is our belief that a program development system will include aspects of all three applying them in combination and separately as dictated by the application (and further research).
Reference: [HL85] <author> D. Helmbold and D. Luckham. </author> <title> Debugging ada tasking programs. </title> <journal> IEEE Software, </journal> <volume> 2(2) </volume> <pages> 47-57, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: 1 Introduction The need to identify access races in parallel programs is a well recognized problem. Current approaches to solving this difficult problem include compile time analysis [CKS90, McD89, YT88], run time detection <ref> [HL85, DS90] </ref> and post mortem trace analysis [HMW90, EP88, EGP89, NM89]. No single approach has yet been developed that is clearly superior under all conditions.
Reference: [HMW90] <author> D. P. Helmbold, C. E. McDowell, and J. Z. Wang. </author> <title> Analyzing traces with anonymous synchronization. </title> <booktitle> In Proc. International Conference on Parallel Processing, </booktitle> <month> August </month> <year> 1990. </year> <note> 22 References </note>
Reference-contexts: 1 Introduction The need to identify access races in parallel programs is a well recognized problem. Current approaches to solving this difficult problem include compile time analysis [CKS90, McD89, YT88], run time detection [HL85, DS90] and post mortem trace analysis <ref> [HMW90, EP88, EGP89, NM89] </ref>. No single approach has yet been developed that is clearly superior under all conditions. Furthermore, it is our belief that a program development system will include aspects of all three applying them in combination and separately as dictated by the application (and further research).
Reference: [McD89] <author> C. E. McDowell. </author> <title> A practical algorithm for static analysis of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <month> June, </month> <year> 1989. </year>
Reference-contexts: 1 Introduction The need to identify access races in parallel programs is a well recognized problem. Current approaches to solving this difficult problem include compile time analysis <ref> [CKS90, McD89, YT88] </ref>, run time detection [HL85, DS90] and post mortem trace analysis [HMW90, EP88, EGP89, NM89]. No single approach has yet been developed that is clearly superior under all conditions.
Reference: [NM89] <author> R. Netzer and B. P. Miller. </author> <title> Detecting Data Races in Parallel Program Executions. </title> <type> Technical Report 894, </type> <institution> University of Wisconsin-Madison, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: 1 Introduction The need to identify access races in parallel programs is a well recognized problem. Current approaches to solving this difficult problem include compile time analysis [CKS90, McD89, YT88], run time detection [HL85, DS90] and post mortem trace analysis <ref> [HMW90, EP88, EGP89, NM89] </ref>. No single approach has yet been developed that is clearly superior under all conditions. Furthermore, it is our belief that a program development system will include aspects of all three applying them in combination and separately as dictated by the application (and further research).
Reference: [YT88] <author> M. Young and R. N. Taylor. </author> <title> Combining static concurrency analysis with symbolic execution. </title> <journal> IEEE Tran. on Software Engineering, </journal> <volume> 14(10) </volume> <pages> 1499-1511, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: 1 Introduction The need to identify access races in parallel programs is a well recognized problem. Current approaches to solving this difficult problem include compile time analysis <ref> [CKS90, McD89, YT88] </ref>, run time detection [HL85, DS90] and post mortem trace analysis [HMW90, EP88, EGP89, NM89]. No single approach has yet been developed that is clearly superior under all conditions.
References-found: 9

