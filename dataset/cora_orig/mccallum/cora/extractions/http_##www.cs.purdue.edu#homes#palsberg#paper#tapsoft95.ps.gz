URL: http://www.cs.purdue.edu/homes/palsberg/paper/tapsoft95.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: palsberg@daimi.aau.dk  
Title: Comparing Flow-based Binding-time Analyses  
Author: Jens Palsberg 
Keyword: -calculus.  
Address: Ny Munkegade, DK-8000 Aarhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Note: In Proc. TAPSOFT'95, Springer-Verlag (LNCS 915), pages 561-574.  
Abstract: Binding-time analyses based on flow analysis have been presented by Bondorf, Consel, Bondorf and Jtrgensen, and Schwartzbach and the present author. The analyses are formulated in radically different ways, making comparison non-trivial. In this paper we demonstrate how to compare such analyses. We prove that the first and the fourth analyses can be specified by constraint systems of a particular form, enabling direct comparison. As corollaries, we get that Bondorf's analysis is more conservative than ours, that both analyses can be performed in cubic time, and that the core of Bondorf's analysis is correct. Our comparison is of analyses that apply to the pure 1 Our Results 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Henk P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <year> 1981. </year>
Reference-contexts: Recall the - calculus <ref> [1] </ref>. Definition 1.
Reference: 2. <author> Anders Bondorf. </author> <title> Automatic autoprojection of higher order recursive equations. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 17(1-3):3-34, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: Several binding-time analyses of untyped higher-order languages such as Scheme use a flow analysis to obtain information about higher-order control flow. Such analyses have been presented by Bondorf <ref> [2] </ref>, Consel [4], Bondorf and Jtrgensen [3], and Schwartzbach and the present author [10]. The analyses are formulated in radically different ways, as follows: - Bondorf. <p> Consider the -term (x:xx)(y). Throughout we assume that free variables, in this case y, correspond to dynamic information. The task of a binding-time analysis is to assign either Stat (static) or Dyn (dynamic) to each subterm. This information can then be used to annotate the -term. Following Bondorf <ref> [2] </ref> and others, we label all abstractions and applications. Variables will also be labeled: if a variable is bound, then it is labeled with the label of the that binds it, and if it is free, then with an arbitrary label. <p> The following flow analysis uses a constraint system. It has been used by Schwartzbach and the present author in [12, 9], and in [8] is was proved equivalent to the flow analysis of Bondorf <ref> [2] </ref>, which in turn is based on Sestoft's [13]. Flow analysis is called closure analysis in some papers, including [2, 8]. <p> It has been used by Schwartzbach and the present author in [12, 9], and in [8] is was proved equivalent to the flow analysis of Bondorf [2], which in turn is based on Sestoft's [13]. Flow analysis is called closure analysis in some papers, including <ref> [2, 8] </ref>. For a -term E, the constraint system is a finite set of conditional clauses over inclusions of the form P P 0 , where P and P 0 are either meta-variables or elements of CSet (E). <p> (E) and (L 0 ; M 0 ) is the least solution of B 0 (E), then M M 0 , and by Lemma 5, T M (E) v T M 0 (E). 5 Equivalence Proofs 5.1 Bondorf 's Analysis The Original Formulation We recall the binding-time analysis of Bondorf <ref> [2] </ref>, with a few minor changes in the notation compared to his presentation. The analysis assumes that all labels are distinct. Bondorf's definition was originally given for a subset of Scheme; we have restricted it to the -calculus.
Reference: 3. <author> Anders Bondorf and Jesper Jtrgensen. </author> <title> Efficient analyses for realistic off-line partial evaluation. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(3) </volume> <pages> 315-346, </pages> <year> 1993. </year>
Reference-contexts: Several binding-time analyses of untyped higher-order languages such as Scheme use a flow analysis to obtain information about higher-order control flow. Such analyses have been presented by Bondorf [2], Consel [4], Bondorf and Jtrgensen <ref> [3] </ref>, and Schwartzbach and the present author [10]. The analyses are formulated in radically different ways, as follows: - Bondorf. Flow analysis is performed first, by abstract interpretation; and binding-time analysis is then performed by another abstract interpretation, using the computed flow information. - Consel.
Reference: 4. <author> Charles Consel. </author> <title> Binding time analysis for higher order untyped functional languages. </title> <booktitle> In Proc. ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 264-272, </pages> <year> 1990. </year>
Reference-contexts: Several binding-time analyses of untyped higher-order languages such as Scheme use a flow analysis to obtain information about higher-order control flow. Such analyses have been presented by Bondorf [2], Consel <ref> [4] </ref>, Bondorf and Jtrgensen [3], and Schwartzbach and the present author [10]. The analyses are formulated in radically different ways, as follows: - Bondorf. Flow analysis is performed first, by abstract interpretation; and binding-time analysis is then performed by another abstract interpretation, using the computed flow information. - Consel.
Reference: 5. <author> Carsten K. Gomard. </author> <title> Partial type inference for untyped functional programs. </title> <booktitle> In Proc. ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 282-287, </pages> <year> 1990. </year>
Reference-contexts: By Theorem 14, T M (E) is well-annotated. We thus get that Bondorf's analysis, when restricted to the pure -calculus, is correct. 6 Concluding Remarks In a previous paper [10], we proved that the type inference based binding-time analysis of Gomard <ref> [5] </ref> is more conservative than the analysis of PS. In the papers [7, 10] we emphasized that the analysis of PS was originally intended to capture the outputs of the binding-time analyses of Bondorf and Consel.
Reference: 6. <author> Hanne R. Nielson and Flemming Nielson. </author> <title> Automatic binding time analysis for a typed -calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 10 </volume> <pages> 139-176, </pages> <year> 1988. </year>
Reference-contexts: In the annotated term, all dynamic abstractions and applications are underlined. The language of annotated terms is usually called a 2-level -calculus <ref> [6] </ref> and is defined as follows. Definition 3.
Reference: 7. <author> Jens Palsberg. </author> <title> Correctness of binding-time analysis. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(3) </volume> <pages> 347-363, </pages> <year> 1993. </year>
Reference-contexts: Annotated -terms are called 2-level -terms. Consistency means that no static computation can depend on the result of a dynamic computation <ref> [7] </ref>. Notice that only abstraction and application symbols can be annotated. We do not need to annotate variables because a free variable is dynamic and the binding-time of a bound variable is the same as that of the that binds it. <p> Our equivalence proofs makes it possible to relate Bondorf's analysis to a known correctness result for binding-time analysis <ref> [7] </ref>. We thereby obtain the first proof of correctness for the core of Bondorf's analysis. In the following section we recall from [8] a constraint system that specifies flow analysis. <p> Theorem 11. For every -term E, the three binding-time analyses defined in Section 5.1.1, 5.1.2, and by the SF-system B 0 (E) are equivalent. Proof. Combine Lemmas 9 and 10. 5.2 The Well-annotatedness Predicate The Original Formulation We recall the binding-time analysis of Schwartz-bach and me <ref> [10, 7] </ref>, with a few minor changes in the notation compared to the previous presentations. First, we introduce two new forms of meta-variables. A meta-variable is of one of the forms [[-l ]], [[ l ]], [[@ i ]], [[ l ]], and [[@ i ]]. <p> In conclusion, T M (E) = W l . From Theorem 15 follows the desired result: Theorem 16. For every -term E, the binding-time analyses defined in Section 5.2.1 and by the SF-system B (E) are equivalent. In previous work <ref> [7] </ref>, we proved that any binding-time analysis that always produces well-annotated 2-level terms is correct. Since for every -term E, we have B (E) B 0 (E), the least solution (L; M ) of B 0 (E) is also a solution of B (E). <p> We thus get that Bondorf's analysis, when restricted to the pure -calculus, is correct. 6 Concluding Remarks In a previous paper [10], we proved that the type inference based binding-time analysis of Gomard [5] is more conservative than the analysis of PS. In the papers <ref> [7, 10] </ref> we emphasized that the analysis of PS was originally intended to capture the outputs of the binding-time analyses of Bondorf and Consel. With the result of this paper, it is now clarified that the analyses of Bondorf is more conservative than the analysis of PS.
Reference: 8. <author> Jens Palsberg. </author> <title> Closure analysis in constraint form. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> 1995. To appear. Also in Proc. </note> <editor> CAAP'94, </editor> <booktitle> Colloquium on Trees in Algebra and Programming, </booktitle> <publisher> Springer-Verlag (LNCS 787), </publisher> <pages> pages 276-290, </pages> <address> Edinburgh, Scotland, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: Our equivalence proofs makes it possible to relate Bondorf's analysis to a known correctness result for binding-time analysis [7]. We thereby obtain the first proof of correctness for the core of Bondorf's analysis. In the following section we recall from <ref> [8] </ref> a constraint system that specifies flow analysis. In Section 4 we define SF-systems and we present the two SF-systems that are equivalent to the analyses of Bondorf and PS. <p> The set CMap (E) with point-wise ordering, written , is a complete lattice where least upper bound is written t. The following flow analysis uses a constraint system. It has been used by Schwartzbach and the present author in [12, 9], and in <ref> [8] </ref> is was proved equivalent to the flow analysis of Bondorf [2], which in turn is based on Sestoft's [13]. Flow analysis is called closure analysis in some papers, including [2, 8]. <p> It has been used by Schwartzbach and the present author in [12, 9], and in [8] is was proved equivalent to the flow analysis of Bondorf [2], which in turn is based on Sestoft's [13]. Flow analysis is called closure analysis in some papers, including <ref> [2, 8] </ref>. For a -term E, the constraint system is a finite set of conditional clauses over inclusions of the form P P 0 , where P and P 0 are either meta-variables or elements of CSet (E). <p> Bondorf's analysis proceeds by first computing flow information by an abstract interpretation. In a previous paper <ref> [8] </ref> we proved that Bondorf's flow analysis is equivalent to computing the least solution of the constraint system C (E). So for a -term E, suppose that C (E) has least solution L. <p> The proof of this involves repeated use of Lemma 8 and is analogous to the proof of <ref> [8, Lemma 5] </ref>; we omit the details. Lemma 10. B 0 (E) has least solution (L; fst (Bt (E))). Proof. Similar to the proof of Lemma 9. Theorem 11.
Reference: 9. <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference for partial types. </title> <journal> Information Processing Letters, </journal> <volume> 43 </volume> <pages> 175-180, </pages> <year> 1992. </year>
Reference-contexts: The set CMap (E) with point-wise ordering, written , is a complete lattice where least upper bound is written t. The following flow analysis uses a constraint system. It has been used by Schwartzbach and the present author in <ref> [12, 9] </ref>, and in [8] is was proved equivalent to the flow analysis of Bondorf [2], which in turn is based on Sestoft's [13]. Flow analysis is called closure analysis in some papers, including [2, 8].
Reference: 10. <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Binding-time analysis: Abstract interpretation versus type inference. </title> <booktitle> In Proc. ICCL'94, Fifth IEEE International Conference on Computer Languages, </booktitle> <pages> pages 289-298, </pages> <address> Toulouse, France, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Several binding-time analyses of untyped higher-order languages such as Scheme use a flow analysis to obtain information about higher-order control flow. Such analyses have been presented by Bondorf [2], Consel [4], Bondorf and Jtrgensen [3], and Schwartzbach and the present author <ref> [10] </ref>. The analyses are formulated in radically different ways, as follows: - Bondorf. Flow analysis is performed first, by abstract interpretation; and binding-time analysis is then performed by another abstract interpretation, using the computed flow information. - Consel. <p> Previously, no complexity analysis has been given for the analysis of Bondorf, and the best-known algorithm for the analysis of PS has so far been one with worst-case exponential running time <ref> [10] </ref>. Our equivalence proofs makes it possible to relate Bondorf's analysis to a known correctness result for binding-time analysis [7]. We thereby obtain the first proof of correctness for the core of Bondorf's analysis. In the following section we recall from [8] a constraint system that specifies flow analysis. <p> Theorem 11. For every -term E, the three binding-time analyses defined in Section 5.1.1, 5.1.2, and by the SF-system B 0 (E) are equivalent. Proof. Combine Lemmas 9 and 10. 5.2 The Well-annotatedness Predicate The Original Formulation We recall the binding-time analysis of Schwartz-bach and me <ref> [10, 7] </ref>, with a few minor changes in the notation compared to the previous presentations. First, we introduce two new forms of meta-variables. A meta-variable is of one of the forms [[-l ]], [[ l ]], [[@ i ]], [[ l ]], and [[@ i ]]. <p> For every W 1 @ i W 2 in W , the set consisting of var (W 1 ) = var (W 2 ) = [[@ i ]] = Dyn. Fact 13 For all -terms, there is a v-least well-annotated version. Proof. See <ref> [10] </ref>. We can now do binding-time analysis of a -term by computing the v-least well-annotated version. <p> By Theorem 14, T M (E) is well-annotated. We thus get that Bondorf's analysis, when restricted to the pure -calculus, is correct. 6 Concluding Remarks In a previous paper <ref> [10] </ref>, we proved that the type inference based binding-time analysis of Gomard [5] is more conservative than the analysis of PS. In the papers [7, 10] we emphasized that the analysis of PS was originally intended to capture the outputs of the binding-time analyses of Bondorf and Consel. <p> We thus get that Bondorf's analysis, when restricted to the pure -calculus, is correct. 6 Concluding Remarks In a previous paper [10], we proved that the type inference based binding-time analysis of Gomard [5] is more conservative than the analysis of PS. In the papers <ref> [7, 10] </ref> we emphasized that the analysis of PS was originally intended to capture the outputs of the binding-time analyses of Bondorf and Consel. With the result of this paper, it is now clarified that the analyses of Bondorf is more conservative than the analysis of PS.
Reference: 11. <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference-contexts: The desired binding-time information is then the mapping M . Each SF-system has a least solution namely the component-wise greatest lower bound of all solutions. The least solution of an SF-system can be computed in cubic time using a straightforward modification of the algorithm in [12] (see also <ref> [11, Chapter 5] </ref>). Given a -term E, the following SF-system yields a binding-time analysis of E. For a -term E, the constraint system B (E) is the union of C (E) and the following sets of constraints. The singleton set consisting of var b (E) = Dyn.
Reference: 12. <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference. </title> <journal> Information and Computation, </journal> <volume> 118(1) </volume> <pages> 128-141, </pages> <year> 1995. </year>
Reference-contexts: The set CMap (E) with point-wise ordering, written , is a complete lattice where least upper bound is written t. The following flow analysis uses a constraint system. It has been used by Schwartzbach and the present author in <ref> [12, 9] </ref>, and in [8] is was proved equivalent to the flow analysis of Bondorf [2], which in turn is based on Sestoft's [13]. Flow analysis is called closure analysis in some papers, including [2, 8]. <p> The desired binding-time information is then the mapping M . Each SF-system has a least solution namely the component-wise greatest lower bound of all solutions. The least solution of an SF-system can be computed in cubic time using a straightforward modification of the algorithm in <ref> [12] </ref> (see also [11, Chapter 5]). Given a -term E, the following SF-system yields a binding-time analysis of E. For a -term E, the constraint system B (E) is the union of C (E) and the following sets of constraints. The singleton set consisting of var b (E) = Dyn.
Reference: 13. <author> Peter Sestoft. </author> <title> Replacing function parameters by global variables. </title> <type> Master's thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <month> September </month> <year> 1989. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: The following flow analysis uses a constraint system. It has been used by Schwartzbach and the present author in [12, 9], and in [8] is was proved equivalent to the flow analysis of Bondorf [2], which in turn is based on Sestoft's <ref> [13] </ref>. Flow analysis is called closure analysis in some papers, including [2, 8]. For a -term E, the constraint system is a finite set of conditional clauses over inclusions of the form P P 0 , where P and P 0 are either meta-variables or elements of CSet (E).
References-found: 13

