URL: ftp://dimacs.rutgers.edu/pub/dimacs/TechnicalReports/TechReports/1997/97-48.ps.gz
Refering-URL: http://dimacs.rutgers.edu/TechnicalReports/1997.html
Root-URL: http://www.cs.rutgers.edu
Email: manindra@iitk.ernet.in  allender@cs.rutgers.edu  sdatta@paul.rutgers.edu  
Title: by  
Author: Manindra Agrawal Eric Allender ; Samir Datta ; 
Address: Kanpur 208016, India  Piscataway, NJ 08855, USA  Piscataway, NJ 08855, USA  Chennai, India  
Affiliation: Department of Computer Science Indian Institute of Technology  Department of Computer Science Rutgers University  Department of Computer Science Rutgers University  scholar at the Institute of Mathematical Sciences,  
Note: On TC 0 AC 0 and Arithmetic Circuits 1  Complexity, 1997, pp. 134-148. 2 Part of this research was done while visiting the University of Ulm under an Alexander von Hum boldt Fellowship. 3 Permanent Member 4 Supported in part by NSF grant CCR-9509603.Portions of the work were performed while this author was a visiting  5 Affiliated Graduate Student Member 6 Supported in part by a Rutgers University Graduate Excellence Fellowship and by NSF grant CCR-9509603. DIMACS is a partnership of Rutgers University, Princeton University, AT&T Labs, Bellcore, and Bell Labs. DIMACS is an NSF Science and Technology Center, funded under contract STC-91-19999; and also receives support from the New Jersey Commission on Science and Technology.  
Abstract: DIMACS Technical Report 97-48 September 1997 
Abstract-found: 1
Intro-found: 1
Reference: [AH94] <author> E. Allender and U. Hertrampf, </author> <title> Depth Reduction for Circuits of Unbounded Fan-In. </title> <journal> Information and Computation, </journal> <volume> 112(2) </volume> <pages> 217-238, </pages> <year> 1994. </year>
Reference-contexts: Assume that #AC 0 k = #AC 0 k+1 for some k &gt; 0. It follows then that #AC 0 = #AC 0 k . Let A be a language in AC 0 but not in depth k AC 0 [2]. (See, for instance Proposition 11 in <ref> [AH94] </ref>. We can choose A to be the mod 3 of the first log a n bits, for some a.) The characteristic function of A is in #AC 0 , and therefore, in #AC 0 k by our assumption.
Reference: [ABO96] <author> E. Allender, R. Beals, and M. Ogihara. </author> <title> The complexity of matrix rank and feasible systems of linear equations. </title> <booktitle> In Proc. 28th ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 161-167, </pages> <year> 1996. </year>
Reference-contexts: has recently defined #AC 0 somewhat differently, and his definition does not appear comparable to ours. - 3 - PP and PL were first studied in [Gil77] and have been considered in many papers; C = P was studied in [Wag86] and elsewhere, and C = L was studied in <ref> [ABO96] </ref> (see also [ST]). PNC 1 and C = NC 1 were defined and studied in [CMTV96] (see also [Mac]). A main result of this paper is that PAC 0 and C = AC 0 coincide with TC 0 .
Reference: [AJ93a] <author> E. Allender and J. Jiao. </author> <title> Depth reduction for noncommutative arithmetic circuits. </title> <booktitle> In Proc. 25th ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 515-522, </pages> <year> 1993. </year>
Reference: [AJ93b] <author> C. Alvarez and B. Jenner. </author> <title> A very hard log-space counting class. </title> <journal> Theoretical Computer Science, </journal> <volume> 107 </volume> <pages> 3-30, </pages> <year> 1993. </year>
Reference-contexts: Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention <ref> [AJ93b, Vin91, Tod, MV] </ref>. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant [Vin91, Tod, Val92, MV].
Reference: [AJMV] <author> E. Allender, J. Jiao, M. Mahajan, and V. Vinay. </author> <title> Non-commutative arithmetic circuits: depth reduction and size lower bounds. </title> <note> To appear in Theoretical Computer Science. Preliminary versions appeared as [AJ93a, MV94]. </note>
Reference: [All] <author> E. Allender. </author> <title> The permanent requires large uniform threshold circuits. </title> <note> Submitted. A preliminary version of this paper appeared as [All96]. </note>
Reference-contexts: as multiplication, division, and sorting, as well as being a computational model for neural nets [RT92, CSV84, PS88].) It remains an open question as to whether every function in #P has TC 0 circuits (although it is at least known that not all #P functions have Dlogtime-uniform TC 0 circuits <ref> [All] </ref>). The main contribution of this paper is to present a new connection between AC 0 and TC 0 . We characterize TC 0 as being the class of languages that arises in several ways from counting the number of accepting subtrees of AC 0 circuits. <p> It is currently an open question whether a given bit of the permanent can be computed as the high-order bit of Dlogtime-uniform #AC 0 functions, although if the inclusion PAC 0 TC 0 holds also in the Dlogtime-uniform setting, then a negative answer would follow from the lower bound of <ref> [All] </ref>. The main obstacle to proving a Dlogtime-uniform analog to Theorem 18 seems to be the problem of finding a generator for the multiplicative group Z p .
Reference: [All89] <author> E. Allender. </author> <title> P-uniform circuit complexity. </title> <journal> J. ACM, </journal> <volume> 36 </volume> <pages> 912-928, </pages> <year> 1989. </year>
Reference-contexts: If there is an "efficient" algorithm for constructing C n , given n, then the family is said to be uniform, where different notions of "efficient" give rise to different notions of uniformity. We will consider P-uniform, Logspace-uniform, and Dlogtime-uniform circuit families. For P-uniform circuits <ref> [BCH86, All89] </ref>, the mapping n 7! C n is computable in polynomial time, for Logspace-uniform circuits [Ruz81], the mapping is computable in Logspace. Dlogtime-uniformity requires a somewhat more careful definition; we refer the reader to [BIS90].
Reference: [All96] <author> E. Allender. </author> <title> A note on uniform circuit lower bounds for the counting hierarchy. </title> <booktitle> In International Conference on Computing and Combinatorics Conference (COCOON), volume 1090 of Lecture Notes in Computer Science, </booktitle> <pages> pages 127-135. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: [AO94] <author> E. Allender and M. Ogihara. </author> <title> Relationships among PL, #L, and the determinant. </title> <booktitle> In Proc. 9th IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 267-278, </pages> <year> 1994. </year>
Reference-contexts: In order to develop this in a general setting, it is useful to define the "Gap" classes. The class GapP was defined in [FFK94], and by analogy GapL was studied in <ref> [Vin91, AO94] </ref>, and GapNC 1 was studied in [CMTV96]. In all of these cases, there are two equivalent definitions: 1. GapC is the class of functions that are the difference of two #C functions. 2.
Reference: [BCH86] <author> P. Beame, S. Cook, and H. J. </author> <title> Hoover. Log depth circuits for division and related problems. </title> <journal> SIAM J. Comput., </journal> <volume> 15 </volume> <pages> 994-1003, </pages> <year> 1986. </year>
Reference-contexts: If there is an "efficient" algorithm for constructing C n , given n, then the family is said to be uniform, where different notions of "efficient" give rise to different notions of uniformity. We will consider P-uniform, Logspace-uniform, and Dlogtime-uniform circuit families. For P-uniform circuits <ref> [BCH86, All89] </ref>, the mapping n 7! C n is computable in polynomial time, for Logspace-uniform circuits [Ruz81], the mapping is computable in Logspace. Dlogtime-uniformity requires a somewhat more careful definition; we refer the reader to [BIS90]. <p> Getting rid of the P-uniformity condition in Theorem 12 seems closely-related to the problem of finding Logspace-uniform (or Dlogtime-uniform) circuits for iterated integer multiplication, which in turn is equivalent to obtaining more uniform circuits for division <ref> [BCH86, IL95, RT92] </ref>. Another direction worth investigating concerns branching programs.
Reference: [BFS92] <author> J. Boyar, G. Frandsen, and G. Sturtivant. </author> <title> An arithmetical model of computation equivalent to threshold circuits. </title> <journal> Theoretical Computer Science, </journal> <volume> 93 </volume> <pages> 303-319, </pages> <year> 1992. </year> <month> - 26 </month> - 
Reference-contexts: Corollary 25 In the Logspace-Uniform Setting, TC 0 = C = AC 0 circ = PAC 0 circ : 5 Arithmetic Circuits over Finite Fields There has been earlier work characterizing TC 0 in terms of finite fields <ref> [BFS92, FVB94, RT92] </ref>. However, this earlier work provides no connection to AC 0 , and the characterizations involve having a different finite field for each input length.
Reference: [B97] <author> D. A. </author> <title> Mix Barrington, </title> <type> Personal Communication, </type> <year> 1997. </year>
Reference-contexts: 4 below, we have, - 9 - k1 X 2 ki1 Y #M j (x) 5 k1 X h i 4 j=0 3 = 2 kq 1 (n) j=1 = 2 kq 1 (n) #M (x): The proof is now complete except for the following lemmas. (As David Mix Barrington <ref> [B97] </ref> has pointed out, this first lemma can be understood intuitively as computing the volume of a k-dimensional cube of side a with a piece removed.) Lemma 4 Let a, a 1 ; : : : ; a k be integers, where a 0 = 1. <p> follows by an essentially identical proof. (The basis case needs to be augmented to deal with the constant 1.) A proof along these lines can also be used to show that #NC 1 is closed under the choose operation but (as was pointed out to us by David Mix Barrington <ref> [B97] </ref>) a much simpler proof suffices for #NC 1 , since one can show that #NC 1 is closed under the "monus" and "div m" operations for any constant m. (That is, if f is in #NC 1 , then so are the functions max (f (x) 1; 0), and df <p> It may be interesting to point out that, when one uses our notion of arithmetic circuits over finite fields, one obtains a characterization of ACC 0 . (It has been pointed out to us by David Mix Barrington <ref> [B97] </ref> that this is in some sense implicit in the work of Smolensky [Smo87].) We need the following fact from number theory. - 22 - Theorem 26 (Dirichlet) (see e.g. [HW79]) For any two relatively prime numbers q and r, there exist infinitely many primes in the sequence fqn + rg
Reference: [BIS90] <author> D. A. Mix Barrington, N. Immerman, and H. </author> <title> Straubing. </title> <journal> On uniformity within NC 1 . Journal of Computer and System Sciences, </journal> <volume> 41 </volume> <pages> 274-306, </pages> <year> 1990. </year>
Reference-contexts: We will consider P-uniform, Logspace-uniform, and Dlogtime-uniform circuit families. For P-uniform circuits [BCH86, All89], the mapping n 7! C n is computable in polynomial time, for Logspace-uniform circuits [Ruz81], the mapping is computable in Logspace. Dlogtime-uniformity requires a somewhat more careful definition; we refer the reader to <ref> [BIS90] </ref>. Although Dlogtime-uniformity is widely-regarded as being the "right" notion of uniformity to use when discussing small circuit complexity classes such as TC 0 and AC 0 , only a few of our theorems mention Dlogtime-uniformity.
Reference: [BT88] <author> D. A. Mix Barrington and D. Therien. </author> <title> Finite monoids and the fine structure of NC 1 . Journal of the ACM, </title> <booktitle> 35 </booktitle> <pages> 941-952, </pages> <year> 1988. </year>
Reference-contexts: Another direction worth investigating concerns branching programs. It is shown in [CMTV96] that #NC 1 is closely related to the problem of counting paths in bounded-width branching programs, and it is also known that AC 0 is the class of languages accepted by branching programs over acyclic monoids <ref> [BT88] </ref>.
Reference: [BT91] <author> Richard Beigel and Jun Tarui. </author> <booktitle> On ACC. 32nd Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 783-792, </pages> <year> 1991. </year>
Reference-contexts: We need the following fact (a proof of which can be found in <ref> [BT91, Fact 2.2] </ref>): a is divisible by 2 r iff 2 j is even for each 1 j r 1.
Reference: [CMTV96] <author> H. Caussinus, P. McKenzie, D. Therien, and H. Vollmer. </author> <title> Nondeterministic NC 1 computation. </title> <booktitle> In Proceedings, 11th Annual IEEE Conference on Computational Complexity, </booktitle> <pages> pages 12-21, </pages> <year> 1996. </year>
Reference-contexts: The counting classes that result in this way by arithmetizing the Boolean circuit classes - 2 - SAC 1 and NC 1 were studied in [Vin91] (where it was shown that #SAC 1 corresponds to counting the accepting paths of a NAuxPDA) and in <ref> [CMTV96] </ref> (where it was shown that #NC 1 is closely-related to counting paths in bounded-width branching programs). In this paper, we study #AC 0 . <p> In order to develop this in a general setting, it is useful to define the "Gap" classes. The class GapP was defined in [FFK94], and by analogy GapL was studied in [Vin91, AO94], and GapNC 1 was studied in <ref> [CMTV96] </ref>. In all of these cases, there are two equivalent definitions: 1. GapC is the class of functions that are the difference of two #C functions. 2. <p> PNC 1 and C = NC 1 were defined and studied in <ref> [CMTV96] </ref> (see also [Mac]). A main result of this paper is that PAC 0 and C = AC 0 coincide with TC 0 . However, there are two difficulties that must be overcome before we can even state this theorem. <p> Another direction worth investigating concerns branching programs. It is shown in <ref> [CMTV96] </ref> that #NC 1 is closely related to the problem of counting paths in bounded-width branching programs, and it is also known that AC 0 is the class of languages accepted by branching programs over acyclic monoids [BT88].
Reference: [CSV84] <author> A. Chandra, L. Stockmeyer, and U. Vishkin. </author> <title> Constant depth reducibility. </title> <journal> SIAM Journal on Computing, </journal> <volume> 13 </volume> <pages> 423-439, </pages> <year> 1984. </year>
Reference-contexts: is only poorly understood, in spite of having been the object of many investigations. (The class TC 0 is of special interest in computer science, since it characterizes the computational complexity of such important operations as multiplication, division, and sorting, as well as being a computational model for neural nets <ref> [RT92, CSV84, PS88] </ref>.) It remains an open question as to whether every function in #P has TC 0 circuits (although it is at least known that not all #P functions have Dlogtime-uniform TC 0 circuits [All]). <p> This circuit is clearly Logspace uniform from the Logspace computability of f . Composing this circuit with the circuit for g yields the required circuit. - 21 - * (of Lemma 24-2) Straightforward. * (of Lemma 24-3) This is well known (e.g. see <ref> [CSV84] </ref>). * (of Lemma 24-4) sum k = mod k ffi sum. Result follows from Lemmas 23-4, 24-3 and 24-1. * (of Lemma 24-5) Let g = ind g ffi mod p . Then prod p = pow g ffi sum p1 ffi ~g.
Reference: [DGS86] <author> L. Denenberg, Y. Gurevich, and S. Shelah. </author> <title> Definability by constant-depth polynomial-size circuits. </title> <journal> Information and Control, </journal> <volume> 70 </volume> <pages> 216-240, </pages> <year> 1986. </year>
Reference-contexts: function g (n) 6= log O (1) n, the function g (n) is not in #AC 0 , since this function is 0 iff f (x) &lt; g (n), and thus the underlying Boolean AC 0 circuit would be computing the g (n)-threshold function, which is not in AC 0 <ref> [FKPS85, DGS86] </ref>. (This shows merely that P g (n) is not in #AC 0 ; for an improvement of this result to a lower bound for GapAC 0 , see Theorem 11.) This argument leaves open the question of what happens when g (n) 6= O (1) but g (n) = <p> For g in this range, the g (n) threshold is computable in AC 0 <ref> [FKPS85, DGS86] </ref>, but the currently-known proofs of this fact do not preserve the number of accepting subtrees. - 14 - Open Question 6 Are the functions P log n and i x i Theorem 11 For every integer k 2, there are infinitely many integers n with the property that there
Reference: [DL91] <author> George I. Davida and Bruce Litow. </author> <title> Fast parallel arithmetic via modular representation. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(4) </volume> <pages> 756-765, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: But this follows from Lemma 24-7,8 below. (We remark that, instead of relying on [DMS94], it is also possible to make use of similar results of <ref> [Lit92, DL91] </ref>.
Reference: [DMS94] <author> Paul F. Dietz, Ioan I. Macarie, and Joel I. Seiferas. </author> <title> Bits and relative order from residues, space efficiently. </title> <journal> Information Processing Letters, </journal> <volume> 50(3) </volume> <pages> 123-127, </pages> <month> 9 May </month> <year> 1994. </year>
Reference-contexts: Remainder Theorem we know that the number in question (i.e. the number with residues x i modulo p i ) is X k = A k q k P k : Essentially we need to find out the first bit of the fractional representation of A k =P k . <ref> [DMS94] </ref> shows how to do this in Logspace. <p> to compute the first 3dlog 2 ie bits of each of the fractions t i;j (x) = ((x j c i;j ) mod p j )=p j (for 1 j i k) and find the sums q 0 P i j=1 t i;j (x) approximating A i =P i . <ref> [DMS94] </ref> show that if the fractional part of q 0 k (x) contains any zeros, then the first bit of the fractional part of q 0 k (x) is equal to the first bit of the fractional part of A k =P k (which is the bit that we need to <p> If the fractional parts of q 0 (x) and of q 0 (x 0 ) are both all ones, then <ref> [DMS94] </ref> show that the computation can be repeated using q 0 k1 approximating A k1 =P k1 (which in this case has the same bit as A k =P k ). <p> So we just need to show that each of the q 0 i 's and i fl can be computed using Logspace uniform TC 0 circuits. But this follows from Lemma 24-7,8 below. (We remark that, instead of relying on <ref> [DMS94] </ref>, it is also possible to make use of similar results of [Lit92, DL91]. It seems to us that the construction of [DMS94] results in a simpler circuit.) Lemma 23 The following are computable in O (log n) space where in the following x is n bits long and p; p <p> But this follows from Lemma 24-7,8 below. (We remark that, instead of relying on <ref> [DMS94] </ref>, it is also possible to make use of similar results of [Lit92, DL91]. It seems to us that the construction of [DMS94] results in a simpler circuit.) Lemma 23 The following are computable in O (log n) space where in the following x is n bits long and p; p i ; g; k; z are all O (log n) bits long. 1.
Reference: [Ete95] <author> K. Etessami. </author> <title> Counting quantifiers, successor relations, and logarithmic space. </title> <booktitle> In Proc. 10th IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 2-11, </pages> <year> 1995. </year>
Reference-contexts: can check if the graph on f1; : : : ; pg with edges i ! ig (modp) is a cycle. (It is a cycle if and only if g is a generator.) The problem of checking if a general graph is a cycle is complete for logspace (see, e.g., <ref> [Ete95] </ref>), and thus any argument handling the Dlogtime-uniform TC 0 case will almost certainly need to make use of special properties of this graph.
Reference: [FFK94] <author> Stephen A. Fenner, Lance J. Fortnow, and Stuart A. Kurtz. </author> <title> Gap-definable counting classes. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 48(1) </volume> <pages> 116-148, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: In order to develop this in a general setting, it is useful to define the "Gap" classes. The class GapP was defined in <ref> [FFK94] </ref>, and by analogy GapL was studied in [Vin91, AO94], and GapNC 1 was studied in [CMTV96]. In all of these cases, there are two equivalent definitions: 1. GapC is the class of functions that are the difference of two #C functions. 2. <p> For large enough constant k, the function ((2 n k f (x)) + g (x)) is in #AC 0 , by Theorem 3. 3.2 Closure Properties We begin with some simple closure properties. In <ref> [FFK94] </ref> the notions of "weak sum" and "weak product" were defined as follows: Definition 8 Let C be a class of functions. * C is closed under weak sum if, for any f 2 C and any k, the function g (x) = P n k is in C. * C <p> Proof.(of Theorem 9) Notice that once we know that #AC 0 is closed under the choose operation, it follows immediately that DiffAC 0 is closed as well (using essentially the same proof as that of Closure Property 5 in <ref> [FFK94] </ref>). We proceed by induction on the depth of the counting circuit computing the #AC 0 function. If the circuit has depth 0, then the claim follows trivially as f (x) assumes values 0 and 1 only. <p> By Corollary 6, f (x) is of the form h (x) 2 jxj l for some #AC 0 function h and some constant l. (This corollary shows that TC 0 is the AC 0 -analog of the class LWPP studied in <ref> [FFK94] </ref>. We refer the reader to [FFK94] for further details.) Corollary 17 is probably nearly the strongest result in this direction that one can prove. <p> By Corollary 6, f (x) is of the form h (x) 2 jxj l for some #AC 0 function h and some constant l. (This corollary shows that TC 0 is the AC 0 -analog of the class LWPP studied in <ref> [FFK94] </ref>. We refer the reader to [FFK94] for further details.) Corollary 17 is probably nearly the strongest result in this direction that one can prove. For instance, one might seek to strengthen Corollary 17 to obtain g (n) = 1. (This corresponds to the AC 0 -analog of the class SPP studied in [FFK94].) Note that if <p> the reader to <ref> [FFK94] </ref> for further details.) Corollary 17 is probably nearly the strongest result in this direction that one can prove. For instance, one might seek to strengthen Corollary 17 to obtain g (n) = 1. (This corresponds to the AC 0 -analog of the class SPP studied in [FFK94].) Note that if g (n) = 1, then the characteristic function of A is in GapAC 0 . However, it follows from Proposition 28 that any such language A is in AC 0 [2].
Reference: [FKPS85] <author> R. Fagin, M. Klawe, N. Pippenger, and L. Stockmeyer. Bounded-depth, </author> <title> polynomial-size circuits for symmetric functions. </title> <journal> Theoretical Computer Science, </journal> <volume> 36 </volume> <pages> 239-250, </pages> <year> 1985. </year>
Reference-contexts: function g (n) 6= log O (1) n, the function g (n) is not in #AC 0 , since this function is 0 iff f (x) &lt; g (n), and thus the underlying Boolean AC 0 circuit would be computing the g (n)-threshold function, which is not in AC 0 <ref> [FKPS85, DGS86] </ref>. (This shows merely that P g (n) is not in #AC 0 ; for an improvement of this result to a lower bound for GapAC 0 , see Theorem 11.) This argument leaves open the question of what happens when g (n) 6= O (1) but g (n) = <p> For g in this range, the g (n) threshold is computable in AC 0 <ref> [FKPS85, DGS86] </ref>, but the currently-known proofs of this fact do not preserve the number of accepting subtrees. - 14 - Open Question 6 Are the functions P log n and i x i Theorem 11 For every integer k 2, there are infinitely many integers n with the property that there
Reference: [FVB94] <author> G. Frandsen, M. Valence, and D. </author> <title> Mix Barrington. Some results on uniform arithmetic circuit complexity. </title> <journal> Mathematical Systems Theory, </journal> <volume> 27, </volume> <year> 1994. </year>
Reference-contexts: Corollary 25 In the Logspace-Uniform Setting, TC 0 = C = AC 0 circ = PAC 0 circ : 5 Arithmetic Circuits over Finite Fields There has been earlier work characterizing TC 0 in terms of finite fields <ref> [BFS92, FVB94, RT92] </ref>. However, this earlier work provides no connection to AC 0 , and the characterizations involve having a different finite field for each input length.
Reference: [Gil77] <author> J. Gill. </author> <title> Computational complexity of probabilistic Turing machines. </title> <journal> SIAM Journal on Computing, </journal> <volume> 6 </volume> <pages> 675-695, </pages> <year> 1977. </year>
Reference-contexts: () f (x) &gt; 0g, C = C = fAj9f 2 GapC, x 2 A () f (x) = 0g. 1 Tomo Yamakami [Yam96] has recently defined #AC 0 somewhat differently, and his definition does not appear comparable to ours. - 3 - PP and PL were first studied in <ref> [Gil77] </ref> and have been considered in many papers; C = P was studied in [Wag86] and elsewhere, and C = L was studied in [ABO96] (see also [ST]). PNC 1 and C = NC 1 were defined and studied in [CMTV96] (see also [Mac]).
Reference: [HW79] <author> G. H. Hardy and E. M. Wright. </author> <title> An Introduction to the Theory of Numbers. </title> <publisher> Oxford press, </publisher> <address> USA, </address> <year> 1979. </year> <month> - 27 </month> - 
Reference-contexts: We will need the following variant of the Chinese Remainder Theorem: - 18 - Theorem 19 (see e.g. <ref> [HW79] </ref>) Given primes p 1 ; p 2 ; : : : ; p s and an integer x, there are unique integers x 1 ; x 2 ; : : : ; x s (modulo p 1 ; p 2 ; : : : ; p s respectively), satisfying x <p> More explicitly, x = A s q s P s where A s = j=1 c s;j = (P s =p j ) mod p j ; And the following variant of the prime-number theorem: Theorem 20 (see e.g. <ref> [HW79] </ref>) For sufficiently large values of n, the product of all primes less than n exceeds 2 n . <p> fields, one obtains a characterization of ACC 0 . (It has been pointed out to us by David Mix Barrington [B97] that this is in some sense implicit in the work of Smolensky [Smo87].) We need the following fact from number theory. - 22 - Theorem 26 (Dirichlet) (see e.g. <ref> [HW79] </ref>) For any two relatively prime numbers q and r, there exist infinitely many primes in the sequence fqn + rg 1 n=1 .
Reference: [IL95] <author> N. Immerman and S. Landau. </author> <title> The complexity of iterated multiplication. </title> <journal> Information and Computation, </journal> <volume> 116 </volume> <pages> 103-116, </pages> <year> 1995. </year>
Reference-contexts: Getting rid of the P-uniformity condition in Theorem 12 seems closely-related to the problem of finding Logspace-uniform (or Dlogtime-uniform) circuits for iterated integer multiplication, which in turn is equivalent to obtaining more uniform circuits for division <ref> [BCH86, IL95, RT92] </ref>. Another direction worth investigating concerns branching programs.
Reference: [Lit92] <author> B. Litow. </author> <title> On iterated integer product. </title> <journal> Information Processing Letters, </journal> <volume> 42(5) </volume> <pages> 269-272, </pages> <month> 03 July </month> <year> 1992. </year>
Reference-contexts: But this follows from Lemma 24-7,8 below. (We remark that, instead of relying on [DMS94], it is also possible to make use of similar results of <ref> [Lit92, DL91] </ref>.
Reference: [Mac] <author> I. Macarie. </author> <title> Space-efficient deterministic simulation of probabilistic automata. </title> <note> To appear in SIAM J. Comput. Preliminary version appeared as [Mac94]. </note>
Reference-contexts: PNC 1 and C = NC 1 were defined and studied in [CMTV96] (see also <ref> [Mac] </ref>). A main result of this paper is that PAC 0 and C = AC 0 coincide with TC 0 . However, there are two difficulties that must be overcome before we can even state this theorem.
Reference: [Mac94] <author> I. Macarie. </author> <title> Space-efficient deterministic simulation of probabilistic automata. </title> <booktitle> In 11th Symposium on Theoretical Aspects of Computing (STACS), volume 775 of Lecture Notes in Computer Science, </booktitle> <pages> pages 109-122. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [MV] <author> M. Mahajan and V. Vinay. </author> <title> A combinatorial algorithm for the determinant. </title> <booktitle> In Proc. 8th ACM-SIAM Symposium on Discrete Algorithms (SODA), </booktitle> <publisher> ACM Press, </publisher> <year> 1997, </year> <pages> pp. 730-738. </pages>
Reference-contexts: Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention <ref> [AJ93b, Vin91, Tod, MV] </ref>. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant [Vin91, Tod, Val92, MV]. <p> Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention [AJ93b, Vin91, Tod, MV]. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant <ref> [Vin91, Tod, Val92, MV] </ref>.
Reference: [MV94] <author> M. Mahajan and V. Vinay. </author> <title> Non-commutative computation, depth reduction and skew circuits. </title> <booktitle> In Proc. 14th FST&TCS, volume 880 of Lecture Notes in Computer Science, </booktitle> <pages> pages 48-59. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [PS88] <author> I. Parberry and G. Schnitger. </author> <title> Parallel computation with threshold functions. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 36 </volume> <pages> 278-302, </pages> <year> 1988. </year>
Reference-contexts: is only poorly understood, in spite of having been the object of many investigations. (The class TC 0 is of special interest in computer science, since it characterizes the computational complexity of such important operations as multiplication, division, and sorting, as well as being a computational model for neural nets <ref> [RT92, CSV84, PS88] </ref>.) It remains an open question as to whether every function in #P has TC 0 circuits (although it is at least known that not all #P functions have Dlogtime-uniform TC 0 circuits [All]). <p> Theorem 12 P-uniform TC 0 P-uniform C = AC 0 and Dlogtime-uniform TC 0 Dlogtime uniform C = AC 0 circ . Proof. We will need to use the following well-known fact (see e.g. <ref> [PS88] </ref>), Fact 13 A problem is in TC 0 if and only if it is accepted by a constant-depth family of "exact-threshold" gates ET m m=2 (an ET s r gate has s inputs and outputs 1 iff exactly r of them are 1). Q m j=1;j6=m=2 (m=2 j).
Reference: [Raz87] <author> A. A. Razborov. </author> <title> Lower bounds on the size of bounded depth networks over a complete basis with logical addition. </title> <journal> Mathematicheskie Zametki, </journal> <volume> 41 </volume> <pages> 598-607, </pages> <year> 1987. </year> <booktitle> English translation in Mathematical Notes of the Academy of Sciences of the USSR </booktitle> 41:333-338, 1987. 
Reference-contexts: However, it follows from Proposition 28 that any such language A is in AC 0 [2]. Thus the lower bound of <ref> [Raz87] </ref> (showing that MAJORITY is not in AC 0 [2]) shows that we cannot improve Corollary 17 to obtain g (n) = 1. More generally, observe that the function g (n) has lots of small divisors. This is no accident. <p> For instance, the Mod 3 function is not in #AC 0 , as a consequence of Proposition 28 and the circuit lower bounds in <ref> [Raz87] </ref>. At the end of Section 3.2 we saw that some functions related to the symmetric polynomials are not in #AC 0 .
Reference: [RR94] <author> A. A. Razborov and S. Rudich. </author> <title> Natural proofs. </title> <booktitle> In Proceedings, 26th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 204-213, </pages> <year> 1994. </year>
Reference-contexts: Note that <ref> [RR94] </ref> argues that, if certain popular cryptographic assumptions are true, then there are no "natural proofs" of lower bounds for TC 0 circuits.
Reference: [RT92] <author> J. Reif and S. Tate. </author> <title> On threshold circuits and polynomial computation. </title> <journal> SIAM J. Comput., </journal> <volume> 21 </volume> <pages> 896-908, </pages> <year> 1992. </year>
Reference-contexts: is only poorly understood, in spite of having been the object of many investigations. (The class TC 0 is of special interest in computer science, since it characterizes the computational complexity of such important operations as multiplication, division, and sorting, as well as being a computational model for neural nets <ref> [RT92, CSV84, PS88] </ref>.) It remains an open question as to whether every function in #P has TC 0 circuits (although it is at least known that not all #P functions have Dlogtime-uniform TC 0 circuits [All]). <p> Proposition 14 C = AC 0 PAC 0 (under all considered notions of uniformity). Proposition 15 P-uniform (non-uniform) GapAC 0 P-uniform (non-uniform) FTC 0 . (This is a simple consequence of the fact that unbounded fan-in addition and multiplica tion are in P-uniform TC 0 <ref> [RT92] </ref>.) Corollary 16 In the P-Uniform and Non-Uniform Settings, C = AC 0 = PAC 0 = TC 0 = C = AC 0 circ = PAC 0 circ : Note that one interpretation of the preceding corollary is that TC 0 languages can be computed with just constant-depth arithmetic and <p> Corollary 25 In the Logspace-Uniform Setting, TC 0 = C = AC 0 circ = PAC 0 circ : 5 Arithmetic Circuits over Finite Fields There has been earlier work characterizing TC 0 in terms of finite fields <ref> [BFS92, FVB94, RT92] </ref>. However, this earlier work provides no connection to AC 0 , and the characterizations involve having a different finite field for each input length. <p> Getting rid of the P-uniformity condition in Theorem 12 seems closely-related to the problem of finding Logspace-uniform (or Dlogtime-uniform) circuits for iterated integer multiplication, which in turn is equivalent to obtaining more uniform circuits for division <ref> [BCH86, IL95, RT92] </ref>. Another direction worth investigating concerns branching programs.
Reference: [Ruz81] <author> W. Ruzzo. </author> <title> On uniform circuit complexity. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21 </volume> <pages> 365-383, </pages> <year> 1981. </year>
Reference-contexts: We will consider P-uniform, Logspace-uniform, and Dlogtime-uniform circuit families. For P-uniform circuits [BCH86, All89], the mapping n 7! C n is computable in polynomial time, for Logspace-uniform circuits <ref> [Ruz81] </ref>, the mapping is computable in Logspace. Dlogtime-uniformity requires a somewhat more careful definition; we refer the reader to [BIS90].
Reference: [Smo87] <author> R. Smolensky. </author> <title> Algebraic methods in the theory of lower bounds for Boolean circuit complexity. </title> <booktitle> In Proceedings, 19th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 77-82, </pages> <year> 1987. </year>
Reference-contexts: we will show how to compute the exact threshold predicate m X x i = m=2 (for any large enough m of the form 2 r ), using depth k + 1 AC 0 [2] circuits of size smaller than the 2 (m 1=2 (k+1) ) lower bound proved in <ref> [Smo87] </ref>. We need the following fact (a proof of which can be found in [BT91, Fact 2.2]): a is divisible by 2 r iff 2 j is even for each 1 j r 1. <p> has depth k + 1 AC 0 [2] circuits of size (n log k1 n ) O (1) = 2 O (m 1=3k 2 m (k1)=3k 2 ) = 2 O (m 1=3k ) which is asymptotically less than the lower bound of 2 (m 1=2 (k+1) ) given by <ref> [Smo87] </ref>. - 15 - 0 0 0 The most important step in proving this characterization involves showing how to simulate threshold circuits. Theorem 12 P-uniform TC 0 P-uniform C = AC 0 and Dlogtime-uniform TC 0 Dlogtime uniform C = AC 0 circ . Proof. <p> may be interesting to point out that, when one uses our notion of arithmetic circuits over finite fields, one obtains a characterization of ACC 0 . (It has been pointed out to us by David Mix Barrington [B97] that this is in some sense implicit in the work of Smolensky <ref> [Smo87] </ref>.) We need the following fact from number theory. - 22 - Theorem 26 (Dirichlet) (see e.g. [HW79]) For any two relatively prime numbers q and r, there exist infinitely many primes in the sequence fqn + rg 1 n=1 .
Reference: [ST] <author> M. Santha and S. Tan. </author> <title> Verifying the determinant in parallel. </title> <note> To appear in Computational Complexity. A preliminary version of this paper appeared in Proceedings of the 5th ACM-SIGSAM International Symposium on Symbolic and Algebraic Computation, 1994. - 28 </note> - 
Reference-contexts: #AC 0 somewhat differently, and his definition does not appear comparable to ours. - 3 - PP and PL were first studied in [Gil77] and have been considered in many papers; C = P was studied in [Wag86] and elsewhere, and C = L was studied in [ABO96] (see also <ref> [ST] </ref>). PNC 1 and C = NC 1 were defined and studied in [CMTV96] (see also [Mac]). A main result of this paper is that PAC 0 and C = AC 0 coincide with TC 0 .
Reference: [Tod] <author> S. </author> <title> Toda. Counting problems computationally equivalent to the determinant. </title> <type> Manuscript. </type>
Reference-contexts: Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention <ref> [AJ93b, Vin91, Tod, MV] </ref>. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant [Vin91, Tod, Val92, MV]. <p> Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention [AJ93b, Vin91, Tod, MV]. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant <ref> [Vin91, Tod, Val92, MV] </ref>.
Reference: [Tod92] <author> S. </author> <title> Toda. Classes of arithmetic circuits capturing the complexity of computing the determinant. </title> <journal> IEICE Trans. Inf. and Syst., </journal> <volume> E75-D:116-124, </volume> <year> 1992. </year>
Reference-contexts: of accepting subtrees of a circuit C is (a) equal to the output of the "arithmetized" version of C, (which we denote by #C) and (b) provides a natural notion of counting the number of proofs that C accepts.) The arithmetic circuits corresponding to #L were studied further by Toda <ref> [Tod92] </ref>.
Reference: [Val79a] <author> L. Valiant. </author> <title> Completeness classes in algebra. </title> <booktitle> In Proc. 11th ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 249-261, </pages> <year> 1979. </year>
Reference: [Val79b] <author> L. Valiant. </author> <title> The complexity of computing the Permanent. </title> <journal> Theoretical Computer Science, </journal> <volume> 8 </volume> <pages> 189-201, </pages> <year> 1979. </year>
Reference-contexts: Equivalently, we characterize TC 0 in terms of constant-depth arithmetic circuits. In order to make these notions precise, we need to discuss counting and enumeration classes. 1.1 Counting Classes Certainly the best-known counting class is Valiant's class #P <ref> [Val79b] </ref>, consisting of functions that map x to the number of accepting computations of an NP-machine on input x. Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention [AJ93b, Vin91, Tod, MV]. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while <p> #P <ref> [Val79b] </ref>, consisting of functions that map x to the number of accepting computations of an NP-machine on input x. Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention [AJ93b, Vin91, Tod, MV]. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant [Vin91, Tod, Val92, MV].
Reference: [Val92] <author> L. Valiant. </author> <title> Why is boolean complexity theory difficult? In M. </title> <editor> S. Paterson, editor, </editor> <title> Boolean Function Complexity, </title> <booktitle> volume 169 of London Mathematical Society Lecture Notes Series, </booktitle> <pages> pages 84-94. </pages> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention [AJ93b, Vin91, Tod, MV]. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant <ref> [Vin91, Tod, Val92, MV] </ref>.
Reference: [Ven92] <author> H. Venkateswaran. </author> <title> Circuit definitions of nondeterministic complexity classes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21 </volume> <pages> 655-670, </pages> <year> 1992. </year>
Reference-contexts: that #P and #L can also be characterized in terms of uniform arithmetic circuits, as follows: NP and NL both have characterizations in terms of uniform Boolean circuits. (NP sets are accepted by uniform exponential-size circuits of "polynomial algebraic degree," and NL sets are accepted by uniform polynomial-size "skew" circuits <ref> [Ven92] </ref>. <p> Alternatively, #P and #L arise by counting the number of "accepting subtrees" for the corresponding classes of Boolean circuits. (See <ref> [Ven92] </ref> for a formal definition of this notion; for our purposes it is sufficient to know that the number of accepting subtrees of a circuit C is (a) equal to the output of the "arithmetized" version of C, (which we denote by #C) and (b) provides a natural notion of counting
Reference: [Vin91] <author> V. Vinay. </author> <title> Counting auxiliary pushdown automata and semi-unbounded arithmetic circuits. </title> <booktitle> In Proc. 6th IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 270-284, </pages> <year> 1991. </year>
Reference-contexts: Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention <ref> [AJ93b, Vin91, Tod, MV] </ref>. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant [Vin91, Tod, Val92, MV]. <p> Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention [AJ93b, Vin91, Tod, MV]. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant <ref> [Vin91, Tod, Val92, MV] </ref>. <p> The counting classes that result in this way by arithmetizing the Boolean circuit classes - 2 - SAC 1 and NC 1 were studied in <ref> [Vin91] </ref> (where it was shown that #SAC 1 corresponds to counting the accepting paths of a NAuxPDA) and in [CMTV96] (where it was shown that #NC 1 is closely-related to counting paths in bounded-width branching programs). In this paper, we study #AC 0 . <p> In order to develop this in a general setting, it is useful to define the "Gap" classes. The class GapP was defined in [FFK94], and by analogy GapL was studied in <ref> [Vin91, AO94] </ref>, and GapNC 1 was studied in [CMTV96]. In all of these cases, there are two equivalent definitions: 1. GapC is the class of functions that are the difference of two #C functions. 2.
Reference: [Wag86] <author> K. W. Wagner. </author> <title> The complexity of combinatorial problems with succinct input representation. </title> <journal> Acta Informatica, </journal> <volume> 23 </volume> <pages> 325-356, </pages> <year> 1986. </year>
Reference-contexts: A () f (x) = 0g. 1 Tomo Yamakami [Yam96] has recently defined #AC 0 somewhat differently, and his definition does not appear comparable to ours. - 3 - PP and PL were first studied in [Gil77] and have been considered in many papers; C = P was studied in <ref> [Wag86] </ref> and elsewhere, and C = L was studied in [ABO96] (see also [ST]). PNC 1 and C = NC 1 were defined and studied in [CMTV96] (see also [Mac]). A main result of this paper is that PAC 0 and C = AC 0 coincide with TC 0 .
Reference: [Yam96] <author> T. Yamakami. </author> <title> Uniform AC 0 Counting Circuits. </title> <type> Manuscript, </type> <year> 1996. </year>
Reference-contexts: many other equivalent definitions, as well.) Now, for a given class C, GapC gives rise to two language classes: PC = fAj9f 2 GapC, x 2 A () f (x) &gt; 0g, C = C = fAj9f 2 GapC, x 2 A () f (x) = 0g. 1 Tomo Yamakami <ref> [Yam96] </ref> has recently defined #AC 0 somewhat differently, and his definition does not appear comparable to ours. - 3 - PP and PL were first studied in [Gil77] and have been considered in many papers; C = P was studied in [Wag86] and elsewhere, and C = L was studied in
References-found: 48

