URL: http://ext.math.umass.edu/~avrunin/recent_pubs/ce-toolset.ps.gz
Refering-URL: http://laser.cs.umass.edu/abstracts/90-116.html
Root-URL: 
Title: Automated Analysis of Concurrent Systems with the Constrained Expression Toolset  
Author: George S. Avrunin Ugo A. Buy James C. Corbett Laura K. Dillon Jack C. Wileden 
Address: Amherst  Amherst  Santa Barbara  Amherst  
Affiliation: University of Massachusetts,  University of Illinois, Chicago  University of Massachusetts,  University of California,  University of Massachusetts,  
Abstract: The constrained expression approach to analysis of concurrent software systems has several attractive features, including the facts that it can be used with a variety of design and programming languages and that it does not require a complete enumeration of the set of reachable states of the concurrent system. This paper reports on the construction of a toolset automating the main constrained expression analysis techniques and the results of experiments with that toolset. The toolset is capable of carrying out completely automated analyses of a variety of concurrent systems, starting from source code in an Ada-like design language and producing system traces displaying the properties represented by the analyst's queries. It has been successfully used with designs that involve hundreds of concurrent processes. fl This paper appeared in IEEE Trans. Softw. Eng., vol. 17, no. 11, pp. 1204-1222, 1991. fl Research partially supported by NSF grant CCR-8806970 and ONR grant N00014-89-J 1064. y Research partially supported by NSF grant CCR-8702905. z Research partially supported by NSF grant CCR-8704478 with cooperation from DARPA (ARPA order 6104). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. M. Karam and R. J. Buhr, </author> <title> "Starvation and critical race analyzers for Ada," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 16, no. 8, </volume> <pages> pp. 829-843, </pages> <year> 1990. </year>
Reference-contexts: A number of analysis methods for concurrent systems have been proposed, based on a variety of models of concurrent computation and intended for answering different questions at different stages of development. The methods include those based on constructing the set of possible states of the concurrent system (e.g., <ref> [1] </ref>, [2], [3]), on proving theorems in some logical structure associated with the system (e.g., [4], [5]), and on examining the execution of a completed system or some simulation of it (e.g., [6], [7]). <p> The final two rows of the table give results for dining philosophers systems similar to ones analyzed by Karam and Buhr <ref> [1] </ref> for deadlock and starvation. These systems use a single fork manager task to model the forks, rather than individual tasks. Deadlock is possible in the system dp5-efm, and the toolset produces a system trace that displays deadlock. <p> We discuss these issues further in Section 5. 24 4.2 Gas station The automated gas station example introduced by Helmbold and Luckham [6] has been studied by a number of authors (e.g., <ref> [1] </ref>, [17]). This system models an automated gas station with an operator, a number of pumps, and a collection of customers. We have analyzed several versions of the system that correspond to some of the refinements used by Helmbold and Luckham. <p> Our second version, gas2, eliminates the race condition and the toolset correctly reports that the system cannot deadlock. (Note that, even though deadlock is avoided, it is still possible for a customer to receive another customer's change. Karam and Buhr's <ref> [1] </ref> critical race assistant points up this possibility.) When the deadlock-free two-customer design is scaled up to three customers, however, a more complicated race condition arises, again leading to the possibility of deadlock. (This was first noticed by K. C. <p> For example, the version of the CATS suite of tools described in [16] is unable to determine that deadlock is impossible in the dining philosophers with host for this reason. (Other reachability-based methods, such as <ref> [1] </ref>, do correctly deal with dataflow.) However, the ability of the toolset to analyze systems having tasks with very complex dataflow is limited. The problem, as for the reachability-based methods, is the explosion in the number of states that must be considered. <p> Several investigators have implemented analysis techniques for concurrent systems based on generating and examining some sort of reachability graph for states of the system (e.g., <ref> [1] </ref>, [2], [16]). In general, the number of states such methods must examine is exponential in the number of tasks in the system, and different approaches are taken to reducing this complexity. <p> For example, the CATS system [16] uses "task interaction graphs" and ignores the values of variables in order to reduce the number of states, while the starvation and 33 critical race analyzers described by Karam and Buhr <ref> [1] </ref> work from a temporal logic specification. Similarly, the Petri net reduction techniques of [17] are intended to reduce the size of a Petri net representation of a concurrent Ada program in order to make reachability analysis practical.
Reference: [2] <author> S. M. Shatz and W. K. Cheng, </author> <title> "A Petri net framework for automated static analysis of Ada tasking behavior," </title> <journal> Journal of Systems and Software, </journal> <volume> vol. 8, </volume> <pages> pp. 343-359, </pages> <year> 1988. </year>
Reference-contexts: A number of analysis methods for concurrent systems have been proposed, based on a variety of models of concurrent computation and intended for answering different questions at different stages of development. The methods include those based on constructing the set of possible states of the concurrent system (e.g., [1], <ref> [2] </ref>, [3]), on proving theorems in some logical structure associated with the system (e.g., [4], [5]), and on examining the execution of a completed system or some simulation of it (e.g., [6], [7]). <p> Several investigators have implemented analysis techniques for concurrent systems based on generating and examining some sort of reachability graph for states of the system (e.g., [1], <ref> [2] </ref>, [16]). In general, the number of states such methods must examine is exponential in the number of tasks in the system, and different approaches are taken to reducing this complexity.
Reference: [3] <author> R. N. Taylor, </author> <title> "A general-purpose algorithm for analyzing concurrent programs," </title> <journal> Communications ACM, </journal> <volume> vol. 26, </volume> <pages> pp. 362-376, </pages> <month> May </month> <year> 1983. </year> <month> 36 </month>
Reference-contexts: The methods include those based on constructing the set of possible states of the concurrent system (e.g., [1], [2], <ref> [3] </ref>), on proving theorems in some logical structure associated with the system (e.g., [4], [5]), and on examining the execution of a completed system or some simulation of it (e.g., [6], [7]).
Reference: [4] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla, </author> <title> "Automatic verification of finite-state concurrent systems using temporal logic specifications," </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> vol. 8, </volume> <pages> pp. 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: The methods include those based on constructing the set of possible states of the concurrent system (e.g., [1], [2], [3]), on proving theorems in some logical structure associated with the system (e.g., <ref> [4] </ref>, [5]), and on examining the execution of a completed system or some simulation of it (e.g., [6], [7]).
Reference: [5] <author> L. K. Dillon, </author> <title> "Verifying general safety properties of Ada tasking programs," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 16, no. 1, </volume> <pages> pp. 51-63, </pages> <year> 1990. </year>
Reference-contexts: The methods include those based on constructing the set of possible states of the concurrent system (e.g., [1], [2], [3]), on proving theorems in some logical structure associated with the system (e.g., [4], <ref> [5] </ref>), and on examining the execution of a completed system or some simulation of it (e.g., [6], [7]).
Reference: [6] <author> D. Helmbold and D. Luckham, </author> <title> "Debugging Ada tasking programs," </title> <journal> IEEE Software, </journal> <volume> vol. 2, </volume> <pages> pp. 47-57, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: The methods include those based on constructing the set of possible states of the concurrent system (e.g., [1], [2], [3]), on proving theorems in some logical structure associated with the system (e.g., [4], [5]), and on examining the execution of a completed system or some simulation of it (e.g., <ref> [6] </ref>, [7]). <p> The difficulty appears to be due to stability problems related to the bandedness of the system of inequalities. We discuss these issues further in Section 5. 24 4.2 Gas station The automated gas station example introduced by Helmbold and Luckham <ref> [6] </ref> has been studied by a number of authors (e.g., [1], [17]). This system models an automated gas station with an operator, a number of pumps, and a collection of customers.
Reference: [7] <author> D. S. Rosenblum and D. C. Luckham, </author> <title> "Testing the correctness of tasking supervisors with TSL specifications," </title> <booktitle> in Proceedings of the ACM SIGSOFT '89 Third Symposium on Software Testing, Analysis and Verification (R. </booktitle> <publisher> A. Kemmerer, ed.), </publisher> <pages> pp. 187-196, </pages> <year> 1989. </year> <note> Appeared as Software Engineering Notes, 14(8). </note>
Reference-contexts: The methods include those based on constructing the set of possible states of the concurrent system (e.g., [1], [2], [3]), on proving theorems in some logical structure associated with the system (e.g., [4], [5]), and on examining the execution of a completed system or some simulation of it (e.g., [6], <ref> [7] </ref>).
Reference: [8] <author> J. C. Wileden, </author> <title> "Constrained expressions and the analysis of designs for dynamically-structured distributed systems," </title> <booktitle> in Proceedings of the International Conference on Parallel Processing, </booktitle> <pages> pp. 340-344, </pages> <month> August </month> <year> 1982. </year>
Reference-contexts: But it is not possible to understand the value of the method to software developers without this sort of experience with its application. For several years, we have been developing analysis methods based on the constrained expression formalism <ref> [8] </ref>, [9], [10], [11]. The constrained expression approach to analysis has a number of attractive features. It is based on a formal model of concurrent computation that is well-suited to answering some of the natural and fundamental questions about occurrences of events that arise in analysis of concurrent systems.
Reference: [9] <author> G. S. Avrunin, L. K. Dillon, J. C. Wileden, and W. E. Riddle, </author> <title> "Constrained expressions: Adding analysis capabilities to design methods for concurrent software systems," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 12, no. 2, </volume> <pages> pp. 278-292, </pages> <year> 1986. </year>
Reference-contexts: But it is not possible to understand the value of the method to software developers without this sort of experience with its application. For several years, we have been developing analysis methods based on the constrained expression formalism [8], <ref> [9] </ref>, [10], [11]. The constrained expression approach to analysis has a number of attractive features. It is based on a formal model of concurrent computation that is well-suited to answering some of the natural and fundamental questions about occurrences of events that arise in analysis of concurrent systems. <p> This section contains a brief description of the central features of the constrained expression formalism. A detailed and rigorous presentation of the formalism is given in the appendix to [10], and a less formal treatment presenting the motivation for many of the features of the formalism appears in <ref> [9] </ref>. The description of the constrained expression formalism presented in this section generalizes aspects of these previous presentations. <p> That is, the constrained expression determines a language and this language describes the possible sequences of event symbols that can occur as system traces. This is the interpretation of constrained expressions described in our earlier work <ref> [9, 10] </ref>. This interpretation of constrained expressions suffices for most purposes (and, in particular, for the purpose of understanding the constrained expression analysis techniques described in this paper).
Reference: [10] <author> L. K. Dillon, G. S. Avrunin, and J. C. Wileden, </author> <title> "Constrained expressions: Toward broad applicability of analysis methods for distributed software systems," </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> vol. 10, </volume> <pages> pp. 374-402, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: But it is not possible to understand the value of the method to software developers without this sort of experience with its application. For several years, we have been developing analysis methods based on the constrained expression formalism [8], [9], <ref> [10] </ref>, [11]. The constrained expression approach to analysis has a number of attractive features. It is based on a formal model of concurrent computation that is well-suited to answering some of the natural and fundamental questions about occurrences of events that arise in analysis of concurrent systems. <p> It can be used with a variety of standard design or programming languages based on different views of the semantics of concurrent computation and applied at different stages of the development process <ref> [10] </ref>, thereby allowing developers to work in congenial and appropriate notations while retaining the ability to apply rigorous analysis methods. Furthermore, the analysis techniques limit some of the effects of combinatorial explosion, since they do not require enumeration of the set of reachable states of the system. <p> This section contains a brief description of the central features of the constrained expression formalism. A detailed and rigorous presentation of the formalism is given in the appendix to <ref> [10] </ref>, and a less formal treatment presenting the motivation for many of the features of the formalism appears in [9]. The description of the constrained expression formalism presented in this section generalizes aspects of these previous presentations. <p> Constrained expressions provide a very general model of system behaviors and have been used with a variety of descriptive notations, including a design language providing asynchronous message passing primitives, a subset of CSP (which provides synchronous message passing primitives), and Petri net languages <ref> [10] </ref>. The front-end of the constrained expression toolset described in this paper implements a particular constrained expression formulation of an Ada-like design language, called CEDL (Constrained Expression Design Language), which we use for the examples below. <p> That is, the constrained expression determines a language and this language describes the possible sequences of event symbols that can occur as system traces. This is the interpretation of constrained expressions described in our earlier work <ref> [9, 10] </ref>. This interpretation of constrained expressions suffices for most purposes (and, in particular, for the purpose of understanding the constrained expression analysis techniques described in this paper).
Reference: [11] <author> G. S. Avrunin, L. K. Dillon, and J. C. Wileden, </author> <title> "Experiments with automated constrained expression analysis of concurrent software systems," </title> <booktitle> in Proceedings of the ACM SIGSOFT '89 Third Symposium on Software Testing, Analysis and Verification (R. </booktitle> <publisher> A. Kemmerer, ed.), </publisher> <pages> pp. 124-130, </pages> <month> December </month> <year> 1989. </year> <note> Appeared as Software Engineering Notes, 14(8). </note>
Reference-contexts: But it is not possible to understand the value of the method to software developers without this sort of experience with its application. For several years, we have been developing analysis methods based on the constrained expression formalism [8], [9], [10], <ref> [11] </ref>. The constrained expression approach to analysis has a number of attractive features. It is based on a formal model of concurrent computation that is well-suited to answering some of the natural and fundamental questions about occurrences of events that arise in analysis of concurrent systems.
Reference: [12] <author> S. Katz and D. Peled, </author> <title> "An interleaving set temporal logic," </title> <booktitle> in Proceedings of the 6th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 178-190, </pages> <year> 1987. </year>
Reference-contexts: To explain how a constrained expression describes partial orders among system events, we show in the next subsection how the constrained expression can be used to group the system traces into interleaving sets <ref> [12] </ref>. Informally, an interleaving set represents a partial order on event occurrences by the full set of total orders that extend the partial order.
Reference: [13] <author> L. A. Clarke, J. C. Wileden, and A. L. Wolf, </author> <title> "Nesting in Ada programs is for the birds," </title> <booktitle> in Proceedings of an ACM-SIGPLAN Symposium on the Ada Programming Language, </booktitle> <pages> pp. 139-145, </pages> <year> 1980. </year> <note> Appeared as SIGPLAN Notices 15(11). </note>
Reference-contexts: The restriction against nesting, besides simplifying the constrained expression representations for CEDL designs, reflects our belief that nesting is a poor design (and programming) practice <ref> [13] </ref>. Other restrictions limit the complexity of CEDL designs and of their constrained expression representations. Most of the Ada control-flow constructs have correspondents in CEDL. CEDL also provides an ellipsis notation (written "...") for expressing incompleteness in designs.
Reference: [14] <author> R. J. Dakin, </author> <title> "A tree search algorithm for mixed integer programming problems," </title> <journal> Computer Journal, </journal> <volume> vol. 8, </volume> <pages> pp. 250-255, </pages> <year> 1965. </year> <month> 37 </month>
Reference-contexts: assist the analyst in interpreting the systems of inequalities and solutions found by the integer programming tool in terms of the task expressions and constraints. 3.4 IMINOS We solve the inequality systems produced by our inequality generator using a branch-and-bound algorithm employing the variable dichotomy scheme first introduced by Dakin <ref> [14] </ref>. Our implementation of this algorithm makes use of the MINOS [15] optimization package to solve LP-relaxations of the integer programming problems. We refer to the tool that incorporates our code and MINOS as IMINOS (Integer MINOS).
Reference: [15] <author> M. A. Saunders, </author> <title> "MINOS system manual," </title> <type> Tech. Rep. SOL 77-31, </type> <institution> Stanford University, Department of Operations Research, </institution> <year> 1977. </year>
Reference-contexts: Our implementation of this algorithm makes use of the MINOS <ref> [15] </ref> optimization package to solve LP-relaxations of the integer programming problems. We refer to the tool that incorporates our code and MINOS as IMINOS (Integer MINOS). The IMINOS tool takes an inequality system and associated objective function in the standard MPS file format as input.
Reference: [16] <author> M. Young, R. N. Taylor, K. Forester, and D. Brodbeck, </author> <title> "Integrated con-currency analysis in a software development environment," </title> <booktitle> in Proceedings of the ACM SIGSOFT '89 Third Symposium on Software Testing, Analysis and Verification (R. </booktitle> <publisher> A. Kemmerer, ed.), </publisher> <pages> pp. 200-209, </pages> <year> 1989. </year> <note> Appeared as Software Engineering Notes, 14(8). </note>
Reference-contexts: The first of these systems, dp5-u, is a five-philosopher "unrolled" version of the dining philosophers with host, like that analyzed by Young, Taylor, Forester, and Brodbeck <ref> [16] </ref> using their CATS system. In this version, the host task does not use a variable to keep track of the number of philosophers in the dining room, but instead uses nested select statements. <p> The CATS system was used to verify a temporal logic assertion (that, under the assumption of a fair scheduler, each philosopher can get into the dining room). We used the constrained expression toolset to analyze the system for deadlock. The design published in <ref> [16] </ref> is not equivalent to the one in which the host uses a variable to keep track of the number of philosophers in the room (as was pointed out to us by Sol Shatz), and the constrained expression toolset produces a trace displaying the deadlock in the "unrolled" system. <p> Some reachability-based methods intentionally ignore information about the values of variables in order to reduce the number of states that must be generated and examined. For example, the version of the CATS suite of tools described in <ref> [16] </ref> is unable to determine that deadlock is impossible in the dining philosophers with host for this reason. (Other reachability-based methods, such as [1], do correctly deal with dataflow.) However, the ability of the toolset to analyze systems having tasks with very complex dataflow is limited. <p> Several investigators have implemented analysis techniques for concurrent systems based on generating and examining some sort of reachability graph for states of the system (e.g., [1], [2], <ref> [16] </ref>). In general, the number of states such methods must examine is exponential in the number of tasks in the system, and different approaches are taken to reducing this complexity. For example, the CATS system [16] uses "task interaction graphs" and ignores the values of variables in order to reduce the <p> and examining some sort of reachability graph for states of the system (e.g., [1], [2], <ref> [16] </ref>). In general, the number of states such methods must examine is exponential in the number of tasks in the system, and different approaches are taken to reducing this complexity. For example, the CATS system [16] uses "task interaction graphs" and ignores the values of variables in order to reduce the number of states, while the starvation and 33 critical race analyzers described by Karam and Buhr [1] work from a temporal logic specification.
Reference: [17] <author> S. Tu, S. M. Shatz, and T. Murata, </author> <title> "Theory and application of Petri net reduction for Ada-tasking deadlock analysis." </title> <type> Preprint, </type> <year> 1990. </year>
Reference-contexts: We discuss these issues further in Section 5. 24 4.2 Gas station The automated gas station example introduced by Helmbold and Luckham [6] has been studied by a number of authors (e.g., [1], <ref> [17] </ref>). This system models an automated gas station with an operator, a number of pumps, and a collection of customers. We have analyzed several versions of the system that correspond to some of the refinements used by Helmbold and Luckham. <p> Similarly, the Petri net reduction techniques of <ref> [17] </ref> are intended to reduce the size of a Petri net representation of a concurrent Ada program in order to make reachability analysis practical. It appears that none of these techniques can currently deal with systems as large as some of those analyzed using the constrained expression toolset.
Reference: [18] <author> K.-C. Tai, </author> <title> "A graphical notation for describing executions of concurrent Ada programs," </title> <journal> Ada Letters, </journal> <volume> vol. 6, </volume> <pages> pp. 94-103, </pages> <month> January-February </month> <year> 1986. </year>
Reference-contexts: Karam and Buhr's [1] critical race assistant points up this possibility.) When the deadlock-free two-customer design is scaled up to three customers, however, a more complicated race condition arises, again leading to the possibility of deadlock. (This was first noticed by K. C. Tai <ref> [18] </ref>, who used a graphical analysis method to detect the error.) We analyzed two versions of the three-customer extension of this problem. The first, gas3, is a straightforward extension.
Reference: [19] <author> G. Ricart and A. K. Agrawala, </author> <title> "An optimal algorithm for mutual exclusion in computer networks," </title> <journal> Communications ACM, </journal> <volume> vol. 24, </volume> <pages> pp. 9-17, </pages> <year> 1981. </year>
Reference-contexts: The system analyzed is a CEDL version of a design that implements part of an algorithm for mutual exclusion due to Ricart and Agrawala <ref> [19] </ref>. In it, a node wishing to obtain exclusive use of the resource sends a request to each of the other nodes in the system, and then waits for a reply from each node before proceeding to use the resource.
Reference: [20] <author> L. Lamport, </author> <title> "A new solution of Dijkstra's concurrent programming problem," </title> <journal> Communications ACM, </journal> <volume> vol. 17, no. 8, </volume> <pages> pp. 453-455, </pages> <year> 1974. </year>
Reference-contexts: The sequence numbers are generated by the individual nodes and are similar to the numbers used in Lamport's "bakery algorithm" <ref> [20] </ref>. 27 The constrained expression approach was applied in [21] to detect an error in a partial design for a system implementing the Ricart-Agrawala algorithm, and then to show that the error was eliminated in a modified version of the design.
Reference: [21] <author> G. S. Avrunin and J. C. Wileden, </author> <title> "Describing and analyzing distributed software system designs," </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> vol. 7, </volume> <pages> pp. 380-403, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: The sequence numbers are generated by the individual nodes and are similar to the numbers used in Lamport's "bakery algorithm" [20]. 27 The constrained expression approach was applied in <ref> [21] </ref> to detect an error in a partial design for a system implementing the Ricart-Agrawala algorithm, and then to show that the error was eliminated in a modified version of the design. <p> The analysis was intended to determine whether a request received at the node may be permanently deferred. The toolset showed that this cannot happen. This is essentially equivalent to the analysis performed by hand in <ref> [21] </ref>, though the different communication primitives in CEDL and DYMOL make the details of the designs quite different. We next considered two versions of a system with three elaborated nodes and an additional task simulating the resource.
Reference: [22] <author> R. N. Taylor, </author> <title> "Complexity of analyzing the synchronization structure of concurrent programs," </title> <journal> Acta Informatica, </journal> <volume> vol. 19, </volume> <pages> pp. 57-84, </pages> <year> 1983. </year>
Reference-contexts: We are currently investigating these possibilities. The performance of the toolset is not easily predicted from known results on the computational complexity of the algorithms it implements, especially since problems like the detection of deadlock are NP -hard <ref> [22] </ref>. The translation process implemented by the deriver is essentially linear in the number of tasks and the size of each task.
Reference: [23] <author> G. S. Avrunin, J. C. Corbett, L. K. Dillon, and J. C. Wileden, </author> <title> "Automated constrained expression analysis of real-time software." </title> <note> Submitted for publication. Available as Technical Report 90-117, </note> <institution> Department of Computer and Information Science, University of Massachusetts, </institution> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: The results presented in Section 4 show how the toolset can be used to answer questions about deadlock and violation of mutual exclusion. We have also used the toolset to detect blocking of single processes. In <ref> [23] </ref>, we have shown how the toolset can be extended to answer questions about the timing properties of a concurrent system. The current version of the constrained expression toolset, however, is not able to address questions about fairness or starvation. <p> Details of this approach to constrained expression analysis of real-time systems and an example of its application can be found in <ref> [23] </ref>. Based on the results of the experiments conducted with the current version of the toolset and the improvements to be expected in the near future, we believe that the constrained expression approach can serve as a foundation for practical tools for developers of concurrent software.
Reference: [24] <author> C. E. McDowell, </author> <title> "A practical algorithm for static analysis of parallel programs," </title> <journal> Journal of Parallel and Distributed Processing, </journal> <volume> vol. 6, </volume> <pages> pp. 515-536, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: McDowell <ref> [24] </ref>, for example, has described a method for collapsing parts of the reachability graph when the system includes a large number of identical tasks. (This is the case in which we have experimented with setting a variable to n, rather than one, as discussed in Section 4.5.) Valmari [25] has described
Reference: [25] <author> A. Valmari, </author> <title> "A stubborn attack on state explosion." To appear in Computer-Aided Verification 90, </title> <booktitle> Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> vol. 3, </volume> <publisher> American Mathematical Society, </publisher> <address> Providence, RI, </address> <year> 1991. </year>
Reference-contexts: McDowell [24], for example, has described a method for collapsing parts of the reachability graph when the system includes a large number of identical tasks. (This is the case in which we have experimented with setting a variable to n, rather than one, as discussed in Section 4.5.) Valmari <ref> [25] </ref> has described a method that can detect deadlock in systems with communication structure like that of the basic dining philosophers in time that is linear in the number of tasks.
Reference: [26] <author> T. Murata, B. Shenker, and S. M. Shatz, </author> <title> "Detection of Ada static deadlocks using Petri net invariants," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 15, no. 3, </volume> <pages> pp. 314-326, </pages> <year> 1989. </year>
Reference-contexts: Another approach, very closely related to ours, is the Petri net invariant method of Murata, Shenker, and Shatz <ref> [26] </ref>. In this method, certain Petri nets are derived from Ada tasking programs, and the T -invariants of these nets are determined. <p> These "spurious" T -invariants are thus similar to the solutions of our systems of 34 inequalities that do not correspond to traces of CEDL systems. The approach of <ref> [26] </ref> is to use the T -invariants first to detect and remove certain "inconsistency" deadlocks, and then to guide the construction of a reachability graph to determine whether "circular" deadlocks are possible. 6 Conclusion The constrained expression approach to analysis of concurrent software systems has several attractive features.
References-found: 26

