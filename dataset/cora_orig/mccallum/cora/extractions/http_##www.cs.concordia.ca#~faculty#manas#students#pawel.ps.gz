URL: http://www.cs.concordia.ca/~faculty/manas/students/pawel.ps.gz
Refering-URL: http://www.cs.concordia.ca/~faculty/manas/students.html
Root-URL: http://www.cs.concordia.ca
Title: TIMING AND SCHEDULING ANALYSIS OF REAL-TIME OBJECT-ORIENTED MODELS  
Author: PAWE RODZIEWICZ 
Degree: A THESIS IN THE DEPARTMENT OF COMPUTER SCIENCE PRESENTED IN PARTIAL FULFILLMENT OF THE REQUIREMENTS FOR THE DEGREE OF MASTER OF COMPUTER SCIENCE  
Note: c PAWE RODZIEWICZ, 1998  
Date: SEPTEMBER 1998  
Address: MONTR EAL, QU EBEC, CANADA  
Affiliation: CONCORDIA UNIVERSITY  
Abstract-found: 0
Intro-found: 1
Reference: [ABR + 93] <author> N. Audsley, A. Burns, M. Richardson, K. Tindell, and A. Wellings. </author> <title> Applying new scheduling theory to static priority preemptive scheduling. </title> <journal> Software Engineering Journal, </journal> <pages> pages 284292, </pages> <year> 1993. </year>
Reference-contexts: Thus, the above analysis allows us to test task schedulability and optimize the processor utilization by considering the worst case scenario, when all the tasks become ready to run at the critical instant. 3.1.2 Release Jitter Another very important contribution to real-time scheduling theory was made by Audsley et al. <ref> [ABR + 93] </ref>, who created a scheduling test for a hybrid event- and timer-driven scheduler which was unique to the system they modelled. In this system, some tasks would undergo the timer jitter effect, while others did not. <p> The above equation is a simple extension of the scheduling equation <ref> [ABR + 93] </ref> for a hybrid event-and timer-driven scheduler.
Reference: [AKZ96] <author> M. Awad, J. Kuusela, and J. Ziegler. </author> <title> Object-Oriented Technology for Real-Time Systems: A Practical Approach using OMT and Fusion. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: Indeed, we observe that the telecommunications community has widely accepted such new generation of CASE tool support, e.g. ROOM [SGW94] and OCTOPUS <ref> [AKZ96] </ref>. We believe that such acceptance is due, in part, to the sheer size and complexity of new telecommunication products and their fundamentally event-driven nature. 1 In contrast, the embedded control systems community continues to be much more con-servative. <p> Automobile cruise control is a well studied example which has been used to illustrate real-time designed methods such as Octopus <ref> [AKZ96] </ref>, ADARTS and CODARTS [Gom93]. In order to keep the example manageable, we have selected only a subset of its functionality.
Reference: [BAL97] <author> H. Ben-Abdallah and S. Leue. </author> <title> Expressing and analyzing timing constraints in message sequence chart specifications. </title> <type> Technical report, </type> <institution> University of Waterloo, Dept. of Electrical and Computer Engineering, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: itself does not provide any mechanisms to specify and enforce timing constraints imposed on each MSC scenario. 2 Only optional actors may be placed in threads other than the main thread. 12 Thus, in order to perform our scheduling analysis, we will add additional annotations to in-dicate these timing constraints <ref> [BAL97] </ref>. We will call these annotated MSCs transactions, and we will use them to indicate time critical end-to-end computations, for which timing constraints such as periodicity and deadlines may be specified.
Reference: [BCL91] <author> J.R. Burch, E.M. Clarke, and D.E. </author> <title> Long. Symbolic model checking with partitioned transition relation. </title> <editor> In A. Halaas and P.B. Denyer, editors, </editor> <booktitle> International Conference on Very Large Scale Integration, </booktitle> <month> August </month> <year> 1991. </year> <note> Winner of the Sid-ney Michaelson Best Paper Award. </note>
Reference-contexts: Using binary decision diagrams for transition relations, they were able to verify some examples that had more than 10 20 states [BCM90]. Since then, various refinements of the OBDD-based techniques by other researchers at Carnegie Mellon have pushed the state space up to more than 10 120 <ref> [BCL91] </ref>. 3.2.1 Timing and Scheduling Analysis of Tasks Symbolic Model Checking can also be used to verify the timing constraints of a set of tasks scheduled with a fixed priority algorithm.
Reference: [BCM90] <author> J.R. Burch, E.M. Clarke, and K.L. McMillan. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In IEEE Symposium on Logic in Computer Science, </booktitle> <address> Philadelphia, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: In their representation, they use ordered binary decision diagrams (OBDD) [Bry86], which allow many practical systems with extremely large state spaces to be verified. Using binary decision diagrams for transition relations, they were able to verify some examples that had more than 10 20 states <ref> [BCM90] </ref>.
Reference: [Boa93] <author> M. </author> <title> Boasson. </title> <journal> Control systems software. IEEE Transactions on Automatic Control, </journal> <volume> 38(7):10941106, </volume> <month> July </month> <year> 1993. </year>
Reference-contexts: The increasing complexity and the sophisticated demands of such systems in terms of safety, reliability, and performance <ref> [Boa93] </ref> requires the use of rigorous methodologies, to ensure reliable software development, along with analytical techniques to analyze and predict the temporal behavior of applications.
Reference: [Bry86] <author> R.E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8), </volume> <year> 1986. </year>
Reference-contexts: The symbolic model checking (SMC) technique, developed at Carnegie Mellon University by the Formal Methods Model Checking group, tries to resolves the state explosion problem by representing the transition relation symbolically instead of explicitly. In their representation, they use ordered binary decision diagrams (OBDD) <ref> [Bry86] </ref>, which allow many practical systems with extremely large state spaces to be verified. Using binary decision diagrams for transition relations, they were able to verify some examples that had more than 10 20 states [BCM90].
Reference: [BS89] <author> T.P. Baker and A. Shaw. </author> <title> The cyclic executive model and ada. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 1(1):725, </volume> <month> June </month> <year> 1989. </year> <month> 68 </month>
Reference-contexts: Until recently, the majority of real-time applications have been developed with the cyclic executive model [Loc92], <ref> [BS89] </ref>. With this model, real-time software engineers are forced to fit their computational tasks, i.e. concurrent sets of sequential actions which can take place within a system, into a predetermined cycle. The cycle is repeated once per period and is called the major cycle.
Reference: [BW96] <author> A. Burns and A. Wellings. </author> <title> Advanced fixed priority scheduling. In Real-time Systems: Specification, Verification and Analysis, pages 3265. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: We will call these annotated MSCs transactions, and we will use them to indicate time critical end-to-end computations, for which timing constraints such as periodicity and deadlines may be specified. To deal with temporal requirements of distributed real-time systems, Burns and Wellings also defined the notion of a transaction <ref> [BW96] </ref> to link input and output activities that share associated deadlines. They were used to reflect end-to-end properties, i.e. from an input event trigger to an output event response, of a real-time system. <p> These end-to-end computations were formally defined as transactions, thus they can be subjected to common timing analysis methods such as the real-time scheduling theory <ref> [BW96] </ref> or symbolic model checking. In this chapter, we will examine and select a suitable timing and scheduling analysis method for ROOM models, where we will consider three orthogonal timing analysis methods: real-time scheduling theory, symbolic model checking and discrete task simulation. <p> Thus, blocking is incurred if a transaction is invoked when a lower priority transaction is 44 sending a message to the invoked transaction's thread. We will refer to this blocking time as B i . Using the Immediate Inheritance Protocol <ref> [BW96] </ref>, we access shared message queues at the ceiling priority of the queue. This ensures that a higher priority transaction can be blocked by either the timer re-arming or message queue access, but not both.
Reference: [CCM96] <author> S. Campos, E.M. Clarke, and M. Minea. </author> <title> Analysis of real-time systems using symbolic techniques. In Formal Methods for Real-Time Computing. </title> <publisher> John Wiley & Sons, </publisher> <year> 1996. </year>
Reference-contexts: For the analysis to be described here, we used the Symbolic Model Verification (SMV) tool [McM92], which can check finite state systems against their specifications expressed in the Computational Tree Logic (CTL) <ref> [CCM96] </ref>. <p> This is accomplished by using the MIN and MAX quantitative algorithms <ref> [CCM96] </ref>. Because we are concerned here with timing and scheduling analysis of ROOM models which represent a family of hard real-time systems, we will concentrate on MAX quantitative results.
Reference: [Fre98] <author> P. Freedman. </author> <title> Investigating the suitability of ObjecTime for the software development of embedded control systems. </title> <booktitle> In ObjecTime Workshop on Research in Real-Time Object-Oriented Modeling. </booktitle> <publisher> ObjecTime Limited, </publisher> <month> January </month> <year> 1998. </year>
Reference-contexts: The train tilting system represented a realistic computerized control system and illustrated the scalability of the approach. Note that previous work on the application of ROOM/ObjecTime for the development of the train tilting system <ref> [Fre98] </ref> had revealed serious timing problems associated with TargetRTS and the use of static thread priorities. 1.3 Thesis Outline This thesis contains seven chapters.
Reference: [GF96] <author> D. Gaudreau and P. Freedman. </author> <title> Temporal analysis and object-oriented real-time software development: a case study with ROOM/ObjecTime. </title> <booktitle> In IEEE Real-Time Technology and Applications Symposium, </booktitle> <address> Brookline, Massachusetts, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: In <ref> [GF96] </ref>, Gaudreau and Freedman described how ROOM models could be subjected to Generalized Rate Monotonic Analysis (GRMA) [KRP + 93], using a simplified cruise control example adopted from [Gom93]. <p> Chapter 6 illustrates the concepts developed in earlier chapters by studying a variant of the automobile cruise control system 3 presented in <ref> [GF96] </ref>. The chapter provides an overview of the cruise control system, specifies its time-critical transactions and presents schedulability analysis results for these transactions.
Reference: [Gom93] <author> H. Gomaa. </author> <title> Software Design Methods for Concurrent and Real-Time Systems. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: In [GF96], Gaudreau and Freedman described how ROOM models could be subjected to Generalized Rate Monotonic Analysis (GRMA) [KRP + 93], using a simplified cruise control example adopted from <ref> [Gom93] </ref>. They wanted to promote GRMA as a method for the temporal analysis of ROOM models at design time, to the software development team. <p> Examples of hard-real-time systems are flight and traffic control, nuclear plant control, robotics and automobile cruise control systems, the last one described in <ref> [Gom93] </ref> and further studied in Chapter 6. When hard-real-time systems are employed to regulate physical environments imposing computational resource constraints, such systems are called embedded control systems. <p> Automobile cruise control is a well studied example which has been used to illustrate real-time designed methods such as Octopus [AKZ96], ADARTS and CODARTS <ref> [Gom93] </ref>. In order to keep the example manageable, we have selected only a subset of its functionality.
Reference: [Har87] <author> D. Harel. Statecharts: </author> <title> A visual approach to complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8, </volume> <month> August </month> <year> 1987. </year>
Reference-contexts: Although, we do not need to create actors dynamically, we will define optional 11 actors to assign them to different logical threads 2 . 2.1.2 Behavioral Model The actor's behavior is represented by an extended state machine called a ROOMchart, based on statechart formalism <ref> [Har87] </ref>. Each actor remains dormant in its current state until a message is received by an actor. Incoming messages trigger transitions to new states as defined by the actor's finite state machine. Actions may be associated with state transitions, as well as entry and exit points of a state.
Reference: [HG96] <author> D. Harel and E. Gery. </author> <title> Executable object modeling with statecharts. </title> <booktitle> In ACM/IEEE 18th International Conference on Software Engineering, </booktitle> <year> 1996. </year>
Reference-contexts: It is not surprising that there is increasing interest in new generation methodologies and CASE tools which make possible the modelling and analysis of computing systems in terms of executable models <ref> [HG96] </ref>. One such product is the modelling language ROOM (Real-Time Object Oriented Modeling) [SGW94] and its CASE tool, ObjecTime, which grew out of more than ten years of internal development at Bell-Northern Research (now Nortel).
Reference: [Int94] <author> International Telecommunication Union. </author> <title> Message sequence charts standard (Z.120) reference, </title> <year> 1994. </year>
Reference-contexts: no transition is triggered at all levels of the state hierarchy is discarded, unless it is explicitly deferred. 2.2 Message Sequence Charts and Transactions Interactions between selected ROOM actor instances can be specified at design time in a Message Sequence Chart (MSC), conforming to a subset of CCITT recommendations Z.120 <ref> [Int94] </ref>. ROOM MSCs may graphically depict message flow between actors, transition actions and changes in actor states.
Reference: [JP86] <author> M. Joseph and P. Pandya. </author> <title> Finding response times in a real-time system. </title> <journal> Computer Journal (British Computer Society), </journal> <volume> 29(5):390395, </volume> <year> 1986. </year>
Reference-contexts: Since then, significant progress has been made on generalizing and improving the schedulability analysis. Necessary and sufficient conditions for fixed priority algorithms have also been developed [LSD87] and <ref> [JP86] </ref>. These conditions construct the worst case phasing for each task, i.e. task critical instance, and test the task scheduling under this configuration. These conditions also release the requirement that tasks are scheduled according to the rate-monotonic algorithm. 3.1.1 Worst Case Response Time The Joseph and Pandya work [JP86] provided a <p> [LSD87] and <ref> [JP86] </ref>. These conditions construct the worst case phasing for each task, i.e. task critical instance, and test the task scheduling under this configuration. These conditions also release the requirement that tasks are scheduled according to the rate-monotonic algorithm. 3.1.1 Worst Case Response Time The Joseph and Pandya work [JP86] provided a necessary and sufficient timing analysis test for a set of tasks scheduled by the deadline-monotonic or rate-monotonic algorithm. They came up with the idea of calculating the worst case response time 1 of a task.
Reference: [Kat94] <author> D. Katcher. </author> <title> Engineering and Analysis of Real-Time Operating Systems. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: In a ROOM/ObjecTime model, the TargetRTS timing service is polled by OS timing services. Because of the asynchronous nature of these services, polling leads to the blocking affect we shall discuss in Chapter 3. This type of transaction scheduling is defined as timer-driven scheduling and is further described in <ref> [Kat94] </ref>. 3 Restricting the transaction period to a minimum inter-arrival time of the one-shot timer is a limitation necessary for our timing and scheduling analysis. 15 Chapter 3 Choosing a Scheduling Analysis Method for ROOM Models Task scheduling analysis is a fundamental issue in developing hard-real-time systems, where all the tasks <p> implementation costs of ROOM models, the generic resource scheduling model along with its canonical scheduling models for single- and multi-threaded ROOM executables will be developed in Chapter 5. 3.1.3 Time and Space Complexity The complexity of the scheduling models described in this section were derived in a similar way to <ref> [Kat94] </ref>. Let N be the number of application tasks, and L be the ratio of the longest period to the shortest period of all tasks.
Reference: [KRP + 93] <author> M.H. Klein, T. Ralya, B. Pollak, R. Obenza, and M.G. Harbour. </author> <title> A Practitioner's Handbook for Real-Time Analysis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Once again this is due, in part, to the smaller size and complexity of these products and their dominating time-driven behavior. In the time-driven context, programming features, such as the task construct in Ada95, were developed to handle periodic behavior of embedded control systems along with real-time scheduling theory <ref> [KRP + 93] </ref> which provides guidance, at design time, about predicting the time-driven behavior of such systems. <p> In [GF96], Gaudreau and Freedman described how ROOM models could be subjected to Generalized Rate Monotonic Analysis (GRMA) <ref> [KRP + 93] </ref>, using a simplified cruise control example adopted from [Gom93]. They wanted to promote GRMA as a method for the temporal analysis of ROOM models at design time, to the software development team.
Reference: [LL73] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 20(1):4661, </volume> <month> January </month> <year> 1973. </year>
Reference-contexts: Clearly, there is a tight coupling between timing analysis and the design of the task set. The increasing complexity and the sophisticated demands of real-time systems in terms of development time, software maintenance and reliability gave rise to real-time scheduling theory <ref> [LL73] </ref>, which decouples the design of a task set from its timing or scheduling analysis. <p> We will present an overview of 16 each method, followed by the time and space complexity costs of using them, and we will summarize the chapter with concluding remarks. 3.1 Overview of Real-Time Scheduling Theory A first contribution to task scheduling analysis was made by Liu and Layland <ref> [LL73] </ref> who developed optimal static and dynamic priority scheduling algorithms for hard-real-time sets of independent tasks. They showed that the dynamic priority scheduling algorithms, i.e. earliest deadline, can achieve 100% CPU schedulable utilization, while the rate-monotonic algorithm has a least upper bound of 69% of CPU schedulable utilization.
Reference: [Loc92] <author> C. Douglas Locke. </author> <title> Software architectures for hard real-time applications: Cyclic executives vs. fixed priority executives. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 4(1):3753, </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: Until recently, the majority of real-time applications have been developed with the cyclic executive model <ref> [Loc92] </ref>, [BS89]. With this model, real-time software engineers are forced to fit their computational tasks, i.e. concurrent sets of sequential actions which can take place within a system, into a predetermined cycle. The cycle is repeated once per period and is called the major cycle.
Reference: [LSD87] <author> J. Lehoczky, L. Sha, and Y. Ding. </author> <title> The rate monotonic scheduling algorithm: Exact characterization and average case behavior. </title> <booktitle> In IEEE Real-Time Systems Symposium, </booktitle> <address> San Jose, CA, </address> <month> December </month> <year> 1987. </year>
Reference-contexts: Since then, significant progress has been made on generalizing and improving the schedulability analysis. Necessary and sufficient conditions for fixed priority algorithms have also been developed <ref> [LSD87] </ref> and [JP86]. These conditions construct the worst case phasing for each task, i.e. task critical instance, and test the task scheduling under this configuration. <p> The task priority can be determined either with the deadline-monotonic or rate-monotonic algorithm. 21 CTL Formulas To test task schedulability, we create CTL formulas, imposing restrictions on our SMV model. According to the Completion Time Theorem <ref> [LSD87] </ref>, each task has to finish before its deadline.
Reference: [McM92] <author> K.L. McMillan. </author> <title> The SMV system DRAFT. </title> <institution> Carnegie-Mellon University, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: For the analysis to be described here, we used the Symbolic Model Verification (SMV) tool <ref> [McM92] </ref>, which can check finite state systems against their specifications expressed in the Computational Tree Logic (CTL) [CCM96]. <p> Time Space (ms) (ms) (ms) (sec) (bytes) BDD Nodes (sec/min) (Mbytes) 1 20 50 245 1 670 1566 8.8sec 1.13 3 60 150 735 1 670 2028 6min 1.94 5 100 250 1225 1 670 2318 45.78min 2.44 Table 2: Empirical Results for Three Independent Tasks In the SMV manual <ref> [McM92] </ref>, the overall time complexity of an SMV program is derived from three factors: an increase in the transition relation BDD nodes, an increase in the state set BDD nodes and an increase in the number of iterations.
Reference: [Obj97] <author> ObjecTime Limited, Kanata, </author> <title> Ontario. MicroRTS Guide Product Release 5.0, </title> <month> March </month> <year> 1997. </year>
Reference-contexts: The ObjecTime Developer Toolset is a CASE tool that provides a fully integrated development environment to support the ROOM methodology, with features such as graphical and textual editing for actor construction and C++ code generation from the model. The ObjecTime toolset includes a target run-time system (TargetRTS) <ref> [Obj97] </ref>, which is linked with the application code to provide a stand-alone executable that may be executed on either a Unix workstation 14 environment, e.g. Solaris, or on a target environment with an underlying real-time oper-ating system such as VxWorks, QNX, pSOS, and VRTX.
Reference: [Sel95] <author> B. Selic. </author> <title> Periodic tasks in ROOM. </title> <booktitle> In Workshop on Object-Oriented Real-Time Systems, </booktitle> <month> October </month> <year> 1995. </year>
Reference-contexts: In addition to executing ROOM specifications, the virtual machine provides a set of system services, among which there is a communication service and a timing service. The communication service establishes and manages connections between actors. The timing service is used to set and cancel timers, both one-shot and periodic <ref> [Sel95] </ref>. The system services are accessed through SAPs, like other services, however their corresponding SPPs are implicit. The ROOM virtual machine is also responsible for interfacing with other (non-ROOM) environments, such as specialized hardware or foreign software systems that may be part of the computing environment. <p> In addition to executing ROOM specifications, TargetRTS provides a set of system services, among which there is a communication service and a timing service. The timing service is used to set and cancel timers, both one-shot and periodic <ref> [Sel95] </ref>. In ROOM, actors are potentially concurrent objects having a private address space. In implementing ROOM models, one must deal with the mapping of ROOM actors to the underlying operating system's execution abstractions.
Reference: [Sel96] <author> B. Selic. </author> <title> Tutorial: Real-time object-oriented modeling (ROOM). </title> <booktitle> In IEEE Real-Time Technology and Applications Symposium, </booktitle> <address> Brookline, Massachusetts, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Although, the use of real-time scheduling theory has greatly improved development time and maintenance of real-time applications, there is still a need for a formal design 7 method. In the ROOM tutorial <ref> [Sel96] </ref>, Selic presents arguments for using ROOM method-ology along with its CASE toolset, ObjecTime, during design, implementation, maintenance and evolutionary development phases of real-time applications. To do that, he defines the term architectural decay, the phenomenon of successive deterioration of system architecture during software implementation and maintenance phases.
Reference: [SFR97] <author> M. Saksena, P. Freedman, and P. Rodziewicz. </author> <title> Guidelines for automated implementation of executable object oriented models for real-time embedded control systems. </title> <booktitle> In IEEE Real-Time Systems Symposium, </booktitle> <address> San Francisco, </address> <month> December </month> <year> 1997. </year>
Reference-contexts: In September 1996, another project began at CRIM jointly founded by Bombardier and the Natural Sciences and Engineering Research Council (NSERC) to include the University of Sherbrooke and Concordia University. As a result of CRIM-Concordia collaboration, another paper <ref> [SFR97] </ref> was published. In [SFR97], Saksena et al. showed that it is possible to perform scheduling analysis on ROOM models, based on the key insight that even though a given application may be processing many external messages in a state-dependent manner, only a relatively small number of transactions 1 are time-critical <p> In September 1996, another project began at CRIM jointly founded by Bombardier and the Natural Sciences and Engineering Research Council (NSERC) to include the University of Sherbrooke and Concordia University. As a result of CRIM-Concordia collaboration, another paper <ref> [SFR97] </ref> was published. In [SFR97], Saksena et al. showed that it is possible to perform scheduling analysis on ROOM models, based on the key insight that even though a given application may be processing many external messages in a state-dependent manner, only a relatively small number of transactions 1 are time-critical and need to be <p> an external incoming (stimulus) message and will be formally defined in Chapter 2. 2 Actors are the primary structural element in ROOM and will be also described in Chapter 2. 4 as part of continuing CRIM-Concordia collaborative efforts which presented experimental evidence of the soundness of the ideas described in <ref> [SFR97] </ref>. To do that, the ObjecTime run-time system (TargetRTS) was modified in accordance with the guidelines presented in [SFR97], a schedulability analysis model was developed taking into account implementation costs of TargetRTS, and the approach was validated using a simple instrumented ROOM model implementing a set of periodic transactions through measurements. <p> structural element in ROOM and will be also described in Chapter 2. 4 as part of continuing CRIM-Concordia collaborative efforts which presented experimental evidence of the soundness of the ideas described in <ref> [SFR97] </ref>. To do that, the ObjecTime run-time system (TargetRTS) was modified in accordance with the guidelines presented in [SFR97], a schedulability analysis model was developed taking into account implementation costs of TargetRTS, and the approach was validated using a simple instrumented ROOM model implementing a set of periodic transactions through measurements. <p> It may not be possible to nicely separate the control and data processing functionalities into separate actors. Even when it is possible, there may be sufficient low priority workload in the control thread that can lead to missed transaction deadlines. This problem was identified in <ref> [SFR97] </ref>, and it was suggested that TargetRTS should automatically manage thread priorities to reflect the priority of the messages to be processed by the thread. <p> at any time during their execution, but in reality they are only preempted during their message passing time intervals. 49 Chapter 6 Case Study of Automobile Cruise Control To illustrate the concepts developed earlier in this thesis, we will use a variant of an automobile cruise control system, presented in <ref> [SFR97] </ref>. Here, we assume that the current automobile speed is readily available within the Speedometer actor. In [SFR97], the current automobile speed was calculated from an external interrupt event generated by the engine drive shaft. We also modified the behavior of the system under driver control. <p> time intervals. 49 Chapter 6 Case Study of Automobile Cruise Control To illustrate the concepts developed earlier in this thesis, we will use a variant of an automobile cruise control system, presented in <ref> [SFR97] </ref>. Here, we assume that the current automobile speed is readily available within the Speedometer actor. In [SFR97], the current automobile speed was calculated from an external interrupt event generated by the engine drive shaft. We also modified the behavior of the system under driver control. <p> In particular, our ManualControl state contains the Accelerating, Braking and ReadytoCruise states; also the automobile cruise control can switch to state AutomaticControl whenever the driver shifts the cruise control lever to either the cruise or resume position while neither the brake nor the accelerator pedals are pressed. In <ref> [SFR97] </ref>, the ManualControl state contained the Initial, Accelerating, NotBraking and Braking states and the cruise control was switched to AutomaticControl when the driver shifted the cruise control lever to either the cruise or resume position when the brake pedal was not pressed, or the driver shifted the cruise control level to
Reference: [SGW94] <author> B. Selic, G. Gullekson, and P.T. Ward. </author> <title> Real-Time Object Oriented Modeling. </title> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference-contexts: It is not surprising that there is increasing interest in new generation methodologies and CASE tools which make possible the modelling and analysis of computing systems in terms of executable models [HG96]. One such product is the modelling language ROOM (Real-Time Object Oriented Modeling) <ref> [SGW94] </ref> and its CASE tool, ObjecTime, which grew out of more than ten years of internal development at Bell-Northern Research (now Nortel). <p> Indeed, we observe that the telecommunications community has widely accepted such new generation of CASE tool support, e.g. ROOM <ref> [SGW94] </ref> and OCTOPUS [AKZ96]. We believe that such acceptance is due, in part, to the sheer size and complexity of new telecommunication products and their fundamentally event-driven nature. 1 In contrast, the embedded control systems community continues to be much more con-servative.
Reference: [SPFR98] <author> M. Saksena, A. Ptak, P. Freedman, and P. Rodziewicz. </author> <title> Schedulability analysis for automated implementations of real-time object-oriented models. </title> <booktitle> In IEEE Real-Time Systems Symposium, </booktitle> <address> Madrid, </address> <month> December </month> <year> 1998. </year>
Reference-contexts: Also, another closely related paper <ref> [SPFR98] </ref>, was written 1 A transaction is a chained sequence of transition actions triggered by an external incoming (stimulus) message and will be formally defined in Chapter 2. 2 Actors are the primary structural element in ROOM and will be also described in Chapter 2. 4 as part of continuing CRIM-Concordia <p> Dynamic Thread Priorities Lets begin by describing a system where a static thread priority approach fails to work. The train tilting system presented in <ref> [SPFR98] </ref> is one such example. It may not be possible to nicely separate the control and data processing functionalities into separate actors. Even when it is possible, there may be sufficient low priority workload in the control thread that can lead to missed transaction deadlines. <p> Then we will develop a specific scheduling model for each executable. The generic and canonical scheduling models are based on observations presented in <ref> [SPFR98] </ref>. 5.1 Generic Resource Scheduling Model We let each transaction G i with n transitions has the generic overhead cost O i , generic blocking penalty B i , specific overhead for single- or multi-threaded ROOM executables O speci f ic i , specific blocking penalty for single- or multi-threaded ROOM
Reference: [SR98] <author> B. Selic and J. Rumbaugh. </author> <title> Using UML for modeling complex real-time systems. </title> <note> Available from www.objectime.com/uml/index.html, March 1998. 70 </note>
Reference-contexts: In particular, the results developed here are equally applicable to the Unified Modeling Language (UML) developed by a consortium of companies, including Rational, i-Logix and ObjecTime, and recently standardized by Object Management Group (OMG). Indeed, a recent white paper <ref> [SR98] </ref> from ObjecTime and Rational states that Rational and ObjecTime are defining a comprehensive approach for the application of UML to the development of complex real-time systems, in which modelling constructs defined in the ROOM language are specified using the UML standard.
Reference: [SRL90] <author> L. Sha, R. Rajkumar, and J. Lehoczky. </author> <title> Priority inheritance protocols: An approach to real-time synchronization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(9):11751185, </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: The authors presented implementation guidelines that minimize priority inversion of transactions due to lower priority transactions by managing thread priorities dynamically, bound priority inversion of transactions due to inter-thread message passing mechanism by using the Immediate Inheritance protocol <ref> [SRL90] </ref>, and allow adding new functionality to an actor 2 without affecting the schedulability of higher priority transactions associated with that actor. <p> In the case of multi-threaded ROOM models, actors communicate via inter-thread message passing mechanisms. The message passing itself requires the sharing of message queues, and therefore, the processing associated with sending and receiving messages can incur unbounded blocking. Immediate Inheritance and Priority Ceiling protocols <ref> [SRL90] </ref> can be used to bound the blocking time associated with such priority inversion. We propose the use of a simpler Immediate Inheritance protocol and show that using this protocol, such blocking may be bounded.
Reference: [SW96] <author> B. Selic and P. Ward. </author> <title> The challenges of real-time software design. </title> <booktitle> Embedded Systems Programming, </booktitle> <pages> pages 6682, </pages> <month> October </month> <year> 1996. </year> <month> 71 </month>
Reference-contexts: Later on, we will describe how ROOM addresses the architectural decay problem. In a recent article entitled The Challenges of Real-Time Software Design <ref> [SW96] </ref>, Selic and Ward describe two basic styles of real-time software. The time-driven style corresponds to using cyclic activities triggered by time and is well suited to the implementation of periodic activities, e.g. control loops within embedded systems.
References-found: 32

