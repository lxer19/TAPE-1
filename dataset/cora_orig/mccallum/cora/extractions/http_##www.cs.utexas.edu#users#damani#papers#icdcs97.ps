URL: http://www.cs.utexas.edu/users/damani/papers/icdcs97.ps
Refering-URL: http://www.cs.utexas.edu/users/damani/papers/papers.html
Root-URL: 
Title: Distributed Recovery with K-Optimistic Logging  
Author: Yi-Min Wang Om P. Damani Vijay K. Garg 
Abstract: Fault-tolerance techniques based on checkpointing and message logging have been increasingly used in real-world applications to reduce service downtime. Most industrial applications have chosen pessimistic logging because it allows fast and localized recovery. The price that they must pay, however, is the higher failure-free overhead. In this paper, we introduce the concept of K-optimistic logging where K is the degree of optimism that can be used to fine-tune the tradeoff between failure-free overhead and recovery efficiency. Traditional pessimistic logging and optimistic logging then become the two extremes in the entire spectrum spanned by K-optimistic logging. Our approach is to prove that only dependencies on those states that may be lost upon a failure need to be tracked on-line, and so transitive dependency tracking can be performed with a variable-size vector. The size of the vector piggybacked on a message then indicates the number of processes whose failures may revoke the message, and K corresponds to the system-imposed upper bound on the vector size. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Borg, W. Blau, W. Graetsch, F. Herrmann, and W. Oberle. </author> <title> Fault tolerance under UNIX. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 7(1) </volume> <pages> 1-24, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Log-based rollback-recovery [3] is an effective technique for providing low-cost fault tolerance to distributed applications <ref> [1, 4, 7, 12] </ref>. It is based on the following piecewise deterministic (PWD) execution model [12]: process execution is divided into a sequence of state intervals each of which is started by a nondeterministic event such as message receipt 1 . The execution within an interval is completely deterministic. <p> Depending on when received messages are logged, log-based rollback-recovery techniques can be divided into two categories: pessimistic logging <ref> [1, 5] </ref> and optimistic logging [12]. Pessimistic logging either synchronously logs each message upon receiving it, or logs all delivered messages before sending a message.
Reference: [2] <author> O. P. Damani and V. K. Garg. </author> <title> How to recover efficiently and asynchronously when optimism fails. </title> <booktitle> In Proc. IEEE Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pages 108-115, </pages> <year> 1996. </year>
Reference-contexts: When a process rolls back, it starts a new incarnation [12] (or version <ref> [2] </ref>), as illustrated by P 1 's execution. Each (t; x) i identifies the interval as the x th state interval of the t th incarnation of process P i . <p> Traditional asynchronous recovery protocols usually require every non-failed rolled-back process to behave as if it itself has failed [11, 12] by starting a new incarnation and broadcasting a rollback announcement. It was recently observed that, under piecewise deterministic execution model, announcing only failures is sufficient for orphan detection <ref> [2] </ref>. We give a proof of this observation in Theorem 1, and carry the observation even further by proving, in Theorem 2, that any dependencies on stable intervals can be omitted without affecting the correctness of a recovery protocol which tracks dependencies transitively. <p> We next describe three modifications to Strom and Yemini's protocol, based on Theorem 1, Theorem 2 and Corollary 1, respectively. The modified protocol then serves as the basis for K-optimistic logging. Applying Theorem 1: Damani and Garg improved Strom and Yemini's protocol by applying Theorem 1 <ref> [2] </ref>. Since only failures are announced, the number of rollback announcements and the size of incarnation end tables are reduced. They did not increment the incarnation number on occurrence of non-failure rollback. <p> The protocol describes the actions taken by a process P i upon the occurrence of different events. We explain in detail only those parts that are unique to our algorithm. A complete explanation of the generic parts for optimistic logging and asynchronous recovery can be found in previous papers <ref> [2, 12] </ref>. All routines modifying volatile state are described in Figure 2 and those modifying stable storage are described in Figure 3. In the variable definition section, the integer K is the degree of optimism known to all processes at Initialize.
Reference: [3] <author> E. N. Elnozahy, D. B. Johnson, and Y. M. Wang. </author> <title> A survey of rollback-recovery protocols in message-passing systems. </title> <type> Tech. Rep. </type> <institution> No. CMU-CS-96-181, Dept. of Computer Science, Carnegie Mellon University (also available at ftp://ftp.cs.cmu.edu/user/mootaz/papers/S.ps), </institution> <year> 1996. </year>
Reference-contexts: 1 Introduction Log-based rollback-recovery <ref> [3] </ref> is an effective technique for providing low-cost fault tolerance to distributed applications [1, 4, 7, 12]. <p> We use the example in Figure 1 to illustrate the major components of an asynchronous recovery protocol. Each rectangular box represents a state interval started by a message-delivering event. A shaded box 3 We do not address the issue of lost in-transit messages <ref> [3] </ref> in this paper. They either do not cause inconsistency, or they can be retrieved from the senders' volatile logs [12]. indicates that the state interval is stable, i.e., can al-ways be recreated from a checkpoint and message logs saved on stable storage.
Reference: [4] <author> E. N. Elnozahy and W. Zwaenepoel. </author> <title> On the use and implementation of message logging. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 298-307, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction Log-based rollback-recovery [3] is an effective technique for providing low-cost fault tolerance to distributed applications <ref> [1, 4, 7, 12] </ref>. It is based on the following piecewise deterministic (PWD) execution model [12]: process execution is divided into a sequence of state intervals each of which is started by a nondeterministic event such as message receipt 1 . The execution within an interval is completely deterministic. <p> Log-based rollback-recovery is especially useful for distributed applications that frequently interact with the outside world <ref> [4] </ref>. It can be used either to reduce the amount of lost work due to failures in long-running scientific applications [4], or to enable fast and localized recovery in continuously-running service-providing applications [5]. <p> Log-based rollback-recovery is especially useful for distributed applications that frequently interact with the outside world <ref> [4] </ref>. It can be used either to reduce the amount of lost work due to failures in long-running scientific applications [4], or to enable fast and localized recovery in continuously-running service-providing applications [5]. Depending on when received messages are logged, log-based rollback-recovery techniques can be divided into two categories: pessimistic logging [1, 5] and optimistic logging [12]. <p> The execution of each process satisfies the piecewise deterministic (PWD) model. A rollback-recovery layer is implemented underneath the application layer to perform checkpointing, message logging, dependency tracking, output commit, etc. During failure-free execution, each process takes independent or coordinated checkpoints <ref> [4] </ref>, and employs additional optimistic logging. When a checkpoint is taken, all messages in the volatile buffer are also written to stable storage at the same time so that stable state intervals are always continuous. Upon a failure, non-stable state intervals are lost and cannot be reconstructed.
Reference: [5] <author> Y. Huang and Y. M. Wang. </author> <title> Why optimistic message logging has not been used in telecommunications systems. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 459-463, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Log-based rollback-recovery is especially useful for distributed applications that frequently interact with the outside world [4]. It can be used either to reduce the amount of lost work due to failures in long-running scientific applications [4], or to enable fast and localized recovery in continuously-running service-providing applications <ref> [5] </ref>. Depending on when received messages are logged, log-based rollback-recovery techniques can be divided into two categories: pessimistic logging [1, 5] and optimistic logging [12]. Pessimistic logging either synchronously logs each message upon receiving it, or logs all delivered messages before sending a message. <p> Depending on when received messages are logged, log-based rollback-recovery techniques can be divided into two categories: pessimistic logging <ref> [1, 5] </ref> and optimistic logging [12]. Pessimistic logging either synchronously logs each message upon receiving it, or logs all delivered messages before sending a message. <p> Systems running such applications are often designed with extra capacity which can absorb reasonable overhead without causing noticeable service degradation. On the other hand, improving recovery efficiency to reduce service down time can greatly improve service quality. As a result, most commercial service-providing applications have chosen pessimistic logging <ref> [5] </ref>. The above coarse-grain tradeoff, however, may not provide optimal performance when the typical scenarios are no longer valid. For example, although hardware failures are rare, programs can also fail or exit due to transient software or protocol errors such as triggered boundary conditions, temporary resource un-availability, and bypassable deadlocks.
Reference: [6] <author> D. B. Johnson. </author> <title> Efficient transparent optimistic rollback recovery for distributed application programs. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 86-95, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: An alternative is to perform output-driven logging by sending additional messages to force the logging progress at P 0 , P 1 and P 3 <ref> [6] </ref>. 3 Commit Dependency Tracking In this paper, we use i; j; k for process numbers, t and s for incarnation numbers, and x and y for state interval indices. <p> Lowry et al. [9] introduced the concept of recovery unit gateways to compress the vector at the cost of introducing false dependencies. Direct dependency tracking techniques <ref> [6, 7, 10] </ref> piggyback only the sender's current state interval index, and so are in general more scalable.
Reference: [7] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> Recovery in distributed systems using optimistic message logging and checkpointing. </title> <journal> J. Algorithms, </journal> <volume> 11 </volume> <pages> 462-491, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Log-based rollback-recovery [3] is an effective technique for providing low-cost fault tolerance to distributed applications <ref> [1, 4, 7, 12] </ref>. It is based on the following piecewise deterministic (PWD) execution model [12]: process execution is divided into a sequence of state intervals each of which is started by a nondeterministic event such as message receipt 1 . The execution within an interval is completely deterministic. <p> In this section, u; v; w; z refer to state intervals, and P v:p refers to the process to which v belongs. Lamport [8] defined the happen before relation for states. Similarly, Johnson and Zwaenepoel <ref> [7] </ref> defined the happen before relation (or transitive dependency relation [10]) for state intervals. Let u v if u and v are intervals of same process and u immediately precedes v. Let u ; v if a message sent from interval u is delivered to start interval v. <p> Lowry et al. [9] introduced the concept of recovery unit gateways to compress the vector at the cost of introducing false dependencies. Direct dependency tracking techniques <ref> [6, 7, 10] </ref> piggyback only the sender's current state interval index, and so are in general more scalable.
Reference: [8] <author> L. Lamport. </author> <title> Time, clocks and the ordering of events in a distributed system. </title> <journal> Commun. ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: In this section, u; v; w; z refer to state intervals, and P v:p refers to the process to which v belongs. Lamport <ref> [8] </ref> defined the happen before relation for states. Similarly, Johnson and Zwaenepoel [7] defined the happen before relation (or transitive dependency relation [10]) for state intervals. Let u v if u and v are intervals of same process and u immediately precedes v.
Reference: [9] <author> A. Lowry, J. R. Russell, and A. P. Goldberg. </author> <title> Optimistic failure recovery for very large networks. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 66-75, </pages> <year> 1991. </year>
Reference-contexts: To address the scalability issue of dependency tracking for large systems, Sistla and Welch [10] divided the entire system into clusters and treated interclus-ter messages as output messages. Lowry et al. <ref> [9] </ref> introduced the concept of recovery unit gateways to compress the vector at the cost of introducing false dependencies. Direct dependency tracking techniques [6, 7, 10] piggyback only the sender's current state interval index, and so are in general more scalable.
Reference: [10] <author> A. P. Sistla and J. L. Welch. </author> <title> Efficient distributed recovery using message logging. </title> <booktitle> In Proc. 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 223-238, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Our approach to deriving the K-optimistic logging protocol is to first prove a fundamental property on minimum transitive dependency tracking. To enable decentralized recovery and efficient output commit, transitive dependency tracking <ref> [10] </ref> is commonly used to record the highest-index state interval of each process, on which a local process depends. Since we need at least one entry for each process 2 , the size of a transitive dependency vector is at least N . <p> In this section, u; v; w; z refer to state intervals, and P v:p refers to the process to which v belongs. Lamport [8] defined the happen before relation for states. Similarly, Johnson and Zwaenepoel [7] defined the happen before relation (or transitive dependency relation <ref> [10] </ref>) for state intervals. Let u v if u and v are intervals of same process and u immediately precedes v. Let u ; v if a message sent from interval u is delivered to start interval v. <p> The concept of K-optimistic logging can be considered as the counterpart of lazy checkpoint coordination for the area of log-based rollback-recovery. To address the scalability issue of dependency tracking for large systems, Sistla and Welch <ref> [10] </ref> divided the entire system into clusters and treated interclus-ter messages as output messages. Lowry et al. [9] introduced the concept of recovery unit gateways to compress the vector at the cost of introducing false dependencies. <p> Lowry et al. [9] introduced the concept of recovery unit gateways to compress the vector at the cost of introducing false dependencies. Direct dependency tracking techniques <ref> [6, 7, 10] </ref> piggyback only the sender's current state interval index, and so are in general more scalable. <p> Direct dependency tracking techniques [6, 7, 10] piggyback only the sender's current state interval index, and so are in general more scalable. The tradeoff is that, at the time of output commit and recovery, the system needs to assemble direct dependencies to obtain transitive dependencies <ref> [10] </ref>. 6 Summary In this paper, we proved a fundamental result in distributed systems recovery: with transitive dependency tracking, dependencies on stable state intervals are redundant and can be omitted. The result naturally lead to a dependency tracking scheme with a variable-size vector carrying only minimum amount of information.
Reference: [11] <author> S. W. Smith, D. B. Johnson, and J. D. Tygar. </author> <title> Completely asynchronous optimistic recovery with minimal rollbacks. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 361-370, </pages> <year> 1995. </year>
Reference-contexts: To avoid this disadvantage, existing protocols couple dependency propagation with failure information propagation: the protocol by Strom and Yemini [12] delays the delivery of certain messages until receiving necessary failure information (to be described later); the protocol by Smith et al. <ref> [11] </ref> piggybacks failure information along with dependency information. We focus on Strom and Yem-ini's approach in this paper. In the next section, we prove a theorem on omitting redundant dependency tracking and describe how the result can be used to improve their protocol. <p> Messages sent by orphan states are also called orphans. If the current state of a process is orphan then process itself might be called orphan when there is no confusion. Traditional asynchronous recovery protocols usually require every non-failed rolled-back process to behave as if it itself has failed <ref> [11, 12] </ref> by starting a new incarnation and broadcasting a rollback announcement. It was recently observed that, under piecewise deterministic execution model, announcing only failures is sufficient for orphan detection [2].
Reference: [12] <author> R. E. Strom and S. Yemini. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Log-based rollback-recovery [3] is an effective technique for providing low-cost fault tolerance to distributed applications <ref> [1, 4, 7, 12] </ref>. It is based on the following piecewise deterministic (PWD) execution model [12]: process execution is divided into a sequence of state intervals each of which is started by a nondeterministic event such as message receipt 1 . The execution within an interval is completely deterministic. <p> 1 Introduction Log-based rollback-recovery [3] is an effective technique for providing low-cost fault tolerance to distributed applications [1, 4, 7, 12]. It is based on the following piecewise deterministic (PWD) execution model <ref> [12] </ref>: process execution is divided into a sequence of state intervals each of which is started by a nondeterministic event such as message receipt 1 . The execution within an interval is completely deterministic. During normal execution, each process periodically saves its state on stable storage as a checkpoint. <p> Depending on when received messages are logged, log-based rollback-recovery techniques can be divided into two categories: pessimistic logging [1, 5] and optimistic logging <ref> [12] </ref>. Pessimistic logging either synchronously logs each message upon receiving it, or logs all delivered messages before sending a message. <p> A major disadvantage is that it allows potential orphan states to send messages, which may create more orphans and hence more rollbacks. To avoid this disadvantage, existing protocols couple dependency propagation with failure information propagation: the protocol by Strom and Yemini <ref> [12] </ref> delays the delivery of certain messages until receiving necessary failure information (to be described later); the protocol by Smith et al. [11] piggybacks failure information along with dependency information. We focus on Strom and Yem-ini's approach in this paper. <p> Each rectangular box represents a state interval started by a message-delivering event. A shaded box 3 We do not address the issue of lost in-transit messages [3] in this paper. They either do not cause inconsistency, or they can be retrieved from the senders' volatile logs <ref> [12] </ref>. indicates that the state interval is stable, i.e., can al-ways be recreated from a checkpoint and message logs saved on stable storage. When a process rolls back, it starts a new incarnation [12] (or version [2]), as illustrated by P 1 's execution. <p> They either do not cause inconsistency, or they can be retrieved from the senders' volatile logs <ref> [12] </ref>. indicates that the state interval is stable, i.e., can al-ways be recreated from a checkpoint and message logs saved on stable storage. When a process rolls back, it starts a new incarnation [12] (or version [2]), as illustrated by P 1 's execution. Each (t; x) i identifies the interval as the x th state interval of the t th incarnation of process P i . <p> Rollback announcements: When a process P j fails, it restores the most recent checkpoint and replays the logged messages that were processed after that checkpoint. Then P j increments its incarnation number and broadcast a rollback announcement (or recovery message <ref> [12] </ref>) containing the ending index number of the failed incarnation. Upon receiving a rollback announcement, a process P i compares its dependency with that index. <p> If the dependency shows that P i 's state depends on a higher-index interval of any failed incarnation of P j , P i rolls back to undo the orphan states, and starts a new incarnation as if it itself has failed <ref> [12] </ref>. For example, suppose process P 1 in Figure 1 fails at the point marked "X". It rolls back to (0; 4) 1 , increments the incarnation number to 1, and broadcast announcement r 1 containing (0; 4) 1 . <p> Periodically, it broadcast a logging progress notification to let other processes know which of its state intervals has become stable. Such information is accumulated locally at each process to allow output commit and garbage collection <ref> [12] </ref>. For example, after P 3 makes the state intervals (2; 5) 3 and (2; 6) 3 stable, it can broadcast a notification to let others know that. Output commit: Distributed applications often need to interact with the outside world. <p> This is called the output commit problem. In a PWD execution, an output can be committed when the state intervals that it depends on have all become stable <ref> [12] </ref>. <p> Messages sent by orphan states are also called orphans. If the current state of a process is orphan then process itself might be called orphan when there is no confusion. Traditional asynchronous recovery protocols usually require every non-failed rolled-back process to behave as if it itself has failed <ref> [11, 12] </ref> by starting a new incarnation and broadcasting a rollback announcement. It was recently observed that, under piecewise deterministic execution model, announcing only failures is sufficient for orphan detection [2]. <p> COROLLARY 3 Upon starting the execution, a process has no dependency entry. As pointed out earlier, completely asynchronous recovery protocols that decouple dependency propagation from failure information propagation in general need to keep track of dependencies on all incarnations of all processes. Strom and Yemini <ref> [12] </ref> introduced the following coupling in their protocol to allow tracking dependency on only one incarnation of each process so that the size of dependency vector always remains N : when process P j receives a message m carrying a dependency entry (t; x) i before it receives the rollback announcement <p> For example, in Figure 1, P 4 should delay the delivery of m 6 until it receives r 1 . After P 4 determines that its state has not become orphan, a lexicographical maximum operation <ref> [12] </ref> is applied to the two pairs (0; 4) and (1; 5) to update the entry to (1; 5). This update in fact implicitly applies Corollary 1: r 1 notifies P 4 that (0; 4) 1 has become stable, and so the dependency on (0; 4) 1 can be omitted. <p> The protocol describes the actions taken by a process P i upon the occurrence of different events. We explain in detail only those parts that are unique to our algorithm. A complete explanation of the generic parts for optimistic logging and asynchronous recovery can be found in previous papers <ref> [2, 12] </ref>. All routines modifying volatile state are described in Figure 2 and those modifying stable storage are described in Figure 3. In the variable definition section, the integer K is the degree of optimism known to all processes at Initialize.
Reference: [13] <author> Y. M. Wang and W. K. Fuchs. </author> <title> Lazy checkpoint coordination for bounding rollback propagation. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 78-85, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: In the area of checkpoint-based rollback-recovery, the concept of lazy checkpoint coordination <ref> [13] </ref> has been proposed to provide a fine-grain tradeoff in-between the two extremes of uncoordinated checkpointing and coordinated checkpointing. An integer parameter Z, called the laziness, was introduced to control the degree of optimism by controlling the frequency of coordination.
References-found: 13

