URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/survey98.ps
Refering-URL: http://www.cs.toronto.edu/~bonner/papers.html
Root-URL: http://www.cs.toronto.edu
Email: bonner@db.toronto.edu  kifer@cs.sunysb.edu  
Phone: 2  
Title: The State of Change: A Survey  
Author: Anthony J. Bonner and Michael Kifer 
Address: Toronto, Toronto, Ontario M5S 1A4, Canada,  11794, U.S.A.,  
Affiliation: 1 Department of Computer Science, University of  Department of Computer Science, SUNY at Stony Brook, Stony Brook, NY  
Abstract: Updates are a crucial component of any database programming language. Even the simplest database transactions, such as withdrawal from a bank account, require updates. Unfortunately, updates are not accounted for by the classical Horn semantics of logic programs and deductive databases, which limits their usefulness in real-world applications. As a short-term practical solution, logic programming languages have resorted to handling updates using ad hoc operators without a logical semantics. A great many works have been dedicated to developing logical theories in which the state of the underlying database can evolve with time. Many of these theories were developed with specific applications in mind, such as reasoning about actions, database transactions, program verification, etc. As a result, the different approaches have different strengths and weaknesses. In this survey, we review a number of these works, discuss their application domains, and highlight their strong and weak points. 
Abstract-found: 1
Intro-found: 1
Reference: [Abi88] <author> S. Abiteboul. </author> <title> Updates, a new frontier. </title> <booktitle> In Intl. Conference on Database Theory, </booktitle> <pages> pages 1-18, </pages> <year> 1988. </year>
Reference: [AHV95] <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference: [AP91] <author> J.-M. Andreoli and R. Pareschi. </author> <title> Linear objects: Logical processes with built-in inheritance. </title> <journal> New Generation Computing, </journal> <volume> 9(4) </volume> <pages> 445-473, </pages> <year> 1991. </year>
Reference-contexts: In particular, we have excluded works based on various temporal logics, since they have had minimal influence on databases and logic programming. (Some discussion of these works appears in [BK95].) Likewise, we did not discuss proposals based on Linear Logic (such as <ref> [AP91] </ref>) or Rewriting Logic (e.g., [Mes92a,Mes92b]). Nevertheless, some comparison of these approaches with Concurrent Transaction Logic can be found in [BK96]. Acknowledgments. The presentation in this paper has been greatly improved due to the referee comments.
Reference: [AU79] <author> A.V. Aho and J.D. Ullman. </author> <title> Universality of data retrieval languages. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 110-120, </pages> <year> 1979. </year>
Reference-contexts: Unfortunately, this means that much of the familiar database and logic programming methodology does not apply. For instance, although transitive closure is trivial to express in a deductive database, it cannot be expressed by the databases of Re-iter's theory, since transitive closure is not first-order definable <ref> [AU79] </ref>. The lack of a minimal-model semantics also complicates the representation of relational databases. Instead of representing them as sets of ground atomic formulas in the usual way, the theory uses Clark's completion [Llo87,Rei84], which, in the case of databases, requires very large first-order formulas.
Reference: [AV90] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural languages for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41 </volume> <pages> 181-229, </pages> <year> 1990. </year>
Reference-contexts: Like Datalog with State, the update languages of [AV91,Abi88] assume that databases are relational, and they do not support subtransactions, save-points, or partial abort and rollback. Furthermore, there is no support for subroutines. This can be seen most clearly in the procedural languages defined in <ref> [AV90] </ref>, where the lack of subroutines is reflected in the PSPACE data complexity of some of the languages, since subroutines would lead to alternating PSPACE, that is, EXPTIME [Bon97a].
Reference: [AV91] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 62-124, </pages> <year> 1991. </year>
Reference-contexts: So, John's salary will keep increasing indefinitely. In general, writing update programs in such a language is not a simple matter. Abiteboul and Vianu suggest that, to be useful, update programs must be augmented with explicit control over iteration <ref> [AV91] </ref>.
Reference: [Ban86] <editor> F. Bancilhon. A logic-programming/Object-oriented cocktail. </editor> <booktitle> SIGMOD Record, </booktitle> <volume> 15(3) </volume> <pages> 11-21, </pages> <month> September </month> <year> 1986. </year>
Reference: [Bee92] <author> C. Beeri. </author> <title> New data models and languages|The challenge. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> New York, </address> <month> June </month> <year> 1992. </year> <note> ACM. </note>
Reference: [BK93] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming. </title> <booktitle> In Intl. Conference on Logic Programming, </booktitle> <pages> pages 257-282, </pages> <address> Budapest, Hungary, June 1993. </address> <publisher> MIT Press. </publisher>
Reference: [BK94] <author> A.J. Bonner and M. Kifer. </author> <title> An overview of transaction logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 133 </volume> <pages> 205-265, </pages> <month> October </month> <year> 1994. </year>
Reference: [BK95] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming (or a logic of declarative and procedural knowledge). </title> <type> Technical Report CSRI-323, </type> <institution> University of Toronto, </institution> <month> November </month> <year> 1995. </year> <note> http://www.cs.toronto.edu/~bonner/ transaction-logic.html. </note>
Reference-contexts: This semantics leads to a natural interpretation of "^" as a mechanism for applying constraints that prune away any undesirable executions of a nondeterministic transaction. Such constraints are developed to a greater depth in <ref> [BK95] </ref>, where a rich class of temporal and dynamic constraints is discussed. Some results on executional constraints also appear in [DKRR98]. <p> This in turn leads naturally to the notions of left and right serial implication: ff ( fi = ff :fi and ff ) fi = :ff fi. Using serial implication, one can express a wide variety of dynamic and temporal constraints in T R <ref> [BK95] </ref>. 4.2 McCarty and Van der Meyden In [MvdM92], McCarty and Van der Meyden develop a theory for reasoning about "indefinite" actions. However, [MvdM92] does not address action execution or the updating of databases. <p> In particular, we have excluded works based on various temporal logics, since they have had minimal influence on databases and logic programming. (Some discussion of these works appears in <ref> [BK95] </ref>.) Likewise, we did not discuss proposals based on Linear Logic (such as [AP91]) or Rewriting Logic (e.g., [Mes92a,Mes92b]). Nevertheless, some comparison of these approaches with Concurrent Transaction Logic can be found in [BK96]. Acknowledgments. The presentation in this paper has been greatly improved due to the referee comments.
Reference: [BK96] <author> A.J. Bonner and M. Kifer. </author> <title> Concurrency and communication in transaction logic. </title> <booktitle> In Joint Intl. Conference and Symposium on Logic Programming, </booktitle> <pages> pages 142-156, </pages> <address> Bonn, Germany, September 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Nevertheless, some comparison of these approaches with Concurrent Transaction Logic can be found in <ref> [BK96] </ref>. Acknowledgments. The presentation in this paper has been greatly improved due to the referee comments. The first author was partially supported by a research grant from the Natural Sciences and Engineering Research Council of Canada (NSERC). The second author was partially supported by the NSF grant IRI-9404629.
Reference: [BK98a] <author> A.J. Bonner and M. Kifer. </author> <title> A logic for programming database transactions. </title> <editor> In J. Chomicki and G. Saake, editors, </editor> <booktitle> Logics for Databases and Information Systems, chapter 5, </booktitle> <pages> pages 117-166. </pages> <publisher> Kluwer Academic Publishers, </publisher> <month> March </month> <year> 1998. </year>
Reference: [BK98b] <author> A.J. Bonner and M. Kifer. </author> <title> Results on reasoning about updates in transaction logic. </title> <booktitle> This volume, </booktitle> <year> 1998. </year>
Reference-contexts: In the Horn fragment, users specify and execute transaction programs; and in the full logic, users can express properties of programs and reason about them <ref> [BK98b] </ref>. Like classical Horn logic, the Horn fragment of T R has an operational semantics based on an SLD-style proof procedure, in the logic programming tradition. <p> Instead, frame axioms are needed in T R only when reasoning about the properties of actions, and only then does the frame problem become an issue <ref> [BK98b] </ref>. Historically, there are two versions of T R: sequential T R [BK98a,BK93,BK95,BK94] and concurrent T R [BK96,Bon97b]. In 5 In addition, some of the languages surveyed here assume a fixed set of elementary updates, such as the insertion and deletion of tuples in a relational database. <p> When used for reasoning, properties of programs are expressed as T R formulas, and a logical inference system derives properties of complex programs from those of simple programs <ref> [BK98b] </ref>. In this way, one can reason, for instance, about whether a transaction program preserves the integrity constraints of a database. <p> In AI terminology, this reasoning takes place in open worlds, that is, in the absence of the closed world assumption. The assumption of open worlds separates the T R theory of reasoning <ref> [BK98b] </ref> from the T R theory of logic programming [BK98a,BK93,BK95,BK94], which is based on closed worlds. The rest of this section elaborates on the theory of logic programming. Transaction Logic Programming. Logic programs in sequential T R are based on serial goals.
Reference: [BKC94] <author> A.J. Bonner, M. Kifer, and M. Consens. </author> <title> Database programming in transaction logic. </title> <editor> In A. Ohori C. Beeri and D.E. Shasha, editors, </editor> <booktitle> Proceedings of the International Workshop on Database Programming Languages, Workshops in Computing, </booktitle> <pages> pages 309-337. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1994. </year> <booktitle> Workshop held on Aug 30-Sept 1, 1993, </booktitle> <address> New York City, NY. </address>
Reference: [Bon97a] <author> A.J. Bonner. </author> <title> The power of cooperating transactions. </title> <type> Manuscript, </type> <year> 1997. </year>
Reference-contexts: Furthermore, there is no support for subroutines. This can be seen most clearly in the procedural languages defined in [AV90], where the lack of subroutines is reflected in the PSPACE data complexity of some of the languages, since subroutines would lead to alternating PSPACE, that is, EXPTIME <ref> [Bon97a] </ref>.
Reference: [Bon97b] <author> A.J. Bonner. </author> <title> Transaction Datalog: a compositional language for transaction programming. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <address> Estes Park, Colorado, </address> <month> August </month> <year> 1997. </year> <note> Springer Ver-lag. </note>
Reference-contexts: This system executes transactions, updates the database, and generates query answers, all as a result of proving theorems. Transactional features such as abort, rollback, and save-points are also handled by the theorem prover <ref> [Bon97b] </ref>. T R programs thus retain all the traditional features of classical logic programs, while providing a logical semantics for database updates, and an operational semantics for atomic transactions.
Reference: [BSR96] <author> A. Bonner, A. Shrufi, and S. Rozen. LabFlow-1: </author> <title> a database benchmark for high-throughput workflow management. </title> <booktitle> In Intl. Conference on Extending Database Technology, number 1057 in Lecture Notes in Computer Science, </booktitle> <pages> pages 463-478, </pages> <address> Avignon, France, March 25-29 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference: [CH80] <author> A.K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: Syntactically, Golog is similar to the procedural database language QL developed by Chandra and Harel <ref> [CH80] </ref> extended with subroutines and non-deterministic choice. Semantically, however, Golog is much more complex, since the meaning of elementary actions is specified in the situation calculus, and the meaning of larger programs is specified by formulas of second-order logic.
Reference: [Che95] <author> W. Chen. </author> <title> Declarative updates of relational databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 20(1) </volume> <pages> 42-70, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: In this case, events can be indexed for fast retrieval, resulting in fast inference [Kow92]. 3.5 Chen's Calculus Chen developed a calculus and an equivalent algebra for constructing database transactions <ref> [Che95] </ref>. Like T R, this calculus uses logical operators (including serial conjunction) to build complex transactions from elementary updates. One interesting idea in [Che95] is a special semantics for the logical connective ^, which makes it easy to express bulk updates (assigning the contents of a database view to a relation). <p> events can be indexed for fast retrieval, resulting in fast inference [Kow92]. 3.5 Chen's Calculus Chen developed a calculus and an equivalent algebra for constructing database transactions <ref> [Che95] </ref>. Like T R, this calculus uses logical operators (including serial conjunction) to build complex transactions from elementary updates. One interesting idea in [Che95] is a special semantics for the logical connective ^, which makes it easy to express bulk updates (assigning the contents of a database view to a relation). <p> The minimality principle makes the calculus non-monotonic even in the absence of negation. As with all "update in the head" languages, Chen's calculus lacks mechanisms for defining subroutines, which makes it unsuitable as a programming language for database transactions. However, Chen mentions in <ref> [Che95] </ref> that his calculus was intended as a language for specifying bulk and other non-trivial updates, which could then be used as elementary operations by a language like Transaction Logic. 3.6 Ultra Wichert and Freitag [WF97] describe an update language, which later received the name Ultra. <p> Because of his interest in deontic concepts, McCarty defines two notions of satisfaction. In one notion, called "strict satisfaction," the conjunction ^ corresponds to concurrent action, as it does in Chen's work <ref> [Che95] </ref>. In the other notion, called "satisfaction," the same symbol corresponds to constraints on action execution, as it does in T R. However, the development of such constraints was never considered, and this promising avenue of study was not developed in detail.
Reference: [CM81] <author> W.F. Clocksin and C.S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: 1 Introduction Logic-based approaches to updates can be broadly classified into two categories: those designed for database or logic programming and those designed for reasoning about programs and actions. Prolog <ref> [CM81] </ref> is an early (and the best-known) example of the languages in the first category. The situation calculus [McC63], Dynamic Logic [Har79], and Temporal Logic [Pnu77] are, in our view, the forefathers of the modern approaches to reasoning about actions.
Reference: [DKRR98] <author> H. Davulcu, M. Kifer, C.R. Ramakrishnan, and I.V. Ramakrishnan. </author> <title> Logic based modeling and analysis of workflows. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: Such constraints are developed to a greater depth in [BK95], where a rich class of temporal and dynamic constraints is discussed. Some results on executional constraints also appear in <ref> [DKRR98] </ref>. Note that it would not be possible to express constraints on transaction execution (not to mention reasoning about them) if T R had a semantics based on pairs of states (like Dynamic Logic) instead of paths.
Reference: [Fin86] <author> J. </author> <title> Finger. Exploiting Constraints in Design Synthesis. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1986. </year>
Reference: [Gre69] <author> C.C. Green. </author> <title> Application of theorem proving to problem solving. </title> <booktitle> In Intl. Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 219-240, </pages> <year> 1969. </year>
Reference-contexts: Specifying all the invariants of an action in a succinct way is known as the frame problem. Early solutions to this problem required one axiom for each action-fluent pair <ref> [Gre69] </ref>. For instance, in the example above, the following rule would be a frame axiom: clear (Z; do (move (X; Y ); S)) possible (move (X; Y ); S) ^ clear (Z; S) ^ Z 6= Y This rule pairs the action move with the fluent clear.
Reference: [Har79] <author> D. Harel. </author> <title> First-Order Dynamic Logic, </title> <booktitle> volume 68 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Prolog [CM81] is an early (and the best-known) example of the languages in the first category. The situation calculus [McC63], Dynamic Logic <ref> [Har79] </ref>, and Temporal Logic [Pnu77] are, in our view, the forefathers of the modern approaches to reasoning about actions. As we shall see, both the situation calculus and Dynamic Logic influenced the design of several logic-based languages for programming database transactions. <p> :assert (X)? or assert (X) retract (Y )? Also, how does one logically account for the fact that the order of updates is important? None of these questions is addressed by Pro-log's operational semantics, or by the classical theory of logic programming. 2.2 Dynamic Logic and Process Logic Dynamic Logic <ref> [Har79] </ref> and Process Logic [HKP82] allow a user to express properties of procedural programs and to reason about them. 3 Dynamic Logic reasons about the initial and the final states of program execution.
Reference: [HKP82] <author> D. Harel, D. Kozen, and R. Parikh. </author> <title> Process Logic: Expressiveness, decidabil-ity, completeness. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(2) </volume> <pages> 144-170, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: (X) retract (Y )? Also, how does one logically account for the fact that the order of updates is important? None of these questions is addressed by Pro-log's operational semantics, or by the classical theory of logic programming. 2.2 Dynamic Logic and Process Logic Dynamic Logic [Har79] and Process Logic <ref> [HKP82] </ref> allow a user to express properties of procedural programs and to reason about them. 3 Dynamic Logic reasons about the initial and the final states of program execution. <p> The version in <ref> [HKP82] </ref> is most interesting for the purpose of this survey. The bracketed part of the formula is a program|a naive procedure that is sup-posed to find the transitive closure of the connection relation. <p> Note that we are not claiming that flight (a; c) will be true at the end of the computation; so this property is not implied by the above formula in Dynamic Logic. To reason about what happens during a computation, Process Logic <ref> [HKP82] </ref> has a path-based semantics, where a path is a sequence of states, representing a program computation. Process Logic includes several non-classical connectives for making assertions about programs and computations.
Reference: [Kow79] <author> R. Kowalski. </author> <title> Logic for Problem Solving. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, The Netherlands, </address> <year> 1979. </year>
Reference-contexts: In general, specifying frame axioms in this way requires O (M N ) rules, where N is the number of actions, and M is the number of fluents. In <ref> [Kow79] </ref>, Kowalski presents a more succinct solution to the frame problem, which requires only O (M + N ) frame axioms. This solution relies on the Closed World Assumption (CWA). Other AI researchers continued searching for an equally simple solution, but one that does not require CWA. <p> Several variants of the event calculus have been developed [SK95]. They are all based on variants of the "Holds" formalism <ref> [Kow79] </ref>, and they all assume that actions take place instantaneously. The original event calculus [KS86] was the most complex, partly because its ontology is based on maximal time periods. In the rest of this section, we describe the so-called simplified event calculus [SK95], whose ontology is based on time points.
Reference: [Kow92] <author> R.A. Kowalski. </author> <title> Database updates in event calculus. </title> <journal> Journal of Logic Programming, </journal> 12(1&2):121-146, January 1992. 
Reference-contexts: All of the actions considered in this section were carefully designed to be write-only. For such actions, the truth of a proposition P depends only on the most recent event to affect P . In this case, events can be indexed for fast retrieval, resulting in fast inference <ref> [Kow92] </ref>. 3.5 Chen's Calculus Chen developed a calculus and an equivalent algebra for constructing database transactions [Che95]. Like T R, this calculus uses logical operators (including serial conjunction) to build complex transactions from elementary updates.
Reference: [KS86] <author> R.A. Kowalski and M. Sergot. </author> <title> A logic-based calculus of events. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 67-95, </pages> <year> 1986. </year>
Reference-contexts: Several variants of the event calculus have been developed [SK95]. They are all based on variants of the "Holds" formalism [Kow79], and they all assume that actions take place instantaneously. The original event calculus <ref> [KS86] </ref> was the most complex, partly because its ontology is based on maximal time periods. In the rest of this section, we describe the so-called simplified event calculus [SK95], whose ontology is based on time points. The Simplified Event Calculus.
Reference: [KS97] <author> R. Kowalski and F. Sadri. </author> <title> Reconciling the event calculus and the situation calculus. </title> <journal> Journal of Logic Programming, </journal> <volume> 31 </volume> <pages> 39-58, </pages> <year> 1997. </year>
Reference-contexts: It was originally developed by Kowalski and Sergot for reasoning about time and events in a logic-programming setting [KS86,Kow92] and for overcoming some of the problems of the situation calculus. A comparison of the event calculus and the situation calculus is developed in <ref> [KS97] </ref>. Unlike Transaction Logic and LDL, the event calculus is not a language for programming database transactions. In fact, like the situation calculus, the event calculus does not update the database at all. Instead, it is a query language for historical databases.
Reference: [LHL95] <author> B. Ludascher, U. Hamann, and G. Lausen. </author> <title> A logical framework for active rules. </title> <booktitle> In Proceedings of the 7th Intl. Conference on Management of Data, </booktitle> <address> Pune, India, </address> <month> December </month> <year> 1995. </year> <note> Tata McGrow-Hill. </note>
Reference-contexts: For instance, like the situation calculus, states are identified with function terms; and like the event calculus, action instances (and action requests) can be stored in the database as atomic formulas. To illustrate these ideas, we sketch the approach of <ref> [LHL95] </ref>, adapting it for the purpose of our presentation. States are identified by positive integers (represented as function terms). For instance, the atom on (b; c; 3) means that block b is on block c in state 3. The effects of actions are specified by Datalog-style rules. <p> These four actions will all be executed concurrently. The ability to trigger actions in this way forms the basis of a theory of active databases <ref> [LHL95] </ref>. Although actions like move can be defined in terms of simpler actions, the ability of Datalog with State to combine actions is limited in comparison with languages like Transaction Logic. For instance, Datalog with State has no notion of sequential composition, and no notion of subroutine. <p> One important difference is that Datalog with State relies on a small, fixed set of elementary updates, so only a small, fixed set of frame axioms is needed. Another difference is that Datalog with State uses a form of closed-world semantics (XY-stratification [Zan93] or state-stratification <ref> [LHL95] </ref>), which is closer to the database tradition. Consequently, unlike Reiter's theory, Datalog with State has no problem in representing database views, recursive or otherwise.
Reference: [LLL + 94] <author> Y. Lesperance, H. Levesque, F. Lin, D. Marcu, and R. Reiter. </author> <title> A logical approach to high-level robot programming-a progress report. In Control of the Physical World by Intelligent Systems, </title> <booktitle> Working Notes of the 1994 AAAI Fall Symposium. </booktitle> <publisher> AAAI Press, </publisher> <address> New Orleans, LA, </address> <month> November </month> <year> 1994. </year>
Reference: [Llo87] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming (Second Edition). </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference: [LML96] <author> B. Ludascher, W. May, and G. Lausen. </author> <title> Nested transactions in a logical language for active rules. </title> <editor> In D. Pedreschi and C. Zaniolo, editors, </editor> <booktitle> Intl. Workshop on Logic in Databases, volume 1154 of Lecture Notes in Computer Science, </booktitle> <pages> pages 196-222. </pages> <publisher> Springer-Verlag, </publisher> <address> San Miniato, Italy, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: For instance, Datalog with State has no notion of sequential composition, and no notion of subroutine. Because of this, the applications of Datalog with State to database programming are limited. Recognizing this problem, the authors have extended Datalog with State to include nested transactions and procedures <ref> [LML96] </ref>. The extended language includes a form of sequential composition modeled on the connective of serial conjunction in Transaction Logic. Finally, it is instructive to compare Datalog with State to Golog [LRL + 97] and to Reiter's theory of database evolution [Rei95], described in Section 4.4.
Reference: [LR94] <author> F. Lin and R. Reiter. </author> <title> How to progress a database (and why) I. Logical foundations. </title> <editor> In Jon Doyle, Erik Sandewall, and Pietro Torasso, editors, </editor> <booktitle> Proceedings of the International Conference on Knowledge Representation and Reasoning, </booktitle> <pages> pages 425-436, </pages> <year> 1994. </year>
Reference-contexts: In AI terminology, these complications arise because Reiter's theory is about open worlds, whereas databases are closed worlds. Unfortunately, updating open worlds is an intractable problem in general, since the result of an update may not have a finite representation in first-order logic <ref> [LR94] </ref>. Second, the theory does not protect deductive rules from database updates. In particular, updates can damage and destroy rules. For example, suppose that a deductive database consists of the single rule p (X) q (X), and suppose that the atom q (b) is inserted into this database.
Reference: [LRL + 97] <author> H.J. Levesque, R. Reiter, Y. Lesperance, F. Lin, and R. Scherl. Golog: </author> <title> A logic programming language for dynamic domains. </title> <journal> Journal of Logic Programming, </journal> <volume> 31 </volume> <pages> 59-84, </pages> <year> 1997. </year>
Reference-contexts: Recognizing this problem, the authors have extended Datalog with State to include nested transactions and procedures [LML96]. The extended language includes a form of sequential composition modeled on the connective of serial conjunction in Transaction Logic. Finally, it is instructive to compare Datalog with State to Golog <ref> [LRL + 97] </ref> and to Reiter's theory of database evolution [Rei95], described in Section 4.4. One important difference is that Datalog with State relies on a small, fixed set of elementary updates, so only a small, fixed set of frame axioms is needed. <p> Consequently, the theory does not provide a logical account of how to query or update such databases. 4.4 Golog Levesque et al. have recently developed Golog, a procedural language for programming complex actions, including database transactions <ref> [LRL + 97] </ref>. Syntactically, Golog is similar to the procedural database language QL developed by Chandra and Harel [CH80] extended with subroutines and non-deterministic choice. <p> Transitive closure can be defined in Golog, but not by deductive rules. Instead, the user must write an Algol-like procedure, as illustrated in <ref> [LRL + 97] </ref>. In this way, Golog sacrifices the declarativeness of deductive databases for the procedurality of Algol. For the same reason, Golog has difficulty in specifying database views, especially recursive views [Rei95]. These difficulties all arise because Golog abandons the logic-programming paradigm. <p> Golog has numerous other characteristics that should also be mentioned. For instance, Golog subroutines are not logical entities, but are macros specified outside the logic. Thus, one cannot refer to them in the logic, and in particular, one cannot quantify over them or reason about them <ref> [LRL + 97] </ref>. In addition, like many logics of action, updates in Golog are hypothetical, not real. This is because Golog uses the situation calculus to reason about what would be true if an action took place. The actual execution of actions requires a separate run-time system, outside of Golog.
Reference: [McC63] <author> J. McCarthy. </author> <title> Situations, actions, and clausal laws, </title> <type> memo 2. </type> <institution> Stanford Artificial Intelligence Project, </institution> <year> 1963. </year>
Reference-contexts: 1 Introduction Logic-based approaches to updates can be broadly classified into two categories: those designed for database or logic programming and those designed for reasoning about programs and actions. Prolog [CM81] is an early (and the best-known) example of the languages in the first category. The situation calculus <ref> [McC63] </ref>, Dynamic Logic [Har79], and Temporal Logic [Pnu77] are, in our view, the forefathers of the modern approaches to reasoning about actions. As we shall see, both the situation calculus and Dynamic Logic influenced the design of several logic-based languages for programming database transactions. <p> In addition, they do not support defined procedures, such as subroutines and views. 2.3 Situation Calculus The situation calculus is a methodology for specifying the effects of elementary actions in first-order classical logic. It was introduced by McCarthy <ref> [McC63] </ref> and then further developed by McCarthy and Hayes [MH69]. Recently, it has received renewed development by Reiter [Rei92a,Rei92b,Rei91]. Unlike the approaches discussed so far, the emphasis in the situation calculus is on specifying elementary actions, not on combining them into complex procedures.
Reference: [McC83] <author> L.T. McCarty. </author> <title> Permissions and obligations. </title> <booktitle> In Intl. Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 287-294, </pages> <address> San Francisco, CA, 1983. </address> <publisher> Morgan Kauf-mann. </publisher>
Reference-contexts: Thus, an occurrence of action a implies an occurrence of action b. In earlier work, McCarty outlined a logic of action as part of a larger proposal for reasoning about deontic concepts <ref> [McC83] </ref>. His proposal contains three distinct layers, each with its own logic: first-order predicate logic, a logic of action, and a logic of permission and obligation.
Reference: [Mes92a] <author> J. Meseguer. </author> <title> Conditional rewriting logic as a unified model of concurrency. </title> <journal> Theoretical Computer Science, </journal> <volume> 96(1) </volume> <pages> 73-155, </pages> <year> 1992. </year>
Reference: [Mes92b] <author> J. Meseguer. </author> <title> Multiparadigm logic programming. In Algebraic and Logic Specifications, </title> <booktitle> number 632 in Lecture Notes in Computer Science, </booktitle> <pages> pages 158-200. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1992. </year>
Reference: [MH69] <author> J.M. McCarthy and P.J. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> volume 4, </volume> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year> <note> Reprinted in Readings in Artificial Intelligence, </note> <year> 1981, </year> <title> Tioga Publ. </title> <publisher> Co. </publisher>
Reference-contexts: In addition, they do not support defined procedures, such as subroutines and views. 2.3 Situation Calculus The situation calculus is a methodology for specifying the effects of elementary actions in first-order classical logic. It was introduced by McCarthy [McC63] and then further developed by McCarthy and Hayes <ref> [MH69] </ref>. Recently, it has received renewed development by Reiter [Rei92a,Rei92b,Rei91]. Unlike the approaches discussed so far, the emphasis in the situation calculus is on specifying elementary actions, not on combining them into complex procedures.
Reference: [MvdM92] <author> L.T. McCarty and R. van der Meyden. </author> <title> Reasoning about indefinite actions. </title> <booktitle> In Proceedings of the International Conference on Knowledge Representation and Reasoning, </booktitle> <pages> pages 59-70, </pages> <address> Cambridge, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Using serial implication, one can express a wide variety of dynamic and temporal constraints in T R [BK95]. 4.2 McCarty and Van der Meyden In <ref> [MvdM92] </ref>, McCarty and Van der Meyden develop a theory for reasoning about "indefinite" actions. However, [MvdM92] does not address action execution or the updating of databases. To give an idea of what [MvdM92] is about, consider a set consisting of exactly the following two rules in Transaction Logic: 10 a c1 <p> Using serial implication, one can express a wide variety of dynamic and temporal constraints in T R [BK95]. 4.2 McCarty and Van der Meyden In <ref> [MvdM92] </ref>, McCarty and Van der Meyden develop a theory for reasoning about "indefinite" actions. However, [MvdM92] does not address action execution or the updating of databases. To give an idea of what [MvdM92] is about, consider a set consisting of exactly the following two rules in Transaction Logic: 10 a c1 c2 c3 b c2 c3 Here, a and b are complex actions defined in terms <p> wide variety of dynamic and temporal constraints in T R [BK95]. 4.2 McCarty and Van der Meyden In <ref> [MvdM92] </ref>, McCarty and Van der Meyden develop a theory for reasoning about "indefinite" actions. However, [MvdM92] does not address action execution or the updating of databases. To give an idea of what [MvdM92] is about, consider a set consisting of exactly the following two rules in Transaction Logic: 10 a c1 c2 c3 b c2 c3 Here, a and b are complex actions defined in terms of the elementary actions c1; c2; c3. <p> In T R, the effects of the elementary actions are specified by an oracle, which is invoked to execute them. In contrast, <ref> [MvdM92] </ref> has no mechanism for specifying the effects of elementary actions. <p> Also, unlike the original situation calculus, which was entirely first-order [McC63,MH69], Reiter's development includes an induction 10 Here we use the syntax of T R, which can be translated into the original syntax of <ref> [MvdM92] </ref>. axiom specified in second-order logic, for reasoning about sequences of transac-tions. Applying this approach, Reiter has developed a logical theory of database evolution [Rei95]. From the perspective of database theory [AHV95,Ull88], Reiter's approach is quite unusual.
Reference: [MW88] <author> S. Manchanda and D.S. Warren. </author> <title> A logic-based language for database updates. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: It also provides the logical foundation for a proof procedure that executes transactions, updates the database and evaluates queries, all as a result of proving theorems [BK98a,BK96,BK95,BK94]. 3.2 Dynamic Prolog Manchanda and Warren <ref> [MW88] </ref> developed Dynamic Prolog, a logic programming language for database transactions. Although the authors were greatly influenced by Dynamic Logic in the design of the semantics, their language is very different from Dynamic Logic. In fact, Dynamic Prolog has many similarities with Transaction Logic, both in syntax and in spirit. <p> In these approaches, actions are represented as propositions. One of these approaches is based on a dynamic interpretation of classical predicate logic. A dynamic interpretation associates a pair of states to each proposition, which resembles Dynamic Prolog of Manchanda and Warren <ref> [MW88] </ref>.
Reference: [NK88] <author> S. Naqvi and R. Krishnamurthy. </author> <title> Database updates in logic programming. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 251-262, </pages> <address> New York, </address> <month> March </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: In fact, this work is an adaptation of Dynamic Logic to database updates and the sample program (1) in Section 2.2 is inspired by [SWM93,Spr94]. 3.3 LDL Naqvi and Krishnamurthy have extended classical Datalog with update operators <ref> [NK88] </ref>, which were later incorporated in the LDL language [NT89]. The treatment of updates in LDL is similar to that of Dynamic Prolog and Transaction Logic. In particular, updates are performed in the body of rules, and complex update procedures can be defined from simpler ones.
Reference: [NT89] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year>
Reference-contexts: In fact, this work is an adaptation of Dynamic Logic to database updates and the sample program (1) in Section 2.2 is inspired by [SWM93,Spr94]. 3.3 LDL Naqvi and Krishnamurthy have extended classical Datalog with update operators [NK88], which were later incorporated in the LDL language <ref> [NT89] </ref>. The treatment of updates in LDL is similar to that of Dynamic Prolog and Transaction Logic. In particular, updates are performed in the body of rules, and complex update procedures can be defined from simpler ones. <p> Since this basic transactional feature is not implemented in LDL, the programmer must ensure that all updates in an LDL program are followed by unfailing predicates <ref> [NT89] </ref> (predicates that never fail). Primitive updates are examples of unfailing predicates. Other unfailing predicates can be constructed from the if-then-else and do-while constructs. Bulk Updates. Since LDL is geared towards database applications, it provides for bulk updates. <p> In fact, some of the restrictions mentioned above seem to preclude such an extension. For instance, the following example, paraphrased from <ref> [NT89] </ref>: q (a): ? p: inserts a single tuple r (a), and so its semantics is easy to define in propositional dynamic logic.
Reference: [PDR91] <author> G. Phipps, M.A. Derr, and K.A. Ross. </author> <title> Glue-Nail: A deductive database system. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 308-317, </pages> <address> New York, 1991. </address> <publisher> ACM. </publisher>
Reference: [Pnu77] <author> A. Pnueli. </author> <title> A temporal logic of programs. </title> <booktitle> In Intl. Conference on Foundations of Computer Science, </booktitle> <pages> pages 46-57, </pages> <month> October </month> <year> 1977. </year>
Reference-contexts: Prolog [CM81] is an early (and the best-known) example of the languages in the first category. The situation calculus [McC63], Dynamic Logic [Har79], and Temporal Logic <ref> [Pnu77] </ref> are, in our view, the forefathers of the modern approaches to reasoning about actions. As we shall see, both the situation calculus and Dynamic Logic influenced the design of several logic-based languages for programming database transactions.
Reference: [Pra79] <author> V.R. Pratt. </author> <title> Process logic. </title> <booktitle> In ACM Symposium on Principles of Program--ming Languages, </booktitle> <pages> pages 93-100, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: flight ae temp do flight := temp; temp := temp [ (temp 1 connection); od ] 8X; Y; Z flight (X; Y ) ^ flight (Y; Z) ! flight (X; Z) (1) 3 A number of different process logics have been proposed in the literature, beginning with Pratt's original work <ref> [Pra79] </ref>. The version in [HKP82] is most interesting for the purpose of this survey. The bracketed part of the formula is a program|a naive procedure that is sup-posed to find the transitive closure of the connection relation.
Reference: [Pra90] <author> V.R. Pratt. </author> <title> Action logic and pure induction. </title> <booktitle> In Workshop on Logics in AI, volume 478 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-120. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Under this semantics, John gets the raise precisely once, after which both of the above rules are disabled. 4 Logics for Reasoning about Programs 4.1 Action Logic and Related Proposals Pratt <ref> [Pra90] </ref> develops a logic, called Action Logic, that is superficially similar to Transaction Logic, but is different from it in essential ways. Like T R, Action Logic does not distinguish between actions and propositions: actions are simply propositions that hold on intervals. <p> Transaction Logic has two kinds of conjunction, classical (^) and serial (). Combined with negation, they lead to two kinds of disjunction, and two kinds of implication, in a natural way. In contrast, Action Logic has one type of conjunction (serial conjunction), as pointed out in <ref> [Pra90] </ref>. Action algebras have a lattice-like "meet" operator that might form the model-theoretic basis for another kind of conjunction, but the meet operation is not always defined. In [vB91], van Benthem outlines a number of logical approaches to dynamic information processing. In these approaches, actions are represented as propositions. <p> However, the states associated to propositions by dynamic interpretations of [vB91] are not database states but rather variable assignments. van Benthem also discusses an algebraic approach to the logic of dynamic systems, which is akin to the action logic of Pratt <ref> [Pra90] </ref>. 8 state is a proposition that is true precisely on paths of the form hsi, where s is a state. In other words, state is true precisely at states.
Reference: [Rei84] <author> R. Reiter. </author> <title> Towards a logical reconstruction of relational database theory. In M.L. </title> <editor> Brodie, J. Mylopoulos, and J. Schmidt, editors, </editor> <booktitle> On Conceptual Modeling: Perspectives from Artificial Intelligence, Databases and Programming Languages, </booktitle> <pages> pages 191-233. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference: [Rei91] <author> R. Reiter. </author> <title> The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression. </title> <editor> In V. Lifschitz, editor, </editor> <booktitle> Aritifial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarty, </booktitle> <pages> pages 359-380. </pages> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: This solution relies on the Closed World Assumption (CWA). Other AI researchers continued searching for an equally simple solution, but one that does not require CWA. Recently, Reiter has found just such a solution <ref> [Rei91] </ref>: it also requires only O (M + N ) axioms, but is based on the Open World Assumption (OWA). We shall describe Reiter's approach here. According to Reiter [Rei91], formalizing an action requires one axiom for each action (to describe its preconditions), and one axiom for each fluent (to describe <p> Recently, Reiter has found just such a solution <ref> [Rei91] </ref>: it also requires only O (M + N ) axioms, but is based on the Open World Assumption (OWA). We shall describe Reiter's approach here. According to Reiter [Rei91], formalizing an action requires one axiom for each action (to describe its preconditions), and one axiom for each fluent (to describe the effect of actions on the fluent). In these axioms, all free variables are universally quantified at the top level. In Example 3, three axioms would be required. <p> However, Reiter argues that the unique name axioms can be ignored, since their effects can be compiled into a theorem prover <ref> [Rei91] </ref>. That is, although the theory itself has size O (M + N 2 ), it is only necessary to write down a fragment of the theory of size O (M + N ) when doing reasoning. <p> This change is a direct result of Reiter's approach to the frame problem <ref> [Rei91] </ref>, briefly described earlier in this survey (Section 2.3). Indeed, since the atom p (b) was not true in the initial database, it must not be true in the final database; so the rule premise must be modified to ensure that X 6= b.
Reference: [Rei92a] <author> R. Reiter. </author> <title> Formalizing database evolution in the situation calculus. </title> <booktitle> In Conference on Fifth Generation Computer Systems, </booktitle> <year> 1992. </year>
Reference: [Rei92b] <author> R. Reiter. </author> <title> On formalizing database updates: Preliminary report. </title> <booktitle> In Proceedings of the Third Intl. Conference on Extending Database Technology, </booktitle> <pages> pages 10-20. </pages> <publisher> Springer-Verlag, </publisher> <month> March </month> <year> 1992. </year>
Reference: [Rei95] <author> R. Reiter. </author> <title> On specifying database updates. </title> <journal> Journal of Logic Programming, </journal> <volume> 25(1) </volume> <pages> 53-91, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: The extended language includes a form of sequential composition modeled on the connective of serial conjunction in Transaction Logic. Finally, it is instructive to compare Datalog with State to Golog [LRL + 97] and to Reiter's theory of database evolution <ref> [Rei95] </ref>, described in Section 4.4. One important difference is that Datalog with State relies on a small, fixed set of elementary updates, so only a small, fixed set of frame axioms is needed. <p> Applying this approach, Reiter has developed a logical theory of database evolution <ref> [Rei95] </ref>. From the perspective of database theory [AHV95,Ull88], Reiter's approach is quite unusual. For instance, a database state is usually modeled as set of relations or logical formulas; but in Reiter's theory, a state is identified with a sequence of actions. <p> Thus, the current database state is not materialized, but is virtual. In this framework, queries to the current state are answered by querying the log and reasoning backwards through it to the initial state <ref> [Rei95] </ref>. Unfortunately, this means that simple operations, like retrieving a single tuple from the database, can turn into long and complicated reasoning processes. Since database logs are typically large (perhaps millions of transaction records long), reasoning backwards through them is unacceptably expensive. <p> Instead, the axioms of the transaction system are modified to treat views as stored data. For instance, in the above example, whenever a transaction inserts (or deletes) the atom q (b) from the database, the modified axioms would insert (or delete) the atom p (b) as well <ref> [Rei95] </ref>. In this way, the system behaves as if the database contained the deductive rule p (X) q (X) (with a minimal model semantics). Unfortunately, in this approach, view definitions depend on transaction definitions. <p> Instead, the user must write an Algol-like procedure, as illustrated in [LRL + 97]. In this way, Golog sacrifices the declarativeness of deductive databases for the procedurality of Algol. For the same reason, Golog has difficulty in specifying database views, especially recursive views <ref> [Rei95] </ref>. These difficulties all arise because Golog abandons the logic-programming paradigm. Golog has numerous other characteristics that should also be mentioned. For instance, Golog subroutines are not logical entities, but are macros specified outside the logic.
Reference: [SK95] <author> F. Sadri and R. Kowalski. </author> <title> Variants of the event calculus. </title> <editor> In L. Sterling, editor, </editor> <booktitle> Intl. Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: For instance, they can infer that Block 1 is still on top of Block 3 on February 8, and that the tops of Blocks 2 and 3 are still clear on February 10. Several variants of the event calculus have been developed <ref> [SK95] </ref>. They are all based on variants of the "Holds" formalism [Kow79], and they all assume that actions take place instantaneously. The original event calculus [KS86] was the most complex, partly because its ontology is based on maximal time periods. <p> The original event calculus [KS86] was the most complex, partly because its ontology is based on maximal time periods. In the rest of this section, we describe the so-called simplified event calculus <ref> [SK95] </ref>, whose ontology is based on time points. The Simplified Event Calculus. This variant of the event calculus was designed for reasoning about complete event descriptions, i:e:, databases that contain a complete description of all relevant events.
Reference: [Spr94] <author> P.A. Spruit. </author> <title> Logics of Database Updates. </title> <type> PhD thesis, </type> <institution> Faculty of Mathematics and Computer Science, Vrije Universiteit, </institution> <address> Amsterdam, </address> <year> 1994. </year>
Reference: [SWM93] <author> P.A. Spruit, R.J. Wieringa, and J.-J.Ch. Meyer. </author> <title> Dynamic database logic: The first-order case. </title> <editor> In U.W. Lipeck and B. Thalheim, editors, </editor> <booktitle> Modeling Database Dynamics, </booktitle> <pages> pages 103-120. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [Ull88] <author> J.F. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> Volume 1. </volume> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1988. </year>
Reference: [vB91] <author> J. van Benthem. </author> <title> Language in Action: Categories, Lambdas and Dynamic Logic. </title> <publisher> Elsevier Science Pub. Co., </publisher> <address> Amsterdam, New York, </address> <year> 1991. </year>
Reference-contexts: In contrast, Action Logic has one type of conjunction (serial conjunction), as pointed out in [Pra90]. Action algebras have a lattice-like "meet" operator that might form the model-theoretic basis for another kind of conjunction, but the meet operation is not always defined. In <ref> [vB91] </ref>, van Benthem outlines a number of logical approaches to dynamic information processing. In these approaches, actions are represented as propositions. One of these approaches is based on a dynamic interpretation of classical predicate logic. <p> One of these approaches is based on a dynamic interpretation of classical predicate logic. A dynamic interpretation associates a pair of states to each proposition, which resembles Dynamic Prolog of Manchanda and Warren [MW88]. However, the states associated to propositions by dynamic interpretations of <ref> [vB91] </ref> are not database states but rather variable assignments. van Benthem also discusses an algebraic approach to the logic of dynamic systems, which is akin to the action logic of Pratt [Pra90]. 8 state is a proposition that is true precisely on paths of the form hsi, where s is a
Reference: [WF97] <author> C.A. Wichert and B. Freitag. </author> <title> Capturing database dynamics by deferred updates. </title> <booktitle> In Intl. Conference on Logic Programming, </booktitle> <pages> pages 226-240, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: However, Chen mentions in [Che95] that his calculus was intended as a language for specifying bulk and other non-trivial updates, which could then be used as elementary operations by a language like Transaction Logic. 3.6 Ultra Wichert and Freitag <ref> [WF97] </ref> describe an update language, which later received the name Ultra. Ultra attempts to integrate several of the concepts used in other update languages, including sequential composition, concurrent composition, and bulk updates. <p> Under a different semantics, the enabled rules fire all at once and then the corresponding changes are applied to the database, provided that different rules do not make conflicting changes, such as adding and deleting the same fact (this idea is also used in Ultra <ref> [WF97] </ref>, as discussed in Section 3.6).
Reference: [Zan93] <author> Carlo Zaniolo. </author> <title> A unified semantics for active and deductive databases. </title> <editor> In N.W. Paton and M.H. Williams, editors, </editor> <booktitle> Proceedings of the Workshop on Rules in Database Systems, Workshops in Computing. </booktitle> <publisher> Springer-Verlag, Edinburgh, </publisher> <address> U.K., </address> <year> 1993. </year>
Reference-contexts: One important difference is that Datalog with State relies on a small, fixed set of elementary updates, so only a small, fixed set of frame axioms is needed. Another difference is that Datalog with State uses a form of closed-world semantics (XY-stratification <ref> [Zan93] </ref> or state-stratification [LHL95]), which is closer to the database tradition. Consequently, unlike Reiter's theory, Datalog with State has no problem in representing database views, recursive or otherwise.
References-found: 61

