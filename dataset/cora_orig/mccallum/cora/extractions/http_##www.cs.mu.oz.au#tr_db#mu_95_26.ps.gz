URL: http://www.cs.mu.oz.au/tr_db/mu_95_26.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Deriving Logic Programming Languages  
Author: Michael Winikoff James Harland 
Address: Parkville, Victoria 3052 Australia  
Affiliation: Department of Computer Science The University of Melbourne  
Pubnum: Technical Report 95/26  
Abstract: Given a logic we would like to derive from it a programming language. In order to do this we need to have a formal litmus test which identifies logic programming languages. The standard test is uniformity introduced by Miller, Nadathur, Pfenning and Scedrov. Uniformity suffers from a number of shortcomings, one of the major ones being that it works best in logics which allow only a single conclusion. This report looks at a variety of intuitions which distinguish logic programming from theorem proving. Some of these intuitions are formalised and applied to a variety of languages which have been proposed in the literature. We then introduce a mechanism by which the proof search can be guided by atomic goals. This enables us to propery generalise uniformity to multiple conclusioned logics. We propose an extended version of single conclusion uniformity and two versions of multiple conclusion uniformity all of which remedy the problems which plague uniformity. 
Abstract-found: 1
Intro-found: 1
Reference: [AB94] <author> Krzystof R. Apt and Roland N. Bol. </author> <title> Logic programming and negation: A survey. </title> <journal> The Journal of Logic Programming, </journal> <volume> 19,20:9-71, </volume> <year> 1994. </year>
Reference-contexts: A potential characteriser of logic programming languages that we have not addressed in this report is negation as failure. Negation as failure was introduced into logic programming for purely pragmatic reasons. Although the semantics of the construct is still an active area of research and debate (see <ref> [AB94] </ref> for a recent survey of the area) negation as failure has featured in the vast majority of logic programming languages. Could it somehow be an essential feature of logic programming? The Big Picture When working with a logic programming language there are three logics involved: 1.
Reference: [Ale94] <author> Vladimir Alexiev. </author> <title> Applications of linear logic to computation: An overview. </title> <journal> Bulletin of the IGPL, </journal> <volume> 2(1) </volume> <pages> 77-107, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: A good tutorial introduction to linear logic and its applications to computer science is [Sce90] and the longer version <ref> [Ale94] </ref>. 2.4 Permutabilities 7 2.4 Permutabilities Permutabilities [Kle52b] play an important role in the proof theoretical analysis of logic programming languages.
Reference: [And92] <author> Jean-Marc Andreoli. </author> <title> Logic programming with focusing proofs in linear logic. </title> <journal> Journal of Logic and Computation, </journal> <volume> 2(3), </volume> <year> 1992. </year>
Reference-contexts: We would however like to have a general characteriser which can be applied to a wide variety of logics. Logic programming languages have been derived from a variety of logics including relevant logic [Bol91], temporal and modal logics [OM94] and linear logic <ref> [HM94, And92, KY93, AP91, Mil94, Vol94, Win95] </ref>. The original work to attack the problem of characterising logic programming languages is [MNPS91]. Miller et al. take goal directedness as a suitable intuitive characteriser of logic programming languages and formalise it using the notion of uniform proofs. <p> Driven by a desire to create programming languages based on (multiple conclusioned) linear logic there have been a number of attempts to generalise the notion of uniform proofs to the multiple conclusioned case <ref> [And92, Mil94, AP91, Vol94, PH94, KY93] </ref>. These have not been entirely convincing, primarily since the full linear logic can be made to satisfy these criteria through a simple translation. Thus, the existing generalisations of uniformity 2 2 BACKGROUND to multiple conclusioned settings seem to be too coarse. <p> Note that, as an extreme case, the application of standard linear logical equivalences enables one to encode the entirety of linear logic into a subset that can be shown to be uniform <ref> [And92, 3.1 Abusing Logical Equivalence 11 Mil94] </ref>. Since full linear logic is patently not uniform (for example, consider the proof of a b ` a b) this should seem at least mildly suspicious. To see that full linear logic is not uniform consider the sequent a b ` a b. <p> Then there is a proof of ` where all left rules are part of a sequence which decomposes a single clause. Proof: Observe that all of the connectives occurring in Lolli programs are synchronous (on the left) hence according to the focusing property <ref> [And92] </ref> once we have applied a left rule to a program formula we can continue to decompose that formula without a loss of completeness. We show the second step by defining a notion of an atom matching a clause. <p> Proof: Observe that the connectives 8 , ! , ( and O are synchronous when they occur on the left. Thus by an application of the focusing property <ref> [And92] </ref> we can apply the left rules decomposing a program clause as an indivisible group of inferences without any loss of completeness. We shall refer to this sequence of inferences as a left focused proof step or proof step.
Reference: [AP91] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> Linear objects: Logical processes with built-in inheritance. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 445-473, </pages> <year> 1991. </year>
Reference-contexts: We would however like to have a general characteriser which can be applied to a wide variety of logics. Logic programming languages have been derived from a variety of logics including relevant logic [Bol91], temporal and modal logics [OM94] and linear logic <ref> [HM94, And92, KY93, AP91, Mil94, Vol94, Win95] </ref>. The original work to attack the problem of characterising logic programming languages is [MNPS91]. Miller et al. take goal directedness as a suitable intuitive characteriser of logic programming languages and formalise it using the notion of uniform proofs. <p> Driven by a desire to create programming languages based on (multiple conclusioned) linear logic there have been a number of attempts to generalise the notion of uniform proofs to the multiple conclusioned case <ref> [And92, Mil94, AP91, Vol94, PH94, KY93] </ref>. These have not been entirely convincing, primarily since the full linear logic can be made to satisfy these criteria through a simple translation. Thus, the existing generalisations of uniformity 2 2 BACKGROUND to multiple conclusioned settings seem to be too coarse. <p> Since there are no atoms we know that the sequent cannot be the result of left rules or the axiom rule and thus it must be the result of a right rule. Corollary: ACL satisfies criteria A and C. 6.5.2 LO LO (Linear Objects) <ref> [AP91] </ref> is one of the earlier languages based on linear logic. It is motivated by a desire to add concurrency and object-oriented features to logic programming.
Reference: [Bol91] <author> A. W. Bollen. </author> <title> Relevant logic programming. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 7 </volume> <pages> 563-585, </pages> <year> 1991. </year>
Reference-contexts: We would however like to have a general characteriser which can be applied to a wide variety of logics. Logic programming languages have been derived from a variety of logics including relevant logic <ref> [Bol91] </ref>, temporal and modal logics [OM94] and linear logic [HM94, And92, KY93, AP91, Mil94, Vol94, Win95]. The original work to attack the problem of characterising logic programming languages is [MNPS91].
Reference: [Gen69] <author> G. </author> <title> Gentzen. Investigations into logical deductions, 1935. In M.E. </title> <editor> Szabo, editor, </editor> <booktitle> The Collected Papers of Gerhard Gentzen, </booktitle> <pages> pages 68-131. </pages> <publisher> North-Holland Publishing Co., </publisher> <address> Amsterdam, </address> <year> 1969. </year>
Reference-contexts: It may be skipped by the reader familiar with the notions discussed. 2.1 Sequent Calculus The sequent calculus is a formalism for representing inferences and proofs due to Gentzen <ref> [Gen69] </ref>. It is the standard notation used in the proof theoretical analysis of logic programming since it distinguishes naturally between programs and goals. Additionally the sequent calculus rules construct a proof locally (as opposed to natural deduction) and allow short direct proofs (as opposed to Hilbert-type systems). <p> The cut elimination theorem is also known as the Hauptsatz (main theorem) <ref> [Gen69] </ref>. The cut elimination property has been shown to hold for all of the logics we shall be considering. That cut elimination holds is essential for bottom up proof search to be practical. From cut elimination we can derive a number of useful properties.
Reference: [Gir87] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: This makes it attractive as a single uniform 4 framework within which to work. Finally, linear logic has a richer set of impermutabilities (see section 2.4) which makes it a better source of examples to distinguish between various characterisers. Linear logic was introduced in <ref> [Gir87] </ref>. Whereas classical logic can be said to be based on the intuitive notion of truth, linear logic is intuitively based on the notion of resources. A theorem in linear logic is a resource. Resources can be neither duplicated nor discarded.
Reference: [Gir95] <author> Jean-Yves Girard. </author> <title> Linear logic : its syntax and semantics. </title> <editor> In Jean-Yves Girard, Yves Lafont, and Laurent Regnier, editors, </editor> <booktitle> Advances in Linear Logic, chapter 0. </booktitle> <publisher> Cam-bridge University Press, </publisher> <year> 1995. </year>
Reference-contexts: In our presentation we strive to be general. We shall mostly assume only that the logic in question has a cut-elimination theorem 8 . 8 A logic without cut-elimination is like a car without engine (sic) <ref> [Gir95] </ref> 5.1 Criteria 15 A criterion is a formalisation of the (informal) notion of a characteriser. A criterion is (usually) a limitation on the structure of proofs. A subset of the logic is deemed a programming language by a given criterion if the application of the criterion preserves completeness.
Reference: [GLT89] <author> Jean-Yves Girard, Yves G. A. Lafont, and Paul Taylor. </author> <title> Proofs and Types, </title> <booktitle> volume 7 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: An Alternative Embedding of Logic Programming in the Sequent Calculus There are other ways of embedding logic programming into the sequent calculus (see <ref> [GLT89] </ref>). One alternative is to add for each clause A B 1 ^ : : : ^ B n an axiom schema of the form: B 1 ; : : : ; B n ` A We then derive proofs using cut to simulate the resolution operation.
Reference: [Har94a] <author> James Harland. </author> <title> On goal-directed provability in classical logic. </title> <booktitle> In Proceedings of the Workshop on Proof-Theoretical Extensions of Logic Programming, </booktitle> <pages> pages 10-18, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: As far as we are aware there is not much existing work which applies the idea of uniformity to determine (in a proof theoretical manner) a classical logic based logic programming language. In <ref> [Har94a] </ref> the criteria D all and D some (introduced in the next section) are used to derive logic programming languages based on classical logic. The conclusions drawn in the paper are that: 1. D some does not produce any non-trivial languages that do not also satisfy D all . 2. <p> Lemma 6.48 (Lemma 3 of <ref> [Har94a] </ref>) Let and be respectively a program and goal in SLK. Then ` is provable iff ` F is provable for some F 2 . What is happening is that the omission of ! R and : R prevents the multiple goals from interacting. Thus our results echo those of [Har94a] <p> <ref> [Har94a] </ref>) Let and be respectively a program and goal in SLK. Then ` is provable iff ` F is provable for some F 2 . What is happening is that the omission of ! R and : R prevents the multiple goals from interacting. Thus our results echo those of [Har94a] there do not seem to be any interesting languages based on classical logic which satisfy D S but not D A . <p> In the absence of a notion of atom guided proof search the choice that has been presented in papers seeking to extend uniformity to a multiple conclusion setting <ref> [Mil95, Vol94, Har94a] </ref> is between D all : For a sequent of the form ` C; A or ` C there exist proofs where the first step introduces the topmost connective of F for all F 2 C.
Reference: [Har94b] <author> James Harland. </author> <title> A proof-theoretic analysis of goal-directed provability. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(1) </volume> <pages> 69-88, </pages> <year> 1994. </year>
Reference-contexts: The characterisation of logic fragments suitable for logic programming has seen a significant amount of work and some conclusions in the context of intuitionistic logic. For example, it is known that, in some sense, hereditary Harrop formulae are maximal for intuitionistic logic <ref> [Har94b] </ref>. We would however like to have a general characteriser which can be applied to a wide variety of logics. Logic programming languages have been derived from a variety of logics including relevant logic [Bol91], temporal and modal logics [OM94] and linear logic [HM94, And92, KY93, AP91, Mil94, Vol94, Win95]. <p> An interesting case study that ought to be investigated is the derivation of a programming language from a multiple conclusion presentation of intuitionistic logic. Since intuitionistic logic has seen a fair amount of work and some definite conclusions <ref> [Har94b] </ref> this is also a good test for proposed multiple conclusion criteria such as D A and D S . If the presentation of a logic does affect the derived programming language then there is scope for further work into the derivation of logic programming languages.
Reference: [HM91] <author> Joshua S. Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic (extended abstract). </title> <booktitle> In Logic in Computer Science, </booktitle> <pages> pages 32-42. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: Proposition 5.35 Prolog satisfies criterion F Proof: Prolog satisfies criteria D strong and E. According to proposition 5.29 it satisfies criterion F . 5.3.2 Lolli Lolli was introduced in <ref> [HM91] </ref>. For our purposes it can be viewed essentially as a single con clusion version of Lygon 9 .
Reference: [HM94] <author> Joshua S. Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic logic. </title> <journal> Journal of Information and Computation, </journal> <volume> 10(2) </volume> <pages> 327-365, </pages> <year> 1994. </year>
Reference-contexts: We would however like to have a general characteriser which can be applied to a wide variety of logics. Logic programming languages have been derived from a variety of logics including relevant logic [Bol91], temporal and modal logics [OM94] and linear logic <ref> [HM94, And92, KY93, AP91, Mil94, Vol94, Win95] </ref>. The original work to attack the problem of characterising logic programming languages is [MNPS91]. Miller et al. take goal directedness as a suitable intuitive characteriser of logic programming languages and formalise it using the notion of uniform proofs. <p> An obvious example is the use of logical variables and unification to delay the choice of a term in the 9 R and 8 L rules. Another example is the handling of the R rule in linear logic based programming languages <ref> [HM94, WH94, WH95b] </ref>. An additional problem with the use of efficiency as a characteriser is that the vast majority of logic programming languages and systems omit the occur check. This yields efficiency but costs soundness. <p> The original paper's wording requires that a non-atomic goal be the conclusion of the right rule which introduces its topmost connective. Other papers (for example <ref> [HM94] </ref>) do not specify which right rule. Note that for a single conclusion setting with no structural rules these two definitions coincide. Our definition of D weak allows for any right rule to be used and D strong requires that the right rule introduce the goal's topmost connective.
Reference: [Hod94] <author> Joshua Hodas. </author> <title> Logic Programming in Intuitionistic Linear Logic: Theory, Design and Implementation. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <year> 1994. </year> <note> 64 REFERENCES </note>
Reference-contexts: Induction: If the conclusion of a left rule has an empty goal then so does at least one premise of the rule. Hence no sequent with an empty goal can be proven. Proposition 5.38 Lolli satisfies criterion D strong Proof: See <ref> [Hod94] </ref>. The proof basically involves the use of permutability properties to transform a given proof into one satisfying D strong Corollary: Lolli satisfies criteria D weak and C. We now look at showing that Lolli satisfies criterion E.
Reference: [HP96] <author> Joshua S. Hodas and Jeffrey Polakow. </author> <title> Forum as a logic programming language: Preliminary results and observations. </title> <booktitle> In Linear Logic 1996, </booktitle> <year> 1996. </year>
Reference-contexts: The problem is that any goal (for example 9xp (x) above) is really considered to be the goal 9xp (x); ?. Allowing such clauses which can be resolved against anytime is a matter of taste. As we have seen (and as has been observed with respect to Forum <ref> [HP96] </ref>) allowing clauses that can be resolved against at any time (thus violating the notion of atom guided proof search) causes problems. 6.5 Examples 51 We shall therefore consider a variant of Lygon - Lygon ? which differs from Lygon in that it removes the production D ::= ?jG ? .
Reference: [HPW96] <author> James Harland, David Pym, and Michael Winikoff. </author> <title> Bottom-up execution of linear logic programming languages. </title> <type> Manuscript, </type> <year> 1996. </year>
Reference-contexts: Our whole approach is based on a top down execution model of logic programs. Recently there has been work applying proof theoretic concepts to bottom up logic programming <ref> [HPW96] </ref>. The relationship between the proof theoretic characterisation of bottom up and top down logic programming languages is unknown at present. A potential characteriser of logic programming languages that we have not addressed in this report is negation as failure.
Reference: [Kle52a] <author> S. Kleene. </author> <title> Introduction to Metamathematics. </title> <publisher> North Holland, </publisher> <year> 1952. </year>
Reference-contexts: to what logic programmers normally call top-down, ie. the standard Prolog mechanism. 2.2 Intuitionistic Logic 5 ` A ! B then we can derive ` B: ` A A ` A B ` B ! L Cut Cut For more details on the sequent calculus we refer the reader to <ref> [Kle52a] </ref>. 2.2 Intuitionistic Logic Intuitionistic logic was developed early this century. It shares its syntax with classical logic but differs semantically in that it rejects the law of the excluded middle which states that ` A _ :A is true, ie. that predicates must be either true or false. <p> For our purposes it is sufficient to know that it can be specified by taking the standard sequent calculus for classical logic and limiting it to single conclusions. For more details we refer the reader to <ref> [Kle52a] </ref>. 2.3 Linear Logic We will draw many of our examples from linear logic for a number of reasons. Firstly, it is the logic of most interest to the authors. Additionally, linear logic generalises classical and intuition-istic logic. It also possesses both single and multiple conclusion versions.
Reference: [Kle52b] <author> S.C. Kleene. </author> <title> Permutability of inferences in Gentzen's calculi LK and LJ. </title> <journal> Memoirs of the American Mathematical Society, </journal> <volume> 10 </volume> <pages> 1-26, </pages> <year> 1952. </year>
Reference-contexts: A good tutorial introduction to linear logic and its applications to computer science is [Sce90] and the longer version [Ale94]. 2.4 Permutabilities 7 2.4 Permutabilities Permutabilities <ref> [Kle52b] </ref> play an important role in the proof theoretical analysis of logic programming languages. We say that (eg.) -R permutes down over N-L if whenever a proof contains an occurrence of -R immediately above an occurrence of N-L we can swap the order and retain a valid proof.
Reference: [KY93] <author> Naoki Kobayashi and Akinori Yonezawa. </author> <title> ACL a concurrent linear logic programming paradigm. </title> <booktitle> In International Logic Programming Symposium, </booktitle> <pages> pages 279-294, </pages> <year> 1993. </year>
Reference-contexts: We would however like to have a general characteriser which can be applied to a wide variety of logics. Logic programming languages have been derived from a variety of logics including relevant logic [Bol91], temporal and modal logics [OM94] and linear logic <ref> [HM94, And92, KY93, AP91, Mil94, Vol94, Win95] </ref>. The original work to attack the problem of characterising logic programming languages is [MNPS91]. Miller et al. take goal directedness as a suitable intuitive characteriser of logic programming languages and formalise it using the notion of uniform proofs. <p> Driven by a desire to create programming languages based on (multiple conclusioned) linear logic there have been a number of attempts to generalise the notion of uniform proofs to the multiple conclusioned case <ref> [And92, Mil94, AP91, Vol94, PH94, KY93] </ref>. These have not been entirely convincing, primarily since the full linear logic can be made to satisfy these criteria through a simple translation. Thus, the existing generalisations of uniformity 2 2 BACKGROUND to multiple conclusioned settings seem to be too coarse. <p> Thus it is complete to delay applying a left focused proof step until all of the required atoms are present. Furthermore, the proof step produces a left focused proof as desired. 6.5.1 ACL ACL (Asynchronous Communication based on Linear logic) <ref> [KY93] </ref> has the flavour of a concurrent extension to an ML-like functional language. The concurrent extensions are based on linear logic.
Reference: [Lin92] <author> Patrick D. Lincoln. </author> <title> Computational Aspects of Linear Logic. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> August </month> <year> 1992. </year>
Reference: [Mil89] <author> Dale Miller. </author> <title> A logical analysis of modules in logic programming. </title> <journal> Journal of Logic Programming, </journal> <pages> pages 79-108, </pages> <year> 1989. </year>
Reference-contexts: Furthermore it fails criteria A and B. There are a number of approaches to limiting the proof search process for sequents with atomic goals: 1. Simplicity 2. Static Clausal Form 3. Dynamic Clausal Form The first, the notion of simplicity, was introduced in <ref> [Mil89] </ref>. Simplicity restricts occurrences of the ! L rule to have axiomatic right hand premises. <p> It corresponds to criterion D strong . Fully Uniform Uniformity with the addition of left focusing. Applies to single conclusion sys tems and corresponds to criterion F . Simple This is one method of insisting that atoms guide the proof search process. It is used in <ref> [Mil89] </ref> and simply requires that the right premise of the ( L rule be the conclusion of an axiom rule. Left Focussed This is another method, introduced in this report [WH95a], of allowing atoms to guide the proof search process.
Reference: [Mil94] <author> Dale Miller. </author> <title> A multiple-conclusion meta-logic. </title> <booktitle> In Logic in Computer Science, </booktitle> <pages> pages 272-281, </pages> <year> 1994. </year>
Reference-contexts: We would however like to have a general characteriser which can be applied to a wide variety of logics. Logic programming languages have been derived from a variety of logics including relevant logic [Bol91], temporal and modal logics [OM94] and linear logic <ref> [HM94, And92, KY93, AP91, Mil94, Vol94, Win95] </ref>. The original work to attack the problem of characterising logic programming languages is [MNPS91]. Miller et al. take goal directedness as a suitable intuitive characteriser of logic programming languages and formalise it using the notion of uniform proofs. <p> Driven by a desire to create programming languages based on (multiple conclusioned) linear logic there have been a number of attempts to generalise the notion of uniform proofs to the multiple conclusioned case <ref> [And92, Mil94, AP91, Vol94, PH94, KY93] </ref>. These have not been entirely convincing, primarily since the full linear logic can be made to satisfy these criteria through a simple translation. Thus, the existing generalisations of uniformity 2 2 BACKGROUND to multiple conclusioned settings seem to be too coarse. <p> Moreover there is no uniform proof. Attempts to use this logical equivalence in a programming language can cause problems. An example of a language that falls into this loophole is Forum <ref> [Mil94] </ref>. It makes extensive use of logical equivalence to encode the whole of linear logic into a fragment of the logic which can be argued to be uniform. For example, in Forum there is no 9 connective. <p> Note that the need to use atomic goals to guide the proof is not as vital here as it is for the previous case. We term this characteriser asynchronous uniformity. This is the notion that is used in (for example) the design of Forum <ref> [Mil94] </ref>. 6.3 Asynchronous Uniformity Given that we can apply right rules whenever there is a compound goal formulae it is easy to show that we cannot have impermutabilities on the right. <p> Furthermore according to theorem 6.20 LO proofs satisfy the left focusing condition. Corollary: LO satisfies D S , C , A and C strong . Proposition 6.26 LO satisfies B Proof: Simple induction as for ACL. 46 6 THE MULTIPLE CONCLUSIONED CASE 6.5.3 Forum Forum was introduced in <ref> [Mil94] </ref>. It is intended more as a specification language than as a programming language. It is interesting in that it consists entirely of asynchronous connectives (in goals) and the same class of formulae in programs.
Reference: [Mil95] <author> Dale Miller. Forum: </author> <title> A multiple-conclusion specification logic (draft). </title> <note> Submitted to Theory of Computer Science. Also at ftp://ftp.cis.upenn.edu/pub/papers/miller/tcs95draft.dvi.Z, </note> <year> 1995. </year>
Reference-contexts: It is interesting in that it consists entirely of asynchronous connectives (in goals) and the same class of formulae in programs. D ::= G We begin by considering Forum as the class of formulae above extended using logical equivalences to cover all of linear logic <ref> [Mil95] </ref>. Proposition 6.27 Forum fails to satisfy criterion B Proof: The proof of the sequent ? ` violates criterion B. Proposition 6.28 Forum satisfies criteria A Proof: Linear logic does not have generally applicable right structural rules. <p> In the absence of a notion of atom guided proof search the choice that has been presented in papers seeking to extend uniformity to a multiple conclusion setting <ref> [Mil95, Vol94, Har94a] </ref> is between D all : For a sequent of the form ` C; A or ` C there exist proofs where the first step introduces the topmost connective of F for all F 2 C.
Reference: [MNPS91] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: Logic programming languages have been derived from a variety of logics including relevant logic [Bol91], temporal and modal logics [OM94] and linear logic [HM94, And92, KY93, AP91, Mil94, Vol94, Win95]. The original work to attack the problem of characterising logic programming languages is <ref> [MNPS91] </ref>. Miller et al. take goal directedness as a suitable intuitive characteriser of logic programming languages and formalise it using the notion of uniform proofs. Unfortunately the notion of uniform proofs as defined in [MNPS91] is only applicable to single conclusioned logics (such as intuitionistic logic). <p> The original work to attack the problem of characterising logic programming languages is <ref> [MNPS91] </ref>. Miller et al. take goal directedness as a suitable intuitive characteriser of logic programming languages and formalise it using the notion of uniform proofs. Unfortunately the notion of uniform proofs as defined in [MNPS91] is only applicable to single conclusioned logics (such as intuitionistic logic). <p> A connective is asynchronous if the corresponding right rule is reversible and is relatively asynchronous if the corresponding right rule is relatively reversible. The permutability properties of the various logics are summarised in appendix E. 2.5 Uniform Proofs The main existing characteriser of logic programming is uniformity <ref> [MNPS91] </ref>. Uniformity is simply a formalisation of the intuitive notion of goal-directedness which we now examine. The sequent ` is seen as comprising a program and a goal . <p> A proof is goal directed if its shape that is the choice of rule to be applied at each step in the derivation of a proof is determined by the goal and not by the program. Goal directedness is formalised using the definition (based on the definition in <ref> [MNPS91] </ref>): Uniformity: A proof is uniform if each occurrence of a sequent whose succedent contains a non-atomic formula is the conclusion of the infer ence rule which introduces its [the non-atomic formula's] top-level connec tive. <p> by transitivity we have that C 6 B Proposition 5.6 A 6 C , B 6 C Proof: The (only) proof of 9xp (x) ` 9xp (x) satisfies both criteria A and B yet violates criterion C. 18 5 THE SINGLE CONCLUSIONED CASE The next criterion is uniformity, introduced in <ref> [MNPS91] </ref>. Uniformity restricts sequents with non-atomic goals to be the conclusions of right rules. There is some scope for variation though, as we have a choice as to which right rule. i.e.,even for a single conclusioned system there is still a choice between a structural and a logical right rule. <p> An important goal is to suggest a common terminology. As mentioned earlier the seminal work in this area is <ref> [MNPS91] </ref> where the original definition of uniformity is presented. Since uniformity works reasonably well in a single conclusion setting there has been little research on extending it until the need arose for a multiple conclusion generalisation. <p> Goal Directed This is an intuitive, informal notion that requires that the proof search process be guided by the goal. Uniform This is the original definition in <ref> [MNPS91] </ref> which applies to single conclusion sys tems. It corresponds to criterion D strong . Fully Uniform Uniformity with the addition of left focusing. Applies to single conclusion sys tems and corresponds to criterion F . Simple This is one method of insisting that atoms guide the proof search process. <p> The introduction of left focused proof steps was crucial in allowing us to define a working version of synchronous uniformity. Although uniformity (in the sense of <ref> [MNPS91] </ref>) works reasonably well in the single conclusion setting we propose that full uniformity is the better criterion in this setting. In the multiple conclusion case we propose that there are two distinct classes of languages - synchronous and asynchronous. These are characterised respectively by synchronous and asynchronous uniformity.
Reference: [Nad96] <author> Gopalan Nadathur. </author> <title> Uniform provability in classical logic. </title> <type> Technical Report TR-96-09, </type> <institution> University of Chicago, </institution> <year> 1996. </year>
Reference-contexts: In [NL95] Nadathur and Loveland examine the application of uniformity to disjunctive logic programming (Nadathur expands on the paper in <ref> [Nad96] </ref>).
Reference: [NL95] <author> Gopalan Nadathur and Donald W. Loveland. </author> <title> Uniform proofs and disjunctive logic programming (extended abstract). </title> <booktitle> In Tenth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 148-155, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: A consequence of observation (3) is that A and B both fail to satisfy the left focusing condition and hence the languages fail to satisfy D A and D S . In <ref> [NL95] </ref> Nadathur and Loveland examine the application of uniformity to disjunctive logic programming (Nadathur expands on the paper in [Nad96]).
Reference: [OM94] <author> Mehmet A. Orgun and Wanli Ma. </author> <title> An overview of temporal and modal logic programming. </title> <editor> In D. M. Gabbay and H. J. Ohlbach, editors, </editor> <booktitle> First International Conference on Temporal Logic, </booktitle> <pages> pages 445-479. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1994. </year>
Reference-contexts: We would however like to have a general characteriser which can be applied to a wide variety of logics. Logic programming languages have been derived from a variety of logics including relevant logic [Bol91], temporal and modal logics <ref> [OM94] </ref> and linear logic [HM94, And92, KY93, AP91, Mil94, Vol94, Win95]. The original work to attack the problem of characterising logic programming languages is [MNPS91]. Miller et al. take goal directedness as a suitable intuitive characteriser of logic programming languages and formalise it using the notion of uniform proofs.
Reference: [PH94] <author> David Pym and James Harland. </author> <title> A uniform proof-theoretic investigation of linear logic programming. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(2) </volume> <pages> 175-207, </pages> <month> April </month> <year> 1994. </year> <note> REFERENCES 65 </note>
Reference-contexts: Driven by a desire to create programming languages based on (multiple conclusioned) linear logic there have been a number of attempts to generalise the notion of uniform proofs to the multiple conclusioned case <ref> [And92, Mil94, AP91, Vol94, PH94, KY93] </ref>. These have not been entirely convincing, primarily since the full linear logic can be made to satisfy these criteria through a simple translation. Thus, the existing generalisations of uniformity 2 2 BACKGROUND to multiple conclusioned settings seem to be too coarse. <p> We shall consider dynamic clausal form since it generalises both simplicity and static clausal form. A problem with dynamic clausal form is that formulating an equivalent logical system which combines the left rules into a single rule can involve considerable ingenuity (see for example <ref> [PH94] </ref>) and as a result it is generally hard to show that it is not possible to combine the left rules into a single rule. <p> Note that it is essential that we have a notion of atomic goals directing the proof search process. We term this characteriser synchronous uniformity. This notion is similar to the notion of locally LR proof search which was used in the design of Lygon <ref> [PH94] </ref>. (2) By choosing to be guided by compound goals even if there are atomic goals we obtain sufficient guidance. The only place where the proof search process has no restrictions is in the proof of sequents of the form ` A. <p> However, if as programmers we are prepared to think in terms of a slightly different set of rules where, for example, R can apply simple preprocessing to the left hand side of the sequent then Lygon regains its uniformity. We refer the reader to <ref> [PH94] </ref> for the details of the derivation and for the logical rules involved. As figure 7 indicates the languages proposed fall into three groups: 1. Those which satisfy criterion D A : LO, Forum and LC. 2. <p> Left Focussed This is another method, introduced in this report [WH95a], of allowing atoms to guide the proof search process. Locally LR This is the criterion used in <ref> [PH94] </ref> for defining Lygon. Although the paper defines uniform as simple locally LR we feel that this overloading is undesirable since the two concepts are distinct.
Reference: [Sce90] <author> Andre Scedrov. </author> <title> A brief guide to linear logic. </title> <journal> Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> 41 </volume> <pages> 154-165, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: A good tutorial introduction to linear logic and its applications to computer science is <ref> [Sce90] </ref> and the longer version [Ale94]. 2.4 Permutabilities 7 2.4 Permutabilities Permutabilities [Kle52b] play an important role in the proof theoretical analysis of logic programming languages.
Reference: [Vol94] <author> Paolo Volpe. </author> <title> Concurrent logic programming as uniform linear proofs. </title> <editor> In Gior-gio Levi and Mario Rodr guez-Artalejo, editors, </editor> <booktitle> Algebraic and Logic Programming, </booktitle> <pages> pages 133-149. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: We would however like to have a general characteriser which can be applied to a wide variety of logics. Logic programming languages have been derived from a variety of logics including relevant logic [Bol91], temporal and modal logics [OM94] and linear logic <ref> [HM94, And92, KY93, AP91, Mil94, Vol94, Win95] </ref>. The original work to attack the problem of characterising logic programming languages is [MNPS91]. Miller et al. take goal directedness as a suitable intuitive characteriser of logic programming languages and formalise it using the notion of uniform proofs. <p> Driven by a desire to create programming languages based on (multiple conclusioned) linear logic there have been a number of attempts to generalise the notion of uniform proofs to the multiple conclusioned case <ref> [And92, Mil94, AP91, Vol94, PH94, KY93] </ref>. These have not been entirely convincing, primarily since the full linear logic can be made to satisfy these criteria through a simple translation. Thus, the existing generalisations of uniformity 2 2 BACKGROUND to multiple conclusioned settings seem to be too coarse. <p> In the absence of a notion of atom guided proof search the choice that has been presented in papers seeking to extend uniformity to a multiple conclusion setting <ref> [Mil95, Vol94, Har94a] </ref> is between D all : For a sequent of the form ` C; A or ` C there exist proofs where the first step introduces the topmost connective of F for all F 2 C.
Reference: [WH94] <author> Michael Winikoff and James Harland. </author> <title> Deterministic resource management for the linear logic programming language Lygon. </title> <type> Technical Report 94/23, </type> <institution> Melbourne University, </institution> <year> 1994. </year>
Reference-contexts: An obvious example is the use of logical variables and unification to delay the choice of a term in the 9 R and 8 L rules. Another example is the handling of the R rule in linear logic based programming languages <ref> [HM94, WH94, WH95b] </ref>. An additional problem with the use of efficiency as a characteriser is that the vast majority of logic programming languages and systems omit the occur check. This yields efficiency but costs soundness.
Reference: [WH95a] <author> Michael Winikoff and James Harland. </author> <title> Characterising logic programming languages. </title> <type> Technical Report 95/26, </type> <institution> Melbourne University, </institution> <year> 1995. </year>
Reference-contexts: Simple This is one method of insisting that atoms guide the proof search process. It is used in [Mil89] and simply requires that the right premise of the ( L rule be the conclusion of an axiom rule. Left Focussed This is another method, introduced in this report <ref> [WH95a] </ref>, of allowing atoms to guide the proof search process. Locally LR This is the criterion used in [PH94] for defining Lygon. Although the paper defines uniform as simple locally LR we feel that this overloading is undesirable since the two concepts are distinct.
Reference: [WH95b] <author> Michael Winikoff and James Harland. </author> <title> Implementing the linear logic programming language Lygon. </title> <editor> In John Lloyd, editor, </editor> <booktitle> International Logic Programming Symposium, </booktitle> <pages> pages 66-80, </pages> <address> Portland, Oregon, December 1995. </address> <publisher> MIT Press. </publisher>
Reference-contexts: An obvious example is the use of logical variables and unification to delay the choice of a term in the 9 R and 8 L rules. Another example is the handling of the R rule in linear logic based programming languages <ref> [HM94, WH94, WH95b] </ref>. An additional problem with the use of efficiency as a characteriser is that the vast majority of logic programming languages and systems omit the occur check. This yields efficiency but costs soundness.
Reference: [Win95] <author> Michael Winikoff. </author> <note> Lygon home page. http://www.cs.mu.oz.au/winikoff/lygon/lygon.html, 1995. 66 A CLASSICAL SEQUENT CALCULUS (LK) </note>
Reference-contexts: We would however like to have a general characteriser which can be applied to a wide variety of logics. Logic programming languages have been derived from a variety of logics including relevant logic [Bol91], temporal and modal logics [OM94] and linear logic <ref> [HM94, And92, KY93, AP91, Mil94, Vol94, Win95] </ref>. The original work to attack the problem of characterising logic programming languages is [MNPS91]. Miller et al. take goal directedness as a suitable intuitive characteriser of logic programming languages and formalise it using the notion of uniform proofs.
References-found: 34

