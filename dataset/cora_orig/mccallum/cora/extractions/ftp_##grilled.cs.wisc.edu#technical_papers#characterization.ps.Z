URL: ftp://grilled.cs.wisc.edu/technical_papers/characterization.ps.Z
Refering-URL: http://www.cs.umd.edu/users/keleher/syllabus.818.html
Root-URL: 
Email: netzer@cs.wisc.edu  bart@cs.wisc.edu  
Title: What are Race Conditions? Some Issues and Formalizations  
Author: Robert H. B. Netzer Barton P. Miller 
Address: 1210 W. Dayton Street Madison, Wisconsin 53706  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Date: 1 March 1992  
Note: In ACM Letters on Programming Languages and Systems, Vol. 1 No.  
Abstract: In shared-memory parallel programs that use explicit synchronization, race conditions result when accesses to shared memory are not properly synchronized. Race conditions are often considered to be manifestations of bugs since their presence can cause the program to behave unexpectedly. Unfortunately, there has been little agreement in the literature as to precisely what constitutes a race condition. Two different notions have been implicitly considered: one pertaining to programs intended to be deterministic (which we call general races) and the other to nondeterministic programs containing critical sections (which we call data races). However, the differences between general races and data races have not yet been recognized. This paper examines these differences by characterizing races using a formal model and exploring their properties. We show that two variations of each type of race exist: feasible general races and data races capture the intuitive notions desired for debugging and apparent races capture less accurate notions implicitly assumed by most dynamic race detection methods. We also show that locating feasible races is an NP-hard problem, implying that only the apparent races, which are approximations to feasible races, can be detected in practice. The complexity of dynamically locating apparent races depends on the type of synchronization used by the program. Apparent races can be exhaustively located efficiently only for weak types of synchronization that are incapable of implementing mutual exclusion. This result has important implications since we argue that debugging general races requires exhaustive race detection and is inherently harder than debugging data races (which requires only partial race detection). Programs containing data races can therefore be efficiently debugged by locating certain easily identifiable races. In contrast, programs containing general races require more complex debugging techniques. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Research supported in part by National Science Foundation grant CCR-8815928, Office of Naval Research grant N00014-89-J-1222, and a Digital Equipment Corporation External Research Grant. Also available as Univ. of Wisconsin-Madison Computer Sciences Dept. Technical Report #1014. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Allen, Todd R. and David A. Padua, </author> <title> ``Debugging Fortran on a Shared Memory Machine,'' </title> <booktitle> 1987 Intl. Conf. on Parallel Processing, </booktitle> <pages> pp. </pages> <address> 721-727 St. Charles, IL, </address> <month> (August </month> <year> 1987). </year>
Reference-contexts: Indeed, two different notions have been used, but the distinction between them has not been previously recognized. Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race <ref> [1, 4, 5, 11, 16, 20, 22] </ref>, critical race [13], harmful shared-memory access [24], race condition [10, 26], or just race [2, 9, 17]. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection. <p> Bernstein's conditions state that atomic execution is guaranteed if shared variables that are read and modified by the critical section are not modified by any other concurrently executing section of code [3]. A violation of these conditions has typically been called a data race <ref> [1, 4, 5, 11, 16, 17, 20, 22] </ref> or access anomaly [6-8, 18]. We prefer the term data race. commands from bank tellers that make deposits and withdrawals for a given bank account. Figure 1 (a) shows a correct version of the program.
Reference: [2] <author> Balasundaram, Vasanth and Ken Kennedy, </author> <title> ``Compile-time Detection of Race Conditions in a Parallel Program,'' </title> <booktitle> 3rd Intl. Conf. on Supercomputing, </booktitle> <pages> pp. </pages> <address> 175-185 Crete, Greece, </address> <month> (June </month> <year> 1989). </year>
Reference-contexts: Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race [1, 4, 5, 11, 16, 20, 22], critical race [13], harmful shared-memory access [24], race condition [10, 26], or just race <ref> [2, 9, 17] </ref>. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection.
Reference: [3] <author> Bernstein, A. J., </author> <title> ``Analysis of Programs for Parallel Processing,'' </title> <journal> IEEE Trans. on Electronic Computers EC-15(5) pp. </journal> <month> 757-763 (October </month> <year> 1966). </year>
Reference-contexts: Bernstein's conditions state that atomic execution is guaranteed if shared variables that are read and modified by the critical section are not modified by any other concurrently executing section of code <ref> [3] </ref>. A violation of these conditions has typically been called a data race [1, 4, 5, 11, 16, 17, 20, 22] or access anomaly [6-8, 18]. We prefer the term data race. commands from bank tellers that make deposits and withdrawals for a given bank account.
Reference: [4] <author> Choi, Jong-Deok, Barton P. Miller, and Robert H. B. Netzer, </author> <title> ``Techniques for Debugging Parallel Programs with Flowback Analysis,'' </title> <journal> ACM Trans. on Programming Languages and Systems 13(4) pp. </journal> <month> 491-530 (Oc-tober </month> <year> 1991). </year>
Reference-contexts: Indeed, two different notions have been used, but the distinction between them has not been previously recognized. Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race <ref> [1, 4, 5, 11, 16, 20, 22] </ref>, critical race [13], harmful shared-memory access [24], race condition [10, 26], or just race [2, 9, 17]. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection. <p> Bernstein's conditions state that atomic execution is guaranteed if shared variables that are read and modified by the critical section are not modified by any other concurrently executing section of code [3]. A violation of these conditions has typically been called a data race <ref> [1, 4, 5, 11, 16, 17, 20, 22] </ref> or access anomaly [6-8, 18]. We prefer the term data race. commands from bank tellers that make deposits and withdrawals for a given bank account. Figure 1 (a) shows a correct version of the program.
Reference: [5] <author> Choi, Jong-Deok and Sang Lyul Min, </author> <title> ``Race Frontier: Reproducing Data Races in Parallel Program Debugging,'' </title> <booktitle> 3rd ACM Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pp. </pages> <address> 145-154 Willi-amsburg, VA, </address> <month> (April </month> <year> 1991). </year>
Reference-contexts: Indeed, two different notions have been used, but the distinction between them has not been previously recognized. Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race <ref> [1, 4, 5, 11, 16, 20, 22] </ref>, critical race [13], harmful shared-memory access [24], race condition [10, 26], or just race [2, 9, 17]. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection. <p> Bernstein's conditions state that atomic execution is guaranteed if shared variables that are read and modified by the critical section are not modified by any other concurrently executing section of code [3]. A violation of these conditions has typically been called a data race <ref> [1, 4, 5, 11, 16, 17, 20, 22] </ref> or access anomaly [6-8, 18]. We prefer the term data race. commands from bank tellers that make deposits and withdrawals for a given bank account. Figure 1 (a) shows a correct version of the program. <p> Debugging with Race Condition Detection An important aspect of debugging involves determining whether portions of the execution are race-free in the sense that they are unaffected by incorrect or inconsistent data produced by a race <ref> [5, 20] </ref>. For example, a programmer browsing an execution trace might focus only on portions of the trace recorded before any races occurred. These portions of the trace contain events that are guaranteed to be unaffected by the outcome of any race.
Reference: [6] <author> Dinning, Anne and Edith Schonberg, </author> <title> ``The Task Recycling Technique for Detecting Access Anomalies On-The-Fly,'' </title> <type> IBM Tech. Rep. RC 15385, </type> <month> (January </month> <year> 1990). </year>
Reference: [7] <author> Dinning, Anne and Edith Schonberg, </author> <title> ``An Empirical Comparison of Monitoring Algorithms for Access Anomaly Detection,'' </title> <booktitle> 2nd ACM Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pp. </pages> <address> 1-10 Seattle, WA, </address> <month> (March </month> <year> 1990). </year>
Reference: [8] <author> Dinning, Anne and Edith Schonberg, </author> <title> ``Detecting Access Anomalies in Programs with Critical Sections,'' </title> <booktitle> ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <address> 79-90 Santa Cruz, CA, </address> <month> (May </month> <year> 1991). </year>
Reference: [9] <author> Emrath, Perry A. and David A. Padua, </author> <title> ``Automatic Detection Of Nondeterminacy in Parallel Programs,'' </title> <booktitle> SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <address> 89-99 Madison, WI, </address> <month> (May </month> <year> 1988). </year> <note> Also appears in SIGPLAN Notices 24(1) (January 1989). 11 </note>
Reference-contexts: Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race [1, 4, 5, 11, 16, 20, 22], critical race [13], harmful shared-memory access [24], race condition [10, 26], or just race <ref> [2, 9, 17] </ref>. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection. <p> Nondeterminism is generally introduced when the order of two accesses to the same resource is not enforced by the program's synchronization. The existence of two such unordered accesses has been called a race condition <ref> [9, 10, 26] </ref>, access anomaly [12], critical race [13], or harmful shared-memory access [24]. <p> Programs using shared work-pools fall into this category. They are not intended to be deterministic, but critical sections (that access shared data) are still expected to behave atomically. Emrath and Padua have also characterized different types of race conditions but have only addressed programs intended to be deterministic <ref> [9] </ref>. They considered four levels of nondeterminism of a program (on a given input). Internally deterministic programs are those whose executions on the given input exhibit no general races.
Reference: [10] <author> Emrath, Perry A., Sanjoy Ghosh, and David A. Padua, </author> <title> ``Event Synchronization Analysis for Debugging Parallel Programs,'' </title> <booktitle> Supercomputing '89, </booktitle> <pages> pp. </pages> <address> 580-588 Reno, NV, </address> <month> (November </month> <year> 1989). </year>
Reference-contexts: Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race [1, 4, 5, 11, 16, 20, 22], critical race [13], harmful shared-memory access [24], race condition <ref> [10, 26] </ref>, or just race [2, 9, 17]. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection. <p> Nondeterminism is generally introduced when the order of two accesses to the same resource is not enforced by the program's synchronization. The existence of two such unordered accesses has been called a race condition <ref> [9, 10, 26] </ref>, access anomaly [12], critical race [13], or harmful shared-memory access [24]. <p> As discussed above, exhaustive apparent general race detection is efficient only for programs that use synchronization incapable of implementing mutual exclusion. However, for more powerful types of synchronization (such as semaphores), conservative approximations that locate a superset of the apparent general races have been proposed <ref> [10, 11] </ref>.
Reference: [11] <author> Helmbold, David P., Charles E. McDowell, and Jian-Zhong Wang, </author> <title> ``Analyzing Traces with Anonymous Synchronization,'' </title> <booktitle> 1990 Intl. Conf. on Parallel Processing, </booktitle> <pages> pp. </pages> <address> 70-77 St. Charles, IL, </address> <month> (August </month> <year> 1990). </year>
Reference-contexts: Indeed, two different notions have been used, but the distinction between them has not been previously recognized. Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race <ref> [1, 4, 5, 11, 16, 20, 22] </ref>, critical race [13], harmful shared-memory access [24], race condition [10, 26], or just race [2, 9, 17]. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection. <p> Bernstein's conditions state that atomic execution is guaranteed if shared variables that are read and modified by the critical section are not modified by any other concurrently executing section of code [3]. A violation of these conditions has typically been called a data race <ref> [1, 4, 5, 11, 16, 17, 20, 22] </ref> or access anomaly [6-8, 18]. We prefer the term data race. commands from bank tellers that make deposits and withdrawals for a given bank account. Figure 1 (a) shows a correct version of the program. <p> As discussed above, exhaustive apparent general race detection is efficient only for programs that use synchronization incapable of implementing mutual exclusion. However, for more powerful types of synchronization (such as semaphores), conservative approximations that locate a superset of the apparent general races have been proposed <ref> [10, 11] </ref>.
Reference: [12] <author> Hood, Robert, Ken Kennedy, and John Mellor-Crummey, </author> <title> ``Parallel Program Debugging with On-the-fly Anomaly Detection,'' </title> <booktitle> Supercomputing '90, </booktitle> <pages> pp. </pages> <address> 74-81 New York, NY, </address> <month> (November </month> <year> 1990). </year>
Reference-contexts: Indeed, two different notions have been used, but the distinction between them has not been previously recognized. Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly <ref> [6-8, 12, 18] </ref>, data race [1, 4, 5, 11, 16, 20, 22], critical race [13], harmful shared-memory access [24], race condition [10, 26], or just race [2, 9, 17]. <p> Nondeterminism is generally introduced when the order of two accesses to the same resource is not enforced by the program's synchronization. The existence of two such unordered accesses has been called a race condition [9, 10, 26], access anomaly <ref> [12] </ref>, critical race [13], or harmful shared-memory access [24].
Reference: [13] <author> Karam, Gerald M., Christine M. Stanczyk, and Gregory W. Bond, </author> <title> ``Critical Races in Ada Programs,'' </title> <journal> IEEE Trans. on Software Engineering 15(11) pp. </journal> <month> 1471-1480 (November </month> <year> 1989). </year>
Reference-contexts: Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race [1, 4, 5, 11, 16, 20, 22], critical race <ref> [13] </ref>, harmful shared-memory access [24], race condition [10, 26], or just race [2, 9, 17]. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection. <p> Nondeterminism is generally introduced when the order of two accesses to the same resource is not enforced by the program's synchronization. The existence of two such unordered accesses has been called a race condition [9, 10, 26], access anomaly [12], critical race <ref> [13] </ref>, or harmful shared-memory access [24].
Reference: [14] <author> Lamport, Leslie, </author> <title> ``How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs,'' </title> <journal> IEEE Trans. on Computers C-28(9) pp. </journal> <month> 690-691 (September </month> <year> 1979). </year>
Reference-contexts: Actual Program Executions The first part of our model is simply a notation for representing an execution of a shared-memory parallel pro gram on a sequentially consistent <ref> [14] </ref> processor . A program execution, P, is a triple, E, T D , where E is a finite set of events, and T (the temporal ordering relation) and D (the shared-data dependence relation) are relations over those events.
Reference: [15] <author> Lamport, Leslie, </author> <title> ``The Mutual Exclusion Problem: Part I A Theory of Interprocess Communication,'' </title> <journal> Journal of the ACM 33(2) pp. </journal> <month> 313-326 (April </month> <year> 1986). </year>
Reference-contexts: In this section, we briefly overview our model for reasoning about race conditions that was first presented in an earlier paper [22] and that is based on Lamport's theory of concurrent systems <ref> [15] </ref>. Our model consists of two parts: one to represent the actual behavior exhibited by the program and the other to represent potential behaviors possibly exhibited by the program. 4 3.1.
Reference: [16] <author> Mellor-Crummey, John M., </author> <title> ``On-the-Fly Detection of Data Races for Programs with Nested Fork-Join Parallelism,'' </title> <booktitle> Supercomputing '91, </booktitle> <pages> pp. </pages> <address> 24-33 Albuquerque, NM, </address> <month> (November </month> <year> 1991). </year>
Reference-contexts: Indeed, two different notions have been used, but the distinction between them has not been previously recognized. Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race <ref> [1, 4, 5, 11, 16, 20, 22] </ref>, critical race [13], harmful shared-memory access [24], race condition [10, 26], or just race [2, 9, 17]. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection. <p> Bernstein's conditions state that atomic execution is guaranteed if shared variables that are read and modified by the critical section are not modified by any other concurrently executing section of code [3]. A violation of these conditions has typically been called a data race <ref> [1, 4, 5, 11, 16, 17, 20, 22] </ref> or access anomaly [6-8, 18]. We prefer the term data race. commands from bank tellers that make deposits and withdrawals for a given bank account. Figure 1 (a) shows a correct version of the program.
Reference: [17] <author> Miller, Barton P. and Jong-Deok Choi, </author> <title> ``A Mechanism for Efficient Debugging of Parallel Programs,'' </title> <booktitle> SIG-PLAN Conf. on Programming Language Design and Implementation, </booktitle> <pages> pp. </pages> <address> 135-144 Atlanta, GA, </address> <month> (June </month> <year> 1988). </year> <note> Also appears in SIGPLAN Notices 23(7) (July 1988). </note>
Reference-contexts: Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race [1, 4, 5, 11, 16, 20, 22], critical race [13], harmful shared-memory access [24], race condition [10, 26], or just race <ref> [2, 9, 17] </ref>. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection. <p> Bernstein's conditions state that atomic execution is guaranteed if shared variables that are read and modified by the critical section are not modified by any other concurrently executing section of code [3]. A violation of these conditions has typically been called a data race <ref> [1, 4, 5, 11, 16, 17, 20, 22] </ref> or access anomaly [6-8, 18]. We prefer the term data race. commands from bank tellers that make deposits and withdrawals for a given bank account. Figure 1 (a) shows a correct version of the program.
Reference: [18] <author> Min, Sang Lyul and Jong-Deok Choi, </author> <title> ``An Efficient Cache-based Access Anomaly Detection Scheme,'' </title> <booktitle> 4th Intl. Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. </pages> <address> 235-244 Palo Alto, CA, </address> <month> (April </month> <year> 1991). </year>
Reference-contexts: Indeed, two different notions have been used, but the distinction between them has not been previously recognized. Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly <ref> [6-8, 12, 18] </ref>, data race [1, 4, 5, 11, 16, 20, 22], critical race [13], harmful shared-memory access [24], race condition [10, 26], or just race [2, 9, 17]. <p> A violation of these conditions has typically been called a data race [1, 4, 5, 11, 16, 17, 20, 22] or access anomaly <ref> [6-8, 18] </ref>. We prefer the term data race. commands from bank tellers that make deposits and withdrawals for a given bank account. Figure 1 (a) shows a correct version of the program. Since the variables balance and interest are shared, operations that manipulate them are enclosed in critical sections.
Reference: [19] <author> Netzer, Robert H. B. and Barton P. Miller, </author> <title> ``On the Complexity of Event Ordering for Shared-Memory Parallel Program Executions,'' </title> <booktitle> 1990 Intl. Conf. on Parallel Processing, </booktitle> <pages> pp. </pages> <address> II-93-II-97 St. Charles, IL, </address> <month> (August </month> <year> 1990). </year>
Reference-contexts: In general, for another execution to perform the same events as P, it must also exhibit the same shared-data dependences as P; when general races occur (whether or not they are considered failures), F SYNC may contain infeasible executions <ref> [19, 22] </ref>. As discussed later, the existence of such infeasible executions impacts the accuracy of races reported by methods that analyze only explicit synchron ization. Nevertheless, we will see that this notion is useful because it allows a simple characterization of race conditions that are easy to detect. 4. <p> We have proven that deciding these membership problems is NP-hard (no matter what type of synchronization the program uses) and that locating feasible races is also NP-hard <ref> [19, 21] </ref>. It is therefore an intractable problem to locate precisely the race conditions exhibited by an execution of the program. This result suggests that, in practice, we must settle for an approximation, discussed next. Indeed, previously proposed race detection methods compute such an approximation. 4.3. <p> We have also proven that, for program executions using synchronization powerful enough to implement two-process mutual exclusion, determining membership in F SYNC and locating apparent races is NP-hard <ref> [19] </ref>. Membership in F SYNC is efficiently computable only for weaker synchronization incapable of implementing mutual exclusion (such as Post/Wait style synchronization without Clear operations); all apparent races can thus be efficiently detected in executions of such programs [23].
Reference: [20] <author> Netzer, Robert H. B. and Barton P. Miller, </author> <title> ``Improving the Accuracy of Data Race Detection,'' </title> <booktitle> 3rd ACM Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pp. </pages> <address> 133-144 Williamsburg, VA, </address> <month> (April </month> <year> 1991). </year>
Reference-contexts: Indeed, two different notions have been used, but the distinction between them has not been previously recognized. Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race <ref> [1, 4, 5, 11, 16, 20, 22] </ref>, critical race [13], harmful shared-memory access [24], race condition [10, 26], or just race [2, 9, 17]. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection. <p> Bernstein's conditions state that atomic execution is guaranteed if shared variables that are read and modified by the critical section are not modified by any other concurrently executing section of code [3]. A violation of these conditions has typically been called a data race <ref> [1, 4, 5, 11, 16, 17, 20, 22] </ref> or access anomaly [6-8, 18]. We prefer the term data race. commands from bank tellers that make deposits and withdrawals for a given bank account. Figure 1 (a) shows a correct version of the program. <p> Because not all program executions in F SYNC are feasible, some apparent races may be spurious. Spurious races can occur whenever the values of shared variables are used (directly or indirectly) in conditional expressions or shared-array subscripts <ref> [20, 22] </ref>. In such cases, the existence of one event may depend on another event occurring first. <p> If the operations on the shared buffer were instead complex and involved many shared-memory references, a large number of spurious races could be reported. Spurious races pose a problem since they are not direct manifestations of any program bug <ref> [20, 22] </ref>. The programmer can be overwhelmed with large amounts of misleading information, irrelevant for debugging, that masks the location of actual failures. Nonetheless, apparent race detection provides valuable information, since apparent races exist if and only if at least one feasible race exists somewhere in the execution [22]. <p> Debugging with Race Condition Detection An important aspect of debugging involves determining whether portions of the execution are race-free in the sense that they are unaffected by incorrect or inconsistent data produced by a race <ref> [5, 20] </ref>. For example, a programmer browsing an execution trace might focus only on portions of the trace recorded before any races occurred. These portions of the trace contain events that are guaranteed to be unaffected by the outcome of any race.
Reference: [21] <author> Netzer, Robert H. B., </author> <title> ``Race Condition Detection for Debugging Shared-Memory Parallel Programs,'' </title> <institution> Computer Sciences Dept. </institution> <type> Tech. Rep. #1039 (Ph.D. Thesis), </type> <institution> Univ. of Wisconsin-Madison, </institution> <month> (August </month> <year> 1991). </year>
Reference-contexts: We have proven that deciding these membership problems is NP-hard (no matter what type of synchronization the program uses) and that locating feasible races is also NP-hard <ref> [19, 21] </ref>. It is therefore an intractable problem to locate precisely the race conditions exhibited by an execution of the program. This result suggests that, in practice, we must settle for an approximation, discussed next. Indeed, previously proposed race detection methods compute such an approximation. 4.3.
Reference: [22] <author> Netzer, Robert H. B. and Barton P. Miller, </author> <title> ``Detecting Data Races in Parallel Program Executions,'' pp. </title> <booktitle> 109-129 in Advances in Languages and Compilers for Parallel Processing, </booktitle> <editor> ed. A. Nicolau, D. Gelernter, T. Gross, and D. Padua, </editor> <publisher> MIT Press (1991). </publisher>
Reference-contexts: Indeed, two different notions have been used, but the distinction between them has not been previously recognized. Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race <ref> [1, 4, 5, 11, 16, 20, 22] </ref>, critical race [13], harmful shared-memory access [24], race condition [10, 26], or just race [2, 9, 17]. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection. <p> Bernstein's conditions state that atomic execution is guaranteed if shared variables that are read and modified by the critical section are not modified by any other concurrently executing section of code [3]. A violation of these conditions has typically been called a data race <ref> [1, 4, 5, 11, 16, 17, 20, 22] </ref> or access anomaly [6-8, 18]. We prefer the term data race. commands from bank tellers that make deposits and withdrawals for a given bank account. Figure 1 (a) shows a correct version of the program. <p> Doing so not only provides unambiguous characterizations of each, but also provides a mechanism with which to reason about their properties. In this section, we briefly overview our model for reasoning about race conditions that was first presented in an earlier paper <ref> [22] </ref> and that is based on Lamport's theory of concurrent systems [15]. Our model consists of two parts: one to represent the actual behavior exhibited by the program and the other to represent potential behaviors possibly exhibited by the program. 4 3.1. <p> The model also contains axioms describing properties that any program execution must possess <ref> [22] </ref>. We omit these axioms here as they are unnecessary for simply characterizing race conditions. <p> In general, for another execution to perform the same events as P, it must also exhibit the same shared-data dependences as P; when general races occur (whether or not they are considered failures), F SYNC may contain infeasible executions <ref> [19, 22] </ref>. As discussed later, the existence of such infeasible executions impacts the accuracy of races reported by methods that analyze only explicit synchron ization. Nevertheless, we will see that this notion is useful because it allows a simple characterization of race conditions that are easy to detect. 4. <p> Because not all program executions in F SYNC are feasible, some apparent races may be spurious. Spurious races can occur whenever the values of shared variables are used (directly or indirectly) in conditional expressions or shared-array subscripts <ref> [20, 22] </ref>. In such cases, the existence of one event may depend on another event occurring first. <p> If the operations on the shared buffer were instead complex and involved many shared-memory references, a large number of spurious races could be reported. Spurious races pose a problem since they are not direct manifestations of any program bug <ref> [20, 22] </ref>. The programmer can be overwhelmed with large amounts of misleading information, irrelevant for debugging, that masks the location of actual failures. Nonetheless, apparent race detection provides valuable information, since apparent races exist if and only if at least one feasible race exists somewhere in the execution [22]. <p> The programmer can be overwhelmed with large amounts of misleading information, irrelevant for debugging, that masks the location of actual failures. Nonetheless, apparent race detection provides valuable information, since apparent races exist if and only if at least one feasible race exists somewhere in the execution <ref> [22] </ref>. Moreover, we have proven results showing how to reason about the potential feasibility of apparent races, and how a post-mortem race detector can be extended to conservatively determine which apparent races are feasible and of interest for debugging [20-22].
Reference: [23] <author> Netzer, Robert H.B. and Sanjoy Ghosh, </author> <title> ``Efficient Race Condition Detection for Shared-Memory Programs with Post/Wait Synchronization,'' </title> <institution> Computer Sciences Dept. </institution> <type> Tech. Rep., </type> <institution> Univ. of Wisconsin-Madison, </institution> <month> (January </month> <year> 1992). </year>
Reference-contexts: Membership in F SYNC is efficiently computable only for weaker synchronization incapable of implementing mutual exclusion (such as Post/Wait style synchronization without Clear operations); all apparent races can thus be efficiently detected in executions of such programs <ref> [23] </ref>. It is important to note that data races are not of interest for such programs since weaker synchronization cannot implement critical sections. Exhaustively locating all apparent data races is therefore always NP-hard. In contrast, the complexity of apparent general race detection depends on the type of synchronization used.
Reference: [24] <author> Nudler, Itzhak and Larry Rudolph, </author> <title> ``Tools for the Efficient Development of Efficient Parallel Programs,'' </title> <booktitle> 1st Israeli Conf. on Computer System Engineering, </booktitle> <year> (1988). </year>
Reference-contexts: Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race [1, 4, 5, 11, 16, 20, 22], critical race [13], harmful shared-memory access <ref> [24] </ref>, race condition [10, 26], or just race [2, 9, 17]. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection. <p> Nondeterminism is generally introduced when the order of two accesses to the same resource is not enforced by the program's synchronization. The existence of two such unordered accesses has been called a race condition [9, 10, 26], access anomaly [12], critical race [13], or harmful shared-memory access <ref> [24] </ref>. For a more consistent terminology, we propose the term general race, since such a race is more general than a data race. 3 As an example of programs for which general races are manifestations of bugs, consider parallel programs that are constructed from sequential programs by parallelizing loops.
Reference: [25] <author> Randell, B., P. A. Lee, and P. C. Treleaven, </author> <title> ``Reliability Issues in Computing System Design,'' </title> <journal> Computing Surveys 10(2) pp. </journal> <month> 123-165 (June </month> <year> 1978). </year>
Reference-contexts: Previous work has not provided unambiguous characterizations of the different types of race conditions or related races to program bugs. For example, race conditions have only been defined as occurring when two shared-memory hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh To be consistent with the fault tolerant research community <ref> [25] </ref>, a failure occurs when a program's external behavior differs from its specification, and a fault is its algorithmic cause (although we use the term bug). There is some controversy over terminology that is the most descriptive.
Reference: [26] <author> Steele, Guy L., </author> <title> ``Making Asynchronous Parallelism Safe for the World,'' </title> <booktitle> 17th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. </pages> <address> 218-23 San Francisco, CA, </address> <month> (January </month> <year> 1990). </year> <month> 12 </month>
Reference-contexts: Because no consistent terminology has appeared, several terms have been used with different intended meanings, such as access anomaly [6-8, 12, 18], data race [1, 4, 5, 11, 16, 20, 22], critical race [13], harmful shared-memory access [24], race condition <ref> [10, 26] </ref>, or just race [2, 9, 17]. This paper explores the nature of race conditions and uncovers some previously hidden issues regarding the accuracy and complexity of dynamic race detection. <p> Nondeterminism is generally introduced when the order of two accesses to the same resource is not enforced by the program's synchronization. The existence of two such unordered accesses has been called a race condition <ref> [9, 10, 26] </ref>, access anomaly [12], critical race [13], or harmful shared-memory access [24].
References-found: 26

