URL: ftp://ftp.cs.utexas.edu/pub/psp/seuss/discipline.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/misra/
Root-URL: http://www.cs.utexas.edu
Email: misra@cs.utexas.edu  
Phone: (512) 471-9547  
Title: A Discipline of Multiprogramming  
Author: Jayadev Misra 
Note: 1 This material is based in part upon work supported by the National Science Foun dation Awards CCR-9111912 and CCR-9504190.  
Date: June 11, 1996  
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. Batcher. </author> <title> Sorting networks and their applications. </title> <booktitle> In Proc. AFIPS Spring Joint Computer Conference, </booktitle> <volume> volume 32, </volume> <pages> pages 307-314, </pages> <address> Reston, VA, 1968. </address> <publisher> AFIPS Press. </publisher>
Reference-contexts: A total procedure need not be deterministic; e.g., any minimum spanning tree could be returned by the procedure. Furthermore, a total procedure need not be implemented on a single processor, e.g., the list may be sorted by a sorting network <ref> [1] </ref>, for instance. Data parallel programs and other synchronous computation schemes are usually total procedures. <p> that reappears in section 2.7. box H clone mult [1::3]: Fifo clone merge: Fifo init put (1) box P var h [1::3]:nat init 0, f: nat partial action read:: ([]i : 1 i 3 : h [i] = 0; mult [i]:get (h [i]) ! skip ) partial action write:: h <ref> [1] </ref> 6= 0 ^ h [2] 6= 0 ^ h [3] 6= 0 ! skip end fP g clone produce : P partial method next (g: nat):: true; merge:get (g) ! skip end fH g Box H consists of the clones, mult (an array of three clones), merge and produce, and <p> A PUBLICATION NOTATION Library. Hamming contains a single partial method, next , that yields the next number, g, in the desired sequence. Since, 2 fi g; 3 fi g; 5 fi g are also numbers of the desired sequence, next sends these numbers along the Fifo channels mult <ref> [1 ] </ref>, mult [2 ], mult [3 ], respectively. The role of produce is to merge the increasing sequences received along mult [1 ], mult [2 ], mult [3 ], and send the resulting increasing sequence along merge. <p> Since, 2 fi g; 3 fi g; 5 fi g are also numbers of the desired sequence, next sends these numbers along the Fifo channels mult <ref> [1 ] </ref>, mult [2 ], mult [3 ], respectively. The role of produce is to merge the increasing sequences received along mult [1 ], mult [2 ], mult [3 ], and send the resulting increasing sequence along merge. Merging is done by using three variables, h [1..3], where h [i] is the last number received along mult [i ]; if all numbers received have already been output then h [i] is 0. <p> the channel merge, initially. clone Hamming clone mult [1::3]: Fifo clone merge: Fifo init put (1) clone produce var h [1::3]:nat init 0, f: nat partial action read :: ([]i : 1 i 3 : h [i] = 0; mult [i]:get (h [i]) ! skip ) partial action write:: h <ref> [1] </ref> 6= 0 ^ h [2] 6= 0 ^ h [3] 6= 0 ! f := min (h [1]; h [2]; h [3]); merge:put (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then <p> var h [1::3]:nat init 0, f: nat partial action read :: ([]i : 1 i 3 : h [i] = 0; mult [i]:get (h [i]) ! skip ) partial action write:: h <ref> [1] </ref> 6= 0 ^ h [2] 6= 0 ^ h [3] 6= 0 ! f := min (h [1]; h [2]; h [3]); merge:put (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end fproduceg partial method next (g: nat):: ; merge:get (g) ! mult [1 ]:put <p> ([]i : 1 i 3 : h [i] = 0; mult [i]:get (h [i]) ! skip ) partial action write:: h <ref> [1] </ref> 6= 0 ^ h [2] 6= 0 ^ h [3] 6= 0 ! f := min (h [1]; h [2]; h [3]); merge:put (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end fproduceg partial method next (g: nat):: ; merge:get (g) ! mult [1 ]:put (2 fi g ); mult [2 ]:put (3 fi g ); <p> i 3 : h [i] = 0; mult [i]:get (h [i]) ! skip ) partial action write:: h <ref> [1] </ref> 6= 0 ^ h [2] 6= 0 ^ h [3] 6= 0 ! f := min (h [1]; h [2]; h [3]); merge:put (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end fproduceg partial method next (g: nat):: ; merge:get (g) ! mult [1 ]:put (2 fi g ); mult [2 ]:put (3 fi g ); mult [3 ]:put <p> (h [1]; h [2]; h [3]); merge:put (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end fproduceg partial method next (g: nat):: ; merge:get (g) ! mult <ref> [1 ] </ref>:put (2 fi g ); mult [2 ]:put (3 fi g ); mult [3 ]:put (5 fi g ) end fHamming g Chapter 3 Small Examples A number of small examples are treated in this chapter.
Reference: [2] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1987. </year>
Reference-contexts: We expect that the rules of combination have to become even simpler at the multiprogramming level. That is why we propose that the component actions of a multiprogram be executed using a form of repeated non-deterministic selection only. Our work incorporates ideas from serializability and atomicity in databases <ref> [2] </ref>, notions of objects and inheritance [19], Communicating Sequential Processes [15], i/o automata [17], and Temporal Logic of Actions [16]. <p> box H clone mult [1::3]: Fifo clone merge: Fifo init put (1) box P var h [1::3]:nat init 0, f: nat partial action read:: ([]i : 1 i 3 : h [i] = 0; mult [i]:get (h [i]) ! skip ) partial action write:: h [1] 6= 0 ^ h <ref> [2] </ref> 6= 0 ^ h [3] 6= 0 ! skip end fP g clone produce : P partial method next (g: nat):: true; merge:get (g) ! skip end fH g Box H consists of the clones, mult (an array of three clones), merge and produce, and a single component box, P <p> Hamming contains a single partial method, next , that yields the next number, g, in the desired sequence. Since, 2 fi g; 3 fi g; 5 fi g are also numbers of the desired sequence, next sends these numbers along the Fifo channels mult [1 ], mult <ref> [2 ] </ref>, mult [3 ], respectively. The role of produce is to merge the increasing sequences received along mult [1 ], mult [2 ], mult [3 ], and send the resulting increasing sequence along merge. <p> 2 fi g; 3 fi g; 5 fi g are also numbers of the desired sequence, next sends these numbers along the Fifo channels mult [1 ], mult <ref> [2 ] </ref>, mult [3 ], respectively. The role of produce is to merge the increasing sequences received along mult [1 ], mult [2 ], mult [3 ], and send the resulting increasing sequence along merge. Merging is done by using three variables, h [1..3], where h [i] is the last number received along mult [i ]; if all numbers received have already been output then h [i] is 0. <p> Hamming clone mult [1::3]: Fifo clone merge: Fifo init put (1) clone produce var h [1::3]:nat init 0, f: nat partial action read :: ([]i : 1 i 3 : h [i] = 0; mult [i]:get (h [i]) ! skip ) partial action write:: h [1] 6= 0 ^ h <ref> [2] </ref> 6= 0 ^ h [3] 6= 0 ! f := min (h [1]; h [2]; h [3]); merge:put (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end <p> [1::3]:nat init 0, f: nat partial action read :: ([]i : 1 i 3 : h [i] = 0; mult [i]:get (h [i]) ! skip ) partial action write:: h [1] 6= 0 ^ h <ref> [2] </ref> 6= 0 ^ h [3] 6= 0 ! f := min (h [1]; h [2]; h [3]); merge:put (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end fproduceg partial method next (g: nat):: ; merge:get (g) ! mult [1 ]:put (2 fi <p> mult [i]:get (h [i]) ! skip ) partial action write:: h [1] 6= 0 ^ h <ref> [2] </ref> 6= 0 ^ h [3] 6= 0 ! f := min (h [1]; h [2]; h [3]); merge:put (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end fproduceg partial method next (g: nat):: ; merge:get (g) ! mult [1 ]:put (2 fi g ); mult [2 ]:put (3 fi g ); mult [3 ]:put (5 fi g ) end fHamming g <p> [i]) ! skip ) partial action write:: h [1] 6= 0 ^ h <ref> [2] </ref> 6= 0 ^ h [3] 6= 0 ! f := min (h [1]; h [2]; h [3]); merge:put (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end fproduceg partial method next (g: nat):: ; merge:get (g) ! mult [1 ]:put (2 fi g ); mult [2 ]:put (3 fi g ); mult [3 ]:put (5 fi g ) end fHamming g Chapter 3 Small <p> (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end fproduceg partial method next (g: nat):: ; merge:get (g) ! mult [1 ]:put (2 fi g ); mult <ref> [2 ] </ref>:put (3 fi g ); mult [3 ]:put (5 fi g ) end fHamming g Chapter 3 Small Examples A number of small examples are treated in this chapter.
Reference: [3] <editor> J.C. Browne et al. </editor> <title> A language for specification and programming of reconfigurable parallel computation structures. </title> <booktitle> In Int. Conf. of Parallel Processing, </booktitle> <address> Bellaire, </address> <publisher> Michigan, </publisher> <pages> pages 142-149. </pages> <publisher> IEEE, </publisher> <month> Aug </month> <year> 1982. </year>
Reference-contexts: Fifo clone merge: Fifo init put (1) box P var h [1::3]:nat init 0, f: nat partial action read:: ([]i : 1 i 3 : h [i] = 0; mult [i]:get (h [i]) ! skip ) partial action write:: h [1] 6= 0 ^ h [2] 6= 0 ^ h <ref> [3] </ref> 6= 0 ! skip end fP g clone produce : P partial method next (g: nat):: true; merge:get (g) ! skip end fH g Box H consists of the clones, mult (an array of three clones), merge and produce, and a single component box, P . <p> Since, 2 fi g; 3 fi g; 5 fi g are also numbers of the desired sequence, next sends these numbers along the Fifo channels mult [1 ], mult [2 ], mult <ref> [3 ] </ref>, respectively. The role of produce is to merge the increasing sequences received along mult [1 ], mult [2 ], mult [3 ], and send the resulting increasing sequence along merge. <p> 3 fi g; 5 fi g are also numbers of the desired sequence, next sends these numbers along the Fifo channels mult [1 ], mult [2 ], mult <ref> [3 ] </ref>, respectively. The role of produce is to merge the increasing sequences received along mult [1 ], mult [2 ], mult [3 ], and send the resulting increasing sequence along merge. Merging is done by using three variables, h [1..3], where h [i] is the last number received along mult [i ]; if all numbers received have already been output then h [i] is 0. <p> clone merge: Fifo init put (1) clone produce var h [1::3]:nat init 0, f: nat partial action read :: ([]i : 1 i 3 : h [i] = 0; mult [i]:get (h [i]) ! skip ) partial action write:: h [1] 6= 0 ^ h [2] 6= 0 ^ h <ref> [3] </ref> 6= 0 ! f := min (h [1]; h [2]; h [3]); merge:put (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end fproduceg partial method next (g: <p> 0, f: nat partial action read :: ([]i : 1 i 3 : h [i] = 0; mult [i]:get (h [i]) ! skip ) partial action write:: h [1] 6= 0 ^ h [2] 6= 0 ^ h <ref> [3] </ref> 6= 0 ! f := min (h [1]; h [2]; h [3]); merge:put (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end fproduceg partial method next (g: nat):: ; merge:get (g) ! mult [1 ]:put (2 fi g ); <p> h [1] 6= 0 ^ h [2] 6= 0 ^ h <ref> [3] </ref> 6= 0 ! f := min (h [1]; h [2]; h [3]); merge:put (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end fproduceg partial method next (g: nat):: ; merge:get (g) ! mult [1 ]:put (2 fi g ); mult [2 ]:put (3 fi g ); mult [3 ]:put (5 fi g ) end fHamming g Chapter 3 Small Examples A number of small examples are <p> 0 ^ h [2] 6= 0 ^ h <ref> [3] </ref> 6= 0 ! f := min (h [1]; h [2]; h [3]); merge:put (f); if f = h [1] then h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end fproduceg partial method next (g: nat):: ; merge:get (g) ! mult [1 ]:put (2 fi g ); mult [2 ]:put (3 fi g ); mult [3 ]:put (5 fi g ) end fHamming g Chapter 3 Small Examples A number of small examples are treated in this <p> h [1] := 0; if f = h [2] then h [2] := 0; if f = h [3] then h [3] := 0 end fproduceg partial method next (g: nat):: ; merge:get (g) ! mult [1 ]:put (2 fi g ); mult [2 ]:put (3 fi g ); mult <ref> [3 ] </ref>:put (5 fi g ) end fHamming g Chapter 3 Small Examples A number of small examples are treated in this chapter.
Reference: [4] <author> K. M. Chandy and J. Misra. </author> <title> The drinking philosophers problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(4) </volume> <pages> 632-646, </pages> <year> 1984. </year>
Reference-contexts: SMALL EXAMPLES algorithm for a problem may be the basis for a family of interrelated algorithms. Finally (third), we exploit the notion of exactness to eliminate undesirable solutions for a given specification, that restrict concurrency, for instance. As an example, consider a scheduling strategy in a dining philosophers problem <ref> [4] </ref> that allows only one philosopher to eat at any time, thereby implementing the constraint that no two neighbors are eating simultaneously; we can eliminate such solutions from consideration by requiring that no solution may restrict concurrency, i.e., by asking for an exact solution. <p> The problem also subsumes the classical dining philosophers problem and its variations <ref> [11, 4] </ref>: there are equal number of processes and resources, numbered 0 through N , and the i th process needs resources i and i 1, where is addition modulo N , when it is hungry. We show the code for a generic process.
Reference: [5] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: The form of a partial procedure is inspired by Communicating Sequential Processes [15]. 1.3. WHY SEUSS 17 Our model may be viewed as a special case of CSP because we disallow nested partial procedures. Seuss is an outgrowth of our earlier work on UNITY <ref> [5] </ref>. A UNITY program consists of statements each of which may change the program state. A program execution starts in a specified initial state. Statements of the program are chosen for execution in a non-deterministic fashion, subject only to the (fairness) rule that each statement be chosen eventually. <p> It is required to compute the sequence of integers of the form 2 i fi 3 j fi 5 k in increasing order, for all natural numbers i; j; k. Our solution follows the treatment in Section 8.2 (page 182) of Chandy and Misra <ref> [5] </ref>, and it is sketched briefly below. The program Hamming (a clone) consists of the boxes, mult , merge, and produce . Boxes mult and merge are Fifo channels, where Fifo is declared in 26 CHAPTER 2. A PUBLICATION NOTATION Library. <p> We employ a parameter N in our solution that indicates the maximum number of readers permitted to have simultaneous access to the resource; N may be set arbitrarily high to permit simultaneous access for all readers. The following solution, based upon one in section 6.10 of <ref> [5] </ref>, uses a pool of tokens. Initially, there are N tokens. A reader needs 1 token and a writer N tokens to proceed.
Reference: [6] <author> K. M. Chandy and B. A. Sanders. </author> <title> Towards compositional specifications for parallel programs. </title> <booktitle> In DIMACS Workshop on Specifications of Parallel Algorithms, </booktitle> <address> Princeton, NJ, </address> <month> May 9-11 </month> <year> 1994. </year>
Reference-contexts: We have developed a simple logic for UNITY (for some recent developments, see [22], [21], <ref> [6] </ref>) that is applicable to Seuss as well. 18 CHAPTER 1. INTRODUCTION Chapter 2 A Publication Notation The goal of this chapter is to propose a programming model and a publication notation.
Reference: [7] <author> M.E. Conway. </author> <title> Design of a separable transition-diagram compiler. </title> <journal> Communications of the ACM, </journal> <volume> 6(7) </volume> <pages> 396-408, </pages> <month> July </month> <year> 1963. </year>
Reference-contexts: This fault model of a channel is assumed in the Alternating Bit Protocol [24]. Such a protocol can be studied (proved correct) by encoding the communication between the sender and the receiver using FaultyChannel . 3.3 A Problem due to Conway The following problem, due to Conway <ref> [7] </ref>, has become a benchmark in assessing multiprogramming language features. A sequence of cards, each with 80 characters, is to be read from a card-reader (reader) and printed as a sequence of lines, each line with 125 characters, on a line-printer (printer).
Reference: [8] <author> P.J. Courtois, F. Heymans, and D.L. Parnas. </author> <title> Concurrent control with readers and writers. </title> <journal> Communications of the ACM, </journal> <volume> 14(10) </volume> <pages> 667-668, </pages> <month> October </month> <year> 1967. </year>
Reference-contexts: sync (p: boolean):: b ^ p ! c; p := c 1; false; b := (c 6= 0) 6 j :b ^ :p ! c; p := c + 1; true; b := (c = N ) end fbarrierg 3.6 Readers and Writers We consider the classic Readers Writers Problem <ref> [8] </ref> in which a common resource say, a file is shared among a set of reader processes and writer processes. Any number of readers may have simultaneous access to the file where as a writer needs exclusive access.
Reference: [9] <author> W. Diffie and M. Hellman. </author> <title> New directions in cryptography. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 22(6) </volume> <pages> 644-654, </pages> <year> 1976. </year>
Reference-contexts: A determined intruder could attempt to guess the holder's ticket value in a series of attempts. If this box is to be used in an environment where malice rules, it should be enclosed within a box that thwarts such access by using digital signatures <ref> [9, 23] </ref>, for instance. The current implementation guards against errors caused by poor programming or hardware malfunction.
Reference: [10] <author> E. W. Dijkstra. </author> <title> Solution of a problem in concurrent programming control. </title> <journal> Communications of the ACM, </journal> <volume> 8(9):569, </volume> <year> 1965. </year>
Reference-contexts: The goals are in conflict because fine granularity, in general, implies considerable interference. The earliest mul-tiprograms (see, for instance, the solution to the mutual exclusion problem in Dijkstra <ref> [10] </ref>) were trivially small and impossibly difficult to understand, because the behaviors of the individual processes could not be understood in isolation, and all possible interactions among the processes had to be analyzed explicitly.
Reference: [11] <author> E. W. Dijkstra. </author> <title> Cooperating sequential processes. </title> <editor> In F.Genuys, editor, </editor> <booktitle> Programming Languages, </booktitle> <pages> pages 43-112. </pages> <publisher> Academic press, </publisher> <year> 1968. </year>
Reference-contexts: Consecutive readers in the queue are permitted to have simultaneous access to the resource. 3.7 Semaphore A ubiquitous concept in multiprogramming is semaphore <ref> [11] </ref>. A binary semaphore, often called a lock, is typically associated with a resource, such as a file, device or communication channel. A process has exclusive access to a resource only when it has acquired, i.e., it holds, the corresponding semaphore. <p> The problem also subsumes the classical dining philosophers problem and its variations <ref> [11, 4] </ref>: there are equal number of processes and resources, numbered 0 through N , and the i th process needs resources i and i 1, where is addition modulo N , when it is hungry. We show the code for a generic process.
Reference: [12] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1976. </year> <note> 61 62 BIBLIOGRAPHY </note>
Reference-contexts: The last partial action declaration creates N partial actions where the i th action accepts if it receives a message from the i th channel, in [i], and then it sends the message along an output channel, out. 2.7 An Example This example, attributed to Hamming, is taken from Dijkstra <ref> [12] </ref>. The purpose of the example is not to show a clever algorithm, but to illustrate various features of Seuss including: nested boxes, representation of message communication over unbounded channels, and quantified actions.
Reference: [13] <author> E. W. Dijkstra. </author> <title> Misra's weakest fair buffer. </title> <type> EWD 1225, </type> <institution> University of Texas, Austin, </institution> <month> 78712, Dec </month> <year> 1995. </year>
Reference-contexts: A get either increases t, thus decreasing i t, or it keeps t the same and decreases p, thus, decreasing (i t; p). 3.2. CHANNELS 31 The proposed solution is, furthermore, exact. The original proof is due to Dijkstra <ref> [13] </ref>, on which the following argument is based. Consider a sequence finite or infinite each element of which is of the form (put; y) or (get; y).
Reference: [14] <author> C.A.R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <month> Aug </month> <year> 1978. </year>
Reference-contexts: b [r]; k := r 1; x; k + 1 partial method get (x: type):: k &gt; 0 ! f; x; k := f 1; b [f ]; k 1 end fbch (N ) of typeg As an application of bounded channels, we consider the following example due to Hoare <ref> [14] </ref>. A multiplexor process receives a stream of messages from 10 different consoles. It acknowledges each message it receives and sends the received message along an output channel. A console may terminate the stream by sending a special end-of-stream (eos) message. The solution in [14] uses rendezvous-based communication that eliminates the <p> the following example due to Hoare <ref> [14] </ref>. A multiplexor process receives a stream of messages from 10 different consoles. It acknowledges each message it receives and sends the received message along an output channel. A console may terminate the stream by sending a special end-of-stream (eos) message. The solution in [14] uses rendezvous-based communication that eliminates the need for acknowledging the receipt of messages. We achieve a similar effect by requiring that a console and the multiplexor communicate over a bounded channel of size 1, i.e., a word.
Reference: [15] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall International, </publisher> <address> London, </address> <year> 1984. </year>
Reference-contexts: No specific communication or synchronization mechanism, except the procedure call, is built into the model. In particular, the notions of input/output and their complementary nature in rendezvous-based communication <ref> [15, 20] </ref> is outside this model. There is no distinction between computation and communication; process specifications and interface specifications are not distinguished. Consequently, we do not have many of the traditional multiprogramming concepts such as, processes, locking, rendezvous, waiting, interference and deadlock, as basic concepts in our model. <p> A consequence of having a single thread is that the notion of waiting has to be abandoned, because a thread can afford to wait only if there is another thread whose execution can terminate its waiting; rendezvous-based interactions <ref> [15, 20] </ref> that require at least two threads of control to be meaningful, have to be abandoned in this model of execution. We have replaced waiting by the refusal of a procedure to execute. <p> That is why we propose that the component actions of a multiprogram be executed using a form of repeated non-deterministic selection only. Our work incorporates ideas from serializability and atomicity in databases [2], notions of objects and inheritance [19], Communicating Sequential Processes <ref> [15] </ref>, i/o automata [17], and Temporal Logic of Actions [16]. A partial procedure is similar to a database (nested) transaction that may commit or abort; the procedure commits (to execute) if its precondition holds and its preprocedure commits, and it aborts otherwise. <p> A typical abort of a database transaction requires a rollback to a valid state. In Seuss, a partial procedure does not change the program state until it commits, and therefore, there is no need for a rollback. The form of a partial procedure is inspired by Communicating Sequential Processes <ref> [15] </ref>. 1.3. WHY SEUSS 17 Our model may be viewed as a special case of CSP because we disallow nested partial procedures. Seuss is an outgrowth of our earlier work on UNITY [5]. A UNITY program consists of statements each of which may change the program state.
Reference: [16] <author> L. Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Our work incorporates ideas from serializability and atomicity in databases [2], notions of objects and inheritance [19], Communicating Sequential Processes [15], i/o automata [17], and Temporal Logic of Actions <ref> [16] </ref>. A partial procedure is similar to a database (nested) transaction that may commit or abort; the procedure commits (to execute) if its precondition holds and its preprocedure commits, and it aborts otherwise. A typical abort of a database transaction requires a rollback to a valid state.
Reference: [17] <author> N. Lynch and M. Tuttle. </author> <title> An introduction to input/output automata. </title> <journal> CWI-Quarterly, </journal> <volume> 2(3) </volume> <pages> 219-246, </pages> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: That is why we propose that the component actions of a multiprogram be executed using a form of repeated non-deterministic selection only. Our work incorporates ideas from serializability and atomicity in databases [2], notions of objects and inheritance [19], Communicating Sequential Processes [15], i/o automata <ref> [17] </ref>, and Temporal Logic of Actions [16]. A partial procedure is similar to a database (nested) transaction that may commit or abort; the procedure commits (to execute) if its precondition holds and its preprocedure commits, and it aborts otherwise.
Reference: [18] <author> Zohar Manna and Amir Pnueli. </author> <title> The temporal logic of reactive and concurrent systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In this view, a P operation on a semaphore is a partial procedure because it may never terminate whereas a V operation is a total procedure. A total procedure models wait-free, or transformational , aspects of programming and a partial procedure models concurrent, or reactive, aspects of programming <ref> [18] </ref>. Our programming model does not include waiting as a fundamental concept; therefore, a (partial) procedure does not wait, but it rejects the call, thus preserving the program state.
Reference: [19] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall international, </publisher> <address> London, </address> <year> 1988. </year>
Reference-contexts: That is why we propose that the component actions of a multiprogram be executed using a form of repeated non-deterministic selection only. Our work incorporates ideas from serializability and atomicity in databases [2], notions of objects and inheritance <ref> [19] </ref>, Communicating Sequential Processes [15], i/o automata [17], and Temporal Logic of Actions [16]. A partial procedure is similar to a database (nested) transaction that may commit or abort; the procedure commits (to execute) if its precondition holds and its preprocedure commits, and it aborts otherwise.
Reference: [20] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> International Series in Computer Science, </booktitle> <editor> C. A. R. </editor> <booktitle> Hoare, Series Editor. Prentice-Hall International, </booktitle> <address> London, </address> <year> 1989. </year>
Reference-contexts: No specific communication or synchronization mechanism, except the procedure call, is built into the model. In particular, the notions of input/output and their complementary nature in rendezvous-based communication <ref> [15, 20] </ref> is outside this model. There is no distinction between computation and communication; process specifications and interface specifications are not distinguished. Consequently, we do not have many of the traditional multiprogramming concepts such as, processes, locking, rendezvous, waiting, interference and deadlock, as basic concepts in our model. <p> A consequence of having a single thread is that the notion of waiting has to be abandoned, because a thread can afford to wait only if there is another thread whose execution can terminate its waiting; rendezvous-based interactions <ref> [15, 20] </ref> that require at least two threads of control to be meaningful, have to be abandoned in this model of execution. We have replaced waiting by the refusal of a procedure to execute.
Reference: [21] <author> Jayadev Misra. </author> <title> A logic for concurrent programming: Progress. </title> <journal> Journal of Computer and Software Engineering, </journal> <volume> 3(2) </volume> <pages> 273-300, </pages> <year> 1995. </year>
Reference-contexts: We have developed a simple logic for UNITY (for some recent developments, see [22], <ref> [21] </ref>, [6]) that is applicable to Seuss as well. 18 CHAPTER 1. INTRODUCTION Chapter 2 A Publication Notation The goal of this chapter is to propose a programming model and a publication notation.
Reference: [22] <author> Jayadev Misra. </author> <title> A logic for concurrent programming: Safety. </title> <journal> Journal of Computer and Software Engineering, </journal> <volume> 3(2) </volume> <pages> 239-272, </pages> <year> 1995. </year>
Reference-contexts: We have developed a simple logic for UNITY (for some recent developments, see <ref> [22] </ref>, [21], [6]) that is applicable to Seuss as well. 18 CHAPTER 1. INTRODUCTION Chapter 2 A Publication Notation The goal of this chapter is to propose a programming model and a publication notation.
Reference: [23] <author> R.L. Rivest, A.Shamir, and L. Adelman. </author> <title> A method for obtaining digital signatures and public key cryptosystems. </title> <journal> Communications of the ACM, </journal> <volume> 21(2) </volume> <pages> 120-126, </pages> <month> February </month> <year> 1978. </year>
Reference-contexts: A determined intruder could attempt to guess the holder's ticket value in a series of attempts. If this box is to be used in an environment where malice rules, it should be enclosed within a box that thwarts such access by using digital signatures <ref> [9, 23] </ref>, for instance. The current implementation guards against errors caused by poor programming or hardware malfunction.
Reference: [24] <author> R. A. Scantlebury, K. A. Bartlett, and P.T. Wilkinson. </author> <title> A note on reliable full-duplex transmission over half-duplex links. </title> <journal> Communications of the ACM, </journal> <volume> 12(5) </volume> <pages> 260-261, </pages> <month> May </month> <year> 1969. </year>
Reference-contexts: This fault model of a channel is assumed in the Alternating Bit Protocol <ref> [24] </ref>. Such a protocol can be studied (proved correct) by encoding the communication between the sender and the receiver using FaultyChannel . 3.3 A Problem due to Conway The following problem, due to Conway [7], has become a benchmark in assessing multiprogramming language features. <p> To implement the precondition for reading, we associate a sequence number with the value stored in v. It is sufficient to have a 1-bit sequence number, a boolean variable t, as in the Alternating Bit Protocol for communication over a faulty channel <ref> [24] </ref>. A read operation has a boolean argument, s, that is the last sequence number read by this reader. If s and t match then the reader has already read this value and, hence, the call upon read is rejected.
References-found: 24

