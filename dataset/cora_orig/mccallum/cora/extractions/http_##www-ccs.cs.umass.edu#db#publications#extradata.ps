URL: http://www-ccs.cs.umass.edu/db/publications/extradata.ps
Refering-URL: http://www-ccs.cs.umass.edu/db/publications/
Root-URL: 
Email: nhg@research.bell-labs.com  krithi@cs.umass.edu  jai@cs.wisc.edu  oshmu@cs.technion.ac.il  
Title: Accessing Extra-Database Information: Concurrency Control and Correctness  
Author: Narain Gehani Krithi Ramamritham Jayavel Shanmugasundaram Oded Shmueli 
Note: Partially supported by the National Science Foundation under grant IRI-9619588. Currently at the  
Date: February 1998  
Address: Israel  
Affiliation: Lucent Bell Laboratories  University of Massachusetts  University of Massachusetts  Technion  University of Wisconsin-Madison.  
Abstract: Traditional concurrency control theory views transactions in terms of read and write operations on database items. Thus, the effects of accessing non-database entities, such as the system clock or the log, on a transaction's behavior are not explicitly considered. In this paper, we are motivated by a desire to include accesses to such extra-data items within the purview of transaction and database correctness. We provide a formal treatment of concurrency control when transactions are allowed access to extra-data by discussing the inter-transaction dependencies that are induced when transactions access extra-data. We also develop a spectrum of correctness criteria that apply when such transactions are considered and outline mechanisms to enforce these criteria. Furthermore, we show that allowing databases to view data which has been traditionally kept hidden from users increases the database functionality and in many cases can lead to improved performance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. A. Bernstein, V. Hadzilacos and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley (1987). </publisher>
Reference-contexts: Note that serializability with respect to the set of axioms 13 K may, by itself, specify a correctness criterion (like, for example, serializability over the extended database). We return to this issue in section 6. Extra-data independence of transaction programs assures view serializability <ref> [1] </ref> (though not necessarily conflict serializability) of instances of the conventional transaction programs which are equivalent to the transactions which access extra data. <p> A formal proof of the extra-data independence of transaction programs for this example is given in section 7.1. 5.1.6 Audit Queries on Logs Logs of operations performed by transactions are normally written for transaction recovery purposes <ref> [1] </ref>. These logs can also serve as an audit trail to track the progress of transactions in the transaction management system. In this example, we explore the use of the log as an audit trail. <p> We assume here that the changes done by a transaction can be undone upon its abort without forming further C relationships. This is a valid assumption if transactions perform read and write operations on data <ref> [1] </ref>. Theorem: Given a set of existing C relationships defined on committed operations, it is always possible to force transactions' operations, including those on the log, to occur in an order such that C fl (defined on committed operations) will be acyclic. <p> We first discuss how C relationships can be tracked for concurrency control and then outline concurrency control mechanisms for each correctness criterion. C relationships could be enforced in a manner similar to the Serialization Graph Testing (SGT) <ref> [1] </ref> concurrency control technique. In this technique, a serialization graph is maintained in order to perform concurrency control. An edge (t i ; t j ) exists in the serialization graph iff transaction t i performs a conflicting operation on an object before transaction t j . <p> If so, the operation is rejected, else it is performed. In the Conservative SGT, operations may be delayed before being scheduled in order to reduce the number of rejected operations. Algorithms for distributed SGT <ref> [1] </ref> have also been proposed. The Serialization Graph Testing technique could be adapted in order to enforce C relationships induced by a set of axioms K. <p> We now outline implementation techniques for the correctness criteria proposed in Section 5. * Serializability over Database: This is the easiest correctness criterion to enforce because traditional concurrency control techniques can be directly applied <ref> [1] </ref>. This is because traditional concurrency control is performed on just the database and serializability is the commonly enforced correctness criterion. * Serializability over the Extended Database: There are two main ways in which Serializ-ability over the Extended Database can be enforced.
Reference: [2] <author> P. K. Chrysanthis and K. Ramamritham. </author> <title> Synthesis of Extended Transaction Models Using ACTA. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 19, No. 3, </volume> <month> 450-491 (Sep </month> <year> 1994). </year>
Reference-contexts: Thus new mechanisms for concurrency control should be devised to deal with such properties of extra-data. These issues are treated in detail in subsequent sections. 3 Preliminaries and Definitions In this section we introduce a simple formalism based on the ACTA transaction framework <ref> [2] </ref>. <p> If P t = , then these axioms reduce to those of traditional atomic transactions <ref> [2] </ref>. The above axioms take care of the case in which it may not be possible to undo certain operations performed by (or due to) a transaction even if it aborts. <p> Suppose t j has done a write on an object and then t i does a read on the same object. Then, (t j C t i ). Also, if we desire failure atomicity, then if t j aborts then t i must also abort. Thus, abort dependencies <ref> [2] </ref> between transactions may also form due to conflicting operations. However, when we extend the notion of serializability to the extended database, we have to take into account the fact that the execution of a transaction may not be atomic over the extended database. <p> Thus, we require that if a transaction t i uses up the space freed by transaction t j , then t i should abort whenever t j aborts (so that the space freed by t j is now free). Thus t i has an abort dependency <ref> [2] </ref> on t j . Note that there are no C relationships induced due to accesses to the extra-data item (because the page space map table is not used in any way which might affect the state of the database) but instead, an abort dependency is induced.
Reference: [3] <author> D. Georgakopoulos, M. Rusinkiewicz and A. Sheth. </author> <title> On Serializability of Multidatabase Transactions through Forced Local Conflicts. </title> <booktitle> In Proceedings of the IEEE Seventh International Conference on Data Engineering (1991). </booktitle>
Reference-contexts: A detailed proof of the extra-data independence of proclamation transactions appears in [5]. 18 5.1.5 Serializability in Multi-databases Another example of extra-data independent transaction programs occurs in the multi-database concurrency control scheme proposed in <ref> [3] </ref>. Here, to ensure the serializability of transactions that access multiple (autonomous) database sites, the following scheme is used. Every site has a special "ticket" that all global transactions that visit the database at that site are expected to write.
Reference: [4] <author> N. Gehani and O. Shmueli. </author> <title> The LOG as Part of the Database. </title> <institution> Bell Laboratories Technical Memorandum (1992). </institution>
Reference-contexts: Traditional database systems hide recovery data from the user. Eliminating this restriction, that is, storing such data as just another object that can be accessed by any user has many benefits <ref> [12, 4] </ref>. Users can pose queries on the log that cannot be specified in traditional database systems and queries that were not envisioned by the system designers. <p> For concreteness, we consider the database log as an example of extra-data which can be accessed by transactions in the course of their execution <ref> [4] </ref>. Both committing and aborting transactions write log records. Transactions can also read the log to perform queries. We require serializability of all the data items in the extended database, in this case, the database plus the log.
Reference: [5] <author> N. Gehani, K. Ramamritham, J. Shanmugasundaram and O. Shmueli. </author> <title> Accessing Extra Database Information: Concurrency Control and Correctness. </title> <type> Technical Report 1996-016, </type> <institution> University of Massachusetts, Amherst, Massachusetts, </institution> <year> 1996. </year>
Reference-contexts: These proclamation data items can be treated as extra data items with the required correctness criterion being the extra-data independence of transactions. A detailed proof of the extra-data independence of proclamation transactions appears in <ref> [5] </ref>. 18 5.1.5 Serializability in Multi-databases Another example of extra-data independent transaction programs occurs in the multi-database concurrency control scheme proposed in [3]. Here, to ensure the serializability of transactions that access multiple (autonomous) database sites, the following scheme is used.
Reference: [6] <author> J.N. Gray and A. Reuter. </author> <title> Transaction Processing: </title> <booktitle> Techniques and Concepts. </booktitle> <month> Morgan-Kaufman </month> <year> (1992). </year>
Reference-contexts: Since relaxing correctness requirements is one way to achieve this, serious consideration must be given to it. Let us now consider some weakened isolation requirements <ref> [6] </ref> that have been suggested and adopted in practice for transactions accessing the database. In the context of read/write objects, degree-2 isolation ignores conflicts resulting from a read followed by a write. Such a requirement leads to lack of repeatable reads.
Reference: [7] <author> H.V. Jagadish and O. Shmueli. </author> <title> A Proclamation-Based Model for Cooperating Transactions. </title> <booktitle> In Proceedings of the eighteenth International Conference on Very Large Databases, </booktitle> <month> 265-276 </month> <year> (1992). </year>
Reference-contexts: If a transaction knows the set of possible values it will write to a data item, it can proclaim this to other transactions, which may then be in a position to proceed without waiting for this transaction to relinquish its lock on the data item <ref> [7] </ref>. Estimate of execution time and data requirements of transactions. These will be useful for dealing with transactions in real-time database systems [11]. <p> However, suppose t 1 gives t 2 (or any other transaction) an indication of all the possible values it might write, then t 2 might be able to proceed with its computations using this information, thus increasing the degree of concurrency. This is the idea underlying proclamations <ref> [7] </ref>. t 1 proclaims the set of possible values that may be written so that transactions such as t 2 may be able to proceed without waiting. These proclamation data items can be treated as extra data items with the required correctness criterion being the extra-data independence of transactions.
Reference: [8] <author> H. F. Korth and G. Speegle. </author> <title> Formal Aspects of Concurrency Control in Long-Duration Transaction Systems Using the NT/PV Model. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 19, No. 3, </volume> <month> 492-535 (Sep </month> <year> 1994). </year>
Reference-contexts: Some of the other approaches include looking at serializability over a subset of data items [13] and relaxing the serializability correctness criterion by imposing instead specific constraints on acceptable schedules <ref> [8] </ref>. The work reported herein bears resemblance to these extensions in that, technically, we also view extra-data as objects with arbitrary operations defined on them and impose some restrictions on acceptable schedules.
Reference: [9] <author> C. Mohan and D. Haderle. </author> <title> Algorithms for Flexible Space Management in Transaction Systems Supporting Fine-Granularity Locking. </title> <booktitle> In Proc. 4th International Conference on Extending Database Technology, </booktitle> <month> 1-13 (March </month> <year> 1994). </year>
Reference-contexts: While the failure recovery semantics of extra-data items accessed by transactions is usually comparable to that of database items (for example, updates to the page space map tables, which are extra-data items, are normally logged <ref> [9] </ref>, see Section 5.1.3), the recovery of extra-data items after transaction aborts may not be possible. The reason for this is twofold. <p> Now tp 1 does not require exact values of the data item X iff tp 2 and tp 3 are extra data independent (with respect to serializability over the database). 5.1.3 Page Space Map Tables Page space map tables <ref> [9] </ref> are commonly used in databases to indicate the location of free space in pages. These tables are normally accessed by transactions, though they are not 17 considered as database items and brought within the scope of correctness and concurrency control. <p> In addition, in order to provide for transaction roll back (in case of transaction abort), we may need to specify that a transaction can reclaim the space it freed (in the event of it aborting) so that its changes can be undone easily <ref> [9] </ref>. Thus, we require that if a transaction t i uses up the space freed by transaction t j , then t i should abort whenever t j aborts (so that the space freed by t j is now free). <p> In normal implementations of the page space map tables, a transaction t j can use the space freed by a transaction t i only if t i has committed <ref> [9] </ref>. Thus, this induced abort dependency is taken care of and only serializability over accesses to the database items need be ensured. 5.1.4 Proclamation Locking Consider the following example in which 2PL is used for concurrency control.
Reference: [10] <author> K. Ramamritham and P. K. Chrysanthis. </author> <title> A Taxonomy of Correctness Criteria in Database Applications. </title> <booktitle> In VLDB (Very Large Data Bases) Journal, </booktitle> <volume> Vol. 5, No. 1, </volume> <month> 85-97 (Jan </month> <year> 1996). </year>
Reference-contexts: The definition of serializability remains the same, where acyclicity is ensured with respect to this C relation. As mentioned earlier, an application may desire correctness properties that are weaker than serializability when an extended database is used. A discussion of such correctness properties can be found in <ref> [10] </ref> and some examples of their application to extra-data are presented in section 5.4. For the purposes of this paper, given an extended database, we can consider (1) serializability of accesses to data items in the extended database (2) serializability of accesses to data items in the database.
Reference: [11] <author> K. Ramamritham. </author> <title> Real-Time Databases. </title> <journal> International Journal of Distributed and Parallel Databases, </journal> <volume> Vol. 1, No 2, </volume> <month> 199-226 </month> <year> (1993). </year>
Reference-contexts: Estimate of execution time and data requirements of transactions. These will be useful for dealing with transactions in real-time database systems <ref> [11] </ref>. For example, if it is possible for a transaction to realize that there is not enough time left for it to complete execution or that a feasible schedule is not possible, it could instead invoke an alternative, with a lower computational requirement. 4 * Concurrency status of data items. <p> However, this criterion is weaker than serializability in the sense that we allow for non-repeatable reads to the clock. Another example in which clocks are accessed as extra-data items occurs in the context of real-time databases <ref> [11] </ref>. In this case, transactions have a correctness requirement which is stronger than traditional serializability in the sense that we have the additional requirement that if a transaction t i commits, it should commit before its deadline, deadline (t i ).
Reference: [12] <author> M. R. Stonebraker. </author> <title> Hypothetical Data Bases as Views. </title> <booktitle> Proc. ACM-SIGMOD 1981 Int'l Conf. on Management of Data, </booktitle> <month> 224-229 (May </month> <year> 1981). </year>
Reference-contexts: Traditional database systems hide recovery data from the user. Eliminating this restriction, that is, storing such data as just another object that can be accessed by any user has many benefits <ref> [12, 4] </ref>. Users can pose queries on the log that cannot be specified in traditional database systems and queries that were not envisioned by the system designers.
Reference: [13] <author> K. Vidyasankar. </author> <title> Generalized Theory of Serializability. </title> <journal> Acta Informatica, </journal> <volume> Vol. 24, </volume> <month> 105-119 </month> <year> (1987). </year>
Reference-contexts: Thus, this notion of serializability differs from that in <ref> [13] </ref> where serializability over a subset of data items (in this case, the database items) implies that if we rerun the programs according to the serial schedule, we would get the same overall state for that subset of data items. 5.4 Application Specific Correctness of Accesses to Extra-Data Thus far, we <p> One approach extends and elaborates the structure of data items, viewing them as abstract data type objects thus exploiting the semantics of the operations for better concurrency control [14]. Some of the other approaches include looking at serializability over a subset of data items <ref> [13] </ref> and relaxing the serializability correctness criterion by imposing instead specific constraints on acceptable schedules [8]. The work reported herein bears resemblance to these extensions in that, technically, we also view extra-data as objects with arbitrary operations defined on them and impose some restrictions on acceptable schedules.
Reference: [14] <author> W. Weihl. </author> <title> Commutativity-Based Concurrency Control for Abstract Data Types. </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 37, No. 12, </volume> <month> 1488-1505 (Dec </month> <year> 1988). </year> <month> 35 </month>
Reference-contexts: The extra-database is, for purposes of concurrency control, treated like any other data item and serializability is applied without differentiating between database items and extra-data items. One implication of this is that techniques for improving performance, such as exploiting the semantics of operations <ref> [14] </ref>, can be applied to both database and extra-data items. 5.3 Serializable Accesses to the Database In this section, we give some examples of cases where we require serializability over only the database in the presence of extra-data dependent transaction programs. <p> One approach extends and elaborates the structure of data items, viewing them as abstract data type objects thus exploiting the semantics of the operations for better concurrency control <ref> [14] </ref>. Some of the other approaches include looking at serializability over a subset of data items [13] and relaxing the serializability correctness criterion by imposing instead specific constraints on acceptable schedules [8].
References-found: 14

