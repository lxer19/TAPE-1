URL: ftp://www.elet.polimi.it/pub/data/Pierguido.Caironi/jmsi96.ps.gz
Refering-URL: http://www.elet.polimi.it/~caironi/listpub.html
Root-URL: 
Email: Email: sami@elet.polimi.it  
Phone: Phone +39 2 2399 3516 fax +39 2 2399 3411  
Title: Context Reorder Buffer: an Architectural Support for Real-Time Interrupt Processing in RISC Superscalar CPU Architectures
Author: Pierguido V.C. CAIRONI, Lorenzo MEZZALIRA, Mariagiovanna SAMI Mariagiovanna SAMI 
Address: ITALY  Piazza Leonardo da Vinci 32 20133 Milano ITALY  
Affiliation: Dipartimento di Elettronica e Informazione Politecnico di Milano Milano  Dipartimento di Elettronica e Informazione Politecnico di Milano  
Note: Title:  Authors affiliation:  Running head:  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. E. Smith and A. R. Pleszkun, </author> <title> Implementing Precise Int errupts in Pipelined Processors, </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 37, No. 5, </volume> <pages> pp. 562-573, </pages> <year> 1988. </year>
Reference-contexts: Solutions like c), which explicitly reconstruct a state consistent with a definite return address before starting the interrupt service, are called precise interrupts, while solutions like a) and b) are called imprecise interrupts <ref> [1] </ref>. The concept of precision may be applied to exceptions as well. If the exception is precise, the excepting process may be easily restarted after the interrupt handler has solved the cause of 5 the exception. <p> If the exception is not precise, the state of the machine is not consistent with the return address and the exception handler has to reconstruct a precise state before restarting the excepting process. Published precise solutions are: in-order instruction completion , reorder buffer , history buffer, future file <ref> [1] </ref>, register update unit [3] and checkpoint repair mechanism [4]. Imprecise solutions, besides solutions a) and b), include among others the invisible exchange packet [5]. <p> Processors specifically designed for real-time applications tend to adopt more conservative approaches which, while being usually less aggressive as computing power than the ones already mentioned, grant lower and much more predictable interrupt handling 6 latencies (instances of these approaches are linear pipelines <ref> [1] </ref>, tightly coupled pipelines [15], shadow registers or stacks [6]). Current computational requirements of real-time applications are however pushing these solutions to their architectural limits and some real-time processors with more aggressive architectures are appearing (e.g., Motorola 88110 [16]). <p> The present paper offers a hardware solution to the problem of real-time interrupt handling in a deeply pipelined RISC superscalar architecture. This solution (based on the reorder buffer concept <ref> [1] </ref>) assures precise interrupts and exceptions, does not require any change to the programming model of standard RISC processors and grants that the interrupt handler fetching starts the clock cycle after the interrupt handler address has been loaded from the interrupt vector. <p> The CRB architecture In this section we introduce the main concepts of the CRB functionality. Further details on structural implementation and functional characteristics will be given in Sections 4 and 5. The CRB ensues from reorder buffer (RB) architecture as presented by Smith and Pleszkun <ref> [1] </ref>. Therefore, before describing CRB let us summarize the standard RB. <p> The entry fields, which are required to store proper piece of information, are denoted with a dot notation, such as in CRB [.].field_name. Therefore, the CRB entry fields (some of them taken by Smith and Pleszkun <ref> [1] </ref>) are: CRB [.].dest_regs: encoding of the destination registers of the instruction CRB [.].results: encoding of the instructions results (in case of a branch instruction, it stores the computed target of the branch). 16 CRB [.].exception: encoding of the possible type of exception caused by the instruction.
Reference: [2] <author> D. A. Patterson and J. L. Hennessy, </author> <title> Computer Organization & Design: </title> <publisher> the Hardware/Software Interface , Morgan Kaufmann Publishers, </publisher> <address> San Mateo, California, </address> <year> 1994. </year>
Reference-contexts: 1. Introduction Initially conceived as high-performance CPUs for workstation-class computers, RISC CPUs <ref> [2] </ref> are now also proposed as core devices for embedded real-time systems.
Reference: [3] <author> G. S. Sohi, </author> <title> Instruction Issue Logic for High-Performance, Interruptible, Multiple Functional Unit, Pipelined Computers, </title> <journal> IEEE Transactions on Computers , Vol. </journal> <volume> 39, No. 3, </volume> <pages> pp. 349-359, </pages> <year> 1990. </year>
Reference-contexts: Published precise solutions are: in-order instruction completion , reorder buffer , history buffer, future file [1], register update unit <ref> [3] </ref> and checkpoint repair mechanism [4]. Imprecise solutions, besides solutions a) and b), include among others the invisible exchange packet [5].
Reference: [4] <author> W. W. Hwu and Y. N. Patt, </author> <title> Checkpoint Repair for High-Pe rformance Out-of-Order Execution Machines, </title> <journal> IEEE Transactions on Computers , Vol. </journal> <volume> C-36, No. 12, </volume> <pages> pp. 1496-1514, </pages> <year> 1987. </year>
Reference-contexts: Published precise solutions are: in-order instruction completion , reorder buffer , history buffer, future file [1], register update unit [3] and checkpoint repair mechanism <ref> [4] </ref>. Imprecise solutions, besides solutions a) and b), include among others the invisible exchange packet [5].
Reference: [5] <author> Control Data Corp, </author> <title> CDC CYBER 200 Model 205 Computer System Hardware Reference Manual, </title> <type> Arden Hills, </type> <institution> MN, </institution> <year> 1981. </year>
Reference-contexts: Published precise solutions are: in-order instruction completion , reorder buffer , history buffer, future file [1], register update unit [3] and checkpoint repair mechanism [4]. Imprecise solutions, besides solutions a) and b), include among others the invisible exchange packet <ref> [5] </ref>. In practice, due to simplicity and cost requirements, in current implemented architectures interrupts and exceptions are made precise only if process recovery is strictly required (such as in the case of TLB miss, or unimplemented code exceptions).
Reference: [6] <author> W. Walker and H. G. Cragon, </author> <title> Interrupt Processing in Concurrent Processors, </title> <journal> IEEE Computer, </journal> <volume> Vol. 28, No. 6, </volume> <pages> pp. 36-46, </pages> <year> 1995. </year>
Reference-contexts: designed for real-time applications tend to adopt more conservative approaches which, while being usually less aggressive as computing power than the ones already mentioned, grant lower and much more predictable interrupt handling 6 latencies (instances of these approaches are linear pipelines [1], tightly coupled pipelines [15], shadow registers or stacks <ref> [6] </ref>). Current computational requirements of real-time applications are however pushing these solutions to their architectural limits and some real-time processors with more aggressive architectures are appearing (e.g., Motorola 88110 [16]).
Reference: [7] <author> J. E. Smith and S. Weiss, </author> <title> PowerPC 601 and Alpha 21064: A Tale of Two RISCs, </title> <journal> IEEE Computer, </journal> <volume> Vol. 27, No. 6, </volume> <pages> pp. 46-58, </pages> <year> 1994. </year>
Reference: [8] <author> J. H. Edmondson, P. Rubinfield, R. Preston and V. Rajagopalan, </author> <title> Superscalar Instruction Execution in the 21164 Alpha Microprocessor, </title> <journal> IEEE Micro, </journal> <volume> Vol. 15, No. 2, </volume> <pages> pp. 33-43, </pages> <year> 1995. </year> <month> 30 </month>
Reference: [9] <author> S. Weiss and J. E. Smith, </author> <title> POWER and PowerPC: </title> <booktitle> Principles, Architecture and Implementation, </booktitle> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Francisco, California, </address> <year> 1994. </year>
Reference: [10] <author> T. Potter, M. Vaden, J. Young and N. Ullah, </author> <title> Resolution of Data and Control-Flow Dependencies in the PowerPC 601, </title> <journal> IEEE Micro, </journal> <volume> Vol. 14, No. 5, </volume> <pages> pp. 18-29, </pages> <year> 1994. </year>
Reference: [11] <author> S. P. Song, M. Denman and J. Chang, </author> <title> The PowerPC 604 RISC Microprocessor, </title> <journal> IEEE Micro, </journal> <volume> Vol. 14, No. 5, </volume> <pages> pp. 8-17, </pages> <year> 1994. </year>
Reference-contexts: Interface with the precise state This section of the CRB interface logic deals with instruction results committing, exception activation and speculative execution. This control logic is purely combinatorial and its complexity is comparable with that of the control logic of many current implementations of the reorder buffer <ref> [11] </ref>. 20 The CRB commit control logic is organized referring to a number of different functions. Each function relates to a specific condition on the contents of the two entries of the CRB pointed to by head and inc_head (see Table 1).
Reference: [12] <author> S. Mirapuri, M. Woodacre and N. Vasseghi, </author> <title> The MIPS R4000 Processor, </title> <journal> IEEE Micro, </journal> <volume> Vol. 12, No. 2, </volume> <pages> pp. 10-22, </pages> <year> 1992. </year>
Reference: [13] <author> G. Kane and J. Heinrich, </author> <title> MIPS, RISC Architecture, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference: [14] <author> T. R. </author> <title> Halfhill, </title> <journal> Intels P6, BYTE, </journal> <volume> Vol. 20, No. 4, </volume> <pages> pp. 42-58, </pages> <year> 1995. </year>
Reference: [15] <author> J. Circello, G. Edgington, D. McCarthy, J. Gay, D. Schimke, S. Sullivan, R. Duerden, C. Hinds, D. Marquette, L. Sood, A. Crouch and D. Chow, </author> <title> The Superscalar Architecture of the MC68060, </title> <journal> IEEE Micro, </journal> <volume> Vol. 15, No. 2, </volume> <pages> pp. 10-21, </pages> <year> 1995. </year>
Reference-contexts: Processors specifically designed for real-time applications tend to adopt more conservative approaches which, while being usually less aggressive as computing power than the ones already mentioned, grant lower and much more predictable interrupt handling 6 latencies (instances of these approaches are linear pipelines [1], tightly coupled pipelines <ref> [15] </ref>, shadow registers or stacks [6]). Current computational requirements of real-time applications are however pushing these solutions to their architectural limits and some real-time processors with more aggressive architectures are appearing (e.g., Motorola 88110 [16]).
Reference: [16] <author> K. Diefendorff and M. Allen, </author> <title> Organization of the Motorola 88110 Superscalar RISC Microprocessor, </title> <journal> IEEE Micro, </journal> <volume> Vol. 12, No. 2, </volume> <pages> pp. 40-63, </pages> <year> 1992. </year>
Reference-contexts: Current computational requirements of real-time applications are however pushing these solutions to their architectural limits and some real-time processors with more aggressive architectures are appearing (e.g., Motorola 88110 <ref> [16] </ref>). The present paper offers a hardware solution to the problem of real-time interrupt handling in a deeply pipelined RISC superscalar architecture.
Reference: [17] <author> R. M. Tomasulo, </author> <title> An Efficient Algorithm for Exploiting Multiple Arithmetic Units, </title> <journal> IBM Journal, </journal> <volume> Vol. 11, </volume> <pages> pp. 25-33, </pages> <month> January </month> <year> 1967. </year>
Reference-contexts: In the case of incorrect branch prediction, correct instruction sequencing for branch instructions is checked in the CRB before committing the branch instruction. Decode: decode stage. 8 Reservation stations: initially proposed by Tomasulo <ref> [17] </ref> and further extended by Weiss and Smith [18], they manage data-dependencies and availability of registers. Instructions wait in reservation stations for their operands to be available. Depending on data dependencies, instructions may exit the reservation stations out of program order even if they entered in program order.
Reference: [18] <author> S. Weiss and J. E. Smith, </author> <title> Instruction issue logic in pipelined supercomputers, </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. C-33, No. 11, </volume> <pages> pp. 1013-1022, </pages> <year> 1984. </year> <month> 31 </month>
Reference-contexts: In the case of incorrect branch prediction, correct instruction sequencing for branch instructions is checked in the CRB before committing the branch instruction. Decode: decode stage. 8 Reservation stations: initially proposed by Tomasulo [17] and further extended by Weiss and Smith <ref> [18] </ref>, they manage data-dependencies and availability of registers. Instructions wait in reservation stations for their operands to be available. Depending on data dependencies, instructions may exit the reservation stations out of program order even if they entered in program order.
References-found: 18

