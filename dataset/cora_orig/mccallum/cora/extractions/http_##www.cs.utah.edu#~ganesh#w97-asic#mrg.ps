URL: http://www.cs.utah.edu/~ganesh/w97-asic/mrg.ps
Refering-URL: http://www.cs.utah.edu/~ganesh/w97-asic/
Root-URL: 
Email: ftesfaye,ckern,mrgg@cs.ubc.ca  
Title: Verifying a Self-Timed Divider  
Author: Tarik Ono-Tesfaye Christoph Kern Mark R. Greenstreet 
Address: Vancouver, BC V6T 1Z4 Canada  
Affiliation: Department of Computer Science University of British Columbia  
Abstract: This paper presents an approach to verifying timed designs based on refinement: first, correctness is established for a speed-independent model; then, the timed design is shown to be a refinement of this model. Although this approach is less automatic than methods based on timed state space enumeration, it is tractable for larger designs. Our method is implemented using a proof checker with a built-in model checker for verifying properties of high-level models, a tautology checker for establishing refinement, and a graph-based timing verification procedure for showing timing properties of transistor level models. We demonstrate the method by proving the timing correctness of Williams' self-timed divider. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport. </author> <title> An old-fashioned recipe for real time. </title> <editor> In J. de Bakker et al., editors, </editor> <booktitle> Proceedings of the REX Workshop, "Real-Time: Theory in Practice". </booktitle> <publisher> Springer, </publisher> <year> 1992. </year> <note> LNCS 600. </note>
Reference-contexts: The order in which transitions are selected is unspecified: this non-determinism corresponds to arbitrary delays in a speed-independent model. To model bounded delays, we introduce a real-valued variable, t , whose value corresponds to the current time (see <ref> [1] </ref>).
Reference: [2] <author> R. Alur, T. Henzinger, and P.-H. Ho. </author> <title> Automatic symbolic verification of embedded systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(3) </volume> <pages> 181-201, </pages> <year> 1996. </year>
Reference-contexts: Many researchers have recognized the need for verification of designs that have critical delay dependencies. Timed automata provide a theoretical framework for modeling such designs, and in principle, many properties of such automata are decidable [11]. Several tools have been implemented based on various timed automata models <ref> [15, 2, 3, 24] </ref>. Although fully automatic, the high computational complexity of these automata based models have limited their application to models much simpler than typical self-timed designs.
Reference: [3] <author> W. Belluomini and C. J. Myers. </author> <title> Efficient timing analysis algorithms for timed state space exploration. </title> <booktitle> In Proceedings of the 1997 International Symposium on Advanced Research in Asynchronous Circuits and Systems, </booktitle> <pages> pages 88-100. </pages> <publisher> IEEE, </publisher> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: Many researchers have recognized the need for verification of designs that have critical delay dependencies. Timed automata provide a theoretical framework for modeling such designs, and in principle, many properties of such automata are decidable [11]. Several tools have been implemented based on various timed automata models <ref> [15, 2, 3, 24] </ref>. Although fully automatic, the high computational complexity of these automata based models have limited their application to models much simpler than typical self-timed designs.
Reference: [4] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: The application of the wp operator can be done either by explicitly enumerating the states satisfying Q and each successive application of wp or by symbolic means such as Binary Decision Diagrams <ref> [4, 5] </ref>. When model checking is used in this1=) paper, we use a symbolic approach. The predicate Q is a safety property of P iff Q 0 ) win (P; Q). <p> Similar to HOL, the user interface of the checker is the ML interactive top level. 4.2 General Purpose Decision Procedures The proof checker includes a library that provides decision procedures for propositional logic and linear inequalities. The propositional logic decision procedure is based on Binary Decision Diagrams <ref> [4, 5] </ref>; to allow the treatment of non-trivial problems, we have integrated a state-of-the-art BDD package [?] into the SML/NJ runtime system.
Reference: [5] <author> R. E. Bryant. </author> <title> Symbolic boolean manipulation with Ordered Binary Decision Diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: The application of the wp operator can be done either by explicitly enumerating the states satisfying Q and each successive application of wp or by symbolic means such as Binary Decision Diagrams <ref> [4, 5] </ref>. When model checking is used in this1=) paper, we use a symbolic approach. The predicate Q is a safety property of P iff Q 0 ) win (P; Q). <p> Similar to HOL, the user interface of the checker is the ML interactive top level. 4.2 General Purpose Decision Procedures The proof checker includes a library that provides decision procedures for propositional logic and linear inequalities. The propositional logic decision procedure is based on Binary Decision Diagrams <ref> [4, 5] </ref>; to allow the treatment of non-trivial problems, we have integrated a state-of-the-art BDD package [?] into the SML/NJ runtime system.
Reference: [6] <author> J. Burch, E. Clarke, et al. </author> <title> Symbolic model checking for sequential circuit verification. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 13(4) </volume> <pages> 401-424, </pages> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: Often, finding an invariant requires the insight of the designer, and this approach is taken for some of the proofs in this paper. In some cases, invariants can be found automatically by model-checking <ref> [6] </ref>. Let win (P; Q) be the least fixpoint of wp (P ) starting from Q, i.e. apply the wp operator until it converges. If the state space of P is finite, this computation will converge in a finite number of steps.
Reference: [7] <author> J. J. F. Cavanagh. </author> <title> Digital Computer Arithmetic : Design and Implementation. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: The proof checker is described in section 4, and the proofs are presented in section 5. 2 The Divider The divider that we verified [29] implements the radix-2 SRT algorithm <ref> [7] </ref>. This algorithm is similar to the binary version of the traditional "paper-and-pencil" algorithm except that quotient bits are chosen from the set f1; 0; 1g instead of the more traditional f0; 1g.
Reference: [8] <author> E. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: The state space of a program is the cross-product of the ranges of the types of the variables of the program. A state is an element of the state space. Many properties of ST programs can be easily formulated using a wp semantics <ref> [8] </ref>. If P is a program and Q is a predicate, then wp (P; Q) is the weakest condition that must hold such that Q is guaranteed to hold after any single action allowed by P is performed.
Reference: [9] <author> M. J. Gordon. </author> <title> HOL: a proof generating system for higher-order logic. </title> <editor> In G. Birtwistle and P. Subrah-manyam, editors, </editor> <booktitle> VLSI Specification, Verification and Synthesis, </booktitle> <pages> pages 74-128. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1988. </year>
Reference-contexts: This section will briefly introduce the main characteristics of the proof checking environment and explain how the domain specific decision procedures mentioned above were embedded in the verification framework. 4.1 Light-weight proof checking Similar to theorem proving environments such as ACL2, HOL, ISABELLE or PVS <ref> [13, 9, 19, 18] </ref>, a (backwards-style) proof in our proof checker is represented as a sequence of proof states.
Reference: [10] <author> M. R. Greenstreet. </author> <title> A simple proof checker for timing verification. </title> <booktitle> In Proceedings of the 1995 Tau Workshop, </booktitle> <address> Seattle, </address> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: The procedure attempts to find a counterexample for a formula by rewriting its negation into sum-of-products form and solving the resulting linear programs <ref> [?, 10] </ref>. The latter step uses an implementation of the Simplex algorithm for linear programs with arbitrary coefficients.
Reference: [11] <author> T. Henzinger, P. Kopke, A. Puri, and P. Varaiya. </author> <booktitle> What's decidable about hybrid automata? In Proceedings of the 27th Annual Symposium on Theory of Computing, </booktitle> <pages> pages 373-382. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: Many researchers have recognized the need for verification of designs that have critical delay dependencies. Timed automata provide a theoretical framework for modeling such designs, and in principle, many properties of such automata are decidable <ref> [11] </ref>. Several tools have been implemented based on various timed automata models [15, 2, 3, 24]. Although fully automatic, the high computational complexity of these automata based models have limited their application to models much simpler than typical self-timed designs.
Reference: [12] <author> H. Hulgaard, S. M. Burns, T. Amon, and G. Borriello. </author> <title> An algorithm for exact bounds on the time separation of events in concurrent systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 44(11) </volume> <pages> 1306-1317, </pages> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: Several tools have been implemented based on various timed automata models [15, 2, 3, 24]. Although fully automatic, the high computational complexity of these automata based models have limited their application to models much simpler than typical self-timed designs. Hulgaard et. al. <ref> [12] </ref> avoid some of this state space explosion by using a task graph where dependencies are independent of data values. This allows them to verify timing properties of abstract models of sizable designs, but they cannot model dealys that depend on data values.
Reference: [13] <author> M. Kaufmann and J. S. Moore. ACL2: </author> <title> an industrial strength version of Nqthm. </title> <booktitle> In Proc. 11th Annual Conference on Computer Assurance (COMPASS '96), </booktitle> <pages> pages 23-34. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: This section will briefly introduce the main characteristics of the proof checking environment and explain how the domain specific decision procedures mentioned above were embedded in the verification framework. 4.1 Light-weight proof checking Similar to theorem proving environments such as ACL2, HOL, ISABELLE or PVS <ref> [13, 9, 19, 18] </ref>, a (backwards-style) proof in our proof checker is represented as a sequence of proof states. <p> In contrast to the more traditional embedding of decision procedures such as in ACL2 or PVS <ref> [13, 18] </ref>, our system encourages the development of domain-specific decision procedures, allowing the controlled introduction of formal, but not mechanically checked reasoning into proofs. The system has been implemented in SML/NJ. The parametrization of the core checker is realized by its implementation as an SML functor.
Reference: [14] <author> L. Lamport. </author> <title> win and sin: Predicate transformers for concurrency. </title> <type> Technical Report 17, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: A predicate Q is a safety property of P if Q holds in all states reachable in any execution of P . Let Q 0 be the initial state predicate of P . It can be shown (see <ref> [14] </ref>), that Q is a safety property of P if and only if there is an invariant I such that Q 0 ) I and I ) Q.
Reference: [15] <author> K. Larsen and F. Laroussinie. </author> <title> Compositional model checking of real time systems. </title> <booktitle> In Proceedings of CONCUR'95, </booktitle> <year> 1995. </year> <note> LNCS 962. </note>
Reference-contexts: Many researchers have recognized the need for verification of designs that have critical delay dependencies. Timed automata provide a theoretical framework for modeling such designs, and in principle, many properties of such automata are decidable [11]. Several tools have been implemented based on various timed automata models <ref> [15, 2, 3, 24] </ref>. Although fully automatic, the high computational complexity of these automata based models have limited their application to models much simpler than typical self-timed designs.
Reference: [16] <author> G. Matsubara and N. Ide. </author> <title> A low power zero-overhead self-timed division and square root unit. </title> <booktitle> In Proc. International Symposium on Advanced Research in Asynchronous Circuits and Systems. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: This design was chosen because includes several low-level optimizations including timing assumptions and extensive use of pre-charged logic. It is also the basis of several subsequent divider designs including a five-stage design [27] and a design based on static logic for lower power consumption <ref> [16] </ref>. In the remainder of this paper, the divider design is described in section 2, and section 3 outlines our verification stragegy for the divider. Our proofs were developed in a proof checker.
Reference: [17] <author> R. Miller. </author> <title> Switching Theory. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1965. </year>
Reference-contexts: This leads naturally to an iterative implementation, and the divider chip we verify uses the self-timed ring [28, 21] shown in figure 2. Data values are encoded using a dual-rail code [20] except for the quotient bits which are encoded using a three-wire, "one-hot" scheme <ref> [17] </ref>. Precharged logic is used throughout the design. Each stage can be in one of 2 three states: precharge, evaluate, or hold. Precharging leads to a state where every dual-rail signal produced by the stage has the "empty" value.
Reference: [18] <author> S. Owre, S. Rajan, J. Rushby, N. Shankar, and M. Sri-vas. PVS: </author> <title> Combining specification, proof checking, and model checking. </title> <editor> In R. Alur and T. A. Henzinger, editors, </editor> <booktitle> 8th International Conference on Computer-Aided Verification, CAV '96, number 1102 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> July/Aug. </address> <year> 1996. </year>
Reference-contexts: This section will briefly introduce the main characteristics of the proof checking environment and explain how the domain specific decision procedures mentioned above were embedded in the verification framework. 4.1 Light-weight proof checking Similar to theorem proving environments such as ACL2, HOL, ISABELLE or PVS <ref> [13, 9, 19, 18] </ref>, a (backwards-style) proof in our proof checker is represented as a sequence of proof states. <p> In contrast to the more traditional embedding of decision procedures such as in ACL2 or PVS <ref> [13, 18] </ref>, our system encourages the development of domain-specific decision procedures, allowing the controlled introduction of formal, but not mechanically checked reasoning into proofs. The system has been implemented in SML/NJ. The parametrization of the core checker is realized by its implementation as an SML functor.
Reference: [19] <author> L. C. Paulson. </author> <title> Isabelle: A Generic Theorem Prover. </title> <booktitle> Number 828 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: This section will briefly introduce the main characteristics of the proof checking environment and explain how the domain specific decision procedures mentioned above were embedded in the verification framework. 4.1 Light-weight proof checking Similar to theorem proving environments such as ACL2, HOL, ISABELLE or PVS <ref> [13, 9, 19, 18] </ref>, a (backwards-style) proof in our proof checker is represented as a sequence of proof states. <p> In contrast to IS-ABELLE <ref> [19] </ref>, where different object logics are embedded in the system's meta-logic, we use a simpler and more general, but less formal approach: The syntax of a logic is represented by an abstract data type and a function that recognizes well-formed formulas; inference rules are imple mented as functions on lists of
Reference: [20] <author> C. L. Seitz. </author> <title> System timing. In Introduction to VLSI Systems (Carver Mead and Lynn Conway), </title> <booktitle> chapter 7, </booktitle> <pages> pages 218-262. </pages> <publisher> Addison Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The SRT algorithm computes a sequence of partial remainders and quotient bits. This leads naturally to an iterative implementation, and the divider chip we verify uses the self-timed ring [28, 21] shown in figure 2. Data values are encoded using a dual-rail code <ref> [20] </ref> except for the quotient bits which are encoded using a three-wire, "one-hot" scheme [17]. Precharged logic is used throughout the design. Each stage can be in one of 2 three states: precharge, evaluate, or hold.
Reference: [21] <author> J. Sparst and J. Staunstrup. </author> <title> Delay-insensitive multi-ring structures. </title> <journal> INTEGRATION, </journal> <volume> 15(3) </volume> <pages> 313-340, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: The SRT algorithm computes a sequence of partial remainders and quotient bits. This leads naturally to an iterative implementation, and the divider chip we verify uses the self-timed ring <ref> [28, 21] </ref> shown in figure 2. Data values are encoded using a dual-rail code [20] except for the quotient bits which are encoded using a three-wire, "one-hot" scheme [17]. Precharged logic is used throughout the design. Each stage can be in one of 2 three states: precharge, evaluate, or hold.
Reference: [22] <author> J. Staunstrup. </author> <title> A Formal Approach to Hardware Design. </title> <publisher> Kluwer, </publisher> <year> 1993. </year>
Reference-contexts: The most detailed program maintains all of the properties verified for any of the programs. This approach to verification is described in greater detail in the remainder of this section. 3.1 ST In ST, programs are collections of guarded commands called transitions <ref> [22] </ref>. For example, &lt;&lt; x &gt; y !x, y := y, x &gt;&gt; is a transition that is enabled to swap x and y when x is greater than y. Two or more transitions may be combined using the asynchronous combinator, k. <p> However, it is not practical to write non-trivial ST programs in this form. The specifications of the divider hierarchy make use of several advanced features of the ST language, such as cells, set-expressions, modules <ref> [22] </ref> etc. These language constructs provide syntactic sugar and can be defined in terms of transitions and the asynchronous 9 combinator.
Reference: [23] <author> J. Staunstrup and N. Mellergaard. </author> <title> Localized verification of modular designs. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 6(3) </volume> <pages> 295-320, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: time at which x acquired this value, then we can express a minimum delay of ffi min for the swap transition by strengthening its guard as shown below: &lt;&lt; (x.v &gt; y.v) ^ (max (x.t; y.t ) ffi min ) &gt;&gt; The passage of time is modeled by a protocol <ref> [23] </ref> that describes the behaviour of the circuit's environment. In a protocol, x:pre denotes the value of x before an environment action, and x:post denotes the value of x afterwards.
Reference: [24] <author> S. Ta~siran and R. K. Brayton. STARI: </author> <title> A case study in compositional and hierarchical timing verification. </title> <booktitle> In Proceedings of the Ninth Conference on Computer Aided Verification, </booktitle> <pages> pages 191-201, </pages> <address> Haifa, Israel, June 1997. </address> <publisher> Springer. LNCS 1254. </publisher>
Reference-contexts: Many researchers have recognized the need for verification of designs that have critical delay dependencies. Timed automata provide a theoretical framework for modeling such designs, and in principle, many properties of such automata are decidable [11]. Several tools have been implemented based on various timed automata models <ref> [15, 2, 3, 24] </ref>. Although fully automatic, the high computational complexity of these automata based models have limited their application to models much simpler than typical self-timed designs.
Reference: [25] <author> D. Weih and M. Greenstreet. </author> <title> Verifying asynchronous data path circuits. </title> <booktitle> IEE Proceedings, Part E, Computers and Digital Techniques, </booktitle> <volume> 143(5) </volume> <pages> 295-300, </pages> <month> Sept. </month> <year> 1996. </year>
Reference: [26] <author> T. Williams, M. Horowitz, et al. </author> <title> A self-timed chip for division. </title> <booktitle> In Proceedings of the Conference on Advanced Research in VLSI. </booktitle> <publisher> Computer Science Press, </publisher> <year> 1987. </year>
Reference-contexts: In the second, decision procedures based on simple timing verification techniques can be employed. We combine these results using a proof checker to establish the correctness of the optimized design. To demonstrate our approach, we consider the three-stage version of Williams' self-timed divider <ref> [26] </ref>. This design was chosen because includes several low-level optimizations including timing assumptions and extensive use of pre-charged logic. It is also the basis of several subsequent divider designs including a five-stage design [27] and a design based on static logic for lower power consumption [16]. <p> Thus, verification of timing and verification of functionality are not separable for this design. To close this section, we include a few remarks about our model for the divider. Our design is based primarily on the description in <ref> [26] </ref>. Many details of the design are omitted from that paper, and we had to fill them by following the general design style guided by some earlier conversations with the designer. Although our design is not an exact replica of the chip described in [26], we believe that the two designs <p> based primarily on the description in <ref> [26] </ref>. Many details of the design are omitted from that paper, and we had to fill them by following the general design style guided by some earlier conversations with the designer. Although our design is not an exact replica of the chip described in [26], we believe that the two designs are very similar. For simplicity, we assumed the same upper and lower bounds on the delays of all logic elements.
Reference: [27] <author> T. E. Williams. </author> <title> Self-Timed Rings and their Application to Division. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: To demonstrate our approach, we consider the three-stage version of Williams' self-timed divider [26]. This design was chosen because includes several low-level optimizations including timing assumptions and extensive use of pre-charged logic. It is also the basis of several subsequent divider designs including a five-stage design <ref> [27] </ref> and a design based on static logic for lower power consumption [16]. In the remainder of this paper, the divider design is described in section 2, and section 3 outlines our verification stragegy for the divider. Our proofs were developed in a proof checker.
Reference: [28] <author> T. E. Williams. </author> <title> Analyzing and improving latency and throughput in self-timed pipelines and rings. </title> <booktitle> In TAU 1992 ACM International Workshop on Timing Issues in the Specification and Synthesis of Digital Systems, </booktitle> <address> Princeton, NJ, </address> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: The SRT algorithm computes a sequence of partial remainders and quotient bits. This leads naturally to an iterative implementation, and the divider chip we verify uses the self-timed ring <ref> [28, 21] </ref> shown in figure 2. Data values are encoded using a dual-rail code [20] except for the quotient bits which are encoded using a three-wire, "one-hot" scheme [17]. Precharged logic is used throughout the design. Each stage can be in one of 2 three states: precharge, evaluate, or hold.

References-found: 28

