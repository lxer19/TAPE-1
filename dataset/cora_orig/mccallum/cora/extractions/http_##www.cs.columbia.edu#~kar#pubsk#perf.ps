URL: http://www.cs.columbia.edu/~kar/pubsk/perf.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Email: ,karg@cs.columbia.edu  
Title: PERF Join: An Alternative To Two-way Semijoin And Bloomjoin  
Author: Zhe Li Kenneth A. Ross 
Address: New York, NY 10027  
Affiliation: Department of Computer Science, Columbia University,  
Abstract: This paper presents "Positionally Encoded Record Filters" (PERFs) and describes their use in a distributed query processing technique called PERF join. A PERF is a novel two-way join reduction implementation primitive. While having the same storage and transmission efficiency as a hash filter (e.g., Bloom Filter), a PERF is based on the relation tuple scan order instead of hashing. Hence it doesn't suffer any loss of join information incurred by hash collisions. Using the query response time measured in terms of network cost as a comparison criterion, we demonstrate through analytical studies that PERF join performs significantly better than two-way Bloomjoin and two-way semijoin variants under a wide range of relevant cost parameter values. For the large number of distributed query processing algorithms relying on Bloomjoin or semijoin variants to reduce their network cost, we can sometimes gain an instant improvement in their response time by switching to PERF join instead. Other salient features of PERF join include cheap local join processing cost, and the capability to handle inequality and cyclic join queries. 
Abstract-found: 1
Intro-found: 1
Reference: [AHY83] <author> P. Apers, A. Hevner, and S Yao. </author> <title> Optimization algorithm for distributed queries. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-9:57-68, </volume> <year> 1983. </year>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Most distributed query processing algorithms proposed so far <ref> [HY79, AHY83, YC84, RK91, WCS92, CY93] </ref> rely on some variants of the semijoin technique to reduce their network cost. They typically process a distributed query in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2.
Reference: [Bab79] <author> E. Babb. </author> <title> Implementing a relational database by means of specialized hardware. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(1) </volume> <pages> 1-29, </pages> <year> 1979. </year>
Reference-contexts: We call this improved version 2SJ+. In contrast to semijoin variants which always transmit join attribute values, Bloomjoin (hashed semijoin) [ML86] transmits Bloom filters <ref> [Blo70, Bab79] </ref> which are more space efficient. A Bloom filter is a hashing based bit vector used to encode the same joining information as the join attribute projections do.
Reference: [BC81] <author> P.A. Bernstein and D.M. Chiu. </author> <title> Using semi-joins to solve relational queries. </title> <journal> J.ACM, </journal> <volume> 28(1) </volume> <pages> 25-40, </pages> <year> 1981. </year>
Reference-contexts: Semijoins were introduced in <ref> [BC81, BG81] </ref>. Suppose two relations R and S are stored at different sites. <p> Since PERF join carries the complete join information, it is therefore capable of handling cyclic join queries without transmitting any useless tuples. In contrast, neither semijoin variants nor Bloomjoin can reduce the class of cyclic join queries, which does not have a full-reducer <ref> [BC81] </ref>. In addition, PERF join can handle inequality join while Bloomjoin will fail (due to the nature of hashing). It is possible that due to a very high (or low) semi-join selectivity, PERF (R i ) will largely consist of 0's (or 1's).
Reference: [BG81] <author> P.A. Bernstein and N. Goodman. </author> <title> The power of natural joins. </title> <journal> SIAM J. Computi., </journal> <volume> 10 </volume> <pages> 751-771, </pages> <year> 1981. </year>
Reference-contexts: Semijoins were introduced in <ref> [BC81, BG81] </ref>. Suppose two relations R and S are stored at different sites.
Reference: [BGW + 81] <author> Philip Bernstein, Nathan Goodman, Eu-gene Wong, Christopher L. Reeve, and James B. Rothie. </author> <title> Query processing in a system for distruibuted databases(sdd-1). </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(4) </volume> <pages> 602-625, </pages> <year> 1981. </year>
Reference-contexts: Let the aggregate semijoin selectivity of these m relations over R i be i , and the other n1m relations over R i be i . Assuming that semijoin reduction effects are independent, we can use the semijoin selectivity model proposed in <ref> [BGW + 81] </ref> 5 to derive the following: (R i ) = i fl i (1) To simplify the analysis, we assmue Step 3 uses the uncompressed PERF semijoin. Similar results hold if the compressed PERF join is used.
Reference: [Blo70] <author> Burton H. Bloom. </author> <title> Space/time trade-offs in hash coding with allowable errors. </title> <journal> Communications of the ACM, </journal> <volume> 13(7) </volume> <pages> 422-426, </pages> <year> 1970. </year>
Reference-contexts: We call this improved version 2SJ+. In contrast to semijoin variants which always transmit join attribute values, Bloomjoin (hashed semijoin) [ML86] transmits Bloom filters <ref> [Blo70, Bab79] </ref> which are more space efficient. A Bloom filter is a hashing based bit vector used to encode the same joining information as the join attribute projections do.
Reference: [CY93] <author> Ming-Syan Chen and Philip S. Yu. </author> <title> Combining join and semi-join operations for distributed query procesing. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(3) </volume> <pages> 534-542, </pages> <year> 1993. </year>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Most distributed query processing algorithms proposed so far <ref> [HY79, AHY83, YC84, RK91, WCS92, CY93] </ref> rely on some variants of the semijoin technique to reduce their network cost. They typically process a distributed query in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2.
Reference: [Dan82] <author> D. Daniels. </author> <title> Query compilation in a distributed database system. </title> <institution> IBM Res. </institution> <type> Rep. RJ 3423, </type> <institution> IBM, </institution> <year> 1982. </year>
Reference-contexts: Final assembly: All the reduced relations that are needed to compute the query result are shipped (possibly in parallel) to an assembling site (usually the query site) where the join result is composed. An important extension of the semijoin operation is the "two-way" semijoin, which we abbreviate as 2SJ <ref> [Dan82] </ref>. In the terminology of the description above, an additional step is performed: S 0 is projected onto the join attributes to get a new relation P S 0 . P S 0 is sent back to the site of R. <p> of bits in PERF (R i ), K bits be the size of the PERF addresses, S be the number of 1's or 0's (whichever is smaller) then compression is preferred if S &lt; P=K. 3.1 Improvements of PERF Join Over Semijoin The "two-way" semijoin (2SJ) operator was introduced in <ref> [Dan82] </ref> and later promoted in [Seg86]. In [RK91], an improved version 2SJ+ was proposed.
Reference: [DNS91] <author> David J. DeWitt, Jeffrey F. Naughton, and Donovan A. Schneider. </author> <title> An evaluation of non-equijoin algorithms. </title> <booktitle> In Proceedings of the 17th VLDB conference, </booktitle> <pages> pages 443-452, </pages> <year> 1991. </year>
Reference-contexts: In particular, we can handle non-equality joins. Another situation where Bloomjoin does not apply is a join based on some notion of "similarity" rather than on strict equality. Examples include band joins <ref> [DNS91] </ref>, and joins based on domain-specific similarity functions [HS95]. 1 16 256 4096 0 0.2 0.4 0.6 0.8 1 KBytes Transmitted (log 2 scale) semijoin selectivity of S over R 2SJ CPERF UPERF Variants Example 4.3: Consider the example of a retailer X and a manufacturer Y who have their databases
Reference: [GL94] <author> Piyush Gupta and Eileen Lin. DataJoiner: </author> <title> A practical approach to multi-database access. </title> <booktitle> In Proceedings of Third International Conference on Parallel and distributed Information Systems, </booktitle> <pages> page 264, </pages> <year> 1994. </year>
Reference-contexts: The main reason is the significant latency involved to generate, transmit and join the Bloom filters with the receiving relations. This latency is further exacerbated in a heterogeneous environment. In such an environment, the remote sites can not always talk to each other <ref> [GL94, Tem94] </ref> since they may assume different network protocols, query languages and data models. To perform a Bloomjoin between two remote sites, a third site (usually the query site) has to act like a coordinator to relay the Bloom filter from the sending site to the receiving site.
Reference: [Gra93] <author> Goetz Graefe. </author> <title> Query evaluation techniques for large databases. </title> <journal> ACM Computing Surverys, </journal> <volume> 25(2) </volume> <pages> 73-170, </pages> <year> 1993. </year>
Reference-contexts: To reduce the network transmission cost, one can compress the encoded join information by sending the addresses of the 1 (or 0) bits within PERF (R i ) and perform a semijoin (or anti-semijoin <ref> [Gra93] </ref>) with R i .
Reference: [HS95] <author> Mauricio Hernandez and Sal Stolfo. </author> <title> The merge/purge problem for large databases. </title> <booktitle> In Proceedings of the 1995 ACM-SIGMOD Conference, </booktitle> <year> 1995. </year>
Reference-contexts: In particular, we can handle non-equality joins. Another situation where Bloomjoin does not apply is a join based on some notion of "similarity" rather than on strict equality. Examples include band joins [DNS91], and joins based on domain-specific similarity functions <ref> [HS95] </ref>. 1 16 256 4096 0 0.2 0.4 0.6 0.8 1 KBytes Transmitted (log 2 scale) semijoin selectivity of S over R 2SJ CPERF UPERF Variants Example 4.3: Consider the example of a retailer X and a manufacturer Y who have their databases on-line for a distributor (the client) to read.
Reference: [HY79] <author> A.R. Hevner and S.B. Yao. </author> <title> Query processing in distributed database system. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-5(3), </volume> <year> 1979. </year>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Most distributed query processing algorithms proposed so far <ref> [HY79, AHY83, YC84, RK91, WCS92, CY93] </ref> rely on some variants of the semijoin technique to reduce their network cost. They typically process a distributed query in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2.
Reference: [LR94] <author> Zhe Li and Kenneth A. Ross. </author> <title> Better semi-joins using Tuple Bit-Vectors. </title> <type> Technical Report CUCS-010-94, </type> <institution> Columbia University, </institution> <address> New York, NY 10027, </address> <year> 1994. </year>
Reference-contexts: In general, (R i ) is defined as: (R i ) = jR i j 3 PERF join In this section we first introduce PERFs (an acronym for "Positionally Encoded Record Filters") and PERF join, as proposed in <ref> [LR94] </ref>. We then describe several popular semijoin variants and Bloomjoin, and show how PERF join outperforms them in terms of both network and local join processing cost. Definition 3.1: Consider two relations R and S, with R physically ordered in some fashion. S contains the join reduction information for R.
Reference: [LR95] <author> Zhe Li and Kenneth A. Ross. </author> <title> Federated query processing on the net using information servers. </title> <note> Submitted for publication, </note> <year> 1995. </year>
Reference-contexts: Inequality join query handling. 5. Cyclic join query handling. As future work, we are in the process of implementing the PERF join technique together with other optimizations in the context of a Parallel and Distributed Query Processing System (PDQPS) being developed at Columbia University <ref> [LR95] </ref>. We hope to demonstrate the practical utility of PERF join operators within this realistic general distributed query processing framework.
Reference: [ML86] <author> Lothar F. Mackert and Guy M. Lohman. </author> <title> R* optimizer validation and performance evaluation for distributed queries. </title> <booktitle> In Proceedings of the 12th VLDB conference, </booktitle> <pages> pages 300-311, </pages> <year> 1986. </year>
Reference-contexts: The 2SJ technique has been enhanced in [RK91] to send back to R's site the smaller of P S 0 and P R P S 0 . We call this improved version 2SJ+. In contrast to semijoin variants which always transmit join attribute values, Bloomjoin (hashed semijoin) <ref> [ML86] </ref> transmits Bloom filters [Blo70, Bab79] which are more space efficient. A Bloom filter is a hashing based bit vector used to encode the same joining information as the join attribute projections do. <p> If the receiving site's memory is limited, multiple passes over either the receiving relation or the received join attribute projection might be needed to perform the backward semijoin. In a fast network, this semijoin I/O cost can easily exceed the network transmission cost, as shown by <ref> [ML86] </ref>. In contrast, the backward PERF join can be done more cheaply. Due to the compactness of a bit vector representation, a PERF is likely to fit entirely in memory most of the time. <p> We will elaborate on this issue in Section 5. 3.2 Bloomjoin and Its Limitations We have introduced Bloomjoin in Section 1. Due to the compact size of Bloom filters, Bloomjoin can sometimes reduce the network and local join cost better than semi-join. It was demonstrated in <ref> [ML86] </ref> that distributed join algorithms employing Bloomjoin consistently performed better than those employing semijoins. The two major drawbacks with Bloomjoin are (a) that only equality joins can be handled, and (b) that hash collisions result in a loss of join information. <p> We now quantify the difference in query response time between Alg P and Alg B . Many previous researchers have looked at how to propagate Bloom filters in order to maximize the join reduction effect while trying to minimize query response time <ref> [Mul83, Mul90, ML86, WCS92] </ref>. We do not wish to extend their work here. Instead we simply take the best Bloom filter sequence that would have been generated by any of their algorithms, and "plug it in" to Step 1 of our Alg P strategy.
Reference: [Mul83] <author> James K. Mullin. </author> <title> A second look at Bloom filters. </title> <journal> Communications of the ACM, </journal> <volume> 26(8) </volume> <pages> 570-571, </pages> <year> 1983. </year>
Reference-contexts: We now quantify the difference in query response time between Alg P and Alg B . Many previous researchers have looked at how to propagate Bloom filters in order to maximize the join reduction effect while trying to minimize query response time <ref> [Mul83, Mul90, ML86, WCS92] </ref>. We do not wish to extend their work here. Instead we simply take the best Bloom filter sequence that would have been generated by any of their algorithms, and "plug it in" to Step 1 of our Alg P strategy.
Reference: [Mul90] <author> James K. Mullin. </author> <title> Optimal semijoins for distributed database systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(5) </volume> <pages> 558-560, </pages> <year> 1990. </year>
Reference-contexts: Bloom filters on a relation R perform best when they are of size kjRj where k is a small constant greater than 1 <ref> [Mul90] </ref>. From Definition 3.1, one can observe that a 1 Note that S can represent several remote relations which will together reduce R. In addition, PERF can encode reduction information for other relational operators, such as intersection. <p> We now quantify the difference in query response time between Alg P and Alg B . Many previous researchers have looked at how to propagate Bloom filters in order to maximize the join reduction effect while trying to minimize query response time <ref> [Mul83, Mul90, ML86, WCS92] </ref>. We do not wish to extend their work here. Instead we simply take the best Bloom filter sequence that would have been generated by any of their algorithms, and "plug it in" to Step 1 of our Alg P strategy.
Reference: [RK91] <author> Nick Roussopoulos and Hyunchul Kang. </author> <title> A pipeline n-way join algorithm based on the 2-way semijoin program. </title> <journal> IEEE Transactions on Knowledge And Data Engineering, </journal> <volume> 3(4) </volume> <pages> 486-495, </pages> <year> 1991. </year>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Most distributed query processing algorithms proposed so far <ref> [HY79, AHY83, YC84, RK91, WCS92, CY93] </ref> rely on some variants of the semijoin technique to reduce their network cost. They typically process a distributed query in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2. <p> It is particularly useful when both R and S need to be transmitted to a third site, either because that is where the answer is needed, or because a third joining relation is stored at a third site. The 2SJ technique has been enhanced in <ref> [RK91] </ref> to send back to R's site the smaller of P S 0 and P R P S 0 . We call this improved version 2SJ+. <p> In <ref> [RK91] </ref>, an improved version 2SJ+ was proposed. <p> Clearly, the backward transmission cost of 2SJ+ is bounded by half of P R . When jP 0 S j &gt; jP R j=2, 2SJ+ is more effective. In <ref> [RK91] </ref> it is proved that the backward reduction of 2SJ+ is always cost-effective, i.e., that the benefits outweigh the costs, when the original site's relation needs to be transmitted to another site.
Reference: [Seg86] <author> Arie Segev. </author> <title> Optimization of join operations in horizontally partitioned database systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 11(1) </volume> <pages> 48-80, </pages> <year> 1986. </year>
Reference-contexts: i ), K bits be the size of the PERF addresses, S be the number of 1's or 0's (whichever is smaller) then compression is preferred if S &lt; P=K. 3.1 Improvements of PERF Join Over Semijoin The "two-way" semijoin (2SJ) operator was introduced in [Dan82] and later promoted in <ref> [Seg86] </ref>. In [RK91], an improved version 2SJ+ was proposed.
Reference: [Tem94] <author> Marjorie Templeton. Interviso: </author> <title> A data integration server. </title> <booktitle> In Proceedings of Third International Conference on Parallel and distributed Information Systems, </booktitle> <pages> pages 265-266, </pages> <year> 1994. </year>
Reference-contexts: The main reason is the significant latency involved to generate, transmit and join the Bloom filters with the receiving relations. This latency is further exacerbated in a heterogeneous environment. In such an environment, the remote sites can not always talk to each other <ref> [GL94, Tem94] </ref> since they may assume different network protocols, query languages and data models. To perform a Bloomjoin between two remote sites, a third site (usually the query site) has to act like a coordinator to relay the Bloom filter from the sending site to the receiving site.
Reference: [WCS92] <author> Chihping Wang, Arbee L.P. Chen, and Shiow-Chen Shyu. </author> <title> A parallel execution method for minimizing distributed query response time. </title> <journal> IEEE Transactions on Parallel And Distributed Systems, </journal> <volume> 3(3) </volume> <pages> 325-333, </pages> <year> 1992. </year>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Most distributed query processing algorithms proposed so far <ref> [HY79, AHY83, YC84, RK91, WCS92, CY93] </ref> rely on some variants of the semijoin technique to reduce their network cost. They typically process a distributed query in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2. <p> In contrast to a full reduction after semijoin, a relation will only be partially reduced after Bloomjoin. There is another reason why non-joining tuples will remain in the reduced relation after a Bloomjoin. Previous work <ref> [WCS92] </ref> has shown that even for an n-way equality join R 1 1 R 2 1 : : : 1 R n with the use of good hash functions, it is not always optimal to reduce R i fully with Bloom filters generated from the other n 1 relations in order <p> We now quantify the difference in query response time between Alg P and Alg B . Many previous researchers have looked at how to propagate Bloom filters in order to maximize the join reduction effect while trying to minimize query response time <ref> [Mul83, Mul90, ML86, WCS92] </ref>. We do not wish to extend their work here. Instead we simply take the best Bloom filter sequence that would have been generated by any of their algorithms, and "plug it in" to Step 1 of our Alg P strategy.
Reference: [YC84] <author> C.T. Yu and C. C. Chang. </author> <title> Distributed query processing. </title> <booktitle> ACM Computing Surverys, </booktitle> <pages> pages 399-433, </pages> <year> 1984. </year>
Reference-contexts: S 0 can then be sent to R's site (or to a third site) to construct the full join. Most distributed query processing algorithms proposed so far <ref> [HY79, AHY83, YC84, RK91, WCS92, CY93] </ref> rely on some variants of the semijoin technique to reduce their network cost. They typically process a distributed query in the following manner: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2.
References-found: 23

