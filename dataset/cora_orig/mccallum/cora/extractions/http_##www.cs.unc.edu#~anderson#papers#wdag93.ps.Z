URL: http://www.cs.unc.edu/~anderson/papers/wdag93.ps.Z
Refering-URL: http://www.cs.unc.edu/~anderson/papers.html
Root-URL: http://www.cs.unc.edu
Title: Towards a Necessary and Sufficient Condition for Wait-free Synchronization (Extended Abstract)  
Author: James H. Anderson and Mark Moir 
Address: College Park, Maryland 20742-3255 U.S.A.  
Affiliation: Department of Computer Science, The University of Maryland  
Abstract: We define a class of shared objects called snapshot objects, and give a necessary and sufficient condition for the existence of a wait-free implementation of such objects from atomic registers. Snapshot objects can be accessed by means of a read operation that returns the entire object state, or by a set of operations that do not return values. Our condition for the existence of a wait-free implementation requires that for any pair of operation invocations, either the two invocations commute or one overwrites the other.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Y. Afek, H. Attiya, D. Dolev, E. Gafni, M. Merritt, and N. Shavit, </author> <title> "Atomic Snapshots of Shared Memory", </title> <booktitle> Proceedings of the Ninth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1990, </year> <pages> pp. 1-14. </pages>
Reference-contexts: These include multi-reader, multi-writer, multi-bit atomic registers [4, 7, 8, 11, 12, 14, 15, 17, 18, 19, 20, 21], multi-reader, multi-writer counters [5, 6], and multi-reader, multi-writer composite registers <ref> [1, 2, 3, 13] </ref>. <p> The operations in H are replayed as follows. We use a bounded, wait-free counter CTR, and a composite register LIST of size L+1, where L is the number of invocations in H. It follows from the results in <ref> [1, 2, 3, 5, 6, 13] </ref> that such objects can be implemented from atomic registers in a wait-free (and therefore 1-resilient) manner. Each process i performs the invocations in Hj i in the order in which they appear in H. <p> Example (continued): In our example, anc and ow are defined as follows. anc = (U ) (S) (T ) 2 (S) 0 0 1 ow = (U ) (S) (T ) The following functions represent operations CLR and SET in class U . func <ref> [1; 1] </ref>(obj; u) h0; 0; 0; 0i func [1; 2](obj; u) hu; u; u; ui The first clears all registers, and the second sets all registers to the value of the parameter. <p> In our example, anc and ow are defined as follows. anc = (U ) (S) (T ) 2 (S) 0 0 1 ow = (U ) (S) (T ) The following functions represent operations CLR and SET in class U . func [1; 1](obj; u) h0; 0; 0; 0i func <ref> [1; 2] </ref>(obj; u) hu; u; u; ui The first clears all registers, and the second sets all registers to the value of the parameter. <p> The following functions represent the operation CNZ in class S. func <ref> [2; 1] </ref>(obj; i) obj with first i non-zero registers cleared f apply g func [2; 2](i; u) min (i + 1; 4) f compose g func [2; 3](u) 1 f initialize g The initialize function starts a count of how many registers to clear. <p> The compose function increments the count, and the apply function clears the number of registers that the count indicates. The following functions represent the operation RNZ in class T . func <ref> [3; 1] </ref>(obj; i) obj with first non-zero reg. reversed if i = 1 obj if i 6= 1 f apply g func [3; 2](i; u) 1 i f compose g func [3; 3](u) 1 f initialize g The initialize function notes that the bits of the leftmost non-zero register are to <p> n 6= i ^ n 6= i N ^ v [cl; n]:done :: v [cl; n]:seen [i] 6= v [cl; i]:tag:uniq _ v [cl; n]:cnt [i] 6= 4)) current (v; j; k) alive (v; j; k) ^ sametags (v; v [j; k]:atags [0]; j) ^ sametags (v; v [j; k]:atags <ref> [1] </ref>; j) ^ (ow [j] ) (8n : alive (v; j; n) ^ sametags (v; v [j; n]:atags [0]; j) ^ sametags (v; v [j; n]:atags [1]; j) :: (v [j; n]:tag:seq; n) (v [j; k]:tag:seq; k))) local variables v : array [1::C; 0::2N 1] of cell type; f Local copy <p> 6= 4)) current (v; j; k) alive (v; j; k) ^ sametags (v; v [j; k]:atags [0]; j) ^ sametags (v; v [j; k]:atags <ref> [1] </ref>; j) ^ (ow [j] ) (8n : alive (v; j; n) ^ sametags (v; v [j; n]:atags [0]; j) ^ sametags (v; v [j; n]:atags [1]; j) :: (v [j; n]:tag:seq; n) (v [j; k]:tag:seq; k))) local variables v : array [1::C; 0::2N 1] of cell type; f Local copy of object representation g outval : 0::B; f Output value for Read g i : 1::C; k : 0::2N 1; f Counters g q, r: array
Reference: 2. <author> J. Anderson, </author> <title> "Composite Registers", </title> <journal> Distributed Computing, </journal> <volume> Vol. 6, </volume> <year> 1993, </year> <pages> pp. 141-154. </pages> <note> Preliminary version appeared in Proceedings of the Ninth Annual Symposium on Principles of Distributed Computing, </note> <year> 1990, </year> <pages> pp. 15-30. </pages>
Reference-contexts: These include multi-reader, multi-writer, multi-bit atomic registers [4, 7, 8, 11, 12, 14, 15, 17, 18, 19, 20, 21], multi-reader, multi-writer counters [5, 6], and multi-reader, multi-writer composite registers <ref> [1, 2, 3, 13] </ref>. <p> The operations in H are replayed as follows. We use a bounded, wait-free counter CTR, and a composite register LIST of size L+1, where L is the number of invocations in H. It follows from the results in <ref> [1, 2, 3, 5, 6, 13] </ref> that such objects can be implemented from atomic registers in a wait-free (and therefore 1-resilient) manner. Each process i performs the invocations in Hj i in the order in which they appear in H. <p> In our example, anc and ow are defined as follows. anc = (U ) (S) (T ) 2 (S) 0 0 1 ow = (U ) (S) (T ) The following functions represent operations CLR and SET in class U . func [1; 1](obj; u) h0; 0; 0; 0i func <ref> [1; 2] </ref>(obj; u) hu; u; u; ui The first clears all registers, and the second sets all registers to the value of the parameter. <p> The following functions represent the operation CNZ in class S. func <ref> [2; 1] </ref>(obj; i) obj with first i non-zero registers cleared f apply g func [2; 2](i; u) min (i + 1; 4) f compose g func [2; 3](u) 1 f initialize g The initialize function starts a count of how many registers to clear. <p> The following functions represent the operation CNZ in class S. func [2; 1](obj; i) obj with first i non-zero registers cleared f apply g func <ref> [2; 2] </ref>(i; u) min (i + 1; 4) f compose g func [2; 3](u) 1 f initialize g The initialize function starts a count of how many registers to clear. The compose function increments the count, and the apply function clears the number of registers that the count indicates. <p> The following functions represent the operation CNZ in class S. func [2; 1](obj; i) obj with first i non-zero registers cleared f apply g func [2; 2](i; u) min (i + 1; 4) f compose g func <ref> [2; 3] </ref>(u) 1 f initialize g The initialize function starts a count of how many registers to clear. The compose function increments the count, and the apply function clears the number of registers that the count indicates. <p> The following functions represent the operation RNZ in class T . func [3; 1](obj; i) obj with first non-zero reg. reversed if i = 1 obj if i 6= 1 f apply g func <ref> [3; 2] </ref>(i; u) 1 i f compose g func [3; 3](u) 1 f initialize g The initialize function notes that the bits of the leftmost non-zero register are to be reversed. <p> v [cl; q [cl]]:atags [0]; :cell:tag:alt; v [cl; q [cl]]:tag:uniq; 0; for i := 1 to C, k := 0 to 2N 1 do cell:atags [1][i; k] := v [i; k]:tag od; f Compose subsequent parameter g if :ow [cl] ^ current (v; cl; r [cl]) then cell:pars := func <ref> [cl; 2] </ref>(v [cl; r [cl]]:pars; inval) elseif :ow [cl] ^ :current (v; cl; r [cl]) then cell:pars := func [cl; 3](inval) else cell:pars := inval fi; f Already overwritten? g cell:valid := (ow [cl] ) (8n : n 6= r [cl] ^ n 6= r [cl] N :: v [cl; n]:seen
Reference: 3. <author> J. Anderson, </author> <title> "Multi-Writer Composite Registers", </title> <note> submitted to Distributed Computing. </note>
Reference-contexts: These include multi-reader, multi-writer, multi-bit atomic registers [4, 7, 8, 11, 12, 14, 15, 17, 18, 19, 20, 21], multi-reader, multi-writer counters [5, 6], and multi-reader, multi-writer composite registers <ref> [1, 2, 3, 13] </ref>. <p> The operations in H are replayed as follows. We use a bounded, wait-free counter CTR, and a composite register LIST of size L+1, where L is the number of invocations in H. It follows from the results in <ref> [1, 2, 3, 5, 6, 13] </ref> that such objects can be implemented from atomic registers in a wait-free (and therefore 1-resilient) manner. Each process i performs the invocations in Hj i in the order in which they appear in H. <p> The following functions represent the operation CNZ in class S. func [2; 1](obj; i) obj with first i non-zero registers cleared f apply g func [2; 2](i; u) min (i + 1; 4) f compose g func <ref> [2; 3] </ref>(u) 1 f initialize g The initialize function starts a count of how many registers to clear. The compose function increments the count, and the apply function clears the number of registers that the count indicates. <p> The compose function increments the count, and the apply function clears the number of registers that the count indicates. The following functions represent the operation RNZ in class T . func <ref> [3; 1] </ref>(obj; i) obj with first non-zero reg. reversed if i = 1 obj if i 6= 1 f apply g func [3; 2](i; u) 1 i f compose g func [3; 3](u) 1 f initialize g The initialize function notes that the bits of the leftmost non-zero register are to <p> The following functions represent the operation RNZ in class T . func [3; 1](obj; i) obj with first non-zero reg. reversed if i = 1 obj if i 6= 1 f apply g func <ref> [3; 2] </ref>(i; u) 1 i f compose g func [3; 3](u) 1 f initialize g The initialize function notes that the bits of the leftmost non-zero register are to be reversed. <p> The following functions represent the operation RNZ in class T . func [3; 1](obj; i) obj with first non-zero reg. reversed if i = 1 obj if i 6= 1 f apply g func [3; 2](i; u) 1 i f compose g func <ref> [3; 3] </ref>(u) 1 f initialize g The initialize function notes that the bits of the leftmost non-zero register are to be reversed. The compose function toggles the value of the intermediate form to indicate whether the bits of the leftmost non-zero register should be reversed. <p> 0 to 2N 1 do cell:atags [1][i; k] := v [i; k]:tag od; f Compose subsequent parameter g if :ow [cl] ^ current (v; cl; r [cl]) then cell:pars := func [cl; 2](v [cl; r [cl]]:pars; inval) elseif :ow [cl] ^ :current (v; cl; r [cl]) then cell:pars := func <ref> [cl; 3] </ref>(inval) else cell:pars := inval fi; f Already overwritten? g cell:valid := (ow [cl] ) (8n : n 6= r [cl] ^ n 6= r [cl] N :: v [cl; n]:seen [r [cl]] 6= v [cl; r [cl]]:tag:uniq _ v [cl; n]:cnt &lt; 2)); if ow [cl] then f Choose <p> In particular, a sequence number is associated with each invocation. Conceptually, these sequence numbers grow without bound, and the "most recent" invocation is the one with the largest sequence number. To bound the sequence numbers, we use a technique similar to that employed by Anderson in <ref> [3] </ref> and by Li, Tromp, and Vitanyi in [15]. The idea is to have each invocation choose a value uniq that is stored along with its sequence number. Each invocation also makes a copy of each other cell's uniq value.
Reference: 4. <author> J. Anderson and M. Gouda, </author> <title> "A Criterion for Atomicity", </title> <journal> Formal Aspects of Computing: The International Journal of Formal Methods, </journal> <volume> Vol. 4, No. 3, </volume> <month> May </month> <year> 1992, </year> <pages> pp. 273-298. </pages>
Reference: 5. <author> J. Anderson and B. Groselj, </author> <title> "Beyond Atomic Registers: Bounded Wait-Free Implementations of Nontrivial Objects", </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1992, </year> <pages> pp. 192-237. </pages> <note> Preliminary version appeared as "Pseudo Read-Modify-Write Operations: </note> <editor> Bounded Wait-Free Implementations", </editor> <booktitle> Proceedings of the Fifth International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 579, </booktitle> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1991, </year> <pages> pp. 52-70. </pages>
Reference-contexts: Various shared objects have been shown to have wait-free implementations using only the simplest kind of atomic registers, i.e., single-reader, single-writer, single-bit atomic registers. These include multi-reader, multi-writer, multi-bit atomic registers [4, 7, 8, 11, 12, 14, 15, 17, 18, 19, 20, 21], multi-reader, multi-writer counters <ref> [5, 6] </ref>, and multi-reader, multi-writer composite registers [1, 2, 3, 13]. <p> Both authors are now with the Department of Computer Science, The University of North Carolina at Chapel Hill, Chapel Hill, North Carolina 27599-3175 snapshot operation. Other objects have been shown to have no resilient imple-mentation from atomic registers, including multiple-register assignment objects [9], multiply-add registers <ref> [5] </ref>, and read-modify-write objects [9]. In this paper, we consider the problem of precisely characterizing those shared objects that can be implemented in a resilient manner from single-reader, single-writer, single-bit atomic registers. <p> The operations in H are replayed as follows. We use a bounded, wait-free counter CTR, and a composite register LIST of size L+1, where L is the number of invocations in H. It follows from the results in <ref> [1, 2, 3, 5, 6, 13] </ref> that such objects can be implemented from atomic registers in a wait-free (and therefore 1-resilient) manner. Each process i performs the invocations in Hj i in the order in which they appear in H. <p> Within a commuting class, multiple invocations of an operation are "collapsed" to appear as one invocation. The technique used for this purpose is similar to one employed by Anderson and Groselj in <ref> [5] </ref>, where a bounded, wait-free algorithm is presented for a counter object that can be modified using Reset and Increment operations. In [5], Increment invocations that have been subsequently overwritten by a Reset are detected as follows. <p> The technique used for this purpose is similar to one employed by Anderson and Groselj in <ref> [5] </ref>, where a bounded, wait-free algorithm is presented for a counter object that can be modified using Reset and Increment operations. In [5], Increment invocations that have been subsequently overwritten by a Reset are detected as follows. Increment invocations make a copy of a tag value stored by the most recent Reset invocation, and Reset invocations choose a tag value that is not currently stored as a copy. <p> Because tags are required to be bounded, complications can arise when a tag's value "wraps around". This problem is dealt with in <ref> [5] </ref> by having the Increment operation execute in two phases. For details, see [5] or the full version of this paper. This technique is generalized in several ways in our algorithm. <p> Because tags are required to be bounded, complications can arise when a tag's value "wraps around". This problem is dealt with in <ref> [5] </ref> by having the Increment operation execute in two phases. For details, see [5] or the full version of this paper. This technique is generalized in several ways in our algorithm. First, note that each class is potentially an ancestor and a descendant, so operations must perform roles analogous to those of both the Reset and Increment operations described above.
Reference: 6. <author> J. Aspnes and M. Herlihy, </author> <title> "Wait-Free Data Structures in the Asynchronous PRAM Model", </title> <booktitle> Proceedings of the Second Annual ACM Symposium on Parallel Architectures and Algorithms, </booktitle> <month> July, </month> <year> 1990. </year>
Reference-contexts: Various shared objects have been shown to have wait-free implementations using only the simplest kind of atomic registers, i.e., single-reader, single-writer, single-bit atomic registers. These include multi-reader, multi-writer, multi-bit atomic registers [4, 7, 8, 11, 12, 14, 15, 17, 18, 19, 20, 21], multi-reader, multi-writer counters <ref> [5, 6] </ref>, and multi-reader, multi-writer composite registers [1, 2, 3, 13]. <p> Loui and Abu-Amara [16] have shown that such a protocol cannot be implemented using only atomic registers. It follows that if a snapshot object does not satisfy the condition, then it has no 1-resilient implementation from atomic registers. With regard to sufficiency, Aspnes and Herlihy <ref> [6] </ref> have presented an algorithm that provides a wait-free implementation for a large class of objects. This class includes any snapshot object that satisfies the Resiliency Condition, thereby showing the condition to be sufficient. <p> Furthermore, if an object does not satisfy the Resiliency Condition, then it not only has no wait-free implementation, it does not even have a 1-resilient implementation. Proof: The sufficiency of this condition follows from results presented by Aspnes and Herlihy in <ref> [6] </ref>, where it is shown that any object (and thus any snapshot object) satisfying the condition has an unbounded, wait-free implementation. Aspnes and Herlihy's condition is slightly stronger in that they require every pair of invocations to commute or overwrite, even for invocations of the same process. <p> The operations in H are replayed as follows. We use a bounded, wait-free counter CTR, and a composite register LIST of size L+1, where L is the number of invocations in H. It follows from the results in <ref> [1, 2, 3, 5, 6, 13] </ref> that such objects can be implemented from atomic registers in a wait-free (and therefore 1-resilient) manner. Each process i performs the invocations in Hj i in the order in which they appear in H. <p> then both decide false if process u applies its tie-breaker first, and true if process v applies its tie-breaker first. 2 4 Implementation of a Subclass of Snapshot Objects In this section, we describe a bounded, wait-free implementation for a subclass of the snapshot objects shown by Aspnes and Herlihy <ref> [6] </ref> to have wait-free, but unbounded, implementations. <p> Next, we define a relation over the classes as follows: A B iff (9P; Q : P 2 A; Q 2 B :: P overwrites Q) ^ A 6= B. The overwrites relation is transitive <ref> [6] </ref>, so is transitive and irreflexive, and thus defines an irreflexive partial order over the overwriting and commuting classes. We label the classes 1 to C according to some arbitrary total order that extends the partial order defined by the relation.
Reference: 7. <author> B. Bloom, </author> <title> "Constructing Two-Writer Atomic Registers", </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 37, No. 12, </volume> <month> December </month> <year> 1988, </year> <pages> pp. 1506-1514. </pages> <booktitle> Also appeared in Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1987, </year> <pages> pp. 249-259. </pages>
Reference: 8. <author> J. Burns and G. Peterson, </author> <title> "Constructing Multi-Reader Atomic Values from NonAtomic Values", </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1987, </year> <pages> pp. 222-231. </pages>
Reference: 9. <author> M. Herlihy, </author> <title> "Wait-Free Synchronization", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No. 1, </volume> <year> 1991, </year> <pages> pp. 124-149. </pages>
Reference-contexts: Both authors are now with the Department of Computer Science, The University of North Carolina at Chapel Hill, Chapel Hill, North Carolina 27599-3175 snapshot operation. Other objects have been shown to have no resilient imple-mentation from atomic registers, including multiple-register assignment objects <ref> [9] </ref>, multiply-add registers [5], and read-modify-write objects [9]. In this paper, we consider the problem of precisely characterizing those shared objects that can be implemented in a resilient manner from single-reader, single-writer, single-bit atomic registers. <p> Both authors are now with the Department of Computer Science, The University of North Carolina at Chapel Hill, Chapel Hill, North Carolina 27599-3175 snapshot operation. Other objects have been shown to have no resilient imple-mentation from atomic registers, including multiple-register assignment objects <ref> [9] </ref>, multiply-add registers [5], and read-modify-write objects [9]. In this paper, we consider the problem of precisely characterizing those shared objects that can be implemented in a resilient manner from single-reader, single-writer, single-bit atomic registers. <p> That such an object has a wait-free implementation may be surprising, given that multiple-register assignments cannot be implemented from atomic registers without waiting <ref> [9] </ref>. The remainder of this paper is organized as follows. In Section 2, we define some notation, and in Section 3, we formally state the Resiliency Condition and show that it is necessary. In Section 4, we describe the bounded, wait-free implementation discussed above.
Reference: 10. <author> M. Herlihy and J. Wing, </author> <title> "Linearizability: A Correctness Condition for Concurrent Objects", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 12, No. 3, </volume> <year> 1990, </year> <pages> pp. 463-492. </pages>
Reference-contexts: Within such a program fragment, the only shared objects that may be invoked are atomic registers (or objects that may in turn be implemented from atomic registers with the desired resiliency see below). The primary correctness condition for an implementation of an object is that of linearizability <ref> [10] </ref>. A process may fail by stopping undetectably, in which case it is said to be faulty. A process that does not fail is nonfaulty.
Reference: 11. <author> A. Israeli and M. Li, </author> <title> "Bounded Time-Stamps", </title> <booktitle> Proceedings of the 28th IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1987, </year> <pages> pp. 371-382. </pages>
Reference: 12. <author> L. Kirousis, E. Kranakis, and P. Vitanyi, </author> <title> "Atomic Multireader Register", </title> <booktitle> Proceedings of the Second International Workshop on Distributed Computing, Springer Verlag Lecture Notes in Computer Science 312, </booktitle> <year> 1987, </year> <pages> pp. 278-296. </pages>
Reference: 13. <author> L. Kirousis, P. Spirakis, and P. Tsigas, </author> <title> "Reading Many Variables in One Atomic Operation: Solutions with Linear or Sublinear Complexity", </title> <booktitle> Proceedings of the Fifth International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 579, </booktitle> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1991, </year> <pages> pp. 229-241. </pages>
Reference-contexts: These include multi-reader, multi-writer, multi-bit atomic registers [4, 7, 8, 11, 12, 14, 15, 17, 18, 19, 20, 21], multi-reader, multi-writer counters [5, 6], and multi-reader, multi-writer composite registers <ref> [1, 2, 3, 13] </ref>. <p> The operations in H are replayed as follows. We use a bounded, wait-free counter CTR, and a composite register LIST of size L+1, where L is the number of invocations in H. It follows from the results in <ref> [1, 2, 3, 5, 6, 13] </ref> that such objects can be implemented from atomic registers in a wait-free (and therefore 1-resilient) manner. Each process i performs the invocations in Hj i in the order in which they appear in H.
Reference: 14. <author> L. Lamport, </author> <title> "On Interprocess Communication, Parts I and II", </title> <journal> Distributed Computing, </journal> <volume> Vol. 1, </volume> <year> 1986, </year> <pages> pp. 77-101. </pages>
Reference-contexts: Most prior research on resilient shared objects has focused on implementations based on atomic registers. An atomic register is a shared object consisting of a single shared variable that can be either read or written in a single operation <ref> [14] </ref>. An N -reader, M -writer, L-bit atomic register consists of an L-bit value that can be read by N processes and can be written by M processes.
Reference: 15. <author> M. Li, J. Tromp, and P. Vitanyi, </author> <title> "How to Construct Wait-Free Variables", </title> <booktitle> Proceedings of International Colloquium on Automata, Languages, and Programming, Lecture Notes in Computer Science 372, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1989, </year> <pages> pp. 488-505. </pages>
Reference-contexts: Conceptually, these sequence numbers grow without bound, and the "most recent" invocation is the one with the largest sequence number. To bound the sequence numbers, we use a technique similar to that employed by Anderson in [3] and by Li, Tromp, and Vitanyi in <ref> [15] </ref>. The idea is to have each invocation choose a value uniq that is stored along with its sequence number. Each invocation also makes a copy of each other cell's uniq value. The uniq value is chosen so as to be distinct from all corresponding copies.
Reference: 16. <author> M. Loui, H. Abu-Amara, </author> <title> "Memory Requirements for Agreement Among Unreliable Asynchronous Processes", </title> <booktitle> Advances in Computing Research, </booktitle> <volume> Vol. 4, </volume> <year> 1987, </year> <pages> pp. 163-183. </pages>
Reference-contexts: In the first part of this paper, we show that the Resiliency Condition is necessary by showing that any snapshot object that fails to satisfy it can be used to implement a 1-resilient consensus protocol. Loui and Abu-Amara <ref> [16] </ref> have shown that such a protocol cannot be implemented using only atomic registers. It follows that if a snapshot object does not satisfy the condition, then it has no 1-resilient implementation from atomic registers. <p> In the remainder of the proof, we show that the Resiliency Condition is necessary. Specifically, we show that any snapshot object that does not satisfy the condition can be used to solve 1-resilient consensus. It has been shown by Loui and Abu-Amara <ref> [16] </ref> that 1-resilient consensus cannot be solved using only atomic registers. Thus, an object that does not satisfy our condition has no 1-resilient implementation using only atomic registers.
Reference: 17. <author> R. Newman-Wolfe, </author> <title> "A Protocol for Wait-Free, Atomic, Multi-Reader Shared Variables", </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1987, </year> <pages> pp. 232-248. </pages>
Reference: 18. <author> G. Peterson and J. Burns, </author> <title> "Concurrent Reading While Writing II: The Multi-Writer Case", </title> <booktitle> Proceedings of the 28th Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1987. </year>
Reference: 19. <author> A. Singh, J. Anderson, and M. Gouda, </author> <title> "The Elusive Atomic Register, Revisited", </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1987, </year> <pages> pp. 206-221. </pages> <note> Expanded version to appear in Journal of the ACM. </note>
Reference: 20. <author> J. Tromp, </author> <title> "How to Construct an Atomic Variable", </title> <booktitle> Proceedings of the Third International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 392, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1989, </year> <pages> pp. 292-302. </pages>
Reference: 21. <author> P. Vitanyi and B. Awerbuch, </author> <title> "Atomic Shared Register Access by Asynchronous Hardware", </title> <booktitle> Proceedings of the 27th IEEE Symposium on the Foundations of Computer Science, </booktitle> <year> 1986, </year> <pages> pp. 233-243. </pages>
Reference-contexts: Within an overwriting class, only the "most recent" invocation affects the state of the object. To identify this invocation, we use a technique originated by Vitanyi and Awerbuch in <ref> [21] </ref>. In particular, a sequence number is associated with each invocation. Conceptually, these sequence numbers grow without bound, and the "most recent" invocation is the one with the largest sequence number.
References-found: 21

