URL: http://www.cs.washington.edu/homes/amir/generals/general.ps
Refering-URL: http://www.cs.washington.edu/homes/amir/generals/
Root-URL: http://www.cs.washington.edu
Title: Beyond Grep: Advanced Pattern Matching Tools  
Author: Amir Michail 
Affiliation: University of Washington  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. V. Aho, B. W. Kernighan, and P. J. Weinberger. </author> <title> Awka pattern scanning and processing language. </title> <journal> Software Practice and Experience, </journal> <volume> 9(4):267280, </volume> <year> 1979. </year>
Reference-contexts: These include grep [25], awk <ref> [1] </ref>, lex [28], and perl [46]. Grep only searches for matches that do not span multiple lines and has no support for action code.
Reference: [2] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: In particular, a regular expression, being equivalent in power to a onite automata (i.e., with onite memory), can only be used to match items in which one need not irememberj or icountj an arbitrarily large number of characters (see <ref> [2] </ref>, page 98, and [18], pages 5558). To illustrate the problem, suppose we want to ond a while statement followed by a for statement at the same level of nesting in some C source code.
Reference: [3] <author> B. S. Baker. </author> <title> Parameterized pattern matching: algorithms and applications. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 52(1):2042, </volume> <year> 1996. </year>
Reference-contexts: Another possibility is a parametric match where the pattern string may contain iparameter symbolsj that may match arbitrary characters as long as multiple occurrences of the same parameter symbol match the same character in the text <ref> [3] </ref>. (Parameterized pattern matching is useful in onding repeated segments of code that are better abstracted into a single function.) The string matching techniques just described can be viewed as a single point in a two dimensional design space where one dimension is for the pattern representation and the other dimension
Reference: [4] <author> D. Borsky. </author> <title> An algorithm for parsing AEow graphs. </title> <type> Master's thesis, </type> <institution> MIT Artiocial Intelligence Lab, </institution> <year> 1984. </year>
Reference-contexts: Whereas the automaton simulated by SCRUPLE has onite memory, the one simulated by GRASPR is a stack-based graph parser with unbounded memory (similar to a nondeterministic pushdown automata [18]). GRASPR uses a graph parsing algorithm similar to that developed by Brotsky <ref> [4] </ref> and extended by Lutz [30]; these graph parsing algorithms are inspired by Earley's string parsing algorithm [9]. The graph parser simulation maintains a chart of items to store all parses found so far.
Reference: [5] <author> R. S. Boyer and J. S. Moore. </author> <title> A fast string searching algorithm. </title> <journal> Communication of the ACM, </journal> <volume> 20(10):762772, </volume> <year> 1977. </year>
Reference-contexts: Perhaps the most fundamental form of pattern matching involves a string pattern and string text. There are several interesting ways in which one might want the pattern to match the text. Most obvious is an exact match were the pattern string must occur verbatim in the text <ref> [5, 24, 26] </ref>. One may also want an approximate match in which the pattern string p matches a substring x of the text if and only if d (p; x) k for some distance metric d (eg., edit distance) and user specioed constant k [13].
Reference: [6] <author> A. Church. </author> <title> A note on the entscheidungsproblem. </title> <journal> Journal of Symbolic Logic, 1:4041 and 101102, </journal> <year> 1936. </year>
Reference-contexts: Unfortunately, determining whether a query speciocation matches that of a function in the library is semidecidable <ref> [22, 45, 6] </ref>and undecidable if we also include arithmetic in the logic [23]. Moreover, programmers don't want the burden of writing complicated logic speciocations for each function they code. For these reasons, tools such as Beagle and AIRS provide approximations to function/package logic speciocations.
Reference: [7] <author> P. Devanbu, R. J. Brachman, P. G. Selfridge, and B. W. Ballard. </author> <title> Lassie: A knowledge-based software information system. </title> <journal> Communications of the ACM, </journal> <volume> 34(5):3549, </volume> <month> May </month> <year> 1991. </year>
Reference-contexts: package query, the user specioes the package P 2 by feature terms and a list of member functions, along with the feature terms for each such function, and AIRS returns a list of packages packages P 1 in order of increasing package distance to P 2: 2.5.3 Related Tools LaSSIE <ref> [7] </ref> uses a frame-based system [41] to capture inheritance of properties.
Reference: [8] <author> P. T. Devanbu. </author> <title> GENOAa customizable, language- and front-end independent code analyzer. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <pages> pages 307317, </pages> <address> New York, 1992. </address> <publisher> ACM. </publisher>
Reference-contexts: This simplioes patterns (eg., there is only one loop construct) and makes retargetting the tool to another language simpler (i.e., one only modioes the front end and not the pattern matching engine). GENOA <ref> [8] </ref> combines TAWK's abstract syntax tree with A*'s user-deoned tree traversals. 2.3 GRASPR Tool Pattern Text Technique References GRASPR attributed data AEow attributed simulate nondeterministic [49, 48, 47, 38, 37] graph grammar data AEow graph stack-based graph parser The GRASPR (GRAph-based System for Program Recognition) tool [49, 48, 47, 38, 37]
Reference: [9] <author> J. Earley. </author> <title> An eOEcient context-free parsing algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 13(2):94 102, </volume> <month> February </month> <year> 1970. </year>
Reference-contexts: GRASPR uses a graph parsing algorithm similar to that developed by Brotsky [4] and extended by Lutz [30]; these graph parsing algorithms are inspired by Earley's string parsing algorithm <ref> [9] </ref>. The graph parser simulation maintains a chart of items to store all parses found so far.
Reference: [10] <author> J. Ferrante, K. Ottenstein, and J. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3):319349, </volume> <month> July </month> <year> 1987. </year>
Reference-contexts: Similarly, we can have a control AEow edge from the start node i$B$j to the i+j and ij functions to indicate that these functions always executes on each invocation of the procedure RIGHTP. Indeed, such a representation would be quite similar to a program dependence graph <ref> [10, 19] </ref>, which has control and data dependence edges. 3 (See Figure 13; contrast this with graph (which has assignment nodes); the latter will, unfortunately, distinguish between data passed through nested expressions versus that via bindings to intermediate variables (eg., c=(a+b)*2; versus c=(a+b); c=c*2;).
Reference: [11] <author> B. Fischer, M. Kievernagel, and W. Struckmann. </author> <title> High-precision retrieval for high-quality software. </title> <booktitle> In Proceedings of the 4th Software Quality Conference, </booktitle> <volume> volume 1, </volume> <pages> pages 8088, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: In particular, Beagle uses signature matching as a crude form of speciocation matching <ref> [52, 11] </ref>. In specializing the pattern to a signature and the text to a signature library, the tool maker hopes to increase precision over more general tools.
Reference: [12] <author> W. B. Frakes and B. A. Nejmeh. </author> <title> An information system for software reuse. </title> <editor> In W. Tracz, editor, </editor> <booktitle> Software reuse: Emerging Technology. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: Other systems <ref> [12, 31] </ref> use a more lightweight approach by automatically extracting representative keywords from the function/package documentation. The user can then perform queries using keywords. 3 EOEciency It is crucial that a software engineering tool scale to large systems with millions of lines of code.
Reference: [13] <author> Z. Galil and Kunsoo-Park. </author> <title> An improved algorithm for approximate string matching. </title> <journal> SIAM Journal on Computing, </journal> <volume> 19(6):989999, </volume> <year> 1990. </year>
Reference-contexts: One may also want an approximate match in which the pattern string p matches a substring x of the text if and only if d (p; x) k for some distance metric d (eg., edit distance) and user specioed constant k <ref> [13] </ref>.
Reference: [14] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability: A Guide to the theory of NP-Completeness. </title> <publisher> Freeman and Company, </publisher> <year> 1979. </year>
Reference-contexts: Also, it would be interesting to see if grammar patterns can be used with other text representations. For string text, tools like yacc [20] are available which parse the entire string according to a 2 Although this may appear to require solving the subgraph isomorphism problem which is NP-complete <ref> [14] </ref>, observe that many of the nodes and edges in an attributed data AEow graph have distinct labelsa property that can reduce the search for subgraphs signiocantly. 18 grammar.
Reference: [15] <author> W. G. Griswold, D. C. Atkinson, and C. McCurdy. </author> <title> Fast, AEexible, syntactic pattern matching and processing. </title> <booktitle> In Proceedings of the 4th Workshop on Program Comprehension, </booktitle> <pages> pages 144153, </pages> <address> Los Alamitos, California, 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Each new 2-tuple is then inserted into the queue, if it is not there already, at the appropriate location so as to preserve the increasing preorder numbering of syntax tree nodes. (Figure 4 shows a path that leads to an accepting state in the automaton simulation.) 2.2.2 Related Tools TAWK <ref> [15] </ref> and A* [27] improve upon SCRUPLE by allowing the user to associate action code with patterns. Both tools take a sequence of (pattern, action) pairs, where a pattern in TAWK is a tree regular expression while in A* it is a grammar rule.
Reference: [16] <author> J. Hartman. </author> <title> Automatic control understanding for natural programs. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1991. </year> <type> Technical Report AI 91-161. 21 </type>
Reference-contexts: For example, PROUST [21] only allows variations in the clichs accounted for by idioeerence rulesj. Both [21] and [42] use knowledge about the purpose of the program to narrow down the search for clichs. Whereas GRASPR uses a data AEow graph with control AEow attributes, UNPROG <ref> [16] </ref> uses a control AEow graph with data AEow attributes.
Reference: [17] <author> J. Hartmanis. </author> <title> On the succinctness of dioeerent representations of languages. </title> <journal> SIAM Journal on Computing, </journal> <volume> 9(1):114120, </volume> <year> 1980. </year>
Reference-contexts: As shown above, LSME gives the user signiocant leverage in specifying simple and succinct regular expressions queries. (The question concerning the relative succinctness of dioeerent regular expression notations is of theoretical interest; see <ref> [17, 32] </ref>.) With other lexical tools, programmers will probably use simple but less precise regular expressions and/or action code. This can result in false positives and false negatives.
Reference: [18] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The scanner reads this ole and converts each regular expression into a deterministic onite automata. (This conversion is described in <ref> [18] </ref>, Chapter 2.) The transition values are the tokens found in the regular expressions, each being either a single-character or an identioer as discussed earlier. The result is a forest of onite automata with the same hierarchical relationships as those of the regular expressions from which the automata were derived. <p> Whereas the automaton simulated by SCRUPLE has onite memory, the one simulated by GRASPR is a stack-based graph parser with unbounded memory (similar to a nondeterministic pushdown automata <ref> [18] </ref>). GRASPR uses a graph parsing algorithm similar to that developed by Brotsky [4] and extended by Lutz [30]; these graph parsing algorithms are inspired by Earley's string parsing algorithm [9]. The graph parser simulation maintains a chart of items to store all parses found so far. <p> In particular, a regular expression, being equivalent in power to a onite automata (i.e., with onite memory), can only be used to match items in which one need not irememberj or icountj an arbitrarily large number of characters (see [2], page 98, and <ref> [18] </ref>, pages 5558). To illustrate the problem, suppose we want to ond a while statement followed by a for statement at the same level of nesting in some C source code. <p> Rather, we want to set skipPattern to a regular expression whose language is the complement of the language of .*parent.*[.*child.*. Although regular expressions are closed under complementation, onding skipPattern by hand is by no means trivial (see <ref> [18] </ref>, page 59). Furthermore, we must also encode the LSME rules for choosing matches in the presence of overlapping parent and/or child matches in the input string.
Reference: [19] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1):2660, </volume> <month> January </month> <year> 1990. </year>
Reference-contexts: Similarly, we can have a control AEow edge from the start node i$B$j to the i+j and ij functions to indicate that these functions always executes on each invocation of the procedure RIGHTP. Indeed, such a representation would be quite similar to a program dependence graph <ref> [10, 19] </ref>, which has control and data dependence edges. 3 (See Figure 13; contrast this with graph (which has assignment nodes); the latter will, unfortunately, distinguish between data passed through nested expressions versus that via bindings to intermediate variables (eg., c=(a+b)*2; versus c=(a+b); c=c*2;).
Reference: [20] <author> S. C. Johnson. </author> <title> Yaccyet another compiler compiler. </title> <type> Technical Report 32, </type> <institution> AT&T Bell Laboratories, Murray Hill, N. J., </institution> <year> 1975. </year>
Reference-contexts: Also, it would be interesting to see if grammar patterns can be used with other text representations. For string text, tools like yacc <ref> [20] </ref> are available which parse the entire string according to a 2 Although this may appear to require solving the subgraph isomorphism problem which is NP-complete [14], observe that many of the nodes and edges in an attributed data AEow graph have distinct labelsa property that can reduce the search for
Reference: [21] <author> W. L. Johnson. </author> <title> Intention-Based Diagnosis of Novice Programming Errors. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, CA, </address> <year> 1986. </year>
Reference-contexts: added to the chart, in addition to performing the actions described above, the algorithm also adds items to the agenda for each rule that needs the complete item to get started (because that complete item occurs in the right-hand side of the rule). 2.3.4 Related Tools Some clich recognition systems <ref> [21, 42, 29] </ref> operate directly on the program source (instead of a data AEow graph say) which limits the syntactic variability and interleaving with other code that they can handle. For example, PROUST [21] only allows variations in the clichs accounted for by idioeerence rulesj. <p> For example, PROUST <ref> [21] </ref> only allows variations in the clichs accounted for by idioeerence rulesj. Both [21] and [42] use knowledge about the purpose of the program to narrow down the search for clichs. <p> For example, PROUST <ref> [21] </ref> only allows variations in the clichs accounted for by idioeerence rulesj. Both [21] and [42] use knowledge about the purpose of the program to narrow down the search for clichs. Whereas GRASPR uses a data AEow graph with control AEow attributes, UNPROG [16] uses a control AEow graph with data AEow attributes.
Reference: [22] <author> K. Gdel. </author> <title> ber die Vollstndigkeit des Logikkalkls. </title> <type> PhD thesis, </type> <institution> University of Vienna, </institution> <year> 1930. </year>
Reference-contexts: Unfortunately, determining whether a query speciocation matches that of a function in the library is semidecidable <ref> [22, 45, 6] </ref>and undecidable if we also include arithmetic in the logic [23]. Moreover, programmers don't want the burden of writing complicated logic speciocations for each function they code. For these reasons, tools such as Beagle and AIRS provide approximations to function/package logic speciocations.
Reference: [23] <author> K. Gdel. </author> <title> ber formal unentscheidbare Stze der Principia mathematica und verwandter Systeme I. </title> <institution> Monatschefte fr Mathematik und Physic, 38:173198, </institution> <year> 1931. </year>
Reference-contexts: Unfortunately, determining whether a query speciocation matches that of a function in the library is semidecidable [22, 45, 6]and undecidable if we also include arithmetic in the logic <ref> [23] </ref>. Moreover, programmers don't want the burden of writing complicated logic speciocations for each function they code. For these reasons, tools such as Beagle and AIRS provide approximations to function/package logic speciocations. Beagle's signature matching is less precise than AIRS feature similarity measures.
Reference: [24] <author> R. M. Karp and M. O. Rabin. </author> <title> EOEcient randomized pattern matching. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 31(2):249260, </volume> <year> 1987. </year>
Reference-contexts: Perhaps the most fundamental form of pattern matching involves a string pattern and string text. There are several interesting ways in which one might want the pattern to match the text. Most obvious is an exact match were the pattern string must occur verbatim in the text <ref> [5, 24, 26] </ref>. One may also want an approximate match in which the pattern string p matches a substring x of the text if and only if d (p; x) k for some distance metric d (eg., edit distance) and user specioed constant k [13].
Reference: [25] <author> B. W. Kernighan and R. Pike. </author> <title> The UNIX Programming Environment. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Clioes, NJ, </address> <year> 1984. </year>
Reference-contexts: Speciocally, how does one ond items of interest in source code? Even in this restricted domain, numerous tools have been developed which vary widely in the kinds of patterns and texts they use and the pattern matching techniques they employ. Moreover, many general purpose tools, such as grep <ref> [25] </ref>, are widely used in the software engineering domain. Perhaps the most fundamental form of pattern matching involves a string pattern and string text. There are several interesting ways in which one might want the pattern to match the text. <p> These include grep <ref> [25] </ref>, awk [1], lex [28], and perl [46]. Grep only searches for matches that do not span multiple lines and has no support for action code.
Reference: [26] <author> D. E. Knuth, J. H. Morris, and V. R. Pratt. </author> <title> Fast pattern matching in strings. </title> <journal> SIAM Journal of Computing, </journal> <volume> 6(2):323350, </volume> <year> 1977. </year>
Reference-contexts: Perhaps the most fundamental form of pattern matching involves a string pattern and string text. There are several interesting ways in which one might want the pattern to match the text. Most obvious is an exact match were the pattern string must occur verbatim in the text <ref> [5, 24, 26] </ref>. One may also want an approximate match in which the pattern string p matches a substring x of the text if and only if d (p; x) k for some distance metric d (eg., edit distance) and user specioed constant k [13].
Reference: [27] <author> D. A. Ladd and J. C. Ramming. </author> <title> A*: A language for implementing language processors. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(11):894901, </volume> <month> November </month> <year> 1995. </year>
Reference-contexts: is then inserted into the queue, if it is not there already, at the appropriate location so as to preserve the increasing preorder numbering of syntax tree nodes. (Figure 4 shows a path that leads to an accepting state in the automaton simulation.) 2.2.2 Related Tools TAWK [15] and A* <ref> [27] </ref> improve upon SCRUPLE by allowing the user to associate action code with patterns. Both tools take a sequence of (pattern, action) pairs, where a pattern in TAWK is a tree regular expression while in A* it is a grammar rule.
Reference: [28] <author> M. E. Lesk. </author> <title> Lexa lexical analyzer generator. </title> <type> Technical Report 39, </type> <institution> AT&T Bell Laboratories, Murray Hill, N. J., </institution> <year> 1975. </year>
Reference-contexts: These include grep [25], awk [1], lex <ref> [28] </ref>, and perl [46]. Grep only searches for matches that do not span multiple lines and has no support for action code. Awk, lex, and perl relax these restrictions but only awk and perl support 3 unifying parts of the matched text to variables in the user's action code.
Reference: [29] <author> F. J. Lukey. </author> <title> Understanding and debugging programs. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 12:189202, </volume> <year> 1980. </year>
Reference-contexts: added to the chart, in addition to performing the actions described above, the algorithm also adds items to the agenda for each rule that needs the complete item to get started (because that complete item occurs in the right-hand side of the rule). 2.3.4 Related Tools Some clich recognition systems <ref> [21, 42, 29] </ref> operate directly on the program source (instead of a data AEow graph say) which limits the syntactic variability and interleaving with other code that they can handle. For example, PROUST [21] only allows variations in the clichs accounted for by idioeerence rulesj.
Reference: [30] <author> R. Lutz. </author> <title> Chart parsing of AEowgraphs. </title> <booktitle> In Proceedings of the 11th International Joint Conference on Artiocial Intelligence, </booktitle> <pages> pages 116121, </pages> <address> Detroit, Michigan, </address> <year> 1989. </year>
Reference-contexts: Whereas the automaton simulated by SCRUPLE has onite memory, the one simulated by GRASPR is a stack-based graph parser with unbounded memory (similar to a nondeterministic pushdown automata [18]). GRASPR uses a graph parsing algorithm similar to that developed by Brotsky [4] and extended by Lutz <ref> [30] </ref>; these graph parsing algorithms are inspired by Earley's string parsing algorithm [9]. The graph parser simulation maintains a chart of items to store all parses found so far.
Reference: [31] <author> Y. S. Maarek, D. M. Berry, and G. E. Kaiser. </author> <title> An information-retrieval approach for automatically constructing software libraries. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(18):800 813, </volume> <month> August </month> <year> 1991. </year>
Reference-contexts: Other systems <ref> [12, 31] </ref> use a more lightweight approach by automatically extracting representative keywords from the function/package documentation. The user can then perform queries using keywords. 3 EOEciency It is crucial that a software engineering tool scale to large systems with millions of lines of code.
Reference: [32] <author> A. R. Meyer and M. J. Fischer. </author> <title> Economy of description by automata, grammars, and formal systems. </title> <booktitle> In Proceedings of the IEEE Symposium on Switching and Automata Theory, </booktitle> <pages> pages 188190, </pages> <year> 1971. </year>
Reference-contexts: As shown above, LSME gives the user signiocant leverage in specifying simple and succinct regular expressions queries. (The question concerning the relative succinctness of dioeerent regular expression notations is of theoretical interest; see <ref> [17, 32] </ref>.) With other lexical tools, programmers will probably use simple but less precise regular expressions and/or action code. This can result in false positives and false negatives.
Reference: [33] <author> G. C. Murphy and D. Notkin. </author> <title> Lightweight lexical source model extraction. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(3):262292, </volume> <month> July </month> <year> 1996. </year> <month> 22 </month>
Reference-contexts: Indeed, some of the tools I will describe use syntax and semantics to make the pattern matching more precise. However, we will also see that one has to be satisoed with approximations to the code's meaning for eOEciency reasons. In this paper, I will consider the following tools: LSME <ref> [33] </ref>, SCRUPLE [36], GRASPR [49], Beagle [51], and AIRS [34]. LSME is a lexical tool, SCRUPLE is a syntactic tool, while GRASPR, Beagle, and AIRS are all semantic tools. <p> For example, tools that use a string pattern and a string text would be shown in the upper left corner of the table.) Pattern similar to text regular expression grammar string LSME <ref> [33] </ref> syntax tree SCRUPLE [36] Text attributed data AEow graph GRASPR [49] function/package signatures Beagle [51] function/package features AIRS [34] I will describe the ove pattern matching tools and then compare and contrast in them terms of eOEciency and precision. <p> and precision, respectively; Section 5 discusses which (if any) of these tools one might use in practice; Section 6 presents several future research directions; and Section 7 concludes with a summary of the paper. 2 Tools 2.1 LSME Tool Pattern Text Technique Reference LSME hierarchies of string simulate hierarchies of <ref> [33] </ref> regular expressions deterministic onite automata The LSME (Lexical Source Model Extraction) scanner tool [33] goes beyond regular expression-based tools by using a more sophisticated pattern: hierarchies of regular expressions on tokens (eg., identioers, numbers, characters). As an example, consider the following pattern for extracting C function calls. <p> use in practice; Section 6 presents several future research directions; and Section 7 concludes with a summary of the paper. 2 Tools 2.1 LSME Tool Pattern Text Technique Reference LSME hierarchies of string simulate hierarchies of <ref> [33] </ref> regular expressions deterministic onite automata The LSME (Lexical Source Model Extraction) scanner tool [33] goes beyond regular expression-based tools by using a more sophisticated pattern: hierarchies of regular expressions on tokens (eg., identioers, numbers, characters). As an example, consider the following pattern for extracting C function calls.
Reference: [34] <author> E. Ostertag, J. Hendler, R. P. Diaz, and C. Braun. </author> <title> Computing similarity in a reuse library system: An AI-based approach. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(3):205228, </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: However, we will also see that one has to be satisoed with approximations to the code's meaning for eOEciency reasons. In this paper, I will consider the following tools: LSME [33], SCRUPLE [36], GRASPR [49], Beagle [51], and AIRS <ref> [34] </ref>. LSME is a lexical tool, SCRUPLE is a syntactic tool, while GRASPR, Beagle, and AIRS are all semantic tools. <p> example, tools that use a string pattern and a string text would be shown in the upper left corner of the table.) Pattern similar to text regular expression grammar string LSME [33] syntax tree SCRUPLE [36] Text attributed data AEow graph GRASPR [49] function/package signatures Beagle [51] function/package features AIRS <ref> [34] </ref> I will describe the ove pattern matching tools and then compare and contrast in them terms of eOEciency and precision. Both eOEciency and precision are important in a software engineering tool and there are generally tradeooes between the two. <p> Moreover, Beagle is the orst tool to support package signature matching. Recent work [44] improves upon Beagle by introducing a subset match, which is like reorder match but allows tuple elements to be dropped. 9 2.5 AIRS Tool Pattern Text Technique Reference AIRS function/package function/package semantic distance <ref> [34, 35] </ref> features features metrics AIRS (AI-based Reuse System) [34, 35] allows a programmer to ond a function or package in a library that best approximates some requirement. For example, the programmer may want a function that iinserts an element at the front of a structurej. <p> Recent work [44] improves upon Beagle by introducing a subset match, which is like reorder match but allows tuple elements to be dropped. 9 2.5 AIRS Tool Pattern Text Technique Reference AIRS function/package function/package semantic distance <ref> [34, 35] </ref> features features metrics AIRS (AI-based Reuse System) [34, 35] allows a programmer to ond a function or package in a library that best approximates some requirement. For example, the programmer may want a function that iinserts an element at the front of a structurej.
Reference: [35] <author> E. J. Ostertag and J. A. Hendler. </author> <title> An AI-based reuse system. </title> <type> Technical Report UMIACS-TR-89-16, </type> <institution> University of Maryland, </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: Moreover, Beagle is the orst tool to support package signature matching. Recent work [44] improves upon Beagle by introducing a subset match, which is like reorder match but allows tuple elements to be dropped. 9 2.5 AIRS Tool Pattern Text Technique Reference AIRS function/package function/package semantic distance <ref> [34, 35] </ref> features features metrics AIRS (AI-based Reuse System) [34, 35] allows a programmer to ond a function or package in a library that best approximates some requirement. For example, the programmer may want a function that iinserts an element at the front of a structurej. <p> Recent work [44] improves upon Beagle by introducing a subset match, which is like reorder match but allows tuple elements to be dropped. 9 2.5 AIRS Tool Pattern Text Technique Reference AIRS function/package function/package semantic distance <ref> [34, 35] </ref> features features metrics AIRS (AI-based Reuse System) [34, 35] allows a programmer to ond a function or package in a library that best approximates some requirement. For example, the programmer may want a function that iinserts an element at the front of a structurej.
Reference: [36] <author> S. Paul and A. Prakash. </author> <title> A framework for source code searching using program patterns. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(6):463475, </volume> <month> June </month> <year> 1994. </year>
Reference-contexts: However, we will also see that one has to be satisoed with approximations to the code's meaning for eOEciency reasons. In this paper, I will consider the following tools: LSME [33], SCRUPLE <ref> [36] </ref>, GRASPR [49], Beagle [51], and AIRS [34]. LSME is a lexical tool, SCRUPLE is a syntactic tool, while GRASPR, Beagle, and AIRS are all semantic tools. <p> For example, tools that use a string pattern and a string text would be shown in the upper left corner of the table.) Pattern similar to text regular expression grammar string LSME [33] syntax tree SCRUPLE <ref> [36] </ref> Text attributed data AEow graph GRASPR [49] function/package signatures Beagle [51] function/package features AIRS [34] I will describe the ove pattern matching tools and then compare and contrast in them terms of eOEciency and precision. <p> None of these tools support LSME's hierarchical regular expressions or heuristic tokenization. 2.2 SCRUPLE Tool Pattern Text Technique Reference SCRUPLE tree regular syntax tree simulate nondeterministic <ref> [36] </ref> expression onite tree automata The SCRUPLE tool [36] parses the user's source code to obtain a syntax tree text and uses a itree regular expressionj pattern to search for items of interest in this text. <p> None of these tools support LSME's hierarchical regular expressions or heuristic tokenization. 2.2 SCRUPLE Tool Pattern Text Technique Reference SCRUPLE tree regular syntax tree simulate nondeterministic <ref> [36] </ref> expression onite tree automata The SCRUPLE tool [36] parses the user's source code to obtain a syntax tree text and uses a itree regular expressionj pattern to search for items of interest in this text.
Reference: [37] <author> C. Rich and R. C. Waters. </author> <title> The Programmer's Apprentice. </title> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: GENOA [8] combines TAWK's abstract syntax tree with A*'s user-deoned tree traversals. 2.3 GRASPR Tool Pattern Text Technique References GRASPR attributed data AEow attributed simulate nondeterministic <ref> [49, 48, 47, 38, 37] </ref> graph grammar data AEow graph stack-based graph parser The GRASPR (GRAph-based System for Program Recognition) tool [49, 48, 47, 38, 37] converts the user's code into an attributed data AEow graph text representation and uses an attributed data AEow graph grammar pattern to identify clichs in <p> GENOA [8] combines TAWK's abstract syntax tree with A*'s user-deoned tree traversals. 2.3 GRASPR Tool Pattern Text Technique References GRASPR attributed data AEow attributed simulate nondeterministic <ref> [49, 48, 47, 38, 37] </ref> graph grammar data AEow graph stack-based graph parser The GRASPR (GRAph-based System for Program Recognition) tool [49, 48, 47, 38, 37] converts the user's code into an attributed data AEow graph text representation and uses an attributed data AEow graph grammar pattern to identify clichs in the text. Clichs are common algorithmic computations (such as binary search) and data structures (such as hash tables).
Reference: [38] <author> C. Rich and L. M. Wills. </author> <title> Recognizing a program's design: a graph-parsing approach. </title> <journal> IEEE Software, </journal> <volume> 7(1):8289, </volume> <month> January </month> <year> 1990. </year>
Reference-contexts: GENOA [8] combines TAWK's abstract syntax tree with A*'s user-deoned tree traversals. 2.3 GRASPR Tool Pattern Text Technique References GRASPR attributed data AEow attributed simulate nondeterministic <ref> [49, 48, 47, 38, 37] </ref> graph grammar data AEow graph stack-based graph parser The GRASPR (GRAph-based System for Program Recognition) tool [49, 48, 47, 38, 37] converts the user's code into an attributed data AEow graph text representation and uses an attributed data AEow graph grammar pattern to identify clichs in <p> GENOA [8] combines TAWK's abstract syntax tree with A*'s user-deoned tree traversals. 2.3 GRASPR Tool Pattern Text Technique References GRASPR attributed data AEow attributed simulate nondeterministic <ref> [49, 48, 47, 38, 37] </ref> graph grammar data AEow graph stack-based graph parser The GRASPR (GRAph-based System for Program Recognition) tool [49, 48, 47, 38, 37] converts the user's code into an attributed data AEow graph text representation and uses an attributed data AEow graph grammar pattern to identify clichs in the text. Clichs are common algorithmic computations (such as binary search) and data structures (such as hash tables).
Reference: [39] <author> M. Rittri. </author> <title> Using types as search keys in function libraries. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architectures, </booktitle> <pages> pages 174183, </pages> <address> Reading, Mass., 1989. </address> <publisher> Addison-Wesley. </publisher>
Reference-contexts: Finally, if the inverse relation U 1 F is a one-to-one function (but possibly not onto), then we have a generalized package match; such a match implies that I L may have more functions than I Q . 2.4.3 Related Tools Function signature matching was orst proposed simultaneously in <ref> [39] </ref> and [40].
Reference: [40] <author> C. Runciman and I. Toyn. </author> <title> Retrieving re-usable software components by polymorphic type. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architectures, </booktitle> <pages> pages 166173, </pages> <address> Reading, Mass., 1989. </address> <publisher> Addison-Wesley. </publisher>
Reference-contexts: if the inverse relation U 1 F is a one-to-one function (but possibly not onto), then we have a generalized package match; such a match implies that I L may have more functions than I Q . 2.4.3 Related Tools Function signature matching was orst proposed simultaneously in [39] and <ref> [40] </ref>. While these early eoeorts deone one type of match ((M reorder function ffi M uncurry function )(o l ; o q ) and M unify function (o l ; o q ), respectively), the Beagle tool allows the user to choose a composition of primitive matches for the query.
Reference: [41] <author> S. Russell and P. Norvig. </author> <title> Artiocial Intelligence: A Modern Approach. </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference-contexts: the package P 2 by feature terms and a list of member functions, along with the feature terms for each such function, and AIRS returns a list of packages packages P 1 in order of increasing package distance to P 2: 2.5.3 Related Tools LaSSIE [7] uses a frame-based system <ref> [41] </ref> to capture inheritance of properties.
Reference: [42] <author> G. R. Ruth. </author> <title> Analysis of algorithm implementations. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1974. </year> <type> Technical Report 130. </type>
Reference-contexts: added to the chart, in addition to performing the actions described above, the algorithm also adds items to the agenda for each rule that needs the complete item to get started (because that complete item occurs in the right-hand side of the rule). 2.3.4 Related Tools Some clich recognition systems <ref> [21, 42, 29] </ref> operate directly on the program source (instead of a data AEow graph say) which limits the syntactic variability and interleaving with other code that they can handle. For example, PROUST [21] only allows variations in the clichs accounted for by idioeerence rulesj. <p> For example, PROUST [21] only allows variations in the clichs accounted for by idioeerence rulesj. Both [21] and <ref> [42] </ref> use knowledge about the purpose of the program to narrow down the search for clichs. Whereas GRASPR uses a data AEow graph with control AEow attributes, UNPROG [16] uses a control AEow graph with data AEow attributes.
Reference: [43] <author> R. Sedgewick. </author> <title> Algorithms in C. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: To show that this complexity is typical for onding regular expression matches in strings, the authors reference <ref> [43] </ref> which presents an algorithm with a worst case running time of O (n 2 ). However, this is misleading because O (n 2 ) is the worst case time to ond all matches in the string text not just one which would only take O (n) time.
Reference: [44] <author> D. W. J. Stringer-Calvert. </author> <title> Signature matching for ada software reuse. </title> <type> Master's thesis, </type> <institution> University of York, </institution> <year> 1994. </year>
Reference-contexts: Moreover, Beagle is the orst tool to support package signature matching. Recent work <ref> [44] </ref> improves upon Beagle by introducing a subset match, which is like reorder match but allows tuple elements to be dropped. 9 2.5 AIRS Tool Pattern Text Technique Reference AIRS function/package function/package semantic distance [34, 35] features features metrics AIRS (AI-based Reuse System) [34, 35] allows a programmer to ond a
Reference: [45] <author> A. M. </author> <title> Turing. On computable numbers, with an application to the entscheidungsproblem. </title> <booktitle> Proceedings of the London Mathematical Society, 2nd series, 42:230265, 1936. Correction published in Vol. </booktitle> <volume> 43, </volume> <pages> pages 544546. </pages>
Reference-contexts: Unfortunately, determining whether a query speciocation matches that of a function in the library is semidecidable <ref> [22, 45, 6] </ref>and undecidable if we also include arithmetic in the logic [23]. Moreover, programmers don't want the burden of writing complicated logic speciocations for each function they code. For these reasons, tools such as Beagle and AIRS provide approximations to function/package logic speciocations.
Reference: [46] <author> L. Wall. </author> <title> Programming Perl. </title> <publisher> O'Reilly and Associates, </publisher> <address> Sebastopol, California, </address> <year> 1990. </year>
Reference-contexts: These include grep [25], awk [1], lex [28], and perl <ref> [46] </ref>. Grep only searches for matches that do not span multiple lines and has no support for action code. Awk, lex, and perl relax these restrictions but only awk and perl support 3 unifying parts of the matched text to variables in the user's action code.
Reference: [47] <author> L. M. Wills. </author> <title> Automated program recognition: A feasibility demonstration. </title> <journal> Artiocial Intelligence, </journal> <volume> 45(12):113171, </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: GENOA [8] combines TAWK's abstract syntax tree with A*'s user-deoned tree traversals. 2.3 GRASPR Tool Pattern Text Technique References GRASPR attributed data AEow attributed simulate nondeterministic <ref> [49, 48, 47, 38, 37] </ref> graph grammar data AEow graph stack-based graph parser The GRASPR (GRAph-based System for Program Recognition) tool [49, 48, 47, 38, 37] converts the user's code into an attributed data AEow graph text representation and uses an attributed data AEow graph grammar pattern to identify clichs in <p> GENOA [8] combines TAWK's abstract syntax tree with A*'s user-deoned tree traversals. 2.3 GRASPR Tool Pattern Text Technique References GRASPR attributed data AEow attributed simulate nondeterministic <ref> [49, 48, 47, 38, 37] </ref> graph grammar data AEow graph stack-based graph parser The GRASPR (GRAph-based System for Program Recognition) tool [49, 48, 47, 38, 37] converts the user's code into an attributed data AEow graph text representation and uses an attributed data AEow graph grammar pattern to identify clichs in the text. Clichs are common algorithmic computations (such as binary search) and data structures (such as hash tables).
Reference: [48] <author> L. M. Wills. </author> <title> Automated program recognition by graph parsing. </title> <type> PhD thesis, </type> <institution> MIT Artiocial Intelligence Lab, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: GENOA [8] combines TAWK's abstract syntax tree with A*'s user-deoned tree traversals. 2.3 GRASPR Tool Pattern Text Technique References GRASPR attributed data AEow attributed simulate nondeterministic <ref> [49, 48, 47, 38, 37] </ref> graph grammar data AEow graph stack-based graph parser The GRASPR (GRAph-based System for Program Recognition) tool [49, 48, 47, 38, 37] converts the user's code into an attributed data AEow graph text representation and uses an attributed data AEow graph grammar pattern to identify clichs in <p> GENOA [8] combines TAWK's abstract syntax tree with A*'s user-deoned tree traversals. 2.3 GRASPR Tool Pattern Text Technique References GRASPR attributed data AEow attributed simulate nondeterministic <ref> [49, 48, 47, 38, 37] </ref> graph grammar data AEow graph stack-based graph parser The GRASPR (GRAph-based System for Program Recognition) tool [49, 48, 47, 38, 37] converts the user's code into an attributed data AEow graph text representation and uses an attributed data AEow graph grammar pattern to identify clichs in the text. Clichs are common algorithmic computations (such as binary search) and data structures (such as hash tables).
Reference: [49] <author> L. M. Wills. </author> <title> Using attributed AEow graph parsing to recognize clichs in programs. </title> <editor> In J. Cuny, H. Ehrig, G. Engels, and G. Rozenberg, editors, </editor> <booktitle> Graph Grammars and Their Application to Computer Science, </booktitle> <pages> pages 170184. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: However, we will also see that one has to be satisoed with approximations to the code's meaning for eOEciency reasons. In this paper, I will consider the following tools: LSME [33], SCRUPLE [36], GRASPR <ref> [49] </ref>, Beagle [51], and AIRS [34]. LSME is a lexical tool, SCRUPLE is a syntactic tool, while GRASPR, Beagle, and AIRS are all semantic tools. <p> For example, tools that use a string pattern and a string text would be shown in the upper left corner of the table.) Pattern similar to text regular expression grammar string LSME [33] syntax tree SCRUPLE [36] Text attributed data AEow graph GRASPR <ref> [49] </ref> function/package signatures Beagle [51] function/package features AIRS [34] I will describe the ove pattern matching tools and then compare and contrast in them terms of eOEciency and precision. Both eOEciency and precision are important in a software engineering tool and there are generally tradeooes between the two. <p> GENOA [8] combines TAWK's abstract syntax tree with A*'s user-deoned tree traversals. 2.3 GRASPR Tool Pattern Text Technique References GRASPR attributed data AEow attributed simulate nondeterministic <ref> [49, 48, 47, 38, 37] </ref> graph grammar data AEow graph stack-based graph parser The GRASPR (GRAph-based System for Program Recognition) tool [49, 48, 47, 38, 37] converts the user's code into an attributed data AEow graph text representation and uses an attributed data AEow graph grammar pattern to identify clichs in <p> GENOA [8] combines TAWK's abstract syntax tree with A*'s user-deoned tree traversals. 2.3 GRASPR Tool Pattern Text Technique References GRASPR attributed data AEow attributed simulate nondeterministic <ref> [49, 48, 47, 38, 37] </ref> graph grammar data AEow graph stack-based graph parser The GRASPR (GRAph-based System for Program Recognition) tool [49, 48, 47, 38, 37] converts the user's code into an attributed data AEow graph text representation and uses an attributed data AEow graph grammar pattern to identify clichs in the text. Clichs are common algorithmic computations (such as binary search) and data structures (such as hash tables).
Reference: [50] <author> A. M. Zaremski. </author> <title> Signature and Speciocation Matching. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: UNPROG can easily ond control 7 AEow clichs using simple exact graph matching (eg., ibounded linear searchj) but has problems with clichs based on data AEow (due to syntactic variations and interleaving with other code). 2.4 Beagle Tool Pattern Text Techniques References Beagle function/package function/package (1) exact (4) unify <ref> [51, 50] </ref> signature signatures (2) specialized (5) uncurry (3) generalized (6) reorder A signature denotes the type of a function or the interface of a package. The Beagle tool [51, 50] automatically derives a signature library text from the code which the user can then search using a signature pattern. <p> syntactic variations and interleaving with other code). 2.4 Beagle Tool Pattern Text Techniques References Beagle function/package function/package (1) exact (4) unify <ref> [51, 50] </ref> signature signatures (2) specialized (5) uncurry (3) generalized (6) reorder A signature denotes the type of a function or the interface of a package. The Beagle tool [51, 50] automatically derives a signature library text from the code which the user can then search using a signature pattern. The idea behind signature matching is that one can search for functions or packages that perform certain tasks (i.e., reuse candidates) by searching for their signatures.
Reference: [51] <author> A. M. Zaremski and J. M. Wing. </author> <title> Signature matching: A tool for using software libraries. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 4(2):146170, </volume> <month> April </month> <year> 1995. </year> <month> 23 </month>
Reference-contexts: However, we will also see that one has to be satisoed with approximations to the code's meaning for eOEciency reasons. In this paper, I will consider the following tools: LSME [33], SCRUPLE [36], GRASPR [49], Beagle <ref> [51] </ref>, and AIRS [34]. LSME is a lexical tool, SCRUPLE is a syntactic tool, while GRASPR, Beagle, and AIRS are all semantic tools. <p> For example, tools that use a string pattern and a string text would be shown in the upper left corner of the table.) Pattern similar to text regular expression grammar string LSME [33] syntax tree SCRUPLE [36] Text attributed data AEow graph GRASPR [49] function/package signatures Beagle <ref> [51] </ref> function/package features AIRS [34] I will describe the ove pattern matching tools and then compare and contrast in them terms of eOEciency and precision. Both eOEciency and precision are important in a software engineering tool and there are generally tradeooes between the two. <p> UNPROG can easily ond control 7 AEow clichs using simple exact graph matching (eg., ibounded linear searchj) but has problems with clichs based on data AEow (due to syntactic variations and interleaving with other code). 2.4 Beagle Tool Pattern Text Techniques References Beagle function/package function/package (1) exact (4) unify <ref> [51, 50] </ref> signature signatures (2) specialized (5) uncurry (3) generalized (6) reorder A signature denotes the type of a function or the interface of a package. The Beagle tool [51, 50] automatically derives a signature library text from the code which the user can then search using a signature pattern. <p> syntactic variations and interleaving with other code). 2.4 Beagle Tool Pattern Text Techniques References Beagle function/package function/package (1) exact (4) unify <ref> [51, 50] </ref> signature signatures (2) specialized (5) uncurry (3) generalized (6) reorder A signature denotes the type of a function or the interface of a package. The Beagle tool [51, 50] automatically derives a signature library text from the code which the user can then search using a signature pattern. The idea behind signature matching is that one can search for functions or packages that perform certain tasks (i.e., reuse candidates) by searching for their signatures.
Reference: [52] <author> A. M. Zaremski and J. M. Wing. </author> <title> Speciocation matching of software components. </title> <booktitle> Proceedings of SIGSOFT'95 Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, ACM SIGSOFT Software Engineering Notes, </booktitle> <address> 20(4):617, </address> <month> October </month> <year> 1995. </year> <month> 24 </month>
Reference-contexts: In particular, Beagle uses signature matching as a crude form of speciocation matching <ref> [52, 11] </ref>. In specializing the pattern to a signature and the text to a signature library, the tool maker hopes to increase precision over more general tools.
References-found: 52

