URL: http://www.cs.rice.edu/CS/PLT/Publications/tr94-238.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: The Semantics of Future  
Author: Cormac Flanagan Matthias Felleisen 
Date: October 1994  
Address: COMP TR94-238  P.O. Box 1892 Houston, TX 77251-1892  
Affiliation: Rice  Department of Computer Science Rice University  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Baker, H., and Hewitt, C. </author> <title> The incremental garbage collection of processes. </title> <booktitle> In Proceedings of the Symposium on Artificial Intelligence and Programming Languages (1977), </booktitle> <volume> vol. 12(8), </volume> <pages> pp. 55-59. </pages>
Reference-contexts: However, if such a strategy were applied indiscriminately, the execution of a program would generate far too many parallel threads. The overhead of managing these threads would clearly outweigh any benefits from parallel execution. The future annotations of MultiLisp <ref> [1, 11] </ref> and its Scheme successors provide a simple method for taming the implicit parallelism of functional programs. If a programmer believes that the parallel evaluation of some expression outweighs the overhead of creating a separate task, he may annotate the expression with the keyword future.
Reference: [2] <author> Cousot, P., and Cousot, R. </author> <title> Abstract interpretation: A unified lattice model for static analyses of programs by consruction or approximation of fixpoints. </title> <booktitle> In POPL (1977), </booktitle> <pages> pp. 238-252. </pages>
Reference-contexts: They also show how the future annotation can be implemented using spawn. Since their primary goal is the derivation of a semantically well-founded abstract interpretation (in the spirit of Cousot and Cousot <ref> [2] </ref>), they extend Deutsch's transition semantics [3] to their language. The transition semantics requires the assignments of a unique label to each sub-expression of a program and expresses computation as the movement of a token from label to label.
Reference: [3] <author> Deutsch, A. </author> <title> Modeles Operationnels de Language de Programmation et Representations de Relations sue des Languages Rationnels avec Application a la Determination Statique de Proprietes de Partages Dynamiques de Donnees. </title> <type> PhD thesis, </type> <institution> Universite Paris VI, </institution> <year> 1992. </year>
Reference-contexts: They also show how the future annotation can be implemented using spawn. Since their primary goal is the derivation of a semantically well-founded abstract interpretation (in the spirit of Cousot and Cousot [2]), they extend Deutsch's transition semantics <ref> [3] </ref> to their language. The transition semantics requires the assignments of a unique label to each sub-expression of a program and expresses computation as the movement of a token from label to label. An auxiliary label on each sub-expression is used to collect information about the values of the expression.
Reference: [4] <author> Feeley, M. </author> <title> An Efficient and General Implementation of Futures on Large Scale Shared-Memory Multiprocessors. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Bran-deis University, </institution> <year> 1993. </year>
Reference-contexts: An annotated functional program has the same observable behavior as the original program, but the run-time system may choose to evaluate the future expression in parallel to the rest of the program. While past research on futures has concentrated on implementation and design issues <ref> [4, 13, 20, 16, 18, 15, 19] </ref>, this technical report focuses on the semantics of futures. Specifically, it presents a series of semantics with varying degrees of intensionality. <p> It focuses on the derivation of a provably correct program analysis algorithm from the last semantics. The paper also describes a optimization algorithm for lowering the overhead of task coordination in a language with futures, and the effects of implementing this optimization for the Gambit compiler <ref> [4] </ref>. The presentation of our semantics for future proceeds as follows. The second section introduces the language we consider and its definitional semantics, which interprets futures as annotations. The third section presents a parallel program rewriting semantics of futures, and the fourth section introduces placeholder objects and touch operations. <p> Alternatively, an implementation may never invoke the rule (fork ), resulting in a purely sequential evaluation. In between these two extremes lie a range of strategies where new tasks are created according to some implementation-dependent and possibly load-dependent algorithm. A particularly efficient strategy is lazy task creation <ref> [4, 19] </ref>, where new tasks are created via fork transitions only when the additional parallelism can exploit idle computing resources. A second source of indeterminism in the specification of the P (C)-machine is the transition rule (parallel). <p> We have used the semantics to derive a provably-correct program optimization algorithm that removes redundant touch operations from programs [7, 8]. Experiments with the Gambit compiler <ref> [4] </ref> show that this optimization substantially reduces program execution times on a standard set of benchmarks. Another important application of the low-level semantics is as a basis from which to derive a parallel and distributed implementation of Scheme with futures.
Reference: [5] <author> Felleisen, M., and Friedman, D. P. </author> <title> Control operators, the SECD-machine, and the lambda-calculus. </title> <booktitle> In 3rd Working Conference on the Formal Description of Programming Concepts (Aug. </booktitle> <year> 1986), </year> <pages> pp. 193-219. </pages>
Reference-contexts: specify the definitional semantics for fl 0 a using a sequential abstract machine called the C-machine (see Figure 2), whose states are either closed terms in the run-time language fl c or the special state error, and whose deterministic transition rules are the typical leftmost-outermost reductions of the lambda calculus <ref> [5] </ref>. Each transition rule also specifies the error semantics of a particular class of expressions. For example, the transition rule for car defines that if the argument to car is a pair, then the transition rule extracts the first element of the pair. <p> Instead, the machine relies on substitution for making progress. To address this problem, we refine the P (C ph )-machine to the P (CEK)-machine (see Figures 7 and 8) using standard techniques <ref> [5, 9] </ref>. 5.1 Specification of the P (CEK )-machine The substitution operation is replaced by an environment in the usual manner. An environment E is a finite mapping from variables to run-time values. <p> States of the form hx; E; *i or error are called final states, and a state blocked if it is in normal form but not a final state. 5.2 Correctness of the P (CEK )-machine The proof of correctness of the P (CEK)-machine uses standard proof techniques from <ref> [5] </ref>, appropriately modified to account for parallel evaluation. Theorem 5.1 (Correctness of eval pcek ) eval pcek = eval pc 0 Proof: The proof of this theorem is included in appendix A. <p> His primary goal is to design a semantics for the language that treats pcall as a pure annotation, and to derive a reasonably efficient implementation. The semantics is an extension of Felleisen and Friedman's control calculus <ref> [5] </ref>; the implementation is a parallel version of the CESK machine [6] that implements placeholders as globally accessible reference cells. The equivalence proof establishes that both evaluators define the same observational equivalence relation via the construction of a number of intermediate calculi and machines. <p> Reppy's language, Concurrent ML, can provide the future mechanism as an abstraction over the given primitives. The semantics is a two-level rewriting system. The first level, also a program rewriting system 28 C. Flanagan, M. Felleisen in the tradition of Felleisen and Friedman <ref> [5, 6] </ref>, accounts for the sequential behavior; the second-level specifies the behavior of sets of parallel tasks and the task communication mechanisms. <p> Proof: 1. The proof of the first part is by case analysis of the last step in S 0 1 7! pc 0 S 0 based on a similar proof in <ref> [5] </ref> for sequential programs. 2. We prove the second part by case analysis of the last step in the transition S 1 7! pcek S 2 . * Suppose S 1 7! 1;1 pcek S 2 via the rule (bind-const).
Reference: [6] <author> Felleisen, M., and Friedman, D. P. </author> <title> A calculus for assignments in higher-order languages. </title> <booktitle> In Conference Record of the 14th Annual ACM Symposium on Principles of Programming Languages (Munich, </booktitle> <address> West Germany, </address> <month> Jan. </month> <year> 1987), </year> <pages> pp. 314-345. </pages>
Reference-contexts: His primary goal is to design a semantics for the language that treats pcall as a pure annotation, and to derive a reasonably efficient implementation. The semantics is an extension of Felleisen and Friedman's control calculus [5]; the implementation is a parallel version of the CESK machine <ref> [6] </ref> that implements placeholders as globally accessible reference cells. The equivalence proof establishes that both evaluators define the same observational equivalence relation via the construction of a number of intermediate calculi and machines. <p> Reppy's language, Concurrent ML, can provide the future mechanism as an abstraction over the given primitives. The semantics is a two-level rewriting system. The first level, also a program rewriting system 28 C. Flanagan, M. Felleisen in the tradition of Felleisen and Friedman <ref> [5, 6] </ref>, accounts for the sequential behavior; the second-level specifies the behavior of sets of parallel tasks and the task communication mechanisms.
Reference: [7] <author> Flanagan, C., and Felleisen, M. </author> <title> Well-founded touch optimization for futures. </title> <institution> Rice University Computer Science TR94-239. </institution>
Reference-contexts: The fourth and last semantics is a low-level refinement of the third semantics, which explicates just enough information to permit the smooth derivation of program analyses. A companion paper describes the use of our semantics in program optimization <ref> [7] </ref>. It focuses on the derivation of a provably correct program analysis algorithm from the last semantics. The paper also describes a optimization algorithm for lowering the overhead of task coordination in a language with futures, and the effects of implementing this optimization for the Gambit compiler [4]. <p> We have used the semantics to derive a provably-correct program optimization algorithm that removes redundant touch operations from programs <ref> [7, 8] </ref>. Experiments with the Gambit compiler [4] show that this optimization substantially reduces program execution times on a standard set of benchmarks. Another important application of the low-level semantics is as a basis from which to derive a parallel and distributed implementation of Scheme with futures.
Reference: [8] <author> Flanagan, C., and Felleisen, M. </author> <title> The semantics of future and its use in program optimizations. </title> <booktitle> In POPL (Jan. 1995). </booktitle> <address> 34 C. </address> <note> Flanagan, M. Felleisen </note>
Reference-contexts: We have used the semantics to derive a provably-correct program optimization algorithm that removes redundant touch operations from programs <ref> [7, 8] </ref>. Experiments with the Gambit compiler [4] show that this optimization substantially reduces program execution times on a standard set of benchmarks. Another important application of the low-level semantics is as a basis from which to derive a parallel and distributed implementation of Scheme with futures.
Reference: [9] <author> Flanagan, C., Sabry, A., Duba, B. F., and Felleisen, M. </author> <title> The essence of compiling with continuations. </title> <booktitle> In PLDI (1993), </booktitle> <pages> pp. 237-247. </pages>
Reference-contexts: Compilers typically convert source programs into a simple intermediate representation, and then proceed to compile and optimize the intermediate representation of the program. Therefore, we formulate the semantics of futures for an intermediate representation of an idealized functional language. Specifically, we use the subset of A-normal forms <ref> [9] </ref> of a -calculus-like language with a let construct, a future construct, a conditional and an explicit apply primitive: see Figure 1. <p> The use of A-normal forms facilitates the compile-time analysis of programs since every intermediate value is named [22], and it simplifies the definition of abstract machines <ref> [9] </ref>, a fact that we exploit in the development of abstract machines below. <p> Instead, the machine relies on substitution for making progress. To address this problem, we refine the P (C ph )-machine to the P (CEK)-machine (see Figures 7 and 8) using standard techniques <ref> [5, 9] </ref>. 5.1 Specification of the P (CEK )-machine The substitution operation is replaced by an environment in the usual manner. An environment E is a finite mapping from variables to run-time values.
Reference: [10] <author> Gabriel, R., and McCarthy, J. </author> <title> Qlisp. </title> <booktitle> Parallel Computation and Computers for Artificial Intelligence (1988), </booktitle> <pages> 63-89. </pages>
Reference-contexts: The choice of whether or not to apply the transition rule (fork ) is entirely up to the implementation of the machine. An implementation may immediately apply this rule whenever a future expression is encountered, realizing a task creation strategy called eager task creation <ref> [16, 23, 10] </ref>. Alternatively, an implementation may never invoke the rule (fork ), resulting in a purely sequential evaluation. In between these two extremes lie a range of strategies where new tasks are created according to some implementation-dependent and possibly load-dependent algorithm.
Reference: [11] <author> Halstead, R. </author> <title> Multilisp: A language for concurrent symbolic computataion. </title> <journal> ACM Transactions on Programming Languages and Systems 7, </journal> <volume> 4 (1985), </volume> <pages> 501-538. </pages>
Reference-contexts: However, if such a strategy were applied indiscriminately, the execution of a program would generate far too many parallel threads. The overhead of managing these threads would clearly outweigh any benefits from parallel execution. The future annotations of MultiLisp <ref> [1, 11] </ref> and its Scheme successors provide a simple method for taming the implicit parallelism of functional programs. If a programmer believes that the parallel evaluation of some expression outweighs the overhead of creating a separate task, he may annotate the expression with the keyword future.
Reference: [12] <editor> Ito, T., and Halstead, R., Eds. </editor> <booktitle> Parallel Lisp: Languages and Systems. Springer-Verlag Lecture Notes in Computer Science 441, </booktitle> <year> 1989. </year>
Reference: [13] <author> Ito, T., and Matsui, M. </author> <title> A parallel lisp language: Pailisp and its kernel specification. </title> [12:58-100]. 
Reference-contexts: An annotated functional program has the same observable behavior as the original program, but the run-time system may choose to evaluate the future expression in parallel to the rest of the program. While past research on futures has concentrated on implementation and design issues <ref> [4, 13, 20, 16, 18, 15, 19] </ref>, this technical report focuses on the semantics of futures. Specifically, it presents a series of semantics with varying degrees of intensionality.
Reference: [14] <author> Jagannathan, S., and Weeks, S. </author> <title> Analyzing stores and references in a parallel symbolic language. </title> <booktitle> In LFP (1994), </booktitle> <pages> pp. 294-305. </pages>
Reference-contexts: He also uses his semantics to prove the type soundness of the complete language. No attempt is made to exploit the semantics for the derivation of an analysis algorithm or a compiler optimization. Jaganathan and Weeks <ref> [14] </ref> define an operational semantics for a simple function language extended with the spawn construct. They also show how the future annotation can be implemented using spawn.
Reference: [15] <author> Katz, M., and Weise, D. </author> <title> Continuing into the future: on the interaction of futures and first-class continuations. </title> <booktitle> In LFP (1990). </booktitle>
Reference-contexts: An annotated functional program has the same observable behavior as the original program, but the run-time system may choose to evaluate the future expression in parallel to the rest of the program. While past research on futures has concentrated on implementation and design issues <ref> [4, 13, 20, 16, 18, 15, 19] </ref>, this technical report focuses on the semantics of futures. Specifically, it presents a series of semantics with varying degrees of intensionality. <p> After synchronization (line 4), 3 The concept of a mandatory step is closely related to the notion of legitimacy introduced by Katz and Weise <ref> [15] </ref>. 10 C. Flanagan, M. Felleisen the operation car applies to the new argument (cons 1 1), and execution continues with the program returning the answer 1.
Reference: [16] <author> Kranz, D., Halstead, R., and Mohr, E. Mul-T: </author> <title> A high-performance parallel lisp. </title> <booktitle> In PLDI (1989), </booktitle> <pages> pp. 81-90. </pages>
Reference-contexts: An annotated functional program has the same observable behavior as the original program, but the run-time system may choose to evaluate the future expression in parallel to the rest of the program. While past research on futures has concentrated on implementation and design issues <ref> [4, 13, 20, 16, 18, 15, 19] </ref>, this technical report focuses on the semantics of futures. Specifically, it presents a series of semantics with varying degrees of intensionality. <p> The choice of whether or not to apply the transition rule (fork ) is entirely up to the implementation of the machine. An implementation may immediately apply this rule whenever a future expression is encountered, realizing a task creation strategy called eager task creation <ref> [16, 23, 10] </ref>. Alternatively, an implementation may never invoke the rule (fork ), resulting in a purely sequential evaluation. In between these two extremes lie a range of strategies where new tasks are created according to some implementation-dependent and possibly load-dependent algorithm.
Reference: [17] <author> Leroy, X. </author> <title> Typage polymorphe d'un langage algorithmique. </title> <type> PhD thesis, </type> <institution> Universite Paris 7, </institution> <year> 1992. </year>
Reference-contexts: The equivalence proof establishes that both evaluators define the same observational equivalence relation via the construction of a number of intermediate calculi and machines. It is far more complicated than our diamond and bisimulation techniques, possibly due to the inclusion of continuations. Independently, Reppy [21] and Leroy <ref> [17] </ref> define a formal operational semantics for an ML-like language with first-class synchronization operations. Reppy's language, Concurrent ML, can provide the future mechanism as an abstraction over the given primitives. The semantics is a two-level rewriting system. The first level, also a program rewriting system 28 C. Flanagan, M.
Reference: [18] <author> Miller, J. MultiScheme: </author> <title> A Parallel Processing System. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1987. </year>
Reference-contexts: An annotated functional program has the same observable behavior as the original program, but the run-time system may choose to evaluate the future expression in parallel to the rest of the program. While past research on futures has concentrated on implementation and design issues <ref> [4, 13, 20, 16, 18, 15, 19] </ref>, this technical report focuses on the semantics of futures. Specifically, it presents a series of semantics with varying degrees of intensionality.
Reference: [19] <author> Mohr, E., Kranz, R., and Halstead, R. </author> <title> Lazy task creation: A technique for increasing the granularity of parallel programs. </title> <booktitle> In LFP (1990). </booktitle>
Reference-contexts: An annotated functional program has the same observable behavior as the original program, but the run-time system may choose to evaluate the future expression in parallel to the rest of the program. While past research on futures has concentrated on implementation and design issues <ref> [4, 13, 20, 16, 18, 15, 19] </ref>, this technical report focuses on the semantics of futures. Specifically, it presents a series of semantics with varying degrees of intensionality. <p> Alternatively, an implementation may never invoke the rule (fork ), resulting in a purely sequential evaluation. In between these two extremes lie a range of strategies where new tasks are created according to some implementation-dependent and possibly load-dependent algorithm. A particularly efficient strategy is lazy task creation <ref> [4, 19] </ref>, where new tasks are created via fork transitions only when the additional parallelism can exploit idle computing resources. A second source of indeterminism in the specification of the P (C)-machine is the transition rule (parallel).
Reference: [20] <author> Moreau, L. </author> <title> Sound Evaluation of Parallel Functional Programs with First-Class Continuations. </title> <type> PhD thesis, </type> <institution> Universite de Liege, </institution> <year> 1994. </year>
Reference-contexts: An annotated functional program has the same observable behavior as the original program, but the run-time system may choose to evaluate the future expression in parallel to the rest of the program. While past research on futures has concentrated on implementation and design issues <ref> [4, 13, 20, 16, 18, 15, 19] </ref>, this technical report focuses on the semantics of futures. Specifically, it presents a series of semantics with varying degrees of intensionality. <p> The only one that directly deals with parallelism based on transparent annotations is Moreau's Ph.D. thesis <ref> [20] </ref>. Moreau studies the functional core of Scheme extended with pcall (a construct for evaluating function and argument expressions of an application in parallel) and first-class continuations.
Reference: [21] <author> Reppy, J.H. </author> <title> Higher-Order Concurrency. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: The equivalence proof establishes that both evaluators define the same observational equivalence relation via the construction of a number of intermediate calculi and machines. It is far more complicated than our diamond and bisimulation techniques, possibly due to the inclusion of continuations. Independently, Reppy <ref> [21] </ref> and Leroy [17] define a formal operational semantics for an ML-like language with first-class synchronization operations. Reppy's language, Concurrent ML, can provide the future mechanism as an abstraction over the given primitives. The semantics is a two-level rewriting system. The first level, also a program rewriting system 28 C.
Reference: [22] <author> Sabry, A., and Felleisen, M. </author> <title> Is continuation-passing useful for data flow analysis. </title> <booktitle> In PLDI (1994), </booktitle> <pages> pp. 1-12. </pages>
Reference-contexts: The key property of terms in A-normal form is that each intermediate value is explicitly named and where the order of execution follows the lexical nesting of let-expressions. The use of A-normal forms facilitates the compile-time analysis of programs since every intermediate value is named <ref> [22] </ref>, and it simplifies the definition of abstract machines [9], a fact that we exploit in the development of abstract machines below.
Reference: [23] <author> Swanson, M., Kessler, R., and Lindstrom, G. </author> <title> An implementation of portable standard lisp on the BBN butterfly. </title> <booktitle> In LFP (1988), </booktitle> <pages> pp. 132-142. </pages>
Reference-contexts: The choice of whether or not to apply the transition rule (fork ) is entirely up to the implementation of the machine. An implementation may immediately apply this rule whenever a future expression is encountered, realizing a task creation strategy called eager task creation <ref> [16, 23, 10] </ref>. Alternatively, an implementation may never invoke the rule (fork ), resulting in a purely sequential evaluation. In between these two extremes lie a range of strategies where new tasks are created according to some implementation-dependent and possibly load-dependent algorithm.
Reference: [24] <author> Wand, M. </author> <title> Compiler correctness for parallel languages. </title> <type> Unpublished manuscript, </type> <year> 1995. </year>
Reference-contexts: An auxiliary label on each sub-expression is used to collect information about the values of the expression. The semantics is well-suited for deriving traditional abstract interpretations, but is inappropriate for specifying a user-level semantics. Finally, Wand <ref> [24] </ref> recently extended his work on correctness proofs for sequential compilers to parallel languages. In his prior work on the correctness of sequential compilers, he derived compilers from the semantic mappings that translate syntax into -calculus expressions.
References-found: 24

