URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/implementation.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Title: Implementation and Performance of Transaction Logic in Prolog  
Author: by Samuel Y. K. Hung Samuel Y. K. Hung 
Degree: A thesis submitted in conformity with the requirements for the degree of Master of Science  
Date: (1996)  
Note: c Copyright by  
Address: Toronto  
Affiliation: Graduate Department of Computer Science University of  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Alan Gibbons, </author> <title> Algorithmic Graph Theory. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: So, "declare p=4 key 3 size 100" is equivalent to "declare p=4 key 3 size 100 index <ref> [1 + 2 + 3; 1 + 2; 1] </ref>". Examples: 1. declare edge/2. 2. declare buffer/2 key 0. 3. declare account/3 key 2. 4. declare account/3 key 2 size 100. CHAPTER 4. IMPLEMENTATION 43 5. declare account/3 key 2 size 100 index [1]. <p> Examples: 1. declare edge/2. 2. declare buffer/2 key 0. 3. declare account/3 key 2. 4. declare account/3 key 2 size 100. CHAPTER 4. IMPLEMENTATION 43 5. declare account/3 key 2 size 100 index <ref> [1] </ref>. Example 1 declares a predicate called edge with 2 arguments, which together form the primary key. Therefore, edge (v1; v2) and edge (v1; v3) can both be stored in the database. This declare statement is equivalent to "declare edge=2 key 2". No indexes are created. <p> Since the index information is not specified, no indexes are created. Example 4 is similar to Example 3 except that it specifies hash tables of size 100 for the key and value predicates. Default indexes are built on <ref> [1 + 2; 1] </ref>, i.e., an index on arguments 1 and 2 combined, and another index on argument 1. Example 5 shows a user-defined index specification. <p> Since the key predicate is CHAPTER 4. IMPLEMENTATION 46 not a base predicate, the index information is transferred to its tag predicates which are base. For instance, "declare distance=3 key 2 size 100 index <ref> [1] </ref>" puts indexes on the first argument of i key 3 distance=2, d key 3 distance=2, and value 3 distance=3. 4.3.6 Create, Destroy and Set In our implementation, three basic operations for a database tuple are create, destroy, and set. <p> IMPLEMENTATION 53 Examples: 1. Database Before: p (1; 1); p (2; 2) Execution: Y = 2 sc f orall [X] in p (X; Y ) do create (q (X)): Database After: p (1; 1); p (2; 2); q (1); q (2) The loop first determines a set of values <ref> [1; 2] </ref> for X, from p (X; Y ), and from this set, it creates q (X) at each iteration. 2. Database Before: p (1; 1); p (2; 2) Execution: Y = 2 sc with [Y ] f orall [X] in p (X; Y ) do create (q (X)). <p> there is a general rule defining key=2 in terms of its tags: key (X; N ) : i key (X; N ); not (d key (X; N )): (4.26) So, with the above declaration, the atom p (1; 1) is stored as i key (p (1); 2), val (p (1); <ref> [1] </ref>; 2) in database, and p (2; 2) is stored as i key (p (2); 2), val (p (2); [2]; 2) in database. In Prolog, if the indexed argument is a predicate, then the name of the predicate is used for indexing. <p> An IndexArg may be an integer, indicating the argument to be indexed, or a sequence of up to three integers separated by +. The latter indicates that an index is to be built a combination of arguments. As an example, the command : index (p=3; <ref> [1 + 2; 1; 3] </ref>; 100) specifies an index on predicate p=3. With this declaration, three hash tables are created, and each of them has 100 entries.
Reference: [2] <author> Anthony J. Bonner and Michael Kifer, </author> <title> Transaction Logic Programming. </title> <type> Technical Report CSRI-323, </type> <institution> Computer Systems Research Institute, University of Toronto, </institution> <month> April </month> <year> 1995. </year> <month> [BK95] </month>
Reference-contexts: An IndexArg is an integer or a sequence of integers separated by +, e.g., 1+2+3, which indicates that a single index is to be built using these combined arguments. As an example, "declare p=3 key 2 size 100 index <ref> [1+2; 2] </ref>" will construct two hash tables with 100 entries for the combination of the first and second argument of the key (key 3 p (X; Y )) and value (value 3 p (X; Y; Z)) predicates, and two other hash tables with 100 entries for the second argument of the <p> IMPLEMENTATION 53 Examples: 1. Database Before: p (1; 1); p (2; 2) Execution: Y = 2 sc f orall [X] in p (X; Y ) do create (q (X)): Database After: p (1; 1); p (2; 2); q (1); q (2) The loop first determines a set of values <ref> [1; 2] </ref> for X, from p (X; Y ), and from this set, it creates q (X) at each iteration. 2. Database Before: p (1; 1); p (2; 2) Execution: Y = 2 sc with [Y ] f orall [X] in p (X; Y ) do create (q (X)). <p> (X; N ); not (d key (X; N )): (4.26) So, with the above declaration, the atom p (1; 1) is stored as i key (p (1); 2), val (p (1); [1]; 2) in database, and p (2; 2) is stored as i key (p (2); 2), val (p (2); <ref> [2] </ref>; 2) in database. In Prolog, if the indexed argument is a predicate, then the name of the predicate is used for indexing. So, Prolog indexes the key on the predicate name, which is almost equivalent to no indexing because tuples are exhaustively searched in access time. <p> For instance, consider the above example. To insert p (1; 2) into database, in Prototype 1, i key (p (1); 2) and value (p (1); <ref> [2] </ref>; 2) are inserted into database. These two base predicates are easily generated by decomposing p (1; 2) into p (1), and [2], which are stored as the arguments of two general predicates, i key=2 and value=3. <p> For instance, consider the above example. To insert p (1; 2) into database, in Prototype 1, i key (p (1); 2) and value (p (1); <ref> [2] </ref>; 2) are inserted into database. These two base predicates are easily generated by decomposing p (1; 2) into p (1), and [2], which are stored as the arguments of two general predicates, i key=2 and value=3. In Prototype 2, with the same update, two predicates i key 2 p (1) and value 2 p (1; 2) are generated from p (1; 2).
Reference: [3] <author> Anthony J. Bonner and Michael Kifer, </author> <booktitle> Applications of Transaction Logic to Knowledge Representation In Proceedings of the International Conference on Temporal Logic (ICTL), </booktitle> <pages> page 67-81, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: An IndexArg may be an integer, indicating the argument to be indexed, or a sequence of up to three integers separated by +. The latter indicates that an index is to be built a combination of arguments. As an example, the command : index (p=3; <ref> [1 + 2; 1; 3] </ref>; 100) specifies an index on predicate p=3. With this declaration, three hash tables are created, and each of them has 100 entries.
Reference: [4] <author> Anthony J. Bonner and Michael Kifer, </author> <title> Transaction Logic: </title> <booktitle> An (Early) Expose In Proceedings of the Workshop on Formal Methods in Databases and Software Engineering, Pringer-Verlag, Workshops in Computing Series, </booktitle> <month> May </month> <year> 1993. </year>
Reference: [5] <author> Barry Wilkinson, </author> <title> Digital System Design Prentice Hall 1987. </title>
Reference: [6] <author> David S. Warren, Konstantinos F. Sagonas and Terrance Swift, </author> <title> the XSB Programmer's Manual Version 1.4.1, </title> <institution> SUNY at Stony Brook, </institution> <year> 1994. </year>
Reference: [7] <author> Ivan Bratko, </author> <title> Prolog Programming for Artifical Intelligence Addison-Wesley, </title> <year> 1991. </year>
Reference: [8] <author> J. W. Llody, </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference: [9] <author> Henry F. Korth and Abraham Silberschatz, </author> <title> Database System Concepts. </title> <publisher> McGraw-Hill, </publisher> <year> 1991. </year>
Reference: [10] <author> Sara Baase, </author> <title> Computer Algorithms, Introduction to Design and Analysis. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference: [11] <author> J.D. Ullman, </author> <title> Principles of Database and Knowledge Base Systems. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year> <month> 106 </month>
References-found: 11

