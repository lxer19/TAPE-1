URL: http://www.daimi.aau.dk/~mis/dsl.ps
Refering-URL: http://www.daimi.aau.dk/~mis/papers.html
Root-URL: http://www.daimi.aau.dk
Email: klarlund@research.att.com mis@brics.dk  
Title: A Domain-Specific Language for Regular Sets of Strings and Trees based on a combination of
Author: Nils Klarlund Michael I. Schwartzbach 
Address: Aarhus  
Affiliation: University of  
Note: AT&T Labs-Research BRICS,  FIDO is  
Abstract: We propose a new high-level programming notation, called FIDO, that we have designed to concisely express regular sets of strings or trees. In particular, it can be viewed as a domain-specific language for the expression of finite-state automata on large alphabets (of sometimes astronomical size). In the present paper, we motivate the need for a language like FIDO, and discuss our design and its implementation. We show how recursive data types, unification, implicit coercions, and subtyping can be merged with a variation of predicate logic, called the Monadic Second-order Logic (M2L) on trees. FIDO is translated first into pure M2L via suitable encodings, and finally into finite-state automata through the MONA tool. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Ayari, D. Basin, and A. Podelski. Lisa: </author> <title> A specification language based on WS2S. </title> <booktitle> In Proceedings of CSL'97. BRICS, </booktitle> <year> 1997. </year>
Reference-contexts: colored blue is not a recursive data type; however, it is easily captured by the following FIDO specification: type RGB = red,green,blue (left, right: RGB) j leaf; tree x: RGB; 8pos p,q: x.(p=blue ^ q=blue ) p=q) Certainly, more advanced and complicated notions of data types could similarly be adopted <ref> [1] </ref>. However, the FIDO philosophy is to rely heavily on standard programming language concepts to describe complex structures and operations. The ambition is that these idioms should be merged seamlessly with logical concepts that describe complex properties of such structures. <p> Only trees synthesizing the values zero or one are accepted. The transitions, which are simply inherited from the tree automaton that MONA computes, are as follows: HTML j word: [] 7! 0 HTML j anchor: [0,0] 7! 1 [0,1] 7! 2 HTML j bold: [0] 7! 0 <ref> [1] </ref> 7! 1 HTML j italic: [0] 7! 0 [1] 7! 1 HTML j paragraph: [] 7! 0 HTML j rule: [] 7! 0 HTML j list: [0] 7! 0 [1] 7! 1 LIST j empty: [] 7! 0 LIST j entity: [0,0] 7! 0 [0,1] 7! 1 [1,1] 7! 1 <p> The transitions, which are simply inherited from the tree automaton that MONA computes, are as follows: HTML j word: [] 7! 0 HTML j anchor: [0,0] 7! 1 [0,1] 7! 2 HTML j bold: [0] 7! 0 <ref> [1] </ref> 7! 1 HTML j italic: [0] 7! 0 [1] 7! 1 HTML j paragraph: [] 7! 0 HTML j rule: [] 7! 0 HTML j list: [0] 7! 0 [1] 7! 1 LIST j empty: [] 7! 0 LIST j entity: [0,0] 7! 0 [0,1] 7! 1 [1,1] 7! 1 [2,0] 7! 2 [2,1] 7! 2 URL j url: <p> j word: [] 7! 0 HTML j anchor: [0,0] 7! 1 [0,1] 7! 2 HTML j bold: [0] 7! 0 <ref> [1] </ref> 7! 1 HTML j italic: [0] 7! 0 [1] 7! 1 HTML j paragraph: [] 7! 0 HTML j rule: [] 7! 0 HTML j list: [0] 7! 0 [1] 7! 1 LIST j empty: [] 7! 0 LIST j entity: [0,0] 7! 0 [0,1] 7! 1 [1,1] 7! 1 [2,0] 7! 2 [2,1] 7! 2 URL j url: [] 7! 0 The transition HTML j anchor: [0,0] 7! 1 means that if the node is an anchor and each
Reference: [2] <author> D. Basin and N. Klarlund. </author> <title> Hardware verification using monadic second-order logic. </title> <booktitle> In Computer aided verification : 7th International Conference, CAV '95, LNCS 939, </booktitle> <year> 1995. </year>
Reference-contexts: In each case, the results are obtained by identifying an inherent regularity in the problem domain, thus reducing the problem to questions of regular string or tree languages. Successful applications today include verification of concurrent systems [9, 8], hardware verification <ref> [2] </ref>, software engineering [10], and pointer verification [7]. Work in progress involves a graphical user interface for regular expressions extended with M2L and document logics for the WWW. The role of M2L in this approach is to provide an extraordinarily succinct notation for complicated regular sets.
Reference: [3] <author> Morten Biehl, Nils Klarlund, and Theis Rauhe. </author> <title> Algorithms for guided tree automata. </title> <booktitle> In Proceedings of WIA'96. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Surprisingly, the MONA implementation of M2L [5] can handle nontrivial formulas, some as large as 500,000 characters. This is due in part to the application of BDD techniques [4], specialized algorithms on finite-state automata <ref> [3] </ref>, and careful tuning of the implementation [11]. Also, it turns out that the intermediate automata generated, even those resulting from subset constructions, are usually not big compared to the automata representing the properties reasoned about. <p> In particular, we discuss the type system and compilation techniques. We also give several examples (some taken from articles already published, where we have used FIDO without explaining its origin or design). Some technical considerations concerning the relationship between our data structures for tree automaton representation <ref> [3] </ref> and the compilation process will be explained elsewhere. 2 M2L and MONA Basic M2L has a very simple syntax and semantics. Formulas are interpreted on a binary tree (or a string) labeled with bit patterns determining the values of free variables.
Reference: [4] <author> Randal E. Bryant. </author> <title> Graph-based algorithms for Boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <month> August </month> <year> 1986. </year>
Reference-contexts: The flip side of this impressive succinctness is that M2L correspondingly has a non-elementary lower bound on its decision procedure. Surprisingly, the MONA implementation of M2L [5] can handle nontrivial formulas, some as large as 500,000 characters. This is due in part to the application of BDD techniques <ref> [4] </ref>, specialized algorithms on finite-state automata [3], and careful tuning of the implementation [11]. Also, it turns out that the intermediate automata generated, even those resulting from subset constructions, are usually not big compared to the automata representing the properties reasoned about.
Reference: [5] <author> Jesper Gulmann Henriksen, Michael Jrgensen, Jakob Jensen, Nils Klarlund, Bob Paige, Theis Rauhe, and Anders Sandholm. Mona: </author> <title> Monadic second-order logic in practice. </title> <booktitle> In Proceedings of TACAS'95, LNCS 1019, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: The flip side of this impressive succinctness is that M2L correspondingly has a non-elementary lower bound on its decision procedure. Surprisingly, the MONA implementation of M2L <ref> [5] </ref> can handle nontrivial formulas, some as large as 500,000 characters. This is due in part to the application of BDD techniques [4], specialized algorithms on finite-state automata [3], and careful tuning of the implementation [11].
Reference: [6] <author> G.J. Holzmann. </author> <title> The model checker spin. </title> <journal> IEEE Trans. on Software Engineering, </journal> <month> May </month> <year> 1997. </year> <note> Special issue on Formal Methods in Software Practice. </note>
Reference-contexts: That is, automata are the primitive objects that are subjected to operations reflecting the semantics of the language. This view is quite different from the method behind most state-machine formalisms used in verification (such as the Promela language <ref> [6] </ref>): a language resembling a general purpose language expresses a single finite-state machine, whose state space and transition system is constructed piecemeal from calculations that explore the state space.
Reference: [7] <author> J.L. Jensen, M.E. Jrgensen, N. Klarlund, and M.I. Schwartzbach. </author> <title> Automatic verification of pointer programs using monadic second-order logic. </title> <booktitle> In Proceedings of PLDI'97, </booktitle> <year> 1997. </year>
Reference-contexts: In each case, the results are obtained by identifying an inherent regularity in the problem domain, thus reducing the problem to questions of regular string or tree languages. Successful applications today include verification of concurrent systems [9, 8], hardware verification [2], software engineering [10], and pointer verification <ref> [7] </ref>. Work in progress involves a graphical user interface for regular expressions extended with M2L and document logics for the WWW. The role of M2L in this approach is to provide an extraordinarily succinct notation for complicated regular sets. <p> An entirely different use of FIDO allows us to verify many properties of PASCAL programs that use pointers <ref> [7] </ref>. By encoding a store as a string and using FIDO formulas to describe the effects of program statements, we can automatically verify some desirable properties.
Reference: [8] <author> N. Klarlund, M. Nielsen, and K. Sunesen. </author> <title> A case study in automated verification based on trace abstractions. </title> <type> Technical Report RS-95-54, BRICS, </type> <institution> Aarhus University, </institution> <year> 1995. </year>
Reference-contexts: In each case, the results are obtained by identifying an inherent regularity in the problem domain, thus reducing the problem to questions of regular string or tree languages. Successful applications today include verification of concurrent systems <ref> [9, 8] </ref>, hardware verification [2], software engineering [10], and pointer verification [7]. Work in progress involves a graphical user interface for regular expressions extended with M2L and document logics for the WWW. The role of M2L in this approach is to provide an extraordinarily succinct notation for complicated regular sets. <p> For more realistic examples, internal events can be projected away by means of the existential quantifier. In <ref> [8] </ref>, a detailed account is given of an application of the FIDO language to a verification problem posed by Broy and Lamport in 1994. The distributed systems are described in an interval logic, which is easily defined in FIDO.
Reference: [9] <author> N. Klarlund, M. Nielsen, and K. Sunesen. </author> <title> Automated logical verification based on trace abstraction. </title> <booktitle> In Proceedings of PODC'96, </booktitle> <year> 1996. </year>
Reference-contexts: In each case, the results are obtained by identifying an inherent regularity in the problem domain, thus reducing the problem to questions of regular string or tree languages. Successful applications today include verification of concurrent systems <ref> [9, 8] </ref>, hardware verification [2], software engineering [10], and pointer verification [7]. Work in progress involves a graphical user interface for regular expressions extended with M2L and document logics for the WWW. The role of M2L in this approach is to provide an extraordinarily succinct notation for complicated regular sets.
Reference: [10] <author> Nils Klarlund, Jari Koistinen, and Michael I. Schwartzbach. </author> <title> Formal design constraints. </title> <booktitle> In Proceedings of OOPSLA'96, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: In each case, the results are obtained by identifying an inherent regularity in the problem domain, thus reducing the problem to questions of regular string or tree languages. Successful applications today include verification of concurrent systems [9, 8], hardware verification [2], software engineering <ref> [10] </ref>, and pointer verification [7]. Work in progress involves a graphical user interface for regular expressions extended with M2L and document logics for the WWW. The role of M2L in this approach is to provide an extraordinarily succinct notation for complicated regular sets. <p> These simple ideas have been exploited in a collaboration with the Ericsson telecommunications company to formalize the constraints of design architectures <ref> [10] </ref>. Verification Two specifications, of say distributed systems, can be compared by means of the implication or bi-implication connective.
Reference: [11] <author> Nils Klarlund and Theis Rauhe. </author> <title> BDD algo-rithms and cache misses. </title> <type> Technical Report RS-96-05, BRICS, </type> <year> 1996. </year> <note> Submitted. </note>
Reference-contexts: Surprisingly, the MONA implementation of M2L [5] can handle nontrivial formulas, some as large as 500,000 characters. This is due in part to the application of BDD techniques [4], specialized algorithms on finite-state automata [3], and careful tuning of the implementation <ref> [11] </ref>. Also, it turns out that the intermediate automata generated, even those resulting from subset constructions, are usually not big compared to the automata representing the properties reasoned about.
Reference: [12] <author> J.C. Reynolds. </author> <title> Three approaches to type structure. </title> <booktitle> In Mathematical Foundations of Software Development, LNCS 185, </booktitle> <year> 1985. </year>
Reference-contexts: This subtype structure is exploited to automatically insert coercions. Note that our subtype structure clearly is semantically coherent, so that coercions are unique <ref> [12] </ref>. If we added the coercion: singleton: pos ! set, then semantic coherence would fail. Second, we allow implicit casts between finite domains.
References-found: 12

