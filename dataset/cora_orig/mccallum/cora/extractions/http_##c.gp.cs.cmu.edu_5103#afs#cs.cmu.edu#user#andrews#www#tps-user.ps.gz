URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/andrews/www/tps-user.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/andrews/www/tps-mans.html
Root-URL: http://www.cs.cmu.edu
Author: Dan Nesmith Matthew Bishop Peter B. Andrews Sunil Issar Frank Pfenning 
Date: 1998 August 7  
Note: Copyright 1998 Carnegie Mellon University. All rights reserved. This manual is based upon work supported by NSF grants MCS81-02870, DCR-8402532, CCR-8702699, CCR-9002546, CCR-9201893, and a grant from the Center for Design of Educational Computing, Carnegie Mellon University. Any opinions, findings, and conclusions or recommendations are those of the author(s) and do not necessarily reflect the views of the National Science Foundation. TPS User's Manual  Hongwei Xi  
Abstract-found: 0
Intro-found: 1
Reference: <institution> Here are some references which you may wish to consult: </institution>
Reference: 1. <author> Peter B. Andrews, </author> <title> Resolution in Type Theory, </title> <journal> Journal of Symbolic Logic 36 (1971), </journal> <pages> 414-432. </pages>
Reference: 2. <author> Peter B. Andrews, </author> <title> Refutations by Matings, </title> <journal> IEEE Transactions on Computers C-25 (1976), </journal> <pages> 801-807. </pages>
Reference: 3. <author> Peter B. Andrews, </author> <title> "Transforming Matings into Natural Deduction Proofs," </title> <booktitle> in 5th Conference on Automated Deduction, </booktitle> <editor> edited by W. Bibel and R. Kowalski, Les Arcs, </editor> <booktitle> France, Lecture Notes in Computer Science 87, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1980, </year> <pages> 281-292. </pages> <note> TPS User's Manual Chapter 1: Introduction 2 </note>
Reference: 4. <author> Peter B. Andrews, </author> <title> Theorem Proving via General Matings, </title> <journal> Journal of the ACM 28 (1981), </journal> <pages> 193-214. </pages>
Reference: 5. <author> Peter B. Andrews, Dale A. Miller, Eve Longini Cohen, Frank Pfenning, </author> <title> "Automating Higher-Order Logic," in Automated Theorem Proving: After 25 Years, edited by W. </title> <editor> W. Bledsoe and D. W. Loveland, </editor> <booktitle> Contemporary Mathematics series, </booktitle> <volume> vol. 29, </volume> <publisher> American Mathematical Society, </publisher> <year> 1984, </year> <pages> 169-192. </pages>
Reference: 6. <author> Peter B. Andrews, </author> <title> An Introduction to Mathematical Logic and Type Theory: To Truth Through Proof, </title> <publisher> Academic Press, </publisher> <year> 1986. </year>
Reference: 7. <author> Peter B. Andrews, </author> <title> "Connections and Higher-Order Logic," </title> <booktitle> in 8th International Conference on Automated Deduction, edited by Jorg H. Siekmann, Oxford, England, Lecture Notes in Computer Science 230, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986, </year> <pages> 1-4. </pages>
Reference: 8. <author> Peter B. Andrews, Frank Pfenning, Sunil Issar, C. P. Klapper, </author> <title> "The TPS Theorem Proving System," </title> <booktitle> in 8th International Conference on Automated Deduction, edited by Jorg H. Siekmann, Oxford, England, Lecture Notes in Computer Science 230, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986, </year> <pages> 663-664. </pages>
Reference: 9. <author> Peter B. Andrews, </author> <title> "Typed l-calculus and Automated Mathematics," </title> <booktitle> in Mathematical Logic and Theoretical Computer Science, </booktitle> <editor> edited by David W. Kueker, Edgar G. K. Lopez-Escobar and Carl H. Smith, </editor> <booktitle> Lecture Notes in Pure and Applied Mathematics, </booktitle> <volume> vol. 106, </volume> <publisher> Marcel Dekker, </publisher> <year> 1987, </year> <pages> 1-14. </pages>
Reference: 10. <author> Peter B. Andrews, Sunil Issar, Daniel Nesmith, Frank Pfenning, </author> <title> "The TPS Theorem Proving System," </title> <booktitle> in 9th International Conference on Automated Deduction, </booktitle> <editor> edited by Ewing Lusk and Ross Overbeek, </editor> <address> Argonne, Illinois, </address> <booktitle> Lecture Notes in Computer Science 310, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988, </year> <pages> 760-761. </pages>
Reference: 11. <author> Peter B. Andrews, Matthew Bishop, Sunil Issar, Dan Nesmith, Frank Pfenning, Hongwei Xi, TPS: </author> <title> A Theorem Proving System for Classical Type Theory, </title> <booktitle> Journal of Automated Reasoning 16 (1996), </booktitle> <pages> 321-353. </pages>
Reference: 12. <author> Peter B. Andrews, Sunil Issar, Dan Nesmith, Frank Pfenning, Hongwei Xi, Matthew Bishop, </author> <title> TPS3 Facilities Guide for Programmers and Users, </title> <booktitle> 1997. </booktitle> <pages> 207+viii pp. </pages>
Reference-contexts: ETPS is used for educational purposes, however, so it contains none of the automatic facilities of TPS such as mating-search. For a full list of all commands, flags, etc., see <ref> [12] </ref>. Those relating to mating-search are in a separate chapter, and other commands and flags can be found under the heading mating-search in other chapters. Currently, there are 2 separate documents which together constitute the programmer's manual.
Reference: 13. <author> Matthew Bishop and Peter B. Andrews, </author> <title> "Selectively Instantiating Definitions," </title> <booktitle> in Automated Deduction - CADE-15; 15th International Conference on Automated Deduction, edited by Claude and Helene Kirchner, Lecture Notes in Artificial Intelligence 1421, </booktitle> <publisher> Springer, </publisher> <year> 1998, </year> <pages> 365-380. </pages>
Reference: 14. <author> Amy P. Felty. </author> <title> Using Extended Tactics to Do Proof Transformations. </title> <type> Tech. </type> <institution> Rept. MS-CIS-86-89, Department of Computer and Information Science, University of Pennsylvania, </institution> <year> 1986. </year>
Reference: 15. <author> Michael J. Gordon, Arthur J. Milner, Christopher P. Wadsworth. </author> <title> Edinburgh LCF, </title> <booktitle> Lecture Notes in Computer Science 78, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1979. </year>
Reference: 16. <author> Gerard P. Huet, </author> <title> A Unification Algorithm for Typed l-Calculus, </title> <booktitle> Theoretical Computer Science 1 (1975), </booktitle> <pages> 27-57. </pages>
Reference: 17. <author> Sunil Issar, </author> <title> "Path-Focused Duplication: A Search Procedure for General Matings," </title> <booktitle> in AAAI-90. Proceedings of the Eighth National Conference on Artificial Intelligence, </booktitle> <publisher> AAAI Press/The MIT Press, </publisher> <year> 1990, </year> <pages> 221-226. </pages>
Reference: 18. <author> Sunil Issar, Peter B. Andrews, Frank Pfenning, Dan Nesmith, GRADER Manual, </author> <year> 1995. </year> <pages> 24+i pp. </pages>
Reference-contexts: Following the general convention in TPS, most of the programmer's manual is produced in scribe. However, there are certain documents that are part of other work, and it's more convenient to have them in TeX format. <ref> [18] </ref> covers the commands which are particular to the Grader subsystem. 1.2. Top-Levels TPS has various top-levels. One can view it as that there's a main top-level to which one always returns, and then there are sub top-levels for specific purposes.
Reference: 19. <author> Dale A. Miller, Eve Longini Cohen, Peter B. Andrews, </author> <title> "A Look at TPS," </title> <booktitle> in 6th Conference on Automated Deduction, </booktitle> <editor> edited by Donald W. Loveland, </editor> <address> New York, USA, </address> <booktitle> Lecture Notes in Computer Science 138, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1982, </year> <pages> 50-69. </pages>
Reference: 20. <author> Dale A. Miller. </author> <title> Proofs in Higher-Order Logic, </title> <type> Ph.D. Thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1983. </year> <pages> 81 pp. </pages>
Reference: 21. <author> Dale A. Miller, </author> <title> "Expansion Tree Proofs and Their Conversion to Natural Deduction Proofs," </title> <booktitle> in 7th International Conference on Automated Deduction, </booktitle> <editor> edited by R. E. Shostak, </editor> <address> Napa, California, USA, </address> <booktitle> Lecture Notes in Computer Science 170, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1984, </year> <pages> 375-393. </pages>
Reference: 22. <author> Dale A. Miller, </author> <title> A Compact Representation of Proofs, </title> <journal> Studia Logica 46 (1987), </journal> <pages> 347-370. </pages>
Reference: 23. <author> Frank Pfenning, </author> <title> "Analytic and Non-analytic Proofs," </title> <booktitle> in 7th International Conference on Automated Deduction, </booktitle> <editor> edited by R. E. Shostak, </editor> <address> Napa, California, USA, </address> <booktitle> Lecture Notes in Computer Science 170, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1984, </year> <pages> 394-413. </pages> <note> TPS User's Manual Chapter 1: Introduction 3 </note>
Reference: 24. <author> Frank Pfenning. </author> <title> Proof Transformations in Higher-Order Logic, </title> <type> Ph.D. Thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1987. </year> <pages> 156 pp. </pages>
Reference: 25. <author> Frank Pfenning, Sunil Issar, Dan Nesmith, Peter B. Andrews, Hongwei Xi, Matthew Bishop, </author> <note> ETPS User's Manual, 1996. 58+ii pp. 4 </note>
Reference-contexts: Some areas are covered in detail, while others are very sketchy. We hope, however, that these manuals (which are listed in the next section) will allow you to get started with TPS. To first learn the system, read <ref> [25] </ref>. This will introduce you to the interaction style of the program, tell you how to get help, and show you how to enter wffs and use the inference rules. ETPS is used for educational purposes, however, so it contains none of the automatic facilities of TPS such as mating-search.

Reference: 1. <institution> Work on the original problem for SEARCH-TIME-LIMIT seconds using either MS88 or MS90-3 as appropriate. </institution>
Reference: 2. <editor> If that fails, </editor> <title> change the weight of the old problem (using RECONSIDER-FN). </title>
Reference: 3. <institution> Generate new options (which will be a list of possible duplications and primitive substitutions for the expansion variables of the problem). </institution>
Reference: 4. <editor> Using the list of options, </editor> <title> attempt to generate NEW-OPTION-SET-LIMIT many new option sets whose weights lie within MS91-WEIGHT-LIMIT-RANGE of the weight of the last option set used. If we fail to do this because no more option sets can be generated from the current option list, give up and go on to the next step. If we fail because all the option sets we generate are not in our desired weight range, increase the lower limit of this range and try again. </title>
Reference: 5. <editor> Apply either MS88 or MS90-3 to each of the new option sets, </editor> <title> in order of their weight (may also reconsider old option sets; an option set expires permanently after MAX-SEARCH-LIMIT seconds in total have been spent on it). Each set gets considered for SEARCH-TIME-LIMIT seconds at a time. </title>

Reference: 1. <author> IDTAC: </author> <title> (idtac) Returns (goal), (lambda (x) x). </title>
Reference: 2. <author> FAILTAC: </author> <title> (failtac) Returns failure </title>
Reference: 3. <author> CALL: </author> <title> (call command) Executes command as if it were entered at top level of TPS. This is used only for side-effects. Returns (goal), (lambda (x) x). </title>
Reference: 4. <author> ORELSE: </author> <title> (orelse tactic1 tactic2 ... tacticN) If N=0 return failure, else apply tactic1 to goal. If this fails, call (orelse tactic2 tactic3 ... tacticN) on goal, else return the result of applying tactic1 to goal. </title>
Reference: 5. <author> THEN: </author> <title> (then tactic1 tactic2) Apply tactic1 to goal. If this fails, return failure, else apply tactic2 to each of the subgoals generated by tactic1. If this fails on any subgoal, return failure, else return the list of new subgoals returned from the calls to tactic2, and the lambda-expression representing the combination of applying tactic1 followed by tactic2. TPS User's Manual Chapter 2: Proving theorems 26 Note that if tactic1 returns no subgoals, tactic2 will not be called. </title>
Reference: 6. <author> REPEAT: </author> <title> (repeat tactic) Behaves like (orelse (then tactic (repeat tactic)) (idtac)). </title>
Reference: 7. <author> THEN*: </author> <title> (then* tactic1 tactic2) Defined by: </title> <note> (then tactic1 (then (orelse tactic2 (idtac)) (idtac))). This tactical is taken from [14]. </note>
Reference: 8. <author> THEN**: </author> <title> (then** tactic1 tactic2) Acts like then, except that no copying of the goal or related structures will be done. </title>
Reference: 9. <author> IFTHEN: </author> <title> (ifthen test tactic1) or (ifthen test tactic1 tactic2) First evaluates test, which may be either a tactic or (if user is an expert) an arbitrary LISP expression. If test is a tactic and does not fail, or is an arbitrary LISP expression that does not evaluate to nil, then tactic1 will be called on goal and its results returned. Otherwise, if tactic2 is present, the results of calling tactic2 on goal will be returned, else failure is returned. test should be some kind of predicate; any new subgoals it returns will be ignored by ifthen. </title>
Reference: 10. <editor> SEQUENCE: (sequence tactic1 tactic2 ... tacticN) Applies tactic1, </editor> ... , <title> tacticN in succession regardless of their success or failure. Their results are composed. </title>
Reference: 11. <editor> COMPOSE: (compose tactic1 ... tacticN) Applies tactic1, ..., tacticN in succession, </editor> <title> composing their results until one of them fails. Defined by: (idtac) if N=0 (then* tactic1 (compose tactic2 ... tacticN)) if N &gt; 0. </title>
Reference: 12. <author> TRY: </author> <title> (try tactic) Defined by: (then tactic (failtac)). Succeeds only if tactic returns no new subgoals, in which case it returns the results from applying tactic. </title>
Reference-contexts: ETPS is used for educational purposes, however, so it contains none of the automatic facilities of TPS such as mating-search. For a full list of all commands, flags, etc., see <ref> [12] </ref>. Those relating to mating-search are in a separate chapter, and other commands and flags can be found under the heading mating-search in other chapters. Currently, there are 2 separate documents which together constitute the programmer's manual.



Reference: 1. <editor> In the presence of the ETA-RULE, </editor> <title> we modify the binders and arguments of the elements of rigid-rigid disagreement pairs so that the binders have the same length. This way we obviate the necessity of finding eta head normal form, keep the binder reduced to a certain extent, and do not form some disagreement pairs which would have been immediately eliminated anyway. </title>
Reference: 2. <author> As noted by Huet, </author> <title> if x FV(e) then x e is a mgu for this pair of terms, where x is a variable, e is a term of the same type, and FV(e) denotes the set of variables that are free in e. We will find substitutions of this kind. We intend to implement the rigid path check to identify non-unifiable disagreement sets here. 2 It has certain other attributes which are convenient for implementation purposes. </title> <note> TPS User's Manual Chapter 4: Unification 45 </note>

Reference: 1. <editor> The modifications in simpl and match mentioned above obviate the need to compute eta head normal form, </editor> <title> and it suffices to find the head normal form of elements in the disagreement pairs. For example, consider the disagreement pair: (f ii , ly i G ii . We can straight away find the mgu for this dpair. If, however, we convert this to eta head normal form, then we have to call the unification algorithm to find the unifiers. </title>











Reference: 1. <editor> Read and follow the directions which are presented as comments in the files .depend and Makefile. </editor> <title> In general, this will just mean changing the .depend file or the Makefile to show the correct pathname for your version of Lisp, changing the Makefile to show where remarks by TPS users should be sent and which users are allowed "expert" privileges, and then issuing the command "make tps" or "make etps". (Of course, this assumes you are using a Unix operating system.) </title>
Reference: 2. <author> If you are using KCL or IBCL, </author> <title> you may get an error during compiling which says something like "unable to allocate". This error indicates that your C compiler cannot handle the size of the file that is being compiled. To fix this, split the offending file (e.g. foo.lisp) into smaller pieces (e.g., foo1.lisp and foo2.lisp) and replace the occurrence of "foo" in the file defpck.lisp with "foo1 foo2". If this doesn't work you may have to split the files again. </title>

Reference: 4. <editor> When TPS starts up, </editor> <title> it loads a file called tps3.patch if one is there; this contains fixes for bugs, new code which has been added since TPS was last built, etc. For example, if you wish to change expert-list after tps has been built, just put the appropriate line into tps3.patch, using the format of the example in tps3-save.lisp. </title>

Reference: 1. <author> For X10R4: </author> <title> Make sure that the font directory fonts is in your XFONTPATH. </title>

Reference: 1. <institution> Introduction 1 1.1. </institution> <note> Guide to documentation 1 1.2. Top-Levels 1 1.3. References 1 </note>

Reference: 3. <author> The Matingstree Procedure 32 3.1. </author> <title> A Brief Overview 32 3.2. A Detailed Plan of the Matingstree Top Level 32 3.3. How to Use the Mtree Top Level 35 3.4. Automatic Searches with the Mtree Top Level 36 3.5. The Mtree Subsumption Checker 37 3.6. An Interactive Session in the Mtree Top Level 37 </title>
Reference: 4. <author> Unification 41 4.1. </author> <title> A Few Comments About Higher-Order Unification 41 4.2. Bounds on Higher-Order Unification 41 4.2.1. Depth Bounds 42 4.2.2. Substitution Bounds 42 4.2.3. Combining the Above 43 4.3. Support Facilities 43 4.3.1. Review 43 ii 4.3.2. Saving Disagreement sets 43 4.4. Unification Tree 44 4.4.1. Node Names 44 4.4.2. Substitution Stack 44 4.5. </title> <note> Simpl 44 4.6. Match 45 4.7. Comments 45 4.8. A Session in Unification Top-Level 45 </note>
Reference: 5. <editor> How to define wffs, abbrevs, </editor> <address> etc 47 </address>
Reference: 6. <author> Using the library 48 6.1. </author> <title> Storing and Retrieving Objects 48 6.2. Displaying Objects 50 6.3. File Maintenance 50 6.4. Printed Output 50 6.5. Expert Users 50 6.6. </title> <address> Cautions 50 </address>
Reference: 7. <editor> Rewrite Rules and Theories 52 7.1. </editor> <title> An Example of Rewrite Rules in Use 53 7.2. How Rewrite Rules and Theories Are Stored in the Library 55 </title>
Reference: 8. <author> Output: </author> <title> files and styles 56 8.1. Output files 56 8.2. Output styles 56 8.3. Saving Output from Mating Search 56 8.4. </title> <booktitle> Interrupting TPS for Occasional Output 57 8.5. Output for Slides 57 8.6. Record files 58 </booktitle>
Reference: 9. <author> Review, flags, </author> <title> and modes 60 </title>
Reference: 10. <author> Events 61 10.1. </author> <title> Events in TPS3 61 10.1.1. Defining an Event 61 10.1.2. Signalling Events 62 10.1.3. Examples 62 10.2. More on Events 64 10.3. The Report Package 66 </title>
Reference: 11. <author> Rules Module 68 11.1. </author> <title> Defining Inference Rules 68 11.2. Assembling the Rules 69 11.2.1. An example 69 11.2.2. Customizing ETPS or TPS with your own rules 70 11.2.3. Creating Exercises 71 </title>
Reference: 12. <editor> Notes on setting things up 73 12.1. </editor> <title> Compiling TPS 73 12.2. The .ini files 74 12.3. Using TPS within Gnu Emacs 74 12.4. Using TPS with the X window system 75 12.5. Running TPS in Batch Mode or from Omega 75 12.5.1. Batch Processing Work Files 75 12.5.2. Interactive/Omega Batch Processing 76 12.5.3. Batch Processing With UNIFORM-SEARCH 76 12.6. The TPS package philosophy 77 12.7. Interruptions and Emergencies 77 12.8. Preparing ETPS for classroom use 78 iii 12.8.1. Security, </title> <journal> grades, </journal> <note> etc. 78 12.9. How to produce manuals 79 12.9.1. HTML manuals 80 Index 81 </note>
Reference-contexts: ETPS is used for educational purposes, however, so it contains none of the automatic facilities of TPS such as mating-search. For a full list of all commands, flags, etc., see <ref> [12] </ref>. Those relating to mating-search are in a separate chapter, and other commands and flags can be found under the heading mating-search in other chapters. Currently, there are 2 separate documents which together constitute the programmer's manual.
References-found: 61

