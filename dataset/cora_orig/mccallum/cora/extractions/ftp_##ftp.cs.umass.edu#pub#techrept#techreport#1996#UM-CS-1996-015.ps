URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1996/UM-CS-1996-015.ps
Refering-URL: http://www.cs.umass.edu/~potter/LC/spring96.doc.html
Root-URL: 
Title: Efficient Transaction Support for  
Keyword: Concurrency Control, Recovery, Transaction Management, Index Management, Information Retrieval, Optimization, Performance, Digital Libraries  
Note: Supported by NSF grant IRI-9314376 and a grant from Sun Microsystems Labs  
Abstract: Dynamic Information Retrieval Systems y Mohan Kamath and Krithi Ramamritham Computer Science Technical Report 96-15 Department of Computer Science University of Massachusetts Amherst MA 01003 fkamath,krithig@cs.umass.edu Abstract To properly handle concurrent accesses to documents by updates and queries in information retrieval (IR) systems, efforts are on to integrate IR features with database management system (DBMS) features. However, initial research has revealed that DBMS features optimized for traditional databases, display degraded performance while handling text databases. Since efficiency is critical in IR systems, infrastructural extensions are necessary for several DBMS features, transaction support being one of them. This paper focuses on developing efficient transaction support for IR systems where updates and queries arrive dynamically, by exploiting the data characteristics of the indexes as well as of the queries and updates that access the indexes. Results of performance tests on a prototype system demonstrate the superior performance of our algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [BCC94] <author> E.W. Brown, J.P. Callan, and W.B. Croft. </author> <title> Fast incremental indexing for full-text information retrieval. </title> <booktitle> In Proc. of Intl. Conference on Very Large Databases (VLDB), </booktitle> <address> Santiago, Chile, </address> <year> 1994. </year>
Reference-contexts: Hence the new documents are analyzed first in a batch and the keywords extracted, and all the inverted-lists are updated at the end in an incremental fashion as shown in figure 1. The incremental strategy also obviates the need to rebuild indexes <ref> [BCC94, TGMS94] </ref>. Given the keywords relevant to a query, the set of inverted-lists corresponding to these keywords is identified. After reading the inverted-lists, the document IDs and other required information are extracted from the inverted-lists.
Reference: [BCCM94] <author> E.W. Brown, J.P. Callan, W.B. Croft, and J.E.B Moss. </author> <title> Supporting Full-Text Information Retrieval with a Persistent Object Store. </title> <booktitle> In Proc. of Intl. Conference on Extending Database Technology, </booktitle> <address> Cambridge, UK, </address> <year> 1994. </year>
Reference-contexts: Providing transaction semantics for concurrent accesses by updates and queries to documents has been a long recognized goal. Hence recently there have been some research efforts to integrate information retrieval (IR) features with database management system (DBMS) features <ref> [Fuh93, BCCM94, DDS + 95] </ref>. However, initial findings have revealed that DBMS features optimized for large traditional databases show performance degradation while handling text databases [DDS + 95].
Reference: [BGAS94] <author> C. Buckley, G.Salton, J. Allan, and A. Singhal. </author> <title> Auotmatic Query Expansion Using SMART: </title> <booktitle> TREC3. In Third Text REtrieval Conference (TREC-3), </booktitle> <pages> pages 69-80, </pages> <address> Gaithersburg, Maryland, </address> <year> 1994. </year> <month> 19 </month>
Reference-contexts: The query goes through an optional query expansion phase by referring to the context dictionary, i:e:; a user specified query is transformed to have more semantic context (by changing/adding new keywords) before it reads the inverted-lists <ref> [LK94, BGAS94] </ref>. Any changes made to the context dictionary should also be reflected in the system at the earliest. 2.2 Query and Update Processing When a document is added to the database, the indexes must be updated to reflect the addition of the new document to the database.
Reference: [BHG87] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Isolation requirements can be usually specified based on the dependencies between the read (R) and write (W) operations. The three dependencies we need to consider are W-W, W-R and R-W <ref> [BHG87] </ref>. * W-W dependencies: Since updates are in the form of appends and appends to a set can be considered to be idempotent 2 . Appends also commute and hence these dependencies need not be tracked.
Reference: [Bro95] <author> E.W. Brown. </author> <title> Fast Evaluation of Structured Queries for Information Retrieval. </title> <booktitle> In Proc. of SIGIR Intl. Conf. on Research and Development in Information Retrieval, </booktitle> <year> 1995. </year>
Reference-contexts: Once the document IDs are determined, query processing is complete and the user is presented with the basic information about the documents like the abstract or the first few lines. Several optimizations can be performed to truncate the search process <ref> [Bro95] </ref>. The shaded areas in figure 1 show the scope of the transactions during query and update processing.
Reference: [Cro94] <author> W. B. Croft. </author> <title> What do People Want from Information Retrieval? In D-Lib Magazine. </title> <note> Available at http://www.dlib.org/dlib/november95/11croft.html, 1994. </note>
Reference-contexts: An example of a system that handles dynamic queries is an on-line search system for web pages and news articles (like Infoseek search). Here documents arriving over the network with rates sometimes as high as 100 MB/hour <ref> [Cro94] </ref> are continuously analyzed and added to the system, while several thousand queries are processed every hour. In many IR systems, for example, news retrieval systems, the most recently added items are often the most relevant ones.
Reference: [DDS + 95] <author> S. DeFazio, A. Daoud, L. Smith, J. Srinivasan, B. Croft, and J. Callan. </author> <title> Integrating IR and RDBMS Using Cooperative Indexing. </title> <booktitle> In Proc. of SIGIR Intl. Conf. on Research and Development in Information Retrieval, </booktitle> <pages> pages 84-92, </pages> <year> 1995. </year>
Reference-contexts: Providing transaction semantics for concurrent accesses by updates and queries to documents has been a long recognized goal. Hence recently there have been some research efforts to integrate information retrieval (IR) features with database management system (DBMS) features <ref> [Fuh93, BCCM94, DDS + 95] </ref>. However, initial findings have revealed that DBMS features optimized for large traditional databases show performance degradation while handling text databases [DDS + 95]. <p> Hence recently there have been some research efforts to integrate information retrieval (IR) features with database management system (DBMS) features [Fuh93, BCCM94, DDS + 95]. However, initial findings have revealed that DBMS features optimized for large traditional databases show performance degradation while handling text databases <ref> [DDS + 95] </ref>. Efficiency is a critical factor that governs the success of large IR systems and hence successful integration of IR and DBMS features requires careful analysis and redesign of some of the DBMS features. <p> Hence it can be used in the integration of IR with any type of DBMS | RDBMS or an OODBMS and with any index structure like hashing or B-tree and its variants. Since our schemes are independent of the index structure used, applications can store and interpret the indexes <ref> [LS88, DDS + 95] </ref>. <p> The total size of a batch is about 0.45 MB, which is close to that used in <ref> [DDS + 95] </ref>. Notice that updates are long since on an average 1694 inverted-lists are to be updated. To avoid deadlocks arising from long duration updates in the DB-locking scheme, we rearranged the keywords whose inverted-lists are to be updated in an alphabetical order.
Reference: [Fuh93] <author> N. Fuhr. </author> <title> A probabilistic relational model for the integration of IR and databases. </title> <booktitle> In Proc. of SIGIR Intl. Conf. on Research and Development in Information Retrieval, </booktitle> <pages> pages 309-317, </pages> <year> 1993. </year>
Reference-contexts: Providing transaction semantics for concurrent accesses by updates and queries to documents has been a long recognized goal. Hence recently there have been some research efforts to integrate information retrieval (IR) features with database management system (DBMS) features <ref> [Fuh93, BCCM94, DDS + 95] </ref>. However, initial findings have revealed that DBMS features optimized for large traditional databases show performance degradation while handling text databases [DDS + 95].
Reference: [GR93] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Since inverted-lists have to be accessed quickly, normally B-trees (or some other index structure) are used to maintain a keyword-index. There are several ways in which the inverted-lists (secondary index) can be linked to a keyword in a B-tree node <ref> [GR93] </ref>, especially for non-unique keyword additions. The choice reflects the tradeoff in the number and type of accesses. The type of structure used for maintaining the keyword-index or the inverted-list is not relevant to us since the techniques we are proposing in this paper are independent of the structure used. <p> Thus updates are performed on a large number of inverted-lists, increasing the duration of such updates. When updates are of long duration, queries will have longer response times and the probability of transactions deadlocks also increase <ref> [GR93] </ref>. After identifying the performance and correctness considerations, we exploit them to design high performance concurrency control and recovery schemes tailored for DIRSs. <p> Towards this end we have introduced the notion of operation reordering as discussed in section 4. Because dependencies need not be tracked, the update can be programmed as a mini-batch 3 <ref> [GR93] </ref>. Since there no dependencies between index entries and there are no operations that can lead to logical errors, logical failures are rare. <p> This way the lock waiting time for queries is drastically reduced and we can ensure that the query sees the most recent documents without paying a high price. The locking mechanisms and data structures are similar to the ones described in <ref> [GR93] </ref>. The main data structure is a hash table and each hash chain contains a number of locked inverted-lists. The lock header for each inverted-list contains a list of transactions to whom locks have been granted and a waiting queue for transactions that need a lock on that inverted-list.
Reference: [LK94] <author> X. A. Lu and R. B. Keefer. </author> <title> Query Expansion/Reduction and its Impact on Retrieval Effectiveness. </title> <booktitle> In Third Text REtrieval Conference (TREC-3), </booktitle> <pages> pages 231-240, </pages> <address> Gaithersburg, Maryland, </address> <year> 1994. </year>
Reference-contexts: The query goes through an optional query expansion phase by referring to the context dictionary, i:e:; a user specified query is transformed to have more semantic context (by changing/adding new keywords) before it reads the inverted-lists <ref> [LK94, BGAS94] </ref>. Any changes made to the context dictionary should also be reflected in the system at the earliest. 2.2 Query and Update Processing When a document is added to the database, the indexes must be updated to reflect the addition of the new document to the database.
Reference: [LS88] <author> C. Lynch and M. Stonebraker. </author> <title> Extended user-defined indexing with application to textual databases. </title> <booktitle> In Proc. Int'l. Conf. on Very Large Data Bases, </booktitle> <pages> page 306, </pages> <address> Los Angeles, CA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Hence it can be used in the integration of IR with any type of DBMS | RDBMS or an OODBMS and with any index structure like hashing or B-tree and its variants. Since our schemes are independent of the index structure used, applications can store and interpret the indexes <ref> [LS88, DDS + 95] </ref>.
Reference: [LS92] <author> D. Lomet and B. Salzberg. </author> <title> Access method concurrency with recovery. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> page 351, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Since our schemes are independent of the index structure used, applications can store and interpret the indexes [LS88, DDS + 95]. We did not discuss the details of concurrency control scheme for the different tyoe of index structure since they have been thoroughly investigated <ref> [Moh90, ML92, MN92, SC92, LS92] </ref>. 5 Logging and Recovery In this section we present logging techniques for making document changes durable on the disk and recovery techniques to ensure consistency in the event of failures. These are implemented by the log manager.
Reference: [ML92] <author> C. Mohan and F. Levine. ARIES/IM: </author> <title> An efficient and high-concurrency index management method using write-ahead logging. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> page 371, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Since our schemes are independent of the index structure used, applications can store and interpret the indexes [LS88, DDS + 95]. We did not discuss the details of concurrency control scheme for the different tyoe of index structure since they have been thoroughly investigated <ref> [Moh90, ML92, MN92, SC92, LS92] </ref>. 5 Logging and Recovery In this section we present logging techniques for making document changes durable on the disk and recovery techniques to ensure consistency in the event of failures. These are implemented by the log manager.
Reference: [MN92] <author> C. Mohan and I. Narang. </author> <title> Algorithms for creating indexes for very large tables without quiescing updates. </title> <booktitle> In ACM SIGMOD Conf. on the Management of Data, </booktitle> <address> San Diego, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Since our schemes are independent of the index structure used, applications can store and interpret the indexes [LS88, DDS + 95]. We did not discuss the details of concurrency control scheme for the different tyoe of index structure since they have been thoroughly investigated <ref> [Moh90, ML92, MN92, SC92, LS92] </ref>. 5 Logging and Recovery In this section we present logging techniques for making document changes durable on the disk and recovery techniques to ensure consistency in the event of failures. These are implemented by the log manager.
Reference: [Moh90] <author> C. Mohan. ARIES/KVL: </author> <title> A key-value locking method for concurrencty control of multiaction transactions operating on BTree indexes. </title> <booktitle> In Proceedings of the 16th Conference on Very Large Databases, </booktitle> <publisher> Morgan Kaufman pubs. </publisher> <address> (Los Altos CA), Bris-bane, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Since our schemes are independent of the index structure used, applications can store and interpret the indexes [LS88, DDS + 95]. We did not discuss the details of concurrency control scheme for the different tyoe of index structure since they have been thoroughly investigated <ref> [Moh90, ML92, MN92, SC92, LS92] </ref>. 5 Logging and Recovery In this section we present logging techniques for making document changes durable on the disk and recovery techniques to ensure consistency in the event of failures. These are implemented by the log manager.
Reference: [Reu84] <author> A. Reuter. </author> <title> Performance analysis of recovery techniques. </title> <journal> ACM Trans. on Database Sys., </journal> <volume> 9(4):526, </volume> <month> December </month> <year> 1984. </year>
Reference-contexts: Hence we force the log records of the committed mini-batch to the disk at commit time. A checkpoint is to be taken periodically. How often a checkpoint is to be done is a tradeoff and studies have been made in this regard <ref> [Reu84] </ref>. When a checkpoint is taken, all system inverted-list database buffers are flushed to the disk and a checkpoint record that contains the LSN (log sequence number) of the last log record processed is also flushed to the disk.
Reference: [SC91] <author> V. Srinivasan and M. J. Carey. </author> <title> Performance of B-tree concurrency control algorithms. </title> <booktitle> In ACM SIGMOD Conf. on the Management of Data, </booktitle> <address> Boulder, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Thus our idea of operation reordering has a huge pay off and contributes to good recency. The 0.5 % we miss in terms of latest documents can be attributed to update transactions that start while query transactions are in progress. Similar to the compensation based on-line query processing technique <ref> [SC91] </ref>, we could force the query to check if there are 17 new updates before it completes and if so re-execute the query.
Reference: [SC92] <author> V. Srinivasan and M. J. Carey. </author> <title> Compensation-based on-line query processing. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> page 331, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Since our schemes are independent of the index structure used, applications can store and interpret the indexes [LS88, DDS + 95]. We did not discuss the details of concurrency control scheme for the different tyoe of index structure since they have been thoroughly investigated <ref> [Moh90, ML92, MN92, SC92, LS92] </ref>. 5 Logging and Recovery In this section we present logging techniques for making document changes durable on the disk and recovery techniques to ensure consistency in the event of failures. These are implemented by the log manager.
Reference: [TGMS94] <author> A. Thomasic, H. Garcia-Molina, and K. Shoens. </author> <title> Incremental Updates of Inverted Lists for Text Document Retrieval. </title> <booktitle> In Proc. of SIGMOD Intl. Conference on Management of Data, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Hence the new documents are analyzed first in a batch and the keywords extracted, and all the inverted-lists are updated at the end in an incremental fashion as shown in figure 1. The incremental strategy also obviates the need to rebuild indexes <ref> [BCC94, TGMS94] </ref>. Given the keywords relevant to a query, the set of inverted-lists corresponding to these keywords is identified. After reading the inverted-lists, the document IDs and other required information are extracted from the inverted-lists.
Reference: [TGNO92] <author> D. Terry, D. Goldberg, D. Nichols, and B. </author> <title> Oki. Continuous queries over append-only databases. </title> <booktitle> In Proc ACM SIGMOD Conf., </booktitle> <pages> pages 321-330, </pages> <address> San Diego, California, </address> <year> 1992. </year>
Reference-contexts: In this paper, we primarily focus on dynamic IR systems (DIRS) where queries and updates arriving dynamically are processed. Thus the articles of interest to a user are known only when a query arrives. This is unlike systems like SIFT [YGM95a] and Tapestry <ref> [TGNO92] </ref> which are geared to continuously respond to statically specified queries or filters. In these systems, a new document that arrives is routed to a user only if it passes the filtering criterion specified by that user.
Reference: [YGM95a] <author> T. W. Yan and H. Garcia-Molina. </author> <title> SIFT ATool for Wide-Area Information Dissemination. </title> <booktitle> In In Proc. of 1995 USENIX Technical Conference, </booktitle> <pages> pages 177-186, </pages> <year> 1995. </year>
Reference-contexts: In this paper, we primarily focus on dynamic IR systems (DIRS) where queries and updates arriving dynamically are processed. Thus the articles of interest to a user are known only when a query arrives. This is unlike systems like SIFT <ref> [YGM95a] </ref> and Tapestry [TGNO92] which are geared to continuously respond to statically specified queries or filters. In these systems, a new document that arrives is routed to a user only if it passes the filtering criterion specified by that user. <p> In the context of static continuous queries, when a user submits a new profile or makes a profile modification, the profile inverted-lists corresponding to these profiles are to be updated. The queries from the document analyzer read these profile inverted-lists <ref> [YGM95a] </ref> only after the updates from the profile-modification have updated the profile inverted-lists. The responses received by a user from the IR system will thus immediately reflect the profile changes.
Reference: [YGM95b] <author> T.W. Yan and H. Garcia-Molina. </author> <title> Information Finding in a Digital Library: the Stanford Perspective. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 24(3), </volume> <month> September </month> <year> 1995. </year> <month> 20 </month>
Reference-contexts: Thus, all efforts should be made to consider the most latest documents for processing a query. A similar situation exists in distributed IR systems, comprised of 1000s of independent text databases. In the text-database discovery problem <ref> [YGM95b] </ref>, before answering a query, the most appropriate site which contains documents that best match a query is to be determined. This is achieved by accessing a local database that is continuously updated using meta-information arriving from 1 other sites.
References-found: 22

