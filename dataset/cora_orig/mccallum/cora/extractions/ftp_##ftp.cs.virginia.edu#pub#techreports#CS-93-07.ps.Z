URL: ftp://ftp.cs.virginia.edu/pub/techreports/CS-93-07.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Hardware Support for Aggressive Parallel Discrete Event Simulation  
Author: Sudhir Srinivasan Paul F. Reynolds, Jr. 
Abstract: Computer Science Report No. TR-93-07 January 11, 1993 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Ball, D. and Hoyt, S., </author> <title> The adaptive Time-Warp concurrency control algorithm, </title> <booktitle> Proceedings of the SCS Multiconference on Distributed Simulation, </booktitle> <month> January </month> <year> 1990, </year> <pages> pp 174-177. </pages>
Reference-contexts: An interesting and promising subclass of adaptive protocols are those in which the LPs dynamically control their aggressiveness. Recent research <ref> [1, 6, 7, 16, 17] </ref> suggests that controlled aggressiveness will most likely be a feature of a universally efficient protocol. In the rest of this paper, we will use the term adaptive to refer to this subclass of adaptive protocols which is characterized by controlled aggressiveness.
Reference: 2. <author> Bauer, H. and Sporrer, C., </author> <title> Distributed logic simulation and an approach to asynchronous GVT-calculation, </title> <booktitle> Proceedings of the sixth workshop on parallel and distributed simulation, </booktitle> <month> January </month> <year> 1992, </year> <pages> pp 205-208. </pages>
Reference-contexts: However, this problem can be alleviated by using several pairs of T-values to perform several acknowledgments concurrently. 8.3 Previous work Since the introduction of the Time Warp protocol, several algorithms have been proposed to compute GVT in a message passing system <ref> [2, 3, 5, 8, 11, 20, 27] </ref>. With the exception of [8], all of these algorithms share the property that they use the host communication network of the message passing computer to compute GVT. <p> This is considerably larger than the few tens of microseconds projected for our algorithm. Bauer and Sporrer <ref> [2] </ref> also proposed an asynchronous approach to GVT calculation. Their method uses a dedicated processor for computing GVT (besides other functions). All other processors communicate periodically with this GVT Calculator. Obviously, the GVT Calculator is a potential bottleneck. Their algorithm also uses the host communication network to compute GVT.
Reference: 3. <author> Bellenot, S., </author> <title> Global virtual time algorithms, </title> <booktitle> Proceedings of the 1990 SCS Multiconference on Distributed Simulation, </booktitle> <month> January </month> <year> 1990, </year> <pages> pp 122-127. </pages>
Reference-contexts: However, this problem can be alleviated by using several pairs of T-values to perform several acknowledgments concurrently. 8.3 Previous work Since the introduction of the Time Warp protocol, several algorithms have been proposed to compute GVT in a message passing system <ref> [2, 3, 5, 8, 11, 20, 27] </ref>. With the exception of [8], all of these algorithms share the property that they use the host communication network of the message passing computer to compute GVT. <p> A hierarchical scatter-gather scheme can be used to alleviate this situation. However, whenever a processor needs the value of GVT, all other processors are involved in the operation. Bellenots algorithm <ref> [3] </ref> also uses acknowledgments to maintain the smallest unreceived message time. Here again, there is a designated initiator processor. The optimization in this algorithm is the way in which GVT is computed, so that the initiator does not become the bottleneck.
Reference: 4. <author> Chandy, K.M. and Misra, J., </author> <title> Distributed Simulation: A case study in the design and verification of distributed programs, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-5, No. 5, </volume> <month> September </month> <year> 1979, </year> <pages> pp 440-452. </pages>
Reference-contexts: Consequently, a different method for parallelizing DES has been adopted <ref> [4, 19] </ref>. The essence of this method is to divide the DES into several logical processes (LPs), each responsible for simulating a part of the physical system.
Reference: 5. <author> Concepcion, A.I. and Kelly, S. G., </author> <title> Computing global virtual time using the Multiple-Level Token Passing algorithm, </title> <booktitle> Proceedings of the SCS Multiconference on Advances in Parallel and Distributed Simulation, </booktitle> <month> January </month> <year> 1991, </year> <pages> pp 63-68. </pages>
Reference-contexts: However, this problem can be alleviated by using several pairs of T-values to perform several acknowledgments concurrently. 8.3 Previous work Since the introduction of the Time Warp protocol, several algorithms have been proposed to compute GVT in a message passing system <ref> [2, 3, 5, 8, 11, 20, 27] </ref>. With the exception of [8], all of these algorithms share the property that they use the host communication network of the message passing computer to compute GVT. <p> Moreover, [13] do not address the issue of maintaining , which will require more messages through the host network. Lin and Lazowska [11] proposed an algorithm in which they eliminated acknowledgments of messages. This cuts the message traffic in the host network by half. However, Concepcion and Kelly <ref> [5] </ref> pointed out that the network traffic in the worst case for this algorithm could be O (n 2 ). In effect, this algorithm suffers the penalties of acknowledging messages. Concepcion and Kelly proposed the first asynchronous approach to GVT computation, called the Multiple Level Token Passing algorithm (MLTP).
Reference: 6. <author> Dickens, P.M., Reynolds, P.F., Jr. and Duva, J.M., </author> <title> State saving and rollback costs for an aggressive global windowing algorithm, </title> <type> Technical Report number TR-92-18, </type> <institution> Computer Science Department, University of Virginia, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: An interesting and promising subclass of adaptive protocols are those in which the LPs dynamically control their aggressiveness. Recent research <ref> [1, 6, 7, 16, 17] </ref> suggests that controlled aggressiveness will most likely be a feature of a universally efficient protocol. In the rest of this paper, we will use the term adaptive to refer to this subclass of adaptive protocols which is characterized by controlled aggressiveness.
Reference: 7. <author> Dickens, P.M. and Reynolds, P.F., Jr., </author> <title> SRADS with local rollback, </title> <booktitle> Proceedings of the 1990 SCS Multiconference on Distributed Simulation, </booktitle> <month> January </month> <year> 1990, </year> <pages> pp 161-164. </pages>
Reference-contexts: An interesting and promising subclass of adaptive protocols are those in which the LPs dynamically control their aggressiveness. Recent research <ref> [1, 6, 7, 16, 17] </ref> suggests that controlled aggressiveness will most likely be a feature of a universally efficient protocol. In the rest of this paper, we will use the term adaptive to refer to this subclass of adaptive protocols which is characterized by controlled aggressiveness.
Reference: 8. <author> Filloque, J.M., Gautrin, E. and Pottier, B., </author> <title> Efficient global computations on a processor network with programmable logic, </title> <type> Research Report number 1374, </type> <institution> Institut National de Recherche en Informatique et en Automatique, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: However, this problem can be alleviated by using several pairs of T-values to perform several acknowledgments concurrently. 8.3 Previous work Since the introduction of the Time Warp protocol, several algorithms have been proposed to compute GVT in a message passing system <ref> [2, 3, 5, 8, 11, 20, 27] </ref>. With the exception of [8], all of these algorithms share the property that they use the host communication network of the message passing computer to compute GVT. <p> With the exception of <ref> [8] </ref>, all of these algorithms share the property that they use the host communication network of the message passing computer to compute GVT. <p> Finally, we have presented results of preliminary studies of the performance of the algorithm and compared this with previous work in this area. Acknowledgments This work was supported in part by the National Science Foundation <ref> (grant CCR-9108448, Aug. 91, number 48) </ref> and MITRE Corporation (Academic Affiliates Program). All simulations were performed using SES/Workbench. Hardware Support for Aggressive Parallel Discrete Event Simulation 36
Reference: 9. <author> Fujimoto, </author> <title> R.M., Parallel discrete event simulation, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 33, No. 10, </volume> <month> October </month> <year> 1990, </year> <pages> pp 30-53. </pages>
Reference-contexts: A dependence graph can be constructed using these causal relations, which defines a partial order on all of the simulated events. Events which are not related under this partial order can be executed concurrently. It appears that typical DESs exhibit substantial concurrency in their dependence graphs <ref> [9, 15, 19] </ref> which makes DES a candidate for parallelization. Ironically though, this concurrency is difficult to extract in practice. <p> Our algorithm will serve as a foundation for the design of adaptive protocols which use the hardware to gather status information at very low cost. 1.2 Background In the past, researchers have proposed several protocols <ref> [9] </ref>, most of which belong to one of two categories: non-aggressive, accurate and without risk (commonly known as conservative) and aggressive, accurate and with risk (commonly optimistic) with some exceptions. <p> Another problem aggressive protocols face is that LPs periodically require a global value called global virtual time (GVT) [10]. Computing GVT has thus far been an expensive operation. Note that the general class of aggressive protocols includes optimistic protocols. Researchers have reported success with both non-aggressive and aggressive protocols <ref> [9] </ref>. Studies have shown that there are applications for which aggressive protocols will outperform non-aggressive ones [12, 14] and vice-versa [16]. As a result, there is no optimal protocol. <p> We assume that the simulators under discussion are functionally accurate. By temporal correctness we mean that none of the committed events violate causality constraints. The following criteria define (temporal) correctness of a parallel simulation: i) each LP must ultimately execute events in strictly non-decreasing timestamp order <ref> [9] </ref> ii) the simulator must make progress if the application being simulated makes progress The second criterion incorporates the concepts of freedom from deadlock as well as termination. 4.1 Correctness of a Time Warp system For a Time Warp system, it can be proven that the value of GVT never decreases,
Reference: 10. <author> Jefferson, </author> <title> D.R., Virtual time, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 7, No. 3, </volume> <month> July </month> <year> 1985, </year> <pages> pp 404-425. </pages>
Reference-contexts: The Hardware Support for Aggressive Parallel Discrete Event Simulation 2 costs of these actions can become prohibitively high in implementations. Another problem aggressive protocols face is that LPs periodically require a global value called global virtual time (GVT) <ref> [10] </ref>. Computing GVT has thus far been an expensive operation. Note that the general class of aggressive protocols includes optimistic protocols. Researchers have reported success with both non-aggressive and aggressive protocols [9]. <p> In this section, we present our algorithm which is a modified version of the algorithm of Figure 2, modified to incorporate the considerations for the two attributes just mentioned. For exposition, our choice of aggressive protocol is Time Warp <ref> [10] </ref>. The most important synchronization value required by the LPs in Time Warp is GVT. GVT is required by the LPs during a simulation for several reasons: fossil collection in systems with limited state saving space, performing I/O, collecting statistics and detecting termination conditions. <p> progress The second criterion incorporates the concepts of freedom from deadlock as well as termination. 4.1 Correctness of a Time Warp system For a Time Warp system, it can be proven that the value of GVT never decreases, by considering all of the possible ways in which GVT may change <ref> [10] </ref>. Hence, GVT defines a commitment horizon, i.e. events with timestamps lower than GVT can be committed. Other uses of GVT are fossil collection, gathering statistical data and detecting the occurrence of termination conditions.
Reference: 11. <author> Lin, Y-B. and Lazowska, E.D., </author> <title> Determining the global virtual time in a distributed simulation, </title> <type> Technical Report number 90-01-02, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: However, this problem can be alleviated by using several pairs of T-values to perform several acknowledgments concurrently. 8.3 Previous work Since the introduction of the Time Warp protocol, several algorithms have been proposed to compute GVT in a message passing system <ref> [2, 3, 5, 8, 11, 20, 27] </ref>. With the exception of [8], all of these algorithms share the property that they use the host communication network of the message passing computer to compute GVT. <p> The result of this operation is carried further by the message. Thus GVT computation involves O (n) messages. Moreover, [13] do not address the issue of maintaining , which will require more messages through the host network. Lin and Lazowska <ref> [11] </ref> proposed an algorithm in which they eliminated acknowledgments of messages. This cuts the message traffic in the host network by half. However, Concepcion and Kelly [5] pointed out that the network traffic in the worst case for this algorithm could be O (n 2 ).
Reference: 12. <author> Lin, Y-B. and Lazowska, E.D., </author> <title> A study of Time Warp rollback mechanisms, </title> <journal> ACM Transactions on Modeling and Computer Simulations, </journal> <volume> Vol. 1, No. 1, </volume> <month> January </month> <year> 1991, </year> <pages> pp 51-72. </pages>
Reference-contexts: Computing GVT has thus far been an expensive operation. Note that the general class of aggressive protocols includes optimistic protocols. Researchers have reported success with both non-aggressive and aggressive protocols [9]. Studies have shown that there are applications for which aggressive protocols will outperform non-aggressive ones <ref> [12, 14] </ref> and vice-versa [16]. As a result, there is no optimal protocol. In [21], Reynolds points out that there are several other categories of protocols, based on a set of design variables used to characterize protocols.
Reference: 13. <author> Livny, M. and Manber, U., </author> <title> Distributed computation via active messages, </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol C-34, No. 12, </volume> <month> December </month> <year> 1985, </year> <pages> pp 1185-1190. </pages>
Reference-contexts: Preiss [20] proposed a ring algorithm using a token which is passed around to compute GVT. Here again, all processors are involved in every GVT computation and the host communication network is used to compute GVT. A similar approach was followed in <ref> [13] </ref> where GVT is computed in a networked environment using active messages in the network. <p> The result of this operation is carried further by the message. Thus GVT computation involves O (n) messages. Moreover, <ref> [13] </ref> do not address the issue of maintaining , which will require more messages through the host network. Lin and Lazowska [11] proposed an algorithm in which they eliminated acknowledgments of messages. This cuts the message traffic in the host network by half.
Reference: 14. <author> Lipton, R.J. and Mizell, D.W., </author> <title> Time Warp vs. Chandy-Misra: A worst-case comparison, </title> <booktitle> Proceedings of the 1990 SCS Multiconference on Distributed Simulation, </booktitle> <month> January </month> <year> 1990, </year> <pages> pp 137-143. </pages>
Reference-contexts: Computing GVT has thus far been an expensive operation. Note that the general class of aggressive protocols includes optimistic protocols. Researchers have reported success with both non-aggressive and aggressive protocols [9]. Studies have shown that there are applications for which aggressive protocols will outperform non-aggressive ones <ref> [12, 14] </ref> and vice-versa [16]. As a result, there is no optimal protocol. In [21], Reynolds points out that there are several other categories of protocols, based on a set of design variables used to characterize protocols.
Reference: 15. <author> Livny, M., </author> <title> A study of parallelism in distributed simulation, </title> <booktitle> Proceedings of the 1990 SCS Multiconference on Distributed Simulation, </booktitle> <month> January </month> <year> 1985, </year> <pages> pp 94-98. </pages> <booktitle> Hardware Support for Aggressive Parallel Discrete Event Simulation 37 </booktitle>
Reference-contexts: A dependence graph can be constructed using these causal relations, which defines a partial order on all of the simulated events. Events which are not related under this partial order can be executed concurrently. It appears that typical DESs exhibit substantial concurrency in their dependence graphs <ref> [9, 15, 19] </ref> which makes DES a candidate for parallelization. Ironically though, this concurrency is difficult to extract in practice.
Reference: 16. <author> Lubachevsky, B., Weiss, A. and Shwartz, A., </author> <title> Rollback sometimes works . . . if filtered, </title> <booktitle> Proceedings of the 1989 Winter Simulation Conference, </booktitle> <month> December </month> <year> 1989, </year> <pages> pp 630-639. </pages>
Reference-contexts: Note that the general class of aggressive protocols includes optimistic protocols. Researchers have reported success with both non-aggressive and aggressive protocols [9]. Studies have shown that there are applications for which aggressive protocols will outperform non-aggressive ones [12, 14] and vice-versa <ref> [16] </ref>. As a result, there is no optimal protocol. In [21], Reynolds points out that there are several other categories of protocols, based on a set of design variables used to characterize protocols. <p> An interesting and promising subclass of adaptive protocols are those in which the LPs dynamically control their aggressiveness. Recent research <ref> [1, 6, 7, 16, 17] </ref> suggests that controlled aggressiveness will most likely be a feature of a universally efficient protocol. In the rest of this paper, we will use the term adaptive to refer to this subclass of adaptive protocols which is characterized by controlled aggressiveness.
Reference: 17. <author> Lubachevsky, B., Weiss, A. and Shwartz, A., </author> <title> An analysis of rollback-based simulation, </title> <journal> ACM Transactions on Modeling and Computer Simulation, </journal> <volume> Vol. 1, No. 2, </volume> <month> April </month> <year> 1991, </year> <pages> pp 154-193. </pages>
Reference-contexts: An interesting and promising subclass of adaptive protocols are those in which the LPs dynamically control their aggressiveness. Recent research <ref> [1, 6, 7, 16, 17] </ref> suggests that controlled aggressiveness will most likely be a feature of a universally efficient protocol. In the rest of this paper, we will use the term adaptive to refer to this subclass of adaptive protocols which is characterized by controlled aggressiveness.
Reference: 18. <author> Pancerella, </author> <title> C.M., Improving the efficiency of a framework for parallel simulations, </title> <booktitle> Proceedings of the 6th Workshop on Parallel and Distributed Simulation, </booktitle> <month> January </month> <year> 1992, </year> <pages> pp 22-27. </pages>
Reference-contexts: To achieve this, the algorithm acknowledges each message received by an LP using the two-phase protocol described in <ref> [18] </ref>. The acknowledgment protocol uses two more T-values, and . <p> It is executed periodically, as often as possible. Since acknowledgments are performed through the reduction network, they do not interfere with the simulation message traffic in the host communication network. We first briey present the two enhancements described in <ref> [18] </ref> which have been incorporated into the CHKACK procedure, viz., the two-phase protocol for acknowledging messages and batched acknowledgments. Two-phase acknowledgment protocol In the framework, messages are acknowledged through the reduction network.
Reference: 19. <author> Peacock, J.K., Wong, J.W. and Manning, E.G., </author> <title> Distributed simulation using a network of processors, </title> <journal> Computer Networks, </journal> <volume> Vol. 3, No. 1, </volume> <month> February </month> <year> 1979, </year> <pages> pp 44-56. </pages>
Reference-contexts: A dependence graph can be constructed using these causal relations, which defines a partial order on all of the simulated events. Events which are not related under this partial order can be executed concurrently. It appears that typical DESs exhibit substantial concurrency in their dependence graphs <ref> [9, 15, 19] </ref> which makes DES a candidate for parallelization. Ironically though, this concurrency is difficult to extract in practice. <p> Consequently, a different method for parallelizing DES has been adopted <ref> [4, 19] </ref>. The essence of this method is to divide the DES into several logical processes (LPs), each responsible for simulating a part of the physical system.
Reference: 20. <author> Preiss, B., </author> <title> The Yaddes distributed discrete event simulation specification language and execution environments, </title> <booktitle> Proceedings of the SCS Multiconference on Distributed Simulation, </booktitle> <month> January </month> <year> 1989, </year> <pages> pp 139-144. </pages>
Reference-contexts: However, this problem can be alleviated by using several pairs of T-values to perform several acknowledgments concurrently. 8.3 Previous work Since the introduction of the Time Warp protocol, several algorithms have been proposed to compute GVT in a message passing system <ref> [2, 3, 5, 8, 11, 20, 27] </ref>. With the exception of [8], all of these algorithms share the property that they use the host communication network of the message passing computer to compute GVT. <p> Bellenots algorithm [3] also uses acknowledgments to maintain the smallest unreceived message time. Here again, there is a designated initiator processor. The optimization in this algorithm is the way in which GVT is computed, so that the initiator does not become the bottleneck. Preiss <ref> [20] </ref> proposed a ring algorithm using a token which is passed around to compute GVT. Here again, all processors are involved in every GVT computation and the host communication network is used to compute GVT.
Reference: 21. <author> Reynolds, P.F., Jr., </author> <title> A spectrum of options for parallel simulation, </title> <booktitle> Proceedings of the 1988 Winter Simulation Conference, </booktitle> <month> December </month> <year> 1988, </year> <pages> pp 325-332. </pages>
Reference-contexts: Researchers have reported success with both non-aggressive and aggressive protocols [9]. Studies have shown that there are applications for which aggressive protocols will outperform non-aggressive ones [12, 14] and vice-versa [16]. As a result, there is no optimal protocol. In <ref> [21] </ref>, Reynolds points out that there are several other categories of protocols, based on a set of design variables used to characterize protocols.
Reference: 22. <author> Reynolds, P.F., Jr., </author> <title> An efficient framework for parallel simulations, </title> <booktitle> To appear in the International Journal in Computer Simulation, </booktitle> <volume> Vol. 3, No. 4, </volume> <year> 1992. </year> <note> An earlier version appeared in Proceedings of the SCS Multiconference on Distributed Simulation, </note> <month> January </month> <year> 1991, </year> <pages> pp 167-174. </pages>
Reference-contexts: The method used to synchronize the LPs of a Parallel Discrete Event Simulation (PDES) is generally referred to as a protocol. We present a modified version of a previously proposed synchronization algorithm <ref> [22] </ref>, modified to operate with a class of protocols which we call aggressive protocols. This class includes the so-called optimistic protocols as well as an interesting and as yet relatively unexplored subclass: adaptive protocols in which the aggressiveness of the LPs is controlled. <p> This class includes the so-called optimistic protocols as well as an interesting and as yet relatively unexplored subclass: adaptive protocols in which the aggressiveness of the LPs is controlled. Also, we prove the correctness of our algorithm. The algorithm of <ref> [22] </ref> as well as our algorithm operate on special-purpose hardware designed to desseminate global information rapidly. <p> The need for global synchronization information motivated a universal framework for all parallel simulations, proposed by Reynolds <ref> [22] </ref>. This framework has the capability of rapidly providing the global information required in any PDES. For instance, it can be used to compute GVT, the minimum lookahead in the system, the oor and ceiling of a computation window or to break deadlocks. <p> At each LP, the algorithm maintains the local counterpart of each global value. For instance, the algorithm could maintain the event processing rate at each LP so that the corresponding global value could identify the fastest LPs. In <ref> [22] </ref>, Reynolds identified two such global values: , the smallest of the timestamps in the future events list of all the LPs and , the smallest of the timestamps of messages that are outstanding (as yet unreceived). Since these values are logical timestamps, we call them T-values. <p> In non-selective operations, the choice can be arbitrary but should be deterministic. 3 Making the framework aggressive It has been established in <ref> [22] </ref> that the framework algorithm will operate correctly with non-aggressive protocols. <p> Gathering this information through the host communication system is very costly as it usually requires several messages. To solve this problem, Reynolds <ref> [22] </ref> proposed the use of special purpose hardware for rapidly computing and disseminating critical synchronization information to all the LPs in a PDES. <p> The problem of obtaining non-local information is especially acute in adaptive systems, where LPs dynamically control their aggressive processing, because each LP requires information only from its set of predecessors. Computing this kind of target-specific information <ref> [22] </ref> is generally more expensive than computing completely global information. Simulations [28] have demonstrated the speed of the framework hardware. It is expected that future versions of this hardware will have the capability to provide target-specific information at such high speeds.
Reference: 23. <author> Reynolds, P.F., Jr. and Pancerella, </author> <title> C.M., Hardware support for parallel discrete event simulations, </title> <institution> Computer Science Technical Report No. TR-92-08, University of Virginia, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: of three parts: (i) A small set of global values required by any PDES protocol (ii) High speed special purpose hardware to rapidly compute and disseminate these global values and (iii) A synchronization algorithm executed by each LP to correctly maintain the global values. (i) and (iii) are described in <ref> [23] </ref> while (ii) is described in [25]. It must be noted that the synchronization algorithm is not a protocol, but a foundation for PDES protocols. It is intuitively clear that the synchronization algorithm can operate with non-aggressive protocols, in which the logical clocks of the LPs never move backwards. <p> In Section 8, we present the findings of preliminary studies of our algorithm and compare this with previous work in this area. Section 9 concludes the paper. 2 A Framework for PDES We begin with a brief review of the Reynolds framework. Details can be found in <ref> [23] </ref>. We first describe the framework algorithm and then the hardware support for the algorithm. 2.1 Framework algorithm The main purpose of the algorithm is to correctly maintain a set of global values required by the protocol being used in the PDES.
Reference: 24. <author> Reynolds, P.F., Jr., Pancerella, C.M. and Srinivasan, S., </author> <title> Making parallel simulations go fast, </title> <booktitle> Proceedings of the 1993 Winter Simulation Conference, </booktitle> <month> December </month> <year> 1992, </year> <pages> pp 646-656. </pages>
Reference-contexts: In the rest of this paper, we will use the term adaptive to refer to this subclass of adaptive protocols which is characterized by controlled aggressiveness. Most PDES protocols require global information of some sort <ref> [24] </ref>. For example, Time Warp LPs require the value of GVT for several reasons. Correspondingly, non-aggressive (or blocking) protocols, which have the potential to deadlock, need to be able to identify the LP with the event that must be executed next, to break a deadlock. <p> For n &gt; 2, this means that a new reduction cycle is started before the current one completes. Since speed of reduction is the primary design goal of this hardware, it is important that c be small. In the prototype hardware described in <ref> [24] </ref>, c is expected to be around 150 nanoseconds giving a reduction cycle time of 1.2 microseconds for 32 processors with 4-element state vectors. Besides the ALU, each PRN node has some additional logic to accommodate T-values which have multiple components (such as and ). <p> It is critical that synchronization values be computed and disseminated rapidly. Based on timing values obtained from the prototype of the framework hardware described in <ref> [24] </ref>, the PRN is expected to compute a globally reduced state vector of four elements from 32 input state vectors in 1.2 microseconds. We note that in the design of the prototype, significant effort was directed towards proof of concept in addition to speed of operation.
Reference: 25. <author> Reynolds, P.F., Jr., Pancerella, C.M. and Srinivasan, S., </author> <title> Design and performance analysis of hardware support for parallel simulations, </title> <type> Technical Report number TR-92-20, </type> <institution> Computer Science Department, University of Virginia, </institution> <month> June </month> <year> 1992. </year> <note> To appear in the special issue of the Journal of Parallel and Distributed Computing on Parallel and Distributed Simulation, </note> <year> 1993. </year>
Reference-contexts: set of global values required by any PDES protocol (ii) High speed special purpose hardware to rapidly compute and disseminate these global values and (iii) A synchronization algorithm executed by each LP to correctly maintain the global values. (i) and (iii) are described in [23] while (ii) is described in <ref> [25] </ref>. It must be noted that the synchronization algorithm is not a protocol, but a foundation for PDES protocols. It is intuitively clear that the synchronization algorithm can operate with non-aggressive protocols, in which the logical clocks of the LPs never move backwards. <p> The four local T-values define a state vector for each LP. State vectors are the smallest unit of transaction between the LPs and the reduction network. They provide atomic snapshots and guarantee that the hardware satisfies certain correctness criteria defined in <ref> [25] </ref>. Whenever an LP changes a T-value, it constructs a state vector with that change and presents it to the reduction network. <p> A detailed description can be found in <ref> [25] </ref>. The hardware configuration is shown in Figure 3. The main components of this hardware are the parallel reduction network (PRN) and the auxiliary processors (AP). For each host processor (HP), there is an AP which is a general purpose processor such as the HP itself. <p> The IN and OUT registers are comprised of three sets of registers each which provide the isolation between the AP and the PRN. The detailed operation of these register interfaces is described in <ref> [25] </ref>. The PRN is a binary tree of height log 2 n, where n is the number of processors. Figure 4 shows a PRN for eight processors. Each node of the tree contains a general purpose ALU which performs reduction operations on its two operands.
Reference: 26. <author> Reiher, P., Fujimoto, R., Bellenot, S. and Jefferson, D., </author> <title> Cancellation strategies in optimistic execution systems, </title> <booktitle> Proceedings of the 1990 SCS Multiconference on Distributed Simulation, </booktitle> <month> January </month> <year> 1990, </year> <pages> pp 112-121. </pages>
Reference-contexts: On a rollback, the logical clock of the LP is rolled back to the timestamp of the straggler. In the ROLLBACK subroutine, we have chosen to employ aggressive cancellation <ref> [26] </ref>. We show later that lazy cancellation is easily accommodated in this algorithm. At the end of a rollback, the PROCESS procedure checks to see if any new stragglers have arrived during the rollback process which will cause the LP to roll back further. If so, ROLLBACK is called again.
Reference: 27. <author> Samadi, B., </author> <title> Distributed simulation: algorithms and performance analysis, </title> <type> Ph.D. Thesis, </type> <institution> Computer Science Department, University of California, </institution> <address> Los Angeles, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: However, this problem can be alleviated by using several pairs of T-values to perform several acknowledgments concurrently. 8.3 Previous work Since the introduction of the Time Warp protocol, several algorithms have been proposed to compute GVT in a message passing system <ref> [2, 3, 5, 8, 11, 20, 27] </ref>. With the exception of [8], all of these algorithms share the property that they use the host communication network of the message passing computer to compute GVT. <p> Thus, we believe our system will provide more accurate values of GVT and also scale better. The first GVT computation algorithm was proposed by Samadi <ref> [27] </ref>. This algorithm uses message acknowledgments in the host network and is quite straightforward. It has the added disadvantage that one processor is designated the initiator of the GVT computation.
Reference: 28. <author> Srinivasan, S., </author> <title> Modeling a framework for parallel simulations, </title> <institution> Master of Science Thesis, Computer Science Department, University of Virginia, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: This enhancement is expected to make the system more robust under heavy loads, as corroborated by simulation studies <ref> [28] </ref>. The CHKACK procedure consists of two parts. <p> Sometimes, a global computation may require multiple reduction cycles (for instance, the two-phase acknowledgment). In addition, the introduction of the interface between the HP and the AP introduces delays in a global computation. It is difficult to analytically estimate the time taken for such multi-cycle global computations. <ref> [28] </ref> describes two simulation experiments conducted to estimate the performance of the framework hardware and AFA2P. The first of these was directed at determining the loading limits of the framework hardware. <p> The problem of obtaining non-local information is especially acute in adaptive systems, where LPs dynamically control their aggressive processing, because each LP requires information only from its set of predecessors. Computing this kind of target-specific information [22] is generally more expensive than computing completely global information. Simulations <ref> [28] </ref> have demonstrated the speed of the framework hardware. It is expected that future versions of this hardware will have the capability to provide target-specific information at such high speeds.
References-found: 28

