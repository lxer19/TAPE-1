URL: http://www.cs.berkeley.edu/~manuel/IRAM/report/eel.ps
Refering-URL: http://www.cs.berkeley.edu/~manuel/IRAM/
Root-URL: http://www.cs.berkeley.edu
Email: fremzi,manuelg@cs.berkeley.edu  
Title: revEELing Solaris  
Author: Remzi Arpaci Manuel Fahndrich 
Date: May 13, 1996  
Address: Berkeley, CA 94720-1776  
Affiliation: EECS Department University of California, Berkeley  
Abstract-found: 0
Intro-found: 1
Reference: [BKLW90] <author> Anita Borg, R. E. Kessler, Georgia Lazana, and David W. Wall. </author> <title> Long address traces from RISC machines: Generation and analysis. </title> <booktitle> In Seventeenth Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 270-279, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: The particular problem addressed by this project is to include the operating system's activity in the trace. Operating system traces can be obtained in several ways. Past efforts have utilized hardware monitors [CHRG95], complete simulation (SimOS [WR96]), and binary instrumentation <ref> [BKLW90, CB93] </ref>. Binary instrumentation is a low-cost, medium-effort approach, which has the advantage of not requiring particular monitoring hardware. Furthermore, we can build on top of existing binary instrumentation tools, leading to a lower development effort than writing a complete operating system simulator. <p> It is quite another challenge to produce meaningful traces, devoid of error. We believe there are two independent steps to producing correct traces: the first is scrutiny of the trace method itself, and the second is scrutiny of the traces themselves. Note that <ref> [BKLW90] </ref> contains a relevant discussion of trace correctness, and has influenced some of our thoughts on the matter. The tracing process has a number of potential pitfalls. The first and foremost in our current implementation is a race condition in the tracing code.
Reference: [BL94] <author> Thomas Ball and James R. Larus. </author> <title> Optimally Profiling and Tracing Programs. </title> <journal> ACM Transactions on Porgramming Languages and Systems, </journal> <volume> 16(4) </volume> <pages> 1319-1360, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Many tools have been written in the past that use this technique for various purposes (Pixie, Mahler [WP87], Nixie and Epoxy [Wal92], QPT <ref> [BL94] </ref>, ATOM [SW94]). All these tools work essentially in the same way, performing a sequence of 3 phases: 1. Analysis * Break code into functions and basic-blocks * Analyze control transfers (jumps, branches, calls) * Produce control flow graph 2. Instrumentation * insert, change, remove code 3.
Reference: [CB93] <author> J. B. Chen and B. N. Bershad. </author> <title> The impact of operating system structure on memory system performance. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <volume> volume 27, </volume> <pages> pages 120-133, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The particular problem addressed by this project is to include the operating system's activity in the trace. Operating system traces can be obtained in several ways. Past efforts have utilized hardware monitors [CHRG95], complete simulation (SimOS [WR96]), and binary instrumentation <ref> [BKLW90, CB93] </ref>. Binary instrumentation is a low-cost, medium-effort approach, which has the advantage of not requiring particular monitoring hardware. Furthermore, we can build on top of existing binary instrumentation tools, leading to a lower development effort than writing a complete operating system simulator. <p> This implies EEL will work on binaries shipped from companies, removing the requirement that we must compile and link every program that we wish to trace. This limitation has limited previous work <ref> [CB93] </ref> in the area to program suites based on SPEC and other readily available source codes. The single issue that remains unresolved for user-code tracing relates to dynamically linked libraries.
Reference: [CHRG95] <author> John Chapin, Stephen A. Harrod, Mendel Rosenblum, and Anoop Gupta. </author> <title> Memory System Performance of UNIX on CC-NUMA Multiprocessors. </title> <booktitle> In Proceedings of the Joint International Conference on Measurement & Modeling of Computer Systems (Sigmet-rics'95/Performance'95), </booktitle> <pages> pages 1-13, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: The particular problem addressed by this project is to include the operating system's activity in the trace. Operating system traces can be obtained in several ways. Past efforts have utilized hardware monitors <ref> [CHRG95] </ref>, complete simulation (SimOS [WR96]), and binary instrumentation [BKLW90, CB93]. Binary instrumentation is a low-cost, medium-effort approach, which has the advantage of not requiring particular monitoring hardware.
Reference: [LS95] <author> James R. Larus and Eric Schnarr. EEL: </author> <title> Machine-Independent Executable Editing. </title> <booktitle> In Proceedings of the 1995 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 291-300, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: To this end, we are putting an instrumentation framework into place that allows tracing of applications running on the Solaris 2.4 operating system. Our methodology for collecting the traces is to extend EEL (Executable Editing Library) <ref> [LS95] </ref>, a library for building tools that analyze and modify executable programs and object files. EEL allows code to be inserted at arbitrary points in a program, enabling other tools that insert code to gather instruction and data address traces for on-the-fly simulations or buffering for later analysis. <p> For our purposes, EEL seemed to be the ideal match. It handles executables (statically and dynamically linked), as well as object files. EEL runs on SPARC under Solaris, and the source code is freely available. 2.2 The Tool Builder: EEL EEL is a C++ library for editing executables <ref> [LS95] </ref>. EEL encapsulates the analysis and regeneration phases of binary instrumentation, allowing the tool programmer to focus on the instrumentation phase. EEL presents the executable (or object file) to the programmer as a set of routines, each consisting of a collection of basic-blocks.
Reference: [SP95] <author> Richard Sites and Sharon Perl. PatchWrx: </author> <title> A Dynamic Execution Tracing Tool. </title> <note> Submitted for Publication, 1995. 10 </note>
Reference-contexts: Unfortunately, traces often do not include kernel code. Furthermore, traces of small programs, including many applications found in the SPEC benchmark suite, do not show system behavior under real workloads. Orienting designs on such traces may be harmful <ref> [SP95] </ref>. In the context of the IRAM project at Berkeley, we decided to overcome the SPEC trace dilemma and obtain meaningful traces of "real world" applications, such as web browsers and personal productivity tools.
Reference: [SW94] <author> Amitabh Srivastava and David W. Wall. </author> <title> Link-Time Optimization of Address Calculation on a 64-bit Architecture. </title> <booktitle> In Proceedings of the SIGPLAN'94 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 49-60, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Many tools have been written in the past that use this technique for various purposes (Pixie, Mahler [WP87], Nixie and Epoxy [Wal92], QPT [BL94], ATOM <ref> [SW94] </ref>). All these tools work essentially in the same way, performing a sequence of 3 phases: 1. Analysis * Break code into functions and basic-blocks * Analyze control transfers (jumps, branches, calls) * Produce control flow graph 2. Instrumentation * insert, change, remove code 3.
Reference: [Wal92] <author> David W. Wall. </author> <title> Systems for Late Code Modification. </title> <type> Technical report, </type> <institution> Digital Western Research Laboratory, </institution> <month> May </month> <year> 1992. </year> <note> WRL Research Report 92/3. </note>
Reference-contexts: Many tools have been written in the past that use this technique for various purposes (Pixie, Mahler [WP87], Nixie and Epoxy <ref> [Wal92] </ref>, QPT [BL94], ATOM [SW94]). All these tools work essentially in the same way, performing a sequence of 3 phases: 1. Analysis * Break code into functions and basic-blocks * Analyze control transfers (jumps, branches, calls) * Produce control flow graph 2. Instrumentation * insert, change, remove code 3.
Reference: [Wei84] <author> Mark Weiser. </author> <title> Program Slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: EEL contains a set of cooked analyses, such as loop detection, dominator trees, and live variable analysis. Furthermore, a framework for building new analyses is provided in the form of general forward and backward program slicing <ref> [Wei84] </ref>.
Reference: [WP87] <author> David W. Wall and Michael L. Powell. </author> <title> The Mahler experience: Using an intermediate language as the machine description. </title> <booktitle> In Second International Symposium on Architectural Support for Programming Languages and Operating Systems (ASPLOS), volume 22 of SIGPLAN Notices, </booktitle> <pages> pages 100-104, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: Many tools have been written in the past that use this technique for various purposes (Pixie, Mahler <ref> [WP87] </ref>, Nixie and Epoxy [Wal92], QPT [BL94], ATOM [SW94]). All these tools work essentially in the same way, performing a sequence of 3 phases: 1. Analysis * Break code into functions and basic-blocks * Analyze control transfers (jumps, branches, calls) * Produce control flow graph 2.
Reference: [WR96] <author> Emmett Witchel and Mendel Rosenblum. Embra: </author> <title> Fast and Flexible Machine Simulation. </title> <note> In To appear in SIGMETRICS '96, </note> <month> May </month> <year> 1996. </year> <month> 11 </month>
Reference-contexts: The particular problem addressed by this project is to include the operating system's activity in the trace. Operating system traces can be obtained in several ways. Past efforts have utilized hardware monitors [CHRG95], complete simulation (SimOS <ref> [WR96] </ref>), and binary instrumentation [BKLW90, CB93]. Binary instrumentation is a low-cost, medium-effort approach, which has the advantage of not requiring particular monitoring hardware. Furthermore, we can build on top of existing binary instrumentation tools, leading to a lower development effort than writing a complete operating system simulator.
References-found: 11

