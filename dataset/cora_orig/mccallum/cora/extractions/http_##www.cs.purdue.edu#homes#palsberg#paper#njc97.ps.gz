URL: http://www.cs.purdue.edu/homes/palsberg/paper/njc97.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Title: Type Inference with Simple Selftypes is NP-complete  
Author: Jens Palsberg Trevor Jim 
Keyword: CR Classification: Categories and Subject Descriptors: D.3.2 [Programming Languages]: Language Classifications|object-oriented languages; F.3.3 [Logics and Meanings of Programs]: Studies of Program Constructs|type structure. General Terms: Languages, Theory. Key words: Type inference, constraints.  
Address: West Lafayette, IN 47907  200 South 33rd Street Philadelphia, PA 19104-6389  
Affiliation: Purdue University Department of Computer Science  Department of Computer and Information Science University of Pennsylvania  
Note: Nordic Journal of Computing  
Email: palsberg@cs.purdue.edu  tjim@saul.cis.upenn.edu  
Date: 4(3):259-286, Fall 1997  
Abstract: The metavariable self is fundamental in object-oriented languages. Typing self in the presence of inheritance has been studied by Abadi and Cardelli, Bruce, and others. A key concept in these developments is the notion of selftype, which enables flexible type annotations that are impossible with recursive types and subtyping. Bruce et al. demonstrated that, for the language TOOPLE, type checking is decidable. Open until now is the problem of type inference with selftype. In this paper we present a simple type system with selftype, recursive types, and subtyping, and we prove that type inference is NP-complete. With recursive types and subtyping alone, type inference is known to be P-complete. Our example language is the object calculus of Abadi and Cardelli. Both our type inference algorithm and our lower bound are the first such results for a type system with selftype. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Luca Cardelli. </author> <title> A semantics of object types. </title> <booktitle> In Proc. LICS'94, Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 332-341, </pages> <year> 1994. </year>
Reference-contexts: This phenomenon is a key reason why static typing for object-oriented lan guages is a challenging problem. For a denotational semantics of inheritance and self, see for example [8]. Typing self in the presence of inheritance has been studied by Abadi and Cardelli <ref> [3, 2, 1, 4] </ref>, Bruce [6, 7], Mitchell, Honsell, and Fisher [12, 13], Received January 10, 1998. 2 J. PALSBERG, T. JIM Palsberg and Schwartzbach [15, 16], and others.
Reference: [2] <author> Martn Abadi and Luca Cardelli. </author> <title> A theory of primitive objects: Second-order systems. </title> <booktitle> In Proc. ESOP'94, European Symposium on Programming, </booktitle> <pages> pages 1-25. </pages> <publisher> Springer-Verlag (LNCS 788), </publisher> <year> 1994. </year> <note> 28 J. </note> <author> PALSBERG, T. </author> <title> JIM </title>
Reference-contexts: This phenomenon is a key reason why static typing for object-oriented lan guages is a challenging problem. For a denotational semantics of inheritance and self, see for example [8]. Typing self in the presence of inheritance has been studied by Abadi and Cardelli <ref> [3, 2, 1, 4] </ref>, Bruce [6, 7], Mitchell, Honsell, and Fisher [12, 13], Received January 10, 1998. 2 J. PALSBERG, T. JIM Palsberg and Schwartzbach [15, 16], and others.
Reference: [3] <author> Martn Abadi and Luca Cardelli. </author> <title> A theory of primitive objects: Untyped and first-order systems. </title> <booktitle> In Proc. TACS'94, Theoretical Aspects of Computing Software, </booktitle> <pages> pages 296-320. </pages> <publisher> Springer-Verlag (LNCS 789), </publisher> <year> 1994. </year>
Reference-contexts: This phenomenon is a key reason why static typing for object-oriented lan guages is a challenging problem. For a denotational semantics of inheritance and self, see for example [8]. Typing self in the presence of inheritance has been studied by Abadi and Cardelli <ref> [3, 2, 1, 4] </ref>, Bruce [6, 7], Mitchell, Honsell, and Fisher [12, 13], Received January 10, 1998. 2 J. PALSBERG, T. JIM Palsberg and Schwartzbach [15, 16], and others. <p> B i fAg 8i 2 1::n i ] : A (where A = [` i : B i21::n i ]) (3) E ` a:` ( &(x)b : A (where A [` : B]) (4) E ` a : A (where A B) (5) Table I: Typing rules and Cardelli in <ref> [3] </ref> and studied further by Palsberg in [14]. Specifically, if selftype is never used, then BfAg = B and the rules take the form used in [14]. Thus, the type rules above type more terms than the rules in [14].
Reference: [4] <author> Martn Abadi and Luca Cardelli. </author> <title> An imperative object calculus. </title> <booktitle> In Proc. TAP-SOFT'95, Theory and Practice of Software Development, </booktitle> <pages> pages 471-485. </pages> <publisher> Springer-Verlag (LNCS 915), </publisher> <address> Aarhus, Denmark, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: This phenomenon is a key reason why static typing for object-oriented lan guages is a challenging problem. For a denotational semantics of inheritance and self, see for example [8]. Typing self in the presence of inheritance has been studied by Abadi and Cardelli <ref> [3, 2, 1, 4] </ref>, Bruce [6, 7], Mitchell, Honsell, and Fisher [12, 13], Received January 10, 1998. 2 J. PALSBERG, T. JIM Palsberg and Schwartzbach [15, 16], and others. <p> Type systems with selftype have been presented by Abadi and Cardelli <ref> [4] </ref>, Bruce et al. [6, 7], Mitchell, Honsell, and Fisher [12, 13], and others. A type system with selftype is used in the language Eiffel [11]. In this paper, we address the following fundamental question: Fundamental question. <p> Both Mytype and like Current refer to the selftype of the innermost enclosing object; in these systems there is no way of referring to the selftype of other enclosing objects. The systems of Abadi and Cardelli <ref> [4] </ref>, and Mitchell, Honsell, and Fisher [12, 13], are more expressive, binding a name for selftype in each object type. Another design issue is the choice of type rules. For example, when comparing the type rules of Abadi and Cardelli [4] with those of Bruce et al. [6, 7], we find <p> The systems of Abadi and Cardelli <ref> [4] </ref>, and Mitchell, Honsell, and Fisher [12, 13], are more expressive, binding a name for selftype in each object type. Another design issue is the choice of type rules. For example, when comparing the type rules of Abadi and Cardelli [4] with those of Bruce et al. [6, 7], we find both striking similarities, such as the rules for message send, and significant differences. Both of these type systems have been proved sound, and Bruce et al. have shown that type checking is decidable in their language, TOOPLE [7]. <p> Thus, self-type seems to be a construct which in practice should be used in languages with explicit typing. TYPE INFERENCE WITH SELFTYPE 5 Future Work. We have been unable to establish a connection between our type system and the seemingly more expressive type systems of Abadi and Cardelli <ref> [4] </ref>, and Bruce et al. [6, 7]. This means that although a "tiny drop of selftype" gives NP-hardness, one can imagine that "a bigger drop of selftype" may or may not give NP-hardness.
Reference: [5] <author> Martn Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: As an aside, one might wonder why we do not relax the definition of A B to allow A # ` B # `, instead of A # ` = B # `. Intuitively, this relaxation would allow "depth" subtyping. Unfortunately, this would make the type rules below unsound <ref> [5] </ref>. If A and B are object types, then BfAg is defined BfAg = A if B = selftype; B otherwise: The typing rules are given in Table I.
Reference: [6] <author> Kim B. Bruce. </author> <title> Safe type checking in a statically typed object-oriented programming language. </title> <booktitle> In Proc. POPL'93, Twentieth Annual SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-298, </pages> <year> 1993. </year>
Reference-contexts: This phenomenon is a key reason why static typing for object-oriented lan guages is a challenging problem. For a denotational semantics of inheritance and self, see for example [8]. Typing self in the presence of inheritance has been studied by Abadi and Cardelli [3, 2, 1, 4], Bruce <ref> [6, 7] </ref>, Mitchell, Honsell, and Fisher [12, 13], Received January 10, 1998. 2 J. PALSBERG, T. JIM Palsberg and Schwartzbach [15, 16], and others. <p> Type systems with selftype have been presented by Abadi and Cardelli [4], Bruce et al. <ref> [6, 7] </ref>, Mitchell, Honsell, and Fisher [12, 13], and others. A type system with selftype is used in the language Eiffel [11]. In this paper, we address the following fundamental question: Fundamental question. <p> Another design issue is the choice of type rules. For example, when comparing the type rules of Abadi and Cardelli [4] with those of Bruce et al. <ref> [6, 7] </ref>, we find both striking similarities, such as the rules for message send, and significant differences. Both of these type systems have been proved sound, and Bruce et al. have shown that type checking is decidable in their language, TOOPLE [7]. <p> TYPE INFERENCE WITH SELFTYPE 5 Future Work. We have been unable to establish a connection between our type system and the seemingly more expressive type systems of Abadi and Cardelli [4], and Bruce et al. <ref> [6, 7] </ref>. This means that although a "tiny drop of selftype" gives NP-hardness, one can imagine that "a bigger drop of selftype" may or may not give NP-hardness.
Reference: [7] <author> Kim B. Bruce, Jon Crabtree, Thomas P. Murtagh, Robert van Gent, Allyn Dimock, and Robert Muller. </author> <title> Safe and decidable type checking in an object-oriented language. </title> <booktitle> In Proc. OOPSLA'93, ACM SIGPLAN Eighth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 29-46, </pages> <year> 1993. </year>
Reference-contexts: This phenomenon is a key reason why static typing for object-oriented lan guages is a challenging problem. For a denotational semantics of inheritance and self, see for example [8]. Typing self in the presence of inheritance has been studied by Abadi and Cardelli [3, 2, 1, 4], Bruce <ref> [6, 7] </ref>, Mitchell, Honsell, and Fisher [12, 13], Received January 10, 1998. 2 J. PALSBERG, T. JIM Palsberg and Schwartzbach [15, 16], and others. <p> Type systems with selftype have been presented by Abadi and Cardelli [4], Bruce et al. <ref> [6, 7] </ref>, Mitchell, Honsell, and Fisher [12, 13], and others. A type system with selftype is used in the language Eiffel [11]. In this paper, we address the following fundamental question: Fundamental question. <p> Another design issue is the choice of type rules. For example, when comparing the type rules of Abadi and Cardelli [4] with those of Bruce et al. <ref> [6, 7] </ref>, we find both striking similarities, such as the rules for message send, and significant differences. Both of these type systems have been proved sound, and Bruce et al. have shown that type checking is decidable in their language, TOOPLE [7]. <p> Both of these type systems have been proved sound, and Bruce et al. have shown that type checking is decidable in their language, TOOPLE <ref> [7] </ref>. However, we know of no type inference algorithm for any system with selftype. Our approach to type inference with selftype is to begin with a system of object types where type inference is well understood, and then consider the simplest possible extension with selftype. <p> TYPE INFERENCE WITH SELFTYPE 5 Future Work. We have been unable to establish a connection between our type system and the seemingly more expressive type systems of Abadi and Cardelli [4], and Bruce et al. <ref> [6, 7] </ref>. This means that although a "tiny drop of selftype" gives NP-hardness, one can imagine that "a bigger drop of selftype" may or may not give NP-hardness.
Reference: [8] <author> William Cook and Jens Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <journal> Information and Computation, </journal> <volume> 114(2) </volume> <pages> 329-350, </pages> <year> 1994. </year> <note> Preliminary version in Proc. </note> <editor> OOPSLA'89, </editor> <booktitle> ACM SIGPLAN Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 433-443, </pages> <address> New Orleans, Louisiana, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Since meth ods can be inherited, the meaning of self cannot be determined statically. This phenomenon is a key reason why static typing for object-oriented lan guages is a challenging problem. For a denotational semantics of inheritance and self, see for example <ref> [8] </ref>. Typing self in the presence of inheritance has been studied by Abadi and Cardelli [3, 2, 1, 4], Bruce [6, 7], Mitchell, Honsell, and Fisher [12, 13], Received January 10, 1998. 2 J. PALSBERG, T. JIM Palsberg and Schwartzbach [15, 16], and others.
Reference: [9] <author> My Hoang and John C. Mitchell. </author> <title> Lower bounds on type inference with subtypes. </title> <booktitle> In Proc. POPL'95, 22nd Annual SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 176-185, </pages> <year> 1995. </year>
Reference-contexts: The type system does not contain function types, base types, etc. Moreover, there is no contravariance or atomic subtyping in the type system, so the complexity results on type inference of Tiuryn [17] and Hoang and Mitchell <ref> [9] </ref> do not apply. Of course, if we introduce more constructs, then the upper and lower complexity bounds for type inference may change. Our extension of the Abadi/Cardelli type system is based on two design decisions, both aiming for the simplest possible extension.
Reference: [10] <author> Bent B. Kristensen, Ole Lehrmann Madsen, Birger Mtller-Pedersen, and Kristen Nygaard. </author> <title> The BETA programming language. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 7-48. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Thus, in a method &(x)b, x is self and b is the body. Since the names for self can be chosen to be different and since objects can be nested, one can refer to any enclosing object, as in the Beta language <ref> [10] </ref>. We consider &-terms to be syntactically identical modulo renaming of bound variables (ff-conversion), and we use to denote syntactic identity. Abadi and Cardelli define a term rewriting operational semantics by the following rules. 6 J. PALSBERG, T.
Reference: [11] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: Type systems with selftype have been presented by Abadi and Cardelli [4], Bruce et al. [6, 7], Mitchell, Honsell, and Fisher [12, 13], and others. A type system with selftype is used in the language Eiffel <ref> [11] </ref>. In this paper, we address the following fundamental question: Fundamental question. Is type inference with selftype feasible? Of course, the answer will depend on the exact details of the type system. And there is no common agreement on the "right" type system with self-type.
Reference: [12] <author> John C. Mitchell. </author> <title> Toward a typed foundation for method specialization and inheritance. </title> <booktitle> In Seventeenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-124, </pages> <year> 1990. </year>
Reference-contexts: For a denotational semantics of inheritance and self, see for example [8]. Typing self in the presence of inheritance has been studied by Abadi and Cardelli [3, 2, 1, 4], Bruce [6, 7], Mitchell, Honsell, and Fisher <ref> [12, 13] </ref>, Received January 10, 1998. 2 J. PALSBERG, T. JIM Palsberg and Schwartzbach [15, 16], and others. <p> Type systems with selftype have been presented by Abadi and Cardelli [4], Bruce et al. [6, 7], Mitchell, Honsell, and Fisher <ref> [12, 13] </ref>, and others. A type system with selftype is used in the language Eiffel [11]. In this paper, we address the following fundamental question: Fundamental question. Is type inference with selftype feasible? Of course, the answer will depend on the exact details of the type system. <p> Both Mytype and like Current refer to the selftype of the innermost enclosing object; in these systems there is no way of referring to the selftype of other enclosing objects. The systems of Abadi and Cardelli [4], and Mitchell, Honsell, and Fisher <ref> [12, 13] </ref>, are more expressive, binding a name for selftype in each object type. Another design issue is the choice of type rules.
Reference: [13] <author> John C. Mitchell, Furio Honsell, and Kathleen Fisher. </author> <title> A lambda calculus of objects and method specialization. </title> <journal> Nordic Journal of Computing, </journal> <volume> 1(1) </volume> <pages> 3-37, </pages> <year> 1994. </year> <note> Also in Proc. LICS'93, pp.26-38. </note>
Reference-contexts: For a denotational semantics of inheritance and self, see for example [8]. Typing self in the presence of inheritance has been studied by Abadi and Cardelli [3, 2, 1, 4], Bruce [6, 7], Mitchell, Honsell, and Fisher <ref> [12, 13] </ref>, Received January 10, 1998. 2 J. PALSBERG, T. JIM Palsberg and Schwartzbach [15, 16], and others. <p> Type systems with selftype have been presented by Abadi and Cardelli [4], Bruce et al. [6, 7], Mitchell, Honsell, and Fisher <ref> [12, 13] </ref>, and others. A type system with selftype is used in the language Eiffel [11]. In this paper, we address the following fundamental question: Fundamental question. Is type inference with selftype feasible? Of course, the answer will depend on the exact details of the type system. <p> Both Mytype and like Current refer to the selftype of the innermost enclosing object; in these systems there is no way of referring to the selftype of other enclosing objects. The systems of Abadi and Cardelli [4], and Mitchell, Honsell, and Fisher <ref> [12, 13] </ref>, are more expressive, binding a name for selftype in each object type. Another design issue is the choice of type rules.
Reference: [14] <author> Jens Palsberg. </author> <title> Efficient inference of object types. </title> <journal> Information and Computation, </journal> <volume> 123(2) </volume> <pages> 198-209, </pages> <year> 1995. </year> <note> Preliminary version in Proc. </note> <editor> LICS'94, </editor> <booktitle> Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 186-195, </pages> <address> Paris, France, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: We use Abadi and Cardelli's system of recursive object types and subtyping as our starting point; type inference in this system is P-complete <ref> [14] </ref>. The only type constructor in this type system is the one for object types. The type of an object is of the form [` i : B i21::n i ], where each ` i is a method name and each B i is a type. <p> We prove that type inference for our type system with selftype, recursive types, and subtyping is NP-complete. With recursive types and subtyping alone, type inference is known to be P-complete <ref> [14] </ref>. Intuitively, the type inference problem is in NP because we can first guess which methods should be annotated with selftype as the return type, and then solve the remaining type inference problem in polynomial time. <p> ] : A (where A = [` i : B i21::n i ]) (3) E ` a:` ( &(x)b : A (where A [` : B]) (4) E ` a : A (where A B) (5) Table I: Typing rules and Cardelli in [3] and studied further by Palsberg in <ref> [14] </ref>. Specifically, if selftype is never used, then BfAg = B and the rules take the form used in [14]. Thus, the type rules above type more terms than the rules in [14]. <p> : A (where A [` : B]) (4) E ` a : A (where A B) (5) Table I: Typing rules and Cardelli in [3] and studied further by Palsberg in <ref> [14] </ref>. Specifically, if selftype is never used, then BfAg = B and the rules take the form used in [14]. Thus, the type rules above type more terms than the rules in [14]. Theorem 1. (Subject Reduction) If E ` a : A and a ! a 0 , then E ` a 0 : A. Proof. <p> (where A B) (5) Table I: Typing rules and Cardelli in [3] and studied further by Palsberg in <ref> [14] </ref>. Specifically, if selftype is never used, then BfAg = B and the rules take the form used in [14]. Thus, the type rules above type more terms than the rules in [14]. Theorem 1. (Subject Reduction) If E ` a : A and a ! a 0 , then E ` a 0 : A. Proof. <p> For an example of an S-system, see Section 6. In comparison with the AC-systems of <ref> [14] </ref>, the novel aspect of S-systems is the use of selftype and the notation U fU 0 g. 10 J. PALSBERG, T. JIM We now show how to reduce type inference for a term c to the solution of an S-system C (c). <p> This is in turn equivalent to deciding if F S (C) has a solution L where no L (U ) contains free variables. This can be done in O (n 3 ) time using a slightly modified version of the algorithm in <ref> [14] </ref>. (The algorithm in [14] handles so-called AC-systems, that is, S-systems without U fU 0 g and without selftype. In the journal version of [14], it is indicated how to extend the constraint solving algorithm for AC-systems to handle functions and records. It is equally easy to extend 14 J. <p> This is in turn equivalent to deciding if F S (C) has a solution L where no L (U ) contains free variables. This can be done in O (n 3 ) time using a slightly modified version of the algorithm in <ref> [14] </ref>. (The algorithm in [14] handles so-called AC-systems, that is, S-systems without U fU 0 g and without selftype. In the journal version of [14], it is indicated how to extend the constraint solving algorithm for AC-systems to handle functions and records. It is equally easy to extend 14 J. PALSBERG, T. <p> This can be done in O (n 3 ) time using a slightly modified version of the algorithm in <ref> [14] </ref>. (The algorithm in [14] handles so-called AC-systems, that is, S-systems without U fU 0 g and without selftype. In the journal version of [14], it is indicated how to extend the constraint solving algorithm for AC-systems to handle functions and records. It is equally easy to extend 14 J. PALSBERG, T. <p> [center = &(d)Point] ColorCircle Circle:center ( &(e)(ColorPoint:move:setcolor) Main ColorCircle:center:move : We may then ask: can the program be typed in Abadi and Cardelli's first-order type system with recursive types and subtyping? The answer is, perhaps surprisingly: no! This answer can be obtained by running the type inference algorithm of Palsberg <ref> [14] </ref>. The key reason for the untypability is 24 J. PALSBERG, T. JIM that the body of the ColorCircle's center method forces ColorPoint to have a type which is not a subtype of the type of Point, intuitively as follows. <p> Conclusion Throughout, we have considered a type system with recursive types. Our constructions also work without recursive types (the details of checking this are left to the reader). We have thus completed the following table. Selftype Recursive types Subtyping Type inference p O (n 3 ) time, P-complete <ref> [14] </ref> p p O (n 3 ) time, P-complete [14] p p NP-complete [this paper] p p p NP-complete [this paper] Acknowledgements We thank Martn Abadi, Kim Bruce, and Luca Cardelli for helpful discussions. We also thank the anonymous referees for many insightful suggestions and comments. <p> Our constructions also work without recursive types (the details of checking this are left to the reader). We have thus completed the following table. Selftype Recursive types Subtyping Type inference p O (n 3 ) time, P-complete <ref> [14] </ref> p p O (n 3 ) time, P-complete [14] p p NP-complete [this paper] p p p NP-complete [this paper] Acknowledgements We thank Martn Abadi, Kim Bruce, and Luca Cardelli for helpful discussions. We also thank the anonymous referees for many insightful suggestions and comments.
Reference: [15] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference-contexts: Typing self in the presence of inheritance has been studied by Abadi and Cardelli [3, 2, 1, 4], Bruce [6, 7], Mitchell, Honsell, and Fisher [12, 13], Received January 10, 1998. 2 J. PALSBERG, T. JIM Palsberg and Schwartzbach <ref> [15, 16] </ref>, and others.
Reference: [16] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Static typing for object-oriented programming. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 23(1) </volume> <pages> 19-53, </pages> <year> 1994. </year>
Reference-contexts: Typing self in the presence of inheritance has been studied by Abadi and Cardelli [3, 2, 1, 4], Bruce [6, 7], Mitchell, Honsell, and Fisher [12, 13], Received January 10, 1998. 2 J. PALSBERG, T. JIM Palsberg and Schwartzbach <ref> [15, 16] </ref>, and others.
Reference: [17] <author> Jerzy Tiuryn. </author> <title> Subtype inequalities. </title> <booktitle> In LICS'92, Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 308-315, </pages> <year> 1992. </year>
Reference-contexts: The type system does not contain function types, base types, etc. Moreover, there is no contravariance or atomic subtyping in the type system, so the complexity results on type inference of Tiuryn <ref> [17] </ref> and Hoang and Mitchell [9] do not apply. Of course, if we introduce more constructs, then the upper and lower complexity bounds for type inference may change. Our extension of the Abadi/Cardelli type system is based on two design decisions, both aiming for the simplest possible extension.
Reference: [18] <author> Sergei Vorobyov. </author> <title> Structural decidable extensions of bounded quantification. </title> <booktitle> In Proc. POPL'95, 22nd Annual SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <year> 1995. </year>
Reference-contexts: In general, one may ask if there is any sound type system at all which types at least what can be typed by the type system in this paper, and which has type inference in polynomial time. (For an investigation of tractable extensions of F , see <ref> [18] </ref>.) Moreover, one may test the robustness of the NP-completeness result and the proof technique by extending the calculus with, say, object extension.
References-found: 18

