URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1049/CS-TR-91-1049.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1049/
Root-URL: http://www.cs.wisc.edu
Title: Cache Performance of the SPEC Benchmark Suite  
Author: Jeffrey D. Gee Mark D. Hill Dionisios N. Pnevmatikatos Alan Jay Smith 
Address: Berkeley, CA 94720  Madison, WI 53706  
Affiliation: Computer Science Division Dept. of Electrical Engineering and Computer Science University of California Berkeley  Computer Sciences Department University of Wisconsin-Madison  
Abstract: The SPEC benchmark suite consists of ten public-domain, non-trivial programs that are widely used to measure the performance of computer systems, particularly those in the Unix workstation market. These benchmarks were expressly chosen to represent real-world applications and were intended to be large enough to stress the computational and memory system resources of current-generation machines. The extent to which the SPECmark (the figure of merit obtained from running the SPEC benchmarks under certain specified conditions) accurately represents performance with live real workloads is not well established; in particular, there is some question whether the memory referencing behavior (cache performance) is appropriate. In this paper, we present measurements of miss ratios for the entire set of SPEC benchmarks for a variety of CPU cache configurations; this study extends earlier work that measured only the performance of the integer (C) SPEC benchmarks. We find that instruction cache miss ratios are generally very low, and that data cache miss ratios for the integer benchmarks are also quite low. Data cache miss ratios for the floating point benchmarks are more in line with published measurements for real workloads. We believe that the discrepancy between the SPEC benchmark miss ratios and those observed elsewhere is partially due to the fact that the SPEC benchmarks are all almost exclusively user state CPU benchmarks run until completion as the single active user process. We therefore believe that SPECmark performance levels may not reflect system performance when there is multiprogramming, *The material presented here is based on research supported in part by the National Science Foundation under grants MIP-8713274 and MIPS-8957278, by NASA under grant NCC2-550, by the State of California under the MICRO program, and by A.T.& T. Bell Laboratories, Apple Computer Corporation, Cray Research Foundation, Digital Equipment Corporation, Intel Corporation, International Business Machines Corporation, Mitsubishi Corporation, and Philips Laboratories/Signetics. **This paper has been submitted for publication and released as University of California at Berkeley Computer Science Division Technical Report UCB/CSD 91/648 and University of Wisconsin at Madison Computer Sciences Department Technical Report #1049. time sharing and/or significant operating systems activity.
Abstract-found: 1
Intro-found: 1
Reference: [Agar88] <author> A. Agarwal, J. Hennessy, and M. Horowitz, </author> <title> ``Cache Performance of Operating System and Multiprogramming Workloads,'' </title> <journal> ACM Trans. Comp. Sys., </journal> <volume> vol. 6, 4, </volume> <month> November </month> <year> 1988, </year> <pages> pp. 393-433. </pages>
Reference-contexts: He synthesized them from real (hardware monitor) measurements that existed in the literature and a large number of trace-driven simulation results. The initial DTMRs for 16-byte line size, fully-associative caches [Smit85] were later extended to other line sizes [Smit87] and to set associative caches [Hill87,89]. (d) Agarwal, et al. <ref> [Agar88] </ref> presented miss ratios that include the effects of operating system references and multiprogramming by using microcode to capture address traces from multi-tasked machines. <p> These include: Amdahl 470 supervisor and user state miss ratios (plots labeled 470.sup and 470.user), VAX 11/780 and VAX 8800 miss ratios (plots labeled VAX.780 and VAX.8800), and miss ratios from <ref> [Agar88] </ref> for a multiprogramming level of 3 (plots labeled agarwal.mul3). (We plot the Amdahl data from the fitted curve in [Smit82]; the original data points are not available.) We note that the VAX8800 data was collected from a very heavily used timeshared system. <p> 256 i iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii 8K 0.0417 0.0260 16K 0.0258 0.0195 32K 0.0146 0.0131 64K 0.0095 0.0076 128K 0.0066 0.0030 256K 0.0058 0.0025 512K 0.0043 0.0017 1M 0.0020 0.0008 i iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc cccccccccccccccccc cccccccccccccccc cccccccccccccccc cccccccccccccccc cccccccccccccccc ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc - 13 - All of the data in the literature (see e.g. [Smit82], [Ande91], <ref> [Agar88] </ref>) suggests that operating systems activity significantly increases miss ratios. First, operating systems code tends to loop less than user code, and so instruction miss ratios are high. <p> Similar differences in cache performance between compute bound and multiprogrammed environments are reported in [Mogu91]. The SPEC floating-point benchmark miss ratios are quite close to the DTMRs, the data from <ref> [Agar88] </ref>, and the VAX 11/780 measurements, and for large cache sizes are also very close to the Amdahl 470 user program miss ratios. The SPEC integer benchmark miss ratios are lowest. 4.
Reference: [Ande91] <author> T.E. Anderson, H.M. Levy, B.N. Bershad, and E.D. Lazowska, </author> <title> ``The Interaction of Architecture and Operating System Design,'' </title> <booktitle> Proc. </booktitle> <address> ASPLOS-IV, April, 1991, Santa Clara, CA, </address> <pages> pp. 108-120. </pages>
Reference-contexts: 64 256 i iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii 8K 0.0417 0.0260 16K 0.0258 0.0195 32K 0.0146 0.0131 64K 0.0095 0.0076 128K 0.0066 0.0030 256K 0.0058 0.0025 512K 0.0043 0.0017 1M 0.0020 0.0008 i iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc cccccccccccccccccc cccccccccccccccc cccccccccccccccc cccccccccccccccc cccccccccccccccc ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc - 13 - All of the data in the literature (see e.g. [Smit82], <ref> [Ande91] </ref>, [Agar88]) suggests that operating systems activity significantly increases miss ratios. First, operating systems code tends to loop less than user code, and so instruction miss ratios are high.
Reference: [Borg90] <author> A. Borg, R.E. Kessler, and D.W. Wall, </author> <title> ``Generation and Analysis of Very Long Address Traces,'' </title> <booktitle> Proc. 17th Int'l Symp. Comp. Arch., </booktitle> <address> May, 1990, Seattle, WA, </address> <pages> pp. 270-279. </pages>
Reference-contexts: We compare the SPEC cache miss ratios to design target miss ratios [Smit87], miss ratios measured using hardware monitors at Amdahl [Smit82] and on DEC VAX-series machines [Clar83,88], miss ratios observed from very long address traces <ref> [Borg90] </ref>, and other miss ratios that include operating system and multiprogramming behavior. We also note that miss ratios for multiprogrammed workloads with significant operating system activity are known to be high [Agar88,Ande91]. 2. SPEC Cache Performance 2.1. <p> These effects can more than double miss rates from those measured in a uniprogrammed, user-only environment. - 7 - (e) Borg, et al. <ref> [Borg90] </ref> generated miss ratios for very long address traces using tools similar to our own; those traces were over twelve billion memory references long. The traces were used to evaluate the performance of a variety of caches. <p> These averages represent the unweighted arithmetic mean of individual program miss ratios, similar to how the SPECmark represents the geometric mean of individual program SPECratios. In Figures 1 and 2, averages miss rates are plotted against the design target miss ratios (labeled dtmr) and primary cache miss ratios from <ref> [Borg90] </ref> for a multiprogrammed workload (labeled borg). Unfortunately, miss ratios from the other studies are not available for separate instruction and data caches, but are plotted against SPEC unified cache results in Figure 3. <p> SPEC.int SPEC.fp 1 10 100 1000 0.05 0.15 0.25 Cache Size (kbytes) M s R t o Data Caches Associativity: 2-way Block Size: 32 bytes In Figure 2, we see that data cache miss ratios for the SPEC integer and floating point benchmarks bracket the DTMRs; both are above the <ref> [Borg90] </ref> measurements. Both sets of SPEC benchmarks approach zero miss ratio for large caches, a phenomenon that might not occur for a time sharing workload where programs task switch many times before completing. - 9 - addition to SPEC and design target miss ratios.
Reference: [Cmel91] <author> R. M. Cmelik, S. I. Kong, D. R. Ditzel, and E. J. Kelly, </author> <title> ``An Analysis of SPARC and MIPS Instruction Set Utilization on the SPEC benchmarks,'' </title> <booktitle> Proc. </booktitle> <address> ASPLOS-IV, April, 1991, Santa Clara, CA, </address> <pages> pp. 290-302. </pages> <note> [DEC91] ``Pixie,'' DEC Ultrix manual page. </note>
Reference-contexts: We must thus caution readers that your actual mileage may vary. Cmelik et al. <ref> [Cmel91] </ref> give instruction counts for SPEC benchmarks. With two exceptions, Xlisp and Spice, their counts are close to ours. For Xlisp, the instruction count difference is due to different input files; we solved the eight queens problem, while they solved the nine queens problem.
Reference: [Clar83] <author> D.W. Clark, </author> <title> ``Cache Performance in the VAX-11/780,'' </title> <journal> ACM Trans. Comp. Sys., </journal> <volume> vol. 1, 1, </volume> <month> February </month> <year> 1983, </year> <pages> pp. 24-37. </pages>
Reference-contexts: Note also that the trace includes only actual program loads, stores and instruction fetches; it does not include the extra memory activity such as instruction pre-fetch that would occur on most machines <ref> [Clar83] </ref>. iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Program Instruction Data Total iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii eqntott 1,241,913,236 215,772,134 1,457,685,370 espresso 3,143,686,831 696,870,530 3,840,557,361 gcc 1,262,492,069 398,952,157 1,661,444,226 xlisp 1,234,252,567 457,209,682 1,691,462,249 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii doduc 1,619,374,300 583,667,566 2,203,041,866 fpppp 2,396,679,406 1,514,694,293 3,911,373,699 matrix300 2,766,534,109 1,311,922,365 4,078,456,474 nasa7 9,195,719,149 4,720,515,938 13,916,235,087 spice 28,696,843,509 8,288,246,353 36,985,089,862 tomcatv 1,872,460,468 913,221,318 2,785,681,786 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c
Reference: [Clar88] <author> D.W. Clark, P.J. Bannon, J.B. Keller, </author> <title> ``Measuring VAX 8800 Performance with a Histogram Hardware Monitor,'' </title> <booktitle> Proc. 15th Int'l Symp. Comp. Arch., </booktitle> <month> May, </month> <year> 1988, </year> <title> Honolulu, </title> <booktitle> HI, </booktitle> <pages> pp. 176-185. </pages>
Reference: [Hill87] <author> M.D. Hill, </author> <title> ``Aspects of Cache Memory and Instruction Buffer Performance,'' </title> <type> Ph.D. Thesis, </type> <institution> Univ. of California at Berkeley, </institution> <type> Technical Report UCB/CSD 87/381, </type> <month> November </month> <year> 1987. </year>
Reference-contexts: Tycho uses algorithms that, for a given block size, simulate all cache sizes and associativities in a single pass through an address trace <ref> [Hill87] </ref>. We varied cache size from 1 Kbyte to 1 Mbyte, set size from one (direct-mapped) to eight, and block size from 16 to 256 bytes. All caches used the LRU replacement algorithm and the lowest order available address bits to select the set.
Reference: [Hill89] <author> Mark Hill and Alan Jay Smith, </author> <title> ``Evaluating Associativity in CPU Caches,'' </title> <journal> IEEETC, </journal> <volume> 38, 12, </volume> <month> December, </month> <year> 1989, </year> <pages> pp. 1612-1630. </pages>
Reference-contexts: It is worth noting that there are a few anomalies in the data with respect to the effect of associativity on miss ratio. Generally, miss ratios decrease with increased degrees of set associativity, since the probability of mapping conflicts decreases <ref> [Hill89] </ref>. It is possible, however, that miss ratios can increase with increasing associativity if certain reference patterns are present in the memory reference string; we note just that effect at one or more data points for the fpppp, matrix300, spice, tomcatv, and doduc miss ratios. <p> Previous results based on - 8 - different block sizes (VAX 11/780, VAX 8800, Agarwal, et al.) or different associativities (VAX 8800, Borg et al.) are adjusted for these parameters using ratios of miss ratios from prior studies <ref> [Hill89, Smit87] </ref>.
Reference: [Hill] <institution> M.D. Hill, </institution> <note> ``Tycho,'' Unpublished UNIX-style manual page. The Tycho simulator is available from Prof. </note> <institution> Mark Hill, Computer Sciences Dept., University of Wisconsin. </institution>
Reference-contexts: Note that we have not used any of the recently developed preprocessors which have been very successful in reorganizing the data references for Matrix300. We then used the MIPS pixie [DEC91] tool to generate address traces to feed directly to the tycho <ref> [Hill] </ref> cache simulator. Pixie modifies the compiled code to generate a trace record for each load, store and basic block entry; trace records for all instruction fetches are then constructed from the basic block records.
Reference: [Hinn88] <author> David Hinnant, </author> <title> ``Accurate Unix Benchmarking: Art, Science or Black Magic?,'' </title> <booktitle> IEEE MICRO, </booktitle> <month> October, </month> <year> 1988, </year> <pages> pp. 64-75. </pages>
Reference-contexts: 1. Introduction The SPEC benchmarks [SPEC89,90, Scot90] are a selection of non-trivial programs chosen to standardize benchmarking. SPEC (System Performance Evaluation Consortium) assembled this suite to provide a standard set of realistic benchmarks for inter-system comparisons; see <ref> [Pric89, Hinn88] </ref> for a discussion of the many problems with the benchmarking situation prior to SPEC. Several factors, including strong industrial support for SPEC, the realistic nature of the benchmarks, and acceptable code portability have led to the wide use of these programs for benchmarking purposes.
Reference: [Mogu91] <author> J. C. Mogul, and Anita Borg, </author> <title> ``The Effects of Context Switches on Cache Performance,'' </title> <booktitle> Proc. </booktitle> <address> ASPLOS-IV, April, 1991, Santa Clara, CA, </address> <pages> pp. 75-84. </pages>
Reference-contexts: As illustrated by Figure 3, miss ratios for the SPEC benchmarks are considerably below those for any workloads with significant OS activity. Similar differences in cache performance between compute bound and multiprogrammed environments are reported in <ref> [Mogu91] </ref>. The SPEC floating-point benchmark miss ratios are quite close to the DTMRs, the data from [Agar88], and the VAX 11/780 measurements, and for large cache sizes are also very close to the Amdahl 470 user program miss ratios. The SPEC integer benchmark miss ratios are lowest. 4.
Reference: [Pnev90] <author> D.N. Pnevmatikatos, M.D. Hill, </author> <title> ``Cache Performance of the Integer SPEC Benchmarks on a RISC,'' </title> <journal> Computer Architecture News, </journal> <volume> vol. 18, 2, </volume> <month> June </month> <year> 1990, </year> <pages> pp. 53-68. </pages>
Reference-contexts: Pnevmatikatos and Hill <ref> [Pnev90] </ref> presented cache miss ratios for the four integer (C language) SPEC benchmarks. They used a different compiler (gcc) and a tracing methodology that excludes library references. Nevertheless, most miss ratio differences are less than 0.01.
Reference: [Pric89] <author> Walter Price, </author> <title> ``A Benchmark Tutorial,'' </title> <booktitle> IEEE MICRO, </booktitle> <month> October, </month> <year> 1989, </year> <pages> pp. 28-43. </pages>
Reference-contexts: 1. Introduction The SPEC benchmarks [SPEC89,90, Scot90] are a selection of non-trivial programs chosen to standardize benchmarking. SPEC (System Performance Evaluation Consortium) assembled this suite to provide a standard set of realistic benchmarks for inter-system comparisons; see <ref> [Pric89, Hinn88] </ref> for a discussion of the many problems with the benchmarking situation prior to SPEC. Several factors, including strong industrial support for SPEC, the realistic nature of the benchmarks, and acceptable code portability have led to the wide use of these programs for benchmarking purposes.
Reference: [Saav90] <author> Rafael H. Saavedra-Barrera, and Alan Jay Smith, </author> <title> ``Performance Prediction by Benchmark and Machine Analysis,'' </title> <institution> UC Berkeley Computer Science Division Technical Report UCB/CSD 90/607, </institution> <month> December, </month> <year> 1990. </year>
Reference: [Saav91] <author> Rafael Saavedra-Barrera and Alan Jay Smith, </author> <title> ``Analysis of Standard Benchmark Programs,'' </title> <note> in preparation, available fall, </note> <year> 1991. </year>
Reference: [Sang84] <author> John Sanguinetti, </author> <title> ``Program Optimization for a Pipelined Machine: A Case Study,'' </title> <booktitle> Proc. 1984 ACM Sigmetrics Conf. on Measurement and Modeling of Computer Systems, </booktitle> <month> August, </month> <year> 1984, </year> <title> Cambridge, </title> <booktitle> Mass., </booktitle> <pages> pp. 88-95. </pages>
Reference-contexts: Second, operating systems routines are usually called into the cache by an exception, interrupt or trap, then run for a short time, and finally are replaced from the cache before they run again; they effectively always face a "cold start" situation. Sanguinetti observes <ref> [Sang84] </ref> that for the Amdahl 580, routines must execute over 600 times per second to stay cache resident. Third, operating system activity is associated with timesharing and high levels of multiprogramming; frequent task switching means that programs are constantly experiencing cold start.
Reference: [Scot90] <author> Vicki Scott, </author> <title> ``Is Standardization of Benchmarks Feasible?,'' </title> <booktitle> Proceedings of the Buscon Conference, </booktitle> <address> Feb 14-16, 1990. Long Beach, CA, </address> <pages> 139-147. </pages>
Reference-contexts: 1. Introduction The SPEC benchmarks <ref> [SPEC89,90, Scot90] </ref> are a selection of non-trivial programs chosen to standardize benchmarking. SPEC (System Performance Evaluation Consortium) assembled this suite to provide a standard set of realistic benchmarks for inter-system comparisons; see [Pric89, Hinn88] for a discussion of the many problems with the benchmarking situation prior to SPEC.
Reference: [Smit82] <author> Alan Jay Smith, </author> <title> ``Cache Memories,'' </title> <journal> Computing Surveys, </journal> <volume> vol. 14, 3, </volume> <month> September </month> <year> 1982. </year>
Reference-contexts: We compare the SPEC cache miss ratios to design target miss ratios [Smit87], miss ratios measured using hardware monitors at Amdahl <ref> [Smit82] </ref> and on DEC VAX-series machines [Clar83,88], miss ratios observed from very long address traces [Borg90], and other miss ratios that include operating system and multiprogramming behavior. We also note that miss ratios for multiprogrammed workloads with significant operating system activity are known to be high [Agar88,Ande91]. 2. <p> Evaluation In this section we compare the SPEC miss ratios with miss ratios from previous studies and discuss whether the SPEC applications make suitable cache benchmarks. We first describe the other studies. (a) Smith <ref> [Smit82] </ref> includes several measurements taken with a hardware monitor at Amdahl Corporation on various models of the Amdahl 470V machines. <p> include: Amdahl 470 supervisor and user state miss ratios (plots labeled 470.sup and 470.user), VAX 11/780 and VAX 8800 miss ratios (plots labeled VAX.780 and VAX.8800), and miss ratios from [Agar88] for a multiprogramming level of 3 (plots labeled agarwal.mul3). (We plot the Amdahl data from the fitted curve in <ref> [Smit82] </ref>; the original data points are not available.) We note that the VAX8800 data was collected from a very heavily used timeshared system. The Amdahl 470 supervisor data was collected from the execution of a standard internal Amdahl commercial workload. <p> 16 64 256 i iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii 8K 0.0417 0.0260 16K 0.0258 0.0195 32K 0.0146 0.0131 64K 0.0095 0.0076 128K 0.0066 0.0030 256K 0.0058 0.0025 512K 0.0043 0.0017 1M 0.0020 0.0008 i iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc cccccccccccccccccc cccccccccccccccc cccccccccccccccc cccccccccccccccc cccccccccccccccc ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc - 13 - All of the data in the literature (see e.g. <ref> [Smit82] </ref>, [Ande91], [Agar88]) suggests that operating systems activity significantly increases miss ratios. First, operating systems code tends to loop less than user code, and so instruction miss ratios are high.
Reference: [Smit85] <author> Alan Jay Smith, </author> <title> ``Cache Evaluation and the Impact of Workload Choice,'' </title> <booktitle> Proc. 12'th International Symposium on Computer Architecture, </booktitle> <address> June 17-19, 1985, Boston, Mass, </address> <pages> pp. 64-75. </pages>
Reference-contexts: The 11/780 has an 8 Kbyte, write-through unified cache with an 8-byte block size and a set size of two. The 8800 has a 64 Kbyte, write-through, direct-mapped unified cache with a 64-byte block size. (c) Smith <ref> [Smit85] </ref> introduced the design target miss ratios (DTMRs) to represent typical levels of performance, averaged over a wide class of workloads, ranging from workstations to timeshared mainframes. He synthesized them from real (hardware monitor) measurements that existed in the literature and a large number of trace-driven simulation results. <p> He synthesized them from real (hardware monitor) measurements that existed in the literature and a large number of trace-driven simulation results. The initial DTMRs for 16-byte line size, fully-associative caches <ref> [Smit85] </ref> were later extended to other line sizes [Smit87] and to set associative caches [Hill87,89]. (d) Agarwal, et al. [Agar88] presented miss ratios that include the effects of operating system references and multiprogramming by using microcode to capture address traces from multi-tasked machines.
Reference: [Smit87] <author> Alan Jay Smith, </author> <title> ``Line (Block) Size Choice for CPU Cache Memories,'' </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-36, 9, </volume> <month> September </month> <year> 1987, </year> <pages> pp. 1063-1075. </pages>
Reference-contexts: We compare the SPEC cache miss ratios to design target miss ratios <ref> [Smit87] </ref>, miss ratios measured using hardware monitors at Amdahl [Smit82] and on DEC VAX-series machines [Clar83,88], miss ratios observed from very long address traces [Borg90], and other miss ratios that include operating system and multiprogramming behavior. <p> He synthesized them from real (hardware monitor) measurements that existed in the literature and a large number of trace-driven simulation results. The initial DTMRs for 16-byte line size, fully-associative caches [Smit85] were later extended to other line sizes <ref> [Smit87] </ref> and to set associative caches [Hill87,89]. (d) Agarwal, et al. [Agar88] presented miss ratios that include the effects of operating system references and multiprogramming by using microcode to capture address traces from multi-tasked machines. <p> Previous results based on - 8 - different block sizes (VAX 11/780, VAX 8800, Agarwal, et al.) or different associativities (VAX 8800, Borg et al.) are adjusted for these parameters using ratios of miss ratios from prior studies <ref> [Hill89, Smit87] </ref>.
Reference: [Spec89] <editor> SPEC newsletter, </editor> <volume> vol. 1, </volume> <year> 1989. </year>
Reference: [Spec90] <editor> SPEC newsletter, </editor> <volume> vol. 2, </volume> <year> 1990. </year>
References-found: 22

