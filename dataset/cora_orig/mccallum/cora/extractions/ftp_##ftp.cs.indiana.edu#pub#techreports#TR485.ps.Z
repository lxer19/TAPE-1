URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR485.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Title: Tabular Language for System Design  
Author: by Steven D. Johnson 
Address: Bloomington, Indiana 47405-4101  
Affiliation: Hampton, Virginia,  Computer Science Department Indiana University  
Date: June 1997  September 10-12, 1997  
Note: A  To appear in the proceedings of the Fourth NASA LaRC Formal Methods Workshop (Lfm'97),  
Abstract: Technical Report No. 485 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Dominiquie Borrione, Fredrik Vestman, and Hakim Bouamama. </author> <title> An approch to VerilogVHDL interoperability for synchronous de-signs. </title> <booktitle> In Procedings of the IFIP WG 10.5 Advanced Research Working Conference on Correct Hardware Design and Verification Methods (CHARME'97). To appear. </booktitle>
Reference-contexts: This is closer to the intended high-level synthesis models than the "synthesizable HDL subsets" now in use. For example, Borrione, et.al., have recently proposed hierarchical finite state machines (HFSMs) as a common basis for HDL interoperability <ref> [1] </ref>. The semantic relationship between HFSMs and behavior tables is very close. Composition is specified by giving a connection map that is faithful to each component's arity. Valid maps must preserve I/O directionality, excluding both combinational cycles and output conflicts.
Reference: [2] <author> Robert G. Burger. </author> <title> The scheme machine. </title> <type> Technical Report 413, </type> <institution> Indiana University, Computer Science Department, </institution> <month> August </month> <year> 1994. </year> <pages> 59 pages. 9 </pages>
Reference-contexts: the algorithm at the lower left of Figure 1 describes is the well-known iterative computation of fib (n), where fib (0) = 0 fib (k + 2) = fib (k) + fib (k + 1) The behavior table in Figure 2 describes the garbage collector of a list processing computer <ref> [2] </ref>. It is representative of the tables we work with in our case studies. Its level of specification is more abstract, with two of the registers of type memory.
Reference: [3] <institution> Derivation Systems, Inc., Carlsbad, Cali-fornia. DRS: </institution> <note> Derivational Reasoning System, 1.2.1 edition, December 1995. Contact drs@derivation.com. </note>
Reference-contexts: The final derivation is just a residual proof of the design. This example was carried out and formatted by hand, but Tuna was able to mimic the entire derivation [12] using the DRS mechanized transformation system <ref> [3] </ref> (Appendix A), which operates on recursive systems of functional expressions. That exercise exposed one significant error in the manual derivation. The now and done* columns suggest an assignment of concrete values 0 to work and 1 to wait.
Reference: [4] <author> Nikil D. Dutt and Daniel D. Gajski. Exel: </author> <title> A language for interactive behavioral synthesis. </title> <editor> In John A. Darringer and Franz J. Rammig, editors, </editor> <booktitle> Computer Hardware Description Languages and their Applications, </booktitle> <pages> pages 3-18, </pages> <year> 1989. </year>
Reference-contexts: Their work is also evidence of the utility of a tabular specification language for CAD tool development. Behavior tables have been proposed as an interchange format by Gajski, Dutt, et. al. <ref> [5, 4] </ref>. The intermediate synthesis language BLIV-MV contains a very rich syntax for the tabular specification of multi-valued boolean functions [15].
Reference: [5] <author> D. Gajski, N. Dutt, A. Wu, and S. Lin. </author> <title> Highlevel Synthesis: Introduction to Chip and System Design. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: Their work is also evidence of the utility of a tabular specification language for CAD tool development. Behavior tables have been proposed as an interchange format by Gajski, Dutt, et. al. <ref> [5, 4] </ref>. The intermediate synthesis language BLIV-MV contains a very rich syntax for the tabular specification of multi-valued boolean functions [15].
Reference: [6] <author> D. Harel. Statecharts: </author> <title> a visual formalism for complex systems. </title> <booktitle> The Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: Our experience integrating design derivation with PVS verification suggests a somewhat deeper embedding will needed to support reasoning about transformations. One reason for this is that the underlying semantic domain of streams is not well founded [14]. Leveson's Requirements State Machine Language [16] is based on Harel's state charts <ref> [6] </ref>, but uses and- or tables to specify hyper-edges. She echos Hoover's observation that decision tables are readily accepted and used by practicing engineers. Li and Gupta introduce timed decision tables as an HDL [18, 17].
Reference: [7] <author> Constance Heitmeyer, Alan Bull, Carolyn Gasarch, and Bruce Labaw. SCR*: </author> <title> a toolset for specifying and analyzing requirements. </title> <booktitle> In Proceedings of the Tenth Annual Conference on Computer Assurance (COMPASS '95), </booktitle> <pages> pages 109-122, </pages> <year> 1995. </year>
Reference-contexts: Future topics mentioned in [9] include connections to state-machine and stat- echart based specification. This connection is the focus of our interest. The Software Cost Reduction system of Naval Re- search Laboratories is also a requirements specification tool set with graphics support and aids for analysis and verification <ref> [7] </ref>. A formalization in PVS by a group at SRI is based on SCR* constructs and also contains an extensive review of tabular specification notations [19]. Their treatment is a shallow embedding, supported by tabular syntax contained in the PVS surface language.
Reference: [8] <author> D. N. Hoover and Zewei Chen. Tbell: </author> <title> A mathematical tool for analyzing decision tables. </title> <type> Contractor Report 195027, </type> <address> NASA/LRC, Hampton VA 23681-0001, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: Furthermore, there are other objects in the literature with similar names, including "behavior table," that have different, possibly incompatible forms and interpretations. We hope this terminology will stabilize in the future. 2 Related work The work on decision tables by Hoover, Chen, and others <ref> [9, 8] </ref> inspired us to think more seriously about the behavior tables developed in our case studies of design derivation. Their Tablewise specification tool was developed for avionics software development, but clearly applies to reactive systems in general. <p> The notion of term evaluation used here is standard. The value of a term, t, is written [[t]], where is an assignment or association of values to variables. A generic don't-care constant is written as `"'. A finite extension of propositional logic is assumed|Hoover calls it finite logic <ref> [8] </ref>. Arbitrary collections of enumerated values, or tokens, can be formed. These finite sets come with a polymorphic selection operation. A behavior table can be thought 2 of as a parallel composition of selection expressions.
Reference: [9] <author> D. N. Hoover, David Guaspari, </author> <title> and Polar Humenn. Applications of formal methods to specification and safety of avionics software. </title> <type> Contractor Report 4723, </type> <address> NASA/LRC, Hampton VA 23681-0001, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: We believe that the most urgent task of this line research is to develop graphics interface facilities. An apology about terminology. The term "behavior table" arose spontaneously in our laboratory. In Section 3 we adopt "decision table" from <ref> [9] </ref> and "action table" from [18] for fragments of our forms. But these fragments are not identical to the previously published objects. Furthermore, there are other objects in the literature with similar names, including "behavior table," that have different, possibly incompatible forms and interpretations. <p> Furthermore, there are other objects in the literature with similar names, including "behavior table," that have different, possibly incompatible forms and interpretations. We hope this terminology will stabilize in the future. 2 Related work The work on decision tables by Hoover, Chen, and others <ref> [9, 8] </ref> inspired us to think more seriously about the behavior tables developed in our case studies of design derivation. Their Tablewise specification tool was developed for avionics software development, but clearly applies to reactive systems in general. <p> In addition to a graphical front end, there are functions for verifying exclusivity and completeness of decision tables and for performing structural analyses to aid in obtaining these properties. Future topics mentioned in <ref> [9] </ref> include connections to state-machine and stat- echart based specification. This connection is the focus of our interest. The Software Cost Reduction system of Naval Re- search Laboratories is also a requirements specification tool set with graphics support and aids for analysis and verification [7]. <p> We say g holds for an assignment to ISC when, for each p 2 P , either c p = " or [[p]] = c p . A decision table D = [P; G], consists of a condition set and a list of guards. Following <ref> [9] </ref>, we say a decision table is functional when G describes a proper partitioning of the possible assignments to ISC.
Reference: [10] <author> Steven D. Johnson. </author> <title> Synthesis of Digital Designs from Recursion Equations. </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1984. </year>
Reference-contexts: Provided they are well formed, deterministic systems are readily animated in modeling languages that allow recursive stream networks to be expressed <ref> [10] </ref>. As long as each register has an initial value, the streams are constructed head-first as a fixed-point computation. Translation to event-based simulation languages is also relatively straightforward for systems expressed over concrete types. A synchronous semantics is simple and suited to the clocked implementation models most high-level synthesizers use.
Reference: [11] <author> Steven D. Johnson. </author> <title> Manipulating logical organi-zation with system factorizations. </title> <editor> In Leeser and Brown, editors, </editor> <title> Hardware Specification, Verification and Synthesis: </title> <booktitle> Mathematical Aspects, volume 408 of LNCS, </booktitle> <pages> pages 260-281. </pages> <publisher> Springer, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: u=0 " v " " " " 0 0 2 false ao v w sub u 1 2 " done* u=0 u w ao add v w ALU:(x,y,z) x ao* sub x-y A system factorization encapsulates a set of subject terms in a new table and generates residual interface signals <ref> [11] </ref>. Here, the interface signal x* generates instruction tokens, sub and add, telling ALU which operation to perform. The transformation tool keeps track of the connectivity. In particular, factorizations preserve well-formedness even when one of the factors is entriely combinational, as is ALU in this case.
Reference: [12] <author> Steven D. Johnson. </author> <title> A tabular language for sys-tem design, Appendix A. </title> <type> Technical Report 485, </type> <institution> Indiana University Computer Science Department, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: The final derivation is just a residual proof of the design. This example was carried out and formatted by hand, but Tuna was able to mimic the entire derivation <ref> [12] </ref> using the DRS mechanized transformation system [3] (Appendix A), which operates on recursive systems of functional expressions. That exercise exposed one significant error in the manual derivation. The now and done* columns suggest an assignment of concrete values 0 to work and 1 to wait.
Reference: [13] <author> Steven D. Johnson and Bhaskar Bose. </author> <title> A sys-tem for mechanized digital design derivation. </title> <booktitle> In IFIP and ACM/SIGDA International Workshop on Formal Methods in VLSI Design, </booktitle> <year> 1991. </year> <note> Available as Indiana University Computer Science Department Technical Report No. </note> <month> 323 (December </month> <year> 1990). </year>
Reference-contexts: 1 Introduction and background The tabular specification language described in this article emerged as a visual representation for interactive system design. We started using tables in a casual way, generating them from the underlying expressions of a formal system for design derivation <ref> [13] </ref>. Behavior tables emerged as a bridging notation between control oriented and architecture oriented modes of description. With better graphical support, we think tables such as these can assume a prominent role in system specification, verification, and synthesis. <p> We call these sequences streams because in prior work we obtain a semantics by interpreting a table as a (co)recursive system of stream-defining equations <ref> [13] </ref>. More directly, suppose we are given a set of initial values for the registers, fx s g s2S and a stream for each input variable in I.
Reference: [14] <author> Steven D. Johnson and Paul S. Miner. </author> <title> inte-grated reasoning support in system design: de-sign derivation and theorem proving. </title> <booktitle> In IFIP WG 10.5 Advanced Research Working Conference on Correct Hardware Design and Verification Methods (CHARME'97), </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Our experience integrating design derivation with PVS verification suggests a somewhat deeper embedding will needed to support reasoning about transformations. One reason for this is that the underlying semantic domain of streams is not well founded <ref> [14] </ref>. Leveson's Requirements State Machine Language [16] is based on Harel's state charts [6], but uses and- or tables to specify hyper-edges. She echos Hoover's observation that decision tables are readily accepted and used by practicing engineers. Li and Gupta introduce timed decision tables as an HDL [18, 17].
Reference: [15] <author> Yuji Kukimoto. BLIF-MV. </author> <note> http://www-cad.eecs.berkeley.edu/~/vis/. </note>
Reference-contexts: Behavior tables have been proposed as an interchange format by Gajski, Dutt, et. al. [5, 4]. The intermediate synthesis language BLIV-MV contains a very rich syntax for the tabular specification of multi-valued boolean functions <ref> [15] </ref>. <p> Typically, these serve to condense decision conditions by specifying sets of values. BLIF-MV, for example, allows sub- range, subset, and complementation expressions in its table specifications <ref> [15] </ref>. We have added syntax for bounded indirection which often significantly reduces the size of action tables [25] and is novel for hardware description languages. If r is a signal or register, then #r denotes a token referring to r.
Reference: [16] <author> Nancy G. Leveson, Mats Per Erik Heimdahl, Holly Hildreth, and Jon Damon Reese. </author> <title> Requirements specifiation for process-control sys-tems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9) </volume> <pages> 684-707, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Our experience integrating design derivation with PVS verification suggests a somewhat deeper embedding will needed to support reasoning about transformations. One reason for this is that the underlying semantic domain of streams is not well founded [14]. Leveson's Requirements State Machine Language <ref> [16] </ref> is based on Harel's state charts [6], but uses and- or tables to specify hyper-edges. She echos Hoover's observation that decision tables are readily accepted and used by practicing engineers. Li and Gupta introduce timed decision tables as an HDL [18, 17]. <p> As these examples may illustrate, behavior tables are not the best representation for understanding the specification of an algorithm. However, they seem (in our experience) to serve well as a bridging notation for simultaneously contemplating control and architecture. Furthermore, studies (e.g. <ref> [16] </ref>) suggest that complicated control functions are clearer when presented as decision tables. In hardware design, the intuitive sense of control flow is quickly overwhelmed when processes are composed. 6 Table manipulations Let us explore some basic transformations, starting with the table in Figure 1.
Reference: [17] <author> Jian Li. </author> <title> Timed decision tables: A behavioral model for embedded system specification and optimization. </title> <type> Technical Report UIUCDCS-R96-1971, </type> <institution> Univeristy of Illinois Department of Computer Science, </institution> <address> 1304 West Springfield Ave, Urbana IL 61801, </address> <year> 1996. </year>
Reference-contexts: Leveson's Requirements State Machine Language [16] is based on Harel's state charts [6], but uses and- or tables to specify hyper-edges. She echos Hoover's observation that decision tables are readily accepted and used by practicing engineers. Li and Gupta introduce timed decision tables as an HDL <ref> [18, 17] </ref>. Their results on optimizations exploiting don't care entries are directly applicable to the forms we use in our work. Their work is also evidence of the utility of a tabular specification language for CAD tool development.
Reference: [18] <author> Jian Li and Rejash K. Gupta. </author> <title> HDL optimization using timed decision tables. </title> <booktitle> In 33rd ACM/IEEE Design Automation Conference, </booktitle> <year> 1996. </year>
Reference-contexts: We believe that the most urgent task of this line research is to develop graphics interface facilities. An apology about terminology. The term "behavior table" arose spontaneously in our laboratory. In Section 3 we adopt "decision table" from [9] and "action table" from <ref> [18] </ref> for fragments of our forms. But these fragments are not identical to the previously published objects. Furthermore, there are other objects in the literature with similar names, including "behavior table," that have different, possibly incompatible forms and interpretations. <p> Leveson's Requirements State Machine Language [16] is based on Harel's state charts [6], but uses and- or tables to specify hyper-edges. She echos Hoover's observation that decision tables are readily accepted and used by practicing engineers. Li and Gupta introduce timed decision tables as an HDL <ref> [18, 17] </ref>. Their results on optimizations exploiting don't care entries are directly applicable to the forms we use in our work. Their work is also evidence of the utility of a tabular specification language for CAD tool development.
Reference: [19] <author> Sam Owre, John Rushby, and N. Shankar. </author> <title> Integration in PVS: Tables, types, and model checking. In Tools and Algorithms for the Construction and Analysis of Systems TACAS '97, </title> <note> Springer LNCS. To appear. </note>
Reference-contexts: A formalization in PVS by a group at SRI is based on SCR* constructs and also contains an extensive review of tabular specification notations <ref> [19] </ref>. Their treatment is a shallow embedding, supported by tabular syntax contained in the PVS surface language. One immediate benefit of this approach is exploitation of the PVS type system, in particular, its management of type correctness conditions.
Reference: [20] <author> K. Rath, I. Celis, and R. M. Wehrmeister. RTBA: </author> <title> A generic bit-sliced bus architecture for 10 datapath synthesis. </title> <type> Technical Report 321, </type> <institution> De-partment of Computer Science, Indiana University, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: This realization prompted us to consider our tables more seriously as a formal design notation, and we began exploring features that are useful in system design applications [28, 25]. We comtemplated direct realizations in VLSI <ref> [20] </ref>. Other encouraging influences have been the emerging tools and techniques for using tables in requirements specification, verification, and synthesis. These are reviewed in the next section. In Sections 3 through 5 we present a syntax and representative semantics for the tables we use.
Reference: [21] <author> Kamlesh Rath. </author> <title> Sequential System Decomposition. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Indiana University, USA, </institution> <year> 1995. </year> <type> Technical Report No. 457, </type> <pages> 90 pages. </pages>
Reference-contexts: One possible factorization is shown in Figure 4. We have have investigated several constructive approaches to this family of decompositions <ref> [21, 23, 30, 29, 24] </ref>. We cannot yet claim a universal construction, but we do have transformations general enough to handle many common interface specifications [22].
Reference: [22] <author> Kamlesh Rath, Bhaskar Bose, and Steven D. Johnson. </author> <title> Derivation of a DRAM memory in-terface by sequential decomposition. </title> <booktitle> In Proceedings of the International Conference on Computer Design (ICCD), </booktitle> <pages> pages 438-441. </pages> <publisher> IEEE, </publisher> <month> October </month> <year> 1993. </year>
Reference-contexts: One possible factorization is shown in Figure 4. We have have investigated several constructive approaches to this family of decompositions [21, 23, 30, 29, 24]. We cannot yet claim a universal construction, but we do have transformations general enough to handle many common interface specifications <ref> [22] </ref>.
Reference: [23] <author> Kamlesh Rath, Venkatesh Choppella, and Steven D. Johnson. </author> <title> Decomposition of sequential behavior using interface specification and com-plementation. </title> <journal> VLSI Design Journal, </journal> <volume> 3(3-4):347358, </volume> <year> 1995. </year>
Reference-contexts: One possible factorization is shown in Figure 4. We have have investigated several constructive approaches to this family of decompositions <ref> [21, 23, 30, 29, 24] </ref>. We cannot yet claim a universal construction, but we do have transformations general enough to handle many common interface specifications [22].
Reference: [24] <author> Kamlesh Rath and Steven D. Johnson. </author> <title> Toward a basis for protocol specification and pro-cess decomposition. </title> <editor> In D. Agnew, L. Claesen, and R. Camposano, editors, </editor> <booktitle> Proceedings of IFIP Conference on Hardware Description Languages and their Applications, </booktitle> <pages> pages 157-174. </pages> <publisher> Elsevier, </publisher> <month> April </month> <year> 1993. </year>
Reference-contexts: One possible factorization is shown in Figure 4. We have have investigated several constructive approaches to this family of decompositions <ref> [21, 23, 30, 29, 24] </ref>. We cannot yet claim a universal construction, but we do have transformations general enough to handle many common interface specifications [22].
Reference: [25] <author> Kamlesh Rath, M. Esen Tuna, and Steven D. Johnson. </author> <title> Behavior tables: A basis for system representation and transformational system syn-thesis. </title> <booktitle> In Proceedings of the International Conference on Computer Aided Design (ICCAD), </booktitle> <pages> pages 736-740. </pages> <publisher> IEEE, </publisher> <month> November </month> <year> 1993. </year>
Reference-contexts: This realization prompted us to consider our tables more seriously as a formal design notation, and we began exploring features that are useful in system design applications <ref> [28, 25] </ref>. We comtemplated direct realizations in VLSI [20]. Other encouraging influences have been the emerging tools and techniques for using tables in requirements specification, verification, and synthesis. These are reviewed in the next section. <p> Typically, these serve to condense decision conditions by specifying sets of values. BLIF-MV, for example, allows sub- range, subset, and complementation expressions in its table specifications [15]. We have added syntax for bounded indirection which often significantly reduces the size of action tables <ref> [25] </ref> and is novel for hardware description languages. If r is a signal or register, then #r denotes a token referring to r.
Reference: [26] <author> Andres Takach, Wayne Wolf, and Miriam Leeser. </author> <title> An automaton model for scheduling constraints in synchronous machines. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 44(1) </volume> <pages> 1-12, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: BFSM are intended to serve as specification models for high-level synthesis. Any implementation of a BFSM refines this constraint by assigning particular transition to each event, subject to the constraints <ref> [26] </ref>. As the example of Section 6 suggests, one row of an action table can represent a number of transitions at a finer time scale. However, BFSMs are more expressive than behavior tables in the sense that unstructured programs are more expressive than structured ones.
Reference: [27] <author> M. Esen Tuna, Steven D. Johnson, and Bob Burger. </author> <title> Continuations in hardware-software codesign. </title> <booktitle> In Proceedings of the International Conference on Computer Design (ICCD), </booktitle> <pages> pages 264-269. </pages> <publisher> IEEE, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: In [28] we show how a behavior table describing a bus reduces to one row when indirection is used to specify sources and destinations. In <ref> [27] </ref> we explore control indirection. The behavior FSMs proposed by Takach, Wolf, and Leeser contain constructs to constrain events to occur within sets of transitions. BFSM are intended to serve as specification models for high-level synthesis.
Reference: [28] <author> M. Esen Tuna, Kamlesh Rath, and Steven D. Johnson. </author> <title> Specification and synthesis of bounded indirection. </title> <booktitle> In Proceedings of the Fifth Great Lakes Symposium on VLSI, </booktitle> <pages> pages 86-89. </pages> <publisher> IEEE, </publisher> <month> March </month> <year> 1995. </year>
Reference-contexts: This realization prompted us to consider our tables more seriously as a formal design notation, and we began exploring features that are useful in system design applications <ref> [28, 25] </ref>. We comtemplated direct realizations in VLSI [20]. Other encouraging influences have been the emerging tools and techniques for using tables in requirements specification, verification, and synthesis. These are reviewed in the next section. <p> If r is a signal or register, then #r denotes a token referring to r. If register s contains such a token, then @s denotes the entity to which s refers; that is, @s case s of . . . #r: r. . . In <ref> [28] </ref> we show how a behavior table describing a bus reduces to one row when indirection is used to specify sources and destinations. In [27] we explore control indirection. The behavior FSMs proposed by Takach, Wolf, and Leeser contain constructs to constrain events to occur within sets of transitions.
Reference: [29] <author> Zheng Zhu and Steven D. Johnson. </author> <title> Automatic synthesis of sequential synchronizations. </title> <editor> In D. Agnew, L. Claesen, and R. Camposano, ed-itors, </editor> <booktitle> Proceedings of IFIP Conference on Hardware Description Languages and their Applications, </booktitle> <pages> pages 285-301. </pages> <publisher> Elsevier, </publisher> <month> April </month> <year> 1993. </year>
Reference-contexts: One possible factorization is shown in Figure 4. We have have investigated several constructive approaches to this family of decompositions <ref> [21, 23, 30, 29, 24] </ref>. We cannot yet claim a universal construction, but we do have transformations general enough to handle many common interface specifications [22].
Reference: [30] <author> Zheng Zhu and Steven D. Johnson. </author> <title> Capturing synchronization specifications for sequential compositions. </title> <booktitle> In Proceedings of the 1994 IEEE International Conference on Computer Design (ICCD 94), </booktitle> <pages> pages 117-121. </pages> <publisher> IEEE, </publisher> <month> October </month> <year> 1994. </year> <month> 11 </month>
Reference-contexts: One possible factorization is shown in Figure 4. We have have investigated several constructive approaches to this family of decompositions <ref> [21, 23, 30, 29, 24] </ref>. We cannot yet claim a universal construction, but we do have transformations general enough to handle many common interface specifications [22].
References-found: 30

