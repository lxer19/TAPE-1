URL: file://ftp.cs.wisc.edu/coral/doc/coralpp.ps
Refering-URL: http://www.cs.wisc.edu/coral/coral.papers.html
Root-URL: 
Email: fdivesh,raghu,praveeng@cs.wisc.edu and sudar-sha@research.att.com.  
Title: Coral++: Adding Object-Orientation to a Logic Database Language several important decisions: the data model is
Author: Divesh Srivastava Raghu Ramakrishnan Praveen Seshadri S. Sudarshan Raghu Ramakrishnan, Divesh Srivastava and Praveen Seshadri 
Date: 1993  
Note: The design and implementation of Coral++ incorporates  was supported by a David and Lu-cile Packard Foundation Fellowship in Science and Engineering, a Presidential Young Investigator Award with matching grants from DEC, Tandem and Xerox, and NSF grant IRI-9011563. The addresses of the authors are  The authors e-mail addresses are  Part of the work of this author was done while the author was at the  Proceedings of the 19th VLDB Conference Dublin, Ireland  
Address: Wisconsin, Madison  Wisconsin, Madison  Wisconsin, Madison  Murray Hill  Wisconsin, Madison, WI 53706, USA,  600 Mountain Avenue, Murray Hill, NJ 07974, USA.  
Affiliation: University of  University of  University of  AT&T Bell Labs,  Computer Sciences Department, University of  and AT&T Bell Laboratories,  University of Wisconsin.  
Abstract: Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the VLDB copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. lated notion of class extents; and declarative Coral++ programs can be largely understood in terms of standard Horn clause logic with C++ method invocations treated as external functions. The implementation outline illustrates that extending an existing deductive system to incorporate object-oriented features in the data model is feasible, and is orthogonal to the techniques used for object storage and retrieval. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal and N. H. Gehani. </author> <title> Ode (Object Database and Environment): The language and the data model. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Two main directions of research in database programming languages have been object-oriented database languages and deductive database languages, and the issue of combining the two paradigms has received attention recently. Object-oriented database languages, such as O++ <ref> [1] </ref> and O 2 [7], among others, enhance the relational data model by providing support for abstract data types, encapsulation, object identifiers, methods, inheritance and polymorphism. Such sophisticated features are very useful for data modeling in many scientific, engineering, and multimedia applications. <p> The Coral++ query language is more expressive than CQL++ or ZQL [C++], which are based on SQL. However, each of these proposals is integrated with a computationally complete imperative language: CQL++ with O++ <ref> [1] </ref>, and Coral++ and ZQL [C++] with C++. CQL++ has a syntax similar to SQL syntax for class definition. These classes do not have any facility for data abstraction (i.e., all class members are public).
Reference: [2] <author> N. Arni, K. Ong, S. Tsur, and C. Zaniolo. </author> <title> The LDL++ system: Rationale, </title> <journal> technology and applications. </journal> <note> (Submitted), </note> <year> 1993. </year>
Reference-contexts: Some of the important aspects of our design are: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model (e.g., <ref> [28, 8, 13, 9, 10, 17, 2] </ref>) This approach benefits from the support for data abstraction, inheritance, polymor-phism and parametrized types already available in C++. <p> This translation is possible because of the lack of behavioral features and polymorphism in the data model. It is not clear how the translation approach generalizes once we introduce behavioral features in the model. LDL++ <ref> [2] </ref> is a deductive database system whose type system extends that of LDL [19] with an abstract data type facility that supports inheritance and predicate-valued methods.
Reference: [3] <author> J. A. Blakeley. ZQL[C++]: </author> <title> Integrating the C++ language and an object query capability. </title> <booktitle> In Proceedings of the Workshop on Combining Declarative and Object-Oriented Databases, </booktitle> <pages> pages 138-144, </pages> <address> Washing-ton, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Other query languages that use the C++ type system include CQL++ [6], ZQL [C++] <ref> [3] </ref> and ObjectStore [20]. * The Coral++ declarative query language sup-ports the combination of Coral rules with C++ expressions in a clean fashion. This approach can effectively utilize the Coral implementation and the C++ compiler. <p> We presented a summary of the differences between our proposal and these other proposals in Section 1.2. We now examine some of the closely related proposals in more detail. Proposals Based on C++ ZQL [C++] <ref> [3] </ref> and CQL++ [6] are the proposals most closely related to Coral++ since they are also based on the C++ object model. The Coral++ query language is more expressive than CQL++ or ZQL [C++], which are based on SQL.
Reference: [4] <author> F. Cacace, S. Ceri, S. Crespi-Reghizzi, L. Tanca, and R. Zicari. </author> <title> Integrating object-oriented data modeling with a rule-based programming paradigm. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 225-236, </pages> <address> Atlantic City, New Jersey, </address> <month> May </month> <year> 1990. </year>
Reference: [5] <author> W. Chen, M. Kifer, and D. S. Warren. Hilog: </author> <title> A first-order semantics for higher-order logic programming constructs. </title> <booktitle> In Proceedings of the North Amer ican Conference on Logic Programming, </booktitle> <pages> pages 1090--1114, </pages> <year> 1989. </year>
Reference-contexts: It also supports unordered relations (i.e., sets and multisets) and ordered relations (lists and arrays), which are use ful in applications involving sequence data [27]. * The Coral++ query language can be largely understood in terms of standard Horn clause logic, unlike Noodle [17] which is based on HiLog <ref> [5] </ref> and XSQL [13] which is based on F-logic [14]. <p> Noodle [17, 18] is a declarative query language for the Sword declarative object-oriented database. Unlike Coral++ and XSQL, Noodle does not use path expressions to access attributes and invoke methods on objects. Instead, Noodle uses a syntax reminiscent of HiLog <ref> [5] </ref> for this purpose. Noodle also has a number of built-in classes to facilitate schema querying.
Reference: [6] <author> S. Dar, N. H. Gehani, and H. V. Jagadish. CQL++: </author> <title> An SQL for a C++ based object-oriented DBMS. </title> <booktitle> In Proceedings of the International Conference on Extending Database Technology, </booktitle> <address> Vienna, Austria, </address> <month> Mar. </month> <year> 1992. </year> <note> (A full version is available as AT&T Bell Labs Technical Memorandum 11252-910219-26). </note>
Reference-contexts: Other query languages that use the C++ type system include CQL++ <ref> [6] </ref>, ZQL [C++] [3] and ObjectStore [20]. * The Coral++ declarative query language sup-ports the combination of Coral rules with C++ expressions in a clean fashion. This approach can effectively utilize the Coral implementation and the C++ compiler. <p> We presented a summary of the differences between our proposal and these other proposals in Section 1.2. We now examine some of the closely related proposals in more detail. Proposals Based on C++ ZQL [C++] [3] and CQL++ <ref> [6] </ref> are the proposals most closely related to Coral++ since they are also based on the C++ object model. The Coral++ query language is more expressive than CQL++ or ZQL [C++], which are based on SQL.
Reference: [7] <author> O. </author> <title> Deux. The O 2 database programming language. </title> <journal> Communications of the ACM, </journal> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Two main directions of research in database programming languages have been object-oriented database languages and deductive database languages, and the issue of combining the two paradigms has received attention recently. Object-oriented database languages, such as O++ [1] and O 2 <ref> [7] </ref>, among others, enhance the relational data model by providing support for abstract data types, encapsulation, object identifiers, methods, inheritance and polymorphism. Such sophisticated features are very useful for data modeling in many scientific, engineering, and multimedia applications.
Reference: [8] <author> L. J. Gallagher. </author> <title> Object SQL: Language extensions for object data management. </title> <booktitle> In Proceedings of the ISMM First International Conference on Information and Knowledge Management, </booktitle> <pages> pages 17-26, </pages> <address> Baltimore, Maryland, </address> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Some of the important aspects of our design are: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model (e.g., <ref> [28, 8, 13, 9, 10, 17, 2] </ref>) This approach benefits from the support for data abstraction, inheritance, polymor-phism and parametrized types already available in C++.
Reference: [9] <author> S. Greco, N. Leone, and P. Rullo. </author> <title> COMPLEX: An object-oriented logic programming system. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 4(4) </volume> <pages> 344-359, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: Some of the important aspects of our design are: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model (e.g., <ref> [28, 8, 13, 9, 10, 17, 2] </ref>) This approach benefits from the support for data abstraction, inheritance, polymor-phism and parametrized types already available in C++. <p> Since ZQL [C++] also allows SQL subqueries to appear as predicates, it does not distinguish between the pred icate truth semantics and the C++ expression truth semantics, unlike Coral++ and CQL++. Proposals Based on Deductive Languages The COMPLEX data model <ref> [9] </ref> is a structural, typed data model that adds features such as object identity, object sharing and inheritance to the relational model. It does not support abstract data types, encapsulation, or methods; consequently, the data model is not as rich as the Coral++ data model.
Reference: [10] <author> M. H. Jamil and L. V. S. Lakshmanan. ORLOG: </author> <title> A logic for semantic object-oriented models. </title> <booktitle> In Proceedings of the ISMM First International Conference on Information and Knowledge Management, </booktitle> <pages> pages 584-592, </pages> <address> Baltimore, Maryland, </address> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Some of the important aspects of our design are: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model (e.g., <ref> [28, 8, 13, 9, 10, 17, 2] </ref>) This approach benefits from the support for data abstraction, inheritance, polymor-phism and parametrized types already available in C++. <p> Unlike Coral++ and XSQL, Noodle does not use path expressions to access attributes and invoke methods on objects. Instead, Noodle uses a syntax reminiscent of HiLog [5] for this purpose. Noodle also has a number of built-in classes to facilitate schema querying. Orlog <ref> [10] </ref> combines the modeling capabilities of object-oriented and semantic data models, and is similar to Noodle in that its logic-based language for querying and implementing methods uses a higher-order syntax with first order semantics.
Reference: [11] <author> M. Jarke, S. Eherer, R. Gallersdoerfer, M. Jeusfeld, and M. Staudt. </author> <title> ConceptBase a deductive object base manager. </title> <note> (Submitted), </note> <year> 1993. </year>
Reference-contexts: There are several other interesting proposals for combining semantically rich data models with deductive databases that are less closely related to Coral++. ConceptBase <ref> [11] </ref> and Quixote [30] are two such systems. ConceptBase is based on the Telos knowledge representation language, and allows the specification of methods using deductive rules and integrity constraints.
Reference: [12] <author> P. C. Kanellakis, G. M. Kuper, and P. Z. Revesz. </author> <title> Constraint query languages. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 299-313, </pages> <address> Nashville, Tennessee, </address> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: Such facts are often useful in knowledge representation, natural language processing and could be particularly useful in a database that stores (and possibly manipulates) rules. There is another, possibly more important, use of variables | namely to specify constraint facts <ref> [12, 22] </ref>. However, the Coral data model does not allow values of (arbitrary) user-defined types in facts.
Reference: [13] <author> M. Kifer, W. Kim, and Y. Sagiv. </author> <title> Querying object-oriented databases. </title> <booktitle> In Proceedings of the ACM SIG-MOD Conference on Management of Data, </booktitle> <pages> pages 393-402, </pages> <address> San Diego, California, </address> <year> 1992. </year>
Reference-contexts: Some of the important aspects of our design are: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model (e.g., <ref> [28, 8, 13, 9, 10, 17, 2] </ref>) This approach benefits from the support for data abstraction, inheritance, polymor-phism and parametrized types already available in C++. <p> supports unordered relations (i.e., sets and multisets) and ordered relations (lists and arrays), which are use ful in applications involving sequence data [27]. * The Coral++ query language can be largely understood in terms of standard Horn clause logic, unlike Noodle [17] which is based on HiLog [5] and XSQL <ref> [13] </ref> which is based on F-logic [14]. <p> However, the Coral++ declarative language can create facts describing relationships between existing objects in the database. Rules in Coral++ are deliberately restricted to avoid creating new objects, since this is an issue that is not yet well-understood despite work by Maier [16], Kifer et al. <ref> [13] </ref>, and others. A number of issues, notably the resolution of conflicts when rules generate distinct objects with the same object identifier, remain unclear, especially in the presence of partially specified objects (e.g. some fields are variables, in the Coral++ context). <p> Further, LDL++ methods can be defined only using LDL++ rules; however, this can be done more naturally than in Coral++. Proposals Based on Non-Horn Logics XSQL <ref> [13] </ref> extends SQL by adding path expressions that may have variables that range over classes, attributes and methods. This facilitates querying schema information as well as instance-level information in object-oriented databases, using a single declarative query language. <p> In Coral++, methods and other aspects of data abstraction borrowed from C++ are viewed as being outside the scope of the deductive machinery, notably the unification mechanism. A more comprehensive treatment of features like path expressions (e.g., as in XSQL <ref> [13] </ref>) may well enable more efficient (i.e., set-oriented) processing of certain queries. We make no attempt to give these features a logical semantics; we simply borrow the C++ semantics, in order to enable ease of implementation.
Reference: [14] <author> M. Kifer and G. Lausen. F-logic, </author> <title> a higher-order language for reasoning about objects, inheritance and schemes. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1989. </year>
Reference-contexts: multisets) and ordered relations (lists and arrays), which are use ful in applications involving sequence data [27]. * The Coral++ query language can be largely understood in terms of standard Horn clause logic, unlike Noodle [17] which is based on HiLog [5] and XSQL [13] which is based on F-logic <ref> [14] </ref>. <p> We make no attempt to give these features a logical semantics; we simply borrow the C++ semantics, in order to enable ease of implementation. The semantic foundations of XSQL, i.e., F-logic <ref> [14] </ref>, Noodle, i.e., HiLog, and Orlog have features that are difficult to support efficiently, at least in a bottom-up implementation. In particular, variables can get bound to predicate names only at run-time, and this causes problems with analysis of strongly connected components (SCCs) and can make semi-naive evaluation inefficient.
Reference: [15] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: (Coral is implemented in C++), but we believe that our approach can also be applied to extending Coral with an alternative object-oriented data model. 3.1 Overview of the Coral Data Model The formal definitions of constants, variables, terms, tuples, facts and relations are available in logic programming texts such as <ref> [15] </ref>. We informally describe these features of the Coral data model. The following facts could be interpreted as follows: the first fact indicates that John is an employee in the "Toys for Tots" department who has been with the company for 3 years and makes 35K. <p> first give an overview of the Coral query language and the evaluation of Coral queries, and then discuss the Coral++ design decisions. 4.1 Overview of the Coral Query Lan guage The formal definitions of constants, variables, terms, atoms, literals, facts and rules are available in logic programming texts such as <ref> [15] </ref>. We briefly describe some of these features here. Rules in Coral take the form: head : body 1 , body 2 , : : : , body n . where head is a positive literal, each body i is a (positive or negative) literal, and n 0.
Reference: [16] <author> D. Maier. </author> <title> A logic for objects. </title> <type> Technical Report Technical report CS/E-86-012, </type> <institution> Oregon Graduate Center, Beaverton Oregon 97006-1999, </institution> <month> November </month> <year> 1986. </year>
Reference-contexts: However, the Coral++ declarative language can create facts describing relationships between existing objects in the database. Rules in Coral++ are deliberately restricted to avoid creating new objects, since this is an issue that is not yet well-understood despite work by Maier <ref> [16] </ref>, Kifer et al. [13], and others. A number of issues, notably the resolution of conflicts when rules generate distinct objects with the same object identifier, remain unclear, especially in the presence of partially specified objects (e.g. some fields are variables, in the Coral++ context).
Reference: [17] <author> I. S. Mumick and K. A. Ross. </author> <title> An architecture for declarative object-oriented databases. </title> <booktitle> In Proceedings of the JICSLP-92 Workshop on Deductive Databases, </booktitle> <pages> pages 21-30, </pages> <address> Washington, D.C., </address> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Some of the important aspects of our design are: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model (e.g., <ref> [28, 8, 13, 9, 10, 17, 2] </ref>) This approach benefits from the support for data abstraction, inheritance, polymor-phism and parametrized types already available in C++. <p> This approach can effectively utilize the Coral implementation and the C++ compiler. Noodle <ref> [17] </ref> and ObjectStore [20], for instance, take the alternative approach of inventing new syntax to query an object data model. * Coral++ is more expressive than most of the other proposals ([28, 8, 6, 9]). In particular, it provides a facility for generalized recursive view definition in the query language. <p> It also supports unordered relations (i.e., sets and multisets) and ordered relations (lists and arrays), which are use ful in applications involving sequence data [27]. * The Coral++ query language can be largely understood in terms of standard Horn clause logic, unlike Noodle <ref> [17] </ref> which is based on HiLog [5] and XSQL [13] which is based on F-logic [14]. <p> Proposals Based on Non-Horn Logics XSQL [13] extends SQL by adding path expressions that may have variables that range over classes, attributes and methods. This facilitates querying schema information as well as instance-level information in object-oriented databases, using a single declarative query language. Noodle <ref> [17, 18] </ref> is a declarative query language for the Sword declarative object-oriented database. Unlike Coral++ and XSQL, Noodle does not use path expressions to access attributes and invoke methods on objects. Instead, Noodle uses a syntax reminiscent of HiLog [5] for this purpose.
Reference: [18] <author> I. S. Mumick and K. A. Ross. </author> <title> The influence of class hierarchy choice on query language design. </title> <booktitle> In Proceedings of the Workshop on Combining Declarative and Object-Oriented Databases, </booktitle> <pages> pages 152-154, </pages> <address> Washing-ton, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Proposals Based on Non-Horn Logics XSQL [13] extends SQL by adding path expressions that may have variables that range over classes, attributes and methods. This facilitates querying schema information as well as instance-level information in object-oriented databases, using a single declarative query language. Noodle <ref> [17, 18] </ref> is a declarative query language for the Sword declarative object-oriented database. Unlike Coral++ and XSQL, Noodle does not use path expressions to access attributes and invoke methods on objects. Instead, Noodle uses a syntax reminiscent of HiLog [5] for this purpose.
Reference: [19] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <booktitle> Principles of Computer Science. </booktitle> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Such sophisticated features are very useful for data modeling in many scientific, engineering, and multimedia applications. Deductive database languages, such as LDL <ref> [19] </ref>, Coral [23] and Glue-Nail! [21], among others, enhance the declarative query language by providing a facility for generalized recursive view definition, which is of considerable practical importance. However, data models for deductive databases are typically structural, and do not have the richness of object-oriented data models. <p> In deductive database languages such as LDL <ref> [19] </ref> and Coral [23], values can be Her-brand terms, which are essentially structured values. However, data modeling in many scientific and engineering applications require support for more sophisticated features such as abstract data types, encapsulation, methods and inheritance. <p> This translation is possible because of the lack of behavioral features and polymorphism in the data model. It is not clear how the translation approach generalizes once we introduce behavioral features in the model. LDL++ [2] is a deductive database system whose type system extends that of LDL <ref> [19] </ref> with an abstract data type facility that supports inheritance and predicate-valued methods. However, it does not support object sharing or ADT extents, and its support of encapsulation and object identity is limited. consequently, the data model is not as rich as the Coral++ data model.
Reference: [20] <author> J. Orenstein, S. Haradhvala, B. Margulies, and D. Sakahara. </author> <title> Query processing in the ObjectStore database system. </title> <booktitle> In Proceedings of the ACM SIG-MOD Conference on Management of Data, </booktitle> <pages> pages 403-412, </pages> <address> San Diego, California, </address> <year> 1992. </year>
Reference-contexts: Other query languages that use the C++ type system include CQL++ [6], ZQL [C++] [3] and ObjectStore <ref> [20] </ref>. * The Coral++ declarative query language sup-ports the combination of Coral rules with C++ expressions in a clean fashion. This approach can effectively utilize the Coral implementation and the C++ compiler. Noodle [17] and ObjectStore [20], for instance, take the alternative approach of inventing new syntax to query an object <p> that use the C++ type system include CQL++ [6], ZQL [C++] [3] and ObjectStore <ref> [20] </ref>. * The Coral++ declarative query language sup-ports the combination of Coral rules with C++ expressions in a clean fashion. This approach can effectively utilize the Coral implementation and the C++ compiler. Noodle [17] and ObjectStore [20], for instance, take the alternative approach of inventing new syntax to query an object data model. * Coral++ is more expressive than most of the other proposals ([28, 8, 6, 9]). In particular, it provides a facility for generalized recursive view definition in the query language.
Reference: [21] <author> G. Phipps, M. A. Derr, and K. A. Ross. </author> <title> Glue-NAIL!: A deductive database system. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 308-317, </pages> <year> 1991. </year>
Reference-contexts: Such sophisticated features are very useful for data modeling in many scientific, engineering, and multimedia applications. Deductive database languages, such as LDL [19], Coral [23] and Glue-Nail! <ref> [21] </ref>, among others, enhance the declarative query language by providing a facility for generalized recursive view definition, which is of considerable practical importance. However, data models for deductive databases are typically structural, and do not have the richness of object-oriented data models.
Reference: [22] <author> R. Ramakrishnan. </author> <title> Magic Templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Such facts are often useful in knowledge representation, natural language processing and could be particularly useful in a database that stores (and possibly manipulates) rules. There is another, possibly more important, use of variables | namely to specify constraint facts <ref> [12, 22] </ref>. However, the Coral data model does not allow values of (arbitrary) user-defined types in facts.
Reference: [23] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> CORAL: Control, Relations and Logic. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1992. </year>
Reference-contexts: Such sophisticated features are very useful for data modeling in many scientific, engineering, and multimedia applications. Deductive database languages, such as LDL [19], Coral <ref> [23] </ref> and Glue-Nail! [21], among others, enhance the declarative query language by providing a facility for generalized recursive view definition, which is of considerable practical importance. However, data models for deductive databases are typically structural, and do not have the richness of object-oriented data models. <p> In deductive database languages such as LDL [19] and Coral <ref> [23] </ref>, values can be Her-brand terms, which are essentially structured values. However, data modeling in many scientific and engineering applications require support for more sophisticated features such as abstract data types, encapsulation, methods and inheritance. <p> However, data modeling in many scientific and engineering applications require support for more sophisticated features such as abstract data types, encapsulation, methods and inheritance. To support the data modeling needs of such applications, the Coral++ data model enhances the untyped Coral data model <ref> [23] </ref> with the C++ class facility. Values in Coral++ can additionally be of any type definable in C++, which can be manipulated using only the corresponding methods, supporting encapsulation. This allows a programmer to effectively use a combination of C++ and Coral, with minimal impedance mismatch. <p> It is based on the Coral query language <ref> [23] </ref> which supports general Horn clauses with complex terms, set-grouping, aggregation and negation. Coral++ extends the Coral query language by allowing C++ expressions for accessing attributes and invoking (side-effect free) methods of objects in program rules. <p> These include member, union, intersection, difference, multise-tunion, cardinality, subset, and makeset. Coral also allows several aggregate operations on sets and multi-sets: these include count, min, max, sum, product, average and any. Some of the aggregate operations can be combined directly with the multiset-generation operations for increased efficiency (see <ref> [23] </ref> for further details). Modules provide a way, as the name suggests, to modularize Coral code. In developing large applications, incremental program development and testing is critical, and modules in Coral provide the basis for this kind of programming. <p> We refer the interested reader to <ref> [23] </ref> for a discussion of these annotations and their effect on module evaluation. In the absence of any user-specified annotations, the Coral system chooses from among a set of default evaluation strategies.
Reference: [24] <author> R. Ramakrishnan, D. Srivastava, S. Sudarshan, and P. Seshadri. </author> <title> Implementation of the CORAL deductive database system. </title> <booktitle> In Proceedings of the ACM SIG-MOD Conference on Management of Data, </booktitle> <year> 1993. </year>
Reference-contexts: An implementation based on the run-time system of the Coral implementation <ref> [24] </ref> is already underway. The rest of this paper is structured as follows. We start with example programs written in Coral++ that demonstrate several features of the data model and query language. We describe the object-oriented features of the Coral++ data model in Section 3. <p> As with updates, we have a deferred semantics for deletes. 2 6 Implementing Coral++ One of the fundamental design decisions of our proposal is to use the run-time system of the Coral implementation <ref> [24] </ref> as much as possible in the implementation of Coral++. Several design decisions are a practical consequence of this: * The notation for class definitions in Coral++ is the same as in C++. <p> It is cleanly integrated with C++, providing the user the ability to program in a combination of programming styles, with minimal impedance mismatch. We proposed an implementation strategy for Coral++ that effectively uses the existing Coral run-time system <ref> [24] </ref> and the C++ compiler to implement object-oriented features of the data model and query language. This, in our view, is one of the strong points of our proposal, and distinguishes it from many proposals in the literature describing query languages for object-oriented databases.
Reference: [25] <author> J. Richardson. </author> <title> Supporting lists in a data model (a timely approach). </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 127-138, </pages> <address> Vancouver, Canada, </address> <year> 1992. </year>
Reference-contexts: Typically, current database systems support only multisets of tuples, and the utility of these collections can be seen from the variety of applications written in SQL. However, for many applications (see <ref> [25, 27] </ref>, for instance) involving sequence data and spatial data, for example, ordered collections of list-type and array-type are more natural. Hence, Coral++ also supports list-relations and array-relations, in addition to multiset-relations. Each of these relation types supports the operation of iterating through the elements in the collection.
Reference: [26] <author> K. Ross. </author> <title> Modular Stratification and Magic Sets for DATALOG programs with negation. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 161-171, </pages> <year> 1990. </year>
Reference-contexts: Consider the following query from <ref> [26] </ref>: "Find if a given part is working, where a part is known to be working either if it has been (successfully) tested or if it is constructed from smaller parts, and all the smaller parts are known to be working".
Reference: [27] <author> W. G. Roth. Mimsy: </author> <title> A system for analyzing time series data in the stock market domain. </title> <note> Technical Report (To appear), </note> <institution> University of Wisconsin at Madison, </institution> <year> 1993. </year>
Reference-contexts: In particular, it provides a facility for generalized recursive view definition in the query language. It also supports unordered relations (i.e., sets and multisets) and ordered relations (lists and arrays), which are use ful in applications involving sequence data <ref> [27] </ref>. * The Coral++ query language can be largely understood in terms of standard Horn clause logic, unlike Noodle [17] which is based on HiLog [5] and XSQL [13] which is based on F-logic [14]. <p> Typically, current database systems support only multisets of tuples, and the utility of these collections can be seen from the variety of applications written in SQL. However, for many applications (see <ref> [25, 27] </ref>, for instance) involving sequence data and spatial data, for example, ordered collections of list-type and array-type are more natural. Hence, Coral++ also supports list-relations and array-relations, in addition to multiset-relations. Each of these relation types supports the operation of iterating through the elements in the collection. <p> public: double low ; double high ; double average ( ) ; int volume traded ; g ; Stock market information for individual companies can be naturally represented as array relations, which results in extremely efficient querying and manipula tion of such information, as is demonstrated in the Mimsy system <ref> [27] </ref>. 2 4 Coral++: Query Language The Coral++ query language is modular, declarative and provides support for generalized recursive view definition. It is based on the Coral query language [23] which supports general Horn clauses with complex terms, set-grouping, aggregation and negation.
Reference: [28] <author> L. A. Rowe and M. R. Stonebraker. </author> <title> The POSTGRES data model. </title> <booktitle> In Proceedings of the Thirteenth International Conference on Very Large Databases, </booktitle> <pages> pages 83-96, </pages> <address> Brighton, England, </address> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: Some of the important aspects of our design are: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model (e.g., <ref> [28, 8, 13, 9, 10, 17, 2] </ref>) This approach benefits from the support for data abstraction, inheritance, polymor-phism and parametrized types already available in C++.
Reference: [29] <author> B. Stroustrup. </author> <title> The C++ Programming Language (2nd Edition). </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: In relational query languages such as SQL, values in fields of tables have been restricted to be atomic constants (e.g. integers or strings). In logic programs, values can be Herbrand terms, which are essentially structured values. In Coral++, values can additionally be of any class definable in C++ <ref> [29] </ref>. (We chose C++ since it provides a well-understood and widely used object-oriented type system.) Coral++ provides support for maintaining extents or collections of objects of a given type, either in a simple manner that reflects the inclusions associated with traditional IS-A hierarchies, or in a more sophisticated way through the
Reference: [30] <author> K. Yokota, H. Tsuda, and Y. Morita. </author> <title> Specific features of a deductive object-oriented database language QUIXOTE. </title> <booktitle> In Proceedings of the Workshop on Combining Declarative and Object-Oriented Databases, </booktitle> <pages> pages 89-99, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: There are several other interesting proposals for combining semantically rich data models with deductive databases that are less closely related to Coral++. ConceptBase [11] and Quixote <ref> [30] </ref> are two such systems. ConceptBase is based on the Telos knowledge representation language, and allows the specification of methods using deductive rules and integrity constraints.
References-found: 30

