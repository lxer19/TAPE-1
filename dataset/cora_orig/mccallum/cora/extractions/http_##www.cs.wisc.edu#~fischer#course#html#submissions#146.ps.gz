URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/146.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/
Root-URL: http://www.cs.wisc.edu
Title: Optimizing Compilation of Constraint Logic Programming Languages  
Author: Andrew D. Kelly Andrew Macdonald Kim Marriott Peter J. Stuckey Roland H.C. Yap 
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> H. At-Kaci. </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The optimizing compiler has four main components (see Figure 1): the optimizer which performs the optimizations; a global analyzer and a constraint solver which provide information to guide the optimizer; and a code generator which produces CLAM abstract machine code. CLAM is an extension of the Prolog WAM <ref> [1] </ref> architecture which supports calls to constraint solvers. The main complication in the design of the optimizer is the number of different optimizations. This is exacerbated by non-trivial interaction between the optimizations.

Reference: [3] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation and application to logic programs. </title> <journal> Journal of Logic Programming 13 (2&3): </journal> <pages> 103-179, </pages> <year> 1992. </year>
Reference-contexts: Our analyzer is based on abstract interpretation of logic programs and constraint logic programs <ref> [3, 14, 15] </ref> in which operations in the execution of the goal are mimicked by abstract operations on the domain of descriptions. As an example consider the following Fibonacci program.
Reference: [4] <author> J. Darlington, Y. Guo and H. </author> <title> Pull. A new perspective on integrating functional and logic languages. </title> <booktitle> Proc. Fifth Generation Computer Systems, </booktitle> <pages> 682-693. </pages> <address> Tokyo, </address> <year> 1992. </year>
Reference-contexts: optimizations and compiler design are specific to CLP (R) , the general ideas behind the optimizations and compiler design are applicable to any CLP language and also to other constraint programming paradigms such as concurrent constraint programming languages [19], constraint databases [7], constraint imperative languages [5] and constraint functional languages <ref> [4] </ref>. The main contributions of this paper are: * A general design for optimizing compilers of CLP languages.
Reference: [5] <author> B. Freeman-Benson and A. Borning. </author> <title> The design and implementation of Kaleidoscope'90: A constraint imperative programming language. </title> <booktitle> Proc. IEEE Int. Conf. Computer Languages, </booktitle> <pages> 174-180. </pages> <publisher> IEEE Computer Soc. Press, </publisher> <year> 1992. </year>
Reference-contexts: Although some details of the optimizations and compiler design are specific to CLP (R) , the general ideas behind the optimizations and compiler design are applicable to any CLP language and also to other constraint programming paradigms such as concurrent constraint programming languages [19], constraint databases [7], constraint imperative languages <ref> [5] </ref> and constraint functional languages [4]. The main contributions of this paper are: * A general design for optimizing compilers of CLP languages.
Reference: [6] <author> M. Hermenegildo, G. Peubla, K. Marriott, and P. Stuckey. </author> <title> Incremental Analysis of Logic Programs. </title> <booktitle> In Proc. of the Int. Conf. on Logic Programming, </booktitle> <address> Tokyo, Japan, </address> <publisher> MIT Press, </publisher> <month> June </month> <year> 1995, </year> <pages> 797-814. </pages>
Reference-contexts: When rules are modified, then from correctness of the transformations, the analyzer knows that all success pattern information is still correct, meaning that in practice little additional analysis is needed. Details about the algorithms used can be found in <ref> [6] </ref>. Details of the description domains are deliberately kept insulated from the optimizer, so as to make it easier to change these. The most difficult condition to analyze for is deadness. This is because not being textually alive may not mean a variable is dead, for two reasons.
Reference: [7] <author> P.C. Kanellakis, G.M. Kuper and P. Revesz. </author> <title> Constraint query languages. </title> <booktitle> Proc. ACM Symp. Principles of Database Systems, </booktitle> <pages> 299-313, </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Although some details of the optimizations and compiler design are specific to CLP (R) , the general ideas behind the optimizations and compiler design are applicable to any CLP language and also to other constraint programming paradigms such as concurrent constraint programming languages [19], constraint databases <ref> [7] </ref>, constraint imperative languages [5] and constraint functional languages [4]. The main contributions of this paper are: * A general design for optimizing compilers of CLP languages.
Reference: [8] <author> A. Kelly, A. Macdonald, K. Marriott, H. Sonder-gaard, P. Stuckey, and R. Yap. </author> <title> An Optimizing Compiler for CLP(R). </title> <booktitle> In Proc of the First Int. Conf. on Principles and Practices of Constraint Programming, </booktitle> <publisher> LNCS 976, Springer-Verlag, </publisher> <pages> 222-239, </pages> <year> 1995. </year>
Reference-contexts: This paper continues our work on the implementation of CLP (R) <ref> [10, 9, 13, 8] </ref> and on preliminary studies of each of the optimizations considered here [11, 9, 17, 13, 16]. <p> The only other paper which describes an optimizing compiler for a CLP language, that we are aware of, is <ref> [8] </ref> which describes a preliminary version of this compiler which only provided three of the eight optimizations used in the current compiler. The main difference with this earlier work is that the analysis and optimization were each performed in a single static phase.
Reference: [9] <author> J. Jaffar, S. Michaylov, P. Stuckey and R. Yap. </author> <title> An abstract machine for CLP(R). </title> <booktitle> Proc. ACM Conf. Programming Language Design and Implementation, </booktitle> <pages> pages 128-139. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: This paper continues our work on the implementation of CLP (R) <ref> [10, 9, 13, 8] </ref> and on preliminary studies of each of the optimizations considered here [11, 9, 17, 13, 16]. <p> This paper continues our work on the implementation of CLP (R) [10, 9, 13, 8] and on preliminary studies of each of the optimizations considered here <ref> [11, 9, 17, 13, 16] </ref>. The only other paper which describes an optimizing compiler for a CLP language, that we are aware of, is [8] which describes a preliminary version of this compiler which only provided three of the eight optimizations used in the current compiler. <p> If so the rules are mutually exclusive and are combined into one rule using if then else. Code Generator The code generator maps the CLIC code into CLAM <ref> [9] </ref> instructions which are executed by the CLAM emulator. The original CLP (R) compiler also produced CLAM code, but used only a core set. The new compiler makes use of extended CLAM instructions for achieving the optimizations that are made possible by global analysis.
Reference: [10] <author> J. Jaffar, S. Michaylov, P. Stuckey and R. Yap. </author> <title> The CLP(R) language and system. </title> <booktitle> ACM Trans 11 actions on Programming Languages and Systems 14 (3): </booktitle> <pages> 339-395, </pages> <year> 1992. </year>
Reference-contexts: This paper continues our work on the implementation of CLP (R) <ref> [10, 9, 13, 8] </ref> and on preliminary studies of each of the optimizations considered here [11, 9, 17, 13, 16].
Reference: [11] <author> N. Jtrgensen, K. Marriott and S. Michaylov. </author> <title> Some global compile-time optimizations for CLP(R). </title> <editor> In V. Saraswat and K. Ueda, editors, </editor> <booktitle> Logic Programming: Proc. 1991 Int. Symp., </booktitle> <pages> pages 420-434. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: This paper continues our work on the implementation of CLP (R) [10, 9, 13, 8] and on preliminary studies of each of the optimizations considered here <ref> [11, 9, 17, 13, 16] </ref>. The only other paper which describes an optimizing compiler for a CLP language, that we are aware of, is [8] which describes a preliminary version of this compiler which only provided three of the eight optimizations used in the current compiler.
Reference: [12] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental evaluation of a generic abstract interpretation algorithm for Prolog. </title> <booktitle> ACM Transactions on Programming Languages and Systems 16 (1): </booktitle> <pages> 35-101, </pages> <year> 1994. </year>
Reference-contexts: To facilitate the rich variety of analyses required in the compiler, the analyzer is a generic tool like other analysis engines, such as PLAI [18] and GAIA <ref> [12] </ref> developed for Prolog. The core of the analyzer is an algorithm for efficient fixpoint computation. Efficiency is obtained by keeping track of which parts of a program must be reexamined when a success pattern is updated. The analyzer has two novel features.
Reference: [13] <author> A. Macdonald, P. Stuckey and R. Yap. </author> <title> Redundancy of variables in CLP(R). </title> <booktitle> In Logic Programming: Proc. 1993 Int. Symp., </booktitle> <pages> pages 75-93. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: This paper continues our work on the implementation of CLP (R) <ref> [10, 9, 13, 8] </ref> and on preliminary studies of each of the optimizations considered here [11, 9, 17, 13, 16]. <p> This paper continues our work on the implementation of CLP (R) [10, 9, 13, 8] and on preliminary studies of each of the optimizations considered here <ref> [11, 9, 17, 13, 16] </ref>. The only other paper which describes an optimizing compiler for a CLP language, that we are aware of, is [8] which describes a preliminary version of this compiler which only provided three of the eight optimizations used in the current compiler.
Reference: [14] <author> K. Marriott and H. Stndergaard. </author> <title> Analysis of constraint logic programs. </title> <editor> In S. Debray and M. Hermenegildo, </editor> <booktitle> Logic Programming: Proc. North American Conf. </booktitle> <year> 1990, </year> <pages> pages 531-547. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Our analyzer is based on abstract interpretation of logic programs and constraint logic programs <ref> [3, 14, 15] </ref> in which operations in the execution of the goal are mimicked by abstract operations on the domain of descriptions. As an example consider the following Fibonacci program.
Reference: [15] <author> K. Marriott, H. Stndergaard and N. D. Jones. </author> <title> Denotational abstract interpretation of logic programs. </title> <booktitle> ACM Transactions on Programming Languages and Systems 16 (3): </booktitle> <pages> 607-648, </pages> <year> 1994. </year>
Reference-contexts: Our analyzer is based on abstract interpretation of logic programs and constraint logic programs <ref> [3, 14, 15] </ref> in which operations in the execution of the goal are mimicked by abstract operations on the domain of descriptions. As an example consider the following Fibonacci program.
Reference: [16] <author> K. Marriott, H. Stndergaard, P. Stuckey and R. Yap. </author> <title> Optimizing compilation for CLP(R). </title> <editor> In G. Gupta, editor, </editor> <booktitle> Proc. Seventeenth Australian Computer Science Conf., Australian Computer Science Comm. </booktitle> <volume> 16 (1): </volume> <pages> 551-560, </pages> <year> 1994. </year>
Reference-contexts: This paper continues our work on the implementation of CLP (R) [10, 9, 13, 8] and on preliminary studies of each of the optimizations considered here <ref> [11, 9, 17, 13, 16] </ref>. The only other paper which describes an optimizing compiler for a CLP language, that we are aware of, is [8] which describes a preliminary version of this compiler which only provided three of the eight optimizations used in the current compiler.
Reference: [17] <author> K. Marriott and P. Stuckey. </author> <title> The 3 R's of optimizing constraint logic programs: Refinement, removal and reordering. </title> <booktitle> Proc. Twentieth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 334-344. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: This paper continues our work on the implementation of CLP (R) [10, 9, 13, 8] and on preliminary studies of each of the optimizations considered here <ref> [11, 9, 17, 13, 16] </ref>. The only other paper which describes an optimizing compiler for a CLP language, that we are aware of, is [8] which describes a preliminary version of this compiler which only provided three of the eight optimizations used in the current compiler.
Reference: [18] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-time derivation of variable dependency using abstract interpretation. </title> <journal> Journal of Logic Programming 13 (2&3): </journal> <pages> 315-347, </pages> <year> 1992. </year>
Reference-contexts: To facilitate the rich variety of analyses required in the compiler, the analyzer is a generic tool like other analysis engines, such as PLAI <ref> [18] </ref> and GAIA [12] developed for Prolog. The core of the analyzer is an algorithm for efficient fixpoint computation. Efficiency is obtained by keeping track of which parts of a program must be reexamined when a success pattern is updated. The analyzer has two novel features.
Reference: [19] <author> V. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Although some details of the optimizations and compiler design are specific to CLP (R) , the general ideas behind the optimizations and compiler design are applicable to any CLP language and also to other constraint programming paradigms such as concurrent constraint programming languages <ref> [19] </ref>, constraint databases [7], constraint imperative languages [5] and constraint functional languages [4]. The main contributions of this paper are: * A general design for optimizing compilers of CLP languages.
Reference: [20] <author> H. Stndergaard. </author> <title> An application of abstract interpretation of logic programs: Occur check reduction. </title> <editor> In B. Robinet and R. Wilhelm, editors, </editor> <booktitle> Proc. ESOP 86 (Lecture Notes in Computer Science 213), </booktitle> <pages> pages 327-338. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <month> 12 </month>
Reference-contexts: We use ROBDDs to repre sent the Boolean functions. CallAlive This consists of lists of variables which may be directly referenced later in execution. Shar This captures information about possible structure sharing of variables between Pro-log terms. It is based on descriptions introduced by Stndergaard <ref> [20] </ref> for eliminating occur checks in Prolog. The description consists of a possible sharing relation for variables. Consider the goal Y = f (X); p (X); Y = f (Z); q (Z). After Y = f (X), X and Y possibly share, but Z does not share with anything else.
References-found: 19

