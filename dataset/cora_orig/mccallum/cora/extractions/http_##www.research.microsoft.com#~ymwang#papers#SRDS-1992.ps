URL: http://www.research.microsoft.com/~ymwang/papers/SRDS-1992.ps
Refering-URL: http://www.research.microsoft.com/~ymwang/papers/SRDS92CR.htm
Root-URL: http://www.research.microsoft.com
Title: Optimistic Message Logging for Independent Checkpointing in Message-Passing Systems  
Author: Yi-Min Wang and W. Kent Fuchs 
Affiliation: Coordinated Science Laboratory University of Illinois at Urbana-Champaign  
Abstract: Message-passing systems with communication protocol transparent to the applications typically require message logging to ensure consistency between checkpoints. This paper describes a periodic independent checkpointing scheme with optimistic logging to reduce performance degradation during normal execution while keeping the recovery cost acceptable. Both time and space overhead for message logging can be reduced by detecting messages that need not be logged. A checkpoint space reclamation algorithm is presented to reclaim all checkpoints which are not useful for any possible future recovery. Communication trace-driven simulation for several hypercube programs is used to evaluate the techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. M. Chandy and L. Lamport, </author> <title> "Distributed snapshots: Determining global states of distributed systems," </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> Vol. 3, No. 1, </volume> <pages> pp. 63-75, </pages> <month> Feb. </month> <year> 1985. </year>
Reference-contexts: Since the low-level communication protocol is transparent to the applications, optimistic message logging protocol is employed to ensure the consistency between checkpoints without incurring large run-time overhead. Because the recovery line is unknown during normal execution for independent checkpointing, the problem of recording the state of the channels <ref> [1] </ref> through message logging is more involved than the case of coordinated checkpointing [14]. An algorithm is described for effectively reducing the number of messages requiring logging. A checkpoint space reclamation algorithm is also presented to further reduce the space overhead for maintaining multiple checkpoints. <p> Without such in formation, CP ik and CP jm in Fig. 3 (b) can not be considered as consistent unless message m is somehow recorded. By defining the state of the channels to be the set of messages sent but not yet received, Chandy and Lam-port <ref> [1] </ref> proved that checkpoints like CP ik and CP jm in Fig. 3 (b) can become consistent if the corresponding state of the channels is also recorded. Pessimistic logging can ensure that such a state is properly recorded at the receiving end.
Reference: [2] <author> R. Koo and S. Toueg, </author> <title> "Checkpointing and rollback-recovery for distributed systems," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. SE-13, No. 1, </volume> <pages> pp. 23-31, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: CP jm . Bhargava and Lian [8] defined consistency in such a way that CP ik and CP jm are considered consistent. Koo and Toueg <ref> [2] </ref> explained that the situation of restarting from CP ik and CP jm is indistinguishable from the situation that message m is lost during normal execution. Therefore, an end-to-end transmission protocol which can guarantee the redelivery of lost messages can also guarantee the resend-ing of message m during reexecution.
Reference: [3] <author> K. Li, J. F. Naughton, and J. S. Plank, </author> <title> "Check-pointing multicomputer applications," </title> <booktitle> in Proc. IEEE Symp. on Reliable Distr. Syst., </booktitle> <pages> pp. 2-11, </pages> <year> 1991. </year>
Reference-contexts: CP i (k+1) then has potential incoming rollback edges and all the checkpoints reachable from CP i (k+1) should be excluded from the checkpoint graph. 4 Reducing Overhead 4.1 Reducing message logging overhead The concept of recording channel state through message logging has typically been applied to coordinated checkpointing techniques <ref> [3, 14] </ref>. In these schemes, since only the checkpoints with the same checkpoint number can form a recovery line, messages comprising the state of the channels can be easily identified.
Reference: [4] <author> B. Randell, </author> <title> "System structure for software fault tolerance," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. SE-1, No. 2, </volume> <pages> pp. 220-232, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: In terms of checkpointing techniques, they can be classified into two basic categories. Coordinated checkpointing schemes synchronize computation with checkpointing by coordinating processes during a checkpointing session in order to maintain a consistent recovery line [1-3]. Each process only keeps the most recent successful checkpoint. Domino effect <ref> [4] </ref> is avoided at the cost of potentially significant performance degradation during normal execution. Independent checkpointing schemes replace the 1 Proc. IEEE 11th Symp. on Reliable Distributed Systems, pp. 147 - 154. <p> Traditional checkpoint space reclamation algorithms only reclaim obsolete checkpoints, i.e., checkpoints older than the global recovery line. All non-obsolete checkpoints are assumed to be possibly useful for future recovery and therefore need to be kept on stable storage. When the domino effect <ref> [4] </ref> occurs, a large number of non-obsolete checkpoints result in large space overhead. We define a discardable checkpoint as a checkpoint that will never belong to any future recovery line. Obsolete checkpoints are clearly discardable. We give an example to show that some of the non-obsolete checkpoints are also discardable.
Reference: [5] <author> K. Tsuruoka, A. Kaneko, and Y. Nishihara, </author> <title> "Dynamic recovery schemes for distributed processes," </title> <booktitle> in Proc. IEEE 2nd Symp. on Reliability in Distributed Software and Database, </booktitle> <pages> pp. 124-130, </pages> <year> 1981. </year>
Reference-contexts: A centralized checkpoint space reclamation algorithm [17] can be invoked by any processor occasionally to reduce the space overhead. First, the communication information for all existing checkpoints is collected to construct the checkpoint graph <ref> [5] </ref> (Fig. 2 (c)). <p> Each surviving processor takes a virtual checkpoint upon receiving the rollback initiating message (Fig. 2 (a) and (b)). After receiving the responses, p i constructs the extended checkpoint graph <ref> [5] </ref> and executes the rollback propagation algorithm to determine the local recovery line (Fig. 2 (d)). A rollback request message is then broadcast to roll back each processor according to the local recovery line. 3 Temporary Inconsistency 3.1 Checkpoint consistency There are two situations concerning the consistency between two checkpoints.
Reference: [6] <author> R. E. Strom and S. Yemini, </author> <title> "Optimistic recovery in distributed systems," </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> Vol. 3, No. 3, </volume> <pages> pp. 204-226, </pages> <month> Aug. </month> <year> 1985. </year>
Reference-contexts: Pessimistic logging protocols [10, 11] log each message synchronously, i.e., the receiver is blocked until the message is logged on stable storage. Faster recovery is achieved at the expense of greater run-time overhead or specialized hardware. Optimistic logging protocols <ref> [6, 9, 12, 13] </ref> log messages asynchronously. Several messages can be grouped together and written to the stable storage in a single operation to reduce the logging overhead. Messages not yet logged when a rollback is initiated can cause slower recovery. <p> Processes are assumed to run on fail-stop processors [15] and each processor is considered as an individual recovery unit <ref> [6] </ref>. We do not assume deterministic execution. Therefore, if the sender of a message is rolled back, the corresponding message log will be invalid during reexecution, which means that the receiver also has to be rolled back.
Reference: [7] <author> K. H. Kim, J. H. You, and A. Abouelnaga, </author> <title> "A scheme for coordinated execution of independently designed recoverable distributed processes," </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 130-135, </pages> <year> 1986. </year>
Reference: [8] <author> B. Bhargava and S. R. Lian, </author> <title> "Independent check-pointing and concurrent rollback for recovery An optimistic approach," </title> <booktitle> in Proc. IEEE Symp. on Reliable Distr. Syst., </booktitle> <pages> pp. 3-12, </pages> <year> 1988. </year>
Reference-contexts: Several messages can be grouped together and written to the stable storage in a single operation to reduce the logging overhead. Messages not yet logged when a rollback is initiated can cause slower recovery. This paper considers independent checkpointing schemes for possibly nondeterministic execution <ref> [8] </ref>. We address the problems of application-level check-pointing for systems in which applications access the message-passing capabilities through system calls. Since the low-level communication protocol is transparent to the applications, optimistic message logging protocol is employed to ensure the consistency between checkpoints without incurring large run-time overhead. <p> Each message is tagged with the current checkpoint interval number and the processor number of the sender. Each processor takes its checkpoint independently and updates the communication information table (or input table <ref> [8] </ref>) as follows: if at least one message from the mth checkpoint interval of processor p j has been processed during the previous checkpoint interval, the pair (j; m) is added to the table entry for the new checkpoint (Fig. 2 (b)). <p> All the checkpoints taken before the global recovery line then become obsolete and their space can therefore be reclaimed. When processor p i initiates a rollback, it sends out a rollback initiating message <ref> [8] </ref> to every other processor to request the up-to-date communication information. Each surviving processor takes a virtual checkpoint upon receiving the rollback initiating message (Fig. 2 (a) and (b)). <p> A local recovery line is used when a subset of processors becomes faulty. (c) checkpoint graph for space reclamation, (d) extended checkpoint graph when p 1 initiates a rollback. but not yet sent, (b) message sent but not yet received. CP jm . Bhargava and Lian <ref> [8] </ref> defined consistency in such a way that CP ik and CP jm are considered consistent. Koo and Toueg [2] explained that the situation of restarting from CP ik and CP jm is indistinguishable from the situation that message m is lost during normal execution.
Reference: [9] <author> D. B. Johnson and W. Zwaenepoel, </author> <title> "Recovery in distributed systems using optimistic message logging and checkpointing," </title> <journal> J. of Algorithms, </journal> <volume> Vol. 11, </volume> <pages> pp. 462-491, </pages> <year> 1990. </year>
Reference-contexts: Pessimistic logging protocols [10, 11] log each message synchronously, i.e., the receiver is blocked until the message is logged on stable storage. Faster recovery is achieved at the expense of greater run-time overhead or specialized hardware. Optimistic logging protocols <ref> [6, 9, 12, 13] </ref> log messages asynchronously. Several messages can be grouped together and written to the stable storage in a single operation to reduce the logging overhead. Messages not yet logged when a rollback is initiated can cause slower recovery.
Reference: [10] <author> A. Borg, J. Baumbach, and S. Glazer, </author> <title> "A message system supporting fault-tolerance," </title> <booktitle> in Proc. 9th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pp. 90-99, </pages> <year> 1983. </year>
Reference-contexts: Lower run-time overhead during normal execution is achieved by maintaining multiple checkpoints and allowing slower recovery. In terms of message logging techniques, there are also two primary categories: pessimistic and optimistic. Pessimistic logging protocols <ref> [10, 11] </ref> log each message synchronously, i.e., the receiver is blocked until the message is logged on stable storage. Faster recovery is achieved at the expense of greater run-time overhead or specialized hardware. Optimistic logging protocols [6, 9, 12, 13] log messages asynchronously.
Reference: [11] <author> M. L. Powell and D. L. Presotto, </author> <title> "Publishing: A reliable broadcast communication mechanism," </title> <booktitle> in Proc. 9th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pp. 100-109, </pages> <year> 1983. </year>
Reference-contexts: Lower run-time overhead during normal execution is achieved by maintaining multiple checkpoints and allowing slower recovery. In terms of message logging techniques, there are also two primary categories: pessimistic and optimistic. Pessimistic logging protocols <ref> [10, 11] </ref> log each message synchronously, i.e., the receiver is blocked until the message is logged on stable storage. Faster recovery is achieved at the expense of greater run-time overhead or specialized hardware. Optimistic logging protocols [6, 9, 12, 13] log messages asynchronously.
Reference: [12] <author> A. P. Sistla and J. L. Welch, </author> <title> "Efficient distributed recovery using message logging," </title> <booktitle> in Proc. 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 223-238, </pages> <year> 1989. </year>
Reference-contexts: Pessimistic logging protocols [10, 11] log each message synchronously, i.e., the receiver is blocked until the message is logged on stable storage. Faster recovery is achieved at the expense of greater run-time overhead or specialized hardware. Optimistic logging protocols <ref> [6, 9, 12, 13] </ref> log messages asynchronously. Several messages can be grouped together and written to the stable storage in a single operation to reduce the logging overhead. Messages not yet logged when a rollback is initiated can cause slower recovery.
Reference: [13] <author> E. N. Elnozahy and W. Zwaenepoel, "Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit," </title> <journal> IEEE Trans. on Computers, </journal> <volume> Vol. 41, No. 5, </volume> <pages> pp. 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Pessimistic logging protocols [10, 11] log each message synchronously, i.e., the receiver is blocked until the message is logged on stable storage. Faster recovery is achieved at the expense of greater run-time overhead or specialized hardware. Optimistic logging protocols <ref> [6, 9, 12, 13] </ref> log messages asynchronously. Several messages can be grouped together and written to the stable storage in a single operation to reduce the logging overhead. Messages not yet logged when a rollback is initiated can cause slower recovery.
Reference: [14] <author> F. Cristian and F. Jahanian, </author> <title> "A timestamp-based checkpointing protocol for long-lived distributed computations," </title> <booktitle> in Proc. IEEE Symp. on Reliable Distr. Syst., </booktitle> <pages> pp. 12-20, </pages> <year> 1991. </year>
Reference-contexts: Because the recovery line is unknown during normal execution for independent checkpointing, the problem of recording the state of the channels [1] through message logging is more involved than the case of coordinated checkpointing <ref> [14] </ref>. An algorithm is described for effectively reducing the number of messages requiring logging. A checkpoint space reclamation algorithm is also presented to further reduce the space overhead for maintaining multiple checkpoints. This paper is organized as follows. <p> CP i (k+1) then has potential incoming rollback edges and all the checkpoints reachable from CP i (k+1) should be excluded from the checkpoint graph. 4 Reducing Overhead 4.1 Reducing message logging overhead The concept of recording channel state through message logging has typically been applied to coordinated checkpointing techniques <ref> [3, 14] </ref>. In these schemes, since only the checkpoints with the same checkpoint number can form a recovery line, messages comprising the state of the channels can be easily identified. <p> The average rollback distance for the coordinated checkpointing scheme is approximately (0 + 1)=2 = 0:5 checkpoint intervals. The actual number should be slightly higher because a certain amount of time has to be spent in receiving and logging the messages comprising the channel states <ref> [14] </ref>. The following remarks are made based on the fact that the average rollback distances shown in Table 1 range from 0.97 to 1.90 checkpoint intervals for the four programs: 1.
Reference: [15] <author> R. D. Schlichting and F. B. Schneider, </author> <title> "Fail-stop processors: An approach to designing fault-tolerant computing systems," </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> Vol. 1, No. 3, </volume> <pages> pp. 222-238, </pages> <month> Aug. </month> <year> 1983. </year>
Reference-contexts: Processes are assumed to run on fail-stop processors <ref> [15] </ref> and each processor is considered as an individual recovery unit [6]. We do not assume deterministic execution. Therefore, if the sender of a message is rolled back, the corresponding message log will be invalid during reexecution, which means that the receiver also has to be rolled back.
Reference: [16] <author> S. F. </author> <title> Nugent, </title> <booktitle> "The iPSC/2 direct-connect communications technology," in Proc. 3rd ACM Hypercube Conf., </booktitle> <pages> pp. 384-390, </pages> <year> 1988. </year>
Reference-contexts: Such systems hide the detailed communication protocol from the user. As a result, information such as "a certain message has arrived at its destination" or "a message has been lost" is typically not available to the applications <ref> [16] </ref>. During normal execution, the state of each processor is periodically saved as a checkpoint on stable storage. Let CP ik denote the kth checkpoint of processor p i with k 0 and 0 i N 1, where N is the number of processors.
Reference: [17] <author> Y. M. Wang, P. Y. Chung, I. J. Lin, and W. K. Fuchs, </author> <title> "Reducing space overhead for independent check-pointing," </title> <type> Tech. Rep. </type> <institution> CRHC-92-06, Coordinated Science Laboratory, University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: A centralized checkpoint space reclamation algorithm <ref> [17] </ref> can be invoked by any processor occasionally to reduce the space overhead. First, the communication information for all existing checkpoints is collected to construct the checkpoint graph [5] (Fig. 2 (c)). <p> By using the model of maximum-sized antichains on a partially ordered set [19, 20] to predict the possibility for a checkpoint to become part of any future recovery line, the following necessary and sufficient condition for a checkpoint to be non-discardable has been derived. Interested readers are referred to <ref> [17] </ref> for detailed proofs. THEOREM 2 Let N be the number of processors and ^ G be the supergraph of a checkpoint graph G as shown in Fig. 7. <p> Notice that all the checkpoints marked "X" in Fig. 8 (d) are discardable whereas only the leftmost four checkpoints are obsolete. 3 The situation becomes more complicated when some checkpoints can be removed from the checkpoint graph due to rollback recovery. We have been able to show that <ref> [17] </ref> all the results in this subsection are also valid for such a situation. Table 1: Execution parameters and message logging overhead.
Reference: [18] <author> Z. Tong, R. Y. Kain, and W. T. Tsai, </author> <title> "Rollback recovery in distributed systems using loosely synchronized clocks," </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> Vol. 3, No. 2, </volume> <pages> pp. 246-251, </pages> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: In Fig. 3 (a), if p i and p j restart from the checkpoints CP ik and CP jm respectively, the message m will be recorded as "received but not yet sent". Without the assumption of deterministic execution, message m becomes an orphan message <ref> [18] </ref>. CP ik and CP jm are thus inconsistent. Fig. 3 (b) illustrates the second situation.
Reference: [19] <author> L. Lamport, </author> <title> "Time, clocks and the ordering of events in a distributed system," </title> <journal> Comm. of the ACM, </journal> <volume> Vol. 21, No. 7, </volume> <pages> pp. 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Since a recovery line must contain one checkpoint from each processor, CP 02 will never belong to any recovery line and is therefore discardable 3 . CP 11 and CP 01 are discardable by similar arguments. By using the model of maximum-sized antichains on a partially ordered set <ref> [19, 20] </ref> to predict the possibility for a checkpoint to become part of any future recovery line, the following necessary and sufficient condition for a checkpoint to be non-discardable has been derived. Interested readers are referred to [17] for detailed proofs.
Reference: [20] <author> I. Anderson, </author> <title> Combinatorics of finite sets. </title> <publisher> Clarendon Press, Oxford, </publisher> <year> 1987. </year>
Reference-contexts: Since a recovery line must contain one checkpoint from each processor, CP 02 will never belong to any recovery line and is therefore discardable 3 . CP 11 and CP 01 are discardable by similar arguments. By using the model of maximum-sized antichains on a partially ordered set <ref> [19, 20] </ref> to predict the possibility for a checkpoint to become part of any future recovery line, the following necessary and sufficient condition for a checkpoint to be non-discardable has been derived. Interested readers are referred to [17] for detailed proofs.
Reference: [21] <author> K. Li, J. F. Naughton, and J. S. Plank, </author> <title> "Real-time, concurrent checkpointing for parallel programs," </title> <booktitle> in Proc. 2nd ACM SIGPLAN Symp. on Principles and Practice of Parallel Programming, </booktitle> <pages> pp. 79-88, </pages> <month> Mar. </month> <year> 1990. </year>
Reference-contexts: The periodic checkpointing routine is implemented as the interrupt service routine for UNIX alarm (T) system call, where T is the checkpoint interval in seconds. A concurrent checkpointing algorithm <ref> [21] </ref> is assumed so that the program thread is interrupted for a small, fixed amount of time (0.1 seconds) for taking each checkpoint, after which the checkpoint-ing thread executes concurrently with the program thread to finish the checkpointing. Communication traces are collected by intercepting the "send" and "receive" system calls.
Reference: [22] <author> Y. M. Wang and W. K. Fuchs, </author> <title> "Scheduling message processing for reducing rollback propagation," </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 204-211, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: The domino effect does occur with an independent checkpointing scheme but the average rollback distances are acceptable at least for the four programs tested. 2. Applications with independent checkpointing can benefit from the techniques for reducing rollback propagation (e.g., <ref> [22] </ref>) and for reducing the space overhead (e.g., the PCSR algorithm). Table 1 also shows the average overhead for message logging. The number of logged messages is only a very small portion (less than 2 percent) of the total number of messages.
References-found: 22

