URL: ftp://ftp.cs.unc.edu/pub/publications/techreports/90-029.ps.Z
Refering-URL: http://www.cs.unc.edu/Info/Publications/PHDAbstracts.html
Root-URL: http://www.cs.unc.edu
Title: CLIN An Automated Reasoning System Using Clause Linking  
Author: Advisor: David A. Plaisted Reader: Donald W. Loveland Reader: Gopalan Nadathur 
Degree: by Shie-Jue Lee A Dissertation submitted to the faculty of the  in partial fulfillment of the requirements for the degree of Doctor of Philosophy in the  Approved by:  
Date: 1990  
Address: Chapel Hill  Chapel Hill  
Affiliation: University of North Carolina at  Department of Computer Science.  
Abstract-found: 0
Intro-found: 1
Reference: [Aba87] <author> M. Abadi. </author> <title> Temporal-Logic Theorem Proving. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1987. </year>
Reference: [ALS88] <institution> Applied Logic Systems, Inc. </institution> <note> ALS Prolog User's Guide and Reference Manual. </note> <institution> Syracuse, </institution> <address> New York, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: The times spent on these problems for different proving systems are listed in Table 7.1. All the times are obtained on a SUN3/60M workstation with 12 MB memory. The prolog system used for running PTTP, "sprfn", and CLIN is ALS-Prolog (Version 0.60) of Applied Logic System, Inc. <ref> [ALS88] </ref>. <p> All the times are obtained on a SUN3/60M workstation with 12 MB memory. The prolog system used for running PTTP, "sprfn", and CLIN is ALS-Prolog (Version 0.60) of Applied Logic System, Inc. <ref> [ALS88] </ref>. The statistics for OTTER are taken from [Nie89]. The strategies used are hyperresolution and UR resolution together, plus forward and backward subsumptions. A correct set of support clauses have to be supplied to OTTER for many problems, marked by "*" in the table, in order to get the proof. <p> Problems 112-115 are implicational calculus theorems. The problem "freuder" is a constraint satisfaction problem taken from Freuder's paper [Fre78]. Problems 117-120 are logic puzzles taken from [SS86][WOLB84]. All the times are obtained by running ALS-Prolog (Version 0.60) of Applied Logic System, Inc. <ref> [ALS88] </ref> on a SUN3/60M workstation with 12 MB memory. We use user support for problems "wos20" and "wos31", and replace rules for problems "ls118" and "ls121". An entry with "***" means we had memory allocation problem; thrashing occurred due to inadequate main memory of the workstation. <p> There are a number of user settable flags, but many of them are for experimentation and can be ignored under normal use. CLIN is written in Prolog. It can be run with either C-Prolog [Per84] or ALS-Prolog <ref> [ALS88] </ref>. CLIN can be used in an automatic way, that is, by triggering the top-level supervisor. It can also be used in a controlled way; the user specifies desired options and decides support strategies before the prover tries on the input problem.
Reference: [And81] <author> P. B. Andrews. </author> <title> Theorem proving via general matching. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28 </volume> <pages> 193-214, </pages> <year> 1981. </year>
Reference-contexts: If there are n literals, there may be up to n 2 connections between them. This can be a large number of connections, and may require excessive storage and time to process. The mating strategy of <ref> [And81] </ref> is similar to the connection graph method and has similar properties. In fact, the mating strategy is much like the linked conjunct procedure of [Dav63]. Since it explicitly constructs links, or connections, between literals, the number of links with a particular literal may be much larger than two.
Reference: [BH80] <author> W. W. Bledsoe and L. Hines. </author> <title> Variable elimination and chaining in a resolution-based prover for inequalities. </title> <booktitle> In Proceedings of the 5th International Conference on Automated Deduction, </booktitle> <pages> pages 70-87, </pages> <year> 1980. </year>
Reference-contexts: This completes the proof. One would think that such a simple proof would be easy for a computer. However, most provers cannot obtain this proof. One of the few that can is the prover of Bledsoe and Hines <ref> [BH80] </ref> at Austin, which uses special inference rules for dense linearly ordered sets. Note that most of the inference steps involve reasoning about terms that have already been constructed, and not many involve constructing new terms, except in certain reasonable ways.
Reference: [Bib82] <author> W. Bibel. </author> <title> Automated Theorem Proving. </title> <publisher> Vieweg, </publisher> <year> 1982. </year>
Reference-contexts: This has advantages and disadvantages. The 7 # # - -? ? ? ? detector contradiction generator clause clause empty fail fail pass simplification unit replacement predicate input clauses hyper-linking small proof checking propositional unsatisfiability test done pass 8 connection graph methods of <ref> [Bib82] </ref> are close to ours, but even these combine literals from different clauses. We feel that instance-based approaches deserve more attention, and our experience with our implementation confirms this belief. <p> An extension of this to a unification-based prover was attempted, without much success [PM88]. A key to our current success seems to be that we do not store any links between clauses, which sets our method apart from the connection graph resolution of <ref> [Bib82] </ref> which relies heavily on such links. Also, another key to our success is the idea of hyper-linking, that is, considering all the literals in a clause at the same time, rather than one by one as in the previous attempts. <p> We treat (L, M) and (M,L) as identical. Note that this is essentially the same as a connection in Kowalski's proving procedure for Horn clauses [Kow75] or in the connection graph resolution <ref> [Bib82] </ref>, except that we don't explicitly store the links, so that they cannot be deleted as they are in Kowalski's proving procedure or the connection graph resolution. Definition. Suppose S is a set of clauses.
Reference: [Ble77] <author> W. W. Bledsoe. </author> <title> Non-resolution theorem proving. </title> <journal> Artificial Intelligence, </journal> <volume> 9 </volume> <pages> 1-35, </pages> <year> 1977. </year>
Reference-contexts: The proof size is 0 + 1 + 0 = 1. Therefore, "LS100" is unsatisfiable. Example 3.4 The following problem is "exx5", a verification condition from Hoare's FIND program <ref> [Ble77] </ref>: 1. C 1 = flt (j, i)g 3. C 3 = fle (p, q)g 5. C 5 = f:le (b (p), b (q))g 7. <p> Problems 1-93 are from Stickel's paper [Sti86]. The problem "example" is a theorem presented by Pellitier and Rudnicki in AAR Newsletter No. 6, 1986. The problem "exx5" is a verification condition from Hoare's FIND program <ref> [Ble77] </ref>. The problem "exx7" is a situation calculus theorem developed by David Plaisted [Pla82]. "latinsq" is the latin square problem from [Rob63]. "liar" is the truthtellers and liars problem [LO85]. "salt" is the salt and mustard problem from Lewis Carroll [LO85]. The problem "schubert" is Schubert's steamroller [Wal84].
Reference: [BLM + 86] <author> R. Boyer, E. Lusk, W. McCune, R. Overbeek, M. Stickel, and L. Wos. </author> <title> Set theory in first-order logic: Clauses for Godel's axioms. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 2 </volume> <pages> 287-327, </pages> <year> 1986. </year>
Reference-contexts: With appropriate guidance, the search space may be much reduced and the prover is less likely to get lost. One typical example of this kind is set theory <ref> [BLM + 86] </ref>. Some "natural deduction" system theorem provers can prove set theory theorems quickly by simulating a human's capability of replacing predicates by definitions using explicit quantifiers. Unfortunately, these definitions with explicit quantifiers cannot be used directly in CLIN since it is a quantifier-free system.
Reference: [CL73] <author> C. Chang and R. Lee. </author> <title> Symbolic Logic and Mechanical Theorem Proving. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1973. </year>
Reference-contexts: The first case is proved by Theorem 3.8. Consider the second case. A deleted literal is either unifiable with or subsumed by a unit clause. By the lifting lemma <ref> [CL73] </ref>, if a small proof can be found with this clause as nucleus then a small proof can also be found with the input clause from which it was generated as nucleus. Of course, more electrons are needed for the input clause. <p> Here are the steps for converting the definition into replace rules: 1. Transform the definition to clauses. The definition is generally written in first-order formula. We may do skolemization to take care of existential quantifiers. For more details about the transformation of first-order formula to clause form, see <ref> [CL73, Lov78] </ref>. 2. For each clause C, we pick distinguished literals, negate them, and place them at the left-hand side of !. The remaining literals are placed at the right-hand side of !. Usually, literals containing the predicate being defined are made into distinguished literals.
Reference: [Coo71] <author> S. A. Cook. </author> <title> The complexity of theorem-proving procedures. </title> <booktitle> In Proceedings of the 3rd Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 151-158, </pages> <year> 1971. </year>
Reference-contexts: The motivation of our propositional calculus prover is to remove such unnecessary duplication. Our propositional calculus prover always performs as well as the Davis-Putnam procedure on the problems tested, and for some problems it performs much better. Although the satisfiability problem is NP-complete <ref> [Coo71] </ref>, we have found that the time taken by the propositional calculus prover is usually much smaller than the time taken by the other steps of the system. Therefore, even if P = NP, this would not help most of the time.
Reference: [DaPu60] <author> M. Davis and H. Putnam. </author> <title> A computing procedure for quantification theory. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 7 </volume> <pages> 201-215, </pages> <year> 1960. </year>
Reference-contexts: The same instances of a clause can contribute to many resolvents, for example. The second kind of duplication is duplication by case analysis. This appears in the linked conjunct procedure of [Dav63] as well as in the Davis-Putnam propositional calculus decision procedure <ref> [DaPu60] </ref>. The same instances of clauses may appear in more than one case of a case analysis, although in each case there may be no duplication. Some early provers used duplication by case analysis, but few if any clause form provers currently 4 use it. <p> If Gr (S) is unsatisfiable, then the 16 ground instantiation problem has been solved and we know S is unsatisfiable. Otherwise, more rounds of hyper-linking and so on, are done. The propositional calculus prover is a modification of the Davis-Putnam procedure <ref> [DaPu60] </ref>. It uses a technique similar to dependency-directed backtracking [dK86a][dK89] and McAllester's RUP [McA80][McA82] in the area of Artificial Intelligence. One disadvantage of the Davis-Putnam procedure is that it carries out two cases in a case analysis all the time, which results in unnecessary duplication by case analysis.
Reference: [Dav63] <author> M. Davis. </author> <title> Eliminating the irrelevant from machanical proofs. </title> <booktitle> In Proceedings Symp. of Applied Math, </booktitle> <volume> volume 15, </volume> <pages> pages 15-30, </pages> <year> 1963. </year>
Reference-contexts: This appears in resolution, model elimination, the connection graph method, and other strategies. The same instances of a clause can contribute to many resolvents, for example. The second kind of duplication is duplication by case analysis. This appears in the linked conjunct procedure of <ref> [Dav63] </ref> as well as in the Davis-Putnam propositional calculus decision procedure [DaPu60]. The same instances of clauses may appear in more than one case of a case analysis, although in each case there may be no duplication. <p> Then the literals in Cfi i may appear in many different resolvents. This is another kind of duplication by combination. Duplication by combination occurs for similar reasons in model elimination and the connection graph method. The linked conjunct procedure of <ref> [Dav63] </ref> involves duplication by case analysis. Given a set S of clauses, a linked conjunct is obtained by matching the literals in clauses in S in different ways. Each matching has to be looked at separately; each such matching is another case to be considered. <p> This can be a large number of connections, and may require excessive storage and time to process. The mating strategy of [And81] is similar to the connection graph method and has similar properties. In fact, the mating strategy is much like the linked conjunct procedure of <ref> [Dav63] </ref>. Since it explicitly constructs links, or connections, between literals, the number of links with a particular literal may be much larger than two. Mating appears to have duplication by case analysis rather than duplication by combination, since matings are constructed and considered one by one. <p> clauses is a real problem for theorem proving, and that an instance-based approach which is able to eliminate such duplication may be superior to other approaches. 1.6 Related Work Some of the early work in theorem proving was similar in spirit to ours, such as the linked conjunct procedure of <ref> [Dav63] </ref>. Even the methods of [Gil60][PPV60] have similarities to ours. However, they also have significant differences. Gilmore's procedure is not based on unification. This means that the number of instances generated may be very large. The Prawitz procedure and the linked conjunct procedure are based on something like unification. <p> This means that the number of instances generated may be very large. The Prawitz procedure and the linked conjunct procedure are based on something like unification. However, they both consider a large number of possibilities for which literals to unify, resulting in many cases to consider. The paper <ref> [Dav63] </ref> (linked conjunct procedure) also doesn't explicitly give a completeness proof or a method of generating instances. Our method is based on unification but does not generate such a large number of cases. In this our method is similar to resolution. <p> The use of support strategies, explained later, is also important. Finally, in previous strategies [JP84][PM88], a "fully linked subset," was computed which was essentially the same as the linked conjunct of <ref> [Dav63] </ref>.
Reference: [DePe88] <author> R. Dechter and J. Pearl. </author> <title> Network-based heuristics for constraint satisfaction problems. </title> <journal> Artificial Intelligence, </journal> <volume> 34 </volume> <pages> 1-38, </pages> <year> 1988. </year>
Reference: [Der82] <author> N. Dershowitz. </author> <title> Orderings for term-rewriting systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 17 </volume> <pages> 279-301, </pages> <year> 1982. </year>
Reference-contexts: This problem can be addressed with a priority system that will be described later. However, we do give some general conditions guaranteeing termination. Here we apply some ideas similar to those used to show termination of term rewriting systems <ref> [Der82] </ref> to prove termination of replacements. Definition. An ordering on literals is called a replacement ordering if this ordering is reflexive and transitive and has the property that if L - M then for all substitutions fi, Lfi - Mfi.
Reference: [dK86a] <author> J. de Kleer. </author> <title> An assumption-based TMS. </title> <journal> Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 127-162, </pages> <year> 1986. </year>
Reference: [dK86b] <author> J. de Kleer. </author> <title> Problem solving with the ATMS. </title> <journal> Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 197-224, </pages> <year> 1986. </year>
Reference: [dK89] <author> J. de Kleer. </author> <title> A comparison of ATMS and CSP techniques. </title> <booktitle> In Proceedings of 11th International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 290-296, </pages> <year> 1989. </year>
Reference-contexts: Constraint preprocessing has been proposed to eliminate such maladies [Mac77][Fre78]. However, the expense of the preprocessing to avoid all futile backtracks typically outweighs the cost of the futile backtracks in the first place <ref> [dK89] </ref>. CLIN seems to be able to solve CSPs efficiently. One important feature of CLIN is to eliminate futile duplications which include futile backtracks. We don't need preprocessing as was required in [Mac77][Fre78]. Example 9.1 Let's solve Freuder's example mentioned above. For clarity, we restate the problem here.
Reference: [Fre78] <author> E. C. Freuder. </author> <title> Synthesizing constraint expressions. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 21 </volume> <pages> 958-966, </pages> <year> 1978. </year>
Reference-contexts: The constraint satisfaction task consists of finding all sets of values a 1j 1 , : : : , a 1j n for x 1 , : : : , x n that simultaneously satisfy all the given constraints. Consider the following example from Freuder <ref> [Fre78] </ref>. <p> The problem "schubert" is Schubert's steamroller [Wal84]. The stack problem is a proof of a trivial property of push down stores. Problems 104-111 are pigeonhole problems from Pelletier's paper [Pel86]. Problems 112-115 are implicational calculus theorems. The problem "freuder" is a constraint satisfaction problem taken from Freuder's paper <ref> [Fre78] </ref>. Problems 117-120 are logic puzzles taken from [SS86][WOLB84]. All the times are obtained by running ALS-Prolog (Version 0.60) of Applied Logic System, Inc. [ALS88] on a SUN3/60M workstation with 12 MB memory. We use user support for problems "wos20" and "wos31", and replace rules for problems "ls118" and "ls121".
Reference: [Gil60] <author> P. C. Gilmore. </author> <title> A proof method for quantification theory. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 4 </volume> <pages> 28-35, </pages> <year> 1960. </year>
Reference-contexts: The idea also makes CLIN more self-guiding, requiring less input and insight from the user. Furthermore, the idea can be easily applied to any other prover using breadth-first search strategies, such as the resolution method [Rob65] and Gilmore's procedure <ref> [Gil60] </ref>. 5.1 Descriptions 5.1.1 Basic Idea Suppose we decide in advance that we only want to store b clauses at one time. We call b the work bound. Each clause has a priority, which is an integer giving its size and/or some other measure of complexity.
Reference: [Hin88] <author> L. Hines. </author> <title> Hyper-chaining and knowledge-based theorem proving. </title> <booktitle> In Proceedings of the 9th International Conference on Automated Deduction, </booktitle> <pages> pages 469-486, </pages> <year> 1988. </year>
Reference-contexts: By low-level heuristics, we mean such methods as preferring terms that are small, 5 or contain a small number of variables, and so on. Some of the methods used in theorem proving, such as variable elimination <ref> [Hin88] </ref> and the complexity measure of Wang [WB87], successful though they are, seem to be mysterious, since it is unlikely that a human would use such methods. We believe that a theorem prover which works well with these low-level heuristics provides a better rational reconstruction of human theorem proving activity.
Reference: [HW74] <author> L. Henschen and L. Wos. </author> <title> Unit refutations and Horn sets. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 21 </volume> <pages> 590-605, </pages> <year> 1974. </year>
Reference-contexts: For example, it is complete to only delete instances of non-forward supported clauses. The reason is that eventually all the instances needed will be forward supported, and therefore retained. Also, if the set of input clauses is a Horn set <ref> [HW74] </ref>, then unit resolution is complete, and all instances can be deleted. In fact, instance deletion is complete whenever unit resolution suffices to obtain a proof, although this may not be known in advance. We have obtained significant improvements on some problems using these ideas, but significant slowdowns on others.
Reference: [JP84] <author> S. Jefferson and D. Plaisted. </author> <title> Implementation of an improved relevance criterion. </title> <booktitle> In First Conference on Artificial Intelligence Applications, </booktitle> <pages> pages 476-482, </pages> <year> 1984. </year>
Reference-contexts: The two stages are performed iteratively until the input problem is solved or until the time limit is exceeded. Figure 2.1 shows the block diagram of the hyper-linking strategy prover. Several prior implementations have been tried. The idea first appeared in [Pla80] and the first implementation was in <ref> [JP84] </ref>. An extension of this to a unification-based prover was attempted, without much success [PM88].
Reference: [Kor85] <author> R. E. Korf. </author> <title> Depth-first iterative deepening: An optimal admissible tree search. </title> <journal> Artificial Intelligence, </journal> <volume> 27 </volume> <pages> 97-109, </pages> <year> 1985. </year>
Reference-contexts: The iterative deepening method <ref> [Kor85, ST85] </ref> is used for this purpose. The idea is as follows. Suppose B S is the specified proof size bound. We start with allowable size bound 0. If a small proof is found, then we are done. Otherwise we increase the allowable size bound by 1 and try again.
Reference: [Kow75] <author> R. Kowalski. </author> <title> A proof procedure using connection graphs. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 22 </volume> <pages> 572-595, </pages> <year> 1975. </year>
Reference-contexts: We may have to rename the variables in L or M so that L and M have no common variables. We treat (L, M) and (M,L) as identical. Note that this is essentially the same as a connection in Kowalski's proving procedure for Horn clauses <ref> [Kow75] </ref> or in the connection graph resolution [Bib82], except that we don't explicitly store the links, so that they cannot be deleted as they are in Kowalski's proving procedure or the connection graph resolution. Definition. Suppose S is a set of clauses.
Reference: [Lew80] <author> H. Lewis. </author> <title> Complexity results for classes of quantificational formulas. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21 </volume> <pages> 317-353, </pages> <year> 1980. </year>
Reference-contexts: This is essentially the same as Schonfinkel-Bernays form in logic <ref> [Lew80] </ref>, which is known to be decidable. The function-free first-order form guarantees finitely many instances generated by hyper-linking. Thus CLIN is guaranteed to stop with an answer. Suppose the domain of the problem contains elements a 1 , : : : , and a n . 1.
Reference: [LO85] <author> E. Lusk and R. Overbeek. </author> <title> Non-horn problems. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 1 </volume> <pages> 103-114, </pages> <year> 1985. </year>
Reference-contexts: The problem "exx5" is a verification condition from Hoare's FIND program [Ble77]. The problem "exx7" is a situation calculus theorem developed by David Plaisted [Pla82]. "latinsq" is the latin square problem from [Rob63]. "liar" is the truthtellers and liars problem <ref> [LO85] </ref>. "salt" is the salt and mustard problem from Lewis Carroll [LO85]. The problem "schubert" is Schubert's steamroller [Wal84]. The stack problem is a proof of a trivial property of push down stores. Problems 104-111 are pigeonhole problems from Pelletier's paper [Pel86]. Problems 112-115 are implicational calculus theorems. <p> The problem "exx7" is a situation calculus theorem developed by David Plaisted [Pla82]. "latinsq" is the latin square problem from [Rob63]. "liar" is the truthtellers and liars problem <ref> [LO85] </ref>. "salt" is the salt and mustard problem from Lewis Carroll [LO85]. The problem "schubert" is Schubert's steamroller [Wal84]. The stack problem is a proof of a trivial property of push down stores. Problems 104-111 are pigeonhole problems from Pelletier's paper [Pel86]. Problems 112-115 are implicational calculus theorems. The problem "freuder" is a constraint satisfaction problem taken from Freuder's paper [Fre78].
Reference: [Lov78] <author> D. Loveland. </author> <title> Automated Theorem Proving: A Logical Basis. </title> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Here are the steps for converting the definition into replace rules: 1. Transform the definition to clauses. The definition is generally written in first-order formula. We may do skolemization to take care of existential quantifiers. For more details about the transformation of first-order formula to clause form, see <ref> [CL73, Lov78] </ref>. 2. For each clause C, we pick distinguished literals, negate them, and place them at the left-hand side of !. The remaining literals are placed at the right-hand side of !. Usually, literals containing the predicate being defined are made into distinguished literals. <p> Let's start with f:pg. By applying ME, we obtain the following proof: * f:q, [:p]g % resolve with fp, :qg * fp, [:q], [:p]g % resolve with fp, qg * f [:q], [:p]g % delete p * fg % delete leftmost framed literals PTTP actually uses the MESON procedures <ref> [Lov78] </ref> which is a refinement of Model Elimination. It uses depth-first iterative-deepening search to make search complete.
Reference: [LP89] <author> S.-J. Lee and D. Plaisted. </author> <title> Theorem proving using hyper-matching strategy. </title> <booktitle> In Proceedings of the 4th International Symposium on Methodologies for Intelligent Systems, </booktitle> <pages> pages 467-476, </pages> <year> 1989. </year>
Reference: [LP90a] <author> S.-J. Lee and D. Plaisted. </author> <title> New applications of a fast propositional calculus decision procedure. </title> <booktitle> In Proceedings of the 8th Biennial Conference of Canadian Society for Computational Studies of Intelligence, </booktitle> <pages> pages 204-211, </pages> <year> 1990. </year>
Reference: [LP90b] <author> S.-J. Lee and D. Plaisted. </author> <title> Reasoning with predicate replacement. </title> <booktitle> In Proceedings of the 5th International Symposium on Methodologies for Intelligent Systems, to appear, </booktitle> <year> 1990. </year>
Reference: [Mac77] <author> A. K. Mackworth. </author> <title> Consistency in network of relations. </title> <journal> Artificial Intelligence, </journal> <volume> 8 </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference-contexts: This CSP has two solutions: 114 x 1 = b, x 2 = e, x 3 = d CSPs are typically solved by backtracking search. However, as Mackworth <ref> [Mac77] </ref> pointed out, backtracking suffers from numerous maladies often making it "grotesquely inefficient." These maladies includes futile backtracks. Constraint preprocessing has been proposed to eliminate such maladies [Mac77][Fre78].
Reference: [Mac87] <author> A. K. Mackworth. </author> <title> Constraint satisfaction. </title> <editor> In S. C. Shapiro, editor, </editor> <booktitle> Encyclopedia of Artificial Intelligence, </booktitle> <pages> pages 205-211. </pages> <publisher> John Wiley and Son, </publisher> <year> 1987. </year>
Reference-contexts: They were originated from computer vision tasks, and have attracted a lot of research efforts [Mac77][Fre78][dK86b][DePe88][dK89]. For details, Mackworth <ref> [Mac87] </ref> gives an excellent introduction to CSPs. A constraint satisfaction problem (CSP) is specified by a set of variables x 1 , : : : , x n and a set of constraints on subsets of these variables limiting the values they can take on.
Reference: [McA80] <author> D. McAllester. </author> <title> An outlook on truth maintenance. </title> <type> Technical Report AIM-551, </type> <institution> Artificial Intelligence Laboratory, MIT, </institution> <address> Cambridge, MA, </address> <year> 1980. </year>
Reference: [McA82] <author> D. McAllester. </author> <title> Reasoning utility package user's manual. </title> <type> Technical Report AIM-667, </type> <institution> Artificial Intelligence Laboratory, MIT, </institution> <address> Cambridge, MA, </address> <year> 1982. </year> <month> 201 </month>
Reference-contexts: The same instances of clauses may appear in more than one case of a case analysis, although in each case there may be no duplication. Some early provers used duplication by case analysis, but few if any clause form provers currently 4 use it. Andrews' prover <ref> [MCA82] </ref> seems to be one of the few current provers that use duplication by case analysis. We now make more precise how resolution and other methods involve the duplication of instances.
Reference: [MCA82] <author> D. Miller, E. Cohen, and P. B. Andrews. </author> <title> A look at TPS. </title> <booktitle> In Proceedings of the 6th International Conference on Automated Deduction, </booktitle> <pages> pages 50-69, </pages> <year> 1982. </year>
Reference-contexts: The same instances of clauses may appear in more than one case of a case analysis, although in each case there may be no duplication. Some early provers used duplication by case analysis, but few if any clause form provers currently 4 use it. Andrews' prover <ref> [MCA82] </ref> seems to be one of the few current provers that use duplication by case analysis. We now make more precise how resolution and other methods involve the duplication of instances.
Reference: [McC89] <author> W. W. McCune. </author> <title> Otter 1.0 Users' Guide. </title> <institution> Mathematics and Computer Science Division, Aggonne National Laboratory, Argonne, Illinois, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: The similarities with semantic networks in artificial intelligence, and with connection graph methods in theorem proving, are closer. CLIN has been implemented in Prolog. Its effectiveness has been shown by comparing it with other major provers, such as OTTER <ref> [McC89] </ref>, "sprfn"[Pla88] , and PTTP [Sti88]. CLIN performs better than the other provers for propositional and near-propositional problems. For other problems, CLIN can prove more of them than the other provers. <p> UR means "unit resulting," and this strategy only generates resolvents that are unit clauses. This strategy is often used by the Argonne group <ref> [McC89] </ref>. UR resolution is an inference rule which produces a unit clause (UR resolvent) from a set of clauses one of which is a nonunit clause (nucleus) while the remaining are unit clauses (electrons). One application of UR resolution which generates a UR resolvent is called a UR resolution step. <p> Even for other problems, CLIN can prove more of them than the other provers. This shows that, especially for hard problems, the advantanges of an instance-based ap proach are starting to appear. The other provers considered are OTTER <ref> [McC89] </ref>, "sprfn" [Pla88][Nie89][NP90], and PTTP [Sti88]. All these provers were published in the past two years. We don't consider Prolog in the comparison for the following reasons. The inference rule, SLD resolution, that Prolog uses is only complete for Horn clauses; it is not complete for first-order clauses. <p> Then we use some propositional and near-propositional problems to show the significance of removing duplications. We then give statistics of some other problems to demonstrate the competitiveness of our system. 86 7.1 Introduction to Other Provers 7.1.1 OTTER OTTER <ref> [McC89] </ref>, developed in the Argonne National Laboratory, is a fast resolution-style theorem prover for first-order logic with equality. It is written in C and uses discrimination nets for fast look-up of potential unifications.
Reference: [MP83] <author> Z. Manna and A. Pnueli. </author> <title> Verification of concurrent programs: a temporal proof system. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, Stanford University, </institution> <year> 1983. </year>
Reference-contexts: The proofs obtained by CLIN are more natural and are more similar to those obtained by a human being. We concentrate on one specific temporal logic that has been proposed in the context of concurrent program verification <ref> [MP83] </ref>. In this logic, time is discrete, linear, and extends infinitely toward the future.
Reference: [MR86] <author> N. Murray and E. Rosenthal. </author> <title> Theory links in semantic graphs. </title> <booktitle> In Proceedings of the 8th International Conference on Automated Deduction, </booktitle> <pages> pages 353-364, </pages> <year> 1986. </year>
Reference-contexts: Another possibility is to use a kind of "theory hyper-linking," analogous to the theory resolution of Stickel [Sti85], to generate the needed instances and guarantee completeness. The idea of theory hyper-linking is similar to the idea of theory links mentioned by Murray and Rosenthal <ref> [MR86] </ref>. One area where a specialized decision procedure might help is temporal logic, where a decision procedure for discrete linearly ordered sets could be applied. 10.2.3 Semantics In general, it would be nice to use semantics in a proving system.
Reference: [MW88] <author> D. Maier and D. S. Warren. </author> <title> Computing with Logic. </title> <publisher> The Benjamin/Cummings Publishing Co., </publisher> <address> Menlo Park, California, </address> <year> 1988. </year>
Reference: [Nie89] <author> X. Nie. </author> <title> Implementation Techniques in Automatic Theorem Proving. </title> <type> PhD thesis, </type> <institution> University of North Carolina at Chapel Hill, </institution> <year> 1989. </year>
Reference-contexts: All the times are obtained on a SUN3/60M workstation with 12 MB memory. The prolog system used for running PTTP, "sprfn", and CLIN is ALS-Prolog (Version 0.60) of Applied Logic System, Inc. [ALS88]. The statistics for OTTER are taken from <ref> [Nie89] </ref>. The strategies used are hyperresolution and UR resolution together, plus forward and backward subsumptions. A correct set of support clauses have to be supplied to OTTER for many problems, marked by "*" in the table, in order to get the proof. <p> 36 ls112 23 | | | 318.883 38 chang lee 2 7 0.520 2.016 5.470 3.883 39 chang lee 8 9 0.700 15.100 2.300 9.183 40 chang lee 9 8 0.480 0.680 2.820 5.183 41 schubert 30 3.920 2483.080 112.970 130.583 Table 7.2: Performance comparison on some other problems 92 <ref> [Nie89] </ref>. Contrapositives have to be added in the input clauses of some problems, marked by "+" in the table, in order to get the proof. Two problems for CLIN use user support; they are marked by "-". The following observations can be made from Table 7.2: 1.
Reference: [NO80] <author> G. Nelson and D. Oppen. </author> <title> Fast decision procedures based on congruence closure. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 27 </volume> <pages> 356-364, </pages> <year> 1980. </year>
Reference-contexts: Many specialized decision procedures are especially suited to ground clauses. One way to build in a specialized decision procedure, then, is just to add it to the propositional calculus prover. For example, equality could be built in by adding a congruence closure test <ref> [NO80] </ref> to the propositional calculus prover. However, this is not complete unless the right instances of the input clauses are generated. Such instances will not necessarily be generated unless the equality axioms are included in the input. Including such axioms largely negates the benefits of a specialized decision procedure.
Reference: [NP90] <author> X. Nie and D. Plaisted. </author> <title> A complete semantic back chaining proof system. </title> <booktitle> In Proceedings of the 10th International Conference on Automated Deduction, </booktitle> <year> 1990. </year>
Reference-contexts: If the problem can't be solved with 68 the current space quota, the space quota is increased automatically. In this way, we always solve a given problem with, in some sense, minimum space. A similar idea has been proposed in another context in <ref> [NP90] </ref>. The same effect could also be obtained by best-first search [OMW76], but our method permits a simpler implementation. The idea of sliding priority has been proven very effective. It enabled us to get a number of proofs that couldn't be obtained without sliding priority.
Reference: [NP90] <author> X. Nie and D. Plaisted. </author> <title> Refinements to depth-first iterative deepening search in theorem proving. </title> <journal> Artificial Intelligence, </journal> <volume> 41 </volume> <pages> 223-235, </pages> <year> 1989/90. </year>
Reference-contexts: If the problem can't be solved with 68 the current space quota, the space quota is increased automatically. In this way, we always solve a given problem with, in some sense, minimum space. A similar idea has been proposed in another context in <ref> [NP90] </ref>. The same effect could also be obtained by best-first search [OMW76], but our method permits a simpler implementation. The idea of sliding priority has been proven very effective. It enabled us to get a number of proofs that couldn't be obtained without sliding priority.
Reference: [OMW76] <author> R. J. Overbeek, J. Mecharen, and L. Wos. </author> <title> Complexity and related enhancements for automated theorem-proving programs. </title> <journal> Computers and Mathematics with Applications, </journal> <volume> 2 </volume> <pages> 1-16, </pages> <year> 1976. </year>
Reference-contexts: In this way, we always solve a given problem with, in some sense, minimum space. A similar idea has been proposed in another context in [NP90]. The same effect could also be obtained by best-first search <ref> [OMW76] </ref>, but our method permits a simpler implementation. The idea of sliding priority has been proven very effective. It enabled us to get a number of proofs that couldn't be obtained without sliding priority. The idea also makes CLIN more self-guiding, requiring less input and insight from the user.
Reference: [Ost89] <author> J. S. Ostroff. </author> <title> Temporal Logic for Real-Time Systems. </title> <publisher> Research Studies Press, </publisher> <address> England, </address> <year> 1989. </year>
Reference: [Pel86] <author> F. J. Pelletier. </author> <title> Seventy-five problems for testing automatic theorem provers. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 2 </volume> <pages> 191-216, </pages> <year> 1986. </year>
Reference-contexts: Therefore, even if P = NP, this would not help most of the time. It is only for a few problems such as the "pigeonhole problems" <ref> [Pel86] </ref> that the propositional prover takes most of the time. This enables us to do the unsatisfiability test on the ground set of all the clauses instead of on the ground set of a fully linked subset of these clauses. <p> The problem "schubert" is Schubert's steamroller [Wal84]. The stack problem is a proof of a trivial property of push down stores. Problems 104-111 are pigeonhole problems from Pelletier's paper <ref> [Pel86] </ref>. Problems 112-115 are implicational calculus theorems. The problem "freuder" is a constraint satisfaction problem taken from Freuder's paper [Fre78]. Problems 117-120 are logic puzzles taken from [SS86][WOLB84].
Reference: [Per84] <author> F. Pereira. </author> <title> C-Prolog User's Manual. </title> <booktitle> SRI International, </booktitle> <address> Menlo Park, California, </address> <month> August </month> <year> 1984. </year>
Reference-contexts: There are a number of user settable flags, but many of them are for experimentation and can be ignored under normal use. CLIN is written in Prolog. It can be run with either C-Prolog <ref> [Per84] </ref> or ALS-Prolog [ALS88]. CLIN can be used in an automatic way, that is, by triggering the top-level supervisor. It can also be used in a controlled way; the user specifies desired options and decides support strategies before the prover tries on the input problem. <p> Prepare an input file. The format of the file will be explained later. 2. Run C-Prolog or ALS-Prolog. Usually, the user has to allocate more memory for stacks and heap when using C-Prolog, see C-Prolog manual <ref> [Per84] </ref> for details. Both C-Prolog and ALS-Prolog can be run on SUN3. 3. Consult the prover. A welcome message will come up on the screen. 4. Try the input file.
Reference: [PG86] <author> D. Plaisted and S. Greenbaum. </author> <title> A structure-preserving clause form translation. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 2 </volume> <pages> 293-304, </pages> <year> 1986. </year>
Reference-contexts: Furthermore, the predicate replacement, similar to hyper-linking operations, does not incur any duplication by combination. Our method has another advantage. It avoids exponential increase in length of clauses by direct substitutions. This has the same virtue as the structure preserving translation described in <ref> [PG86] </ref>. The use of predicate replacement is not restricted to definition replacements. It can be used to replace predicates by predicates in any clause. In this way, the user may convey his or her intuition or knowledge about how to prove the underlying problem to the system through replace rules. <p> This results in exponential increase in size. One way to transform it with polynomial size is to add extra predicate symbols to represent partial expressions <ref> [PG86] </ref>. Note that the transformation can be done mechanically. 9.1.3 Examples We illustrate the problem solving capability of CLIN by solving two kinds of problems: constraint satisfaction problems and logic puzzles. 9.1.3.1 Constraint Satisfaction Problems (CSPs) Constraint Satisfaction Problems are fundamental problems in the area of Artificial Intelligence.
Reference: [PL90] <author> D. Plaisted and S.-J. Lee. </author> <title> Inference by clause linking. </title> <type> Technical Report TR90-022, </type> <institution> University of North Carolina Chapel Hill, Chapel Hill, NC, </institution> <year> 1990. </year>
Reference-contexts: We have run CLIN with various options on the test set. Some results are listed in Appendix A. Appendix B lists the input files of some test problems. Appendix C includes a brief user manual for CLIN. 1.8 Related Publications This thesis is partially based on <ref> [PL90] </ref>. Parts of chapters 2, 4, and 9 appear in preliminary forms in [LP89][LP90a][LP90b]. 10 Chapter 2 The Hyper-Linking Strategy Prover The philosophy of the hyper-linking strategy prover is never to combine literals from two clauses. The prover consists of a two stage process.
Reference: [Pla80] <author> D. Plaisted. </author> <title> An efficient relevance criterion for mechanical theorem proving. </title> <booktitle> In Proceedings of the First Annual National Conference on Artificial Intelligence, </booktitle> <pages> pages 79-83, </pages> <year> 1980. </year>
Reference-contexts: The two stages are performed iteratively until the input problem is solved or until the time limit is exceeded. Figure 2.1 shows the block diagram of the hyper-linking strategy prover. Several prior implementations have been tried. The idea first appeared in <ref> [Pla80] </ref> and the first implementation was in [JP84]. An extension of this to a unification-based prover was attempted, without much success [PM88].
Reference: [Pla81] <author> D. Plaisted. </author> <title> Theorem proving with abstraction. </title> <journal> Artificial Intelligence, </journal> <volume> 16 </volume> <pages> 47-108, </pages> <year> 1981. </year>
Reference: [Pla82] <author> D. Plaisted. </author> <title> A simplified problem reduction format. </title> <journal> Artificial Intelligence, </journal> <volume> 18 </volume> <pages> 227-261, </pages> <year> 1982. </year>
Reference-contexts: Problems 1-93 are from Stickel's paper [Sti86]. The problem "example" is a theorem presented by Pellitier and Rudnicki in AAR Newsletter No. 6, 1986. The problem "exx5" is a verification condition from Hoare's FIND program [Ble77]. The problem "exx7" is a situation calculus theorem developed by David Plaisted <ref> [Pla82] </ref>. "latinsq" is the latin square problem from [Rob63]. "liar" is the truthtellers and liars problem [LO85]. "salt" is the salt and mustard problem from Lewis Carroll [LO85]. The problem "schubert" is Schubert's steamroller [Wal84]. The stack problem is a proof of a trivial property of push down stores.
Reference: [Pla86] <author> D. Plaisted. </author> <title> A decision procedure for combinations of propositional temporal logic and other specialized theories. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 2 </volume> <pages> 171-190, </pages> <year> 1986. </year>
Reference-contexts: As usual, we may omit parentheses if no ambiguities occur. For example, the following two expressions are PTL formulae: 125 w ! 3 w The semantics of the PTL formulae is defined, following <ref> [Pla86] </ref>, in terms of a structure M = (S,D,L) where S is a sequence (s 1 , s 2 , s 3 , : : : ) of states, D is a set of proposition symbols, and L is an interpretation which assigns to each proposition symbol w and each state
Reference: [Pla88] <author> D. Plaisted. </author> <title> Non-Horn clause logic programming without contrapositives. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 4 </volume> <pages> 287-325, </pages> <year> 1988. </year>
Reference-contexts: However, since the number of links per literal may be much larger than two, the number of cases may be much larger than in the Davis-Putnam procedure for propositional calculus, it appears. Even the modified problem reduction format prover <ref> [Pla88] </ref> has duplication by combination on non Horn problems. Another motivation of our work is to justify the claim that a theorem proving method may benefit from applying the low-level heuristics a human mathematician uses to obtain a proof. <p> All literals are on an equal footing. This contrasts with the modified problem reduction format of <ref> [Pla88] </ref>, in which contrapositives of clauses are considered separately. The conceptual simplicity of having clauses as lists has enabled us to add some refinements to the prover without having to deal with the complexities of contrapositives. <p> However, we are really measuring the depth of the proof, not its size. This different measure may explain some differences in performance between CLIN and the iterative deepening prover of Stickel [Sti86] as well as the modified problem reduction format prover <ref> [Pla88] </ref>. Both of those provers measure the size rather than the depth of a proof. <p> Unfortunately, these definitions with explicit quantifiers cannot be used directly in CLIN since it is a quantifier-free system. An idea of term rewriting with a quantifier-free theorem prover "sprfn" <ref> [Pla88] </ref> results in an efficient approach in proving these theorems [PP88]. However, the approach is less natural. A special tautology tester is written for "sprfn" solely for this purpose. In this section, we discuss a method, called predicate replacement, which accepts the user's guidance and helps CLIN do search efficiently. <p> (X, Y), :mother (X, Z), father (Y, Z)g 2. fmarried (thelma, pete), olderthan (thelma, pete)g 3. fmother (thelma, steve)g If we apply hyperresolution to these clauses, then we have ffather (pete, steve), olderthan (thelma, pete)g as a result. 7.1.2 sprfn "sprfn" is based on the modified problem reduction format (MPRF) <ref> [Pla88] </ref>. MPRF uses the subgoaling paradigm. It basically derives f alse from inference rules and axioms. Clauses are converted to inference rules in two steps. First, all clauses are converted into Horn-like clauses. <p> Since CLIN is not subgoal-oriented, as the modified problem reduction format is <ref> [Pla88] </ref>, it is more difficult to use semantics. There is one way to use semantics, however.
Reference: [Pla90] <author> D. Plaisted. </author> <title> Mechanical theorem proving. </title> <editor> In R. Banerji, editor, </editor> <booktitle> A Sourcebook on Formal Techniques in Artificial Intelligence. </booktitle> <publisher> Elsevier, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: Therefore a lot of work may be saved sometimes. We can construct a resolution proof of the empty clause from the run of our propositional calculus prover, as described in <ref> [Pla90] </ref>. The time taken by the propositional calculus prover is only 5.293 percent in average of the total time for the test problems listed in Appendix A.
Reference: [PM88] <author> D. Plaisted and U. Meyer. </author> <title> A matching strategy for first-order theorem proving. </title> <type> Unpublished, </type> <year> 1988. </year>
Reference-contexts: Figure 2.1 shows the block diagram of the hyper-linking strategy prover. Several prior implementations have been tried. The idea first appeared in [Pla80] and the first implementation was in [JP84]. An extension of this to a unification-based prover was attempted, without much success <ref> [PM88] </ref>. A key to our current success seems to be that we do not store any links between clauses, which sets our method apart from the connection graph resolution of [Bib82] which relies heavily on such links.
Reference: [PP88] <author> R. Potter and D. Plaisted. </author> <title> Term rewriting: Some experimental results. </title> <booktitle> In Proceedings of the 9th International Conference on Automated Deduction, </booktitle> <pages> pages 435-453, </pages> <year> 1988. </year>
Reference-contexts: Unfortunately, these definitions with explicit quantifiers cannot be used directly in CLIN since it is a quantifier-free system. An idea of term rewriting with a quantifier-free theorem prover "sprfn" [Pla88] results in an efficient approach in proving these theorems <ref> [PP88] </ref>. However, the approach is less natural. A special tautology tester is written for "sprfn" solely for this purpose. In this section, we discuss a method, called predicate replacement, which accepts the user's guidance and helps CLIN do search efficiently. This method is similar to the idea of [PP88] but fits <p> these theorems <ref> [PP88] </ref>. However, the approach is less natural. A special tautology tester is written for "sprfn" solely for this purpose. In this section, we discuss a method, called predicate replacement, which accepts the user's guidance and helps CLIN do search efficiently. This method is similar to the idea of [PP88] but fits in more naturally in our system. It allows the same effect of replacing predicates by their definitions in a Skolemized, quantifier-free setting. With this technique, our system can prove set theory theorems easily.
Reference: [PP90] <author> H. Przymusinska and T. Przymusinski. </author> <title> Semantic issues in deductive databases and logic programs. </title> <editor> In R. Banerji, editor, </editor> <booktitle> A Sourcebook on Formal Techniques in Artificial Intelligence. </booktitle> <publisher> Elsevier, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: Both databases have disadvantages. For relational databases, tuples or relations have to be prepared in different ways. New data can't be deduced from the existing relations <ref> [PP90] </ref>. The database management system is at most a retrieval instrument.
Reference: [PPV60] <author> D. Prawitz, H. Prawitz, and N. Voghera. </author> <title> A mechanical proof procedure and its realization in an electronic computer. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 7 </volume> <pages> 102-128, </pages> <year> 1960. </year>
Reference: [Rei80] <author> R. Reiter. </author> <title> A logic for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13 </volume> <pages> 81-132, </pages> <year> 1980. </year>
Reference-contexts: The DBMS should be able to retrieve such information from the database. The DDBMS has to be capable of detecting inconsistency and locating the inconsistent clauses. If we allow default rules <ref> [Rei80] </ref>, then common sense reasoning can be done. In this case, we may label each conclusion derived by CLIN in the database with the default rules it depends on. When new facts or rules are added into the deductive database, some conclusions may have to be retracted.
Reference: [Rob63] <author> J. Robinson. </author> <title> Theorem proving on the computer. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 10 </volume> <pages> 163-174, </pages> <year> 1963. </year>
Reference-contexts: The problem "example" is a theorem presented by Pellitier and Rudnicki in AAR Newsletter No. 6, 1986. The problem "exx5" is a verification condition from Hoare's FIND program [Ble77]. The problem "exx7" is a situation calculus theorem developed by David Plaisted [Pla82]. "latinsq" is the latin square problem from <ref> [Rob63] </ref>. "liar" is the truthtellers and liars problem [LO85]. "salt" is the salt and mustard problem from Lewis Carroll [LO85]. The problem "schubert" is Schubert's steamroller [Wal84]. The stack problem is a proof of a trivial property of push down stores. Problems 104-111 are pigeonhole problems from Pelletier's paper [Pel86].
Reference: [Rob65] <author> J. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 12 </volume> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: Methods developed since 1965, such as model elimination and connection graph methods, also tend to be based on unification without requiring a large number of cases to be considered. Since 1965, much work has been done on the resolution method of Robinson <ref> [Rob65] </ref>. Unlike our method, resolution combines parts of different clauses. This has advantages and disadvantages. <p> The idea also makes CLIN more self-guiding, requiring less input and insight from the user. Furthermore, the idea can be easily applied to any other prover using breadth-first search strategies, such as the resolution method <ref> [Rob65] </ref> and Gilmore's procedure [Gil60]. 5.1 Descriptions 5.1.1 Basic Idea Suppose we decide in advance that we only want to store b clauses at one time. We call b the work bound. Each clause has a priority, which is an integer giving its size and/or some other measure of complexity.
Reference: [SC85] <author> A.P. Sistla and E.M. Clarke. </author> <title> The complexity of propositional linear temporal logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 32 </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference: [SM77] <author> D.F. Stanat and D.F. McAllister. </author> <booktitle> Discrete Mathematics in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1977. </year>
Reference-contexts: A proof of a theorem is an argument which establishes that the theorem is true. To establish that one assertion follows from another, we must use only principles of reasoning which we accept as valid; these principles are called inference rules <ref> [SM77] </ref>. An inference system for a specified theory is complete if all valid statements in the underlying theory can be derived from the given axioms using the inference rules.
Reference: [SS86] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: They are usually stated in words instead of formulae like constraint satisfaction problems. Example 9.2 Here is a description for a logic puzzle "friends" <ref> [SS86] </ref>: 1. There are three friends: Michael, Richard, and Simon; three nationalities: American, Australian, and Israeli; three sports: basketball, cricket, and tennis. 2. Each friend has a unique nationality and plays a unique sport. 3. These friends came first, second, and third in a programming competition. 4. <p> The total time for solving this problem is 351.683 seconds. Example 9.4 The following rules are for a problem called "zebra" <ref> [SS86] </ref>: 1.
Reference: [ST85] <author> M.E. Stickel and W.M. Tyson. </author> <title> An analysis of consecutively bounded depth-first search with applications in automated deduction. </title> <booktitle> In Proceedings of the 9th International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 1073-1075, </pages> <year> 1985. </year>
Reference-contexts: The iterative deepening method <ref> [Kor85, ST85] </ref> is used for this purpose. The idea is as follows. Suppose B S is the specified proof size bound. We start with allowable size bound 0. If a small proof is found, then we are done. Otherwise we increase the allowable size bound by 1 and try again.
Reference: [Sti81] <author> M.E. Stickel. </author> <title> A unification algorithm for associative-commutative functions. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28 </volume> <pages> 423-434, </pages> <year> 1981. </year>
Reference-contexts: For example, in temporal logic it is desirable to replace pred (suc (T)) by T since they are equal. Therefore, it would be nice to have facilities, such as term-rewriting built in our system. More sophisticated techniques, like associative-commutative unification <ref> [Sti81] </ref>, are sometimes needed. In general, CLIN is well suited to the use of specialized decision procedures, since it generates a set of ground clauses for testing by the propositional calculus prover. Many specialized decision procedures are especially suited to ground clauses.
Reference: [Sti85] <author> M.E. Stickel. </author> <title> Automated deduction by theory resolution. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 1 </volume> <pages> 333-355, </pages> <year> 1985. </year>
Reference-contexts: Such instances will not necessarily be generated unless the equality axioms are included in the input. Including such axioms largely negates the benefits of a specialized decision procedure. Another possibility is to use a kind of "theory hyper-linking," analogous to the theory resolution of Stickel <ref> [Sti85] </ref>, to generate the needed instances and guarantee completeness. The idea of theory hyper-linking is similar to the idea of theory links mentioned by Murray and Rosenthal [MR86].
Reference: [Sti86] <author> M.E. Stickel. </author> <title> A prolog technology theorem prover: Implementation by an extended prolog compiler. </title> <booktitle> In Proceedings of the 8th International Conference on Automated Deduction, </booktitle> <pages> pages 573-587, </pages> <year> 1986. </year>
Reference-contexts: Our distance measure is an attempt to restrict the proof size. However, we are really measuring the depth of the proof, not its size. This different measure may explain some differences in performance between CLIN and the iterative deepening prover of Stickel <ref> [Sti86] </ref> as well as the modified problem reduction format prover [Pla88]. Both of those provers measure the size rather than the depth of a proof. <p> Mathematical induction might be difficult because the system does not explicitly generate lemmas. 139 Appendix A Test Results A.1 Test Problems We have run CLIN on a set of test problems with various options, and list some results in this appendix. Problems 1-93 are from Stickel's paper <ref> [Sti86] </ref>. The problem "example" is a theorem presented by Pellitier and Rudnicki in AAR Newsletter No. 6, 1986. The problem "exx5" is a verification condition from Hoare's FIND program [Ble77].
Reference: [Sti88] <author> M.E. Stickel. </author> <title> A prolog technology theorem prover: Implementation by an extended prolog compiler. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 4 </volume> <pages> 353-380, </pages> <year> 1988. </year> <month> 203 </month>
Reference-contexts: The similarities with semantic networks in artificial intelligence, and with connection graph methods in theorem proving, are closer. CLIN has been implemented in Prolog. Its effectiveness has been shown by comparing it with other major provers, such as OTTER [McC89], "sprfn"[Pla88] , and PTTP <ref> [Sti88] </ref>. CLIN performs better than the other provers for propositional and near-propositional problems. For other problems, CLIN can prove more of them than the other provers. <p> Also, different support strategies may have different search patterns for the proof. The number of rounds needed and the size of the search space may vary. Example 3.1 Consider the following set S of clauses which is a reduced version of "wos15" <ref> [Sti88] </ref>: 2. C 2 : fo (b)g 4. C 4 : fp (a, b, c)g 6. C 6 : fp (X, e, X)g 8. C 8 : fp (X, g (X), e)g 10. <p> Thus we have obtained a unit clause :q (a) by resolving the given clause with two unit clauses; this is essentially the same as UR resolution. Example 3.2 Let's use UR resolution to solve the following problem "chang lee 8" <ref> [Sti88] </ref>: * C 2 : fd (X, X)g * C 4 : fd (X, Z), :d (Y, Z), :d (X, Y)g * C 6 : fd (f (X), X), :l (1, X), :l (X, a)g * C 8 : fl (1, g (X)), p (X)g In the first round, only the <p> With this ordering, a simplest small proof is always found first if it exists. 3.7.6 Two Examples We give two examples to illustrate how the small proof checking works. Example 3.3 The following problem is "ls100" <ref> [Sti88] </ref>: 1. C 1 : fe (b, c)g 3. C 3 : fm (Z 3 , Y 3 ), :s (X 3 , Y 3 ), :m (Z 3 , X 3 )g 5. <p> This example is "ls103" <ref> [Sti88] </ref>. <p> Even for other problems, CLIN can prove more of them than the other provers. This shows that, especially for hard problems, the advantanges of an instance-based ap proach are starting to appear. The other provers considered are OTTER [McC89], "sprfn" [Pla88][Nie89][NP90], and PTTP <ref> [Sti88] </ref>. All these provers were published in the past two years. We don't consider Prolog in the comparison for the following reasons. The inference rule, SLD resolution, that Prolog uses is only complete for Horn clauses; it is not complete for first-order clauses. <p> The version we used for our comparison is a Prolog version that is not as fast as that reported in <ref> [Sti88] </ref>, and does not have all of the optimizations of the faster version. 7.2 Propositional and Near-Propositional Problems In this section, we want to show that CLIN performs better than other provers for propositional and near-propositional problems. Propositional problems contains no variables. All clauses contained in them are ground.
Reference: [Wal84] <author> C. Walther. </author> <title> A mechanical solution of schubert's steamroller by many-sorted res-olution. </title> <booktitle> In Proceedings of the 4th National Conference on Artificial Intelligence, </booktitle> <pages> pages 330-334, </pages> <year> 1984. </year>
Reference-contexts: The problem "exx7" is a situation calculus theorem developed by David Plaisted [Pla82]. "latinsq" is the latin square problem from [Rob63]. "liar" is the truthtellers and liars problem [LO85]. "salt" is the salt and mustard problem from Lewis Carroll [LO85]. The problem "schubert" is Schubert's steamroller <ref> [Wal84] </ref>. The stack problem is a proof of a trivial property of push down stores. Problems 104-111 are pigeonhole problems from Pelletier's paper [Pel86]. Problems 112-115 are implicational calculus theorems. The problem "freuder" is a constraint satisfaction problem taken from Freuder's paper [Fre78].
Reference: [WB87] <author> T.C. Wang and W.W. Bledsoe. </author> <title> Hierarchical deduction. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 3 </volume> <pages> 35-77, </pages> <year> 1987. </year>
Reference-contexts: By low-level heuristics, we mean such methods as preferring terms that are small, 5 or contain a small number of variables, and so on. Some of the methods used in theorem proving, such as variable elimination [Hin88] and the complexity measure of Wang <ref> [WB87] </ref>, successful though they are, seem to be mysterious, since it is unlikely that a human would use such methods. We believe that a theorem prover which works well with these low-level heuristics provides a better rational reconstruction of human theorem proving activity. <p> This is a very natural rule. The proof is obtained totally by replacement and ground substitution in 13.700 seconds. 8.4 AM8 This theorem states that a continuous function f in a closed real interval [a, b] attains its minimum (or maximum) in this interval <ref> [WB87] </ref>.
Reference: [WOLB84] <author> L. Wos, R. Overbeek, E. Lusk, and J. Boyle. </author> <title> Automated Reasoning: Introduction and Applications. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1984. </year>
Reference-contexts: Both of those provers measure the size rather than the depth of a proof. Sometimes it may be preferable to use one measure, and sometimes it may be preferable to use another. 3.5 UR resolution We note that the UR resolution strategy <ref> [WOLB84] </ref>, though incomplete, is compatible with the philosophy of our system, namely, that literals from different clauses should never be combined. UR means "unit resulting," and this strategy only generates resolvents that are unit clauses. This strategy is often used by the Argonne group [McC89]. <p> This can be verified by adding the negated literals above and run CLIN again. The total time for solving this problem is 29.783 seconds. Example 9.3 The following constraints are for the "jobs" puzzle found in <ref> [WOLB84] </ref>: 1. There are four people: Roberta, Thelma, Pete, and Steve; eight jobs: actor, boxer, chef, guard, nurse, police officer, teacher, and telephone operator. 118 2. Each person holds exactly two jobs. 3. The job of nurse is held by a male. 4.
Reference: [Wos88] <author> L. Wos. </author> <title> Automated Reasoning: 33 Basic Research Problems. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1988. </year>
Reference-contexts: Unfortunately, many instances become user-supported rapidly, since only one electron needs to be user-supported for an instance to be user supported. The use of user support set effectively controls the generation of level 1 instances, as mentioned in <ref> [Wos88] </ref>, but fails to control the instances of levels greater than 1. Forward support is more restrictive because all the electrons for the negative literals have to be forward supported in order for an instance to be forward supported.
Reference: [WRC65] <author> L. Wos, G. Robinson, and D. Carson. </author> <title> Efficiency and completeness of the set of support strategy in theorem proving. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 12 </volume> <pages> 536-541, </pages> <year> 1965. </year> <month> 204 </month>
Reference-contexts: Note that we have proven S unsatisfiable without applying any hyper-link operations. Ground unit generation makes small proof checking more efficient because we don't need to consider non-unit electrons which contain ground literals. 3.3 Support Sets 3.3.1 Descriptions In resolution, set-of-support strategies <ref> [WRC65] </ref> are widely used. Given a set S of clauses, a support set is a subset T of S such that S - T is satisfiable. Such strategies restrict the generation of irrelevant resolvents and seem essential for applications in which there are a large number of clauses.
References-found: 74

