URL: http://www.cs.iastate.edu/tech-reports/TR96-01a.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: An Overview of Larch/C++: Behavioral Specifications for C++ Modules  
Author: Gary T. Leavens TR #-a 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Date: February 1996, revised March 1996  
Abstract: Keywords: behavioral specification, model-based, behavioral interface specification language, Larch, C++, Larch/C++, Larch Shared Language, VDM, Z, correctness, verification, abstract data type, object-oriented, specification inheritance, example, checkable redundancy, behavioral subtype, informality, tunable formality. 1993 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications | Languages; F.3.1 [Logics and Meaning of Programs] Specifying and verifying and reasoning about programs | Assertions, invariants, pre- and post-conditions, specification techniques. Copyright c flKluwer Academic Publishers, 1996. Used by permission. A version of this paper will be a chapter in the book Specification of Behavioral Semantics in Object-Oriented Information Modeling , edited by Haim Kilov and William Harvey (Kluwer Academic Publishers, 1996). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. J. Alencar and J. A. Goguen. </author> <title> OOZE: An object oriented Z environment. </title> <editor> In P. America, editor, </editor> <booktitle> ECOOP '91: European Conference on Object Oriented Programming, volume 512 of Lecture Notes in Computer Science, </booktitle> <pages> pages 180-199. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [27, 26], ZEST [11], Object-Z [40, 41], OOZE <ref> [1, 2, 3] </ref>, MooZ [36, 37], and VDM++ [39]. However, apparently there are "variants of Fresco" [48, 49] that are "derived from C++ and Smalltalk" [50, p. 135]; these may permit more exact specification of interface details. <p> The trait FourSidedFigure defines the type Edges as a tuple of four Vector values. As a convenience, the trait also introduces the operator, __ [__], which allows one to write e <ref> [1] </ref> instead of e.v1. In the asserts section, the specification defines the condition on four-sided figures from [44] as a predicate. The predicate isLoop (e) holds just when the vectors sum to zero (make a loop). <p> 4 FourSidedFigure: trait includes PreVector (Scalar, Vector for Vec [T]), int Edges tuple of v1: Vector, v2: Vector, v3: Vector, v4: Vector introduces __ [__]: Edges, int ! Vector isLoop: Edges ! Bool asserts 8 e: Edges isLoop (e) == (e.v1 + e.v2 + e.v3 + e.v4 = 0:Vector); e <ref> [1] </ref> == e.v1; e [3] == e.v3; implies 8 e: Edges isLoop (e) == (e [1] + e [2] + e [3] + e [4] = 0:Vector); PreVectorSig (T): trait introduces __ + __: Vec [T], Vec [T] ! Vec [T] 0: ! Vec [T] __ - __: Vec [T], Vec <p> Vector, v2: Vector, v3: Vector, v4: Vector introduces __ [__]: Edges, int ! Vector isLoop: Edges ! Bool asserts 8 e: Edges isLoop (e) == (e.v1 + e.v2 + e.v3 + e.v4 = 0:Vector); e <ref> [1] </ref> == e.v1; e [3] == e.v3; implies 8 e: Edges isLoop (e) == (e [1] + e [2] + e [3] + e [4] = 0:Vector); PreVectorSig (T): trait introduces __ + __: Vec [T], Vec [T] ! Vec [T] 0: ! Vec [T] __ - __: Vec [T], Vec [T] ! Vec [T] __ __: Vec [T], Vec [T] ! T % inner product <p> But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [40, 41], MooZ [36, 37], VDM++ [39], Z++ [27, 26], OOZE <ref> [1, 2, 3] </ref>, and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's abstract values may have more <p> (The operator isaParallelogram is specified in the trait shown in Figure 12.) 11 imports QuadShape, NoInterior; abstract class ParallelShape : public QuadShape - public: uses QuadSubtype (ParallelShape, QuadShape); simulates QuadShape by toSuperWithoutChange; uses IsaParallelogram; invariant isaParallelogram (self * .edges); virtual double AnglePar () const throw (NoInterior) - requires : (self^.edges <ref> [1] </ref> = 0 _ self^.edges [2] = 0); ensures informally "result is the angle between self^.edges [1] and" "self^.edges [2]"; requires self^.edges [1] = 0 _ self^.edges [2] = 0; ensures thrown (NoInterior) = theException; - IsaParallelogram: trait includes FourSidedFigure introduces isaParallelogram: Edges ! Bool asserts 8 e: Edges isaParallelogram (e) <p> abstract class ParallelShape : public QuadShape - public: uses QuadSubtype (ParallelShape, QuadShape); simulates QuadShape by toSuperWithoutChange; uses IsaParallelogram; invariant isaParallelogram (self * .edges); virtual double AnglePar () const throw (NoInterior) - requires : (self^.edges <ref> [1] </ref> = 0 _ self^.edges [2] = 0); ensures informally "result is the angle between self^.edges [1] and" "self^.edges [2]"; requires self^.edges [1] = 0 _ self^.edges [2] = 0; ensures thrown (NoInterior) = theException; - IsaParallelogram: trait includes FourSidedFigure introduces isaParallelogram: Edges ! Bool asserts 8 e: Edges isaParallelogram (e) == isLoop (e) ^ (e.v1 + e.v3 = 0:Vector); implies 8 e: Edges isaParallelogram (e) == <p> - public: uses QuadSubtype (ParallelShape, QuadShape); simulates QuadShape by toSuperWithoutChange; uses IsaParallelogram; invariant isaParallelogram (self * .edges); virtual double AnglePar () const throw (NoInterior) - requires : (self^.edges <ref> [1] </ref> = 0 _ self^.edges [2] = 0); ensures informally "result is the angle between self^.edges [1] and" "self^.edges [2]"; requires self^.edges [1] = 0 _ self^.edges [2] = 0; ensures thrown (NoInterior) = theException; - IsaParallelogram: trait includes FourSidedFigure introduces isaParallelogram: Edges ! Bool asserts 8 e: Edges isaParallelogram (e) == isLoop (e) ^ (e.v1 + e.v3 = 0:Vector); implies 8 e: Edges isaParallelogram (e) == isLoop (e) ^ (e.v2 + e.v4 <p> == isaParallelogram (e) ^ (e.v2 e.v3 = 0); imports Rhombus; imports Rectangle; class Square : public Rhombus, public Rectangle - public: uses QuadSubtype (Square, Rhombus); simulates Rhombus by toSuperWithoutChange; uses QuadSubtype (Square, Rectangle); simulates Rectangle by toSuperWithoutChange; Square (Vector v1, Vector pos) - uses IsaSquare; modifies self; ensures liberally self'.edges <ref> [1] </ref> = v1 ^ self'.position = pos; claims liberally isaSquare (self'.edges); - 15 IsaSquare: trait includes IsaRectangle, IsaRhombus introduces isaSquare: Edges ! Bool asserts 8 e: Edges isaSquare (e) == isaRectangle (e) ^ isaRhombus (e); * The behavioral interface specifications are roughly comparable to the various OO specifications written in the
Reference: [2] <author> A. J. Alencar and J. A. Goguen. </author> <title> OOZE. </title> <editor> In Stepney et al. </editor> <volume> [44], </volume> <pages> pages 79-94. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [27, 26], ZEST [11], Object-Z [40, 41], OOZE <ref> [1, 2, 3] </ref>, MooZ [36, 37], and VDM++ [39]. However, apparently there are "variants of Fresco" [48, 49] that are "derived from C++ and Smalltalk" [50, p. 135]; these may permit more exact specification of interface details. <p> v3: Vector, v4: Vector introduces __ [__]: Edges, int ! Vector isLoop: Edges ! Bool asserts 8 e: Edges isLoop (e) == (e.v1 + e.v2 + e.v3 + e.v4 = 0:Vector); e [1] == e.v1; e [3] == e.v3; implies 8 e: Edges isLoop (e) == (e [1] + e <ref> [2] </ref> + e [3] + e [4] = 0:Vector); PreVectorSig (T): trait introduces __ + __: Vec [T], Vec [T] ! Vec [T] 0: ! Vec [T] __ - __: Vec [T], Vec [T] ! Vec [T] __ __: Vec [T], Vec [T] ! T % inner product length: Vec [T] <p> But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [40, 41], MooZ [36, 37], VDM++ [39], Z++ [27, 26], OOZE <ref> [1, 2, 3] </ref>, and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's abstract values may have more <p> in the trait shown in Figure 12.) 11 imports QuadShape, NoInterior; abstract class ParallelShape : public QuadShape - public: uses QuadSubtype (ParallelShape, QuadShape); simulates QuadShape by toSuperWithoutChange; uses IsaParallelogram; invariant isaParallelogram (self * .edges); virtual double AnglePar () const throw (NoInterior) - requires : (self^.edges [1] = 0 _ self^.edges <ref> [2] </ref> = 0); ensures informally "result is the angle between self^.edges [1] and" "self^.edges [2]"; requires self^.edges [1] = 0 _ self^.edges [2] = 0; ensures thrown (NoInterior) = theException; - IsaParallelogram: trait includes FourSidedFigure introduces isaParallelogram: Edges ! Bool asserts 8 e: Edges isaParallelogram (e) == isLoop (e) ^ (e.v1 <p> : public QuadShape - public: uses QuadSubtype (ParallelShape, QuadShape); simulates QuadShape by toSuperWithoutChange; uses IsaParallelogram; invariant isaParallelogram (self * .edges); virtual double AnglePar () const throw (NoInterior) - requires : (self^.edges [1] = 0 _ self^.edges <ref> [2] </ref> = 0); ensures informally "result is the angle between self^.edges [1] and" "self^.edges [2]"; requires self^.edges [1] = 0 _ self^.edges [2] = 0; ensures thrown (NoInterior) = theException; - IsaParallelogram: trait includes FourSidedFigure introduces isaParallelogram: Edges ! Bool asserts 8 e: Edges isaParallelogram (e) == isLoop (e) ^ (e.v1 + e.v3 = 0:Vector); implies 8 e: Edges isaParallelogram (e) == isLoop (e) ^ <p> QuadShape); simulates QuadShape by toSuperWithoutChange; uses IsaParallelogram; invariant isaParallelogram (self * .edges); virtual double AnglePar () const throw (NoInterior) - requires : (self^.edges [1] = 0 _ self^.edges <ref> [2] </ref> = 0); ensures informally "result is the angle between self^.edges [1] and" "self^.edges [2]"; requires self^.edges [1] = 0 _ self^.edges [2] = 0; ensures thrown (NoInterior) = theException; - IsaParallelogram: trait includes FourSidedFigure introduces isaParallelogram: Edges ! Bool asserts 8 e: Edges isaParallelogram (e) == isLoop (e) ^ (e.v1 + e.v3 = 0:Vector); implies 8 e: Edges isaParallelogram (e) == isLoop (e) ^ (e.v2 + e.v4 = 0:Vector); An interesting aspect
Reference: [3] <author> A. J. Alencar and J. A. Goguen. </author> <title> Specification in OOZE with examples. </title> <booktitle> In Lano and Haughton [25], </booktitle> <pages> pages 158-183. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [27, 26], ZEST [11], Object-Z [40, 41], OOZE <ref> [1, 2, 3] </ref>, MooZ [36, 37], and VDM++ [39]. However, apparently there are "variants of Fresco" [48, 49] that are "derived from C++ and Smalltalk" [50, p. 135]; these may permit more exact specification of interface details. <p> PreVector (Scalar, Vector for Vec [T]), int Edges tuple of v1: Vector, v2: Vector, v3: Vector, v4: Vector introduces __ [__]: Edges, int ! Vector isLoop: Edges ! Bool asserts 8 e: Edges isLoop (e) == (e.v1 + e.v2 + e.v3 + e.v4 = 0:Vector); e [1] == e.v1; e <ref> [3] </ref> == e.v3; implies 8 e: Edges isLoop (e) == (e [1] + e [2] + e [3] + e [4] = 0:Vector); PreVectorSig (T): trait introduces __ + __: Vec [T], Vec [T] ! Vec [T] 0: ! Vec [T] __ - __: Vec [T], Vec [T] ! Vec [T] <p> Vector introduces __ [__]: Edges, int ! Vector isLoop: Edges ! Bool asserts 8 e: Edges isLoop (e) == (e.v1 + e.v2 + e.v3 + e.v4 = 0:Vector); e [1] == e.v1; e <ref> [3] </ref> == e.v3; implies 8 e: Edges isLoop (e) == (e [1] + e [2] + e [3] + e [4] = 0:Vector); PreVectorSig (T): trait introduces __ + __: Vec [T], Vec [T] ! Vec [T] 0: ! Vec [T] __ - __: Vec [T], Vec [T] ! Vec [T] __ __: Vec [T], Vec [T] ! T % inner product length: Vec [T] ! T % <p> But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [40, 41], MooZ [36, 37], VDM++ [39], Z++ [27, 26], OOZE <ref> [1, 2, 3] </ref>, and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's abstract values may have more
Reference: [4] <author> Pierre America. </author> <title> Inheritance and subtyping in a parallel object-oriented language. </title> <editor> In Jean Bezivin et al., editors, </editor> <booktitle> ECOOP '87, European Conference on Object-Oriented Programming, Paris, France, </booktitle> <pages> pages 234-242, </pages> <address> New York, N.Y., </address> <month> June </month> <year> 1987. </year> <title> Springer-Verlag. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 276. </volume>
Reference-contexts: [__]: Edges, int ! Vector isLoop: Edges ! Bool asserts 8 e: Edges isLoop (e) == (e.v1 + e.v2 + e.v3 + e.v4 = 0:Vector); e [1] == e.v1; e [3] == e.v3; implies 8 e: Edges isLoop (e) == (e [1] + e [2] + e [3] + e <ref> [4] </ref> = 0:Vector); PreVectorSig (T): trait introduces __ + __: Vec [T], Vec [T] ! Vec [T] 0: ! Vec [T] __ - __: Vec [T], Vec [T] ! Vec [T] __ __: Vec [T], Vec [T] ! T % inner product length: Vec [T] ! T % approximate length is <p> Informally, a type S is a behavioral subtype of T if objects of type S can act as if they are objects of type T <ref> [4, 5, 32, 28, 35, 33] </ref>. Having subclasses not implement subtypes would make for a poor design; it would also make such classes unim-plementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public super-classes [12].
Reference: [5] <author> Pierre America. </author> <title> Designing an object-oriented programming language with be-havioural subtyping. </title> <editor> In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, No-ordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 60-90. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can act as if they are objects of type T <ref> [4, 5, 32, 28, 35, 33] </ref>. Having subclasses not implement subtypes would make for a poor design; it would also make such classes unim-plementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public super-classes [12].
Reference: [6] <author> Axex Borgida, John Mylopoulos, and Rayomnd Reiter. </author> <title> On the frame problem in procedure specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(10) </volume> <pages> 785-798, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: It also allows exact C++ type information to be recorded. To illustrate the specification format, the body of Move has six clauses. The requires clause gives the function's precondition, the modifies and trashes clauses form a frame axiom <ref> [6] </ref>, the ensures clause gives the function's post-condition, the example clause gives a redundant example of its execution, and the claims clause states a redundant property of the specification. The postcondition, and the assertions in the example and claims clauses, are predicates over two states.
Reference: [7] <author> R. M. Burstall and J. A. Goguen. </author> <title> Algebras, theories and freeness: An introduction for computer scientists. </title> <editor> In Manfred Broy and Gunther Schmidt, editors, </editor> <booktitle> Theoretical Foundations of Programming Methodology: Lecture Notes of an International Summer School directed by F. </booktitle> <editor> L. Bauer, E. W. Dijkstra and C. A. R. </editor> <booktitle> Hoare, volume 91 of series C, </booktitle> <pages> pages 329-348. </pages> <address> D. Ridel, Dordrecht, Holland, </address> <year> 1982. </year>
Reference-contexts: In the theory section, the generated by clause states that all abstract values of type Q are equivalent to [e,v] for some e and v. (This corresponds to the "no junk" principle of the initial algebra approach <ref> [15, 7, 14] </ref>.
Reference: [8] <author> Patrice Chalin. </author> <title> On the Language Design and Semantic Foundation of LCL, a Larch/C Interface Specification Language. </title> <type> PhD thesis, </type> <institution> Concordia University, 1455 de Maisonneuve Blvd. West, Montreal, Qquebec, Canada, </institution> <month> October </month> <year> 1995. </year> <note> Available as CU/DCS TR 95-12. </note>
Reference-contexts: Having a distinction between modification and trashing may seem counterintuitive, but is important in helping shorten the specifications users have to write. In LCL and other Larch interface languages, these notions are not separated, which this leads to semantic problems <ref> [8, 9] </ref>. By following Chalin's ideas, most Larch/C++ function specifications do not have to make assertions about objects being allocated and assigned in postconditions. <p> More important for expressiveness are some fundamental semantic ideas that, while they also add to the complexity of the language, add new dimensions to the expressiveness of the language. One semantic idea is the distinction between trashing and modification <ref> [8, 9] </ref>, which places the frame axiom of Larch-style specification languages on a firm semantic foundation. In Larch/C++ one can also specify such notions as whether storage is allocated or assigned.
Reference: [9] <author> Patrice Chalin, Peter Grogono, and T. Radhakrishnan. </author> <title> Identification of and solutions to shortcomings of LCL, a Larch/C interface specification language. </title> <booktitle> In Proceedings of the FME'96 Symposium. FME'96: Industrial Benefit and Advances in Formal Methods, Formal Methods Europe., </booktitle> <year> 1996. </year> <note> To appear. An earlier version of this paper is available as Concordia University, Department of Computer Science TR 95-09. </note>
Reference-contexts: Having a distinction between modification and trashing may seem counterintuitive, but is important in helping shorten the specifications users have to write. In LCL and other Larch interface languages, these notions are not separated, which this leads to semantic problems <ref> [8, 9] </ref>. By following Chalin's ideas, most Larch/C++ function specifications do not have to make assertions about objects being allocated and assigned in postconditions. <p> More important for expressiveness are some fundamental semantic ideas that, while they also add to the complexity of the language, add new dimensions to the expressiveness of the language. One semantic idea is the distinction between trashing and modification <ref> [8, 9] </ref>, which places the frame axiom of Larch-style specification languages on a firm semantic foundation. In Larch/C++ one can also specify such notions as whether storage is allocated or assigned.
Reference: [10] <author> Yoonsik Cheon and Gary T. Leavens. </author> <title> The Larch/Smalltalk interface specification language. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 3(3) </volume> <pages> 221-253, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Examples include LCL [18, Chapter 5] (for C), LM3 [18, Chapter 6] (for Modula-3), Larch/Ada [17] (for Ada), Larch/CLU [52, 51] (for CLU), Larch/Smalltalk <ref> [10] </ref> (for Smalltalk) and Larch/C++. The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed [24]. <p> In Larch-style BISLs, such as Larch/C++, LM3 [18, Chapter 6], and Larch/Smalltalk <ref> [10] </ref>, abstract values of object do not have to be tuples. This means that there is a problem in giving a semantics to inherited specifications.
Reference: [11] <editor> Elspeth Cusack and G. H. B. Rafsanjani. ZEST. In Stepney et al. </editor> <volume> [44], </volume> <pages> pages 113-126. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [27, 26], ZEST <ref> [11] </ref>, Object-Z [40, 41], OOZE [1, 2, 3], MooZ [36, 37], and VDM++ [39]. However, apparently there are "variants of Fresco" [48, 49] that are "derived from C++ and Smalltalk" [50, p. 135]; these may permit more exact specification of interface details. <p> assumes RingWithUnit, Abelian (* for ffi) includes AbelianGroup (Vec [T] for T, + for ffi, 0 for unit, - __ for 1 ), DistributiveRingAction (T for M, Vec [T] for T) % ... implications omitted ... to the behavioral interface specifications. 2.2 Specification of QuadShape and Quadrilateral Following the ZEST <ref> [11] </ref> and Fresco [50] specifications of the shapes example, the first class to specify is an abstract class of four-sided figures, QuadShape. The reason for this is that, if we follow [44, Chapter 2], then quadrilaterals are shearable, but some subtypes (rectangle, rhombus, and square) are not. <p> But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [40, 41], MooZ [36, 37], VDM++ [39], Z++ [27, 26], OOZE [1, 2, 3], and ZEST <ref> [11] </ref>, there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's abstract values may have more such abstract fields than the <p> For example, in Larch/C++ one could start out by using largely informal specifications, and then increase the level of formality as needed or desired. 3 Other Subtypes of QuadShape This section contains the behavioral interface specifications of the other sub-types of QuadShape described in [44]. As in <ref> [11] </ref>, we start with the abstract type ParallelShape, which is shown in Figure 11.
Reference: [12] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Forcing behavioral subtyping through specification inheritance. </title> <type> Technical Report 95-20b, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, December </month> <year> 1995. </year> <booktitle> To appear in proceedings of the 18th International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <year> 1996. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. 17 </note>
Reference-contexts: Having subclasses not implement subtypes would make for a poor design; it would also make such classes unim-plementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public super-classes <ref> [12] </ref>. Thus we will follow the ZEST and Fresco specifications in using an abstract class without a shear operation as the superclass of Quadrilateral. <p> Technically, in Larch/C++ behavioral subtyping is forced by inheriting the specification of the supertype's invariant and virtual member functions in the subtype <ref> [12] </ref>. The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. <p> What Larch/C++ currently (in release 4.1) requires is that the user specify a simulation function, which maps the abstract values of subtype objects to the abstract values of supertype objects <ref> [12] </ref>. Inheritance of the su-pertype's specifications is accomplished by applying the simulation function to each term whose type is the supertype. <p> In <ref> [12] </ref>, we give more interesting examples, in which the abstract models of the subtype objects contain more information than objects of their supertypes. However, the shapes example does permit direct comparison to the OO specification languages presented in [44]. <p> Allowing the specification of several specification cases (an idea due to Wills [48, 50, 49]) is convenient for the specification of exceptions and for giving a concrete form to specification inheritance <ref> [12] </ref>. Furthermore, when combined with the ability to specify both total and partial correctness, the expressiveness of the specification language becomes much more complete [20].
Reference: [13] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Larch/C++ [30] is a model-based specification language that allows the specification of both the exact interface and the behavior of a C++ <ref> [13, 45] </ref> program module. 1.1 Model-Based Specification The idea of model-based specifications builds on two seminal papers by Hoare. Hoare's paper "An Axiomatic Basis for Computer Programming" [21], used two predicates over program states to specify a computation.
Reference: [14] <author> Kokichi Futatsugi, Joseph A. Goguen, Jean-Pierre Jouannaud, and Jose Meseguer. </author> <booktitle> Principles of OBJ2. In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 52-66. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1985. </year>
Reference-contexts: In the theory section, the generated by clause states that all abstract values of type Q are equivalent to [e,v] for some e and v. (This corresponds to the "no junk" principle of the initial algebra approach <ref> [15, 7, 14] </ref>. <p> (The first three assumed traits are found in [18, Appendix A]; the last trait, and the included trait Real that specifies the real numbers, are found in [31].) The use of traits for stating such assumptions is similar to the way that theories are used for parameterized specifications in OBJ <ref> [16, 14] </ref>. The assertions in the trait PreVector specify the theory of an inner product and the approximate length function. (Comments in LSL start with % and continue to the end of a line.) Two features of the implies section not previously seen are illustrated in this trait.
Reference: [15] <author> J. A. Goguen, J. W. Thatcher, and E. G. Wagner. </author> <title> An initial algebra approach to the specification, correctness and implementation of abstract data types. </title> <editor> In Raymond T. Yeh, editor, </editor> <booktitle> Current Trends in Programming Methodology, </booktitle> <volume> volume 4, </volume> <pages> pages 80-149. </pages> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1978. </year>
Reference-contexts: In the theory section, the generated by clause states that all abstract values of type Q are equivalent to [e,v] for some e and v. (This corresponds to the "no junk" principle of the initial algebra approach <ref> [15, 7, 14] </ref>.
Reference: [16] <author> Joseph A. Goguen. </author> <title> Parameterized programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(5):528-543, </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: (The first three assumed traits are found in [18, Appendix A]; the last trait, and the included trait Real that specifies the real numbers, are found in [31].) The use of traits for stating such assumptions is similar to the way that theories are used for parameterized specifications in OBJ <ref> [16, 14] </ref>. The assertions in the trait PreVector specify the theory of an inner product and the approximate length function. (Comments in LSL start with % and continue to the end of a line.) Two features of the implies section not previously seen are illustrated in this trait.
Reference: [17] <author> David Guaspari, Carla Marceau, and Wolfgang Polak. </author> <title> Formal verification of Ada programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 1058-1075, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Examples include LCL [18, Chapter 5] (for C), LM3 [18, Chapter 6] (for Modula-3), Larch/Ada <ref> [17] </ref> (for Ada), Larch/CLU [52, 51] (for CLU), Larch/Smalltalk [10] (for Smalltalk) and Larch/C++. The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed [24].
Reference: [18] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: The toolkit in Z is based on set theory; it has a relatively elaborate notation for various set constructions, as well as powerful techniques for combining specifications (the schema calculus). 1.2 Larch The work of Wing, Guttag, and Horning on Larch extends the VDM-SL and Z tradition in two directions <ref> [52, 51, 18] </ref>: * Although a mathematical toolkit is provided [18, Appendix A], specifiers may design their own mathematical theories using the Larch Shared Language (LSL) [18, Chapter 4]. <p> has a relatively elaborate notation for various set constructions, as well as powerful techniques for combining specifications (the schema calculus). 1.2 Larch The work of Wing, Guttag, and Horning on Larch extends the VDM-SL and Z tradition in two directions [52, 51, 18]: * Although a mathematical toolkit is provided <ref> [18, Appendix A] </ref>, specifiers may design their own mathematical theories using the Larch Shared Language (LSL) [18, Chapter 4]. <p> specifications (the schema calculus). 1.2 Larch The work of Wing, Guttag, and Horning on Larch extends the VDM-SL and Z tradition in two directions [52, 51, 18]: * Although a mathematical toolkit is provided [18, Appendix A], specifiers may design their own mathematical theories using the Larch Shared Language (LSL) <ref> [18, Chapter 4] </ref>. This allows users, if they desire, to create and use an abstract model at exactly the right level of abstraction; that is, one can either build an abstract model out of readily available parts, or one can build a model from scratch. <p> Examples include LCL <ref> [18, Chapter 5] </ref> (for C), LM3 [18, Chapter 6] (for Modula-3), Larch/Ada [17] (for Ada), Larch/CLU [52, 51] (for CLU), Larch/Smalltalk [10] (for Smalltalk) and Larch/C++. <p> Examples include LCL [18, Chapter 5] (for C), LM3 <ref> [18, Chapter 6] </ref> (for Modula-3), Larch/Ada [17] (for Ada), Larch/CLU [52, 51] (for CLU), Larch/Smalltalk [10] (for Smalltalk) and Larch/C++. The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed [24]. <p> abstract class QuadShape and the class Quadrilateral. 2.1 Abstract Model of Quadrilaterals Although LSL has the power to specify abstract models "from scratch," most abstract models are built using tuples (records), sets, and other standard mathematical tools that are either built-in to LSL or found in Guttag and Horning's Handbook <ref> [18, Appendix A] </ref>. A typical example is given in Figure 1. That figure specifies a theory in LSL, using a LSL module, which is called a trait . <p> __ - __: Vec [T], Vec [T] ! Vec [T] __ __: Vec [T], Vec [T] ! T % inner product length: Vec [T] ! T % approximate length is to be treated as a "given". to and from the real numbers. (The first three assumed traits are found in <ref> [18, Appendix A] </ref>; the last trait, and the included trait Real that specifies the real numbers, are found in [31].) The use of traits for stating such assumptions is similar to the way that theories are used for parameterized specifications in OBJ [16, 14]. <p> To push this mathematical modeling back to standard traits, one needs the trait PreVectorSpace, found in Figure 6. (The trait DistributiveRingAction is found in [31], the other traits are from <ref> [18, Appendix A] </ref>.) Now that we are done with the initial mathematical modeling, we can turn 5 PreVector (T): trait assumes RingWithUnit, Abelian (* for ffi), TotalOrder, CoerceToReal (T) includes PreVectorSpace (T), Real introduces __ __: Vec [T], Vec [T] ! T % inner product length: Vec [T] ! T asserts <p> In the specification of GetVec, i is passed by value. Thus i is not considered an object within the specification. This is why i denotes an int value, and why notations such as i^are not used <ref> [18, Chapter 5] </ref>. The invariant clause describes a property that must hold in each visible state; it can be thought of as implicitly conjoined to the pre- and postcondi-tions of each member function specification. <p> In Larch-style BISLs, such as Larch/C++, LM3 <ref> [18, Chapter 6] </ref>, and Larch/Smalltalk [10], abstract values of object do not have to be tuples. This means that there is a problem in giving a semantics to inherited specifications.
Reference: [19] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: The pre- and postconditions use the vocabulary specified in an abstract model, which specifies the abstract values mathematically. fl Leavens's work was supported in part by NSF grant CCR-9593168. 1 The best-known model-based specification languages are VDM-SL [23] and Z <ref> [43, 42, 19] </ref>. Both come with a mathematical toolkit from which a user can assemble abstract models for use in specifying procedures.
Reference: [20] <author> Wim H. Hesselink. </author> <title> Programs, Recursion, and Unbounded Choice, </title> <booktitle> volume 27 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: Furthermore, when combined with the ability to specify both total and partial correctness, the expressiveness of the specification language becomes much more complete <ref> [20] </ref>. When combined with the approach of behavioral interface specification, the expressive features of Larch/C++ make it a step towards the day when formal documentation of C++ class libraries will be practical and useful. 16 Acknowledgements This work was supported in part by NSF grant CCR-9593168.
Reference: [21] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: Hoare's paper "An Axiomatic Basis for Computer Programming" <ref> [21] </ref>, used two predicates over program states to specify a computation. The first predicate specifies the requirements on the state before the computation; it is called the computation's precondition. The second predicate specifies the desired final state; it is called the computation's postcondition. <p> More important, allowing the user to specify both total and partial correctness for functions gives to users a choice previously reserved by specification language designers; the use of partial correctness, for example, is necessary for succinct specification of functions that may fail due to the finiteness of various data structures <ref> [21] </ref>. Allowing the specification of several specification cases (an idea due to Wills [48, 50, 49]) is convenient for the specification of exceptions and for giving a concrete form to specification inheritance [12].
Reference: [22] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: The first predicate specifies the requirements on the state before the computation; it is called the computation's precondition. The second predicate specifies the desired final state; it is called the computation's postcondition. Hoare's paper "Proof of correctness of data representations" <ref> [22] </ref>, described the verification of abstract data type (ADT) implementations. In this paper Hoare introduced the use of an abstraction function that maps the implementation data structure (e.g., an array) to a mathematical value space (e.g., a set). The elements of this value space are thus called abstract values [34].
Reference: [23] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: The pre- and postconditions use the vocabulary specified in an abstract model, which specifies the abstract values mathematically. fl Leavens's work was supported in part by NSF grant CCR-9593168. 1 The best-known model-based specification languages are VDM-SL <ref> [23] </ref> and Z [43, 42, 19]. Both come with a mathematical toolkit from which a user can assemble abstract models for use in specifying procedures.
Reference: [24] <author> Leslie Lamport. </author> <title> A simple approach to specifying concurrent systems. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 32-45, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed <ref> [24] </ref>. This is of great practical benefit, because the details of the interface that need to be specified vary among programming languages.
Reference: [25] <author> K. Lano and H. Haughton, </author> <title> editors. Object-Oriented Specification Case Studies. The Object-Oriented Series. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference: [26] <author> K. Lano and H. Haughton. </author> <title> Specifying a concept-recognition system in Z++. </title> <booktitle> In Lano and Haughton [25], chapter 7, </booktitle> <pages> pages 137-157. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ <ref> [27, 26] </ref>, ZEST [11], Object-Z [40, 41], OOZE [1, 2, 3], MooZ [36, 37], and VDM++ [39]. However, apparently there are "variants of Fresco" [48, 49] that are "derived from C++ and Smalltalk" [50, p. 135]; these may permit more exact specification of interface details. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [40, 41], MooZ [36, 37], VDM++ [39], Z++ <ref> [27, 26] </ref>, OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's abstract values
Reference: [27] <editor> Kevin C. Lano. Z++. In Stepney et al. </editor> <volume> [44], </volume> <pages> pages 106-112. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ <ref> [27, 26] </ref>, ZEST [11], Object-Z [40, 41], OOZE [1, 2, 3], MooZ [36, 37], and VDM++ [39]. However, apparently there are "variants of Fresco" [48, 49] that are "derived from C++ and Smalltalk" [50, p. 135]; these may permit more exact specification of interface details. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [40, 41], MooZ [36, 37], VDM++ [39], Z++ <ref> [27, 26] </ref>, OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's abstract values
Reference: [28] <author> Gary T. Leavens. </author> <title> Modular specification and verification of object-oriented programs. </title> <journal> IEEE Software, </journal> <volume> 8(4) </volume> <pages> 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can act as if they are objects of type T <ref> [4, 5, 32, 28, 35, 33] </ref>. Having subclasses not implement subtypes would make for a poor design; it would also make such classes unim-plementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public super-classes [12].
Reference: [29] <author> Gary T. Leavens. </author> <title> Inheritance of interface specifications (extended abstract). </title> <booktitle> In Proceedings of the Workshop on Interface Definition Languages, volume 29(8) of ACM SIGPLAN Notices, </booktitle> <pages> pages 129-138, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: However, because that solution seems to have modularity problems <ref> [29] </ref>, a slightly less general solution is currently used in Larch/C++. What Larch/C++ currently (in release 4.1) requires is that the user specify a simulation function, which maps the abstract values of subtype objects to the abstract values of supertype objects [12].
Reference: [30] <author> Gary T. Leavens. </author> <note> Larch/C++ Reference Manual. Version 4.1. Available in ftp://ftp.cs.iastate.edu/pub/larchc++/lcpp.ps.gz or on the world wide web at the URL http://www.cs.iastate.edu/~leavens/larchc++.html, December 1995. </note>
Reference-contexts: 1 Introduction Larch/C++ <ref> [30] </ref> is a model-based specification language that allows the specification of both the exact interface and the behavior of a C++ [13, 45] program module. 1.1 Model-Based Specification The idea of model-based specifications builds on two seminal papers by Hoare. <p> This trait itself includes instances of two other traits: FourSidedFigure, and NoContainedObjects (Q). The latter of these simply says that an abstract value of type Q has no subobjects <ref> [30, Section 7.5] </ref>. The type Q itself is defined next, by using the built-in LSL tuple of notation. What LSL calls a tuple is a record-like value; in this case the tuple has two fields: edges of type Edges and position of type Vector. <p> The Larch/C++ specification of the abstract class QuadShape is given in Larch/C++, one could also specify QuadShape as a C++ template class with the types Vector and Scalar as type parameters <ref> [30, Chapter 8] </ref>, but the approach adopted here is more in keeping with the examples in [44]. In the specification of QuadShape, the first thing to note is that much of the syntax is the same as in C++. <p> The box may also be empty. When the box empty, the object is said to be unassigned ; an object is assigned when it contains a proper value. C++ objects are formally modeled in Larch/C++ using various traits <ref> [30, Section 2.8] </ref>, and these traits allow one to write assigned (v, pre) to assert that the 7 imports Vector; abstract class QuadShape - public: uses Quad (QuadShape); invariant isLoop (self * .edges); virtual Move (const Vector& v) - requires assigned (v, pre); modifies self; trashes nothing; ensures liberally self' = <p> that the post-state value of the receiver object is equal to the pre-state value, with the position field changed to the pre-state position plus the pre-state value of the vector v. (Except for constructors, the object self is implicitly required to be assigned in every member function of a class <ref> [30, Section 6.2.2] </ref>.) The ensures clause of Move's specification uses the Larch/C++ keyword liberally. <p> This is because, if an object is modified, it must stay allocated, and if it was assigned in the pre-state, it must also be assigned in the post-state <ref> [30, Section 6.2.3] </ref>. An example adds checkable redundancy to a specification. There may be several examples listed in a single function specification in Larch/C++. <p> An example adds checkable redundancy to a specification. There may be several examples listed in a single function specification in Larch/C++. For each example, what is checked is roughly that the example's assertion, together with the precondition should imply the postcondition <ref> [30, Section 6.7] </ref>. (The 9 in the example given is typed as "E by users.) As far as we know, this idea of adding examples to formal function specifications is new in Larch/C++. <p> Although the mathematics of angles is left informal, the specification of the exception is formalized. The term thrown (NoInterior) denotes the abstract value of the exception result The specification of the type NoInterior is in Figure 13. This specification uses the Larch/C++ built-in trait NoInformationExecption <ref> [30, Section 6.9] </ref> to specify the abstract model of the type NoInterior. This trait is designed as an aid in specifying abstract models for exceptions in which no significant information is being passed; it says that there is only one abstract value: theException.
Reference: [31] <author> Gary T. Leavens. </author> <note> LSL math traits. http://www.cs.iastate.edu/~leavens/Math-traits.html, Jan 1996. </note>
Reference-contexts: inner product length: Vec [T] ! T % approximate length is to be treated as a "given". to and from the real numbers. (The first three assumed traits are found in [18, Appendix A]; the last trait, and the included trait Real that specifies the real numbers, are found in <ref> [31] </ref>.) The use of traits for stating such assumptions is similar to the way that theories are used for parameterized specifications in OBJ [16, 14]. <p> On the other hand, the length operator is not so well-specified, and thus is not named in the converts clause. To push this mathematical modeling back to standard traits, one needs the trait PreVectorSpace, found in Figure 6. (The trait DistributiveRingAction is found in <ref> [31] </ref>, the other traits are from [18, Appendix A].) Now that we are done with the initial mathematical modeling, we can turn 5 PreVector (T): trait assumes RingWithUnit, Abelian (* for ffi), TotalOrder, CoerceToReal (T) includes PreVectorSpace (T), Real introduces __ __: Vec [T], Vec [T] ! T % inner product
Reference: [32] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about object-oriented programs that use subtypes (extended abstract). </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> OOPSLA ECOOP '90 Proceedings, volume 25(10) of ACM SIGPLAN Notices, </booktitle> <pages> pages 212-223. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1990. </year> <month> 18 </month>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can act as if they are objects of type T <ref> [4, 5, 32, 28, 35, 33] </ref>. Having subclasses not implement subtypes would make for a poor design; it would also make such classes unim-plementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public super-classes [12].
Reference: [33] <author> Gary T. Leavens and William E. Weihl. </author> <title> Specification and verification of object--oriented programs using supertype abstraction. </title> <journal> Acta Informatica, </journal> <volume> 32(8) </volume> <pages> 705-778, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can act as if they are objects of type T <ref> [4, 5, 32, 28, 35, 33] </ref>. Having subclasses not implement subtypes would make for a poor design; it would also make such classes unim-plementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public super-classes [12].
Reference: [34] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: In this paper Hoare introduced the use of an abstraction function that maps the implementation data structure (e.g., an array) to a mathematical value space (e.g., a set). The elements of this value space are thus called abstract values <ref> [34] </ref>. The idea is that one specifies the ADT using the abstract values, which allows clients of the ADT's operations to reason about calls without worrying about the details of the implementation. A model-based specification language combines these ideas.
Reference: [35] <author> Barbara Liskov and Jeannette Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> Novem-ber </month> <year> 1994. </year>
Reference-contexts: Informally, a type S is a behavioral subtype of T if objects of type S can act as if they are objects of type T <ref> [4, 5, 32, 28, 35, 33] </ref>. Having subclasses not implement subtypes would make for a poor design; it would also make such classes unim-plementable if specified in Larch/C++. This is because Larch/C++ forces subclasses to specify behavioral subtypes of the types of their public super-classes [12].
Reference: [36] <author> Silvio Lemos Meira and Ana Lucia C. Cavalcanti. </author> <title> MooZ case studies. </title> <editor> In Stepney et al. </editor> <volume> [44], </volume> <pages> pages 37-58. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [27, 26], ZEST [11], Object-Z [40, 41], OOZE [1, 2, 3], MooZ <ref> [36, 37] </ref>, and VDM++ [39]. However, apparently there are "variants of Fresco" [48, 49] that are "derived from C++ and Smalltalk" [50, p. 135]; these may permit more exact specification of interface details. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [40, 41], MooZ <ref> [36, 37] </ref>, VDM++ [39], Z++ [27, 26], OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract
Reference: [37] <author> Silvio Lemos Meira, Ana Lucia C. Cavalcanti, and Cassio Souza Santos. </author> <title> The Unix filing system: A MooZ specification. </title> <booktitle> In Lano and Haughton [25], chapter 4, </booktitle> <pages> pages 80-109. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [27, 26], ZEST [11], Object-Z [40, 41], OOZE [1, 2, 3], MooZ <ref> [36, 37] </ref>, and VDM++ [39]. However, apparently there are "variants of Fresco" [48, 49] that are "derived from C++ and Smalltalk" [50, p. 135]; these may permit more exact specification of interface details. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [40, 41], MooZ <ref> [36, 37] </ref>, VDM++ [39], Z++ [27, 26], OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract
Reference: [38] <author> Tan Yang Meng. </author> <title> Formal Specification Techniques for Engineering Modular C Programs, </title> <booktitle> volume 1 of Kluwer International Series in Software Engineering. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1995. </year>
Reference-contexts: As such, it has no "constructors" and therefore no objects will exist that are direct instances of such a class. This extra information could be used in consistency checking tool <ref> [47, 46, 38] </ref>. Traits, including those that define the abstract model, are noted in uses clauses. <p> Another instance of the checkable redundancy idea is the claims clause, which is a feature of Tan's work on LCL <ref> [47, 46, 38] </ref>. This borrowing from LCL can be used to state a redundantly checkable property implied by the conjunction of the precondition and postcondition. In the example, the claim follows from the postcondition and the meaning of set_position (see Figures 1 and 2). <p> The example clause is new with Larch/C++; the idea for the claims clause is due to Tan <ref> [47, 46, 38] </ref>. More important for expressiveness are some fundamental semantic ideas that, while they also add to the complexity of the language, add new dimensions to the expressiveness of the language.
Reference: [39] <author> Swapan Mitra. </author> <title> Object-oriented specification in VDM++. </title> <booktitle> In Lano and Haughton [25], chapter 6, </booktitle> <pages> pages 130-136. </pages>
Reference-contexts: The same remark applies to object-oriented (OO) specification languages such as Z++ [27, 26], ZEST [11], Object-Z [40, 41], OOZE [1, 2, 3], MooZ [36, 37], and VDM++ <ref> [39] </ref>. However, apparently there are "variants of Fresco" [48, 49] that are "derived from C++ and Smalltalk" [50, p. 135]; these may permit more exact specification of interface details. The remainder of this chapter gives a set of examples in Larch/C++, and then concludes with a discussion. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z [40, 41], MooZ [36, 37], VDM++ <ref> [39] </ref>, Z++ [27, 26], OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or schema) of abstract fields; the subtype's
Reference: [40] <editor> Gordon Rose. Object-Z. In Stepney et al. </editor> <volume> [44], </volume> <pages> pages 59-77. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [27, 26], ZEST [11], Object-Z <ref> [40, 41] </ref>, OOZE [1, 2, 3], MooZ [36, 37], and VDM++ [39]. However, apparently there are "variants of Fresco" [48, 49] that are "derived from C++ and Smalltalk" [50, p. 135]; these may permit more exact specification of interface details. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z <ref> [40, 41] </ref>, MooZ [36, 37], VDM++ [39], Z++ [27, 26], OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or
Reference: [41] <author> Gordon Rose and Roger Duke. </author> <title> An Object-Z specification of a mobile phone system. </title> <booktitle> In Lano and Haughton [25], chapter 5, </booktitle> <pages> pages 110-129. </pages>
Reference-contexts: No such details can be specified directly in a specification language such as VDM-SL or Z that is not tailored to C++. The same remark applies to object-oriented (OO) specification languages such as Z++ [27, 26], ZEST [11], Object-Z <ref> [40, 41] </ref>, OOZE [1, 2, 3], MooZ [36, 37], and VDM++ [39]. However, apparently there are "variants of Fresco" [48, 49] that are "derived from C++ and Smalltalk" [50, p. 135]; these may permit more exact specification of interface details. <p> The technical problem to overcome is that the supertype's specifications were written as if self were a supertype object. But when applying such specifications to the subtype, self is a subtype object. In most OO specification languages, including Object-Z <ref> [40, 41] </ref>, MooZ [36, 37], VDM++ [39], Z++ [27, 26], OOZE [1, 2, 3], and ZEST [11], there is no problem treating the subtype's abstract values as abstract values of the supertypes (and in deciding how to do that), because every object's abstract value is a tuple (i.e., a record or
Reference: [42] <author> J. Spivey. </author> <title> An introduction to Z and formal specifications. </title> <journal> Software Engineering Journal, </journal> <month> January </month> <year> 1989. </year>
Reference-contexts: The pre- and postconditions use the vocabulary specified in an abstract model, which specifies the abstract values mathematically. fl Leavens's work was supported in part by NSF grant CCR-9593168. 1 The best-known model-based specification languages are VDM-SL [23] and Z <ref> [43, 42, 19] </ref>. Both come with a mathematical toolkit from which a user can assemble abstract models for use in specifying procedures.
Reference: [43] <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: The pre- and postconditions use the vocabulary specified in an abstract model, which specifies the abstract values mathematically. fl Leavens's work was supported in part by NSF grant CCR-9593168. 1 The best-known model-based specification languages are VDM-SL [23] and Z <ref> [43, 42, 19] </ref>. Both come with a mathematical toolkit from which a user can assemble abstract models for use in specifying procedures.
Reference: [44] <author> Susan Stepney, Rosalind Barden, and David Cooper, </author> <title> editors. Object Orientation in Z. Workshops in Computing. </title> <publisher> Springer-Verlag, </publisher> <address> Cambridge CB2 1LQ, UK, </address> <year> 1992. </year>
Reference-contexts: The remainder of this chapter gives a set of examples in Larch/C++, and then concludes with a discussion. The set of examples specifies a hierarchy of shapes that is used as a case study in the book Object Orientation in Z <ref> [44] </ref>. 2 Quadrilaterals To write a specification in Larch/C++, one specifies an abstract model in LSL, and then uses that to specify the C++ interface and its behavior. <p> The trait FourSidedFigure defines the type Edges as a tuple of four Vector values. As a convenience, the trait also introduces the operator, __ [__], which allows one to write e [1] instead of e.v1. In the asserts section, the specification defines the condition on four-sided figures from <ref> [44] </ref> as a predicate. The predicate isLoop (e) holds just when the vectors sum to zero (make a loop). <p> Such properties must be handled by either constructing an abstract model from scratch, or by asserting that the property holds at the interface level, as is done below.) In <ref> [44] </ref>, vectors are usually treated as a given set, meaning that their specification is of no interest. <p> In this trait's assumes clause, the type T is required to be a ring with a unit element, have a commutative multiplication operator, be totally ordered, and to have conversions 1 In the trait FourSidedFigure, the type Vec [T] is renamed to be Vector. The specifications in <ref> [44] </ref> are a bit vague on exactly what capabilities are needed by the scalar type (which is named Scalar in FourSidedFigure and T in the trait PreVector). <p> The reason for this is that, if we follow <ref> [44, Chapter 2] </ref>, then quadrilaterals are shearable, but some subtypes (rectangle, rhombus, and square) are not. <p> The reason for this is that, if we follow [44, Chapter 2], then quadrilaterals are shearable, but some subtypes (rectangle, rhombus, and square) are not. If we were to follow the class hierarchy given on page 8 of <ref> [44] </ref>, there would be problems, because the classes Rectangle, Rhombus, and Square would be sub 6 types but not behavioral subtypes of the types of their superclasses. <p> The Larch/C++ specification of the abstract class QuadShape is given in Larch/C++, one could also specify QuadShape as a C++ template class with the types Vector and Scalar as type parameters [30, Chapter 8], but the approach adopted here is more in keeping with the examples in <ref> [44] </ref>. In the specification of QuadShape, the first thing to note is that much of the syntax is the same as in C++. Indeed, all of the C++ declaration syntax (with a few ambiguities removed) is supported by Larch/C++. <p> The specification of ShearBy illustrates another feature of Larch/C++: informal predicates. An informal predicate looks like the keyword informally, followed by a string constant. Such a predicate can be used to suppress details about a specification. This is done frequently in the specifications in <ref> [44] </ref> by using comments instead of formal specifications when discussing shearing. This also illustrates how one can use informal predicates to "tune" the level of formality in a Larch/C++ specification. <p> For example, in Larch/C++ one could start out by using largely informal specifications, and then increase the level of formality as needed or desired. 3 Other Subtypes of QuadShape This section contains the behavioral interface specifications of the other sub-types of QuadShape described in <ref> [44] </ref>. As in [11], we start with the abstract type ParallelShape, which is shown in Figure 11. <p> trait includes FourSidedFigure introduces isaParallelogram: Edges ! Bool asserts 8 e: Edges isaParallelogram (e) == isLoop (e) ^ (e.v1 + e.v3 = 0:Vector); implies 8 e: Edges isaParallelogram (e) == isLoop (e) ^ (e.v2 + e.v4 = 0:Vector); An interesting aspect of ParallelShape (apparently overlooked in all the specifications in <ref> [44] </ref>) is that if all the sides of a quadrilateral are zero length, then the angle to be returned by AnglePar is not well defined. The specification of AnglePar illustrates how to specify exceptions to handle such cases. <p> Quadrilateral); simulates Quadrilateral by toSuperWithoutChange; uses QuadSubtype (Parallelogram, ParallelShape); simulates ParallelShape by toSuperWithoutChange; Parallelogram (Vector v1, Vector v2, Vector pos) - modifies self; ensures liberally self' = [[v1, v2, -v1, -v2], pos]; - (specified in Figure 14) is a public subclass of Quadrilateral and ParallelShape. (This follows the design in <ref> [44] </ref>; whether this is a good idea for a design in C++ is debatable.) It inherits the specifications of each, including the ShearBy member function of Quadrilateral, and the invariant from ParallelShape (including the inherited invariant from QuadShape). This is done by specifying a simulation function for each supertype. <p> isaRhombus (e) == isaParallelogram (e) ^ (length (e.v1) = length (e.v2)); implies 8 e: Edges isaRhombus (e) ) isaParallelogram (e); isaRhombus (e) == isaParallelogram (e) ^ (length (e.v1) = length (e.v3)); isaRhombus (e) == isaParallelogram (e) ^ (length (e.v1) = length (e.v4)); 4 Discussion and Conclusions The shapes example from <ref> [44] </ref> is perhaps not ideal for illustrating the mechanisms in Larch/C++ used for specification inheritance, as the subtypes all use isomorphic spaces of abstract values. In [12], we give more interesting examples, in which the abstract models of the subtype objects contain more information than objects of their supertypes. <p> In [12], we give more interesting examples, in which the abstract models of the subtype objects contain more information than objects of their supertypes. However, the shapes example does permit direct comparison to the OO specification languages presented in <ref> [44] </ref>. The following are the most basic points of similarity and difference. * The LSL traits specified in the examples correspond roughly to the Z specifications given in [44, Chapter 2]. This says that LSL is roughly comparable to Z in terms of modeling power. <p> However, the shapes example does permit direct comparison to the OO specification languages presented in [44]. The following are the most basic points of similarity and difference. * The LSL traits specified in the examples correspond roughly to the Z specifications given in <ref> [44, Chapter 2] </ref>. This says that LSL is roughly comparable to Z in terms of modeling power. <p> = pos; claims liberally isaSquare (self'.edges); - 15 IsaSquare: trait includes IsaRectangle, IsaRhombus introduces isaSquare: Edges ! Bool asserts 8 e: Edges isaSquare (e) == isaRectangle (e) ^ isaRhombus (e); * The behavioral interface specifications are roughly comparable to the various OO specifications written in the OO specification languages in <ref> [44] </ref>, in particular to ZEST and Fresco. However, only for Fresco is there even a hint [50, p. 135] that it may be able to specify the C++ interface details that Larch/C++ can specify. It is important that a formal specification language not require one to formalize every detail.
Reference: [45] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language: Second Edition. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Larch/C++ [30] is a model-based specification language that allows the specification of both the exact interface and the behavior of a C++ <ref> [13, 45] </ref> program module. 1.1 Model-Based Specification The idea of model-based specifications builds on two seminal papers by Hoare. Hoare's paper "An Axiomatic Basis for Computer Programming" [21], used two predicates over program states to specify a computation.
Reference: [46] <author> Yang Meng Tan. </author> <title> Formal specification techniques for promoting software modularity, enhancing documentation, and testing specifications. </title> <type> Technical Report 619, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, 545 Technology Square, </institution> <address> Cambridge, Mass., </address> <month> June </month> <year> 1994. </year>
Reference-contexts: As such, it has no "constructors" and therefore no objects will exist that are direct instances of such a class. This extra information could be used in consistency checking tool <ref> [47, 46, 38] </ref>. Traits, including those that define the abstract model, are noted in uses clauses. <p> Another instance of the checkable redundancy idea is the claims clause, which is a feature of Tan's work on LCL <ref> [47, 46, 38] </ref>. This borrowing from LCL can be used to state a redundantly checkable property implied by the conjunction of the precondition and postcondition. In the example, the claim follows from the postcondition and the meaning of set_position (see Figures 1 and 2). <p> The example clause is new with Larch/C++; the idea for the claims clause is due to Tan <ref> [47, 46, 38] </ref>. More important for expressiveness are some fundamental semantic ideas that, while they also add to the complexity of the language, add new dimensions to the expressiveness of the language.
Reference: [47] <author> Yang Meng Tan. </author> <title> Interface language for supporting programming styles. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(8) </volume> <pages> 74-83, </pages> <month> August </month> <year> 1994. </year> <booktitle> Proceedings of the Workshop on Interface Definition Languages. </booktitle>
Reference-contexts: As such, it has no "constructors" and therefore no objects will exist that are direct instances of such a class. This extra information could be used in consistency checking tool <ref> [47, 46, 38] </ref>. Traits, including those that define the abstract model, are noted in uses clauses. <p> Another instance of the checkable redundancy idea is the claims clause, which is a feature of Tan's work on LCL <ref> [47, 46, 38] </ref>. This borrowing from LCL can be used to state a redundantly checkable property implied by the conjunction of the precondition and postcondition. In the example, the claim follows from the postcondition and the meaning of set_position (see Figures 1 and 2). <p> The example clause is new with Larch/C++; the idea for the claims clause is due to Tan <ref> [47, 46, 38] </ref>. More important for expressiveness are some fundamental semantic ideas that, while they also add to the complexity of the language, add new dimensions to the expressiveness of the language.
Reference: [48] <author> Alan Wills. </author> <title> Capsules and types in Fresco: Program validation in Smalltalk. </title> <editor> In P. America, editor, </editor> <booktitle> ECOOP '91: European Conference on Object Oriented Programming, volume 512 of Lecture Notes in Computer Science, </booktitle> <pages> pages 59-76. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: The same remark applies to object-oriented (OO) specification languages such as Z++ [27, 26], ZEST [11], Object-Z [40, 41], OOZE [1, 2, 3], MooZ [36, 37], and VDM++ [39]. However, apparently there are "variants of Fresco" <ref> [48, 49] </ref> that are "derived from C++ and Smalltalk" [50, p. 135]; these may permit more exact specification of interface details. The remainder of this chapter gives a set of examples in Larch/C++, and then concludes with a discussion. <p> Allowing the specification of several specification cases (an idea due to Wills <ref> [48, 50, 49] </ref>) is convenient for the specification of exceptions and for giving a concrete form to specification inheritance [12]. Furthermore, when combined with the ability to specify both total and partial correctness, the expressiveness of the specification language becomes much more complete [20].
Reference: [49] <author> Alan Wills. </author> <booktitle> Refinement in Fresco. In Lano and Houghton [25], chapter 9, </booktitle> <pages> pages 184-201. </pages>
Reference-contexts: The same remark applies to object-oriented (OO) specification languages such as Z++ [27, 26], ZEST [11], Object-Z [40, 41], OOZE [1, 2, 3], MooZ [36, 37], and VDM++ [39]. However, apparently there are "variants of Fresco" <ref> [48, 49] </ref> that are "derived from C++ and Smalltalk" [50, p. 135]; these may permit more exact specification of interface details. The remainder of this chapter gives a set of examples in Larch/C++, and then concludes with a discussion. <p> Allowing the specification of several specification cases (an idea due to Wills <ref> [48, 50, 49] </ref>) is convenient for the specification of exceptions and for giving a concrete form to specification inheritance [12]. Furthermore, when combined with the ability to specify both total and partial correctness, the expressiveness of the specification language becomes much more complete [20].
Reference: [50] <author> Alan Wills. </author> <title> Specification in Fresco. </title> <editor> In Stepney et al. </editor> <volume> [44], chapter 11, </volume> <pages> pages 127-135. </pages>
Reference-contexts: The same remark applies to object-oriented (OO) specification languages such as Z++ [27, 26], ZEST [11], Object-Z [40, 41], OOZE [1, 2, 3], MooZ [36, 37], and VDM++ [39]. However, apparently there are "variants of Fresco" [48, 49] that are "derived from C++ and Smalltalk" <ref> [50, p. 135] </ref>; these may permit more exact specification of interface details. The remainder of this chapter gives a set of examples in Larch/C++, and then concludes with a discussion. <p> (* for ffi) includes AbelianGroup (Vec [T] for T, + for ffi, 0 for unit, - __ for 1 ), DistributiveRingAction (T for M, Vec [T] for T) % ... implications omitted ... to the behavioral interface specifications. 2.2 Specification of QuadShape and Quadrilateral Following the ZEST [11] and Fresco <ref> [50] </ref> specifications of the shapes example, the first class to specify is an abstract class of four-sided figures, QuadShape. The reason for this is that, if we follow [44, Chapter 2], then quadrilaterals are shearable, but some subtypes (rectangle, rhombus, and square) are not. <p> However, only for Fresco is there even a hint <ref> [50, p. 135] </ref> that it may be able to specify the C++ interface details that Larch/C++ can specify. It is important that a formal specification language not require one to formalize every detail. <p> Allowing the specification of several specification cases (an idea due to Wills <ref> [48, 50, 49] </ref>) is convenient for the specification of exceptions and for giving a concrete form to specification inheritance [12]. Furthermore, when combined with the ability to specify both total and partial correctness, the expressiveness of the specification language becomes much more complete [20].
Reference: [51] <author> Jeannette M. Wing. </author> <title> Writing Larch interface language specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: The toolkit in Z is based on set theory; it has a relatively elaborate notation for various set constructions, as well as powerful techniques for combining specifications (the schema calculus). 1.2 Larch The work of Wing, Guttag, and Horning on Larch extends the VDM-SL and Z tradition in two directions <ref> [52, 51, 18] </ref>: * Although a mathematical toolkit is provided [18, Appendix A], specifiers may design their own mathematical theories using the Larch Shared Language (LSL) [18, Chapter 4]. <p> Examples include LCL [18, Chapter 5] (for C), LM3 [18, Chapter 6] (for Modula-3), Larch/Ada [17] (for Ada), Larch/CLU <ref> [52, 51] </ref> (for CLU), Larch/Smalltalk [10] (for Smalltalk) and Larch/C++. The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed [24].
Reference: [52] <author> Jeannette Marie Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year> <month> 19 </month>
Reference-contexts: The toolkit in Z is based on set theory; it has a relatively elaborate notation for various set constructions, as well as powerful techniques for combining specifications (the schema calculus). 1.2 Larch The work of Wing, Guttag, and Horning on Larch extends the VDM-SL and Z tradition in two directions <ref> [52, 51, 18] </ref>: * Although a mathematical toolkit is provided [18, Appendix A], specifiers may design their own mathematical theories using the Larch Shared Language (LSL) [18, Chapter 4]. <p> Examples include LCL [18, Chapter 5] (for C), LM3 [18, Chapter 6] (for Modula-3), Larch/Ada [17] (for Ada), Larch/CLU <ref> [52, 51] </ref> (for CLU), Larch/Smalltalk [10] (for Smalltalk) and Larch/C++. The advantage of tailoring each BISL to a specific programming language is that one can specify both the behavior and the exact interface to be programmed [24].
References-found: 52

