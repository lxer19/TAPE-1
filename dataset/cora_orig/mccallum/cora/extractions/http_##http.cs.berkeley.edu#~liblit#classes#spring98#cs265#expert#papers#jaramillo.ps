URL: http://http.cs.berkeley.edu/~liblit/classes/spring98/cs265/expert/papers/jaramillo.ps
Refering-URL: http://http.cs.berkeley.edu/~liblit/classes/spring98/cs265/expert/
Root-URL: 
Title: Draft Debugging of Optimized Code through Comparison Checking  
Author: Clara Jaramillo, Rajiv Gupta and Mary Lou Soffa 
Keyword: code optimization, program transformation, comparison checking, debugging.  
Address: Pittsburgh.  
Affiliation: University of  
Note: Supported in part by a grant from Hewlett Packard Labs to the  
Abstract: We present a new approach to the debugging of optimized code through comparison checking. In this scheme, both the unoptimized and optimized versions of an application execute, and values they compute are compared in order to ensure that the behaviors of the two versions are the same. To determine what values should be compared and where the comparisons must take place, statement instances in the unoptimized code are mapped to statement instances in the optimized code. The mappings are derived automatically as optimizations are performed. Annotations for both versions of the code are developed from the mappings. Using the annotations, a driver checks, while the programs are executing, that both programs are producing the same values. If values are different, the user determines if there is a bug in the unoptimized code. If so, a conventional debugger is used to debug the code. If the bug is in the optimized code, the user is told where in the code the problem occurred and what optimizations are involved in producing the error. The user can then turn off those offending optimizations and leave the other optimizations in place. This information is also helpful to the optimizer writer in debugging the optimizer. We implemented our checker, COP, and ran experiments which indicate that the approach is practical. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abramson, D. A., Foster, I., Michalakes, J., and Sosic, R. </author> <title> Relative Debugging and its Application to the Development of Large Numerical Models. </title> <booktitle> In Proceedings of IEEE Supercomputing 1995, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: In our approach, the user can still use conventional debuggers for unoptimized code that are currently in use. The most closely related work to our approach is Guard, which is a relative debugger, but not designed to debug optimized programs <ref> [20, 2, 1] </ref>. Using Guard, users can compare the execution of one program, the reference program, with the execution of another program, the development version.
Reference: [2] <author> Abramson, D., Foster, I, Michalakes, J., and Sosic, R. </author> <title> A New Methodology for Debugging Scientific Applications. </title> <journal> Communications of the ACM, </journal> <volume> 39(11) </volume> <pages> 69-77, </pages> <month> November </month> <year> 1996. </year>
Reference-contexts: continuing to run more programs and will add the results to the final paper.) Although the benchmarks did not include floating point numbers, these can be handled by our system by allowing for inexact equality; that is by allowing two floating point numbers to differ by a certain small delta <ref> [2] </ref>. Table 1 shows the total number of times various optimizations were applied by our optimizer. Table 2 shows the cpu execution times of the unoptimized and optimized programs with and without annotations. <p> In our approach, the user can still use conventional debuggers for unoptimized code that are currently in use. The most closely related work to our approach is Guard, which is a relative debugger, but not designed to debug optimized programs <ref> [20, 2, 1] </ref>. Using Guard, users can compare the execution of one program, the reference program, with the execution of another program, the development version.
Reference: [3] <author> A. Adl-Tabatabai. </author> <title> Source-Level Debugging of Globally Optimized Code. </title> <type> PhD dissertation, </type> <institution> Carnegie Mellon University, </institution> <year> 1996. </year> <note> Technical Report CMU-CS-96-133. </note>
Reference: [4] <author> Adl-Tabatabai, A., and Gross, T. </author> <title> Evicted Variables and the Interaction of Global Register Allocation and Symbolic Debugging. </title> <booktitle> In Proceedings 20th POPL Conference, </booktitle> <pages> pages 371-383, </pages> <month> January </month> <year> 1993. </year>
Reference: [5] <author> Brooks, G., Hansen, G.J., and Simmons, S. </author> <title> A New Approach to Debugging Optimized Code. </title> <booktitle> In Proceedings ACM SIGPLAN'92 Conf. on Programming Languages Design and Implementation, </booktitle> <pages> pages 1-11, </pages> <month> June </month> <year> 1992. </year>
Reference: [6] <author> Chase, B. and Hood, R. </author> <title> Selective Interpretation as a Technique for Debugging Computationally Intensive Programs. </title> <booktitle> In ACM SIGPLAN '87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <pages> pages 113-124, </pages> <month> June </month> <year> 1987. </year>
Reference: [7] <author> Copperman, M. </author> <title> Debugging Optimized Code Without Being Misled. </title> <type> Technical Report 92-01, </type> <institution> Board of Studies in Computer and Information Sciences, University of California at Santa Cruz, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: For example optimizations change the data layout of a program, which may cause an uninitialized variable to be assigned different values in the unoptimized and optimized programs causing them to behave differently <ref> [7] </ref>. Clearly in this case the application program must be further debugged. * If it is found that an error was introduced by the optimizer, it would be beneficial to know the statements and optimizations that were involved in the error.
Reference: [8] <author> Copperman, M., and McDowell, C.E. </author> <title> Detecting Unexpected Data Values in Optimized Code. </title> <type> Technical Report 90-56, </type> <institution> Board of Studies in Computer and Information Sciences, University of California at Santa Cruz, </institution> <month> October </month> <year> 1990. </year>
Reference: [9] <author> Copperman, Max. </author> <title> Debugging Optimized Code Without Being Misled. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 387-427, </pages> <year> 1994. </year>
Reference: [10] <author> Coutant, D.S., Meloy, S., and Ruscetta, M. </author> <title> A Practical Approach to Source-Level Debugging of Globally Optimized Code. </title> <booktitle> In Proceedings ACM SIGPLAN'88 Conf. on Programming Languages Design and Implementation, </booktitle> <pages> pages 125-134, </pages> <month> June </month> <year> 1988. </year>
Reference: [11] <author> Fraser, Chris, and Hanson, David. </author> <title> A Retargetable C Compiler: Design and Implementation. </title> <address> Benjamin/Cummings, </address> <year> 1995. </year>
Reference-contexts: The algorithms will be included in the completed paper. 3 Experimental Results We implemented COP to test our algorithms for instruction mapping, annotation placement and checking, and performed experiments to assess the practicality of COP. Lcc <ref> [11] </ref> was used as the compiler for the application program and was extended to include a set of optimizations, namely loop invariant code motion, dead code elimination, PRE, copy propagation, and constant propagation and folding. As a program is optimized, mappings are updated.
Reference: [12] <author> Fritzson, P. </author> <title> A Systematic Approach to Advanced Debugging through Incremental Compilation. </title> <booktitle> In Proceedings ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging, </booktitle> <pages> pages 130-139, </pages> <year> 1983. </year>
Reference: [13] <author> Gross, Thomas. </author> <title> Bisection Debugging. </title> <booktitle> In Proceedings of the AADEBUG'97 Workshop, </booktitle> <pages> pages 185-191, </pages> <month> May, </month> <year> 1997. </year>
Reference-contexts: The concept of a bisection debugging model, and a high level approach, was recently presented that also has as its goal the identification of semantic differences between two versions of the same program, one of which is assumed to be correct <ref> [13] </ref>. The bisection debugger attempts to identify the earliest point where the two versions diverge. However, in order to handle the debugging of optimized code, all data values problems have to be solved at all breakpoints.
Reference: [14] <author> Gupta, R. </author> <title> Debugging Code Reorganized by a Trace Scheduling Compiler. </title> <journal> Structured Programming, </journal> <volume> 11 </volume> <pages> 141-150, </pages> <year> 1990. </year>
Reference: [15] <author> Hennessy, J. </author> <title> Symbolic Debugging of Optimized Code. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 323-344, </pages> <month> July </month> <year> 1982. </year>
Reference: [16] <author> Holzle, U., Chambers, C., and Ungar, D. </author> <title> Debugging Optimized Code with Dynamic Deoptimization. </title> <booktitle> In Proceedings ACM SIGPLAN'92 Conf. on Programming Languages Design and Implementation, </booktitle> <pages> pages 32-43, </pages> <month> June </month> <year> 1992. </year>
Reference: [17] <author> Kessler, P. </author> <title> Fast Breakpoints: </title> <booktitle> Design and Implementation. In ACM SIGPLAN Proceedings of Conf. on Programming Languages Design and Implementation, </booktitle> <pages> pages 78-84, </pages> <year> 1990. </year>
Reference-contexts: We compare array addresses and pointer addresses by actually comparing their offsets from the closest base addresses collected by the checker. Breakpointing is implemented using fast breakpoints <ref> [17] </ref>. Two versions of COP were implemented. In the first version, traces of the unoptimized and optimized program were collected and the comparison checks were performed on the traces.
Reference: [18] <author> Pineo, P.P. and Soffa, </author> <title> M.L. A Practical Approach to the Symbolic Debugging of Code. </title> <booktitle> Proceedings of International Conference on Compiler Construction, </booktitle> <volume> 26(12) </volume> <pages> 357-373, </pages> <month> April </month> <year> 1994. </year>
Reference: [19] <author> Pollock, L.L., and Soffa, </author> <title> M.L. High-Level Debugging with the Aid of an Incremental Optimizer. </title> <booktitle> In 21st Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume 2, </volume> <pages> pages 524-531, </pages> <month> January </month> <year> 1988. </year>
Reference: [20] <author> Sosic, R. and Abramson, D. A. </author> <title> Guard: A Relative Debugger. </title> <journal> Software Practice and Experience, </journal> <month> February </month> <year> 1997. </year> <month> 10 </month>
Reference-contexts: In our approach, the user can still use conventional debuggers for unoptimized code that are currently in use. The most closely related work to our approach is Guard, which is a relative debugger, but not designed to debug optimized programs <ref> [20, 2, 1] </ref>. Using Guard, users can compare the execution of one program, the reference program, with the execution of another program, the development version.
Reference: [21] <author> Wismueller, R. </author> <title> Debugging of Globally Optimized Programs Using Data Flow Analysis. </title> <booktitle> In Proceedings ACM SIG PLAN'94 Conf. on Programming Languages Design and Implementation, </booktitle> <pages> pages 278-289, </pages> <month> June </month> <year> 1994. </year>
Reference: [22] <author> Zellweger, P.T. </author> <title> An Interactive High-Level Debugger for Control-Flow Optimized Programs. </title> <booktitle> In Proceedings ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging, </booktitle> <pages> pages 159-171, </pages> <year> 1983. </year> <month> 11 </month>
References-found: 22

