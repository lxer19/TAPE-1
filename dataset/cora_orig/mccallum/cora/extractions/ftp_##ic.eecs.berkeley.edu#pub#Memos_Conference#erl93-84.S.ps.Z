URL: ftp://ic.eecs.berkeley.edu/pub/Memos_Conference/erl93-84.S.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu:80/~shiple/publications/index.html
Root-URL: 
Title: Computing Boolean Expressions with OBDDs  
Author: Thomas R. Shiple Robert K. Brayton Alberto L. Sangiovanni-Vincentelli 
Date: 10 December 1993  
Address: Berkeley, CA 94720  
Affiliation: Department of EECS, University of California,  
Pubnum: Memorandum No. UCB/ERL M93/84  
Abstract: We present a method to compute the bdd for an arbitrary Boolean expression, where the operands are themselves bdds. Such expressions are usually computed by the successive application of binary operators. However, cases exist where this method performs wasteful intermediate computations and creates bdd nodes not used in the final result. In contrast, our method never creates a bdd node unless it is present in the final result. We tested the new method on the application of building bdds for the nodes in a multi-level logic network. Although the new method uses fewer bdd nodes, its runtime is much worse. By analyzing the reasons for this, we further our understanding of bdd operations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Karl S. Brace, Richard L. Rudell, and Randal E. Bryant. </author> <title> Efficient implementation of a BDD package. </title> <booktitle> In Proc. 27th Design Automat. Conf., </booktitle> <pages> pages 40-45, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: 5 The auxiliary variables are stored and manipulated in a separate bdd manager so that bdd operations on the auxiliary variable space can be counted separately from those on the principal variable space. 6 Copying is a constant time operation in a bdd package that uses a strong canonical form <ref> [1] </ref>. 4 function build terminal condition (expression tree) f switch (type of node) f case OPRND: return (auxiliary variable corresponding to operand); case AND: left = build terminal condition (left child of expression); right = build terminal condition (right child of expression); return (bdd and (left, right)); case OR: left =
Reference: [2] <author> Randal E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: 1 Introduction A reduced ordered binary decision diagram (bdd) is a data structure used to store and manipulate Boolean functions <ref> [2] </ref>. Researchers are applying bdds to a growing number of problems, such as formal design verification, logic synthesis, and graph-theoretic problems.
Reference: [3] <author> Olivier Coudert, Christian Berthet, and Jean Christophe Madre. </author> <title> Verification of synchronous sequential machines based on symbolic execution. </title> <editor> In J. Sifakis, editor, </editor> <booktitle> Proceedings of the Workshop on Automatic Verification Methods for Finite State Systems, volume 407 of Lecture Notes in Computer Science, </booktitle> <pages> pages 365-373. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Thus, we can use a heuristic, such as restrict <ref> [3] </ref>, to minimize each of f and g (with respect to the don't care set h) before forming their product. In the special case where h is one, f and g will each be simplified to constants, thus making their product trivial.
Reference: [4] <author> Ellen M. Sentovich, Kanwar Jit Singh, Cho Moon, Hamid Savoj, Robert K. Brayton, and Alberto Sangiovanni-Vincentelli. </author> <title> Sequential circuit design using synthesis and optimization. </title> <booktitle> In Proc. Int'l Conf. on Computer Design, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: We tested these methods on the application of building the bdd for every node of a multi-level logic network, in terms of the primary inputs. In particular, we experimented with logic networks in SIS <ref> [4] </ref>, where the function at every node is represented as a sum of products in terms of the node's immediate fanins. bdds are built for the network by starting at the primary outputs and recursively building the bdd at each node, always in terms of the primary inputs.
Reference: [5] <author> Thomas R. Shiple, Ramin Hojati, Alberto L. Sangiovanni-Vincentelli, and Robert K. Brayton. </author> <title> Heuristic minimization of BDDs using don't cares. </title> <type> Technical Report UCB/ERL M93/58, </type> <institution> Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: The second avenue is to incorporate bdd minimization using don't cares into building bdds for 20 Boolean expressions. The bdd minimization problem for a single incompletely specified function is to find a cover of the function with a small bdd <ref> [5] </ref>. We could extend the input to the multi-way method to allow a don't care function for each operand in the expression. Then the goal would be to use the don't cares present in each operand to make the final bdd for the expression as small as possible.
References-found: 5

