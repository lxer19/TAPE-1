URL: http://www.cs.washington.edu/homes/wchan/work/ICSE99.ps
Refering-URL: http://www.cs.washington.edu/homes/wchan/work/
Root-URL: http://www.cs.washington.edu
Email: notking@cs.washington.edu  fdavid.h.jones, william.e.warnerg@boeing.com  
Title: Decoupling Synchronization from Local Control for Efficient Symbolic Model Checking of Statecharts  
Author: William Chan Richard J. Anderson Paul Beame David H. Jones David Notkin William E. Warner fwchan, anderson, beame, 
Keyword: Formal methods, formal verification, symbolic model checking, binary decision diagrams, software specification, state-charts, fault tolerance.  
Address: Box 352350, Seattle, Washington 98195-2350, USA +1-206-543-1695  Seattle, Washington, USA  
Affiliation: Department of Computer Science and Engineering, University of Washington  The Boeing Company,  
Abstract: Symbolic model checking is a powerful formal-verification technique for reactive systems. In this paper we address the problem of symbolic model checking for software specifications written as statecharts. We concentrate on how the synchronization of statecharts relates to the efficiency of model checking. We show that statecharts synchronized in an oblivious manner, such that the synchronization and the local control are decoupled, tend to be easier for symbolic analysis. Based on this insight, the verification of some non-oblivious systems can be optimized by a simple, transparent modification to the model to separate the synchronization from the local control. The technique enabled the analysis of the statecharts model of a fault-tolerant electrical power distribution system developed by the Boeing Commercial Airplane Group. The results disclosed subtle modeling and logical flaws not found by simulation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Berry and G. Gonthier. </author> <title> The ESTEREL synchronous programming language: Design, semantics, </title> <booktitle> implementation. Science of Computer Programming, </booktitle> <volume> 19(2) </volume> <pages> 87-152, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: called a step and a super-step respectively in STATEMATE, whereas in RSML they are called a microstep and a step respectively.) The synchrony hypothesis says that during a macrostep no external events can arrive and the environmental inputs remain unchanged; that is, the system is infinitely faster than the environment <ref> [1] </ref>. Figure 2 depicts these notions. RSML enforces the synchrony hypothesis, while STATEMATE optionally allows it. We assume the synchrony hypothesis, which is central to the issues and techniques discussed in this paper. 2.2 Styles: Oblivious vs.
Reference: [2] <author> M. C. Browne, E. M. Clarke, and O. Grumberg. </author> <title> Characterizing finite Kripke structures in propositional temporal logic. </title> <journal> Theoretical Computer Science, </journal> 59(1/2):115-131, July 1988. 
Reference-contexts: However, because the microstep counter is not visible to the user, the modified system will not produce any visible change until stable. Formally, the system stutters in the interim [13], and every CTL formula without the next-time X operator is preserved by stuttering <ref> [2] </ref>. (Formulas with the X operator can count the number of microsteps and thus may not be preserved.) A0 A1 B10 A01 StateA StateB PSfrag replacements A off x [ :c ^ mc = 1]=y off y [ :d ^ mc = 2]=z Our final modification uses the microstep counter to
Reference: [3] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 35(6) </volume> <pages> 677-691, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: For statecharts not written in these styles, we give procedures to automatically modify their internal representations to greatly improve the performance of their analysis. This work started as a case study of applying symbolic model checking based on binary decision diagrams (BDDs) <ref> [3] </ref> to a statecharts specification developed by the Boeing Commercial Airplane Group. Previously, the same technique was applied to the requirements specification of the airborne collision avoidance system TCAS II [6, 7] written in the Requirements State Machine Language (RSML) [14], a language also based on statecharts. <p> Because we are dealing with finite state spaces, we can assume without loss of generality that each state variable is Boolean, so each such predicate is a Boolean function, which can be represented as reduced ordered binary decision diagrams (BDDs) <ref> [3] </ref>. Boolean operations, satisfiabil-ity checking, and predecessor computation can be performed efficiently using BDDs, which therefore can be used to implement the searches described above. BDDs are canonical, meaning that each Boolean function has a unique BDD representation up to a chosen variable order.
Reference: [4] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-170, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 INTRODUCTION Symbolic model checking <ref> [4] </ref> shows promise as an aid to producing industrial-strength software specifications in which developers have increased confidence [6, 20]. The formal languages for writing such specifications allow developers to produce specifications in a number of different styles. <p> More complicated temporal-logic formulas can be evaluated in similar ways by computing one or more fixed points [8]. The method is impractical for many large systems because of the sheer number of states that must be explored. More efficient for large state spaces are symbolic searches <ref> [4, 9] </ref>. A state set (e.g., Y ) can be symbolically encoded as a predicate over the state variables, just as we encoded the initial states I in Section 3.1. The idea then is to manipulate this predicate directly to explore the whole set without enumerating its elements.
Reference: [5] <author> G. Cabodi, P. Camurati, and S. Quer. </author> <title> Improved reachability analysis of large finite state machines. </title> <booktitle> In 1996 IEEE/ACM International Conference on Computer-Aided Design, Digest of Technical Papers, </booktitle> <pages> pages 10-14, </pages> <address> San Jose, California, USA, </address> <month> November </month> <year> 1996. </year>
Reference-contexts: Our optimization technique aims at reducing the size of the BDDs representing state sets. In hardware verification, techniques with the same goal exist and usually work by altering these BDDs dynamically during the search <ref> [5, 12, 19] </ref>. They 9 are quite general and work for large classes of circuits. We implemented some of these techniques and applied them to the EPD model, but the results were not satisfactory. In contrast, the technique we developed concentrates on statecharts and statically changes the underlying global structure.
Reference: [6] <author> W. Chan, R. J. Anderson, P. Beame, S. Burns, F. Modugno, D. Notkin, and J. D. Reese. </author> <title> Model checking large software specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 24(7) </volume> <pages> 498-520, </pages> <month> July </month> <year> 1998. </year>
Reference-contexts: 1 INTRODUCTION Symbolic model checking [4] shows promise as an aid to producing industrial-strength software specifications in which developers have increased confidence <ref> [6, 20] </ref>. The formal languages for writing such specifications allow developers to produce specifications in a number of different styles. Just as the way that a program is written affects how efficiently one This work was supported in part by National Science Foundation grant CCR-970670. W. <p> This work started as a case study of applying symbolic model checking based on binary decision diagrams (BDDs) [3] to a statecharts specification developed by the Boeing Commercial Airplane Group. Previously, the same technique was applied to the requirements specification of the airborne collision avoidance system TCAS II <ref> [6, 7] </ref> written in the Requirements State Machine Language (RSML) [14], a language also based on statecharts. The observations and the optimization technique described in this paper result from the combined experience of these two case studies. <p> This simply says that initially, each machine is in its initial local state, all the internal events do not occur, but the external events and inputs are not constrained. More 3 interesting is the encoding of the transition relation R <ref> [6] </ref>.
Reference: [7] <author> W. Chan, R. J. Anderson, P. Beame, and D. Notkin. </author> <title> Improving efficiency of symbolic model checking for state-based system requirements. </title> <editor> In M. Young, editor, </editor> <booktitle> ISSTA 98: Proceedings of the ACM SIGSOFT International Symposium on Software Testing and Analysis, </booktitle> <pages> pages 102-112, </pages> <address> Clearwater Beach, Florida, USA, </address> <month> March </month> <year> 1998. </year> <note> Published as Software Engineering Notes, 23(2). </note>
Reference-contexts: This work started as a case study of applying symbolic model checking based on binary decision diagrams (BDDs) [3] to a statecharts specification developed by the Boeing Commercial Airplane Group. Previously, the same technique was applied to the requirements specification of the airborne collision avoidance system TCAS II <ref> [6, 7] </ref> written in the Requirements State Machine Language (RSML) [14], a language also based on statecharts. The observations and the optimization technique described in this paper result from the combined experience of these two case studies. <p> This problem was attacked in an earlier work by identifying a subset of events (such as x, y, z in our examples) that are mutually exclusive in all reachable states, and incorporating this fact into the transition relation to prune the search <ref> [7] </ref>. The BDD size was dramatically reduced as a result. However, for reasons that we will not elaborate, this method is more effective for oblivious than for non-oblivious systems.
Reference: [8] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: An alternative is to represent a macrostep as a global transition, but this would prevent us from analyzing behaviors within a macrostep, which is often useful for debugging purposes. Many system properties can be expressed in the Computation Tree Logic (CTL) <ref> [8] </ref>, a common temporal logic for model checking. <p> In conventional explicit search, Y is implemented as a hash table, while the search frontier Y i is implemented as a queue. More complicated temporal-logic formulas can be evaluated in similar ways by computing one or more fixed points <ref> [8] </ref>. The method is impractical for many large systems because of the sheer number of states that must be explored. More efficient for large state spaces are symbolic searches [4, 9].
Reference: [9] <author> O. Coudert, C. Berthet, and J. C. Madre. </author> <title> Verification of synchronous sequential machines based on symbolic execution. </title> <editor> In J. Sifakis, editor, </editor> <title> Automatic Verification Methods for Finite State Systems: </title> <booktitle> International Workshop Proceedings, volume 407 of Lecture Notes in Computer Science, </booktitle> <pages> pages 365-373, </pages> <address> Grenoble, France, June 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: More complicated temporal-logic formulas can be evaluated in similar ways by computing one or more fixed points [8]. The method is impractical for many large systems because of the sheer number of states that must be explored. More efficient for large state spaces are symbolic searches <ref> [4, 9] </ref>. A state set (e.g., Y ) can be symbolically encoded as a predicate over the state variables, just as we encoded the initial states I in Section 3.1. The idea then is to manipulate this predicate directly to explore the whole set without enumerating its elements.
Reference: [10] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8(3) </volume> <pages> 231-274, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: The statecharts language is one of the most broadly used languages for specifying reactive systems <ref> [10] </ref>. In this paper, we address how the synchronization in a statecharts specification influences the efficiency of symbolic model checking. We identify certain styles for synchronization that are more efficient for symbolic analysis. <p> We describe the model of the EPD system and the results of the analysis in Section 6. Finally, Section 7 concludes the paper with some lessons learned. 2 STATECHARTS The statecharts language is a popular visual language for specifying complex reactive systems <ref> [10] </ref>. It extends state-machine diagrams with parallelism, superstates, and broadcast communications. For simplicity, we will not discuss su-perstates in this paper (the techniques to be developed apply equally well to systems with superstates).
Reference: [11] <author> D. Harel and A. Naamad. </author> <title> The STATEMATE semantics of statecharts. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(4) </volume> <pages> 293-333, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Different statechart-based languages disagree on which enabled transitions are taken and what effects the taken transitions produce. We adopt the semantics of RSML [14] and STATEMATE <ref> [11] </ref>: Two transitions are non-conflicting if they do not share the same source local state, and a maximal set of enabled transitions that are pairwise non-conflicting, collectively called a microstep, is simultaneously takenthe 2 macrostep no_change microsteps environment_change environment_change stable PSfrag replacements microsteps macrostep environmental change stable (no environmental change) system <p> This is consistent with Harel and Naamad's comment that in RSML a macrostep appears to be the basic operation, while in STATEMATE a microstep is the basic operation <ref> [11, p. 323] </ref>.
Reference: [12] <author> A. J. Hu and D. L. Dill. </author> <title> Efficient verification with BDDs using implicitly conjoined invariants. </title> <editor> In C. Courcoubetis, editor, </editor> <booktitle> Computer Aided Verification, 5th International Conference, CAV'93 Proceedings, volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 3-14, </pages> <address> Elounda, Greece, June/July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: One possible reason for the inefficiency is that forward searches from the initial states maintain all system invariants, whether or not they are relevant to the properties being checked. There may be many such invariants relating local states, events, and inputs in nontrivial ways, resulting in large BDDs <ref> [12] </ref>. 4.1 Oblivious vs. Non-Oblivous Intuitively, the decoupled synchronization and local control of oblivious systems induces fewer dependencies among the state variables, potentially keeping the BDDs smaller. <p> Our optimization technique aims at reducing the size of the BDDs representing state sets. In hardware verification, techniques with the same goal exist and usually work by altering these BDDs dynamically during the search <ref> [5, 12, 19] </ref>. They 9 are quite general and work for large classes of circuits. We implemented some of these techniques and applied them to the EPD model, but the results were not satisfactory. In contrast, the technique we developed concentrates on statecharts and statically changes the underlying global structure.
Reference: [13] <author> L. Lamport. </author> <title> What good is temporal logic? In R. </title> <editor> E. A. Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of the IFIP 9th World Computer Congress, </booktitle> <pages> pages 657-668, </pages> <address> Paris, France, September 1983. </address> <publisher> North Holland. </publisher>
Reference-contexts: The microstep counter also helps prune certain unreachable states from backward searches. The incorporation of the microstep counter is transparent to the specifier, and preserves the model-checking results for most interesting properties (formally, all stutter-invariant properties, including all temporal-logic formulas without the next-time operator, are preserved <ref> [13] </ref>). The technique is interesting, particularly because it achieved substantial time and space improvements in our case study even though the numbers of state variables, reachable states, and search iterations were all increased, exactly the opposite of what most existing techniques attempt to do to tame BDD blow-ups. <p> However, because the microstep counter is not visible to the user, the modified system will not produce any visible change until stable. Formally, the system stutters in the interim <ref> [13] </ref>, and every CTL formula without the next-time X operator is preserved by stuttering [2]. (Formulas with the X operator can count the number of microsteps and thus may not be preserved.) A0 A1 B10 A01 StateA StateB PSfrag replacements A off x [ :c ^ mc = 1]=y off y
Reference: [14] <author> N. G. Leveson, M. P. E. Heimdahl, H. Hildreth, and J. D. Reese. </author> <title> Requirements specification for process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9), </volume> <month> September </month> <year> 1994. </year>
Reference-contexts: Previously, the same technique was applied to the requirements specification of the airborne collision avoidance system TCAS II [6, 7] written in the Requirements State Machine Language (RSML) <ref> [14] </ref>, a language also based on statecharts. The observations and the optimization technique described in this paper result from the combined experience of these two case studies. In symbolic model checking, the state space of a formal model is exhaustively explored. <p> Different statechart-based languages disagree on which enabled transitions are taken and what effects the taken transitions produce. We adopt the semantics of RSML <ref> [14] </ref> and STATEMATE [11]: Two transitions are non-conflicting if they do not share the same source local state, and a maximal set of enabled transitions that are pairwise non-conflicting, collectively called a microstep, is simultaneously takenthe 2 macrostep no_change microsteps environment_change environment_change stable PSfrag replacements microsteps macrostep environmental change stable (no
Reference: [15] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: guarding condition c of the controller is usually a nontrivial predicate relating inputs and the local states of other circuit breakers and the power sources. 6.2 Analysis We analyzed the main and backup AC power subsystems by translating the statecharts to the input language of the CTL model checker SMV <ref> [15] </ref>; other subsystems were abstracted away manually. The analysis can be divided into analysis on normal behaviors (i.e., no component failures) and fault tolerance (single and multiple failures). We report some of the more interesting results here.
Reference: [16] <author> C. R. Nobe and M. G. Bingle. </author> <title> Model-based development: Five processes used at Boeing. </title> <booktitle> In Proceedings of the IEEE International Conference and Workshop: Engineering of Computer-Based Systems, </booktitle> <address> Jerusalem, Israel, </address> <month> March/April </month> <year> 1998. </year>
Reference-contexts: Another contribution of this work is the case study itself. Formal models have been used increasingly in Boeing to specify and validate functional requirements of airborne computing systems <ref> [16] </ref>. One of the modeling languages used is state-charts, thanks to their intuitive notations, ability to scale, and the availability of supported tools [17]. Developed for research purposes, the statecharts studied in this work model a fault-tolerant electrical power distribution (EPD) system designed for use on aircraft. <p> The use of modeling and simulation to support requirements validation at Boeing is described in Nobe and Bingle <ref> [16] </ref>. In this process, the written specification is developed first, and then a model is created to assist in validation of the requirements. Typically the model is simulated and executed by providing user-oriented inputs to the model and monitoring responses through panel graphics that represent actual system interfaces.
Reference: [17] <author> C. R. Nobe and W. E. Warner. </author> <title> Lessons learned from a trial application of requirements modeling using statecharts. </title> <booktitle> In Proceedings of the 2nd International Conference on Requirements Engineering, </booktitle> <pages> pages 86-93, </pages> <address> Colorado Springs, USA, </address> <month> April </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: Formal models have been used increasingly in Boeing to specify and validate functional requirements of airborne computing systems [16]. One of the modeling languages used is state-charts, thanks to their intuitive notations, ability to scale, and the availability of supported tools <ref> [17] </ref>. Developed for research purposes, the statecharts studied in this work model a fault-tolerant electrical power distribution (EPD) system designed for use on aircraft. <p> As such the model by intent did not include all the logic necessary for a complete specification. The model was intended as a high-level abstraction of the electrical system, which included only the logic necessary to accomplish the goals of a wider airplane system analysis <ref> [17] </ref>. b1 b2 etc etcpower_sources: circuit_breakers: busses: PSfrag replacements l gen l main r main power sources: circuit breakers: power busses: (a) Normal operations b1 b2 etc PSfrag replacements l gen l main r main (b) l gen fails 6.1 The EPD Model The purpose of the EPD system is to
Reference: [18] <author> R. K. Ranjan, A. Aziz, R. K. Brayton, B. Plessier, and C. Pix-ley. </author> <title> Efficient BDD algorithms for FSM synthesis and verification. </title> <booktitle> In Proceedings of IEEE/ACM International Workshop on Logic Synthesis, </booktitle> <address> Lake Tahoe, USA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: The results were obtained on a Sun Ultra-2 workstation using SMV version 2.4.4 (augmented with a conjunctive partitioning heuristic <ref> [18] </ref>). The data suggest dramatic improvements made by our optimization technique, without which the evaluation of each of the properties was not feasible.
Reference: [19] <author> K. Ravi and F. Somenzi. </author> <title> High-density reachability analysis. </title> <booktitle> In 1995 IEEE/ACM International Conference on Computer-Aided Design, Digest of Technical Papers, </booktitle> <pages> pages 154-158, </pages> <address> San Jose, California, USA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Our optimization technique aims at reducing the size of the BDDs representing state sets. In hardware verification, techniques with the same goal exist and usually work by altering these BDDs dynamically during the search <ref> [5, 12, 19] </ref>. They 9 are quite general and work for large classes of circuits. We implemented some of these techniques and applied them to the EPD model, but the results were not satisfactory. In contrast, the technique we developed concentrates on statecharts and statically changes the underlying global structure.
Reference: [20] <author> T. Sreemani and J. M. Atlee. </author> <title> Feasibility of model checking software requirements: A case study. </title> <booktitle> In COMPASS'96, Proceedings of the 11th Annual Conference on Computer Assurance, </booktitle> <pages> pages 77-88, </pages> <address> Gaithersburg, Maryland, USA, </address> <month> June </month> <year> 1996. </year> <journal> IEEE. </journal> <volume> 10 </volume>
Reference-contexts: 1 INTRODUCTION Symbolic model checking [4] shows promise as an aid to producing industrial-strength software specifications in which developers have increased confidence <ref> [6, 20] </ref>. The formal languages for writing such specifications allow developers to produce specifications in a number of different styles. Just as the way that a program is written affects how efficiently one This work was supported in part by National Science Foundation grant CCR-970670. W.
References-found: 20

