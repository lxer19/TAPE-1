URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3394/3394.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: fchechik,gannong@cs.umd.edu  
Title: AUTOMATIC ANALYSIS OF CONSISTENCY BETWEEN IMPLEMENTATIONS AND REQUIREMENTS  
Author: Marsha Chechik John Gannon 
Date: July 28, 1995  
Note: Date:  This research is supported in part by the Air Force Office of Scientific Research under contract F49620-93-1-0034.  
Address: College Park, MD 20742  
Affiliation: Computer Science Department University of Maryland  
Abstract: Formal methods like model checking can be used to demonstrate that safety properties of embedded systems are enforced by the system's requirements. Unfortunately, proving these properties provides no guarantee that they will be preserved in an implementation of the system. We have developed a tool, called Analyzer, which helps discover instances of inconsistency and incompleteness in implementations with respect to requirements. Analyzer uses requirements information to automatically generate properties which ensure that required state transitions appear in a model of an implementation. A model is created through abstract interpretation of an implementation annotated with assertions about values of state variables which appear in requirements. Analyzer determines if the model satisfies both automatically-generated and user-specified safety properties. This paper presents a description of our implementation of Analyzer and our experience in applying it to a small but realistic problem. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, R. Sethi, and J. Ulman. </author> <booktitle> Compilers: Principles, Techniques, and Tools, Chapter 10. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference: [2] <author> T. Alspaugh, S. Faulk, K. Britton, R. Parker, D. Parnas, and J. Shore. </author> <title> "Software Requirements for the A-7E Aircraft". </title> <type> Technical report, </type> <institution> Naval Research Laboratory, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Finally, in Section 8, we compare the approach taken in Analyzer with related work and discuss limitations of our approach. 2 Requirements Notation This section describes the requirements specification format. Software Cost Reduction (SCR) requirements <ref> [2, 14, 16, 17] </ref> model a system as a set of concurrently executing state machines, where each machine interacts with its environment's state variables. Each state machine represents one mode class, whose states are modes and whose transitions occur in response to events. <p> Re 7 quirements specifications of realistic size and complexity (like <ref> [2] </ref>), however, contain global properties which cannot be expressed using only these assertions. Allowing the user to specify a richer set of properties is relatively easy, although not every CTL-expressible formula can be verified during our analysis.
Reference: [3] <author> J. Atlee. </author> <title> "Automated Analysis of Software Requirements". </title> <type> PhD thesis, </type> <institution> University of Maryland, College Park, Maryland, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: This information records relationships between monitored or controlled variables. Relationships help requirements designers eliminate redundant information and increase the clarity of specifications <ref> [3] </ref>. They also improve readability and reduce the effort involved in annotating an implementation.
Reference: [4] <author> J.M. Atlee and J. Gannon. </author> <title> "State-Based Model Checking of Event-Driven System Requirements". </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 22-40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Automated techniques can be used to derive a finite-state representation of a set of requirements, and determine if it is a model for system safety properties expressed as temporal logic assertions <ref> [4] </ref>. We present a complementary technique which automatically compares properties derived from a set of requirements with a finite state representation of its implementation. <p> Controlled variables are set to trigger alarms and to display the water level to the operator. A mode transition table for modeclass Normal is shown in Table 5. The requirements included four user-defined safety properties, identical to those used in <ref> [4] </ref>. They are shown in Table 6. If the SelfTest button has been pressed for 500ms or more, the system is either in mode Test or will be in mode Test after its next transition.
Reference: [5] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Verification of Requirements Implementations". </title> <booktitle> In Proceedings of the 1994 ISSTA, </booktitle> <pages> pages 1-14, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: Reviewers successfully discover local inconsistencies, but the bookkeeping tasks needed to determine all the possible system states at a particular program point make it difficult to ensure that global properties of the system hold. We developed a prototype tool, called Analyzer <ref> [5, 6] </ref>, which automatically determines if an implementation is consistent with its requirements. The inputs to the tool are a requirements specification and a C source program annotated with comments describing the values of variables which appear in the requirements.
Reference: [6] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Analysis of Consistency Between Implementations and Requirements: A Case Study". </title> <booktitle> In Proceedings of 10th Annual Conference on Compute Assurance, </booktitle> <pages> pages 123-131, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Reviewers successfully discover local inconsistencies, but the bookkeeping tasks needed to determine all the possible system states at a particular program point make it difficult to ensure that global properties of the system hold. We developed a prototype tool, called Analyzer <ref> [5, 6] </ref>, which automatically determines if an implementation is consistent with its requirements. The inputs to the tool are a requirements specification and a C source program annotated with comments describing the values of variables which appear in the requirements.
Reference: [7] <author> Edmind M. Clarke, Orna Grumberg, and David E. </author> <title> Long. "Model Checking and Abstraction". </title> <booktitle> In Proceedings of the Ninth Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Dataflow analysis is used to compute an upper bound on the data dependencies of the implementation. If an asserted dependency is missing, an error is reported. Clarke et al. <ref> [7] </ref> also create abstract, finite state models of programs, and use model checking techniques to verify formulas. Programs written in a special finite-state programming language are translated into relational expressions characterizing the program's initial state and transition relation.
Reference: [8] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. "Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year> <month> 29 </month>
Reference: [9] <author> Keith D. Cooper, Mary W. Hall, and Ken Kennedy. </author> <title> "Procedure Cloning". </title> <booktitle> In Proceed--ings of IEEE International Conference on Computer Languages, </booktitle> <pages> pages 96-105, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: However, since programs usually consist of several procedures, we needed to extend our analysis technique to process these programs. We perform interprocedural analysis using an adaptation of a technique called cloning <ref> [9] </ref>. A similar algorithm was described in [32]. This technique enables Analyzer to process programs with cycles in their call graphs (recursion), to analyze each called function only a constant 21 1. Start with an annotated program. Build its CFG. 2.
Reference: [10] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Static Determination of Dynamic Properties of Programs". </title> <booktitle> In Proceedings of the "Colloque sur la Programmation", </booktitle> <month> April </month> <year> 1976. </year>
Reference-contexts: edges, s.t. (v 1 , v 2 ) 2 E iff v 2 can immediately follow v 1 in some execution sequence; and V 0 2 V is an entry node. 10 We interpret annotations in an ANP to create a set-based approximation of attainable values for each requirements' variable <ref> [10, 11] </ref>. We compute two sets of information for our analysis: reaching values (RVs) and conditions (Conds). The RV of a variable at a node is a set of values that a variable may attain if the control reaches the node. RVs are computed by interpreting Update and Initial annotations. <p> Given that all variables in R have a finite number of abstract values, our system states do not have an infinite increasing chain of values <ref> [10] </ref>, and thus we can define our widening operation to be the same as union. Thus, we no longer need to distinguish between the two types of join nodes, which simplifies our analysis significantly.
Reference: [11] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Abstract Interpretation: A Unified Lattice Model For Static Analysis of Programs by Construction or Approximation of Fix-points". </title> <booktitle> In Proceedings of the 4th POPL, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, California, </address> <year> 1977. </year>
Reference-contexts: edges, s.t. (v 1 , v 2 ) 2 E iff v 2 can immediately follow v 1 in some execution sequence; and V 0 2 V is an entry node. 10 We interpret annotations in an ANP to create a set-based approximation of attainable values for each requirements' variable <ref> [10, 11] </ref>. We compute two sets of information for our analysis: reaching values (RVs) and conditions (Conds). The RV of a variable at a node is a set of values that a variable may attain if the control reaches the node. RVs are computed by interpreting Update and Initial annotations.
Reference: [12] <author> O. Grumberg and D.E. </author> <title> Long. "Model Checking and Modular Verification". </title> <booktitle> In Proceedings of CONCUR'91: 2nd International Conference on Concurrency Theory, </booktitle> <year> 1991. </year>
Reference: [13] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtull-Trauring, and M. Trakhtenbrot. "STATEMATE: </author> <title> A Working Environment for the Development of Complex Reactive Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 403-414, </pages> <month> April </month> <year> 1990. </year>
Reference: [14] <author> C. Heitmeyer and B. Labaw. </author> <title> "Consistency Checks for SCR-Style Requirements Specifications". </title> <type> Technical Report NRL Report 93-9586, </type> <institution> Naval Research Laboratory, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Finally, in Section 8, we compare the approach taken in Analyzer with related work and discuss limitations of our approach. 2 Requirements Notation This section describes the requirements specification format. Software Cost Reduction (SCR) requirements <ref> [2, 14, 16, 17] </ref> model a system as a set of concurrently executing state machines, where each machine interacts with its environment's state variables. Each state machine represents one mode class, whose states are modes and whose transitions occur in response to events.
Reference: [15] <author> C. Heitmeyer, B. Labaw, and D. Kiskis. </author> <title> "Consistency Checking of SCR-Style Requirements Specifications". </title> <booktitle> In Proceedings of RE'95 International Symposium of Requirements Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference: [16] <author> K. Heninger. </author> <title> "Software Requirements for the A-7E Aircraft". </title> <type> Technical Report NRL Report 3876, </type> <institution> Naval Research Laboratory, </institution> <address> Washington, DC, </address> <year> 1978. </year>
Reference-contexts: Finally, in Section 8, we compare the approach taken in Analyzer with related work and discuss limitations of our approach. 2 Requirements Notation This section describes the requirements specification format. Software Cost Reduction (SCR) requirements <ref> [2, 14, 16, 17] </ref> model a system as a set of concurrently executing state machines, where each machine interacts with its environment's state variables. Each state machine represents one mode class, whose states are modes and whose transitions occur in response to events.
Reference: [17] <author> K. Heninger. </author> <title> "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-12, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Finally, in Section 8, we compare the approach taken in Analyzer with related work and discuss limitations of our approach. 2 Requirements Notation This section describes the requirements specification format. Software Cost Reduction (SCR) requirements <ref> [2, 14, 16, 17] </ref> model a system as a set of concurrently executing state machines, where each machine interacts with its environment's state variables. Each state machine represents one mode class, whose states are modes and whose transitions occur in response to events.
Reference: [18] <author> W.E. Howden. </author> <title> "Comments Analysis and Programming Errors". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(1) </volume> <pages> 72-81, </pages> <month> January </month> <year> 1990. </year>
Reference: [19] <author> W.E. Howden and G.M. Shi. </author> <title> "Linear and Structural Event Sequence Analysis". </title> <note> Submitted to ISSTA'96, </note> <month> June </month> <year> 1995. </year>
Reference-contexts: Other comments contain assertions about properties of objects. An interpreter builds an abstract model of the implementation from the assertions and the implementation's control flow graph. Hypotheses are verified with respect to this model. More recent work <ref> [19] </ref> enriches QDA's specification language so assertions also describe event occurrences and hypotheses assert that the implementation's events occur in certain sequences.
Reference: [20] <author> W.E. Howden and B. Wieand. </author> <title> "QDA A Method for Systematic Informal Program Analysis". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(6) </volume> <pages> 445-462, </pages> <month> June </month> <year> 1994. </year>
Reference: [21] <author> D. Jackson. </author> <title> Aspect: A Formal Specification Language for Detecting Bugs. </title> <type> PhD thesis, </type> <institution> MIT, Cambridge, Massachusetts, </institution> <month> June </month> <year> 1992. </year> <month> 30 </month>
Reference-contexts: After a user specifies a mapping from programming language constructs to Cecil events, the Cesar analyzer uses dataflow analysis techniques to determine if the implementation meets Cecil constraints. 27 Aspect's <ref> [21, 22, 23] </ref> specification notation permits users to write pre- and postconditions about the data dependencies of an operation. Dataflow analysis is used to compute an upper bound on the data dependencies of the implementation. If an asserted dependency is missing, an error is reported.
Reference: [22] <author> Daniel Jackson. </author> <title> "Abstract Analysis with Aspect". </title> <booktitle> In Proceedings of the 1993 Inter--national Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 19-27, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: After a user specifies a mapping from programming language constructs to Cecil events, the Cesar analyzer uses dataflow analysis techniques to determine if the implementation meets Cecil constraints. 27 Aspect's <ref> [21, 22, 23] </ref> specification notation permits users to write pre- and postconditions about the data dependencies of an operation. Dataflow analysis is used to compute an upper bound on the data dependencies of the implementation. If an asserted dependency is missing, an error is reported.
Reference: [23] <author> Daniel Jackson. </author> <title> "Aspect: Detecting Bugs with Abstract Dependences". </title> <note> (submitted to Transactions on Software Engineering and Methodology), </note> <month> November </month> <year> 1993. </year>
Reference-contexts: After a user specifies a mapping from programming language constructs to Cecil events, the Cesar analyzer uses dataflow analysis techniques to determine if the implementation meets Cecil constraints. 27 Aspect's <ref> [21, 22, 23] </ref> specification notation permits users to write pre- and postconditions about the data dependencies of an operation. Dataflow analysis is used to compute an upper bound on the data dependencies of the implementation. If an asserted dependency is missing, an error is reported.
Reference: [24] <author> N.G. Levenson, M.P.E. Heimdahl, H. Hildreth, and J.D. Reese. </author> <title> "Requirements Specification for Process-Control Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9) </volume> <pages> 684-707, </pages> <month> September </month> <year> 1994. </year>
Reference: [25] <author> Kurt M. Olender and Leon J. Osterweil. </author> <title> "Cesar: A Static Sequencing Constraint Analyzer". </title> <booktitle> In Proceedings of the ACM SIGSOFT '89 Third Symposium on Software Testing, Analysis, and Verification (TAV3), </booktitle> <pages> pages 66-74, </pages> <month> December </month> <year> 1989. </year>
Reference: [26] <author> Kurt M. Olender and Leon J. Osterweil. "Cecil: </author> <title> A Sequencing Constraint Language for Automatic Static Analysis Generation". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 268-280, </pages> <month> March </month> <year> 1990. </year>
Reference: [27] <author> Kurt M. Olender and Leon K. Osterweil. </author> <title> "Interprocedural Static Analysis of Sequencing Constraints". </title> <journal> ACM Transactions of Software Engineering and Methodology, </journal> <volume> 1(1) </volume> <pages> 21-52, </pages> <month> January </month> <year> 1992. </year>
Reference: [28] <author> Dewayne E. Perry. </author> <title> "Software Interconnection Models". </title> <booktitle> In Proceedings of the 9th International Conference on Software Engineering, </booktitle> <pages> pages 61-69. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference-contexts: To simplify the verification of properties of implementations, these systems restrict the forms of their formal specification notations or create abstract models from implementations that could be analyzed with state-exploration rather than theorem-proving techniques. In Inscape <ref> [28, 29, 30] </ref>, complex logical formulas are abstracted to simple predicates which may be primitive or defined in terms of other predicates (like our relationships). Predicates form pre- and postconditions used to specify implementations.
Reference: [29] <author> Dewayne E. Perry. </author> <booktitle> "The Inscape Environment.". In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 60-68, </pages> <address> Pittsburgh PA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: To simplify the verification of properties of implementations, these systems restrict the forms of their formal specification notations or create abstract models from implementations that could be analyzed with state-exploration rather than theorem-proving techniques. In Inscape <ref> [28, 29, 30] </ref>, complex logical formulas are abstracted to simple predicates which may be primitive or defined in terms of other predicates (like our relationships). Predicates form pre- and postconditions used to specify implementations.
Reference: [30] <author> Dewayne E. Perry. </author> <title> "The Logic of Propagation in The Inscape Environment". </title> <booktitle> In Proceedings of the 3rd Symposium on Software Testing, Analysis, and Verification (TAV3), </booktitle> <pages> pages 114-121, </pages> <address> Key West, Florida, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: To simplify the verification of properties of implementations, these systems restrict the forms of their formal specification notations or create abstract models from implementations that could be analyzed with state-exploration rather than theorem-proving techniques. In Inscape <ref> [28, 29, 30] </ref>, complex logical formulas are abstracted to simple predicates which may be primitive or defined in terms of other predicates (like our relationships). Predicates form pre- and postconditions used to specify implementations.
Reference: [31] <author> A. J. van Schouwen. </author> <title> "The A-7 Requirements Model: Re-examination for Real-Time Systems and an Application to Monitoring Systems". </title> <type> Technical Report TR-90-276, </type> <institution> Queen's University, Kingston, </institution> <address> Ontario, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: In this paper we describe the tool and show results of a case study in which we analyzed an implementation of a water-level monitoring system (WLMS) <ref> [31] </ref> and discovered several latent errors. The rest of the paper is organized as follows: Section 2 presents our requirements specification format. In Section 3, we describe the types of global system properties which are automatically generated from the specifications. <p> Two push buttons, SelfTest and Reset, permit the operator to test the system and return it to normal operation. A complete description of this system can be found in <ref> [31] </ref>. WLMS has two mode classes, Normal and Failure, whose modes are described in Table 4. The system starts in mode Standby of mode class Normal and mode AllOK of mode class Failure.
Reference: [32] <author> Ben Wegbreit. </author> <title> "Property Extraction in Well-Founded Property Sets". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(3) </volume> <pages> 270-285, </pages> <month> September </month> <year> 1975. </year>
Reference-contexts: However, since programs usually consist of several procedures, we needed to extend our analysis technique to process these programs. We perform interprocedural analysis using an adaptation of a technique called cloning [9]. A similar algorithm was described in <ref> [32] </ref>. This technique enables Analyzer to process programs with cycles in their call graphs (recursion), to analyze each called function only a constant 21 1. Start with an annotated program. Build its CFG. 2. Abstract it to ACF G: Compute gen and kill sets for each node containing an annotation.
Reference: [33] <author> Michal Young. </author> <title> "How to Leave Out Details: Error-Preserving Abstractions of State-Space Models". </title> <booktitle> In Proceedings of the Workshop on Software Testing, </booktitle> <pages> pages 63-70, </pages> <year> 1988. </year>
Reference-contexts: To understand which of these properties are preserved in the correctly annotated program, we need to formalize our discussion, using notation similar to that in <ref> [33] </ref> 2 : 2 Unfortunately, it is impossible to analyze the actual program behavior when annotations are missing or wrong. We are currently exploring ways to explicitly connect annotations and code. 15 Let M be a class of models. In our case, M contains ANP, ACFG, and FSM.
Reference: [34] <author> Michal Young and Richard N. Taylor. </author> <title> "Rethinking the Taxonomy of Fault Detec--tion Techniques". </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 53-62, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: So, assuming that a formula does not include negated quantifiers (i.e. ~ A2 (P ) = E3 (~ P ), we can verify it only if it does not contain mixed quantifiers. Young and 28 Taylor <ref> [34] </ref> reach the same conclusion. All properties discussed in earlier sections contained just one quantifier, and thus could be processed. We plan to extend Analyzer to be able to verify arbitrary consistent CTL formulae.
References-found: 34

