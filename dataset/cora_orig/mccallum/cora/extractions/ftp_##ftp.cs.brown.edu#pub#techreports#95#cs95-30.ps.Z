URL: ftp://ftp.cs.brown.edu/pub/techreports/95/cs95-30.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-95-30.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> C. Braem, B. Le Charlier, S. Modart, and P. Van Hentenryck. </author> <title> Cardinality Analysis of Prolog. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS-94), </booktitle> <pages> pages 457-471, </pages> <address> Ithaca, NY, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: In particular, it uses the generic abstract interpretation algorithm GAIA [11] instantiated to three abstract domains: Prop [13, 20] to deduce information on fixed variables, RatOrder <ref> [1] </ref> to remove redundant constraints, and LSign [16, 19] to reorder constraints and to determine unconstrained variables. The preliminary experimental results indicate that substantial speedups can be obtained. In particular, on most of the benchmarks, the speedups are asymptotic, i.e., they depend on the size of the inputs.
Reference: [2] <author> A. Cortesi, B. Le Charlier, and P. Van Hentenryck. </author> <title> Combinations of Abstract Domains for Logic Programming. </title> <booktitle> In 21st Annual ACM SIGPLAN-SIGACT Symposium on Principles Of Programming Languages, </booktitle> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Second, it is necessary to keep track of structural information to extend the scope of this work. The basic idea is to instantiate the generic domain Pat (&lt;) <ref> [2] </ref> with the domains handling linear constraints. Pat (&lt;) automatically upgrades a domain with structural information. Third, the present source to source optimizations 14 can be combined with lower-level optimizations such as dead-variable elimination [10]. Finally, we would like to explore various tradeoffs in the compiler organization and the optimizations.
Reference: [3] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <publisher> In New York ACM Press, </publisher> <editor> editor, </editor> <booktitle> Conf. Record of Fourth ACM Symposium on Programming Languages (POPL'77), </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, CA, </address> <month> January </month> <year> 1977. </year>
Reference-contexts: These additional optimizations are orthogonal to the contents of this paper and are not discussed here. 4 Program Analysis Our compiler performs a series of analyses to infer the runtime properties necessary to carry out the optimizations. It uses abstract interpretation <ref> [3] </ref>, a systematic method to develop static analyses. In particular, the compiler uses the abstract interpretation system GAIA [11] on three different domains: LSign, RatOrder, and Prop. <p> This section contains an informal review of these components. 4.1 The Abstract Interpretation Framework The abstract interpretation framework used by the compiler is a natural extension to CLP of our logic programming framework [11]. It follows the traditional approach to abstract interpretation <ref> [3] </ref>. 5 Note that this constraint is useful for other uses of the program. 5 As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language.
Reference: [4] <author> P. Cousot and N. Halbwachs. </author> <title> Automatic Discovery of Linear Restraints Among Variables of a Program. </title> <booktitle> In Conf. Record of Fifth ACM Symposium on Principles of Programming Languages (POPL'78), </booktitle> <year> 1978. </year>
Reference-contexts: There are many ways to extend this work. First, the domains used in our compiler can be improved to increase precision. In particular, signs in LSign should be replaced by intervals and the domain RatOrder may be replaced by the domain Hull of <ref> [4] </ref>. Second, it is necessary to keep track of structural information to extend the scope of this work. The basic idea is to instantiate the generic domain Pat (&lt;) [2] with the domains handling linear constraints. Pat (&lt;) automatically upgrades a domain with structural information.
Reference: [5] <author> S. Debray. </author> <title> Unfold/Fold Transformations and Loop Optimizations of Logic Programs. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation (PLDI'92), </booktitle> <pages> pages 297-307, </pages> <address> Atlanta, </address> <year> 1988. </year>
Reference-contexts: It is essentially a Prolog program enhanced with a rational arithmetic component. As a consequence, traditional Prolog transformations and optimizations can now be applied. For instance, in our running example, the techniques of <ref> [5] </ref> can be used to transform our final program into a tail-recursive program. Similarly, efficient instructions can be generated for the tests and assignments.
Reference: [6] <author> V. Dumortier and G. Janssens. </author> <title> Towards a Practical Full Mode Inference System for CLP(H,N). </title> <booktitle> In Eleventh International Conference on Logic Programming (ICLP-94), </booktitle> <address> Santa Marguerita Ligure, Italy, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The main conceptual contribution of the paper is to show that sophisticated static analyses and source to source transformations can produce dramatic (often asymptotic) speedups for CLP (&lt; Lin ) programs. Much research has been devoted to abstract interpretation of CLP (&lt; Lin ) (e.g., <ref> [6, 7, 14, 16, 19] </ref>) but almost no experimental results have appeared to quantify the possible benefits. The only exception we are aware of is the system described in [10] but no reordering or constraint removal is performed in the system.
Reference: [7] <author> M. Garcia de la Banda and M. Hermenegildo. </author> <title> A Practical Approach to the Global Analysis of CLP Programs. </title> <booktitle> In Proc. of the International Symposium on Logic Programming (ILPS'93), </booktitle> <address> Vancouver, Canada, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: The main conceptual contribution of the paper is to show that sophisticated static analyses and source to source transformations can produce dramatic (often asymptotic) speedups for CLP (&lt; Lin ) programs. Much research has been devoted to abstract interpretation of CLP (&lt; Lin ) (e.g., <ref> [6, 7, 14, 16, 19] </ref>) but almost no experimental results have appeared to quantify the possible benefits. The only exception we are aware of is the system described in [10] but no reordering or constraint removal is performed in the system. <p> For instance, the second abstract store captures the stores encountered for the first recursive call to mg. 4.3 The Domain Prop The domain Prop [14, 20] is an effective domain to compute groundness information for Prolog. It can be extended easily to infer fixed variables in CLP (e.g. <ref> [7] </ref>). Its key idea is to represent the information through a Boolean formula. Informally speaking, a formula x $ y means that, whenever x is fixed, y is fixed and vice-versa.
Reference: [8] <author> N. Heintze and J. Jaffar. </author> <title> An Engine for Logic Program Analysis. </title> <booktitle> In IEEE 7th Annual Symposium on Logic in Computer Science, </booktitle> <year> 1992. </year>
Reference-contexts: Section 7 reports our preliminary experimental results, while Section 8 concludes the paper. 2 Overview of CLP (&lt; Lin ) In this section, we give an informal overview of CLP (&lt; Lin ). The reader interested in more details can refer to <ref> [8, 21] </ref>.
Reference: [9] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In POPL-87, </booktitle> <address> (Munich, Germany), </address> <month> January </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Constraint logic programming (CLP) <ref> [9] </ref> is a generalization of logic programming where unification is replaced by constraint solving as the basic operation of the language. Constraint solving makes it possible to preserve some traditional advantages of logic programming (e.g., the logical variable and reversibility of programs) even when arithmetic operations are involved.
Reference: [10] <author> A.D. Kelly, A. MacDonald, K. Marriott, H. Sondergaard, P. Stuckey, and R. Yap. </author> <title> An Optimizing Compiler for CLP(&lt;). </title> <booktitle> In First International Conference on Principles and Practice of Constraint Programming (CP'95), </booktitle> <address> Cassis, France, September 1995. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: Much research has been devoted to abstract interpretation of CLP (&lt; Lin ) (e.g., [6, 7, 14, 16, 19]) but almost no experimental results have appeared to quantify the possible benefits. The only exception we are aware of is the system described in <ref> [10] </ref> but no reordering or constraint removal is performed in the system. As we show in this paper, reordering is probably the most fundamental optimization. The rest of the paper is organized as follows. Section 2 gives a brief overview of CLP (&lt; Lin ). <p> The basic idea is to instantiate the generic domain Pat (&lt;) [2] with the domains handling linear constraints. Pat (&lt;) automatically upgrades a domain with structural information. Third, the present source to source optimizations 14 can be combined with lower-level optimizations such as dead-variable elimination <ref> [10] </ref>. Finally, we would like to explore various tradeoffs in the compiler organization and the optimizations. Acknowledgments Special thanks to Baudouin Le Charlier for his numerous contributions to this research. Many of the abstract interpretation tools used in the work have in fact been developed jointly with Baudouin Le Charlier.
Reference: [11] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental Evaluation of a Generic Abstract Interpretation Algorithm for Prolog. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 35-101, </pages> <month> January 94. 15 </month>
Reference-contexts: The compiler, which includes about 10,000 lines only for the optimizations, uses abstract interpretation to collect the information necessary to 1 p (X,Y,X) : Y Z, q (X,Y,Z) : q (X,Y,Z) : r (X,Y) : perform the optimizations safely. In particular, it uses the generic abstract interpretation algorithm GAIA <ref> [11] </ref> instantiated to three abstract domains: Prop [13, 20] to deduce information on fixed variables, RatOrder [1] to remove redundant constraints, and LSign [16, 19] to reorder constraints and to determine unconstrained variables. The preliminary experimental results indicate that substantial speedups can be obtained. <p> It uses abstract interpretation [3], a systematic method to develop static analyses. In particular, the compiler uses the abstract interpretation system GAIA <ref> [11] </ref> on three different domains: LSign, RatOrder, and Prop. This section contains an informal review of these components. 4.1 The Abstract Interpretation Framework The abstract interpretation framework used by the compiler is a natural extension to CLP of our logic programming framework [11]. <p> the compiler uses the abstract interpretation system GAIA <ref> [11] </ref> on three different domains: LSign, RatOrder, and Prop. This section contains an informal review of these components. 4.1 The Abstract Interpretation Framework The abstract interpretation framework used by the compiler is a natural extension to CLP of our logic programming framework [11]. It follows the traditional approach to abstract interpretation [3]. 5 Note that this constraint is useful for other uses of the program. 5 As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language.
Reference: [12] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental Evaluation of a Generic Abstract Interpreta--tion Algorithm for Prolog. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 35-101, </pages> <month> January 94. </month>
Reference-contexts: The upper bound operation is a consistent abstraction of union of sets of constraint stores. The last step of the methodology consists of computing the least fixpoint or a postfixpoint of the abstract semantics using an algorithm such as GAIA <ref> [12] </ref> or PLAI [18].
Reference: [13] <author> K. Marriott and H. Sondergaard. </author> <title> Abstract Interpretation of Logic Programs: the Denotational Approach, </title> <month> June </month> <year> 1990. </year> <note> To appear in ACM Transaction on Programming Languages. </note>
Reference-contexts: In particular, it uses the generic abstract interpretation algorithm GAIA [11] instantiated to three abstract domains: Prop <ref> [13, 20] </ref> to deduce information on fixed variables, RatOrder [1] to remove redundant constraints, and LSign [16, 19] to reorder constraints and to determine unconstrained variables. The preliminary experimental results indicate that substantial speedups can be obtained.
Reference: [14] <author> K. Marriott and H. Sondergaard. </author> <title> Analysis of Constraint Logic Programs. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP-90), </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: The main conceptual contribution of the paper is to show that sophisticated static analyses and source to source transformations can produce dramatic (often asymptotic) speedups for CLP (&lt; Lin ) programs. Much research has been devoted to abstract interpretation of CLP (&lt; Lin ) (e.g., <ref> [6, 7, 14, 16, 19] </ref>) but almost no experimental results have appeared to quantify the possible benefits. The only exception we are aware of is the system described in [10] but no reordering or constraint removal is performed in the system. <p> For instance, the second abstract store captures the stores encountered for the first recursive call to mg. 4.3 The Domain Prop The domain Prop <ref> [14, 20] </ref> is an effective domain to compute groundness information for Prolog. It can be extended easily to infer fixed variables in CLP (e.g. [7]). Its key idea is to represent the information through a Boolean formula.
Reference: [15] <author> K. Marriott and P. Stuckey. </author> <title> The 3 R's of optimizing Constraint Logic Programs: Refinement, Removal, and Reordering. </title> <booktitle> In Proc. of the 20th ACM Symposium on Principles of Programming Languages (POPL'93), </booktitle> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Constraint solving however is an expensive operation in general and it is natural for a compiler to aim at minimizing its use by replacing constraints by assignments and tests. An interesting methodology to exploit this basic observation was proposed by Marriott and Stuckey <ref> [15] </ref> for CLP (&lt; Lin ), a constraint logic programming language over linear constraints. The key idea behind the methodology consists of refining constraints into tests and assignments, removing redundant constraints (i.e., constraints which are implied by the constraint store), and reordering constraints to maximize refinements and removals.
Reference: [16] <author> K. Marriott and P. Stuckey. </author> <title> Approximating Interaction Between Linear Arithmetic Constraints. </title> <booktitle> In Proc. of the International Symposium on Logic Programming (ILPS'94), </booktitle> <address> Ithaca, NY, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: In particular, it uses the generic abstract interpretation algorithm GAIA [11] instantiated to three abstract domains: Prop [13, 20] to deduce information on fixed variables, RatOrder [1] to remove redundant constraints, and LSign <ref> [16, 19] </ref> to reorder constraints and to determine unconstrained variables. The preliminary experimental results indicate that substantial speedups can be obtained. In particular, on most of the benchmarks, the speedups are asymptotic, i.e., they depend on the size of the inputs. <p> The main conceptual contribution of the paper is to show that sophisticated static analyses and source to source transformations can produce dramatic (often asymptotic) speedups for CLP (&lt; Lin ) programs. Much research has been devoted to abstract interpretation of CLP (&lt; Lin ) (e.g., <ref> [6, 7, 14, 16, 19] </ref>) but almost no experimental results have appeared to quantify the possible benefits. The only exception we are aware of is the system described in [10] but no reordering or constraint removal is performed in the system. <p> This input description of course characterizes all input stores for p encountered at runtime. The fact that these two descriptions suffice to produce good results comes from the nature of the abstract domains. 4.2 The Domain LSign The domain LSign <ref> [16, 19] </ref> is fundamental for the reordering phase and for detecting unconstrained variables in the refinement phase. Its two critical ideas are the replacement of coefficients by their signs and the association of multiplicity information with constraints. <p> Note that abstract operations on this domain are non-trivial and use abstract versions of Fourier and Gaussian elimination. See <ref> [16, 19] </ref> for the details. We now illustrate the domain LSign on our running example.
Reference: [17] <author> S. Michaylov and B. Pippin. </author> <title> Optimizing Compilation of Linear Arithmetic in a Class of Constraint Logic Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS-94), </booktitle> <pages> pages 586-600, </pages> <address> Ithaca, NY, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: In our benchmarks, we have used an interest rate of 1% per month and a monthly repayment of 2 units; the final balance is unconstrained. The value of the principal and time period vary to illustrate various tradeoffs in the optimizations. Ode-euler <ref> [17] </ref> is a program solving the ordinary differential equation y 0 = t numerically using Euler method.
Reference: [18] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-Time Derivation of Variable Dependency Using Abstract Interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2-3):315-347, </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: The upper bound operation is a consistent abstraction of union of sets of constraint stores. The last step of the methodology consists of computing the least fixpoint or a postfixpoint of the abstract semantics using an algorithm such as GAIA [12] or PLAI <ref> [18] </ref>. Both of these are top-down algorithms computing a small, but sufficient, subset of least fixpoint (or of a postfixpoint) necessary to answer a user query. &gt;From the abstract interpretation results, our current optimizing compiler uses basically two pieces of information for each predicate p in the program.
Reference: [19] <author> V. Ramachandran and P. Van Hentenryck. LSign Reordered. </author> <title> In Static Analysis Symposium (SAS-95), </title> <address> Glasgow, UK, </address> <month> September </month> <year> 1995. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: In particular, it uses the generic abstract interpretation algorithm GAIA [11] instantiated to three abstract domains: Prop [13, 20] to deduce information on fixed variables, RatOrder [1] to remove redundant constraints, and LSign <ref> [16, 19] </ref> to reorder constraints and to determine unconstrained variables. The preliminary experimental results indicate that substantial speedups can be obtained. In particular, on most of the benchmarks, the speedups are asymptotic, i.e., they depend on the size of the inputs. <p> The main conceptual contribution of the paper is to show that sophisticated static analyses and source to source transformations can produce dramatic (often asymptotic) speedups for CLP (&lt; Lin ) programs. Much research has been devoted to abstract interpretation of CLP (&lt; Lin ) (e.g., <ref> [6, 7, 14, 16, 19] </ref>) but almost no experimental results have appeared to quantify the possible benefits. The only exception we are aware of is the system described in [10] but no reordering or constraint removal is performed in the system. <p> This input description of course characterizes all input stores for p encountered at runtime. The fact that these two descriptions suffice to produce good results comes from the nature of the abstract domains. 4.2 The Domain LSign The domain LSign <ref> [16, 19] </ref> is fundamental for the reordering phase and for detecting unconstrained variables in the refinement phase. Its two critical ideas are the replacement of coefficients by their signs and the association of multiplicity information with constraints. <p> Note that abstract operations on this domain are non-trivial and use abstract versions of Fourier and Gaussian elimination. See <ref> [16, 19] </ref> for the details. We now illustrate the domain LSign on our running example.
Reference: [20] <author> P. Van Hentenryck, A. Cortesi, and B. Le Charlier. </author> <title> Evaluation of Prop. </title> <journal> Journal of Logic Programming, </journal> <volume> 23(3), </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: In particular, it uses the generic abstract interpretation algorithm GAIA [11] instantiated to three abstract domains: Prop <ref> [13, 20] </ref> to deduce information on fixed variables, RatOrder [1] to remove redundant constraints, and LSign [16, 19] to reorder constraints and to determine unconstrained variables. The preliminary experimental results indicate that substantial speedups can be obtained. <p> For instance, the second abstract store captures the stores encountered for the first recursive call to mg. 4.3 The Domain Prop The domain Prop <ref> [14, 20] </ref> is an effective domain to compute groundness information for Prolog. It can be extended easily to infer fixed variables in CLP (e.g. [7]). Its key idea is to represent the information through a Boolean formula.
Reference: [21] <author> P. Van Hentenryck and V. Ramachandran. </author> <note> Backtracking without Trailing in CLP(&lt; lin ). ACM Transactions on Programming Languages and Systems, 1995. (to appear). 16 </note>
Reference-contexts: Section 7 reports our preliminary experimental results, while Section 8 concludes the paper. 2 Overview of CLP (&lt; Lin ) In this section, we give an informal overview of CLP (&lt; Lin ). The reader interested in more details can refer to <ref> [8, 21] </ref>.
References-found: 21

