URL: http://www-cad.eecs.berkeley.edu/HomePages/luciano/publications/jou/micro-94.ps.gz
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/luciano/publications.html
Root-URL: 
Title: A Formal Methodology for Hardware/Software Co-design of Embedded Systems  
Author: Massimiliano Chiodo, Paolo Giusto, Harry Hsieh Attila Jurecska, Luciano Lavagno Alberto Sangiovanni-Vincentelli 
Abstract: Our methodology for control-dominated embedded reactive systems is based on an implementation-independent representation, Codesign Finite State Machines (CFSMs). This representation allows us to preserve se-mantical correctness throughout the design process, because CFSMs assume unbounded, non-zero reaction delays, that correspond both to hardware and software behavior. CFSMs can be generated from a variety of specification languages, such as Esterel, StateCharts, VHDL, Verilog. Partitioning is user-driven, while our codesign environment performs automatically all other synthesis tasks. We derive hardware directly from CFSMs, assuming single-cycle reaction delays (but pipelining is also allowed by the model semantics). We synthesize software using an intermediate representation, Software Graphs, that allows better optimization and tighter control over implementation costs than general-purpose compilers. We are also planning to synthesize automatically a real-time scheduler and I/O port drivers, depending on the chosen micro-controller. We perform system validation by mixing formal verification (made possible by our finite-state model) with simulation (to identify and rule out special cases).
Abstract-found: 1
Intro-found: 1
Reference: [ACD90] <author> R. Alur, C. Courcoubetis, and D. Dill. </author> <title> Model-Checking for Real-Time Systems. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 414-425, </pages> <month> June </month> <year> 1990. </year> <month> 15 </month>
Reference-contexts: One such intermediate model can be obtained by composing N F (as proposed in <ref> [ACD90] </ref>) with an implementation-specific component T called a timing descriptor , which captures information about the allowed delays in a given implementation. Portions of T related to hardware are obtained trivially as a 1-clock delays. <p> Even with an unrealistically coarse base clock of 0.1 seconds, we have a total of 60,000,000 states. The longest run requires about 6.5 hours of CPU time on a DEC5000/125 with 64 Mbytes of memory. Dense-time algorithm as in <ref> [ACD90] </ref>) may be one way to cope with complexity, but more research needs to be done to make these algorithms applicable to 14 problems of real-life magnitude.
Reference: [ASU88] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Hence, the s-graph is a reduced form of the control-flow graphs that are used in compiler technology (see, e.g., <ref> [ASU88] </ref>). As such, it is amenable to the standard set of optimizations that are done by compilers, plus some specific ones. An s-graph is a directed acyclic graph (DAG), containing the following types of vertices: BEGIN, END, CALL, TEST, and ASSIGN.
Reference: [Bak93] <author> W. Baker. </author> <title> Application of the synchronous/reactive model to the VHDL language. </title> <type> Technical report, </type> <institution> U.C. Berkeley, </institution> <year> 1993. </year>
Reference: [BCG91] <author> G. Berry, P. Couronne, and G. Gonthier. </author> <title> The synchronous approach to reactive and real-time systems. </title> <journal> IEEE Proceedings, </journal> <volume> 79, </volume> <month> September </month> <year> 1991. </year>
Reference: [Bur92] <author> J. R. Burch. </author> <title> Automatic Symbolic Verification of Real-Time Concurrent Systems. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: In our methodology, we use a discrete model of time, where each computing element takes a non-zero unbounded (at least before an implementation is chosen) time to perform its task. This model is quite realistic for synchronous systems and lends itself to efficient formal verification techniques (e.g. [Kur90], <ref> [Bur92] </ref>). The synthesis methodology uses two auxiliary models, derived from CFSM specifications, to describe a hardware and a software component respectively. The first model is a standard logic netlist used by logic synthesis systems.
Reference: [CGH + 93] <author> Massimiliano Chiodo, Paolo Giusto, Harry Hsieh, Attila Jurecska, Luciano Lavagno, and Alberto Sangiovanni-Vincentelli. </author> <title> A formal specification model for hardware/software codesign. </title> <type> Technical Report UCB/ERL M93/48, </type> <institution> U.C. Berkeley, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: This section describes the set of assumptions that we chose to add to this basic intuition, in order to obtain a powerful general model for control-dominated reactive systems. A more extensive treatment can be found in <ref> [CGH + 93] </ref>. Suppose that we want to specify a simple safety function of an automobile: a seat belt alarm.
Reference: [COB92] <author> P. Chou, R. Ortega, and G. Borriello. </author> <booktitle> Synthesis of hardware/software interface in microcontroller-based systems. In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1992. </year>
Reference-contexts: Conversely, methods to implement hardware specifications in software have been proposed (e.g., [GJM94], [Str92]). Some research has focused on particular aspects of hardware-software cooperation, such as design of interfaces between hardware and software components (e.g., [SB92], <ref> [COB92] </ref>) or formal specification of hardware-software system properties (e.g., [MKP92]). Our formalism, the Co-design Finite State Machine (CFSM), is an extension of classical Finite State Machines. It is equally expressive for hardware or software implementations of control-dominated machines. <p> Conceptually we can think of an interface mechanism as a three-layer block (see figure 4 and <ref> [COB92] </ref>). A "carrier" here can be, for example, a printed circuit board track or a bus. Each block acts as a translator between representations in different domains. For example, Figure 5.(a) describes the "A" and "B" blocks of a hardware ) hardware interface (a simple wire).
Reference: [DH89] <author> D. Druzinski and D. Har'el. </author> <title> Using statecharts for hardware description and synthesis. </title> <journal> IEEE Transacions on Computer-Aided Design, </journal> <volume> 8(7), </volume> <month> July </month> <year> 1989. </year>
Reference: [GJM94] <author> R. K. Gupta, C. N. Coelho Jr., and G. De Micheli. </author> <title> Program implementation schemes for hardware-software systems. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 48-55, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Conversely, methods to implement hardware specifications in software have been proposed (e.g., <ref> [GJM94] </ref>, [Str92]). Some research has focused on particular aspects of hardware-software cooperation, such as design of interfaces between hardware and software components (e.g., [SB92], [COB92]) or formal specification of hardware-software system properties (e.g., [MKP92]). Our formalism, the Co-design Finite State Machine (CFSM), is an extension of classical Finite State Machines.
Reference: [HCRP91] <author> N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud. </author> <title> The synchronous data flow programming language LUSTRE. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9) </volume> <pages> 1305-1320, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: This scheme assumes a broadcast communication model, as opposed to point-to-point channels as in CSP. Note that events are quite similar to the valued-token model used to model computation-intensive applications (e.g., <ref> [HCRP91] </ref>) and can be used to interface the two domains.
Reference: [Kur90] <author> R. P. Kurshan. </author> <title> Analysis of discrete event coordination. </title> <booktitle> In Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: It is equally expressive for hardware or software implementations of control-dominated machines. It is also formally defined, hence it can be directly used to verify some properties that will be shared by all implementations (e.g., as proposed in <ref> [Kur90] </ref>). The basic model is a network of interacting CFSMs, that communicate through a very low-level primitive: events. Events are emitted by a CFSM or by the environment where the system operates and can be detected some time later by one or more CFSMs or by the environment. <p> In our methodology, we use a discrete model of time, where each computing element takes a non-zero unbounded (at least before an implementation is chosen) time to perform its task. This model is quite realistic for synchronous systems and lends itself to efficient formal verification techniques (e.g. <ref> [Kur90] </ref>, [Bur92]). The synthesis methodology uses two auxiliary models, derived from CFSM specifications, to describe a hardware and a software component respectively. The first model is a standard logic netlist used by logic synthesis systems. <p> Examples of properties of our seat-belt system are "The alarm will not be on forever" (untimed) and "The alarm will not be on for more than 6 seconds" (timed). After modeling both the system and the properties, implementation-independent verification can be done with existing formal verification tools (e.g., <ref> [Kur90] </ref>, [SAB + 93]). Between the abstracted behavior of a specification (an FSM network N F in our case) and the actual behavior of a given implementation I there exists a number of intermediate models, which can be used as input to a formal verification algorithm.
Reference: [MKP92] <author> M.C. McFarland, T.J. Kowalski, and M.J. Peman. </author> <title> Language and formal semantics of the specification system CPA. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Code-sign, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: Conversely, methods to implement hardware specifications in software have been proposed (e.g., [GJM94], [Str92]). Some research has focused on particular aspects of hardware-software cooperation, such as design of interfaces between hardware and software components (e.g., [SB92], [COB92]) or formal specification of hardware-software system properties (e.g., <ref> [MKP92] </ref>). Our formalism, the Co-design Finite State Machine (CFSM), is an extension of classical Finite State Machines. It is equally expressive for hardware or software implementations of control-dominated machines.
Reference: [SAB + 93] <author> T. Shiple, A. Aziz, F. Balarin, S. Cheng, R. Hojati, T. Kam, S. Kr-ishnan, V. Singhal, H. Wang, R. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Formal design verification of digital systems. </title> <booktitle> In Proceedings of TECHCON, </booktitle> <year> 1993. </year> <month> 16 </month>
Reference-contexts: Examples of properties of our seat-belt system are "The alarm will not be on forever" (untimed) and "The alarm will not be on for more than 6 seconds" (timed). After modeling both the system and the properties, implementation-independent verification can be done with existing formal verification tools (e.g., [Kur90], <ref> [SAB + 93] </ref>). Between the abstracted behavior of a specification (an FSM network N F in our case) and the actual behavior of a given implementation I there exists a number of intermediate models, which can be used as input to a formal verification algorithm.
Reference: [SB92] <author> J. Sun and R. W. Brodersen. </author> <title> Design of system interface modules. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 478-481, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Conversely, methods to implement hardware specifications in software have been proposed (e.g., [GJM94], [Str92]). Some research has focused on particular aspects of hardware-software cooperation, such as design of interfaces between hardware and software components (e.g., <ref> [SB92] </ref>, [COB92]) or formal specification of hardware-software system properties (e.g., [MKP92]). Our formalism, the Co-design Finite State Machine (CFSM), is an extension of classical Finite State Machines. It is equally expressive for hardware or software implementations of control-dominated machines.
Reference: [SSM + 92] <author> E.M. Sentovich, K.J. Singh, C. Moon, H. Savoj, R.K. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> Sequential circuit design using synthesis and optimization. </title> <booktitle> In Proceedings of the International Conference on Computer Design, </booktitle> <month> October </month> <year> 1992. </year>
Reference: [Str92] <author> C. E. Stroud. </author> <title> Problems associated with hardware implementation of software algorithms using behavioral model synthesis. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: Conversely, methods to implement hardware specifications in software have been proposed (e.g., [GJM94], <ref> [Str92] </ref>). Some research has focused on particular aspects of hardware-software cooperation, such as design of interfaces between hardware and software components (e.g., [SB92], [COB92]) or formal specification of hardware-software system properties (e.g., [MKP92]). Our formalism, the Co-design Finite State Machine (CFSM), is an extension of classical Finite State Machines.
Reference: [WDW94] <author> N. Woo, A. Dunlop, and W. Wolf. </author> <title> Codesign from cospecification. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 42-47, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: For example various flavors of Hoare's Communicating Sequential Processes (CSP) have been translated into synchronous or asynchronous circuits; languages for real-time software specification, such as ESTEREL ([BCG91]), StateCharts ([DH89]), or some modification of C (e.g., <ref> [WDW94] </ref>), have been directly or indirectly used as hardware description languages. Conversely, methods to implement hardware specifications in software have been proposed (e.g., [GJM94], [Str92]).

References-found: 17

