URL: ftp://ftp.ics.hawaii.edu/pub/tr/ics-tr-94-11.ps.Z
Refering-URL: ftp://ftp.ics.hawaii.edu/pub/tr/INDEX.html
Root-URL: 
Email: corbett@hawaii.edu  
Title: Modeling and Analysis of Real-Time Ada Tasking Programs  
Author: James C. Corbett 
Address: Manoa  
Affiliation: Department of Information and Computer Science University of Hawaii at  
Abstract: We propose a model for real-time Ada tasking programs that naturally represents such features as processor sharing, priority preemption, and process suspension. We describe a semi-decision procedure for proving properties of the model that uses linear programming to determine the feasibility of paths explored during a state-space search of the program. We demonstrate the feasibility of this procedure by applying a prototype analyzer to several examples. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur and D. Dill. </author> <title> Automata for modeling real-time systems. </title> <booktitle> In Proc. 17th Int. Colloq. </booktitle> <address> Aut. Lang. Prog., </address> <year> 1990. </year>
Reference-contexts: Third, we describe the results of several experiments with a prototype analyzer. Model. One might question the need for a new model of real-time systems given the abundance of such models, including: timed Petri nets [4, 6], timed automata <ref> [1, 13, 14, 17] </ref>, timed process algebras [5, 16], and real-time logics [7, 10]. The difficultly is that real programs usually have resource constraints that are absent in these more abstract models and are difficult to represent within them. <p> x 3 0:9 ! y 3 10 send2*, fx 4 g send1*, fx 3 g signal, fx 3 g x 3 ; x 4 := 0 x 3 3:6 ! Real CPU Delay time Action time Sensor1Expire 4 ReadSensor1 [0:5; 1:1] Sensor2Expire 8 ReadSensor2 [1:5; 2] ProximityExpire 10 accept Sendi <ref> [0:9; 1] </ref> PeriodLength 6 Compute+Signal [3:6; 5:6] error, ; signal, ; y 4 := 0 x 4 0 x 2 2 x 4 0 x 2 2 y 1 6 read1, fx 1 g x 1 0:5 ! x 1 := 0 expire1, ; y 1 4 ! x 3 0
Reference: [2] <author> R. Alur, T. Henzinger, and P. Ho. </author> <title> Automatic symbolic verification of embedded systems. </title> <booktitle> In Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <year> 1993. </year>
Reference-contexts: Models used in schedulability analysis [9] do account for resource sharing, but are restricted to scheduling highly structured units of computation with limited interaction. Our model is essentially a restricted form of hybrid automata <ref> [2] </ref>, with the addition of features for representing priority and resource sharing. It combines the generality of the specification models with features needed to represent a running program. <p> In Section 4, we apply a prototype analyzer to a range of examples from the literature. We also compare the performance of our tool with that of the HyTech verifier for hybrid systems <ref> [2] </ref>. 2 Model We want to construct an abstract model of a real-time Ada tasking program that is sufficiently accurate and yet analyzable. The model must include enough detail to verify properties of interest, but not so much detail that the analysis becomes intractable. <p> := 0 x 4 0:9 ! x 3 0:9 ! y 3 10 send2*, fx 4 g send1*, fx 3 g signal, fx 3 g x 3 ; x 4 := 0 x 3 3:6 ! Real CPU Delay time Action time Sensor1Expire 4 ReadSensor1 [0:5; 1:1] Sensor2Expire 8 ReadSensor2 <ref> [1:5; 2] </ref> ProximityExpire 10 accept Sendi [0:9; 1] PeriodLength 6 Compute+Signal [3:6; 5:6] error, ; signal, ; y 4 := 0 x 4 0 x 2 2 x 4 0 x 2 2 y 1 6 read1, fx 1 g x 1 0:5 ! x 1 := 0 expire1, ; y <p> The LP problems are solved with the MINOS optimization package which uses a simplex-based method. We applied our tool to versions of several real-time specifications from the literature, including: the Fischer timed mutual exclusion protocol in <ref> [2] </ref>, the nuclear control rods [3], the train crossing [2, 3], a timed producer-consumer system [11], and the distributed robot system [5]. The first four examples all involved proving certain states unreachable (e.g., states where the train is in the crossing and the gate is not down). <p> The LP problems are solved with the MINOS optimization package which uses a simplex-based method. We applied our tool to versions of several real-time specifications from the literature, including: the Fischer timed mutual exclusion protocol in [2], the nuclear control rods [3], the train crossing <ref> [2, 3] </ref>, a timed producer-consumer system [11], and the distributed robot system [5]. The first four examples all involved proving certain states unreachable (e.g., states where the train is in the crossing and the gate is not down). <p> The first four examples all involved proving certain states unreachable (e.g., states where the train is in the crossing and the gate is not down). Our analysis algorithm terminated successfully for all of these examples except the Fischer protocol, the specification of which in <ref> [2] </ref> contains a timed feasible cycle of unreachable states. When we added an upper bound on the time a process can remain in its critical section, however, this cycle was no longer timed feasible and our analysis algorithm terminated successfully. <p> For comparison, we also include in Table 1 the performance of the HyTech verifier for hybrid systems <ref> [2] </ref> on the same problems. We wrote a simple translator to generate the input for HyTech automatically from the mounted product automaton produced by our tool, which is essentially a restricted kind of hybrid automaton.
Reference: [3] <author> J. M. Atlee and J. Gannon. </author> <title> Analyzing timing requirements. </title> <editor> In T. Ostrand and E. Weyuker, editors, </editor> <booktitle> Proceedings of the 1993 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 117-127, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The LP problems are solved with the MINOS optimization package which uses a simplex-based method. We applied our tool to versions of several real-time specifications from the literature, including: the Fischer timed mutual exclusion protocol in [2], the nuclear control rods <ref> [3] </ref>, the train crossing [2, 3], a timed producer-consumer system [11], and the distributed robot system [5]. The first four examples all involved proving certain states unreachable (e.g., states where the train is in the crossing and the gate is not down). <p> The LP problems are solved with the MINOS optimization package which uses a simplex-based method. We applied our tool to versions of several real-time specifications from the literature, including: the Fischer timed mutual exclusion protocol in [2], the nuclear control rods [3], the train crossing <ref> [2, 3] </ref>, a timed producer-consumer system [11], and the distributed robot system [5]. The first four examples all involved proving certain states unreachable (e.g., states where the train is in the crossing and the gate is not down).
Reference: [4] <author> B. Berthomieu and M. Diaz. </author> <title> Modeling and verification of time dependent systems using time Petri nets. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17 </volume> <pages> 259-273, </pages> <year> 1991. </year>
Reference-contexts: Third, we describe the results of several experiments with a prototype analyzer. Model. One might question the need for a new model of real-time systems given the abundance of such models, including: timed Petri nets <ref> [4, 6] </ref>, timed automata [1, 13, 14, 17], timed process algebras [5, 16], and real-time logics [7, 10]. The difficultly is that real programs usually have resource constraints that are absent in these more abstract models and are difficult to represent within them.
Reference: [5] <author> R. Gerber and I. Lee. </author> <title> A layered approach to automating the verification of real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 18(9) </volume> <pages> 768-784, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Third, we describe the results of several experiments with a prototype analyzer. Model. One might question the need for a new model of real-time systems given the abundance of such models, including: timed Petri nets [4, 6], timed automata [1, 13, 14, 17], timed process algebras <ref> [5, 16] </ref>, and real-time logics [7, 10]. The difficultly is that real programs usually have resource constraints that are absent in these more abstract models and are difficult to represent within them. This is not a shortcoming of these modelsmost are intended for representing specifications, not implementations. <p> The difficultly is that real programs usually have resource constraints that are absent in these more abstract models and are difficult to represent within them. This is not a shortcoming of these modelsmost are intended for representing specifications, not implementations. Gerber's CCSR <ref> [5] </ref> is one exception, and indeed we borrow his notion of priority and preemption with shared resources, though we use a continuous model of time rather than his discrete one. <p> For example, a certain block of code might take exactly 5, 10, or 15 time units to execute. In our model, we would represent this code using an action whose duration could be any real value in the interval <ref> [5; 15] </ref>. If we now prove that no behaviors of the model have a certain anomaly, then we have shown that no behaviors of the real program do either. <p> As an example, we present a variant of the distributed robot system of <ref> [5] </ref> in which sensor data are integrated to periodically send a command to a robot. There are two sensor tasks and one integrator task. The code for one sensor task is shown in Figure 1; the other sensor task is similar. <p> We applied our tool to versions of several real-time specifications from the literature, including: the Fischer timed mutual exclusion protocol in [2], the nuclear control rods [3], the train crossing [2, 3], a timed producer-consumer system [11], and the distributed robot system <ref> [5] </ref>. The first four examples all involved proving certain states unreachable (e.g., states where the train is in the crossing and the gate is not down). <p> The last example we present is a variant of the distributed robot system of <ref> [5] </ref> with two sensor tasks and one integrator task, each of which has been slightly modified so that the whole example illustrates as many real-time features of Ada as possible. The system in [5] has many more components, but each action takes exactly one time unit. <p> The last example we present is a variant of the distributed robot system of <ref> [5] </ref> with two sensor tasks and one integrator task, each of which has been slightly modified so that the whole example illustrates as many real-time features of Ada as possible. The system in [5] has many more components, but each action takes exactly one time unit. Our version was described in Section 2.3.
Reference: [6] <author> C. Ghezzi, D. Mandriolli, S. Morasca, and M. Pezze. </author> <title> A unified high-level Petri net model for time-critical systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(2), </volume> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: Third, we describe the results of several experiments with a prototype analyzer. Model. One might question the need for a new model of real-time systems given the abundance of such models, including: timed Petri nets <ref> [4, 6] </ref>, timed automata [1, 13, 14, 17], timed process algebras [5, 16], and real-time logics [7, 10]. The difficultly is that real programs usually have resource constraints that are absent in these more abstract models and are difficult to represent within them.
Reference: [7] <author> C. Ghezzi, D. Mandriolli, and A. Morzenti. </author> <title> Trio: A logic language for executable specifications of real-time systems. </title> <journal> Journal of Systems and Software, </journal> <volume> 12(2) </volume> <pages> 107-123, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Model. One might question the need for a new model of real-time systems given the abundance of such models, including: timed Petri nets [4, 6], timed automata [1, 13, 14, 17], timed process algebras [5, 16], and real-time logics <ref> [7, 10] </ref>. The difficultly is that real programs usually have resource constraints that are absent in these more abstract models and are difficult to represent within them. This is not a shortcoming of these modelsmost are intended for representing specifications, not implementations.
Reference: [8] <author> P. Godefroid and P. Wolper. </author> <title> Using partial orders for the efficient verification of deadlock freedom and safety properties. </title> <editor> In K. G. Larsen and A. Skou, editors, </editor> <booktitle> Computer Aided Verification, 3rd International Workshop Proceedings, volume 575 of Lecture Notes in Computer Science, </booktitle> <pages> pages 332-242, </pages> <address> Aalborg, Den-mark, July 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We may verify such properties by including their automata in the product and then testing for the reachability of all product states in which the property automaton is accepting <ref> [8] </ref>. Figure 4 shows an automaton expressing the real-time response property a signal must be generated at least every 15 ms. Integration properties (e.g., a task spends less than 10 percent of its time in its critical section) can be expressed using property automata with local clocks.
Reference: [9] <author> M. G. Harbour, M. H. Klein, and J. P. Lehoczky. </author> <title> Timing analysis for fixed-priority scheduling of hard real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 20(1) </volume> <pages> 13-28, </pages> <year> 1994. </year>
Reference-contexts: Gerber's CCSR [5] is one exception, and indeed we borrow his notion of priority and preemption with shared resources, though we use a continuous model of time rather than his discrete one. Models used in schedulability analysis <ref> [9] </ref> do account for resource sharing, but are restricted to scheduling highly structured units of computation with limited interaction. Our model is essentially a restricted form of hybrid automata [2], with the addition of features for representing priority and resource sharing.
Reference: [10] <author> F. Jahanian and A. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 12(5) </volume> <pages> 890-904, </pages> <year> 1986. </year>
Reference-contexts: Model. One might question the need for a new model of real-time systems given the abundance of such models, including: timed Petri nets [4, 6], timed automata [1, 13, 14, 17], timed process algebras [5, 16], and real-time logics <ref> [7, 10] </ref>. The difficultly is that real programs usually have resource constraints that are absent in these more abstract models and are difficult to represent within them. This is not a shortcoming of these modelsmost are intended for representing specifications, not implementations.
Reference: [11] <author> I. Lee, R. Gerber, and A. Zwarico. </author> <title> Specifying scheduling paradigms for time dependent processes. </title> <booktitle> In Proceedings of the IEEE Workshop on Real-time Operating Systems and Software, </booktitle> <year> 1988. </year>
Reference-contexts: We applied our tool to versions of several real-time specifications from the literature, including: the Fischer timed mutual exclusion protocol in [2], the nuclear control rods [3], the train crossing [2, 3], a timed producer-consumer system <ref> [11] </ref>, and the distributed robot system [5]. The first four examples all involved proving certain states unreachable (e.g., states where the train is in the crossing and the gate is not down).
Reference: [12] <author> A. Mok. </author> <title> Evaluating tight execution time bounds of programs by annotations. </title> <booktitle> In Proceedings of the IEEE Workshop on Real-time Operating Systems and Software, </booktitle> <pages> pages 74-80, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: States in this automaton correspond to points of control within the task before and after synchronizations (e.g., entry calls/accepts, delay statements). We partition task actions into three classes: rendezvous, internal computations, and timeouts. The representation of each kind of action is described below. We assume that techniques like <ref> [12, 15] </ref>, closely tied to a compiler and architectural information, would be used to determine bounds on the CPU time for all code regions between synchronizations. We also assume that other kinds of overhead (e.g., context switch time, timer interrupts) can be accounted for in these bounds.
Reference: [13] <author> X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> Compiling real-time specifications into extended automata. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 18(9) </volume> <pages> 794-804, </pages> <year> 1992. </year>
Reference-contexts: Third, we describe the results of several experiments with a prototype analyzer. Model. One might question the need for a new model of real-time systems given the abundance of such models, including: timed Petri nets [4, 6], timed automata <ref> [1, 13, 14, 17] </ref>, timed process algebras [5, 16], and real-time logics [7, 10]. The difficultly is that real programs usually have resource constraints that are absent in these more abstract models and are difficult to represent within them.
Reference: [14] <author> J. S. Ostroff. </author> <title> Deciding properties of timed transition models. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(2) </volume> <pages> 170-183, </pages> <year> 1990. </year>
Reference-contexts: Third, we describe the results of several experiments with a prototype analyzer. Model. One might question the need for a new model of real-time systems given the abundance of such models, including: timed Petri nets [4, 6], timed automata <ref> [1, 13, 14, 17] </ref>, timed process algebras [5, 16], and real-time logics [7, 10]. The difficultly is that real programs usually have resource constraints that are absent in these more abstract models and are difficult to represent within them.
Reference: [15] <author> C. Y. Park and A. C. Shaw. </author> <title> Experiments with a program timing tool based on source-level timing schema. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 48-57, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: For example, a certain block of code might take exactly 5, 10, or 15 time units to execute. In our model, we would represent this code using an action whose duration could be any real value in the interval <ref> [5; 15] </ref>. If we now prove that no behaviors of the model have a certain anomaly, then we have shown that no behaviors of the real program do either. <p> States in this automaton correspond to points of control within the task before and after synchronizations (e.g., entry calls/accepts, delay statements). We partition task actions into three classes: rendezvous, internal computations, and timeouts. The representation of each kind of action is described below. We assume that techniques like <ref> [12, 15] </ref>, closely tied to a compiler and architectural information, would be used to determine bounds on the CPU time for all code regions between synchronizations. We also assume that other kinds of overhead (e.g., context switch time, timer interrupts) can be accounted for in these bounds.
Reference: [16] <author> G. M. Reed and A. W. Roscoe. </author> <title> A timed model for communicating sequential processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 58 </volume> <pages> 249-261, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Third, we describe the results of several experiments with a prototype analyzer. Model. One might question the need for a new model of real-time systems given the abundance of such models, including: timed Petri nets [4, 6], timed automata [1, 13, 14, 17], timed process algebras <ref> [5, 16] </ref>, and real-time logics [7, 10]. The difficultly is that real programs usually have resource constraints that are absent in these more abstract models and are difficult to represent within them. This is not a shortcoming of these modelsmost are intended for representing specifications, not implementations.
Reference: [17] <author> A. C. Shaw. </author> <title> Communicating real-time state machines. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 18(9) </volume> <pages> 805-816, </pages> <year> 1992. </year>
Reference-contexts: Third, we describe the results of several experiments with a prototype analyzer. Model. One might question the need for a new model of real-time systems given the abundance of such models, including: timed Petri nets [4, 6], timed automata <ref> [1, 13, 14, 17] </ref>, timed process algebras [5, 16], and real-time logics [7, 10]. The difficultly is that real programs usually have resource constraints that are absent in these more abstract models and are difficult to represent within them.
References-found: 17

