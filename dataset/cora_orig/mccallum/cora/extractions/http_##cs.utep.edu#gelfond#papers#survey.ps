URL: http://cs.utep.edu/gelfond/papers/survey.ps
Refering-URL: http://cs.utep.edu/gelfond/gelfond.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fchitta,mgelfondg@cs.ep.utexas.edu  
Title: Logic Programming and Knowledge Representation  
Author: Chitta Baral and Michael Gelfond 
Date: February 22, 1994  
Address: El Paso, Texas 79968  
Affiliation: Computer Science Department University of Texas at El Paso  
Abstract-found: 0
Intro-found: 1
Reference: [AB90] <author> K. Apt and H. Blair. </author> <title> Arithmetic classification of perfect models of stratified programs. </title> <journal> Fundamenta Informaticae, </journal> <volume> 13 </volume> <pages> 1-18, </pages> <year> 1990. </year>
Reference-contexts: [Sch90] [MNR93] characterizes the expressibility of the stable model semantics of logic programs over natural numbers Theorem 10.2 [Sch90],[MNR93] A set s of natural numbers is 1 1 definable iff s is definable by a logic program under the stable model semantics. 2 The actual results of [Sch90], [MNR93], and <ref> [AB90] </ref> are stronger than the above theorem. Instead of definability of sets of natural numbers, these papers deal with definability over arbitrary infinite Herbrand universes. <p> The complexity is further decreased if we limit ourselves to stratified programs. Theorem 10.4 <ref> [AB90] </ref> A set s of natural numbers is definable by a stratified logic program iff s is definable by a first-order arithmetic formula. 2 The above theorem implies that any semantics of arbitrary logic programs is uncom-putable whenever the semantics agrees with the perfect model semantics on stratified programs.
Reference: [AB91] <author> K. Apt and M. Bezem. </author> <title> Acyclic programs. New Generation Computing, </title> <address> 9(3,4):335-365, </address> <year> 1991. </year>
Reference-contexts: From this and Lemma 2.4 it is easy to see that Y entails holds (alive; res (load; s 0 )), and :holds (alive; res (shoot; res (wait; (res (load; s 0 ))))). 2 As we can see, the logic programming solution <ref> [Eva89, AB91, EK89] </ref> to the original Yale Shooting Problem is rather natural and simple. (This is not, of course, to say that it can be easily generalized to more complicated forms of reasoning about actions.) It is worth recalling that the original formulations of this story in the formalisms of circumscription <p> Existence of a unique stable model and some additional insights into the above solution can be obtained from the fact that it belongs to the class of acyclic programs studied in <ref> [AB91] </ref>. We will briefly describe this class and its properties. Intuitively, the atom dependency graph of a program is analogous to the dependency graph but has as its vertices ground atoms, instead of predicate names. <p> For example, the dependency graph of a program, = fp (a) p (b)g does contain a cycle with only positive edges, but the atom dependency graph of does not. It is also easy to see that program Y is acyclic. As was shown in <ref> [AB91] </ref>, most of the semantics of general logic programs coincide for this class. The following theorem is obtained by combining results from [AB91], [Cav89], and [Prz89a] and is further discussed in Section 2.4. Theorem 2.5 [AB91] Let be an acyclic program. <p> It is also easy to see that program Y is acyclic. As was shown in <ref> [AB91] </ref>, most of the semantics of general logic programs coincide for this class. The following theorem is obtained by combining results from [AB91], [Cav89], and [Prz89a] and is further discussed in Section 2.4. Theorem 2.5 [AB91] Let be an acyclic program. <p> As was shown in <ref> [AB91] </ref>, most of the semantics of general logic programs coincide for this class. The following theorem is obtained by combining results from [AB91], [Cav89], and [Prz89a] and is further discussed in Section 2.4. Theorem 2.5 [AB91] Let be an acyclic program.
Reference: [ABW88] <author> K. Apt, H. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA., </address> <year> 1988. </year>
Reference-contexts: It is easy to show that a stable model of a general logic program is a model of its classical counterpart T . This explains the use of the term "model" in the definition of the stable model semantics which was influenced by the "preferred models" <ref> [ABW88, Prz88a, VG88] </ref> approach to the semantics of logic programs. According to this approach a logic program is identified with its classical counterpart and its semantics is given in terms of some (preferred) class of models of . <p> There is a collection of results giving sufficient conditions for these properties. We will now discuss some of these results. We start with the class of stratified programs <ref> [ABW88, VG88, CH85] </ref>. <p> Note that an edge may be labeled both by + and . A cycle in the dependency graph of a program is said to be a negative cycle if it contains at least one edge with a negative label. Proposition 2.1 <ref> [ABW88] </ref> A general logic program is stratified iff its dependency graph D does not contain any negative cycles. 2 The notion of stratification plays an important role in the fields of logic programming, deductive databases, and AI. The following theorem describes an important property of stratified programs. <p> The following theorem describes an important property of stratified programs. Proposition 2.2 <ref> [ABW88, GL88] </ref> Any stratified general logic program is categorical. 2 It is easy to see that the program from Example 2.1 is stratified and therefore has only one stable model. Existence of stable models was further studied in [Fag90, Cav89, Dun92, Prz88a]. <p> The first approach was to put a syntactic restriction on the program. Chandra and Harel [CH85] defined the concept of stratification and Apt, Blair and Walker <ref> [ABW88] </ref> and Van Gelder [VG88] developed a fixpoint semantics for stratified programs. Przymusinski [Prz88b] generalized the concept of stratification and introduced local stratification and perfect models. The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification.
Reference: [AN78] <author> H. Andreka and I. Nemeti. </author> <title> The generalized completeness of Horn predicate logic as a programming language. </title> <journal> Acta Cybernetica, </journal> <volume> 4 </volume> <pages> 3-10, </pages> <year> 1978. </year>
Reference-contexts: As was shown in <ref> [AN78] </ref> there are definite programs with non-recursive sets of ground consequences.) The second one states that entailment in such programs is equivalent to classical entailment in the first-order theory comp () [ DCA. (More information on the form of this theory can be found in Section 2.4).
Reference: [AP92] <author> J. Alferes and L. Pereira. </author> <title> On logic program semantics with two kinds of negation. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. of the Joint International Conference and Symposium on Logic Programming, </booktitle> <address> Wash DC, </address> <pages> pages 574-588. </pages> <publisher> MIT Press, </publisher> <month> Nov </month> <year> 1992. </year>
Reference-contexts: Several other semantics of extended logic programs are suggested in the literature <ref> [AP92, PAA91c, PAA92a, PAA92b, Prz90a, KS90] </ref>. We now discuss some of them. The formulation of well-founded semantics of general logic programs in [BS91] can be extended to define the well-founded semantics [Prz90a] of extended logic programs. More precisely, let us consider G (S) = b ( S ).
Reference: [Apt89] <author> K.R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science. </booktitle> <publisher> North Holland, </publisher> <year> 1989. </year>
Reference-contexts: Even though some affinity between logic programs and nonmonotonic logics was recognized rather early [Rei82], [Lif85a], the intensive work in this direction started in 1987 after the discovery of model theoretic semantics for stratified logic programs <ref> [Apt89] </ref>. Almost immediately after this notion was introduced, stratified logic programs were mapped into the three major nonmonotonic formalisms investigated at that time: circumscription [Lif88],[Prz88a], autoepistemic logic [Gel87] and default theories [BF91], [MT89].
Reference: [AR89] <editor> H. Abramson and M. Rogers, editors. </editor> <booktitle> Meta-Programming in Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: The literature on the subject is vast. Interesting meta-programs can be found in various textbooks on logic programming. Several workshop proceedings contain papers addressing theoretical problems related to meta-programming <ref> [AR89, Met92] </ref>. Logic programming languages based on the ideas of meta-programming such as Godel [HL91], Hilog [CKW93], Reflexive Prolog [CL89] among others are beginning to gain ground in logic programming community. In this paper we will not even attempt to mention all directions of research related to meta-programming.
Reference: [Bar91] <author> C. Baral. </author> <title> Issues in Knowledge Representation : Semantics and Knowledge Combination. </title> <type> PhD thesis, </type> <institution> University of Maryland (CS-TR-2761), Department of Computer Science, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: But the stationary semantics, the DWFS and the answer-set semantics infer a to be true. 2 More detailed comparison of the various semantics of normal disjunctive logic programs can be found in <ref> [Bar91, Dix91, Dix92] </ref>. [Bar91] gives a framework for the various semantics based on iterating a fixpoint operator (also known as an information accumulating operator) from a "nothing is known" initial state. <p> But the stationary semantics, the DWFS and the answer-set semantics infer a to be true. 2 More detailed comparison of the various semantics of normal disjunctive logic programs can be found in [Bar91, Dix91, Dix92]. <ref> [Bar91] </ref> gives a framework for the various semantics based on iterating a fixpoint operator (also known as an information accumulating operator) from a "nothing is known" initial state.
Reference: [Bar92] <author> C. Baral. </author> <title> Generalized Negation As Failure and Semantics of Normal Disjunctive Logic Programs. </title> <editor> In A Voronkov, editor, </editor> <booktitle> Proceedings of International Conference on Logic Programming and Automated Reasoning, St. Petersburg, </booktitle> <pages> pages 309-319, </pages> <year> 1992. </year>
Reference-contexts: Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92]. The semantics proposed in <ref> [Bar92] </ref> (DWFS Disjunctive Well-Founded Semantics) uses a fixpoint operator similar to the fixpoint operators used in [VGRS91, Prz89a] to define the well-founded semantics and iterates it starting from a "nothing is known" initial state until a fixpoint is reached.
Reference: [BED92] <author> R. Ben-Eliyahu and R. Dechter. </author> <title> Propositional semantics for disjunctive logic programs. </title> <booktitle> In Proceedings of the 1992 Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 813-827, </pages> <year> 1992. </year>
Reference-contexts: Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) <ref> [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92] </ref>. <p> problem for a disjunctive logic program (containing : and not) under the answer set semantics is P 2 -complete [EG93b]. 2 70 For a special but broad class of disjunctive logic programs ( in particular the headcycle--free programs) the decision problem under the answer set semantics is coN P -complete <ref> [BED92] </ref>. Note that similar complexity results have recently been derived for various forms of nonmonotonic reasoning such as default and autoepistemic logic [Got92], nonmonotonic S4 [ST93], theory revision [EG92], and abduction [EG93e]. For programs with variables, consider the case of first order disjunctive logic programs without function symbols.
Reference: [BF91] <author> N. Bidoit and C. Froidevaux. </author> <title> General logical databases and programs: Default logic semantics and stratification. </title> <journal> Journal of Information and Computation, </journal> <volume> 91(1) </volume> <pages> 15-54, </pages> <year> 1991. </year>
Reference-contexts: Almost immediately after this notion was introduced, stratified logic programs were mapped into the three major nonmonotonic formalisms investigated at that time: circumscription [Lif88],[Prz88a], autoepistemic logic [Gel87] and default theories <ref> [BF91] </ref>, [MT89]. Research in this area was stimulated by the workshop on Foundations of Deductive Databases and Logic Programming [Min88] and by the workshops on Logic Programming and Nonmonotonic Reasoning [NMS91, PN93]. <p> Thus, the deductive closure operator establishes a one-to-one correspondence between the answer sets of a program and its extensions. This result is a simple extension of results from <ref> [BF91] </ref>, and [MT89]. Perhaps somewhat surprisingly, it is not easily generalized to disjunctive databases.
Reference: [BG93] <author> C. Baral and M. Gelfond. </author> <title> Representing concurrent actions in extended logic programming. </title> <booktitle> In Proc. of 13th International Joint Conference on Artificial Intelligence, </booktitle> <address> Chambery, France, </address> <pages> pages 866-871, </pages> <year> 1993. </year>
Reference-contexts: Some of the later solutions, in particular those from [Gel89], and [Mor88], were given in the language of autoepistemic logic and non-normal default theory respectively, and are similar to the one presented here. Representing inheritance reasoning and reasoning about actions in logic programming is an active area of research <ref> [GL92, BG93, Dun93b, PR93, Esh88, DMB92, KS86] </ref>. Some of the works on both subjects will be discussed in the upcoming sections.
Reference: [BGK93] <author> C. Baral, M. Gelfond, and O. Kosheleva. </author> <title> Approximating general logic programs, </title> <booktitle> 1993. In Proc. of the International Symposium on Logic Programming, </booktitle> <pages> pages 181-198, </pages> <year> 1993. </year>
Reference-contexts: Because of its "cautious" approach, the authors prefer it to the formalization in Example 2.5. <ref> [BGK93] </ref> describes the precise relation between B 5 and B and elaborates why B 5 is preferable to B. Let us now prove that the above program, taken in conjunction with consistent (positive and negative) facts formed by predicates bird, penguin, wounded bird, and f lies is categorical. <p> not ab (X) If we allow updates consisting of literals formed with predicate p then the above normative statement should be translated as p (X) q (X); not ab (X); not :p (X) Fortunately, in many cases the more complex formalization seem to be correct extensions of the simpler ones <ref> [BGK93, Tur93] </ref>. The precise relationship between these different approaches is an interesting subject for further investigation.
Reference: [BK82] <author> K. Bowen and R. Kowalski. </author> <title> Amalgamating language and metalanguage in logic programming. In K.L. </title> <editor> Clark and S.A. Tarnlund, editors, </editor> <booktitle> Logic Programming, </booktitle> <pages> pages 153-173. </pages> <publisher> Academic Press, </publisher> <year> 1982. </year>
Reference-contexts: Programs with this property are called amalgamated. They were first introduced and investigated in [Kow79], <ref> [BK82] </ref>. To deal with such programs one should address a basic problem associated with their meaning. The problem is caused by overloading the symbols in the language. <p> It will be interesting to generalize this statement to programs from [BM90] and carefully investigate the relationship between the two approaches. More complicated (but also more general) meta-programming schemes are based on naming statements of object programs by ground terms on the meta-level as in <ref> [BK82] </ref> and [HL91], on allowing sentences name themselves as in [Ric74], or by other naming devices. Normally, these approaches require the development of special semantics. Additional complications occur if we allow self-referencing meta-programs.
Reference: [BLM91] <author> C. Baral, J. Lobo, and J. Minker. </author> <title> W F 3 : A Semantics for Negation in Normal Disjunctive Logic Programs with Equivalent Proof Methods. </title> <booktitle> In Proceedings of ISMIS 91, </booktitle> <pages> pages 459-468, </pages> <institution> Dept of Computer Science, University of Maryland, </institution> <month> October </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) <ref> [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92] </ref>.
Reference: [BLM92] <author> C. Baral, J. Lobo, and J. Minker. </author> <title> Generalized disjunctive well-founded semantics for logic programs. </title> <journal> Annals of Math and Artificial Intelligence, </journal> <volume> 5 </volume> <pages> 89-132, </pages> <year> 1992. </year>
Reference-contexts: Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) <ref> [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92] </ref>. <p> The semantics proposed in [Bar92] (DWFS Disjunctive Well-Founded Semantics) uses a fixpoint operator similar to the fixpoint operators used in [VGRS91, Prz89a] to define the well-founded semantics and iterates it starting from a "nothing is known" initial state until a fixpoint is reached. The semantics proposed in <ref> [BLM92] </ref> (GDWFS Generalized Disjunctive Well-Founded Semantics) uses a fixpoint operator which contains an additional model theoretic part.
Reference: [BM90] <author> A. Bonner and L. McCarty. </author> <title> Adding negation as failure to intuitionistic logic programming. </title> <editor> In S. Debray and M. Hermenegildo, editors, </editor> <booktitle> Logic Programming: Proc. of the 1990 North American Conf., </booktitle> <pages> pages 681-703, </pages> <year> 1990. </year>
Reference-contexts: Stratified programs can be replaced by weakly stratified programs, or possibly, a suitable three valued version of demo can be designed for arbitrary range restricted programs under well-founded semantics. Let us now look at a slightly more complicated example. Consider, for instance, the following story from <ref> [BM90] </ref>. Example 6.1 Consider a database 1 consisting of lists of students and courses, atomic formulas take (s; c) asserting that student s has taken course c, and a definition of predicate grad (s) which means that student s is eligible for graduation. <p> We want to represent the property near grad (s) meaning that student s is within one course of satisfying the graduation requirement. 50 In <ref> [BM90] </ref> this story is used to illustrate the power of intuitionistic logic programming with embedded implication (. <p> Intuitionistic semantics for such programs can be found in <ref> [Mil86, BM90, GO92] </ref>. Roughly speaking, to establish the derivability of near grad (s) in the corresponding intuitionistic program 1 under this semantic one should add the rule take (s; c) to 1 and then try to prove grad (s). <p> Apparently, the program above belongs to this class. It will be interesting to generalize this statement to programs from <ref> [BM90] </ref> and carefully investigate the relationship between the two approaches. More complicated (but also more general) meta-programming schemes are based on naming statements of object programs by ground terms on the meta-level as in [BK82] and [HL91], on allowing sentences name themselves as in [Ric74], or by other naming devices.
Reference: [BMPT92] <author> A. Brogi, P. Mancarella, D. Pedreschi, and F. Turini. </author> <title> Meta for modularising logic programming. </title> <booktitle> In Proc. META-92, </booktitle> <pages> pages 105-119, </pages> <year> 1992. </year>
Reference-contexts: Roughly speaking, to establish the derivability of near grad (s) in the corresponding intuitionistic program 1 under this semantic one should add the rule take (s; c) to 1 and then try to prove grad (s). As noticed in <ref> [BMPT92] </ref>, similar meaning can be naturally expressed via the use of predicate demo (T; q) as follows: 1: near grad (S) course (C); student (S); demo ( 1 + take (S; C); grad (S)) To make the case slightly more interesting let us consider a program 2 consisting of 1 ,
Reference: [BNNS94] <author> C. Bell, A. Nerode, R. Ng, </author> <title> and V.S. Subrahmanian. Computation and implementation of non-monotonic deductive databases. </title> <type> Technical Report CS-TR-2801, </type> <institution> University of Maryland, </institution> <note> 1991 (a revised version is to appear in JACM 94. </note>
Reference-contexts: SLDNF resolution, though sound [Cla78], is only complete for a subclass of stratified programs [JLL83]. Various practical Prolog systems have been developed based on SLDNF resolution. To answer queries with respect to programs with a multiple number of stable models, several approaches have been suggested <ref> [PAA91a, BNNS94, FLMS93, SZ90, IKH92, WC93, EK89] </ref> in the literature. <p> For a precise definition see [Llo87]. 12 and top-down methods. Bell et al. <ref> [BNNS94] </ref> present an approach to compute the stable models by constructing a linear programming problem from the program and solving the linear programming problem. In [Esg90], [PC89] truth maintenance systems are used to compute the stable models of a general program.
Reference: [BRSS92] <author> C. Beeri, R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> The valid model semantics for logic programs. </title> <booktitle> In Proceedings of Principles of Database Systems, </booktitle> <pages> pages 91-104, </pages> <year> 1992. </year>
Reference-contexts: Extensions of the languages by allowing more complex data such as sets and aggregates are very important in database applications <ref> [KS91, BRSS92, Gel92a] </ref>. Even more questions remain for noncategorical programs, i.e. logic programs with multiple answer sets or disjunctive logic programs. In this case one of the most important problems seems to be the lack of clear procedural interpretation of rules of a program.
Reference: [BS85] <author> G. Bossu and P. Siegel. </author> <title> Saturation, nonmonotonic reasoning and the closed-world assumption. </title> <journal> Artificial Intelligence, </journal> <volume> 25(1) </volume> <pages> 13-63, </pages> <year> 1985 </year> <month> January </month> <year> 1985. </year>
Reference-contexts: superscript and the atoms with predicate x. i.e. the answer sets of are fperson (a); :lh usable (a); ab 1 (a); rh usable (a)g and fperson (a); :rh usable (a); ab 2 (a); lh usable (a)g. 2 Answer sets of disjunctive logic programs can be obtained using model generation techniques <ref> [BS85, FM91, FH91, FM92, MB88] </ref>. Inoue et al. [IKH92] extend the model generation theorem prover (MGTP) [FH91] to compute the answer sets of the program obtained using tr 2 .
Reference: [BS91] <author> C. Baral and V. S. Subrahmanian. </author> <title> Duality between alternative semantics of logic programs and nonmonotonic formalisms. </title> <booktitle> In the International Workshop in logic programming and nonmonotonic reasoning pages 69-86- and to appear in Journal of Automated Reasoning, </booktitle> <year> 1991. </year>
Reference-contexts: Others moved closer to non-traditional non-monotonic logics. To give the reader a flavor of these developments, we introduce the well-founded semantics, and compare it with the stable models semantics. We will follow the ideas from <ref> [BS91] </ref> and [VG89]. Definition 2.3 [BS91] For any general logic program and a set of atoms S, consider F (S) = a ( S ), where a and S are as in Definition 2.1 of stable models. <p> Others moved closer to non-traditional non-monotonic logics. To give the reader a flavor of these developments, we introduce the well-founded semantics, and compare it with the stable models semantics. We will follow the ideas from <ref> [BS91] </ref> and [VG89]. Definition 2.3 [BS91] For any general logic program and a set of atoms S, consider F (S) = a ( S ), where a and S are as in Definition 2.1 of stable models. <p> S 1 , and p is true in all interpretations contained in S 1 . 2 Lemma 2.7 <ref> [BS91, Fit91] </ref> Let lf p stand for least fixpoint and gf p stand for greatest fix-point. <p> For any program , flf p (F 2 ); gf p (F 2 )g is a stable class, where F 2 denotes the operator that applies F twice. 2 We now give a simple characterization of the well-founded semantics in terms of stable classes. Definition 2.4 <ref> [BS91] </ref> For a general logic program , the stable class flf p (F 2 )g defines the well-founded semantics of . i.e. 1. a ground atom A is true in the well-founded semantics of iff A 2 lf p (F 2 ), and 2. a ground atom A is f alse <p> Several other semantics of extended logic programs are suggested in the literature [AP92, PAA91c, PAA92a, PAA92b, Prz90a, KS90]. We now discuss some of them. The formulation of well-founded semantics of general logic programs in <ref> [BS91] </ref> can be extended to define the well-founded semantics [Prz90a] of extended logic programs. More precisely, let us consider G (S) = b ( S ).
Reference: [BS92] <author> C. Baral and V. S. Subrahmanian. </author> <title> Stable and Extension Class Theory for Logic Programs and Default Logics. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 8 </volume> <pages> 345-366, </pages> <year> 1992. </year>
Reference-contexts: The third approach is analogous to the traditional approach in Reiter's default logic [Rei80b] and Moore's autoepistemic logic [Moo85] in which the definition of entailment is based on the notion of beliefs. The stable model semantics [GL88] used in this paper is based on this approach. In <ref> [BS92] </ref>, Baral and Subrahamanian introduce the concept of stable classes as a generalization of the stable models. Some of these approaches aimed at preserving reduction of the notion of entailment in logic programming to entailment in "classical" two-valued or three-valued theories. Others moved closer to non-traditional non-monotonic logics.
Reference: [Cav89] <author> L. Cavedon. </author> <title> Continuity, consistency, and completeness properties for logic programs. </title> <editor> In Giorgio Levi and Maurizio Martelli, editors, </editor> <booktitle> Logic Programming: Proc. of the Sixth Int'l Conf., </booktitle> <pages> pages 571-584, </pages> <year> 1989. </year>
Reference-contexts: Proposition 2.2 [ABW88, GL88] Any stratified general logic program is categorical. 2 It is easy to see that the program from Example 2.1 is stratified and therefore has only one stable model. Existence of stable models was further studied in <ref> [Fag90, Cav89, Dun92, Prz88a] </ref>. The following result, due to Fages [Fag90], is representative of this direction of research. A general logic program is said to be call-consistent [Kun89, Sat87] if its dependency graph does not have a cycle with an odd number of negative edges. <p> It is also easy to see that program Y is acyclic. As was shown in [AB91], most of the semantics of general logic programs coincide for this class. The following theorem is obtained by combining results from [AB91], <ref> [Cav89] </ref>, and [Prz89a] and is further discussed in Section 2.4. Theorem 2.5 [AB91] Let be an acyclic program.
Reference: [CDT91] <author> L. Console, D. Dupre, and P. Torasso. </author> <title> On the relationship between abduction and deduction. </title> <journal> Journal of Logic and Computation, </journal> <volume> 2(5), </volume> <year> 1991. </year>
Reference-contexts: For an alternative approach based on Clark's predicate completion see, for instance, <ref> [CDT91] </ref>). 60 Notice, that in this formalization knowledge about particular birds is not placed in 0 but in the integrity constraints. The rules of 0 represent general knowledge about birds and their flying abilities.
Reference: [CH85] <author> A. Chandra and D. Harel. </author> <title> Horn clause queries and generalizations. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(1) </volume> <pages> 1-5, </pages> <year> 1985. </year> <month> 75 </month>
Reference-contexts: There is a collection of results giving sufficient conditions for these properties. We will now discuss some of these results. We start with the class of stratified programs <ref> [ABW88, VG88, CH85] </ref>. <p> The first approach was to put a syntactic restriction on the program. Chandra and Harel <ref> [CH85] </ref> defined the concept of stratification and Apt, Blair and Walker [ABW88] and Van Gelder [VG88] developed a fixpoint semantics for stratified programs. Przymusinski [Prz88b] generalized the concept of stratification and introduced local stratification and perfect models.
Reference: [Cha93] <author> E. Chan. </author> <title> A Possible Worlds Semantics for Disjunctive Databases. </title> <journal> IEEE Trans--actions on Data and Knowledge Engineering, </journal> <volume> 5(2) </volume> <pages> 282-292, </pages> <year> 1993. </year>
Reference-contexts: Then the following holds: Theorem 10.7 (a) the decision problem for under the disjunctive database rule [RT88] and the equivalent weak generalized CWA [RLM89] is polynomial <ref> [Cha93] </ref> (co-N P -complete if heads can be empty), (b) the decision problem for under the possible models semantics [Sak89] and the equivalent possible worlds semantics [Cha93] is polynomial (co-N P -complete again if heads can be empty), (c) the decision problem for under the careful CWA [GP86] is P 2 <p> following holds: Theorem 10.7 (a) the decision problem for under the disjunctive database rule [RT88] and the equivalent weak generalized CWA [RLM89] is polynomial <ref> [Cha93] </ref> (co-N P -complete if heads can be empty), (b) the decision problem for under the possible models semantics [Sak89] and the equivalent possible worlds semantics [Cha93] is polynomial (co-N P -complete again if heads can be empty), (c) the decision problem for under the careful CWA [GP86] is P 2 -hard and in P 3 [O (log n)], (d) the decision problem for is P 2 -complete for the following semantics [EG93a, EG93c, EG93d]: the generalized
Reference: [Che93] <author> J. Chen. </author> <title> Minimal knowledge + negation as failure = only knowing (sometimes). </title> <booktitle> In Proceedings of the Second Int'l Workshop on Logic Programming and Non-monotonic Reasoning, Lisbon, </booktitle> <pages> pages 132-150, </pages> <year> 1993. </year>
Reference-contexts: Recently, several such mappings were independently found by several researchers [LS93], [MT93], <ref> [Che93] </ref>. The mapping fi from [Lif93], and [Che93] translates rules of a disjunctive logic program (of the form (19) into autoepistemic formulas of the form (L k+1 ^ B L k+1 ) ^ : : : ^ (L m ^ B L m ) ^ :B L m+1 ^ : : <p> Recently, several such mappings were independently found by several researchers [LS93], [MT93], <ref> [Che93] </ref>. The mapping fi from [Lif93], and [Che93] translates rules of a disjunctive logic program (of the form (19) into autoepistemic formulas of the form (L k+1 ^ B L k+1 ) ^ : : : ^ (L m ^ B L m ) ^ :B L m+1 ^ : : : ^ :B L n (L 0
Reference: [CKPR73] <author> A. Colmerauer, H. Kanoui, R. Pasero, and P. Roussel. </author> <title> Un Systeme de Communication Homme-Machine en Francais. </title> <type> Technical report, </type> <institution> Groupe de Intelligence Artificielle Universitae de Aix-Marseille II, Marseille, </institution> <year> 1973. </year>
Reference-contexts: This led Kowalski and Colmerauer to the creation of logic programming [Llo87] and the development of the first logic programming language, Prolog <ref> [CKPR73] </ref>. Even though logic programming and nonmonotonic logic share many common goals and techniques, until recently, there were no strong ties between the two research communities. Originally, declarative Prolog was defined as a small subset of predicate calculus. This dialect of Prolog is now called "pure" Prolog.
Reference: [CKW93] <author> W. Chen, M. Kifer, and D.S. Warren. </author> <title> A foundation for higher-order logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 15(3) </volume> <pages> 187-230, </pages> <year> 1993. </year>
Reference-contexts: The literature on the subject is vast. Interesting meta-programs can be found in various textbooks on logic programming. Several workshop proceedings contain papers addressing theoretical problems related to meta-programming [AR89, Met92]. Logic programming languages based on the ideas of meta-programming such as Godel [HL91], Hilog <ref> [CKW93] </ref>, Reflexive Prolog [CL89] among others are beginning to gain ground in logic programming community. In this paper we will not even attempt to mention all directions of research related to meta-programming.
Reference: [CL89] <author> S. Costantini and G.A. Lanzarone. </author> <title> A metalogic programming language. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Proc ICLP'89, </booktitle> <pages> pages 218-233, </pages> <year> 1989. </year>
Reference-contexts: The literature on the subject is vast. Interesting meta-programs can be found in various textbooks on logic programming. Several workshop proceedings contain papers addressing theoretical problems related to meta-programming [AR89, Met92]. Logic programming languages based on the ideas of meta-programming such as Godel [HL91], Hilog [CKW93], Reflexive Prolog <ref> [CL89] </ref> among others are beginning to gain ground in logic programming community. In this paper we will not even attempt to mention all directions of research related to meta-programming.
Reference: [CL90] <author> M. Cadoli and M. Lenzerini. </author> <title> The Complexity of Closed World Reasoning and Circumscription. </title> <booktitle> In Proceedings AAAI-90, </booktitle> <pages> pages 550-555, </pages> <year> 1990. </year> <note> Full paper to appear in Journal of Computer and System Sciences. </note>
Reference-contexts: Results for important restricted cases have been derived in <ref> [CL90] </ref>. For the extension of logic programming by classical negation [GL91], the following holds.
Reference: [Cla78] <author> K. Clark. </author> <title> Negation as failure. </title> <editor> In Herve Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: With time, however, Prolog evolved to incorporate some nonclassical, nonmonotonic features, which made it closer in spirit to the nonmonotonic logics mentioned above. The most important nonmonotonic feature of modern Prolog is negation as failure <ref> [Cla78, Rei78] </ref>. The initial definition of this construct was purely procedural, which inhibited its use for knowledge representation and software engineering, as well as for the investigation of the relationship between logic programming and other nonmonotonic formalisms. <p> A rule is an expression of the form A 0 A 1 ; : : : ; A m ; not A m+1 ; : : : ; not A n (1) where A i 's are atoms and not is a logical connective called negation as failure <ref> [Cla78, Rei78] </ref>. The left-hand side of the rule is called the rule's head or conclusion; the right-hand side is called the rule's body (or premise). <p> every ground atom A, j= A iff comp () [ DCA j= A; where comp () stands for the Clark's completion of and DCA is the domain closure axiom [Rei80a]. (iii) For all ground atoms A that do not flounder 6 , j= A iff there is an SLDNF derivation <ref> [Cla78] </ref> of A from . 2 The first condition of the theorem guarantees that, for a rather broad class of programs (including Y), there is an algorithm to answer all ground queries. (This is of course not true in the general case even for definite programs. <p> This is especially important because SLDN F is incorporated in most existing Prolog interpreters. 2.3 Answering Queries Several query answering methods have been suggested for stratified programs in the literature: in particular, SLDNF resolution <ref> [Cla78] </ref> and XOLDT resolution [TS86], [War91]. SLDNF resolution, though sound [Cla78], is only complete for a subclass of stratified programs [JLL83]. Various practical Prolog systems have been developed based on SLDNF resolution. <p> This is especially important because SLDN F is incorporated in most existing Prolog interpreters. 2.3 Answering Queries Several query answering methods have been suggested for stratified programs in the literature: in particular, SLDNF resolution <ref> [Cla78] </ref> and XOLDT resolution [TS86], [War91]. SLDNF resolution, though sound [Cla78], is only complete for a subclass of stratified programs [JLL83]. Various practical Prolog systems have been developed based on SLDNF resolution. <p> For more detailed discussion see the paper by Apt and Bol in this issue. 7 The research on finding a declarative semantics for general logic programs started with the pioneering work of Clark <ref> [Cla78] </ref> and Reiter [Rei78]. Clark [Cla78] introduced the concept of program completion to define a declarative semantics for negation as failure. In a general logic program, the bodies of clauses with a predicate p in the head can be viewed as "sufficiency" conditions for inferring p from the program. <p> For more detailed discussion see the paper by Apt and Bol in this issue. 7 The research on finding a declarative semantics for general logic programs started with the pioneering work of Clark <ref> [Cla78] </ref> and Reiter [Rei78]. Clark [Cla78] introduced the concept of program completion to define a declarative semantics for negation as failure. In a general logic program, the bodies of clauses with a predicate p in the head can be viewed as "sufficiency" conditions for inferring p from the program. <p> contains the first order formula 8X 1 : : : 8X k :q (X 1 ; : : : ; X k ) Comp (), Clark's completion of a general logic program contains the first order formulas generated in Step 2 and Step 3 above and the corresponding equality theory <ref> [Cla78] </ref>. The first order formulas obtained in step 2 and step 3 above allow us to infer negative facts. Clark's completion [Cla78] was the first declarative semantics of a general logic program. It partially corresponded to the procedural NAF rule and the SLDNF-resolution. Clark [Cla78] provided a constructive definition for completing <p> k ) Comp (), Clark's completion of a general logic program contains the first order formulas generated in Step 2 and Step 3 above and the corresponding equality theory <ref> [Cla78] </ref>. The first order formulas obtained in step 2 and step 3 above allow us to infer negative facts. Clark's completion [Cla78] was the first declarative semantics of a general logic program. It partially corresponded to the procedural NAF rule and the SLDNF-resolution. Clark [Cla78] provided a constructive definition for completing a general logic program and used it to prove the soundness of the NAF rule and the SLDNF-resolution. <p> above and the corresponding equality theory <ref> [Cla78] </ref>. The first order formulas obtained in step 2 and step 3 above allow us to infer negative facts. Clark's completion [Cla78] was the first declarative semantics of a general logic program. It partially corresponded to the procedural NAF rule and the SLDNF-resolution. Clark [Cla78] provided a constructive definition for completing a general logic program and used it to prove the soundness of the NAF rule and the SLDNF-resolution.
Reference: [CP86] <author> P. Cox and T. Pietrzykowski. </author> <title> Causes for events: their computation and applications. </title> <editor> In J.H. Siekmann, editor, </editor> <booktitle> Proc. of CADE-86, </booktitle> <pages> pages 608-621, </pages> <year> 1986. </year>
Reference: [CS92] <author> M. Cadoli and M. Schaerf. </author> <title> A survey on complexity results for nonmonotonic logics. </title> <type> Technical report, </type> <institution> University di Roma "La Sapienza", Dipartiment o di Informatica e sistemistica, Roma, Italy, </institution> <year> 1992. </year>
Reference-contexts: Variables for such sets will be denoted by X's and Y 's. 23 <ref> [CS92] </ref> contains a survey on complexity results for nonmonotonic logics. 68 Definition 10.2 A formula is 1 1 ( 1 1 ) if it is of the form 9XF (8XF ) where F is a first order formula.
Reference: [DDS92] <author> M. Denecker and D. De Schreye. SLDNFA: </author> <title> an abductive procedure for normal abductive logic programs. </title> <booktitle> In Proc. of JICSLP., </booktitle> <pages> pages 686-700, </pages> <year> 1992. </year>
Reference-contexts: In [EK89] a basic query answering procedure for abductive programs based on SLDN F resolution is defined. In addition to the usual yes/no answer of SLDN F , this procedure also returns an abductive explanation of the corresponding query. The idea was further developed in [KM91], [Dun91a], and <ref> [DDS92] </ref>. The procedure is shown to be correct w.r.t. the stable model semantics for call-consistent logic programs, but (as pointed out in [EK89]) not in general.
Reference: [DDS93] <author> M. Denecker and D. De Schreye. </author> <title> Representing incomplete knowledge in abductive logic programming, </title> <booktitle> 1993. In Proc. of the International Symposium on Logic Programming, </booktitle> <pages> pages 147-163, </pages> <year> 1993. </year>
Reference: [DG84] <author> W. Dowling and H. Gallier. </author> <title> Linear time algorithms for testing the satisfiability of propositional horn formulae. </title> <journal> Journal of Logic Programming, </journal> <volume> 1 </volume> <pages> 267-284, </pages> <year> 1984. </year>
Reference-contexts: By jj and jP j we will denote the number of rules and the number of propositional letters in respectively. Then the following holds: Theorem 10.1 (a) the decision problem for stratified is O (jj) (follows from <ref> [DG84] </ref>), (b) the decision problem for under completion semantics and under stable model semantics is coN P complete ([KP87] and [MT91] respectively), and (c) the decision problem for under 3-valued program completion semantics and under the well-founded semantics is O (jj) and O (jj) fl jP j respectively (folklore). 2 Let
Reference: [Dix91] <author> J. Dix. </author> <title> Classifying semantics of logic programs. </title> <booktitle> In Proceedings of International Workshop in logic programming and nonmonotonic reasoning, </booktitle> <address> Washington D.C., </address> <pages> pages 166-180, </pages> <year> 1991. </year>
Reference-contexts: This approach was first suggested in [Gab85] and further developed by Makinson, Lehman [Leh89] and others. For a good application of this approach in the context of logic programming see <ref> [Dix91, Dix92] </ref>. <p> See Section 10 for more discussion on complexity issues. 18 As mentioned in Example 2.11 entailment based on stable model semantics does not satisfy this property while the well-founded semantics does <ref> [Dix91] </ref>. This fact can be and often is viewed as an argument against stable model semantics. It can also be viewed as a beginning of a search for broad classes of programs for which cautious monotonicity holds. This is of course true for weakly stratified programs. <p> But the stationary semantics, the DWFS and the answer-set semantics infer a to be true. 2 More detailed comparison of the various semantics of normal disjunctive logic programs can be found in <ref> [Bar91, Dix91, Dix92] </ref>. [Bar91] gives a framework for the various semantics based on iterating a fixpoint operator (also known as an information accumulating operator) from a "nothing is known" initial state. <p> Dix <ref> [Dix91, Dix92] </ref> studies the various semantics based on their behavior as a nonmonotonic entailment relation. 42 5 Epistemic Logic Programs The framework of disjunctive logic programs is the most general form of logic programming that we have discussed so far.
Reference: [Dix92] <author> J. Dix. </author> <title> Classifying semantics of disjunctive logic programs. </title> <booktitle> In Proc. of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 798-812, </pages> <year> 1992. </year>
Reference-contexts: This approach was first suggested in [Gab85] and further developed by Makinson, Lehman [Leh89] and others. For a good application of this approach in the context of logic programming see <ref> [Dix91, Dix92] </ref>. <p> But the stationary semantics, the DWFS and the answer-set semantics infer a to be true. 2 More detailed comparison of the various semantics of normal disjunctive logic programs can be found in <ref> [Bar91, Dix91, Dix92] </ref>. [Bar91] gives a framework for the various semantics based on iterating a fixpoint operator (also known as an information accumulating operator) from a "nothing is known" initial state. <p> Dix <ref> [Dix91, Dix92] </ref> studies the various semantics based on their behavior as a nonmonotonic entailment relation. 42 5 Epistemic Logic Programs The framework of disjunctive logic programs is the most general form of logic programming that we have discussed so far.
Reference: [DMB92] <author> M. Denecker, L. Missiaen, and M. Bruynooghe. </author> <title> Temporal reasoning with abduc--tive event calculus. </title> <booktitle> In Proc. of ECAI92, </booktitle> <year> 1992. </year>
Reference-contexts: Some of the later solutions, in particular those from [Gel89], and [Mor88], were given in the language of autoepistemic logic and non-normal default theory respectively, and are similar to the one presented here. Representing inheritance reasoning and reasoning about actions in logic programming is an active area of research <ref> [GL92, BG93, Dun93b, PR93, Esh88, DMB92, KS86] </ref>. Some of the works on both subjects will be discussed in the upcoming sections. <p> These methods were applied to formalizations of various benchmarks in temporal, legal and other types of reasoning <ref> [Sha89, DMB92, Esh88] </ref>. There are several useful generalizations of the notion of abductive logic programs. In [Gel91], abduction is combined with reasoning with classical negation and epistemic disjunction, and generalized stable models are replaced by their answer set counterparts.
Reference: [Doy79] <author> J. Doyle. </author> <title> A truth-maintenance system. </title> <journal> Artificial Intelligence, </journal> <volume> 12 </volume> <pages> 231-272, </pages> <year> 1979. </year>
Reference-contexts: For an interesting discussion on defaults with quantifiers see [Lif90]. 9.3 Truth Maintenance Systems and Logic Programming Finally, we will briefly discuss the relationship between logic programs and nonmonotonic truth maintenance systems (TMSs) <ref> [Doy79] </ref>. Systems of this sort, originally described by procedural (and sometimes rather complicated) means, commonly serve as inference engines of AI reasoning systems. We will follow a comparatively simple description of TMSs from [Elk90].
Reference: [Dun91a] <author> P. Dung. </author> <title> Negation as hypotheses: an abductive foundation for logic programming. </title> <booktitle> In Proc. of ICLP-91, </booktitle> <pages> pages 3-17, </pages> <year> 1991. </year>
Reference-contexts: In [EK89] a basic query answering procedure for abductive programs based on SLDN F resolution is defined. In addition to the usual yes/no answer of SLDN F , this procedure also returns an abductive explanation of the corresponding query. The idea was further developed in [KM91], <ref> [Dun91a] </ref>, and [DDS92]. The procedure is shown to be correct w.r.t. the stable model semantics for call-consistent logic programs, but (as pointed out in [EK89]) not in general.
Reference: [Dun91b] <author> P. Dung. </author> <title> Well-founded reasoning with classical negation. </title> <booktitle> In Proc. of 1st international workshop on logic programming and non-monotonic reasoning, </booktitle> <year> 1991. </year>
Reference-contexts: The -well-founded semantics is given by ffc; :bg; fc; a; :bgg. 2 Before we end this section we would like to briefly mention another class of semantics of extended logic programs based on contradiction removal <ref> [Dun91b, Wag93, PAA91a, GM90] </ref>. To illustrate the problem let us consider the program 4 : 1. p not q 3. s Obviously, under the answer set semantics this program is inconsistent.
Reference: [Dun92] <author> P. Dung. </author> <title> On the relations between stable and well-founded semantics of logic programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 105 </volume> <pages> 7-25, </pages> <year> 1992. </year>
Reference-contexts: Proposition 2.2 [ABW88, GL88] Any stratified general logic program is categorical. 2 It is easy to see that the program from Example 2.1 is stratified and therefore has only one stable model. Existence of stable models was further studied in <ref> [Fag90, Cav89, Dun92, Prz88a] </ref>. The following result, due to Fages [Fag90], is representative of this direction of research. A general logic program is said to be call-consistent [Kun89, Sat87] if its dependency graph does not have a cycle with an odd number of negative edges.
Reference: [Dun93a] <author> P. Dung. </author> <title> On the acceptability of arguments and its fundamental role in nonmono-tonic reasoning and logic programming. </title> <booktitle> In Proc. of IJCAI 93, </booktitle> <pages> pages 852-857, </pages> <year> 1993. </year>
Reference-contexts: Fitting [FBJ88, Fit85, Fit86], Kunen [Kun87, Kun89] and others [LM85, Myc83] used Kleene's strong three-valued logic while Van Gelder, Ross and Schlifp [VGRS91] used a different three valued logic to give the well-founded semantics of a logic program. Przymusinski [Prz89a, Prz89d], Dung <ref> [Dun93a] </ref>, Van Gelder [VG89], and many others gave alternative formalizations of the well-founded semantics. The semantics of Fitting and Jacob differ from the well-founded semantics.
Reference: [Dun93b] <author> P. Dung. </author> <title> Representing actions in logic programming and its application in database updates. </title> <booktitle> In Proceedings of the International Conference in Logic Programming, </booktitle> <pages> pages 222-238, </pages> <year> 1993. </year>
Reference-contexts: Some of the later solutions, in particular those from [Gel89], and [Mor88], were given in the language of autoepistemic logic and non-normal default theory respectively, and are similar to the one presented here. Representing inheritance reasoning and reasoning about actions in logic programming is an active area of research <ref> [GL92, BG93, Dun93b, PR93, Esh88, DMB92, KS86] </ref>. Some of the works on both subjects will be discussed in the upcoming sections.
Reference: [EG92] <author> T. Eiter and G. Gottlob. </author> <title> On the Complexity of Propositional Knowledge Base Revision, Updates, and Counterfactuals. </title> <journal> Artificial Intelligence, </journal> <volume> 57(2-3):227-270, </volume> <year> 1992. </year>
Reference-contexts: Note that similar complexity results have recently been derived for various forms of nonmonotonic reasoning such as default and autoepistemic logic [Got92], nonmonotonic S4 [ST93], theory revision <ref> [EG92] </ref>, and abduction [EG93e]. For programs with variables, consider the case of first order disjunctive logic programs without function symbols. Then following holds.
Reference: [EG93a] <author> T. Eiter and G. Gottlob. </author> <title> Complexity Aspects of Various Semantics for Disjunctive Databases. </title> <booktitle> In Proceedings of the Twelth ACM SIGACT SIGMOD-SIGART Symposium on Principles of Database Systems (PODS-93), </booktitle> <pages> pages 158-167, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: equivalent possible worlds semantics [Cha93] is polynomial (co-N P -complete again if heads can be empty), (c) the decision problem for under the careful CWA [GP86] is P 2 -hard and in P 3 [O (log n)], (d) the decision problem for is P 2 -complete for the following semantics <ref> [EG93a, EG93c, EG93d] </ref>: the generalized CWA [Min82], the extended generalized CWA [YH85], the extended CWA [GPP89], the iterated CWA [GPP89], the perfect model semantics [Prz88b], and the partial as well as total disjunctive stable model semantics [Prz91]. 2 Here P 2 and P 3 [O (log n)] are classes above coN
Reference: [EG93b] <author> T. Eiter and G. Gottlob. </author> <title> Complexity Results for Disjunctive Logic Programming and Application to Nonmonotonic Logics. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings of the International Logic Programming Symposium (ILPS), </booktitle> <address> Vancouver, 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Results for important restricted cases have been derived in [CL90]. For the extension of logic programming by classical negation [GL91], the following holds. Theorem 10.8 The decision problem for a disjunctive logic program (containing : and not) under the answer set semantics is P 2 -complete <ref> [EG93b] </ref>. 2 70 For a special but broad class of disjunctive logic programs ( in particular the headcycle--free programs) the decision problem under the answer set semantics is coN P -complete [BED92].
Reference: [EG93c] <author> T. Eiter and G. Gottlob. </author> <title> On the Computational Cost of Disjunctive Logic Programming: Propositional Case. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <note> 1993. to appear. </note>
Reference-contexts: equivalent possible worlds semantics [Cha93] is polynomial (co-N P -complete again if heads can be empty), (c) the decision problem for under the careful CWA [GP86] is P 2 -hard and in P 3 [O (log n)], (d) the decision problem for is P 2 -complete for the following semantics <ref> [EG93a, EG93c, EG93d] </ref>: the generalized CWA [Min82], the extended generalized CWA [YH85], the extended CWA [GPP89], the iterated CWA [GPP89], the perfect model semantics [Prz88b], and the partial as well as total disjunctive stable model semantics [Prz91]. 2 Here P 2 and P 3 [O (log n)] are classes above coN
Reference: [EG93d] <author> T. Eiter and G. Gottlob. </author> <title> Propositional Circumscription and Extended Closed World Reasoning are P 2 -complete. </title> <booktitle> Theoretical Computer Science, 114(2):231 245, 1993. Addendum 118:315. </booktitle>
Reference-contexts: equivalent possible worlds semantics [Cha93] is polynomial (co-N P -complete again if heads can be empty), (c) the decision problem for under the careful CWA [GP86] is P 2 -hard and in P 3 [O (log n)], (d) the decision problem for is P 2 -complete for the following semantics <ref> [EG93a, EG93c, EG93d] </ref>: the generalized CWA [Min82], the extended generalized CWA [YH85], the extended CWA [GPP89], the iterated CWA [GPP89], the perfect model semantics [Prz88b], and the partial as well as total disjunctive stable model semantics [Prz91]. 2 Here P 2 and P 3 [O (log n)] are classes above coN
Reference: [EG93e] <author> T. Eiter and G. Gottlob. </author> <title> The Complexity of Logic-Based Abduction. </title> <journal> Journal of the ACM, </journal> <note> 1993. To appear. Extended abstract in Proceedings STACS 1993, </note> <editor> P. Enjalbert and A. Finkel and K. Wagner eds., </editor> <publisher> Springer LNCS 665, </publisher> <pages> pages 70-79, </pages> <year> 1993. </year>
Reference-contexts: Note that similar complexity results have recently been derived for various forms of nonmonotonic reasoning such as default and autoepistemic logic [Got92], nonmonotonic S4 [ST93], theory revision [EG92], and abduction <ref> [EG93e] </ref>. For programs with variables, consider the case of first order disjunctive logic programs without function symbols. Then following holds.
Reference: [EGM93] <author> T. Eiter, G. Gottlob, and H. Mannila. </author> <title> Expressive Power and Complexity of Disjunctive Datalog. </title> <editor> In H. Blair, W. Marek, A. Nerode, and J. Remmel, editors, </editor> <booktitle> Proceedings of the Second Workshop on Structural Complexity and Recursion-Theoretic Methods in Logic Programming, </booktitle> <address> Vancouver, </address> <month> October 29 </month> <year> 1993. </year> <institution> Cornell University, Mathematical Sciences Institute. </institution> <note> Also available as CD-TR 93/51, </note> <institution> Christian Doppler Lab for Expert Systems, TU Vienna. </institution>
Reference-contexts: For programs with variables, consider the case of first order disjunctive logic programs without function symbols. Then following holds. Theorem 10.9 <ref> [EGM93] </ref> (a) The data complexity of first order disjunctive logic programs without function symbols under stable model semantics is P 2 -complete, and (b) The class of first order disjunctive logic programs without function symbols under stable semantics expresses P 2 . 2 Notice that first order disjunction-free logic programs without
Reference: [EK88] <author> K. Eshghi and R. Kowalski. </author> <title> Abduction through deduction, </title> <note> 1988. unpublished paper. </note>
Reference-contexts: Various (non-equivalent) definitions can be found in the literature. (For comparison of several of them see [Ino92a].) Here we shell concentrate on the proposal by Kakas and Mancarella (based on the unpublished paper by Esghi and Kowalski <ref> [EK88] </ref>). In [KM90] they develop a semantics of abductive logic programs closely related to stable model semantics of general logic program. Let &lt; ; A; I &gt; be an abductive logic program. <p> In the first option, the resulting abductive program &lt; 1 ; A; I [ X &gt; not only explains the observation f lies (a) by concluding bird (a) and :penguin (a) (which can also be achieved by the standard approach of abductive logic programs <ref> [EK88, KM90] </ref>) but also entails the conclusion hasbeak (a), which is apparently not done by the standard approach.
Reference: [EK89] <author> K. Eshghi and R. Kowalski. </author> <title> Abduction compared with negation as failure. </title> <editor> In Giorgio Levi and Maurizio Martelli, editors, </editor> <booktitle> Logic Programming: Proc. of the Sixth Int'l Conf., </booktitle> <pages> pages 234-255, </pages> <year> 1989. </year>
Reference-contexts: From this and Lemma 2.4 it is easy to see that Y entails holds (alive; res (load; s 0 )), and :holds (alive; res (shoot; res (wait; (res (load; s 0 ))))). 2 As we can see, the logic programming solution <ref> [Eva89, AB91, EK89] </ref> to the original Yale Shooting Problem is rather natural and simple. (This is not, of course, to say that it can be easily generalized to more complicated forms of reasoning about actions.) It is worth recalling that the original formulations of this story in the formalisms of circumscription <p> SLDNF resolution, though sound [Cla78], is only complete for a subclass of stratified programs [JLL83]. Various practical Prolog systems have been developed based on SLDNF resolution. To answer queries with respect to programs with a multiple number of stable models, several approaches have been suggested <ref> [PAA91a, BNNS94, FLMS93, SZ90, IKH92, WC93, EK89] </ref> in the literature. <p> Theorist of [PGA87], [Poo88] provides an implementation of abduction for first-order based abductive frameworks which uses resolution-based proof procedure. There are also several procedures for answering queries for abductive logic programs and computing abductive explanations. In <ref> [EK89] </ref> a basic query answering procedure for abductive programs based on SLDN F resolution is defined. In addition to the usual yes/no answer of SLDN F , this procedure also returns an abductive explanation of the corresponding query. The idea was further developed in [KM91], [Dun91a], and [DDS92]. <p> The idea was further developed in [KM91], [Dun91a], and [DDS92]. The procedure is shown to be correct w.r.t. the stable model semantics for call-consistent logic programs, but (as pointed out in <ref> [EK89] </ref>) not in general. This fact led to modification of the procedure to achieve correctness w.r.t. the stable model semantics [SI92], as well as to work on modification of the semantics to fit the inference method of the procedure [KM91],[Dun91a]. <p> In [Ino91], [Ino92a] this work is further extended by replacing abducible literals by abducible logic programs. 8.2 Abduction and Negation as Failure There are some close similarities between abductive reasoning and negation as failure. The first attempt to make this relationship precise is due to Esghi and Kowalski. In <ref> [EK89] </ref>, they give a transformation from a general logic program to an abductive framework &lt; fl ; A fl ; I fl &gt; (where fl is a Horn logic program, A fl is a set of abducible predicates, and I fl is a first order theory) and show that the stable <p> of the form: 8X:[p (X) ^ p (X)] and We say that fl [ satisfies integrity constraints from I if for every ground atom a from the language of (a) fl [ 6j= a ^ a and (b) fl [ j= a or fl [ j= a 2 Proposition 8.1 <ref> [EK89] </ref> 1. If M is a stable model of then fl [ fa : a is a ground atom, a 62 M g satisfies I fl . 2.
Reference: [EKP91] <author> D. Etherington, S. Kraus, and D. Perlis. </author> <title> Nonmonotonicity and the scope of reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 52(3) </volume> <pages> 221-261, </pages> <year> 1991. </year>
Reference-contexts: This allows us to conclude, say, that a is not a professor without concluding that there are no professors except m and n. 2 Open domain semantics is also useful for representing certain types of null values in databases [GT93]. An application to formalization of anonymous exceptions to defaults <ref> [EKP91] </ref> can be found in [GP93a]. [Sch93] contains some results of query answering in open domain semantics. Related work in the context of autoepistemic logic and default logic can be found in [Lif89, Lif90].
Reference: [Elk90] <author> C. Elkan. </author> <title> A rational reconstruction of non-monotonic truth maintenance systems. </title> <journal> Artificial Intelligence, </journal> <volume> 43, </volume> <year> 1990. </year>
Reference-contexts: Systems of this sort, originally described by procedural (and sometimes rather complicated) means, commonly serve as inference engines of AI reasoning systems. We will follow a comparatively simple description of TMSs from <ref> [Elk90] </ref>. We will need the following terminology: a justification is a set of directed propositional clauses of the form ff ^ fi c where c is an atom, ff is a conjunction of atoms and fi is a conjunction of negated atoms. <p> The form of justifications suggests the obvious analogy with rules of logic programs where negated literals :A from fi are replaced by not A. Let us denote the corresponding logic program by fl . The following theorem establishes the relationship between TMSs and logic programs: Proposition 9.3 <ref> [Elk90] </ref> M is a grounded model of a collection of justifications iff it is a stable model of a program fl . Similar results were obtained in [WB93], [GM90], [PC89], [RM89], and [FH89]. (The last two papers use autoepistemic logic instead of logic programs).
Reference: [Esg90] <author> K. Esghi. </author> <title> Computing Stable Models by Using the ATMS. </title> <booktitle> In Proc. AAAI-90, </booktitle> <pages> pages 272-277, </pages> <year> 1990. </year>
Reference-contexts: For a precise definition see [Llo87]. 12 and top-down methods. Bell et al. [BNNS94] present an approach to compute the stable models by constructing a linear programming problem from the program and solving the linear programming problem. In <ref> [Esg90] </ref>, [PC89] truth maintenance systems are used to compute the stable models of a general program. Fernandez and Lobo [FL92] propose an almost top-down proof procedure to find answers to queries with respect to the stable model semantics. <p> Similar results were obtained in [WB93], [GM90], [PC89], [RM89], and [FH89]. (The last two papers use autoepistemic logic instead of logic programs). They led to a better understanding of the semantics of nonmonotonic truth maintenance systems, to their use for computing stable models <ref> [Esg90] </ref> and autoepistemic extensions [JK91], for doing abductive reasoning [IS91], [RP91], and to the development of variants of TMSs based on other semantics of logic programs.
Reference: [Esh88] <author> K. Eshghi. </author> <title> Abductive planning with event calculus. </title> <booktitle> In Proc. of the Fith ICLP., </booktitle> <pages> pages 562-579, </pages> <year> 1988. </year>
Reference-contexts: Some of the later solutions, in particular those from [Gel89], and [Mor88], were given in the language of autoepistemic logic and non-normal default theory respectively, and are similar to the one presented here. Representing inheritance reasoning and reasoning about actions in logic programming is an active area of research <ref> [GL92, BG93, Dun93b, PR93, Esh88, DMB92, KS86] </ref>. Some of the works on both subjects will be discussed in the upcoming sections. <p> These methods were applied to formalizations of various benchmarks in temporal, legal and other types of reasoning <ref> [Sha89, DMB92, Esh88] </ref>. There are several useful generalizations of the notion of abductive logic programs. In [Gel91], abduction is combined with reasoning with classical negation and epistemic disjunction, and generalized stable models are replaced by their answer set counterparts.
Reference: [Eva89] <author> C. Evans. </author> <title> Negation-as-failure as an approach to the Hanks and McDermott problem. </title> <booktitle> In Proc. of the Second Int'l Symp. on Artificial Intelligence, </booktitle> <year> 1989. </year>
Reference-contexts: From this and Lemma 2.4 it is easy to see that Y entails holds (alive; res (load; s 0 )), and :holds (alive; res (shoot; res (wait; (res (load; s 0 ))))). 2 As we can see, the logic programming solution <ref> [Eva89, AB91, EK89] </ref> to the original Yale Shooting Problem is rather natural and simple. (This is not, of course, to say that it can be easily generalized to more complicated forms of reasoning about actions.) It is worth recalling that the original formulations of this story in the formalisms of circumscription
Reference: [Fag90] <author> F. Fages. </author> <title> Consistency of Clark's completion and existence of stable models. </title> <type> Technical Report 90-15, </type> <institution> Ecole Normale Superieure, </institution> <year> 1990. </year>
Reference-contexts: Proposition 2.2 [ABW88, GL88] Any stratified general logic program is categorical. 2 It is easy to see that the program from Example 2.1 is stratified and therefore has only one stable model. Existence of stable models was further studied in <ref> [Fag90, Cav89, Dun92, Prz88a] </ref>. The following result, due to Fages [Fag90], is representative of this direction of research. A general logic program is said to be call-consistent [Kun89, Sat87] if its dependency graph does not have a cycle with an odd number of negative edges. <p> Existence of stable models was further studied in [Fag90, Cav89, Dun92, Prz88a]. The following result, due to Fages <ref> [Fag90] </ref>, is representative of this direction of research. A general logic program is said to be call-consistent [Kun89, Sat87] if its dependency graph does not have a cycle with an odd number of negative edges. Theorem 2.3 [Fag90] A call-consistent logic program whose dependency graph does not have a cycle with <p> The following result, due to Fages <ref> [Fag90] </ref>, is representative of this direction of research. A general logic program is said to be call-consistent [Kun89, Sat87] if its dependency graph does not have a cycle with an odd number of negative edges. Theorem 2.3 [Fag90] A call-consistent logic program whose dependency graph does not have a cycle with only positive edges has at least one stable model. 2 In our further discussion we will need the following Lemma about general logic programs.
Reference: [FBJ88] <author> M. Fitting and M. Ben-Jacob. </author> <title> Stratified and Three-Valued Logic programming Semantics. </title> <editor> In R.A. Kowalski and K.A. Bowen, editors, </editor> <booktitle> Proc. 5 th International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1054-1069, </pages> <address> Seattle, Washington, </address> <month> August 15-19, </month> <year> 1988. </year>
Reference-contexts: Przymusinski [Prz88b] generalized the concept of stratification and introduced local stratification and perfect models. The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. The second approach <ref> [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] </ref> was to use three-valued logic instead of the classical 2-valued logic. <p> The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. The second approach [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] was to use three-valued logic instead of the classical 2-valued logic. Fitting <ref> [FBJ88, Fit85, Fit86] </ref>, Kunen [Kun87, Kun89] and others [LM85, Myc83] used Kleene's strong three-valued logic while Van Gelder, Ross and Schlifp [VGRS91] used a different three valued logic to give the well-founded semantics of a logic program.
Reference: [FH89] <author> Y. Fujiwara and S. Honiden. </author> <title> Relating the tms to autoepistemic logic. </title> <booktitle> In Proc. IJCAI-89, </booktitle> <pages> pages 1199-1205, </pages> <year> 1989. </year>
Reference-contexts: The following theorem establishes the relationship between TMSs and logic programs: Proposition 9.3 [Elk90] M is a grounded model of a collection of justifications iff it is a stable model of a program fl . Similar results were obtained in [WB93], [GM90], [PC89], [RM89], and <ref> [FH89] </ref>. (The last two papers use autoepistemic logic instead of logic programs).
Reference: [FH91] <author> H. Fujita and R. Hasegawa. </author> <title> A model generation theorem prover in KL1 using a ramified stack algorithm. </title> <booktitle> In Eight International Conference in Logic Programming, </booktitle> <pages> pages 535-548, </pages> <year> 1991. </year>
Reference-contexts: Hence, stable ( 1 ) consists of two stable models which are obtained from the second and the third one and which are fpg and fqg. 2 There are several approaches to compute the minimal models of a positive disjunctive program <ref> [FH91, FM91] </ref>. Fernandez et al. [FLMS93] use model trees to compute minimal models. Inoue et al. [IKH92] use an extension of the model generation theorem prover (MGTP) [FH91] to directly compute the minimal models of the formulas obtained using tr 1 . <p> Fernandez et al. [FLMS93] use model trees to compute minimal models. Inoue et al. [IKH92] use an extension of the model generation theorem prover (MGTP) <ref> [FH91] </ref> to directly compute the minimal models of the formulas obtained using tr 1 . <p> superscript and the atoms with predicate x. i.e. the answer sets of are fperson (a); :lh usable (a); ab 1 (a); rh usable (a)g and fperson (a); :rh usable (a); ab 2 (a); lh usable (a)g. 2 Answer sets of disjunctive logic programs can be obtained using model generation techniques <ref> [BS85, FM91, FH91, FM92, MB88] </ref>. Inoue et al. [IKH92] extend the model generation theorem prover (MGTP) [FH91] to compute the answer sets of the program obtained using tr 2 . <p> Inoue et al. [IKH92] extend the model generation theorem prover (MGTP) <ref> [FH91] </ref> to compute the answer sets of the program obtained using tr 2 .
Reference: [Fit85] <author> M. </author> <title> Fitting. A Kripke-Kleene semantics for logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(4) </volume> <pages> 295-312, </pages> <year> 1985. </year>
Reference-contexts: Przymusinski [Prz88b] generalized the concept of stratification and introduced local stratification and perfect models. The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. The second approach <ref> [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] </ref> was to use three-valued logic instead of the classical 2-valued logic. <p> The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. The second approach [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] was to use three-valued logic instead of the classical 2-valued logic. Fitting <ref> [FBJ88, Fit85, Fit86] </ref>, Kunen [Kun87, Kun89] and others [LM85, Myc83] used Kleene's strong three-valued logic while Van Gelder, Ross and Schlifp [VGRS91] used a different three valued logic to give the well-founded semantics of a logic program. <p> Moreover, they show that the problem of determining if a literal l is a stable model consequence of a program is 1 1 complete, i.e. is represen tative of the hardest decision problem in 1 1 . As shown in [VG89], [KP87], and <ref> [Fit85] </ref>, the same result holds for the well-founded semantics as well as for two-valued and three-valued completion based semantics of logic programs.
Reference: [Fit86] <author> M. </author> <title> Fitting. Partial models and logic programming. </title> <journal> Theoretical Computer Science, </journal> <volume> 48 </volume> <pages> 229-255, </pages> <year> 1986. </year> <month> 78 </month>
Reference-contexts: Przymusinski [Prz88b] generalized the concept of stratification and introduced local stratification and perfect models. The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. The second approach <ref> [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] </ref> was to use three-valued logic instead of the classical 2-valued logic. <p> The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. The second approach [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] was to use three-valued logic instead of the classical 2-valued logic. Fitting <ref> [FBJ88, Fit85, Fit86] </ref>, Kunen [Kun87, Kun89] and others [LM85, Myc83] used Kleene's strong three-valued logic while Van Gelder, Ross and Schlifp [VGRS91] used a different three valued logic to give the well-founded semantics of a logic program.
Reference: [Fit91] <author> M. </author> <title> Fitting. Well-founded semantics, generalized. </title> <booktitle> In Proceedings of International Symposium on Logic Programming, </booktitle> <address> San Diego, </address> <pages> pages 71-84, </pages> <year> 1991. </year>
Reference-contexts: S 1 , and p is true in all interpretations contained in S 1 . 2 Lemma 2.7 <ref> [BS91, Fit91] </ref> Let lf p stand for least fixpoint and gf p stand for greatest fix-point.
Reference: [FL92] <author> J. Fernandez and J. Lobo. </author> <title> A proof procedure for stable theories. </title> <type> Technical report, </type> <institution> University of Maryland, CS-TR-3034, </institution> <year> 1992. </year>
Reference-contexts: Bell et al. [BNNS94] present an approach to compute the stable models by constructing a linear programming problem from the program and solving the linear programming problem. In [Esg90], [PC89] truth maintenance systems are used to compute the stable models of a general program. Fernandez and Lobo <ref> [FL92] </ref> propose an almost top-down proof procedure to find answers to queries with respect to the stable model semantics.
Reference: [FLMS93] <author> J. Fernandez, J. Lobo, J. Minker, and V. S. Subrahmanian. </author> <title> Disjunctive LP + Integrity Constraints = Stable Model Semantics. </title> <journal> Annals of Mathematics and AI, </journal> <pages> 8(3-4), </pages> <year> 1993. </year>
Reference-contexts: SLDNF resolution, though sound [Cla78], is only complete for a subclass of stratified programs [JLL83]. Various practical Prolog systems have been developed based on SLDNF resolution. To answer queries with respect to programs with a multiple number of stable models, several approaches have been suggested <ref> [PAA91a, BNNS94, FLMS93, SZ90, IKH92, WC93, EK89] </ref> in the literature. <p> Fernandez et al. <ref> [FLMS93] </ref> and Inoue et al. [IKH92] propose bottom-up methods to compute all the stable models of a general program. While Fernandez et al. [FLMS93] transform a general logic program to a disjunctive logic program with constraints, Inoue et al. [IKH92] transform a general program to a propositional theory. <p> Fernandez et al. <ref> [FLMS93] </ref> and Inoue et al. [IKH92] propose bottom-up methods to compute all the stable models of a general program. While Fernandez et al. [FLMS93] transform a general logic program to a disjunctive logic program with constraints, Inoue et al. [IKH92] transform a general program to a propositional theory. <p> Hence, stable ( 1 ) consists of two stable models which are obtained from the second and the third one and which are fpg and fqg. 2 There are several approaches to compute the minimal models of a positive disjunctive program [FH91, FM91]. Fernandez et al. <ref> [FLMS93] </ref> use model trees to compute minimal models. Inoue et al. [IKH92] use an extension of the model generation theorem prover (MGTP) [FH91] to directly compute the minimal models of the formulas obtained using tr 1 .
Reference: [FM91] <author> J. Fernandez and J. Minker. </author> <title> Bottom-up evaluation of hierarchical disjunctive deductive databases. </title> <booktitle> In Eight International Conference in Logic Programming, </booktitle> <pages> pages 660-675, </pages> <year> 1991. </year>
Reference-contexts: Hence, stable ( 1 ) consists of two stable models which are obtained from the second and the third one and which are fpg and fqg. 2 There are several approaches to compute the minimal models of a positive disjunctive program <ref> [FH91, FM91] </ref>. Fernandez et al. [FLMS93] use model trees to compute minimal models. Inoue et al. [IKH92] use an extension of the model generation theorem prover (MGTP) [FH91] to directly compute the minimal models of the formulas obtained using tr 1 . <p> D apparently satisfies the specification and may be used with any collection of facts formed by predicate symbols p and a. 2 4.2 Answering Queries There has been considerable research in developing query answering methods for positive disjunctive programs <ref> [MZ82, MR90, FM91, LMR92, HP88] </ref>. It should be noted that for positive programs minimal models coincides with answer sets. <p> superscript and the atoms with predicate x. i.e. the answer sets of are fperson (a); :lh usable (a); ab 1 (a); rh usable (a)g and fperson (a); :rh usable (a); ab 2 (a); lh usable (a)g. 2 Answer sets of disjunctive logic programs can be obtained using model generation techniques <ref> [BS85, FM91, FH91, FM92, MB88] </ref>. Inoue et al. [IKH92] extend the model generation theorem prover (MGTP) [FH91] to compute the answer sets of the program obtained using tr 2 .
Reference: [FM92] <author> J. Fernandez and J. Minker. </author> <title> Disjunctive deductive databases. </title> <booktitle> In International Conference on Logic Programming and Automated Reasoning: Lecture Notes in Artificial Intelligence 624, </booktitle> <pages> pages 332-356, </pages> <address> St. Petersburg, Russia, </address> <year> 1992. </year> <title> Springer-Verlag. </title> <type> Invited Paper. </type>
Reference-contexts: superscript and the atoms with predicate x. i.e. the answer sets of are fperson (a); :lh usable (a); ab 1 (a); rh usable (a)g and fperson (a); :rh usable (a); ab 2 (a); lh usable (a)g. 2 Answer sets of disjunctive logic programs can be obtained using model generation techniques <ref> [BS85, FM91, FH91, FM92, MB88] </ref>. Inoue et al. [IKH92] extend the model generation theorem prover (MGTP) [FH91] to compute the answer sets of the program obtained using tr 2 .
Reference: [Gab85] <author> D. Gabbay. </author> <title> Theoretical foundations for non-monotonic reasoning in expert systems. </title> <editor> In Krzysztof R. Apt, editor, </editor> <booktitle> Proc. of the NATO Advanced Study Institute on Logics and Models of Concurrent Systems, </booktitle> <pages> pages 439-457, </pages> <address> La Colle-sur-Loup, France, </address> <month> October </month> <year> 1985. </year> <note> Springer-Verlag. </note>
Reference-contexts: There are several attempts to classify the various semantics of general logic programs. One attempt uses the notion of complexity of query answering. 9 Another attempt is based on establishing basic principles of nonmonotonic entailment. This approach was first suggested in <ref> [Gab85] </ref> and further developed by Makinson, Lehman [Leh89] and others. For a good application of this approach in the context of logic programming see [Dix91, Dix92].
Reference: [Gel87] <author> M. Gelfond. </author> <title> On stratified autoepistemic theories. </title> <booktitle> In Proc. AAAI-87, </booktitle> <pages> pages 207-211, </pages> <year> 1987. </year>
Reference-contexts: Almost immediately after this notion was introduced, stratified logic programs were mapped into the three major nonmonotonic formalisms investigated at that time: circumscription [Lif88],[Prz88a], autoepistemic logic <ref> [Gel87] </ref> and default theories [BF91], [MT89]. Research in this area was stimulated by the workshop on Foundations of Deductive Databases and Logic Programming [Min88] and by the workshops on Logic Programming and Nonmonotonic Reasoning [NMS91, PN93]. <p> If T does not contain the modal operator B, T has a unique stable expansion [MT91]. We will denote this expansion by T h (T ). Let ff be a mapping <ref> [Gel87] </ref> which takes a general logic program , and translates its rules (of the form (7)) into autoepistemic formulas of the form A 1 ^ : : : ^ A m ^ :B A m+1 ^ : : : ^ :B A n A 0 , where B is the belief <p> In <ref> [Gel87] </ref>, it was shown that the declarative semantics of stratified logic programs can be characterized in terms of the autoepistemic theory obtained by this transformation, and that therefore, negation as failure can be understood as an epistemic operator.
Reference: [Gel89] <author> M. Gelfond. </author> <title> Autoepistemic logic and formalization of commonsense reasoning. </title> <editor> In M Reinfrank, Johan de Kleer, M Ginsberg, and Erik Sandewall, editors, </editor> <booktitle> Non-Monotonic Reasoning: 2nd International Workshop (Lecture Notes in Artificial Intelligence 346), </booktitle> <pages> pages 176-186. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Some of the later solutions, in particular those from <ref> [Gel89] </ref>, and [Mor88], were given in the language of autoepistemic logic and non-normal default theory respectively, and are similar to the one presented here. Representing inheritance reasoning and reasoning about actions in logic programming is an active area of research [GL92, BG93, Dun93b, PR93, Esh88, DMB92, KS86].
Reference: [Gel91] <author> M. Gelfond. </author> <title> Epistemic approach to formalization of commonsense reasoning. </title> <type> Technical Report TR-91-2, </type> <institution> University of Texas at El Paso, </institution> <year> 1991. </year>
Reference-contexts: These methods were applied to formalizations of various benchmarks in temporal, legal and other types of reasoning [Sha89, DMB92, Esh88]. There are several useful generalizations of the notion of abductive logic programs. In <ref> [Gel91] </ref>, abduction is combined with reasoning with classical negation and epistemic disjunction, and generalized stable models are replaced by their answer set counterparts.
Reference: [Gel92a] <author> A. Van Gelder. </author> <title> The well-founded semantics of aggregation. </title> <booktitle> In Proceedings of Principles of Database Systems, </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: Extensions of the languages by allowing more complex data such as sets and aggregates are very important in database applications <ref> [KS91, BRSS92, Gel92a] </ref>. Even more questions remain for noncategorical programs, i.e. logic programs with multiple answer sets or disjunctive logic programs. In this case one of the most important problems seems to be the lack of clear procedural interpretation of rules of a program.
Reference: [Gel92b] <author> M. Gelfond. </author> <title> Logic programming and reasoning with incomplete information. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <note> 1992. To appear. </note>
Reference-contexts: Work in this direction was started by Minker [Min82], Loveland [Lov87] and others, who investigated the possibility of expanding logic programs by disjunctive information. In <ref> [GL90, PW89, Gel92b] </ref>, extensions of logic programming by classical (or strong) negation and epistemic operators were suggested. Unlike "traditional" nonmonotonic formalisms, these extensions are not based on the use of classical logical connectives, and do not include full first-order logic (not even its propositional part). <p> This result was extended to arbitrary T in [GP86, She88]. The following proposition establishes the connection between Minker's semantics and answer set semantics of disjunctive logic programs. Proposition 4.4 <ref> [Gel92b] </ref> Let be a program consisting of rules of the form A 0 or : : : or A k A k+1 : : : A m (where A's are atoms), and the closed world assumptions of the form :p (X) not p (X), for all predicates in . <p> answer set that does not contain guilty (a). (C 2 ) We would infer cleared (a) iff none of the answer sets contain guilty (a). 2 To capture the intuition in (B 2 ) and (C 2 ) in the above example, we use two unary operators K and M <ref> [Gel92b] </ref> and add them to our language. Intuitively, KL stands for L is known and M L stands for L may be believed. <p> is preferable to the other two world views of T 2 as it treats p (a) and p (b) in the same manner (unlike A 1 and A 2 ) and can be used to answer queries with respect to T 2 For a detailed discussion on this phenomena see <ref> [Gel92b] </ref>. 2 It remains to be seen if epistemic specifications with multiple world views will prove to be useful for knowledge representation. 46 6 Meta-logic Programming In this section we briefly discuss another important tool for representing knowledge, in particular, knowledge in the domains containing logic programs as objects of discourse.
Reference: [Gin87] <editor> M. Ginsberg, editor. </editor> <booktitle> Readings in Nonmonotonic Reasoning. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> CA, USA, </address> <year> 1987. </year>
Reference-contexts: This observation has led to the development and investigation of new logical formalisms, nonmonotonic logics. The best known of them are circumscription [McC80, McC86, Lif85b], default logic [Rei80b], and nonmonotonic modal logics [MD80, McD82, Moo85]. A collection of important papers on nonmonotonic reasoning published before 1987 appears in <ref> [Gin87] </ref>. A survey can be found in [Rei87a]. Much technical work has been done to investigate the mathematical properties of these logics, as well as their applicability to the formalization of commonsense reasoning in various specific domains.
Reference: [GL88] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <editor> In R. Kowalski and K. Bowen, editors, </editor> <booktitle> Logic Programming: Proc. of the Fifth Int'l Conf. and Symp., </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year> <month> 79 </month>
Reference-contexts: Semantics of logic programs differ in the way they define satisfiability of the rules. In this paper we will mainly use the stable model semantics <ref> [GL88] </ref> and its extensions but most of our discussion will be semantics independent. Under this semantics the corresponding theories are sets of ground atoms, called the stable models of a program. <p> The following theorem describes an important property of stratified programs. Proposition 2.2 <ref> [ABW88, GL88] </ref> Any stratified general logic program is categorical. 2 It is easy to see that the program from Example 2.1 is stratified and therefore has only one stable model. Existence of stable models was further studied in [Fag90, Cav89, Dun92, Prz88a]. <p> The third approach is analogous to the traditional approach in Reiter's default logic [Rei80b] and Moore's autoepistemic logic [Moo85] in which the definition of entailment is based on the notion of beliefs. The stable model semantics <ref> [GL88] </ref> used in this paper is based on this approach. In [BS92], Baral and Subrahamanian introduce the concept of stable classes as a generalization of the stable models.
Reference: [GL90] <author> M. Gelfond and V. Lifschitz. </author> <title> Logic programs with classical negation. </title> <editor> In D. War--ren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 579-597, </pages> <year> 1990. </year>
Reference-contexts: Work in this direction was started by Minker [Min82], Loveland [Lov87] and others, who investigated the possibility of expanding logic programs by disjunctive information. In <ref> [GL90, PW89, Gel92b] </ref>, extensions of logic programming by classical (or strong) negation and epistemic operators were suggested. Unlike "traditional" nonmonotonic formalisms, these extensions are not based on the use of classical logical connectives, and do not include full first-order logic (not even its propositional part). <p> Proposition 3.2 <ref> [GL90] </ref> A consistent set S Lit is an answer set of if and only if S + is a stable model of + . 2 Proposition 3.2 suggests the following simple way of evaluating queries in extended logic programs. <p> If + 's answer to p is yes then 's answer to p is yes. If + 's answer to p 0 is yes then 's answer to p is no. The next proposition is an immediate consequence of Propositions 3.2 and 2.1. Proposition 3.3 <ref> [GL90] </ref> An extended logic program is categorical if (a) + is stratified, and (b) The answer set of + does not contain atoms of the form p (t), p 0 (t). 2 3.1 Representing Knowledge Using Extended Logic Programs In this section we demonstrate the applicability of extended logic programs for <p> This means birds are weak exceptions to rule r2 which can be expressed by the rule ab (r2; X) not:bird (X) The resulting program together with rules expressing the subclass-class relationship between birds and things gives a correct formalization of the extended hierarchy. The next example from <ref> [GL90] </ref> demonstrates how extended logic programs can be used to reason about unknown information in the context of deductive databases. <p> Every extended program is identified in this way with some default theory. It is clear that a default theory is an extended program if and only if each of its justifications and consequents is a literal, and each of its preconditions is a conjunction of literals. Proposition 9.2 <ref> [GL90] </ref> For any extended program , (i) if S is an answer set of , then the deductive closure of S is an extension of ; (ii) every extension of is the deductive closure of exactly one answer set of .
Reference: [GL91] <author> M. Gelfond and V. Lifschitz. </author> <title> Classical negation in logic programs and disjunctive databases. </title> <journal> New Generation Computing, </journal> <pages> pages 365-387, </pages> <year> 1991. </year>
Reference-contexts: We briefly discuss the other semantics of general logic programs and discuss classes of general logic programs where the various semantics agree. We also review a method of computing the stable models of a general logic program. In Section 3 we consider extended logic programs <ref> [GL91, Wag91] </ref> that allow classical negation (also referred to as "strong negation") and discuss its expressibility in the context of knowledge representation. <p> To do that the language should allow for a third possibility the unknown answer, which corresponds to the inability to conclude yes or no. In this section, we discuss "extended" logic programs (ELP's) <ref> [GL91] </ref> (See also [Wag91, PAA92b, PW89]) that contain a second type of negation : (called "classical", "strong" or "explicit" by different authors who associate different meanings to it) 11 in addition to negation-as-failure not. <p> More examples and discussions on the subject can be found in <ref> [GL91] </ref>, [PAA91a], [KS90], [PAA]. Example 3.1 Let us go back to the bird's story from Example 2.5 in which we knew that birds typically fly, that penguins are exceptions to this rule they are non-flying birds and that our information about penguins, birds and flying objects is complete. <p> In this section, we discuss another approach to expressing disjunctive information based on the expansion of the language of extended logic programs by a new connective or called epistemic disjunction <ref> [GL91] </ref>. (Notice the use of the symbol or instead of classical _. The meaning of or is given by the semantics of disjunctive logic programs and differs from that of _. <p> When m = n and the L i 's are atoms, we refer to the program as a positive disjunctive logic program. The definition of an answer set of a disjunctive logic program <ref> [Prz91, GL91] </ref> is almost identical to that of extended logic programs. Let us first consider disjunctive logic programs without negation as failure. <p> Results for important restricted cases have been derived in [CL90]. For the extension of logic programming by classical negation <ref> [GL91] </ref>, the following holds.
Reference: [GL92] <author> M. Gelfond and V. Lifschitz. </author> <title> Representing actions in extended logic programs. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming., </booktitle> <pages> pages 559-573, </pages> <year> 1992. </year>
Reference-contexts: Some of the later solutions, in particular those from [Gel89], and [Mor88], were given in the language of autoepistemic logic and non-normal default theory respectively, and are similar to the one presented here. Representing inheritance reasoning and reasoning about actions in logic programming is an active area of research <ref> [GL92, BG93, Dun93b, PR93, Esh88, DMB92, KS86] </ref>. Some of the works on both subjects will be discussed in the upcoming sections.
Reference: [GLPT91] <author> M. Gelfond, V Lifschitz, H. Przymusinska, and M. Truszczynski. </author> <title> Disjunctive defaults. </title> <editor> In J. Allen, R. Fikes, and E. Sandewall, editors, </editor> <booktitle> Principles of Knowledge Representation and Reasoning: Proc. of the Second Int'l Conf., </booktitle> <pages> pages 230-237, </pages> <year> 1991. </year>
Reference-contexts: It not only helped to single out important classes of theories such as stratified autoepistemic theories and their variants, with comparatively good computational and other properties but also led to the development of new versions of basic formalisms, such as "default theories" [LY91, PP92], disjunctive defaults <ref> [GLPT91] </ref>, reflexive autoepistemic logic [Sch91], introspective circumscription [Lif89], and MBNF [Lif91, LS90], to mention only a few.
Reference: [GM90] <author> L. Giordano and A. Martelli. </author> <title> Generalized stable models, truth maintenance and conflict resolution. </title> <booktitle> In Proc. of the Seventh International, </booktitle> <pages> pages 427-441. </pages> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The -well-founded semantics is given by ffc; :bg; fc; a; :bgg. 2 Before we end this section we would like to briefly mention another class of semantics of extended logic programs based on contradiction removal <ref> [Dun91b, Wag93, PAA91a, GM90] </ref>. To illustrate the problem let us consider the program 4 : 1. p not q 3. s Obviously, under the answer set semantics this program is inconsistent. <p> The following theorem establishes the relationship between TMSs and logic programs: Proposition 9.3 [Elk90] M is a grounded model of a collection of justifications iff it is a stable model of a program fl . Similar results were obtained in [WB93], <ref> [GM90] </ref>, [PC89], [RM89], and [FH89]. (The last two papers use autoepistemic logic instead of logic programs).
Reference: [GO92] <author> L. Giordano and N. Olivetti. </author> <title> Negation as failure in intuitionistic logic programming. </title> <booktitle> In Proc. of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 430-445. </pages> <publisher> The MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Intuitionistic semantics for such programs can be found in <ref> [Mil86, BM90, GO92] </ref>. Roughly speaking, to establish the derivability of near grad (s) in the corresponding intuitionistic program 1 under this semantic one should add the rule take (s; c) to 1 and then try to prove grad (s).
Reference: [Got92] <author> G. Gottlob. </author> <title> Complexity Results for Nonmonotonic Logics. </title> <journal> Journal of Logic and Computation, </journal> <volume> 2(3) </volume> <pages> 397-425, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Note that similar complexity results have recently been derived for various forms of nonmonotonic reasoning such as default and autoepistemic logic <ref> [Got92] </ref>, nonmonotonic S4 [ST93], theory revision [EG92], and abduction [EG93e]. For programs with variables, consider the case of first order disjunctive logic programs without function symbols. Then following holds.
Reference: [GP86] <author> M. Gelfond and H. Przymusinska. </author> <title> Negation as failure: Careful closure procedure. </title> <journal> Artificial Intelligence, </journal> <volume> 30(3) </volume> <pages> 273-287, </pages> <year> 1986. </year>
Reference-contexts: The syntactic counterpart for inferring negative literals, called the generalized closed world assumption, is defined as follows: (We will use the terminology from <ref> [GP86] </ref>.) A disjunction D of ground atoms is called essential w.r.t. theory T if T j= D and no sub-disjunction of D is entailed by T . A ground atom is called free for negation in T if it does not belong to any clause essential in T . <p> This result was extended to arbitrary T in <ref> [GP86, She88] </ref>. The following proposition establishes the connection between Minker's semantics and answer set semantics of disjunctive logic programs. <p> Then for any literal query q, 's answer to q under answer set semantics coincides with the answer to q by ff () under Minker's semantics. 2 Minker's GCWA was later extended by many people <ref> [YH85, GP86, GPP86] </ref> in several various directions. Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92]. <p> [RLM89] is polynomial [Cha93] (co-N P -complete if heads can be empty), (b) the decision problem for under the possible models semantics [Sak89] and the equivalent possible worlds semantics [Cha93] is polynomial (co-N P -complete again if heads can be empty), (c) the decision problem for under the careful CWA <ref> [GP86] </ref> is P 2 -hard and in P 3 [O (log n)], (d) the decision problem for is P 2 -complete for the following semantics [EG93a, EG93c, EG93d]: the generalized CWA [Min82], the extended generalized CWA [YH85], the extended CWA [GPP89], the iterated CWA [GPP89], the perfect model semantics [Prz88b], and
Reference: [GP90] <author> M. Gelfond and H. Przymusinska. </author> <title> Inheritance reasoning in autoepistemic logic. </title> <journal> Fundamenta Informaticae, </journal> <volume> 13(4) </volume> <pages> 403-445, </pages> <year> 1990. </year>
Reference-contexts: We will use it throughout the paper. There is a vast literature on representing inheritance hierarchies using nonmonotonic formalisms (For a survey see [Hor]). Representing inheritance hierarchies using logic programs is discussed in <ref> [GP90, Lin91, PAA, PAA91c] </ref>. We conclude this section with a brief discussion of the application of general logic programs to the formalization of reasoning about results of actions.
Reference: [GP91] <author> M. Gelfond and H. Przymusinska. </author> <title> Definitions in epistemic specifications. </title> <editor> In A. Nerode, W. Marek, and Subrahmanian V. S., editors, </editor> <booktitle> Logic Programming and Non-monotonic Reasoning: Proc. of the First Int'l Workshop, </booktitle> <pages> pages 245-259, </pages> <year> 1991. </year>
Reference-contexts: Hence, S is a world view of T 1 . It is possible to show that S is the only world view of T 1 <ref> [GP91] </ref> and therefore T 1 j= presumed innocent (john), T 1 j= presumed innocent (peter), T 1 j= :cleared (john) and T 1 j= :cleared (peter) which corresponds to our specification. 2 Example 5.3 [Representing Unknown] Consider the extended logic program E 1 from Ex ample 3.4.
Reference: [GP93a] <author> M. Gelfond and H. Przymusinska. </author> <title> Reasoning in open domains. </title> <editor> In L. Pereira and A. Nerode, editors, </editor> <booktitle> Proceedings of the Second International Workshop in Logic Programming and Nonmonotonic Reasoning, </booktitle> <pages> pages 397-413, </pages> <year> 1993. </year>
Reference-contexts: An application to formalization of anonymous exceptions to defaults [EKP91] can be found in <ref> [GP93a] </ref>. [Sch93] contains some results of query answering in open domain semantics. Related work in the context of autoepistemic logic and default logic can be found in [Lif89, Lif90].
Reference: [GP93b] <author> M. Gelfond and H. Przymusinska. </author> <title> Stratification in extended logic programs, 1993. </title> <type> manuscript. </type>
Reference-contexts: It is possible to show that for any set of facts not containing facts of the form :f lies (t), where t is an arbitrary ground term, programs B 3 and B 4 are equivalent. For a general theorem to this effect see <ref> [GP93b] </ref>. This observation leads us to a translation of normative statements to extended logic programs which is different from the one suggested in Section 2.
Reference: [GPP86] <author> M. Gelfond, H. Przymusinska, and T. Przymusinski. </author> <title> The extended closed world assumption and its relation to parallel circumscription. </title> <booktitle> In Proc. of the fifth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 133-139, </pages> <year> 1986. </year> <month> 80 </month>
Reference-contexts: Then for any literal query q, 's answer to q under answer set semantics coincides with the answer to q by ff () under Minker's semantics. 2 Minker's GCWA was later extended by many people <ref> [YH85, GP86, GPP86] </ref> in several various directions. Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92].
Reference: [GPP89] <author> M. Gelfond, H. Przymusinska, and T. Przymusinski. </author> <title> On the Relationship Be--tween Circumscription and Negation as Failure. </title> <journal> Artificial Intelligence, </journal> <volume> 38 </volume> <pages> 75-94, </pages> <year> 1989. </year>
Reference-contexts: empty), (c) the decision problem for under the careful CWA [GP86] is P 2 -hard and in P 3 [O (log n)], (d) the decision problem for is P 2 -complete for the following semantics [EG93a, EG93c, EG93d]: the generalized CWA [Min82], the extended generalized CWA [YH85], the extended CWA <ref> [GPP89] </ref>, the iterated CWA [GPP89], the perfect model semantics [Prz88b], and the partial as well as total disjunctive stable model semantics [Prz91]. 2 Here P 2 and P 3 [O (log n)] are classes above coN P (= P 1 ) in the refined polynomial hierarchy, which is a subrecursive analog <p> problem for under the careful CWA [GP86] is P 2 -hard and in P 3 [O (log n)], (d) the decision problem for is P 2 -complete for the following semantics [EG93a, EG93c, EG93d]: the generalized CWA [Min82], the extended generalized CWA [YH85], the extended CWA <ref> [GPP89] </ref>, the iterated CWA [GPP89], the perfect model semantics [Prz88b], and the partial as well as total disjunctive stable model semantics [Prz91]. 2 Here P 2 and P 3 [O (log n)] are classes above coN P (= P 1 ) in the refined polynomial hierarchy, which is a subrecursive analog to the Kleene arithmetical
Reference: [GPP90] <author> M. Gelfond, H. Przymusinska, and T. Przymusinski. </author> <title> On the relationship between CWA, Minimal Model, and Minimal Herbrand Model semantics. </title> <journal> International Journal of Intelligent Systems, </journal> <volume> 5(5) </volume> <pages> 549-565, </pages> <year> 1990. </year>
Reference-contexts: Under the proper definition of the answer to a query, both and fl answer unknown to q. At the same time, the semantics from [Prz89b] does not diverge too far from the least Herbrand model semantics. In fact, these two semantics are equivalent for existential queries <ref> [GPP90] </ref>. 17 Other solutions of the universal query problem are suggested in [Ros89], [Kun87], and [VGRS91]. They are based on the assumption that the language of any logic program contains constants and function symbols not appearing in it explicitly.
Reference: [Gre69] <author> C. Green. </author> <title> Theorem Proving by Resolution as a Basis for Question Answering Systems. </title> <editor> In B. Meltzer D. Michie, editor, </editor> <booktitle> Machine Intelligence 4, </booktitle> <pages> pages 183-205. </pages> <publisher> Edinburgh University Press, </publisher> <address> New York, </address> <year> 1969. </year>
Reference-contexts: This work has substantially deepened our understanding 1 of the properties of nonmonotonic reasoning and of the technical problems involved in its formalization. Another direction of research, started by Green <ref> [Gre69] </ref>, Hayes [Hay73] and Kowalski [Kow74], and continued by many others, combined the idea of logic as a representation language with the theory of automated deduction and constructive logic.
Reference: [GT93] <author> M. Gelfond and B. Traylor. </author> <title> Representing null values in logic programs. </title> <booktitle> In Workshop on Logic Programming with incomplete information, </booktitle> <address> Vancouver, BC., </address> <year> 1993. </year>
Reference-contexts: This allows us to conclude, say, that a is not a professor without concluding that there are no professors except m and n. 2 Open domain semantics is also useful for representing certain types of null values in databases <ref> [GT93] </ref>. An application to formalization of anonymous exceptions to defaults [EKP91] can be found in [GP93a]. [Sch93] contains some results of query answering in open domain semantics. Related work in the context of autoepistemic logic and default logic can be found in [Lif89, Lif90].
Reference: [Hay73] <author> P. Hayes. </author> <title> Computation and deduction. </title> <booktitle> In Proceedings of the Second Symposium on Mathematical Foundations of Computer Science, </booktitle> <pages> pages 105-118. </pages> <institution> Czechoslo-vakia: Czechoslovakian Academy of Sciences, </institution> <year> 1973. </year>
Reference-contexts: This work has substantially deepened our understanding 1 of the properties of nonmonotonic reasoning and of the technical problems involved in its formalization. Another direction of research, started by Green [Gre69], Hayes <ref> [Hay73] </ref> and Kowalski [Kow74], and continued by many others, combined the idea of logic as a representation language with the theory of automated deduction and constructive logic. This led Kowalski and Colmerauer to the creation of logic programming [Llo87] and the development of the first logic programming language, Prolog [CKPR73].
Reference: [HL91] <author> P. Hill and J. Lloyd. </author> <title> The godel report. </title> <type> Technical Report TR-91-02, </type> <institution> University of Bristol, </institution> <year> 1991. </year>
Reference-contexts: The literature on the subject is vast. Interesting meta-programs can be found in various textbooks on logic programming. Several workshop proceedings contain papers addressing theoretical problems related to meta-programming [AR89, Met92]. Logic programming languages based on the ideas of meta-programming such as Godel <ref> [HL91] </ref>, Hilog [CKW93], Reflexive Prolog [CL89] among others are beginning to gain ground in logic programming community. In this paper we will not even attempt to mention all directions of research related to meta-programming. <p> It will be interesting to generalize this statement to programs from [BM90] and carefully investigate the relationship between the two approaches. More complicated (but also more general) meta-programming schemes are based on naming statements of object programs by ground terms on the meta-level as in [BK82] and <ref> [HL91] </ref>, on allowing sentences name themselves as in [Ric74], or by other naming devices. Normally, these approaches require the development of special semantics. Additional complications occur if we allow self-referencing meta-programs.
Reference: [HM87] <author> S. Hanks and D. McDermott. </author> <title> Nonmonotonic logic and temporal projection. </title> <journal> Artificial Intelligence, </journal> <volume> 33(3) </volume> <pages> 379-412, </pages> <year> 1987. </year>
Reference-contexts: In Section 2 we consider general logic programs (also known as normal logic programs) and show how general logic programs can be used to represent knowledge in AI. In particular we consider McCarthy's [McC59] example of flying birds and the Yale shooting problem <ref> [HM87] </ref> and show their formalization using general logic programs. We also discuss formalization of normative statements 1 of the kind "A's are normally B's" using general logic programs. Our discussion is based on the stable model semantics of general logic programs. <p> The most frequently cited example of such reasoning is probably the Yale Shooting Problem (YSP) from <ref> [HM87] </ref>.
Reference: [Hor] <author> J. Horty. </author> <title> Some direct theories of non-monotonic inheritance. </title> <editor> In D. Gabbay and C. Hogger, editors, </editor> <booktitle> Forthcoming in Handbook of Logic in AI and logic programming. </booktitle>
Reference-contexts: We will use it throughout the paper. There is a vast literature on representing inheritance hierarchies using nonmonotonic formalisms (For a survey see <ref> [Hor] </ref>). Representing inheritance hierarchies using logic programs is discussed in [GP90, Lin91, PAA, PAA91c]. We conclude this section with a brief discussion of the application of general logic programs to the formalization of reasoning about results of actions.
Reference: [HP88] <author> L. Henschen and H. Park. </author> <title> Compiling the GCWA in Indefinite Databases. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 395-438. </pages> <publisher> Morgan Kaufmann Pub., </publisher> <address> Washington, D.C., </address> <year> 1988. </year>
Reference-contexts: D apparently satisfies the specification and may be used with any collection of facts formed by predicate symbols p and a. 2 4.2 Answering Queries There has been considerable research in developing query answering methods for positive disjunctive programs <ref> [MZ82, MR90, FM91, LMR92, HP88] </ref>. It should be noted that for positive programs minimal models coincides with answer sets.
Reference: [IKH92] <author> K. Inoue, M. Koshimura, and R. Hasegawa. </author> <title> Embedding negation as failure into a model generation theorem prover. </title> <booktitle> In The Eleventh International Conference on Automated Deduction, </booktitle> <year> 1992. </year>
Reference-contexts: SLDNF resolution, though sound [Cla78], is only complete for a subclass of stratified programs [JLL83]. Various practical Prolog systems have been developed based on SLDNF resolution. To answer queries with respect to programs with a multiple number of stable models, several approaches have been suggested <ref> [PAA91a, BNNS94, FLMS93, SZ90, IKH92, WC93, EK89] </ref> in the literature. <p> Fernandez et al. [FLMS93] and Inoue et al. <ref> [IKH92] </ref> propose bottom-up methods to compute all the stable models of a general program. While Fernandez et al. [FLMS93] transform a general logic program to a disjunctive logic program with constraints, Inoue et al. [IKH92] transform a general program to a propositional theory. <p> Fernandez et al. [FLMS93] and Inoue et al. <ref> [IKH92] </ref> propose bottom-up methods to compute all the stable models of a general program. While Fernandez et al. [FLMS93] transform a general logic program to a disjunctive logic program with constraints, Inoue et al. [IKH92] transform a general program to a propositional theory. They show that the minimal (in the sense of set-theoretic inclusion) models of the resultant theory that satisfy certain conditions are the stable models of the original program. <p> They show that the minimal (in the sense of set-theoretic inclusion) models of the resultant theory that satisfy certain conditions are the stable models of the original program. To give the reader a flavor of the issues involved, we now present the approach of <ref> [IKH92] </ref> in more detail. Their approach is based on transforming a general logic program into a propositional theory in an extended language and reducing computing stable models of the original program to computing minimal models of the transformed theory that satisfy certain properties. <p> Let stable () = fS : S 0 2 M (tr 1 ()) and S is obtained from S 0 by removing all atoms with + and in their superscript g. Theorem 2.6 <ref> [IKH92] </ref> For any general logic program , stable () is the set of stable models of . 2 Example 2.7 Consider the general logic program 1 p not q q not p tr 1 ( 1 ) consists of the rules: (q ^ p) _ q + and has the four <p> Fernandez et al. [FLMS93] use model trees to compute minimal models. Inoue et al. <ref> [IKH92] </ref> use an extension of the model generation theorem prover (MGTP) [FH91] to directly compute the minimal models of the formulas obtained using tr 1 . <p> By using the renaming technique (as in Section 3) of replacing negative literals :p by new positive atoms p 0 we can extend the query answering methods to answer queries in the presence of :. For disjunctive programs with not, Fernandez et al.and Inoue et al. <ref> [IKH92] </ref> have developed bottom-up query answering methods. In this section we present the query answering algorithm for disjunctive logic programs of [IKH92], which is a bottom-up procedure based on computing the answer sets of a positive disjunctive logic program. <p> For disjunctive programs with not, Fernandez et al.and Inoue et al. <ref> [IKH92] </ref> have developed bottom-up query answering methods. In this section we present the query answering algorithm for disjunctive logic programs of [IKH92], which is a bottom-up procedure based on computing the answer sets of a positive disjunctive logic program. It extends the approach of computing the stable models of general logic programs as described in Section 2 to compute the answer sets of disjunctive logic programs. <p> It extends the approach of computing the stable models of general logic programs as described in Section 2 to compute the answer sets of disjunctive logic programs. Like the computation of the stable models, a disjunctive logic program is transformed to a disjunctive program without not. <ref> [IKH92] </ref> show that the answer sets of the transformed program that satisfy certain additional properties (similar to integrity constraints in databases) are the answer sets of the original disjunctive program. In the transformation we use new atoms that are constructed from the literals of the original program. <p> define answerset () to be the set of minimal elements of the set fS : S 0 2 G (tr 2 ()) and S is obtained from S 0 by removing all atoms with + and in their superscript, and the intermediate atoms X i 's g 2 Theorem 4.3 <ref> [IKH92] </ref> For any consistent disjunctive logic program , answerset () is the set of answer sets of . 2 Example 4.4 [IKH92] Consider the following version of Example 4.2 from [IKH92]. lh usable (X) person (X); not ab 1 (X) rh usable (X) person (X); not ab 2 (X) ab 1 <p> ()) and S is obtained from S 0 by removing all atoms with + and in their superscript, and the intermediate atoms X i 's g 2 Theorem 4.3 <ref> [IKH92] </ref> For any consistent disjunctive logic program , answerset () is the set of answer sets of . 2 Example 4.4 [IKH92] Consider the following version of Example 4.2 from [IKH92]. lh usable (X) person (X); not ab 1 (X) rh usable (X) person (X); not ab 2 (X) ab 1 (X) :lh usable (X) ab 2 (X) :rh usable (X) person (a) :lh usable (a) or :rh usable (a) 9 &gt; <p> removing all atoms with + and in their superscript, and the intermediate atoms X i 's g 2 Theorem 4.3 <ref> [IKH92] </ref> For any consistent disjunctive logic program , answerset () is the set of answer sets of . 2 Example 4.4 [IKH92] Consider the following version of Example 4.2 from [IKH92]. lh usable (X) person (X); not ab 1 (X) rh usable (X) person (X); not ab 2 (X) ab 1 (X) :lh usable (X) ab 2 (X) :rh usable (X) person (a) :lh usable (a) or :rh usable (a) 9 &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; ; 16 <p> Inoue et al. <ref> [IKH92] </ref> extend the model generation theorem prover (MGTP) [FH91] to compute the answer sets of the program obtained using tr 2 .
Reference: [Ino91] <author> K. Inoue. </author> <title> Extended logic programs with default assumptions. </title> <booktitle> In Proc. of ICLP91, </booktitle> <year> 1991. </year>
Reference-contexts: There are several useful generalizations of the notion of abductive logic programs. In [Gel91], abduction is combined with reasoning with classical negation and epistemic disjunction, and generalized stable models are replaced by their answer set counterparts. In <ref> [Ino91] </ref>, [Ino92a] this work is further extended by replacing abducible literals by abducible logic programs. 8.2 Abduction and Negation as Failure There are some close similarities between abductive reasoning and negation as failure. The first attempt to make this relationship precise is due to Esghi and Kowalski. <p> a 62 g is a stable model of . 2 The Proposition shows that an expression not p (t) in logic programs can be interpreted as abductive hypotheses that can be assumed to hold provided that, together with the program, they satisfy a canonical set of integrity constraints. [IS91] and <ref> [Ino91] </ref> further investigate relationship between abduction and negation as failure. In particular, they define a transformation of an abductive logic program &lt; ; A; ; &gt; into an extended logic program fl obtained from by adding two rules p not :p for every atom p 2 atoms (A). [Ino91] shows that, <p> [IS91] and <ref> [Ino91] </ref> further investigate relationship between abduction and negation as failure. In particular, they define a transformation of an abductive logic program &lt; ; A; ; &gt; into an extended logic program fl obtained from by adding two rules p not :p for every atom p 2 atoms (A). [Ino91] shows that, under certain natural conditions on the syntax of , there is a simple one-to-one correspondence between generalized stable models of &lt; ; A; ; &gt; and answer sets of fl .
Reference: [Ino92a] <author> K. Inoue. </author> <title> Studies on Abductive and Nonmonotonic Reasoning. </title> <type> PhD thesis, </type> <institution> Kyoto University, </institution> <year> 1992. </year>
Reference-contexts: Abductive frameworks whose first components are general logic programs are called abduc-tive logic programs. Since is no longer a first-order theory we need a new definition of explanation. Various (non-equivalent) definitions can be found in the literature. (For comparison of several of them see <ref> [Ino92a] </ref>.) Here we shell concentrate on the proposal by Kakas and Mancarella (based on the unpublished paper by Esghi and Kowalski [EK88]). In [KM90] they develop a semantics of abductive logic programs closely related to stable model semantics of general logic program. <p> There are several useful generalizations of the notion of abductive logic programs. In [Gel91], abduction is combined with reasoning with classical negation and epistemic disjunction, and generalized stable models are replaced by their answer set counterparts. In [Ino91], <ref> [Ino92a] </ref> this work is further extended by replacing abducible literals by abducible logic programs. 8.2 Abduction and Negation as Failure There are some close similarities between abductive reasoning and negation as failure. The first attempt to make this relationship precise is due to Esghi and Kowalski.
Reference: [IS91] <author> N. Iwayama and K. Satoh. </author> <title> Computing abduction using the TMS. </title> <booktitle> In Proc. of ICLP 91, </booktitle> <pages> pages 505-518, </pages> <year> 1991. </year> <month> 81 </month>
Reference-contexts: ground atom, a 62 g is a stable model of . 2 The Proposition shows that an expression not p (t) in logic programs can be interpreted as abductive hypotheses that can be assumed to hold provided that, together with the program, they satisfy a canonical set of integrity constraints. <ref> [IS91] </ref> and [Ino91] further investigate relationship between abduction and negation as failure. <p> They led to a better understanding of the semantics of nonmonotonic truth maintenance systems, to their use for computing stable models [Esg90] and autoepistemic extensions [JK91], for doing abductive reasoning <ref> [IS91] </ref>, [RP91], and to the development of variants of TMSs based on other semantics of logic programs.
Reference: [JK91] <author> U. Junker and K. Konolige. </author> <title> Computing the extensions of autoepistemic and default logics with a truth maintenance systems. </title> <booktitle> In Proc. of AAAI 90, </booktitle> <pages> pages 278-283, </pages> <year> 1991. </year>
Reference-contexts: Similar results were obtained in [WB93], [GM90], [PC89], [RM89], and [FH89]. (The last two papers use autoepistemic logic instead of logic programs). They led to a better understanding of the semantics of nonmonotonic truth maintenance systems, to their use for computing stable models [Esg90] and autoepistemic extensions <ref> [JK91] </ref>, for doing abductive reasoning [IS91], [RP91], and to the development of variants of TMSs based on other semantics of logic programs.
Reference: [JLL83] <author> J. Jaffar, J-L. Lassez, and J. Lloyd. </author> <title> Completeness of the negation as failure rule. </title> <booktitle> In Proc. of IJCAI-83, </booktitle> <volume> volume 1, </volume> <pages> pages 500-506, </pages> <year> 1983. </year>
Reference-contexts: SLDNF resolution, though sound [Cla78], is only complete for a subclass of stratified programs <ref> [JLL83] </ref>. Various practical Prolog systems have been developed based on SLDNF resolution. To answer queries with respect to programs with a multiple number of stable models, several approaches have been suggested [PAA91a, BNNS94, FLMS93, SZ90, IKH92, WC93, EK89] in the literature.
Reference: [KK91] <author> R. Kowalski and J. Kim. </author> <title> A metalogic programming approach to multy-agent knowledge and belief. </title> <editor> In V. Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation. </booktitle> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: A version of demo predicate formalizing entailment in classical logic was used in <ref> [KK91] </ref> to represent knowledge of multiple agents. In particular the paper contains an elegant meta-programming formalization of the three wise men problem. The object theory of the 51 formalization is classical theory containing disjunctive information.
Reference: [KM90] <author> A. Kakas and P. Mancarella. </author> <title> Generalized stable models: a semantics for abduction. </title> <booktitle> In Proc. of ECAI-90, </booktitle> <pages> pages 385-391, </pages> <year> 1990. </year>
Reference-contexts: Various (non-equivalent) definitions can be found in the literature. (For comparison of several of them see [Ino92a].) Here we shell concentrate on the proposal by Kakas and Mancarella (based on the unpublished paper by Esghi and Kowalski [EK88]). In <ref> [KM90] </ref> they develop a semantics of abductive logic programs closely related to stable model semantics of general logic program. Let &lt; ; A; I &gt; be an abductive logic program. <p> In the first option, the resulting abductive program &lt; 1 ; A; I [ X &gt; not only explains the observation f lies (a) by concluding bird (a) and :penguin (a) (which can also be achieved by the standard approach of abductive logic programs <ref> [EK88, KM90] </ref>) but also entails the conclusion hasbeak (a), which is apparently not done by the standard approach.
Reference: [KM91] <author> A. Kakas and P. Mancarella. </author> <title> Stable theories for logic programs. </title> <booktitle> In Proc. of ISLP-91, </booktitle> <pages> pages 88-100, </pages> <year> 1991. </year>
Reference-contexts: In [EK89] a basic query answering procedure for abductive programs based on SLDN F resolution is defined. In addition to the usual yes/no answer of SLDN F , this procedure also returns an abductive explanation of the corresponding query. The idea was further developed in <ref> [KM91] </ref>, [Dun91a], and [DDS92]. The procedure is shown to be correct w.r.t. the stable model semantics for call-consistent logic programs, but (as pointed out in [EK89]) not in general.
Reference: [kak92] <author> A. Kakas and R. Kowalski and F. Toni. </author> <title> Abductive logic programming. </title> <journal> Journal of Logic and Computation, </journal> <volume> 2(6) </volume> <pages> 719-771, </pages> <year> 1992. </year>
Reference-contexts: Abduction was introduced by C. Peirce in the beginning of the century (see [pei32]) and has been used in AI for explaining observations, diagnosis, planning, and natural language understanding. <ref> [kak92] </ref> gives a survey and analysis of work on the extension of logic programming to perform abductive reasoning. In this paper, we will briefly discuss the traditional role of abduction as a formalism for explanation of observations and the connection between abduction and negation as failure.
Reference: [Kow74] <author> R. Kowalski. </author> <title> Predicate logic as a programming language. </title> <booktitle> Information Processing 74, </booktitle> <pages> pages 569-574, </pages> <year> 1974. </year>
Reference-contexts: This work has substantially deepened our understanding 1 of the properties of nonmonotonic reasoning and of the technical problems involved in its formalization. Another direction of research, started by Green [Gre69], Hayes [Hay73] and Kowalski <ref> [Kow74] </ref>, and continued by many others, combined the idea of logic as a representation language with the theory of automated deduction and constructive logic. This led Kowalski and Colmerauer to the creation of logic programming [Llo87] and the development of the first logic programming language, Prolog [CKPR73]. <p> Such interpretation of definite logic programs which treats predicates as procedure calls and interpreters the rule A 0 A 1 ; : : : A n as saying "to execute procedure A 0 execute procedures A 1 ; : : : A n " was suggested by Kowalski in <ref> [Kow74] </ref> and lies at the heart of logic programming paradigm. It remains to be seen if similar interpretation can be discovered for disjunctive logic programs and the other formalisms described in the paper.
Reference: [Kow79] <author> R. Kowalski. </author> <title> Logic for Problem Solving. </title> <publisher> North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: Instead we consider a few simple (but important) meta-programs and try to outline several fundamental points related to their construction and declarative meaning. We will start with an investigation of a two argument proof predicate demo (; q) (first introduced in <ref> [Kow79] </ref>), which expresses that the general logic program named can be used to demonstrate the conclusion named q. The predicate demo and its numerous variations are used for many meta-programming applications. As an illustration let us consider its possible use for knowledge assimilation. <p> Programs with this property are called amalgamated. They were first introduced and investigated in <ref> [Kow79] </ref>, [BK82]. To deal with such programs one should address a basic problem associated with their meaning. The problem is caused by overloading the symbols in the language.
Reference: [Kow90] <author> R. Kowalski. </author> <title> Problems and promises of computational logic. </title> <editor> In J. Lloyd, editor, </editor> <booktitle> Computational Logic: Symposium Proceedings, </booktitle> <pages> pages 80-95. </pages> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: Logic programs representing such knowledge are called meta-programs and the process of their design is referred to as meta-programming. The situations requiring various types of meta-programming are numerous. (For many interesting examples and discusion see <ref> [Kow90] </ref>). Meta-programming is used for representing and analyzing proof procedures, for assimilating new knowledge and updating knowledge bases, for modeling knowledge and beliefs of multiple agents, for hypothetical reasoning, for structured and object oriented logic programming and for many other purposes. The literature on the subject is vast. <p> For some applications such a naming scheme is both appropriate and convenient. For other applications, however, it is not. For an interesting discussion on pros and cons of different naming schemes see <ref> [Kow90] </ref>. Now we are ready to give a definition of assimilate. The informal specification of this relation will be developed concurrently with the formal one.
Reference: [KP87] <author> P. Kolaitis and C. Papadimitriou. </author> <title> Why not negation by fixpoint? In Proc. </title> <booktitle> of PODS-87, </booktitle> <pages> pages 231-239, </pages> <year> 1987. </year>
Reference-contexts: Moreover, they show that the problem of determining if a literal l is a stable model consequence of a program is 1 1 complete, i.e. is represen tative of the hardest decision problem in 1 1 . As shown in [VG89], <ref> [KP87] </ref>, and [Fit85], the same result holds for the well-founded semantics as well as for two-valued and three-valued completion based semantics of logic programs.
Reference: [KS86] <author> R. Kowalski and M. Sergot. </author> <title> A logic-based calculus of events. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 67-95, </pages> <year> 1986. </year>
Reference-contexts: The most frequently cited example of such reasoning is probably the Yale Shooting Problem (YSP) from [HM87]. The original formalization of the problem uses the language of situation calculus [MH69]. (An alternative approach can be found in <ref> [KS86] </ref>.) The syntax of the language contains variables of three sorts: situation variables S; S 0 ; : : :; fluent variables F; F 0 ; : : :; 3 and action variables A; A 0 ; : : : 4 Its only situation constant is s 0 , and res <p> Some of the later solutions, in particular those from [Gel89], and [Mor88], were given in the language of autoepistemic logic and non-normal default theory respectively, and are similar to the one presented here. Representing inheritance reasoning and reasoning about actions in logic programming is an active area of research <ref> [GL92, BG93, Dun93b, PR93, Esh88, DMB92, KS86] </ref>. Some of the works on both subjects will be discussed in the upcoming sections.
Reference: [KS90] <author> R. Kowalski and F. Sadri. </author> <title> Logic programs with exceptions. </title> <editor> In D. Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 598-613, </pages> <year> 1990. </year>
Reference-contexts: More examples and discussions on the subject can be found in [GL91], [PAA91a], <ref> [KS90] </ref>, [PAA]. Example 3.1 Let us go back to the bird's story from Example 2.5 in which we knew that birds typically fly, that penguins are exceptions to this rule they are non-flying birds and that our information about penguins, birds and flying objects is complete. <p> Several other semantics of extended logic programs are suggested in the literature <ref> [AP92, PAA91c, PAA92a, PAA92b, Prz90a, KS90] </ref>. We now discuss some of them. The formulation of well-founded semantics of general logic programs in [BS91] can be extended to define the well-founded semantics [Prz90a] of extended logic programs. More precisely, let us consider G (S) = b ( S ). <p> There are several approaches to doing that. One, suggested in <ref> [KS90] </ref>, modifies the answer set semantics to give preference to rules with negative conclusions (viewed as exceptions to general rules). Under the corresponding entailment relation 4 concludes s and :p. Another possibility is to first identify literals responsible for contradiction, in our case q.
Reference: [KS91] <author> D. Kemp and P. Stuckey. </author> <title> Semantics of logic programs with aggregates. </title> <booktitle> In Proceedings of International Symposium on Logic Programming, </booktitle> <pages> pages 387-401, </pages> <year> 1991. </year>
Reference-contexts: Extensions of the languages by allowing more complex data such as sets and aggregates are very important in database applications <ref> [KS91, BRSS92, Gel92a] </ref>. Even more questions remain for noncategorical programs, i.e. logic programs with multiple answer sets or disjunctive logic programs. In this case one of the most important problems seems to be the lack of clear procedural interpretation of rules of a program.
Reference: [Kun87] <author> K. Kunen. </author> <title> Negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(4) </volume> <pages> 289-308, </pages> <year> 1987. </year>
Reference-contexts: Przymusinski [Prz88b] generalized the concept of stratification and introduced local stratification and perfect models. The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. The second approach <ref> [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] </ref> was to use three-valued logic instead of the classical 2-valued logic. <p> The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. The second approach [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] was to use three-valued logic instead of the classical 2-valued logic. Fitting [FBJ88, Fit85, Fit86], Kunen <ref> [Kun87, Kun89] </ref> and others [LM85, Myc83] used Kleene's strong three-valued logic while Van Gelder, Ross and Schlifp [VGRS91] used a different three valued logic to give the well-founded semantics of a logic program. <p> At the same time, the semantics from [Prz89b] does not diverge too far from the least Herbrand model semantics. In fact, these two semantics are equivalent for existential queries [GPP90]. 17 Other solutions of the universal query problem are suggested in [Ros89], <ref> [Kun87] </ref>, and [VGRS91]. They are based on the assumption that the language of any logic program contains constants and function symbols not appearing in it explicitly.
Reference: [Kun89] <author> K. Kunen. </author> <title> Signed data dependencies in logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 7(3) </volume> <pages> 231-245, </pages> <year> 1989. </year>
Reference-contexts: Existence of stable models was further studied in [Fag90, Cav89, Dun92, Prz88a]. The following result, due to Fages [Fag90], is representative of this direction of research. A general logic program is said to be call-consistent <ref> [Kun89, Sat87] </ref> if its dependency graph does not have a cycle with an odd number of negative edges. <p> Przymusinski [Prz88b] generalized the concept of stratification and introduced local stratification and perfect models. The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. The second approach <ref> [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] </ref> was to use three-valued logic instead of the classical 2-valued logic. <p> The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. The second approach [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] was to use three-valued logic instead of the classical 2-valued logic. Fitting [FBJ88, Fit85, Fit86], Kunen <ref> [Kun87, Kun89] </ref> and others [LM85, Myc83] used Kleene's strong three-valued logic while Van Gelder, Ross and Schlifp [VGRS91] used a different three valued logic to give the well-founded semantics of a logic program.
Reference: [Leh89] <author> D. Lehmann. </author> <booktitle> What does a conditional knowledge base entail? In Proceedings of KR 89, </booktitle> <pages> pages 212-221, </pages> <year> 1989. </year> <month> 82 </month>
Reference-contexts: There are several attempts to classify the various semantics of general logic programs. One attempt uses the notion of complexity of query answering. 9 Another attempt is based on establishing basic principles of nonmonotonic entailment. This approach was first suggested in [Gab85] and further developed by Makinson, Lehman <ref> [Leh89] </ref> and others. For a good application of this approach in the context of logic programming see [Dix91, Dix92].
Reference: [Lif85a] <author> V. Lifschitz. </author> <title> Closed-world data bases and circumscription. </title> <journal> Artificial Intelligence, </journal> <volume> 27, </volume> <year> 1985. </year>
Reference-contexts: Even though some affinity between logic programs and nonmonotonic logics was recognized rather early [Rei82], <ref> [Lif85a] </ref>, the intensive work in this direction started in 1987 after the discovery of model theoretic semantics for stratified logic programs [Apt89].
Reference: [Lif85b] <author> V. Lifschitz. </author> <title> Computing circumscription. </title> <booktitle> In Proc. of IJCAI-85, </booktitle> <pages> pages 121-127, </pages> <year> 1985. </year>
Reference-contexts: Commonsense reasoning is nonmonotonic: new information constantly forces us to withdraw previous conclusions. This observation has led to the development and investigation of new logical formalisms, nonmonotonic logics. The best known of them are circumscription <ref> [McC80, McC86, Lif85b] </ref>, default logic [Rei80b], and nonmonotonic modal logics [MD80, McD82, Moo85]. A collection of important papers on nonmonotonic reasoning published before 1987 appears in [Gin87]. A survey can be found in [Rei87a].
Reference: [Lif88] <author> V. Lifschitz. </author> <title> On the declarative semantics of logic programs with negation. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 177-192. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA., </address> <year> 1988. </year>
Reference: [Lif89] <author> V. Lifschitz. </author> <title> Between circumscription and autoepistemic logic. </title> <editor> In R. Brachman, H. Levesque, and R. Reiter, editors, </editor> <booktitle> Proc. of the First Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 235-244, </pages> <year> 1989. </year>
Reference-contexts: An application to formalization of anonymous exceptions to defaults [EKP91] can be found in [GP93a]. [Sch93] contains some results of query answering in open domain semantics. Related work in the context of autoepistemic logic and default logic can be found in <ref> [Lif89, Lif90] </ref>. <p> helped to single out important classes of theories such as stratified autoepistemic theories and their variants, with comparatively good computational and other properties but also led to the development of new versions of basic formalisms, such as "default theories" [LY91, PP92], disjunctive defaults [GLPT91], reflexive autoepistemic logic [Sch91], introspective circumscription <ref> [Lif89] </ref>, and MBNF [Lif91, LS90], to mention only a few. Many of these formalisms are new, and we are in the beginning stages of evaluating their utility to knowledge representation, but their role in gaining a much better understanding of commonsense reasoning cannot be seriously disputed. <p> The stronger result establishes a one-to-one correspondence between the stable models of an arbitrary general logic program and the stable expansions of ff (). Other mappings of logic programs into autoepistemic logic and its variants were investigated in [MT89], <ref> [Lif89] </ref> [Sch91], and [LS89] but none of these mappings seem to extend in a natural way to logic programs with classical negation and disjunction. Recently, several such mappings were independently found by several researchers [LS93], [MT93], [Che93].
Reference: [Lif90] <author> V. Lifschitz. </author> <title> On open defaults. </title> <editor> In J. Lloyd, editor, </editor> <booktitle> Computational Logic: Symposium Proceedings, </booktitle> <pages> pages 80-95. </pages> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: An application to formalization of anonymous exceptions to defaults [EKP91] can be found in [GP93a]. [Sch93] contains some results of query answering in open domain semantics. Related work in the context of autoepistemic logic and default logic can be found in <ref> [Lif89, Lif90] </ref>. <p> This property accounts for the difficulty in formalizing Example 4.2 in default logic. It is easy to see that its disjunctive logic program counterpart entails p. 22 We limit ourselves to the quantifier-free case. For an interesting discussion on defaults with quantifiers see <ref> [Lif90] </ref>. 9.3 Truth Maintenance Systems and Logic Programming Finally, we will briefly discuss the relationship between logic programs and nonmonotonic truth maintenance systems (TMSs) [Doy79]. Systems of this sort, originally described by procedural (and sometimes rather complicated) means, commonly serve as inference engines of AI reasoning systems.
Reference: [Lif91] <author> V. Lifschitz. </author> <title> Nonmonotonic databases and epistemic queries: Preliminary report. </title> <booktitle> In Proceedings of International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 381-386, </pages> <address> Sydney, Australia, </address> <year> 1991. </year>
Reference-contexts: out important classes of theories such as stratified autoepistemic theories and their variants, with comparatively good computational and other properties but also led to the development of new versions of basic formalisms, such as "default theories" [LY91, PP92], disjunctive defaults [GLPT91], reflexive autoepistemic logic [Sch91], introspective circumscription [Lif89], and MBNF <ref> [Lif91, LS90] </ref>, to mention only a few. Many of these formalisms are new, and we are in the beginning stages of evaluating their utility to knowledge representation, but their role in gaining a much better understanding of commonsense reasoning cannot be seriously disputed.
Reference: [Lif93] <author> V. Lifschitz. </author> <title> A language for representing actions. </title> <booktitle> In Working Papers of the Second Int'l Symp. on Logical Formalizations of Commonsense Knowledge, </booktitle> <year> 1993. </year>
Reference-contexts: Recently, several such mappings were independently found by several researchers [LS93], [MT93], [Che93]. The mapping fi from <ref> [Lif93] </ref>, and [Che93] translates rules of a disjunctive logic program (of the form (19) into autoepistemic formulas of the form (L k+1 ^ B L k+1 ) ^ : : : ^ (L m ^ B L m ) ^ :B L m+1 ^ : : : ^ :B L n
Reference: [Lin91] <author> F. Lin. </author> <title> A study of Nonmonotonic Reasoning. </title> <type> PhD thesis, </type> <institution> Stanford University, Department of Computer Science, 1991. Stanford TR - STAN-CS-91-1385. </institution>
Reference-contexts: We will use it throughout the paper. There is a vast literature on representing inheritance hierarchies using nonmonotonic formalisms (For a survey see [Hor]). Representing inheritance hierarchies using logic programs is discussed in <ref> [GP90, Lin91, PAA, PAA91c] </ref>. We conclude this section with a brief discussion of the application of general logic programs to the formalization of reasoning about results of actions.
Reference: [Llo87] <author> J. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: Another direction of research, started by Green [Gre69], Hayes [Hay73] and Kowalski [Kow74], and continued by many others, combined the idea of logic as a representation language with the theory of automated deduction and constructive logic. This led Kowalski and Colmerauer to the creation of logic programming <ref> [Llo87] </ref> and the development of the first logic programming language, Prolog [CKPR73]. Even though logic programming and nonmonotonic logic share many common goals and techniques, until recently, there were no strong ties between the two research communities. Originally, declarative Prolog was defined as a small subset of predicate calculus. <p> For a precise definition see <ref> [Llo87] </ref>. 12 and top-down methods. Bell et al. [BNNS94] present an approach to compute the stable models by constructing a linear programming problem from the program and solving the linear programming problem. In [Esg90], [PC89] truth maintenance systems are used to compute the stable models of a general program.
Reference: [LM85] <author> J. Lassez and M. Maher. </author> <title> Optimal fixedpoints of logic programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 39 </volume> <pages> 15-25, </pages> <year> 1985. </year>
Reference-contexts: Przymusinski [Prz88b] generalized the concept of stratification and introduced local stratification and perfect models. The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. The second approach <ref> [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] </ref> was to use three-valued logic instead of the classical 2-valued logic. <p> The second approach [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] was to use three-valued logic instead of the classical 2-valued logic. Fitting [FBJ88, Fit85, Fit86], Kunen [Kun87, Kun89] and others <ref> [LM85, Myc83] </ref> used Kleene's strong three-valued logic while Van Gelder, Ross and Schlifp [VGRS91] used a different three valued logic to give the well-founded semantics of a logic program. Przymusinski [Prz89a, Prz89d], Dung [Dun93a], Van Gelder [VG89], and many others gave alternative formalizations of the well-founded semantics.
Reference: [LMR92] <author> J. Lobo, J. Minker, and A. Rajasekar. </author> <title> Foundations of disjunctive logic programming. </title> <publisher> The MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: This work was generalized and/or modified by various authors (an overview can be found in [PP90a], <ref> [LMR92] </ref>) but most of the approaches still assume the closed world assumption, and hence do not allow the representation of such simple forms of incompleteness as missing information in the database tables, null values and partial definitions. <p> D apparently satisfies the specification and may be used with any collection of facts formed by predicate symbols p and a. 2 4.2 Answering Queries There has been considerable research in developing query answering methods for positive disjunctive programs <ref> [MZ82, MR90, FM91, LMR92, HP88] </ref>. It should be noted that for positive programs minimal models coincides with answer sets. <p> Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) <ref> [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92] </ref>. <p> We conclude this section by briefly addressing some recent complexity and expressiveness results for disjunctive logic programming, where the heads of clauses may be disjunctions of atoms instead of single atoms (cf. <ref> [LMR92] </ref>). The main decision problem for the language of propositional disjunctive logic programs (not containing : ) is as for nondisjunctive programs: given a disjunctive logic program and a literal l, determine whether l is a consequence of in the given semantics.
Reference: [Lov87] <author> D.W. Loveland. </author> <title> Near-Horn PROLOG. </title> <editor> In J.-L. Lassez, editor, </editor> <booktitle> Proc. 4 th International Conference on Logic Programming, </booktitle> <pages> pages 456-459, </pages> <year> 1987. </year>
Reference-contexts: It became apparent, on the other hand, that in order to become satisfactory tools for knowledge representation, logic programming languages should be expanded to allow for better handling of incomplete information. Work in this direction was started by Minker [Min82], Loveland <ref> [Lov87] </ref> and others, who investigated the possibility of expanding logic programs by disjunctive information. In [GL90, PW89, Gel92b], extensions of logic programming by classical (or strong) negation and epistemic operators were suggested. <p> L k L k+1 : : : L m from , if L k+1 ; : : : ; L m 2 S, then for some i, 0 i k, L i 2 S; (ii) if S contains a pair of complementary literals, then S = Lit. 14 Independently, Loveland <ref> [Lov87] </ref> considered extensions to Horn logic programs which he called near Horn logic programs. His main concern was efficient implementation [Lov87, SL88]. 15 For positive disjunctive logic programs this definition is similar to Minker's [Min82] original definition. <p> His main concern was efficient implementation <ref> [Lov87, SL88] </ref>. 15 For positive disjunctive logic programs this definition is similar to Minker's [Min82] original definition. For a precise relationship see Proposition 4.4. 33 Unlike extended logic programs without not, a disjunctive logic program without not may have more than one answer sets.
Reference: [LS89] <author> F. Lin and Y. Shoham. </author> <title> Argument systems: a uniform basis for nonmonotonic reasoning. </title> <editor> In R. Brachman, H. Levesque, and R. Reiter, editors, </editor> <booktitle> Proc. of the First Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 245-255, </pages> <year> 1989. </year>
Reference-contexts: The stronger result establishes a one-to-one correspondence between the stable models of an arbitrary general logic program and the stable expansions of ff (). Other mappings of logic programs into autoepistemic logic and its variants were investigated in [MT89], [Lif89] [Sch91], and <ref> [LS89] </ref> but none of these mappings seem to extend in a natural way to logic programs with classical negation and disjunction. Recently, several such mappings were independently found by several researchers [LS93], [MT93], [Che93].
Reference: [LS90] <author> F. Lin and Y. Shoham. </author> <title> Epistemic semantics for fixed-points nonmonotonic logics. </title> <editor> In R. Parikh, editor, </editor> <booktitle> Theoretical Aspects of Reasoning and Knowledge: Proc. of the Third Conf., </booktitle> <pages> pages 111-120, </pages> <institution> Stanford University, Stanford, </institution> <address> CA, </address> <year> 1990. </year> <month> 83 </month>
Reference-contexts: out important classes of theories such as stratified autoepistemic theories and their variants, with comparatively good computational and other properties but also led to the development of new versions of basic formalisms, such as "default theories" [LY91, PP92], disjunctive defaults [GLPT91], reflexive autoepistemic logic [Sch91], introspective circumscription [Lif89], and MBNF <ref> [Lif91, LS90] </ref>, to mention only a few. Many of these formalisms are new, and we are in the beginning stages of evaluating their utility to knowledge representation, but their role in gaining a much better understanding of commonsense reasoning cannot be seriously disputed.
Reference: [LS92] <author> F. Lin and Y. Shoham. </author> <title> A logic of knowledge and justified assumptions. </title> <journal> Artificial Intelligence, </journal> <volume> 57 </volume> <pages> 271-290, </pages> <year> 1992. </year>
Reference-contexts: Moreover, every stable expansion of fi () can be represented in the above form. 2 There are similar results describing mappings of disjunctive databases into reflexive au-toepistemic logic [Sch91] and a logic of minimal belief and negation as failure called M BN F [LW92], <ref> [LS92] </ref>. 9.2 Defaults and Logic Programming A default is an expression of the form F G : M H 1 ; : : : ; M H k ; (22) where F; G; H 1 ; : : : ; H k (k 0) are quantifier-free formulas 22 .
Reference: [LS93] <author> V. Lifschitz and G. Schwarz. </author> <title> Extended logic programs as autoepistemic theories. </title> <booktitle> In Proceedings of the Second Int'l Workshop on Logic Programming and Non-monotonic Reasoning, Lisbon, </booktitle> <pages> pages 101-114, </pages> <year> 1993. </year>
Reference-contexts: Other mappings of logic programs into autoepistemic logic and its variants were investigated in [MT89], [Lif89] [Sch91], and [LS89] but none of these mappings seem to extend in a natural way to logic programs with classical negation and disjunction. Recently, several such mappings were independently found by several researchers <ref> [LS93] </ref>, [MT93], [Che93].
Reference: [LW92] <author> V. Lifschitz and T. Woo. </author> <title> Answer sets in general nonmonotonic reasoning. </title> <booktitle> In Proc. of the Third Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 603-614, </pages> <year> 1992. </year>
Reference-contexts: Moreover, every stable expansion of fi () can be represented in the above form. 2 There are similar results describing mappings of disjunctive databases into reflexive au-toepistemic logic [Sch91] and a logic of minimal belief and negation as failure called M BN F <ref> [LW92] </ref>, [LS92]. 9.2 Defaults and Logic Programming A default is an expression of the form F G : M H 1 ; : : : ; M H k ; (22) where F; G; H 1 ; : : : ; H k (k 0) are quantifier-free formulas 22 . <p> It also helps to avoid another problem associated with the use of superclassical logics: existence of several natural, but nonequivalent translations from natural language statements into the formalism. Consider for instance Example 4.2. Simple disjunctive statement "Matt's left or right hand is broken" can be translated in, say, MBNF <ref> [LW92] </ref>, as lh broken _ rh broken or as B lh broken _ B rh broken where B is the belief operator of MBNF. Only the second translation (probably the less obvious one) leads to the correct result. There are of course many remaining problems.
Reference: [LY91] <author> L. Li and J. </author> <title> You. Making default inferences from logic programs. </title> <journal> Journal of Computational Intelligence, </journal> <volume> 7 </volume> <pages> 142-153, </pages> <year> 1991. </year>
Reference-contexts: It not only helped to single out important classes of theories such as stratified autoepistemic theories and their variants, with comparatively good computational and other properties but also led to the development of new versions of basic formalisms, such as "default theories" <ref> [LY91, PP92] </ref>, disjunctive defaults [GLPT91], reflexive autoepistemic logic [Sch91], introspective circumscription [Lif89], and MBNF [Lif91, LS90], to mention only a few.
Reference: [MB88] <author> R. Manthey and F. Bry. </author> <title> SATCHMO: A theorem prover implemented in PRO-LOG. </title> <editor> In E.L. Lusk and R.A. Overbeek, editors, </editor> <booktitle> Proc. of CADE 9, </booktitle> <pages> pages 415-434, </pages> <year> 1988. </year>
Reference-contexts: superscript and the atoms with predicate x. i.e. the answer sets of are fperson (a); :lh usable (a); ab 1 (a); rh usable (a)g and fperson (a); :rh usable (a); ab 2 (a); lh usable (a)g. 2 Answer sets of disjunctive logic programs can be obtained using model generation techniques <ref> [BS85, FM91, FH91, FM92, MB88] </ref>. Inoue et al. [IKH92] extend the model generation theorem prover (MGTP) [FH91] to compute the answer sets of the program obtained using tr 2 .
Reference: [McC59] <author> J. McCarthy. </author> <title> Programs with common sense. </title> <booktitle> In Proc. of the Teddington Conference on the Mechanization of Thought Processes, </booktitle> <pages> pages 75-91, </pages> <address> London, </address> <year> 1959. </year> <institution> Her Majesty's Stationery Office. </institution>
Reference-contexts: Around 1960, McCarthy <ref> [McC59] </ref> first proposed the use of logical formulas as a basis for a knowledge representation language of this type. This is how he explains the advantages of such a representation: Expressing information in declarative sentences is far more modular than expressing it in segments of computer programs or in tables. <p> The rest of the paper is organized as follows. In Section 2 we consider general logic programs (also known as normal logic programs) and show how general logic programs can be used to represent knowledge in AI. In particular we consider McCarthy's <ref> [McC59] </ref> example of flying birds and the Yale shooting problem [HM87] and show their formalization using general logic programs. We also discuss formalization of normative statements 1 of the kind "A's are normally B's" using general logic programs. <p> The following story is due to McCarthy <ref> [McC59] </ref>. 8 Suppose that a reasoning agent has the following knowledge about birds: birds typically fly and penguins are non-flying birds. He also knows that Tweety is a bird.
Reference: [McC80] <author> J. McCarthy. </author> <title> Circumscription|a form of non-monotonic reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1, </volume> 2):27-39,171-172, 1980. 
Reference-contexts: Commonsense reasoning is nonmonotonic: new information constantly forces us to withdraw previous conclusions. This observation has led to the development and investigation of new logical formalisms, nonmonotonic logics. The best known of them are circumscription <ref> [McC80, McC86, Lif85b] </ref>, default logic [Rei80b], and nonmonotonic modal logics [MD80, McD82, Moo85]. A collection of important papers on nonmonotonic reasoning published before 1987 appears in [Gin87]. A survey can be found in [Rei87a]. <p> understanding between the two approaches. 63 9 Relating logic programming and other nonmono- tonic formalisms In this section, we will briefly discuss the relationship between the logic programming-based formalisms discussed in the previous sections and various nonmonotonic logics (for a review see [Rei87a]) developed in artificial intelligence, such as circumscription <ref> [McC80] </ref>, default logic [Rei80b] and autoepistemic logic [Moo85]. Even though some affinity between logic programs and nonmonotonic logics was recognized rather early [Rei82], [Lif85a], the intensive work in this direction started in 1987 after the discovery of model theoretic semantics for stratified logic programs [Apt89].
Reference: [McC86] <author> J. McCarthy. </author> <title> Applications of circumscription to formalizing common sense knowledge. </title> <journal> Artificial Intelligence, </journal> <volume> 26(3) </volume> <pages> 89-116, </pages> <year> 1986. </year>
Reference-contexts: Commonsense reasoning is nonmonotonic: new information constantly forces us to withdraw previous conclusions. This observation has led to the development and investigation of new logical formalisms, nonmonotonic logics. The best known of them are circumscription <ref> [McC80, McC86, Lif85b] </ref>, default logic [Rei80b], and nonmonotonic modal logics [MD80, McD82, Moo85]. A collection of important papers on nonmonotonic reasoning published before 1987 appears in [Gin87]. A survey can be found in [Rei87a].
Reference: [McD82] <author> D. McDermott. </author> <title> Nonmonotonic logic II: Nonmonotonic modal theories. </title> <journal> Journal of the ACM., </journal> <volume> 29(1) </volume> <pages> 33-57, </pages> <year> 1982. </year>
Reference-contexts: Commonsense reasoning is nonmonotonic: new information constantly forces us to withdraw previous conclusions. This observation has led to the development and investigation of new logical formalisms, nonmonotonic logics. The best known of them are circumscription [McC80, McC86, Lif85b], default logic [Rei80b], and nonmonotonic modal logics <ref> [MD80, McD82, Moo85] </ref>. A collection of important papers on nonmonotonic reasoning published before 1987 appears in [Gin87]. A survey can be found in [Rei87a].
Reference: [MD80] <author> D. McDermott and J. Doyle. </author> <title> Nonmonotonic logic I. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1,2):41-72, </volume> <year> 1980. </year>
Reference-contexts: Commonsense reasoning is nonmonotonic: new information constantly forces us to withdraw previous conclusions. This observation has led to the development and investigation of new logical formalisms, nonmonotonic logics. The best known of them are circumscription [McC80, McC86, Lif85b], default logic [Rei80b], and nonmonotonic modal logics <ref> [MD80, McD82, Moo85] </ref>. A collection of important papers on nonmonotonic reasoning published before 1987 appears in [Gin87]. A survey can be found in [Rei87a].
Reference: [MD93] <author> D. De Schreye and M. Denecker. </author> <title> Representing incomplete knowledge in abductive logic programming, 1993. </title> <type> manuscript. </type>
Reference-contexts: This methodology is, of course, rather general, and can be applied to any weak exception to an arbitrary default. 2 Example 8.5 <ref> [MD93] </ref> In our next example, we consider an abductive logic program for the Yale shooting problem from Example 2.6.
Reference: [MDS92a] <author> B. Martens and D. De Schreye. </author> <title> A Perfect Herbrand Semantics for Untyped Vanilla Meta-Programming. </title> <booktitle> In Proc. of the Joint International Conference and Symposium on Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: The resulting program I is called (untyped) vanilla interpreter for . Notice, that terms of the language of I are build from atoms of the language of , constant empty, and two function symbols not and &. In analysis of this program we will follow <ref> [MDS92a, MDS92b] </ref>. Since we use a stable model semantics we should first prove that I has a stable model. Notice that I is neither stratified nor locally stratified. <p> In analysis of this program we will follow [MDS92a, MDS92b]. Since we use a stable model semantics we should first prove that I has a stable model. Notice that I is neither stratified nor locally stratified. It is possible to show however <ref> [MDS92a] </ref> that for any stratified program , I is weakly stratified and hence categorical, i.e. has a unique stable model [PP90b]. This implies that at least for stratified programs we should not worry about existence of reasonable semantics for their vanilla meta-interpreters. So let us assume that is stratified. <p> Despite this problem vanilla meta-interpreters are frequently and successfully used in practice. We discuss the explanation of this phenomena provided in <ref> [MDS92a] </ref>, where the authors define a broad class of programs for which the above definition of demo is semantically correct. We give a slightly less general formulation here. <p> It is probably fair to say that the vast majority of logic programs used in practical applications are range restricted. This observation explains the importance of the following Theorem 6.1 <ref> [MDS92a] </ref> Let be a stratified, range restricted program.
Reference: [MDS92b] <author> B. Martens and D. De Schreye. </author> <title> Why untyped non-ground meta-programming is not (much of) a problem. </title> <type> Technical report, </type> <institution> Department of Comp. Science, Katholieke Universiteit Leuven, Belgium, </institution> <year> 1992. </year>
Reference-contexts: The resulting program I is called (untyped) vanilla interpreter for . Notice, that terms of the language of I are build from atoms of the language of , constant empty, and two function symbols not and &. In analysis of this program we will follow <ref> [MDS92a, MDS92b] </ref>. Since we use a stable model semantics we should first prove that I has a stable model. Notice that I is neither stratified nor locally stratified. <p> To deal with such programs one should address a basic problem associated with their meaning. The problem is caused by overloading the symbols in the language. Clearly, the predicate symbols of 1 occur both as predicate and function symbol in 2 . <ref> [MDS92b] </ref> argues that for a broad class of programs this does not cause a problem. Apparently, the program above belongs to this class. It will be interesting to generalize this statement to programs from [BM90] and carefully investigate the relationship between the two approaches.
Reference: [Met92] <institution> Meta 92, Uppsala, </institution> <address> Sweeden. </address> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: The literature on the subject is vast. Interesting meta-programs can be found in various textbooks on logic programming. Several workshop proceedings contain papers addressing theoretical problems related to meta-programming <ref> [AR89, Met92] </ref>. Logic programming languages based on the ideas of meta-programming such as Godel [HL91], Hilog [CKW93], Reflexive Prolog [CL89] among others are beginning to gain ground in logic programming community. In this paper we will not even attempt to mention all directions of research related to meta-programming.
Reference: [MH69] <author> J. McCarthy and P. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> volume 4, </volume> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, Edinburgh, </publisher> <year> 1969. </year> <month> 84 </month>
Reference-contexts: The most frequently cited example of such reasoning is probably the Yale Shooting Problem (YSP) from [HM87]. The original formalization of the problem uses the language of situation calculus <ref> [MH69] </ref>. (An alternative approach can be found in [KS86].) The syntax of the language contains variables of three sorts: situation variables S; S 0 ; : : :; fluent variables F; F 0 ; : : :; 3 and action variables A; A 0 ; : : : 4 Its only <p> Moreover, when we speak of an instance of a rule, it will be always assumed that the terms substituted for variables are of the appropriate sorts. 10 is based on the so-called axiom of inertia which says, "Things normally tend to stay the same. <ref> [MH69] </ref>" This is a typical normative statement, which in accordance with (3), can be represented by the rule: y 1 : holds (F; res (A; S)) holds (F; S); not ab (y 1 ; A; F; S) To represent the effect of the actions load, shoot and wait, we need only
Reference: [Mil86] <author> D. Miller. </author> <title> A theory of modules in logic programming. </title> <booktitle> In Proc. of IEEE Sympo--sium on Logic Programming, </booktitle> <pages> pages 106-114, </pages> <year> 1986. </year>
Reference-contexts: Intuitionistic semantics for such programs can be found in <ref> [Mil86, BM90, GO92] </ref>. Roughly speaking, to establish the derivability of near grad (s) in the corresponding intuitionistic program 1 under this semantic one should add the rule take (s; c) to 1 and then try to prove grad (s).
Reference: [Min82] <author> J. Minker. </author> <title> On indefinite data bases and the closed world assumption. </title> <booktitle> In Proc. of CADE-82, </booktitle> <pages> pages 292-308, </pages> <year> 1982. </year>
Reference-contexts: It became apparent, on the other hand, that in order to become satisfactory tools for knowledge representation, logic programming languages should be expanded to allow for better handling of incomplete information. Work in this direction was started by Minker <ref> [Min82] </ref>, Loveland [Lov87] and others, who investigated the possibility of expanding logic programs by disjunctive information. In [GL90, PW89, Gel92b], extensions of logic programming by classical (or strong) negation and epistemic operators were suggested. <p> Minker pioneered the use of disjunctions in the context of logic programming. 14 In <ref> [Min82] </ref> he considers positive disjunctive logic programs defined as collections of first-order clauses of the form B 1 ^ : : : ^ B m A 1 _ : : : _ A n (18) where A 0 s and B 0 s are atoms. <p> The type of incompleteness expressible in these logic programs is, however, rather limited since their semantics suggested in <ref> [Min82] </ref> is closely related to the notion of minimal model and implicitly assumes a form of the closed world assumption. <p> His main concern was efficient implementation [Lov87, SL88]. 15 For positive disjunctive logic programs this definition is similar to Minker's <ref> [Min82] </ref> original definition. For a precise relationship see Proposition 4.4. 33 Unlike extended logic programs without not, a disjunctive logic program without not may have more than one answer sets. For example the program p (a) or p (b) has two answer sets fp (a)g and fp (b)g. <p> Inoue et al. [IKH92] extend the model generation theorem prover (MGTP) [FH91] to compute the answer sets of the program obtained using tr 2 . Their method avoids using the intermediate atoms X i 's. 4.3 Other Approaches to Disjunctive Logic Programs Minker <ref> [Min82] </ref> defines the model theoretic semantics for positive disjunctive logic programs (viewed as first-order clauses of the form (18)) based on minimal Herbrand models. <p> A ground atom is called free for negation in T if it does not belong to any clause essential in T . Let T be the set of negations of all ground atoms free for negation in T . Then GCWA (T ) = T : 40 Minker <ref> [Min82] </ref> proves that for T with finite number of constants and no function symbols, T [ GCW A (T ) classically entails a literal q iff q is true in all minimal Herbrand models of T . This result was extended to arbitrary T in [GP86, She88]. <p> polynomial (co-N P -complete again if heads can be empty), (c) the decision problem for under the careful CWA [GP86] is P 2 -hard and in P 3 [O (log n)], (d) the decision problem for is P 2 -complete for the following semantics [EG93a, EG93c, EG93d]: the generalized CWA <ref> [Min82] </ref>, the extended generalized CWA [YH85], the extended CWA [GPP89], the iterated CWA [GPP89], the perfect model semantics [Prz88b], and the partial as well as total disjunctive stable model semantics [Prz91]. 2 Here P 2 and P 3 [O (log n)] are classes above coN P (= P 1 ) in
Reference: [Min88] <editor> J. Minker, editor. </editor> <booktitle> Foundations of Deductive Databases and Logic Programming. </booktitle> <publisher> Morgan Kaufmann Pub., </publisher> <year> 1988. </year>
Reference-contexts: Almost immediately after this notion was introduced, stratified logic programs were mapped into the three major nonmonotonic formalisms investigated at that time: circumscription [Lif88],[Prz88a], autoepistemic logic [Gel87] and default theories [BF91], [MT89]. Research in this area was stimulated by the workshop on Foundations of Deductive Databases and Logic Programming <ref> [Min88] </ref> and by the workshops on Logic Programming and Nonmonotonic Reasoning [NMS91, PN93]. Collection of important papers can also be found in the forthcoming special issue of Journal of Logic Programming devoted to "logic programming and nonmonotonic reasoning".
Reference: [Min93] <author> J. Minker. </author> <title> An overview of nonmonotonic reasoning and logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 17(2,3,4):95-126, </volume> <year> 1993. </year>
Reference-contexts: Collection of important papers can also be found in the forthcoming special issue of Journal of Logic Programming devoted to "logic programming and nonmonotonic reasoning". This issue includes a recent overview on the relations between logic programming and nonmonotonic reasoning <ref> [Min93] </ref> and an article on performing nonmonotonic reasoning with logic programming [PAA]. This direction of research proved to be fruitful for logic programming as well as for artificial intelligence. The results uncovered deep similarities between various, seemingly different, approaches to formalization of nonmonotonic reasoning.
Reference: [MNR93] <author> W. Marek, A. Nerode, and J. Remmel. </author> <title> A theory of nonmonotonic systems-II. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <note> 1993. To appear. </note>
Reference-contexts: This result implies correctness of the above definition of assimilate for stratified, range restricted programs. Most likely it can be pushed a little further. <ref> [MNR93] </ref> uses more general condition than range restriction. Stratified programs can be replaced by weakly stratified programs, or possibly, a suitable three valued version of demo can be designed for arbitrary range restricted programs under well-founded semantics. Let us now look at a slightly more complicated example. <p> Definition 10.3 A set s of natural numbers is 1 1 ( 1 2 ) definable if it satisfies 8n (s (n) (n)) where formula is 1 1 ( 1 The following theorem [Sch90] <ref> [MNR93] </ref> characterizes the expressibility of the stable model semantics of logic programs over natural numbers Theorem 10.2 [Sch90],[MNR93] A set s of natural numbers is 1 1 definable iff s is definable by a logic program under the stable model semantics. 2 The actual results of [Sch90], [MNR93], and [AB90] are <p> following theorem [Sch90] <ref> [MNR93] </ref> characterizes the expressibility of the stable model semantics of logic programs over natural numbers Theorem 10.2 [Sch90],[MNR93] A set s of natural numbers is 1 1 definable iff s is definable by a logic program under the stable model semantics. 2 The actual results of [Sch90], [MNR93], and [AB90] are stronger than the above theorem. Instead of definability of sets of natural numbers, these papers deal with definability over arbitrary infinite Herbrand universes. <p> The following results demonstrate the decrease in expressive power caused by additional restrictions on the classes of logic programs under consideration: Theorem 10.3 <ref> [MNR93] </ref> A set s of natural numbers is definable by a logic program with a unique stable model iff s is 1 1 , i.e., s and its complement are 1 1 definable. 2 It is known that 1 1 is strictly smaller than 1 1 , but is still highly
Reference: [Moo85] <author> R. Moore. </author> <title> Semantical Considerations on Nonmonotonic Logic. </title> <journal> Artificial Intelligence, </journal> <volume> 25(1) </volume> <pages> 75-94, </pages> <year> 1985. </year>
Reference-contexts: Commonsense reasoning is nonmonotonic: new information constantly forces us to withdraw previous conclusions. This observation has led to the development and investigation of new logical formalisms, nonmonotonic logics. The best known of them are circumscription [McC80, McC86, Lif85b], default logic [Rei80b], and nonmonotonic modal logics <ref> [MD80, McD82, Moo85] </ref>. A collection of important papers on nonmonotonic reasoning published before 1987 appears in [Gin87]. A survey can be found in [Rei87a]. <p> The well-founded semantics is an extension of the perfect model semantics, unlike Fitting and Jacob's semantics. The third approach is analogous to the traditional approach in Reiter's default logic [Rei80b] and Moore's autoepistemic logic <ref> [Moo85] </ref> in which the definition of entailment is based on the notion of beliefs. The stable model semantics [GL88] used in this paper is based on this approach. In [BS92], Baral and Subrahamanian introduce the concept of stable classes as a generalization of the stable models. <p> Relating logic programming and other nonmono- tonic formalisms In this section, we will briefly discuss the relationship between the logic programming-based formalisms discussed in the previous sections and various nonmonotonic logics (for a review see [Rei87a]) developed in artificial intelligence, such as circumscription [McC80], default logic [Rei80b] and autoepistemic logic <ref> [Moo85] </ref>. Even though some affinity between logic programs and nonmonotonic logics was recognized rather early [Rei82], [Lif85a], the intensive work in this direction started in 1987 after the discovery of model theoretic semantics for stratified logic programs [Apt89]. <p> In what follows, we will briefly discuss some of these results. Results relating logic programs with different semantics to various modifications of original nonmonotonic theories can be found in [PAA92a, Prz89c] among others. 64 9.1 Autoepistemic Logic and Logic Programming We will start with an autoepistemic logic <ref> [Moo85] </ref> whose formulas are built from propositional atoms using propositional connectives and the modal operator B.
Reference: [Mor88] <author> P. Morris. </author> <title> The anomalous extension problem in default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 35(3) </volume> <pages> 383-399, </pages> <year> 1988. </year>
Reference-contexts: Some of the later solutions, in particular those from [Gel89], and <ref> [Mor88] </ref>, were given in the language of autoepistemic logic and non-normal default theory respectively, and are similar to the one presented here. Representing inheritance reasoning and reasoning about actions in logic programming is an active area of research [GL92, BG93, Dun93b, PR93, Esh88, DMB92, KS86].
Reference: [MR90] <author> J. Minker and A. Rajasekar. </author> <title> A Fixpoint Semantics for Disjunctive Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 9(1) </volume> <pages> 45-74, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: D apparently satisfies the specification and may be used with any collection of facts formed by predicate symbols p and a. 2 4.2 Answering Queries There has been considerable research in developing query answering methods for positive disjunctive programs <ref> [MZ82, MR90, FM91, LMR92, HP88] </ref>. It should be noted that for positive programs minimal models coincides with answer sets.
Reference: [MR93] <author> J. Minker and C. Ruiz. </author> <title> On extended disjunctive logic programs. </title> <booktitle> In ISMIS, </booktitle> <year> 1993. </year> <type> invited paper. </type>
Reference-contexts: Some of the other interesting semantics of normal disjunctive programs suggested in the literature are the extended well-founded semantics of Ross [Ros89], stationary semantics by Przymusinski [Prz90b] and the possible world semantics by Sakama [Sak89]. Minker and Ruiz <ref> [MR93] </ref> discuss extensions of the various semantics of normal disjunctive logic programs to disjunctive logic programs (They refer to it as extended disjunctive logic programs.). The following examples give a flavor of the differences between the various semantics of disjunctive logic programs.
Reference: [MS89] <author> W. Marek and V.S. Subrahmanian. </author> <title> The relationship between logic program semantics and non-monotonic reasoning. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Proc. of the Sixth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 600-617, </pages> <year> 1989. </year>
Reference-contexts: Theorem 2.3 [Fag90] A call-consistent logic program whose dependency graph does not have a cycle with only positive edges has at least one stable model. 2 In our further discussion we will need the following Lemma about general logic programs. Lemma 2.4 <ref> [MS89] </ref> For any stable model S of a general logic program : (a) For any ground instance of a rule of the type (1) from , if fA 1 ; : : : ; A m g S and fA m+1 ; : : : ; A n g " S
Reference: [MT89] <author> W. Marek and M. Truszczynski. </author> <title> Stable semantics for logic programs and default reasoning. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proc. of the North American Conf. on Logic Programming, </booktitle> <pages> pages 243-257, </pages> <year> 1989. </year>
Reference-contexts: Almost immediately after this notion was introduced, stratified logic programs were mapped into the three major nonmonotonic formalisms investigated at that time: circumscription [Lif88],[Prz88a], autoepistemic logic [Gel87] and default theories [BF91], <ref> [MT89] </ref>. Research in this area was stimulated by the workshop on Foundations of Deductive Databases and Logic Programming [Min88] and by the workshops on Logic Programming and Nonmonotonic Reasoning [NMS91, PN93]. <p> The stronger result establishes a one-to-one correspondence between the stable models of an arbitrary general logic program and the stable expansions of ff (). Other mappings of logic programs into autoepistemic logic and its variants were investigated in <ref> [MT89] </ref>, [Lif89] [Sch91], and [LS89] but none of these mappings seem to extend in a natural way to logic programs with classical negation and disjunction. Recently, several such mappings were independently found by several researchers [LS93], [MT93], [Che93]. <p> Thus, the deductive closure operator establishes a one-to-one correspondence between the answer sets of a program and its extensions. This result is a simple extension of results from [BF91], and <ref> [MT89] </ref>. Perhaps somewhat surprisingly, it is not easily generalized to disjunctive databases.
Reference: [MT91] <author> W. Marek and M. Truszczynski. </author> <title> Autoepistemic logic. </title> <journal> Journal of the ACM., </journal> <volume> 3(38) </volume> <pages> 588-619, </pages> <year> 1991. </year>
Reference-contexts: A formula F is said to be true in T if F belongs to all stable expansions of T . If T does not contain the modal operator B, T has a unique stable expansion <ref> [MT91] </ref>. We will denote this expansion by T h (T ). <p> Then the following holds: Theorem 10.1 (a) the decision problem for stratified is O (jj) (follows from [DG84]), (b) the decision problem for under completion semantics and under stable model semantics is coN P complete ([KP87] and <ref> [MT91] </ref> respectively), and (c) the decision problem for under 3-valued program completion semantics and under the well-founded semantics is O (jj) and O (jj) fl jP j respectively (folklore). 2 Let us now consider programs with variables. <p> The corresponding complexity can be viewed as a function of the size of D. This is called data complexity. Theorem 10.5 <ref> [MT91] </ref> The data complexity of logic programs without function symbols under the stable model semantics is coN P complete. 2 Theorem 10.6 [VG89],[VGRS91].
Reference: [MT93] <author> W. Marek and M. Truszczynski. </author> <title> Reflexive autoepistemic logic and logic programming. </title> <booktitle> In Proceedings of the Second Int'l Workshop on Logic Programming and Non-monotonic Reasoning, Lisbon, </booktitle> <pages> pages 115-131. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Recently, several such mappings were independently found by several researchers [LS93], <ref> [MT93] </ref>, [Che93].
Reference: [Myc83] <author> A. Mycroft. </author> <title> Logic programs and many valued logics. </title> <booktitle> In Proc. of the 1st STACS conference, </booktitle> <year> 1983. </year>
Reference-contexts: Przymusinski [Prz88b] generalized the concept of stratification and introduced local stratification and perfect models. The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. The second approach <ref> [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] </ref> was to use three-valued logic instead of the classical 2-valued logic. <p> The second approach [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] was to use three-valued logic instead of the classical 2-valued logic. Fitting [FBJ88, Fit85, Fit86], Kunen [Kun87, Kun89] and others <ref> [LM85, Myc83] </ref> used Kleene's strong three-valued logic while Van Gelder, Ross and Schlifp [VGRS91] used a different three valued logic to give the well-founded semantics of a logic program. Przymusinski [Prz89a, Prz89d], Dung [Dun93a], Van Gelder [VG89], and many others gave alternative formalizations of the well-founded semantics.
Reference: [MZ82] <author> J. Minker and G. Zanon. </author> <title> An Extension to Linear Resolution with Selection Function. </title> <journal> Information Processing Letters, </journal> <volume> 14(3) </volume> <pages> 191-194, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: D apparently satisfies the specification and may be used with any collection of facts formed by predicate symbols p and a. 2 4.2 Answering Queries There has been considerable research in developing query answering methods for positive disjunctive programs <ref> [MZ82, MR90, FM91, LMR92, HP88] </ref>. It should be noted that for positive programs minimal models coincides with answer sets.
Reference: [Nel49] <author> D. Nelson. </author> <title> Constructible falsity. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 14 </volume> <pages> 16-26, </pages> <year> 1949. </year> <month> 85 </month>
Reference-contexts: As was shown by Pearce and Wagner, this negation has close ties with constructive negation of Nelson <ref> [Nel49] </ref>. 12 For any literal l, the symbol l denotes the literal opposite in sign to l. i.e. for an atom a, if l = :a then l = a, and if l = a then l = :a. 20 Definition 3.1 Let be an extended logic program without variables.
Reference: [NMS91] <editor> A. Nerode, W. Marek, and V. S. Subrahamanian, editors. </editor> <booktitle> Logic Programming and Non-monotonic Reasoning: Proceedings of the First International Workshop. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Research in this area was stimulated by the workshop on Foundations of Deductive Databases and Logic Programming [Min88] and by the workshops on Logic Programming and Nonmonotonic Reasoning <ref> [NMS91, PN93] </ref>. Collection of important papers can also be found in the forthcoming special issue of Journal of Logic Programming devoted to "logic programming and nonmonotonic reasoning".
Reference: [PA93] <author> L. Pereira and J. Alferes. </author> <title> Optative reasoning with scenario semantics. </title> <booktitle> In Proceedings of ICLP 93, Hungary, </booktitle> <pages> pages 601-619, </pages> <year> 1993. </year>
Reference-contexts: This can be achieved by expanding 4 by new statements q not q and :q not :q. The resulting program 5 entails (w.r.t. the -well-founded semantics) :p and s and infers p to be f alse. The last idea is developed to a considerable length in <ref> [PAA91a, PA93] </ref>. 13 Abducible literals are literals that can be assumed true if necessary.
Reference: [PAA] <author> L. Pereira, J. Alferes, and J. Aparicio. </author> <title> Nonmonotonic reasoning with logic programming. </title> <journal> Journal of Logic Programming, 17(2,3,4):227-264,1993. </journal>
Reference-contexts: We will use it throughout the paper. There is a vast literature on representing inheritance hierarchies using nonmonotonic formalisms (For a survey see [Hor]). Representing inheritance hierarchies using logic programs is discussed in <ref> [GP90, Lin91, PAA, PAA91c] </ref>. We conclude this section with a brief discussion of the application of general logic programs to the formalization of reasoning about results of actions. <p> More examples and discussions on the subject can be found in [GL91], [PAA91a], [KS90], <ref> [PAA] </ref>. Example 3.1 Let us go back to the bird's story from Example 2.5 in which we knew that birds typically fly, that penguins are exceptions to this rule they are non-flying birds and that our information about penguins, birds and flying objects is complete. <p> This issue includes a recent overview on the relations between logic programming and nonmonotonic reasoning [Min93] and an article on performing nonmonotonic reasoning with logic programming <ref> [PAA] </ref>. This direction of research proved to be fruitful for logic programming as well as for artificial intelligence. The results uncovered deep similarities between various, seemingly different, approaches to formalization of nonmonotonic reasoning.
Reference: [PAA91a] <author> L. Pereira, J. Aparicio, and J. Alferes. </author> <title> Contradiction removal within well-founded semantics. </title> <editor> In Anil Nerode, Victor Marek, and Subramanian V. S., editors, </editor> <booktitle> Logic Programming and Non-monotonic Reasoning: Proc. of the First Int'l Workshop, </booktitle> <pages> pages 105-119. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: SLDNF resolution, though sound [Cla78], is only complete for a subclass of stratified programs [JLL83]. Various practical Prolog systems have been developed based on SLDNF resolution. To answer queries with respect to programs with a multiple number of stable models, several approaches have been suggested <ref> [PAA91a, BNNS94, FLMS93, SZ90, IKH92, WC93, EK89] </ref> in the literature. <p> More examples and discussions on the subject can be found in [GL91], <ref> [PAA91a] </ref>, [KS90], [PAA]. Example 3.1 Let us go back to the bird's story from Example 2.5 in which we knew that birds typically fly, that penguins are exceptions to this rule they are non-flying birds and that our information about penguins, birds and flying objects is complete. <p> The -well-founded semantics is given by ffc; :bg; fc; a; :bgg. 2 Before we end this section we would like to briefly mention another class of semantics of extended logic programs based on contradiction removal <ref> [Dun91b, Wag93, PAA91a, GM90] </ref>. To illustrate the problem let us consider the program 4 : 1. p not q 3. s Obviously, under the answer set semantics this program is inconsistent. <p> This can be achieved by expanding 4 by new statements q not q and :q not :q. The resulting program 5 entails (w.r.t. the -well-founded semantics) :p and s and infers p to be f alse. The last idea is developed to a considerable length in <ref> [PAA91a, PA93] </ref>. 13 Abducible literals are literals that can be assumed true if necessary.
Reference: [PAA91b] <author> L. Pereira, J. Aparicio, and J. Alferes. </author> <title> Derivation procedures for extended stable models. </title> <booktitle> In Proceedings of IJCAI 91, </booktitle> <pages> pages 863-870, </pages> <year> 1991. </year>
Reference-contexts: Very promising work in this direction is done by Pereira et al. <ref> [PAA91b] </ref>, Chen and Warren [WC93] and others. Some of the other important issues are to learn to deal with floundering queries and planning problems, and to incorporate new logic programming paradigms such as constrained logic programming and concurrent logic programming in the nonmonotonic framework.
Reference: [PAA91c] <author> L. Pereira, J. Aparicio, and J. Alferes. </author> <title> Non-monotonic reasoning with well-founded semantics. </title> <booktitle> In Proc. of the Eight International Logic Programming Conference, </booktitle> <pages> pages 475-489, </pages> <year> 1991. </year>
Reference-contexts: We will use it throughout the paper. There is a vast literature on representing inheritance hierarchies using nonmonotonic formalisms (For a survey see [Hor]). Representing inheritance hierarchies using logic programs is discussed in <ref> [GP90, Lin91, PAA, PAA91c] </ref>. We conclude this section with a brief discussion of the application of general logic programs to the formalization of reasoning about results of actions. <p> Several other semantics of extended logic programs are suggested in the literature <ref> [AP92, PAA91c, PAA92a, PAA92b, Prz90a, KS90] </ref>. We now discuss some of them. The formulation of well-founded semantics of general logic programs in [BS91] can be extended to define the well-founded semantics [Prz90a] of extended logic programs. More precisely, let us consider G (S) = b ( S ). <p> In <ref> [PAA91c] </ref>, similar transformation under the -well-founded semantics is investigated. 8.3 Combining Explanation and Deduction In this section we introduce an entailment relation for abductive logic programs based on the notion of generalized stable model and briefly discuss its use for knowledge representation 21 .
Reference: [PAA92a] <author> L. Pereira, J. Alferes, and J. Aparicio. </author> <title> Default theory for well founded semantics with explicit negation. </title> <editor> In D. Pearce and G. Wagner, editors, </editor> <booktitle> Logic in AI, Proc. of European Workshop JELLA'92 (Lecture Notes in AI, </booktitle> <volume> 633), </volume> <pages> pages 339-356, </pages> <year> 1992. </year>
Reference-contexts: Several other semantics of extended logic programs are suggested in the literature <ref> [AP92, PAA91c, PAA92a, PAA92b, Prz90a, KS90] </ref>. We now discuss some of them. The formulation of well-founded semantics of general logic programs in [BS91] can be extended to define the well-founded semantics [Prz90a] of extended logic programs. More precisely, let us consider G (S) = b ( S ). <p> A literal l is true (resp. f alse) w.r.t. the well-founded semantics of an extended logic program if l 2 lf p (G 2 ) (resp. l 62 gf p (G 2 )). Otherwise l is said to be undef ined. Pereira et al. <ref> [PAA92a] </ref> show that this definition gives unintuitive characterizations for several programs. Example 3.6 Consider the program 0 a not b :a The well-founded semantics infers :a to be true and a and b to be unknown with respect to the above program. <p> a not :a The well-founded semantics infers b to be true with respect to 1 and infers b to be undef ined with respect to 1 [ 2 even though 2 does not have b in its language. 2 To overcome the unintuitiveness of the well-founded semantics Pereira et al. <ref> [PAA92a] </ref> propose an alternative semantics of extended logic programs which we refer to as the -well-founded semantics. We now define the -well-founded semantics. 30 Definition 3.3 [PAA92a] Let be an extended logic program. <p> [ 2 even though 2 does not have b in its language. 2 To overcome the unintuitiveness of the well-founded semantics Pereira et al. <ref> [PAA92a] </ref> propose an alternative semantics of extended logic programs which we refer to as the -well-founded semantics. We now define the -well-founded semantics. 30 Definition 3.3 [PAA92a] Let be an extended logic program. <p> S () the seminormal ver-sion of is obtained by replacing each rule of the form (7) by the rule: L 0 L 1 ; : : : ; L m ; not L m+1 ; : : : ; not L n ; not :L 0 (17) Definition 3.4 <ref> [PAA92a] </ref> For any extended logic program , the function is defined as (X) = G (G S () (X)) 2 Definition 3.5 [PAA92a] A set of literals E is said to be an -extension of an extended logic program iff 1. E is a fixpoint of . 3. <p> L 1 ; : : : ; L m ; not L m+1 ; : : : ; not L n ; not :L 0 (17) Definition 3.4 <ref> [PAA92a] </ref> For any extended logic program , the function is defined as (X) = G (G S () (X)) 2 Definition 3.5 [PAA92a] A set of literals E is said to be an -extension of an extended logic program iff 1. E is a fixpoint of . 3. E is a subset of (G S () (E)) 2 Pereira et al. [PAA92a] show that if an extended logic program has an -extension then <p> as (X) = G (G S () (X)) 2 Definition 3.5 <ref> [PAA92a] </ref> A set of literals E is said to be an -extension of an extended logic program iff 1. E is a fixpoint of . 3. E is a subset of (G S () (E)) 2 Pereira et al. [PAA92a] show that if an extended logic program has an -extension then is a monotonic function and hence has a least fixpoint. The -well-founded semantics is defined as flf p ( ); G S () (lf p ( ))g. <p> Otherwise l is undef ined. Example 3.8 <ref> [PAA92a] </ref> Consider the following program 3 c not b a not a The above program has fc; :bg as the only -extension. <p> In what follows, we will briefly discuss some of these results. Results relating logic programs with different semantics to various modifications of original nonmonotonic theories can be found in <ref> [PAA92a, Prz89c] </ref> among others. 64 9.1 Autoepistemic Logic and Logic Programming We will start with an autoepistemic logic [Moo85] whose formulas are built from propositional atoms using propositional connectives and the modal operator B.
Reference: [PAA92b] <author> L. Pereira, J. Alferes, and J. Aparicio. </author> <title> Well founded semantics for logic programs with explicit negation. </title> <booktitle> In Proc. of European Conference on AI, </booktitle> <year> 1992. </year>
Reference-contexts: To do that the language should allow for a third possibility the unknown answer, which corresponds to the inability to conclude yes or no. In this section, we discuss "extended" logic programs (ELP's) [GL91] (See also <ref> [Wag91, PAA92b, PW89] </ref>) that contain a second type of negation : (called "classical", "strong" or "explicit" by different authors who associate different meanings to it) 11 in addition to negation-as-failure not. General logic programs provide negative information implicitly, through closed-world reasoning; an extended logic program can include explicit negative information. <p> Several other semantics of extended logic programs are suggested in the literature <ref> [AP92, PAA91c, PAA92a, PAA92b, Prz90a, KS90] </ref>. We now discuss some of them. The formulation of well-founded semantics of general logic programs in [BS91] can be extended to define the well-founded semantics [Prz90a] of extended logic programs. More precisely, let us consider G (S) = b ( S ).
Reference: [PC89] <author> S. Pimental and J. Cuadrado. </author> <title> A truth maintenance system based on stable models. </title> <booktitle> In Proc. North American Conference on Logic Programming, </booktitle> <year> 1989. </year>
Reference-contexts: For a precise definition see [Llo87]. 12 and top-down methods. Bell et al. [BNNS94] present an approach to compute the stable models by constructing a linear programming problem from the program and solving the linear programming problem. In [Esg90], <ref> [PC89] </ref> truth maintenance systems are used to compute the stable models of a general program. Fernandez and Lobo [FL92] propose an almost top-down proof procedure to find answers to queries with respect to the stable model semantics. <p> The following theorem establishes the relationship between TMSs and logic programs: Proposition 9.3 [Elk90] M is a grounded model of a collection of justifications iff it is a stable model of a program fl . Similar results were obtained in [WB93], [GM90], <ref> [PC89] </ref>, [RM89], and [FH89]. (The last two papers use autoepistemic logic instead of logic programs).
Reference: [Pea87] <author> J. Pearl. </author> <title> Embracing causality in formal reasoning. </title> <booktitle> In Proc. AAAI-87, </booktitle> <pages> pages 360-373, </pages> <year> 1987. </year>
Reference-contexts: The theoremhood view requires that KB satisfies I iff KB j= I (i.e., KB entails every element of I). Consistency view requires KB [ I to be consistent. There are more sophisticated definitions: we will mention some of them in our further discussion. The following example, drawn from <ref> [Pea87] </ref>, can serve to illustrate a typical application of abductive frameworks to the formalization of the process of explaining observations.
Reference: [PGA87] <author> D. Poole, R. Goebel, and R. Aleliunas. </author> <title> Theorist: a logical reasoning system for defaults and diagnosis. </title> <editor> In N. Cercone and G. McCalla, editors, </editor> <booktitle> The Knowledge Frontier: Essays in the Representation of Knowledge, </booktitle> <pages> pages 331-352. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: Theorist of <ref> [PGA87] </ref>, [Poo88] provides an implementation of abduction for first-order based abductive frameworks which uses resolution-based proof procedure. There are also several procedures for answering queries for abductive logic programs and computing abductive explanations. In [EK89] a basic query answering procedure for abductive programs based on SLDN F resolution is defined. <p> Even though there is some obvious flow of ideas between this work and the work in abductive logic programming (for instance, the relation between abduction and negation as failure was influenced by Poole's <ref> [PGA87] </ref> T heorist which showed for the first time how abduction could be applied to default reasoning), much can be gained from a better understanding between the two approaches. 63 9 Relating logic programming and other nonmono- tonic formalisms In this section, we will briefly discuss the relationship between the logic
Reference: [PN93] <editor> L. Pereira and A. Nerode, editors. </editor> <booktitle> Logic Programming and Non-monotonic Reasoning: Proceedings of the Second International Workshop. </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Research in this area was stimulated by the workshop on Foundations of Deductive Databases and Logic Programming [Min88] and by the workshops on Logic Programming and Nonmonotonic Reasoning <ref> [NMS91, PN93] </ref>. Collection of important papers can also be found in the forthcoming special issue of Journal of Logic Programming devoted to "logic programming and nonmonotonic reasoning".
Reference: [Poo88] <author> D. Poole. </author> <title> A logical framework for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 36(1) </volume> <pages> 27-48, </pages> <year> 1988. </year>
Reference-contexts: Theorist of [PGA87], <ref> [Poo88] </ref> provides an implementation of abduction for first-order based abductive frameworks which uses resolution-based proof procedure. There are also several procedures for answering queries for abductive logic programs and computing abductive explanations. In [EK89] a basic query answering procedure for abductive programs based on SLDN F resolution is defined.
Reference: [Poo89] <author> D. Poole. </author> <title> What the lottery paradox tells us about default reasoning. </title> <editor> In R. Brach-man, H. Levesque, and R. Reiter, editors, </editor> <booktitle> Proc. of the First Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 333-340, </pages> <year> 1989. </year> <month> 86 </month>
Reference-contexts: In Section 4 we consider disjunctive logic programs where disjunctions are allowed in the heads of the rules of the program. We formalize two examples from the literature. In particular we consider an example from <ref> [Poo89] </ref> that was used to demonstrate the difficulties associated with representing disjunctive information in Reiter's default logic. We also discuss other semantics of general logic programs and review a method to compute the answer set semantics of a disjunctive logic program. <p> Its answers to the queries p (a), p (b) and p (c) is the same as 2 's while its answer to the query p (a) ^ p (b) is unknown. 2 The next example was used in <ref> [Poo89] </ref> to demonstrate difficulties with representing disjunctive information in Reiter's default logic. It is worth noting that it has a natural representation in the language of disjunctive programs. Example 4.2 Consider the following story [Poo89]: Normally, a person's left arm is usable, but a person with a broken left arm is <p> the query p (a) ^ p (b) is unknown. 2 The next example was used in <ref> [Poo89] </ref> to demonstrate difficulties with representing disjunctive information in Reiter's default logic. It is worth noting that it has a natural representation in the language of disjunctive programs. Example 4.2 Consider the following story [Poo89]: Normally, a person's left arm is usable, but a person with a broken left arm is an exception, and similarly for the right arm. Suppose also that we remember seeing Matt with a broken left arm or a broken right arm but we do not remember which. <p> Correctness of our method of representation does not depend on the above assumptions. Representations using more complicated translations of normative statements (such as 12 and 13 in Section 3.1) work equally well. However, as shown in <ref> [Poo89] </ref>, similar versions of the default logic representation lead to counter-intuitive results. 2 In the next example we consider a knowledge base containing a default rule about pred-icate a and show that caution should be exercised when expanding the knowledge base by new disjunctive rules about a.
Reference: [PP88] <author> H. Przymusinska and T. Przymusinski. </author> <title> Weakly Perfect Model Semantics for Logic Programs. </title> <editor> In R.A. Kowalski and K.A. Bowen, editors, </editor> <booktitle> Proc. 5 th International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1106-1120, </pages> <address> Seattle, Washington, </address> <month> August 15-19, </month> <year> 1988. </year>
Reference-contexts: Przymusinski [Prz88b] generalized the concept of stratification and introduced local stratification and perfect models. The concept of local stratification was further extended by Przymusinska and Przymusinski <ref> [PP88] </ref> when they introduced the concept of weak stratification. The second approach [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] was to use three-valued logic instead of the classical 2-valued logic.
Reference: [PP90a] <author> H. Przymusinska and T. Przymusinski. </author> <title> Semantic issues in deductive databases and logic programs. </title> <editor> In R. Manerji, editor, </editor> <booktitle> Formal Techniques in Artificial Intelligence, </booktitle> <pages> pages 321 - 367. </pages> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: This work was generalized and/or modified by various authors (an overview can be found in <ref> [PP90a] </ref>, [LMR92]) but most of the approaches still assume the closed world assumption, and hence do not allow the representation of such simple forms of incompleteness as missing information in the database tables, null values and partial definitions.
Reference: [PP90b] <author> H. Przymusinska and T. Przymusinski. </author> <title> Weakly stratified logic programs. </title> <journal> Fun-damenta Informaticae, </journal> <volume> 13 </volume> <pages> 51-65, </pages> <year> 1990. </year>
Reference-contexts: By "correct" we mean that if a program has stable models, then if an atom is true (resp. f alse) with respect to the well-founded semantics then it is true (resp. f alse) with respect to the stable model semantics. For the broad class of weakly stratified programs <ref> [PP90b] </ref> the well-founded semantics coincides with the stable model semantics. There are several attempts to classify the various semantics of general logic programs. One attempt uses the notion of complexity of query answering. 9 Another attempt is based on establishing basic principles of nonmonotonic entailment. <p> Notice that I is neither stratified nor locally stratified. It is possible to show however [MDS92a] that for any stratified program , I is weakly stratified and hence categorical, i.e. has a unique stable model <ref> [PP90b] </ref>. This implies that at least for stratified programs we should not worry about existence of reasonable semantics for their vanilla meta-interpreters. So let us assume that is stratified. To check correctness of I we need to show that for every query q, j= q iff I j= demo (q).
Reference: [PP92] <author> H. Przymusinska and T. Przymusinski. </author> <title> Stationary default extensions. </title> <booktitle> In Proceedings of 4th International Workshop on Non-monotonic reasoning, </booktitle> <pages> pages 179-193, </pages> <year> 1992. </year>
Reference-contexts: It not only helped to single out important classes of theories such as stratified autoepistemic theories and their variants, with comparatively good computational and other properties but also led to the development of new versions of basic formalisms, such as "default theories" <ref> [LY91, PP92] </ref>, disjunctive defaults [GLPT91], reflexive autoepistemic logic [Sch91], introspective circumscription [Lif89], and MBNF [Lif91, LS90], to mention only a few.
Reference: [PR93] <author> J. Pinto and R. Reiter. </author> <title> Temporal reasoning in logic programming: A case for the situation calculus. </title> <booktitle> In Proceedings of 10th International Conference in Logic Programming, Hungary, </booktitle> <pages> pages 203-221, </pages> <year> 1993. </year>
Reference-contexts: Some of the later solutions, in particular those from [Gel89], and [Mor88], were given in the language of autoepistemic logic and non-normal default theory respectively, and are similar to the one presented here. Representing inheritance reasoning and reasoning about actions in logic programming is an active area of research <ref> [GL92, BG93, Dun93b, PR93, Esh88, DMB92, KS86] </ref>. Some of the works on both subjects will be discussed in the upcoming sections.
Reference: [Prz88a] <author> T. Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA., </address> <year> 1988. </year>
Reference-contexts: It is easy to show that a stable model of a general logic program is a model of its classical counterpart T . This explains the use of the term "model" in the definition of the stable model semantics which was influenced by the "preferred models" <ref> [ABW88, Prz88a, VG88] </ref> approach to the semantics of logic programs. According to this approach a logic program is identified with its classical counterpart and its semantics is given in terms of some (preferred) class of models of . <p> Proposition 2.2 [ABW88, GL88] Any stratified general logic program is categorical. 2 It is easy to see that the program from Example 2.1 is stratified and therefore has only one stable model. Existence of stable models was further studied in <ref> [Fag90, Cav89, Dun92, Prz88a] </ref>. The following result, due to Fages [Fag90], is representative of this direction of research. A general logic program is said to be call-consistent [Kun89, Sat87] if its dependency graph does not have a cycle with an odd number of negative edges.
Reference: [Prz88b] <author> T. Przymusinski. </author> <title> Perfect model semantics. </title> <editor> In R. Kowalski and K. Bowen, editors, </editor> <booktitle> Logic Programming: Proc. of the Fifth Int'l Conf. and Symp., </booktitle> <pages> pages 1081-1096, </pages> <year> 1988. </year>
Reference-contexts: The first approach was to put a syntactic restriction on the program. Chandra and Harel [CH85] defined the concept of stratification and Apt, Blair and Walker [ABW88] and Van Gelder [VG88] developed a fixpoint semantics for stratified programs. Przymusinski <ref> [Prz88b] </ref> generalized the concept of stratification and introduced local stratification and perfect models. The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. <p> CWA [GP86] is P 2 -hard and in P 3 [O (log n)], (d) the decision problem for is P 2 -complete for the following semantics [EG93a, EG93c, EG93d]: the generalized CWA [Min82], the extended generalized CWA [YH85], the extended CWA [GPP89], the iterated CWA [GPP89], the perfect model semantics <ref> [Prz88b] </ref>, and the partial as well as total disjunctive stable model semantics [Prz91]. 2 Here P 2 and P 3 [O (log n)] are classes above coN P (= P 1 ) in the refined polynomial hierarchy, which is a subrecursive analog to the Kleene arithmetical hierarchy (cf. [Wag90]).
Reference: [Prz89a] <author> T. Przymusinski. </author> <title> Every logic program has a natural stratification and an iterated least fixed point model. </title> <booktitle> In Proc. of Principles of Database Systems, </booktitle> <year> 1989. </year>
Reference-contexts: It is also easy to see that program Y is acyclic. As was shown in [AB91], most of the semantics of general logic programs coincide for this class. The following theorem is obtained by combining results from [AB91], [Cav89], and <ref> [Prz89a] </ref> and is further discussed in Section 2.4. Theorem 2.5 [AB91] Let be an acyclic program. <p> Fitting [FBJ88, Fit85, Fit86], Kunen [Kun87, Kun89] and others [LM85, Myc83] used Kleene's strong three-valued logic while Van Gelder, Ross and Schlifp [VGRS91] used a different three valued logic to give the well-founded semantics of a logic program. Przymusinski <ref> [Prz89a, Prz89d] </ref>, Dung [Dun93a], Van Gelder [VG89], and many others gave alternative formalizations of the well-founded semantics. The semantics of Fitting and Jacob differ from the well-founded semantics. <p> Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92]. The semantics proposed in [Bar92] (DWFS Disjunctive Well-Founded Semantics) uses a fixpoint operator similar to the fixpoint operators used in <ref> [VGRS91, Prz89a] </ref> to define the well-founded semantics and iterates it starting from a "nothing is known" initial state until a fixpoint is reached. The semantics proposed in [BLM92] (GDWFS Generalized Disjunctive Well-Founded Semantics) uses a fixpoint operator which contains an additional model theoretic part.
Reference: [Prz89b] <author> T. Przymusinski. </author> <title> On the declarative and procedural semantics of logic programs. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 167-205, </pages> <year> 1989. </year>
Reference-contexts: However, Clark's completion of the predicate `reachable' gives only reachable (X) (X = a _ 9 Y (reachable (Y ) ^ edge (Y; X))) from which such a conclusion cannot be derived. The difficulty was recognized as serious (for a good discussion of the subject see, for instance, <ref> [Prz89b] </ref>) and prompted the attempts of finding other approaches to defining the semantics of logic programs. 2 From this point the quest for an appropriate semantics for general logic programs proceeded in several directions which can be classified broadly and incompletely into three different approaches. <p> This lack of modularity, and the surprising ability of a program to entail positive facts not entailed by the corresponding classical theory were recognized as problems of the semantics of general logic programs. Przymusinski in <ref> [Prz89b] </ref> termed the above problem the universal query problem and suggested as a solution the semantics of general logic programs based on arbitrary (not necessarily Herbrand) minimal models. This allows him to avoid the universal query problem. <p> This allows him to avoid the universal query problem. Under the proper definition of the answer to a query, both and fl answer unknown to q. At the same time, the semantics from <ref> [Prz89b] </ref> does not diverge too far from the least Herbrand model semantics. In fact, these two semantics are equivalent for existential queries [GPP90]. 17 Other solutions of the universal query problem are suggested in [Ros89], [Kun87], and [VGRS91]. <p> Such a preference appears somewhat arbitrary. Unless open or closed domain assumptions are stated explicitly, unknown seems to be the more intuitive answer to q. 17 T. Przymusinski's approach is not limited to positive programs. In <ref> [Prz89b] </ref>, it is extended to perfect model semantics. 53 To obtain this answer we will use a slightly different approach. We will parametrize the definition of an answer set w.r.t. the domains of . For simplicity we limit ourselves to extended logic programs.
Reference: [Prz89c] <author> T. Przymusinski. </author> <title> Three-valued formalizations of non-monotonic reasoning and logic programming. </title> <editor> In R. Brachman, H. Levesque, and R. Reiter, editors, </editor> <booktitle> Proc. of the First Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 341-348, </pages> <year> 1989. </year>
Reference-contexts: In what follows, we will briefly discuss some of these results. Results relating logic programs with different semantics to various modifications of original nonmonotonic theories can be found in <ref> [PAA92a, Prz89c] </ref> among others. 64 9.1 Autoepistemic Logic and Logic Programming We will start with an autoepistemic logic [Moo85] whose formulas are built from propositional atoms using propositional connectives and the modal operator B.
Reference: [Prz89d] <author> T. Przymusinski. </author> <title> The well-founded semantics coincides with the three-valued stable semantics. </title> <note> Fundamenta Informaticae, </note> <year> 1989. </year>
Reference-contexts: Fitting [FBJ88, Fit85, Fit86], Kunen [Kun87, Kun89] and others [LM85, Myc83] used Kleene's strong three-valued logic while Van Gelder, Ross and Schlifp [VGRS91] used a different three valued logic to give the well-founded semantics of a logic program. Przymusinski <ref> [Prz89a, Prz89d] </ref>, Dung [Dun93a], Van Gelder [VG89], and many others gave alternative formalizations of the well-founded semantics. The semantics of Fitting and Jacob differ from the well-founded semantics.
Reference: [Prz90a] <author> T. Przymusinski. </author> <title> Extended stable semantics for normal and disjunctive programs. </title> <editor> In D. Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 459-477, </pages> <year> 1990. </year>
Reference-contexts: In particular, we will no longer be able to conclude q. 2 Well-founded semantics can be considered an approximation of stable models in the sense that the well-founded semantics is correct with respect to stable model semantics <ref> [Prz90a] </ref>. By "correct" we mean that if a program has stable models, then if an atom is true (resp. f alse) with respect to the well-founded semantics then it is true (resp. f alse) with respect to the stable model semantics. <p> Several other semantics of extended logic programs are suggested in the literature <ref> [AP92, PAA91c, PAA92a, PAA92b, Prz90a, KS90] </ref>. We now discuss some of them. The formulation of well-founded semantics of general logic programs in [BS91] can be extended to define the well-founded semantics [Prz90a] of extended logic programs. More precisely, let us consider G (S) = b ( S ). <p> Several other semantics of extended logic programs are suggested in the literature [AP92, PAA91c, PAA92a, PAA92b, Prz90a, KS90]. We now discuss some of them. The formulation of well-founded semantics of general logic programs in [BS91] can be extended to define the well-founded semantics <ref> [Prz90a] </ref> of extended logic programs. More precisely, let us consider G (S) = b ( S ). Then for any extended logic program , the fixpoints of G defines the answer-set semantics, and flf p (G 2 ); gf p (G 2 )g defines the well-founded semantics.
Reference: [Prz90b] <author> T. Przymusinski. </author> <title> Stationary semantics for disjunctive logic programs and deductive databases. </title> <booktitle> In Proceedings of North American Conference on Logic Programming, </booktitle> <pages> pages 40-62, </pages> <year> 1990. </year> <month> 87 </month>
Reference-contexts: Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) <ref> [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92] </ref>. <p> The semantics proposed in [BLM92] (GDWFS Generalized Disjunctive Well-Founded Semantics) uses a fixpoint operator which contains an additional model theoretic part. Some of the other interesting semantics of normal disjunctive programs suggested in the literature are the extended well-founded semantics of Ross [Ros89], stationary semantics by Przymusinski <ref> [Prz90b] </ref> and the possible world semantics by Sakama [Sak89]. Minker and Ruiz [MR93] discuss extensions of the various semantics of normal disjunctive logic programs to disjunctive logic programs (They refer to it as extended disjunctive logic programs.).
Reference: [Prz91] <author> T. Przymusinski. </author> <title> Stable semantics for disjunctive programs. New generation computing, </title> <address> 9(3,4):401-425, </address> <year> 1991. </year>
Reference-contexts: When m = n and the L i 's are atoms, we refer to the program as a positive disjunctive logic program. The definition of an answer set of a disjunctive logic program <ref> [Prz91, GL91] </ref> is almost identical to that of extended logic programs. Let us first consider disjunctive logic programs without negation as failure. <p> n)], (d) the decision problem for is P 2 -complete for the following semantics [EG93a, EG93c, EG93d]: the generalized CWA [Min82], the extended generalized CWA [YH85], the extended CWA [GPP89], the iterated CWA [GPP89], the perfect model semantics [Prz88b], and the partial as well as total disjunctive stable model semantics <ref> [Prz91] </ref>. 2 Here P 2 and P 3 [O (log n)] are classes above coN P (= P 1 ) in the refined polynomial hierarchy, which is a subrecursive analog to the Kleene arithmetical hierarchy (cf. [Wag90]). Results for important restricted cases have been derived in [CL90].
Reference: [PW89] <author> D. Pearce and G. Wagner. </author> <title> Reasoning with negative information 1 strong negation in logic programming. </title> <type> Technical report, </type> <institution> Gruppe fur Logic, Wissentheorie and Information, Freie Universitat Berlin, </institution> <year> 1989. </year>
Reference-contexts: Work in this direction was started by Minker [Min82], Loveland [Lov87] and others, who investigated the possibility of expanding logic programs by disjunctive information. In <ref> [GL90, PW89, Gel92b] </ref>, extensions of logic programming by classical (or strong) negation and epistemic operators were suggested. Unlike "traditional" nonmonotonic formalisms, these extensions are not based on the use of classical logical connectives, and do not include full first-order logic (not even its propositional part). <p> To do that the language should allow for a third possibility the unknown answer, which corresponds to the inability to conclude yes or no. In this section, we discuss "extended" logic programs (ELP's) [GL91] (See also <ref> [Wag91, PAA92b, PW89] </ref>) that contain a second type of negation : (called "classical", "strong" or "explicit" by different authors who associate different meanings to it) 11 in addition to negation-as-failure not. General logic programs provide negative information implicitly, through closed-world reasoning; an extended logic program can include explicit negative information.
Reference: [pei32] <author> C. Pearce. </author> <title> Elements of Logic In: </title> <editor> C. Hartshorne and P. Weiss, editors, </editor> <booktitle> Collected Papers of Charles Sanders Peirce, Volume II, </booktitle> <publisher> Harvard University Press, </publisher> <address> Cambridge, Ma, </address> <year> 1932. </year>
Reference-contexts: Abduction was introduced by C. Peirce in the beginning of the century (see <ref> [pei32] </ref>) and has been used in AI for explaining observations, diagnosis, planning, and natural language understanding. [kak92] gives a survey and analysis of work on the extension of logic programming to perform abductive reasoning.
Reference: [Rei78] <author> R. Reiter. </author> <title> On closed world data bases. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 119-140. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: With time, however, Prolog evolved to incorporate some nonclassical, nonmonotonic features, which made it closer in spirit to the nonmonotonic logics mentioned above. The most important nonmonotonic feature of modern Prolog is negation as failure <ref> [Cla78, Rei78] </ref>. The initial definition of this construct was purely procedural, which inhibited its use for knowledge representation and software engineering, as well as for the investigation of the relationship between logic programming and other nonmonotonic formalisms. <p> We reformalize McCarthy's example of flying birds and the Yale shooting problem using extended logic programs and show the utility of using extended logic programs in the presence of incomplete information where the closed world assumption (CWA) <ref> [Rei78] </ref> can not be automatically assumed. In Section 4 we consider disjunctive logic programs where disjunctions are allowed in the heads of the rules of the program. We formalize two examples from the literature. <p> A rule is an expression of the form A 0 A 1 ; : : : ; A m ; not A m+1 ; : : : ; not A n (1) where A i 's are atoms and not is a logical connective called negation as failure <ref> [Cla78, Rei78] </ref>. The left-hand side of the rule is called the rule's head or conclusion; the right-hand side is called the rule's body (or premise). <p> For more detailed discussion see the paper by Apt and Bol in this issue. 7 The research on finding a declarative semantics for general logic programs started with the pioneering work of Clark [Cla78] and Reiter <ref> [Rei78] </ref>. Clark [Cla78] introduced the concept of program completion to define a declarative semantics for negation as failure. In a general logic program, the bodies of clauses with a predicate p in the head can be viewed as "sufficiency" conditions for inferring p from the program. <p> Obviously, every program that does not contain negation as failure has a unique answer set which will be denoted by b (). 10 Informally closed world assumption or CWA <ref> [Rei78] </ref> about a statement p means that p is assumed false unless there is some evidence to the contrary 11 In this paper we refer to it as "classical" negation.
Reference: [Rei80a] <author> R. Reiter. </author> <title> Equality and domain closure in first-order databases. </title> <journal> JACM, </journal> <volume> 27 </volume> <pages> 235-249, </pages> <year> 1980. </year>
Reference-contexts: We also consider several meta-logic programs that formalize database updates and hypothetical reasoning. In Section 7 we discuss the modification of the semantics of logic programs and disjunctive databases which allows for reasoning in the absence of the domain-closure assumption <ref> [Rei80a] </ref>. This modification increases the expressive power of the language and allows one to explicitly state the domain-closure and other assumptions about the domain of discourse in the language of logic programming. In Section 8 we discuss a logic programming language based on abduction. <p> Then we have: (i) has a unique recursive 5 stable model; (ii) For every ground atom A, j= A iff comp () [ DCA j= A; where comp () stands for the Clark's completion of and DCA is the domain closure axiom <ref> [Rei80a] </ref>. (iii) For all ground atoms A that do not flounder 6 , j= A iff there is an SLDNF derivation [Cla78] of A from . 2 The first condition of the theorem guarantees that, for a rather broad class of programs (including Y), there is an algorithm to answer all <p> Equating a program with the set of its ground instances, which occurs during the first step, was justified by the domain closure assumption <ref> [Rei80a] </ref> which asserts that all objects in the domain of discourse have names in the language of .
Reference: [Rei80b] <author> R. Reiter. </author> <title> A logic for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1,2):81-132, </volume> <year> 1980. </year>
Reference-contexts: Commonsense reasoning is nonmonotonic: new information constantly forces us to withdraw previous conclusions. This observation has led to the development and investigation of new logical formalisms, nonmonotonic logics. The best known of them are circumscription [McC80, McC86, Lif85b], default logic <ref> [Rei80b] </ref>, and nonmonotonic modal logics [MD80, McD82, Moo85]. A collection of important papers on nonmonotonic reasoning published before 1987 appears in [Gin87]. A survey can be found in [Rei87a]. <p> The well-founded semantics is an extension of the perfect model semantics, unlike Fitting and Jacob's semantics. The third approach is analogous to the traditional approach in Reiter's default logic <ref> [Rei80b] </ref> and Moore's autoepistemic logic [Moo85] in which the definition of entailment is based on the notion of beliefs. The stable model semantics [GL88] used in this paper is based on this approach. <p> two approaches. 63 9 Relating logic programming and other nonmono- tonic formalisms In this section, we will briefly discuss the relationship between the logic programming-based formalisms discussed in the previous sections and various nonmonotonic logics (for a review see [Rei87a]) developed in artificial intelligence, such as circumscription [McC80], default logic <ref> [Rei80b] </ref> and autoepistemic logic [Moo85]. Even though some affinity between logic programs and nonmonotonic logics was recognized rather early [Rei82], [Lif85a], the intensive work in this direction started in 1987 after the discovery of model theoretic semantics for stratified logic programs [Apt89].
Reference: [Rei82] <author> R. Reiter. </author> <title> Circumscription implies predicate completion (sometimes). </title> <booktitle> In Proc. of IJCAI-82, </booktitle> <pages> pages 418-420, </pages> <year> 1982. </year>
Reference-contexts: Even though some affinity between logic programs and nonmonotonic logics was recognized rather early <ref> [Rei82] </ref>, [Lif85a], the intensive work in this direction started in 1987 after the discovery of model theoretic semantics for stratified logic programs [Apt89].
Reference: [Rei87a] <author> R. Reiter. </author> <title> Nonmonotonic reasoning. </title> <booktitle> Annual Review of Computer Science, </booktitle> <volume> 2 </volume> <pages> 147-186, </pages> <year> 1987. </year>
Reference-contexts: The best known of them are circumscription [McC80, McC86, Lif85b], default logic [Rei80b], and nonmonotonic modal logics [MD80, McD82, Moo85]. A collection of important papers on nonmonotonic reasoning published before 1987 appears in [Gin87]. A survey can be found in <ref> [Rei87a] </ref>. Much technical work has been done to investigate the mathematical properties of these logics, as well as their applicability to the formalization of commonsense reasoning in various specific domains. <p> reasoning), much can be gained from a better understanding between the two approaches. 63 9 Relating logic programming and other nonmono- tonic formalisms In this section, we will briefly discuss the relationship between the logic programming-based formalisms discussed in the previous sections and various nonmonotonic logics (for a review see <ref> [Rei87a] </ref>) developed in artificial intelligence, such as circumscription [McC80], default logic [Rei80b] and autoepistemic logic [Moo85].
Reference: [Rei87b] <author> R. Reiter. </author> <title> A theory of diagnosis from first principles. </title> <journal> Artificial Intelligence, </journal> <volume> 32(1) </volume> <pages> 57-95, </pages> <year> 1987. </year>
Reference: [Ric74] <author> B. Richards. </author> <title> A point of reference. </title> <journal> Synthese 28, </journal> <volume> 28 </volume> <pages> 431-445, </pages> <year> 1974. </year>
Reference-contexts: More complicated (but also more general) meta-programming schemes are based on naming statements of object programs by ground terms on the meta-level as in [BK82] and [HL91], on allowing sentences name themselves as in <ref> [Ric74] </ref>, or by other naming devices. Normally, these approaches require the development of special semantics. Additional complications occur if we allow self-referencing meta-programs.
Reference: [RLM89] <author> A. Rajasekar, J. Lobo, and J. Minker. </author> <title> Weak Generalized Closed World Assumption. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 293-307, </pages> <year> 1989. </year>
Reference-contexts: Example 4.5 Consider the program D 1 consisting of the following rules: p (a) or p (b) All semantics of normal disjunctive logic programs, except the possible model semantics [Sak89] and the WGCWA <ref> [RLM89, RT88] </ref> infer p (b) to be f alse with respect to the above program. The possible model semantics infers p (b) to be unknown. 2 Example 4.6 Consider the program 4 of Example 2.10. <p> Then the following holds: Theorem 10.7 (a) the decision problem for under the disjunctive database rule [RT88] and the equivalent weak generalized CWA <ref> [RLM89] </ref> is polynomial [Cha93] (co-N P -complete if heads can be empty), (b) the decision problem for under the possible models semantics [Sak89] and the equivalent possible worlds semantics [Cha93] is polynomial (co-N P -complete again if heads can be empty), (c) the decision problem for under the careful CWA [GP86]
Reference: [RM89] <author> R. Reiter and A. Mackworth. </author> <title> A logical framework for depiction and image interpretation. </title> <journal> Artificial Intelligence, </journal> <volume> 41(2) </volume> <pages> 125-156, </pages> <year> 1989. </year>
Reference-contexts: The following theorem establishes the relationship between TMSs and logic programs: Proposition 9.3 [Elk90] M is a grounded model of a collection of justifications iff it is a stable model of a program fl . Similar results were obtained in [WB93], [GM90], [PC89], <ref> [RM89] </ref>, and [FH89]. (The last two papers use autoepistemic logic instead of logic programs).
Reference: [RM90] <author> A. Rajasekar and J. Minker. </author> <title> On stratified disjunctive programs. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 1(1-4):339-357, </volume> <year> 1990. </year>
Reference-contexts: Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) <ref> [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92] </ref>.
Reference: [Ros89] <author> K. Ross. </author> <title> A procedural semantics for well founded negation in logic programming. </title> <booktitle> In Proc. of the eighth Symposium on Principles of Database Systems, </booktitle> <pages> pages 22-34, </pages> <year> 1989. </year>
Reference-contexts: Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) <ref> [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92] </ref>. <p> The semantics proposed in [BLM92] (GDWFS Generalized Disjunctive Well-Founded Semantics) uses a fixpoint operator which contains an additional model theoretic part. Some of the other interesting semantics of normal disjunctive programs suggested in the literature are the extended well-founded semantics of Ross <ref> [Ros89] </ref>, stationary semantics by Przymusinski [Prz90b] and the possible world semantics by Sakama [Sak89]. Minker and Ruiz [MR93] discuss extensions of the various semantics of normal disjunctive logic programs to disjunctive logic programs (They refer to it as extended disjunctive logic programs.). <p> DWFS and stationary semantics infer p to be true with respect to the program 3 but 3 does not have any answer-sets. 2 41 Example 4.8 Consider the following program, D 2 a not b b or c &gt; = D 2 The extended well-founded semantics <ref> [Ros89] </ref>, and the GDWFS do not infer a to be true from the above program. <p> At the same time, the semantics from [Prz89b] does not diverge too far from the least Herbrand model semantics. In fact, these two semantics are equivalent for existential queries [GPP90]. 17 Other solutions of the universal query problem are suggested in <ref> [Ros89] </ref>, [Kun87], and [VGRS91]. They are based on the assumption that the language of any logic program contains constants and function symbols not appearing in it explicitly.
Reference: [RP91] <author> W. Rodi and S. Pimentel. </author> <title> A nonmonotonic assumption-based tms using stable bases. </title> <editor> In J. Allen, R. Fikes, and Erik Sandewall, editors, </editor> <booktitle> Proc. of the Second Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <year> 1991. </year>
Reference-contexts: They led to a better understanding of the semantics of nonmonotonic truth maintenance systems, to their use for computing stable models [Esg90] and autoepistemic extensions [JK91], for doing abductive reasoning [IS91], <ref> [RP91] </ref>, and to the development of variants of TMSs based on other semantics of logic programs.
Reference: [RT88] <author> K. Ross and R. Topor. </author> <title> Inferring Negative Information from Disjunctive Databases. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 4(2) </volume> <pages> 397-424, </pages> <month> December, </month> <year> 1988. </year> <month> 88 </month>
Reference-contexts: Example 4.5 Consider the program D 1 consisting of the following rules: p (a) or p (b) All semantics of normal disjunctive logic programs, except the possible model semantics [Sak89] and the WGCWA <ref> [RLM89, RT88] </ref> infer p (b) to be f alse with respect to the above program. The possible model semantics infers p (b) to be unknown. 2 Example 4.6 Consider the program 4 of Example 2.10. <p> Then the following holds: Theorem 10.7 (a) the decision problem for under the disjunctive database rule <ref> [RT88] </ref> and the equivalent weak generalized CWA [RLM89] is polynomial [Cha93] (co-N P -complete if heads can be empty), (b) the decision problem for under the possible models semantics [Sak89] and the equivalent possible worlds semantics [Cha93] is polynomial (co-N P -complete again if heads can be empty), (c) the decision
Reference: [Sak89] <author> C. Sakama. </author> <title> Possible model semantics for disjunctive databases. </title> <booktitle> In Proc. of the first international conference on deductive and object oriented databases, </booktitle> <pages> pages 1055-1060, </pages> <year> 1989. </year>
Reference-contexts: Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) <ref> [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92] </ref>. <p> Some of the other interesting semantics of normal disjunctive programs suggested in the literature are the extended well-founded semantics of Ross [Ros89], stationary semantics by Przymusinski [Prz90b] and the possible world semantics by Sakama <ref> [Sak89] </ref>. Minker and Ruiz [MR93] discuss extensions of the various semantics of normal disjunctive logic programs to disjunctive logic programs (They refer to it as extended disjunctive logic programs.). The following examples give a flavor of the differences between the various semantics of disjunctive logic programs. <p> The following examples give a flavor of the differences between the various semantics of disjunctive logic programs. Example 4.5 Consider the program D 1 consisting of the following rules: p (a) or p (b) All semantics of normal disjunctive logic programs, except the possible model semantics <ref> [Sak89] </ref> and the WGCWA [RLM89, RT88] infer p (b) to be f alse with respect to the above program. The possible model semantics infers p (b) to be unknown. 2 Example 4.6 Consider the program 4 of Example 2.10. <p> Then the following holds: Theorem 10.7 (a) the decision problem for under the disjunctive database rule [RT88] and the equivalent weak generalized CWA [RLM89] is polynomial [Cha93] (co-N P -complete if heads can be empty), (b) the decision problem for under the possible models semantics <ref> [Sak89] </ref> and the equivalent possible worlds semantics [Cha93] is polynomial (co-N P -complete again if heads can be empty), (c) the decision problem for under the careful CWA [GP86] is P 2 -hard and in P 3 [O (log n)], (d) the decision problem for is P 2 -complete for the
Reference: [Sat87] <author> T. Sato. </author> <title> On the consistency of first-order logic programs. </title> <type> Technical report, ETL, </type> <institution> TR-87-12, </institution> <year> 1987. </year>
Reference-contexts: Existence of stable models was further studied in [Fag90, Cav89, Dun92, Prz88a]. The following result, due to Fages [Fag90], is representative of this direction of research. A general logic program is said to be call-consistent <ref> [Kun89, Sat87] </ref> if its dependency graph does not have a cycle with an odd number of negative edges.
Reference: [Sch90] <author> J. Schlipf. </author> <title> The expressive power of the logic programming semantics. </title> <booktitle> In Proc. of the Ninth Symp. on Principles of Database Systems, </booktitle> <pages> pages 196-204, </pages> <year> 1990. </year>
Reference-contexts: Definition 10.3 A set s of natural numbers is 1 1 ( 1 2 ) definable if it satisfies 8n (s (n) (n)) where formula is 1 1 ( 1 The following theorem <ref> [Sch90] </ref> [MNR93] characterizes the expressibility of the stable model semantics of logic programs over natural numbers Theorem 10.2 [Sch90],[MNR93] A set s of natural numbers is 1 1 definable iff s is definable by a logic program under the stable model semantics. 2 The actual results of [Sch90], [MNR93], and [AB90] <p> The following theorem <ref> [Sch90] </ref> [MNR93] characterizes the expressibility of the stable model semantics of logic programs over natural numbers Theorem 10.2 [Sch90],[MNR93] A set s of natural numbers is 1 1 definable iff s is definable by a logic program under the stable model semantics. 2 The actual results of [Sch90], [MNR93], and [AB90] are stronger than the above theorem. Instead of definability of sets of natural numbers, these papers deal with definability over arbitrary infinite Herbrand universes. <p> of first order disjunctive logic programs without function symbols under stable model semantics is P 2 -complete, and (b) The class of first order disjunctive logic programs without function symbols under stable semantics expresses P 2 . 2 Notice that first order disjunction-free logic programs without functions expresses coN P <ref> [Sch90] </ref>; hence, by allowing disjunction the expressive power of stable models increases a lot.
Reference: [Sch91] <author> G. Schwarz. </author> <title> Autoepistemic logic of knowledge. </title> <editor> In Anil Nerode, Victor Marek, and Subramanian V. S., editors, </editor> <booktitle> Logic Programming and Non-monotonic Reasoning: Proc. of the First Int'l Workshop, </booktitle> <pages> pages 260-274, </pages> <year> 1991. </year>
Reference-contexts: It not only helped to single out important classes of theories such as stratified autoepistemic theories and their variants, with comparatively good computational and other properties but also led to the development of new versions of basic formalisms, such as "default theories" [LY91, PP92], disjunctive defaults [GLPT91], reflexive autoepistemic logic <ref> [Sch91] </ref>, introspective circumscription [Lif89], and MBNF [Lif91, LS90], to mention only a few. Many of these formalisms are new, and we are in the beginning stages of evaluating their utility to knowledge representation, but their role in gaining a much better understanding of commonsense reasoning cannot be seriously disputed. <p> The stronger result establishes a one-to-one correspondence between the stable models of an arbitrary general logic program and the stable expansions of ff (). Other mappings of logic programs into autoepistemic logic and its variants were investigated in [MT89], [Lif89] <ref> [Sch91] </ref>, and [LS89] but none of these mappings seem to extend in a natural way to logic programs with classical negation and disjunction. Recently, several such mappings were independently found by several researchers [LS93], [MT93], [Che93]. <p> Moreover, every stable expansion of fi () can be represented in the above form. 2 There are similar results describing mappings of disjunctive databases into reflexive au-toepistemic logic <ref> [Sch91] </ref> and a logic of minimal belief and negation as failure called M BN F [LW92], [LS92]. 9.2 Defaults and Logic Programming A default is an expression of the form F G : M H 1 ; : : : ; M H k ; (22) where F; G; H 1
Reference: [Sch92] <author> J. Schlipf. </author> <title> Complexity and undecidability results in logic programming. </title> <booktitle> In Workshop on Structural Complexity and Recursion-theoretic methods in Logic Programming, </booktitle> <year> 1992. </year>
Reference-contexts: A good description of one such system, based on the well-founded semantics, together with the proof of its tractability can be found in [Wit91]. 67 10 Expressiveness and complexity results In this section, we will briefly discuss the complexity and expressibility of logic programming languages. In <ref> [Sch92] </ref>, a survey containing most of the recent results is provided. 23 Apart from the theoretical appeal, complexity and expressiveness results for logic programming are significant for practice. Characterizations of the complexity of logic programming formalisms allow us to get insight into computational obstacles for designing efficient programs.
Reference: [Sch93] <author> J. Schlipf. </author> <title> Some remarks on computability and open domain semantics, 1993. </title> <type> manuscript. </type>
Reference-contexts: An application to formalization of anonymous exceptions to defaults [EKP91] can be found in [GP93a]. <ref> [Sch93] </ref> contains some results of query answering in open domain semantics. Related work in the context of autoepistemic logic and default logic can be found in [Lif89, Lif90].
Reference: [Scr59] <author> M. Scriven. </author> <title> Truisms as the grounds for historical explanations. </title> <editor> In P. Gardiner, editor, </editor> <title> Theories of History. </title> <publisher> Free Press, </publisher> <address> New York, </address> <year> 1959. </year>
Reference-contexts: In Section 5 we show the inadequacy of disjunctive logic programs in representing certain kinds of information and introduce two new unary operators K (meaning known) and M (meaning may be believed). The extension of disjunctive logic programs by these operators 1 Normative or normic statements <ref> [Scr59, Scr63] </ref> frequently involve terms such as `naturally', `normally', `typically', `tendency', `ought', `should' and other. 3 (called epistemic logic programs) is used to overcome this inadequacy. In Section 6 we consider the framework of meta-logic programming and discuss several of its features.
Reference: [Scr63] <author> M. Scriven. </author> <title> New issues in the logic of explanation. </title> <editor> In S. Hook, editor, </editor> <booktitle> Philosophy and History. </booktitle> <publisher> New York University Press, </publisher> <address> New York, </address> <year> 1963. </year>
Reference-contexts: In Section 5 we show the inadequacy of disjunctive logic programs in representing certain kinds of information and introduce two new unary operators K (meaning known) and M (meaning may be believed). The extension of disjunctive logic programs by these operators 1 Normative or normic statements <ref> [Scr59, Scr63] </ref> frequently involve terms such as `naturally', `normally', `typically', `tendency', `ought', `should' and other. 3 (called epistemic logic programs) is used to overcome this inadequacy. In Section 6 we consider the framework of meta-logic programming and discuss several of its features.
Reference: [Sha89] <author> M. Shanahan. </author> <title> Prediction is deduction but explanation is abduction. </title> <booktitle> In Proc. of IJCAI-89, </booktitle> <pages> pages 1055-1060, </pages> <year> 1989. </year>
Reference-contexts: These methods were applied to formalizations of various benchmarks in temporal, legal and other types of reasoning <ref> [Sha89, DMB92, Esh88] </ref>. There are several useful generalizations of the notion of abductive logic programs. In [Gel91], abduction is combined with reasoning with classical negation and epistemic disjunction, and generalized stable models are replaced by their answer set counterparts.
Reference: [She88] <author> J. Shepherdson. </author> <title> Negation in Logic Programming. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 19-88. </pages> <publisher> Morgan Kaufman Pub., </publisher> <year> 1988. </year>
Reference-contexts: This result was extended to arbitrary T in <ref> [GP86, She88] </ref>. The following proposition establishes the connection between Minker's semantics and answer set semantics of disjunctive logic programs.
Reference: [Sho67] <author> J. Shoenfield. </author> <title> Mathematical Logic. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass, </address> <year> 1967. </year>
Reference-contexts: such that for every ground term t of L, s (t) j= p (t) or s (t) j= :p (t). 2 To discuss the expressive power of logic programs, we will need the following classification of formulas of second order arithmetic, i.e., arithmetic with quantifiers over sets of natural numbers <ref> [Sho67] </ref>.
Reference: [SI92] <author> K. Satoh and N. Iwayama. </author> <title> A correct goal-directed proof procedure for a general logic programs with integrity constraints. </title> <booktitle> In Proc. of the Third Int'l Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 19-34, </pages> <year> 1992. </year>
Reference-contexts: The procedure is shown to be correct w.r.t. the stable model semantics for call-consistent logic programs, but (as pointed out in [EK89]) not in general. This fact led to modification of the procedure to achieve correctness w.r.t. the stable model semantics <ref> [SI92] </ref>, as well as to work on modification of the semantics to fit the inference method of the procedure [KM91],[Dun91a]. These methods were applied to formalizations of various benchmarks in temporal, legal and other types of reasoning [Sha89, DMB92, Esh88].
Reference: [SL88] <author> B. Smith and D. Loveland. </author> <title> A Simple Near-Horn Prolog Interpreter. </title> <editor> In R.A. Kowalski and K.A. Bowen, editors, </editor> <booktitle> Proc. 5 th International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 794-809, </pages> <address> Seattle, Washington, </address> <month> August 15-19, </month> <year> 1988. </year>
Reference-contexts: His main concern was efficient implementation <ref> [Lov87, SL88] </ref>. 15 For positive disjunctive logic programs this definition is similar to Minker's [Min82] original definition. For a precise relationship see Proposition 4.4. 33 Unlike extended logic programs without not, a disjunctive logic program without not may have more than one answer sets.
Reference: [ST93] <author> G. Schwarz and M. Truszczynski. </author> <title> Nonmonotonic Reasoning is Sometimes Simpler. </title> <editor> In G. Gottlob, A. Leitsch, and D. Mundici, editors, </editor> <booktitle> Proceedings of the Third Kurt Godel Colloquium, number 713 in LNCS, </booktitle> <pages> pages 313-325, </pages> <address> Brno, Czech Republic, </address> <month> August 24-27 </month> <year> 1993. </year> <note> Springer. 89 </note>
Reference-contexts: Note that similar complexity results have recently been derived for various forms of nonmonotonic reasoning such as default and autoepistemic logic [Got92], nonmonotonic S4 <ref> [ST93] </ref>, theory revision [EG92], and abduction [EG93e]. For programs with variables, consider the case of first order disjunctive logic programs without function symbols. Then following holds.
Reference: [SZ90] <author> D. Sacca and C. Zaniolo. </author> <title> Stable models and non-determinism in logic programs with negation. </title> <booktitle> In Proceedings of PODS 1990, </booktitle> <pages> pages 205-217, </pages> <year> 1990. </year>
Reference-contexts: SLDNF resolution, though sound [Cla78], is only complete for a subclass of stratified programs [JLL83]. Various practical Prolog systems have been developed based on SLDNF resolution. To answer queries with respect to programs with a multiple number of stable models, several approaches have been suggested <ref> [PAA91a, BNNS94, FLMS93, SZ90, IKH92, WC93, EK89] </ref> in the literature.
Reference: [Tou86] <author> D. Touretzky. </author> <title> The mathematics of inheritance systems. </title> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1986. </year>
Reference-contexts: b's" is represented by the rule ab (r; X) c (X) (4) Exceptions of this sort will be called strong exceptions. (Compare with weak exceptions in (13) in Section 3.) The cancellation rule (4) can be viewed as a particular instance of a general reasoning principle called the Inheritance Principle <ref> [Tou86] </ref>, according to which more specific information is preferable to that which is more general. 2 We will discuss several versions of this program and use B with subscripts to denote the different versions. 9 It is easy to see that a general logic program B consisting of rules 1. -
Reference: [TS84] <author> H. Tamaki and T. Sato. </author> <title> Unfold/fold transformation of logic programs. </title> <editor> In S. Tarn-lund, editor, </editor> <booktitle> Proc. 2nd international logic programming conference, </booktitle> <pages> pages 127-138, </pages> <address> Uppsala, Sweeden, </address> <year> 1984. </year>
Reference-contexts: The existence of Clark's declarative semantics facilitated the development of a theory of logic programs. It made possible first proofs of correctness of certain transformations of logic programs such as fold/unfold <ref> [TS84] </ref>, proofs of equivalence and other properties of programs. It is still widely and successfully used for logic programming applications. Unfortunately, Clark's semantics appears too weak for representation of some type of knowledge.
Reference: [TS86] <author> H. Tanaki and T. Sato. </author> <title> OLD resolution with tabulation. </title> <booktitle> In Proc. of the Third International Conference on Logic Programming, </booktitle> <year> 1986. </year>
Reference-contexts: This is especially important because SLDN F is incorporated in most existing Prolog interpreters. 2.3 Answering Queries Several query answering methods have been suggested for stratified programs in the literature: in particular, SLDNF resolution [Cla78] and XOLDT resolution <ref> [TS86] </ref>, [War91]. SLDNF resolution, though sound [Cla78], is only complete for a subclass of stratified programs [JLL83]. Various practical Prolog systems have been developed based on SLDNF resolution.
Reference: [TS88] <author> R. Topor and L. Sonenberg. </author> <title> On domain independent databases. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 217-240. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA., </address> <year> 1988. </year>
Reference-contexts: A program p (X) q (X); not r (X) is range restricted while the program 0 above or any program containing the rule p (X) are not. The notion of range restriction is closely related to the notion of allowedness <ref> [TS88] </ref> and is extensively used for analysis of such notions as domain independence, floundering, and typing. It is probably fair to say that the vast majority of logic programs used in practical applications are range restricted.
Reference: [Tur93] <author> K. Turner. </author> <title> A monotonicity theorem for extended logic programs. </title> <editor> In D. S. Warren, editor, </editor> <booktitle> Proc. of 10th International Conference on Logic Programming, </booktitle> <pages> pages 567-585, </pages> <year> 1993. </year>
Reference-contexts: not ab (X) If we allow updates consisting of literals formed with predicate p then the above normative statement should be translated as p (X) q (X); not ab (X); not :p (X) Fortunately, in many cases the more complex formalization seem to be correct extensions of the simpler ones <ref> [BGK93, Tur93] </ref>. The precise relationship between these different approaches is an interesting subject for further investigation.
Reference: [vEK76] <author> M. van Emden and R. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM., </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: illustrate this point, let us consider the following simple example from the literature: Example 7.1 Consider the positive logic program consisting of the rule: p (a) and the query q = 8Xp (X). 2 Under the domain-closure assumption, the semantics of this program is given by its least Herbrand model <ref> [vEK76] </ref>, i.e, the answer to 8Xp (X) is yes iff for any ground term t in the language of the answer to p (t) is yes. Hence, 's answer to a query q will be yes.
Reference: [VG88] <author> A. Van Gelder. </author> <title> Negation as failure using tight derivations for general logic programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 149-176. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA., </address> <year> 1988. </year>
Reference-contexts: It is easy to show that a stable model of a general logic program is a model of its classical counterpart T . This explains the use of the term "model" in the definition of the stable model semantics which was influenced by the "preferred models" <ref> [ABW88, Prz88a, VG88] </ref> approach to the semantics of logic programs. According to this approach a logic program is identified with its classical counterpart and its semantics is given in terms of some (preferred) class of models of . <p> There is a collection of results giving sufficient conditions for these properties. We will now discuss some of these results. We start with the class of stratified programs <ref> [ABW88, VG88, CH85] </ref>. <p> The first approach was to put a syntactic restriction on the program. Chandra and Harel [CH85] defined the concept of stratification and Apt, Blair and Walker [ABW88] and Van Gelder <ref> [VG88] </ref> developed a fixpoint semantics for stratified programs. Przymusinski [Prz88b] generalized the concept of stratification and introduced local stratification and perfect models. The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. <p> The stable class ffg; fp; a; bgg corresponds to the well-founded semantics of the above program. Therefore, p is a consequence of 4 in the stable model semantics, while the answer to p in the well-founded semantics is undefined. 2 Example 2.11 Consider the following program 5 <ref> [VG88] </ref>: q not r p not p 9 &gt; &gt; &gt; ; 5 has a unique stable model, viz. fp; qg. 5 has three strict stable classes (stable classes which have no proper subset which is also a stable class), namely, C 1 ; C 2 and C 3 , where
Reference: [VG89] <author> A. Van Gelder. </author> <title> The alternating fixpoint of logic programs with negation. </title> <booktitle> In Proc. of PODS-89, </booktitle> <pages> pages 1-10, </pages> <year> 1989. </year>
Reference-contexts: Fitting [FBJ88, Fit85, Fit86], Kunen [Kun87, Kun89] and others [LM85, Myc83] used Kleene's strong three-valued logic while Van Gelder, Ross and Schlifp [VGRS91] used a different three valued logic to give the well-founded semantics of a logic program. Przymusinski [Prz89a, Prz89d], Dung [Dun93a], Van Gelder <ref> [VG89] </ref>, and many others gave alternative formalizations of the well-founded semantics. The semantics of Fitting and Jacob differ from the well-founded semantics. <p> Others moved closer to non-traditional non-monotonic logics. To give the reader a flavor of these developments, we introduce the well-founded semantics, and compare it with the stable models semantics. We will follow the ideas from [BS91] and <ref> [VG89] </ref>. Definition 2.3 [BS91] For any general logic program and a set of atoms S, consider F (S) = a ( S ), where a and S are as in Definition 2.1 of stable models. <p> Moreover, they show that the problem of determining if a literal l is a stable model consequence of a program is 1 1 complete, i.e. is represen tative of the hardest decision problem in 1 1 . As shown in <ref> [VG89] </ref>, [KP87], and [Fit85], the same result holds for the well-founded semantics as well as for two-valued and three-valued completion based semantics of logic programs.
Reference: [VGRS91] <author> A. Van Gelder, K. Ross, and J. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> Journal of ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: Przymusinski [Prz88b] generalized the concept of stratification and introduced local stratification and perfect models. The concept of local stratification was further extended by Przymusinska and Przymusinski [PP88] when they introduced the concept of weak stratification. The second approach <ref> [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] </ref> was to use three-valued logic instead of the classical 2-valued logic. <p> The second approach [FBJ88, Fit85, Fit86, Kun87, Kun89, LM85, Myc83, VGRS91] was to use three-valued logic instead of the classical 2-valued logic. Fitting [FBJ88, Fit85, Fit86], Kunen [Kun87, Kun89] and others [LM85, Myc83] used Kleene's strong three-valued logic while Van Gelder, Ross and Schlifp <ref> [VGRS91] </ref> used a different three valued logic to give the well-founded semantics of a logic program. Przymusinski [Prz89a, Prz89d], Dung [Dun93a], Van Gelder [VG89], and many others gave alternative formalizations of the well-founded semantics. The semantics of Fitting and Jacob differ from the well-founded semantics. <p> 2 ), and 2. a ground atom A is f alse in the well-founded semantics of iff A =2 gf p (F 2 ). 3. a ground atom A is undef ined in the well-founded semantics of if neither of the above two cases hold. 2 It was shown in <ref> [VGRS91] </ref> that unlike the stable model semantics, the well-founded semantics is defined for all general logic programs. Even though the stable model semantics is not defined for 3 of Example 2.9 the well-founded semantics is defined and its answer to p and a is true and unknown respectively. <p> Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92]. The semantics proposed in [Bar92] (DWFS Disjunctive Well-Founded Semantics) uses a fixpoint operator similar to the fixpoint operators used in <ref> [VGRS91, Prz89a] </ref> to define the well-founded semantics and iterates it starting from a "nothing is known" initial state until a fixpoint is reached. The semantics proposed in [BLM92] (GDWFS Generalized Disjunctive Well-Founded Semantics) uses a fixpoint operator which contains an additional model theoretic part. <p> At the same time, the semantics from [Prz89b] does not diverge too far from the least Herbrand model semantics. In fact, these two semantics are equivalent for existential queries [GPP90]. 17 Other solutions of the universal query problem are suggested in [Ros89], [Kun87], and <ref> [VGRS91] </ref>. They are based on the assumption that the language of any logic program contains constants and function symbols not appearing in it explicitly. Under this semantics, both programs and fl answer no to the query q, which, in a sense, amounts to preferring open domains over closed ones.
Reference: [Wag90] <author> K. Wagner. </author> <title> Bounded query classes. </title> <journal> SIAM J. Comp., </journal> <volume> 19(5) </volume> <pages> 833-846, </pages> <year> 1990. </year>
Reference-contexts: model semantics [Prz88b], and the partial as well as total disjunctive stable model semantics [Prz91]. 2 Here P 2 and P 3 [O (log n)] are classes above coN P (= P 1 ) in the refined polynomial hierarchy, which is a subrecursive analog to the Kleene arithmetical hierarchy (cf. <ref> [Wag90] </ref>). Results for important restricted cases have been derived in [CL90]. For the extension of logic programming by classical negation [GL91], the following holds.
Reference: [Wag91] <author> G. Wagner. </author> <title> Logic programming with strong negation and inexact predicates. </title> <journal> Journal of Logic and Computation, </journal> <volume> 1(6) </volume> <pages> 835-861, </pages> <year> 1991. </year>
Reference-contexts: We briefly discuss the other semantics of general logic programs and discuss classes of general logic programs where the various semantics agree. We also review a method of computing the stable models of a general logic program. In Section 3 we consider extended logic programs <ref> [GL91, Wag91] </ref> that allow classical negation (also referred to as "strong negation") and discuss its expressibility in the context of knowledge representation. <p> To do that the language should allow for a third possibility the unknown answer, which corresponds to the inability to conclude yes or no. In this section, we discuss "extended" logic programs (ELP's) [GL91] (See also <ref> [Wag91, PAA92b, PW89] </ref>) that contain a second type of negation : (called "classical", "strong" or "explicit" by different authors who associate different meanings to it) 11 in addition to negation-as-failure not. General logic programs provide negative information implicitly, through closed-world reasoning; an extended logic program can include explicit negative information.
Reference: [Wag93] <author> G. Wagner. </author> <title> Reasoning with inconsistency in extended deductive databases. </title> <booktitle> In Proc. of 2nd International workshop on Logic programming and non-monotonic reasoning, </booktitle> <year> 1993. </year>
Reference-contexts: The -well-founded semantics is given by ffc; :bg; fc; a; :bgg. 2 Before we end this section we would like to briefly mention another class of semantics of extended logic programs based on contradiction removal <ref> [Dun91b, Wag93, PAA91a, GM90] </ref>. To illustrate the problem let us consider the program 4 : 1. p not q 3. s Obviously, under the answer set semantics this program is inconsistent.
Reference: [War91] <author> D. S. Warren. </author> <title> Computing the well-founded semantics of logic programs. </title> <type> Technical Report 91/12, </type> <institution> CS dept. SUNY Stony Brook, </institution> <year> 1991. </year>
Reference-contexts: This is especially important because SLDN F is incorporated in most existing Prolog interpreters. 2.3 Answering Queries Several query answering methods have been suggested for stratified programs in the literature: in particular, SLDNF resolution [Cla78] and XOLDT resolution [TS86], <ref> [War91] </ref>. SLDNF resolution, though sound [Cla78], is only complete for a subclass of stratified programs [JLL83]. Various practical Prolog systems have been developed based on SLDNF resolution.
Reference: [WB93] <author> C. Witteveen and G. Brewka. </author> <title> Skeptical reason maintenance and belief revision. </title> <journal> Artificial Intelligence, </journal> <volume> 61 </volume> <pages> 1-36, </pages> <year> 1993. </year> <month> 90 </month>
Reference-contexts: The following theorem establishes the relationship between TMSs and logic programs: Proposition 9.3 [Elk90] M is a grounded model of a collection of justifications iff it is a stable model of a program fl . Similar results were obtained in <ref> [WB93] </ref>, [GM90], [PC89], [RM89], and [FH89]. (The last two papers use autoepistemic logic instead of logic programs).
Reference: [WC93] <author> D. S. Warren and W. Chen. </author> <title> Query evaluation under well-founded semantics. </title> <booktitle> In Proc. of PODS 93, </booktitle> <year> 1993. </year>
Reference-contexts: SLDNF resolution, though sound [Cla78], is only complete for a subclass of stratified programs [JLL83]. Various practical Prolog systems have been developed based on SLDNF resolution. To answer queries with respect to programs with a multiple number of stable models, several approaches have been suggested <ref> [PAA91a, BNNS94, FLMS93, SZ90, IKH92, WC93, EK89] </ref> in the literature. <p> Very promising work in this direction is done by Pereira et al. [PAA91b], Chen and Warren <ref> [WC93] </ref> and others. Some of the other important issues are to learn to deal with floundering queries and planning problems, and to incorporate new logic programming paradigms such as constrained logic programming and concurrent logic programming in the nonmonotonic framework.
Reference: [Wit91] <author> C. Witteveen. </author> <title> Skeptical reason maintenance system is tractable. </title> <editor> In J. A, R. Fikes, and E. Sandewall, editors, </editor> <booktitle> Proc. of KR'91, </booktitle> <pages> pages 570-581, </pages> <year> 1991. </year>
Reference-contexts: A good description of one such system, based on the well-founded semantics, together with the proof of its tractability can be found in <ref> [Wit91] </ref>. 67 10 Expressiveness and complexity results In this section, we will briefly discuss the complexity and expressibility of logic programming languages.
Reference: [YH85] <author> A. Yahya and L. Henschen. </author> <title> Deduction in non-horn databases. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 1(2) </volume> <pages> 141-160, </pages> <year> 1985. </year> <month> 91 </month>
Reference-contexts: Then for any literal query q, 's answer to q under answer set semantics coincides with the answer to q by ff () under Minker's semantics. 2 Minker's GCWA was later extended by many people <ref> [YH85, GP86, GPP86] </ref> in several various directions. Several semantics have been proposed for normal disjunctive programs (disjunctive programs with not but without :) [LMR92, RM90, BLM92, BLM91, Ros89, Prz90b, Sak89, BED92]. <p> if heads can be empty), (c) the decision problem for under the careful CWA [GP86] is P 2 -hard and in P 3 [O (log n)], (d) the decision problem for is P 2 -complete for the following semantics [EG93a, EG93c, EG93d]: the generalized CWA [Min82], the extended generalized CWA <ref> [YH85] </ref>, the extended CWA [GPP89], the iterated CWA [GPP89], the perfect model semantics [Prz88b], and the partial as well as total disjunctive stable model semantics [Prz91]. 2 Here P 2 and P 3 [O (log n)] are classes above coN P (= P 1 ) in the refined polynomial hierarchy, which
References-found: 242

