URL: http://www.pdos.lcs.mit.edu/papers/LogicalDisk.ps
Refering-URL: http://www.pdos.lcs.mit.edu/PDOS-papers.html
Root-URL: 
Title: because operating systems, file systems, and disk drivers have all been tightly coupled in monolithic
Author: M. Frans Kaashoek and Wilson C. Hsieh 
Keyword: Disk storage management, file system organization, file system performance, high write performance, logical disk, log-structured file system, UNIX, MINIX.  
Address: Amsterdam  Cambridge, MA  
Affiliation: Wiebren de Jonge Dept. of Mathematics and Computer Science, Vrije Universiteit,  Laboratory for Computer Science, MIT,  
Note: Until recently these benefits have not been important,  The  
Abstract: Separating these two concerns has three advantages. First, it leads to a file system structure that makes file systems easier to develop, maintain, and modify. Second, it makes file systems more exible. Different implementations of LD can be tailored for different access patterns and different disks can run under different implementations of LD. Similarly, different file systems can all share a particular LD implementation. Third, it allows for efficient solutions to the I/O bottleneck [Ousterhout and Douglis 1989; Ousterhout 1990]. LD can transparently reorganize the layout of blocks on the disk to reduce access time, similar to other systems that use logical-block numbers [Vongsathorn and Carson 1990; Solworth and Orji 1991; English and Stepanov 1992; Akyrek and Salem 1993]. To demonstrate these benefits we built a prototype implementation of LD. This implementation, LLD, is log-structured and is based on the ideas used in Sprite LFS [Rosenblum and Ousterhout 1992]. We combined LLD with MINIX [Tanenbaum 1987], a POSIX-compliant [IEEE 1990] file system for PCs. The resulting file system, MINIX LLD, required very few modifications to MINIX and exhibits the same performance characteristics as Sprite LFS; we expect MINIX LLD to outperform Sprite LFS, as it writes fewer blocks. However, it uses more main memory than Sprite LFS. The contributions of this paper are threefold. First, we show that the LD allows a clean separation of file and disk management without loss of efficiency. Second, we show that an existing file system can easily be turned into a log-structured one by using a log-structured implementation of LD. Third, we introduce new implementation techniques for log-structured storage managers: a new recovery strategy and a new strategy for writing partially filled segments. The Logical Disk: A New Approach to Improving File Systems Abstract A log-structured implementation of LD (LLD) demonstrates that LD can be implemented efficiently. LLD adds about 5% to 10% to the purchase cost of a disk for the main memory it requires. Combining LLD with an existing file system results in a log-structured file system that exhibits the same performance characteristics as the Sprite log-structured file system. 
Abstract-found: 1
Intro-found: 1
Reference: [Akyrek and Salem 1993] <author> Akyrek, S., and Salem, K., </author> <title> Adaptive Block Rearrangement Under UNIX, </title> <booktitle> Proc. USENIX 1993 Summer Conference, </booktitle> <pages> pp. 307-321, </pages> <address> Cin-cinnati, OH, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Thus, Mimes recovery model is weaker than Loges one, as is also the case for LLD. 5.3 Other related work Akyrek and Salem describe an adaptive UNIX disk device driver <ref> [Akyrek and Salem 1993] </ref>, which shares some ideas with work done by Vongsathorn and Carson [Vongsathorn and Carson 1990]. The driver periodically reorganizes the layout of blocks on the disk based on estimated reference frequencies, which are acquired by monitoring the stream of disk accesses.
Reference: [Baker et al. 1992] <author> Baker, M., Asami, S., Deprit, E., Ouster-hout, J., and Seltzer, M., </author> <title> Non-Volatile Memory for Fast, Reliable File Systems, </title> <booktitle> Proc. Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, ACM SIG-PLAN Notices, </booktitle> <volume> Vol. 27, No. 9, </volume> <pages> pp. 10-22, </pages> <address> Boston, MA, </address> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: Measurements show that the adaptive driver reduces seek times by more than half and reduces response time significantly. As LD can rearrange blocks dynamically, the proposed scheme can be applied to LD too. Baker et al. analyzed the impact of NVRAM on log-structured file systems <ref> [Baker et al. 1992] </ref>. They concluded that with 0.5 Mbyte of NVRAM the number of partially written segments can be reduced considerably; the number of disk accesses can be reduced by about 20% and on heavily used file systems it can even be reduced by about 90% [Baker et al. 1992]. <p> log-structured file systems <ref> [Baker et al. 1992] </ref>. They concluded that with 0.5 Mbyte of NVRAM the number of partially written segments can be reduced considerably; the number of disk accesses can be reduced by about 20% and on heavily used file systems it can even be reduced by about 90% [Baker et al. 1992]. We expect that similar results can be obtained for LLD. Carson and Setia present an analytical derivation of the optimal segment size in log-structured file systems [Carson and Setia 1992].
Reference: [Brown et al. 1985] <author> Brown, M.R., Kolling, K.N., and Taft, </author> <title> E.A., The Alpine File System, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 3, No. 4, </volume> <pages> pp. 261-293, </pages> <month> Nov. </month> <year> 1985. </year>
Reference: [Burrows et al. 1992] <author> Burrows, M., Jerian, C., Lampson, B., and Mann, T., </author> <title> On-line Data Compression in a Log-structured File System, </title> <booktitle> Proc. Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, ACM SIG-PLAN Notices, </booktitle> <volume> Vol. 27, No. 9, </volume> <pages> pp. 2-9, </pages> <address> Boston, MA, </address> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: The disadvantage is that frequent Flushs will cause blocks to be written multiple times, which does not occur in Sprite LFS. 3.3 Compression To demonstrate the exibility that the LD interface offers, we have implemented compression, as has been done for Sprite LFS <ref> [Burrows et al. 1992] </ref>. We use an algorithm due to Wheeler for its simplicity and performance; the algorithm is described by Burrows et al. Using LLD, a file system can transparently use compression to make more effective use of disk space. <p> With compression in LLD, each physical block requires three additional bytes, i.e., 10 bytes. Assuming Wheelers algorithm achieves a compression ratio of about 60% <ref> [Burrows et al. 1992] </ref>, a segment contains on average 211 compressed blocks (i.e. 2,110 bytes for the block entries), leaving room in a 4-Kbyte segment summary block for 165 link tuples. 3.5 Cleaning and clustering Rosenblum and Ousterhout describe a number of policies for selecting and cleaning segments using the segment
Reference: [Carson and Setia 1992] <author> Carson, S., and Setia, S., </author> <title> Optimal Write Batch Size in Log-structured File Systems, </title> <booktitle> Proc. USENIX File System Workshop, </booktitle> <pages> pp. 79-91, </pages> <address> Ann Harbor, MI, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: We expect that similar results can be obtained for LLD. Carson and Setia present an analytical derivation of the optimal segment size in log-structured file systems <ref> [Carson and Setia 1992] </ref>. They show that large segments are good for write performance, but can have an adverse effect on read performance. Based on an analytical model of a disk they conclude optimal segment sizes range between 52 Kbyte and 74 Kbyte, depending on the disk parameters.
Reference: [Chang et al. 1990] <author> Chang, A., Mergen, F., Rader, R.K., Roberts, J.A., and Porter, </author> <title> S.L., Evolution of Storage Facilities in AIX Version 3 for RISC System/6000 Processors, </title> <journal> IBM Journal of Research and Development, </journal> <volume> Vol. 34, No. 1, </volume> <pages> pp. 105-110, </pages> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: However, using 64-Kbyte segments we measured serious performance degradation for writes. AIX Version 3 uses database memory to ensure that the AIX file system is always in a consistent state <ref> [Chang et al. 1990] </ref>. Database memory are files in virtual memory with the additional implicit properties of access serializability and atomic update. The database memory is implemented using a log to record the begin and the end of a transaction.
Reference: [Chao et al. 1992] <author> Chao, C., English, R., Jacobson, D., Stepanov, A., and Wilkes, J., Mime: </author> <title> a High Performance Parallel Storage Device with Strong Recovery Guarantees, </title> <type> HPL-CSP-92-9 rev 1, </type> <institution> Hewlett-Packard Laboratories, </institution> <address> CA, </address> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Section 3 describes a log-structured LD implementation called LLD. Section 4 describes how we combined LLD with the MINIX file system to produce a log-structured file system, MINIX LLD. In Section 5, we compare related work (in particular, Sprite LFS, Loge [English and Stepanov 1992], and Mime <ref> [Chao et al. 1992] </ref>) and describe our ongoing and future work. In Section 6 we summarize our results and conclusions. 2. The Logical Disk In this section we briey describe abstractions supported by LD. <p> For its internal operation Loge typically reserves 3-5% of the physical blocks <ref> [Chao et al. 1992] </ref>. When a block is written to disk, the Loge disk controller writes to a free reserved physical block closest to the current position of the disk head. <p> As a consequence, recovery in our LLD implementation is at least one order of magnitude faster than in Loge, since LLD only reads the segment summaries. Mime <ref> [Chao et al. 1992] </ref> extends the work on Loge by offering a rich set of transaction-like capabilities. The most interesting aspect of Mime is its support of provisional writes by the use of so-called visibility groups.
Reference: [Chutani et al 1992] <author> Chutani, S., Anderson, O.T., Kazar, M.L., Leverett, B.W., Mason, W.A., and Sidebotham, R.N., </author> <title> The Episode File System, </title> <booktitle> Proc. USENIX Win ter Conference 1992, </booktitle> <pages> pp. 43-60, </pages> <address> San Francisco, CA, </address> <month> Jan. </month> <year> 1992. </year>
Reference: [Custer 1993] <author> Custer, H., </author> <title> Inside Windows/NT, </title> <publisher> Microsoft Press, </publisher> <address> Redmond, WA, </address> <year> 1993. </year>
Reference: [English and Stepanov 1992] <author> English, R.M., and Stepanov, A.A., Loge: </author> <title> a Self-Organizing Disk Controller, </title> <booktitle> Proc. USENIX 1992 Winter Conference, </booktitle> <pages> pp. 237-251, </pages> <address> San Francisco, CA, </address> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Section 3 describes a log-structured LD implementation called LLD. Section 4 describes how we combined LLD with the MINIX file system to produce a log-structured file system, MINIX LLD. In Section 5, we compare related work (in particular, Sprite LFS, Loge <ref> [English and Stepanov 1992] </ref>, and Mime [Chao et al. 1992]) and describe our ongoing and future work. In Section 6 we summarize our results and conclusions. 2. The Logical Disk In this section we briey describe abstractions supported by LD. <p> MINIX LLD however does not have to roll for-ward; as shown by the measurements in the previous section, MINIX LLDs recovery strategy is still quite fast. 5.2 Comparison with Loge and Mime Loge <ref> [English and Stepanov 1992] </ref> improves the I/O performance of disks by having the disk controller reduce the time required for writing a stream of individual blocks. For its internal operation Loge typically reserves 3-5% of the physical blocks [Chao et al. 1992].
Reference: [Golub et al. 1990] <author> Golub, D., Dean, R., Forin, A., and Rashid, R., </author> <title> UNIX as an application program, </title> <booktitle> Proc. USENIX 1990 Summer Conference, </booktitle> <pages> pp. 87-95, </pages> <address> Ana-heim, CA, </address> <month> June </month> <year> 1990. </year>
Reference: [Hagmann 1987] <author> Hagmann, R., </author> <title> Reimplementing the Cedar File System Using Logging and Group Commit, </title> <booktitle> Proc. of the 11th Symposium on Operating System Principles, </booktitle> <pages> pp. 155-162, </pages> <address> Austin, TX, </address> <month> Nov. </month> <year> 1987. </year>
Reference-contexts: Episode is a traditional UNIX file system that logs changes to file system metadata only. Echo logs all modifications: those to file system metadata as well as application data. Both file systems build on earlier file system that use logging, such as Cedar <ref> [Hagmann 1987] </ref> and Alpine [Brown 1985]. Seltzer et al. describe a log-structured implementation of 4.4BSD [Seltzer et al. 1993]. This particular implementation is more robust than Sprite LFS. The authors also report on a head-to-head comparison between FFS [McKusick et al. 1984], EFS [McVoy and Kleimann 1991], and BSD-LFS.
Reference: [Hisgen et al. 1990] <author> Hisgen, A., Birrell, A.D., Jerian, C., Mann, T., Schroeder M., and Swart, C., </author> <title> Granularity and Semantic Level of Replication in the Echo Distributed System, </title> <journal> IEEE TOCS Newsletter, </journal> <volume> Vol. 4, No. 3, </volume> <pages> pp. 30-32, </pages> <year> 1990. </year>
Reference-contexts: All the file system metadata reside in database memory; therefore all the updates are treated as part of a transaction. Database memory is a mechanism that can be built on top of LD using LDs atomic recovery units. The Echo <ref> [Hisgen et al. 1990] </ref> and Episode file systems [Chutani et al. 1992] are two recent file systems that use logging to increase reliability, to obtain good performance, and to restart quickly. Episode is a traditional UNIX file system that logs changes to file system metadata only.
Reference: [IEEE 1990] <author> IEEE, </author> <title> POSIX - Part 1: System Application Program Interface (API) [C Language], </title> <journal> IEEE Std 1003.1-1990, </journal> <month> Jan. </month> <year> 1990. </year>
Reference: [McKusick et al. 1984] <author> McKusick, M.K., Joy, W.N., Lefer, S.J., and Fabry, </author> <title> R.S., A Fast File System for UNIX, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 2, No. 3, </volume> <pages> pp. 181-197, </pages> <month> Aug. </month> <year> 1984. </year>
Reference-contexts: The order of blocks on a list does not have to be the same as their order in a file; for example, it could correspond to the order in which they will be read. With lists the file system does not need to maintain partitions and cylinder groups <ref> [McKusick et al. 1984] </ref>. Finally, lists can be used to perform read-ahead effectively. File systems can also specify the logical relationship between lists: LD keeps a single ordered list of lists, in which the file system inserts new lists. <p> If we improved MINIXs block allocation strategy as in FFS <ref> [McKusick et al. 1984] </ref>, MINIX should achieve similar performance on sequential writes as MINIX LLD. MINIX achieves higher throughput than MINIX LLD on sequential reads because it uses prefetching, which we disabled for MINIX LLD. <p> Seltzer et al. describe a log-structured implementation of 4.4BSD [Seltzer et al. 1993]. This particular implementation is more robust than Sprite LFS. The authors also report on a head-to-head comparison between FFS <ref> [McKusick et al. 1984] </ref>, EFS [McVoy and Kleimann 1991], and BSD-LFS. The results show that EFS often provides comparable and sometimes superior performance to BSD-LFS due to BSD-LFSs cleaner competing for the disk arm.
Reference: [McVoy and Kleimann 1991] <author> McVoy, L., and Kleimann, S., </author> <title> Extent-like Performance from a UNIX File System, </title> <booktitle> Proc. USENIX 1991 Winter Conference, </booktitle> <pages> pp. 33-44, </pages> <address> Dallas, TX, </address> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: Seltzer et al. describe a log-structured implementation of 4.4BSD [Seltzer et al. 1993]. This particular implementation is more robust than Sprite LFS. The authors also report on a head-to-head comparison between FFS [McKusick et al. 1984], EFS <ref> [McVoy and Kleimann 1991] </ref>, and BSD-LFS. The results show that EFS often provides comparable and sometimes superior performance to BSD-LFS due to BSD-LFSs cleaner competing for the disk arm. The authors, however, point out that BSD-LFS can be extended to incorporate additional functionality such as embedded transactions and versioning.
Reference: [Ousterhout 1990] <author> Ousterhout, J., </author> <title> Why arent Operating Systems Getting Faster as fast as Hardware?, </title> <booktitle> Proc. USENIX 1990 Summer Conference, </booktitle> <pages> pp. 247-256, </pages> <address> Ana-heim, CA, </address> <month> June </month> <year> 1990. </year>
Reference: [Ousterhout and Douglis 1989] <author> Ousterhout, J., and Douglis, F., </author> <title> Beating the I/O Bottleneck: A Case for Log-structured File Systems, </title> <journal> Operating Systems Review, </journal> <volume> Vol. 23, No. 1, </volume> <pages> pp. 11-28, </pages> <month> Jan. </month> <year> 1989. </year>
Reference: [Rosenblum 1992] <author> Rosenblum, M., </author> <title> The Design and Implementation of a Log-structured File System, </title> <type> Report No. UCB/CSD 92/26 (Ph.D. thesis), </type> <institution> University of Cal-ifornia, Berkeley, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: MINIXs throughput is low because the disk must make an additional rotation between writing two consecutive 4-Kbyte blocks (a program that writes back-to-back 4-Kbyte blocks to the disk achieves a throughput of only 300 Kbyte per second); the same phenomenon was detected in the original Sprite file system <ref> [Rosenblum 1992] </ref>. If we improved MINIXs block allocation strategy as in FFS [McKusick et al. 1984], MINIX should achieve similar performance on sequential writes as MINIX LLD. MINIX achieves higher throughput than MINIX LLD on sequential reads because it uses prefetching, which we disabled for MINIX LLD. <p> The i-nodes must be written out because the disk addresses and the modification times stored in them have changed. Since in Sprite LFS dirty i-nodes are collected together in special blocks <ref> [Rosenblum 1992] </ref>, the cost of writing a dirty i-node is much smaller than the cost of writing one block and will be denoted by e. <p> Assuming that each i-node map entry is 12 bytes, the i-node map in Sprite LFS for a 4-Gbyte disk with 4-Kbyte blocks requires 6 Mbyte of memory <ref> [Rosenblum 1992] </ref>. However, Sprite LFS stores the i-node map on disk and caches it on a block-by-block basis, so it need not be entirely memory resident. To make caching effective Sprite LFS allocates i-node numbers to maximize locality (e.g., files in the same directory have nearby i-node numbers). <p> To make caching effective Sprite LFS allocates i-node numbers to maximize locality (e.g., files in the same directory have nearby i-node numbers). For an 8.1-Gbyte disk Sprite LFS caches on average only 3.6-Mbyte of the i-node map <ref> [Rosenblum 1992] </ref>. MINIX LLD currently keeps the entire block-number map and list table in main memory.
Reference: [Rosenblum and Ousterhout 1990] <author> Rosenblum, M., and Ousterhout, J.K., </author> <title> The LFS Storage Manager, </title> <booktitle> Proc. USENIX 1991 Summer Conference, </booktitle> <pages> pp. 215-324, </pages> <address> Ana-heim, CA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: The end result was that the MINIX file system became simpler, as most of the disk management code (350 lines) could be deleted. 4.2 Performance of MINIX LLD To measure MINIX LLDs performance we ran the same microbenchmarks as Rosenblum and Ousterhout <ref> [Rosenblum and Ousterhout 1990] </ref>. These benchmarks measure the performance of specific file operations and not overall system performance [Seltzer 1992]. However, these benchmarks are good enough to demonstrate that combining LLD with an existing file system achieves the same performance characteristics as a log-structured file system.
Reference: [Rosenblum and Ousterhout 1992] <author> Rosenblum, M., and Ousterhout, J.K., </author> <title> The Design and Implementation of a Log-structured File System, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 10, No. 1, </volume> <pages> pp. 26-52, </pages> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: 1992], a segment contains on average 211 compressed blocks (i.e. 2,110 bytes for the block entries), leaving room in a 4-Kbyte segment summary block for 165 link tuples. 3.5 Cleaning and clustering Rosenblum and Ousterhout describe a number of policies for selecting and cleaning segments using the segment usage table <ref> [Rosenblum and Ousterhout 1992] </ref>; all of these can be used for LLD as well. Using the lists, LLD can physically cluster related blocks. We have not yet implemented the disk reorganizer, which should clean segments and improve the layout of blocks and lists on the disk during idle periods. <p> It provides logical block numbers, block lists, atomic recovery units and multiple block sizes. We have designed, built, and measured a log-structured implementation of the LD interface, called LLD. LLD is inspired by Sprite LFS <ref> [Rosenblum and Ousterhout 1992] </ref>. The key properties of LLD are: a clean separation of file and disk management, long contiguous writes, a simple and fast recovery scheme, and a new approach to writing partially full segments.
Reference: [Ruemmler and Wilkes 1993] <author> Ruemmler, C., and Wilkes, J., </author> <title> UNIX Disk Access Patterns, </title> <booktitle> Proc. USENIX 1993 Winter Conference, </booktitle> <pages> pp. 405-420, </pages> <address> San Diego, CA, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: The list table seems to be a good candidate for this, as probably only a small percentage of the lists will be actively used at any moment in time. Ruemmler and Wilkes analyzed UNIX block access patterns and observed that 1% of the blocks receive 90% of the writes <ref> [Ruemmler and Wilkes 1993] </ref>. Although they did not analyze the variation in the set of blocks that are written, this suggests that caching the block-number map could be effective as well.
Reference: [Seltzer 1992] <author> Seltzer, M., </author> <title> File System Performance and Transaction Support, </title> <type> Report No. UCB/CSD (Ph.D. thesis), </type> <institution> University of California, Berkeley, </institution> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: These benchmarks measure the performance of specific file operations and not overall system performance <ref> [Seltzer 1992] </ref>. However, these benchmarks are good enough to demonstrate that combining LLD with an existing file system achieves the same performance characteristics as a log-structured file system.
Reference: [Seltzer et al. 1993] <author> Seltzer, M., Bostic, K., McKusick, M.K., and Staelin, C., </author> <title> An Implementation of a Log-Structured File System for UNIX, </title> <booktitle> Proc. USENIX 1993 Winter Conference, </booktitle> <pages> pp. 201-220, </pages> <address> San Diego, CA, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Echo logs all modifications: those to file system metadata as well as application data. Both file systems build on earlier file system that use logging, such as Cedar [Hagmann 1987] and Alpine [Brown 1985]. Seltzer et al. describe a log-structured implementation of 4.4BSD <ref> [Seltzer et al. 1993] </ref>. This particular implementation is more robust than Sprite LFS. The authors also report on a head-to-head comparison between FFS [McKusick et al. 1984], EFS [McVoy and Kleimann 1991], and BSD-LFS.
Reference: [Solworth and Orji 1991] <author> Solworth, J.A., and Orji, C.U., </author> <title> Distorted Mirrors, </title> <booktitle> Proc. First International Conference on Parallel and Distributed Information Systems, </booktitle> <pages> pp. 10-17, </pages> <address> Miami Beach, FL, </address> <month> Dec. </month> <year> 1991. </year>
Reference: [Tanenbaum 1987] <author> Tanenbaum, </author> <title> A.S., Operating Systems: Design and Implementation, </title> <publisher> Prentice-Hall Inc., </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1987. </year>
Reference-contexts: However, this extension would be difficult to implement in a non-log-structured implementation. Another extension we are considering is offset addressing, where lists could be indexed as arrays. For example, if we combine an implementation of the LD interface with an MS DOS file system <ref> [Tanenbaum 1987] </ref>, we could eliminate the duplication of information in the File Allocation Table and LDs block-number map.
Reference: [Van Renesse et al. 1989] <author> Van Renesse, R., Tanenbaum, A.S., and Wilschut, A., </author> <title> The Design of a High-Performance File Server, </title> <booktitle> Proc. of the Ninth International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 22-27, </pages> <address> Newport Beach, CA, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Furthermore, BSD-LFS shows better performance in case of many small writes. Van Renesse et al. describe a radically different organization for file systems, called the Bullet server, that achieves high throughput and low delay <ref> [Van Renesse et al. 1989] </ref>. Instead of storing files as sequences of disk blocks, each Bullet file is stored contiguously. Furthermore, Bullet files are immutable. This approach achieves high performance, but it has also has a number of disadvantages.
Reference: [Vongsathorn and Carson 1990] <author> Vongsathorn, P., and Car-son, </author> <title> S.D., A System for Adaptive Disk Rearrangement, </title> <journal> SoftwarePractice & Experience, </journal> <volume> Vol. 20, No. 3, </volume> <pages> pp. 225-242, </pages> <month> Mar. </month> <year> 1990. </year>
Reference-contexts: Thus, Mimes recovery model is weaker than Loges one, as is also the case for LLD. 5.3 Other related work Akyrek and Salem describe an adaptive UNIX disk device driver [Akyrek and Salem 1993], which shares some ideas with work done by Vongsathorn and Carson <ref> [Vongsathorn and Carson 1990] </ref>. The driver periodically reorganizes the layout of blocks on the disk based on estimated reference frequencies, which are acquired by monitoring the stream of disk accesses. It copies frequently referenced blocks to reserved space near the center of the disk to reduce seek times.
References-found: 28

