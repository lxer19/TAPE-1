URL: ftp://nezz.cs.stir.ac.uk/pub/papers/GH-14.ps.gz
Refering-URL: http://www.gh.cs.su.oz.au/Grasshopper/Papers/Papers.html
Root-URL: 
Email: dave@cs.adelaide.edu.au al@cs.stir.ac.uk  
Title: A LogStructured Persistent Store  
Author: David Hulse Alan Dearle 
Keyword: persistent stores, logstructured stores, recoverable virtual memory.  
Address: S.A., 5005, Australia Stirling, FK9 4LA, Scotland  
Affiliation: Department of Computer Science Department of Computing Science University of Adelaide University of Stirling  
Abstract: Persistent stores have been implemented using a variety of storage technologies including shadow paging, log-based and logstructured approaches. Here we compare these approaches and advocate the use of logstructuring. The advantages of such a technique include efficient support for large (64 bit) address spaces, scalability and fast snapshot processing. We describe the architecture of a new logstructured persistent store and how it has been used to support resilient persistent processes in the context of the Grasshopper operating system. This store is based on the use of a log server which provides clients with private logical logs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Atkinson, M. P., Bailey, P. J., Chisholm, K. J., Cockshott, W. P. and Morrison, R. </author> <title> An Approach to Persistent Programming, </title> <journal> The Computer Journal, </journal> <volume> Volume 26, Number 4, </volume> <pages> pages 360-365, </pages> <year> 1983. </year>
Reference-contexts: 1 Introduction The concept of persistence may be defined as the attribute of data which specifies its period of existence. Stemming from this simple definition, a wide range of systems supporting various forms of persistence have emerged. In systems that support orthogonal persistence <ref> [1] </ref>, the application programmer does not have to manage the movement of data to and from backing store nor translate between different data formats. Most of these systems are supported at the lowest level by a persistent store which provides a stable and resilient data repository.
Reference: [2] <author> Brown, A. L. </author> <title> Persistent Object Stores, </title> <type> Ph.D thesis, </type> <institution> Computational Science, University of St. Andrews, </institution> <year> 1988. </year>
Reference-contexts: However, if contiguous blocks can be found on disk, writes may be batched considerably improving checkpoint performance. 2.1.2 Before Look Shadow Paging Systems based on the before look approach to shadow paging <ref> [2, 8] </ref> operate similarly to after look systems in that the shadow pages are always written to unused blocks on disk. <p> Since pages always reside at the same location on disk, the mapping of virtual addresses to physical disk locations is much simpler than with after look shadow paging. In some systems this mapping is completely static as demonstrated by Brown's before look shadow paged store <ref> [2] </ref>. Before look has the advantage that it preserves physical clustering of data on disk which can improve read performance. However, since modified data is always written to the location from which it was read, writes are prone to high seek and latency delays.
Reference: [3] <author> Challis, M. F. </author> <title> Database Consistency and Integrity in a MultiUser Environment, Databases: Improving Useability and Responsiveness, </title> <publisher> Academic Press, </publisher> <pages> pages 245 270, </pages> <year> 1978. </year>
Reference-contexts: Provided that appropriate housekeeping information is maintained, this ensures that changes can be undone or redone in the event of failure. Checkpoint atomicity may be achieved through the use of a mirroring technique such as Challis' algorithm <ref> [3] </ref>. Using Challis' algorithm, the persistent store is described by two timestamped root blocks which reside at known disk locations. The final action of a checkpoint is to overwrite the oldest root block with a new root block that describes the new state of the store.
Reference: [4] <author> Davies, C. T. </author> <title> Recovery Semantics for a DB/DC System, </title> <booktitle> ACM Annual Conference, </booktitle> <pages> pages 136-141, </pages> <year> 1973. </year>
Reference-contexts: of shadow paging known as after look and before look. 2.1.1 After Look Shadow Paging In an after look shadow paging system [12, 13, 15], a dirty page is never written to the site from which the clean version of the page was fetched; this is analogous to deferred-write logging <ref> [4, 9] </ref>. Instead, modified pages are shadowed by writing them to unused disk blocks. Since the locations of pages change, it is necessary to maintain a Logical to Physical Mapping (LP-Map) which maps virtual addresses onto locations on nonvolatile storage.
Reference: [5] <author> Dearle, A., di Bona, R., Farrow, J., Henskens, F., Hulse, D., Lindstrm, A., Norris, S., Rosenberg, J. and Vaughan, F. </author> <title> Protection in the Grasshopper Operating System, </title> <booktitle> Proceedings of the 6th International Workshop on Persistent Object Systems, </booktitle> <address> Tarascon, France, </address> <publisher> Springer-Verlag, </publisher> <pages> pages 60 78, </pages> <year> 1994. </year>
Reference-contexts: When writing a segment, the log server fills in the Client field with the identifier supplied by the client. Our implementation of the log server within Grasshopper uses the capability system <ref> [5] </ref> to make this mechanism secure. The Timestamp field is filled in by the log server before the segment is written. It is used to impose a chronological order on the segments in the physical log which is useful for finding the last segment on restart.
Reference: [6] <author> Dearle, A., di Bona, R., Farrow, J., Henskens, F., Lindstrm, A., Rosenberg, J. and Vaughan, F. Grasshopper: </author> <title> An Orthogonally Persistent Operating System, </title> <booktitle> Computer Systems, </booktitle> <pages> pages 289-312, </pages> <month> Summer, </month> <year> 1994. </year>
Reference-contexts: The architecture has been implemented and is being used to support persistent containers in the Grasshopper operating system <ref> [6] </ref>. The next section describes various persistent store technologies, highlights their strengths and weaknesses and justifies our design decisions. Section 3 describes a central part of the architecture, known as the Log Server, which provide clients with an abstract interface to logical logs.
Reference: [7] <author> Dearle, A. and Hulse, D. </author> <title> On Page-based Optimistic Process Checkpointing, </title> <type> IWOOOS '95, </type> <institution> Lund, Sweden, </institution> <note> to appear, </note> <year> 1995. </year>
Reference-contexts: In our implementation of this store within Grasshopper, a list of these pages is maintained by a causal tracking subsystem <ref> [7, 11] </ref> and is supplied to the manager whenever a snapshot is made. In many systems, store managers use page protections to track these pages. The modified pages are marshalled into segments, each described by a Snapshot Page meta record. <p> This permits efficient snapshot processing and hence high throughput. We have implemented the store described in this paper and it is used in the Grasshopper operating system to manage both user level and kernel level persistent data. In conjunction with our optimistic process checkpointing scheme <ref> [7] </ref>, the store supports resilient persistent processes. Preliminary performance measurements confirm the efficacy of this approach.
Reference: [8] <author> Elhardt, K. and Bayer, R. </author> <title> A Database Cache for High Performance and Fast Restart in Database Systems, </title> <journal> Transactions on Database Systems, </journal> <volume> Volume 9, Number 4, </volume> <pages> pages 503-525, </pages> <year> 1984. </year>
Reference-contexts: Section 5 describes how the store is used in the context of the Grasshopper persistent operating system. Section 6 concludes. 2 Persistent Store Technologies Researchers have experimented with many different approaches to the implementation of persistent stores. These include shadow paging techniques, log-based approaches, and more recently, logstructured approaches <ref> [12, 8, 14] </ref>. This section introduces these techniques, highlights the differences between them and justifies why we have decided to design and implement a new logstructured architecture. <p> With an 8K page size, if the LP-Map is represented as a conventional page table containing an 8 byte disk address, six pages of LP-Map must be written to nonvolatile storage to describe the changes made to the single page. These observations have lead others <ref> [8, 9] </ref> to conclude that the after look approach is inappropriate for use in large applications requiring high throughput. A final disadvantage of the after look technique is that physical clustering of pages is prevented since modified data is written to unused disk blocks; this degrades read performance. <p> However, if contiguous blocks can be found on disk, writes may be batched considerably improving checkpoint performance. 2.1.2 Before Look Shadow Paging Systems based on the before look approach to shadow paging <ref> [2, 8] </ref> operate similarly to after look systems in that the shadow pages are always written to unused blocks on disk. <p> We use the term logstructured approach to refer to a store which uses only logs for persistent storage. An effective use of a log-based approach can be seen in the design of the DB Cache <ref> [8] </ref>. This database system was designed to provide efficient throughput of transactions whilst maintaining high availability which required fast failure recovery. The DB Cache is comprised of three integral parts: a volatile cache, the physical database and a nonvolatile safe approximately the same size as the cache. <p> A final problem with the DB Cache approach is that pages in the safe require associated meta information to describe where they are located within the physical database as well as some other flags needed for correct operation of the safe. In the system described in <ref> [8] </ref>, this information is contained in the header of each page. This approach is unsuitable for use in a page based persistent store. 2.3 Log-structured Stores In a logstructured store all data is stored in a log comprising a conceptually infinite sequence of records.
Reference: [9] <author> Gray, J., McJones, P., Blasgen, M., Lindsay, B., Lorie, R., Price, T., Putzolu, F. and Traiger, I. </author> <title> The Recovery Manager of the System R Database Manager, </title> <journal> Computing Surveys, </journal> <volume> Volume 13, Number 2, </volume> <pages> pages 223 242, </pages> <month> June </month> <year> 1981. </year>
Reference-contexts: of shadow paging known as after look and before look. 2.1.1 After Look Shadow Paging In an after look shadow paging system [12, 13, 15], a dirty page is never written to the site from which the clean version of the page was fetched; this is analogous to deferred-write logging <ref> [4, 9] </ref>. Instead, modified pages are shadowed by writing them to unused disk blocks. Since the locations of pages change, it is necessary to maintain a Logical to Physical Mapping (LP-Map) which maps virtual addresses onto locations on nonvolatile storage. <p> With an 8K page size, if the LP-Map is represented as a conventional page table containing an 8 byte disk address, six pages of LP-Map must be written to nonvolatile storage to describe the changes made to the single page. These observations have lead others <ref> [8, 9] </ref> to conclude that the after look approach is inappropriate for use in large applications requiring high throughput. A final disadvantage of the after look technique is that physical clustering of pages is prevented since modified data is written to unused disk blocks; this degrades read performance.
Reference: [10] <author> Liedtke, J. </author> <title> Address Space Sparsity and Fine Granularity,, </title> <journal> ACM Operating Systems Review, </journal> <volume> Volume 29, Number 1, </volume> <pages> pages 87-90, </pages> <year> 1995. </year>
Reference-contexts: However, for large address spaces with frequent checkpoints, this overhead becomes significant. Using conventional page tables to represent the LP-Map requires meta data overheads of between 6% (dense) and 400% (sparse) for 100 pages on a 64 bit architecture <ref> [10] </ref>. Consider the worst case of a process that modifies a single page of data and checkpoints on a 64 bit architecture.
Reference: [11] <author> Lindstrm, A. </author> <title> Multiversioning and Logging in the Grasshopper Kernel Persistent Store, </title> <type> IWOOOS '95, </type> <institution> Lund, Sweden, </institution> <note> to appear, </note> <year> 1995. </year>
Reference-contexts: In our implementation of this store within Grasshopper, a list of these pages is maintained by a causal tracking subsystem <ref> [7, 11] </ref> and is supplied to the manager whenever a snapshot is made. In many systems, store managers use page protections to track these pages. The modified pages are marshalled into segments, each described by a Snapshot Page meta record.
Reference: [12] <author> Lorie, R. A. </author> <title> Physical Integrity in a Large Segmented Database, </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Volume 2, Number 1, </volume> <pages> pages 91-104, </pages> <year> 1977. </year>
Reference-contexts: Section 5 describes how the store is used in the context of the Grasshopper persistent operating system. Section 6 concludes. 2 Persistent Store Technologies Researchers have experimented with many different approaches to the implementation of persistent stores. These include shadow paging techniques, log-based approaches, and more recently, logstructured approaches <ref> [12, 8, 14] </ref>. This section introduces these techniques, highlights the differences between them and justifies why we have decided to design and implement a new logstructured architecture. <p> This technique is illustrated in conjunction with after look shadow paging in Figure 1. The next sections describe two commonly used forms of shadow paging known as after look and before look. 2.1.1 After Look Shadow Paging In an after look shadow paging system <ref> [12, 13, 15] </ref>, a dirty page is never written to the site from which the clean version of the page was fetched; this is analogous to deferred-write logging [4, 9]. Instead, modified pages are shadowed by writing them to unused disk blocks.
Reference: [13] <author> Munro, D. S. </author> <title> On the Integration of Concurrency, Distribution and Persistence, </title> <type> Ph.D. thesis, </type> <institution> Computational Science, University of St Andrews, </institution> <year> 1993. </year>
Reference-contexts: This technique is illustrated in conjunction with after look shadow paging in Figure 1. The next sections describe two commonly used forms of shadow paging known as after look and before look. 2.1.1 After Look Shadow Paging In an after look shadow paging system <ref> [12, 13, 15] </ref>, a dirty page is never written to the site from which the clean version of the page was fetched; this is analogous to deferred-write logging [4, 9]. Instead, modified pages are shadowed by writing them to unused disk blocks.
Reference: [14] <author> Rosenblum, M. and Ousterhout, J. K. </author> <title> The Design and Implementation of a Log-Structured File System, </title> <booktitle> 13th ACM Symposium on Operating Systems Principles, Pacific-Grove, California, ACM Operating Systems Review, </booktitle> <volume> Volume 25, Number 1, </volume> <pages> pages 1-15, </pages> <year> 1991. </year>
Reference-contexts: Section 5 describes how the store is used in the context of the Grasshopper persistent operating system. Section 6 concludes. 2 Persistent Store Technologies Researchers have experimented with many different approaches to the implementation of persistent stores. These include shadow paging techniques, log-based approaches, and more recently, logstructured approaches <ref> [12, 8, 14] </ref>. This section introduces these techniques, highlights the differences between them and justifies why we have decided to design and implement a new logstructured architecture. <p> This eliminates the I/O bottleneck associated with the random writes of shadow paged systems since continuous disk access in the same or neighbouring cylinders can be faster by an order of magnitude <ref> [14] </ref>. We define a log-based store as one in which a log is used in conjunction with another approach such as shadow paging. We use the term logstructured approach to refer to a store which uses only logs for persistent storage.
Reference: [15] <author> Vaughan, F., Schunke, T., Koch, B., Dearle, A., Marlin, C. and Barter, C. Casper: </author> <title> A Cached Architecture Supporting Persistence, </title> <journal> Computing Systems, </journal> <volume> Volume 5, Number 3, </volume> <booktitle> California, </booktitle> <pages> pages 337-364, </pages> <year> 1992. </year>
Reference-contexts: This technique is illustrated in conjunction with after look shadow paging in Figure 1. The next sections describe two commonly used forms of shadow paging known as after look and before look. 2.1.1 After Look Shadow Paging In an after look shadow paging system <ref> [12, 13, 15] </ref>, a dirty page is never written to the site from which the clean version of the page was fetched; this is analogous to deferred-write logging [4, 9]. Instead, modified pages are shadowed by writing them to unused disk blocks. <p> However, larger stores require proportionately larger LP-Maps which may not fit entirely within memory. In this case the map could be paged from a transient region of disk which would require a separate mapping. This introduces complexities which some systems, such as CASPER <ref> [15] </ref>, have solved by embedding the LP-Map in the persistent address space that it describes. This has the advantage that it will be paged and shadowed as it is modified using a single mapping. Atomicity is achieved through the use of Challis algorithm.
References-found: 15

