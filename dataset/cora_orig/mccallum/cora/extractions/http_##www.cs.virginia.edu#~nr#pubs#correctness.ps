URL: http://www.cs.virginia.edu/~nr/pubs/correctness.ps
Refering-URL: http://www.cs.virginia.edu/~nr/activities.html
Root-URL: http://www.cs.virginia.edu
Email: norman@bellcore.com  
Title: Correctness of Trap-Based Breakpoint Implementations  
Author: Norman Ramsey 
Address: 445 South Street, Morristown, NJ 07960  
Affiliation: Bell Communications Research  
Date: January 1994.  
Note: Reprinted from Proceedings of the 21st ACM Symposium on the Principles of Programming Languages,  
Abstract: It is common for debuggers to implement breakpoints by a combination of planting traps and single stepping. When the target program contains multiple threads of execution, a debugger that is not carefully implemented may miss breakpoints. This paper gives a formal model of a breakpoint in a two-threaded program. The model describes correct and incorrect breakpoint implementations. Automatic search of the model's state space shows that the correct implementation never misses a breakpoint. A similar search finds an execution for which the incorrect implementation does miss a breakpoint. The results apply even to debuggers like dbx and gdb, which are apparently for single-threaded programs; when the user evaluates an expression containing function calls, the debugger executes the call in the target address space, in effect creating a new thread. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Aral, Ziya, Ilya Gertner, and Greg Schaffer. </author> <year> 1989 </year> <month> (May). </month> <title> Efficient debugging primitives for multiprocessors. </title> <booktitle> Proceedings of Third International Conference on Architectural Support for Programming Languages and Operating Systems, in a special issue of SIGPLAN Notices, </booktitle> <volume> 24 </volume> <pages> 87-95. </pages>
Reference-contexts: Much of the work on breakpoints has focused on performance. Kessler (1990) describes a fast implementation of code breakpoints; Wahbe (1992) describes simulations of four implementations of data break-points. In a parallel environment, debugging work can be o*oaded onto a second processor <ref> (Aral, Gert-ner, and Schaffer 1989) </ref>. Alternatively, monitoring and logging can be done by a special-purpose coprocessor (Gorlick 1991). All these approaches use either branch or coprocessor instructions to transfer control from target to debugging code without kernel intervention, avoiding the overhead of trap handling and context switching.
Reference: <author> Bruegge, Bernd. </author> <year> 1985 </year> <month> (September). </month> <title> Adaptability and Portability of Symbolic Debuggers. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University. </institution>
Reference-contexts: Single stepping can be avoided by transforming the overwritten instruction so that it can be correctly executed out of line (Digital 1975; Kessler 1990). Finally, some machines have special hardware that supports resumption after a break instruction <ref> (Bruegge 1985) </ref>. This paper exposes a potential pitfall in the implementation of breakpoints based on trapping and single-stepping. Single stepping means arranging that the target machine will trap again immediately after executing I.
Reference: <author> Caswell, Deborah and David Black. </author> <year> 1990 </year> <month> (January). </month> <title> Implementing a Mach debugger for multithreaded applications. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 25-39, </pages> <address> Washington, DC. </address> <institution> Digital Equipment Corporation. </institution> <year> 1975. </year> <title> DDT|Dynamic Debugging Technique. </title> <address> Maynard, MA. </address>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or specific permission. POPL 94- 1/94, Portland Oregon, USA c fl1994 ACM 0-89791-636-0/94/001..$3.50 handle the resulting trap <ref> (Caswell and Black 1990) </ref>, or it can overwrite I with an instruction that branches to debugging code (Digital 1975). To resume execution, there are more choices. A debugger can return the overwritten instruction to memory, execute it by single stepping the target machine, and re-plant the breakpoint (Caswell and Black 1990). <p> the resulting trap <ref> (Caswell and Black 1990) </ref>, or it can overwrite I with an instruction that branches to debugging code (Digital 1975). To resume execution, there are more choices. A debugger can return the overwritten instruction to memory, execute it by single stepping the target machine, and re-plant the breakpoint (Caswell and Black 1990). Single stepping can be avoided by transforming the overwritten instruction so that it can be correctly executed out of line (Digital 1975; Kessler 1990). Finally, some machines have special hardware that supports resumption after a break instruction (Bruegge 1985).
Reference: <author> Dijsktra, Edsger W. </author> <year> 1976. </year> <title> A Discipline of Programming. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice-Hall. </publisher>
Reference: <author> Gorlick, Michael M. </author> <year> 1991 </year> <month> (December). </month> <title> The flight recorder: An architectural aid for system monitoring. </title> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, in SIGPLAN Notices, </booktitle> <volume> 26(12) </volume> <pages> 175-183. </pages>
Reference-contexts: Kessler (1990) describes a fast implementation of code breakpoints; Wahbe (1992) describes simulations of four implementations of data break-points. In a parallel environment, debugging work can be o*oaded onto a second processor (Aral, Gert-ner, and Schaffer 1989). Alternatively, monitoring and logging can be done by a special-purpose coprocessor <ref> (Gorlick 1991) </ref>. All these approaches use either branch or coprocessor instructions to transfer control from target to debugging code without kernel intervention, avoiding the overhead of trap handling and context switching.
Reference: <author> Hoare, C. A. R. </author> <year> 1978 </year> <month> (August). </month> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677. </pages>
Reference-contexts: When a choice is nondeterministic, the checker explores all alternatives, so it will find an execution leading to a violated assertion if one exists. Syntactically, PROMELA models resemble C programs. They use ! and ? operators to send and receive messages over "channels," a la CSP <ref> (Hoare 1978) </ref>. Although PROMELA permits models in which messages are passed asynchronously using buffered channels, the model presented here uses only unbuffered channels; every send and receive is a synchronization point, as in CSP. This paper does not just describe the model; it contains the model.
Reference: <author> Holzmann, Gerard J. </author> <year> 1991. </year> <title> Design and Validation of Computer Protocols. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: It does not matter whether the target processor has a trace mode. The model is expressed in PROMELA, a formalism whose original purpose was to model network protocols <ref> (Holzmann 1991) </ref>. The correctness condition is given by embedded assertions, which state that the number of executions of I is equal to the number of notifications of the debugger.
Reference: <author> Kessler, Peter B. </author> <year> 1990 </year> <month> (June). </month> <title> Fast breakpoints: </title> <booktitle> Design and implementation. Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 25(6) </volume> <pages> 78-84. </pages>
Reference: <author> Knuth, Donald E. </author> <year> 1984. </year> <title> Literate programming. </title> <journal> The Computer Journal, </journal> <volume> 27(2) </volume> <pages> 97-111. </pages>
Reference-contexts: This paper does not just describe the model; it contains the model. The noweb system (Ramsey 1992a) for "literate programming" <ref> (Knuth 1984) </ref> extracts both the paper and the model from the same source. The source contains prose interleaved with definitions of named code "chunks." Definitions are numbered consecutively with bold numerals. Code chunks contain source code and references to other code chunks.
Reference: <author> Linton, Mark A. </author> <year> 1990 </year> <month> (June). </month> <title> The evolution of Dbx. </title> <booktitle> In Proceedings of the Summer USENIX Conference, </booktitle> <pages> pages 211-220, </pages> <address> Anaheim, CA. </address>
Reference-contexts: If this second thread hits the breakpoint at I, it will not be detected. An early version of the author's debugger ldb demonstrated this problem (Ramsey 1992b). The problem cannot be demonstrated with dbx <ref> (Linton 1990) </ref> or gdb (Stallman and Pesch 1991) because neither is capable of recovering if a procedure call hits a breakpoint while the main target thread is stopped at a breakpoint. 3 Model using communicating sequential processes The debugger, target, and breakpoint implementation are modeled as communicating sequential processes.
Reference: <author> Ramsey, Norman. </author> <year> 1992a </year> <month> (August). </month> <title> Literate-programming tools need not be complex. </title> <type> Technical Report CS-TR-351-91, </type> <institution> Department of Computer Science, Princeton University. </institution> <note> Submitted to IEEE Software. </note> . <year> 1992b </year> <month> (December). </month> <title> A Retargetable Debugger. </title> <type> PhD thesis, </type> <institution> Princeton University, Department of Computer Science. </institution> <note> Also Technical Report CS-TR-403-92. </note>
Reference-contexts: Although PROMELA permits models in which messages are passed asynchronously using buffered channels, the model presented here uses only unbuffered channels; every send and receive is a synchronization point, as in CSP. This paper does not just describe the model; it contains the model. The noweb system <ref> (Ramsey 1992a) </ref> for "literate programming" (Knuth 1984) extracts both the paper and the model from the same source. The source contains prose interleaved with definitions of named code "chunks." Definitions are numbered consecutively with bold numerals. Code chunks contain source code and references to other code chunks.
Reference: <author> Redell, David D. </author> <year> 1989 </year> <month> (January). </month> <title> Experience with Topaz TeleDebugging. </title> <booktitle> Proceedings of the ACM SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, in SIGPLAN Notices, </booktitle> <volume> 24(1) </volume> <pages> 35-44. </pages>
Reference-contexts: Although they use similar breakpoint implementations, the Topaz teledebugger puts the breakpoint implementation in the operating system <ref> (Redell 1989) </ref>; ldb, the author's Unix telede-bugger, puts it in the debugger (Ramsey 1992b). The model assumes it can plant trap instructions in the instruction stream of the target program, and that it will be notified when the target program encounters a trap.
Reference: <author> Stallman, Richard M. and Roland H. Pesch. </author> <year> 1991. </year> <title> Using GDB: A guide to the GNU source-level debugger, GDB version 4.0. </title> <type> Technical report, </type> <institution> Free Software Foundation, </institution> <address> Cambridge, MA. </address>
Reference-contexts: If this second thread hits the breakpoint at I, it will not be detected. An early version of the author's debugger ldb demonstrated this problem (Ramsey 1992b). The problem cannot be demonstrated with dbx (Linton 1990) or gdb <ref> (Stallman and Pesch 1991) </ref> because neither is capable of recovering if a procedure call hits a breakpoint while the main target thread is stopped at a breakpoint. 3 Model using communicating sequential processes The debugger, target, and breakpoint implementation are modeled as communicating sequential processes.
Reference: <author> Wahbe, Robert. </author> <year> 1992 </year> <month> (September). </month> <title> Efficient data breakpoints. </title> <booktitle> Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, in SIGPLAN Notices, </booktitle> <volume> 27(9) </volume> <pages> 200-212. </pages>
References-found: 14

