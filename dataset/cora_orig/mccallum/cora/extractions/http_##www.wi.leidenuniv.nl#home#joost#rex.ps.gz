URL: http://www.wi.leidenuniv.nl/home/joost/rex.ps.gz
Refering-URL: http://www.wi.leidenuniv.nl/home/joost/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Semantics, Orderings and Recursion in the Weakest Precondition Calculus  
Author: Marcello Bonsangue Joost N. Kok 
Keyword: and Phrases: weakest preconditions, predicate transformers, refinement, deadlock, backtracking, fixed points, fixed point transformations, Smyth powerdomain, Egli-Milner powerdomain, recursion, denotational semantics.  
Note: 1991 Mathematics Subject Classification: 68Q55, 68Q10, 68Q60, 06A06. 1991 CR Categories:  Note: The research of Marcello Bonsangue was initially supported by a grant of the  and later by a grant of the  
Address: P.O. Box 4079, 1009 AB Amsterdam, The Netherlands  P.O. Box 80.089, 3508 TB Utrecht, The Netherlands  Milano, Italy,  
Affiliation: CWI  Department of Computer Science, Utrecht University  Universita' degli Studi di  Centro Nazionale delle Ricerche (CNR), Italy.  
Email: marcello@cwi.nl  joost@cs.ruu.nl  
Web: D.3.1, F.1.2, F.3.1, F.3.2.  
Abstract: An extension of Dijkstra's guarded command language is studied, including sequential composition, demonic choice and a backtrack operator. We consider three orderings on this language: a refinement ordering defined by Back, a new deadlock ordering, and an approximation ordering of Nelson. The deadlock ordering is in between the two other orderings. All operators are monotonic in Nelson's ordering, but backtracking is not monotonic in Back's ordering and sequential composition is not monotonic for the deadlock ordering. At first sight recursion can only be added using Nelson's ordering. By extending the theory of fixed points in partial orderings we show that, under certain circumstances, least fixed points for non monotonic functions can be obtained by iteration from the least element. This permits us the addition of recursion even using Back's ordering or the deadlock ordering. In order to give a semantic characterization of the three orderings that relates initial states to possible outcomes of the computation, the relations between predicate transformers and discrete powerdomains is studied. Three powerdomains are considered: two versions of the Smyth powerdomain and the Egli-Milner powerdomain. For each of them an isomorphism is proved with a suitable domain of predicate transformers. 
Abstract-found: 1
Intro-found: 1
Reference: [Abr91] <author> S. Abramsky. </author> <title> A domain equation for bisimulation. </title> <journal> Information and Computation, </journal> <volume> 92 </volume> <pages> 161-218, </pages> <year> 1991. </year>
Reference-contexts: It is considered as an element added by means of a smash product following the ideas of <ref> [HP79, MM79, Plo81, Abr91] </ref>, that is, we have for all A X ? : (A v ; , A = f?g _ A = ;) and also (; v A , A = ;): The partial order E ; :X ? is also complete: f?g is the least element and if
Reference: [AP81] <author> K. R. Apt and G. Plotkin. </author> <title> A Cook's tour of countable nondeterminism. </title> <editor> In S. Evens and O. Kariv, editors, </editor> <booktitle> Proc. 8th ICALP, Akko, number 115 in Lecture Notes in Computer Science, </booktitle> <year> 1981. </year>
Reference-contexts: If P is a complete partial order and f is monotone then f &lt;&gt; always exists and moreover, (f &lt;&gt; ) stabilizes [HP72]. If additionally f is continuous then it has closure ordinal !. The following theorem, taken from <ref> [AP81, AP86] </ref>, shows that under certain circumstances g &lt;&gt; always exists and stabilizes for a monotone function g : Q ! Q even if Q is not a complete partial order: Theorem 4.4 Let (P ; v P ) and (Q; v Q ) be two partial orders, and f :
Reference: [AP86] <author> K. R. Apt and G. Plotkin. </author> <title> Countable nondeterminism and random assignment. </title> <journal> Journal of the ACM, </journal> <volume> 33(4) </volume> <pages> 724-767, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: We start from the well known duality theory connecting the discrete version of the Smyth powerdomain [Smy78] and the Dijkstra's predicate transformers <ref> [Wan77, Plo79, Smy83, Bes83, AP86] </ref>: there is an order isomorphism between functions from a set of states to the Smyth powerdomain (ordered pointwise) and the predicate transformers (ordered by a refinement order). <p> We give some general results on fixed points and we show that under particular conditions they can be obtained (even by iteration) also for non-monotonic functions. Moreover, we give some relationships between discrete powerdomains and predicate transformers, generalizing ideas of [Wan77],[Plo79], [Bes83], [Smy83], and <ref> [AP86] </ref>. Most of the standard notions on domain Theory can be found, for example, in [Plo81]. Let P a partial order and A a nonempty subset of P . Then A is said to be directed if every finite subset of A has an upper bound. <p> If P is a complete partial order and f is monotone then f &lt;&gt; always exists and moreover, (f &lt;&gt; ) stabilizes [HP72]. If additionally f is continuous then it has closure ordinal !. The following theorem, taken from <ref> [AP81, AP86] </ref>, shows that under certain circumstances g &lt;&gt; always exists and stabilizes for a monotone function g : Q ! Q even if Q is not a complete partial order: Theorem 4.4 Let (P ; v P ) and (Q; v Q ) be two partial orders, and f : <p> Proof The proof contains part of the proof of the Theorem 4.4 <ref> [AP86] </ref>: suppose f &lt;&gt; exists (as P is a complete partial order f &lt;&gt; is always defined for each ordinal ). <p> We have g &lt;ff&gt; = h:f &lt;ff&gt; = h:f &lt;ff+1&gt; = h:f :f &lt;ff&gt; = g:h:f &lt;ff&gt; = g:g &lt;ff&gt; : So g &lt;ff&gt; is a fixed point of g. In <ref> [AP86] </ref> this is enough to prove that g &lt;ff&gt; = :g because g is monotone. In our case, we have to prove it. Let y 2 Q such that g:y = y and consider the partial order generated by h 1 :y. <p> In [Dij76] a predicate transformer 2 Pred ! Pred satisfies the properties 1. - 5.; in [Wan77, Plo79] it satisfies the properties 1., 2., 4. and 5.; in [Bes83] the properties 1., 2. and 8.; in <ref> [AP86] </ref> the properties 1., 2. and 6.; and finally in [BvW90] only the property 3. Next we are going to relate these conditions. In order to do this we need the following lemma which is a slight variation of the stability lemma in [AP86]: Lemma 4.9 Let 2 PTran satisfying the <p> the properties 1., 2. and 8.; in <ref> [AP86] </ref> the properties 1., 2. and 6.; and finally in [BvW90] only the property 3. Next we are going to relate these conditions. In order to do this we need the following lemma which is a slight variation of the stability lemma in [AP86]: Lemma 4.9 Let 2 PTran satisfying the -multiplicativity law, and let 2 such that :true:. <p> The predicate transformers as defined in [Bes83] are the same predicate transformers defined in <ref> [AP86] </ref> and the predicate transformers in this 25 last one are also predicate transformers in the sense of our definition 4.11. Finally predicate transformers in the sense of our definition 4.11 are also predicate transformers in the sense of [BvW90]. <p> Finally predicate transformers in the sense of our definition 4.11 are also predicate transformers in the sense of [BvW90]. Thus our definition 4.11 generalize the definitions of <ref> [Wan77, Plo79, Bes83, AP86] </ref> and we will generalize some of their results. As far as we know similar results do not hold for the definition of predicate transformers of [BvW90] and this forces us to not consider angelic non-determinism that violates properties 5., 6., 7., and 8.. <p> Next we are going to relate predicate transformers with powerdomains. We generalize the relationship between the Smyth powerdomain and the predicate transformers <ref> [Wan77, Plo79, Bes83, AP86, Smy83] </ref> to new versions of the Smyth powerdomains. Moreover, we will introduce a relationship between the Egli-Milner powerdomain and pair of predicate transformers like is done in [Nel87]. <p> This makes that in general S ffi :X ? is not a complete partial order, for example consider in S ffi :N ? the following directed set which has no upper bound: 28 N v N nf0g v N nf0; 1g v :::; (this example is from <ref> [AP86] </ref>).
Reference: [Bac78] <author> R.-J.R. </author> <title> Back. On the correctness of Refinement Steps in Program Development. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Helsinki, </institution> <year> 1978. </year> <note> Report A-1978-4. </note>
Reference-contexts: 1 Introduction The weakest precondition calculus of Dijkstra identifies statements in the guarded command language with weakest precondition predicate transformers (see [Dij76]). The language was extended to use it as a vehicle for program refinement. Specification constructs were added and a refinement ordering was defined. This approach was introduced in <ref> [Bac78, Bac80] </ref> and is suited for refinement (see [BvW90, Bac90] and also [MRG88, Mor87]). This ordering can be used to add recursion to the language, but not in a fully compositional way. For example, for each set of guards there is a different conditional command. <p> We start by two orderings that can be defined by means of weakest preconditions. The first ordering v B was proposed by Back <ref> [Bac78, Bac80] </ref> and is suited for refinement (see [Bac90] and also [Mor87, MRG88]). <p> We proposed an extension of the Dijkstra's Weakest Precondition Calculus in order to treat recursion in a fully compositional way with respect to three different orders: a refinement order as introduced in <ref> [Bac78] </ref>, a new refinement order that respects deadlock, and an approximation order as introduced in [Nel87]. 2. We showed that (under certain circumstances), least fixed points of functions (even non-monotone) between partial orders exist and that they can be obtained by iteration from the least element. 3.
Reference: [Bac80] <author> R.-J.R. </author> <title> Back. Correctness Preserving Program Refinements: Proof Theory and Applications, volume 131 of Mathematical Centre Tracts. </title> <publisher> Mathematical Centre, </publisher> <address> Amsterdam, </address> <year> 1980. </year>
Reference-contexts: 1 Introduction The weakest precondition calculus of Dijkstra identifies statements in the guarded command language with weakest precondition predicate transformers (see [Dij76]). The language was extended to use it as a vehicle for program refinement. Specification constructs were added and a refinement ordering was defined. This approach was introduced in <ref> [Bac78, Bac80] </ref> and is suited for refinement (see [BvW90, Bac90] and also [MRG88, Mor87]). This ordering can be used to add recursion to the language, but not in a fully compositional way. For example, for each set of guards there is a different conditional command. <p> We start by two orderings that can be defined by means of weakest preconditions. The first ordering v B was proposed by Back <ref> [Bac78, Bac80] </ref> and is suited for refinement (see [Bac90] and also [Mor87, MRG88]).
Reference: [Bac90] <author> R.-J.R. </author> <title> Back. Refinement calculus, part ii: Parallel and reactive programs. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </title> <booktitle> number 430 in Lecture Notes in Computer Science, </booktitle> <pages> pages 67-93, </pages> <year> 1990. </year>
Reference-contexts: The language was extended to use it as a vehicle for program refinement. Specification constructs were added and a refinement ordering was defined. This approach was introduced in [Bac78, Bac80] and is suited for refinement (see <ref> [BvW90, Bac90] </ref> and also [MRG88, Mor87]). This ordering can be used to add recursion to the language, but not in a fully compositional way. For example, for each set of guards there is a different conditional command. <p> We start by two orderings that can be defined by means of weakest preconditions. The first ordering v B was proposed by Back [Bac78, Bac80] and is suited for refinement (see <ref> [Bac90] </ref> and also [Mor87, MRG88]).
Reference: [Bak80] <author> J. W. de Bakker. </author> <title> Mathematical Theory of Program Corretness. </title> <publisher> Prentice-Hall, </publisher> <year> 1980. </year>
Reference-contexts: For example, for each set of guards there is a different conditional command. An early treatment of recursion, depending on continuity, was given in [Roe76], and a more detailed treatment was given in [Heh79] and <ref> [Bak80] </ref>. Inspired by this last work, recursion was added in a fully compositional way by Nelson in [Nel87]: the guarded command language was embedded in a language with sequential composition, demonic choice and a backtrack operator in which the operators can be used freely. <p> The following theorem relates the weakest precondition semantics with the operational semantics as in <ref> [Bak80] </ref>; at first let us generalize predicates P from to (P: [ ? ) by P : ?= false and P :X = (8 2 X : P :). Theorem 2.5 Let S 2 Stat and P 2 Pred .
Reference: [Bes83] <author> E. </author> <title> Best. Relational semantic of concurrent programs (with some applications). </title> <editor> In D. Bjorner, editor, </editor> <booktitle> Proc. of the IFIP Working Conference on on Formal Description of Programming Concepts - II, </booktitle> <pages> pages 431-452, </pages> <address> Garmisch-Partenkirchen, FRG, 1983. </address> <publisher> North-Holland Publishing Company. </publisher>
Reference-contexts: We start from the well known duality theory connecting the discrete version of the Smyth powerdomain [Smy78] and the Dijkstra's predicate transformers <ref> [Wan77, Plo79, Smy83, Bes83, AP86] </ref>: there is an order isomorphism between functions from a set of states to the Smyth powerdomain (ordered pointwise) and the predicate transformers (ordered by a refinement order). <p> We give some general results on fixed points and we show that under particular conditions they can be obtained (even by iteration) also for non-monotonic functions. Moreover, we give some relationships between discrete powerdomains and predicate transformers, generalizing ideas of [Wan77],[Plo79], <ref> [Bes83] </ref>, [Smy83], and [AP86]. Most of the standard notions on domain Theory can be found, for example, in [Plo81]. Let P a partial order and A a nonempty subset of P . Then A is said to be directed if every finite subset of A has an upper bound. <p> In [Dij76] a predicate transformer 2 Pred ! Pred satisfies the properties 1. - 5.; in [Wan77, Plo79] it satisfies the properties 1., 2., 4. and 5.; in <ref> [Bes83] </ref> the properties 1., 2. and 8.; in [AP86] the properties 1., 2. and 6.; and finally in [BvW90] only the property 3. Next we are going to relate these conditions. <p> Then we have 4: ^ 5: ) 6: , 7: , 8: ) 3: Proof 4: ^ 5: ) 8:) A proof is given in <ref> [Bes83] </ref>. 8: ) 6: ) 7:) Clearly multiplicativity implies countable multiplicativity, and this implies the -multiplicativity since is countable. 7: ) 8:) Let fP i 2 Pred ji 2 I g be a set of predicates on where I 6= ; (but possibly, I is uncountable) and let be a predicate <p> The previous lemma together with the lemma 4.2 show that predicate transformers as defined in [Dij76] are the same predicate transformers in the sense of [Wan77, Plo79], and these are predicate transformers as defined in <ref> [Bes83] </ref>. The predicate transformers as defined in [Bes83] are the same predicate transformers defined in [AP86] and the predicate transformers in this 25 last one are also predicate transformers in the sense of our definition 4.11. <p> The previous lemma together with the lemma 4.2 show that predicate transformers as defined in [Dij76] are the same predicate transformers in the sense of [Wan77, Plo79], and these are predicate transformers as defined in <ref> [Bes83] </ref>. The predicate transformers as defined in [Bes83] are the same predicate transformers defined in [AP86] and the predicate transformers in this 25 last one are also predicate transformers in the sense of our definition 4.11. Finally predicate transformers in the sense of our definition 4.11 are also predicate transformers in the sense of [BvW90]. <p> Finally predicate transformers in the sense of our definition 4.11 are also predicate transformers in the sense of [BvW90]. Thus our definition 4.11 generalize the definitions of <ref> [Wan77, Plo79, Bes83, AP86] </ref> and we will generalize some of their results. As far as we know similar results do not hold for the definition of predicate transformers of [BvW90] and this forces us to not consider angelic non-determinism that violates properties 5., 6., 7., and 8.. <p> Next we are going to relate predicate transformers with powerdomains. We generalize the relationship between the Smyth powerdomain and the predicate transformers <ref> [Wan77, Plo79, Bes83, AP86, Smy83] </ref> to new versions of the Smyth powerdomains. Moreover, we will introduce a relationship between the Egli-Milner powerdomain and pair of predicate transformers like is done in [Nel87].
Reference: [BvW90] <author> R.-J.R. Back and J. von Wright. </author> <title> Refinement calculus, part i: Sequential nondeterministic programs. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </title> <booktitle> number 430 in Lecture Notes in Computer Science, </booktitle> <pages> pages 42-66, </pages> <year> 1990. </year>
Reference-contexts: The language was extended to use it as a vehicle for program refinement. Specification constructs were added and a refinement ordering was defined. This approach was introduced in [Bac78, Bac80] and is suited for refinement (see <ref> [BvW90, Bac90] </ref> and also [MRG88, Mor87]). This ordering can be used to add recursion to the language, but not in a fully compositional way. For example, for each set of guards there is a different conditional command. <p> S 1 v N S 2 ^ S 0 2 ) (8op 2 f; ; 2; 3g : S 1 opS 0 2 ): Proof For the orderings v B and v N we refer to <ref> [BvW90] </ref> and [Nel87], respectively. <p> In [Dij76] a predicate transformer 2 Pred ! Pred satisfies the properties 1. - 5.; in [Wan77, Plo79] it satisfies the properties 1., 2., 4. and 5.; in [Bes83] the properties 1., 2. and 8.; in [AP86] the properties 1., 2. and 6.; and finally in <ref> [BvW90] </ref> only the property 3. Next we are going to relate these conditions. In order to do this we need the following lemma which is a slight variation of the stability lemma in [AP86]: Lemma 4.9 Let 2 PTran satisfying the -multiplicativity law, and let 2 such that :true:. <p> Finally predicate transformers in the sense of our definition 4.11 are also predicate transformers in the sense of <ref> [BvW90] </ref>. Thus our definition 4.11 generalize the definitions of [Wan77, Plo79, Bes83, AP86] and we will generalize some of their results. As far as we know similar results do not hold for the definition of predicate transformers of [BvW90] and this forces us to not consider angelic non-determinism that violates properties <p> of our definition 4.11 are also predicate transformers in the sense of <ref> [BvW90] </ref>. Thus our definition 4.11 generalize the definitions of [Wan77, Plo79, Bes83, AP86] and we will generalize some of their results. As far as we know similar results do not hold for the definition of predicate transformers of [BvW90] and this forces us to not consider angelic non-determinism that violates properties 5., 6., 7., and 8.. Next we are going to relate predicate transformers with powerdomains. <p> A declaration assigns to each procedure variable a statement, possibly containing procedure variables. The idea is to associate with a declaration an environment by means of a fixed point construction. We add simultaneous recursion to our language (as opposed to adding for example -recursion as it is done in <ref> [BvW90, vW90] </ref>). Our motivation for having simultaneous recursion is that we developed the original theory for PROLOG programs that have this form of recursion, but we do not expect problems when we add -recursion.
Reference: [Dij76] <author> E.W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: 1 Introduction The weakest precondition calculus of Dijkstra identifies statements in the guarded command language with weakest precondition predicate transformers (see <ref> [Dij76] </ref>). The language was extended to use it as a vehicle for program refinement. Specification constructs were added and a refinement ordering was defined. This approach was introduced in [Bac78, Bac80] and is suited for refinement (see [BvW90, Bac90] and also [MRG88, Mor87]). <p> To guide the intuition about this language we give an operational semantic model below that relates initial states with possible outcomes of the computation. Dijkstra's guarded command language <ref> [Dij76] </ref> can be seen as a subset of this language, except for the dood-construct which will be handled when we add recursion. <p> In <ref> [Dij76] </ref> a predicate transformer 2 Pred ! Pred satisfies the properties 1. - 5.; in [Wan77, Plo79] it satisfies the properties 1., 2., 4. and 5.; in [Bes83] the properties 1., 2. and 8.; in [AP86] the properties 1., 2. and 6.; and finally in [BvW90] only the property 3. <p> From now on, we will consider the following definition of predicate transformers: Definition 4.11 A predicate transformer is any function 2 PTran = Pred ! Pred which satisfies the multiplicativity law. The previous lemma together with the lemma 4.2 show that predicate transformers as defined in <ref> [Dij76] </ref> are the same predicate transformers in the sense of [Wan77, Plo79], and these are predicate transformers as defined in [Bes83].
Reference: [EM85] <author> H. Ehrig and B. Mahr. </author> <title> Fundamentals of Algebraic Specification 1, volume 6 of EATCS monographs. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: We give a tecnique to derive a compositional semantics a least fixed point semantics using a domain transformation. 6.1 Compositional Semantics We start by giving some general definitions (see [GTWW77], <ref> [EM85] </ref> and reference there). A signature S = (F ; r ) consists of a set (f 2)F of function names, and a rank function r : F ! N , indicating for each function symbol its arity. Function names with arity 0 are called constants. <p> ::; u r (f ) ; v 1 ; :::; v r (f) (81 i r (f ) : u i v i ) f (u 1 ; ::; u r (f) ) f (v 1 ; :::; v r (f) )): The following lemma is standard, see for example <ref> [EM85] </ref>: Lemma 6.4 Let D : T (S ) ! Dom be a semantic function, and let D T (S )fiT (S ) be defined by s D t , D (s) = D (t). Then D is compositional if and only if D is a congruence.
Reference: [GTWW77] <author> J.A. Goguen, J.W. Thatcher, E.G. Wagner, and J.B. Wright. </author> <title> Initial algebra semantics and continuous algebras. </title> <journal> Journ. ACM, </journal> <volume> 24 </volume> <pages> 68-95, </pages> <year> 1977. </year>
Reference-contexts: We give a tecnique to derive a compositional semantics a least fixed point semantics using a domain transformation. 6.1 Compositional Semantics We start by giving some general definitions (see <ref> [GTWW77] </ref>, [EM85] and reference there). A signature S = (F ; r ) consists of a set (f 2)F of function names, and a rank function r : F ! N , indicating for each function symbol its arity. Function names with arity 0 are called constants.
Reference: [Heh79] <author> E.C.R. Hehner. </author> <title> do consider od: a contribution to programming calculus. </title> <journal> Acta informatica, </journal> <volume> 11 </volume> <pages> 287-304, </pages> <year> 1979. </year>
Reference-contexts: For example, for each set of guards there is a different conditional command. An early treatment of recursion, depending on continuity, was given in [Roe76], and a more detailed treatment was given in <ref> [Heh79] </ref> and [Bak80]. Inspired by this last work, recursion was added in a fully compositional way by Nelson in [Nel87]: the guarded command language was embedded in a language with sequential composition, demonic choice and a backtrack operator in which the operators can be used freely.
Reference: [Hes89] <author> W.H. Hesselink. </author> <title> Predicate transformer semantics of general recursion. </title> <journal> Acta Infor-matica, </journal> <volume> 26 </volume> <pages> 309-332, </pages> <year> 1989. </year>
Reference-contexts: A form of infinite behaviour (the loop-statement) is added to the language to distinguish different orderings on the language. A similar language is studied in [Nel87]: the only difference is that we have split actions as in <ref> [Hes89] </ref> in the sense that we consider as atomic actions both the assignment actions v := t and the test actions b !. To guide the intuition about this language we give an operational semantic model below that relates initial states with possible outcomes of the computation.
Reference: [HP72] <author> P. Hitchcock and D. Park. </author> <title> Induction rules and termination proofs. </title> <booktitle> In International Conference on Automata, Languages and Programming, </booktitle> <year> 1972. </year> <month> 53 </month>
Reference-contexts: It is well known that a monotone and continuous function from a complete partial order to itself has least fixed point that can be obtained by iteration from the least element. This result was extended at first by Hitchcock and Park <ref> [HP72] </ref> showing that for a function from a complete partial order to itself is enough to be monotone in order to have a least fixed point. <p> If P is a complete partial order and f is monotone then f &lt;&gt; always exists and moreover, (f &lt;&gt; ) stabilizes <ref> [HP72] </ref>. If additionally f is continuous then it has closure ordinal !.
Reference: [HP79] <author> M. Hennessy and G. D. Plotkin. </author> <title> Full abstraction for a simple parallel programming language. </title> <editor> In J. Becvar, editor, </editor> <booktitle> Proc. 8th Int'l Symp. on Mathematical Foundations on Computer Science, volume 74 of Lecture Notes in Computer Science, </booktitle> <pages> pages 108-120. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1979. </year>
Reference-contexts: It is considered as an element added by means of a smash product following the ideas of <ref> [HP79, MM79, Plo81, Abr91] </ref>, that is, we have for all A X ? : (A v ; , A = f?g _ A = ;) and also (; v A , A = ;): The partial order E ; :X ? is also complete: f?g is the least element and if
Reference: [Mey85] <author> J.-J.Ch. Meyer. </author> <title> Programming Calculi Based on Fixed Point Transformations: Semantics and Applications. </title> <type> PhD thesis, </type> <institution> Vrije Universiteit, </institution> <address> Amsterdam, </address> <year> 1985. </year>
Reference-contexts: The use of commutative diagrams to transfer fixed point properties from a domain to another has been explored in detail in Meyer <ref> [Mey85] </ref>. Finally, here we show that the least fixed point property can be transferred, via a commutative diagram, also to functions (even non monotone) from a partial order to itself. <p> In particular if :f exists (being an f &lt;&gt; ) then so does :g and :g = h::f . Several generalizations (always with monotone functions making the diagram above commutes) and applications of the theorem above, often called transfer lemma, can be found in <ref> [Mey85] </ref>.
Reference: [MM79] <author> G. Milne and R. Milner. </author> <title> Concurrent processes and their syntax. </title> <journal> J. ACM, </journal> <volume> 26, 2 </volume> <pages> 302-321, </pages> <year> 1979. </year>
Reference-contexts: It is considered as an element added by means of a smash product following the ideas of <ref> [HP79, MM79, Plo81, Abr91] </ref>, that is, we have for all A X ? : (A v ; , A = f?g _ A = ;) and also (; v A , A = ;): The partial order E ; :X ? is also complete: f?g is the least element and if
Reference: [Mor87] <author> J. Morris. </author> <title> A theoretical basis for stepwise refinement and the programming calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9 </volume> <pages> 287-306, </pages> <year> 1987. </year>
Reference-contexts: The language was extended to use it as a vehicle for program refinement. Specification constructs were added and a refinement ordering was defined. This approach was introduced in [Bac78, Bac80] and is suited for refinement (see [BvW90, Bac90] and also <ref> [MRG88, Mor87] </ref>). This ordering can be used to add recursion to the language, but not in a fully compositional way. For example, for each set of guards there is a different conditional command. <p> We start by two orderings that can be defined by means of weakest preconditions. The first ordering v B was proposed by Back [Bac78, Bac80] and is suited for refinement (see [Bac90] and also <ref> [Mor87, MRG88] </ref>).
Reference: [MRG88] <author> C.C. Morgan, K.A. Robinson, and P.H.B. Gardiner. </author> <title> On the refinement calculus. </title> <type> Technical Report PRG-70, </type> <institution> Programming Research Group, </institution> <year> 1988. </year>
Reference-contexts: The language was extended to use it as a vehicle for program refinement. Specification constructs were added and a refinement ordering was defined. This approach was introduced in [Bac78, Bac80] and is suited for refinement (see [BvW90, Bac90] and also <ref> [MRG88, Mor87] </ref>). This ordering can be used to add recursion to the language, but not in a fully compositional way. For example, for each set of guards there is a different conditional command. <p> We start by two orderings that can be defined by means of weakest preconditions. The first ordering v B was proposed by Back [Bac78, Bac80] and is suited for refinement (see [Bac90] and also <ref> [Mor87, MRG88] </ref>).
Reference: [Nel87] <author> G. Nelson. </author> <title> A generalization of Dijkstra's calculus. </title> <type> Technical Report 16, </type> <institution> Digital Systems Research Center, </institution> <year> 1987. </year>
Reference-contexts: An early treatment of recursion, depending on continuity, was given in [Roe76], and a more detailed treatment was given in [Heh79] and [Bak80]. Inspired by this last work, recursion was added in a fully compositional way by Nelson in <ref> [Nel87] </ref>: the guarded command language was embedded in a language with sequential composition, demonic choice and a backtrack operator in which the operators can be used freely. An ordering is given for which the operators are all monotonic. <p> It is defined with the additional notion of weakest liberal preconditions. A different approach for the addition of recursive procedures is to consider fixed point equations over predicates instead of recursion over predicate transformers, (see a discussion in <ref> [Nel87] </ref>) but this approach is not considered here. 2 Our starting point is the language of [Nel87]. In this language we also have a form of infinite behaviour (a loop construct) and atomic actions that can deadlock (to initiate backtracking). <p> A different approach for the addition of recursive procedures is to consider fixed point equations over predicates instead of recursion over predicate transformers, (see a discussion in <ref> [Nel87] </ref>) but this approach is not considered here. 2 Our starting point is the language of [Nel87]. In this language we also have a form of infinite behaviour (a loop construct) and atomic actions that can deadlock (to initiate backtracking). <p> A similar result is also proved for the Egli-Milner powerdomain (extended with the empty set too, in in order to treat deadlock) showing an isomorphism between the Egli Milner state transformation and the Nelson's predicate transformers like is done in <ref> [Nel87] </ref>. 3 2 Language and Semantics We first introduce the language. We use the notation (d 2)Dom to introduce the domain Dom and a typical element d of this domain. <p> A form of infinite behaviour (the loop-statement) is added to the language to distinguish different orderings on the language. A similar language is studied in <ref> [Nel87] </ref>: the only difference is that we have split actions as in [Hes89] in the sense that we consider as atomic actions both the assignment actions v := t and the test actions b !. <p> Then wp:S :Q , (wp:S :true ^ wlp:S :Q): Since wp is monotone we have wp:S :Q ) wp:S :true, and hence by the theorem above also wp:S :Q ) wlp:S :Q. Now we can give a third ordering which was introduced by Nelson in <ref> [Nel87] </ref>. <p> S 1 v N S 2 ^ S 0 2 ) (8op 2 f; ; 2; 3g : S 1 opS 0 2 ): Proof For the orderings v B and v N we refer to [BvW90] and <ref> [Nel87] </ref>, respectively. <p> We generalize the relationship between the Smyth powerdomain and the predicate transformers [Wan77, Plo79, Bes83, AP86, Smy83] to new versions of the Smyth powerdomains. Moreover, we will introduce a relationship between the Egli-Milner powerdomain and pair of predicate transformers like is done in <ref> [Nel87] </ref>. <p> Note that in this case the non-terminating computation are represented by the element ? in the set of all the possible computations. The empty set is interpreted as a deadlock. The Egli-Milner State-Transformers are in the following relation with the so-called Nelson predicate transformers <ref> [Nel87] </ref>, that are introduced in the next definition: Definition 4.29 Define the Nelson's predicate transformers PTran N to be the set of all the functions 2 Pred ! Pred fi Pred such that: 1. # 1 : 2 PTran, 2. # 2 : 2 PTran, 3. (8Q 2 Pred :# 1 <p> We proposed an extension of the Dijkstra's Weakest Precondition Calculus in order to treat recursion in a fully compositional way with respect to three different orders: a refinement order as introduced in [Bac78], a new refinement order that respects deadlock, and an approximation order as introduced in <ref> [Nel87] </ref>. 2. We showed that (under certain circumstances), least fixed points of functions (even non-monotone) between partial orders exist and that they can be obtained by iteration from the least element. 3.
Reference: [Plo79] <author> G. D. Plotkin. </author> <title> Dijkstra's predicate transformer and Smyth's powerdomain. </title> <booktitle> In Proceedings of the Winter School on Abstract Software Specification, volume 86 of Lecture Notes in Computer Science, </booktitle> <pages> pages 527-553. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1979. </year>
Reference-contexts: We start from the well known duality theory connecting the discrete version of the Smyth powerdomain [Smy78] and the Dijkstra's predicate transformers <ref> [Wan77, Plo79, Smy83, Bes83, AP86] </ref>: there is an order isomorphism between functions from a set of states to the Smyth powerdomain (ordered pointwise) and the predicate transformers (ordered by a refinement order). <p> In [Dij76] a predicate transformer 2 Pred ! Pred satisfies the properties 1. - 5.; in <ref> [Wan77, Plo79] </ref> it satisfies the properties 1., 2., 4. and 5.; in [Bes83] the properties 1., 2. and 8.; in [AP86] the properties 1., 2. and 6.; and finally in [BvW90] only the property 3. Next we are going to relate these conditions. <p> The previous lemma together with the lemma 4.2 show that predicate transformers as defined in [Dij76] are the same predicate transformers in the sense of <ref> [Wan77, Plo79] </ref>, and these are predicate transformers as defined in [Bes83]. The predicate transformers as defined in [Bes83] are the same predicate transformers defined in [AP86] and the predicate transformers in this 25 last one are also predicate transformers in the sense of our definition 4.11. <p> Finally predicate transformers in the sense of our definition 4.11 are also predicate transformers in the sense of [BvW90]. Thus our definition 4.11 generalize the definitions of <ref> [Wan77, Plo79, Bes83, AP86] </ref> and we will generalize some of their results. As far as we know similar results do not hold for the definition of predicate transformers of [BvW90] and this forces us to not consider angelic non-determinism that violates properties 5., 6., 7., and 8.. <p> Next we are going to relate predicate transformers with powerdomains. We generalize the relationship between the Smyth powerdomain and the predicate transformers <ref> [Wan77, Plo79, Bes83, AP86, Smy83] </ref> to new versions of the Smyth powerdomains. Moreover, we will introduce a relationship between the Egli-Milner powerdomain and pair of predicate transformers like is done in [Nel87].
Reference: [Plo81] <editor> G.D. Plotkin. </editor> <booktitle> Post-graduate lecture notes in advanced domain theory (incorporating the "Pisa Notes"). </booktitle> <institution> Department of Computer Science, Univ. of Edinburgh, </institution> <year> 1981. </year>
Reference-contexts: Moreover, we give some relationships between discrete powerdomains and predicate transformers, generalizing ideas of [Wan77],[Plo79], [Bes83], [Smy83], and [AP86]. Most of the standard notions on domain Theory can be found, for example, in <ref> [Plo81] </ref>. Let P a partial order and A a nonempty subset of P . Then A is said to be directed if every finite subset of A has an upper bound. <p> It is considered as an element added by means of a smash product following the ideas of <ref> [HP79, MM79, Plo81, Abr91] </ref>, that is, we have for all A X ? : (A v ; , A = f?g _ A = ;) and also (; v A , A = ;): The partial order E ; :X ? is also complete: f?g is the least element and if
Reference: [Roe76] <author> W.P. de Roever. </author> <title> Dijkstra's predicate transformer, non-determinism, recursion, </title> <booktitle> and terminations. In Mathematical foundations of computer science, volume 45 of Lecture Notes in Computer Science, </booktitle> <pages> pages 472-481. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1976. </year>
Reference-contexts: This ordering can be used to add recursion to the language, but not in a fully compositional way. For example, for each set of guards there is a different conditional command. An early treatment of recursion, depending on continuity, was given in <ref> [Roe76] </ref>, and a more detailed treatment was given in [Heh79] and [Bak80].
Reference: [Smy78] <author> M.B. Smyth. </author> <title> Power domains. </title> <institution> J. Comput. Syst. Sci., 16,1:23-36, </institution> <year> 1978. </year>
Reference-contexts: Next we provide a semantic characterization of the three weakest precondition models based on a denotational semantic model for the language that relates initial states to possible outcomes of the computation. We start from the well known duality theory connecting the discrete version of the Smyth powerdomain <ref> [Smy78] </ref> and the Dijkstra's predicate transformers [Wan77, Plo79, Smy83, Bes83, AP86]: there is an order isomorphism between functions from a set of states to the Smyth powerdomain (ordered pointwise) and the predicate transformers (ordered by a refinement order). <p> powerdomain of X ? (with empty set), is defined as the partial order S ; :X ? = fAj A X g [ fX ? g ordered by the superset order, that is A v B , A B : This definition differs from the original definition of Smyth's powerdomain <ref> [Smy78] </ref> because we add the empty set as a top element. Moreover we have no restriction on the cardinality of X . <p> ? = fAj A X ^ A 6= ;g [ fX ? g [ fffig ordered by A v B , (A = X ? ) _ (A = ffi ^ B = ffi) _ (A B ): This definition differs from both the original definition of the Smyth powerdomain <ref> [Smy78] </ref> and the definition above of Smyth's powerdomain with empty set because we have no empty set and moreover we add an extra element ffi (interpreted as deadlock) that is comparable only with itself and the bottom.
Reference: [Smy83] <author> M.B. Smyth. </author> <title> Power domains and predicate transformers: A topological view. </title> <booktitle> In Proceedings of ICALP '83 (Barcelona), volume 154 of Lecture Notes in Computer Science, </booktitle> <pages> pages 662-675. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1983. </year>
Reference-contexts: We start from the well known duality theory connecting the discrete version of the Smyth powerdomain [Smy78] and the Dijkstra's predicate transformers <ref> [Wan77, Plo79, Smy83, Bes83, AP86] </ref>: there is an order isomorphism between functions from a set of states to the Smyth powerdomain (ordered pointwise) and the predicate transformers (ordered by a refinement order). <p> We give some general results on fixed points and we show that under particular conditions they can be obtained (even by iteration) also for non-monotonic functions. Moreover, we give some relationships between discrete powerdomains and predicate transformers, generalizing ideas of [Wan77],[Plo79], [Bes83], <ref> [Smy83] </ref>, and [AP86]. Most of the standard notions on domain Theory can be found, for example, in [Plo81]. Let P a partial order and A a nonempty subset of P . Then A is said to be directed if every finite subset of A has an upper bound. <p> Next we are going to relate predicate transformers with powerdomains. We generalize the relationship between the Smyth powerdomain and the predicate transformers <ref> [Wan77, Plo79, Bes83, AP86, Smy83] </ref> to new versions of the Smyth powerdomains. Moreover, we will introduce a relationship between the Egli-Milner powerdomain and pair of predicate transformers like is done in [Nel87].
Reference: [vW90] <author> J. von Wright. </author> <title> A Lattice-theoretical Basis for Program Refinement. </title> <type> PhD thesis, </type> <institution> Abo Akademi, </institution> <year> 1990. </year>
Reference-contexts: A declaration assigns to each procedure variable a statement, possibly containing procedure variables. The idea is to associate with a declaration an environment by means of a fixed point construction. We add simultaneous recursion to our language (as opposed to adding for example -recursion as it is done in <ref> [BvW90, vW90] </ref>). Our motivation for having simultaneous recursion is that we developed the original theory for PROLOG programs that have this form of recursion, but we do not expect problems when we add -recursion.
Reference: [Wan77] <author> M. Wand. </author> <title> A characterisation of weakest preconditions. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 15 </volume> <pages> 209-212, </pages> <year> 1977. </year>
Reference-contexts: We start from the well known duality theory connecting the discrete version of the Smyth powerdomain [Smy78] and the Dijkstra's predicate transformers <ref> [Wan77, Plo79, Smy83, Bes83, AP86] </ref>: there is an order isomorphism between functions from a set of states to the Smyth powerdomain (ordered pointwise) and the predicate transformers (ordered by a refinement order). <p> In [Dij76] a predicate transformer 2 Pred ! Pred satisfies the properties 1. - 5.; in <ref> [Wan77, Plo79] </ref> it satisfies the properties 1., 2., 4. and 5.; in [Bes83] the properties 1., 2. and 8.; in [AP86] the properties 1., 2. and 6.; and finally in [BvW90] only the property 3. Next we are going to relate these conditions. <p> The previous lemma together with the lemma 4.2 show that predicate transformers as defined in [Dij76] are the same predicate transformers in the sense of <ref> [Wan77, Plo79] </ref>, and these are predicate transformers as defined in [Bes83]. The predicate transformers as defined in [Bes83] are the same predicate transformers defined in [AP86] and the predicate transformers in this 25 last one are also predicate transformers in the sense of our definition 4.11. <p> Finally predicate transformers in the sense of our definition 4.11 are also predicate transformers in the sense of [BvW90]. Thus our definition 4.11 generalize the definitions of <ref> [Wan77, Plo79, Bes83, AP86] </ref> and we will generalize some of their results. As far as we know similar results do not hold for the definition of predicate transformers of [BvW90] and this forces us to not consider angelic non-determinism that violates properties 5., 6., 7., and 8.. <p> Next we are going to relate predicate transformers with powerdomains. We generalize the relationship between the Smyth powerdomain and the predicate transformers <ref> [Wan77, Plo79, Bes83, AP86, Smy83] </ref> to new versions of the Smyth powerdomains. Moreover, we will introduce a relationship between the Egli-Milner powerdomain and pair of predicate transformers like is done in [Nel87].
Reference: [Wec92] <author> E. Wechler. </author> <title> Universal Algebra for Computer Scientists, volume 25 of EATCS monographs. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: 0 (d (x ))((h ffi ~) = h ( ^ D (d (x ))(~)) = h ( ^ D (~)(x )) Finally, applying the transfer lemmas 4.4, 4.5, and 4.6 we can prove the following theorem that can be seen as a generalization of the Mezei-Wright theorem on !-complete algebras <ref> [Wec92] </ref>: Theorem 6.15 Let S rec be a signature union of a signature S and a set of constant PVar .
References-found: 29

