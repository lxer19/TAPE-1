URL: http://www.cs.jhu.edu/~cypher/pubs/semantics.ps
Refering-URL: http://www.cs.jhu.edu/~cypher/pubs/pubs.html
Root-URL: http://www.cs.jhu.edu
Email: cypher@watson.ibm.com leu@almaden.ibm.com  
Title: The Semantics of Blocking and Nonblocking Send and Receive Primitives  
Author: Robert Cypher Eric Leu 
Address: P.O. Box 218 650 Harry Road Yorktown Heights, NY 10598, U.S.A. San Jose, CA 95120, U.S.A.  
Affiliation: IBM Research Division IBM Research Division T.J. Watson Research Center Almaden Research Center  
Abstract: Current message-passing parallel computers provide send and receive primitives with a wide variety of blocking, synchronization, selectivity and ordering properties. Unfortunately, the interactions between the different properties of the send and receive primitives can be extremely complex, and as a result, the precise semantics of these primitives are not well understood. In this paper we present formal models for message-passing systems that provide both synchronous and asynchronous sends, both blocking and nonblocking sends and receives, and a variety of ordering properties. In addition, the receive primitives are very general in that they can specify the desired source and/or tag value of a message. Our models apply to all message-passing programs, including ones with errors, and they apply to parallel computers with arbitrary amounts of buffering. To the best of our knowledge, this is the first time that such rich message-passing models have been defined formally. In addition to presenting the formal models, we also give a number of theorems that capture the properties of the models. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Back, H. Mannila, </author> <title> A Refinement of Kahn's Semantics to Handle Non-Determinism and Communication, </title> <booktitle> Proc. of ACM Symp. on Principles and Distributed Computing, </booktitle> <pages> pp. 111-120, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. Unfortunately, the existing models of message-passing systems are imprecise [2, 5, 6, 7, 13], or they model a very restricted set of send and receive primitives <ref> [1, 3, 8, 9, 10, 11, 14] </ref>, or they apply only to "correct" programs [3, 5, 11]. While it might seem sufficient to consider only correct programs, there are actually two problems with this approach. First, large and complex message-passing programs are likely to contain errors during their development.
Reference: [2] <author> A. Beguelin, J. Dongarra, A. Geist et al., </author> <title> A user's guide to PVM Parallel Virtual Machine, </title> <type> ORNL Technical Report, </type> <institution> ORNL/TM-11826, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: It is common for a single parallel computer or message-passing library to support send and receive primitives with most, or even all, of the synchronization, blocking, and selectivity properties mentioned above <ref> [2, 5, 6, 7, 12, 13, 15] </ref>. As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. <p> As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. Unfortunately, the existing models of message-passing systems are imprecise <ref> [2, 5, 6, 7, 13] </ref>, or they model a very restricted set of send and receive primitives [1, 3, 8, 9, 10, 11, 14], or they apply only to "correct" programs [3, 5, 11].
Reference: [3] <author> R. Cypher, M. Konstantinidou, </author> <title> Bounds on the Efficiency of Message-Passing Protocols for Parallel Computers, </title> <booktitle> Proc. of ACM Symp. on Parallel Algorithms and Architectures, </booktitle> <pages> pp. 173-181, </pages> <year> 1993. </year>
Reference-contexts: As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. Unfortunately, the existing models of message-passing systems are imprecise [2, 5, 6, 7, 13], or they model a very restricted set of send and receive primitives <ref> [1, 3, 8, 9, 10, 11, 14] </ref>, or they apply only to "correct" programs [3, 5, 11]. While it might seem sufficient to consider only correct programs, there are actually two problems with this approach. First, large and complex message-passing programs are likely to contain errors during their development. <p> Unfortunately, the existing models of message-passing systems are imprecise [2, 5, 6, 7, 13], or they model a very restricted set of send and receive primitives [1, 3, 8, 9, 10, 11, 14], or they apply only to "correct" programs <ref> [3, 5, 11] </ref>. While it might seem sufficient to consider only correct programs, there are actually two problems with this approach. First, large and complex message-passing programs are likely to contain errors during their development.
Reference: [4] <author> R. Cypher, E. Leu, </author> <title> Message-Passing Semantics and Portable Parallel Programs, </title> <type> IBM Research Report RJ 9654, </type> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: WAIT-FOR-RECEIVE-TO-BE-MATCHED (id) abbreviated "WR". A WR completes only after a message has been stored into the receive buffer. All of the message-passing primitives discussed in Section 1 map directly to the above commands or a combination of the above commands <ref> [4] </ref>. <p> F6: (kind (a) 2 fWB; WS; WRg ^ matched (a; M )) ) (9b j R + Property F5 states that PS and PR operations never deadlock. Property F6 states that matched WB, WS and WR operations never deadlock. An additional property F7, formally defined in <ref> [4] </ref>, states that the message that is received is actually the same as the message that was sent. <p> Third, the message ordering properties defined in the next section are most easily expressed in terms of ordered executions. Fourth and finally, program properties, such as the absence of racing messages or the dependency on system buffers, are also expressed most easily in terms of ordered executions (see <ref> [4] </ref>). Intuitively, an ordered execution gives a possible order in which the events and the matches in a program execution may have occurred. An ordered execution gives a total ordering of the events and the matches. 3 Definition. <p> F = fF 1; F 2; F 3; F 4g [ fP 3; P 4g. 7 Properties of the Models In this section we give a number of properties regarding the unordered and weakly ordered communication models (all proofs, including the ones for strictly ordered communication, can be found in <ref> [4] </ref>). The definitions of these models depend on the existence of a suitable total ordering of the events and matches in a total execution. <p> Surprisingly enough, ordering properties that are stronger than those of weakly ordered communication appear to make the task of writing correct programs more difficult. As is shown in <ref> [4] </ref>, the strictly ordered communication model can result in compatible PS and PR commands, neither of which has been matched. <p> Each model is defined by specifying exactly which program executions are possible under the given model and which program executions are impossible. We have used a similar approach to define properties of programs (such as the existence of racing messages, see <ref> [4] </ref>). By using the same framework to model both message-passing systems and message-passing programs, we were able to determine which properties are necessary to guarantee the correct execution of a given message-passing program.
Reference: [5] <author> J. Dongarra, R. Hempel, A. Hey, D. Walker, </author> <title> A Proposal for a User-Level, Message-Passing Interface in a Distributed Memory Environment, </title> <address> ORNL/TM-12231, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: It is common for a single parallel computer or message-passing library to support send and receive primitives with most, or even all, of the synchronization, blocking, and selectivity properties mentioned above <ref> [2, 5, 6, 7, 12, 13, 15] </ref>. As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. <p> As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. Unfortunately, the existing models of message-passing systems are imprecise <ref> [2, 5, 6, 7, 13] </ref>, or they model a very restricted set of send and receive primitives [1, 3, 8, 9, 10, 11, 14], or they apply only to "correct" programs [3, 5, 11]. <p> Unfortunately, the existing models of message-passing systems are imprecise [2, 5, 6, 7, 13], or they model a very restricted set of send and receive primitives [1, 3, 8, 9, 10, 11, 14], or they apply only to "correct" programs <ref> [3, 5, 11] </ref>. While it might seem sufficient to consider only correct programs, there are actually two problems with this approach. First, large and complex message-passing programs are likely to contain errors during their development.
Reference: [6] <institution> Express 3.0 Introductory Guide, Parasoft Corporation, </institution> <year> 1990. </year>
Reference-contexts: It is common for a single parallel computer or message-passing library to support send and receive primitives with most, or even all, of the synchronization, blocking, and selectivity properties mentioned above <ref> [2, 5, 6, 7, 12, 13, 15] </ref>. As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. <p> As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. Unfortunately, the existing models of message-passing systems are imprecise <ref> [2, 5, 6, 7, 13] </ref>, or they model a very restricted set of send and receive primitives [1, 3, 8, 9, 10, 11, 14], or they apply only to "correct" programs [3, 5, 11].
Reference: [7] <author> D. Frye, R. Bryant, H. Ho, R. Lawrence, M. Snir, </author> <title> An External User Interface for Scalable Parallel Systems, </title> <type> Technical Report, </type> <institution> IBM Highly Parallel SuperComputing Systems Lab., </institution> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: It is common for a single parallel computer or message-passing library to support send and receive primitives with most, or even all, of the synchronization, blocking, and selectivity properties mentioned above <ref> [2, 5, 6, 7, 12, 13, 15] </ref>. As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. <p> As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. Unfortunately, the existing models of message-passing systems are imprecise <ref> [2, 5, 6, 7, 13] </ref>, or they model a very restricted set of send and receive primitives [1, 3, 8, 9, 10, 11, 14], or they apply only to "correct" programs [3, 5, 11].
Reference: [8] <author> C.A. Hoare, </author> <title> Communicating Sequential Processes, </title> <journal> CACM, </journal> <volume> Vol.21 No. 8, </volume> <pages> pp. 666-677, </pages> <month> Aug. </month> <year> 1978. </year>
Reference-contexts: As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. Unfortunately, the existing models of message-passing systems are imprecise [2, 5, 6, 7, 13], or they model a very restricted set of send and receive primitives <ref> [1, 3, 8, 9, 10, 11, 14] </ref>, or they apply only to "correct" programs [3, 5, 11]. While it might seem sufficient to consider only correct programs, there are actually two problems with this approach. First, large and complex message-passing programs are likely to contain errors during their development.
Reference: [9] <author> G. Kahn, </author> <title> The Semantics of a Simple Language for Parallel Programming, </title> <booktitle> Information Processing 74, </booktitle> <pages> pp. 471-475, </pages> <publisher> North-Holland, </publisher> <year> 1974. </year>
Reference-contexts: As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. Unfortunately, the existing models of message-passing systems are imprecise [2, 5, 6, 7, 13], or they model a very restricted set of send and receive primitives <ref> [1, 3, 8, 9, 10, 11, 14] </ref>, or they apply only to "correct" programs [3, 5, 11]. While it might seem sufficient to consider only correct programs, there are actually two problems with this approach. First, large and complex message-passing programs are likely to contain errors during their development.
Reference: [10] <author> L. Lamport, </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System, </title> <journal> Communications of the ACM 21(7), </journal> <pages> pp. 558-565, </pages> <year> 1978. </year>
Reference-contexts: As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. Unfortunately, the existing models of message-passing systems are imprecise [2, 5, 6, 7, 13], or they model a very restricted set of send and receive primitives <ref> [1, 3, 8, 9, 10, 11, 14] </ref>, or they apply only to "correct" programs [3, 5, 11]. While it might seem sufficient to consider only correct programs, there are actually two problems with this approach. First, large and complex message-passing programs are likely to contain errors during their development. <p> Thus R + p is the "precedes" rela tion and R + u is the "happened-before" relation. Note that R + u is similar to Lamport's happened-before rela tion <ref> [10] </ref>, except that it has been extended to apply to events and matches, and to synchronous and non-blocking communication primitives. 3 Fundamental Properties In this section we will present the fundamental properties that all of the models guarantee.
Reference: [11] <author> E. Leu, A. Schiper, </author> <title> On the Granularity of Events when Modeling Parallel Program Executions, </title> <booktitle> Proc. of 5th IEEE Symposium on Parallel and Distributed Processing, </booktitle> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. Unfortunately, the existing models of message-passing systems are imprecise [2, 5, 6, 7, 13], or they model a very restricted set of send and receive primitives <ref> [1, 3, 8, 9, 10, 11, 14] </ref>, or they apply only to "correct" programs [3, 5, 11]. While it might seem sufficient to consider only correct programs, there are actually two problems with this approach. First, large and complex message-passing programs are likely to contain errors during their development. <p> Unfortunately, the existing models of message-passing systems are imprecise [2, 5, 6, 7, 13], or they model a very restricted set of send and receive primitives [1, 3, 8, 9, 10, 11, 14], or they apply only to "correct" programs <ref> [3, 5, 11] </ref>. While it might seem sufficient to consider only correct programs, there are actually two problems with this approach. First, large and complex message-passing programs are likely to contain errors during their development.
Reference: [12] <institution> Paragon XP/S Overview, Intel Corp., </institution> <year> 1991. </year>
Reference-contexts: It is common for a single parallel computer or message-passing library to support send and receive primitives with most, or even all, of the synchronization, blocking, and selectivity properties mentioned above <ref> [2, 5, 6, 7, 12, 13, 15] </ref>. As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties.
Reference: [13] <author> G. Regnier, </author> <title> Delta Message Passing Protocol, </title> <booktitle> Proc. of First Intel Delta Applications Workshop, </booktitle> <institution> Cal. Inst. of Technology, </institution> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: It is common for a single parallel computer or message-passing library to support send and receive primitives with most, or even all, of the synchronization, blocking, and selectivity properties mentioned above <ref> [2, 5, 6, 7, 12, 13, 15] </ref>. As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. <p> As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. Unfortunately, the existing models of message-passing systems are imprecise <ref> [2, 5, 6, 7, 13] </ref>, or they model a very restricted set of send and receive primitives [1, 3, 8, 9, 10, 11, 14], or they apply only to "correct" programs [3, 5, 11].
Reference: [14] <author> R. Schlichting, F. Schneider, </author> <title> Understanding and Using Asynchronous Message Passing, </title> <booktitle> ACM Symp. on Principles and Distributed Computing, </booktitle> <pages> pp. 141-147, </pages> <address> Ottawa, </address> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties. Unfortunately, the existing models of message-passing systems are imprecise [2, 5, 6, 7, 13], or they model a very restricted set of send and receive primitives <ref> [1, 3, 8, 9, 10, 11, 14] </ref>, or they apply only to "correct" programs [3, 5, 11]. While it might seem sufficient to consider only correct programs, there are actually two problems with this approach. First, large and complex message-passing programs are likely to contain errors during their development.
Reference: [15] <institution> The Connection Machine CM-5 Technical Summary, Thinking Machines Corporation, </institution> <month> Oct. </month> <year> 1991. </year> <month> 7 </month>
Reference-contexts: It is common for a single parallel computer or message-passing library to support send and receive primitives with most, or even all, of the synchronization, blocking, and selectivity properties mentioned above <ref> [2, 5, 6, 7, 12, 13, 15] </ref>. As a result, it is essential to understand exactly how these properties interact with one another and with the message ordering properties.
References-found: 15

