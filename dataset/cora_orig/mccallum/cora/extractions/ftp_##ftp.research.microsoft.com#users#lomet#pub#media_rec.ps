URL: ftp://ftp.research.microsoft.com/users/lomet/pub/media_rec.ps
Refering-URL: http://www.research.microsoft.com/users/lomet/pub/default.htm
Root-URL: http://www.research.microsoft.com
Title: Exploiting A History Database for Backup  
Author: David Lomet Betty Salzberg 
Address: One Kendall Square, Bldg 700 Cambridge, MA 02139  Boston MA 02115  
Affiliation: DEC Cambridge Research Lab  College of Computer Science Northeastern University  
Abstract: Database systems provide media recovery by taking periodic backups and applying a recovery log to a backup to restore the failed media. A transaction-time database is one that retains multiple versions of data, recording with each version the time of the transaction that created it. Such a database provides access to historical versions based on transaction time, and permits reconstruction of timeslices representing the data that were valid at past times. This paper shows how a TSB-tree supported transaction-time database can also provide the backup function of media recovery. Thus, the same versions used for database history are used for database backup. The cost of taking a TSB-tree backup is comparable to that of a conventional differential backup. The media recovery cost, especially when the media failure is partial, e.g. a single disk page, will usually be lower. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bayer, R. and Schkolnick, M. </author> <title> Concurrency of operations on B-trees. </title> <note> Acta Informatica 9 (1977) 1-21. </note>
Reference: [2] <author> Gray, J. </author> <booktitle> Notes on database operating systems. </booktitle> <institution> IBM Research Report RJ2188 (Feb. 1978), IBM Research Division, </institution> <address> San Jose, CA. </address>
Reference-contexts: As with conventional media recovery, the log can be processed so as to optimize the roll forward of the database. This involves what is called "change accumulation" <ref> [2] </ref>. The log is sorted by node and within node by time. The result is that the part of the log relevant to the rolling forward of a node is stored contiguously.
Reference: [3] <author> Guenther, O. and Buchmann, A. </author> <title> Research issues in spatial databases. </title> <booktitle> SIGMOD Record 19,4 (Dec. </booktitle> <year> 1990) </year> <month> 61-68. </month>
Reference-contexts: The implications of splitting policy are explored in depth in [7]. Here we describe only the mechanics of the splitting process. A sequence of splits is illustrated in Figure 2. The TSB-tree exploits clipping <ref> [3] </ref> to cope with its entries that have extents. For versions of records, the extent only exists in the temporal dimension, while index terms are key-time rectangles, and hence have extent in both attributes.
Reference: [4] <author> Lehman, P. and Yao, B. </author> <title> Efficient locking for concurrent operations on B-trees. </title> <journal> ACM Trans. </journal> <note> Database Systems 6,4 (Dec. </note> <year> 1981) </year> <month> 650-670. </month>
Reference-contexts: The current partition of the TSB-tree looks like a B + -tree when it comes to node splits, except that the new history nodes are placed in the history database. However, concurrency is particularly high when using a method based on the B-link tree <ref> [4] </ref>. Such a method which also provides for recovery as well, is described in [8]. Changes made on the leaf level are in separate atomic actions from those made above the leaf level.
Reference: [5] <author> Lomet, D. </author> <title> Consistent timestamping for transactions in distributed systems. </title> <booktitle> Proc. of Conf. on Parallel and Distributed Information Systems, </booktitle> <address> San Diego, CA (Jan. </address> <year> 1993) </year> <month> 48-55. </month>
Reference-contexts: Garbage-collecting the TID-TIME table is outlined in [10]. 2.5 Distributed Transactions Agreeing on and distributing transaction time to the cohorts of a distributed transaction can be handled by augmenting the two-phase commit protocol messages. Cohorts vote not only on whether to commit a transaction, but also on transaction time <ref> [5] </ref>. The time chosen by the coordinator is not earlier than the times voted by cohorts. Hence, while a transaction is PREPARED, a lower bound for its commit time is known, i.e. the time voted by the cohort.
Reference: [6] <author> Lomet, D. and Salzberg, B. </author> <title> Access methods for multiversion data. </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Portland, OR (June 1989) 315-324. </address>
Reference-contexts: When the database is large (multiple gigabytes), a complete fuzzy dump becomes very expensive. Then differential backups, also fuzzy, which only copy pages changed since the last backup become very desirable. In this paper, we show how to use a temporal indexing method, the time-split B-tree or TSB-tree <ref> [6, 7] </ref>, for differential backup of the database. The TSB-tree is particularly suited to the task of supporting a transaction-time database. It is a multiattribute access method that accesses data by key and by transaction time. <p> Section 6 outlines media recovery, how one can find the backup copies of nodes and how the log is applied. We end with a brief discussion. 2 The TSB-tree 2.1 Overview The TSB-tree search algorithm and its split algorithms for index and data nodes, as originally described in <ref> [6] </ref>, are recapped below. Using the TSB-tree for backup requires a specific (and different) time-splitting strategy. Backup-induced splitting is described in subsequent sections. Data records in a transaction-time database correspond to a line segment (one key value) in the time-key space.
Reference: [7] <author> Lomet, D. and Salzberg, B. </author> <title> The performance of a multiversion access method. </title> <booktitle> Proc. ACM SIG-MOD Conf., </booktitle> <address> Atlantic City, NJ (June 1990) 354-363. </address>
Reference-contexts: When the database is large (multiple gigabytes), a complete fuzzy dump becomes very expensive. Then differential backups, also fuzzy, which only copy pages changed since the last backup become very desirable. In this paper, we show how to use a temporal indexing method, the time-split B-tree or TSB-tree <ref> [6, 7] </ref>, for differential backup of the database. The TSB-tree is particularly suited to the task of supporting a transaction-time database. It is a multiattribute access method that accesses data by key and by transaction time. <p> Deciding whether to split by time, or by key, or by both time and key, impacts the characteristics of the resulting TSB-tree. The implications of splitting policy are explored in depth in <ref> [7] </ref>. Here we describe only the mechanics of the splitting process. A sequence of splits is illustrated in Figure 2. The TSB-tree exploits clipping [3] to cope with its entries that have extents.
Reference: [8] <author> Lomet, D. Salzberg, B. </author> <title> Access method concur-rency with recovery. </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> San Diego, </address> <month> (June </month> <year> 1992) </year> <month> 351-360. </month>
Reference-contexts: However, concurrency is particularly high when using a method based on the B-link tree [4]. Such a method which also provides for recovery as well, is described in <ref> [8] </ref>. Changes made on the leaf level are in separate atomic actions from those made above the leaf level. Details of the use of the concurrency method of [8] in TSB-trees can be found in [9]. 2.4 Timestamping The time chosen as the transaction time for times-tamping record versions in the <p> Such a method which also provides for recovery as well, is described in <ref> [8] </ref>. Changes made on the leaf level are in separate atomic actions from those made above the leaf level. Details of the use of the concurrency method of [8] in TSB-trees can be found in [9]. 2.4 Timestamping The time chosen as the transaction time for times-tamping record versions in the TSB-tree is the commit time of the the transaction which created that version. <p> Once the history node is stably written, the parent index node is updated and this update is logged. This usually requires only a short-term exclusive latch on the parent index node. If the parent splits, latches on higher level nodes will also be needed <ref> [8] </ref>. 4.2.2 The Root Backing up the root is handled somewhat differently. There is no index node above the root into which to store the index terms describing the backup-induced time-split of the root.
Reference: [9] <author> Lomet D. and Salzberg, B. </author> <title> Media recovery with time-split B-trees. </title> <institution> Digital Equipment Corp. </institution> <note> Tech Report CRL 91/9 (September 1991), </note> <institution> Cambridge Research Lab, </institution> <address> Cambridge, MA </address>
Reference-contexts: Such a method which also provides for recovery as well, is described in [8]. Changes made on the leaf level are in separate atomic actions from those made above the leaf level. Details of the use of the concurrency method of [8] in TSB-trees can be found in <ref> [9] </ref>. 2.4 Timestamping The time chosen as the transaction time for times-tamping record versions in the TSB-tree is the commit time of the the transaction which created that version. <p> We systematically eliminate covered index terms from index nodes. The node whose reference is erased in this index node may become inaccessible via a TSB-tree search, but all search relevant information remains accessible. Details of calculating child boundaries for index covering is in <ref> [9] </ref>. When using a WORM device for history nodes, space cannot be re-used. No attempt need then be made to recover space in the historical database used by inaccessible nodes. 4 The Backup Process We wish to make the backup process comparable in cost to a conventional differential backup.
Reference: [10] <author> Lomet, D. and Salzberg, B. </author> <title> Transaction-time databases. in Temporal Databases: Theory, Design and Implementation, </title> <editor> A. </editor> <publisher> Benjamin Cum-mings, </publisher> <address> Redwood City, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: As suggested in [14], timestamping can be piggy-backed on subsequent updates to the same page. Any timestamping that remains can be done by a background process, and must also be logged. Garbage-collecting the TID-TIME table is outlined in <ref> [10] </ref>. 2.5 Distributed Transactions Agreeing on and distributing transaction time to the cohorts of a distributed transaction can be handled by augmenting the two-phase commit protocol messages. Cohorts vote not only on whether to commit a transaction, but also on transaction time [5].
Reference: [11] <author> Reed, D. </author> <title> Implementing atomic actions on decentralized data. </title> <journal> ACM Trans. Computing Systems (Feb. </journal> <year> 1983) </year> <month> 3-23. </month>
Reference: [12] <author> Rosenblum, M. and Ousterhout, J. </author> <title> The design and implementation of a log-structured file system. </title> <booktitle> 13th ACM Symposium on Operating Systems Principles (1991) </booktitle>
Reference-contexts: The writing of the restored database can then require a very small number of large sequential writes. This exploits relocation to optimize writing in the same way as is done with log-structured files <ref> [12] </ref>. 5.2.3 Applying the Log The RELOCATION TABLE is also needed to permit the log to be successfully applied to the restored database. Log records refer to the pre-failure locations of the data, and need to be translated so as to correctly update the restored nodes.
Reference: [13] <author> Shasha, D. and Goodman, N. </author> <title> Concurrent search structure algorithms. </title> <journal> ACM Trans. </journal> <note> Database Systems 13,1 (March 1988) 53-90. </note>
Reference-contexts: Note that because the key space is refined over time, any such clipped index entry will reference a history node. 2.3.3 Concurrent Node Splitting Essentially any concurrency algorithm used for B + - trees, such as those listed in <ref> [13] </ref>, could be used to provide concurrent updating and node splitting for TSB-trees. The current nodes of the TSB-tree are the only ones that are updated.
Reference: [14] <author> Stonebraker, M. </author> <title> The design of the Postgres storage system. </title> <booktitle> Proc. Very Large Databases Conf., </booktitle> <address> Brighton, UK (Sept. </address> <year> 1987) </year> <month> 289-300. </month>
Reference-contexts: We expect most of the pages to be timestamped will be in the database cache right after the transaction commits. Times-tamping them will be part of the disk write, which will be logged. As suggested in <ref> [14] </ref>, timestamping can be piggy-backed on subsequent updates to the same page. Any timestamping that remains can be done by a background process, and must also be logged.
Reference: [15] <author> A. Tansel, J. Clifford, S. Jajodia, A. Segev and R. Snodgrass, </author> <title> editors, Temporal Databases: Theory, Design and Implementation, </title> <editor> A. </editor> <publisher> Benjamin Cummings, </publisher> <address> Redwood City, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: 1 Introduction 1.1 Background There is increasing interest in providing "data mining" capabilities, where one may wish to discover patterns over time, or to explore the database state at some time in the past. To support such temporal queries, transaction-time databases <ref> [15] </ref> store not only the current database but the history of the fl This work was partially supported by NSF grant IRI-88-15707 and IRI-91-02821. <p> Using the TSB-tree for backup requires a specific (and different) time-splitting strategy. Backup-induced splitting is described in subsequent sections. Data records in a transaction-time database correspond to a line segment (one key value) in the time-key space. The line segment in the temporal dimension represents the lifespan <ref> [15] </ref> of the version of the data record, the start point being the transaction time at which it was entered, and the end point being the transaction time at which its successor version was entered, where its successor can be a "delete stub" indicating that the record has been deleted, not
References-found: 15

