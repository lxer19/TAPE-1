URL: http://www.wi.leidenuniv.nl/home/joost/ifip.ps.gz
Refering-URL: http://www.wi.leidenuniv.nl/home/joost/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: e-mail: frob,ted,joostg@cs.ruu.nl  
Title: 127 Progress for Local Variables in UNITY  
Author: Rob Udink and Ted Herman and Joost Kok 
Keyword: Keyword Codes: F.3.1 Keywords: Specifying and Verifying and Reasoning about Programs  
Address: P.O. Box 80089, 3508 TB Utrecht, The Netherlands  
Affiliation: Department of Computer Science, Utrecht University,  
Abstract: A new notion of refinement for UNITY programs with local variables is defined. This notion is compositional in the following sense: programs can be refined in arbitrary contexts such that all unless and leadsto properties (i.e. temporal properties for both safety and progress) of the composition are preserved. The refinement notion is based on preservation of a new kind of UNITY-like property that takes into account the locality of variables. We do a small case study about registers. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design A Foundation. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1988. </year>
Reference-contexts: 1. INTRODUCTION Developing correct parallel and distributed programs from specification to implementation is a difficult task. Stepwise refinement has proven to be a useful methodology for this task. The UNITY framework, introduced by Chandy and Misra <ref> [1] </ref>, supports the idea of stepwise refinement of specifications. The framework consists of a programming language and a programming logic. The logic is based on a small set of temporal properties for describing specifications. <p> A specification is refined by a set of stronger properties and the UNITY approach is to refine specifications toward a specific architecture until a program can be derived easily. Case studies show that the method is useful for deriving parallel and distributed algorithms <ref> [1] </ref>. However, it is not always easy to deal with low-level implementation details at the level of specifications. In this stage of the development process, program refinement seems to be preferable to refinement of specifications. Program refinement consists of program transformations that preserve semantic properties of the programs. <p> THE UNITY FRAMEWORK In this section, a brief overview of the UNITY framework is given. First, we give some preliminaries on states, states spaces and predicates. Second, we describe the UNITY programming language and finally we give two programming logics: the standard UNITY logic of Chandy and Misra <ref> [1] </ref>, and a modified logic introduced by Sanders [7]. Let V be the set of program variables. Elements of V are denoted by x ; y ; z , subsets of V by X ; Y ; Z . The complement of X is X = V nX . <p> The predicate p (E/x) is the predicate p with E substituted for x . The definition for multiple assignment statements is similar, using simultaneous substitution. Now we define the logics for UNITY programs. We start with the logic given by Chandy and Misra <ref> [1] </ref>. This logic is based on three properties: unless, ensures, and leadsto. These properties are attached to an entire program and are defined in terms of the set of statements. Definition 2.4 (Chandy-Misra Logic) Let p; q be arbitrary predicates and F a UNITY program. <p> other properties can be defined, for example, stable p = p unless false; invariant p = ((init (F ) ) p) ^ stable p); p until q = (p unless q ^ p 7! q ): The following theorem, which is a weak version of the union theorem given in <ref> [1] </ref>, shows the properties are compositional in the sense that properties of a union can be split into properties of its components. <p> This explains the choice of the subscript in the previous section. All theorems derived in <ref> [1] </ref> for properties of a single program also hold for subscripted properties. <p> Y q in F : At first sight this definition looks complicated, however the complication is not so difficult to deal with. Firstly, in special cases the definition simplifies (see lemma 3.9). Secondly, the property is similar to ensures Y , in that all theorems derived in <ref> [1] </ref> for the ensures - property also holds for . Y (see lemma 3.7). Furthermore, the reader also should bear in mind that we introduce this property in order to define a refinement relation. <p> Y q in F ) p unless Y q in F : 135 In fact, . Y is more like ensures Y than like 7! Y . For example, all the properties that have been proven for ensures in <ref> [1] </ref> also hold for . Y : Lemma 3.7 For UNITY program F , a set of variables Y and predicates p; q , Reflexivity p . Y p in F ; Consequence weakening (p . Y q in F ^ q ) r ) ) p . <p> Our case study examines one such register implementation: the construction of a single-writer, 2n-bit, safe register using two single-writer, n-bit, safe registers. Previous case studies in <ref> [1] </ref> show how UNITY applies to transient communication by modeling distributed programs with channels. We believe that it is also important to study registers, because they have different atomicity properties than channels or even simple UNITY assignment statements. <p> We assume that the variable out is an array consisting of two parts out <ref> [1] </ref>; out [2] (for example, one can see it as a bitstring which can be split in two parts), and in is similarly split into two parts. Each array part is then implemented by a (smaller) safe register. <p> Hence the goal is to refine Safe to a program Con []Safe1 []Safe2, where Safe1 and Safe2 are instances of Safe with smaller buffers, i.e. the program Safe with variables renamed: Safe1 = Safe [in 1 ; out <ref> [1] </ref>; buf 1 ; w 1 = in; out ; buf ; w ] and Safe2 = Safe [in 2 ; out [2]; buf 2 ; w 2 = in; out ; buf ; w ]. <p> The component Con is the program Program Con global in; in 1 ; in 2 local buf ; w initially w = false; in = ? assign w ; in 1 ; in 2 ; buf := true; in <ref> [1] </ref>; in [2]; in if in 6= ? ^ not w [] w ; in := false; ? if in 1 = ? ^ in 2 = ? endfCong Program Con reads the communication variable in and distributes it to the inputs of Safe1 and Safe2. <p> This gives the program Program S 1 global in; out local buf ; w ; in 1 ; buf 1 ; w 1 initially w = false; in = ?; w 1 = false; in 1 = ? assign w ; in 1 ; buf := true; in <ref> [1] </ref>; in if in 6= ? ^ not w [] w 1 ; buf 1 := true; in 1 if in 1 6= ? ^ not w 1 [] out :=? if w [] w 1 ; out; in 1 := false; ?; ? if w [] out :=? if w <p> w ): This yields the program Program S 2 global in; out local buf ; w ; in 1 ; buf 1 ; w 1 initially w = false; in = ?; w 1 = false; in 1 = ? assign w ; in 1 ; buf := true; in <ref> [1] </ref>; in if in 6= ? ^ not w [] w 1 ; buf 1 := true; in 1 if in 1 6= ? ^ not w 1 [] out [1] :=? if w 1 [] w 1 ; out [1]; in 1 := false; ?; ? if w 1 [] <p> = ?; w 1 = false; in 1 = ? assign w ; in 1 ; buf := true; in <ref> [1] </ref>; in if in 6= ? ^ not w [] w 1 ; buf 1 := true; in 1 if in 1 6= ? ^ not w 1 [] out [1] :=? if w 1 [] w 1 ; out [1]; in 1 := false; ?; ? if w 1 [] out :=? if w [] w ; out; in := false; buf ; ? if w endfS 2 g S 2 v . <p> assign w ; in 1 ; buf := true; in <ref> [1] </ref>; in if in 6= ? ^ not w [] w 1 ; buf 1 := true; in 1 if in 1 6= ? ^ not w 1 [] out [1] :=? if w 1 [] w 1 ; out [1]; in 1 := false; ?; ? if w 1 [] out :=? if w [] w ; out; in := false; buf ; ? if w endfS 2 g S 2 v . <p> : This results in the program Program S 3 global in; out local buf ; w ; in 1 ; buf 1 ; w 1 initially w = false; in = ?; w 1 = false; in 1 = ? assign w ; in 1 ; buf := true; in <ref> [1] </ref>; in if in 6= ? ^ not w [] w 1 ; buf 1 := true; in 1 if in 1 6= ? ^ not w 1 [] out [1] :=? if w 1 [] w 1 ; out [1]; in 1 := false; buf 1 ; ? if w <p> = ?; w 1 = false; in 1 = ? assign w ; in 1 ; buf := true; in <ref> [1] </ref>; in if in 6= ? ^ not w [] w 1 ; buf 1 := true; in 1 if in 1 6= ? ^ not w 1 [] out [1] :=? if w 1 [] w 1 ; out [1]; in 1 := false; buf 1 ; ? if w 1 [] out :=? if w [] w ; out; in := false; buf ; ? if w ^ in 1 = ? endfS 3 g S 3 v . <p> assign w ; in 1 ; buf := true; in <ref> [1] </ref>; in if in 6= ? ^ not w [] w 1 ; buf 1 := true; in 1 if in 1 6= ? ^ not w 1 [] out [1] :=? if w 1 [] w 1 ; out [1]; in 1 := false; buf 1 ; ? if w 1 [] out :=? if w [] w ; out; in := false; buf ; ? if w ^ in 1 = ? endfS 3 g S 3 v . <p> T 4 is concerned with the statements not appearing in either of the safe registers: Program T 4 global in; out; in 1 ; in 2 ; buf ; w initially w = false; in = ? assign w ; in 1 ; in 2 ; buf := true; in <ref> [1] </ref>; in [2]; in if in 6= ? ^ not w [] w ; out ; in := false; buf ; ? if w ^ in 1 = ? ^ in 2 = ? endfT 4 g S 4 v . (var fin 1 ; in 2 ; w ; buf
Reference: 2. <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <booktitle> In Proc. of the 3rd Annual IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 165-175, </pages> <address> Wash-ington D.C., July 1988. </address> <publisher> Computer Society Press. </publisher>
Reference-contexts: In this stage of the development process, program refinement seems to be preferable to refinement of specifications. Program refinement consists of program transformations that preserve semantic properties of the programs. Notions of program refinement differ in the kind of properties that are preserved. Abadi and Lamport <ref> [2] </ref> define refinement as reduction of the set of behaviors (sequences of states that occur during execution) of the program. This corresponds to reduction of nondeterminism. <p> We assume that the variable out is an array consisting of two parts out [1]; out <ref> [2] </ref> (for example, one can see it as a bitstring which can be split in two parts), and in is similarly split into two parts. Each array part is then implemented by a (smaller) safe register. <p> Con []Safe1 []Safe2, where Safe1 and Safe2 are instances of Safe with smaller buffers, i.e. the program Safe with variables renamed: Safe1 = Safe [in 1 ; out [1]; buf 1 ; w 1 = in; out ; buf ; w ] and Safe2 = Safe [in 2 ; out <ref> [2] </ref>; buf 2 ; w 2 = in; out ; buf ; w ]. <p> The component Con is the program Program Con global in; in 1 ; in 2 local buf ; w initially w = false; in = ? assign w ; in 1 ; in 2 ; buf := true; in [1]; in <ref> [2] </ref>; in if in 6= ? ^ not w [] w ; in := false; ? if in 1 = ? ^ in 2 = ? endfCong Program Con reads the communication variable in and distributes it to the inputs of Safe1 and Safe2. <p> is concerned with the statements not appearing in either of the safe registers: Program T 4 global in; out; in 1 ; in 2 ; buf ; w initially w = false; in = ? assign w ; in 1 ; in 2 ; buf := true; in [1]; in <ref> [2] </ref>; in if in 6= ? ^ not w [] w ; out ; in := false; buf ; ? if w ^ in 1 = ? ^ in 2 = ? endfT 4 g S 4 v . (var fin 1 ; in 2 ; w ; buf g :
Reference: 3. <author> R.-J.R. </author> <title> Back. Refinement calculus, part II: Parallel and reactive programs. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </title> <booktitle> volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 42-66. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: for Computer Science in the Netherlands (SION) under project 612-317-107. y The second author was supported in part by the Dutch Organization for Scientific Research (NWO) under contract NF 62-376 (ALADDIN: Algorithmic Aspects of Parallel and Distributed Systems). 128 be extended for refinement of reactive systems by using data refinement <ref> [3] </ref>. This notion implies the reduction of the set of behaviors. Sanders [4] defines program refinement as a syntactic notion on programs and identifies the kind of (adjusted) UNITY properties that are preserved by a specific refinement.
Reference: 4. <author> B.A. Sanders. </author> <title> Stepwise refinement of mixed specifications of concurrent programs. </title> <editor> In M. Broy and Jones C.B., editors, </editor> <booktitle> Proceedings of the IFIP Working Conference on Programming and Methods, </booktitle> <pages> pages 1-25. </pages> <publisher> Elsevier Science Publishers B.V. (North Holland), </publisher> <month> May </month> <year> 1990. </year>
Reference-contexts: This notion implies the reduction of the set of behaviors. Sanders <ref> [4] </ref> defines program refinement as a syntactic notion on programs and identifies the kind of (adjusted) UNITY properties that are preserved by a specific refinement.
Reference: 5. <author> Ambuj K. Singh. </author> <title> Program refinement in fair transition systems. </title> <journal> Acta Informatica, </journal> <volume> 30(6) </volume> <pages> 503-535, </pages> <year> 1993. </year>
Reference-contexts: This notion implies the reduction of the set of behaviors. Sanders [4] defines program refinement as a syntactic notion on programs and identifies the kind of (adjusted) UNITY properties that are preserved by a specific refinement. Singh <ref> [5] </ref> defines program refinement as the preservation of unless, leadsto and fixed-point properties of a program and gives a number of program transformation rules that satisfy this criterion. <p> Then, x = 0 7! V x = 3 holds in (var b : F )[]H but not (var b : G )[]H . So, we can not abstract from local variables completely. To gain some power we can use data refinement. Singh <ref> [5] </ref> uses couplings, functions mapping the new state space to the old one, to formalize data refinement. We adopt the approach of von Wright [10] and use abstraction commands, which are predicate transformers, for modeling data refinement. However, we need to pose some conditions on abstraction commands. <p> The conditions in the theorem above guarantee that progress properties are preserved if the guard is strengthened by q , as is also shown by Singh <ref> [5] </ref>. Since q is a local predicate, the environment has not to be taken into account. So, if it is allowed to strengthen by q, it is also allowed to strengthen it by a weaker predicate. 6.
Reference: 6. <author> R.T. Udink and J.N. Kok. </author> <title> Two fully abstract models for UNITY. In Eike Best, </title> <editor> editor, CONCUR'93, </editor> <booktitle> Proceedings of the 4th International Conference on Concurrency Theory, volume 715 of Lecture Notes in Computer Science, </booktitle> <pages> pages 339-352. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1993. </year>
Reference-contexts: In this paper we follow Singh in the sense that we define program refinement in such a way that all unless and leadsto properties are preserved. Moreover, we give a notion of refinement that is compositional and takes locality of variables into account. In <ref> [6] </ref>, we showed that for programs without local variables preservation of unless and ensures properties is the best compositional notion of refinement. For programs with local variables, i.e., variables that can neither be changed nor observed by any context, this notion is too strong. <p> Y is in some way the best base for 7! V . In <ref> [6] </ref> it is shown that this conjecture holds for Y = ;. An important consequence of theorem 3.10 is that preservation of unless Y and . Y is a correct and compositional base for property preserving refinement in contexts that do not refer to variables in Y . <p> We are interested in property preserving refinement: program transformations that preserve all unless V and 7! V properties of the program in any composition. In <ref> [6] </ref>, we have shown that unless ; and ensures ; preservation is the best compositional notion of refinement for programs without local variables.
Reference: 7. <author> B.A. Sanders. </author> <title> Eliminating the substitution axiom from UNITY logic. </title> <journal> Formal Aspects of Computing, </journal> <volume> 3(2) </volume> <pages> 189-205, </pages> <year> 1991. </year>
Reference-contexts: First, we give some preliminaries on states, states spaces and predicates. Second, we describe the UNITY programming language and finally we give two programming logics: the standard UNITY logic of Chandy and Misra [1], and a modified logic introduced by Sanders <ref> [7] </ref>. Let V be the set of program variables. Elements of V are denoted by x ; y ; z , subsets of V by X ; Y ; Z . The complement of X is X = V nX . <p> predicates p; q, p unless q in F []G ( p unless q in F ^ p unless q in G ; p ensures q in F []G ( p ensures q in F ^ p unless q in G: Next we give (a characterization of) the logic of Sanders <ref> [7] </ref>. We use the subscript V for its properties. The choice of V will become clear in the next section.
Reference: 8. <author> J. Pachl. </author> <title> A simple proof of a completeness result for leads-to in the UNITY logic. </title> <journal> Information Processing Letters, </journal> <volume> 41 </volume> <pages> 35-38, </pages> <year> 1992. </year>
Reference-contexts: Thirdly, compositionality of the properties is lost, i.e., the union theorem as given above does not hold. Lastly, as shown by Pachl <ref> [8] </ref>, for Sanders's logic the interpretation of the properties can be given in terms of execution sequences: 1. p unless V q in F holds if and only if for every state in every execution sequence of F , if p ^ :q holds, then p _ q holds in its
Reference: 9. <author> Sengzong Zhou, Rob Gerth, and Ruurd Kuiper. </author> <title> Transformations preserving properties and properties preserved by transformations in fair transition systems. In Eike Best, </title> <editor> editor, CONCUR93, </editor> <booktitle> Proceedings of the 4th International Conference on Cun-currency Theory, </booktitle> <volume> volume 715, </volume> <pages> pages 353-367. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1993. </year> <note> Lecture Notes in Computer Science. </note>
Reference-contexts: This is exploited in the next section. 4. REFINEMENT WITH LOCAL VARIABLES The UNITY framework does not have local variables: all variables in a program are global. Following Zhou et.al. <ref> [9] </ref>, we introduce a notion of local variables for UNITY programs. The values of local variables can neither be observed nor changed by programs running in parallel (using the union operator).
Reference: 10. <author> J. von Wright. </author> <title> The lattice of data refinement. </title> <journal> Acta Informatica, </journal> <volume> 31(2) </volume> <pages> 105-135, </pages> <year> 1994. </year>
Reference-contexts: So, we can not abstract from local variables completely. To gain some power we can use data refinement. Singh [5] uses couplings, functions mapping the new state space to the old one, to formalize data refinement. We adopt the approach of von Wright <ref> [10] </ref> and use abstraction commands, which are predicate transformers, for modeling data refinement. However, we need to pose some conditions on abstraction commands. Definition 4.4 Let Y ; Z be sets of variables.
Reference: 11. <author> Kaisa Sere. </author> <title> Stepwise Derivation of Parallel Algorithms. </title> <type> PhD thesis, </type> <institution> Abo Akademi, </institution> <month> may </month> <year> 1990. </year>
Reference: 12. <author> Leslie Lamport. </author> <title> On interprocess communication. part II: Algorithms. </title> <journal> Distributed Computing, </journal> <volume> 1 </volume> <pages> 86-101, </pages> <year> 1986. </year>
Reference-contexts: The refinement consists of a number of steps based on theorems presented in Section 5, that is, each step of the refinement is a v . refinement, and hence all unless V and 7! V properties are preserved in any context. In a seminal paper <ref> [12] </ref> on the nature of asynchronous communication, Lamport divides communication acts into two types, transient and persistent. Transient communication corresponds to message-passing, where messages are seen as consumable events; persistent communication is concerned with objects (variables, shared memory) that can be read and written. <p> It is also worthwhile to examine whether the condition for Y ~ Z abstractions can be weakened. Another question is to see whether other constructions for register communication given by Lamport in <ref> [12] </ref> can be handled. Acknowledgements We like to thank Ralph Back and Kaisa Sere for discussions on the subject of the paper and for the hospitality during several visits.
Reference: 13. <author> J. Misra. </author> <title> Axioms for memory access in asynchronous hardware systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6 </volume> <pages> 142-153, </pages> <year> 1986. </year>
Reference-contexts: The difficulties one encounters with persistent communication are related to the low-level semantics of reading and writing in the context of concurrency and limited availability of atomic operations. The objects manipulated by read and write operations are called registers, which are also studied in <ref> [13] </ref>. Registers can be classified by a number of parameters, including the types of operations they admit, the number of concurrent readers and writers that are possible, the size of the register, and how they behave under concurrent access.
Reference: 14. <author> F.S. de Boer, J.N. Kok, C. Palamidessi, and J.J.M.M. Rutten. </author> <title> Non-monotonic concurrent constraint programming. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proc. of the International Logic Programming Symposium (ILPS), </booktitle> <pages> pages 315-334, </pages> <year> 1993. </year>
Reference-contexts: The way local variables are added to Unity and the way the refinement is defined are inspired by the work on action systems. Also the work on locality and hiding of variables in constraint systems of <ref> [14] </ref> was helpful for extending the UNITY logic. We also want to thank the anonymous referees for their useful suggestions. 146
References-found: 14

