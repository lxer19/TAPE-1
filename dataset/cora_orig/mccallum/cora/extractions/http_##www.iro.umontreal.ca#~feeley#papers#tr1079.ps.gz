URL: http://www.iro.umontreal.ca/~feeley/papers/tr1079.ps.gz
Refering-URL: http://www.iro.umontreal.ca/~feeley/
Root-URL: http://www.iro.umontreal.ca
Email: ffeeley,larosemg@iro.umontreal.ca  
Title: Etos: an Erlang to Scheme compiler  
Author: Marc Feeley and Martin Larose 
Date: August 18, 1997  
Address: C.P. 6128 succursale centre-ville Montreal H3C 3J7, Canada  
Affiliation: Universite de Montreal  
Abstract: The programming languages Erlang and Scheme have many common features, yet the performance of the current implementations of Erlang appears to be below that of good implementations of Scheme. This disparity has prompted us to investigate the translation of Erlang to Scheme. In this paper we describe the design and implementation of the Etos Erlang to Scheme compiler and compare its performance to other systems. On most benchmark programs, Etos outperforms all currently available implementations of Erlang. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. L. Armstrong. </author> <title> The development of erlang. </title> <booktitle> In Proceedings of the International Conference on Functional Programming, </booktitle> <pages> pages 196-203, </pages> <address> Ams-terdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Erlang has been mostly developed internally at Ericsson and as a result there is a limited choice of compilers. As the implementers of these compilers freely admit <ref> [1] </ref>, "Performance has always been a major problem".
Reference: [2] <author> J. L. Armstrong, B. O. Dacker, S. R. Virding, and M. C. Williams. </author> <title> Implementing a functional language for highly parallel real-time applications. </title> <booktitle> In Proceedings of Software Engineering for Telecommunication Switching Systems, </booktitle> <address> Florence, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: 2.17 3.37 13.06 tak 13.26 1.12 4.37 11.09 barnes 9.18 2.08 - 4.07 pseudoknot 16.75 2.37 - 3.18 nrev 22.10 .84 1.83 10.98 qsort 14.97 .96 3.88 15.38 ring 129.68 .30 .31 1.92 stable 21.27 1.16 .64 2.43 to C using a register machine as intermediate; * JAM version 4.4.1 <ref> [2] </ref>, a bytecode compiler for a stack machine. 10.3 Execution Time The measurements were made on a Sun UltraSparc 143 MHz with 122 Mb of memory. Each benchmark program was run 5 times and the average was taken after removing the best and worse times.
Reference: [3] <author> J. L. Armstrong, S. R. Virding, C. Wikstrom, and M. C. Williams. </author> <title> Concurrent Programming in Erlang. </title> <publisher> Prentice Hall, </publisher> <address> second edition edition, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction Erlang <ref> [3] </ref> and Scheme [13, 5] have some obvious differences (e.g. infix vs. prefix syntax, pattern matching vs. access functions, catch/throw vs. call/cc, concurrency) but also a large number of similarities (e.g. use of functional style, dynamic typing, automatic memory management, data types).
Reference: [4] <author> D. Boucher. Lalr-scm. </author> <note> Available at ftp.iro.umontreal.ca in pub/parallele/boucherd. </note>
Reference-contexts: Note that Erlang records are just syntactic sugar for tuples so no special representation is required for them. 5 Front End To ensure compatibility with existing Erlang compilers, Etos' parser specification was derived from the one for the JAM interpreter and processed by our own Scheme parser generator <ref> [6, 4] </ref>. The original parser constructs a parse tree built of tuples. Because Etos needs to attach semantic information on the nodes of the parse tree, a conversion phase was added to extend the tree nodes with additional fields.
Reference: [5] <editor> W. Clinger and J. Rees [editors]. </editor> <title> Revised 4 Report on the Algorithmic Language Scheme. </title> <journal> Lisp Pointers, </journal> <volume> 4(3) </volume> <pages> 1-55, </pages> <month> July-September </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Erlang [3] and Scheme <ref> [13, 5] </ref> have some obvious differences (e.g. infix vs. prefix syntax, pattern matching vs. access functions, catch/throw vs. call/cc, concurrency) but also a large number of similarities (e.g. use of functional style, dynamic typing, automatic memory management, data types). <p> Etos is written in standard Scheme <ref> [5] </ref> and the generated programs conform fairly closely to the standard (the discrepancies are explained later). It is clear however that better performance can be achieved if non-standard features of the target Scheme implementation are exploited (in particular the existence of fast operations on fixed precision integers, i.e. fixnums).
Reference: [6] <author> D. Dube. SILex, </author> <title> user manual. </title> <note> Available at ftp.iro.umontreal.ca in pub/parallele. </note>
Reference-contexts: Note that Erlang records are just syntactic sugar for tuples so no special representation is required for them. 5 Front End To ensure compatibility with existing Erlang compilers, Etos' parser specification was derived from the one for the JAM interpreter and processed by our own Scheme parser generator <ref> [6, 4] </ref>. The original parser constructs a parse tree built of tuples. Because Etos needs to attach semantic information on the nodes of the parse tree, a conversion phase was added to extend the tree nodes with additional fields.
Reference: [7] <author> M. Feeley. </author> <note> Etos version 1.4. Compiler available at ftp.iro.umontreal.ca in pub/parallele/etos/etos-1.4. </note>
Reference-contexts: Finally, when the stack cache overflows (because of repeated calls to call/cc or because of a deep recursion), the garbage collector is called to move all reachable frames from the stack cache to the heap. We have compared Etos version 1.4 <ref> [7] </ref> with three implementations of Erlang compilers: * Hipe version 0.27 [14], an extension of the JAM bytecode compiler that selectively compiles byte codes to native code; * BEAM/C version 4.5.2 [12], compiles Erlang code Etos Time relative to Etos Program (secs) Hipe BEAM JAM fib 31.50 1.15 1.98 8.33 huff
Reference: [8] <author> M. Feeley. </author> <note> Gambit-C version 2.7a, user manual. Compiler available at ftp.iro.umontreal.ca in pub/parallele/gambit/gambit-2.7. </note>
Reference-contexts: Creates 20 processes which send mes sages in fairly random patterns. * tak (iterated 1000 times): Recursive integer arithmetic Takeuchi function. Calculates tak (18,12,6). 10.2 Erlang Compilers Etos was coupled with the Gambit-C Scheme compiler version 2.7a <ref> [8] </ref>. We will first briefly describe the 8 Gambit-C compiler. The Gambit programming system combines an interpreter and a compiler fully compliant to R 4 RS and IEEE specifications. The Gambit-C compiler translates Scheme programs to portable C code which can run on a wide variety of platforms.
Reference: [9] <author> M. Feeley. </author> <title> Polling efficiently on stock hardware. </title> <booktitle> In Proceedings of the Functional Programming and Computer Architecture, </booktitle> <pages> pages 179-187, </pages> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Gambit-C represents lists using 3 word long pairs as opposed to 2 words on the other systems. Allocation is longer and the GC has more data to copy. 2. Gambit-C guarantees that interrupts are checked at bound intervals <ref> [9] </ref> which is not the case for the other systems. For example, the code generated by Gambit-C for the function app (the most time consuming function of the nrev benchmark) tests interrupts twice as often as Hipe (i.e. on function entry and return). 3.
Reference: [10] <author> M. Feeley, J. Miller, G. Rozas, and J. Wil-son. </author> <title> Compiling Higher-Order Languages into Fully Tail-Recursive Portable C. </title> <type> Technical Report 1078, </type> <institution> Departement d'informatique et de recherche operationelle, Universite de Montreal, </institution> <year> 1997. </year>
Reference-contexts: The technique used by Gambit-C to implement proper tail-recursion in C imposes an overhead on function returns as well as calls between modules. For nrev the overhead is high because most of the time is spent in a tight non-tail recursive function. Independent experiments <ref> [10] </ref> have shown that this kind of program can be sped up by a factor of two to four when native code is generated. * Finally ring and stable manipulate processes. Here we see a divergence in the results. Hipe is roughly three times faster than Etos on ring.
Reference: [11] <author> P. H. Hartel, M. Feeley, M. Alt, L. Augusts-son, P. Baumann, M. Beemster, E. Chailloux, C. H. Flood, W. Grieskamp, J. H. G. Van Gronin-gen, K. Hammond, B. Hausman, M. Y. Ivory, R. E. Jones, J. Kamperman, P. Lee, X. Leroy, R. D. Lins, S. Loosemore, N. Rojemo, M. Ser-rano, J.-P. Talpin, J. Thackray, S. Thomas, P. Walters, P. Weis, and P. Wentworth. </author> <title> Bench-marking implementations of functional languages with "Pseudoknot", a float-intensive benchmark. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(4) </volume> <pages> 621-655, </pages> <year> 1996. </year>
Reference-contexts: As the implementers of these compilers freely admit [1], "Performance has always been a major problem". On the other hand there are many implementations of Scheme available [15] and the good compilers appear to generate faster code than the Erlang compilers available from Ericsson (for example Hartel et al. <ref> [11] </ref> has shown that the "pseudoknot" benchmark compiled with Ericsson's BEAM/C 6.0.4 is about 5 times slower than when compiled with the Gambit-C 2.3 Scheme compiler). <p> a 38 byte string with the Huffman encoder. * length (iterated 100000 times): Tail recursive function that returns the length of a 2000 element list. * nrev (iterated 20000 times): Naive reverse of a 100 element list. * pseudoknot (iterated 3 times): Floating-point intensive application taken from molecular biol ogy <ref> [11] </ref>. * qsort (iterated 50000 times): Sorts 50 integers using the Quicksort algorithm. * ring (iterated 100 times): Creates a ring of 10 processes which pass around a token 100000 times. * smith (iterated 30 times): Matches a DNA sequence of length 32 to 100 other sequences of length 32.
Reference: [12] <author> B. Hausman. </author> <title> Turbo Erlang: approaching the speed of C. </title> <editor> In Evan Tick and Giancarlo Succi, editors, </editor> <booktitle> Implementations of Logic Programming Systems, </booktitle> <pages> pages 119-135. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: We have compared Etos version 1.4 [7] with three implementations of Erlang compilers: * Hipe version 0.27 [14], an extension of the JAM bytecode compiler that selectively compiles byte codes to native code; * BEAM/C version 4.5.2 <ref> [12] </ref>, compiles Erlang code Etos Time relative to Etos Program (secs) Hipe BEAM JAM fib 31.50 1.15 1.98 8.33 huff 9.74 1.48 5.01 24.81 length 11.56 2.07 3.44 34.48 smith 10.79 2.17 3.37 13.06 tak 13.26 1.12 4.37 11.09 barnes 9.18 2.08 - 4.07 pseudoknot 16.75 2.37 - 3.18 nrev 22.10
Reference: [13] <institution> IEEE Standard for the Scheme Programming Language. IEEE Standard 1178-1990, IEEE, </institution> <address> New York, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Erlang [3] and Scheme <ref> [13, 5] </ref> have some obvious differences (e.g. infix vs. prefix syntax, pattern matching vs. access functions, catch/throw vs. call/cc, concurrency) but also a large number of similarities (e.g. use of functional style, dynamic typing, automatic memory management, data types).
Reference: [14] <author> E. Johansson, C. Jonsson, T. Lindgren, J. Beve-myr, and H. Millroth. </author> <title> A pragmatic approach to compilation of Erlang. </title> <type> UPMAIL Technical Report 136, </type> <institution> Uppsala University, Sweden, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: We have compared Etos version 1.4 [7] with three implementations of Erlang compilers: * Hipe version 0.27 <ref> [14] </ref>, an extension of the JAM bytecode compiler that selectively compiles byte codes to native code; * BEAM/C version 4.5.2 [12], compiles Erlang code Etos Time relative to Etos Program (secs) Hipe BEAM JAM fib 31.50 1.15 1.98 8.33 huff 9.74 1.48 5.01 24.81 length 11.56 2.07 3.44 34.48 smith 10.79
Reference: [15] <institution> The Internet Scheme Repository. </institution> <note> http://www.cs.indiana.edu/scheme-repository. </note>
Reference-contexts: Erlang has been mostly developed internally at Ericsson and as a result there is a limited choice of compilers. As the implementers of these compilers freely admit [1], "Performance has always been a major problem". On the other hand there are many implementations of Scheme available <ref> [15] </ref> and the good compilers appear to generate faster code than the Erlang compilers available from Ericsson (for example Hartel et al. [11] has shown that the "pseudoknot" benchmark compiled with Ericsson's BEAM/C 6.0.4 is about 5 times slower than when compiled with the Gambit-C 2.3 Scheme compiler).
Reference: [16] <author> C. Wikstrom. Estone, </author> <title> an erlang benchmark. </title> <note> Available at http://www.ericsson.se:800 /cslab/~klacke/estone/. 11 </note>
Reference-contexts: We have added two benchmarks (ring and stable) to measure the performance of messaging and processes. Unfortunately, we were not able to use the "Estone" benchmark <ref> [16] </ref> because it uses ports which are not implemented in Etos. * barnes (iterated 10 times): Simulates gravita tional force between 1000 bodies. * fib (iterated 50 times): Computes 30th fibonacci number with a recursive function. * huff (iterated 5000 times): Compresses and un-compresses a 38 byte string with the Huffman
References-found: 16

