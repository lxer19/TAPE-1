URL: ftp://db.stanford.edu/pub/papers/yw-tempview.ps
Refering-URL: http://www.cs.toronto.edu/~mendel/dwbib.html
Root-URL: 
Email: fjunyang,widomg@db.stanford.edu  
Title: Maintaining Temporal Views Over Non-Temporal Information Sources For Data Warehousing  
Author: Jun Yang and Jennifer Widom 
Address: Stanford University  
Affiliation: Computer Science Department  
Abstract: An important use of data warehousing is to provide temporal views over the history of source data that may itself be non-temporal. While recent work in view maintenance is applicable to data warehousing, only non-temporal views have been considered. In this paper, we introduce a framework for maintaining temporal views over non-temporal information sources in a data warehousing environment. We describe an architecture for the temporal data warehouse that automatically maintains temporal views over non-temporal source relations, and allows users to ask temporal queries using these views. Because of the dimension of time, a materialized temporal view may need to be updated not only when source relations change, but also as time advances. We present incremental techniques to maintain temporal views for both cases, and outline the implementation of our approach in the WHIPS warehousing prototype at Stanford. 
Abstract-found: 1
Intro-found: 1
Reference: [B + ] <author> M. H. Bohlen et al. </author> <note> TimeCenter homepage. Available on web at: http://www.iesd.auc.dk/general/DBS/tdb/TimeCenter/. </note>
Reference-contexts: All materialized views, including auxiliary ones, are stored in the temporal warehouse component. The warehouse can be any temporal DBMS with TSQL2 support, such as TimeCenter <ref> [B + ] </ref>. We are currently using our "home grown" temporal DBMS called TIPS. 22 A view is defined by warehouse administrators using the temporal view specifier, which then passes the definition to the temporal view initializer.
Reference: [BCL89] <author> J. A. Blakeley, N. Coburn, and P. A. Larson. </author> <title> Updating derived relations: Detecting irrelevant and autonomously computable updates. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(3) </volume> <pages> 369-400, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: For example, we adopt the algebraic approach of [QW91, GL95] for propagating source changes (Section 4.2), and we apply 2 satisfiability tests to predicates in order to simplify view refresh equations (Section 4.3), similar to the method of detecting irrelevant updates in <ref> [BCL89] </ref>. We also apply methods for maintaining non-temporal aggregate views from [Qua96]. Numerous temporal data models and query languages have been proposed; see [ OS95] for a survey. We have chosen BCDM [JSS94], the underlying data model for TSQL2 [SJS95], as a basis for our work. <p> Then, existing algorithms <ref> [BCL89] </ref> can be used to test for satisfiability. A concrete example of using this test appears near the end of Section 4.3.3. 4.3.3 Example We now demonstrate how to derive the expression for refreshing a temporal view as time advances. <p> The overall architecture of the temporal WHIPS system is illustrated in Figure 8. For each temporal view exported by the warehouse, there is a temporal view manager responsible for maintaining the view. In contrast to non-temporal WHIPS, the concept of self-maintainability <ref> [BCL89, GJM96, QGMW96] </ref> is essential for temporal views since temporal base relations are not available at non-temporal sources: In general, each temporal view manager must also maintain a set of auxiliary views so that the original view together with the auxiliary views can be maintained without sending queries back to the
Reference: [BJS95] <author> M. H. Bohlen, C. S. Jensen, and R. T. Snodgrass. </author> <title> Evaluating the completeness of TSQL2. </title> <booktitle> In Proceedings of the International Workshop on Temporal Databases, </booktitle> <pages> pages 153-174, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Numerous temporal data models and query languages have been proposed; see [ OS95] for a survey. We have chosen BCDM [JSS94], the underlying data model for TSQL2 [SJS95], as a basis for our work. Our concept of t -reducibility (Section 3.2) is essentially that of snapshot reducibility discussed in <ref> [Sno87, BJS95] </ref>. We use a different name in order to avoid potential confusion with the SNAPSHOT construct in TSQL2. A number of papers are related to temporal view maintenance to some degree. [JMS95] addresses the temporal view maintenance problem in the chronicle data model. <p> However, when computing the timestamp for a result tuple, the NOW stored in input tuples cannot simply be replaced with t now . NOW is still treated as a distinct symbol, and thus may appear in the result timestamp. This approach is different from the TSQL2 approach proposed in <ref> [BJS95] </ref>, in which all occurrences of NOW in the query and input relations are replaced with t now during query evaluation. Under that approach, NOW would never appear in a result relation, which is not a problem in general for query results. <p> Note the correspondence with snapshot reducibility from <ref> [Sno87, BJS95] </ref>. Definition 3.2 (t -Reducible Operator) Let R 1 ; :::; R n be relations in a temporal database with current time t now .
Reference: [BL89] <author> M. Bassiouni and M. Llewellyn. </author> <title> On the definition and maintenance of database views with time-varying domains. </title> <booktitle> In Proceedings of the 13th Annual International Computer Software and Applications Conference, </booktitle> <pages> pages 201-208, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: The languages they use are logical rather than algebraic, and are generally less expressive. Furthermore, the problem of detecting constraint violations is a strict subset of the problem of maintaining materialized views. <ref> [BL89] </ref> provides some intuition, but no complete algorithms, for temporal view maintenance in a temporally grouped data model, while our data model is temporally ungrouped [CCT94].
Reference: [BM95] <author> L. Bkgaard and L. Mark. </author> <title> Incremental computation of time-varying query expressions. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 7(4) </volume> <pages> 583-590, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: In order to access the complete history, backlogs must be queried explicitly. The differential operators they introduce are closely related to our change propagation through t -reducible operators (Section 4.2.1). <ref> [BM95] </ref> considers the maintenance of relational queries whose selection predicates may refer to the symbol NOW, the current time. We consider a more expressive temporal query language and also handle NOW stored in data. [CT95] and [Ple93] explore the related problem of monitoring temporal integrity constraints.
Reference: [CCT94] <author> J. Clifford, A. Croker, and A. Tuzhilin. </author> <title> On completeness of historical relational query languages. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(1) </volume> <pages> 64-116, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Furthermore, the problem of detecting constraint violations is a strict subset of the problem of maintaining materialized views. [BL89] provides some intuition, but no complete algorithms, for temporal view maintenance in a temporally grouped data model, while our data model is temporally ungrouped <ref> [CCT94] </ref>. Finally, [LGM97] develops a framework for system-managed expiration of warehouse data, which can be used to vacuum historical data for a restricted class of temporal views. 3 3 Preliminaries We present our temporal data model and view definition language in Sections 3.1 and 3.2; both are fairly standard.
Reference: [CDI + 97] <author> J. Clifford, C. E. Dyreson, T. Isakowitz, C. S. Jensen, and R. T. Snodgrass. </author> <title> On the semantics of "NOW" in databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 22(2) </volume> <pages> 171-214, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: One of the end times may store the symbol NOW, which "automatically" extends T as time advances. We will assume this implementation in some of our later discussions. For a detailed discussion of NOW in temporal databases, please refer to <ref> [CDI + 97] </ref>. employee directory information for a company, with T encoded as a set of periods. 3.2 Temporal View Definition Language Views in the data warehouse are constructed from the conceptual temporal base relations (recall aggregate operator separately later in Section 5.
Reference: [CT95] <author> J. Chomicki and D. Toman. </author> <title> Implementing temporal integrity constraints using an active DBMS. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 7(4) </volume> <pages> 566-581, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: We consider a more expressive temporal query language and also handle NOW stored in data. <ref> [CT95] </ref> and [Ple93] explore the related problem of monitoring temporal integrity constraints. The languages they use are logical rather than algebraic, and are generally less expressive.
Reference: [GHQ95] <author> A. Gupta, V. Harinarayan, and D. Quass. </author> <title> Aggregate-query processing in data warehousing environments. </title> <booktitle> In Proceedings of the 1995 International Conference on Very Large Data Bases, </booktitle> <pages> pages 358-369, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Now, we define A 0 ;w (R) as a temporal relation with the property that for any t t now , t t ( A 0 ;w (R)) = nt A 0 (t t;w (R)). Here nt A 0 is the standard non-temporal grouping and aggregation operator <ref> [GHQ95, Qua96] </ref>. Intuitively, then, the result of a temporal aggregate is a sequence of values generated by moving a window of given length along the time line, and computing the non-temporal aggregate from all tuples valid in the current window. For detailed discussion on temporal aggregates please refer to [SGM93].
Reference: [GJM96] <author> A. Gupta, H. V. Jagadish, and I. S. Mumick. </author> <title> Data integration using self-maintainable views. </title> <booktitle> In Proceedings of the 1996 International Conference on Extending Database Technology, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: The overall architecture of the temporal WHIPS system is illustrated in Figure 8. For each temporal view exported by the warehouse, there is a temporal view manager responsible for maintaining the view. In contrast to non-temporal WHIPS, the concept of self-maintainability <ref> [BCL89, GJM96, QGMW96] </ref> is essential for temporal views since temporal base relations are not available at non-temporal sources: In general, each temporal view manager must also maintain a set of auxiliary views so that the original view together with the auxiliary views can be maintained without sending queries back to the
Reference: [GL95] <author> T. Griffin and L. Libkin. </author> <title> Incremental maintenance of views with duplicates. </title> <booktitle> In Proceedings of the 1995 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 328-339, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: However, most work to date considers only non-temporal views. Although temporal view maintenance introduces many problems that are not present for non-temporal views, a number of techniques developed for maintaining non-temporal views are still applicable. For example, we adopt the algebraic approach of <ref> [QW91, GL95] </ref> for propagating source changes (Section 4.2), and we apply 2 satisfiability tests to predicates in order to simplify view refresh equations (Section 4.3), similar to the method of detecting irrelevant updates in [BCL89]. We also apply methods for maintaining non-temporal aggregate views from [Qua96]. <p> (recall Figure 1) reports a source update at t now that affects the con ceptual temporal base relation R: 10 Step 1.1: If necessary, the warehouse converts the source update it receives to an update on R in the form of deltas 5R and 4R, in the same style as <ref> [QW91, GL95] </ref>. This procedure is discussed in Section 4.1. Step 1.2: The warehouse refreshes all the views whose definitions reference R so that they are current with respect to t now . This procedure is discussed in Section 4.3. <p> This is achieved by repeatedly applying a set of change propagation equations in order to factor out the changes in the base relation from the temporal relational expressions defining the views <ref> [QW91, GL95] </ref>. <p> $1:GB (A 0 )=$2:GB (A 0 ) Proof: Follows from the t -reducibility of A 0 ;0 , Theorem 3.2, and the correctness of the equalities for non-temporal relational algebra. 2 In Theorem 5.1, the requirement that 5RR = ? is analogous to the notion of weak minimality introduced in <ref> [GL95] </ref>. The requirement that 4R"R = ? is necessary because our temporal algebra is t -reduced to set algebra. If part of 4R intersects with R, then the tuples in the intersection would be counted more than once in the final aggregate.
Reference: [GM95] <author> A. Gupta and I. S. Mumick. </author> <title> Maintenance of materialized views: Problems, techniques, </title> <journal> and applications. IEEE Data Engineering, </journal> <volume> 18(2) </volume> <pages> 3-18, </pages> <month> June </month> <year> 1995. </year> <month> 25 </month>
Reference-contexts: Section 7 concludes and discusses further research. Complete proofs for all theorems are provided in Appendix A. 2 Related Work The view maintenance problem has been studied extensively; see <ref> [GM95] </ref> for a survey. However, most work to date considers only non-temporal views. Although temporal view maintenance introduces many problems that are not present for non-temporal views, a number of techniques developed for maintaining non-temporal views are still applicable.
Reference: [JM93] <author> C. S. Jensen and L. Mark. </author> <title> Differential query processing in transaction-time databases. In Temporal Databases: Theory, </title> <booktitle> Design, and Implementation, chapter 19, </booktitle> <pages> pages 457-491. </pages> <address> Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: Under that model, each tuple is timestamped with a single time instant rather than a set; consequently, the algebra is weaker than ours, and more efficient maintenance algorithms are possible. [JMR91] and <ref> [JM93] </ref> present techniques to incrementally maintain views defined using non-temporal operators over arbitrary snapshots of base relations, rather than temporal views over the complete history. In order to access the complete history, backlogs must be queried explicitly.
Reference: [JMR91] <author> C. S. Jensen, L. Mark, and N. Roussopoulos. </author> <title> Incremental implementation model for relational databases with transaction time. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 3(4) </volume> <pages> 461-473, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Under that model, each tuple is timestamped with a single time instant rather than a set; consequently, the algebra is weaker than ours, and more efficient maintenance algorithms are possible. <ref> [JMR91] </ref> and [JM93] present techniques to incrementally maintain views defined using non-temporal operators over arbitrary snapshots of base relations, rather than temporal views over the complete history. In order to access the complete history, backlogs must be queried explicitly.
Reference: [JMS95] <author> H. V. Jagadish, I. S. Mumick, and A. Silberschatz. </author> <title> View maintenance issues for the chronicle data model. </title> <booktitle> In Proceedings of the 1995 ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 113-124, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Our concept of t -reducibility (Section 3.2) is essentially that of snapshot reducibility discussed in [Sno87, BJS95]. We use a different name in order to avoid potential confusion with the SNAPSHOT construct in TSQL2. A number of papers are related to temporal view maintenance to some degree. <ref> [JMS95] </ref> addresses the temporal view maintenance problem in the chronicle data model.
Reference: [JSS94] <author> C. S. Jensen, M. D. Soo, and R. T. Snodgrass. </author> <title> Unifying temporal models via a conceptual model. </title> <journal> Information Systems, </journal> <volume> 19(7) </volume> <pages> 513-547, </pages> <year> 1994. </year>
Reference-contexts: We also apply methods for maintaining non-temporal aggregate views from [Qua96]. Numerous temporal data models and query languages have been proposed; see [ OS95] for a survey. We have chosen BCDM <ref> [JSS94] </ref>, the underlying data model for TSQL2 [SJS95], as a basis for our work. Our concept of t -reducibility (Section 3.2) is essentially that of snapshot reducibility discussed in [Sno87, BJS95]. We use a different name in order to avoid potential confusion with the SNAPSHOT construct in TSQL2. <p> A running example is introduced in Section 3.3, together with some intuition for the temporal view maintenance problem. 3.1 Temporal Data Model The temporal data model we use is essentially BCDM (Bitemporal Conceptual Data Model <ref> [JSS94] </ref>) restricted to transaction time. Intuition and examples for the definition will be given below.
Reference: [LGM97] <author> W. Labio and H. Garcia-Molina. </author> <title> Expiring data from the warehouse. </title> <type> Technical report, </type> <institution> Stanford University, </institution> <month> February </month> <year> 1997. </year> <note> Available on web as: http://www-db.stanford.edu/pub/papers/expire.ps. </note>
Reference-contexts: Furthermore, the problem of detecting constraint violations is a strict subset of the problem of maintaining materialized views. [BL89] provides some intuition, but no complete algorithms, for temporal view maintenance in a temporally grouped data model, while our data model is temporally ungrouped [CCT94]. Finally, <ref> [LGM97] </ref> develops a framework for system-managed expiration of warehouse data, which can be used to vacuum historical data for a restricted class of temporal views. 3 3 Preliminaries We present our temporal data model and view definition language in Sections 3.1 and 3.2; both are fairly standard.
Reference: [LW95] <author> D. Lomet and J. Widom, </author> <title> editors. Special Issue on Materialized Views and Data Warehousing, </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 18(2), </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: 1 Introduction A data warehouse is a repository for efficient querying and analysis of integrated information from a wide variety of sources. The warehouse effectively maintains materialized views over base relations at the sources <ref> [LW95, Wid95] </ref>. Clients of the warehouse may not only be interested in the most up-to-date information, but also the history of how the source data has evolved. It is therefore important that the warehouse supports temporal queries.
Reference: [NA89] <author> S. B. Navathe and R. Ahmed. </author> <title> A temporal relational model and a query language. </title> <journal> Information Sciences, </journal> <volume> 49(1) </volume> <pages> 147-175, </pages> <year> 1989. </year>
Reference-contexts: The temporal view definition language we consider is equivalent to a subset of TSQL2 [SJS95] including a class of commonly used aggregates termed moving-window aggregates <ref> [NA89] </ref>. We present an algorithm to incrementally maintain temporal views as time advances and source relations undergo changes. number of non-temporal source relations which are monitored and exported by an extractor [Wid95]. When a non-temporal source relation is updated, the extractor notifies the warehouse with the content of the update. <p> record individual timestamps of the joining tuples together with V , then there is no need to use the complete source history in R and S. 5 Maintaining Temporal Aggregates In this section we address the problem of maintaining a class of commonly used temporal aggregate views called moving-window aggregates <ref> [NA89] </ref>. We use A 0 ;w to denote the aggregate operator, where A 0 is a set of projected and/or aggregated attributes, and w 0 is the window.
Reference: [ OS95] <author> G. Ozsoyoglu and R. Snodgrass. </author> <title> Temporal and real-time databases: A survey. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 7(4) </volume> <pages> 513-532, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: We also apply methods for maintaining non-temporal aggregate views from [Qua96]. Numerous temporal data models and query languages have been proposed; see <ref> [ OS95] </ref> for a survey. We have chosen BCDM [JSS94], the underlying data model for TSQL2 [SJS95], as a basis for our work. Our concept of t -reducibility (Section 3.2) is essentially that of snapshot reducibility discussed in [Sno87, BJS95].
Reference: [Ple93] <author> D. Plexousakis. </author> <title> Integrity constraint and rule maintenance in temporal deductive knowledge bases. </title> <booktitle> In Proceedings of the 1993 International Conference on Very Large Data Bases, </booktitle> <pages> pages 146-157, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: We consider a more expressive temporal query language and also handle NOW stored in data. [CT95] and <ref> [Ple93] </ref> explore the related problem of monitoring temporal integrity constraints. The languages they use are logical rather than algebraic, and are generally less expressive.
Reference: [QGMW96] <author> D. Quass, A. Gupta, I. S. Mumick, and J. Widom. </author> <title> Making views self-maintainable for data warehousing. </title> <booktitle> In Proceedings of the 1996 International Conference on Parallel and Distributed Information Systems, </booktitle> <pages> pages 158-169, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: The overall architecture of the temporal WHIPS system is illustrated in Figure 8. For each temporal view exported by the warehouse, there is a temporal view manager responsible for maintaining the view. In contrast to non-temporal WHIPS, the concept of self-maintainability <ref> [BCL89, GJM96, QGMW96] </ref> is essential for temporal views since temporal base relations are not available at non-temporal sources: In general, each temporal view manager must also maintain a set of auxiliary views so that the original view together with the auxiliary views can be maintained without sending queries back to the <p> for temporal views since temporal base relations are not available at non-temporal sources: In general, each temporal view manager must also maintain a set of auxiliary views so that the original view together with the auxiliary views can be maintained without sending queries back to the sources, exactly as in <ref> [QGMW96] </ref>. In the worst case, the auxiliary views would be the entire temporal base relations, but as we have seen, many views do not require these relations to be materialized fully. <p> Moreover, because views on history tend to become very large, it is important to enable auxiliary views to be shared among different view managers. How to choose auxiliary views for a set of temporal views so that together they all can be efficiently self-maintained is an open problem. <ref> [QGMW96] </ref> considers self-maintainability for a single, non-temporal view only. [RSS96] presents a framework for choosing auxiliary views that can be extended to a set of non-temporal views, but the criteria is efficiency, not self-maintainability. * Initializing the contents of a temporal view can be tricky.
Reference: [Qua96] <author> D. Quass. </author> <title> Maintenance expressions for views with aggregation. </title> <booktitle> In Proceedings of the ACM Workshop on Materialized Views: Techniques and Applications, </booktitle> <pages> pages 110-118, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: We also apply methods for maintaining non-temporal aggregate views from <ref> [Qua96] </ref>. Numerous temporal data models and query languages have been proposed; see [ OS95] for a survey. We have chosen BCDM [JSS94], the underlying data model for TSQL2 [SJS95], as a basis for our work. <p> Now, we define A 0 ;w (R) as a temporal relation with the property that for any t t now , t t ( A 0 ;w (R)) = nt A 0 (t t;w (R)). Here nt A 0 is the standard non-temporal grouping and aggregation operator <ref> [GHQ95, Qua96] </ref>. Intuitively, then, the result of a temporal aggregate is a sequence of values generated by moving a window of given length along the time line, and computing the non-temporal aggregate from all tuples valid in the current window. For detailed discussion on temporal aggregates please refer to [SGM93]. <p> By definition, A 0 ;0 is t -reducible: t t ( A 0 ;0 (R)) = nt A 0 (t t;0 (R)) = A 0 (t t (R)). According to Theorem 3.2, then, for instantaneous aggregates we may simply reuse the change propagation equations developed for non-temporal aggregates <ref> [Qua96] </ref>: Theorem 5.1 In the following, we require that 5R R = ? and 4R " R = ?; that is, we do not attempt to delete nonexistent tuples or insert existing ones. <p> These functions are identical to the ones used in <ref> [Qua96] </ref> for non-temporal aggregates, and are summarized in Figure 6 for reference. <p> In general, more intuition behind the change propagation equations for aggregates can be found in <ref> [Qua96] </ref>.
Reference: [QW91] <author> X. Qian and G. Wiederhold. </author> <title> Incremental recomputation of active relational expressions. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 3(3) </volume> <pages> 337-341, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: However, most work to date considers only non-temporal views. Although temporal view maintenance introduces many problems that are not present for non-temporal views, a number of techniques developed for maintaining non-temporal views are still applicable. For example, we adopt the algebraic approach of <ref> [QW91, GL95] </ref> for propagating source changes (Section 4.2), and we apply 2 satisfiability tests to predicates in order to simplify view refresh equations (Section 4.3), similar to the method of detecting irrelevant updates in [BCL89]. We also apply methods for maintaining non-temporal aggregate views from [Qua96]. <p> (recall Figure 1) reports a source update at t now that affects the con ceptual temporal base relation R: 10 Step 1.1: If necessary, the warehouse converts the source update it receives to an update on R in the form of deltas 5R and 4R, in the same style as <ref> [QW91, GL95] </ref>. This procedure is discussed in Section 4.1. Step 1.2: The warehouse refreshes all the views whose definitions reference R so that they are current with respect to t now . This procedure is discussed in Section 4.3. <p> This is achieved by repeatedly applying a set of change propagation equations in order to factor out the changes in the base relation from the temporal relational expressions defining the views <ref> [QW91, GL95] </ref>. <p> Thus we arrive at: 12 4.2.1 t -Reducible Operators Based on Theorem 3.2, change propagation equations for t -reducible operators can be derived directly from the corresponding equalities in non-temporal relational algebra, as in, e.g., <ref> [QW91] </ref>. The equations are identical in form to their non-temporal counterparts, except that all operators are now temporal.
Reference: [RSS96] <author> K. A. Ross, D. Srivastava, and S. Sudarshan. </author> <title> Materialized view maintenance and integrity constraint checking: Trading space for time. </title> <booktitle> In Proceedings of the 1996 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 447-458, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: How to choose auxiliary views for a set of temporal views so that together they all can be efficiently self-maintained is an open problem. [QGMW96] considers self-maintainability for a single, non-temporal view only. <ref> [RSS96] </ref> presents a framework for choosing auxiliary views that can be extended to a set of non-temporal views, but the criteria is efficiency, not self-maintainability. * Initializing the contents of a temporal view can be tricky. In particular, we need to assign "sensible" timestamps to tuples from non-temporal sources.
Reference: [SGM93] <author> R. T. Snodgrass, S. Gomez, and L. E. McKenzie. </author> <title> Aggregates in the temporal query language TQuel. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(5) </volume> <pages> 826-842, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Intuitively, then, the result of a temporal aggregate is a sequence of values generated by moving a window of given length along the time line, and computing the non-temporal aggregate from all tuples valid in the current window. For detailed discussion on temporal aggregates please refer to <ref> [SGM93] </ref>. As a concrete example, suppose that we have the following temporal relation: R = ha; f [90; 90]; [95; 96]gi; hb; f [94; 95]gi : Then, at t now = 97, we compute the count aggregate function over R with window length of 0 and 2, respectively.
Reference: [SJS95] <author> M. D. Soo, C. S. Jensen, and R. T. Snodgrass. </author> <title> An algebra for TSQL2. </title> <booktitle> In The TSQL2 Temporal Query Language, </booktitle> <pages> pages 505-546. </pages> <publisher> Kluwer Academic Press, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: We propose an architecture for the temporal data warehouse that automatically maintains temporal views over non-temporal source relations, and allows users to ask temporal queries using these views. The temporal view definition language we consider is equivalent to a subset of TSQL2 <ref> [SJS95] </ref> including a class of commonly used aggregates termed moving-window aggregates [NA89]. We present an algorithm to incrementally maintain temporal views as time advances and source relations undergo changes. number of non-temporal source relations which are monitored and exported by an extractor [Wid95]. <p> We also apply methods for maintaining non-temporal aggregate views from [Qua96]. Numerous temporal data models and query languages have been proposed; see [ OS95] for a survey. We have chosen BCDM [JSS94], the underlying data model for TSQL2 <ref> [SJS95] </ref>, as a basis for our work. Our concept of t -reducibility (Section 3.2) is essentially that of snapshot reducibility discussed in [Sno87, BJS95]. We use a different name in order to avoid potential confusion with the SNAPSHOT construct in TSQL2.
Reference: [Sno87] <author> R. T. Snodgrass. </author> <title> The temporal query language TQuel. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 247-298, </pages> <month> June </month> <year> 1987. </year> <month> 26 </month>
Reference-contexts: Numerous temporal data models and query languages have been proposed; see [ OS95] for a survey. We have chosen BCDM [JSS94], the underlying data model for TSQL2 [SJS95], as a basis for our work. Our concept of t -reducibility (Section 3.2) is essentially that of snapshot reducibility discussed in <ref> [Sno87, BJS95] </ref>. We use a different name in order to avoid potential confusion with the SNAPSHOT construct in TSQL2. A number of papers are related to temporal view maintenance to some degree. [JMS95] addresses the temporal view maintenance problem in the chronicle data model. <p> Note the correspondence with snapshot reducibility from <ref> [Sno87, BJS95] </ref>. Definition 3.2 (t -Reducible Operator) Let R 1 ; :::; R n be relations in a temporal database with current time t now .
Reference: [WGL + 96] <author> J. L. Wiener, H. Gupta, W. J. Labio, Y. Zhuge, H. Garcia-Molina, and J. Widom. </author> <title> A system pro-totype for warehouse view maintenance. </title> <booktitle> In Proceedings of the ACM Workshop on Materialized Views: Techniques and Applications, </booktitle> <pages> pages 26-33, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: The extension of our algorithm for temporal aggregates is discussed in Section 5. Section 6 briefly describes how our framework is being integrated into the WHIPS data warehousing prototype at Stanford <ref> [WGL + 96] </ref>. Section 7 concludes and discusses further research. Complete proofs for all theorems are provided in Appendix A. 2 Related Work The view maintenance problem has been studied extensively; see [GM95] for a survey. However, most work to date considers only non-temporal views. <p> For details on the basic (nontemporal) WHIPS system, see <ref> [WGL + 96] </ref>. The overall architecture of the temporal WHIPS system is illustrated in Figure 8. For each temporal view exported by the warehouse, there is a temporal view manager responsible for maintaining the view. <p> Currently we simply materialize relevant portions of all temporal base relations referenced in the view in addition to the view itself. Second, the view initializer asks the temporal integrator to spawn a new view manager, and sets up monitors to detect relevant source updates <ref> [Wid95, WGL + 96] </ref>. Finally, the view initializer initializes the contents of the newly created tables at the warehouse by issuing queries to the distributed query processor. The query processor contacts the wrapper for each source involved in the view. <p> As discussed throughout this paper, temporal views need to be maintained when source relations are updated and when time advances. Source updates are detected by monitors and sent to the integrator, exactly as in non-temporal warehousing systems <ref> [WGL + 96] </ref>. The temporal integrator first converts the non-temporal source updates to updates to temporal base relations, following the procedure described in Section 4.1. It then forwards these updates to all relevant view managers.
Reference: [Wid95] <author> J. Widom. </author> <title> Research problems in data warehousing. </title> <booktitle> In Proceedings of the 1995 International Conference on Information and Knowledge Management, </booktitle> <pages> pages 25-30, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: 1 Introduction A data warehouse is a repository for efficient querying and analysis of integrated information from a wide variety of sources. The warehouse effectively maintains materialized views over base relations at the sources <ref> [LW95, Wid95] </ref>. Clients of the warehouse may not only be interested in the most up-to-date information, but also the history of how the source data has evolved. It is therefore important that the warehouse supports temporal queries. <p> We present an algorithm to incrementally maintain temporal views as time advances and source relations undergo changes. number of non-temporal source relations which are monitored and exported by an extractor <ref> [Wid95] </ref>. When a non-temporal source relation is updated, the extractor notifies the warehouse with the content of the update. Conceptually, for each non-temporal source relation R nt , the warehouse maintains a temporal relation R, which encodes the complete history of R nt . <p> Currently we simply materialize relevant portions of all temporal base relations referenced in the view in addition to the view itself. Second, the view initializer asks the temporal integrator to spawn a new view manager, and sets up monitors to detect relevant source updates <ref> [Wid95, WGL + 96] </ref>. Finally, the view initializer initializes the contents of the newly created tables at the warehouse by issuing queries to the distributed query processor. The query processor contacts the wrapper for each source involved in the view.
Reference: [YW98] <author> J. Yang and J. Widom. </author> <title> Maintaining temporal views over non-temporal information sources for data warehousing. </title> <booktitle> In Proceedings of the 1998 International Conference on Extending Database Technology, </booktitle> <pages> pages 389-403, </pages> <month> March </month> <year> 1998. </year>
Reference-contexts: Meanwhile, since warehousing applications do often require fl This work was supported by Rome Laboratories under Air Force Contract F30602-96-1-0312, and by the Advanced Research and Development Committee of the Community Management Staff as a project in the MDDS Program. y This paper is the full version of <ref> [YW98] </ref>. temporal information, most commercial systems store time information as normal attributes in the standard relational model, and query it using SQL. However, as pointed out by the temporal database community, writing "interesting" temporal queries in the absence of an actual temporal data model can be extremely cumbersome and error-prone.
References-found: 31

