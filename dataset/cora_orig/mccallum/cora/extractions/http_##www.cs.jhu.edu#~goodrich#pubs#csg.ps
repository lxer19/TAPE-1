URL: http://www.cs.jhu.edu/~goodrich/pubs/csg.ps
Refering-URL: http://www.cs.jhu.edu/~goodrich/pubs/index.html
Root-URL: http://www.cs.jhu.edu
Email: E-mail: goodrich@cs.jhu.edu  
Title: An Improved Ray Shooting Method for Constructive Solid Geometry Models via Tree Contraction announced in
Author: Michael T. Goodrich 
Keyword: Boolean algebra, constructive solid geometry, CSG tree, geometric data structures, ray casting, ray shooting, solid modeling, tree contraction  
Date: 1990, 118-128.  
Note: This research was  Geometry," Proc. 1st ACM-SIAM Symp. on Discrete Algorithms,  This research supported by the NSF and DARPA under Grant CCR-8908092, and by the NSF under Grants CCR-8810568, CCR-9003299, and IRI-9116843.  
Address: Baltimore, MD 21218  
Affiliation: Department of Computer Science The Johns Hopkins University  
Abstract: In the Constructive Solid Geometry (CSG) representation a geometric object is described as the hierarchical combination of a number of primitive shapes using the operations union, intersection, subtraction, and exclusive-union. This hierarchical description defines an expression tree, T , called the CSG tree, with leaves associated with primitive shapes, internal nodes associated with operations, and whose "value" is the geometric object. Evaluation of CSG trees is an important computation that arises in many rendering and analysis problems for geometric models, with ray shooting (also known as "ray casting") being one of the most important. Given any CSG tree T , which may be unbalanced, we show how to convert T into a functionally-equivalent tree, D, that is balanced. We demonstrate the utility of this conversion by showing how it can be used to improve the worst-case running time for ray shooting against a CSG model from O(n 2 ) to O(n log n), which is optimal. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Abrahamson, N. Dadoun, D. G. Kirkpatrick, and T. Przytycka, </author> <title> "A simple parallel tree contraction algorithm," </title> <journal> J. Algorithms, </journal> <volume> 10, </volume> <pages> 287-302, </pages> <year> 1989. </year>
Reference-contexts: Thus, we believe our method should run very fast in practice, compared to previous methods. Indeed, justification for this claim has been given recently by Facello [25] in some benchmarking tests. The main paradigm we exploit for our algorithms is the tree contraction technique <ref> [1, 7, 36, 45, 40] </ref> from parallel algorithm design. The particular approach we follow is that proposed by Miller and Reif [40], where one applies two procedures, "rake" and "compress", to evaluate an m-leaf arithmetic expression tree in parallel [1, 36, 40]. <p> The particular approach we follow is that proposed by Miller and Reif [40], where one applies two procedures, "rake" and "compress", to evaluate an m-leaf arithmetic expression tree in parallel <ref> [1, 36, 40] </ref>. This results in a method that runs in O (log m) parallel steps, even if the tree is quite imbalanced. We use this tree contraction paradigm to convert any given m-leaf CSG tree T into a functionally-equivalent m-leaf expression tree D.
Reference: [2] <author> P. K. Agarwal, </author> <title> "Ray shooting and other applications of spanning trees and low stabbing number," </title> <booktitle> in Proc. 5th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> 315-325, </pages> <year> 1989. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick [18, 20, 19] and others <ref> [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] </ref> directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries.
Reference: [3] <author> P. K. Agarwal, B. Aronov, M. Sharir, and S. Suri, </author> <title> "Selecting distances in the plane," </title> <booktitle> in Proc. 6th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> 321-331, </pages> <year> 1990. </year>
Reference-contexts: Some examples include the ray shooting method of Agarwal and Matousek [4], the "biggest stick" method of Agarwal, Sharir, and Toledo [5], the "largest polygon" algorithm of Toledo [57], the ham-sandwich cut algorithm of Cole [13], the distance-selection method of Agarwal et al. <ref> [3] </ref>, and the closest-pair algorithms of Chazelle et al. [9]. One of the nice side effects of using a technique from parallel algorithm design for a sequential algorithm, is that it makes the parallelization of that method much more likely.
Reference: [4] <author> P. K. Agarwal and J. Matousek, </author> <title> "Ray shooting and parametric search," </title> <booktitle> in Proc. 24th Annu. ACM Sympos. Theory Comput., </booktitle> <pages> 517-526, </pages> <year> 1992. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick [18, 20, 19] and others <ref> [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] </ref> directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries. <p> Incidentally, variants of Megiddo's technique have proven very effective of late at improving the running times of several geometric optimization problems. Some examples include the ray shooting method of Agarwal and Matousek <ref> [4] </ref>, the "biggest stick" method of Agarwal, Sharir, and Toledo [5], the "largest polygon" algorithm of Toledo [57], the ham-sandwich cut algorithm of Cole [13], the distance-selection method of Agarwal et al. [3], and the closest-pair algorithms of Chazelle et al. [9].
Reference: [5] <author> P. K. Agarwal, M. Sharir, and S. Toledo, </author> <title> "Applications of parametric searching in geometric optimization," </title> <booktitle> in Proc. 3rd ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> 72-82, </pages> <year> 1992. </year> <month> 19 </month>
Reference-contexts: Incidentally, variants of Megiddo's technique have proven very effective of late at improving the running times of several geometric optimization problems. Some examples include the ray shooting method of Agarwal and Matousek [4], the "biggest stick" method of Agarwal, Sharir, and Toledo <ref> [5] </ref>, the "largest polygon" algorithm of Toledo [57], the ham-sandwich cut algorithm of Cole [13], the distance-selection method of Agarwal et al. [3], and the closest-pair algorithms of Chazelle et al. [9].
Reference: [6] <author> M. Ben-Or, </author> <title> "Lower bounds for algebraic computation trees," </title> <booktitle> in Proc. 15th Annu. ACM Sym--pos. Theory Comput., </booktitle> <pages> 80-86, </pages> <year> 1983. </year>
Reference-contexts: Proof: We have already established the upper bound. The lower bound is established by a simple reduction from the set disjointness problem, which has (n log n)-time lower bound in the algebraic computation tree model <ref> [6, 53] </ref>. We leave the details to the reader. 2 3.2 Extending Our Method to 3-Dimensional Line Classification If we take a closer look at our method it is easy to see how to extend this approach to higher dimensional line classification.
Reference: [7] <author> R. P. Brent, </author> <title> "The parallel evaluation of general arithmetic expressions," </title> <journal> J. ACM, </journal> <volume> 21(2), </volume> <pages> 201-206, </pages> <year> 1974. </year>
Reference-contexts: Thus, we believe our method should run very fast in practice, compared to previous methods. Indeed, justification for this claim has been given recently by Facello [25] in some benchmarking tests. The main paradigm we exploit for our algorithms is the tree contraction technique <ref> [1, 7, 36, 45, 40] </ref> from parallel algorithm design. The particular approach we follow is that proposed by Miller and Reif [40], where one applies two procedures, "rake" and "compress", to evaluate an m-leaf arithmetic expression tree in parallel [1, 36, 40]. <p> Our method is based on a modification of the tree contraction technique from parallel algorithm design <ref> [7, 35, 40, 45] </ref> for evaluating an arithmetic expression tree whose operations come from the set f+; fig. In particular, we use a sequential implementation of the rake 6 and-compress algorithm of Miller and Reif [40]. <p> We call E the evaluation function. (See Figure 2a.) Case 2: v's sibling w is not a leaf. In this case we still remove v, but, following the approach of Brent <ref> [7] </ref>, we symbolically represent the effect v has on z's value, where z is v's parent. Specifically, we associate two bits, a and b, with z. <p> Incidentally, this formulation seems to be new, as the previous methods for tree-contraction require two operations that form a commutative semi-ring <ref> [7, 35, 40, 45] </ref>, not the four Boolean operations that we consider. Figure 3 shows how to set the ab labels for z, depending on the bit b associated with v and the operation op at z.
Reference: [8] <author> B. Chazelle, H. Edelsbrunner, M. Grigni, L. Guibas, J. Hershberger, M. Sharir, and J. Snoeyink, </author> <title> "Ray shooting in polygons using geodesic triangulations," </title> <booktitle> in Proc. 18th Internat. Colloq. Automata Lang. Program., </booktitle> <publisher> Springer-Verlag, </publisher> <pages> 661-673, </pages> <year> 1991. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick [18, 20, 19] and others <ref> [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] </ref> directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries.
Reference: [9] <author> B. Chazelle, H. Edelsbrunner, L. Guibas, and M. Sharir, </author> <title> "Diameter, width, closest line pair, and parametric searching," </title> <booktitle> in Proc. 8th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> 120-129, </pages> <year> 1992. </year>
Reference-contexts: include the ray shooting method of Agarwal and Matousek [4], the "biggest stick" method of Agarwal, Sharir, and Toledo [5], the "largest polygon" algorithm of Toledo [57], the ham-sandwich cut algorithm of Cole [13], the distance-selection method of Agarwal et al. [3], and the closest-pair algorithms of Chazelle et al. <ref> [9] </ref>. One of the nice side effects of using a technique from parallel algorithm design for a sequential algorithm, is that it makes the parallelization of that method much more likely.
Reference: [10] <author> B. Chazelle, H. Edelsbrunner, L. J. Guibas, and M. Sharir, </author> <title> "Lines in space: </title> <booktitle> combinatorics, algorithms, and applications," in Proc. 21st Annu. ACM Sympos. Theory Comput., </booktitle> <pages> 382-393, </pages> <year> 1989. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick [18, 20, 19] and others <ref> [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] </ref> directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries.
Reference: [11] <author> S. W. Cheng and R. Janardan, </author> <title> "Space-efficient ray shooting and intersection searching: algorithms, </title> <booktitle> dynamization and applications," in Proc. 2nd ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> 7-16, </pages> <year> 1991. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick [18, 20, 19] and others <ref> [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] </ref> directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries.
Reference: [12] <author> R. F. Cohen and R. Tamassia, </author> <title> "Dynamic expression trees and their applications," </title> <booktitle> in Proc. 2nd ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> 52-61, </pages> <year> 1991. </year>
Reference-contexts: Thus, a natural question is whether one can still perform classification efficiently in an environment where the user may dynamically update the CSG representation (say, by inserting and deleting primitives and operations). Cohen and Tamas-sia <ref> [12] </ref> give an elegant method for dynamically maintaining a CSG representation relative to a fixed point in space, but we know of no efficient general methods for dynamic CSG tree maintenance that have good worst-case behavior. Acknowledgements We would like to thank Richard Beigel, John K. Johnstone, S.
Reference: [13] <author> R. Cole, </author> <title> "Slowing down sorting networks to obtain faster sorting algorithms," </title> <journal> J. ACM, </journal> <volume> 34, </volume> <pages> 200-208, </pages> <year> 1987. </year>
Reference-contexts: Some examples include the ray shooting method of Agarwal and Matousek [4], the "biggest stick" method of Agarwal, Sharir, and Toledo [5], the "largest polygon" algorithm of Toledo [57], the ham-sandwich cut algorithm of Cole <ref> [13] </ref>, the distance-selection method of Agarwal et al. [3], and the closest-pair algorithms of Chazelle et al. [9]. One of the nice side effects of using a technique from parallel algorithm design for a sequential algorithm, is that it makes the parallelization of that method much more likely.
Reference: [14] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1990. </year>
Reference-contexts: This will give us the tree T i+1 . First, of course, we must identify the improper nodes in T 0 i that must be compressed, but this is easily done by a simple tree-traversal (e.g., see <ref> [14] </ref>). While we are performing this traversal it is an easy matter to note which improper internal nodes have an improper child and are an odd distance from their nearest proper ancestor. <p> The point p is the first point we traverse such that the value associated with the root of D changes. If we implement the traversal along ~r using a heap (as in the heapsort procedure <ref> [14] </ref>) to give us the intersection points as they occur along ~r, then this takes O (! log m) time, where ! is the number of (spurious) intersections ~r has with primitives of the CSG tree before it hits the boundary of R.
Reference: [15] <author> M. de Berg, D. Halperin, M. Overmars, J. Snoeyink, and M. van Kreveld, </author> <title> "Efficient ray shooting and hidden surface removal," </title> <booktitle> in Proc. 7th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> 21-30, </pages> <year> 1991. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick [18, 20, 19] and others <ref> [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] </ref> directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries.
Reference: [16] <author> D. </author> <title> Dobkin, </title> <journal> "Computational geometry and computer graphics," Proceedings of the IEEE, </journal> <volume> 80(9), </volume> <pages> 1400-1411, </pages> <year> 1992. </year>
Reference-contexts: This area has become a very rich research area of late, and the reader interested in an overview of this previous work is referred to the excellent papers by Dobkin <ref> [16] </ref> and Yao [58].
Reference: [17] <author> D. Dobkin, L. Guibas, J. Hershberger, and J. Snoeyink, </author> <title> "An efficient algorithm for finding the CSG representation of a simple polygon," </title> <booktitle> Proc. SIGGRAPH '88, Computer Graphics, </booktitle> <volume> 22(4), </volume> <pages> 31-40, </pages> <year> 1988. </year>
Reference-contexts: the problem of constructing a concise CSG representation of an object given its boundary 1 Recall that the height of a binary tree T is the length of a longest root-to-leaf path in T (so that the height of single-node tree is 0). 3 description (e.g., see Dobkin et al. <ref> [17] </ref> or Patterson and Yao [42]), which can be viewed as an "inverse" problem to the one that we address here. More specific to this paper, however, our research is directed at applying a technique from parallel algorithm design to a sequential problem in solid modeling.
Reference: [18] <author> D. P. Dobkin and D. G. Kirkpatrick, </author> <title> "Fast detection of polyhedral intersection," </title> <journal> Theoret. Comput. Sci., </journal> <volume> 27, </volume> <pages> 241-253, </pages> <year> 1983. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick <ref> [18, 20, 19] </ref> and others [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries.
Reference: [19] <author> D. P. Dobkin and D. G. Kirkpatrick, </author> <title> "A linear algorithm for determining the separation of convex polyhedra," </title> <journal> J. Algorithms, </journal> <volume> 6, </volume> <pages> 381-392, </pages> <year> 1985. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick <ref> [18, 20, 19] </ref> and others [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries.
Reference: [20] <author> D. P. Dobkin and D. G. Kirkpatrick, </author> <title> "Determining the separation of preprocessed polyhedra - a unified approach," </title> <booktitle> in Proc. 17th Internat. Colloq. Automata Lang. Program., Lecture Notes in Computer Science, </booktitle> <volume> vol. 443, </volume> <publisher> Springer-Verlag, </publisher> <pages> 400-413, </pages> <year> 1990. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick <ref> [18, 20, 19] </ref> and others [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries.
Reference: [21] <author> P. C. Dykstra and M. J. Muuss, </author> <title> "The BRL-CAD package: An overview," </title> <booktitle> in Proc. BRL-CAD Symposium '89, Aberdeen Proving Ground, Maryland, </booktitle> <pages> 1-9, </pages> <year> 1989. </year>
Reference-contexts: In fact, Facello [25] performed a series of benchmark tests of our method (optimized with these two heuristics) versus the ray-shooting procedure used in the CSG software package BRL-CAD developed at the Ballistic Research Laboratory of the U.S. Army Aberdeen Proving Grounds <ref> [21] </ref>, which is an implementation of the method of Laidlaw, Trumbore, and Hughes [37] (and is also optimized with these two heuristics). Facello's results showed that, for "random" models of 50 or more primitives, our method out performed the method of BRL-CAD.
Reference: [22] <author> H. Edelsbrunner, </author> <title> Algorithms in Combinatorial Geometry, </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: then we can assume that L and each f lie in different planes and their intersection is either empty or is a single point, which we can easily determine in O (log n) time, after an O (n)-time preprocessing step, using standard computational geometry triangulation and point-location methods (e.g., see <ref> [22, 44] </ref>). Thus, we can find all the intersections of L with the CSG primitives in O (n + m log n) time in the general case, and in O (m) = O (n) time if all the objects have an O (1) storage description. <p> Fortunately, it is fairly easy to make Steps 2 and 3 robust using infinitesimal perturbation [23, 59], since they deal with the computation of the ordered intersections along the line L. Indeed, in the 2-d case we still assume that L intersects no vertices of the arrangement <ref> [22] </ref> of the primitive boundary edges, and in the 3-d case we still assume that L intersects no vertices or edges of the arrangement of the primitive boundary faces.
Reference: [23] <author> H. Edelsbrunner and E. P. Mucke, </author> <title> "Simulation of simplicity: a technique to cope with degenerate cases in geometric algorithms," </title> <journal> ACM Trans. Graph., </journal> <volume> 9, </volume> <pages> 66-104, </pages> <year> 1990. </year> <month> 20 </month>
Reference-contexts: For example, it is quite common for different primitives to share vertices, edges, and/or faces. Powerful and general computational geometry techniques, such as the simulation of simplicity technique of Edelsbrunner and 17 Mucke <ref> [23] </ref> and the symbolic perturbation technique of Yap [59], have been developed for de-signing computational geometry algorithms assuming there are no degeneracies. Intuitively, these methods apply an "infinitesimal" perturbation to the input so that all the objects are put into general position. <p> If the objects are not in general position, then we must modify our algorithms slightly to take this into consideration. Fortunately, it is fairly easy to make Steps 2 and 3 robust using infinitesimal perturbation <ref> [23, 59] </ref>, since they deal with the computation of the ordered intersections along the line L.
Reference: [24] <author> J. L. Ellis, G. Kedem, T. C. Lyerly, D. G. Thielman, R. J. Marisa, J. P. Menon, and H. B. Voelcker, </author> <title> "The ray casting engine and ray representations: a technical summary," </title> <journal> Internat. J. Comput. Geom. Appl., </journal> <volume> 1(4), </volume> <pages> 347-380, </pages> <year> 1991. </year>
Reference-contexts: Besides this, the most notable previous parallel effort has been the work of Ellis et al. <ref> [24] </ref> on a special-purpose machine, which they call the RayCasting Engine, for line classification of 3-dimensional CSG objects. Their machine has over 250,000 special-purpose processors dedicated to CSG classification. <p> Since classification of lines and other geometric objects (such as the CSG model's boundary) is such a fundamental problem, a considerable amount of work (e.g., see <ref> [24, 28, 29, 37, 41, 47, 48, 49, 54] </ref>) has been directed at methods for improving these running times.
Reference: [25] <author> M. A. Facello, </author> <title> "Improved ray tracing methods for CSG modeling systems," </title> <type> Report JHU-90/05, </type> <institution> Dept. Comput. Sci., Johns Hopkins Univ., Baltimore, MD, </institution> <year> 1990. </year>
Reference-contexts: As an aid to practitioners, we also enumerate some additional heuristics that one can apply to make our method run faster in practice. Thus, we believe our method should run very fast in practice, compared to previous methods. Indeed, justification for this claim has been given recently by Facello <ref> [25] </ref> in some benchmarking tests. The main paradigm we exploit for our algorithms is the tree contraction technique [1, 7, 36, 45, 40] from parallel algorithm design. <p> This does not improve the worst-case performance of the method, but should improve the running time in practice. In fact, Facello <ref> [25] </ref> performed a series of benchmark tests of our method (optimized with these two heuristics) versus the ray-shooting procedure used in the CSG software package BRL-CAD developed at the Ballistic Research Laboratory of the U.S. <p> Facello's results showed that, for "random" models of 50 or more primitives, our method out performed the method of BRL-CAD. In fact, even for objects described with only 500 primitives our method achieved a 50% speed-up over the BRL-CAD method. (See <ref> [25] </ref> for details.) Thus, we have established efficient bounds for line classification and ray shooting in 2-d and 3-d CSG models.
Reference: [26] <author> J. D. Foley, A. Van Dam, S. K. Feiner, and J. F. Hughes, </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Perhaps the most important such computation is line classification [55, 56]: determining the intersections of a line with an object defined by a CSG representation, for it is the primitive computation used in many CSG rendering algorithms <ref> [26, 28, 34, 38, 46, 48] </ref>. 2 1.1 Our Results In this paper we show how to convert any CSG tree T into a functionally-equivalent balanced tree D of roughly the same size as T , and we show how this leads to a method for line classification in a CSG <p> Our tree-contraction method does not have any of these negative side effects. The reader interested in more information on constructive solid geometry is referred to <ref> [26, 34, 38, 46, 47, 48] </ref> for some excellent discussions of this representation and related issues. In the next section we give our method for restructuring the CSG tree T and we show how we can use this restructured tree to speed-up ray shooting in CSG models in Section 3. <p> Formally, these operations are defined so that the result of applying an operation to two objects is the closure of the result of applying that operation to the interiors of the two objects. Such operations are said to be regularized <ref> [26, 28, 34, 38, 46, 48] </ref>. Degeneracies cannot be resolved using an infinitesimal perturbation scheme, since such a perturbation could create spurious portions of the CSG object.
Reference: [27] <author> A. Gajentaan and M. H. Overmars, </author> <title> "n 2 -hard problems in computational geometry," </title> <type> Report RUU-CS-93-15, </type> <institution> Dept. Comput. Sci., Utrecht Univ., </institution> <address> Utrecht, The Netherlands, </address> <year> 1993. </year>
Reference-contexts: It seems very unlikely that one will be able to perform CSG boundary evaluation in o (n 2 ) time in the worst case, however, FOR it is easy to show that this problem belongs to the class of so-called "n 2 -hard" problems in computational geometry <ref> [27] </ref> (we leave the details of this reduction to the interested reader). There are a number of other possible directions for future research, however. One of the most interesting could be the search for new heuristics for further speeding up CSG evaluation procedures that use the dwarf CSG tree.
Reference: [28] <author> P. Getto, </author> <title> "Fast ray tracing of unevaluated constructive solid geometry models," </title> <booktitle> in New Advances in Computer Graphics: Proc. of Computer Graphics International '89, </booktitle> <editor> R. A. Earnshaw and B. Wyvel, editors, </editor> <publisher> Springer-Verlag, </publisher> <pages> 563-578, </pages> <year> 1989. </year>
Reference-contexts: Perhaps the most important such computation is line classification [55, 56]: determining the intersections of a line with an object defined by a CSG representation, for it is the primitive computation used in many CSG rendering algorithms <ref> [26, 28, 34, 38, 46, 48] </ref>. 2 1.1 Our Results In this paper we show how to convert any CSG tree T into a functionally-equivalent balanced tree D of roughly the same size as T , and we show how this leads to a method for line classification in a CSG <p> roughly the same size as T , and we show how this leads to a method for line classification in a CSG model that runs in O (n log n) time, which is optimal and improves the previous O (n 2 ) bound, due to Tilove [55, 56] and Getto <ref> [28] </ref>, where n is the total number of edges that determine all the primitives stored at the leaves of T . Our method can be implemented using simple operations, such as sorting and table look-ups, and does not require any sophisticated data structures. <p> Our method can be implemented using simple operations, such as sorting and table look-ups, and does not require any sophisticated data structures. Moreover, one can apply many of the previous heuristic techniques for speeding up CSG ray shooting to our methods, such as "bounding boxes" <ref> [28, 29, 47, 49, 50, 51] </ref> and face cutting [37], although none of these heuristics would improve the worst case running time. As an aid to practitioners, we also enumerate some additional heuristics that one can apply to make our method run faster in practice. <p> The specific problem of classifying a line against a CSG model was first studied by Tilove [55, 56], who gave a method from which one can derive an O (n 2 )-time method. This bound was achieved explicitly more recently by Getto <ref> [28] </ref>, who also gave some heuristics that should help this classification algorithm run faster in practice. <p> Since classification of lines and other geometric objects (such as the CSG model's boundary) is such a fundamental problem, a considerable amount of work (e.g., see <ref> [24, 28, 29, 37, 41, 47, 48, 49, 54] </ref>) has been directed at methods for improving these running times. <p> The main idea is to restrict comparisons to primitives that are geometrically "near" the object being classified <ref> [28, 29, 47, 49, 50, 51] </ref>. <p> Our method works for both 2- and 3-dimensional objects, and runs in O (n log n) time, improving the previous methods, due to Tilove [55, 56] and Getto <ref> [28] </ref>, by almost a linear factor. We describe our method assuming a 2-dimensional representation, and then show how to extend it to 3-dimensions. <p> Formally, these operations are defined so that the result of applying an operation to two objects is the closure of the result of applying that operation to the interiors of the two objects. Such operations are said to be regularized <ref> [26, 28, 34, 38, 46, 48] </ref>. Degeneracies cannot be resolved using an infinitesimal perturbation scheme, since such a perturbation could create spurious portions of the CSG object.
Reference: [29] <author> J. Goldfeather, S. Molnar, G. Turk, and H. Fuchs, </author> <title> "Near real-time CSG rendering using tree normalization and geometric pruning," </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 9(3), </volume> <pages> 20-28, </pages> <year> 1989. </year>
Reference-contexts: Our method can be implemented using simple operations, such as sorting and table look-ups, and does not require any sophisticated data structures. Moreover, one can apply many of the previous heuristic techniques for speeding up CSG ray shooting to our methods, such as "bounding boxes" <ref> [28, 29, 47, 49, 50, 51] </ref> and face cutting [37], although none of these heuristics would improve the worst case running time. As an aid to practitioners, we also enumerate some additional heuristics that one can apply to make our method run faster in practice. <p> Since classification of lines and other geometric objects (such as the CSG model's boundary) is such a fundamental problem, a considerable amount of work (e.g., see <ref> [24, 28, 29, 37, 41, 47, 48, 49, 54] </ref>) has been directed at methods for improving these running times. <p> The main idea is to restrict comparisons to primitives that are geometrically "near" the object being classified <ref> [28, 29, 47, 49, 50, 51] </ref>. <p> A common way that this approach is implemented is to "push" all the negations in T to the leaves using DeMorgan's Laws and then define T 0 to be the sum-of-products expansion of the resulting logical expression (e.g., see Goldfeather et al. <ref> [29] </ref>), i.e., T 0 is a disjunctive normal form. Of course, if T is sufficiently complicated, this could end up exploding the size of the CSG tree exponentially. <p> So, in order to be practical, this approach must be combined with some kind of a "tree-pruning" heuristic based on partially evaluating T while restructuring it (say using bounding boxes) <ref> [29] </ref>. Rossignac and Voelcker [48] show how to further exploit the structural locality in T by using a notion they call the active zone of a primitive p, which, intuitively, is the portion of the CSG solid that is affected by p.
Reference: [30] <author> M. Goodrich and R. Tamassia, </author> <title> "Dynamic ray shooting and shortest paths via balanced geodesic triangulations," </title> <booktitle> in Proc. 9th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> 318-327, </pages> <year> 1993. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick [18, 20, 19] and others <ref> [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] </ref> directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries.
Reference: [31] <author> M. T. Goodrich, M. Ghouse, and J. </author> <title> Bright, "Generalized sweep methods for parallel computational geometry," </title> <booktitle> in Proc. 2nd ACM Sympos. Parallel Algorithms Architect., </booktitle> <pages> 280-289, </pages> <year> 1990. </year>
Reference-contexts: Indeed, this is exactly what has occurred, in that subsequent to the initial announcement of this work, Goodrich, Ghouse, and Bright <ref> [31] </ref> have shown how our tree-contraction method can be applied to ray shooting of CSG models, and even to more complicated classification problems, such as boundary evaluation. <p> In joint work with Ghouse and Bright, we have shown how our approach can be extended to perform 2-d boundary evaluation in parallel <ref> [31] </ref> using work that is O (n 2 log n) in the worst case. As for the sequential complexity, the best known method is that of Tawfik [54], which runs in O (n 2 ) time in the worst case.
Reference: [32] <author> L. Guibas, M. Overmars, and M. Sharir, </author> <title> "Intersecting line segments, ray shooting, and other applications of geometric partitioning techniques," </title> <booktitle> in Proc. 1st Scand. Workshop Algorithm Theory, Lecture Notes in Computer Science, </booktitle> <volume> vol. 318, </volume> <publisher> Springer-Verlag, </publisher> <pages> 64-73, </pages> <year> 1988. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick [18, 20, 19] and others <ref> [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] </ref> directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries.
Reference: [33] <author> L. Guibas, M. Overmars, and M. Sharir, </author> <title> "Ray shooting, implicit point location, and related queries in arrangements of segments," </title> <type> Report 433, </type> <institution> Dept. Comput. Sci., </institution> <address> New York Univ., New York, NY, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick [18, 20, 19] and others <ref> [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] </ref> directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries.
Reference: [34] <author> F. W. Jansen, </author> <title> "Depth-order point classification techniques for CSG display algorithms," </title> <journal> ACM Trans. on Graphics, </journal> <volume> 10(1), </volume> <pages> 40-70, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Allowing a user to define, manipulate, and analyze realistic geometric objects easily and efficiently is an important goal of geometric modeling. One representation for geometric objects that has received much attention of late, relative to this goal, is the Constructive Solid Geometry (CSG) representation (e.g., see [46] or <ref> [34] </ref>). <p> Perhaps the most important such computation is line classification [55, 56]: determining the intersections of a line with an object defined by a CSG representation, for it is the primitive computation used in many CSG rendering algorithms <ref> [26, 28, 34, 38, 46, 48] </ref>. 2 1.1 Our Results In this paper we show how to convert any CSG tree T into a functionally-equivalent balanced tree D of roughly the same size as T , and we show how this leads to a method for line classification in a CSG <p> Our tree-contraction method does not have any of these negative side effects. The reader interested in more information on constructive solid geometry is referred to <ref> [26, 34, 38, 46, 47, 48] </ref> for some excellent discussions of this representation and related issues. In the next section we give our method for restructuring the CSG tree T and we show how we can use this restructured tree to speed-up ray shooting in CSG models in Section 3. <p> Formally, these operations are defined so that the result of applying an operation to two objects is the closure of the result of applying that operation to the interiors of the two objects. Such operations are said to be regularized <ref> [26, 28, 34, 38, 46, 48] </ref>. Degeneracies cannot be resolved using an infinitesimal perturbation scheme, since such a perturbation could create spurious portions of the CSG object.
Reference: [35] <author> R. M. Karp and V. Ramachandran, </author> <title> "Parallel algorithms for shared memory machines," </title> <booktitle> in Handbook of Theoretical Computer Science, </booktitle> <editor> J. van Leeuwen, editor, </editor> <publisher> Elsevier/The MIT Press, Amsterdam, </publisher> <pages> 869-941, </pages> <year> 1990. </year>
Reference-contexts: Our method is based on a modification of the tree contraction technique from parallel algorithm design <ref> [7, 35, 40, 45] </ref> for evaluating an arithmetic expression tree whose operations come from the set f+; fig. In particular, we use a sequential implementation of the rake 6 and-compress algorithm of Miller and Reif [40]. <p> Incidentally, this formulation seems to be new, as the previous methods for tree-contraction require two operations that form a commutative semi-ring <ref> [7, 35, 40, 45] </ref>, not the four Boolean operations that we consider. Figure 3 shows how to set the ab labels for z, depending on the bit b associated with v and the operation op at z.
Reference: [36] <author> S. R. Kosaraju and A. L. Delcher, </author> <title> "Optimal parallel evaluation of tree-structured computations by raking," </title> <booktitle> in Proc. AWOC 88, Lecture Notes in Computer Science, </booktitle> <volume> vol. 319, </volume> <publisher> Springer-Verlag, </publisher> <pages> 101-110, </pages> <year> 1988. </year>
Reference-contexts: Thus, we believe our method should run very fast in practice, compared to previous methods. Indeed, justification for this claim has been given recently by Facello [25] in some benchmarking tests. The main paradigm we exploit for our algorithms is the tree contraction technique <ref> [1, 7, 36, 45, 40] </ref> from parallel algorithm design. The particular approach we follow is that proposed by Miller and Reif [40], where one applies two procedures, "rake" and "compress", to evaluate an m-leaf arithmetic expression tree in parallel [1, 36, 40]. <p> The particular approach we follow is that proposed by Miller and Reif [40], where one applies two procedures, "rake" and "compress", to evaluate an m-leaf arithmetic expression tree in parallel <ref> [1, 36, 40] </ref>. This results in a method that runs in O (log m) parallel steps, even if the tree is quite imbalanced. We use this tree contraction paradigm to convert any given m-leaf CSG tree T into a functionally-equivalent m-leaf expression tree D.
Reference: [37] <author> D. H. Laidlaw, W. B. Trumbore, and J. F. Hughes, </author> <title> "Constructive solid geometry for polyhedral objects," </title> <journal> Comput. Graph., </journal> <volume> 20(4), </volume> <pages> 161-170, </pages> <year> 1986. </year>
Reference-contexts: Moreover, one can apply many of the previous heuristic techniques for speeding up CSG ray shooting to our methods, such as "bounding boxes" [28, 29, 47, 49, 50, 51] and face cutting <ref> [37] </ref>, although none of these heuristics would improve the worst case running time. As an aid to practitioners, we also enumerate some additional heuristics that one can apply to make our method run faster in practice. <p> Since classification of lines and other geometric objects (such as the CSG model's boundary) is such a fundamental problem, a considerable amount of work (e.g., see <ref> [24, 28, 29, 37, 41, 47, 48, 49, 54] </ref>) has been directed at methods for improving these running times. <p> Army Aberdeen Proving Grounds [21], which is an implementation of the method of Laidlaw, Trumbore, and Hughes <ref> [37] </ref> (and is also optimized with these two heuristics). Facello's results showed that, for "random" models of 50 or more primitives, our method out performed the method of BRL-CAD.
Reference: [38] <author> M. Mantyla, </author> <title> An Introduction to Solid Modeling, </title> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: Perhaps the most important such computation is line classification [55, 56]: determining the intersections of a line with an object defined by a CSG representation, for it is the primitive computation used in many CSG rendering algorithms <ref> [26, 28, 34, 38, 46, 48] </ref>. 2 1.1 Our Results In this paper we show how to convert any CSG tree T into a functionally-equivalent balanced tree D of roughly the same size as T , and we show how this leads to a method for line classification in a CSG <p> Our tree-contraction method does not have any of these negative side effects. The reader interested in more information on constructive solid geometry is referred to <ref> [26, 34, 38, 46, 47, 48] </ref> for some excellent discussions of this representation and related issues. In the next section we give our method for restructuring the CSG tree T and we show how we can use this restructured tree to speed-up ray shooting in CSG models in Section 3. <p> Formally, these operations are defined so that the result of applying an operation to two objects is the closure of the result of applying that operation to the interiors of the two objects. Such operations are said to be regularized <ref> [26, 28, 34, 38, 46, 48] </ref>. Degeneracies cannot be resolved using an infinitesimal perturbation scheme, since such a perturbation could create spurious portions of the CSG object.
Reference: [39] <author> N. Megiddo, </author> <title> "Applying parallel computation algorithms in the design of serial algorithms," </title> <journal> J. ACM, </journal> <volume> 30, </volume> <pages> 852-865, </pages> <year> 1983. </year>
Reference-contexts: More specific to this paper, however, our research is directed at applying a technique from parallel algorithm design to a sequential problem in solid modeling. Our application of this paradigm is therefore somewhat reminiscent of a technique due to Megiddo <ref> [39] </ref>, which is also an application of techniques from parallel algorithm design to improve the time bounds for sequential problems. Incidentally, variants of Megiddo's technique have proven very effective of late at improving the running times of several geometric optimization problems.
Reference: [40] <author> G. L. Miller and J. H. Reif, </author> <title> "Parallel tree contraction and its application," </title> <booktitle> in Proc. 26th IEEE Symp. on Foundations of Computer Science, Aberdeen Proving Ground, Maryland, </booktitle> <pages> 478-489, </pages> <year> 1985. </year>
Reference-contexts: Thus, we believe our method should run very fast in practice, compared to previous methods. Indeed, justification for this claim has been given recently by Facello [25] in some benchmarking tests. The main paradigm we exploit for our algorithms is the tree contraction technique <ref> [1, 7, 36, 45, 40] </ref> from parallel algorithm design. The particular approach we follow is that proposed by Miller and Reif [40], where one applies two procedures, "rake" and "compress", to evaluate an m-leaf arithmetic expression tree in parallel [1, 36, 40]. <p> The main paradigm we exploit for our algorithms is the tree contraction technique [1, 7, 36, 45, 40] from parallel algorithm design. The particular approach we follow is that proposed by Miller and Reif <ref> [40] </ref>, where one applies two procedures, "rake" and "compress", to evaluate an m-leaf arithmetic expression tree in parallel [1, 36, 40]. This results in a method that runs in O (log m) parallel steps, even if the tree is quite imbalanced. <p> The particular approach we follow is that proposed by Miller and Reif [40], where one applies two procedures, "rake" and "compress", to evaluate an m-leaf arithmetic expression tree in parallel <ref> [1, 36, 40] </ref>. This results in a method that runs in O (log m) parallel steps, even if the tree is quite imbalanced. We use this tree contraction paradigm to convert any given m-leaf CSG tree T into a functionally-equivalent m-leaf expression tree D. <p> Our method is based on a modification of the tree contraction technique from parallel algorithm design <ref> [7, 35, 40, 45] </ref> for evaluating an arithmetic expression tree whose operations come from the set f+; fig. In particular, we use a sequential implementation of the rake 6 and-compress algorithm of Miller and Reif [40]. <p> In particular, we use a sequential implementation of the rake 6 and-compress algorithm of Miller and Reif <ref> [40] </ref>. <p> Incidentally, this formulation seems to be new, as the previous methods for tree-contraction require two operations that form a commutative semi-ring <ref> [7, 35, 40, 45] </ref>, not the four Boolean operations that we consider. Figure 3 shows how to set the ab labels for z, depending on the bit b associated with v and the operation op at z.
Reference: [41] <author> T. Ottmann, P. Widmayer, and D. Wood, </author> <title> "A fast algorithm for Boolean mask operations," Comput. Vision Graph. </title> <journal> Image Process., </journal> <volume> 30, </volume> <pages> 249-268, </pages> <year> 1985. </year>
Reference-contexts: Since classification of lines and other geometric objects (such as the CSG model's boundary) is such a fundamental problem, a considerable amount of work (e.g., see <ref> [24, 28, 29, 37, 41, 47, 48, 49, 54] </ref>) has been directed at methods for improving these running times. <p> Some methods have running times that are intersection sensitive, meaning that their time bounds depend on I, the number of intersection points determined by the m primitives. Examples include the 2-D boundary evaluation methods of Ottmann et al. <ref> [41] </ref>, which runs in O ((n + I)(m + log n)) time, and Tawfik [54], which runs in O (n log n + I) time. <p> Of course, if T is sufficiently complicated, this could end up exploding the size of the CSG tree exponentially. In fact, if T contains exclusive-union nodes (which are used in VLSI masking <ref> [41] </ref>), then simply pushing all the negations to the leaves of T could produce an exponential explosion in size. So, in order to be practical, this approach must be combined with some kind of a "tree-pruning" heuristic based on partially evaluating T while restructuring it (say using bounding boxes) [29].
Reference: [42] <author> M. S. Paterson and F. F. Yao, </author> <title> "Efficient binary space partitions for hidden-surface removal and solid modeling," </title> <journal> Discrete Comput. Geom., </journal> <volume> 5, </volume> <pages> 485-503, </pages> <year> 1990. </year>
Reference-contexts: concise CSG representation of an object given its boundary 1 Recall that the height of a binary tree T is the length of a longest root-to-leaf path in T (so that the height of single-node tree is 0). 3 description (e.g., see Dobkin et al. [17] or Patterson and Yao <ref> [42] </ref>), which can be viewed as an "inverse" problem to the one that we address here. More specific to this paper, however, our research is directed at applying a technique from parallel algorithm design to a sequential problem in solid modeling.
Reference: [43] <author> M. Pellegrini, </author> <title> "Stabbing and ray shooting in 3-dimensional space," </title> <booktitle> in Proc. 6th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> 177-186, </pages> <year> 1990. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick [18, 20, 19] and others <ref> [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] </ref> directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries.
Reference: [44] <author> F. P. Preparata and M. I. Shamos, </author> <title> Computational Geometry: an Introduction, </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: then we can assume that L and each f lie in different planes and their intersection is either empty or is a single point, which we can easily determine in O (log n) time, after an O (n)-time preprocessing step, using standard computational geometry triangulation and point-location methods (e.g., see <ref> [22, 44] </ref>). Thus, we can find all the intersections of L with the CSG primitives in O (n + m log n) time in the general case, and in O (m) = O (n) time if all the objects have an O (1) storage description.
Reference: [45] <author> M. Reid-Miller, G. L. Miller, and F. Modugno, </author> <title> "List ranking and parallel tree contraction," in Synthesis of Parallel Algorithms, </title> <editor> J. H. Reif, editor, </editor> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, 115-194, </address> <year> 1993. </year>
Reference-contexts: Thus, we believe our method should run very fast in practice, compared to previous methods. Indeed, justification for this claim has been given recently by Facello [25] in some benchmarking tests. The main paradigm we exploit for our algorithms is the tree contraction technique <ref> [1, 7, 36, 45, 40] </ref> from parallel algorithm design. The particular approach we follow is that proposed by Miller and Reif [40], where one applies two procedures, "rake" and "compress", to evaluate an m-leaf arithmetic expression tree in parallel [1, 36, 40]. <p> Our method is based on a modification of the tree contraction technique from parallel algorithm design <ref> [7, 35, 40, 45] </ref> for evaluating an arithmetic expression tree whose operations come from the set f+; fig. In particular, we use a sequential implementation of the rake 6 and-compress algorithm of Miller and Reif [40]. <p> Incidentally, this formulation seems to be new, as the previous methods for tree-contraction require two operations that form a commutative semi-ring <ref> [7, 35, 40, 45] </ref>, not the four Boolean operations that we consider. Figure 3 shows how to set the ab labels for z, depending on the bit b associated with v and the operation op at z.
Reference: [46] <author> A. A. G. Requicha, </author> <title> "Representations of rigid solids: theory, methods, </title> <journal> and systems," ACM Comput. Surv., </journal> <volume> 12, </volume> <pages> 437-464, </pages> <year> 1980. </year>
Reference-contexts: 1 Introduction Allowing a user to define, manipulate, and analyze realistic geometric objects easily and efficiently is an important goal of geometric modeling. One representation for geometric objects that has received much attention of late, relative to this goal, is the Constructive Solid Geometry (CSG) representation (e.g., see <ref> [46] </ref> or [34]). <p> Perhaps the most important such computation is line classification [55, 56]: determining the intersections of a line with an object defined by a CSG representation, for it is the primitive computation used in many CSG rendering algorithms <ref> [26, 28, 34, 38, 46, 48] </ref>. 2 1.1 Our Results In this paper we show how to convert any CSG tree T into a functionally-equivalent balanced tree D of roughly the same size as T , and we show how this leads to a method for line classification in a CSG <p> Our tree-contraction method does not have any of these negative side effects. The reader interested in more information on constructive solid geometry is referred to <ref> [26, 34, 38, 46, 47, 48] </ref> for some excellent discussions of this representation and related issues. In the next section we give our method for restructuring the CSG tree T and we show how we can use this restructured tree to speed-up ray shooting in CSG models in Section 3. <p> As Requicha reviews <ref> [46] </ref>, it is easy to classify a point p in this way in O (n) time. One begins by determining for each primitive region P whether p is inside or outside of P , which can be done in O (n) time. <p> Formally, these operations are defined so that the result of applying an operation to two objects is the closure of the result of applying that operation to the interiors of the two objects. Such operations are said to be regularized <ref> [26, 28, 34, 38, 46, 48] </ref>. Degeneracies cannot be resolved using an infinitesimal perturbation scheme, since such a perturbation could create spurious portions of the CSG object.
Reference: [47] <author> A. A. G. Requicha and H. B. Voelcker, </author> <title> "Boolean operations in solid modelling: boundary evaluation and merging algorithms," </title> <journal> Proc. of the IEEE, </journal> <volume> 73(1), </volume> <year> 1985. </year>
Reference-contexts: Our method can be implemented using simple operations, such as sorting and table look-ups, and does not require any sophisticated data structures. Moreover, one can apply many of the previous heuristic techniques for speeding up CSG ray shooting to our methods, such as "bounding boxes" <ref> [28, 29, 47, 49, 50, 51] </ref> and face cutting [37], although none of these heuristics would improve the worst case running time. As an aid to practitioners, we also enumerate some additional heuristics that one can apply to make our method run faster in practice. <p> Since classification of lines and other geometric objects (such as the CSG model's boundary) is such a fundamental problem, a considerable amount of work (e.g., see <ref> [24, 28, 29, 37, 41, 47, 48, 49, 54] </ref>) has been directed at methods for improving these running times. <p> The main idea is to restrict comparisons to primitives that are geometrically "near" the object being classified <ref> [28, 29, 47, 49, 50, 51] </ref>. <p> Our tree-contraction method does not have any of these negative side effects. The reader interested in more information on constructive solid geometry is referred to <ref> [26, 34, 38, 46, 47, 48] </ref> for some excellent discussions of this representation and related issues. In the next section we give our method for restructuring the CSG tree T and we show how we can use this restructured tree to speed-up ray shooting in CSG models in Section 3.
Reference: [48] <author> J. R. Rossignac and H. B. Voelcker, </author> <title> "Active zones in constructive solid geometry for redundancy and interference detection," </title> <type> Report RC 11991 (#53914), Auto. </type> <institution> Res. Sci., IBM T. J. Watson Res. Center, </institution> <address> Yorktown Heights, NY, </address> <year> 1986. </year>
Reference-contexts: Perhaps the most important such computation is line classification [55, 56]: determining the intersections of a line with an object defined by a CSG representation, for it is the primitive computation used in many CSG rendering algorithms <ref> [26, 28, 34, 38, 46, 48] </ref>. 2 1.1 Our Results In this paper we show how to convert any CSG tree T into a functionally-equivalent balanced tree D of roughly the same size as T , and we show how this leads to a method for line classification in a CSG <p> Since classification of lines and other geometric objects (such as the CSG model's boundary) is such a fundamental problem, a considerable amount of work (e.g., see <ref> [24, 28, 29, 37, 41, 47, 48, 49, 54] </ref>) has been directed at methods for improving these running times. <p> So, in order to be practical, this approach must be combined with some kind of a "tree-pruning" heuristic based on partially evaluating T while restructuring it (say using bounding boxes) [29]. Rossignac and Voelcker <ref> [48] </ref> show how to further exploit the structural locality in T by using a notion they call the active zone of a primitive p, which, intuitively, is the portion of the CSG solid that is affected by p. <p> Our tree-contraction method does not have any of these negative side effects. The reader interested in more information on constructive solid geometry is referred to <ref> [26, 34, 38, 46, 47, 48] </ref> for some excellent discussions of this representation and related issues. In the next section we give our method for restructuring the CSG tree T and we show how we can use this restructured tree to speed-up ray shooting in CSG models in Section 3. <p> Formally, these operations are defined so that the result of applying an operation to two objects is the closure of the result of applying that operation to the interiors of the two objects. Such operations are said to be regularized <ref> [26, 28, 34, 38, 46, 48] </ref>. Degeneracies cannot be resolved using an infinitesimal perturbation scheme, since such a perturbation could create spurious portions of the CSG object. <p> We have mentioned some possible heuristics in this paper, but there are probably many more, especially if one were to examine the algebraic structure of the dwarf CSG more closely (as Rossignac and Voelcker <ref> [48] </ref> do for the standard CSG tree). Finally, our methods assume one is interested in performing classification tasks against a static CSG tree representation.
Reference: [49] <author> S. D. Roth, </author> <title> "Ray casting for modeling solids," </title> <journal> Computer Graphics and Image Processing, </journal> <volume> 18, </volume> <pages> 109-144, </pages> <year> 1982. </year>
Reference-contexts: Our method can be implemented using simple operations, such as sorting and table look-ups, and does not require any sophisticated data structures. Moreover, one can apply many of the previous heuristic techniques for speeding up CSG ray shooting to our methods, such as "bounding boxes" <ref> [28, 29, 47, 49, 50, 51] </ref> and face cutting [37], although none of these heuristics would improve the worst case running time. As an aid to practitioners, we also enumerate some additional heuristics that one can apply to make our method run faster in practice. <p> Since classification of lines and other geometric objects (such as the CSG model's boundary) is such a fundamental problem, a considerable amount of work (e.g., see <ref> [24, 28, 29, 37, 41, 47, 48, 49, 54] </ref>) has been directed at methods for improving these running times. <p> The main idea is to restrict comparisons to primitives that are geometrically "near" the object being classified <ref> [28, 29, 47, 49, 50, 51] </ref>. <p> As always, we let n denote the total number of primitive edges, and let m denote the number of polygonal primitives. Our method is based on the approach of Roth <ref> [49] </ref> of "walking" down L, and is as follows. Step 1. We begin our algorithm by using the method of the previous section to construct a dwarf CSG tree D for T , where we interpret T as a boolean tree using the natural operation transformations mentioned in Section 2.1.
Reference: [50] <author> H. Samet, </author> <title> Applications of Spatial Data Structures, </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Our method can be implemented using simple operations, such as sorting and table look-ups, and does not require any sophisticated data structures. Moreover, one can apply many of the previous heuristic techniques for speeding up CSG ray shooting to our methods, such as "bounding boxes" <ref> [28, 29, 47, 49, 50, 51] </ref> and face cutting [37], although none of these heuristics would improve the worst case running time. As an aid to practitioners, we also enumerate some additional heuristics that one can apply to make our method run faster in practice. <p> The main idea is to restrict comparisons to primitives that are geometrically "near" the object being classified <ref> [28, 29, 47, 49, 50, 51] </ref>. <p> The second heuristic one can apply is the well-known bounding box or octree heuristics (see <ref> [50, 51] </ref>) to avoid computing intersections between L and faces that are "far away" from L. This does not improve the worst-case performance of the method, but should improve the running time in practice.
Reference: [51] <author> H. Samet, </author> <title> The Design and Analysis of Spatial Data Structures, </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Our method can be implemented using simple operations, such as sorting and table look-ups, and does not require any sophisticated data structures. Moreover, one can apply many of the previous heuristic techniques for speeding up CSG ray shooting to our methods, such as "bounding boxes" <ref> [28, 29, 47, 49, 50, 51] </ref> and face cutting [37], although none of these heuristics would improve the worst case running time. As an aid to practitioners, we also enumerate some additional heuristics that one can apply to make our method run faster in practice. <p> The main idea is to restrict comparisons to primitives that are geometrically "near" the object being classified <ref> [28, 29, 47, 49, 50, 51] </ref>. <p> The second heuristic one can apply is the well-known bounding box or octree heuristics (see <ref> [50, 51] </ref>) to avoid computing intersections between L and faces that are "far away" from L. This does not improve the worst-case performance of the method, but should improve the running time in practice.
Reference: [52] <author> O. Schwarzkopf, </author> <title> "Ray shooting in convex polytopes," </title> <booktitle> in Proc. 8th Annu. ACM Sympos. Com-put. Geom., </booktitle> <pages> 286-295, </pages> <year> 1992. </year>
Reference-contexts: A good example of such work is the recent work of a number of researchers, including Dobkin and Kirkpatrick [18, 20, 19] and others <ref> [2, 4, 8, 10, 11, 15, 30, 32, 33, 43, 52] </ref> directed at maintaining a collection of objects in &lt; d so as to quickly answer ray shooting queries.
Reference: [53] <author> J. M. Steele and A. C. Yao, </author> <title> "Lower bounds for algebraic decision trees," </title> <journal> J. Algorithms, </journal> <volume> 3, </volume> <pages> 1-8, </pages> <year> 1982. </year>
Reference-contexts: Proof: We have already established the upper bound. The lower bound is established by a simple reduction from the set disjointness problem, which has (n log n)-time lower bound in the algebraic computation tree model <ref> [6, 53] </ref>. We leave the details to the reader. 2 3.2 Extending Our Method to 3-Dimensional Line Classification If we take a closer look at our method it is easy to see how to extend this approach to higher dimensional line classification.
Reference: [54] <author> M. S. Tawfik, </author> <title> "An efficient algorithm for CSG to B-Rep conversion," </title> <booktitle> in ACM SIGGRAPH Symp. on Solid Modeling Foundations and CAD/CAM Applications, </booktitle> <address> Austin, TX., </address> <year> 1991. </year>
Reference-contexts: Since classification of lines and other geometric objects (such as the CSG model's boundary) is such a fundamental problem, a considerable amount of work (e.g., see <ref> [24, 28, 29, 37, 41, 47, 48, 49, 54] </ref>) has been directed at methods for improving these running times. <p> Examples include the 2-D boundary evaluation methods of Ottmann et al. [41], which runs in O ((n + I)(m + log n)) time, and Tawfik <ref> [54] </ref>, which runs in O (n log n + I) time. <p> As for the sequential complexity, the best known method is that of Tawfik <ref> [54] </ref>, which runs in O (n 2 ) time in the worst case.
Reference: [55] <author> R. B. Tilove, </author> <title> "Set membership classification: a unified approach to geometric intersection problems," </title> <journal> IEEE Trans. Comput., </journal> <volume> C-29, </volume> <pages> 874-883, </pages> <year> 1980. </year>
Reference-contexts: Indeed, there are a number of fundamental computations involving CSG representations that benefit from being given a balanced tree. Perhaps the most important such computation is line classification <ref> [55, 56] </ref>: determining the intersections of a line with an object defined by a CSG representation, for it is the primitive computation used in many CSG rendering algorithms [26, 28, 34, 38, 46, 48]. 2 1.1 Our Results In this paper we show how to convert any CSG tree T into <p> balanced tree D of roughly the same size as T , and we show how this leads to a method for line classification in a CSG model that runs in O (n log n) time, which is optimal and improves the previous O (n 2 ) bound, due to Tilove <ref> [55, 56] </ref> and Getto [28], where n is the total number of edges that determine all the primitives stored at the leaves of T . Our method can be implemented using simple operations, such as sorting and table look-ups, and does not require any sophisticated data structures. <p> The specific problem of classifying a line against a CSG model was first studied by Tilove <ref> [55, 56] </ref>, who gave a method from which one can derive an O (n 2 )-time method. This bound was achieved explicitly more recently by Getto [28], who also gave some heuristics that should help this classification algorithm run faster in practice. <p> Our method works for both 2- and 3-dimensional objects, and runs in O (n log n) time, improving the previous methods, due to Tilove <ref> [55, 56] </ref> and Getto [28], by almost a linear factor. We describe our method assuming a 2-dimensional representation, and then show how to extend it to 3-dimensions.
Reference: [56] <author> R. B. Tilove, </author> <title> "A null-object detection algorithm for constructive solid geometry," </title> <journal> Commun. ACM, </journal> <volume> 27, </volume> <pages> 684-694, </pages> <year> 1984. </year>
Reference-contexts: Indeed, there are a number of fundamental computations involving CSG representations that benefit from being given a balanced tree. Perhaps the most important such computation is line classification <ref> [55, 56] </ref>: determining the intersections of a line with an object defined by a CSG representation, for it is the primitive computation used in many CSG rendering algorithms [26, 28, 34, 38, 46, 48]. 2 1.1 Our Results In this paper we show how to convert any CSG tree T into <p> balanced tree D of roughly the same size as T , and we show how this leads to a method for line classification in a CSG model that runs in O (n log n) time, which is optimal and improves the previous O (n 2 ) bound, due to Tilove <ref> [55, 56] </ref> and Getto [28], where n is the total number of edges that determine all the primitives stored at the leaves of T . Our method can be implemented using simple operations, such as sorting and table look-ups, and does not require any sophisticated data structures. <p> The specific problem of classifying a line against a CSG model was first studied by Tilove <ref> [55, 56] </ref>, who gave a method from which one can derive an O (n 2 )-time method. This bound was achieved explicitly more recently by Getto [28], who also gave some heuristics that should help this classification algorithm run faster in practice. <p> Our method works for both 2- and 3-dimensional objects, and runs in O (n log n) time, improving the previous methods, due to Tilove <ref> [55, 56] </ref> and Getto [28], by almost a linear factor. We describe our method assuming a 2-dimensional representation, and then show how to extend it to 3-dimensions.
Reference: [57] <author> S. Toledo, </author> <title> "Extremal point containment problems," </title> <booktitle> in Proc. 7th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> 176-185, </pages> <year> 1991. </year>
Reference-contexts: Incidentally, variants of Megiddo's technique have proven very effective of late at improving the running times of several geometric optimization problems. Some examples include the ray shooting method of Agarwal and Matousek [4], the "biggest stick" method of Agarwal, Sharir, and Toledo [5], the "largest polygon" algorithm of Toledo <ref> [57] </ref>, the ham-sandwich cut algorithm of Cole [13], the distance-selection method of Agarwal et al. [3], and the closest-pair algorithms of Chazelle et al. [9].
Reference: [58] <author> F. F. Yao, </author> <title> "Computational geometry," in Algorithms in Complexity, </title> <editor> R. A. Earnshaw and B. Wyvel, editors, </editor> <publisher> Elsevier, Amsterdam, </publisher> <pages> 345-490, </pages> <year> 1990. </year>
Reference-contexts: This area has become a very rich research area of late, and the reader interested in an overview of this previous work is referred to the excellent papers by Dobkin [16] and Yao <ref> [58] </ref>.
Reference: [59] <author> C. K. Yap, </author> <title> "A geometric consistency theorem for a symbolic perturbation scheme," </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 40, </volume> <pages> 2-18, </pages> <year> 1990. </year> <month> 22 </month>
Reference-contexts: For example, it is quite common for different primitives to share vertices, edges, and/or faces. Powerful and general computational geometry techniques, such as the simulation of simplicity technique of Edelsbrunner and 17 Mucke [23] and the symbolic perturbation technique of Yap <ref> [59] </ref>, have been developed for de-signing computational geometry algorithms assuming there are no degeneracies. Intuitively, these methods apply an "infinitesimal" perturbation to the input so that all the objects are put into general position. Thus, the algorithm designer applying one of these techniques need not worry about degeneracies at all. <p> If the objects are not in general position, then we must modify our algorithms slightly to take this into consideration. Fortunately, it is fairly easy to make Steps 2 and 3 robust using infinitesimal perturbation <ref> [23, 59] </ref>, since they deal with the computation of the ordered intersections along the line L.
References-found: 59

