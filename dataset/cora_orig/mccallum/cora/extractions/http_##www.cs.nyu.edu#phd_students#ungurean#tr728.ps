URL: http://www.cs.nyu.edu/phd_students/ungurean/tr728.ps
Refering-URL: http://www.cs.nyu.edu/phd_students/ungurean/index.html
Root-URL: http://www.cs.nyu.edu
Email: email: fungurean,goldbergg@cs.nyu.edu  
Title: Formal Models of Distributed Memory Management prove correct in a compact manner two garbage collectors;
Author: Cristian Ungureanu and Benjamin Goldberg 
Note: This model allows us to specify and  
Address: New York University  
Affiliation: Department of Computer Science  
Abstract: We develop an abstract model of memory management in distributed systems. The model is low-level enough so that we can express communication, allocation and garbage collection, but otherwise hides many of the lower-level details of an actual implementation. Recently, such formal models have been developed for memory management in a functional, sequential setting [8]. The models are rewriting systems whose terms are programs. Programs have both the "code" (control string) and the "store" syntactically apparent. Evaluation is expressed as conditional rewriting and includes store operations. Garbage collection becomes a rewriting relation that removes part of the store without affecting the behavior of the program. Distribution adds another dimension to an already complex problem. By using techniques developed for communicating and concurrent systems [7], we extend their work to a distributed environment. Sending and receiving messages is also made apparent at the syntactic level. A very general garbage collection rule based on reachability is introduced and proved correct. Now proving correct a specific collection strategy is reduced to showing that the relation between programs defined by the strategy is a subrelation of the general relation. Any actual implementation which is capable of providing the transitions (including their atomicity constraints) specified by the strategy is therefore correct. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ben-Ari. </author> <title> Algorithms for on-the-fly garbage collection. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6, </volume> <year> 1984. </year>
Reference-contexts: This property was previously reported [5], but its proof was less formal. 15 Among other papers giving proofs of correctness of garbage collection are the following. Dijkstra [3] presents an algorithm for a garbage collector running in parallel with the mutator, and proves it correct; Ben-Ari <ref> [1] </ref> improves on the algorithm and simplifies the proof. Shapiro [10] proves correct in an informal way a protocol for garbage collection in a fault-tolerant, distributed object-oriented system. The communication model in our language is based on Milner's CCS [6].
Reference: [2] <author> Gerard Boudol. </author> <title> Towards a lambda-calculus for concurrent and communicating systems. </title> <publisher> TAP-SOFT'89 LNCS 351, </publisher> <pages> pages 149-161, </pages> <year> 1989. </year>
Reference-contexts: The communication model in our language is based on Milner's CCS [6]. A full description of CCS and its proof methods is [7]. Our calculus also has some similarities with the fl-calculus proposed by Boudol in <ref> [2] </ref>: his t -actions, on which the evaluation of the language is based, corresponds to our unobservable transitions.
Reference: [3] <author> Edsger Dijkstra, Leslie Lamport, A.J. Martin, C.S. Scholten, and E.F.M. Steffens. </author> <title> On-the-fly garbage collection: An exercise in cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <year> 1978. </year>
Reference-contexts: This property was previously reported [5], but its proof was less formal. 15 Among other papers giving proofs of correctness of garbage collection are the following. Dijkstra <ref> [3] </ref> presents an algorithm for a garbage collector running in parallel with the mutator, and proves it correct; Ben-Ari [1] improves on the algorithm and simplifies the proof. Shapiro [10] proves correct in an informal way a protocol for garbage collection in a fault-tolerant, distributed object-oriented system. <p> Also, the garbage collection may be allowed to proceed in parallel with the computation even on the same node (as described in <ref> [3] </ref>). This can be achieved by raising the scan relation to a transition in the language, together with a way of synchronizing the mutator with the collector. However, the more refined the models are, the more complicated the proofs become.
Reference: [4] <author> Matthias Felleisen and Robert Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 102, </volume> <year> 1992. </year> <month> 16 </month>
Reference-contexts: In this paper, we are presenting such a model. Starting from the v -S calculus of Felleisen and Hieb <ref> [4] </ref>, and from Milner's CCS [7], we introduce a language, k , which roughly corresponds to a distributed, impure functional language. In Section 2, we present the language k with a rewriting semantics that makes allocation and communication explicit. <p> Following <ref> [4] </ref>, reachability is modeled by considering the free variables. If a heap binding is reachable, and the value bound contains free variables, the bindings of these variables are reachable. <p> It is only these lower-level implementations that would make a sharper distinction between the local and remote communication relations in their proofs. 5 Related Work Starting from the v calculus developed by Plotkin in [9], Felleisen and Hieb <ref> [4] </ref> extend it to a calculus, called v -S, suitable for reasoning about state and control in programming languages. This provides the theoretical background of the development of a syntactic theory of memory management in [8]. While in [4] an important effort is made in their model to avoid the garbage <p> from the v calculus developed by Plotkin in [9], Felleisen and Hieb <ref> [4] </ref> extend it to a calculus, called v -S, suitable for reasoning about state and control in programming languages. This provides the theoretical background of the development of a syntactic theory of memory management in [8]. While in [4] an important effort is made in their model to avoid the garbage generated during computation, in order to obtain a "clean" equational reasoning, in [8] the main topic is exactly that garbage.
Reference: [5] <author> Benjamin Goldberg and Michael Gloger. </author> <title> Polymorphic type reconstruction for garbage collection without tags. </title> <booktitle> Symposium on LISP and Functional Programming, </booktitle> <year> 1992. </year>
Reference-contexts: Using the model developed for a typed language with polymorphism, they were able to prove formally that some reachable data is garbage (it will never be accessed). This property was previously reported <ref> [5] </ref>, but its proof was less formal. 15 Among other papers giving proofs of correctness of garbage collection are the following. Dijkstra [3] presents an algorithm for a garbage collector running in parallel with the mutator, and proves it correct; Ben-Ari [1] improves on the algorithm and simplifies the proof.
Reference: [6] <author> R. Milner. </author> <title> A calculus for communicating systems. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 92, </volume> <year> 1980. </year>
Reference-contexts: Shapiro [10] proves correct in an informal way a protocol for garbage collection in a fault-tolerant, distributed object-oriented system. The communication model in our language is based on Milner's CCS <ref> [6] </ref>. A full description of CCS and its proof methods is [7]. Our calculus also has some similarities with the fl-calculus proposed by Boudol in [2]: his t -actions, on which the evaluation of the language is based, corresponds to our unobservable transitions.
Reference: [7] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: In this paper, we are presenting such a model. Starting from the v -S calculus of Felleisen and Hieb [4], and from Milner's CCS <ref> [7] </ref>, we introduce a language, k , which roughly corresponds to a distributed, impure functional language. In Section 2, we present the language k with a rewriting semantics that makes allocation and communication explicit. The semantics defined allows us to use many of the proof techniques developed for CCS. <p> A rule without hypotheses is called an axiom. The other rules are called inference rules. This mode of defining the relations will allow us to prove transition invariants by induction on the length of the proof that the transition is possible. This proof method is called transition induction <ref> [7] </ref>. With the exception of rule Comm r the left term of the pair is a process (thread-heap pair). The transitions that a process can perform are all determined by the thread expression of that process (by the thread combinators). <p> Shapiro [10] proves correct in an informal way a protocol for garbage collection in a fault-tolerant, distributed object-oriented system. The communication model in our language is based on Milner's CCS [6]. A full description of CCS and its proof methods is <ref> [7] </ref>. Our calculus also has some similarities with the fl-calculus proposed by Boudol in [2]: his t -actions, on which the evaluation of the language is based, corresponds to our unobservable transitions.
Reference: [8] <author> Greg Morrisett, Matthias Felleisen, and Robert Harper. </author> <title> Abstract models of memory management. </title> <booktitle> In Functional Programming Languages and Computer Architectures, </booktitle> <year> 1995. </year>
Reference-contexts: This expression reduction is intended to define a left-to-right call-by-value evaluation order. The expression is decomposed into an evaluation context and an instruction. The decomposition is guaranteed to be unique <ref> [8] </ref>, and is obtained by scanning the expression from left to right and taking as the instruction the first redex encountered. The context is the expression with a hole replacing the redex. <p> Note that the relation leaves open the possibility of a garbage collection algorithm to replace the value a variable is bound to with something else (the integer zero, for example), as long as the programs remain bisimilar. (This corresponds to replacing a pointer with NULL.) This is done in <ref> [8] </ref> to reclaim space occupied by objects which, although reachable, would never be accessed by the program. 3.1 Free variable rule The garbage collection algorithms we are going to define are all based on tracing: all the reachable bindings are preserved. <p> This provides the theoretical background of the development of a syntactic theory of memory management in <ref> [8] </ref>. While in [4] an important effort is made in their model to avoid the garbage generated during computation, in order to obtain a "clean" equational reasoning, in [8] the main topic is exactly that garbage. <p> This provides the theoretical background of the development of a syntactic theory of memory management in <ref> [8] </ref>. While in [4] an important effort is made in their model to avoid the garbage generated during computation, in order to obtain a "clean" equational reasoning, in [8] the main topic is exactly that garbage. Using the model developed for a typed language with polymorphism, they were able to prove formally that some reachable data is garbage (it will never be accessed).
Reference: [9] <author> Gordon Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: It is only these lower-level implementations that would make a sharper distinction between the local and remote communication relations in their proofs. 5 Related Work Starting from the v calculus developed by Plotkin in <ref> [9] </ref>, Felleisen and Hieb [4] extend it to a calculus, called v -S, suitable for reasoning about state and control in programming languages. This provides the theoretical background of the development of a syntactic theory of memory management in [8].
Reference: [10] <author> Mark Shapiro, David Plainfosse, and Olivier Gruber. </author> <title> A garbage detection protocol for a realistic distributed object-support system. </title> <type> Technical Report 1320, </type> <institution> INRIA, </institution> <year> 1990. </year> <month> 17 </month>
Reference-contexts: Each local GC cleans the exit table of useless entries. In turn, exit tables are used to clean remote entry tables, yielding successively better estimates. More details about this method can be found in <ref> [10] </ref> It is important to note that these steps can be described in our framework (the domain of the transition relations can be augmented with sets for these tables). However, including them would have made the presentation much less clear. Theorem 3 establishes the correctness of the algorithm. <p> Dijkstra [3] presents an algorithm for a garbage collector running in parallel with the mutator, and proves it correct; Ben-Ari [1] improves on the algorithm and simplifies the proof. Shapiro <ref> [10] </ref> proves correct in an informal way a protocol for garbage collection in a fault-tolerant, distributed object-oriented system. The communication model in our language is based on Milner's CCS [6]. A full description of CCS and its proof methods is [7].
References-found: 10

