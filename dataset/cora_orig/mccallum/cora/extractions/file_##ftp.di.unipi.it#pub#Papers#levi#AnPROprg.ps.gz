URL: file://ftp.di.unipi.it/pub/Papers/levi/AnPROprg.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: levi@di.unipi.it  
Title: Analysis of pure PROLOG programs abstraction of the elements of the sequence, where both upper
Author: Giorgio Levi Daniele Micciancio 
Note: an  
Address: Corso Italia 40, 56125 Pisa, Italy  
Affiliation: Dipartimento di Informatica, Universita di Pisa,  
Abstract: We define a new fixpoint semantics for pure PROLOG, which is obtained as an instance of the generalized semantics of CLP and is oriented towards abstract interpretation. The semantic domain is composed of sequences of standard and divergent constraints. The semantics is then used as the foundation of a framework for the (bottom-up, goal-independent) abstract interpretation of pure PROLOG programs. The abstraction is obtained by combining two independent abstraction mechanisms: We discuss the conditions under which the second abstraction is not needed.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt, E. Marchiori, and C. Palamidessi. </author> <title> A theory of first-order built-in's of PROLOG. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Algebraic and Logic Programming, Proceedings of the Third International Conference, volume 632 of Lecture Notes in Computer Science, </booktitle> <pages> pages 69-83. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Lower approximations and the information our semantics has about termination make it feasible the extension to cut, negation as failure and setof. First order built-in's might be modeled as suggested in <ref> [1] </ref>.
Reference: [2] <author> R. Barbuti, M. Codish, R. Giacobazzi, and G. Levi. </author> <title> Modelling Prolog Control. </title> <booktitle> In Proc. Nineteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 95-104. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: The main problem to be solved in order to extend the generalized semantics approach to pure PROLOG programs is the definition of a semantics of pure PROLOG in the s-semantics style. There are three candidate proposals: * the modeling control semantics <ref> [2, 3] </ref>, where a pure PROLOG program is transformed into an ask-tell constraint program, with the ask constraints expressing the termination properties. * the oracle semantics in [4], which is parametric w.r.t. an oracle which embodies the control strategy (and the oracle can be specialized to the PROLOG case). * the <p> The semantics is given according to the s-semantics style and is oriented towards abstract interpretation. The construction of abstract interpretations in the style of those developed for logic programs was indeed the aim of several other semantics for pure PROLOG <ref> [2, 4, 6] </ref>. However none of those semantics was shown to be actually usable for abstract interpretation. Our bottom-up definition is essentially a reconstruction of the semantics in [6], obtained by instantiating an adaptation of the generalized semantics scheme [26, 27].
Reference: [3] <author> R. Barbuti, M. Codish, R. Giacobazzi, and G. Levi. </author> <title> Modelling Prolog Control. </title> <journal> Journal of Logic and Computation, </journal> <volume> 3 </volume> <pages> 579-603, </pages> <year> 1993. </year>
Reference-contexts: The main problem to be solved in order to extend the generalized semantics approach to pure PROLOG programs is the definition of a semantics of pure PROLOG in the s-semantics style. There are three candidate proposals: * the modeling control semantics <ref> [2, 3] </ref>, where a pure PROLOG program is transformed into an ask-tell constraint program, with the ask constraints expressing the termination properties. * the oracle semantics in [4], which is parametric w.r.t. an oracle which embodies the control strategy (and the oracle can be specialized to the PROLOG case). * the
Reference: [4] <author> R. Barbuti, M. Codish, R. Giacobazzi, and M. Maher. </author> <title> Oracle Semantics for PROLOG. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Algebraic and Logic Programming, Proceedings of the Third International Conference, volume 632 of Lecture Notes in Computer Science, </booktitle> <pages> pages 100-114. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: There are three candidate proposals: * the modeling control semantics [2, 3], where a pure PROLOG program is transformed into an ask-tell constraint program, with the ask constraints expressing the termination properties. * the oracle semantics in <ref> [4] </ref>, which is parametric w.r.t. an oracle which embodies the control strategy (and the oracle can be specialized to the PROLOG case). * the fixpoint semantics in [6], which is simpler and closer to the s semantics and provides a direct modeling of the PROLOG control. <p> The semantics is given according to the s-semantics style and is oriented towards abstract interpretation. The construction of abstract interpretations in the style of those developed for logic programs was indeed the aim of several other semantics for pure PROLOG <ref> [2, 4, 6] </ref>. However none of those semantics was shown to be actually usable for abstract interpretation. Our bottom-up definition is essentially a reconstruction of the semantics in [6], obtained by instantiating an adaptation of the generalized semantics scheme [26, 27].
Reference: [5] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 133-181, </pages> <year> 1993. </year>
Reference-contexts: The second contribution of the paper is the definition of a framework for the abstract interpretation of pure PROLOG programs, based on the above semantics. This is the first example of such a framework based on a bottom-up semantics, in the style of similar frameworks developed for logic programs <ref> [28, 5, 9] </ref>. We have shown that the approximation of the semantics of pure PROLOG programs can essentially be based on domains developed for the analysis of logic programs. However we are confronted with two new problems, i.e. lower approximations and sequences approximation.
Reference: [6] <author> A. Bossi, M. Bugliesi, and M. Fabris. </author> <title> Fixpoint semantics for PROLOG. </title> <editor> In D. S. Warren, editor, </editor> <booktitle> Proc. Tenth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 374-389. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: pure PROLOG program is transformed into an ask-tell constraint program, with the ask constraints expressing the termination properties. * the oracle semantics in [4], which is parametric w.r.t. an oracle which embodies the control strategy (and the oracle can be specialized to the PROLOG case). * the fixpoint semantics in <ref> [6] </ref>, which is simpler and closer to the s semantics and provides a direct modeling of the PROLOG control. <p> Concepts similar to the one of divergent atom have also been considered in some semantics for logic programs with the aim of modeling termination [31] and finite success [18]. The first step in <ref> [6] </ref> is the definition of an extended base B E = f b A j A 2 Bg [ B, where B is the set of non-ground atoms built on the program 3 signature modulo variance. Interpretations are sets of sequences of atoms from B E . <p> The PROLOG answer substitutions of a goal G are proved to be exactly those substitutions which are reachable for G in a sequence belonging to the program denotation. The main problem with the semantics in <ref> [6] </ref> is related to the structure of interpretations, which are (redundant) sets of sequences rather than just sequences. This problem is correctly identified in [6], which suggests a possible solution, which seems to be related to the representation of infinite sequences. <p> The main problem with the semantics in <ref> [6] </ref> is related to the structure of interpretations, which are (redundant) sets of sequences rather than just sequences. This problem is correctly identified in [6], which suggests a possible solution, which seems to be related to the representation of infinite sequences. Our solution is a different one, namely the definition of a better partial order relation on sequences. <p> This allows us to solve by a single technical tool two apparently unrelated problems, namely the simplification of 4 the structure of the interpretations and the extension of the construction to abstract denotations. Another minor problem in <ref> [6] </ref> is the use of the interpretation P ] in the definition of P . In our definition, we will achieve the same result, by simply applying the immediate consequences operator to the least element of our interpretation domain. The last difference between our construction and the one in [6] is <p> in <ref> [6] </ref> is the use of the interpretation P ] in the definition of P . In our definition, we will achieve the same result, by simply applying the immediate consequences operator to the least element of our interpretation domain. The last difference between our construction and the one in [6] is related to the correctness proof. The proof in [6] is rather complex and is based on a dominance relation between the frontiers and the cuts of the SLD-tree. <p> In our definition, we will achieve the same result, by simply applying the immediate consequences operator to the least element of our interpretation domain. The last difference between our construction and the one in <ref> [6] </ref> is related to the correctness proof. The proof in [6] is rather complex and is based on a dominance relation between the frontiers and the cuts of the SLD-tree. Our proof is simply based on an unfolding operator which generates sequences of trees whose frontiers are exactly those generated by our version of P . <p> Our proof is simply based on an unfolding operator which generates sequences of trees whose frontiers are exactly those generated by our version of P . Let us finally note that both the semantics in <ref> [6] </ref> and our semantics are defined only in a bottom-up way. 3 The bottom-up construction of the generalized semantics The (concrete and abstract) semantics of pure PROLOG will be obtained by instantiating on a suitable constraint system a generalized semantics for Constraint Logic Programs. <p> We have shown that this result is still valid if we consider finite constraints only. 9 4 The new bottom-up semantics As already noted in Section 2, most of the problems in the fixpoint semantics of pure PROLOG <ref> [6] </ref> can be solved by defining a suitable partial order on the semantic objects. If logic programs are represented as CLP programs, the solution is simpler, since the partial order can be defined on constraints rather than on interpretations. <p> The (fixpoint) semantics is just an instance of the generalized semantics and we do not need any ad hoc new fixpoint definition. Moreover, the resulting semantics solves some of the problems of the semantics in <ref> [6] </ref>. The following Proposition states that our semantics does indeed model pure PROLOG answers. <p> The semantics is given according to the s-semantics style and is oriented towards abstract interpretation. The construction of abstract interpretations in the style of those developed for logic programs was indeed the aim of several other semantics for pure PROLOG <ref> [2, 4, 6] </ref>. However none of those semantics was shown to be actually usable for abstract interpretation. Our bottom-up definition is essentially a reconstruction of the semantics in [6], obtained by instantiating an adaptation of the generalized semantics scheme [26, 27]. <p> However none of those semantics was shown to be actually usable for abstract interpretation. Our bottom-up definition is essentially a reconstruction of the semantics in <ref> [6] </ref>, obtained by instantiating an adaptation of the generalized semantics scheme [26, 27]. <p> A nice feature is that we don't need to define a new ad hoc fixpoint operator, since we only have to model the control strategy in the constraint system (by means of sequences of standard and divergent constraints). However, the main improvement over the semantics in <ref> [6] </ref> is the definition of a new partial order relation on sequences, which makes the semantics simpler and more adequate to abstraction. The second contribution of the paper is the definition of a framework for the abstract interpretation of pure PROLOG programs, based on the above semantics.
Reference: [7] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. Martelli. </author> <title> The s-semantics approach: </title> <journal> Theory and applications. Journal of Logic Programming, </journal> <note> 1994. to appear. </note>
Reference-contexts: Abstract interpretation can simply be obtained by applying the standard language execution tools to the abstract program. The abstract semantics is just the standard semantics of the abstract program. 1 * Following the s-semantics approach <ref> [20, 24, 21, 7] </ref>, equivalent top--down and bottom-up definitions of the abstract semantics are available, where the abstract semantics is an abstraction of the answer constraints semantics.
Reference: [8] <author> D. Boulanger, M. Bruynooghe, and M. Denecker. </author> <title> Abstracting s-semantics: A model-theoretic approach. </title> <editor> In M. Hermenegildo and J. Penjam, editors, </editor> <booktitle> Programming Language Implementation and Logic Programming, Proc. PLILP'94, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year> <month> 34 </month>
Reference-contexts: Several interesting domains useful for type, groundness, aliasing and independence analysis can easily be formalized as constraint systems. The technique can be combined with an elegant model-theoretic approach to the abstraction of the constraint system <ref> [8] </ref>. Moreover, the approach can be specialized to the case of pure logic programs, by providing the PROLOG implementation of the abstract constraint systems, as done in [11, 12]. The approach was also extended to the case of concurrent constraint programs [32].
Reference: [9] <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Bottom-up Abstract Interpreta--tion of Logic Programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 124(1) </volume> <pages> 93-125, </pages> <year> 1994. </year>
Reference-contexts: The second contribution of the paper is the definition of a framework for the abstract interpretation of pure PROLOG programs, based on the above semantics. This is the first example of such a framework based on a bottom-up semantics, in the style of similar frameworks developed for logic programs <ref> [28, 5, 9] </ref>. We have shown that the approximation of the semantics of pure PROLOG programs can essentially be based on domains developed for the analysis of logic programs. However we are confronted with two new problems, i.e. lower approximations and sequences approximation.
Reference: [10] <author> M. Codish, S. K. Debray, and R. Giacobazzi. </author> <title> Compositional Analysis of Modular Logic Programs. </title> <booktitle> In Proc. Twentieth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 451-464. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: The second approximation, on the contrary, can widely be developed in constraint and analysis independent way. It is worth noting that problems of sequences approximation were found in areas which are apparently loosely related to the problem of approximating the control. This is the case of the compositional analysis <ref> [25, 10, 23] </ref> and of the analysis of concurrent logic programs [13, 14].
Reference: [11] <author> M. Codish and B. Demoen. </author> <title> Analysing Logic Programs using "prop"- ositional Logic Programs and a Magic Wand. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proc. 1993 Int'l Symposium on Logic Programming, </booktitle> <pages> pages 114-129. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: is goal-independent, while the behavior for a specific goal can be determined from the goal independent analysis by using an AND-compositionality theorem. * The approach can be extended to observables which are more concrete than answer constraints, such as call patterns [16], thus allowing us to reconstruct the analyses in <ref> [11, 22] </ref>. Several interesting domains useful for type, groundness, aliasing and independence analysis can easily be formalized as constraint systems. The technique can be combined with an elegant model-theoretic approach to the abstraction of the constraint system [8]. <p> The technique can be combined with an elegant model-theoretic approach to the abstraction of the constraint system [8]. Moreover, the approach can be specialized to the case of pure logic programs, by providing the PROLOG implementation of the abstract constraint systems, as done in <ref> [11, 12] </ref>. The approach was also extended to the case of concurrent constraint programs [32]. In this paper we extend the approach to pure PROLOG, i.e. to logic programs with the PROLOG computation rule (leftmost selection rule and backtracking).
Reference: [12] <author> M. Codish and B. Demoen. </author> <title> Deriving polymorphic type dependencies for logic programs using multiple incarnations of Prop. </title> <editor> In F. S. de Boer and M. Gabbrielli, editors, </editor> <booktitle> Verification and Analysis of Logic Languages, Proc. of the Post-Conference Workshop ICLP'94, </booktitle> <pages> pages 197-212. </pages> <publisher> Vrije Universiteit, </publisher> <address> Amsterdam, </address> <year> 1994. </year>
Reference-contexts: The technique can be combined with an elegant model-theoretic approach to the abstraction of the constraint system [8]. Moreover, the approach can be specialized to the case of pure logic programs, by providing the PROLOG implementation of the abstract constraint systems, as done in <ref> [11, 12] </ref>. The approach was also extended to the case of concurrent constraint programs [32]. In this paper we extend the approach to pure PROLOG, i.e. to logic programs with the PROLOG computation rule (leftmost selection rule and backtracking).
Reference: [13] <author> M. Codish, M. Falaschi, and K. Marriott. </author> <title> Suspension Analysis for Concurrent Logic Programs. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, pages 331- 345. </booktitle> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1991. </year>
Reference-contexts: It is worth noting that problems of sequences approximation were found in areas which are apparently loosely related to the problem of approximating the control. This is the case of the compositional analysis [25, 10, 23] and of the analysis of concurrent logic programs <ref> [13, 14] </ref>. As we will show in Section 5.3, in several cases the approximation of the simple constraints together with the elimination of multiple constraint occurrences in the sequence, guarantees that the fixpoint is obtained in a 21 finite number of steps.
Reference: [14] <author> M. Codish, M. Falaschi, K. Marriott, and W. Winsborough. </author> <title> Efficient Analysis of Concurrent Constraint Logic Programs. </title> <editor> In A. Lingas, R. Karlsson, and S. Carlsson, editors, </editor> <booktitle> Proc. of the 20th International Colloquium on Automata, Languages, and Programming, volume 700 of Lecture Notes in Computer Science, </booktitle> <pages> pages 633-644, </pages> <year> 1993. </year>
Reference-contexts: It is worth noting that problems of sequences approximation were found in areas which are apparently loosely related to the problem of approximating the control. This is the case of the compositional analysis [25, 10, 23] and of the analysis of concurrent logic programs <ref> [13, 14] </ref>. As we will show in Section 5.3, in several cases the approximation of the simple constraints together with the elimination of multiple constraint occurrences in the sequence, guarantees that the fixpoint is obtained in a 21 finite number of steps.
Reference: [15] <author> P. Codognet and G. </author> <title> File. Computations, Abstractions and Constraints. </title> <booktitle> In Proc. Fourth IEEE Int'l Conference on Computer Languages. </booktitle> <publisher> IEEE Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction An elegant and promising technique for analyzing logic programs is that based on constraints, first introduced in <ref> [15] </ref> and then formalized in terms of the so-called generalized semantics in [26, 27, 25]. The main features of the technique are the following. * The abstraction can simply be performed by abstracting the (concrete) constraint system into an abstract constraint system. <p> Once we have a structure C satisfying the conditions of definition 3.11, we automatically obtain a semantics for the class of programs CLP (C). The abstract interpretation scheme, when applied to CLP, turns out to be expressed in terms of a set of conditions on the constraint systems <ref> [15, 26] </ref>. In order to define an abstract interpretation relation between two semantics, we just need to specify a monotonic function from the concrete constraint system to the abstract constraint system and then prove that the operations of the constraint systems satisfy a correctness condition.
Reference: [16] <author> M. Comini and G. Levi. </author> <title> An algebraic theory of observables. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proc. 1994 Int'l Symposium on Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: The resulting analysis is goal-independent, while the behavior for a specific goal can be determined from the goal independent analysis by using an AND-compositionality theorem. * The approach can be extended to observables which are more concrete than answer constraints, such as call patterns <ref> [16] </ref>, thus allowing us to reconstruct the analyses in [11, 22]. Several interesting domains useful for type, groundness, aliasing and independence analysis can easily be formalized as constraint systems. The technique can be combined with an elegant model-theoretic approach to the abstraction of the constraint system [8]. <p> to obtain the semantics as an instance of the generalized semantics, * a simplification of the semantic domain, achieved by defining a new partial order relation, and * a more elegant correctness proof, obtained by showing that the semantics is an abstraction of an SLD-trees denotation in the style of <ref> [16] </ref>. We will then consider the problem of abstraction in Section 5. Here we are faced with two new problems, which do not show up in the analysis of logic programs, i.e. * the lower approximation of constraints, and * the approximation of constraint sequences. <p> The proof is based on the following steps: * definition of a more concrete denotation, similar to the semantics in <ref> [24, 16] </ref>.
Reference: [17] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. Fourth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: As we will show in the next Section, the control information will completely be handled by the constraint system. For technical reasons, we use a variation of the abstract interpretation scheme in <ref> [17] </ref>. In fact our (concrete and abstract) interpretations are composed of finite elements only. In addition, our generalized semantics will be based on a notion of constraint system, which is simpler than the one originally defined in [26, 27].
Reference: [18] <author> G. Delzanno and M. Martelli. </author> <title> A bottom-up characterization of finite success. </title> <type> Technical report, </type> <institution> Universita di Genova, DISI, </institution> <year> 1992. </year>
Reference-contexts: The only information conveyed by b A is that the corresponding derivation is partial and therefore potentially divergent. Concepts similar to the one of divergent atom have also been considered in some semantics for logic programs with the aim of modeling termination [31] and finite success <ref> [18] </ref>. The first step in [6] is the definition of an extended base B E = f b A j A 2 Bg [ B, where B is the set of non-ground atoms built on the program 3 signature modulo variance.
Reference: [19] <author> M. Falaschi, M. Gabbrielli, K. Marriott, and C. Palamidessi. </author> <title> Compositional Analysis for Concurrent Constraint Programming. </title> <booktitle> In Proceedings of the Eight Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 210-221. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year> <month> 35 </month>
Reference-contexts: Let us finally point out that lower approximations can also be useful to approximate the ask constraints in concurrent constraint programs <ref> [19, 32] </ref>. The second new problem, i.e. the approximation of sequences, was already found in the analysis of modular programs and of concurrent programs. The case of pure PROLOG is probably harder because of the different nature of sequences.
Reference: [20] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: Abstract interpretation can simply be obtained by applying the standard language execution tools to the abstract program. The abstract semantics is just the standard semantics of the abstract program. 1 * Following the s-semantics approach <ref> [20, 24, 21, 7] </ref>, equivalent top--down and bottom-up definitions of the abstract semantics are available, where the abstract semantics is an abstraction of the answer constraints semantics.
Reference: [21] <author> M. Gabbrielli. </author> <title> The Semantics of Logic Programming as a Programming Language. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year>
Reference-contexts: Abstract interpretation can simply be obtained by applying the standard language execution tools to the abstract program. The abstract semantics is just the standard semantics of the abstract program. 1 * Following the s-semantics approach <ref> [20, 24, 21, 7] </ref>, equivalent top--down and bottom-up definitions of the abstract semantics are available, where the abstract semantics is an abstraction of the answer constraints semantics.
Reference: [22] <author> M. Gabbrielli and R. Giacobazzi. </author> <title> Goal independency and call patterns in the analysis of logic programs. </title> <booktitle> In Proc. </booktitle> <address> SAC'94, </address> <year> 1994. </year>
Reference-contexts: is goal-independent, while the behavior for a specific goal can be determined from the goal independent analysis by using an AND-compositionality theorem. * The approach can be extended to observables which are more concrete than answer constraints, such as call patterns [16], thus allowing us to reconstruct the analyses in <ref> [11, 22] </ref>. Several interesting domains useful for type, groundness, aliasing and independence analysis can easily be formalized as constraint systems. The technique can be combined with an elegant model-theoretic approach to the abstraction of the constraint system [8].
Reference: [23] <author> M. Gabbrielli, R. Giacobazzi, and D. Montesi. </author> <title> Modular logic programs over finite domains. </title> <editor> In D. Sacca, editor, </editor> <booktitle> Proc. Eight Italian Conference on Logic Programming, </booktitle> <pages> pages 663-678, </pages> <year> 1993. </year>
Reference-contexts: The second approximation, on the contrary, can widely be developed in constraint and analysis independent way. It is worth noting that problems of sequences approximation were found in areas which are apparently loosely related to the problem of approximating the control. This is the case of the compositional analysis <ref> [25, 10, 23] </ref> and of the analysis of concurrent logic programs [13, 14]. <p> Sufficient conditions for the convergence without se-quences approximation are essentially those developed for the compositional analysis in <ref> [23] </ref>. We will first consider in Section 5.1 the approximation of elementary constraints. We will show that, because of some non-monotonic features of pure PROLOG, simple constraints require a lower approximation in addition to the usual upper approximation. <p> This condition is essentially the same proposed in <ref> [23] </ref> to define compositionally tractable domains, and is satisfied by most abstract constraint systems used in the analysis of logic programs. If we have a finite number of simple constraints on a given finite set of variables, then the sequences of constraints without multiple occurrences are finite. <p> Our solution is not yet completely satisfactory and more study is needed. It is worth noting that the class of analyses, for which this approximation is not needed, is essentially the same that was characterized in <ref> [23] </ref> for the compositional analysis. The above discussion shows that there are several relations between the problems of modeling the (sequential) control of pure PROLOG and the synchronization of concurrent logic languages.
Reference: [24] <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Observational Equivalences for Logic Programs. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. Joint Int'l Conf. and Symposium on Logic Programming, </booktitle> <pages> pages 131-145. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: Abstract interpretation can simply be obtained by applying the standard language execution tools to the abstract program. The abstract semantics is just the standard semantics of the abstract program. 1 * Following the s-semantics approach <ref> [20, 24, 21, 7] </ref>, equivalent top--down and bottom-up definitions of the abstract semantics are available, where the abstract semantics is an abstraction of the answer constraints semantics. <p> The proof is based on the following steps: * definition of a more concrete denotation, similar to the semantics in <ref> [24, 16] </ref>.
Reference: [25] <author> R. Giacobazzi. </author> <title> Semantic Aspects of Logic Program Analysis. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year>
Reference-contexts: 1 Introduction An elegant and promising technique for analyzing logic programs is that based on constraints, first introduced in [15] and then formalized in terms of the so-called generalized semantics in <ref> [26, 27, 25] </ref>. The main features of the technique are the following. * The abstraction can simply be performed by abstracting the (concrete) constraint system into an abstract constraint system. <p> The second approximation, on the contrary, can widely be developed in constraint and analysis independent way. It is worth noting that problems of sequences approximation were found in areas which are apparently loosely related to the problem of approximating the control. This is the case of the compositional analysis <ref> [25, 10, 23] </ref> and of the analysis of concurrent logic programs [13, 14].
Reference: [26] <author> R. Giacobazzi, S. K. Debray, and G. Levi. </author> <title> A Generalized Semantics for Constraint Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 581-591, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction An elegant and promising technique for analyzing logic programs is that based on constraints, first introduced in [15] and then formalized in terms of the so-called generalized semantics in <ref> [26, 27, 25] </ref>. The main features of the technique are the following. * The abstraction can simply be performed by abstracting the (concrete) constraint system into an abstract constraint system. <p> In Section 3 we define our generalized semantics based on constraint systems 2 in the style of <ref> [26, 27] </ref>. <p> In fact our (concrete and abstract) interpretations are composed of finite elements only. In addition, our generalized semantics will be based on a notion of constraint system, which is simpler than the one originally defined in <ref> [26, 27] </ref>. The following Sections define the abstract interpretation scheme and the generalized semantics. 3.1 The abstract interpretation scheme We will show that in order to define a (concrete or abstract) semantics, we can consider the "finite" elements only, since there exists a unique continuous extension to the "limit elements". <p> Note however that any CLP program can be transformed into an equivalent program satisfying the above conditions. The above restriction allows us to get rid of the term systems which are needed in <ref> [26, 27] </ref>. Moreover we will not introduce cylindrification operators and diagonal elements in the constraint system, by assuming that local variables are renamed apart whenever two constraints are composed. The resulting constraint system is the following. <p> Once we have a structure C satisfying the conditions of definition 3.11, we automatically obtain a semantics for the class of programs CLP (C). The abstract interpretation scheme, when applied to CLP, turns out to be expressed in terms of a set of conditions on the constraint systems <ref> [15, 26] </ref>. In order to define an abstract interpretation relation between two semantics, we just need to specify a monotonic function from the concrete constraint system to the abstract constraint system and then prove that the operations of the constraint systems satisfy a correctness condition. <p> The two operators T P and T P a , which are defined on = and = a respectively and are associated to the two programs, satisfy the correctness condition T P ffi ff a ff ffi T P a : As first shown in <ref> [26] </ref>, if we replace the concrete constraints by abstract constraints, we automatically obtain an abstract interpretation. <p> However none of those semantics was shown to be actually usable for abstract interpretation. Our bottom-up definition is essentially a reconstruction of the semantics in [6], obtained by instantiating an adaptation of the generalized semantics scheme <ref> [26, 27] </ref>. A nice feature is that we don't need to define a new ad hoc fixpoint operator, since we only have to model the control strategy in the constraint system (by means of sequences of standard and divergent constraints).
Reference: [27] <author> R. Giacobazzi, G. Levi, and S. K. Debray. </author> <title> Joining Abstract and Concrete Computations in Constraint Logic Programming. </title> <editor> In M. Nivat, C. Rattray, T. Rus, and G. Scollo, editors, </editor> <booktitle> Algebraic Methodology and Software Technology (AMAST'93), Proceedings of the Third International Conference on Algebraic Methodology and Software Technology, Workshops in Computing, </booktitle> <pages> pages 111-127. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction An elegant and promising technique for analyzing logic programs is that based on constraints, first introduced in [15] and then formalized in terms of the so-called generalized semantics in <ref> [26, 27, 25] </ref>. The main features of the technique are the following. * The abstraction can simply be performed by abstracting the (concrete) constraint system into an abstract constraint system. <p> In Section 3 we define our generalized semantics based on constraint systems 2 in the style of <ref> [26, 27] </ref>. <p> In fact our (concrete and abstract) interpretations are composed of finite elements only. In addition, our generalized semantics will be based on a notion of constraint system, which is simpler than the one originally defined in <ref> [26, 27] </ref>. The following Sections define the abstract interpretation scheme and the generalized semantics. 3.1 The abstract interpretation scheme We will show that in order to define a (concrete or abstract) semantics, we can consider the "finite" elements only, since there exists a unique continuous extension to the "limit elements". <p> Note however that any CLP program can be transformed into an equivalent program satisfying the above conditions. The above restriction allows us to get rid of the term systems which are needed in <ref> [26, 27] </ref>. Moreover we will not introduce cylindrification operators and diagonal elements in the constraint system, by assuming that local variables are renamed apart whenever two constraints are composed. The resulting constraint system is the following. <p> However none of those semantics was shown to be actually usable for abstract interpretation. Our bottom-up definition is essentially a reconstruction of the semantics in [6], obtained by instantiating an adaptation of the generalized semantics scheme <ref> [26, 27] </ref>. A nice feature is that we don't need to define a new ad hoc fixpoint operator, since we only have to model the control strategy in the constraint system (by means of sequences of standard and divergent constraints).
Reference: [28] <author> K. Marriott and H. Stndergaard. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 733-748. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: The second contribution of the paper is the definition of a framework for the abstract interpretation of pure PROLOG programs, based on the above semantics. This is the first example of such a framework based on a bottom-up semantics, in the style of similar frameworks developed for logic programs <ref> [28, 5, 9] </ref>. We have shown that the approximation of the semantics of pure PROLOG programs can essentially be based on domains developed for the analysis of logic programs. However we are confronted with two new problems, i.e. lower approximations and sequences approximation.
Reference: [29] <author> D. </author> <month> Micciancio. </month> <institution> Interpretazione astratta di programmi logici con il con-trollo di PROLOG. </institution> <type> Master's thesis, </type> <institution> Dipartimento di Informatica, Uni-versita di Pisa, </institution> <year> 1994. </year> <note> in italian. </note>
Reference-contexts: We assume the reader to be familiar with logic programming, abstract interpretation and constraint systems. All the proofs of our results can be found in <ref> [29] </ref>. 2 The fixpoint semantics of pure PROLOG The construction is clearly inspired by the s-semantics and achieves similar results, i.e. modeling computed answers in a goal-independent way. The semantic domain is made of sequences of atoms from an extended Herbrand Base. <p> The complete construction can be found in <ref> [29] </ref>. 4.4 Some examples Example 4.18 nat (X):-X = 02. The immediate consequences operator T P generates the following sequence of constraints in Seq (C): 0 h 0 (X) = T 0 1 h 1 (X) = T 1 2 h 2 (X) = T 1 . . .
Reference: [30] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-time derivation of variable dependency using abstract interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2 </volume> & 3):315-347, 1992. 
Reference-contexts: The study of this relation is worth further study. 33 The main open problem is the development of applications. In particu-lar, we plan to extend to pure PROLOG the techniques developed for the independence analysis <ref> [30] </ref>, with the aim of obtaining more precise results to be used in the parallelization of pure PROLOG programs. Another interesting research direction is the extension of our approach to full PROLOG, with the aim of making the existing analyses useful in real PROLOG compilers.
Reference: [31] <author> T. Vasak and J. Potter. </author> <title> Characterization of Terminating Logic Programs. </title> <booktitle> In Proc. Third IEEE Int'l Symp. on Logic Programming, </booktitle> <pages> pages 140-147. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1986. </year> <month> 36 </month>
Reference-contexts: The only information conveyed by b A is that the corresponding derivation is partial and therefore potentially divergent. Concepts similar to the one of divergent atom have also been considered in some semantics for logic programs with the aim of modeling termination <ref> [31] </ref> and finite success [18]. The first step in [6] is the definition of an extended base B E = f b A j A 2 Bg [ B, where B is the set of non-ground atoms built on the program 3 signature modulo variance.
Reference: [32] <author> E. Zaffanella, G. Levi, and R. Giacobazzi. </author> <title> Abstracting synchroniza-tion in concurrent constraint programming. </title> <editor> In M. Hermenegildo and J. Penjam, editors, </editor> <booktitle> Programming Language Implementation and Logic Programming, Proc. PLILP'94, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year> <month> 37 </month>
Reference-contexts: Moreover, the approach can be specialized to the case of pure logic programs, by providing the PROLOG implementation of the abstract constraint systems, as done in [11, 12]. The approach was also extended to the case of concurrent constraint programs <ref> [32] </ref>. In this paper we extend the approach to pure PROLOG, i.e. to logic programs with the PROLOG computation rule (leftmost selection rule and backtracking). The abstract semantics of a logic program is of course a safe approximation of the semantics of the corresponding pure PROLOG program. <p> Let us finally point out that lower approximations can also be useful to approximate the ask constraints in concurrent constraint programs <ref> [19, 32] </ref>. The second new problem, i.e. the approximation of sequences, was already found in the analysis of modular programs and of concurrent programs. The case of pure PROLOG is probably harder because of the different nature of sequences.
References-found: 32

