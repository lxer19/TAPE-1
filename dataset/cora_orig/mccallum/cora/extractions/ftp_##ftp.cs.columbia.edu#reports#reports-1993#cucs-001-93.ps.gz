URL: ftp://ftp.cs.columbia.edu/reports/reports-1993/cucs-001-93.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1993.html
Root-URL: http://www.cs.columbia.edu
Email: fkaiser, hseush, wug@cs.columbia.edu  
Phone: Tel: 212-939-7081, Fax: 212-666-0140  
Title: MELDC: A Reflective Object-Oriented Coordination Language  
Author: Gail E. Kaiser Wenwey Hseush James C. Lee Shyhtsun F. Wu Esther Woo Eric Hilsdale Scott Meyer c fl, Kaiser, Hseush, Lee, Wu, Woo, Hilsdale, and Meyer 
Note: All Rights Reserved Kaiser is supported by National Science Foundation grants CCR-9106368 and CCR-8858029, by grants from AT&T, BNR, Bull, DEC, IBM, Paramax and SRA, and by the New York State Center for Advanced Technology in Computers and Information Systems. Hseush is supported in part by the NSF Engineering Research Center for Telecommunications Research. Lee is supported in part by the Center for Advanced Technology. Wu is supported in part by an IBM Fellowship and in part by the NSF Engineering Research Center for Telecom munications Research.  
Date: January 15, 1993  
Address: 500 W. 120th Street New York, NY 10027  
Affiliation: Department of Computer Science Columbia University  
Pubnum: Technical Report CUCS-001-93  
Abstract: A coordination language, MELDC, for open systems programming is presented. MELDC is a C-based, concurrent, distributed object-oriented language built on a reflective architecture. Unlike other language research, the focus of MELDC is not only to study what specific language features should be designed for solving certain open system problems but also to provide programmers a high-level and efficient way to construct new features without modifying the language internals. The key to the reflective feature is the metaclass that supports shadow objects to implement secondary behaviors of objects. Thus, the behavior of an object can be extended by dynamically composing multiple secondary behaviors with the object's primary behavior defined in the class. In this paper, both the MELDC programming model and the reflective architecture are described. Then, we introduce the mechanism of dynamic composition as well as its application in building distributed and persistent systems. In particular, a soft real-time network management system, MELDNET, is built on top of MELDC to monitor the EtherNet performance. Finally, the current status of MELDC is given. 
Abstract-found: 1
Intro-found: 1
Reference: [Bob88] <author> D.G. Bobrow. </author> <title> Common lisp object system specification x3j13 dcoument 88-002r. </title> <journal> SIG-PLAN Notices, </journal> <volume> 23, </volume> <month> September </month> <year> 1988. </year> <note> Special issue. </note>
Reference: [Boo83] <author> Grady Booch. </author> <title> Object Oriented Design With Applications. </title> <address> Benjamin/Cummings, </address> <year> 1983. </year>
Reference-contexts: Sometimes the number of modifications is very large; hence the likelihood of introducing new bugs is very high. MELDC supports both inheritance and dynamic composition. Our idea of dynamic composition is inspired by mixins and method inheritance in Flavors <ref> [Moo86, Boo83, Hen86] </ref>. The mixins are ordinary classes, but their sole purpose is to extend the functionality of other classes. When a Flavors object is invoked, one or multiple methods can be selected from the set of inherited methods. The programmer can predefine the multiple methods' calling sequences.
Reference: [CG89] <author> N. Carriero and D. Gelernter. </author> <title> Linda in Context. </title> <journal> Comminications of The ACM, </journal> <volume> 32(4) </volume> <pages> 444-458, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: 1 Introduction The concept of coordination language was introduced by Carriero and Gelernter <ref> [CG89] </ref> to designate a class of programming languages suitable for describing the behavior of open systems. Ciancarini [Cia90] suggests the following definition for open systems: An open system is a dynamic set of agents both cooperating and conflicting for the use of a dynamic set of services and resources.
Reference: [Cia90] <author> Paolo Ciancarini. </author> <title> Coordination Languages for Open System Design. </title> <booktitle> In International Conference on Computer Languages, </booktitle> <pages> pages 252-260, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The concept of coordination language was introduced by Carriero and Gelernter [CG89] to designate a class of programming languages suitable for describing the behavior of open systems. Ciancarini <ref> [Cia90] </ref> suggests the following definition for open systems: An open system is a dynamic set of agents both cooperating and conflicting for the use of a dynamic set of services and resources.
Reference: [Coi87] <author> Pierre Cointe. </author> <title> MetaClasses are First Class: the ObjVlisp Model. </title> <booktitle> In OOPSLA'87, </booktitle> <volume> volume 22, </volume> <pages> pages 156-167, </pages> <year> 1987. </year>
Reference-contexts: There are no senders for these initial messages. A subset of the messages are first delivered to the metaclass to create classes and then the rest of messages are delivered to these classes to create 1 Similar to CLOS [DBM88] and ObjVlisp <ref> [Coi87] </ref>, it is possible to have multiple metaclasses that are instances of the default metaclass. There are numerous complex issues regarding metaclasses, which are not within the scope of our discussion. 2 global objects.
Reference: [Fer88] <author> Jacques Ferber. </author> <title> Conceptual Reflection and Actor Languages. </title> <editor> In Pattie Maes, editor, </editor> <booktitle> Meta-Level Architectures and Reflection, </booktitle> <pages> pages 177-193. </pages> <publisher> North-Holland, </publisher> <year> 1988. </year> <month> 23 </month>
Reference-contexts: The manager can remove the auditing from the object at any time. The idea of reflection is one of the important concepts that allows a program to dynamically alter its own behavior [Mae87, Mae88]. Reflection has been implemented in many languages (e.g., ACTORS <ref> [Fer88] </ref>, ABCL [Wat88], and ObjVlisp [Fer89]). The dynamic composition provided by our MELDC language is one of many forms of reflection. However, MELDC limits the power of reflection in order to improve the efficiency of the language.
Reference: [Fer89] <author> Jacques Ferber. </author> <title> Computational Reflection in Class based Object Oriented Languages. </title> <booktitle> In OOPSLA'89, </booktitle> <volume> volume 24, </volume> <pages> pages 317-326, </pages> <year> 1989. </year>
Reference-contexts: The manager can remove the auditing from the object at any time. The idea of reflection is one of the important concepts that allows a program to dynamically alter its own behavior [Mae87, Mae88]. Reflection has been implemented in many languages (e.g., ACTORS [Fer88], ABCL [Wat88], and ObjVlisp <ref> [Fer89] </ref>). The dynamic composition provided by our MELDC language is one of many forms of reflection. However, MELDC limits the power of reflection in order to improve the efficiency of the language.
Reference: [Hen86] <author> J. Hendler. </author> <title> Enhancement for fMultiple Inheritance. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(10):100, </volume> <year> 1986. </year>
Reference-contexts: Sometimes the number of modifications is very large; hence the likelihood of introducing new bugs is very high. MELDC supports both inheritance and dynamic composition. Our idea of dynamic composition is inspired by mixins and method inheritance in Flavors <ref> [Moo86, Boo83, Hen86] </ref>. The mixins are ordinary classes, but their sole purpose is to extend the functionality of other classes. When a Flavors object is invoked, one or multiple methods can be selected from the set of inherited methods. The programmer can predefine the multiple methods' calling sequences.
Reference: [HLK92] <author> Wenwey Hseush, James C. Lee, and Gail E. Kaiser. </author> <title> MeldC Threads: Supporting Large-Scale Dynamic Parallelism. </title> <type> Technical Report CUCS-010-92, </type> <institution> Department of Computer Science, Columbia University, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: Some applications require a small number of long-lived threads while others need a large number of short-lived threads that are created and destroyed dynamically. Thus MELDC provides three different thread packages (interleaving stack, one-stack-per-thread and heap-based) <ref> [HLK92] </ref>, which can be chosen with a compiler switch. Other compiler options enable the programmer to choose pre-emptive versus non-pre-emptive schedulers and either merging or overriding behavior for multiple inheritance. The MELD project has been one of the major foci of the Programming Systems Laboratory at Columbia University since 1987.
Reference: [IC88] <author> Mamdouh H. Ibrahim and Fred A. Cummins. KSL: </author> <title> A Reflective Object-Oriented Programming Language. </title> <booktitle> In International Conference on Computer Languages, </booktitle> <pages> pages 186-193, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: A language is considered reflective if it uses uniform structures to represent data as well as control entities (e.g., programs) <ref> [IC88] </ref>. A reflective language provides the capability of computing control entities in the same way as computing data. For example, Lisp is a reflective language, because it uses the same structures (lists) for both data and programs.
Reference: [KHPW90] <author> Gail E. Kaiser, Wenwey Hseush, Steven S. Popovich, and Shyhtsun F. Wu. </author> <title> Multiple Concurrency Control Policies in an Object-Oriented Programming System. </title> <booktitle> In 2nd IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 623-626, </pages> <address> Dallas TX, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: The original design of the MELD language focused on supporting multiple programming paradigms at multiple levels of granularity. MELD integrates four paradigms: object-oriented, macro dataflow, module interconnection and transaction processing <ref> [KHPW90, KPHW89] </ref>.
Reference: [KPHW89] <author> Gail E. Kaiser, Steven S. Popovich, Wenwey Hseush, and Shyhtsun Felix Wu. </author> <title> MELDing Multiple Granularities of Parallelism. </title> <editor> In Stephen Cook, editor, </editor> <booktitle> 3rd European Conference on Object-Oriented Programming, British Computer Society Workshop Series, </booktitle> <pages> pages 147-166, </pages> <address> Nottingham, UK, July 1989. </address> <publisher> Cambridge University Press. </publisher>
Reference-contexts: The original design of the MELD language focused on supporting multiple programming paradigms at multiple levels of granularity. MELD integrates four paradigms: object-oriented, macro dataflow, module interconnection and transaction processing <ref> [KHPW90, KPHW89] </ref>.
Reference: [LHHK92] <author> James Lee, Wenwey Hseush, Eric Hilsdale, and Gail E. Kaiser. </author> <title> Dynamic Orthogonal Composition in MeldC. </title> <booktitle> In Workshop of Objects in Large Distributed Applications, </booktitle> <address> Vancouver, British Columbia, Canada, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Since MELDC is running on several versions of the UNIX time-sharing operating system, MELDNET is soft real-time 5 because the timer facility we used is not precise. One major advantage of using MELDC is its support for shadow objects and protocol objects in a distributed environment <ref> [LHHK92] </ref>. In MELDC, if the real managed object is owned by the information agent and a remote managed object is owned by the monitoring system, then the remote object does not contain the actual value.
Reference: [LHM + 86] <author> Bruce Lindsay, Laura Haas, C. Mohan, Hamid Pirahesh, and Paul Wilms. </author> <title> A Snapshot Differential Refresh Algorithm. </title> <booktitle> In SIGMOD, </booktitle> <pages> pages 53-60, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1986. </year>
Reference-contexts: Please note that the remote object in this case is simply a way of caching and replicating remote management information with periodic refreshing <ref> [LHM + 86] </ref>. Furthermore, the quality of the information service (QOIS) is decided by the refreshing rate. Besides object access transparency, the shadow object in MELDC provides another performance advantage in distributed real-time network monitoring.
Reference: [Mae87] <editor> Pattie Maes. </editor> <title> Concepts and Experiment in Computational Reflection. </title> <booktitle> In OOPSLA'87, </booktitle> <volume> volume 22, </volume> <pages> pages 147-155, </pages> <year> 1987. </year>
Reference-contexts: Attaching a secondary behavior simply modifies the primary behaviors in a transient and orthogonal fashion. The manager can remove the auditing from the object at any time. The idea of reflection is one of the important concepts that allows a program to dynamically alter its own behavior <ref> [Mae87, Mae88] </ref>. Reflection has been implemented in many languages (e.g., ACTORS [Fer88], ABCL [Wat88], and ObjVlisp [Fer89]). The dynamic composition provided by our MELDC language is one of many forms of reflection. However, MELDC limits the power of reflection in order to improve the efficiency of the language.
Reference: [Mae88] <editor> Pattie Maes. </editor> <title> Issues in Computational Reflection. </title> <editor> In Pattie Maes, editor, </editor> <booktitle> Meta-Level Architectures and Reflection, </booktitle> <pages> pages 21-34. </pages> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Attaching a secondary behavior simply modifies the primary behaviors in a transient and orthogonal fashion. The manager can remove the auditing from the object at any time. The idea of reflection is one of the important concepts that allows a program to dynamically alter its own behavior <ref> [Mae87, Mae88] </ref>. Reflection has been implemented in many languages (e.g., ACTORS [Fer88], ABCL [Wat88], and ObjVlisp [Fer89]). The dynamic composition provided by our MELDC language is one of many forms of reflection. However, MELDC limits the power of reflection in order to improve the efficiency of the language.
Reference: [Moo86] <author> David A. Moon. </author> <title> Object-oriented programming with Flavors. </title> <booktitle> In OOPSLA, </booktitle> <volume> volume 21, </volume> <pages> pages 1-8, </pages> <year> 1986. </year>
Reference-contexts: Sometimes the number of modifications is very large; hence the likelihood of introducing new bugs is very high. MELDC supports both inheritance and dynamic composition. Our idea of dynamic composition is inspired by mixins and method inheritance in Flavors <ref> [Moo86, Boo83, Hen86] </ref>. The mixins are ordinary classes, but their sole purpose is to extend the functionality of other classes. When a Flavors object is invoked, one or multiple methods can be selected from the set of inherited methods. The programmer can predefine the multiple methods' calling sequences.
Reference: [Pu91] <author> Calton Pu. </author> <title> Generalized Transaction Processing with Epsilon-Serializability. </title> <booktitle> In Proceedings of Fourth International Workshop on High Performance Transaction Systems, Asilomar, </booktitle> <address> California, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: One example would be supporting atomic actions that guarantee serializability; however, it might then be difficult to build applications with concurrency-related correctness criteria other than serializability, such as epsilon-serializability <ref> [Pu91] </ref>. Other object-oriented languages support persistence, remoteness, monitoring, authorization, authentication, etc. as immediate language features. Like other languages, the ultimate goal of the MELDC language is to support a wide range of high-level features for programmers to cope with the problems of implementing open systems.
Reference: [Wat88] <author> Takuo Watanabe. </author> <title> Reflection in an Object-Oriented Concurrent Languages. </title> <booktitle> In OOP-SLA'88, </booktitle> <volume> volume 23, </volume> <pages> pages 306-315, </pages> <year> 1988. </year> <month> 24 </month>
Reference-contexts: The manager can remove the auditing from the object at any time. The idea of reflection is one of the important concepts that allows a program to dynamically alter its own behavior [Mae87, Mae88]. Reflection has been implemented in many languages (e.g., ACTORS [Fer88], ABCL <ref> [Wat88] </ref>, and ObjVlisp [Fer89]). The dynamic composition provided by our MELDC language is one of many forms of reflection. However, MELDC limits the power of reflection in order to improve the efficiency of the language.
Reference: [WK93] <author> Shyhtsun F. Wu and Gail E. Kaiser. </author> <title> On Hard Real-Time Management Information. </title> <booktitle> In IEEE First International Workshop on System Management, page to appear, </booktitle> <address> Los Angles, California, </address> <month> April </month> <year> 1993. </year> <month> 25 </month>
Reference-contexts: We might want to use the same model as object migration. 5 An Application: MELDNET MELDNET is a performance monitoring system for EtherNet and it is built on top of MELDC. MELDNET serves as a prototype revealing technical difficulties in implementing an object-oriented real-time monitoring system <ref> [WK93] </ref>. Since MELDC is running on several versions of the UNIX time-sharing operating system, MELDNET is soft real-time 5 because the timer facility we used is not precise. One major advantage of using MELDC is its support for shadow objects and protocol objects in a distributed environment [LHHK92]. <p> The return value from the real managed object is returned to the management application originating the request. The interaction between the remote and real managed object, as depicted in Figure 5, is transparent to the application, and it is not hard real-time. As described in <ref> [WK93] </ref>, it is more efficient if the remote object keeps a copy of the value and the real managed object periodically sends new values to update the remote replicated copy as in Figure 6. <p> One question about the MELDNET implementation is: Will there be too many shadow objects with this approach, which takes a lot of memory resources? In <ref> [WK93] </ref>, we argued that in a hard real-time monitoring system, at one time instant, management applications can only access a relatively small, bounded, specific set of managed objects with specified QOIS.
References-found: 20

