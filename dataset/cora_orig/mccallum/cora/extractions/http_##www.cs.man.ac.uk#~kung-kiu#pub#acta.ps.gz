URL: http://www.cs.man.ac.uk/~kung-kiu/pub/acta.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: Summary  
Title: A Note on Synthesis and Classification of Sorting Algorithms  
Author: K.K. Lau, 
Address: Manchester M13 9PL, England  
Affiliation: Department of Computer Science, University of Manchester,  
Abstract: Sorting algorithms are traditionally classified according to their main operational characteristic. More recently, program synthesis has been used as a basis for classification. We briefly survey previous work in the synthesis and classification of sorting algorithms, and outline a more comprehensive scheme derived by synthesising many sorting algorithms in a top-down fashion on a semi-automated logic programming system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Barstow, </author> <title> D.R.: Remarks on "A Synthesis of Several Sorting Algorithms" by John Darlington. </title> <journal> Acta Informatica 13, </journal> <pages> 225-227(1980) </pages>
Reference-contexts: Their top-down analysis reveals that the asymmetric part of Darlington's tree can in fact be made symmetric, as Barstow points out in <ref> [1] </ref>. This is due to the fact that they derive bubble sort and sinking sort as "in-place" versions of selection sort and insertion sort .
Reference: [2] <author> Bitton, D., DeWitt, D.J., Hsiao, D.K., Menon, J.: </author> <title> A Taxonomy of Parallel Sorting. </title> <journal> Computing Surveys 16, </journal> <pages> 289-318(1984) </pages>
Reference-contexts: or block-list , each member (ordered) list being called a block . (This idea is borrowed from the d-list used by Hansson & Tarnlund in [9].) The top-level specification for this will also be specialised, and from the new specification, we can derive many block or parallel sorting algorithms (see <ref> [2] </ref> for instance) based on the data partitioning algorithms that have already been synthesised. For instance, we have synthesised the external merge algorithm and a block bubble sort algorithm. Clearly, this branch of the tree offers the greatest scope for future work.
Reference: [3] <author> Burstall, R.M., Darlington, J.: </author> <title> A Transformation System for Developing Recursive Programs. </title> <editor> J. </editor> <booktitle> ACM 24, </booktitle> <pages> 44-67(1977) </pages>
Reference-contexts: This tree represents a synthesis of these algorithms by program transformation on recursion equations, the key transformation rule being the fold-unfold rule of Burstall & Darlington <ref> [3] </ref> and Manna & Waldinger [13].
Reference: [4] <author> Clark, K.L., Darlington, J.: </author> <title> Algorithm Classification Through Synthesis. </title> <journal> The Computer Journal 23, </journal> <pages> 61-65(1980) </pages>
Reference-contexts: Our nomenclature, however, conforms to Knuth's [11].) The derivation tree for this synthesis of these six algorithms therefore exhibits a symmetry in the first four algorithms (thus reflecting a symmetry in their relationships), but not in the last two. Clark & Darlington <ref> [4] </ref> derive the same four algorithms that correspond to P 1 and P 2 . They use similar program transformation rules, but adopt an informal (first-order) predicate logic notation for programs. <p> For list sorting algorithms, we start with a common top-level specification of sorting, which is stated in (first-order) predicate logic (as in <ref> [4] </ref>), i.e. sort (a; b) $ perm (a; b) ^ ord (b) together with definitions of perm and ord. (For the sake of simplicity, we assume that a list does not contain duplicates.) Then we make a high-level design decision, e.g. to aim for an algorithm which concatenates three sorted sublists <p> Consequently, we have been able to synthesise Hoare's Quicksort as a special case of our quick sort , whereas they would not be able to derive it (or Bsort for that matter) from theirs. (As they themselves point out in <ref> [4] </ref>, Clark & Darlington's quick sort differs from Hoare's Quicksort.) Consequently, our classification of quick sort differs from theirs.
Reference: [5] <author> Darlington, J.: </author> <title> A Synthesis of Several Sorting Algorithms. </title> <journal> Acta Informatica 11, </journal> <pages> 1-30(1978) </pages>
Reference-contexts: In this short paper, we first briefly survey previous work in the synthesis and classification of sorting algorithms. Then we outline our own work in this area, and finally compare our results with the others. 1 2 Brief Survey of Previous Work In <ref> [5] </ref>, Darlington presents a family tree of six sorting algorithms, as shown in Figure 1. This tree represents a synthesis of these algorithms by program transformation on recursion equations, the key transformation rule being the fold-unfold rule of Burstall & Darlington [3] and Manna & Waldinger [13].
Reference: [6] <author> Dijkstra, </author> <title> E.W.: A Discipline of Programming. </title> <address> Englewood Cliffs, N.J.: </address> <publisher> Prentice-Hall 1976 11 </publisher>
Reference: [7] <author> Dromey, R.G.: </author> <title> Derivation of Sorting Algorithms from a Specification. </title> <journal> The Computer Journal 30, </journal> <pages> 512-518(1987) </pages>
Reference-contexts: His synthesis of these algorithms can therefore be represented by the tree shown in Figure 4 which is essentially identical to Clark & Darlington's tree. In <ref> [7] </ref> Dromey uses Dijkstra's constructive weakest pre-condition technique ([6]) to derive sorting algorithms from a specification in the form of a pair of pre- and post-conditions.
Reference: [8] <author> Green, C., Barstow, </author> <title> D.:On Program Synthesis Knowledge. </title> <booktitle> Artificial Intelligence 10, </booktitle> <pages> 241-279(1978) </pages>
Reference-contexts: The first path leads to quick sort and selection sort , and the second merge sort and insertion sort respectively. Not surprisingly, their derivation tree exhibits the same symmetry as that in Darlington's. In <ref> [8] </ref>, Green and Barstow present some of the knowledge base of facts and rules 2 used by their system for automatic program construction. They demonstrate the synthesis of programs for the same six sorting algorithms in Darlington's tree using the divide-and-conquer paradigm.
Reference: [9] <author> Hansson, </author> <title> A, Tarnlund, S.A.: Program Transformation by Data Structure Mapping. </title> <editor> In: Clark, K.L., Tarnlund, S.A. (eds.) </editor> <booktitle> Logic Programming, </booktitle> <address> pp.117-122. London: </address> <publisher> Academic Press 1982 </publisher>
Reference-contexts: from this, instead of partitioning the data, we could first transform the data from list to list of ordered lists, which we call b-list , or block-list , each member (ordered) list being called a block . (This idea is borrowed from the d-list used by Hansson & Tarnlund in <ref> [9] </ref>.) The top-level specification for this will also be specialised, and from the new specification, we can derive many block or parallel sorting algorithms (see [2] for instance) based on the data partitioning algorithms that have already been synthesised.
Reference: [10] <author> Hoare, </author> <title> C.A.R.: Quicksort, </title> <journal> The Computer Journal 5, </journal> <pages> 10-15(1962) </pages>
Reference-contexts: To synthesise a particular member of this family, we need to choose an element of a to be the discriminating element f . For example, Quicksort, the original quick sort algorithm defined by Hoare in <ref> [10] </ref>, picks the first element of a for the discriminating element, 7 i.e. writing a as h:t (using standard list notation, we shall write h:t to denote the list [h]^t, where h is a single element and t is itself a list), we have sort (h:t; b^[h]^d) part (h:t; e; [h];
Reference: [11] <author> Knuth, D.E.: </author> <title> The Art of Computer Programming, Vol.3: Sorting and Searching. </title> <address> Reading: </address> <publisher> Addison-Wesley 1973 </publisher>
Reference-contexts: 1 Introduction Traditionally, sorting algorithms are classified according to their main operational characteristic. Standard works such as <ref> [11] </ref> and [14] group them under headings like sorting by insertion, sorting by selection, and sorting by partitioning, etc. A more recent approach is based on program synthesis whereby an algorithm is derived from its specification. <p> Using a different version of P results in another program P 3 , from which bubble sort and sinking sort are obtained. (Note that Darlington actually calls bubble sort and sinking sort respectively exchange sort and bubble sort . Our nomenclature, however, conforms to Knuth's <ref> [11] </ref>.) The derivation tree for this synthesis of these six algorithms therefore exhibits a symmetry in the first four algorithms (thus reflecting a symmetry in their relationships), but not in the last two.
Reference: [12] <author> Lau, K.K., Prestwich, </author> <title> S.D.: Synthesis of Logic Programs for Recursive Sorting Algorithms, </title> <type> Technical Report UMCS-88-10-1, </type> <institution> Department of Computer Science, University of Manchester, </institution> <month> October </month> <year> 1988 </year>
Reference-contexts: His tree, shown in Figure 5, is therefore the traditional one. 3 Our Synthesis and Classification We have a derivation tree for more sorting algorithms, as shown in Figure 6. In our work (see <ref> [12] </ref> for details), the synthesis is done on a semi-automated logic programming system which produces a recursive logic procedure from its given (first-order) logic specification. (We have synthesised all the algorithms shown in literal replaces it with an equivalent formula; folding does the reverse and so can be used for recursion
Reference: [13] <author> Manna, Z., Waldinger, R.: </author> <title> Synthesis: Dreams ) Programs. </title> <journal> IEEE Trans. Soft. Eng. </journal> <volume> 5, </volume> <pages> 294-328(1979) </pages>
Reference-contexts: This tree represents a synthesis of these algorithms by program transformation on recursion equations, the key transformation rule being the fold-unfold rule of Burstall & Darlington [3] and Manna & Waldinger <ref> [13] </ref>. Starting from a common definition P of permutation of a sequence, two different ways, P 1 and P 2 , of computing permutations of a sequence are derived, which in turn lead to quick sort and selection sort , and merge sort and insertion sort respectively.
Reference: [14] <author> Mehlhorn, K.: </author> <title> Data Structures and Algorithms 1: Sorting and Searching. </title> <address> Berlin Heidelberg New York Tokyo: </address> <publisher> Springer-Verlag 1984 </publisher>
Reference-contexts: 1 Introduction Traditionally, sorting algorithms are classified according to their main operational characteristic. Standard works such as [11] and <ref> [14] </ref> group them under headings like sorting by insertion, sorting by selection, and sorting by partitioning, etc. A more recent approach is based on program synthesis whereby an algorithm is derived from its specification.
Reference: [15] <author> Smith, </author> <title> D.R.: Top-down Synthesis of Divide-and-Conquer Algorithms. </title> <booktitle> Artificial Intelligence 27, </booktitle> <pages> 43-96(1985) </pages>
Reference-contexts: Their top-down analysis reveals that the asymmetric part of Darlington's tree can in fact be made symmetric, as Barstow points out in [1]. This is due to the fact that they derive bubble sort and sinking sort as "in-place" versions of selection sort and insertion sort . Smith <ref> [15, 16] </ref> describes a method for synthesising divide-and-conquer algorithms by top-down decomposition of specifications into subproblem specifications, followed by bottom-up composition of (concrete) programs synthesised for the sub-problems. The decomposition and composition is done according to a chosen design strategy associated with a pre-determined (abstract) program scheme.
Reference: [16] <author> Smith, </author> <title> D.R.: The Design of Divide and Conquer Algorithms. </title> <booktitle> Science of Computer Programming 5, </booktitle> <pages> 37-58(1985) </pages>
Reference-contexts: Their top-down analysis reveals that the asymmetric part of Darlington's tree can in fact be made symmetric, as Barstow points out in [1]. This is due to the fact that they derive bubble sort and sinking sort as "in-place" versions of selection sort and insertion sort . Smith <ref> [15, 16] </ref> describes a method for synthesising divide-and-conquer algorithms by top-down decomposition of specifications into subproblem specifications, followed by bottom-up composition of (concrete) programs synthesised for the sub-problems. The decomposition and composition is done according to a chosen design strategy associated with a pre-determined (abstract) program scheme.
Reference: [17] <author> Wainwright, </author> <title> R.L.: A Class of Sorting Algorithms Based on Quicksort. </title> <journal> Comm. ACM 28, </journal> <pages> 396-402(1985) 12 </pages>
References-found: 17

