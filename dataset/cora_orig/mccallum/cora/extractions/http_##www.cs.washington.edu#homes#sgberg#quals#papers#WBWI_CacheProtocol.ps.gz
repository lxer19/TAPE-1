URL: http://www.cs.washington.edu/homes/sgberg/quals/papers/WBWI_CacheProtocol.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/sgberg/quals/index.html
Root-URL: 
Email: ychen@paris.usc.edu and dubois@paris.usc.edu  
Title: Cache Protocols with Partial Block Invalidations  
Author: Yung-Syau Chen and Michel Dubois 
Affiliation: Department of Electrical Engineering-Systems University of Southern California University  
Date: April 1993.  
Address: Newport Beach, CA,  Park, Los Angeles, CA 90089-2562  
Note: To appear, Internatinal Parallel Processing Symposium,  
Abstract: In this paper we introduce hardware cache protocols in which invalidations affect only part of a cached block so that the processor can keep reading the valid part. On a cache miss the entire block is fetched in the cache. The proposed protocols take advantage of the prefetching effects associated with large block sizes while reducing the false sharing miss rate. It does not rely on synchronization as other previous proposals do and therefore it is applicable to systems under any memory consistency model including sequential consistency. Simulation results show that protocols with partial block invalidations may provide significant miss rate and memory traffic reductions over protocols with invalidations of entire blocks. The hardware cost is low and the protocol complexity is only marginally increased. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. V. Adve and M. D. Hill. </author> <title> "Weak Ordering: A New Definition." </title> <booktitle> In Proceedings of the 17th International Symposium on Computer Architecture, </booktitle> <address> pp.1-14, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Other authors [2, 3, 6] have proposed hardware mechanisms to reduce the effects of false sharing given that programmers/compilers may not have the sophistication to understand false sharing and eliminate it. Delayed consistency is one such approach. Delayed consistency [6] relies on weakly ordered memory models <ref> [5, 1] </ref> to delay received invalidations until an acquire is executed in the processor. Invalidations may also be delayed at the sending end. However these schemes are not applicable to systems requiring sequential consistency.
Reference: [2] <author> J. K. Bennett, and J. B. Carter. </author> <title> "Adaptive software cache management for distributed shared memory architectures." </title> <booktitle> In Proceedings of the 17th International Symposium on Computer Architecture, </booktitle> <address> pp.125-134, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Some authors have suggested that the compiler or the programmer align data sets on cache block boundaries or even use indirection to access shared data structures [14, 8]. Other authors <ref> [2, 3, 6] </ref> have proposed hardware mechanisms to reduce the effects of false sharing given that programmers/compilers may not have the sophistication to understand false sharing and eliminate it. Delayed consistency is one such approach.
Reference: [3] <author> L. Borrmann and M. Herdieckerhoff. </author> <title> "A coherency model for virtual shared memory." </title> <booktitle> In Proceedings of an International Conference on Parallel Processing, vol.2, </booktitle> <address> pp.252-257, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Some authors have suggested that the compiler or the programmer align data sets on cache block boundaries or even use indirection to access shared data structures [14, 8]. Other authors <ref> [2, 3, 6] </ref> have proposed hardware mechanisms to reduce the effects of false sharing given that programmers/compilers may not have the sophistication to understand false sharing and eliminate it. Delayed consistency is one such approach.
Reference: [4] <author> L. M. Censier and P. Feautrier. </author> <title> "A New Solution to Coherence Problems in Multicache System." </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-27(12), </volume> <pages> pp. 1112-1118, </pages> <month> Dec. </month> <year> 1978. </year>
Reference-contexts: Computers with private caches need hardware or software support to enforce cache consistency; any modification of a block copy must eventually be reflected in all cache copies so that each load returns the value defined by the latest store with the same address <ref> [4] </ref>. Cache-based multiprocessors use a much smaller block size than uniprocessors. Typically, a block size of 16 or 32 bytes is considered to be optimum for systems with write-invalidate protocols [13, 12]. <p> An invalidation block is contained in an address block and its size is a power-of-two number of bytes. 3 Partial Block Invalidation Scheme Censier and Feautrier's protocol (C&F ) will be the basis of our comparisons <ref> [4] </ref>. It is a full-map directory protocol and the address and invalidation blocks are identical. The memory directory consists in one set of P Presence bits (P-bits) plus one Modified bit (M-bit) per block in memory. The block states kept in the cache controller are Owned, Shared and Invalid.
Reference: [5] <author> M. Dubois and C. Scheurich. </author> <title> "Memory Access Dependencies in Shared Memory Multiprocessors." </title> <journal> IEEE Transactions on Software Eng. </journal> , <volume> S-16(6), </volume> <pages> pp. 660-674, </pages> <month> June. </month> <year> 1990. </year>
Reference-contexts: Other authors [2, 3, 6] have proposed hardware mechanisms to reduce the effects of false sharing given that programmers/compilers may not have the sophistication to understand false sharing and eliminate it. Delayed consistency is one such approach. Delayed consistency [6] relies on weakly ordered memory models <ref> [5, 1] </ref> to delay received invalidations until an acquire is executed in the processor. Invalidations may also be delayed at the sending end. However these schemes are not applicable to systems requiring sequential consistency.
Reference: [6] <author> M. Dubois, J. C. Wang, L. Barroso, K. Lee, Y.S. Chen. </author> <title> "Delayed Consistency and its Effects on the Miss Rate of Parallel Prog rams." </title> <booktitle> In Proceedings of the 1991 Supercomputing Conference. </booktitle> <pages> pp. 197-207, </pages> <month> November. </month> <year> 1991. </year>
Reference-contexts: Some authors have suggested that the compiler or the programmer align data sets on cache block boundaries or even use indirection to access shared data structures [14, 8]. Other authors <ref> [2, 3, 6] </ref> have proposed hardware mechanisms to reduce the effects of false sharing given that programmers/compilers may not have the sophistication to understand false sharing and eliminate it. Delayed consistency is one such approach. <p> Other authors [2, 3, 6] have proposed hardware mechanisms to reduce the effects of false sharing given that programmers/compilers may not have the sophistication to understand false sharing and eliminate it. Delayed consistency is one such approach. Delayed consistency <ref> [6] </ref> relies on weakly ordered memory models [5, 1] to delay received invalidations until an acquire is executed in the processor. Invalidations may also be delayed at the sending end. However these schemes are not applicable to systems requiring sequential consistency. <p> To solve these two problems we introduce in this paper a partial block invalidation scheme for maintaining cache coherence in shared memory multiprocessors. Performance is evaluated with trace-driven simulation of three parallel programs. These programs were selected because the delayed protocols of <ref> [6] </ref> were not able to cut all the false sharing due to the above reasons. This paper is organized as follows. Section 2 and 3 describe our partial block invalidation scheme. Section 4 compares the hardware costs of partial block invalidation and of entire block invalidation. <p> Finally, we can try to compare the effectiveness of partial block invalidation with receive delayed and send-and-receive delayed protocols. In <ref> [6] </ref> traces similar to the ones used in this paper were run. The QSORT and FLOYD experiments were slightly different. But the SOR trace was exactly the same. We can see that for QSORT the delayed protocols fared as well as partial invalidations.
Reference: [7] <author> S. J. Eggers and R. H. Katz. </author> <title> "A characterization of sharing in parallel programs and its application to coherency protocol evaluation." </title> <booktitle> In Proceedings of an International Symposium on Computer Architecture, </booktitle> <pages> pp. 373-383, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Cache-based multiprocessors use a much smaller block size than uniprocessors. Typically, a block size of 16 or 32 bytes is considered to be optimum for systems with write-invalidate protocols [13, 12]. One of the reasons is false sharing <ref> [7, 14, 8] </ref>, the read/write sharing of blocks without true sharing of data. Even if the cache size is infinite, the miss rate usually goes up for large block sizes, because false sharing increases with the block size.
Reference: [8] <author> S. J. Eggers and T. E. Jeremiassen. </author> <title> "Eliminating False Sharing." </title> <booktitle> Proc. of the 1991 Int. Conf. on Par. Proc., </booktitle> <pages> pp. </pages> <address> I-377-I-381, </address> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: Cache-based multiprocessors use a much smaller block size than uniprocessors. Typically, a block size of 16 or 32 bytes is considered to be optimum for systems with write-invalidate protocols [13, 12]. One of the reasons is false sharing <ref> [7, 14, 8] </ref>, the read/write sharing of blocks without true sharing of data. Even if the cache size is infinite, the miss rate usually goes up for large block sizes, because false sharing increases with the block size. <p> Some authors have suggested that the compiler or the programmer align data sets on cache block boundaries or even use indirection to access shared data structures <ref> [14, 8] </ref>. Other authors [2, 3, 6] have proposed hardware mechanisms to reduce the effects of false sharing given that programmers/compilers may not have the sophistication to understand false sharing and eliminate it. Delayed consistency is one such approach. <p> We have run simulations for address blocks (B) of 16, 32, 64 and 128 bytes and for invalidation blocks (b) as small as 16 bytes. 5.2.1 Miss rates Misses are decomposed into false sharing and other misses. Other misses include true sharing and cold misses <ref> [14, 8] </ref>. The false sharing misses are detected by a technique introduced in [8] in the context of infinite caches. <p> Other misses include true sharing and cold misses [14, 8]. The false sharing misses are detected by a technique introduced in <ref> [8] </ref> in the context of infinite caches. A cold miss occurs at the first reference to a specific block by a specific processor and all the following misses to the same block by the same processor are called invalidation misses.
Reference: [9] <author> R. Francis. </author> <title> "The PRISM Multiprocessor Simulator." </title> <type> Technical Report, </type> <institution> High-Performance Computation Project, Division of Information Technology, CSIRO, </institution> <address> 723 Swanston St., Carlton 3053, Australia. </address>
Reference-contexts: The overall effect on the invalidation traffic is hard to predict. To evaluate the miss rate reduction and the effects on memory traffic, we need to run simulations of actual parallel programs. 5.1 Program Traces The traces used in this study were produced by the Prism Simulator <ref> [9] </ref>, an execution-driven simulator. ModulaP [10] source code is compiled to produce intermediate C code consisting in a number of slices (or procedures), which represent the atomic actions performed in turn by the different threads. The intermediate C code is lexically processed to insert statements which output memory reference activity.
Reference: [10] <author> R. Francis. </author> <title> "ModulaP Language Reference Manual." </title> <type> Technical Report, </type> <institution> High-Performance Computation Project, Division of Information Technology, CSIRO, </institution> <address> 723 Swanston St., Carlton 3053, Australia. </address>
Reference-contexts: To evaluate the miss rate reduction and the effects on memory traffic, we need to run simulations of actual parallel programs. 5.1 Program Traces The traces used in this study were produced by the Prism Simulator [9], an execution-driven simulator. ModulaP <ref> [10] </ref> source code is compiled to produce intermediate C code consisting in a number of slices (or procedures), which represent the atomic actions performed in turn by the different threads. The intermediate C code is lexically processed to insert statements which output memory reference activity.
Reference: [11] <author> J. R. Goodman. </author> <title> "Using Cache memory to reduce processor-memory traffic." </title> <booktitle> In Proceedings of the 10th International Symposium on Computer Architecture, </booktitle> <pages> pp. 124-131, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: Section 4 compares the hardware costs of partial block invalidation and of entire block invalidation. The simulation methodology is introduced in Section 5. The simulation results are presented and discussed in Section 6 and the conclusion follows in Section 7. 2 Address and Invalidation Blocks In <ref> [11] </ref>, Goodman defined address blocks and transfer blocks. An address block is the unit of allocation in the cache and is associated with an address tag. The transfer block is the unit of transfer on the bus at the occurrence of a miss.
Reference: [12] <author> A. Gupta and W.-D. Weber. </author> <title> "Cache Invalidation Patterns in Shared-Memory Multiprocessors." </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-41(7), </volume> <pages> pp. 794-810, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Cache-based multiprocessors use a much smaller block size than uniprocessors. Typically, a block size of 16 or 32 bytes is considered to be optimum for systems with write-invalidate protocols <ref> [13, 12] </ref>. One of the reasons is false sharing [7, 14, 8], the read/write sharing of blocks without true sharing of data. Even if the cache size is infinite, the miss rate usually goes up for large block sizes, because false sharing increases with the block size.
Reference: [13] <author> D. Lenoski et al. </author> <title> "The directory-based cache coherence protocol for the DASH multiprocessor." </title> <booktitle> In Proceedings of the 17th International Symposium on Computer Architecture, </booktitle> <pages> pp. 148-159, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Cache-based multiprocessors use a much smaller block size than uniprocessors. Typically, a block size of 16 or 32 bytes is considered to be optimum for systems with write-invalidate protocols <ref> [13, 12] </ref>. One of the reasons is false sharing [7, 14, 8], the read/write sharing of blocks without true sharing of data. Even if the cache size is infinite, the miss rate usually goes up for large block sizes, because false sharing increases with the block size.
Reference: [14] <author> J. Torrellas, M. S. Lam and J. L. Hennessy. </author> <title> "Shared Data Placement Optimizations to Reduce Multiprocessor Cache Misses." </title> <booktitle> Proc. of the 1990 Int. Conf. on Par. Proc., </booktitle> <pages> pp. 266-270, </pages> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: Cache-based multiprocessors use a much smaller block size than uniprocessors. Typically, a block size of 16 or 32 bytes is considered to be optimum for systems with write-invalidate protocols [13, 12]. One of the reasons is false sharing <ref> [7, 14, 8] </ref>, the read/write sharing of blocks without true sharing of data. Even if the cache size is infinite, the miss rate usually goes up for large block sizes, because false sharing increases with the block size. <p> Some authors have suggested that the compiler or the programmer align data sets on cache block boundaries or even use indirection to access shared data structures <ref> [14, 8] </ref>. Other authors [2, 3, 6] have proposed hardware mechanisms to reduce the effects of false sharing given that programmers/compilers may not have the sophistication to understand false sharing and eliminate it. Delayed consistency is one such approach. <p> We have run simulations for address blocks (B) of 16, 32, 64 and 128 bytes and for invalidation blocks (b) as small as 16 bytes. 5.2.1 Miss rates Misses are decomposed into false sharing and other misses. Other misses include true sharing and cold misses <ref> [14, 8] </ref>. The false sharing misses are detected by a technique introduced in [8] in the context of infinite caches.
References-found: 14

