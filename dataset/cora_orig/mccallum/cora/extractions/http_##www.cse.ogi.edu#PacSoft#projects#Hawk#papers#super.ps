URL: http://www.cse.ogi.edu/PacSoft/projects/Hawk/papers/super.ps
Refering-URL: http://www.cse.ogi.edu/~byron/papers/
Root-URL: http://www.cse.ogi.edu
Email: fbyron,jl,johnmg@cse.ogi.edu  
Title: Specifying superscalar microprocessors in Hawk  
Author: Byron Cook, John Launchbury, and John Matthews 
Affiliation: Oregon Graduate Institute  
Abstract: Hawk is a language for the specification of microprocessors at the microarchitectural level. In this paper we use Hawk to specify a modern microarchitecture based on the Intel P6 with features such as speculation, register renaming, and superscalar out-of-order execution. We show that parametric polymorphism, type-classes, higher-order functions, lazy evaluation, and the state monad are key to Hawk's concision and clarity. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Aagaard, M., and Leeser, M. </author> <title> Reasoning about pipelines with structural hazards. </title> <booktitle> In Second International Conference on Theorem Provers in Circuit Design (Bad Herrenalb, </booktitle> <address> Germany, </address> <month> Sept. </month> <year> 1994). </year>
Reference-contexts: Later in this paper we use the function delay, which is defined in terms of before: delay x s = [x] `before` s So, for example: delay 6 primes = 6, 2, 3, 5, 7, 11, 13, 17, .... 3.2 Transactions Transactions <ref> [1] </ref> formalize the notation of instructions introduced in Subsection 2.1. A transaction is a machine instruction grouped together with its state.
Reference: 2. <author> Barton, D. </author> <title> Advanced modeling features of MHDL. </title> <booktitle> In International Conference on Electronic Hardware Description Languages (Jan. </booktitle> <year> 1995). </year>
Reference-contexts: On the other hand, HML is not lazy, so it does not easily allow the dependent circuit specifications that are key in specifying microarchitectures in Hawk. Also, HML does not clearly separate its imperative and functional features. MHDL <ref> [2] </ref> is a hardware description language for describing analog microwave circuits, and includes an interface to VHDL. Though it tackles a very different area of the hardware design spectrum, like Hawk, MHDL is essentially an extended version of Haskell.
Reference: 3. <author> Caspi, P., Pilaud, D., Halbwachs, N., and Plaice, J. Lustre: </author> <title> A declarative language for programming synchronous systems. </title> <booktitle> In Symposium on Principles of Programming Languages (Munich, </booktitle> <address> Germany, </address> <month> Jan. </month> <year> 1987). </year>
Reference-contexts: Informally, we can think of a signal as an infinite sequence where the clock cycle is the index: toggle = True, False, True, False, True, False, .... primes = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, .... Like the synchronous language Lustre <ref> [3] </ref>, Hawk provides a built-in signal type and functions to construct and manipulate them. The function constant, from Fig. 7, returns a signal that does not change over time: constant 5 = 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, .... <p> Lava is a Haskell library for the specification of Field Programmable Gate Arrays. Lava is intended to be used at a lower level of abstraction than Hawk. Like Ruby, Lava specifications focus much attention on issues related to layout. Like Hawk, Lustre <ref> [3] </ref> and the other reactive synchronous languages (Signal, Esterel, Argos, etc) provide mechanisms for constructing expressions over time-varying domains. However, research on these languages has emphasised reactive features rather than the issues addressed in this paper.
Reference: 4. <author> Gwennap, L. </author> <title> Intel's P6 uses decoupled superscalar design. </title> <type> Microprocessor Report 9, </type> <month> 2 </month> <year> (1995). </year>
Reference-contexts: In this paper we explore a Hawk specification of a microarchitecture based on the Intel P6 <ref> [4] </ref>. We give an overview of the top-level design, and describe in detail our specification of the Reorder Buffer. The purpose of this paper is to show that complex microarchitectures can be formally specified in a clear, concise and intelligible way that facilitates understanding, design review, simulation, and verification.
Reference: 5. <author> Hudak, P., Peterson, J., and Fasel, J. </author> <title> A gentle introduction to Haskell. </title> <note> Available at www.haskell.org, Dec. </note> <year> 1997. </year>
Reference-contexts: We assume the reader is familiar with the basic concepts of functional languages and microarchitectural design (such as branch prediction and pipelining). For an in-depth introduction to Haskell, read Hudak, Peterson, and Fasel's tutorial <ref> [5] </ref>. For more information on microarchitectures, refer to Johnson's textbook [6].
Reference: 6. <author> Johnson, M. </author> <title> Superscalar Microprocessor Design. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: We assume the reader is familiar with the basic concepts of functional languages and microarchitectural design (such as branch prediction and pipelining). For an in-depth introduction to Haskell, read Hudak, Peterson, and Fasel's tutorial [5]. For more information on microarchitectures, refer to Johnson's textbook <ref> [6] </ref>.
Reference: 7. <author> Jones, G., and Sheeran, M. </author> <title> Circuit design in Ruby. In Formal Methods for VLSI Design, </title> <editor> J. Staunstrup, Ed. </editor> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: We hope to use Hawk formally to verify the correctness of microprocessors with a mechanical theorem prover (for example, Isabelle [14]). A theorem proving environment for Hawk must have support for manipulating higher-order functions and polymorphic types. 7 Related work Ruby <ref> [7] </ref> is a specification language based on relations, rather than functions. Relations can describe more circuits than functions. Much of Ruby's emphasis is on circuit layout. Ruby provides combinators to specify where circuits are located in relation to each other and to external wires.
Reference: 8. <author> Krsti c, S., Cook, B., Launchbury, J., and Matthews, J. </author> <title> A correctness proof of a speculative, superscalar, out-of-order, renaming micro-architecture. </title> <booktitle> Submitted to 1998 Formal Methods in Computer Aided Design, </booktitle> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: Although Hawk is at a higher level of abstraction than mainstream HDLs from our initial results we believe that, within limits, automatic synthesis is feasible. We have just completed a correctness proof of a microarchitecture based on this paper in which the ROB, RS, and IFU are specified axiomatically <ref> [8] </ref>. We now hope to prove that the ROB, RS, and IFU presented here implement the axioms. We hope to use Hawk formally to verify the correctness of microprocessors with a mechanical theorem prover (for example, Isabelle [14]).
Reference: 9. <author> Launchbury, J., and Jones, S. P. </author> <title> Lazy functional state threads. </title> <booktitle> In Programming Languages Design and Implementation (Orlando, </booktitle> <address> Florida, 1994), </address> <publisher> ACM Press. </publisher>
Reference-contexts: Our approach in this paper is to specify the ROB in a behavioral style using imperative language features. In Fig. 10, the specification of the ROB is provided in the state monad and then encapsulated with Hawk's state thread encapsulation construct runST <ref> [9] </ref>. The advantage of using runST is that the language guarantees that rob neither depends on nor alters mutable state in other components or an outside environment [10]. We can therefore treat the ROB as a pure function that, on a given input, always returns the same output.
Reference: 10. <author> Launchbury, J., and Sabry, A. </author> <title> Monadic state: Axiomatization and type safety. </title> <booktitle> In International Conference on Functional Programming (Amsterdam, </booktitle> <address> The Netherlands, </address> <month> June </month> <year> 1997). </year>
Reference-contexts: The advantage of using runST is that the language guarantees that rob neither depends on nor alters mutable state in other components or an outside environment <ref> [10] </ref>. We can therefore treat the ROB as a pure function that, on a given input, always returns the same output.
Reference: 11. <author> Li, Y., and Leeser, M. HML: </author> <title> An innovative hardware design language and its translation to VHDL. </title> <booktitle> In Conference on Hardware Design Languages (June 1995). </booktitle>
Reference-contexts: Hydra is similar to Hawk in many respects. However composite signal types, such as signals of integers, must be constructed as tuples or lists of Boolean signals. This restriction severely limits Hydra's application to the domain of complex microarchitectures. HML <ref> [11] </ref> is a hardware modelling language based on ML. It supports higher-order functions and polymorphic types, allowing many of the same abstraction techniques that are used in Hawk.
Reference: 12. <author> Lipasti, M. H. </author> <title> Value Locality and Speculative Execution. </title> <type> PhD thesis, </type> <institution> Department of Electrical and Computer Engineering, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <year> 1997. </year>
Reference-contexts: This state might include: * Operand values. * A flag indicating that the instruction has caused an exception. * A predicted jump target, if the instruction is a branch. * Other obscure information, such as predicted operand values if we choose to implement value locality <ref> [12] </ref> optimizations. Transactions are provided as a library of functions, written in Hawk, for creating and modifying transactions. For example, bypass takes two transactions and builds a new transaction where the values from the destination operands of the first transaction are forwarded to the source operands of the second.
Reference: 13. <author> O'Donnell, J. </author> <title> From transistors to computer architecture: Teaching functional circuit specification in Hydra. </title> <booktitle> In Symposium on Functional Programming Languages in Education (July 1995). </booktitle>
Reference-contexts: Like Hawk, Lustre [3] and the other reactive synchronous languages (Signal, Esterel, Argos, etc) provide mechanisms for constructing expressions over time-varying domains. However, research on these languages has emphasised reactive features rather than the issues addressed in this paper. The Haskell library Hydra <ref> [13] </ref> allows modeling of gates at several levels of abstraction, ranging from implementations of gates using CMOS and NMOS pass-transistors, up to abstract gate representations using lazy lists to denote time-varying values. Hydra is similar to Hawk in many respects.
Reference: 14. <author> Paulson, L. </author> <title> Isabelle: A Generic Theorem Prover. </title> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: We now hope to prove that the ROB, RS, and IFU presented here implement the axioms. We hope to use Hawk formally to verify the correctness of microprocessors with a mechanical theorem prover (for example, Isabelle <ref> [14] </ref>). A theorem proving environment for Hawk must have support for manipulating higher-order functions and polymorphic types. 7 Related work Ruby [7] is a specification language based on relations, rather than functions. Relations can describe more circuits than functions. Much of Ruby's emphasis is on circuit layout.
Reference: 15. <author> Peterson, J., and et al. </author> <title> Report on the programming language Haskell: A non-strict, purely functional language, </title> <note> version 1.4. Available at www.haskell.org, Apr. </note> <year> 1997. </year>
Reference-contexts: While today's hardware description languages (HDLs) suffice for simple mi-croarchitectures, the features of modern designs are difficult to specify without a richer language. Hawk is a specification language based on Haskell <ref> [15] </ref> that, for the following reasons, provides a strong foundation for a new generation of HDLs: * Parametric polymorphism allows generic specifications to be used in different contexts. * Type-classes provide a convenient mechanism for abstracting over instruction sets, register sets, and microarchitectural components. * Higher-order functions enable a designer to
References-found: 15

