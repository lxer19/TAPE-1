URL: http://www.cs.wisc.edu/~cs536-1/submissions/129.ps.gz
Refering-URL: 
Root-URL: 
Email: faltjfloriang@cs.uni-sb.de  
Title: Practical Comparison of call string and functional Approach in Data Flow Analysis  
Author: Martin Alt Florian Martin 
Date: October 20, 1995  
Address: P.O. Box 151150, 66041 Saarbrucken,  
Affiliation: Universitat des Saarlandes,  
Abstract: The techniques which are used to implement interprocedural data flow analyzers can be generally divided into two parts: the call string and the functional approach [18]. Both differ in their time and space complexity as well as in the preciseness due to properties of the abstract domains and transfer functions. We have developed a data flow analyzer generator PAG [2] which is able to produce interprocedural analyzers for both techniques. We specified two variants of constant propagation working in an ANSI-C compiler; a copy constant propagation that uses distributive transfer function and can be solved precisely, even interprocedurally [13], and a full constant propagator which includes an interpreter for expressions of the language. We present the practical relevant results applying both analyzers to a rather fair set of real-world programs and compare the space/time consumption of the analyzers versus their preciseness.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martin Alt, Uwe Amann, and Hans van Someren. </author> <title> Cosy Compiler Phase Embedding with the Cosy Compiler Model. </title> <booktitle> In 6th International Conference for Compiler Construction in Edinburgh, volume LNCS786. </booktitle> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: But, for this, the functional analyzers may not terminate for all programs. If we limit the representation size of the abstract functions for a procedure, we do not know which table entries should be combined; an interesting research topic. The (parallel) compilation framework CoSy that has been introduced by <ref> [1] </ref> is perfectly designed for solving our problem. It has several cooperation schemes, including a scheme fastest which implements a runtime competition of algorithms.
Reference: [2] <author> Martin Alt and Florian Martin. </author> <title> Generation of efficient interprocedural analyzers with PAG. In SAS'95, Static Analysis, </title> <publisher> LNCS 983, </publisher> <pages> pages 33-50. </pages> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: These are later used in a normal (intraprocedural-like) algorithm. However, the computation of the abstract functions may not terminate for lattices of infinite cardinality, even if these are of bounded height. We designed and implemented an interprocedural data flow analyzer generator PAG <ref> [2] </ref> , that is able to produce analyzers that use either a fixed call string length or the functional approach. We specified and generated two analyzers, included them in a (production quality) ANSI-C compiler and measured the efficiency and preciseness for practical relevant applications. <p> As we can see, for some programs the functional analyzer behaves best, whereas in some cases it finds no more constants than the C 0 analyzer. So, how do we select an analyzer for incorporation in a real compiler? Using PAG <ref> [2] </ref> that cannot statically determine that copy constant propagation is distributive and can be solved elegantly with other techniques [15], full propagation is not really more expensive but finds, even in real programs, more constants. But, for this, the functional analyzers may not terminate for all programs.
Reference: [3] <author> David Callahan, Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Interprocedural constant propagation. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(7) </volume> <pages> 152-161, </pages> <month> July </month> <year> 1986. </year> <booktitle> Proceedings of the ACM SIGPLAN '86 Symposium on Compiler Construction. </booktitle>
Reference: [4] <author> Anita L. Chow and Andres Rudmik. </author> <title> The design of a data flow analyzer. </title> <journal> SIGPLAN Notices, </journal> <volume> 17(6) </volume> <pages> 106-113, </pages> <month> June </month> <year> 1982. </year> <booktitle> Proceedings of the ACM SIGPLAN '82 Symposium on Compiler Construction. </booktitle>
Reference: [5] <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract interpretation frameworks. </title> <journal> Journal of Logic Computation, </journal> <volume> 2(4) </volume> <pages> 511-547, </pages> <year> 1992. </year>
Reference-contexts: Furthermore, we use a simplified form of a technique called downset completion <ref> [5] </ref>; instead of combining the data flow information directly where two (or more) control flow edges come together, we first apply the transfer function and combine the results: f (a t b) is replaced by f (a) t f (b). This keeps information for non-exact t.
Reference: [6] <author> Patrick Cousot and Nicholas Halbwachs. </author> <title> Automatic discovery of linear restraints among variables of a program. </title> <booktitle> In Conference Record of the Fifth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-96, </pages> <address> Tucson, Arizona, </address> <month> January </month> <year> 1978. </year>
Reference-contexts: We want to test our results for further more sophisticated analyses like different forms of pointer analysis [12] and interval analysis <ref> [6] </ref>.
Reference: [7] <author> Dan Grove and Linda Torczon. </author> <title> Interprocedural constant propagation: A study of jump function implementations. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(6) </volume> <pages> 90-99, </pages> <month> June </month> <year> 1993. </year> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation. </booktitle>
Reference: [8] <author> Suresh Jagannathan and Stephen Weeks. </author> <title> A unified treatment of flow analysis in higher-order languages. </title> <booktitle> In Conference Record of POPL '95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 393-407, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: This results in the super graph in figure 1b. If the underlying lattice L is finite a mapping can be constructed that results in the precise solution of the DFP. Call chains of length up to jLj 2 fl M must be analyzed separately. This approach is related to <ref> [8] </ref>. 2.2 Functional Approach This technique consists of two phases: the first one uses the abstract functions as direct basis for the analysis. <p> may be better in the hot spots of the program. 3 CALL proc ENTRY main RETURN proc EXIT main local local EXIT proc RETURN proc ENTRY proc CALL proc c 2 c 1 proc proc A better measurement for precision is the number of dynamically used optimizations as proposed in <ref> [8] </ref>.
Reference: [9] <author> J.B. Kam and Jeffrey D. Ullman. </author> <title> Monotone data flow analysis frameworks. </title> <journal> Acta Informatica, </journal> <volume> 7 </volume> <pages> 305-317, </pages> <year> 1977. </year>
Reference-contexts: Finally, we give a conclusion. 2 Techniques The data flow analysis practiced nowadays was introduced mainly by [10] and refined by <ref> [9] </ref>. It is based on a control flow graph (CFG=(V,E)) that contains a node for every statement or basic block in a procedure fl Partially funded by the ESPRIT Project #5399 (COMPARE) and SFB 124 1 and an edge for a possible flow of control. <p> Therefore, the minimal fixpoint solution was introduced: MFP (n) = [[s]](?) if n = s F fMFP (m) j m predecessor ng) otherwise If MFP (n) = MOP (n) for all n then the MFP solution is called precise. Kam has proved in <ref> [9] </ref> that for every monotone data flow problem the MFP is greater (with respect to the ordering of the lattice) than the MOP solution, and therefore a save approximation. Moreover, if the DFP is distributive the MFP solution is precise.
Reference: [10] <author> Gary A. Kildall. </author> <title> A unified approach to global program optimization. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 194-206, </pages> <address> Boston, Massachusetts, </address> <month> October </month> <year> 1973. </year>
Reference-contexts: The paper is organized as follows: we briefly introduce the framework for dataflow analysis, discuss the two approaches and give practical measurements by applying these technologies to two different data flow problems. Finally, we give a conclusion. 2 Techniques The data flow analysis practiced nowadays was introduced mainly by <ref> [10] </ref> and refined by [9]. It is based on a control flow graph (CFG=(V,E)) that contains a node for every statement or basic block in a procedure fl Partially funded by the ESPRIT Project #5399 (COMPARE) and SFB 124 1 and an edge for a possible flow of control.
Reference: [11] <author> Jens Knoop and Bernhard Steffen. </author> <title> The interprocedural coincidence theorem. </title> <booktitle> In Proceedings of the 4th International Conference on Compiler Construction (CC'92), </booktitle> <pages> pages 125-140. </pages> <publisher> Springer-Verlag LNCS 641, </publisher> <year> 1992. </year>
Reference-contexts: Moreover, if the DFP is distributive the MFP solution is precise. The interprocedural version of this theorem is presented in <ref> [11] </ref>. 2.1 Call String Approach This approach views procedure calls and returns as ordinary transfers of control, but avoids propagation along interprocedurally invalid paths. This can theoretically be done by tagging the propagated data with a call string, which is a sequence of call nodes, whose calls are still unfinished.
Reference: [12] <author> William Landi and Barbara G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: That lead to the (practical) interesting fact that a (more expensive) functional approach can be replaced by a call string approach, at least for constant propagation in languages similar to C. We want to test our results for further more sophisticated analyses like different forms of pointer analysis <ref> [12] </ref> and interval analysis [6].
Reference: [13] <author> T. Reps M. Sagiv and S. Horwitz. </author> <title> Precise interprocedural dataflow analysis with application to constant propagation. </title> <booktitle> In TAPSOFT'95, Arhus, </booktitle> <address> Denmark, </address> <publisher> LNCS. Springer-Verlag, </publisher> <year> 1995. </year>
Reference: [14] <author> Robert Metzger and Sean Stroud. </author> <title> Interprocedural constant propagation: An empirical study. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 2(1-4):213-232, </volume> <month> March-December </month> <year> 1993. </year>
Reference-contexts: 1 Introduction The need for interprocedural analyses results from a conflict between the goals of software engineering and performance <ref> [14] </ref>. The usage of procedural and functional abstraction generalizes the code and makes it more extensible and maintainable. Optimizing compilers try to compute information about program points that can be used for code improvements.
Reference: [15] <author> Thomas Reps, Susan Horwitz, and Mooly Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In Conference Record of POPL '95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: This keeps information for non-exact t. Furthermore, library calls have been inlined, which result in fewer available constants that other analyzers compute (e.g. <ref> [15] </ref>). The next table shows the structure and size of the used test programs ( a fl indents programs with procedural variables). <p> So, how do we select an analyzer for incorporation in a real compiler? Using PAG [2] that cannot statically determine that copy constant propagation is distributive and can be solved elegantly with other techniques <ref> [15] </ref>, full propagation is not really more expensive but finds, even in real programs, more constants. But, for this, the functional analyzers may not terminate for all programs.
Reference: [16] <author> Barbara G. Ryder. </author> <title> Incremental data flow analysis. </title> <booktitle> In Conference Record of the Tenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 167-176, </pages> <address> Austin, Texas, </address> <month> January </month> <year> 1983. </year>
Reference: [17] <author> G. Sander. </author> <title> Graph layout through the vcg tool. </title> <editor> In R. Tamassia and I.G. Tollis, editors, </editor> <title> Graph Drawing, </title> <booktitle> DIMACS International Workshop GD'94, </booktitle> <pages> pages 194-205. </pages> <publisher> Springer-Verlag LNCS 894, </publisher> <year> 1995. </year>
Reference-contexts: We have determined the best strategy finding all available constants (second column) and the best for source code folding (third column). The results have been visualized with the vcg tool <ref> [17] </ref>. 5 Method Precision Ipc Foldings Steps Time copy constant propagation C 0 1098 1 42 (14) 6289 7,81 C 2 1198 1 44 (16) 21247 37,05 F 1198 1 44 (16) 17664 27,25 full constant propagation C 0 2503 3 50 (18) 6061 6,99 C 2 2763 3 52 (20)
Reference: [18] <author> Micha Sharir and Amir Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In Steven S Muchnick and Neil D Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 7, </volume> <pages> pages 189-233. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Intraprocedural optimization assumes worst case (means loss of all information) at procedure boundaries, whereas interprocedural optimizing compilers propagate information across procedure/function boundaries or eliminates the calls altogether by inline expansions. There exist two different approaches for the interprocedural analysis which have been discussed in <ref> [18] </ref>: the call-string and the functional approach. The call string approach separates call chains (and the related data flow information) to a subroutine up to a fixed length. The preciseness increases with larger call strings and is for non-recursive programs the (maximal) height of the call DAG.
Reference: [19] <author> Steven W. K. Tjiang and John L. Hennessy. </author> <title> Sharlit a tool for building optimizers. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(7) </volume> <pages> 82-93, </pages> <month> July </month> <year> 1992. </year> <booktitle> Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation. </booktitle>
Reference: [20] <author> M. Wegman and K. Zadeck. </author> <title> Constant propagation with conditional branches. </title> <booktitle> In Conference Record of the Twelfth ACM Syposium on Principles of Programming Languages, </booktitle> <pages> pages 291-299, </pages> <month> January </month> <year> 1985. </year> <title> Data Flow Analysis. </title>
Reference-contexts: The ccp only processes assignments of the form x := y; or x := c where x; y are variables and c is a constant, whereas cp includes a full interpreter for expressions. Both analyzers use a conditional propagation <ref> [20] </ref> algorithm. It is technically done by lifting of the underlying lattice and propagation ? to the non-executed paths.
Reference: [21] <author> Mark N. Wegman and F. Kenneth Zadeck. </author> <title> Constant propagation with conditional branches. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 181-210, </pages> <month> April </month> <year> 1991. </year>
Reference: [22] <author> Reinhard Wilhelm and Dieter Maurer. </author> <title> Compiler Design. </title> <booktitle> International Computer Science Series. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1995. </year> <month> 10 </month>
References-found: 22

