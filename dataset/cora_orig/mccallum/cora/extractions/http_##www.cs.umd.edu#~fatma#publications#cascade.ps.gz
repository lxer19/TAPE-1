URL: http://www.cs.umd.edu/~fatma/publications/cascade.ps.gz
Refering-URL: http://www.cs.umd.edu/~fatma/publications.html
Root-URL: 
Email: email: asuman@srdc.metu.edu.tr  
Title: A Region Based Query Optimizer Through Cascades Query Optimizer Framework  
Author: Fatma Ozcan Sena Nural Pinar Koksal Mehmet Altinel Asuman Dogac 
Address: 06531, Ankara Turkiye  
Affiliation: Software Research and Development Center of TUBITAK Dept. of Computer Engineering Middle East Technical University  
Abstract: The Cascades Query Optimizer Framework is a tool to help the database implementor (DBI) in constructing a query optimizer for a DBMS. It is data model independent and allows to code a query optimizer by providing the implementations of the subclasses of predefined interface classes. When the implementations of the required classes are provided properly, the generated optimizer produces the optimum execution plans for the queries. Although providing the complete set of rules and thus finding the optimum execution plans are beneficial for most of the queries, the query optimization time increases unacceptably for certain types of queries, e.g., for star queries. Hence it is important to be able to limit the number of alternative plans considered by the optimizer for specific types of queries by using the proper heuristics for each type. This leads to the concept of region based query optimization, where different types of queries are optimized by using different search strategies in each region. This paper describes our experiences in developing a region based query optimizer through Cascades. Cascades' guidance structures provide the facilities required for the design and implementation of a region based optimizer. The performance comparisons between a region based query optimizer and an exhaustive (which uses the complete rule set without heuristic guidance) query optimizer, both generated through Cascades, indicate that the region based optimizer has a superior performance. In the performance analysis, both the sum of optimization and execution times, namely the response time, and the quality of the plans generated are investigated.
Abstract-found: 1
Intro-found: 1
Reference: [BMG 93] <author> Blakeley, J. A., McKenna, W. J., Graefe, G., </author> <title> "Experiences Building the Open OODB Query Optimizer", </title> <booktitle> Proc. of the ACM SIGMOD Conf., </booktitle> <year> 1993. </year>
Reference-contexts: In this paper, we describe our experiences in developing the region based query optimizer through Cascades. The rule set used <ref> [BMG 93] </ref> is provided in the Appendix. These rules are sufficient to optimize both relational and object-oriented queries. The performance comparisons between a region based query optimizer and an exhaustive query optimizer, both generated through Cascades, indicate that the region based optimizer has a superior performance. <p> if guidance.region is star regionf find the subquery with the minimum cost modify memo () //update "memo" structure such that the subquery with the minimum cost is joined with other subqueries g return plan g 4.2 Select Region In the complete rule set of the optimizer given in the Appendix <ref> [BMG 93] </ref>, there are many rules for select classes (Rules 1,2,3,4,5,6,7,10,15,16). It has been observed that these transformations increase the optimization time a lot for queries with many select predicates. We have further noted that some of these rules can be disabled by using effective heuristics instead.
Reference: [DAOD 95] <author> Dogac, A., Altinel, M., Ozkan, C., Durusoy, I., </author> <title> "Implementation Aspects of an Object-Oriented DBMS", </title> <booktitle> in ACM SIGMOD Record, </booktitle> <address> Vol.24, No.1, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: In Cascades, this represents the worst case that happens when there is no heuristic guidance. The work presented in this paper has evolved through our experiences in developing a query optimizer for METU Object-Oriented DBMS (MOOD) <ref> [DAOD 95, Dog 95] </ref>. MOOD query optimizer [Dur 94] is developed through Volcano by using the full set of rules. Experiments with MOOD optimizer revealed the fact that the optimizer took unacceptably long for certain queries.
Reference: [Dog 95] <author> Dogac, A., Altinel, M., Ozkan, C., Durusoy, I., Altintas, I., </author> <title> "METU Object-Oriented DBMS Kernel", </title> <booktitle> 6th International Conference on Database and Expert Systems Applications, London, September 1995 (Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag 1995). </publisher>
Reference-contexts: In Cascades, this represents the worst case that happens when there is no heuristic guidance. The work presented in this paper has evolved through our experiences in developing a query optimizer for METU Object-Oriented DBMS (MOOD) <ref> [DAOD 95, Dog 95] </ref>. MOOD query optimizer [Dur 94] is developed through Volcano by using the full set of rules. Experiments with MOOD optimizer revealed the fact that the optimizer took unacceptably long for certain queries.
Reference: [Dur 94] <author> Durusoy, I., </author> <title> "MOOD Query Optimizer", M.Sc. </title> <type> Thesis, </type> <institution> Dept. of Computer Eng., Middle East Technical University, Ankara, Turkey, </institution> <year> 1994. </year>
Reference-contexts: In Cascades, this represents the worst case that happens when there is no heuristic guidance. The work presented in this paper has evolved through our experiences in developing a query optimizer for METU Object-Oriented DBMS (MOOD) [DAOD 95, Dog 95]. MOOD query optimizer <ref> [Dur 94] </ref> is developed through Volcano by using the full set of rules. Experiments with MOOD optimizer revealed the fact that the optimizer took unacceptably long for certain queries.
Reference: [Frey 87] <author> Freytag, </author> <title> J.C., "A Rule-based View of Query Optimization", in Pr oc. </title> <booktitle> of ACM SIGMOD Conf., </booktitle> <year> 1987. </year>
Reference-contexts: Furthermore, Cascades provides facilities for incorporating heuristic guidance to the optimizer. These features of Cascades make it a very attractive tool for developing query optimizers. One of the earliest efforts in developing a tool for query optimization with minimal assumption on the data model is given in <ref> [Frey 87] </ref> where a rule-based description of generating equivalent query execution plans from an initial query specification is proposed. The EXODUS project of [GD 87] focuses on how to include rules into an architecture of an optimizer generator.
Reference: [GD 87] <author> Greafe, G., DeWitt, D. J., </author> <title> "The EXODUS Optimizer Generator", </title> <booktitle> in Proc. of ACM SIGMOD Conf., </booktitle> <year> 1987. </year>
Reference-contexts: One of the earliest efforts in developing a tool for query optimization with minimal assumption on the data model is given in [Frey 87] where a rule-based description of generating equivalent query execution plans from an initial query specification is proposed. The EXODUS project of <ref> [GD 87] </ref> focuses on how to include rules into an architecture of an optimizer generator. The concepts used in EXODUS optimizer generator are, data model description as input file, rules to specify alternatives, compilation of rules into source code and separation of logical and physical operators.
Reference: [GM 93] <author> Greafe, G., McKenna, J. W., </author> <title> "The Volcano Optimizer Generator:Extensibility and Efficient Search", </title> <booktitle> Proc. IEEE Conf. on Data Eng., </booktitle> <address> Vienna Austria,1993. </address>
Reference-contexts: The drawback of the EXODUS query optimizer is the inefficiency and the ineffectiveness of its search strategy [Gra 94]. Another effort in this respect is the Volcano Query Optimizer Generator <ref> [McK 93, GM 93] </ref>. Volcano provides an efficient search engine based on dynamic programming and memoization. However, the Volcano technique generates all equivalent logical expressions in the first phase. 1 Even if the actual optimization phase uses a greedy search algorithm, this first phase in Volcano must still be exhaustive.
Reference: [Gra 94] <author> Graefe, </author> <title> G.,"Query Optimization in the Cascades Project", </title> <type> unpublished manuscript, </type> <year> 1994. </year>
Reference-contexts: 1 Introduction The Cascades Query Optimizer Framework <ref> [Gra 94] </ref>, which is being used in Microsoft's forthcoming SQL Server and Access query optimizers as well as Tandem's NonStop SQL product, is a tool to help the database implementor (DBI) in constructing a query optimizer for a DBMS. <p> The concepts used in EXODUS optimizer generator are, data model description as input file, rules to specify alternatives, compilation of rules into source code and separation of logical and physical operators. The drawback of the EXODUS query optimizer is the inefficiency and the ineffectiveness of its search strategy <ref> [Gra 94] </ref>. Another effort in this respect is the Volcano Query Optimizer Generator [McK 93, GM 93]. Volcano provides an efficient search engine based on dynamic programming and memoization. <p> Each of these productions produce a set of alternative plans, each having a vector of properties, including the estimated cost. In addition, productions can require certain properties of their inputs, such as sortedness. 3 Cascades Query Optimizer Framework In Cascades <ref> [Gra 94] </ref>, the optimization algorithm is broken into several parts, which are called tasks. A task is realized as an object and a task object exists for each task that has yet to be done. All the tasks are collected in a task structure, a last-in-first-out stack.
Reference: [HFLP 89] <author> Haas, L.M.,Freytag, J.C.,Lohman, G.M.,Pinaresh, H., </author> <title> "Extensible Query Processing in Starburst", </title> <booktitle> in proceedings of ACM SIGMOD Conf., </booktitle> <year> 1989 </year>
Reference-contexts: The regions define, through their interface, the characteristics of queries they can process, goals for the transformation of queries, and the characteristics of result queries. A higher level control uses this information to plan a sequence of region executions to process a given query expression. 2 In <ref> [Loh 88, HFLP 89] </ref>, in the framework of the extensible query processing in Starburst, productions of a grammar are used to define query execution plan alternatives.
Reference: [IK 84] <author> Iberaki, T., and Kameda, T., </author> <title> "On the Optimal Nesting Order for Computing N-Relational Joins", </title> <journal> ACM Transitions on Database Systems, </journal> <volume> Vol. 9, No. 3, </volume> <year> 1984. </year>
Reference-contexts: Section 5 presents the performance comparisons between a region based query optimizer and an exhaustive query optimizer, both generated through Cascades. Finally, Section 6 contains the conclusions. 2 Related Work We begin by noting that some instances of the query optimization problem are NP-complete <ref> [IK 84] </ref>. In [OL 90], it is shown that the complexity of optimizing the order of join operations is dependent upon the shape of the query. The shape of the query indicates how tables are connected with predicates.
Reference: [Kok 95] <author> Koksal, P., </author> <title> "Design and Implementation of a Region Based Query Optimizer for Object-Oriented DBMSs", M.Sc. </title> <type> Thesis, </type> <institution> Dept. of Computer Eng., Middle East Technical University, Ankara, Turkey, </institution> <year> 1995. </year>
Reference-contexts: Note that this is an initial step towards the region based optimization described in [Mit 93]. We then developed such a region based optimizer through Volcano <ref> [Kok 95] </ref>. However, since it is not possible to add new control strategies to the Volcano search engine, we had to introduce outside control over the Volcano, which in turn reduced the effectiveness of the approach.
Reference: [Loh 88] <author> Lohman, G.M., </author> <title> "Grammar-like Functional Rules for Representing Query Optimization Alternatives", </title> <booktitle> in proceedings of ACM SIGMOD Conf., </booktitle> <year> 1988 </year>
Reference-contexts: The regions define, through their interface, the characteristics of queries they can process, goals for the transformation of queries, and the characteristics of result queries. A higher level control uses this information to plan a sequence of region executions to process a given query expression. 2 In <ref> [Loh 88, HFLP 89] </ref>, in the framework of the extensible query processing in Starburst, productions of a grammar are used to define query execution plan alternatives.
Reference: [McK 93] <author> McKenna, W.J., </author> <title> "Efficient Search in Extensible Database Query Optimization: The Volcano Optimizer Generator", </title> <type> Ph. D. Thesis, </type> <institution> Univ. of Colorado, </institution> <year> 1993. </year>
Reference-contexts: The drawback of the EXODUS query optimizer is the inefficiency and the ineffectiveness of its search strategy [Gra 94]. Another effort in this respect is the Volcano Query Optimizer Generator <ref> [McK 93, GM 93] </ref>. Volcano provides an efficient search engine based on dynamic programming and memoization. However, the Volcano technique generates all equivalent logical expressions in the first phase. 1 Even if the actual optimization phase uses a greedy search algorithm, this first phase in Volcano must still be exhaustive.
Reference: [MDZ 93] <author> Mitchell, G., Dayal, U., and Zdonik, B.S., </author> <title> "Control of an Extensible Query Optimizer: A Planning-Based Approach", </title> <booktitle> Proc. of Intl. Conf. on Very Large Databases, </booktitle> <year> 1993. </year>
Reference-contexts: Yet, certain other types of queries might benefit a lot from considering all possible plans. The space of alternative plans must therefore be adjustable for each type of query. This leads to the concept of region based query optimization. In <ref> [Mit 93, MZD 92, MDZ 93, MDZ 94] </ref> an architecture for region based extensible processing and optimization of queries is proposed. An Epoq optimizer is a collection of concurrently available region modules, each of which embodies one strategy for the optimization of query expressions.
Reference: [MDZ 94] <author> Mitchell, G., Dayal, U., and Zdonik, B.S., </author> <title> "Optimization of Object-Oriented Queries: Problems and Approaches", </title> <booktitle> in Advances in Object-Oriented Database Systems, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Yet, certain other types of queries might benefit a lot from considering all possible plans. The space of alternative plans must therefore be adjustable for each type of query. This leads to the concept of region based query optimization. In <ref> [Mit 93, MZD 92, MDZ 93, MDZ 94] </ref> an architecture for region based extensible processing and optimization of queries is proposed. An Epoq optimizer is a collection of concurrently available region modules, each of which embodies one strategy for the optimization of query expressions.
Reference: [Mit 93] <author> Mitchell, G., </author> <title> "Extensible Query Processing in an Object-Oriented Database" PhD thesis, </title> <institution> Brown University, </institution> <year> 1993. </year>
Reference-contexts: We have identified three types of queries to be optimized with three different strategies and implemented each strategy in a region without any interaction among the regions. Note that this is an initial step towards the region based optimization described in <ref> [Mit 93] </ref>. We then developed such a region based optimizer through Volcano [Kok 95]. However, since it is not possible to add new control strategies to the Volcano search engine, we had to introduce outside control over the Volcano, which in turn reduced the effectiveness of the approach. <p> Yet, certain other types of queries might benefit a lot from considering all possible plans. The space of alternative plans must therefore be adjustable for each type of query. This leads to the concept of region based query optimization. In <ref> [Mit 93, MZD 92, MDZ 93, MDZ 94] </ref> an architecture for region based extensible processing and optimization of queries is proposed. An Epoq optimizer is a collection of concurrently available region modules, each of which embodies one strategy for the optimization of query expressions.
Reference: [MZD 92] <author> Mitchell, G., Zdonik, S., and Dayal, U., </author> <title> "An Architecture for Query Processing in Persistent Object Stores", </title> <booktitle> Proc. of the Hawaii Intl. Conf. on System Sciences, </booktitle> <year> 1992. </year>
Reference-contexts: Yet, certain other types of queries might benefit a lot from considering all possible plans. The space of alternative plans must therefore be adjustable for each type of query. This leads to the concept of region based query optimization. In <ref> [Mit 93, MZD 92, MDZ 93, MDZ 94] </ref> an architecture for region based extensible processing and optimization of queries is proposed. An Epoq optimizer is a collection of concurrently available region modules, each of which embodies one strategy for the optimization of query expressions.
Reference: [ODE 95] <author> Ozkan, C., Dogac, A., Evrendilek, C., </author> <title> "A Heuristic Approach for Optimization of Path Expressions in Object-Oriented Query Languages", </title> <booktitle> 6th International Conference on Database and Expert Systems Applications, London, September 1995 (Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag 1995). </publisher>
Reference-contexts: Yet, not only the size of a partial result of a join, but join selectivity also affects the order of joins. We have developed another heuristic to consider join selectivity and join cost together which is not described in this paper due to 4 space limitations, <ref> [ODE 95] </ref>. In star region, each linear subquery of a given query, (shown with dotted lines in Figure 2) is thought as a unit of processing and optimization of this linear part with associativity and commutativity of join rules enabled (Rules 8,9), takes polynomial time.
Reference: [OL 90] <author> Ono, K., Lohman, G. M., </author> <title> "Measuring the Complexity of Join Enumeration in Query Optimization", </title> <booktitle> Proc. of Intl. Conf. on Very Large Databases, </booktitle> <year> 1990. </year> <month> 10 </month>
Reference-contexts: Section 5 presents the performance comparisons between a region based query optimizer and an exhaustive query optimizer, both generated through Cascades. Finally, Section 6 contains the conclusions. 2 Related Work We begin by noting that some instances of the query optimization problem are NP-complete [IK 84]. In <ref> [OL 90] </ref>, it is shown that the complexity of optimizing the order of join operations is dependent upon the shape of the query. The shape of the query indicates how tables are connected with predicates. <p> If the composite inners are not considered the complexity reduces to (N-1) 2 . On the other hand, using dynamic programming to optimize a star query with N quantifiers requires evaluating (N-1)2 N2 feasible joins <ref> [OL 90] </ref>. This study indicates that it is not feasible to consider all possible alternative plans for star queries. Yet, certain other types of queries might benefit a lot from considering all possible plans. The space of alternative plans must therefore be adjustable for each type of query.
References-found: 19

