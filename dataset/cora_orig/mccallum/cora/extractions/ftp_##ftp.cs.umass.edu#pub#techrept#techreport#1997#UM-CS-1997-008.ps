URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1997/UM-CS-1997-008.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/97-008.html
Root-URL: 
Email: email: fnaumovicjavruninjclarkejljog@cs.umass.edu  
Title: Applying Static Analysis to Software Architectures  
Author: Gleb Naumovich, George S. Avrunin, Lori A. Clarke and Leon J. Osterweil 
Address: Amherst, Massachusetts 01003  
Affiliation: Laboratory for Advanced Software Engineering Research Computer Science Department University of Massachusetts  
Abstract: In this paper we demonstrate how static concurrency analysis techniques can be used to verify application-specific properties of an architectural description. Specifically, we use two concurrency analysis tools, INCA, a flow equation based tool, and FLAVERS, a data flow analysis based tool, to detect errors or prove properties of a Wright architectural description of the gas station problem. Although both these tools are research prototypes, they illustrate the potential of static analysis for verifying that architectural descriptions adhere to important properties, for detecting problems early in the lifecycle, and for helping developers understand the changes that need to be made to satisfy the properties being analyzed.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Allen and D. Garlan. </author> <title> Formalizing architectural connection. </title> <booktitle> In Proceedings of the 14 th International Conference on Software Engineering, </booktitle> <pages> pages 71-80, </pages> <month> may </month> <year> 1994. </year>
Reference-contexts: Another validation approach that has been explored is the use of static analysis techniques to verify general properties 1 of architectural descriptions. When successful, this type of analysis does verify that all possible executions conform to the specification. Allen and Garlan <ref> [1] </ref> use the static analysis tool FDR [7] to prove freedom from deadlock as well as compatibility between the components and connectors in an architectural description. These are general properties that are desirable for all architectural descriptions.
Reference: [2] <author> R. Allen and D. Garlan. </author> <title> The wright architectural specification language. </title> <type> Technical Report CMU-CS96-TBD, </type> <institution> Carnegie Melon University, School of Computer Science, </institution> <year> 1996. </year>
Reference-contexts: Architectural description languages combined with appropriate analysis tools could therefore be an important means for reducing costs and improving reliability. A number of architectural description languages have been proposed, such as Wright <ref> [2] </ref>, Rapide [13], Darwin [14, 15], and UniCon [19]. There has also been some work on validating aspects of architectural designs. Using architectures specified in UniCon, for instance, developers can estimate local timing information and use those estimates to check time-dependent properties with the RMA real-time analysis tool [12].
Reference: [3] <author> B. W. Boehm. </author> <title> Software and Its Impact: A Qualitative Assessment. </title> <journal> Datamation, </journal> <pages> pages 48-59, </pages> <month> May </month> <year> 1973. </year>
Reference-contexts: It has been demonstrated that detecting errors early in the lifecycle <ref> [3] </ref> greatly reduces the cost of fixing those errors. Architectural description languages combined with appropriate analysis tools could therefore be an important means for reducing costs and improving reliability. A number of architectural description languages have been proposed, such as Wright [2], Rapide [13], Darwin [14, 15], and UniCon [19].
Reference: [4] <author> J. Burch, E. Clarke, K. McMillan, D. Dill, and L. Hwang. </author> <title> Symbolic Model Checking: 10 20 States and Beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: Section 5 summarizes the overall results, describes the benefits of this approach, and points out some interesting directions for future research. 2 Tools Used A number of automated static concurrency analysis techniques have been proposed. They span such approaches as reachability analysis (e.g. [11, 20, 8]), symbolic model checking <ref> [4, 17] </ref>, flow equations [5], and data flow analysis [6, 16]. The goal of this work is to demonstrate the applicability of static analysis techniques to architecture descriptions but not, at least at this point in time, to determine which approach might be best.
Reference: [5] <author> J. C. Corbett and G. S. Avrunin. </author> <title> Using integer programming to verify general safety and liveness properties. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 6 </volume> <pages> 97-123, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: They span such approaches as reachability analysis (e.g. [11, 20, 8]), symbolic model checking [4, 17], flow equations <ref> [5] </ref>, and data flow analysis [6, 16]. The goal of this work is to demonstrate the applicability of static analysis techniques to architecture descriptions but not, at least at this point in time, to determine which approach might be best. <p> Thus, we selected two different static analysis tools, based on fundamentally different approaches but on which we have considerable expertise. One tool, INCA <ref> [5] </ref>, is based on flow equations, and the other, FLAVERS [6], is based on data flow analysis. Both these tools can be used to check whether all executions of a concurrent system satisfy a property, such as the mutually exclusive use of some resource.
Reference: [6] <author> M. Dwyer and L. Clarke. </author> <title> Data Flow Analysis for Verifying Properties of Concurrent Programs,. </title> <booktitle> In ACM SIGSOFT'94 Software Engineering Notes, Proceedings of the Second ACM Sigsoft Symposium on Foundations of Software Engineering, v. </booktitle> <volume> 19, </volume> <editor> n. </editor> <volume> 5, </volume> <pages> pages 62-75, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: They span such approaches as reachability analysis (e.g. [11, 20, 8]), symbolic model checking [4, 17], flow equations [5], and data flow analysis <ref> [6, 16] </ref>. The goal of this work is to demonstrate the applicability of static analysis techniques to architecture descriptions but not, at least at this point in time, to determine which approach might be best. <p> Thus, we selected two different static analysis tools, based on fundamentally different approaches but on which we have considerable expertise. One tool, INCA [5], is based on flow equations, and the other, FLAVERS <ref> [6] </ref>, is based on data flow analysis. Both these tools can be used to check whether all executions of a concurrent system satisfy a property, such as the mutually exclusive use of some resource.
Reference: [7] <institution> Formal Systems (Europe) Ltd., </institution> <address> Oxford, England. </address> <booktitle> Failures Divergence Refinement: User Manual and Tutorial. </booktitle> <address> 1.2fi, </address> <year> 1992. </year>
Reference-contexts: Another validation approach that has been explored is the use of static analysis techniques to verify general properties 1 of architectural descriptions. When successful, this type of analysis does verify that all possible executions conform to the specification. Allen and Garlan [1] use the static analysis tool FDR <ref> [7] </ref> to prove freedom from deadlock as well as compatibility between the components and connectors in an architectural description. These are general properties that are desirable for all architectural descriptions.
Reference: [8] <author> P. Godefroid and P. Wolper. </author> <title> Using partial orders for the efficient verification of deadlock freedom and safety properties. </title> <booktitle> In Proceedings of the Third Workshop on Computer Aided Verification, </booktitle> <pages> pages 417-428, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Section 5 summarizes the overall results, describes the benefits of this approach, and points out some interesting directions for future research. 2 Tools Used A number of automated static concurrency analysis techniques have been proposed. They span such approaches as reachability analysis (e.g. <ref> [11, 20, 8] </ref>), symbolic model checking [4, 17], flow equations [5], and data flow analysis [6, 16]. The goal of this work is to demonstrate the applicability of static analysis techniques to architecture descriptions but not, at least at this point in time, to determine which approach might be best.
Reference: [9] <author> D. Helmbold and D. Luckham. </author> <title> Debugging Ada tasking programs. </title> <journal> IEEE Software, </journal> <volume> 2(2) </volume> <pages> 47-57, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: Because of this and our expertise with these tools, we chose them for our initial exploration of analyzing application-specific properties of architectures. 3 Architectural Specification of the Gas Station Example The Gas Station system <ref> [9] </ref> models a self-serve gas station. This example has been widely studied by the static analysis research community. It has also been used in the software architecture community, and was the example provided to us by Garlan.
Reference: [10] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: A system specification is composed of a set of component and connector type definitions, as described above, a set of instantiations of specific objects of these types, and attachments. Attachments specify which components are linked to which connectors. Wright uses CSP <ref> [10] </ref> to describe the behavior of roles ports, computations, and glues. <p>- 3 Component Customer Port Pay = pay!x ! Pay Port Gas = take ! pump?x ! Gas Computation = Pay.pay!x ! Gas.take ! Gas.pump?x ! Computation Component Cashier Port Customer1 = pay?x ! Customer1 Port Customer2 = pay?x !
Reference: [11] <author> G. J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall Software Series, </publisher> <year> 1991. </year>
Reference-contexts: Section 5 summarizes the overall results, describes the benefits of this approach, and points out some interesting directions for future research. 2 Tools Used A number of automated static concurrency analysis techniques have been proposed. They span such approaches as reachability analysis (e.g. <ref> [11, 20, 8] </ref>), symbolic model checking [4, 17], flow equations [5], and data flow analysis [6, 16]. The goal of this work is to demonstrate the applicability of static analysis techniques to architecture descriptions but not, at least at this point in time, to determine which approach might be best. <p> Similarly, other static analysis tools capable of formulating and checking application-specific properties, such as SPIN <ref> [11] </ref> or SMV [17] could be used with architectural specifications. The static analysis tools automate the checking of properties, but it is still up to the system architect to formulate those properties. As always, this is not straightforward and has to be done carefully.
Reference: [12] <author> M. H. Klein, T. Ralya, B. Pollak, R. Obenza, and M. Harobur. </author> <title> A Practitioner's Handbook for Real-Time Analysis: Guide to Rate Monotonic Analysis for Real-Time Systems. </title> <address> New York: Kluwer-Academic, </address> <year> 1993. </year>
Reference-contexts: There has also been some work on validating aspects of architectural designs. Using architectures specified in UniCon, for instance, developers can estimate local timing information and use those estimates to check time-dependent properties with the RMA real-time analysis tool <ref> [12] </ref>. Another approach is to use model-theoretic proof techniques use model-theoretic proof techniques to verify conformance of elaborated architecture descriptions to higher-level architectural designs [14, 18].
Reference: [13] <author> D. C. Luckham, L. M. Augustin, J. J. Kenney, J. Veera, D. Bryan, and W. Mann. </author> <title> Specification analysis of system architectura using Rapide. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 336-355, </pages> <month> april </month> <year> 1995. </year>
Reference-contexts: Architectural description languages combined with appropriate analysis tools could therefore be an important means for reducing costs and improving reliability. A number of architectural description languages have been proposed, such as Wright [2], Rapide <ref> [13] </ref>, Darwin [14, 15], and UniCon [19]. There has also been some work on validating aspects of architectural designs. Using architectures specified in UniCon, for instance, developers can estimate local timing information and use those estimates to check time-dependent properties with the RMA real-time analysis tool [12]. <p> Developers using the Rapide architectural description language can simulate executions of the system and verify that the traces of those executions conform to high-level specifications of the desired behavior <ref> [13] </ref>. Although one would expect the number of traces through an architectural description to be much less than the number of possible executions in the corresponding software system, for most interesting systems there are far too many such traces to explore them all.
Reference: [14] <author> J. Magee, N. Dulay, S. Eisenbach, and J. Kramer. </author> <title> Specifying distributed software architectures. </title> <booktitle> In Proceedings of 5th European Software Engineering Conference, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: Architectural description languages combined with appropriate analysis tools could therefore be an important means for reducing costs and improving reliability. A number of architectural description languages have been proposed, such as Wright [2], Rapide [13], Darwin <ref> [14, 15] </ref>, and UniCon [19]. There has also been some work on validating aspects of architectural designs. Using architectures specified in UniCon, for instance, developers can estimate local timing information and use those estimates to check time-dependent properties with the RMA real-time analysis tool [12]. <p> Another approach is to use model-theoretic proof techniques use model-theoretic proof techniques to verify conformance of elaborated architecture descriptions to higher-level architectural designs <ref> [14, 18] </ref>. Developers using the Rapide architectural description language can simulate executions of the system and verify that the traces of those executions conform to high-level specifications of the desired behavior [13].
Reference: [15] <author> J. Magee and J. Kramer. </author> <title> Dynamic structure in software architectures. </title> <booktitle> In Proceedings of the 4th ACM SIGSOFT symposium on the Foundations of Software Engineering, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Architectural description languages combined with appropriate analysis tools could therefore be an important means for reducing costs and improving reliability. A number of architectural description languages have been proposed, such as Wright [2], Rapide [13], Darwin <ref> [14, 15] </ref>, and UniCon [19]. There has also been some work on validating aspects of architectural designs. Using architectures specified in UniCon, for instance, developers can estimate local timing information and use those estimates to check time-dependent properties with the RMA real-time analysis tool [12].
Reference: [16] <author> S. Masticola and B. Ryder. </author> <title> A Model of Ada Programs for Static Deadlock Detection in Polynomial Time. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 97-107. </pages> <publisher> ACM, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: They span such approaches as reachability analysis (e.g. [11, 20, 8]), symbolic model checking [4, 17], flow equations [5], and data flow analysis <ref> [6, 16] </ref>. The goal of this work is to demonstrate the applicability of static analysis techniques to architecture descriptions but not, at least at this point in time, to determine which approach might be best.
Reference: [17] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1993. </year>
Reference-contexts: Section 5 summarizes the overall results, describes the benefits of this approach, and points out some interesting directions for future research. 2 Tools Used A number of automated static concurrency analysis techniques have been proposed. They span such approaches as reachability analysis (e.g. [11, 20, 8]), symbolic model checking <ref> [4, 17] </ref>, flow equations [5], and data flow analysis [6, 16]. The goal of this work is to demonstrate the applicability of static analysis techniques to architecture descriptions but not, at least at this point in time, to determine which approach might be best. <p> Similarly, other static analysis tools capable of formulating and checking application-specific properties, such as SPIN [11] or SMV <ref> [17] </ref> could be used with architectural specifications. The static analysis tools automate the checking of properties, but it is still up to the system architect to formulate those properties. As always, this is not straightforward and has to be done carefully.
Reference: [18] <author> M. Moriconi, X. Qian, and R. A. Riemenschneider. </author> <title> Correct architecture refinement. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 356-372, </pages> <month> april </month> <year> 1995. </year>
Reference-contexts: Another approach is to use model-theoretic proof techniques use model-theoretic proof techniques to verify conformance of elaborated architecture descriptions to higher-level architectural designs <ref> [14, 18] </ref>. Developers using the Rapide architectural description language can simulate executions of the system and verify that the traces of those executions conform to high-level specifications of the desired behavior [13].
Reference: [19] <author> M. Shaw, R. DeLine, D. V. Klein, T. L. Ross, D. M. Young, and G. Zelesnik. </author> <title> Abstractions for software architecture and tools to support them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 314-335, </pages> <month> april </month> <year> 1995. </year>
Reference-contexts: Architectural description languages combined with appropriate analysis tools could therefore be an important means for reducing costs and improving reliability. A number of architectural description languages have been proposed, such as Wright [2], Rapide [13], Darwin [14, 15], and UniCon <ref> [19] </ref>. There has also been some work on validating aspects of architectural designs. Using architectures specified in UniCon, for instance, developers can estimate local timing information and use those estimates to check time-dependent properties with the RMA real-time analysis tool [12].
Reference: [20] <author> A. Valmari. </author> <title> A Stubborn Attack on State Explosion. </title> <editor> In E. M. Clarke and R. Kurshan, editors, </editor> <booktitle> ComputerAided Verification 90, </booktitle> <pages> pages 25-41. </pages> <publisher> American Mathematical Society, </publisher> <address> Providence RI, </address> <year> 1991. </year> <booktitle> Number 3 in DIMACS Series in Discrete Mathematics and Theoretical Computer Science. </booktitle> <pages> 13 </pages>
Reference-contexts: Section 5 summarizes the overall results, describes the benefits of this approach, and points out some interesting directions for future research. 2 Tools Used A number of automated static concurrency analysis techniques have been proposed. They span such approaches as reachability analysis (e.g. <ref> [11, 20, 8] </ref>), symbolic model checking [4, 17], flow equations [5], and data flow analysis [6, 16]. The goal of this work is to demonstrate the applicability of static analysis techniques to architecture descriptions but not, at least at this point in time, to determine which approach might be best.
References-found: 20

