URL: http://www.cs.berkeley.edu/~yelick/jjones/phylo-super95.ps
Refering-URL: http://www.cs.berkeley.edu/~yelick/papers.html
Root-URL: 
Title: Parallelizing the Phylogeny Problem  
Author: Jeff A. Jones Katherine A. Yelick 
Address: Berkeley  
Affiliation: Computer Science Division University of California,  
Note: Draft Final version to appear in the proceedings of the Supercomputing '95.  64-processor CM-5.  
Abstract: The problem of determining the evolutionary history of species in the form of phyloge-netic trees is known as the phylogeny problem. We present a parallelization of the character compatibility method for solving the phylogeny problem. Abstractly, the algorithm searches through all subsets of characters, which may be traits like opposable thumbs or DNA sequence values, looking for a maximal consistent subset. The notion of consistency in this case is the existence of a particular kind of phylogenetic tree called a perfect phylogeny tree. The two challenges to achieving an efficient implementation are load balancing and efficient sharing of information to enable pruning. In both cases, there is a trade-off between communication overhead and the quality of the solution. For load balancing we use a distributed task queue, which has imperfect load information but avoids centralization bottlenecks. To prune the search space, we use the following property: If a perfect phylogeny tree does not exist for some set of characters, then none exists for any superset of that set. This is implemented by searching the power set starting with the smallest sets, and storing failures in an efficient distributed trie. The resulting program shows speedups of 50 on a 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agarwala and D. Fernandez-Baca. </author> <title> A polynomial-time algorithm for the perfect phylogeny problem when the number of character states is fixed. </title> <booktitle> In Proceedings of the 34th Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pp. 140-147, </pages> <year> 1993. </year>
Reference-contexts: The characters can be skeletal structures, coloring, or other physical characteristics. More often, the characters are elements of molecular sequences. We represent a species u with a vector of character values, u <ref> [1] </ref>; : : : ; u [c max ], where c max is the number of characters to be considered. In the case of molecular sequences, each element of this vector is a nucleotide or amino acid. <p> In contrast, trees b and c are perfect phylogenies because they satisfy the three conditions of the definition. Notice that the perfect phylogeny for a given set of species may not be unique. Also, tree c contains the species <ref> [1; 1; 3] </ref>, which was not a member of the original set. The tree is still a perfect phylogeny, however, because each leaf appears in the original set. <p> If one of the maximal subsets is sufficiently large, the corresponding perfect phylogeny will be a good estimate of the evolutionary history of the species. To determine compatibility, we use the algorithm of Agarwala and Fernandez-Baca <ref> [1] </ref>, modified according to a suggestion of Lawler [9], as described in our previous work [8]. Examining all possible subsets (an exponential number) in turn is extremely time-consuming, however. <p> The implementation is, we believe, the fastest implementation of the character compatibility problem. The sequential algorithm for solving the perfect phylogeny problem tasks is due to Agarwala and Fernandez-Baca <ref> [1] </ref>, with an improvement suggested by Lawler [9]. Using the full character compatibility application, we were able to solve problems with 60 characters in a few minutes, demonstrating speedups of 50 on 64 processors.
Reference: [2] <author> H. Bodlaender, M. Fellows, and T. Warnow. </author> <title> Two strikes against perfect phylogeny. </title> <booktitle> In Proceedings of the 19th International Colloquium on Automata, Languages, and Programming, </booktitle> <pages> pp. 273-283, </pages> <note> Springer-Verlag, Lecture Notes in Computer Science, </note> <year> 1992. </year>
Reference-contexts: Each character takes on one of up to 4 possible values. Tree a is not a perfect phylogeny because it violates condition 3 in the definition: u <ref> [2] </ref> = w [2], but v [2] 6= u [2]. To make the example more concrete, consider u and w to be species with opposable thumbs, and v to be a species without this trait. <p> Each character takes on one of up to 4 possible values. Tree a is not a perfect phylogeny because it violates condition 3 in the definition: u <ref> [2] </ref> = w [2], but v [2] 6= u [2]. To make the example more concrete, consider u and w to be species with opposable thumbs, and v to be a species without this trait. <p> Each character takes on one of up to 4 possible values. Tree a is not a perfect phylogeny because it violates condition 3 in the definition: u <ref> [2] </ref> = w [2], but v [2] 6= u [2]. To make the example more concrete, consider u and w to be species with opposable thumbs, and v to be a species without this trait. Tree a is not a valid phylogeny because, in some evolutionary path, opposable thumbs were lost and then reappeared. <p> Each character takes on one of up to 4 possible values. Tree a is not a perfect phylogeny because it violates condition 3 in the definition: u <ref> [2] </ref> = w [2], but v [2] 6= u [2]. To make the example more concrete, consider u and w to be species with opposable thumbs, and v to be a species without this trait. Tree a is not a valid phylogeny because, in some evolutionary path, opposable thumbs were lost and then reappeared.
Reference: [3] <author> E. Brewer and B. Kuszmaul. </author> <title> How to Get Good Performance from the CM-5 Data Network. </title> <booktitle> In Proceedings of 8th International Parallel Processing Symposium, </booktitle> <address> Cancun, Mexico, </address> <year> 1994. </year>
Reference-contexts: In contrast, trees b and c are perfect phylogenies because they satisfy the three conditions of the definition. Notice that the perfect phylogeny for a given set of species may not be unique. Also, tree c contains the species <ref> [1; 1; 3] </ref>, which was not a member of the original set. The tree is still a perfect phylogeny, however, because each leaf appears in the original set. <p> If the network has reasonably high bandwidth, however, we expect the number of old versions maintained to be small, because the time required to read a trie from another processor will be small. Another source of overhead is the unsynchronized communication. As noted by Brewer and Kuszmaul <ref> [3] </ref>, on an architecture such as the CM-5, unsynchronized communication can lead to the formation of hot spots. For example, several processors may read from the same processor at the same time, which will cause each of the reading processors to be delayed.
Reference: [4] <author> Soumen Chakrabarti, Abhiram Ranade, and Katherine Yelick. </author> <title> Randomized load balancing for tree-structured computation. </title> <booktitle> In Proceedings of the Scalable High Performance Computing Conference, </booktitle> <address> Knoxville, TN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: The task queue has been used in several other applications, including an eigenvalue problem, a symbolic application, and several smaller problems <ref> [4] </ref>. 6 Representation of the Store In this section, we discuss the design decisions in our implementation of the store abstraction. The same data type can be used to represent both the successes and failures, because they are duals of one another.
Reference: [5] <author> J. Felsenstein. </author> <title> Numerical methods for inferring evolutionary trees. Q. </title> <journal> Rev. Biol, </journal> <volume> 57 </volume> <pages> 379-404, </pages> <year> 1982. </year>
Reference-contexts: It is valuable in itself, but also provides clues about migration patterns, climate changes, the formation of the earth, and many other mysteries of the diversity of life. Methods for solving the phylogeny problem include parsimony, compatibility, maximum likelihood, and distance matrix methods <ref> [5] </ref>. Unfortunately, with any of these methods, deriving phylogenetic trees is often prohibitively expensive.
Reference: [6] <author> M. Hasegawa, H. Kishino, K. Hayasaka, and S. Horai. </author> <title> Mitochondrial DNA evolution in primates: transition rate has been extremely low in the lemur. </title> <journal> J. Molecular Evolution, </journal> <volume> 31(2) </volume> <pages> 113-21, </pages> <year> 1990. </year>
Reference-contexts: We present performance results for the parallel implementations of the next three sections below. The benchmarks are two 60 character sections of the mitochondrial third positions in the D-loop region for various species <ref> [6] </ref>. Figures 9 and 11 show the speedups on a 64-node CM-5 and Figures 10 and 12 show the fraction of subsets that were resolved in the failure store. We will discuss these results in the sections that follow.
Reference: [7] <author> J.M. Hullot. </author> <title> Associative-commutative pattern matching. </title> <booktitle> 5th IJCAI, </booktitle> <address> Tokyo, Japan, </address> <year> 1979. </year>
Reference-contexts: From the lattice, we remove edges to obtain the search tree shown in Figure 4a. Trees with this structure are known as binomial trees <ref> [7, 12] </ref>. Figure 4b shows an example with 4 characters. The tree corresponds to a search in which we begin with small subsets and progress to larger subsets. Alternatively, we could begin with large subsets and progress to smaller subsets.
Reference: [8] <author> J. Jones. </author> <title> Parallelizing the Phylogeny Problem. </title> <type> Master's thesis., </type> <institution> University of California, Berkeley, California, </institution> <year> 1994. </year>
Reference-contexts: To determine compatibility, we use the algorithm of Agarwala and Fernandez-Baca [1], modified according to a suggestion of Lawler [9], as described in our previous work <ref> [8] </ref>. Examining all possible subsets (an exponential number) in turn is extremely time-consuming, however. <p> Figure 4b shows an example with 4 characters. The tree corresponds to a search in which we begin with small subsets and progress to larger subsets. Alternatively, we could begin with large subsets and progress to smaller subsets. This approach, however, is not as efficient <ref> [8] </ref> because most large subsets will fail, which gives no information about the rest of the subsets. In contrast, many small subsets will fail, allowing us to use Lemma 1 to prune large branches of the search tree. Notice that we can combine the two techniques above. <p> To avoid confusion, we will discuss only the failure set store in this section. The design of the failure store is more important to performance, since it is used for pruning the search space <ref> [8] </ref>. The failure store must support the following operations: * Insert (S): insert a new set S of characters into the store * DetectSubset (S): determine if any subsets of S are in the store. <p> We first describe an efficient sequential data structure and then present four different representations for distributed memory multiprocessors. 6.1 A Sequential Implementation In previous work, we have determined that a trie is a good data structure for a sequential implementation of the phylogeny problem <ref> [8] </ref>. A trie is a tree in which each leaf holds one value, in our case a character subset. <p> The application has irregular data structures, asynchronous communication inside the task queue and within some versions of the trie, and an irregular task graph with unpredictable task times due. Guided by our measurements of the sequential implementation <ref> [8] </ref>, we developed a parallel version based on two data structures. The task queue from Multipol [13] distributes the tasks and maintains load balance, and the failure store, represented as a distributed trie, manages the sharing of information among processors.
Reference: [9] <author> E.L. Lawler. </author> <type> Personal communication. </type> <month> August </month> <year> 1993. </year>
Reference-contexts: If one of the maximal subsets is sufficiently large, the corresponding perfect phylogeny will be a good estimate of the evolutionary history of the species. To determine compatibility, we use the algorithm of Agarwala and Fernandez-Baca [1], modified according to a suggestion of Lawler <ref> [9] </ref>, as described in our previous work [8]. Examining all possible subsets (an exponential number) in turn is extremely time-consuming, however. <p> The implementation is, we believe, the fastest implementation of the character compatibility problem. The sequential algorithm for solving the perfect phylogeny problem tasks is due to Agarwala and Fernandez-Baca [1], with an improvement suggested by Lawler <ref> [9] </ref>. Using the full character compatibility application, we were able to solve problems with 60 characters in a few minutes, demonstrating speedups of 50 on 64 processors.
Reference: [10] <author> W.J. Le Quesne. </author> <title> A method of selection of characters in numerical taxonomy. In Syst. </title> <journal> Zool., </journal> <volume> 18 </volume> <pages> 201-205, </pages> <year> 1969. </year>
Reference-contexts: by the National Science Foundation as a Research Initiation Award (number CCR-9210260), and as an Infrastructure Grant (number CDA-8722788), The information presented here does not necessarily reflect the position or the policy of the Government and no official endorsement should be inferred. 1 Our algorithm is based on character compatibility <ref> [10] </ref>. The problem statement is defined formally in Section 2 and a sequential algorithm outlined in Section 3. Character compatibility is essentially a search problem and as such has two of the classic problems of parallel search.
Reference: [11] <author> F.R. McMorris, T.J. Warnow, and T. Wimer. </author> <title> Triangulating vertex colored graphs. </title> <booktitle> In Proceedings of the 4th Annual Symposium on Discrete Algorithms, </booktitle> <address> Austin, Texas, </address> <year> 1993. </year>
Reference: [12] <author> J. Vuillemin. </author> <title> A data structure for manipulating priority queues. </title> <journal> C. ACM, </journal> <volume> 21(4), </volume> <year> 1978. </year>
Reference-contexts: From the lattice, we remove edges to obtain the search tree shown in Figure 4a. Trees with this structure are known as binomial trees <ref> [7, 12] </ref>. Figure 4b shows an example with 4 characters. The tree corresponds to a search in which we begin with small subsets and progress to larger subsets. Alternatively, we could begin with large subsets and progress to smaller subsets.
Reference: [13] <author> K. Yelick, S. Chakrabarti, E. Deprit, J. Jones, A. Krishnamurthy and C. Wen. </author> <title> Data structures for irregular applications. DIMACS Workshop on Parallel Algorithms for Unstructured and Dynamic Problems, </title> <booktitle> 1993. </booktitle> <pages> 16 </pages>
Reference-contexts: We use priority to encourage this order. Input Task Queue with Locality Randomized 60:000 89.3 694.1 60:002 221.0 1651.0 8 The task queue data structure from the Multipol <ref> [13] </ref> meets our requirements, and is our choice for our implementation. <p> Guided by our measurements of the sequential implementation [8], we developed a parallel version based on two data structures. The task queue from Multipol <ref> [13] </ref> distributes the tasks and maintains load balance, and the failure store, represented as a distributed trie, manages the sharing of information among processors. We studied four implementations of the failure store and found that the implementation that synchronized periodically to communicate information to all processors was the best.
References-found: 13

