URL: http://www.cs.mu.oz.au/tr_db/mu_94_23.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Deterministic Resource Management for the Linear Logic Programming Language Lygon  
Author: Michael Winikoff James Harland 
Address: Parkville, Victoria 3052 Australia  
Affiliation: Department of Computer Science The University of Melbourne  
Pubnum: Technical Report 94/23  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Jean-Marc Andreoli. </author> <title> Logic programming with focusing proofs in linear logic. </title> <journal> Journal of Logic and Computation, </journal> <volume> 2(3), </volume> <year> 1992. </year>
Reference-contexts: Proof: Algorithm 2 does not introduce U se rules and all of the lemmas used yield use-valid proofs. ffi 38 6 Comparison with Other Work There are a number of logic programming languages based on linear logic. Some of these, like LinLog <ref> [1] </ref> are based on proof-theoretic analyses, as Lygon is, but, to the authors' knowledge, have not been implemented and hence do not involve the problems of lazy splitting discussed in this paper. <p> Secondly, and perhaps more importantly, our presentation allows us to simply use the permutability properties explored in <ref> [6, 1] </ref> to reduce the non-determinism associated with selecting the formula to be reduced. In the 2 Actually ACL includes but only in contexts which prevent lazy splitting from being needed. 39 Lolli encoding selecting the next formula to be reduced is done by the res-olution rule.
Reference: [2] <author> Jean-Marc Andreoli, Paolo Ciancarini, and Remo Pareschi. </author> <title> Interaction abstract machines. </title> <type> Technical Report ECRC-92-23, </type> <institution> ECRC, </institution> <year> 1992. </year>
Reference-contexts: Some idioms such as global variables, state and memory, and mutual exclusion are briefly discussed in [28, 10, 9]. In addition, Lygon allows a class of formulae which is a superset of other linear logic programming languages, thus idioms and techniques possible in languages such as LO <ref> [2] </ref> and Lolli [15, 12] can also be used in Lygon. In addition, idioms such as the use of logical connectives to implement modules and scoping [20] can be expressed in Lygon.
Reference: [3] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> LO and behold! concurrent structured processes. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 44-56, </pages> <year> 1990. </year>
Reference-contexts: Some of these, like LinLog [1] are based on proof-theoretic analyses, as Lygon is, but, to the authors' knowledge, have not been implemented and hence do not involve the problems of lazy splitting discussed in this paper. Others, like ACL [18, 25, 17] and LO <ref> [4, 5, 3] </ref> use linear logic as motivation and a design guide for concurrent logic programming. These languages use a somewhat restricted class of formulae which excludes .
Reference: [4] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> Communication as fair distribution of knowledge. </title> <editor> In Andreas Parpcke, editor, </editor> <booktitle> OOPSLA, </booktitle> <pages> pages 212-229, </pages> <year> 1991. </year>
Reference-contexts: Some of these, like LinLog [1] are based on proof-theoretic analyses, as Lygon is, but, to the authors' knowledge, have not been implemented and hence do not involve the problems of lazy splitting discussed in this paper. Others, like ACL [18, 25, 17] and LO <ref> [4, 5, 3] </ref> use linear logic as motivation and a design guide for concurrent logic programming. These languages use a somewhat restricted class of formulae which excludes .
Reference: [5] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> Linear objects: Logical processes with built-in inheritance. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 445-473, </pages> <year> 1991. </year>
Reference-contexts: Some of these, like LinLog [1] are based on proof-theoretic analyses, as Lygon is, but, to the authors' knowledge, have not been implemented and hence do not involve the problems of lazy splitting discussed in this paper. Others, like ACL [18, 25, 17] and LO <ref> [4, 5, 3] </ref> use linear logic as motivation and a design guide for concurrent logic programming. These languages use a somewhat restricted class of formulae which excludes .
Reference: [6] <author> Didier Galmiche and Guy Perrier. </author> <title> On proof normalization in linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 135(1) </volume> <pages> 67-110, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: Secondly, and perhaps more importantly, our presentation allows us to simply use the permutability properties explored in <ref> [6, 1] </ref> to reduce the non-determinism associated with selecting the formula to be reduced. In the 2 Actually ACL includes but only in contexts which prevent lazy splitting from being needed. 39 Lolli encoding selecting the next formula to be reduced is done by the res-olution rule.
Reference: [7] <author> J. Harland. </author> <title> On normal forms and equivalence for logic programs. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 146-160, </pages> <address> Washington DC, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: Firstly we have come to distrust the blind use of equivalences derived using full linear logic in a goal directed context. The relationship between goal directed (ie. operational) equivalence and logical equivalence is nontrivial and involves intermediate logics <ref> [7] </ref>. The logical equivalence of two formulae only implies operational equivalence if the two formulae are within the appropriate subset.
Reference: [8] <author> James Harland. </author> <title> A proof-theoretic analysis of goal-directed provability. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(1) </volume> <pages> 69-88, </pages> <year> 1994. </year>
Reference-contexts: This class of formulae is known as hereditary Harrop formulae. There is some evidence to suggest that this is the largest class of formulae for which (intuitionistic) uniform proofs are complete <ref> [8] </ref>. Note that this class of formulae properly includes Horn clauses, and that classical and intuitionistic logic coincide on Horn clauses. For more details about uniform proofs see [22]. The notion of a goal-directed proof in linear logic is significantly more complicated than in intuitionistic logic.
Reference: [9] <author> James Harland and David Pym. </author> <title> Implementation issues and applications for a linear logic programming language. </title> <note> In Preparation. </note>
Reference-contexts: Hence we are interested in developing a collection of examples of Lygon code. We expect that due to the language's expressiveness there will be many idioms which are not expressible in Prolog. Some idioms such as global variables, state and memory, and mutual exclusion are briefly discussed in <ref> [28, 10, 9] </ref>. In addition, Lygon allows a class of formulae which is a superset of other linear logic programming languages, thus idioms and techniques possible in languages such as LO [2] and Lolli [15, 12] can also be used in Lygon.
Reference: [10] <author> James Harland and David Pym. </author> <title> A note on the implementation and applications of linear logic programming languages. </title> <editor> In Gopal Gupta, editor, </editor> <booktitle> Seventeeth Annual Computer Science Conference, </booktitle> <pages> pages 647-658, </pages> <year> 1994. </year>
Reference-contexts: Discussion and the completeness results for a large fragment of linear logic may be found in [24]; these formulae form the basis of the logic programming language Lygon <ref> [10, 24, 28] </ref>. The analysis of [24] lead to the definition of resolution proofs, which simplify the search process for Lygon programs and goals, by encoding various rules such as !-L and 8-L into a single resolution rule. However, resolution proofs still contain some elements of non-determinism. <p> However, resolution proofs still contain some elements of non-determinism. One solution to this problem is to search for a proof in a lazy manner <ref> [10, 24, 28] </ref>; in other words, we allocate resources to each branch of the proof on demand, rather than attempting to determine the distribution in advance. This technique has been successfully used in languages such as Lolli [14, 15]. <p> As a result the implementation problems are correspondingly simpler, in that neither language needs lazy splitting 2 , and so again the problems addressed in this paper do not arise. The last class of linear logic programming languages comprises Lolli [14, 15, 11], Forum [21] and Lygon <ref> [24, 10, 28] </ref>. These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful. <p> Hence we are interested in developing a collection of examples of Lygon code. We expect that due to the language's expressiveness there will be many idioms which are not expressible in Prolog. Some idioms such as global variables, state and memory, and mutual exclusion are briefly discussed in <ref> [28, 10, 9] </ref>. In addition, Lygon allows a class of formulae which is a superset of other linear logic programming languages, thus idioms and techniques possible in languages such as LO [2] and Lolli [15, 12] can also be used in Lygon.
Reference: [11] <author> Joshua Hodas. </author> <title> Lolli: An extension of prolog with linear logic context management. In Prolog Worshop, </title> <year> 1992. </year>
Reference-contexts: As a result the implementation problems are correspondingly simpler, in that neither language needs lazy splitting 2 , and so again the problems addressed in this paper do not arise. The last class of linear logic programming languages comprises Lolli <ref> [14, 15, 11] </ref>, Forum [21] and Lygon [24, 10, 28]. These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful.
Reference: [12] <author> Joshua Hodas. </author> <title> Specifying filler-gap dependency parsers in a linear-logic programming language. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 622-636, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: In addition, Lygon allows a class of formulae which is a superset of other linear logic programming languages, thus idioms and techniques possible in languages such as LO [2] and Lolli <ref> [15, 12] </ref> can also be used in Lygon. In addition, idioms such as the use of logical connectives to implement modules and scoping [20] can be expressed in Lygon.
Reference: [13] <author> Joshua Hodas. </author> <title> Logic Programming in Intuitionistic Linear Logic: Theory, Design and Implementation. </title> <type> PhD thesis, </type> <institution> University of Pennsylva-nia, </institution> <year> 1994. </year> <month> 43 </month>
Reference-contexts: The notion of lazy splitting was introduced in Lolli [14], and a lazy method of finding uniform proofs (known in [14] as an input-output model of resource consumption) is given. An extension of this system presented in Hodas' thesis <ref> [13] </ref> handles the &gt; rule lazily. Lolli is based on a single conclusion logic whereas Lygon is based on a multiple conclusion logic. It is actually possible to encode Lygon into Lolli by using a new constant and allowing resolution to select the formula to be reduced.
Reference: [14] <author> Joshua S. Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic (extended abstract). </title> <booktitle> In Logic in Computer Science, </booktitle> <pages> pages 32-42. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: This technique has been successfully used in languages such as Lolli <ref> [14, 15] </ref>. However, in Lygon there is a richer class of formulae (specifically, we make use of the linear connective O), and hence the problem of managing the distribution of formulae across different parts of the proof is significantly more complex. <p> As a result the implementation problems are correspondingly simpler, in that neither language needs lazy splitting 2 , and so again the problems addressed in this paper do not arise. The last class of linear logic programming languages comprises Lolli <ref> [14, 15, 11] </ref>, Forum [21] and Lygon [24, 10, 28]. These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful. <p> These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful. The notion of lazy splitting was introduced in Lolli <ref> [14] </ref>, and a lazy method of finding uniform proofs (known in [14] as an input-output model of resource consumption) is given. An extension of this system presented in Hodas' thesis [13] handles the &gt; rule lazily. <p> These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful. The notion of lazy splitting was introduced in Lolli <ref> [14] </ref>, and a lazy method of finding uniform proofs (known in [14] as an input-output model of resource consumption) is given. An extension of this system presented in Hodas' thesis [13] handles the &gt; rule lazily. Lolli is based on a single conclusion logic whereas Lygon is based on a multiple conclusion logic.
Reference: [15] <author> Joshua S. Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic logic. </title> <journal> Journal of Information and Computation, </journal> <volume> 10(2) </volume> <pages> 327-365, </pages> <year> 1994. </year>
Reference-contexts: This technique has been successfully used in languages such as Lolli <ref> [14, 15] </ref>. However, in Lygon there is a richer class of formulae (specifically, we make use of the linear connective O), and hence the problem of managing the distribution of formulae across different parts of the proof is significantly more complex. <p> As a result the implementation problems are correspondingly simpler, in that neither language needs lazy splitting 2 , and so again the problems addressed in this paper do not arise. The last class of linear logic programming languages comprises Lolli <ref> [14, 15, 11] </ref>, Forum [21] and Lygon [24, 10, 28]. These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful. <p> In addition, Lygon allows a class of formulae which is a superset of other linear logic programming languages, thus idioms and techniques possible in languages such as LO [2] and Lolli <ref> [15, 12] </ref> can also be used in Lygon. In addition, idioms such as the use of logical connectives to implement modules and scoping [20] can be expressed in Lygon.
Reference: [16] <author> S. Kleene. </author> <title> Mathematical Logic. </title> <publisher> Wiley and Sons, </publisher> <year> 1968. </year>
Reference-contexts: In this way we need to be able to interpret the rules of the sequent calculus as a "bottom-up" method of proof construction (Kleene <ref> [16] </ref> discusses this in more depth for the classical sequent calculus). In addition, we need to be able to search for goal-directed proofs, rather than arbitrary proofs. The best known characterization of this property is 3 the notion of a uniform proof [22].
Reference: [17] <author> Naoki Kobayashi and Akinori Yonezawa. </author> <title> ACL a concurrent linear logic programming paradigm. </title> <booktitle> In International Logic Programming Symposium, </booktitle> <pages> pages 279-294, </pages> <year> 1993. </year>
Reference-contexts: Some of these, like LinLog [1] are based on proof-theoretic analyses, as Lygon is, but, to the authors' knowledge, have not been implemented and hence do not involve the problems of lazy splitting discussed in this paper. Others, like ACL <ref> [18, 25, 17] </ref> and LO [4, 5, 3] use linear logic as motivation and a design guide for concurrent logic programming. These languages use a somewhat restricted class of formulae which excludes .
Reference: [18] <author> Naoki Kobayashi and Akinori Yonezawa. </author> <title> Typed higher-order concurrent linear logic programming. </title> <type> Technical Report 12, </type> <institution> University of Tokyo, </institution> <year> 1994. </year>
Reference-contexts: Some of these, like LinLog [1] are based on proof-theoretic analyses, as Lygon is, but, to the authors' knowledge, have not been implemented and hence do not involve the problems of lazy splitting discussed in this paper. Others, like ACL <ref> [18, 25, 17] </ref> and LO [4, 5, 3] use linear logic as motivation and a design guide for concurrent logic programming. These languages use a somewhat restricted class of formulae which excludes .
Reference: [19] <author> P.D. Lincoln and N. Shankar. </author> <title> Proof search in first-order linear logic and other cut-free sequent calculi. </title> <booktitle> In Logic in Computer Science, </booktitle> <pages> pages 282-291, </pages> <year> 1994. </year>
Reference-contexts: In addition to the application of this work to the implementation of logic programming languages based on linear logic, the lazy rules above presumably have application in theorem provers for linear logic <ref> [26, 27, 19, 23] </ref>, where they eliminate a significant potential source of inefficiency. Acknowledgments We would like to thank David Pym for interesting discussions. We would like to thank an anonymous referee for pointing us to Hodas' thesis and for 41 suggesting the encoding of Lygon in Lolli.
Reference: [20] <author> Dale Miller. </author> <title> A logical analysis of modules in logic programming. </title> <journal> Journal of Logic Programming, </journal> <pages> pages 79-108, </pages> <year> 1989. </year>
Reference-contexts: In addition, idioms such as the use of logical connectives to implement modules and scoping <ref> [20] </ref> can be expressed in Lygon. Experience with various programs will presumably suggest optimizations that can be done, and there is a large and growing body of literature on the optimization of logic programming languages.
Reference: [21] <author> Dale Miller. </author> <title> A multiple-conclusion meta-logic. </title> <booktitle> In Logic in Computer Science, </booktitle> <pages> pages 272-281, </pages> <year> 1994. </year>
Reference-contexts: As a result the implementation problems are correspondingly simpler, in that neither language needs lazy splitting 2 , and so again the problems addressed in this paper do not arise. The last class of linear logic programming languages comprises Lolli [14, 15, 11], Forum <ref> [21] </ref> and Lygon [24, 10, 28]. These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful.
Reference: [22] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: One such notion is a goal-directed proof, which is a certain kind of proof in the sequent calculus <ref> [22] </ref>. Essentially, the shape of a goal-directed proof is determined by the goal, and not by the program, and hence may be thought of as a technical characterization of the intuition that in a logic programming language, a formula corresponds to a sequence of instructions in some sense. <p> A logic programming language is then found by identifying a fragment of the logic for which goal-directed proofs are complete. The best known form of goal-directed proofs is uniform proofs, which have been thoroughly investigated by Miller et al. <ref> [22] </ref>, who have shown that this notion can be used to define various logic programming languages, both first-order and higher-order, in intuitionistic logic. <p> This notion of proof may be thought of as one possible generalisation of the notion of uniform proofs of <ref> [22] </ref>. As in the previous case, this has a natural interpretation as a computation, and fragments for which this class of proofs is complete are identified as logic programming languages. <p> In addition, we need to be able to search for goal-directed proofs, rather than arbitrary proofs. The best known characterization of this property is 3 the notion of a uniform proof <ref> [22] </ref>. This is defined in terms of proofs in the intuitionistic sequent calculus (i.e. sequents ` in which contains at most one formula). <p> There is some evidence to suggest that this is the largest class of formulae for which (intuitionistic) uniform proofs are complete [8]. Note that this class of formulae properly includes Horn clauses, and that classical and intuitionistic logic coincide on Horn clauses. For more details about uniform proofs see <ref> [22] </ref>. The notion of a goal-directed proof in linear logic is significantly more complicated than in intuitionistic logic.
Reference: [23] <author> Alberto Momigliano. </author> <title> Theorem proving via uniform proofs. </title> <type> Manuscript. </type>
Reference-contexts: In addition to the application of this work to the implementation of logic programming languages based on linear logic, the lazy rules above presumably have application in theorem provers for linear logic <ref> [26, 27, 19, 23] </ref>, where they eliminate a significant potential source of inefficiency. Acknowledgments We would like to thank David Pym for interesting discussions. We would like to thank an anonymous referee for pointing us to Hodas' thesis and for 41 suggesting the encoding of Lygon in Lolli.
Reference: [24] <author> David Pym and James Harland. </author> <title> A uniform proof-theoretic investigation of linear logic programming. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(2) </volume> <pages> 175-207, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: However, in the linear case, there can be an arbitrary number of such formulae. As a result the generalisation of the notion of uniform proof to linear logic is somewhat more complex than in intuitionistic logic. One such notion was defined and analysed in <ref> [24] </ref>. This investigation was based on an analysis of the permutation properties of linear logic to determine what proof "shapes" were possible, together with a completeness result for this class of proofs on a given fragment of linear logic. <p> As in the previous case, this has a natural interpretation as a computation, and fragments for which this class of proofs is complete are identified as logic programming languages. Discussion and the completeness results for a large fragment of linear logic may be found in <ref> [24] </ref>; these formulae form the basis of the logic programming language Lygon [10, 24, 28]. The analysis of [24] lead to the definition of resolution proofs, which simplify the search process for Lygon programs and goals, by encoding various rules such as !-L and 8-L into a single resolution rule. <p> Discussion and the completeness results for a large fragment of linear logic may be found in [24]; these formulae form the basis of the logic programming language Lygon <ref> [10, 24, 28] </ref>. The analysis of [24] lead to the definition of resolution proofs, which simplify the search process for Lygon programs and goals, by encoding various rules such as !-L and 8-L into a single resolution rule. However, resolution proofs still contain some elements of non-determinism. <p> Discussion and the completeness results for a large fragment of linear logic may be found in <ref> [24] </ref>; these formulae form the basis of the logic programming language Lygon [10, 24, 28]. The analysis of [24] lead to the definition of resolution proofs, which simplify the search process for Lygon programs and goals, by encoding various rules such as !-L and 8-L into a single resolution rule. However, resolution proofs still contain some elements of non-determinism. <p> However, resolution proofs still contain some elements of non-determinism. One solution to this problem is to search for a proof in a lazy manner <ref> [10, 24, 28] </ref>; in other words, we allocate resources to each branch of the proof on demand, rather than attempting to determine the distribution in advance. This technique has been successfully used in languages such as Lolli [14, 15]. <p> Clearly this weaker restriction on the class of proofs will be complete for a larger fragment of linear logic than the former. This latter one is the approach taken in <ref> [24] </ref>, and is the one followed in this report. The details of this approach are beyond the scope of this report and may be found in [24]. The fragment of linear logic for which this notion of goal-directed proof 4 is complete is given below. <p> This latter one is the approach taken in <ref> [24] </ref>, and is the one followed in this report. The details of this approach are beyond the scope of this report and may be found in [24]. The fragment of linear logic for which this notion of goal-directed proof 4 is complete is given below. <p> The remaining problem is then to provide a deterministic proof system (i.e. one that can be implemented directly) for this class of formulae. A step in this direction was given in <ref> [24] </ref>, in the form of resolution proofs; however, these proofs still contain a significant amount of non-determinism, particularly in the way that multiplicative rules are handled. Hence our task is to find a system of proofs for which a bottom-up search can proceed in a deterministic manner. <p> As a result the implementation problems are correspondingly simpler, in that neither language needs lazy splitting 2 , and so again the problems addressed in this paper do not arise. The last class of linear logic programming languages comprises Lolli [14, 15, 11], Forum [21] and Lygon <ref> [24, 10, 28] </ref>. These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful.
Reference: [25] <author> Toshihiro Shimizu and Naoki Kobayashi. HACL Ver. </author> <note> 0.1 user's manual. FTP with HACL release camille.is.s.u-tokyo.ac.jp:pub/hacl, </note> <month> June </month> <year> 1994. </year>
Reference-contexts: Some of these, like LinLog [1] are based on proof-theoretic analyses, as Lygon is, but, to the authors' knowledge, have not been implemented and hence do not involve the problems of lazy splitting discussed in this paper. Others, like ACL <ref> [18, 25, 17] </ref> and LO [4, 5, 3] use linear logic as motivation and a design guide for concurrent logic programming. These languages use a somewhat restricted class of formulae which excludes .
Reference: [26] <author> Tanel Tammet. </author> <title> Proof search strategies in linear logic. Programming Methodology Group 70, </title> <institution> University of Goteborg and Chalmers University of Technology, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: In addition to the application of this work to the implementation of logic programming languages based on linear logic, the lazy rules above presumably have application in theorem provers for linear logic <ref> [26, 27, 19, 23] </ref>, where they eliminate a significant potential source of inefficiency. Acknowledgments We would like to thank David Pym for interesting discussions. We would like to thank an anonymous referee for pointing us to Hodas' thesis and for 41 suggesting the encoding of Lygon in Lolli.
Reference: [27] <author> Tanel Tammet. </author> <title> Completeness of resolution for definite answers. Programming Methodology Group 79, </title> <institution> University of Goteborg and Chalmers University of Technology, </institution> <month> April </month> <year> 1994. </year> <month> 44 </month>
Reference-contexts: In addition to the application of this work to the implementation of logic programming languages based on linear logic, the lazy rules above presumably have application in theorem provers for linear logic <ref> [26, 27, 19, 23] </ref>, where they eliminate a significant potential source of inefficiency. Acknowledgments We would like to thank David Pym for interesting discussions. We would like to thank an anonymous referee for pointing us to Hodas' thesis and for 41 suggesting the encoding of Lygon in Lolli.
Reference: [28] <author> Michael Winikoff and James Harland. </author> <title> Implementation and development issues for the linear logic programming language Lygon. </title> <booktitle> In Australasian Computer Science Conference, </booktitle> <year> 1995. </year> <month> 45 </month>
Reference-contexts: Discussion and the completeness results for a large fragment of linear logic may be found in [24]; these formulae form the basis of the logic programming language Lygon <ref> [10, 24, 28] </ref>. The analysis of [24] lead to the definition of resolution proofs, which simplify the search process for Lygon programs and goals, by encoding various rules such as !-L and 8-L into a single resolution rule. However, resolution proofs still contain some elements of non-determinism. <p> However, resolution proofs still contain some elements of non-determinism. One solution to this problem is to search for a proof in a lazy manner <ref> [10, 24, 28] </ref>; in other words, we allocate resources to each branch of the proof on demand, rather than attempting to determine the distribution in advance. This technique has been successfully used in languages such as Lolli [14, 15]. <p> As a result the implementation problems are correspondingly simpler, in that neither language needs lazy splitting 2 , and so again the problems addressed in this paper do not arise. The last class of linear logic programming languages comprises Lolli [14, 15, 11], Forum [21] and Lygon <ref> [24, 10, 28] </ref>. These languages attempt to take a large fragment of linear logic, implement it and show that the resulting language is expressive and useful. <p> Hence we are interested in developing a collection of examples of Lygon code. We expect that due to the language's expressiveness there will be many idioms which are not expressible in Prolog. Some idioms such as global variables, state and memory, and mutual exclusion are briefly discussed in <ref> [28, 10, 9] </ref>. In addition, Lygon allows a class of formulae which is a superset of other linear logic programming languages, thus idioms and techniques possible in languages such as LO [2] and Lolli [15, 12] can also be used in Lygon.
References-found: 28

