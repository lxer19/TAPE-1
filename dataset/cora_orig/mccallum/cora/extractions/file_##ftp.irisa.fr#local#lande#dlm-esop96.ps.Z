URL: file://ftp.irisa.fr/local/lande/dlm-esop96.ps.Z
Refering-URL: http://www.irisa.fr/lande/LeMetayer.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: [fradet,gaugne,lemetayer]@irisa.fr  
Title: Static detection of pointer errors: an axiomatisation and a checking algorithm  
Author: Pascal Fradet, Ronan Gaugne and Daniel Le Metayer Irisa/Inria 
Address: 35042 Rennes, France  
Affiliation: Campus de Beaulieu,  
Abstract: The incorrect use of pointers is one of the most common source of bugs. As a consequence, any kind of static code checking capable of detecting potential bugs at compile time is welcome. This paper presents a static analysis for the detection of incorrect accesses to memory (dereferences of invalid pointers). A pointer may be invalid because it has not been initialised or because it refers to a memory location which has been deallocated. The analyser is derived from an axiomatisation of alias and connectivity properties which is shown to be sound with respect to the natural semantics of the language. It deals with dynamically allocated data structures and it is accurate enough to handle circular structures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, R. Sethi and J. D. Ullman, </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley publishing company, </publisher> <year> 1988. </year>
Reference-contexts: ^ :(b 7! x) x x 3 P ^ :(a 7! x) 3 (P ^ :(b 7! x)) _ (P ^ (b 7! x)) if b 2 fv 2 Var (P ) j6 9w P j) (v 7! w)g P x i Q 0 i Q _ Q 0 rithms <ref> [1] </ref>.
Reference: [2] <author> R. Altucher and W. Landi, </author> <title> An extended form of must-alias analysis for dynamic allocation, </title> <booktitle> in 22 nd Annual ACM Symp. on Principles of Programming Languages POPL'95, </booktitle> <month> Jan. </month> <year> 1995, </year> <month> pp.74-85. </month>
Reference-contexts: accurate may-alias information (because numerical coefficients are used to record precise positions in a structure); on the other hand, our properties include both may-alias and must-alias information which allows us to gain accuracy in certain situations (the significance of must-alias properties to get more accurate may-alias properties is stressed in <ref> [2] </ref>). This extra level of precision is required to the analysis of correctness-related properties (for instance, the example treated in Section 4 could not be analysed successfully without a form of must-alias information).
Reference: [3] <author> L. Andersen, </author> <title> Program analysis and specialisation for the C programming language, </title> <type> Ph.D Thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: Section 6 reviews related work and suggests other applications of the analysis. 2 A Hoare logic for pointers The syntax and semantics of the subset of C considered in this paper are provided in Figures 9, 10 and 11 in the appendix. They are variations of definitions appearing in <ref> [3] </ref>. We use the exception value illegal to denote the result of a computation involving the dereference of an invalid pointer. The set of valid pointers of the store S D is D.
Reference: [4] <author> M.A. Arbib, S. Alagic, </author> <title> Proof rules for gotos, </title> <journal> Acta Informatica 11,2, pp.139-148,1979. </journal>
Reference-contexts: We therefore describe the extension of our approach to forward gotos, the most common form of control transfer in C programs. Several proposals have been made to extend Hoare's logic to goto statements. We choose here a notation close to Arbib and Alagic's <ref> [4] </ref>. The rules add to the normal post-condition an environment where every label occurring in the statement is associated with a condition.
Reference: [5] <author> T. Austin, S. Breach and G. Sohi, </author> <title> Efficient detection of all pointer and array access errors, </title> <booktitle> in Proceedings of the ACM SIGPLAN'94 Conf. on Programming Language Design and Implementation PLDI'94, </booktitle> <month> Jun. </month> <year> 1994, </year> <pages> pp. 290-301. </pages>
Reference: [6] <author> J.-P. Ban^atre, C. Bryce, D. Le Metayer, </author> <title> Compile-time detection of information flow in sequential programs, </title> <booktitle> proc. European Symposium on Research in Computer Security, </booktitle> <publisher> Springer Verlag, LNCS 875, </publisher> <pages> pp. 55-74. </pages>
Reference-contexts: For example, we are currently studying the integration of the pointer analysis described here with the information flow analysis proposed in <ref> [6] </ref>. Other applications of this analysis include the detection of unsafe programming styles (which rely on specific implementation choices like the order of evaluation of subexpressions) or memory leaks. The algorithm presented in section 3 is only a first step towards the design of an effective analyser.
Reference: [7] <author> J.F. Bergeretti and B. Carre, </author> <title> Information-flow and data-flow analysis of while-programs, </title> <journal> in ACM Transactions on Programming Languages and Systems,Vol. </journal> <volume> 7, No. 1, </volume> <month> Jan. </month> <pages> 85, pp. 37-61. </pages>
Reference-contexts: We sketch related work in each of these areas in turn. * There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions <ref> [7, 15, 17, 33] </ref> and tools [22] can provide information about uninitialised variables but are unable to track illegal accesses in dynamic data structures.
Reference: [8] <author> A. Bijlsma, </author> <title> Calculating with pointers, </title> <booktitle> in Science of Computer Programming 12 (1989) 191-205, </booktitle> <publisher> North-Holland. </publisher>
Reference-contexts: Also, it should be possible to include the numeric lattices of [12] in our framework (dealing with i ! properties rather than just 7! properties) but this extension requires further investigation. * Axiomatisation of pointer and alias relations has been studied for Pascal (see e.g. <ref> [10, 28, 8] </ref>). Most contributions in this area focus on generality and completeness issues and do not consider automatisation. An exception is the work by Luckham and Suzuki [27] which presents an axiom-based verifier for Pascal programs.
Reference: [9] <author> F. Bourdoncle, </author> <title> Abstract debugging of higher-order imperative languages, </title> <booktitle> in Proceeding of the ACM SIGPLAN'93 Conf. on Programming Language Design and Implementation PLDI'93, </booktitle> <month> Jun. 93. </month>
Reference-contexts: Most related contributions [7, 15, 17, 33] and tools [22] can provide information about uninitialised variables but are unable to track illegal accesses in dynamic data structures. Other techniques like <ref> [9, 16, 21] </ref> perform different kinds of analyses (like aspects, invariant propagation, program slicing) which are complementary to the work described here. * There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations (see [12,
Reference: [10] <author> R. Cartwright and D. Oppen, </author> <title> The logic of aliasing, </title> <journal> in Acta Informatica 15, 365-384, 1981 ACM TOPLAS, </journal> <volume> Vol. 7, </volume> <year> 1985, </year> <pages> pp. 299-310. </pages>
Reference-contexts: Also, it should be possible to include the numeric lattices of [12] in our framework (dealing with i ! properties rather than just 7! properties) but this extension requires further investigation. * Axiomatisation of pointer and alias relations has been studied for Pascal (see e.g. <ref> [10, 28, 8] </ref>). Most contributions in this area focus on generality and completeness issues and do not consider automatisation. An exception is the work by Luckham and Suzuki [27] which presents an axiom-based verifier for Pascal programs.
Reference: [11] <author> D. Chase, M. Wegman and F. Zadeck, </author> <title> Analysis of pointers and structures, </title> <booktitle> in Conf. on Programming Language Design and Implementation PLDI, Jun. </booktitle> <volume> 90, Vol. </volume> <booktitle> 25(6) of SIGPLAN Notices, </booktitle> <address> pp296-310. </address>
Reference: [12] <author> A. Deutsch, </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting, </title> <booktitle> in SIGPLAN'94 Conf.on Programming Language Design and Implementation PLDI'94, </booktitle> <month> Jun. </month> <year> 1994, </year> <pages> pp. 230-241. </pages>
Reference-contexts: [9, 16, 21] perform different kinds of analyses (like aspects, invariant propagation, program slicing) which are complementary to the work described here. * There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations (see <ref> [12, 14] </ref> for up to date surveys of the area). One of the most precise published alias analysis is the framework described in [12]. <p> One of the most precise published alias analysis is the framework described in <ref> [12] </ref>. Our analysis is not directly comparable to this one in terms of precision: on one hand, the symbolic access paths used in [12] provide a much more accurate may-alias information (because numerical coefficients are used to record precise positions in a structure); on the other hand, our properties include both <p> One of the most precise published alias analysis is the framework described in <ref> [12] </ref>. Our analysis is not directly comparable to this one in terms of precision: on one hand, the symbolic access paths used in [12] provide a much more accurate may-alias information (because numerical coefficients are used to record precise positions in a structure); on the other hand, our properties include both may-alias and must-alias information which allows us to gain accuracy in certain situations (the significance of must-alias properties to get more accurate may-alias <p> This extra level of precision is required to the analysis of correctness-related properties (for instance, the example treated in Section 4 could not be analysed successfully without a form of must-alias information). Also, it should be possible to include the numeric lattices of <ref> [12] </ref> in our framework (dealing with i ! properties rather than just 7! properties) but this extension requires further investigation. * Axiomatisation of pointer and alias relations has been studied for Pascal (see e.g. [10, 28, 8]).
Reference: [13] <author> A. Deutsch, </author> <title> On determining lifetime and aliasing of dynamically allocated data in higher-order functional specifications, </title> <booktitle> in 17 th Annual ACM Symp. on Principles of Programming Languages POPL'90, </booktitle> <month> Jan. </month> <pages> 90, pp. 157-168. </pages>
Reference: [14] <author> A. Deutsch, </author> <title> Semantic models and abstract interpretation techniques for inductive data structures and pointers, </title> <booktitle> in Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation PEPM'95, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 226-229. </pages>
Reference-contexts: [9, 16, 21] perform different kinds of analyses (like aspects, invariant propagation, program slicing) which are complementary to the work described here. * There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations (see <ref> [12, 14] </ref> for up to date surveys of the area). One of the most precise published alias analysis is the framework described in [12].
Reference: [15] <author> D. Evans, </author> <title> Using specifications to check source code, </title> <type> in Technical Report, </type> <institution> MIT Lab for computer science, </institution> <month> Jun. </month> <year> 1994. </year>
Reference-contexts: We sketch related work in each of these areas in turn. * There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions <ref> [7, 15, 17, 33] </ref> and tools [22] can provide information about uninitialised variables but are unable to track illegal accesses in dynamic data structures.
Reference: [16] <author> J. Field, G. Ramalingam and F. </author> <title> Tip, Parametric program slicing, </title> <booktitle> in 22 th Annual ACM Symp. on Principles of Programming Languages POPL'95, </booktitle> <month> Jan. </month> <pages> 95, pp. 379-392. </pages>
Reference-contexts: Most related contributions [7, 15, 17, 33] and tools [22] can provide information about uninitialised variables but are unable to track illegal accesses in dynamic data structures. Other techniques like <ref> [9, 16, 21] </ref> perform different kinds of analyses (like aspects, invariant propagation, program slicing) which are complementary to the work described here. * There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations (see [12,
Reference: [17] <author> L. Fosdick and L. Osterweil, </author> <title> Data flow analysis in software reliability, </title> <journal> ACM Computing surveys, </journal> <volume> 8(3), </volume> <month> Sept. </month> <year> 1976. </year>
Reference-contexts: We sketch related work in each of these areas in turn. * There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions <ref> [7, 15, 17, 33] </ref> and tools [22] can provide information about uninitialised variables but are unable to track illegal accesses in dynamic data structures.
Reference: [18] <author> C. L. Hankin, D. Le Metayer, </author> <title> Deriving algorithms from type inference systems: Application to strictness analysis, </title> <booktitle> proc. ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1994, </year> <pages> pp. 202-212, </pages> <month> janvier </month> <year> 1994. </year>
Reference-contexts: We are currently investigating a more efficient version of the algorithm inspired by previous work on cahotic iteration [30] and lazy types <ref> [18] </ref> which avoid the exploration of the whole domain of properties (computing only the information required to answer an initial query). A complementary optimisation consists in using (standard) types to detect properties which cannot hold. Exploiting this extra information usually reduces dramatically the size of the properties manipulated by the algorithm.
Reference: [19] <author> S. Harbison and G. Steele Jr., </author> <title> C, a reference manual, second edition, </title> <booktitle> Prentice-Hall software series, </booktitle> <publisher> Prentice-Hall, INC., </publisher> <address> Englewood Cliffs, N.J. 07632, </address> <year> 1987. </year>
Reference: [20] <author> J. Hummel, L. Hendren and A. Nicolau, </author> <title> A general data dependence test for dynamic, pointer-based data structures, </title> <booktitle> in SIGPLAN'94 Conf. on Programming Language Design and Implementation PLDI'94, </booktitle> <month> Jun. </month> <year> 1994, </year> <pages> pp. 218-229. </pages>
Reference: [21] <author> D. Jackson, </author> <title> Aspect: an economical bug-detector, </title> <booktitle> in Proceedings of 13 th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1994, </year> <pages> pp. 13-22. </pages>
Reference-contexts: Most related contributions [7, 15, 17, 33] and tools [22] can provide information about uninitialised variables but are unable to track illegal accesses in dynamic data structures. Other techniques like <ref> [9, 16, 21] </ref> perform different kinds of analyses (like aspects, invariant propagation, program slicing) which are complementary to the work described here. * There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations (see [12,
Reference: [22] <author> S. Johnson, </author> <title> Lint, a C program checker, </title> <institution> Computer Science technical report, Bell Laboratories, </institution> <address> Murray Hill, NH, </address> <month> July </month> <year> 1978. </year>
Reference-contexts: We sketch related work in each of these areas in turn. * There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions [7, 15, 17, 33] and tools <ref> [22] </ref> can provide information about uninitialised variables but are unable to track illegal accesses in dynamic data structures.
Reference: [23] <author> N. Klarlund and M. Schwartzbach, </author> <title> Graph types, </title> <booktitle> in 20 th Annual ACM Symp. on Principles of Programming Languages POPL'93, </booktitle> <month> Jan. </month> <pages> 93, pp. 196-205. </pages>
Reference: [24] <author> W. Landi and B. Ryder, </author> <title> Pointer induced aliasing, a problem classification, </title> <booktitle> in 18 th Annual ACM Symp. on Principles of Programming Languages POPL'91, </booktitle> <month> Jan. </month> <year> 1991, </year> <pages> pp. 93-103. </pages>
Reference: [25] <author> W. Landi and B. Ryder, </author> <title> A safe approximate algorithm for interprocedural pointer aliasing, </title> <booktitle> in Proceedings of the ACM SIGPLAN'92 Conf. on Programming Language Design and Implementation PLDI'92, </booktitle> <month> Jun. </month> <year> 1992, </year> <pages> pp. 235-248. </pages>
Reference-contexts: If we prove fP r g f () fQ r g we can deduce fP g f () fQ r ^ P i g . Actually, much more factorisation is possible. As noted in <ref> [25] </ref>, a procedure f has the same effect on all alias pairs with contain variable x (in the scope of f) and any non-visible variable. This property can be formally justified and exploited in our framework.
Reference: [26] <author> R. London, J. Guttag, J. Horning, B. Lampson, J. Mitchell and G. Popek, </author> <title> Proof rules for the programming language Euclid, </title> <journal> in Acta Informatica 10, </journal> <pages> 1-26, </pages> <year> 1978. </year>
Reference: [27] <author> D. Luckham and N. Suzuki, </author> <title> Verification of array, record, and pointer operations in pascal, </title> <journal> in ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 1, </volume> <pages> No.2, </pages> <month> Oct. </month> <year> 1979, </year> <pages> pp. 226-244. </pages>
Reference-contexts: Most contributions in this area focus on generality and completeness issues and do not consider automatisation. An exception is the work by Luckham and Suzuki <ref> [27] </ref> which presents an axiom-based verifier for Pascal programs. The language of properties encompasses ours but is too rich to make the analysis fully automatic. The verifier (actually a theorem prover) depends heavily on user-supplied properties such as loop invariants.
Reference: [28] <author> J. Morris, </author> <title> A general axiom of assignment and Assignment and linked data structures, </title> <booktitle> in Theoretical Foundations of Programming Methodology, </booktitle> <editor> M. Broy and G. Schmidt (eds), </editor> <booktitle> pp. </booktitle> <pages> 25-41, </pages> <year> 1982. </year>
Reference-contexts: Also, it should be possible to include the numeric lattices of [12] in our framework (dealing with i ! properties rather than just 7! properties) but this extension requires further investigation. * Axiomatisation of pointer and alias relations has been studied for Pascal (see e.g. <ref> [10, 28, 8] </ref>). Most contributions in this area focus on generality and completeness issues and do not consider automatisation. An exception is the work by Luckham and Suzuki [27] which presents an axiom-based verifier for Pascal programs.
Reference: [29] <author> L. Osterweil, </author> <title> Using data-flow tools in software engineering, in Program flow analysis: Theory and applications,S. </title> <editor> Muchnick and N. Jones (Eds), </editor> <booktitle> Prentice-Hall software series, </booktitle> <pages> pp. 237-263. </pages>
Reference: [30] <author> M. Rosendahl, </author> <title> Higher-order chaotic iteration sequences, </title> <booktitle> in Proceedings of the 5th Int. Symp. Programming Language Implementation and Logic Programming PLILP'93, </booktitle> <publisher> LNCS 714, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The main source of inefficiency is the use of disjunctions to represent the lack of information incurred when dereferencing a variable v when flv 62 Var Prog . We are currently investigating a more efficient version of the algorithm inspired by previous work on cahotic iteration <ref> [30] </ref> and lazy types [18] which avoid the exploration of the whole domain of properties (computing only the information required to answer an initial query). A complementary optimisation consists in using (standard) types to detect properties which cannot hold.
Reference: [31] <author> S. Sagiv, N. Francez, M. Rodeh and R. Wilhelm, </author> <title> A logic-based approach to data flow analysis problems, </title> <booktitle> in Programming Language Implementation and Logic Programming PLILP'90, </booktitle> <volume> LNCS 456, </volume> <pages> pp. 277-292, </pages> <year> 1990. </year>
Reference-contexts: The language of properties encompasses ours but is too rich to make the analysis fully automatic. The verifier (actually a theorem prover) depends heavily on user-supplied properties such as loop invariants. The work whose spirit is the closest to our approach is the analysis framework presented in <ref> [31] </ref>. Environments are described as sets of assertions specified as Horn clauses. They define optimal analyses which exploit all the information available.
Reference: [32] <author> R. Sedgewick, </author> <title> Algorithms, </title> <publisher> Addison-Wesley publishing company, </publisher> <year> 1988. </year>
Reference-contexts: rule for assignment which follows from the following lemma: Lemma 3.5 P ) Assign v 1 v 2 (P )[[v 2 =v 1 ]] V 4 Checking a program manipulating circular data structures In this section, we illustrate our analysis with the program of Figure 7 (which is borrowed from <ref> [32] </ref>, page 22). This program first builds a circular list. Then, it proceeds through the list, counting through m 1 items and deleting the next, until only one is left (which points to itself). Figure 8 shows some steps of the analysis.
Reference: [33] <author> R. Strom and D. Yellin, </author> <title> Extending typestate checking using conditional liveness analysis, </title> <journal> in IEEE Transactions on Software Engineering, </journal> <volume> Vol. 19, No 5, </volume> <month> May. </month> <pages> 93, pp. 478-485. </pages>
Reference-contexts: We sketch related work in each of these areas in turn. * There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions <ref> [7, 15, 17, 33] </ref> and tools [22] can provide information about uninitialised variables but are unable to track illegal accesses in dynamic data structures.
Reference: [34] <author> R.P. Wilson and M.S. Lam, </author> <title> Efficient context-sensitive pointer analysis for C programs in Proceedings of the ACM SIGPLAN'95 Conf. </title> <booktitle> on Programming Language Design and Implementation PLDI'95, </booktitle> <month> Jun. </month> <year> 1995, </year> <pages> pp. 1-12. </pages>
References-found: 34

