URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-94-17.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: Poor Man's Watchpoints  
Author: Max Copperman Jeff Thomas Max Copperman Jeff Thomas 
Keyword: Categories and Subject Descriptors: D.2.5 [Software Engineering]: Testing and Debugging debugging aids; D.2.6 [Software Engineering]: Programming Environments; D.3.4 [Programming Languages]: Processors code generation, compilers General Terms: Algorithms, Languages Additional Keywords and Phrases: debugging, watchpoints, post-loaders, instrumentation  
Note: This work largely supported by Kubota  
Address: Santa Cruz, CA 95064  2630 Walsh Avenue Santa Clara, CA 95051-0905  
Affiliation: Board of Studies in Computer and Information Sciences University of California, Santa Cruz  Kubota Pacific Computer, Inc.  Pacific Computer, Inc.  
Pubnum: UCSC-CRL-94-17  
Date: April 26, 1994  
Abstract: Bugs that result from corruption of program data can be very difficult to track down without specialized help from a debugger. If the debugger cannot help the user find the point at which data gets corrupted, the user may have a long iterative debugging task. If the debugger is able to stop execution of the program at the point where data gets corrupted, as with watchpoints (also known as data breakpoints), it may be a very simple task to find a data corruption bug. In this paper, we discuss a method of implementing watchpoints on a system without hardware watchpoint support. By instrumenting the program code to check memory accesses, and supplying an interface to the instrumentation in the debugger, we provide an efficient, general method of implementing watchpoints. 
Abstract-found: 1
Intro-found: 1
Reference: [Wah92] <author> R. Wahbe, </author> <title> "Efficient Data Breakpoints", </title> <booktitle> Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Systems, SIGPLAN Notices, </booktitle> <volume> Vol. 27, No. 9, </volume> <pages> pp. 200-212, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The range of implementations is discussed in Wahbe <ref> [Wah92] </ref>, who compared simulations of each type of watchpoint implementation. According to his simulations, code patching is the most efficient method of implementing watchpoints in software. We implemented watchpoints via code patching on the Titan, a Mips R3000-based multiprocessor machine sold by Kubota Pacific Computer, Inc. (KPC).
Reference: [Wah93] <author> R. Wahbe, S. Lucco, S. Graham, </author> <title> "Practical Data Breakpoints: </title> <booktitle> Design and Implementation", Proceedings of the ACM SIGPLAN 1993 Conference on Programming Language Design and Implementation, SIGPLAN Notices, </booktitle> <volume> Vol. 28, No. 6, </volume> <pages> pp. 1-12, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: to Time to Time to Program Unpatched patch patch patch size stores loads both linpack 130992 1.1 1.1 1.2 C Compiler 2724352 21.6 23.1 N/A linker 56272 0.5 0.5 0.5 Table 0.3: Time required to patch sample programs (in seconds). slows programs down by an extreme factor: Wahbe et al. <ref> [Wah93] </ref> measured the overhead for watchpoints using dbx at a factor of 85,000. Unlike the context-switch approach, our watchpoint facility is fast enough for everyday use. The overhead can be significantly reduced by a more complex patching technology|Wahbe et al. [Wah93] achieved an overhead of only 25 per cent, watching stores <p> slows programs down by an extreme factor: Wahbe et al. <ref> [Wah93] </ref> measured the overhead for watchpoints using dbx at a factor of 85,000. Unlike the context-switch approach, our watchpoint facility is fast enough for everyday use. The overhead can be significantly reduced by a more complex patching technology|Wahbe et al. [Wah93] achieved an overhead of only 25 per cent, watching stores only. Finding a Free Register The high-level watchpoint facility design is portable at least among RISC machines. The implementation is highly dependent on the particular architecture.
Reference: [BK92] <author> J. Brown, R. Klamann, </author> <title> "The Application of Code Instrumentation Technology in the Los Alamos Debugger", </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop `92, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: An interesting technical issue is where the code to test the condition comes from. Kessler [Kes90] requires the code to be previously compiled and available to the Cedar debugger. Brown <ref> [BK92] </ref> has built a mini-compiler into the Los Alamos debugger ldb. Summary We have described a simple, reasonably efficient, extremely general watchpoint implementation that does not require hardware, operating system, or compiler support. A single watchpoint command can watch any contiguous range of locations.
Reference: [Kes90] <author> P. Kessler, </author> <title> "Fast Breakpoints: </title> <booktitle> Design and Implementation", Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Patching technology was used by Wahbe et al. to implement watchpoints on stores efficiently ([Wah93]). Patching technology has also been used to implement fast conditional breakpoints ([BK92], <ref> [Kes90] </ref>). When a breakpoint is set, the debugger patches in the code to test the condition, so that a context switch to the debugger only occurs when the condition is met. An interesting technical issue is where the code to test the condition comes from. Kessler [Kes90] requires the code to <p> fast conditional breakpoints ([BK92], <ref> [Kes90] </ref>). When a breakpoint is set, the debugger patches in the code to test the condition, so that a context switch to the debugger only occurs when the condition is met. An interesting technical issue is where the code to test the condition comes from. Kessler [Kes90] requires the code to be previously compiled and available to the Cedar debugger. Brown [BK92] has built a mini-compiler into the Los Alamos debugger ldb. Summary We have described a simple, reasonably efficient, extremely general watchpoint implementation that does not require hardware, operating system, or compiler support.
Reference: [Bro91] <author> J. S. Brown, </author> <title> "The Los Alamos Debugger ldb", </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop `91, </booktitle> <month> November </month> <year> 1991. </year>
Reference: [CH91] <author> B. Chase, R. Hood, </author> <title> "Debugging with Lightweight Instrumentation", </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop `91, </booktitle> <month> November </month> <year> 1991. </year>
Reference: [HJ92] <author> R. Hastings, B. Joyce, </author> <title> "Fast Detection of Memory Leaks and Access Errors", </title> <booktitle> Proceedings of the Winter Usenix Conference, </booktitle> <pages> pp. 1-12, </pages> <month> January </month> <year> 1992. </year>
Reference: [Kep93] <author> D. Keppel, </author> <title> "Fast Data Breakpoints", </title> <institution> University of Washington, Computer Science and Engineering Technical Report 93-06, </institution> <month> April </month> <year> 1993. </year> <note> Available as UW-CSE-93-04-06.PS.Z via anonymous ftp from ftp.cs.washington.edu. </note>
Reference: [LB92] <author> J. R. Larus, T. Ball, </author> <title> "Rewriting Executable Files to Measure Program Behavior", </title> <institution> University of Wisconsin-Madison, Computer Science Technical Report 1083, </institution> <month> March </month> <year> 1992, </year> <note> to appear in Software Practice & Experience. </note>
References-found: 9

