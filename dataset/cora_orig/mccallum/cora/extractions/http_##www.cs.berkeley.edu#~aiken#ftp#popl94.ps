URL: http://www.cs.berkeley.edu/~aiken/ftp/popl94.ps
Refering-URL: http://www.cs.berkeley.edu/~aiken/pubs.html
Root-URL: 
Email: faiken,wimmersg@almaden.ibm.com  lakshman@cs.uiuc.edu  
Title: Soft Typing with Conditional Types  
Author: Alexander Aiken and Edward L. Wimmers T. K. Lakshman 
Address: 650 Harry Rd., San Jose, CA 95120  1304 W. Springfield Ave, Urbana, IL 61801  
Affiliation: IBM Almaden Research Center  Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: We present a simple and powerful type inference method for dynamically typed languages where no type information is supplied by the user. Type inference is reduced to the problem of solvability of a system of type inclusion constraints over a type language that includes function types, constructor types, union, intersection, and recursive types, and conditional types. Conditional types enable us to analyze control flow using type inference, thus facilitating computation of accurate types. We demonstrate the power and practicality of the method with examples and performance results from an implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aiken, A., and Murphy, B. </author> <title> Implementing regular tree expressions. </title> <booktitle> In Proceedings of the 1991 Conference on Functional Programming Languages and Computer Architecture (Aug. </booktitle> <year> 1991), </year> <pages> pp. 427-447. </pages>
Reference-contexts: This level of performance is not trivial to achieve|a naive implementation is unusable even for small programs. We have relied heavily on a number of simple optimizations that improve the performance of the constraint solver by orders of magnitude <ref> [1] </ref>. In the current implementation, only about 10% of the time is spent solving constraints. The majority of the time is spent simplifying the representation of type expressions and determining where dynamic type checks should be inserted.
Reference: [2] <author> Aiken, A., and Murphy, B. </author> <title> Static type inference in a dynamically typed language. </title> <booktitle> In Eighteenth Annual ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1991), </year> <pages> pp. 279-290. </pages>
Reference-contexts: Most notably the system includes a mechanism for constraining the types of the branches of a conditional using information about the predicate. The system of Aiken and Murphy is a predecessor to the one presented here. In <ref> [2] </ref>, an analysis algorithm based on abstract interpretation combined with constraint solving over sets of regular trees is described. Essentially, the abstract interpretation is used to generate constraints that must be solved. The constraint language has no function types, intersection types are restricted, and there are no conditional types. <p> Like Shiver's algorithm, this algorithm performs an ad hoc analysis to constrain the types of the branches of a conditional using the type of the predicate. Based on several years experience with the implementation of <ref> [2] </ref>, we have come to the conclusion that there are two serious problems with techniques such as these. First, in these works (as in most work on abstract interpretation) there is an implicit assumption that the entire program is available for compilation at once, which is unrealistic.
Reference: [3] <author> Aiken, A., and Wimmers, E. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture (Copenhagen, </booktitle> <address> Denmark, </address> <month> June </month> <year> 1993), </year> <pages> pp. 31-41. </pages>
Reference-contexts: introduction of the type :X, the complement of type X. Definition 7.2 :X is the largest type such that :X " X = 0. The type :X is unique, so :X is well-defined. Also, constraints involving negated types can be solved; for details see <ref> [3] </ref>. As an example, the type :(1 ! 1) is the type of all non-functions, which is S c2C c (1; : : : ; 1) where C is the set of all data constructors. Consider the application constraint true ff ! fi from the example above. <p> These constraints are proper and can be solved using the algorithm in <ref> [3] </ref>. In addition, these constraints always have a solution (e.g., let all variables be 1; then the right-hand side of every constraint is 1). Let S be an extended system of constraints generated from a program e. After solving the constraints, each error variable fl is considered in turn.
Reference: [4] <author> Backus, J. </author> <title> Can programming be liberated from the von Neumann style? A functional style and its algebra of programs. </title> <journal> Commun. ACM 21, </journal> <month> 8 (Aug. </month> <year> 1978), </year> <pages> 613-641. </pages>
Reference-contexts: Note that the case where all error variables are replaced by 0 corresponds to a well-typed program. 8 Implementation There are two implementations of the type inference algorithm presented here: one for L and one for FL [5], a dynamically typed, higher-order functional language based on Backus' FP <ref> [4] </ref>. The implementation of type inference for L is small (about 100 lines of Lisp code).
Reference: [5] <author> Backus, J., Williams, J. H., Wimmers, E. L., Lu-cas, P., and Aiken, A. </author> <title> The FL language manual parts 1 and 2. </title> <type> Tech. Rep. RJ 7100 (67163), </type> <institution> IBM, </institution> <year> 1989. </year>
Reference-contexts: Note that the case where all error variables are replaced by 0 corresponds to a well-typed program. 8 Implementation There are two implementations of the type inference algorithm presented here: one for L and one for FL <ref> [5] </ref>, a dynamically typed, higher-order functional language based on Backus' FP [4]. The implementation of type inference for L is small (about 100 lines of Lisp code).
Reference: [6] <author> Cartwright, R., and Fagan, M. </author> <title> Soft typing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation (June 1991), </booktitle> <pages> pp. 278-292. </pages>
Reference-contexts: Partial types have the same limited expressive power as Gomard's system, and again the types assigned are not very precise. Closest in spirit to our own work is soft typing <ref> [6] </ref>. In [6], Cartwright and Fagan set out criteria that they feel any typing algorithm for dynamically typed languages should meet and provide an algorithm meeting those criteria. The typing algorithm generates type constraints that must be solved. <p> Partial types have the same limited expressive power as Gomard's system, and again the types assigned are not very precise. Closest in spirit to our own work is soft typing <ref> [6] </ref>. In [6], Cartwright and Fagan set out criteria that they feel any typing algorithm for dynamically typed languages should meet and provide an algorithm meeting those criteria. The typing algorithm generates type constraints that must be solved. <p> The constraints are not solved directly; they are first encoded in a special representation in which circular unification is used to obtain representations of solutions, which are then decoded back to types. We feel our approach also meets the criteria in <ref> [6] </ref> for a soft typing system, while providing a simpler formalism and a more accurate type assignment algorithm. Our approach is simpler because we deal directly with the type constraints, without any intermediate encoding. With respect to accuracy, the algorithm in [6] does include union types, function types, and parametric polymorphism. <p> We feel our approach also meets the criteria in <ref> [6] </ref> for a soft typing system, while providing a simpler formalism and a more accurate type assignment algorithm. Our approach is simpler because we deal directly with the type constraints, without any intermediate encoding. With respect to accuracy, the algorithm in [6] does include union types, function types, and parametric polymorphism. It does not have intersection types or conditional types, and unions types are restricted to be discriminative (disjuncts in unions must have distinct outermost constructors). At the present time we do not know how our method compares to that of [6] <p> <ref> [6] </ref> does include union types, function types, and parametric polymorphism. It does not have intersection types or conditional types, and unions types are restricted to be discriminative (disjuncts in unions must have distinct outermost constructors). At the present time we do not know how our method compares to that of [6] in practice. In future work we hope to make some empirical measurements of the strengths and weaknesses of both systems. Outside the realm of dynamically typed languages, Fuh and Mishra [9] and Mitchell [18] have given algorithms for type inference with subtypes. <p> Also related to our work are the refinement types of Freeman and Pfenning [8]. Refinement types include union and intersection types, but not conditional types. For each of the systems listed above, it is immediately apparent that our type language is more expressive, and with the exceptions of <ref> [6, 8] </ref> it is relatively easy to prove formally that our algorithm infers types that are at least as accurate. We believe such a proof is also possible with respect to the algorithm in [6], although a formal proof would be tedious to write down. <p> We believe such a proof is also possible with respect to the algorithm in <ref> [6] </ref>, although a formal proof would be tedious to write down. Currently we do not know the exact relationship of our system to that of [8].
Reference: [7] <author> Damas, L., and Milner, R. </author> <title> Principle type-schemes for functional programs. </title> <booktitle> In Ninth Annual ACM Symposium on Principles of Programming Languages (1982), </booktitle> <pages> pp. 207-212. </pages>
Reference: [8] <author> Freeman, T., and Pfenning, F. </author> <title> Refinement types for ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation (June 1991), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 268-277. </pages>
Reference-contexts: Neither approach incorporates union types, parametric polymorphism, or conditional types. The subtyping algorithm of [17] has limited union and intersection types, but no function types. Also related to our work are the refinement types of Freeman and Pfenning <ref> [8] </ref>. Refinement types include union and intersection types, but not conditional types. <p> Also related to our work are the refinement types of Freeman and Pfenning [8]. Refinement types include union and intersection types, but not conditional types. For each of the systems listed above, it is immediately apparent that our type language is more expressive, and with the exceptions of <ref> [6, 8] </ref> it is relatively easy to prove formally that our algorithm infers types that are at least as accurate. We believe such a proof is also possible with respect to the algorithm in [6], although a formal proof would be tedious to write down. <p> We believe such a proof is also possible with respect to the algorithm in [6], although a formal proof would be tedious to write down. Currently we do not know the exact relationship of our system to that of <ref> [8] </ref>. The greatest qualitative jump in accuracy in our system comes from the ability to encode control-flow analysis of case expressions; using conditional types, we are able to constrain the type of the branch of a case to reflect the possible values that could match the pattern.
Reference: [9] <author> Fuh, Y., and Mishra, P. </author> <title> Type inference with sub-types. </title> <booktitle> In Proceedings of the 1988 European Symposium on Programming (1988), </booktitle> <pages> pp. 94-114. </pages>
Reference-contexts: At the present time we do not know how our method compares to that of [6] in practice. In future work we hope to make some empirical measurements of the strengths and weaknesses of both systems. Outside the realm of dynamically typed languages, Fuh and Mishra <ref> [9] </ref> and Mitchell [18] have given algorithms for type inference with subtypes. Neither approach incorporates union types, parametric polymorphism, or conditional types. The subtyping algorithm of [17] has limited union and intersection types, but no function types.
Reference: [10] <author> Gomard, C. </author> <title> Partial type inference for untyped functional programs (extended abstract). </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming (1990), </booktitle> <pages> pp. 282-287. </pages>
Reference-contexts: The coverage of each proposal is necessarily brief. 9.1 Type Inference Systems A number of type inference systems for dynamically-typed languages have been proposed. Gomard's system adds to the Hindley/Milner type system an undefined type <ref> [10] </ref> and then uses a minor variation of the Hindley/Milner type assignment algorithm. The type undefined represents a value for which nothing is statically known, which is the same role 8 played by the type 1 in our system.
Reference: [11] <author> Heintze, N. </author> <title> Set Based Program Analysis. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference: [12] <author> Henglein, F. </author> <title> Dynamic typing. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming (July 1992), </booktitle> <pages> pp. 205-215. </pages>
Reference-contexts: Our algorithm is sufficiently declarative that we can give at least some guidance (Lemmas 4.5 and 4.6) to programmers who need to write efficient code. 9 9.4 Dynamic Typing Henglein proposes an algorithm for dynamic typing that removes both dynamic type checks and dynamic tags <ref> [12] </ref>. Since our algorithm does not deal with type tags (in fact, we assume all values are tagged) our techniques do not subsume those in [12]. <p> need to write efficient code. 9 9.4 Dynamic Typing Henglein proposes an algorithm for dynamic typing that removes both dynamic type checks and dynamic tags <ref> [12] </ref>. Since our algorithm does not deal with type tags (in fact, we assume all values are tagged) our techniques do not subsume those in [12]. On the other hand, our algorithm removes more dynamic type checks than the dynamic typing algorithm, which is monomorphic, has no intersection or union types, and performs no control-flow analysis. Thus, the two algorithms are incomparable and to some extent aimed at different problems.
Reference: [13] <author> Jones, N. D., and Muchnick, S. S. </author> <title> Flow analysis and optimization of LISP-like structures. </title> <booktitle> In Sixth Annual ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1979), </year> <pages> pp. 244-256. </pages>
Reference-contexts: Reynolds proposes a method for analyzing Lisp programs [19]. This is the first and only other use of conditional types of which we are aware. Jones and Muchnick propose a different analysis system based on solving equations over sets of regular trees <ref> [13] </ref>, which is used not only to eliminate dynamic type checks but also to reduce reference counting. Recently Wang and Hilfinger have proposed an analysis method based on tree grammars [23]. <p> The common weakness of these approaches is that they are inherently first-order (no function types) and monomor-phic. Furthermore, none of these techniques take advantage of control-flow information. One feature found in <ref> [13, 19] </ref> is the use of projections c 1 (c (X; Y )) = X to model selector functions.
Reference: [14] <author> Kozen, D., Palsberg, J., and Schwartzbach, M. I. </author> <title> Efficient inference of partial types. </title> <booktitle> In Foundations of Computer Science (Oct. </booktitle> <year> 1992), </year> <pages> pp. 363-371. </pages>
Reference-contexts: Another generalization of the Hindley/Milner system is partial types. In partial types, the type 1 is added to the usual Hindley/Milner types, but there is a different type assignment algorithm <ref> [14] </ref>. Partial types have the same limited expressive power as Gomard's system, and again the types assigned are not very precise. Closest in spirit to our own work is soft typing [6].
Reference: [15] <author> MacQueen, D., Plotkin, G., and Sethi, R. </author> <title> An ideal model for recursive polymophic types. </title> <booktitle> In Eleventh Annual ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1984), </year> <pages> pp. 165-174. </pages>
Reference: [16] <author> Milner, R. </author> <title> A theory of type polymorphism in programming. </title> <institution> J. Comput. Syst. Sci. </institution> <month> 17 </month> <year> (1978), </year> <pages> 348-375. </pages>
Reference: [17] <author> Mishra, P., and Reddy, U. </author> <title> Declaration-free type checking. </title> <booktitle> In Proceedings of the Twelfth Annual ACM Symposium on the Principles of Programming Languages (1985), </booktitle> <pages> pp. 7-21. </pages>
Reference-contexts: Outside the realm of dynamically typed languages, Fuh and Mishra [9] and Mitchell [18] have given algorithms for type inference with subtypes. Neither approach incorporates union types, parametric polymorphism, or conditional types. The subtyping algorithm of <ref> [17] </ref> has limited union and intersection types, but no function types. Also related to our work are the refinement types of Freeman and Pfenning [8]. Refinement types include union and intersection types, but not conditional types.
Reference: [18] <author> Mitchell, J. </author> <title> Coercion and type inference (summary). </title> <booktitle> In Eleventh Annual ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1984), </year> <pages> pp. 175-185. </pages>
Reference-contexts: At the present time we do not know how our method compares to that of [6] in practice. In future work we hope to make some empirical measurements of the strengths and weaknesses of both systems. Outside the realm of dynamically typed languages, Fuh and Mishra [9] and Mitchell <ref> [18] </ref> have given algorithms for type inference with subtypes. Neither approach incorporates union types, parametric polymorphism, or conditional types. The subtyping algorithm of [17] has limited union and intersection types, but no function types. Also related to our work are the refinement types of Freeman and Pfenning [8].
Reference: [19] <author> Reynolds, J. C. </author> <title> Automatic Computation of Data Set Definitions. </title> <booktitle> Information Processing 68. </booktitle> <publisher> North-Holland, </publisher> <year> 1969, </year> <pages> pp. 456-461. </pages>
Reference-contexts: Reynolds proposes a method for analyzing Lisp programs <ref> [19] </ref>. This is the first and only other use of conditional types of which we are aware. <p> The common weakness of these approaches is that they are inherently first-order (no function types) and monomor-phic. Furthermore, none of these techniques take advantage of control-flow information. One feature found in <ref> [13, 19] </ref> is the use of projections c 1 (c (X; Y )) = X to model selector functions.
Reference: [20] <author> Shivers, O. </author> <title> Control flow analysis in scheme. </title> <booktitle> In Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation (June 1988), </booktitle> <pages> pp. 164-174. </pages>
Reference-contexts: Shivers proposes a type recovery system for Scheme <ref> [20] </ref>. The algorithm is a classical abstract interpretation with a number of features designed specifically for type inference in dynamically typed programs. Most notably the system includes a mechanism for constraining the types of the branches of a conditional using information about the predicate.
Reference: [21] <author> Thatte, S. </author> <title> Type inference with partial types. </title> <booktitle> In Automata, Languages and Programming: 15th International Colloquium (July 1988), Springer-Verlag Lecture Notes in Computer Science, </booktitle> <volume> vol. 317, </volume> <pages> pp. 615-629. </pages>
Reference: [22] <author> Tofte, M. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference: [23] <author> Wang, E., and Hilfinger, P. N. </author> <title> Analysis of recursive types in Lisp-like languages. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming (June 1992), </booktitle> <pages> pp. 216-225. </pages>
Reference-contexts: Jones and Muchnick propose a different analysis system based on solving equations over sets of regular trees [13], which is used not only to eliminate dynamic type checks but also to reduce reference counting. Recently Wang and Hilfinger have proposed an analysis method based on tree grammars <ref> [23] </ref>. Since a grammar X ::= X 1 j : : : j X n is, by a small twist of perspective, a constraint X = X 1 [ : : : [ X n this algorithm also falls into the general class of constraint systems over regular trees.
References-found: 23

