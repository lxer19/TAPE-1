URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/dbpl93.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  kifer@cs.sunysb.edu  consens@db.toronto.edu  
Title: Database Programming in Transaction Logic  
Author: Anthony J. Bonner Michael Kifer Mariano Consens 
Date: Sept, 1993.  
Note: Published in Proceedings of the fourth International Workshop on Database Programming Languages (DBPL), pages 309-337. Springer Verlag, Workshops in Computing Series. Workshop held in  Work supported in part by an Operating Grant from the Natural Sciences and Engineering Research Council of Canada and by a Connaught Grant from the University of Toronto. Supported in part by NSF grant CCR-9102159 and a grant from New York Science and Technology Foundation. Work done during sabbatical year at the  is gratefully acknowledged.  
Address: Toronto, Ontario M5S 1A4, Canada  NY 11790, U.S.A.  Toronto, Ontario M5S 1A4, Canada  New York City, NY, 30 Aug-1  
Affiliation: University of Toronto Department of Computer Science  SUNY at Stony Brook Department of Computer Science Stony Brook,  University of Toronto Department of Computer Science  University of Toronto. Support of Computer Systems Research Institute of University of Toronto  
Abstract: This paper presents database applications of the recently proposed Transaction Logic| an extension of classical predicate logic that accounts in a clean and declarative fashion for the phenomenon of state changes in logic programs and databases. It has a natural model theory and a sound and complete proof theory, but, unlike many other logics, it allows users to program transactions. In addition, the semantics leads naturally to features whose amalgamation in a single logic has proved elusive in the past. Finally, Transaction Logic holds promise as a logical model of hitherto non-logical phenomena, including so-called procedural knowledge in AI, and the behavior of object-oriented databases, especially methods with side effects. This paper focuses on the applications of T R to database systems, including transaction definition and execution, nested transactions, view updates, consistency maintenance, bulk updates, non-determinism, sampling, active databases, dynamic integrity-constraints, hypothetical reasoning, and imperative-style programming. This paper is available at the following URL: ftp://db.toronto.edu/pub/bonner/papers/transaction.logic/dbpl93.ps.gz 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and A.J. Bonner. </author> <title> Objects and views. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 238-247, </pages> <address> Denver, Colorado, </address> <month> May 29-31 </month> <year> 1991. </year> <note> ACM. </note>
Reference-contexts: This approach to view updates is similar to that advocated for object-oriented databases, in which a different update method is programmed for each allowed view update <ref> [1, 6] </ref>. <p> Any subset will do as long as it has the following two properties: * it satisfies the specified FD, 1 ! 2; and * sample <ref> [1] </ref> = eligible [1], i.e., the projections of sample and eligible on the first attribute are equal (and thus every department is represented in the sample). <p> Any subset will do as long as it has the following two properties: * it satisfies the specified FD, 1 ! 2; and * sample <ref> [1] </ref> = eligible [1], i.e., the projections of sample and eligible on the first attribute are equal (and thus every department is represented in the sample).
Reference: [2] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural and declarative database update languages. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 240-250, </pages> <address> New York, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: A transaction base defines complex formulas in terms of simpler ones. However, we also need a way to specify elementary changes to a database. One way to define such transitions is to build them into the semantics as in <ref> [25, 27, 16, 2] </ref>. A problem with this approach is that adding new kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to an overhaul of the entire proof theory. <p> For example, inserting a set of tuples into a relation is a basic SQL operation, as is deleting a set of tuples from a relation. Yet, bulk updates like these are conspicuously absent from most logic-based proposals for updating logic programs. The few exceptions are <ref> [13, 16, 27, 2] </ref>, which are discussed in Section 4. The unusual difficulty with this kind of update seems to arise because most logical formulations of updates are based on the insertion and deletion of single tuples. This is not how SQL works, however. <p> Abiteboul and Vianu developed a family of declarative update languages <ref> [2] </ref>, including impressive results on complexity and expressibility. However, these languages lack several features that are present in T R. First, they apply only to relational databases, not to arbitrary sets of first-order formulas. Thus, it is not possible to insert or delete rules from a deductive database. <p> Finally, these languages do not support transaction subroutines. This lack of subroutines is reflected in the data complexity of some of the languages: they are in PSPACE, whereas recursive subroutines require EXPTIME. The works [28, 17] are related to <ref> [2] </ref> in that they all borrow much of their syntax from deductive databases and yet their semantics is operational (although inspired by logical model theory).
Reference: [3] <author> R. Agrawal, R. Cochrane, and B. Lindsay. </author> <title> On maintaining priorities in a production rule system. </title> <booktitle> In Intl. Conference on Very Large Data Bases (VLDB), </booktitle> <pages> pages 479-487. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1991. </year> <month> 21 </month>
Reference-contexts: If the order of the active rules is immaterial, then the definition of event (X) will have one rule for each permutation of the active rules. By selecting a particular subset of all permutations, one can specify the conflict resolution strategy employed by the system <ref> [34, 3] </ref>. (The reader should not be frightened by the prospect of having to write n! rules. First, this can be done automatically. Second, T R has an operator, called shu*e, which makes this tiresome encoding much more succinct.
Reference: [4] <author> J.F. Allen. </author> <title> Towards a general theory of action and time. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 123-154, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Such constraints are particularly well suited to areas such as planning and design, where it is common to place constraints on the way things are done. This section illustrates a variety of dynamic constraints expressible in T R. These include temporal constraints in the style of James Allen <ref> [4] </ref>, such as, "immediately after," "some time after," "during," "at the start of," and "at the end of." There are several important problems related to constraints. One such problem, and the main subject of this section, is constraint satisfaction. <p> For example, constraints (iii) and (iv) are expressed by the following two formulas, respectively: unlock ( shoot shoot ) lock load In addition to the temporal relations "immediately before" and "immediately after," T R can express many other temporal relations in the style of James Allen's theory of time intervals <ref> [4] </ref>. These relations include "some time before," "some time after," "during," "at the start of," "at the end of," etc.
Reference: [5] <editor> F. Bancilhon. A logic-programming/Object-oriented cocktail. </editor> <booktitle> SIGMOD Record, </booktitle> <volume> 15(3) </volume> <pages> 11-21, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: However, despite a plethora of action logics, researchers continue to complain that there is no clear declarative semantics for updates, whether in databases or in logic programming <ref> [7, 5, 28] </ref>. In fact|in stark contrast to classical logic|no action logic has ever become a core of databases or logic-programming, in theory or in practice. There appear to be a few simple reasons for this unsuitability of existing action logics.
Reference: [6] <author> T. Barsalou, N. Siambela, A.M. Keller, and G. Wiederhold. </author> <title> Updating relational databases through object-based views. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 248-257, </pages> <address> Denver, Colorado, </address> <month> May 29-31 </month> <year> 1991. </year> <note> ACM. </note>
Reference-contexts: This approach to view updates is similar to that advocated for object-oriented databases, in which a different update method is programmed for each allowed view update <ref> [1, 6] </ref>.
Reference: [7] <author> C. Beeri. </author> <title> New data models and languages|The challenge. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 1-15, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: However, despite a plethora of action logics, researchers continue to complain that there is no clear declarative semantics for updates, whether in databases or in logic programming <ref> [7, 5, 28] </ref>. In fact|in stark contrast to classical logic|no action logic has ever become a core of databases or logic-programming, in theory or in practice. There appear to be a few simple reasons for this unsuitability of existing action logics.
Reference: [8] <author> C. Beeri and T. Milo. </author> <title> A model for active object-oriented database. </title> <booktitle> In Intl. Conference on Very Large Data Bases (VLDB), </booktitle> <pages> pages 337-349. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1991. </year>
Reference-contexts: Active rules that are triggered by such events will be executed just before trans starts or just after it terminates. Events specified in this way generalize those supported in actual systems [31, 34, 18], and are analogous to the idea of method invocation and method termination proposed in <ref> [8] </ref>. An Example Consider an active database system that enforces the following constraint: after any salary increase or a salary cut, no staff member should earn more than 120% of his manager's salary.
Reference: [9] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Complexity and expressibility. </title> <journal> Theoretical Computer Science, </journal> <volume> 76 </volume> <pages> 3-51, </pages> <year> 1990. </year>
Reference-contexts: Thus we do not have to explicitly construct a choice operator, unlike in [24, 30]. Instead, it falls out naturally from the semantics of T R as a special case. 13 3.5 Hypothetical Reasoning Hypothetical queries play an important role in reasoning about knowledge <ref> [9] </ref>. Because of such queries, it is often necessary to perform hypothetical updates as well as actual ones.
Reference: [10] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming (or a logic of declarative and procedural knowledge). </title> <type> Technical Report CSRI-270, </type> <institution> University of Toronto, </institution> <month> April </month> <year> 1992. </year> <note> Revised: February 1994. ftp://csri-technical-reports/270/report.ps. </note>
Reference-contexts: This is possible because, like classical logic, T R has a "Horn" version that has both a procedural and a declarative semantics, as well as an efficient SLD-style proof procedure. Since the formal aspects of T R can be found in <ref> [12, 10, 11] </ref>, this paper focuses on the applications of T R to database systems. T R was designed with several applications in mind, especially in databases, logic programming, and AI. It was therefore developed as a general logic, so that it could solve a wide range of update-related problems. <p> It was therefore developed as a general logic, so that it could solve a wide range of update-related problems. Individual applications can be carved out of different fragments of the logic. These applications, both practical and theoretical, are discussed in great detail in <ref> [10] </ref>. For instance, in logic programming, T R leads to a clean, logical treatment of the assert and retract operators in Prolog, which effectively extends the theory of logic programming to include updates as well as queries. <p> In fact|in stark contrast to classical logic|no action logic has ever become a core of databases or logic-programming, in theory or in practice. There appear to be a few simple reasons for this unsuitability of existing action logics. These reasons are discussed at length in <ref> [10] </ref>, and we discuss some of them briefly here. First, most logics of time or action are hypothetical. For instance, some systems can infer that if action A precedes B, and B precedes C, then A must precede C. <p> It also has a natural model theory and a sound-and-complete proof theory. This section gives an overview of the syntax and the model theory. A complete development of T R , including proof theory, can be found in <ref> [10] </ref> (and to some extent in [12]). Like classical logic, T R has a "Horn" version that is of particular interest for deductive databases. In Horn T R, a transaction is defined by Datalog-style rules in which the premise specifies a sequence of queries and updates. <p> Horn T R is thus a logical language for programming database transactions, just as Datalog is a logical language for programming queries. Furthermore, Horn T R has an efficient SLD-style proof procedure and also a dual, bottom-up procedure <ref> [12, 10] </ref>. These proof procedures answer queries, execute transactions, and update the database. <p> This is a serious drawback since there appears to be no small, single set of elementary transitions that is best for all purposes <ref> [10] </ref>. Indeed, Sections 3.3 and 3.4 introduce two new kinds of elementary update. Thus, rather than committing T R to a fixed set of elementary transitions, we have chosen to treat the elementary transitions as a parameter of T R. <p> In practice, these formulas would not be materialized all at once, but would be generated on demand by an algorithm. The reader is referred to <ref> [10] </ref> for a more detailed discussion of transition bases. As seen from the above syntax, there is no strict distinction in T R between predicates that query the database and predicates that update it. <p> T R fixes this problem by providing a simple logical semantics for database updates. 2.3 Model Theory This section discusses the model theory of T R. For easy reference, some details are given in Appendix A; the reader is referred to <ref> [10] </ref> for a full treatment. <p> Instead, we focus on paths, that is, on sequences of states. (This focus 6 on paths is related to the version of Process Logic in [20], but the two logics are fundamentally different <ref> [10] </ref>.) Because of the emphasis on paths, we refer to semantic structures in T R as path structures. Second, truth in path structures is defined on paths, not states. <p> These features include transaction definition and execution, ad hoc queries, view updates, consistency maintenance, bulk updates, non-determinism, sampling, dynamic integrity-constraints, invented values, and more. This section describes some of these applications; more can be found in <ref> [10] </ref>. We shall also see that the semantics of T R allows the easy introduction of a modal necessity operator, 2, which captures a whole new range of applications. These applications 7 include hypothetical reasoning, imperative programming constructs, active databases, software verification, and more. <p> Otherwise, if literals can be negative, truth should be viewed with respect to a perfect model of . See <ref> [10] </ref> for more details. 12 In T R, the choice-operator can be represented as another kind of elementary bulk update, one closely related to the relational assignment operator of the previous section. <p> Likewise, possibility means that is executable along some path leaving the current state. Hypotheticals hold immediately, i.e., over paths of length 1, and so they do not cause any real state transitions. The formal meaning of hypothetical formulas is given in the appendix. As shown in <ref> [10] </ref>, these formulas cannot be be expressed in the version of T R presented so far. Thus they strictly increase the power of the language. The next two sections explore some non-trivial application of hypothetical operators. <p> Thus they strictly increase the power of the language. The next two sections explore some non-trivial application of hypothetical operators. Other applications of hypotheticals as well as a sound-and-complete proof theory for them are developed in <ref> [10] </ref>. 3.6 Imperative Programming Constructs Perhaps, one of the most interesting bonuses provided by the hypothetical operators in T R is the ability to express standard imperative constructs, such as if-then-else and while-do in a simple, declarative way. <p> Furthermore, the negation in "2:a" is of the negation-by-failure variety. In <ref> [10] </ref>, we present the perfect-model semantics for this negation, an adaptation from [29]. 14 In imperative programming, it is often the case that the else-part is omitted, which corre-sponds to "else do nothing." To capture this, we simply remove action c from (4), Thus, the statement if 3a then b fi <p> Likewise, none of them can seamlessly accommodate hypothetical state transitions with transitions that actually commit; and, with the exception of [22], all of the works are limited to updating sets of ground atomic facts. A much more extensive comparison can be found in <ref> [10] </ref>. Winslett [35] did foundational work on the meaning of updates to general logical theories. Later, Grahne, Katsuno and Mendelzon [22, 19] axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results.
Reference: [11] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic: An (early) expose. In V.S. </title> <editor> Alagar, L.V.S. Lakshmanan, and F. Sadri, editors, </editor> <booktitle> Proceedings of the Workshop on Formal Methods in Databases and Software Engineering, Workshops in Computing, </booktitle> <pages> pages 1-23. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <title> Keynote address. Workshop held 15-16 May, </title> <booktitle> 1992, </booktitle> <address> Montreal, Canada. </address>
Reference-contexts: This is possible because, like classical logic, T R has a "Horn" version that has both a procedural and a declarative semantics, as well as an efficient SLD-style proof procedure. Since the formal aspects of T R can be found in <ref> [12, 10, 11] </ref>, this paper focuses on the applications of T R to database systems. T R was designed with several applications in mind, especially in databases, logic programming, and AI. It was therefore developed as a general logic, so that it could solve a wide range of update-related problems.
Reference: [12] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming. </title> <booktitle> In Intl. Conference on Logic Programming (ICLP), </booktitle> <pages> pages 257-282, </pages> <address> Budapest, Hungary, June 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: This is possible because, like classical logic, T R has a "Horn" version that has both a procedural and a declarative semantics, as well as an efficient SLD-style proof procedure. Since the formal aspects of T R can be found in <ref> [12, 10, 11] </ref>, this paper focuses on the applications of T R to database systems. T R was designed with several applications in mind, especially in databases, logic programming, and AI. It was therefore developed as a general logic, so that it could solve a wide range of update-related problems. <p> It also has a natural model theory and a sound-and-complete proof theory. This section gives an overview of the syntax and the model theory. A complete development of T R , including proof theory, can be found in [10] (and to some extent in <ref> [12] </ref>). Like classical logic, T R has a "Horn" version that is of particular interest for deductive databases. In Horn T R, a transaction is defined by Datalog-style rules in which the premise specifies a sequence of queries and updates. <p> Horn T R is thus a logical language for programming database transactions, just as Datalog is a logical language for programming queries. Furthermore, Horn T R has an efficient SLD-style proof procedure and also a dual, bottom-up procedure <ref> [12, 10] </ref>. These proof procedures answer queries, execute transactions, and update the database.
Reference: [13] <author> F. Bry. </author> <title> Intensional updates: Abduction via deduction. </title> <booktitle> In Intl. Conference on Logic Programming (ICLP), </booktitle> <address> Jerusalem, Israel, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: For example, inserting a set of tuples into a relation is a basic SQL operation, as is deleting a set of tuples from a relation. Yet, bulk updates like these are conspicuously absent from most logic-based proposals for updating logic programs. The few exceptions are <ref> [13, 16, 27, 2] </ref>, which are discussed in Section 4. The unusual difficulty with this kind of update seems to arise because most logical formulations of updates are based on the insertion and deletion of single tuples. This is not how SQL works, however.
Reference: [14] <author> A.K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: In this section, we consider relational assignment, which copies the contents of one relation into another relation. Just as variable assignment is a basic operation of procedural programming languages, relational assignment can be used as a basic operation of procedural database languages <ref> [14, 15] </ref>. The rest of this section shows how to express and use relational assignment in T R. Unlike [25, 27, 16], specific elementary transitions are not built into the semantics of T R.
Reference: [15] <author> A.K. Chandra and D. Harel. </author> <title> Structure and complexity of relational queries. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(1) </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: In this section, we consider relational assignment, which copies the contents of one relation into another relation. Just as variable assignment is a basic operation of procedural programming languages, relational assignment can be used as a basic operation of procedural database languages <ref> [14, 15] </ref>. The rest of this section shows how to express and use relational assignment in T R. Unlike [25, 27, 16], specific elementary transitions are not built into the semantics of T R.
Reference: [16] <author> W. Chen. </author> <title> Declarative specification and evaluation of database updates. </title> <booktitle> In Intl. Conference on Deductive and Object-Oriented Databases (DOOD), volume 566 of Lecture Notes in Computer Science, </booktitle> <pages> pages 147-166. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1991. </year>
Reference-contexts: A transaction base defines complex formulas in terms of simpler ones. However, we also need a way to specify elementary changes to a database. One way to define such transitions is to build them into the semantics as in <ref> [25, 27, 16, 2] </ref>. A problem with this approach is that adding new kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to an overhaul of the entire proof theory. <p> For example, inserting a set of tuples into a relation is a basic SQL operation, as is deleting a set of tuples from a relation. Yet, bulk updates like these are conspicuously absent from most logic-based proposals for updating logic programs. The few exceptions are <ref> [13, 16, 27, 2] </ref>, which are discussed in Section 4. The unusual difficulty with this kind of update seems to arise because most logical formulations of updates are based on the insertion and deletion of single tuples. This is not how SQL works, however. <p> Just as variable assignment is a basic operation of procedural programming languages, relational assignment can be used as a basic operation of procedural database languages [14, 15]. The rest of this section shows how to express and use relational assignment in T R. Unlike <ref> [25, 27, 16] </ref>, specific elementary transitions are not built into the semantics of T R. Relational assignment can therefore be added to T R by simply adding appropriate formulas to the transition base. To see how, consider a T R language, L.
Reference: [17] <author> C. de Maindreville and E. Simon. </author> <title> Non-deterministic queries and updates in deductive databases. </title> <booktitle> In Intl. Conference on Very Large Data Bases (VLDB). </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1988. </year> <month> 22 </month>
Reference-contexts: Finally, these languages do not support transaction subroutines. This lack of subroutines is reflected in the data complexity of some of the languages: they are in PSPACE, whereas recursive subroutines require EXPTIME. The works <ref> [28, 17] </ref> are related to [2] in that they all borrow much of their syntax from deductive databases and yet their semantics is operational (although inspired by logical model theory).
Reference: [18] <author> N. Gehani and V. Jagadish. </author> <title> ODE as an active database: Constraints and triggers. </title> <booktitle> In Intl. Conference on Very Large Data Bases (VLDB), </booktitle> <pages> pages 327-336. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1991. </year>
Reference-contexts: Active rules that are triggered by such events will be executed just before trans starts or just after it terminates. Events specified in this way generalize those supported in actual systems <ref> [31, 34, 18] </ref>, and are analogous to the idea of method invocation and method termination proposed in [8]. An Example Consider an active database system that enforces the following constraint: after any salary increase or a salary cut, no staff member should earn more than 120% of his manager's salary.
Reference: [19] <author> G. Grahne and A.O. Mendelzon. </author> <title> Updates and subjunctive queries. </title> <type> Technical Report KRR-TR-91-4, </type> <institution> CSRI, University of Toronto, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: A much more extensive comparison can be found in [10]. Winslett [35] did foundational work on the meaning of updates to general logical theories. Later, Grahne, Katsuno and Mendelzon <ref> [22, 19] </ref> axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results.
Reference: [20] <author> D. Harel, D. Kozen, and R. Parikh. </author> <title> Process Logic: Expressiveness, decidability, completeness. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(2) </volume> <pages> 144-170, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: The first major difference is that truth in T R structures does not hinge on a set of arcs between states. Instead, we focus on paths, that is, on sequences of states. (This focus 6 on paths is related to the version of Process Logic in <ref> [20] </ref>, but the two logics are fundamentally different [10].) Because of the emphasis on paths, we refer to semantic structures in T R as path structures. Second, truth in path structures is defined on paths, not states.
Reference: [21] <author> R. Hull and D. Jacobs. </author> <title> Language constructs for programming active databases. </title> <booktitle> In Intl. Conference on Very Large Data Bases (VLDB), </booktitle> <pages> pages 455-467. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1991. </year>
Reference-contexts: It is not hard to program more sophisticated systems. The use of database programming languages to model active database systems has been discussed in <ref> [21, 32] </ref>. In those attempts, the underlying semantics is denotational. There are two main reasons for using T R to specify active database features and implementations. First, 15 T R provides a complete formalization (including a model and a proof theory) for the behavior of the system.
Reference: [22] <author> H. Katsuno and A.O. Mendelzon. </author> <title> On the difference between updating a knowledge base and revising it. </title> <booktitle> In Proceedings of the International Conference on Knowledge Representation and Reasoning (KR), </booktitle> <pages> pages 387-394, </pages> <address> Boston, Mass., </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Likewise, we represent deletions from p 2 For relational databases, the operators + and can be thought of as union and set-difference. However, if D is a general first-order formula, then defining insertion and deletion is more involved <ref> [22] </ref>. 4 by the predicate del:p. Thus the formula ins:p (a) ins:p (b) ins:p (c) represents an updating transaction that inserts p (a) into the database, then p (b), and then p (c). 2.2 An Example This section gives a simple example of a transaction base. <p> For example, what does it mean to insert an atom b into a database that entails :b, especially if :b itself is not explicitly present in the database? There is no simple answer to this question, and many solutions have been proposed (see <ref> [22] </ref> for a comprehensive discussion). For these reasons, we take a general approach to elementary updates. For us, an elementary update is a mapping that takes each database D 1 to some other database D 2 , where a database is any first-order formula. <p> In particular, none of the works discussed below is capable of expressing constraints on the execution of complex transactions. Likewise, none of them can seamlessly accommodate hypothetical state transitions with transitions that actually commit; and, with the exception of <ref> [22] </ref>, all of the works are limited to updating sets of ground atomic facts. A much more extensive comparison can be found in [10]. Winslett [35] did foundational work on the meaning of updates to general logical theories. <p> A much more extensive comparison can be found in [10]. Winslett [35] did foundational work on the meaning of updates to general logical theories. Later, Grahne, Katsuno and Mendelzon <ref> [22, 19] </ref> axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results.
Reference: [23] <author> M. Kifer, G. Lausen, and J. Wu. </author> <title> Logical foundations of object-oriented and frame-based languages. </title> <journal> Journal of ACM, </journal> <month> May </month> <year> 1995. </year>
Reference-contexts: In object-oriented databases, T R can be combined with object-oriented logics, such as F-logic <ref> [23] </ref>, to provide a logical account of methods|procedures hidden inside objects that manipulate these objects' internal states. Thus, while F-logic covers the structural aspect of object-oriented databases, its combination with T R would account for the behavioral aspect as well. In AI, T R suggests a logical account of planning. <p> T R achieves this by allowing every logical formula to have not only a truth value, but also a "side effect" on the database. In this way, one can account for the behavior of object-oriented databases|something that most formalisms do not do. By integrating T R with F-logic <ref> [23] </ref>, the structural aspect of object-oriented systems can be accounted for as well. The system that comes closest in spirit to T R is Prolog.
Reference: [24] <author> R. Krishnamurthy and S. Naqvi. </author> <title> Non-deterministic choice in Datalog. </title> <booktitle> In Proceedings of the 3-d Intl. Conference on Data and Knowledge Bases, </booktitle> <pages> pages 416-424. </pages> <publisher> Morgan-Kaufmann Publ., </publisher> <year> 1988. </year>
Reference-contexts: Using the methods introduced in Section 3.6, one can iterate over the relation q one tuple at a time, just like an SQL cursor. T R can thus be seen as a formal basis for embedded SQL. 3.4 Non-Deterministic Sampling In <ref> [24] </ref>, Krishnamurthy and Naqvi proposed the so-called choice-operator. <p> The important point here is that the semantics of T R allows such procedures. Thus we do not have to explicitly construct a choice operator, unlike in <ref> [24, 30] </ref>. Instead, it falls out naturally from the semantics of T R as a special case. 13 3.5 Hypothetical Reasoning Hypothetical queries play an important role in reasoning about knowledge [9]. Because of such queries, it is often necessary to perform hypothetical updates as well as actual ones.
Reference: [25] <author> S. Manchanda and D.S. Warren. </author> <title> A logic-based language for database updates. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: A transaction base defines complex formulas in terms of simpler ones. However, we also need a way to specify elementary changes to a database. One way to define such transitions is to build them into the semantics as in <ref> [25, 27, 16, 2] </ref>. A problem with this approach is that adding new kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to an overhaul of the entire proof theory. <p> Just as variable assignment is a basic operation of procedural programming languages, relational assignment can be used as a basic operation of procedural database languages [14, 15]. The rest of this section shows how to express and use relational assignment in T R. Unlike <ref> [25, 27, 16] </ref>, specific elementary transitions are not built into the semantics of T R. Relational assignment can therefore be added to T R by simply adding appropriate formulas to the transition base. To see how, consider a T R language, L. <p> Later, Grahne, Katsuno and Mendelzon [22, 19] axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results. Manchanda and Warren <ref> [25] </ref> introduce Dynamic Prolog|a logic system where update transactions "work right," i.e., when failed, they do not leave a residue in the database. Like T R, their logic can be used to update views, and transactions can be nondeterministic.
Reference: [26] <author> D.R. McCarthy and U. Dayal. </author> <title> The architecture of an active database management system. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 215-224, </pages> <address> New York, 1989. </address> <publisher> ACM. </publisher>
Reference-contexts: This particular active rule is given the name a rule, and its intended meaning is that when the given event occurs, and provided that condition is true at that moment, the system should automatically execute action. This policy is known as immediate coupling of conditions and actions <ref> [26] </ref>. Later, we show how active rules like these can be programmed in T R. In this paper, we limit our attention to two kinds of events: commencement of a transaction and termination of a transaction.
Reference: [27] <author> S. Naqvi and R. Krishnamurthy. </author> <title> Database updates in logic programming. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 251-262, </pages> <address> New York, </address> <month> March </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: A transaction base defines complex formulas in terms of simpler ones. However, we also need a way to specify elementary changes to a database. One way to define such transitions is to build them into the semantics as in <ref> [25, 27, 16, 2] </ref>. A problem with this approach is that adding new kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to an overhaul of the entire proof theory. <p> For example, inserting a set of tuples into a relation is a basic SQL operation, as is deleting a set of tuples from a relation. Yet, bulk updates like these are conspicuously absent from most logic-based proposals for updating logic programs. The few exceptions are <ref> [13, 16, 27, 2] </ref>, which are discussed in Section 4. The unusual difficulty with this kind of update seems to arise because most logical formulations of updates are based on the insertion and deletion of single tuples. This is not how SQL works, however. <p> Just as variable assignment is a basic operation of procedural programming languages, relational assignment can be used as a basic operation of procedural database languages [14, 15]. The rest of this section shows how to express and use relational assignment in T R. Unlike <ref> [25, 27, 16] </ref>, specific elementary transitions are not built into the semantics of T R. Relational assignment can therefore be added to T R by simply adding appropriate formulas to the transition base. To see how, consider a T R language, L. <p> To a certain extent, it can be said that Manchanda and Warren have managed to formalize their intuition procedurally, but not as an inference system. Naqvi and Krishnamurthy <ref> [27] </ref> extended Datalog with update operators, which were later incorporated in the LDL language. Since LDL is geared towards database applications, this 20 extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in [27] is somewhat limited. <p> Naqvi and Krishnamurthy <ref> [27] </ref> extended Datalog with update operators, which were later incorporated in the LDL language. Since LDL is geared towards database applications, this 20 extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in [27] is somewhat limited. First, it matches the proposed execution model only in the propositional case, and so it does not cover bulk updates. Second, it is only defined for update-programs in which commutativity of elementary updates can be assumed. <p> Second, it is only defined for update-programs in which commutativity of elementary updates can be assumed. For sequences of updates in which this does not hold, the semantics turns out to be rather tricky and certainly does not qualify as "model theoretic." Third, the definition of "legal" programs in <ref> [27] </ref> is highly restrictive, making it difficult to build complex transactions out of simpler ones. Abiteboul and Vianu developed a family of declarative update languages [2], including impressive results on complexity and expressibility. However, these languages lack several features that are present in T R.
Reference: [28] <author> G. Phipps, M.A. Derr, and K.A. Ross. </author> <title> Glue-Nail: A deductive database system. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 308-317, </pages> <address> New York, 1991. </address> <publisher> ACM. </publisher>
Reference-contexts: However, despite a plethora of action logics, researchers continue to complain that there is no clear declarative semantics for updates, whether in databases or in logic programming <ref> [7, 5, 28] </ref>. In fact|in stark contrast to classical logic|no action logic has ever become a core of databases or logic-programming, in theory or in practice. There appear to be a few simple reasons for this unsuitability of existing action logics. <p> Finally, these languages do not support transaction subroutines. This lack of subroutines is reflected in the data complexity of some of the languages: they are in PSPACE, whereas recursive subroutines require EXPTIME. The works <ref> [28, 17] </ref> are related to [2] in that they all borrow much of their syntax from deductive databases and yet their semantics is operational (although inspired by logical model theory).
Reference: [29] <author> T.C. Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: Furthermore, the negation in "2:a" is of the negation-by-failure variety. In [10], we present the perfect-model semantics for this negation, an adaptation from <ref> [29] </ref>. 14 In imperative programming, it is often the case that the else-part is omitted, which corre-sponds to "else do nothing." To capture this, we simply remove action c from (4), Thus, the statement if 3a then b fi can be expressed as follows: if a b (3a) b (5) Similarly,
Reference: [30] <author> D. Sacca and C. Zaniolo. </author> <title> Stable models and non-determinism in logic programs with negation. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 205-217, </pages> <address> New York, </address> <month> April </month> <year> 1990. </year> <journal> ACM. </journal> <volume> 23 </volume>
Reference-contexts: The important point here is that the semantics of T R allows such procedures. Thus we do not have to explicitly construct a choice operator, unlike in <ref> [24, 30] </ref>. Instead, it falls out naturally from the semantics of T R as a special case. 13 3.5 Hypothetical Reasoning Hypothetical queries play an important role in reasoning about knowledge [9]. Because of such queries, it is often necessary to perform hypothetical updates as well as actual ones.
Reference: [31] <author> M. Stonebraker, A. Jhingran, J. Goh, and S. Potamianos. </author> <title> On rules, procedures, caching and views in data base systems. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 281-290, </pages> <address> New York, 1990. </address> <publisher> ACM. </publisher>
Reference-contexts: Active rules that are triggered by such events will be executed just before trans starts or just after it terminates. Events specified in this way generalize those supported in actual systems <ref> [31, 34, 18] </ref>, and are analogous to the idea of method invocation and method termination proposed in [8]. An Example Consider an active database system that enforces the following constraint: after any salary increase or a salary cut, no staff member should earn more than 120% of his manager's salary.
Reference: [32] <author> J. Widom. </author> <title> A denotational semantics for the starbust production rule language. </title> <journal> ACM SIGMOD Record, </journal> <volume> 21(3) </volume> <pages> 4-9, </pages> <year> 1992. </year>
Reference-contexts: It is not hard to program more sophisticated systems. The use of database programming languages to model active database systems has been discussed in <ref> [21, 32] </ref>. In those attempts, the underlying semantics is denotational. There are two main reasons for using T R to specify active database features and implementations. First, 15 T R provides a complete formalization (including a model and a proof theory) for the behavior of the system.
Reference: [33] <author> J. Widom, R.J. Cochrane, and B.G. Lindsay. </author> <title> Implementing set-oriented production rules as an extension to starbust. </title> <booktitle> In Intl. Conference on Very Large Data Bases (VLDB), </booktitle> <pages> pages 275-285. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1991. </year>
Reference-contexts: Second, T R has one underlying notation and semantics, which can describe behavior procedurally and in detail, or declaratively and at a high level. We shall use the notation for active rules 4 suggested in Starburst <ref> [33] </ref>: 5 define active rule a rule when event if condition then action (8) We consider these active rules to be part of the transaction base.
Reference: [34] <author> J. Widom and S.J. Finkelstein. </author> <title> Set-oriented production rules in relational database systems. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 259-270, </pages> <address> New York, 1990. </address> <publisher> ACM. </publisher>
Reference-contexts: Active rules that are triggered by such events will be executed just before trans starts or just after it terminates. Events specified in this way generalize those supported in actual systems <ref> [31, 34, 18] </ref>, and are analogous to the idea of method invocation and method termination proposed in [8]. An Example Consider an active database system that enforces the following constraint: after any salary increase or a salary cut, no staff member should earn more than 120% of his manager's salary. <p> If the order of the active rules is immaterial, then the definition of event (X) will have one rule for each permutation of the active rules. By selecting a particular subset of all permutations, one can specify the conflict resolution strategy employed by the system <ref> [34, 3] </ref>. (The reader should not be frightened by the prospect of having to write n! rules. First, this can be done automatically. Second, T R has an operator, called shu*e, which makes this tiresome encoding much more succinct.
Reference: [35] <author> M. Winslett. </author> <title> A model based approach to updating databases with incomplete information. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(2) </volume> <pages> 167-196, </pages> <year> 1988. </year>
Reference-contexts: Likewise, none of them can seamlessly accommodate hypothetical state transitions with transitions that actually commit; and, with the exception of [22], all of the works are limited to updating sets of ground atomic facts. A much more extensive comparison can be found in [10]. Winslett <ref> [35] </ref> did foundational work on the meaning of updates to general logical theories. Later, Grahne, Katsuno and Mendelzon [22, 19] axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results.
References-found: 35

