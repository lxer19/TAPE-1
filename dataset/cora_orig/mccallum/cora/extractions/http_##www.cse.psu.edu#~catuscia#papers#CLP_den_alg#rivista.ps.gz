URL: http://www.cse.psu.edu/~catuscia/papers/CLP_den_alg/rivista.ps.gz
Refering-URL: http://www.cse.psu.edu/~catuscia/publications.html
Root-URL: http://www.cse.psu.edu
Title: An algebraic perspective of constraint logic programming  
Author: Frank S. de Boer and Alessandra Di Pierro and Catuscia Palamidessi 
Abstract: We develop a denotational, fully abstract semantics for constraint logic programming (clp) with respect to successful and failed observables. The denotational approach turns out very useful for the definition of new operators on the language as the counterpart of some abstract operations on the denotational domain. In particular, by defining our domain as a cylindric Heyting algebra, we can exploit, to this aim, operations of both cylindric algebras (such as cylindrification), and Heyting algebras (such as implication and negation). The former allows us to generalize the clp language by introducing an explicit hiding operator; the latter allows us to define a notion of negation which extends the classical negation used in Logic Programming. In particular, we show that our notion subsumes both Negation as Failure ([7]) and Negation as Instantiation ([10]). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abramsky. </author> <title> Domain Theory in Logical Form. </title> <booktitle> Proc. Annual IEEE Symposium on Logic in Computer Science (LICS), </booktitle> <pages> pages 47-53. </pages> <publisher> IEEE, </publisher> <year> 1987. </year> <note> Extended version in Annals of Pure and Applied Logic, </note> <month> 51: </month> <pages> 1-77, </pages> <year> 1991. </year>
Reference: [2] <author> K. R. Apt, H. Blair, and A. Walker. </author> <title> Towards a Theory of Declarative Knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year>
Reference: [3] <author> P. Aczel. </author> <title> An introduction to inductive definitions. </title> <editor> In J. Barwise, editor, </editor> <booktitle> Handbook of Mathematical Logic, </booktitle> <pages> pages 739-782. </pages> <publisher> Elsevier, </publisher> <year> 1977. </year>
Reference: [4] <author> E. Astesiano. </author> <title> Inductive semantics. </title> <editor> In E.J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts, IFIP State-of-the-Art Reports, </booktitle> <pages> pages 51-136. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [5] <author> P. Cousot and R. Cousot. </author> <title> Inductive definitions, semantics and abstract interpretation. </title> <booktitle> In Proc. Annual ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 83-94. </pages> <publisher> ACM, </publisher> <year> 1992. </year>
Reference: [6] <author> D. Chan. </author> <title> Constructive Negation Based on the Completed Database. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 111-125. </pages> <publisher> The MIT Press, </publisher> <year> 1988. </year> <month> 34 </month>
Reference: [7] <author> K.L. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <year> 1978. </year>
Reference: [8] <author> F. S. de Boer, A. Di Pierro, and C. Palamidessi. </author> <title> Nondeterminism and Infinite Computations in Constraint Programming. </title> <booktitle> International Workshop on Topology and Completion in Semantics, </booktitle> <address> Chartres, </address> <year> 1993. </year> <note> To appear in TCS. </note>
Reference-contexts: Of particular interest is the notion corresponding to the so-called S-semantics ([12]). This notion, in fact, is based on the idea of collecting only the exact outputs of a clp program, and therefore arises quite naturally when regarding clp as a standard programming language. In <ref> [8] </ref> we have shown that also the S-sematics of clp can be formulated in algebraic terms. The main difference is that the elements of the semantic domain are taken to be be arbitrary sets of constraints, instead of downward-closed ones.
Reference: [9] <author> F.S. de Boer, M. Gabbrielli, E. Marchiori, and C. Palamidessi. </author> <title> Proving Concurrent Constraint Programs Correct. </title> <booktitle> In Proc. Annual ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 98-108. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference: [10] <author> A. Di Pierro, M. Martelli, and C. Palamidessi. </author> <title> Negation as Instantiation. </title> <booktitle> Information and Computation 120(2), </booktitle> <pages> 263-278, </pages> <year> 1995. </year>
Reference: [11] <author> A. Di Pierro and C. Palamidessi. </author> <title> A Logical Denotational Semantics for Constraint Logic Programming. </title> <editor> In D. Sannella, editor, </editor> <booktitle> Proc. European Symposium on Programming (ESOP), volume 788 of Lecture Notes in Computer Science, </booktitle> <pages> pages 195-21. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: However, since there are no derivations ending in a terminal goal, we have O P (:G) = True. In order to achieve full correspondence with negation as failure, we have to take into account also infinite computations. Following <ref> [11] </ref>, we define for a positive goal G O 1 S fcon (G 0 ) j G ! fl G 0 and G 0 2 TGoalsg [ f i con (G i ) j G ! G 1 ! G 2 ! : : : ! G i ! : : <p> Note that T i con (G i ) is an element of P d (C), since the sets con (G i )'s are non-empty and downward-closed. In <ref> [11] </ref> it is also shown that this notion of observables can be modeled denotationally by considering the greatest fixpoint of the operator D P . 27 It is immediate now to see that the premise of the negation-as-failure rule corresponds to O 1 P (G) = False, under the assumption that <p> For a positive goal G, we define the de-notational semantics G 1 : G 1 P [[G]] = G [[G]]fix 1 D P , where fix 1 D P denotes the greatest fixpoint of D P . In <ref> [11] </ref> it is shown that G 1 P [[G]], G positive, coincides with the notion of observables O 1 P (G) which includes the limit results of infinite computations. Observe that for terminal goals the semantics G 1 P coincides with G P .
Reference: [12] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative modeling of the operational behaviour of logic languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference: [13] <author> M. Gabbrielli. </author> <title> The Semantics of Logic Programming as a Programming Language. </title> <type> PhD Thesis, Technical Report TD-17/93, </type> <institution> Department of Computer Science, University of Pisa, Pisa, </institution> <year> 1993. </year>
Reference-contexts: This reflects on the fact that the observ-ables are taken to be a downward-closed set of constraints. If the meaning of a program contains a certain constraint, then it also contains all the constraints entailed by it. Other (more refined) notions of observables for clp have been investigateded in <ref> [15, 13, 14] </ref>. Of particular interest is the notion corresponding to the so-called S-semantics ([12]). This notion, in fact, is based on the idea of collecting only the exact outputs of a clp program, and therefore arises quite naturally when regarding clp as a standard programming language.
Reference: [14] <author> M. Gabbrielli, G.M. Dore, and G. Levi. </author> <title> Observable Semantics for Constraint Logic Programming. </title> <journal> Journal of Logic and Computation, </journal> <volume> 5(2) </volume> <year> 133-171,1995. </year>
Reference-contexts: This reflects on the fact that the observ-ables are taken to be a downward-closed set of constraints. If the meaning of a program contains a certain constraint, then it also contains all the constraints entailed by it. Other (more refined) notions of observables for clp have been investigateded in <ref> [15, 13, 14] </ref>. Of particular interest is the notion corresponding to the so-called S-semantics ([12]). This notion, in fact, is based on the idea of collecting only the exact outputs of a clp program, and therefore arises quite naturally when regarding clp as a standard programming language.
Reference: [15] <author> M. Gabbrielli, and G. Levi. </author> <title> Modeling Answer Constraints in Constraint Logic Programming. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 238-252. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: This reflects on the fact that the observ-ables are taken to be a downward-closed set of constraints. If the meaning of a program contains a certain constraint, then it also contains all the constraints entailed by it. Other (more refined) notions of observables for clp have been investigateded in <ref> [15, 13, 14] </ref>. Of particular interest is the notion corresponding to the so-called S-semantics ([12]). This notion, in fact, is based on the idea of collecting only the exact outputs of a clp program, and therefore arises quite naturally when regarding clp as a standard programming language.
Reference: [16] <author> G. Gierz, K. H. Hoffman, K. Keimel, J. D. Lawson, and D. S. Scott. </author> <title> A Compendium of Continuous Lattices. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1980. </year>
Reference: [17] <editor> L. Henkin, J.D. Monk, and A. Tarski. Cylindric Algebras (Part I). </editor> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference: [18] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Annual ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference: [19] <author> J. Maluszynski and T. Naslund. </author> <title> Fail Substitutions for Negation as Failure. </title> <editor> In E. Lusk and R. Overbeck, editors, </editor> <booktitle> Proc. North American Conference on Logic Programming (NACLP), </booktitle> <pages> pages 461-476. </pages> <publisher> The MIT Press, </publisher> <year> 1989. </year>
Reference: [20] <author> G. Plotkin. </author> <title> A structured approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1981. </year>
Reference: [21] <author> D. Scott. </author> <title> Domains for denotational semantics. </title> <editor> In M. Nielsen and E.M.Schmidt, editors, </editor> <booktitle> Proc. International Colloquioum on Automata, Languages and Programming (ICALP), volume 140 of Lecture Notes in Computer Science, </booktitle> <pages> pages 577-613. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [22] <author> E.Y. Shapiro. </author> <title> A subset of Concurrent Prolog and its interpreter. </title> <type> Technical Report TR-003, </type> <institution> Institute for New Generation Computer Technology, </institution> <address> Tokyo, </address> <year> 1983. </year>
Reference: [23] <author> J. C. Shepherdson. </author> <title> A sound and complete semantics for a version of negation as failure. </title> <journal> Theoretical Computer Science, </journal> <volume> 65 </volume> <pages> 343-371, </pages> <year> 1989. </year>
Reference-contexts: In our setting we can therefore reformulate the NAF rule as follows: O 1 P (:G) = True :G ! true : Our definition of negation has a correspondence also with an extension of negation as failure, which has been defined by Shepherdson in <ref> [23] </ref>. This is formulated as follows: Shepherdson's rule all and-fair computations of G fail :G succeeds with answer substitution for a positive goal G.
Reference: [24] <author> V.A. Saraswat and M. Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proc. Annual ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 232-245. </pages> <publisher> ACM, </publisher> <year> 1990. </year>
Reference: [25] <author> V.A. Saraswat, M. Rinard, and P. Panangaden. </author> <title> Semantics foundations of Concurrent Constraint Programming. </title> <booktitle> In Proc. Annual ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 333-353. </pages> <publisher> ACM, </publisher> <year> 1991. </year>
Reference-contexts: Such a requirement is customary for constraint systems in the approach of <ref> [25] </ref>, and we assume it in the rest of this section. Proposition 42 Let fC i 2 P (C) j i 2 !g be a decreasing chain of finitary sets, i.e.
Reference: [26] <author> M. H. van Emden and G. J. de Lucena. </author> <title> Predicate logic as language for parallel programming. </title> <editor> In K. L. Clark and S. A. Ta rnlund, editors, </editor> <booktitle> Logic Programming, </booktitle> <pages> pages 189-198. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1982. </year>
Reference: [27] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference: [28] <author> S. Vickers. </author> <title> Topology via Logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year> <month> 36 </month>
References-found: 28

