URL: http://www.eecs.umich.edu/~sjhan/ftcs97.ps
Refering-URL: http://www.eecs.umich.edu/~sjhan/
Root-URL: http://www.eecs.umich.edu
Email: email: fsjhan, kgshing@eecs.umich.edu  
Title: Experimental Evaluation of Failure-Detection Schemes in Real-time Communication Networks  
Author: Seungjae Han and Kang G. Shin 
Address: Ann Arbor, MI 48109-2122.  
Affiliation: Real-Time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: An effective failure-detection scheme is essential for reliable communication services. Most computer networks rely on behavior-based detection schemes: each node uses heartbeats to detect the failure of its neighbor nodes, and the transport protocol (like TCP) achieves reliable communication by acknowledgment/retransmission. In this paper, we experimentally evaluate the effectiveness of such behavior-based detection schemes in real-time communication. Specifically, we measure and analyze the coverage and latency of two failure-detection schemes | neighbor detection and end-to-end detection | through fault-injection experiments. The experimental results have shown that a significant portion of failures can be detected very quickly by the neighbor detection scheme, while the end-to-end detection scheme uncovers the remaining failures with larger detection latencies. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. N. </author> <title> Toy, "Fault-tolerant design of AT&T telephone switching system processors," </title> <booktitle> in Reliable Computer Systems: Design and Evaluation, </booktitle> <pages> pp. 533-574. </pages> <publisher> Digital Press, </publisher> <year> 1992. </year>
Reference-contexts: Any opinions, findings, and conclusions or recommendations expressed in this paper are those of the authors and do not necessarily reflect the views of the funding agencies. ity requirements. Telecommunication networks employ an expensive failure-detection technique using hardware duplication/comparison to detect switching-node failures <ref> [1] </ref>. However, such computer network applications as electronic mail, file transfer, or remote file services do not mandate fast failure recovery, but require reliable (correct) delivery of all messages even if it takes a long time. Behavior-based failure-detection schemes without hardware support may suffice for these applications.
Reference: [2] <author> K. G. Shin and H. Kim, </author> <title> "Derivation and application of hard deadlines for real-time control systems," </title> <journal> IEEE Trans. on System, Man, and Cybernetics, </journal> <volume> vol. 22, no. 6, </volume> <pages> pp. 1403-1413, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: datagram service is often called `best-effort delivery', implying that the network attempts to deliver messages as quickly as possible by using the available resources. streams is acceptable, and temporary message losses are also tolerable in many real-time control applications because of the `system inertia' characterized by the control system deadline <ref> [2] </ref>. In such applications, it would be more attractive to detect and recover from persistent failures. In this paper, we focus on the issue of failure detection, an important step of failure recovery. We experimentally evaluate the effectiveness of two behavior-based detection schemes: neighbor detection and end-to-end detection.
Reference: [3] <author> J. Arlat, Y. Crouzet, and J.-C. Laprie, </author> <title> "Fault injection for dependability validation of fault-tolerant computing systems.," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 348-355, </pages> <year> 1989. </year>
Reference: [4] <author> U. Gunneflo, J. Karlsson, and J. Torin, </author> <title> "Evaluation of error detection schemes using fault injection by heavy-ion radiation," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 340-347, </pages> <year> 1989. </year>
Reference: [5] <author> H. Madeira and J. Silva, </author> <title> "Experimental evaluation of the fail-silent behavior in computers without error masking," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 350-359, </pages> <year> 1994. </year>
Reference-contexts: The dependency of fault-tolerance measures on workload has been reported by several researchers, e.g., [17, 18]. Fourth, our target system, like most other real-time systems, is not equipped with memory-protection capability. The experimental result in <ref> [5] </ref> indicates that memory protection can enhance detection coverage up to 15%. One can make several other observations. The composition of fault manifestations varies greatly, depending on fault types and injection targets. 5 For example, fault injection into PC has resulted in very high channel-failure rate and detection coverage.
Reference: [6] <author> Z. Segall et al., </author> <title> "FIAT fault injection based automated testing environment," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 102-107, </pages> <year> 1988. </year>
Reference: [7] <author> R. Chillarege and N. S. Bowen, </author> <title> "Understanding large system failures | a fault injection experiment," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 356-363, </pages> <month> June </month> <year> 1989. </year>
Reference: [8] <author> G. Kanawati, N. Kanawati, and J. Abraham, "FER-RARI: </author> <title> A tool for the validation of system dependability properties," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 336-344. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference: [9] <author> K. Echtle and M. Leu, </author> <title> "The EFA fault injector for fault-tolerant distributed system testing," </title> <booktitle> in Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <pages> pp. 28-35. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference: [10] <author> W. Kao, R. Iyer, and D. Tang, </author> <title> "FINE: A fault injection and monitoring environment for tracing the UNIX system behavior under faults," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 19, no. 11, </volume> <pages> pp. 1105-1118, </pages> <month> November </month> <year> 1993. </year>
Reference: [11] <author> S. Han, K. G. Shin, and H. Rosenberg, "DOCTOR: </author> <title> An integrateD sOftware fault injeCTiOn enviRonment for distributed real-time systems," </title> <booktitle> in Proc. IEEE IPDS, </booktitle> <pages> pp. 204-213, </pages> <year> 1995. </year>
Reference-contexts: For example, the intrusion into normal execution by fault injection should be minimized and isolated to obtain accurate measurements, especially in real-time systems. In order to remedy some of these difficulties, we have developed an integrated fault-injection environment called DOCTOR <ref> [11] </ref>, particularly for distributed real-time systems. DOCTOR provides a complete set of tools for automated fault-injection experiments. One of the core parts of DOCTOR is the fault injector which consists of three modules: experiment generation module (EGM), experiment control module (ECM), and fault injection agent (FIA).
Reference: [12] <author> L. M. Thompson, </author> <title> "Using pSOS + for embedded real-time computing," </title> <booktitle> in Proc. COMPCON, </booktitle> <pages> pp. 282-288, </pages> <year> 1990. </year>
Reference-contexts: A SUN workstation serves as the host machine, and is connected to nodes through an Ethernet. Nodes are not equipped with disks, and application/system software is downloaded from the host machine. An extended version of the pSOS +m real-time OS <ref> [12] </ref> is used for AP's system software. The AP-side software is not important in our experiment, since APs run very simple applications which request message delivery to the associated NP, and retrieve messages received by the NP.
Reference: [13] <author> L. L. Peterson, N. C. Hutchinson, S. W. O`Malley, and H. C. Rao, </author> <title> "The x-Kernel: A platform for accessing internet resources," </title> <journal> IEEE Computer, </journal> <volume> vol. 23, no. 5, </volume> <pages> pp. 23-33, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: The AP-side software is not important in our experiment, since APs run very simple applications which request message delivery to the associated NP, and retrieve messages received by the NP. NP employs a derivative of x-kernel 3.1 <ref> [13] </ref> as a system executive and a substrate for building the protocol stack. Since NPs do not run user tasks, we disabled the virtual address management of x-kernel. Thus, all tasks in NP are executed within a single (kernel) address space.
Reference: [14] <author> D. D. Kandlur, K. G. Shin, and D. Ferrari, </author> <title> "Real-time communication in multi-hop networks," </title> <journal> IEEE Trans. Parallel and Distributed Systems, </journal> <volume> vol. 5, no. 10, </volume> <pages> pp. 1044-1056, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Thus, all tasks in NP are executed within a single (kernel) address space. Memory protection of x-kernel was also disabled to minimize the overhead. 4.2 Communication Subsystem Each NP features the real-time communication scheme described in <ref> [14] </ref>. The protocol stack includes protocols for application program interface (API), network management (NM), remote procedure call (RPC), transport-level fragmentation (FRAG), unreliable datagram service (HNET), and the device driver for network interface boards (DD).
Reference: [15] <author> A. Mehra, A. Indiresan, and K. G. Shin, </author> <title> "Resource management for real-time communication: Making theory meet practice," </title> <booktitle> in Proc. IEEE RTAS, </booktitle> <pages> pp. 130-138, </pages> <year> 1996. </year>
Reference-contexts: For this reason, we implemented the run-time message scheduler as a special thread that is created at system startup and runs at the highest-priority level. Implementation details can be found in <ref> [15] </ref>. 4.3 Failure-Detection Mechanisms For the neighbor detection scheme, the node heartbeat generator/checker is implemented as a separate task. It is periodically executed and checks special flags, each of which is associated with a link and is set whenever a message is transmitted over the link.
Reference: [16] <author> M. Rela, H. Madeira, and J. Silva, </author> <title> "Experimental evaluation of the fail-silent behavior in programs with consistency checks," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 394-403, </pages> <year> 1996. </year>
Reference-contexts: The experimental results are summarized in Tables 1 and 2. The first observation from these experimental results is the relatively low coverage. For example, (72:6 + 0:1)=(100 18:2) = 88:8 % of failures were reported in <ref> [16] </ref> to have been detected by the system hardware detection mechanism, which was also based on a Motorola 680x0 CPU. This is much higher than the coverage observed in our experiment. This discrepancy can be explained based on the following four reasons. First, the two used different fault-injection methods. In [16], <p> <ref> [16] </ref> to have been detected by the system hardware detection mechanism, which was also based on a Motorola 680x0 CPU. This is much higher than the coverage observed in our experiment. This discrepancy can be explained based on the following four reasons. First, the two used different fault-injection methods. In [16], a hardware-implemented (pin-level) fault injector was used, so the fault injected at a CPU pin for two memory cycles can be manifested as several errors at the level which a software-implemented fault injector deals with. <p> Computationally-intensive workloads (e.g., sorting, searching, matrix multiplication, etc.) were executed in the experiments of <ref> [16] </ref>. The dependency of fault-tolerance measures on workload has been reported by several researchers, e.g., [17, 18]. Fourth, our target system, like most other real-time systems, is not equipped with memory-protection capability. The experimental result in [5] indicates that memory protection can enhance detection coverage up to 15%.
Reference: [17] <author> S. Butner and R. Iyer, </author> <title> "A statistical study of reliability and system load at SLAC," </title> <booktitle> in Proc. IEEE FTCS, </booktitle> <pages> pp. 207-209, </pages> <year> 1980. </year>
Reference-contexts: Computationally-intensive workloads (e.g., sorting, searching, matrix multiplication, etc.) were executed in the experiments of [16]. The dependency of fault-tolerance measures on workload has been reported by several researchers, e.g., <ref> [17, 18] </ref>. Fourth, our target system, like most other real-time systems, is not equipped with memory-protection capability. The experimental result in [5] indicates that memory protection can enhance detection coverage up to 15%. One can make several other observations.
Reference: [18] <author> R. Chillarege and R. Iyer, </author> <title> "Measurement-based analysis of error latency," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 36, no. 5, </volume> <pages> pp. 529-537, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Computationally-intensive workloads (e.g., sorting, searching, matrix multiplication, etc.) were executed in the experiments of [16]. The dependency of fault-tolerance measures on workload has been reported by several researchers, e.g., <ref> [17, 18] </ref>. Fourth, our target system, like most other real-time systems, is not equipped with memory-protection capability. The experimental result in [5] indicates that memory protection can enhance detection coverage up to 15%. One can make several other observations.
References-found: 18

