URL: http://www.cs.purdue.edu/homes/grr/ISMM98-grr-mps-cef.ps
Refering-URL: http://www.cs.purdue.edu/people/grr/
Root-URL: http://www.cs.purdue.edu
Email: -grr, mps, cef-@geodesic.com  
Phone: Tel. (312) 832-1221  
Title: A Non-Fragmenting NonMoving, Garbage Collector  
Author: Gustavo Rodriguez-Rivera Michael Spertus 
Note: Charles Fiterman  
Address: 414 North Orleans Street, Suite 410 Chicago, IL 60610  
Affiliation: Geodesic Systems  
Abstract: 1. ABSTRACT 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Joel F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Technical Report 88/2, </type> <institution> Digital Equipment Corporation Western Research Laboratory, Palo Alto, California, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: Some moving collectors deal with this problem by pinning objects that are pointed by pointers that were found using conservative pointer finding <ref> [1, 6] </ref>, i.e., objects found by the conservative garbage collector are not moved, creating fragmentation problems. In this paper, we describe two techniques to reduce fragmentation in nonmoving garbage collectors. The first technique is intended to reduce internal fragmentation in allocators that use a BiBoP scheme (Big-Bag-of-Pages) [4,12].
Reference: [2] <editor> Yves Bekkers and Jacques Cohen, editors. </editor> <booktitle> International Workshop on Memory Management, number 637 in Lecture Notes in Computer Science, </booktitle> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference: [3] <author> Hans-Juergen Boehm, </author> <title> Space-efficient conservative garbage collection. </title> <booktitle> In Proceedings of the 1993 SIGPLAN Conference on Programming Language Design and Implementation [9], </booktitle> <pages> pages 197-206. </pages>
Reference-contexts: If a new search started where the previous one ended it would reuse all the objects in the list and would not give the opportunity for footprint reduction. A good side effect of footprint reduction is that pages that are blacklisted <ref> [3] </ref>, and therefore cannot be used because they are being pointed by false pointers, are unmapped if they continue blacklisted for several consecutive allocations. 5. EXPERIMENTS In this section, we show the advantages of using footprint reduction in a long-lived program that is subject to changing loads.
Reference: [4] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Some work has been done to obtain pointer information of C programs from the debugging information [13], however their use is limited since C and C++ can store pointer values in non-pointer types, and keeping track of pointer information at execution time is difficult. Conservative garbage collection <ref> [4] </ref> also has some problems when combined with moving garbage collection. Conservative garbage collection considers every valid memory address that is word-aligned and that points to a valid object as a real pointer. <p> In a BiBoP allocator, the objects found in the same page have the same characteristics. The second technique is intended to reduce external fragmentation and uses virtual memory primitives that can be found in most modern operating systems. Allocators such as the one used in Boehms collector <ref> [4] </ref> divide the objects in two classes: small and large objects. Small objects are obtained by dividing a single page in small pieces, and large objects are the ones that use one or more consecutive pages. <p> We will refer to this technique as footprint reduction. Both medium objects and footprint reduction have been implemented in a variation of Boehms conservative garbage collection library <ref> [4] </ref> called Great Circle. Great Circle is a commercially-available garbage collection library from Geodesic Systems. The ideas presented here are explained in the context of garbage collection. However, they can also be applied to any general-purpose memory allocator that does not use garbage collection. The paper is organized as follows.
Reference: [5] <author> Jacques Cohen and Alexandru Nicolau. </author> <title> Comparison of compacting algorithms for garbage collection. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(4) </volume> <pages> 532-553, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: This paper describes these techniques, their implementation, and some experimental results. 1.1 Keywords Memory allocation, garbage collection, fragmentation, conservative garbage collection, non-copying garbage collection 2. INTRODUCTION Moving garbage collectors (i.e. copying and compacting garbage collectors <ref> [5, 8] </ref>) eliminate fragmentation by moving live data and leaving all free space in consecutive locations. Nonmoving collectors are unable to move live data, and therefore free memory is interleaved with holes of live memory.
Reference: [6] <author> David L. Detlefs. </author> <title> Concurrent, Atomic Garbage Collection. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> November </month> <year> 1991. </year> <note> Technical Report CMU-CS-90-177. </note>
Reference-contexts: Some moving collectors deal with this problem by pinning objects that are pointed by pointers that were found using conservative pointer finding <ref> [1, 6] </ref>, i.e., objects found by the conservative garbage collector are not moved, creating fragmentation problems. In this paper, we describe two techniques to reduce fragmentation in nonmoving garbage collectors. The first technique is intended to reduce internal fragmentation in allocators that use a BiBoP scheme (Big-Bag-of-Pages) [4,12].
Reference: [7] <institution> OOPSLA 93 Workshop on Memory Management and Garbage Collection, </institution> <month> October </month> <year> 1993. </year> <note> Available for anonymous FTP from cs.utexas.edu in /pub/garbage/GC93. </note>
Reference: [8] <author> Richard E. Jones and R. Lins. </author> <title> Garbage Collection: Algorithms for Automatic Dynamic Memory Management. 1996. </title> <publisher> Wiley. </publisher>
Reference-contexts: This paper describes these techniques, their implementation, and some experimental results. 1.1 Keywords Memory allocation, garbage collection, fragmentation, conservative garbage collection, non-copying garbage collection 2. INTRODUCTION Moving garbage collectors (i.e. copying and compacting garbage collectors <ref> [5, 8] </ref>) eliminate fragmentation by moving live data and leaving all free space in consecutive locations. Nonmoving collectors are unable to move live data, and therefore free memory is interleaved with holes of live memory.
Reference: [9] <institution> Proceedings of the 1993 SIGPLAN Conference on Programming Language Design and Implementation, </institution> <address> Albuquerque, New Mexico, June 1993. </address> <publisher> ACM Press. </publisher>
Reference: [10] <author> Gustavo Rodriguez-Rivera and Vincent Russo. </author> <title> Nonintrusive cloning garbage collection with stock operating system support. </title> <journal> Software Practice and Experience, </journal> <volume> 27(8), </volume> <month> August </month> <year> 1997. </year>
Reference-contexts: The experiments shown here run in a Sparc Station 10 running the Solaris Operating System. The Great Circle library is linked into Netscape and the X-server at run-time using the injection technique described in <ref> [10] </ref>, and therefore no recompiling or linking is necessary. Great Circle provides a substitute for the malloc/free operations. In the experiments shown, explicit memory management is enabled, and therefore the free operations really return memory back to the free lists.
Reference: [11] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <booktitle> In Bekkers and Cohen [2], </booktitle> <pages> pages 1-42. </pages>
Reference: [12] <author> Paul R. Wilson. </author> <title> Garbage Collection. </title> <journal> Computing Surveys, </journal> <note> 1995. Expanded version of [11]. Draft available via anonymous internet FTP from cs.utexas.edu as /pub/garbage/bigsurv.ps. </note>
Reference-contexts: This causes that some requests for free memory will not be satisfied with the available free memory because it is not in consecutive locations, even though the total free memory could be greater than the amount requested. Moving-collectors can solve the fragmentation problem <ref> [12] </ref>. Unfortunately, moving collectors can not be used in environments where no accurate pointer information is available, since pointers in live objects have to be updated when the objects they point to, are moved. For example, off-the-shelf C and C++ compilers do not give accurate pointer information.
Reference: [13] <author> Paul R. Wilson and Mark S. Johnstone. </author> <title> Truly real-time non-copying garbage collection. In OOPSLA 93 Workshop on Memory Management and Garbage Collection [7]. </title> <note> Expanded version workshop position paper submitted for publication. </note>
Reference-contexts: For example, off-the-shelf C and C++ compilers do not give accurate pointer information. Some work has been done to obtain pointer information of C programs from the debugging information <ref> [13] </ref>, however their use is limited since C and C++ can store pointer values in non-pointer types, and keeping track of pointer information at execution time is difficult. Conservative garbage collection [4] also has some problems when combined with moving garbage collection.
Reference: [14] <author> Paul R. Wilson, Mark S. Johnstone. Michael Neely, and David Boles. </author> <title> Dynamic Storage Allocation: A survey and Critical Review. </title> <note> Available for anonymous FTP from cs.utexas.edu in /pub/garbage/. </note>
Reference-contexts: Medium objects are objects that are allocated by dividing multiple consecutive pages in pieces. Large objects are objects that are a multiple of a pagesize. The small and medium object allocator consists of buckets of objects for each size, called segregated free lists <ref> [14] </ref>. Great Circle pre-computes the sizes of small and medium objects and makes sure that the maximum fragmentation for each object size is less than some pre-specified constant. The large object allocator is a single list of objects ordered by address to allow coalescing.
References-found: 14

