URL: http://www.cs.dartmouth.edu/~jasonliu/courses/sim188/biblio/sw93.ps.gz
Refering-URL: http://www.cs.dartmouth.edu/~jasonliu/courses/sim188/
Root-URL: http://www.cs.dartmouth.edu
Title: A Practical System for Intermodule Code Optimization at Link-Time  
Phone: 1 9 9 2  
Author: Amitabh Srivastava David W. Wall d i g i t a l 
Date: 92/6  
Address: R  Avenue Palo Alto, California 94301 USA  
Affiliation: D E C E M B E  Western Research Laboratory 250 University  
Pubnum: Research Report  
Abstract-found: 0
Intro-found: 1
Reference: [ASU88] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers, Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: We handle global variables similarly: a read or write via an unknown pointer is assumed to read or write any variable whose address is ever taken. We use a variation of the standard iterative algorithm <ref> [ASU88] </ref> to solve the data flow equations: we repeatedly examine the basic blocks, computing the IN and OUT sets from the equations, until we make one complete pass without changes. <p> Mechanisms for detecting loops and loop-invariant code are well-understood 11 p1 call p2 call p3 p2 call p3 p3 call p4 for single procedures <ref> [ASU88] </ref>, but certain loops are not completely visible to techniques that process one procedure at a time. Figure 5 shows two examples. Procedure p2 is called from a loop in procedure p1. Looking at p1 or p2 in isolation will not tell us if p2 contains loop-invariant code. <p> Each liveness analysis requires around eight iterations, correlating weakly with the static number of basic blocks in the program. It is interesting that each phase requires about the same number of iterations that are required to converge on a single procedure <ref> [ASU88] </ref>, even though the whole-program graph is much larger and more deeply nested. Presumably this is because the absence of either all call or all return edges hides the global depth of loop nesting.
Reference: [All74] <author> F.E. Allen. </author> <title> Interprocedural data flow analysis. </title> <booktitle> Proceedings of IFIP Congress 1974, </booktitle> <pages> pp. 398-402. </pages> <publisher> North Holland, </publisher> <year> 1974. </year>
Reference: [Ban79] <author> John P. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 29-41, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: Because information can flow from a caller to a callee as well as vice versa, this results in more precise information than approaches like those of Barth [Bar77] or Banning <ref> [Ban79] </ref>, which use flow-insensitive summary information to capture the effects of a call within the analyzed procedure but do not tell the analyzer how control got to this procedure in the first place. The equations for a normal basic block are the same as in a standard liveness analysis.
Reference: [Bar77] <author> Jeffrey M. Barth. </author> <title> A practical interprocedural data flow analysis algorithm. </title> <journal> Communications of the ACM 21(9), </journal> <pages> pp. 724-736, </pages> <month> September </month> <year> 1978. </year>
Reference-contexts: Because information can flow from a caller to a callee as well as vice versa, this results in more precise information than approaches like those of Barth <ref> [Bar77] </ref> or Banning [Ban79], which use flow-insensitive summary information to capture the effects of a call within the analyzed procedure but do not tell the analyzer how control got to this procedure in the first place.
Reference: [Cal88] <author> David Callahan. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 47-56. </pages> <note> Published as SIGPLAN Notices 23(7), </note> <month> July </month> <year> 1988. </year>
Reference-contexts: We then replace the return edges and delete the call edges, using the procedure summary information from the first pass to compute the variables that are live before a call. This is similar to Callahan's approach <ref> [Cal88] </ref>, which computed the same flow-sensitive summary information but went to considerable trouble to avoid having the whole program in memory at once.
Reference: [CHK92] <author> Keith D. Cooper, Mary W. Hall, and Ken Kennedy. </author> <title> Procedure cloning. </title> <booktitle> Proceedings of the 1992 International Conference on Computer Languages, </booktitle> <pages> pp. 96-105, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> April </month> <year> 1992. </year>
Reference-contexts: Loops that arise through recursion cannot be made intraprocedural by inlining. And inlining can have unpredictable and sometimes detrimental effects on cache performance unless cache behavior is used to guide inlining decisions [McF91]. Good interprocedural analysis together with judicious use of procedure cloning <ref> [CHK92] </ref> would avoid these problems. 2 Though we are looking for loop-invariant code across procedure boundaries, our ambitions in this prototype are modest.
Reference: [DF84] <author> Jack W. Davidson and Christopher W. Fraser. </author> <title> Code selection through object code optimization. </title> <journal> ACM Transactions on Programming Languages and Systems 6(4), </journal> <pages> pp. 505-526, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: If OM is used to translate from one architecture to another, different code generation is required. The RTL is intended to be machine-independent, so this should not be a problem: several existing compilers already generate code from a machine-independent RTL <ref> [DF84, Sta92] </ref>.
Reference: [LR90] <author> William Landi and Barbara Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 93-103, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: To accomplish this, we use a two-phase approach similar to the one described by Landi and Ryder <ref> [LR90] </ref> for alias analysis. In the first phase, we delete all return edges and let information flow over normal edges and call edges, and from a return block to its conjugate call block.
Reference: [LB92] <author> James R. Larus and Thomas Ball. </author> <title> Rewriting executable files to measure program behavior. </title> <institution> University of Wisconsin Computer Sciences Technical Report 1083, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: The relocation information lets us distinguish addresses from coincidental numeric constants [Wal92]; we can therefore perform our transformations without introducing the dynamic translation overhead of schemes that transform executable files <ref> [LB92, MIP86] </ref>. We can also determine exactly which procedures and variables have had their addresses taken; because we can see the whole program at once, we need not make worst-case assumptions about code we cannot see.
Reference: [Lom77] <author> D. Lomet. </author> <title> Data flow analysis in presence of procedure calls. </title> <journal> IBM Journal of Research and Development 21,6, </journal> <pages> pp. 559-571, </pages> <year> 1977. </year> <month> 22 </month>
Reference: [McF91] <author> Scott McFarling. </author> <title> Procedure merging with instruction caches. </title> <booktitle> Proceedings of the SIG--PLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 71-79. </pages> <note> Published as SIGPLAN Notices 26(6), </note> <month> June </month> <year> 1991. </year>
Reference-contexts: Inlining already presupposes some kind of interprocedural analysis to find the most useful inlining opportunities. Loops that arise through recursion cannot be made intraprocedural by inlining. And inlining can have unpredictable and sometimes detrimental effects on cache performance unless cache behavior is used to guide inlining decisions <ref> [McF91] </ref>. Good interprocedural analysis together with judicious use of procedure cloning [CHK92] would avoid these problems. 2 Though we are looking for loop-invariant code across procedure boundaries, our ambitions in this prototype are modest.
Reference: [MIP86] <institution> MIPS Computer Systems, Inc. Language Programmers's Guide, </institution> <year> 1986. </year>
Reference-contexts: The relocation information lets us distinguish addresses from coincidental numeric constants [Wal92]; we can therefore perform our transformations without introducing the dynamic translation overhead of schemes that transform executable files <ref> [LB92, MIP86] </ref>. We can also determine exactly which procedures and variables have had their addresses taken; because we can see the whole program at once, we need not make worst-case assumptions about code we cannot see. <p> We measured the speed of an executable in two ways. The first was real user time, according to the system clock as measured by the systime facility. The second was cycles as measured by instrumenting the executable using pixie <ref> [MIP86] </ref>. The pixie tool counts instructions and pipeline stalls, and gives a theoretical cycle count assuming no cache, memory, paging, or I/O delays. OM was able to improve the performance of each of the benchmarks, sometimes slightly and sometimes significantly.
Reference: [Mye81] <author> E. Myers. </author> <title> A precise inter-procedural data flow algorithm. </title> <booktitle> Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 219-230, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: We treat the entire program as a single flow graph, with edges between procedures corresponding to calls and returns. In the manner of Myers <ref> [Mye81] </ref>, we split a procedure call into a pair of conjugate blocks: the call block executed just before the transfer to the called procedure, and the return block executed just after the called procedure. A call block has a single successor, the entry block of the called procedure.
Reference: [Ros79] <author> B. Rosen. </author> <title> Data flow analysis for procedural languages. </title> <journal> Journal of the ACM 26(2), </journal> <pages> pp. 322-344, </pages> <month> April </month> <year> 1979. </year>
Reference: [Ric91] <author> S.E. Richardson. </author> <title> Evaluating Interprocedural Code Optimization Techniques. </title> <type> Ph.D. Thesis, </type> <institution> Stanford University, </institution> <note> Technical Report No CSL-TR-91-460, </note> <month> February </month> <year> 1991. </year>
Reference-contexts: Looking at p1 or p2 in isolation will not tell us if p2 contains loop-invariant code. Procedures p3 and p4 call each other in a recursive cycle. Code that is invariant across both could be moved out into p1. Richardson <ref> [Ric91] </ref> suggested that this kind of optimization could be accomplished by procedure inlining followed by normal intraprocedural analysis and optimization. That approach has several drawbacks. Inlining already presupposes some kind of interprocedural analysis to find the most useful inlining opportunities.
Reference: [SP81] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In Steven S. Muchnick and Neil D. Jones, editors, </editor> <title> Program Flow Analysis: Theory and Applications. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J, </address> <year> 1981. </year>
Reference: [Sri91] <author> Amitabh Srivastava. </author> <title> Unreachable procedures in object-oriented programming. </title> <note> WRL Technical Note TN-21, </note> <month> November </month> <year> 1991. </year>
Reference: [Sta92] <author> Richard Stallman. </author> <title> Using and porting GNU CC. Free Software Foundation, </title> <year> 1992. </year>
Reference-contexts: If OM is used to translate from one architecture to another, different code generation is required. The RTL is intended to be machine-independent, so this should not be a problem: several existing compilers already generate code from a machine-independent RTL <ref> [DF84, Sta92] </ref>.

References-found: 18

