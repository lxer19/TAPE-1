URL: http://seclab.cs.ucdavis.edu/~samorodi/papers/USENIX/technical97/haines.ps
Refering-URL: http://seclab.cs.ucdavis.edu/~samorodi/papers/USENIX/technical97/
Root-URL: http://www.cs.ucdavis.edu
Email: Email: office@usenix.org  
Title: On Designing Lightweight Threads for Substrate Software  
Phone: 1. Phone: 510 528-8649 2. FAX: 510 548-5738 3.  4.  
Author: Matthew Haines 
Affiliation: Department of Computer Science University of Wyoming  
Web: WWW URL: http://www.usenix.org  
Date: January 6-10, 1997  
Note: The following paper was originally published in the Proceedings of the USENIX 1997 Annual Technical Conference Anaheim, California,  For more information about USENIX Association contact:  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. J. Accetta, R. V. Baron, W. Bolosky, D. B. Golub, R. F. Rashid, A. Tevanian, and M. W. Young. </author> <title> Mach: A new kernel foundation for UNIX development, </title> <month> July </month> <year> 1986. </year>
Reference-contexts: Since the OS kernel controls addressing and scheduling for the CPU, user-level threads must be multiplexed atop one or more kernel-level entities, such as Unix processes [4], Mach kernel threads <ref> [1] </ref>, or a Sun Lightweight Processes (LWP) [24]. This "multiplexing" is commonly referred to as scheduling of the user-level threads.
Reference: [2] <author> Thomas E. Anderson, Brian N. Bershad, Ed-ward D. Lazowska, and Henry M. Levy. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <booktitle> In ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 95-109, </pages> <year> 1991. </year>
Reference-contexts: Fine-grain control over the behavior of a thread is typically not needed. There is no shortage of lightweight thread packages for application-level programmers, and a short list of such systems would likely include pthreads [22] (the POSIX interface for lightweight threads [16]), Solaris threads [26], fast-threads <ref> [2] </ref>, and cthreads [23]. Lightweight threads are also useful for supporting independent tasks generated by parallel or concur fl Supported in part by the National Aeronautics and Space Administration under NASA Contract No.
Reference: [3] <author> Gregory R. Andrews and Ronald A Olsson. </author> <title> The SR Programming Language: Concurrency in Practice. </title> <address> Benjamin/Cummings, </address> <year> 1993. </year> <note> ISBN 0 8053-0088-0. </note>
Reference-contexts: In this context, system-level programmers use lightweight threads as a major building-block of a multithreaded runtime system. For example, each of the following languages is supported by a multithreaded runtime system: CC++ [12], Fortran M [12], Opus [15], Orca [7], PC++ [8], Sisal [13], Split-C [11], and SR <ref> [3] </ref>. However, none of these mul-tithreaded runtime systems employs a single thread package for all platform implementations, and few use any of the lightweight thread packages listed in the preceding paragraph. <p> On the other hand, the run-time system that supports the SR programming language <ref> [3] </ref> assumes non-preemptive scheduling, in which the scheduler is free to select the next thread to the executed from a list of runnable threads. Both languages support communication between multiple processors, and this communi cation directly affects thread scheduling. 2. Lack of performance.
Reference: [4] <author> Maurice J. Bach. </author> <title> The Design of the UNIX Operating System. Software Series. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Since the OS kernel controls addressing and scheduling for the CPU, user-level threads must be multiplexed atop one or more kernel-level entities, such as Unix processes <ref> [4] </ref>, Mach kernel threads [1], or a Sun Lightweight Processes (LWP) [24]. This "multiplexing" is commonly referred to as scheduling of the user-level threads.
Reference: [5] <author> Henri E. Bal, M. Frans Kaashoek, and Andrew S. Tanenbaum. Orca: </author> <title> A language for parallel programming of distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(3) </volume> <pages> 190-205, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: However, most multithreaded runtime systems require explicit control over scheduling decisions and the interaction of threads with a communication substrate. For example, the Panda runtime system [7], which supports the Orca programming language <ref> [5] </ref>, requires preemptive scheduling of threads with priorities, and the ability to turn preemption off and explicitly poll for incoming messages when there are no active threads.
Reference: [6] <author> Greg Benson. </author> <title> Information on thread identification using stacks. </title> <type> Personal communication, </type> <month> March </month> <year> 1996. </year>
Reference-contexts: However, compiler and architecture support are required to reserve this register, and the loss of a register on RISC-based architectures is always cause for concern. Another approach is to keep the current thread pointer on a well-known offset in each thread stack <ref> [6] </ref>. This approach eliminates the need for both global memory and register space, but requires fancy stack alignments. Another approach, and the one currently employed by OpenThreads, is to use a global variable for storing the current thread pointer.
Reference: [7] <author> Raoul Bhoedjang, Tim Ruhl, Rutger Hof-man, Koen Langendoen, Henri Bal, and Frans Kaashoek. Panda: </author> <title> A portable platform to support parallel programming languages. </title> <booktitle> In Symposium on Experiences with Distributed and Multiprocessor Systems IV, </booktitle> <pages> pages 213-226, </pages> <address> San Diego, CA, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: In this context, system-level programmers use lightweight threads as a major building-block of a multithreaded runtime system. For example, each of the following languages is supported by a multithreaded runtime system: CC++ [12], Fortran M [12], Opus [15], Orca <ref> [7] </ref>, PC++ [8], Sisal [13], Split-C [11], and SR [3]. However, none of these mul-tithreaded runtime systems employs a single thread package for all platform implementations, and few use any of the lightweight thread packages listed in the preceding paragraph. <p> However, most multithreaded runtime systems require explicit control over scheduling decisions and the interaction of threads with a communication substrate. For example, the Panda runtime system <ref> [7] </ref>, which supports the Orca programming language [5], requires preemptive scheduling of threads with priorities, and the ability to turn preemption off and explicitly poll for incoming messages when there are no active threads. <p> Flexibility. The flexibility of our design is manifest by the meta-level interface, and the ability of a programmer to provide her own solutions to the design dilemmas outlined in Section 3.1. As a concrete example of its flexibility, we have adapted the Panda multithreaded runtime system <ref> [7] </ref> to use OpenThreads for implementing its tasks. 2. Efficiency. With regards to performance, we can report on the performance of OpenThreads in comparison POSIX Pthreads and the QuickThreads package upon which OpenThreads is built. The comparison with Pthreads demonstrates the efficiency of OpenThreads for doing basic multithreading.
Reference: [8] <author> F. Bodin, P. Beckman, D. Gannon, S. Yang, S. Kesavan, and B. Mohr. </author> <title> Implementing a parallel C++ runtime system for scalable parallel systems. </title> <booktitle> In Supercomputing, </booktitle> <pages> pages 588-597, </pages> <address> Port-land, OR, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: In this context, system-level programmers use lightweight threads as a major building-block of a multithreaded runtime system. For example, each of the following languages is supported by a multithreaded runtime system: CC++ [12], Fortran M [12], Opus [15], Orca [7], PC++ <ref> [8] </ref>, Sisal [13], Split-C [11], and SR [3]. However, none of these mul-tithreaded runtime systems employs a single thread package for all platform implementations, and few use any of the lightweight thread packages listed in the preceding paragraph.
Reference: [9] <author> Martin D. Carroll and Margaret A. Ellis. </author> <title> Designing and Coding Reusable C++. </title> <publisher> Addison Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Recently, the object-oriented research community has been addressing the issue of improved design methodologies for substrate (system-level) software <ref> [9, 18, 19, 20, 27] </ref>. From this research, a new design methodology for substrate software has emerged, called Open Implementation [18, 19].
Reference: [10] <author> Aswini K. Chowdappa, Anthony Skjellum, and Nathan E. Doss. </author> <title> Thread-safe message passing with P4 and MPI. </title> <type> Technical Report TR-CS-941025, </type> <institution> Computer Science Department and NSF Engineering Research Center, Mississippi State University, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: Other systems combining threads with communication primitives include Chant [14], Nexus [12], PVM-threads [21], and MPI-threads <ref> [10] </ref>. 4. Signals. Most papers on lightweight threads include long and involved discussions about signal handling in the presence of threads. We will avoid this discussion for now, and simply state that OpenThreads currently exposes all threads to the same signal mask.
Reference: [11] <author> David E. Culler, Andrea Dusseau, Seth Copen Goldstein, Arvind Krish-namurthy, Steven Lumetta, Thorsten von Eicken, and Katherine Yelick. </author> <title> Parallel programming in Split-C. </title> <booktitle> In Supercomputing, </booktitle> <pages> pages 262-273, </pages> <address> Port-land, OR, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: In this context, system-level programmers use lightweight threads as a major building-block of a multithreaded runtime system. For example, each of the following languages is supported by a multithreaded runtime system: CC++ [12], Fortran M [12], Opus [15], Orca [7], PC++ [8], Sisal [13], Split-C <ref> [11] </ref>, and SR [3]. However, none of these mul-tithreaded runtime systems employs a single thread package for all platform implementations, and few use any of the lightweight thread packages listed in the preceding paragraph.
Reference: [12] <author> Ian Foster, Carl Kesselman, Robert Olson, and Steven Tuecke. </author> <title> Nexus: An interoperability layer for parallel and distributed computer systems. </title> <type> Technical Report Version 1.3, </type> <institution> Argonne National Labs, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: In this context, system-level programmers use lightweight threads as a major building-block of a multithreaded runtime system. For example, each of the following languages is supported by a multithreaded runtime system: CC++ <ref> [12] </ref>, Fortran M [12], Opus [15], Orca [7], PC++ [8], Sisal [13], Split-C [11], and SR [3]. However, none of these mul-tithreaded runtime systems employs a single thread package for all platform implementations, and few use any of the lightweight thread packages listed in the preceding paragraph. <p> In this context, system-level programmers use lightweight threads as a major building-block of a multithreaded runtime system. For example, each of the following languages is supported by a multithreaded runtime system: CC++ <ref> [12] </ref>, Fortran M [12], Opus [15], Orca [7], PC++ [8], Sisal [13], Split-C [11], and SR [3]. However, none of these mul-tithreaded runtime systems employs a single thread package for all platform implementations, and few use any of the lightweight thread packages listed in the preceding paragraph. <p> We are in the process of examining the issues regarding the combination of threads with communication models, and plan to test the flexibility of our system for performing platform-independent optimizations using a combination of thread and communication modules. Other systems combining threads with communication primitives include Chant [14], Nexus <ref> [12] </ref>, PVM-threads [21], and MPI-threads [10]. 4. Signals. Most papers on lightweight threads include long and involved discussions about signal handling in the presence of threads. We will avoid this discussion for now, and simply state that OpenThreads currently exposes all threads to the same signal mask.
Reference: [13] <author> Matthew Haines and Wim Bohm. </author> <title> Task management, virtual shared memory, and multithread-ing in a distributed memory implementation of Sisal. </title> <booktitle> In Parallel Architectures and Languages, </booktitle> <pages> pages 12-23. </pages> <booktitle> Springer-Verlag Lecture Notes in Computer Science, </booktitle> <volume> Vol 694, </volume> <year> 1993. </year>
Reference-contexts: In this context, system-level programmers use lightweight threads as a major building-block of a multithreaded runtime system. For example, each of the following languages is supported by a multithreaded runtime system: CC++ [12], Fortran M [12], Opus [15], Orca [7], PC++ [8], Sisal <ref> [13] </ref>, Split-C [11], and SR [3]. However, none of these mul-tithreaded runtime systems employs a single thread package for all platform implementations, and few use any of the lightweight thread packages listed in the preceding paragraph.
Reference: [14] <author> Matthew Haines, David Cronk, and Piyush Mehrotra. </author> <title> On the design of Chant: A talking threads package. </title> <booktitle> In Proceedings of Supercomputing, </booktitle> <pages> pages 350-359, </pages> <address> Washington D.C., </address> <month> November </month> <year> 1994. </year> <month> ACM/IEEE. </month>
Reference-contexts: We are in the process of examining the issues regarding the combination of threads with communication models, and plan to test the flexibility of our system for performing platform-independent optimizations using a combination of thread and communication modules. Other systems combining threads with communication primitives include Chant <ref> [14] </ref>, Nexus [12], PVM-threads [21], and MPI-threads [10]. 4. Signals. Most papers on lightweight threads include long and involved discussions about signal handling in the presence of threads. We will avoid this discussion for now, and simply state that OpenThreads currently exposes all threads to the same signal mask.
Reference: [15] <author> Matthew Haines, Bryan Hess, Piyush Mehrotra, John Van Rosendale, and Hans Zima. </author> <title> Run-time support for data parallel tasks. </title> <booktitle> In Proceedings of The Fifth Symposium on the Frontiers of Massively Parallel Computation, </booktitle> <pages> pages 432-439, </pages> <address> McLean VA, </address> <month> February </month> <year> 1995. </year> <note> IEEE. </note>
Reference-contexts: In this context, system-level programmers use lightweight threads as a major building-block of a multithreaded runtime system. For example, each of the following languages is supported by a multithreaded runtime system: CC++ [12], Fortran M [12], Opus <ref> [15] </ref>, Orca [7], PC++ [8], Sisal [13], Split-C [11], and SR [3]. However, none of these mul-tithreaded runtime systems employs a single thread package for all platform implementations, and few use any of the lightweight thread packages listed in the preceding paragraph.
Reference: [16] <author> IEEE. </author> <title> Standard for Threads Interface to POSIX, </title> <year> 1996. </year> <month> P1003.1c. </month>
Reference-contexts: Fine-grain control over the behavior of a thread is typically not needed. There is no shortage of lightweight thread packages for application-level programmers, and a short list of such systems would likely include pthreads [22] (the POSIX interface for lightweight threads <ref> [16] </ref>), Solaris threads [26], fast-threads [2], and cthreads [23]. Lightweight threads are also useful for supporting independent tasks generated by parallel or concur fl Supported in part by the National Aeronautics and Space Administration under NASA Contract No. <p> Our hypothesis is that substrate software requires success for each goal, and that existing lightweight thread packages fail in one or more of these goals. For example, one may argue that pthreads <ref> [16] </ref> is efficient and provides portability because its the "standard," but it falls short in providing the flexibility demanded by most system-level programmers. For example, using pthreads it is impossible to trace thread execution when the scheduling policy is round-robin (preemptive). <p> However, more sophisticated debugging tools are clearly required. 5 Related Research OpenThreads represents a novel approach to the design of user-level threads, in which the user is given the opportunity to change the behavior of high-level abstractions in a well-defined manner. Many thread packages, such as pthreads <ref> [16] </ref>, support an extensive user-interface with some behavior-modifying commands intertwined (such as attribute specification for threads). However, these systems do not take a systematic approach to exposing the critical design dilemmas and, as a result, fall short in providing the flexibility required by most system-level programmers.
Reference: [17] <author> David Keppel. </author> <title> Tools and techniques for building fast portable threads packages. </title> <type> Technical Report UWCSE 93-05-06, </type> <institution> University of Washington, </institution> <year> 1993. </year>
Reference-contexts: (void *storage, int size); extern ots_stack *ots_stack_init (ots_stack_t *sp, ots_userf_t *userf, void *userarg, ots_inif_t *initf, void *initarg); extern void *ots_switch_all (ots_helperf_t *helper, void *arg1, void *arg2, ots_stack_t *new); extern void *ots_lock_init (ots_lock_t lock); extern int ots_lock_acquire (ots_lock_t lock); extern void void ots_lock_release (ots_lock_t lock); ing routines intentionally mimic the QuickThreads <ref> [17] </ref> macros, which are an excellent example of how very-low-level thread support can be provided in a machine-independent manner. 4 Discussion In this section we discuss our design in terms of our original design goals and in terms of open issues that have yet to be addressed or resolved. 4.1 Design <p> Portability. Our system-level interface isolates all underlying dependencies in a single file that needs to be changed for each new platform. In some cases, there are no changes required at all. This is due to the fact that OpenThreads is currently mapping its low-level thread operations onto Quick-Threads <ref> [17] </ref>, which is already very portable. The Panda port runs the same code on both the So-laris and Amoeba platforms, and regular Orca programs were run to ensure the stability of the port. <p> However, these systems do not take a systematic approach to exposing the critical design dilemmas and, as a result, fall short in providing the flexibility required by most system-level programmers. QuickThreads <ref> [17] </ref> is a thread-building toolkit that offers platform independent micro-instructions for managing thread stacks. QuickThreads is similar to assembly language programming in terms of flexibility, speed, and complexity.
Reference: [18] <author> Gregor Kiczales. </author> <title> Foil for the workshop on open implementation. </title> <booktitle> In Proceedings of the Workshop on Open Implementation, </booktitle> <year> 1994. </year> <note> Available at http://www.xerox.com/PARC/spl/eca/oi.html. </note>
Reference-contexts: Though "black box" abstractions are effective for constructing complex systems because they hide the details of an implementation, they don't always work because "there are times when the implementation strategy for a module cannot be determined before knowing how the module will be used in a particular system" <ref> [18] </ref>. As we've seen, this is particularly true for multithreaded runtime systems employing lightweight threads, where many of the implementation decisions are to be made by the runtime system designer, not the thread package designer. <p> Recently, the object-oriented research community has been addressing the issue of improved design methodologies for substrate (system-level) software <ref> [9, 18, 19, 20, 27] </ref>. From this research, a new design methodology for substrate software has emerged, called Open Implementation [18, 19]. <p> Recently, the object-oriented research community has been addressing the issue of improved design methodologies for substrate (system-level) software [9, 18, 19, 20, 27]. From this research, a new design methodology for substrate software has emerged, called Open Implementation <ref> [18, 19] </ref>. The basic idea behind this new design methodology is to open the proverbial black box using a well-defined interface, called a meta-interface, that describes how the abstractions provided in the user-interface are to behave. <p> If a user-level thread package is not useful to a system-level programmer, lack of control over scheduling is commonly at the root of the cause. 2.2 Open Implementation Analysis and Design In <ref> [18] </ref>, Kiczales introduces a new approach for the design of substrate software called Open Implementation, and in this section we summarize these ideas. The reader is encouraged to examine [18] and [20] for more details on this design philosophy. <p> programmer, lack of control over scheduling is commonly at the root of the cause. 2.2 Open Implementation Analysis and Design In <ref> [18] </ref>, Kiczales introduces a new approach for the design of substrate software called Open Implementation, and in this section we summarize these ideas. The reader is encouraged to examine [18] and [20] for more details on this design philosophy. We have already stated that black-box abstractions do not always work because "there are times when the best implementation strategy for a module cannot be determined without knowing how the module will be used in a particular situation" [18]. <p> to examine <ref> [18] </ref> and [20] for more details on this design philosophy. We have already stated that black-box abstractions do not always work because "there are times when the best implementation strategy for a module cannot be determined without knowing how the module will be used in a particular situation" [18]. <p> OpenThreads builds on the QuickThreads design philosophy of keeping things simple, and provides high-level abstractions whose be-havior can be modified by the user in a well-defined manner. The initial description of Open Implementation Analysis and Design <ref> [18] </ref> provided the motivation for much of this work. However, the initial description fails to talk about portability concerns.
Reference: [19] <author> Gregor Kiczales, Robert DeLine, Arthur Lee, and Chris Maeda. </author> <title> Open implementation analysis and design of substrate software. </title> <booktitle> In Tutorial Notes, OOPSLA 95, </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year> <pages> ACM/SIGPLAN. </pages>
Reference-contexts: Recently, the object-oriented research community has been addressing the issue of improved design methodologies for substrate (system-level) software <ref> [9, 18, 19, 20, 27] </ref>. From this research, a new design methodology for substrate software has emerged, called Open Implementation [18, 19]. <p> Recently, the object-oriented research community has been addressing the issue of improved design methodologies for substrate (system-level) software [9, 18, 19, 20, 27]. From this research, a new design methodology for substrate software has emerged, called Open Implementation <ref> [18, 19] </ref>. The basic idea behind this new design methodology is to open the proverbial black box using a well-defined interface, called a meta-interface, that describes how the abstractions provided in the user-interface are to behave.
Reference: [20] <author> Gregor Kiczales, Jim des Riv ieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Recently, the object-oriented research community has been addressing the issue of improved design methodologies for substrate (system-level) software <ref> [9, 18, 19, 20, 27] </ref>. From this research, a new design methodology for substrate software has emerged, called Open Implementation [18, 19]. <p> The reader is encouraged to examine [18] and <ref> [20] </ref> for more details on this design philosophy. We have already stated that black-box abstractions do not always work because "there are times when the best implementation strategy for a module cannot be determined without knowing how the module will be used in a particular situation" [18].
Reference: [21] <author> Ravi Konuru, Jeremy Casas, Robert Prouty, Steve Otto, and Jonathan Walpole. </author> <title> A user-level process package for PVM. </title> <booktitle> In Proceedings of Scalable High Performance Computing Conference, </booktitle> <year> 1994. </year>
Reference-contexts: Other systems combining threads with communication primitives include Chant [14], Nexus [12], PVM-threads <ref> [21] </ref>, and MPI-threads [10]. 4. Signals. Most papers on lightweight threads include long and involved discussions about signal handling in the presence of threads. We will avoid this discussion for now, and simply state that OpenThreads currently exposes all threads to the same signal mask.
Reference: [22] <author> Frank Mueller. </author> <title> A library implementation of POSIX threads under UNIX. </title> <booktitle> In Winter USENIX, </booktitle> <pages> pages 29-41, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: In this context, threads free the programmer from the details of dynamic scheduling. Fine-grain control over the behavior of a thread is typically not needed. There is no shortage of lightweight thread packages for application-level programmers, and a short list of such systems would likely include pthreads <ref> [22] </ref> (the POSIX interface for lightweight threads [16]), Solaris threads [26], fast-threads [2], and cthreads [23]. Lightweight threads are also useful for supporting independent tasks generated by parallel or concur fl Supported in part by the National Aeronautics and Space Administration under NASA Contract No.
Reference: [23] <author> Bodhisattwa Mukherjee. </author> <title> A portable and reconfigurable threads package. </title> <type> Technical Report GIT-ICS-91/02, </type> <institution> College of Computing, Georgia Institute of Technology, Atlanta, Georgia, </institution> <month> June </month> <year> 1991. </year> <booktitle> Also appears in Proceedings of Sun User's Group Technical Conference, </booktitle> <pages> pages 101-112. </pages>
Reference-contexts: Fine-grain control over the behavior of a thread is typically not needed. There is no shortage of lightweight thread packages for application-level programmers, and a short list of such systems would likely include pthreads [22] (the POSIX interface for lightweight threads [16]), Solaris threads [26], fast-threads [2], and cthreads <ref> [23] </ref>. Lightweight threads are also useful for supporting independent tasks generated by parallel or concur fl Supported in part by the National Aeronautics and Space Administration under NASA Contract No.
Reference: [24] <author> M.L. Powell, S.R. Kleinman, S. Barton, D. Shah, D. Stein, and M. Weeks. </author> <title> SunOS Multi-thread Architecture. </title> <booktitle> In Proceedings of USENIX Winter Technical Conference, </booktitle> <address> Dallas, TX, </address> <year> 1991. </year>
Reference-contexts: Since the OS kernel controls addressing and scheduling for the CPU, user-level threads must be multiplexed atop one or more kernel-level entities, such as Unix processes [4], Mach kernel threads [1], or a Sun Lightweight Processes (LWP) <ref> [24] </ref>. This "multiplexing" is commonly referred to as scheduling of the user-level threads. The kernel-entity (hereafter referred to as a "process") also provides a common address space that is shared by all threads multiplexed onto that process, and synchronization primitives are provided to keep the memory consistent. <p> This requires protecting critical regions with kernel locks and identifying all global data as either shared among the kernel threads or private. Kernel thread private global data, such as the pointer to the current thread, needs to be stored as thread-specific data for each kernel thread. Powell et.al. <ref> [24] </ref> provide a discussion of this mapping for Solaris threads mapped onto LWPs. Another issue to be addressed in supporting kernel threads is the impact of kernel thread decisions on the meta-level interface.
Reference: [25] <author> Carl Schmidtmann, Michael Tao, and Steven Watt. </author> <title> Design and implementation of a multi-threaded Xlib. </title> <booktitle> In Winter USENIX, </booktitle> <pages> pages 193-203, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Lightweight threads are useful for a variety of purposes. An application-level programmer will typically use threads to facilitate asynchronous scheduling for a number of related tasks. For example, consider an event-driven application, such as Xlib <ref> [25] </ref>, where lightweight threads are used to schedule tasks for execution based on an external event. In this context, threads free the programmer from the details of dynamic scheduling. Fine-grain control over the behavior of a thread is typically not needed.
Reference: [26] <author> SunSoft Manual Set. </author> <title> Solaris Multithreaded Programming Guide. </title> <publisher> SunSoft Press, </publisher> <year> 1996. </year> <note> ISBN 0 13-160896-7. </note>
Reference-contexts: Fine-grain control over the behavior of a thread is typically not needed. There is no shortage of lightweight thread packages for application-level programmers, and a short list of such systems would likely include pthreads [22] (the POSIX interface for lightweight threads [16]), Solaris threads <ref> [26] </ref>, fast-threads [2], and cthreads [23]. Lightweight threads are also useful for supporting independent tasks generated by parallel or concur fl Supported in part by the National Aeronautics and Space Administration under NASA Contract No.
Reference: [27] <author> W. Staringer. </author> <title> Constructing applications from reusable components. </title> <journal> IEEE Software, </journal> <volume> 11(5) </volume> <pages> 61-68, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Recently, the object-oriented research community has been addressing the issue of improved design methodologies for substrate (system-level) software <ref> [9, 18, 19, 20, 27] </ref>. From this research, a new design methodology for substrate software has emerged, called Open Implementation [18, 19].
Reference: [28] <author> D. Stein and D. Shah. </author> <title> Implementing lightweight threads. </title> <booktitle> In Proceedings of USENIX Summer Technical Conference, </booktitle> <address> San Antonio, TX, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: Thread identification is the task of determining which thread, or more specifically, which thread control block is currently active at any given time. One way to do this is to reserve a global register to hold this pointer. This is the approach taken by Solaris threads <ref> [28] </ref>, and has the advantage of being very fast and not requiring global memory. However, compiler and architecture support are required to reserve this register, and the loss of a register on RISC-based architectures is always cause for concern.
References-found: 28

