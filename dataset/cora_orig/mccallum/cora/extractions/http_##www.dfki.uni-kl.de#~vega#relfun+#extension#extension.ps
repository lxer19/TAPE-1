URL: http://www.dfki.uni-kl.de/~vega/relfun+/extension/extension.ps
Refering-URL: http://www.dfki.uni-kl.de/~vega/relfun.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: boley@informatik.uni-kl.de  
Title: Extended Logic-plus-Functional Programming  
Author: Harold Boley 
Date: February 24, 1995  
Address: Box 2080, D-6750 Kaiserslautern, F. R. Germany  
Affiliation: Deutsches Forschungszentrum fur Kunstliche Intelligenz  
Abstract: Extensions of logic and functional programming are integrated in RELFUN. Its valued clauses comprise Horn clauses (`true'-valued) and clauses with a distinguished `foot' premise (returning arbitrary values). Both the logic and functional components permit LISP-like varying-arity and higher-order operators. The DATAFUN sublanguage of the functional component is shown to be preferable to relational encodings of functions in DATALOG. RELFUN permits non-ground, non-deterministic functions, hence certain functions can be inverted using an `is'-primitive generalizing that of PROLOG. For function nestings a strict call-by-value strategy is employed. The reduction of these extensions to a relational sublanguage is discussed and their WAM compilation is sketched. Three examples (`serialise', `wang', and `eval') demonstrate the relational/functional style in use. The list expressions of RELFUN's LISP implementation are presented in an extended PROLOG-like syntax. 
Abstract-found: 1
Intro-found: 1
Reference: [Bac78] <author> John Backus. </author> <title> Can programming be liberated from the von Neumann style? A functional style and its algebra of programs. </title> <journal> CACM, </journal> <volume> 21(8) </volume> <pages> 613-641, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: We then interpret value-returning premises (after the ampersand) as generalized Horn-rule premises: apart from being terms like -1 they may be calls like *(-1,X) or member (X,[-1,3,-5]) and nestings like +(*(-1,X),3) or member (X,rest ([-1,-3,-5])). Nestings are evaluated strictly call-by-value, as, classically, in FP <ref> [Bac78] </ref>. 1 The RELFUN notions of relation and function are amalgamated to an abstract operator concept: functions are generalized to non-ground, non-deterministic operators, hence relations can be viewed as characteristic functions. <p> Higher-order unification of the kind studied with Prolog [NM90], however, is orthogonal to the extensions in RELFUN, which for simplicity and efficiency lives without -expressions (thus avoiding problems with -variables <ref> [Bac78] </ref>) and `semantic' extensions of Robinson unification. Constructor variables can be used to abstract from, or force equality of, the `type' of structures, as encoded by their constructor. For example, the unification of staple [book,X,X] and F [Y,paper,paper] succeeds, binding F to the constructor staple. <p> Note that the free variable Attribute in the first tup position becomes bound by its application in the second tup position before the tup actually returns the pair. Function structures can be employed like "function-forming operators" in FP <ref> [Bac78] </ref>. Bringing the relational-product example in subsection 2.5 back to functional programming, functional composition can be defined by using the structure compose [F,G] as a function, which permits twice to be defined as a compose-structure-valued footed fact: compose [F,G](X) :-& F (G (X)). twice (F) :-& compose [F,F].
Reference: [BBK94] <author> H. Boley, U. Buhrmann, and C. Kremer. </author> <title> Towards a sharable knowledge base on recyclable plastics. </title> <editor> In James K. McDowell and Kenneth J. Meltsner, editors, </editor> <booktitle> Knowledge-Based Applications in Materials Science and Engineering, </booktitle> <pages> pages 29-42. TMS, </pages> <year> 1994. </year> <month> 28 </month>
Reference-contexts: F (naturals (0,V)|Nargs)) & V.] 19 4 The Logic/Functional Style in Use Several RELFUN projects have explored the use of relational/functional programming for non-toy problems: the language has been evaluated and tuned by programs for realistic tasks such as hypergraph processing [Bol92], NC-program generation [BHH + 91], and materials engineering <ref> [BBK94] </ref>. <p> The RELFUN sources are available in (a portable subset of) COMMON LISP along with programming examples, e.g. the ones from this paper. In our hybrid expert-system shell, COLAB, RELFUN's backward rules were augmented by forward rules, taxonomies, and constraints [BHHMng]. Problems of realistic size have been solved by RELFUN <ref> [Bol92, BBK94] </ref> and RELFUN/COLAB [BHH + 91] programs.
Reference: [BGM88] <author> P.G. Bosco, E. Giovannetti, and C. Moiso. </author> <title> Narrowing vs. </title> <journal> SLD-resolution. Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 3-23, </pages> <year> 1988. </year>
Reference-contexts: RELFUN thus provides a version of innermost conditional narowing [Fri85]. Its operational semantics flattens functional nestings to relational conjunctions, thus inherits the search-space reduction of SLD-resolution <ref> [BGM88] </ref>. Hence, our WAM implementation of (first-order) RELFUN can approach the speed of PROLOG [Bol90]. Besides its attempt at integrating basic notions of PROLOG and LISP, many of REL-FUN's extended concepts can also be transferred to relational and functional programming individually.
Reference: [BHH + 91] <author> Harold Boley, Philipp Hanschke, Martin Harm, Knut Hinkelmann, Thomas Labisch, Manfred Meyer, Joerg Mueller, Thomas Oltzen, Michael Sin-tek, Werner Stein, and Frank Steinle. CAD2NC: </author> <title> A declarative lathe-workplanning model transforming CAD-like geometries into abstract NC programs. </title> <type> Technical Report Document D-91-15, </type> <institution> University of Kaiserslautern, DFKI, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: [mu [F](|Nargs) :- once (0 is F (naturals (0,V)|Nargs)) & V.] 19 4 The Logic/Functional Style in Use Several RELFUN projects have explored the use of relational/functional programming for non-toy problems: the language has been evaluated and tuned by programs for realistic tasks such as hypergraph processing [Bol92], NC-program generation <ref> [BHH + 91] </ref>, and materials engineering [BBK94]. <p> In our hybrid expert-system shell, COLAB, RELFUN's backward rules were augmented by forward rules, taxonomies, and constraints [BHHMng]. Problems of realistic size have been solved by RELFUN [Bol92, BBK94] and RELFUN/COLAB <ref> [BHH + 91] </ref> programs.
Reference: [BHHMng] <author> H. Boley, P. Hanschke, K. Hinkelmann, and M. Meyer. COLAB: </author> <title> A hybrid knowledge representation and compilation laboratory. Annals of Operations Research, forthcoming. Presented at 3rd International Workshop on Data, Expert Knowledge and Decisions: Using Knowledge to Transform Data into Information for Decision Support, </title> <address> Reisensburg, Germany, </address> <month> Sept. </month> <year> 1991. </year> <note> Preprinted as: DFKI Research Report RR-93-08, </note> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: The RELFUN sources are available in (a portable subset of) COMMON LISP along with programming examples, e.g. the ones from this paper. In our hybrid expert-system shell, COLAB, RELFUN's backward rules were augmented by forward rules, taxonomies, and constraints <ref> [BHHMng] </ref>. Problems of realistic size have been solved by RELFUN [Bol92, BBK94] and RELFUN/COLAB [BHH + 91] programs.
Reference: [Bol86] <author> Harold Boley. RELFUN: </author> <title> A relational/functional integration with valued clauses. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(12) </volume> <pages> 87-98, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: With RELFUN we have been pursuing the latter alternatives of these dimensions: it was first operationally defined as a highly integrated language (cf. <ref> [Bol86] </ref>), which was later endowed with a model-theoretic semantics capturing the essence of the integration (cf. [Bol93]). The language's operational side stems from its origin as a pure-LISP-based interpreter. Also the present version is both implemented in, and can access precoded functionality from (a subset of) COMMON LISP.
Reference: [Bol90] <author> Harold Boley. </author> <title> A relational/functional language and its compilation into the WAM. </title> <type> Technical Report SEKI SR-90-05, </type> <institution> University of Kaiserslautern, Department of Computer Science, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: RELFUN thus provides a version of innermost conditional narowing [Fri85]. Its operational semantics flattens functional nestings to relational conjunctions, thus inherits the search-space reduction of SLD-resolution [BGM88]. Hence, our WAM implementation of (first-order) RELFUN can approach the speed of PROLOG <ref> [Bol90] </ref>. Besides its attempt at integrating basic notions of PROLOG and LISP, many of REL-FUN's extended concepts can also be transferred to relational and functional programming individually. In the following section (2) the extended relational component will be treated, including higher-order relations. <p> While the structure relproduct [...] can be (higher-order-)called directly, as in relproduct [fathrel,mothrel](john,W), the constant relsquare is (first-order-)called to bind a variable, which is then used as a structure-valued relation variable, as in relsquare (fathrel,T), T (john,W). As discussed in <ref> [Bol90] </ref>, higher-order relations of this form are not easily compiled into the WAM, which collects all clauses with the same constant relation name and arity into a procedure. <p> Besides this kind of RELFUN-to-PROLOG translation we have implemented a more direct WAM compilation of non-deterministic, non-ground functions <ref> [Bol90] </ref>: the WAM temporary register X1 (identical to the argument register A1) is also used for passing returned values, so that first-argument nestings need not be flattened because the caller directly finds the returned value of the first callee in argument register X1. 3.2 Full RELFUN Exemplified by "Self "-Functions When <p> The `horizontal' transformations of the full language into a sublanguage are also important in preparation for RELFUN's `vertical' WAM compilation. While the complete language is implemented as an interpreter, a slightly restricted version is also realized as a compiler/emulator <ref> [Bol90, Sin94] </ref>. The RELFUN sources are available in (a portable subset of) COMMON LISP along with programming examples, e.g. the ones from this paper. In our hybrid expert-system shell, COLAB, RELFUN's backward rules were augmented by forward rules, taxonomies, and constraints [BHHMng].
Reference: [Bol92] <author> Harold Boley. </author> <title> Declarative operations on nets. </title> <editor> In Fritz Lehmann, editor, </editor> <booktitle> Semantic Networks in Artificial Intelligence, </booktitle> <volume> volume 23, </volume> <pages> pages 601-637. </pages> <note> Special Issue of Computers & Mathematics with Applications, Pergamon Press, 1992. Preprinted as: DFKI Research Report RR-90-12, </note> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: ! & V.) [mu [F](|Nargs) :- once (0 is F (naturals (0,V)|Nargs)) & V.] 19 4 The Logic/Functional Style in Use Several RELFUN projects have explored the use of relational/functional programming for non-toy problems: the language has been evaluated and tuned by programs for realistic tasks such as hypergraph processing <ref> [Bol92] </ref>, NC-program generation [BHH + 91], and materials engineering [BBK94]. <p> The RELFUN sources are available in (a portable subset of) COMMON LISP along with programming examples, e.g. the ones from this paper. In our hybrid expert-system shell, COLAB, RELFUN's backward rules were augmented by forward rules, taxonomies, and constraints [BHHMng]. Problems of realistic size have been solved by RELFUN <ref> [Bol92, BBK94] </ref> and RELFUN/COLAB [BHH + 91] programs.
Reference: [Bol93] <author> Harold Boley. </author> <title> A Direct Semantic Characterization of RELFUN. </title> <editor> In Evelina Lamma and Paola Mello, editors, </editor> <booktitle> Proceedings of the 3rd International Workshop on Extensions of Logic Programming, ELP '92, Bologna 1992, volume 660 of LNAI. </booktitle> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: With RELFUN we have been pursuing the latter alternatives of these dimensions: it was first operationally defined as a highly integrated language (cf. [Bol86]), which was later endowed with a model-theoretic semantics capturing the essence of the integration (cf. <ref> [Bol93] </ref>). The language's operational side stems from its origin as a pure-LISP-based interpreter. Also the present version is both implemented in, and can access precoded functionality from (a subset of) COMMON LISP. Besides the definitional interpreter this implementation consists of a WAM compiler/emulator system. <p> While with these reductions RELFUN's semantics is indirectly founded on the usual Herbrand models for Horn clauses, there is also a more direct characterization of RELFUN's first-order hornish and footed clauses <ref> [Bol93] </ref>, using functionally extended Herbrand models (instead of distinguishing an equality relation). The `horizontal' transformations of the full language into a sublanguage are also important in preparation for RELFUN's `vertical' WAM compilation.
Reference: [Bol94] <author> Harold Boley. </author> <title> Finite Domains and Exclusions as First-Class Citizens. </title> <editor> In Roy Dyckhoff, editor, </editor> <booktitle> Proceedings of the 4th International Workshop on Extensions of Logic Programming, </booktitle> <address> ELP '93, St. Andrews, Scotland, </address> <year> 1993, </year> <title> volume 798 of LNAI. </title> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: In particular, this holds for the orthogonal functional, varying-arity, higher-order, and cut extensions of the pure-PROLOG-like Horn language. Several other extensions of pure PROLOG/LISP, e.g. finite domains <ref> [Bol94] </ref> and sort lattices [Hal94], being quite independent from the ones in the RELational/FUNctional kernel, were added in a uniform fashion, e.g. leading to domain values as well as arguments. Further extensions, e.g. modules [Her95], may follow in a similar manner.
Reference: [CK85] <author> Mats Carlsson and Kenneth M. Kahn. </author> <title> LM-Prolog user manual. </title> <type> Technical Report UPMAIL 24, </type> <institution> Uppsala University, Department of Computer Science, </institution> <note> Revised April 1985. </note>
Reference-contexts: Their output cannot go to the (usual) last argument position because of the asymmetry of "|"-list-splicing; the only uniformly usable output argument is the first one. For example, while ordinary PROLOGs' ternary append relation is already quite flexible, LM-PROLOG <ref> [CK85] </ref> defines a natural N-ary extension (N &gt; 0), which in RELFUN is rewritten as append ([]). append (Total,[]|Back) :- append (Total|Back). append ([First|Total],[First|Front]|Back) :- append (Total,Front|Back).
Reference: [DL86] <editor> D. DeGroot and G. Lindstrom, editors. </editor> <title> Logic Programming: Functions, Relations, and Equations. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction Many approaches are possible for combining logic and functional programming, as illustrated by the collection <ref> [DL86] </ref>. <p> But as in newer functional languages, like ML and MIRANDA, a function is defined by "pattern!action" clauses instead of a conditional expression. Generalizing pattern matching to unification, RELFUN permits non-ground functions, as allowed in other logic/functional integrations <ref> [DL86] </ref>. This also leads to non-deterministic functions, enumerating finitly or infinitly many values via backtracking. The relational/functional integration entails a continuing cross-fertilization of the two language styles.
Reference: [Fri84] <author> Laurent Fribourg. </author> <title> Oriented equational clauses as a programming language. </title> <journal> J. Logic Programming, </journal> <volume> 1(2) </volume> <pages> 165-177, </pages> <year> 1984. </year> <month> 29 </month>
Reference-contexts: conciseness, program analysis, and variable elimination this is preferable to flat relational conjunctions such as area (china,A1), area (india,A2), area (usa,A3), +(Area,A1,A2,A3) The main disadvantage lies in the issue of inverted calls, which are easier and sometimes more logically complete for `usage-neutral' relations: a functional non-termination problem is illustrated in <ref> [Fri84] </ref>. However, RELFUN's inversion method for functions appears quite natural, and for its DATAFUN subset completeness problems do not arise.
Reference: [Fri85] <author> Laurent Fribourg. SLOG: </author> <title> A logic programming language interpreter based on clausal superposition and rewriting. </title> <booktitle> In 1985 Symposium on Logic Programming, </booktitle> <pages> pages 172-184. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1985. </year>
Reference-contexts: Our notion of relations as true-valued functions is like in SLOG <ref> [Fri85] </ref>, except that RELFUN's valued facts return true implicitly. Another amalgamating notion is akin to LISP's "useful non-nil values": relation 1 (Nested) function calls will be written with (round) parentheses, while [embedded] structures or lists will be distinguished by [square] brackets. <p> Certain RELFUN functions can be inverted by calling them non-ground (by-value) on the right-hand side (rhs) of a generalized PROLOG is-primitive, mimicking relations (incl. the above eq predicate). RELFUN thus provides a version of innermost conditional narowing <ref> [Fri85] </ref>. Its operational semantics flattens functional nestings to relational conjunctions, thus inherits the search-space reduction of SLD-resolution [BGM88]. Hence, our WAM implementation of (first-order) RELFUN can approach the speed of PROLOG [Bol90].
Reference: [GF91] <author> Michael R. Genesereth and Richard Fikes in collaboration with Danny Bo-brow, Piero Bonissone, Ron Brachman, Ramanathan Guha, Reed Letsinger, Valdimir Lifschitz, Bob MacGregor, John McCarthy, Peter Norvig, Ramesh Patil, and Len Schubert. </author> <title> Knowledge Interchange Format Version 2.2 Reference Manual. </title> <type> Technical Report Logic-90-4, </type> <institution> Stanford University, Computer Science Department, Logic Group, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Thus, both structures and applications can be ended by a vertical bar followed by an ordinary variable; equivalently, they could be ended by a "sequence variable" as used in KIF <ref> [GF91] </ref>. Varying-arity applications give argument sequences the flavor of an implicit list data structure.
Reference: [GM84] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Equality, types, modules, and (why not?) generics for logic programming. </title> <journal> J. Logic Programming, </journal> <volume> 1(2) </volume> <pages> 179-210, </pages> <year> 1984. </year>
Reference-contexts: a country with a precisely given thousands-of-square-miles area such as 8708 (the problem would become even more noticeable if the exact areas were stored, perhaps as real numbers, with rounding problems etc.) Therefore 3 , in our opinion this `historical' DATALOG example should be rewritten functionally, as already implied in <ref> [GM84] </ref>. For this we extract the second argument from the DATALOG facts and use it as the so-called foot after a ":-&"-infix: area (china) :-& 3380. area (india) :-& 1139. area (ussr) :-& 8708. area (usa) :-& 3609.
Reference: [Hal94] <author> Victoria Hall. </author> <title> Integration von Sorten als ausgezeichnete, </title> <note> taxonomische Pradikate in eine relational-funktionale Sprache. Projektarbeit, 1994. In Vorbereitung. </note>
Reference-contexts: In particular, this holds for the orthogonal functional, varying-arity, higher-order, and cut extensions of the pure-PROLOG-like Horn language. Several other extensions of pure PROLOG/LISP, e.g. finite domains [Bol94] and sort lattices <ref> [Hal94] </ref>, being quite independent from the ones in the RELational/FUNctional kernel, were added in a uniform fashion, e.g. leading to domain values as well as arguments. Further extensions, e.g. modules [Her95], may follow in a similar manner.
Reference: [Her95] <editor> Michael Herfert. Deklarative statische und dynamische Softwaremodule. Diplomarbeit, </editor> <address> Universitat Kaiserslautern, </address> <month> February </month> <year> 1995. </year>
Reference-contexts: Several other extensions of pure PROLOG/LISP, e.g. finite domains [Bol94] and sort lattices [Hal94], being quite independent from the ones in the RELational/FUNctional kernel, were added in a uniform fashion, e.g. leading to domain values as well as arguments. Further extensions, e.g. modules <ref> [Her95] </ref>, may follow in a similar manner. Besides the `dynamic' interplay between our language extensions, there are `static' reduction possibilities for several of them. Most notably, the functional sublanguage can be relationalized and the higher-order part can be reduced to the first-order part.
Reference: [Llo87] <author> John W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1987. </year>
Reference-contexts: Below, a sample sorted call is given, which occurs in an (internally non-ground and non-deterministic) functional version of the well-known relational slow-sort program <ref> [Llo87] </ref>. <p> Note that this functional sort version specifies a computationally preferable (nesting) sequence by calling perm before sorted. In the relational sort specification commutativity of conjunction appears to permit calling sorted before perm, which, however, would not run in normal PROLOGs, as discussed in <ref> [Llo87] </ref>.
Reference: [MAE + 62] <author> John McCarthy, Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, and Michael I. Levin. </author> <title> LISP 1.5 programmer's manual. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1962. </year>
Reference-contexts: It is now most easily observed that a ground call such as serialise ([d,a,l,l,a,s]) via the non-ground call (with numbered operating here on qsort's list-of-lists value) numbered ([[a,Y2],[d,Y1],[l,Y3],[s,Y6]],1) & [Y1,Y2,Y3,Y3,Y2,Y6] returns the ground value [2,1,3,3,1,4]. 4.2 wang: On-the-Fly Construction of Proof Trees Since its pure LISP description in <ref> [MAE + 62] </ref>, Wang's proof algorithm for the propositional calculus has often been reformulated to demonstrate the use of declarative languages. <p> be degenerated to a non-tree-building relational algorithm by just omitting all "&"-separators; the resulting hornish clauses could then be simplified, mainly by bringing 24 the work recursions to the top-level. 4.3 eval: Interpreting a LISP Subset in RELFUN Most LISP-in-LISP metainterpreters descended from the metacircular eval/apply specification of LISP 1.5 <ref> [MAE + 62] </ref>. The operational semantics of pure LISP was later transcribed to a concise pure PROLOG relation eval [PP82]. The below deterministic RELFUN function eval, corecursive with apply, defines, without concern for efficiency, a non-trivial LISP subset including closures, macros, and an object-level eval 9 .
Reference: [NM90] <author> Gopalan Nadathur and Dale Miller. </author> <title> Higher-order Horn clauses. </title> <journal> JACM, </journal> <volume> 37(4) </volume> <pages> 777-814, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: This enables a restricted kind of higher-order operators, syntactically reducible to first-order operators, but more expressive and cleaner than PROLOG's use of extralogical builtins like functor, "=..", and metacall as higher-order substitutes. Higher-order unification of the kind studied with Prolog <ref> [NM90] </ref>, however, is orthogonal to the extensions in RELFUN, which for simplicity and efficiency lives without -expressions (thus avoiding problems with -variables [Bac78]) and `semantic' extensions of Robinson unification. Constructor variables can be used to abstract from, or force equality of, the `type' of structures, as encoded by their constructor.
Reference: [O'D85] <author> M. J. O'Donnell. </author> <title> Equational Logic as a Programming Language. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1985. </year>
Reference-contexts: Moreover, the s definition enables a direct analogue to equational addition: +(0,N) :-& N. It should also be noted here that RELFUN definitions obey the "constructor discipline" <ref> [O'D85] </ref>, which with our notation amounts to saying simply that "clause heads must not have embedded parenthesized expressions". This would be violated by the eq-nested signum calls shown in the introduction.
Reference: [PP82] <author> Lus Moniz Pereira and Antonio Porto. </author> <title> Pure Lisp in pure Prolog. </title> <booktitle> Logic Programming Newsletter 3, Summer 1982. </booktitle> <institution> Universidade Nova de Lisboa, Departamento de Informatica. </institution>
Reference-contexts: The operational semantics of pure LISP was later transcribed to a concise pure PROLOG relation eval <ref> [PP82] </ref>. The below deterministic RELFUN function eval, corecursive with apply, defines, without concern for efficiency, a non-trivial LISP subset including closures, macros, and an object-level eval 9 . LISP lists (and function calls) are represented as RELFUN lists (with distinguished first elements). <p> This would provide a `codefinition' of RELFUN and LISP, like the one proposed for PROLOG and LISP in Kenneth M. Kahn's "Pure Prolog in Pure Lisp" response (Logic Programming Newsletter 5, Winter 83/84) to the "Pure Lisp in Pure Prolog" <ref> [PP82] </ref> paper.
Reference: [PS91] <author> Lawrence C. Paulson and Andrew W. Smith. </author> <title> Logic programming, functional programming, and inductive definitions. </title> <editor> In P. Schroeder-Heister, editor, </editor> <booktitle> Extensions of Logic Programming, </booktitle> <pages> pages 283-309, </pages> <address> Berlin, Heidelberg, New York, 1991. </address> <publisher> Springer-Verlag. LNCS 475. </publisher>
Reference-contexts: A special valued conjunction calling only relations to the left of "&" and having a single variable to its right (e.g., country (X), between (X,atlantic,pacific) & X) can be viewed as an indefinite description or -expression (e.g., (x)[country (x)^between (x; atlantic; pacif ic)]), also provided in other relational/functional amalgamations (see <ref> [PS91] </ref>). Certain RELFUN functions can be inverted by calling them non-ground (by-value) on the right-hand side (rhs) of a generalized PROLOG is-primitive, mimicking relations (incl. the above eq predicate). RELFUN thus provides a version of innermost conditional narowing [Fri85]. <p> The algorithm applies reduction rules to a sequent representation of propositional formulas until an atomic formula occurs in both the antecedent and consequent of all derived sequents, reporting true, or no more rule is applicable to a sequent, reporting false. <ref> [PS91] </ref> gives a version with an extra relation argument for constructing a proof tree "on-the-fly", whose size can be computed by an invertible function. 22 Here we give a RELFUN version that returns the trees of successful proofs, where subtrees are built and their roots labeled "on-the-fly" by a constructor and
Reference: [Sin92] <author> Michael Sintek. </author> <title> Generalized indexing methods for higher-order PROLOG extensions: A case study with the RELFUN WAM. </title> <type> Technical report, </type> <institution> University of Kaiserslautern, DFKI, </institution> <month> Forthcoming </month> <year> 1992. </year>
Reference-contexts: Each varying-arity c [x1,...,xN|X] could be replaced by the unary c [[x1,...,xN|X]], where the single argument is a list containing 6 the original c arguments as elements. However, this naive method introduces unnecessary bracketing (which could be hidden to the user) and hinders intrastructure WAM indexing <ref> [Sin92] </ref> with respect to a structure's top-level arguments (which become `neutralized' to a tup or cns constructor). Instead of listifying all c arguments, a `semi-listifying' method might keep a fixed number, K N, of initial arguments and only listify the remaining ones, resulting in the (K+1)-ary c [x1,...,xK,[xK+1,...,xN|X]].
Reference: [Sin94] <author> Michael Sintek. </author> <title> FLIP: Functional-plus-Logic Programming on an Integrated Platform. </title> <booktitle> 3rd Workshop on Functional Logic Programming, </booktitle> <address> Schwarzenberg, Germany, </address> <month> January </month> <year> 1994. </year> <month> 30 </month>
Reference-contexts: The `horizontal' transformations of the full language into a sublanguage are also important in preparation for RELFUN's `vertical' WAM compilation. While the complete language is implemented as an interpreter, a slightly restricted version is also realized as a compiler/emulator <ref> [Bol90, Sin94] </ref>. The RELFUN sources are available in (a portable subset of) COMMON LISP along with programming examples, e.g. the ones from this paper. In our hybrid expert-system shell, COLAB, RELFUN's backward rules were augmented by forward rules, taxonomies, and constraints [BHHMng].
Reference: [War82] <author> David H. D. Warren. </author> <title> Higher-order extensions to PROLOG: </title> <journal> Are they needed? Machine Intelligence, </journal> <volume> 10 </volume> <pages> 441-454, </pages> <year> 1982. </year>
Reference-contexts: As discussed in [Bol90], higher-order relations of this form are not easily compiled into the WAM, which collects all clauses with the same constant relation name and arity into a procedure. However, relation variables and structures can be eliminated by simply 9 introducing an apply relation constant as in <ref> [War82] </ref>, which we shorten to ap: hor (...) is replaced by ap (hor,...) in all heads and bodies, moving the higher-order relation hor to the first argument position.
Reference: [WPP77] <author> David H. D. Warren, Luis M. Pereira, and Fernando Pereira. </author> <title> Prolog the language and its implementation compared with Lisp. </title> <journal> SIGPLAN Notices, </journal> <volume> 12(8) </volume> <pages> 109-115, </pages> <month> August </month> <year> 1977. </year> <note> Special Issue. 31 </note>
Reference-contexts: also indexing on their first arguments. 3 Functions Defined by Footed Clauses 3.1 DATAFUN as a Functional Database Language We now proceed to functions, first considering DATAFUN, the functional subset of REL-FUN corresponding to PROLOG's DATALOG subset. 3.1.1 Footed Facts and Non-Ground Functions Let us consider the database example in <ref> [WPP77] </ref>, containing the following DATALOG facts about country areas (given in thousands of square miles): area (china,3380). area (india,1139). area (ussr, 8708). area (usa, 3609). 10 Although these binary relations would permit requests like area (Cntry,8708), their nor-mal use direction is of the kind area (ussr,Area): the large value range of <p> Non-ground foots can yield both ground and non-ground values, as in exp (2,1), returning 2, and exp (Y,1), returning Y, respectively. 3.1.2 Footed Rules and the density Example In <ref> [WPP77] </ref> there are also DATALOG Horn facts about population (in millions), which we think should be `functionalized' to DATAFUN footed facts as demonstrated for area. <p> To conclude the density example of <ref> [WPP77] </ref>, PROLOG's "database query" rule ans (C1,D1,C2,D2) :- density (C1,D1), density (C2,D2), D1 &gt; D2, 20*D1 &lt; 21*D2. and request ans (C1,D1,C2,D2) for finding countries whose population density differs by less than 5%, in RELFUN could be mimicked directly but can also be rewritten as a single valued conjunction D1 is <p> In order to facilitate comparison with other languages, this section gives versions of three well-known non-trivial programs in RELFUN's logic/functional style (not all features of RELFUN will be needed in these examples). 4.1 serialise: Inplace Updates of Non-Ground Structures After the density database, the second practical PROLOG example given in <ref> [WPP77] </ref> is the relational serialise program. Its task is to transform a list of items into a corresponding list of their alphabetic serial numbers; e.g., [p,r,o,l,o,g] should become [4,5,3,2,3,1].
References-found: 28

