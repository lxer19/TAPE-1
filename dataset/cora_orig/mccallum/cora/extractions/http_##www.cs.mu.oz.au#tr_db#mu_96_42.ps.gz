URL: http://www.cs.mu.oz.au/tr_db/mu_96_42.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: E-mail: flobel,raog@cs.mu.oz.au  E-mail: anand@aaii.oz.au  
Title: Inheritance Anomaly A Formal Treatment  
Author: Lobel Crnogorac Anand S. Rao and Kotagiri Ramamohanarao 
Keyword: inheritance, behavioural subtyping, concurrent object-oriented programming  
Address: Vic. 3052, Australia,  6, 171 La Trobe Street, Melbourne Vic. 3000, Australia,  
Affiliation: Dept. of Computer Science, The University of Melbourne, Parkville  Australian Artificial Intelligence Institute, Level  
Abstract: Inheritance is one of the key concepts in object-oriented programming (OOP). However, the usefulness of inheritance in concurrent OOP is greatly reduced by the inheritance anomalies. These anomalies have been subjected to intense research, but they are still only vaguely defined and often misunderstood. In this paper we show that concurrency is not the real cause of inheritance anomalies. We formally define the inheritance anomaly as a relationship between inheritance mechanisms and behavioural hierarchies. Our framework can be used to analyse the occurrence of inheritance anomalies in many different paradigms. A formal definition of the problem and a clear exposition of its causes are pre-requisites for a successful integration of inheritance and concurrency. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Aksit, J. Bosch, W. van der Sterren, and L. Bergmans. </author> <title> Real-time specification inheritance anomalies and real-time filters. </title> <booktitle> In ECOOP'94, </booktitle> <volume> LNCS 821, </volume> <pages> pages 386-407. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: However, the appearance of inheritance anomalies in other paradigms based on object-oriented concepts points to the need for a much more thorough examination of their causes. For example, inheritance anomaly in real-time specification languages <ref> [1] </ref> could not be caused by an interference between inheritance and concurrency because these languages are purely sequential. The introduction of inheritance into agent-oriented programming (AOP) [14] also leads to the appearance of inheritance anomalies [5]. <p> Of course, in the context of COOP it is still correct to view the anomaly as being caused by an interference between inheritance and concurrency. However, this view does not generalise well. For example, inheritance anomalies have been discovered in sequential real-time specification languages <ref> [1] </ref> (behaviour hierarchy would be based on temporal information). 5 EXAMPLE ANALYSIS This section presents an example analysis of inheritance mechanisms in sequential and concurrent OOP. We examine two different behavioural hierarchies, which are based on the externally observable behaviour of objects.
Reference: [2] <author> P. </author> <title> America. Designing an object-oriented programming language with behavioural subtyping. </title> <publisher> LNCS 489, </publisher> <pages> pages 60-90. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We share the views in <ref> [2, 13] </ref> that inheritance should be an unconstrained, flexible tool for code re-use. Inheritance should maximise the amount of code that can be re-used when defining a new specification from an existing specification. Subtyping is concerned with the use of objects, and is usually based on method signatures. <p> Subtyping is concerned with the use of objects, and is usually based on method signatures. Whenever we require an object, a subtype of that object would do equally well. Inheritance and subtyping are distinct concepts <ref> [2] </ref>, since inheritance is concerned with the internal structure of objects (code sharing), while subtyping is concerned with the external behaviour of objects (the way objects are used). The work on behavioural subtyping [2, 9] extends the concept of subtyping to more general notions of behaviour. <p> Inheritance and subtyping are distinct concepts [2], since inheritance is concerned with the internal structure of objects (code sharing), while subtyping is concerned with the external behaviour of objects (the way objects are used). The work on behavioural subtyping <ref> [2, 9] </ref> extends the concept of subtyping to more general notions of behaviour. The key insight of this paper is the connection between the notions of inheritance and subtyping: the inheritance mechanism should be powerful enough to incrementally mimic the behavioural (subtype) hierarchy. <p> Definition 7 is equivalent to simple subtyping without covariant/contravariant rules <ref> [2] </ref> since messages contain only service names, and parameters are ignored (this can be extended). Sometimes, we need to distinguish between behaviours based on the actual sequencing of accepted messages.
Reference: [3] <author> M.Y. Ben-Gershon and S.J. Goldsack. </author> <title> Using inheritance to build extend-able synchronisation policies for concurrent and distributed systems. </title> <booktitle> In TOOLs Pacific '95, </booktitle> <pages> pages 109-121, </pages> <year> 1995. </year>
Reference-contexts: The requirements we put on a framework for inheritance anomaly are: * The framework must be general enough to allow a uniform analysis of inheritance anomaly for any existing inheritance mechanism in any existing object-oriented paradigm. For example, inheritance anomaly in truly concurrent languages (allowing intra-object concurrency <ref> [3] </ref>) with active objects seems to be a much harder problem than the more constrained case (only inter-object concurrency). The framework must be able to capture the general problem of inheritance anomaly in COOP. * The framework must formally pinpoint the cause of the anomaly. <p> Our framework can be used to analyse the occurrence of inheritance anomalies in many different paradigms. The analysis based on the formal definition provides a clearer understanding of the causes of the anomaly. We provide results that explain the recent directions of research into better inheritance mechanisms <ref> [3, 12] </ref> and show that an ideal solution does not exist. <p> Further research into this area should lead to more formal classifications of the different types of anomalies. The immediate implication of Theorem 2 is that there is no ideal solution to the problem of inheritance anomalies in COOP. Hence, it supports the recent direction of research <ref> [3, 12] </ref> which separates the actual inheritance mechanisms of the synchronisation code and the functionality code, leading to non-behaviour-preserving inheritance mechanisms. The trade-off expressed by Theorem 2 is that an inheritance mechanism is either not powerful enough (not anomaly-free), or it is too powerful (not behaviour preserving).
Reference: [4] <author> W. Cook and J. Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In OOPSLA'89, </booktitle> <pages> pages 433-443, </pages> <year> 1989. </year>
Reference-contexts: New services may be added, the inherited services re-defined or omitted. An inheritance mechanism of a language is usually given by defining the semantics of its inheritance operator <ref> [4] </ref>. We take a different approach. Here we formalise the inheritance mechanism of an arbitrary language as a transition relation on the set of syntactic specifications. A pair of syntactic specifications forms a transition if the second specification can be obtained from the first by using the inheritance rules. <p> We focus on single inheritance in this paper. fl In most contexts this is actually a double implication. However, in order to model inheritance in languages that use self and super <ref> [4] </ref> the definition of incremental transitions needs to be modified to include some additional transitions.
Reference: [5] <author> L. Crnogorac and A. S. Rao. </author> <title> Inheritance by extensions and restrictions in agent systems. </title> <booktitle> In ACSC'97, </booktitle> <address> Sydney, Australia, </address> <month> February </month> <year> 1997. </year>
Reference-contexts: For example, inheritance anomaly in real-time specification languages [1] could not be caused by an interference between inheritance and concurrency because these languages are purely sequential. The introduction of inheritance into agent-oriented programming (AOP) [14] also leads to the appearance of inheritance anomalies <ref> [5] </ref>. The requirements we put on a framework for inheritance anomaly are: * The framework must be general enough to allow a uniform analysis of inheritance anomaly for any existing inheritance mechanism in any existing object-oriented paradigm.
Reference: [6] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: In the context of our chosen object model we define behaviour of an object to be the set of all possible sequences of messages that the object can accept. We use the concept of traces <ref> [6] </ref>. Suppose that an external observer notes down the message acceptances. A trace is a finite sequence of message acceptances by an object.
Reference: [7] <author> D. G. Kafura and K. H. Lee. </author> <title> Inheritance in Actor based concurrent object-oriented languages. </title> <booktitle> In ECOOP'89, </booktitle> <pages> pages 131-145, </pages> <address> UK, </address> <year> 1989. </year>
Reference-contexts: 1 INTRODUCTION Inheritance is one of the key concepts in object-oriented programming (OOP). It is a widely used methodology for code re-use in sequential object-oriented programming. In recent years, the concepts from OOP have been applied in a concurrent setting, leading to the emergence of concurrent object-oriented programming (COOP) <ref> [7, 11, 12] </ref>. In its full generality COOP paradigm allows inter-object concurrency (multiple objects existing concurrently) and intra-object concurrency (multiple threads inside an object). It was found that most OOP concepts (e.g., encapsulation) could be naturally integrated into COOP. However, the integration of inheritance and COOP has not been smooth. <p> The extra states possible in the subclass have to be accounted for in all the methods in the superclass. The classical example involves a language based on accept sets <ref> [7, 15] </ref>. The synchronisation scheme of these proposals uses explicit sets to determine which methods are acceptable at any time. The methods that are not currently acceptable are either rejected, or suspended and placed into a message queue. The keyword become denotes the explicit switching between the states.
Reference: [8] <author> U. Lechner, C. Lengauer, F. Nickl, and M. Wirsing. </author> <title> How to overcome the inheritance anomaly. In ECOOP'96, </title> <publisher> LNCS 1098. Springer-Verlag. </publisher>
Reference-contexts: It was found that most OOP concepts (e.g., encapsulation) could be naturally integrated into COOP. However, the integration of inheritance and COOP has not been smooth. One of the main problems with inheritance in COOP is the in-heritance anomaly <ref> [8, 10, 11, 12, 13, 15] </ref>. Inheritance anomaly arises when additional methods of a subclass cause undesirable re-definitions of the methods in the superclass.
Reference: [9] <author> B. Liskov and J. M. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> TOPLAS, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <year> 1994. </year>
Reference-contexts: Inheritance and subtyping are distinct concepts [2], since inheritance is concerned with the internal structure of objects (code sharing), while subtyping is concerned with the external behaviour of objects (the way objects are used). The work on behavioural subtyping <ref> [2, 9] </ref> extends the concept of subtyping to more general notions of behaviour. The key insight of this paper is the connection between the notions of inheritance and subtyping: the inheritance mechanism should be powerful enough to incrementally mimic the behavioural (subtype) hierarchy.
Reference: [10] <author> S. Matsuoka, K. Wakita, and A. Yonezawa. </author> <title> Synchronization constraints with inheritance: What is not possible so what is? Technical Report 10, </title> <institution> Dept. of Information Science, the University of Tokyo, </institution> <year> 1990. </year>
Reference-contexts: It was found that most OOP concepts (e.g., encapsulation) could be naturally integrated into COOP. However, the integration of inheritance and COOP has not been smooth. One of the main problems with inheritance in COOP is the in-heritance anomaly <ref> [8, 10, 11, 12, 13, 15] </ref>. Inheritance anomaly arises when additional methods of a subclass cause undesirable re-definitions of the methods in the superclass. <p> The aim was to successfully avoid the anomaly in the benchmark examples. Inheritance anomaly has never been formally defined in its full generality, although a particular type of anomaly, state-partitioning, has been formally investigated by Matsuoka et. al. <ref> [10] </ref>. We feel that a general formal treatment of the problem is needed in order to precisely define the inheritance anomaly and to formally compare the different proposals.
Reference: [11] <author> S. Matsuoka and A. Yonezawa. </author> <title> Analysis of inheritance anomaly in object-oriented concurrent programming languages. </title> <booktitle> In Research Directions in COOP, chapter 1, </booktitle> <pages> pages 107-150. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: 1 INTRODUCTION Inheritance is one of the key concepts in object-oriented programming (OOP). It is a widely used methodology for code re-use in sequential object-oriented programming. In recent years, the concepts from OOP have been applied in a concurrent setting, leading to the emergence of concurrent object-oriented programming (COOP) <ref> [7, 11, 12] </ref>. In its full generality COOP paradigm allows inter-object concurrency (multiple objects existing concurrently) and intra-object concurrency (multiple threads inside an object). It was found that most OOP concepts (e.g., encapsulation) could be naturally integrated into COOP. However, the integration of inheritance and COOP has not been smooth. <p> It was found that most OOP concepts (e.g., encapsulation) could be naturally integrated into COOP. However, the integration of inheritance and COOP has not been smooth. One of the main problems with inheritance in COOP is the in-heritance anomaly <ref> [8, 10, 11, 12, 13, 15] </ref>. Inheritance anomaly arises when additional methods of a subclass cause undesirable re-definitions of the methods in the superclass. <p> The main practical progress has been made in the area of languages that do not allow intra-object concurrency. For comparison purposes the proposals were usually evaluated on a set of standard benchmark examples introduced by Matsuoka and Yonezawa <ref> [11] </ref>. The aim was to successfully avoid the anomaly in the benchmark examples. Inheritance anomaly has never been formally defined in its full generality, although a particular type of anomaly, state-partitioning, has been formally investigated by Matsuoka et. al. [10]. <p> The examples used are due to Matsuoka and Yonezawa <ref> [11] </ref>. The anomaly results in the inability of COOP languages to inherit synchroni-sation code without re-definitions. Concurrent object-oriented programming languages have to provide facilities for expressing synchronisation constraints of objects. <p> Inheritance anomaly (in the context of COOP) is the conflict between concurrency and inheritance where extensive re-definitions of inherited methods are necessary in order to maintain the synchronisation constraints of concurrent objects. Matsuoka and Yonezawa <ref> [11] </ref> have distinguished three kinds of inheritance anomalies in COOP languages: * state-partitioning: Execution of a concurrent object can be thought of as a sequence of transitions between states. Each state is determined by the current values of all the state variables and the methods that are acceptable. <p> The anomaly appears when the become statements of put and get (as well as the most of the behaviour block) need to be re-defined to accommodate for the extra state. State-partitioning has been circumvented by proposals that employ method guards instead of accept sets <ref> [11] </ref>. A method is accepted if its guard evaluates to true, otherwise it is suspended (placed into a message queue) or rejected. The syntax is "method method signature when guard" (Figure 2). <p> This observation leads to an explanation of the inconsistency in the current literature. Until now, the definition of behavioural hierarchy was only given informally by researchers, through examples. In the case of HistoryBuffer (Section 2) some researchers have claimed that it illustrates an anomaly <ref> [11, 12] </ref>, while others have claimed that it actually modifies the behaviour of Buffer [13] and therefore should not be considered an anomaly. This inconsistency arises from different assumptions about the behavioural hierarchy. A formal definition of behaviour hierarchy is needed to unambiguously define the problem.
Reference: [12] <author> C. McHale. </author> <title> Synchronisation in COO Languages: Expressive Power, Genericity and Inheritance. </title> <type> PhD dissertation, </type> <institution> Trinity College, </institution> <year> 1994. </year>
Reference-contexts: 1 INTRODUCTION Inheritance is one of the key concepts in object-oriented programming (OOP). It is a widely used methodology for code re-use in sequential object-oriented programming. In recent years, the concepts from OOP have been applied in a concurrent setting, leading to the emergence of concurrent object-oriented programming (COOP) <ref> [7, 11, 12] </ref>. In its full generality COOP paradigm allows inter-object concurrency (multiple objects existing concurrently) and intra-object concurrency (multiple threads inside an object). It was found that most OOP concepts (e.g., encapsulation) could be naturally integrated into COOP. However, the integration of inheritance and COOP has not been smooth. <p> It was found that most OOP concepts (e.g., encapsulation) could be naturally integrated into COOP. However, the integration of inheritance and COOP has not been smooth. One of the main problems with inheritance in COOP is the in-heritance anomaly <ref> [8, 10, 11, 12, 13, 15] </ref>. Inheritance anomaly arises when additional methods of a subclass cause undesirable re-definitions of the methods in the superclass. <p> Also, the framework must be able to formally explain and justify the choices made in the development of better inheritance mechanisms (e.g., the need to separate inheritance of synchronisation code from inheritance of functionality code should be formally justified <ref> [12] </ref>). * The framework must present a formal definition of inheritance anomaly. We share the views in [2, 13] that inheritance should be an unconstrained, flexible tool for code re-use. Inheritance should maximise the amount of code that can be re-used when defining a new specification from an existing specification. <p> Our framework can be used to analyse the occurrence of inheritance anomalies in many different paradigms. The analysis based on the formal definition provides a clearer understanding of the causes of the anomaly. We provide results that explain the recent directions of research into better inheritance mechanisms <ref> [3, 12] </ref> and show that an ideal solution does not exist. <p> This observation leads to an explanation of the inconsistency in the current literature. Until now, the definition of behavioural hierarchy was only given informally by researchers, through examples. In the case of HistoryBuffer (Section 2) some researchers have claimed that it illustrates an anomaly <ref> [11, 12] </ref>, while others have claimed that it actually modifies the behaviour of Buffer [13] and therefore should not be considered an anomaly. This inconsistency arises from different assumptions about the behavioural hierarchy. A formal definition of behaviour hierarchy is needed to unambiguously define the problem. <p> Further research into this area should lead to more formal classifications of the different types of anomalies. The immediate implication of Theorem 2 is that there is no ideal solution to the problem of inheritance anomalies in COOP. Hence, it supports the recent direction of research <ref> [3, 12] </ref> which separates the actual inheritance mechanisms of the synchronisation code and the functionality code, leading to non-behaviour-preserving inheritance mechanisms. The trade-off expressed by Theorem 2 is that an inheritance mechanism is either not powerful enough (not anomaly-free), or it is too powerful (not behaviour preserving).
Reference: [13] <author> J. Meseguer. </author> <title> Solving the inheritance anomaly in concurrent object-oriented programming. </title> <booktitle> In ECOOP'93, </booktitle> <volume> LNCS 707, </volume> <pages> pages 220-246. </pages>
Reference-contexts: It was found that most OOP concepts (e.g., encapsulation) could be naturally integrated into COOP. However, the integration of inheritance and COOP has not been smooth. One of the main problems with inheritance in COOP is the in-heritance anomaly <ref> [8, 10, 11, 12, 13, 15] </ref>. Inheritance anomaly arises when additional methods of a subclass cause undesirable re-definitions of the methods in the superclass. <p> We share the views in <ref> [2, 13] </ref> that inheritance should be an unconstrained, flexible tool for code re-use. Inheritance should maximise the amount of code that can be re-used when defining a new specification from an existing specification. Subtyping is concerned with the use of objects, and is usually based on method signatures. <p> Until now, the definition of behavioural hierarchy was only given informally by researchers, through examples. In the case of HistoryBuffer (Section 2) some researchers have claimed that it illustrates an anomaly [11, 12], while others have claimed that it actually modifies the behaviour of Buffer <ref> [13] </ref> and therefore should not be considered an anomaly. This inconsistency arises from different assumptions about the behavioural hierarchy. A formal definition of behaviour hierarchy is needed to unambiguously define the problem.
Reference: [14] <author> Y. Shoham. </author> <title> Agent-oriented programming. </title> <journal> Artificial Intelligence, </journal> <volume> 60(1) </volume> <pages> 51-92, </pages> <year> 1993. </year>
Reference-contexts: For example, inheritance anomaly in real-time specification languages [1] could not be caused by an interference between inheritance and concurrency because these languages are purely sequential. The introduction of inheritance into agent-oriented programming (AOP) <ref> [14] </ref> also leads to the appearance of inheritance anomalies [5]. The requirements we put on a framework for inheritance anomaly are: * The framework must be general enough to allow a uniform analysis of inheritance anomaly for any existing inheritance mechanism in any existing object-oriented paradigm.

References-found: 14

