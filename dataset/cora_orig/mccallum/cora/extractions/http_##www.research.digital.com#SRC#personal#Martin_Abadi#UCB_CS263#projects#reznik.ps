URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/UCB_CS263/projects/reznik.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/UCB_CS263/projects.html
Root-URL: http://www.research.digital.com
Title: Domain-Specific Programming Languages (DSLs): a paper survey  
Author: Dan S. Reznik 
Date: Spring 1997  
Pubnum: CS263 Final Project  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. Weiss. </author> <title> Creating domain-specific languages: the FAST process. </title> <booktitle> In First ACM SIGPLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: Yet the need for the systematic transfer of knowledge from an individual's memory 1 to "corporate" memory has obvious positive economic consequences <ref> [1] </ref>. So one of the "meta" goals of DSL research is to formalize this very process, i.e., the conversion of domain expertise into a computer-parsable language. <p> And again, such systems preserve the need for CS expertise in development, documentation, and maintenance. 2.2 Designing for the future A basic trend in the software industry has been to tighten the engineering-customer loop <ref> [1] </ref> and in design applications so they can be maintained directly by the customer after release. <p> another to perform corporate acquisitions, both of which require reasoning in terms of current interest rates, inflation, valuation models (often described as differential equations) the point being that anticipating the existence of a family of solutions maybe crucial in cost of the design lifecycle of a (family) of software applications <ref> [1] </ref>. So in one sense, the art of DSL design is to find a reduced enough domain model (in terms of language constructs) which is general enough to accomodate for future family growth. 2.3 Cost issues According to [1], the basic viability of a DSL is validated by the following questions: <p> in cost of the design lifecycle of a (family) of software applications <ref> [1] </ref>. So in one sense, the art of DSL design is to find a reduced enough domain model (in terms of language constructs) which is general enough to accomodate for future family growth. 2.3 Cost issues According to [1], the basic viability of a DSL is validated by the following questions: does a particular DSL solve the right problems, is it easier to use and at least as efficient as current methods, and finally, is there a significant application? From a quantitative viewpont, [1] points out that 3-fold productivity <p> 2.3 Cost issues According to <ref> [1] </ref>, the basic viability of a DSL is validated by the following questions: does a particular DSL solve the right problems, is it easier to use and at least as efficient as current methods, and finally, is there a significant application? From a quantitative viewpont, [1] points out that 3-fold productivity gains can be expected from a DSL systems designed specifically for future growth. <p> Let N is the number of pieces of software sold, C a and C b be the costs of producing A, and modifying B, respectively. In <ref> [1] </ref>, a value of C b = 0:1C a is suggested, though it could be easily one order of magnitude lower. Since B is designed "for the future" it will require an initial investment I, typically greater ([1] suggests three times greater) than C a . <p> When plotted against N these two lines intersect at the "break-even" point beyond which the B solution becomes cheaper than A (in <ref> [1] </ref> it is suggested this would happen for N = 3). <p> is a little too extreme and that it doesn't address many of the DSL desiderata such as creating an environment which is not entirely procedurally-centered and which allows problems to be modeled with a specific language and be maintained by non-experts at a non-programming level. 3.2 The FAST process Weiss <ref> [1] </ref> outlines an architecture, called "FAST" geared toward the systematic construction of DSLs for a family of same-domain problems. While no practical implementation is presented, this work does provide good insight on the basic requirements for such a system. <p> Such a language would have to accommodate the information appearing at each of the stages of a model for customer-centered software development, illustrated by the sequence <ref> [1] </ref>: customer, system concept, application engineering, validation, customer (iterates back), and finally to product.
Reference: [2] <editor> G. Kiczales et al. </editor> <booktitle> Aspect oriented programming. In First ACM SIG-PLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: Object orientation has been an elegant generalization of language design and a good point could be made that it is a general answer to domain-specific programming. One critique presented in <ref> [2] </ref> is that objects do not allow internal structure to be divorced from object behavior, and a program will not explicitate object interactions since these are typically encoded pro-cedurally for example, if a set of objects is used to represent devices in a circuit, the fact that certain devices are directly <p> programmer (a human) they can be done in the form of natural language, which circumvents some of the worries concerning formalization of this type of communication presented in the FAST paper above. 3.4 Aspect oriented programming Not very different from inforcentrism, Aspect-Oriented programming (AOP) as defined by Kiczales et al. <ref> [2] </ref>, represents a similar effort in dissociating domain-specific vocabulary from its implementation. As a tough philosophical issue it is pointed out that a single abstraction framework (say C, or Pascal) only does a good job of capturing one aspect of the program.
Reference: [3] <author> A. vanDeursen and P. Klint. </author> <title> Little languages, </title> <booktitle> little maintenance? In First ACM SIGPLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: It is simply too costly and unreliable to expect a typical domain expert (say a stock trader or a civil engineer) to be able to maintain either lex/yacc or a complex library of routines tailored to their domain. In <ref> [3] </ref>, maintainability is defined as the ease with which system can be kept in operation when modifications to the code become necessary. To this end, consider the usual modeling of problems by computer scientists as algorithms, called the algocentric approach [4]. <p> The authors conjecture that applications are likely to be more economically viable if their input format is designed and maintained by a domain expert rather than a programming language guru similar to the new "organization of software labor" proposed in <ref> [3] </ref> which in essence coalesces jargon creator, document author, developer, and end user into a single individual. In their own words, "a domain expert designing a bad jargon better than computer expert designing good lex and yacc (but weak in domain knowledge)".
Reference: [4] <author> L. Nakatani and M. Jones. Jargons and infocentrism. </author> <booktitle> In First ACM SIG-PLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: In [3], maintainability is defined as the ease with which system can be kept in operation when modifications to the code become necessary. To this end, consider the usual modeling of problems by computer scientists as algorithms, called the algocentric approach <ref> [4] </ref>. Procedurally-encoded information is typically very hard to extract, so the growth and/or redevel 3 opment of a particular application may require a type of black art called reverse-engineering. <p> With an eye on the future, programs should be designed for ease of maintenance and adaptability. 3.3 Infocentrism In <ref> [4] </ref>, Nakatani and Jones emphasize that DSL systems should make explicit the separation of declarative data ("information") from algorithms. They call this paradigm infocentrism.
Reference: [5] <author> P. Pfahler and U. Kastens. </author> <title> Language design and implementation by selection. </title> <booktitle> In First ACM SIGPLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year> <month> 9 </month>
Reference-contexts: rather intuitive when the number of domain applications in the same family is likely to be 3 or greater, it does off to invest in domain engineering and formalize the abstractions and commonalities likely to emerge from that domain. 4 3 Basic Approaches 3.1 Language design 1-2-3 Pfahler and Kastens <ref> [5] </ref> present a rather simplistic solution to the design of a DSL in their view this process should be restricted to a yes/no questionnaire: departing from a general tabula-rasa language, which more or less caputres the union of most current imperative languages (C, Fortran, Pascal, etc.), a "designer" goes through a
References-found: 5

