URL: http://www.cs.iastate.edu/tech-reports/TR94-11.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Generational Garbage Collection of C++ Targeted to SPARC Architectures  
Author: Satish Kumar Guggilla 
Address: 226 Atanasoff Hall Ames, IA 50011  
Affiliation: Department of Computer Science Iowa State University  
Abstract: Dynamic memory management plays a crucial role in the development of large software systems. Traditional techniques for managing dynamic memory require the programmer to free an allocated object when it is no longer required. In addition to posing an intellectual burden on the programmer, this approach has often proved error-prone. Many bugs in existing software systems are known to be caused by dynamic memory management errors. Garbage collectors free the programmer from this intellectual burden by automatically reclaiming allocated objects that are no longer in use. In systems with garbage collection, the programmer need not concern himself with releasing objects no longer in use. Most traditional garbage collectors suspend the application program during the collection process. Generational garbage collectors are known to achieve short pause times as they rely on the observation that most objects die young. They concentrate most of their efforts in reclaiming recently allocated objects, occasionally performing a complete collection. In this project, we have implemented a generational garbage collector for C++ targeted to SPARC architectures. Our technique imposes only minor restrictions on the usage of dynamic memory in C++ and runs on stock hardware. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. F. Bartlett, </author> <title> A Generational, Compacting Garbage Collector for C++, Position Paper for OOPSLA/ECOOP Workshop on Garbage Collection in Object-Oriented Systems, </title> <month> October </month> <year> 1990. </year>
Reference: 2. <author> H. J. Boehm, A. J. Demers and S. Shenker, </author> <title> Mostly Parallel Garbage Collection, </title> <booktitle> Proceedings of the ACM SIG PLAN Notices Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1991. </year> <month> -30- </month>
Reference: 3. <author> P. Caudill, </author> <title> How to Write a Generation Scavenging Collector. </title>
Reference: 4. <author> D. R. Edelson, </author> <title> Fault Interpretation: Fine-Grain Monitoring of Page Accesses, </title> <type> Technical Report UCSC-CRL-92-32, </type> <institution> University of California at Santa Cruz Computer and Information Science Department, </institution> <month> November </month> <year> 1992. </year>
Reference: 5. <author> J. R. Ellis and D. L. Detlefs, </author> <title> Safe, Efficient Garbage Collection for C++, </title> <institution> Digital Equipment Corporation Sys tems Research Center Report 102, </institution> <month> June </month> <year> 1993. </year>
Reference: 6. <author> H. Gao and K. Nilsen, </author> <title> Reliable General Purpose Dynamic Memory Management for Real-Time Systems, </title> <booktitle> IEEE Real-Time Systems Symposium, submitted. </booktitle>
Reference: 7. <author> K. Kuse and T. Kamimura, </author> <title> Generational Garbage Collection for C-Based Object-Oriented Languages. </title>
Reference: 8. <author> K. Nilsen and W. J. Schmidt, </author> <title> Cost-Effective Object-Space Management for Hardware-Assisted Real-Time Garbage Collection, </title> <journal> ACM Letters on Pro g. Lang. and Systems 1, </journal> <month> 4 (December </month> <year> 1992), </year> <pages> 338-354. </pages>
Reference: 9. <author> K. Nilsen, </author> <title> Reliable Real-Time Garbage Collection of C++, </title> <booktitle> Computing Systems 7, </booktitle> <month> 4 (Fall </month> <year> 1994), </year> . 
Reference: 10. <author> K. Nilsen, </author> <title> Cost-Effective Hardware-Assisted Real-Time Garbage Collection, ACM S IGPLAN Notices Work shop on Language, Compiler, and Tool Support for Real-Time Sy stems, </title> <month> June </month> <year> 1994. </year>
Reference-contexts: To illustrate, consider the following global declarations in program foo: -18- /* Type declarations */ /* Globals */ class s1 - s1 g1; int c; s2 g2; int *ip; int g4; int g6 <ref> [10] </ref>; class s2 - s1 *s1p; s2 *next; int val; The gcdata record, for program foo, will be as shown in Fig. 2.4.1. Fig. 2.4.1: The gcdata record for program foo 3. Allocation of Heap Objects As mentioned before, the garbage collector handles all heap allocations.
Reference: 11. <author> K. D. Nilsen and W. J. Schmidt, </author> <title> A High-Performance Hardware-Assisted Real-Time Garbage Collection Sys tem, </title> <journal> Journal of Programming Languages, </journal> <note> To appear. </note>
Reference-contexts: Besides reducing the programmers intellectual burden, automatic garbage collection eliminates a variety of common programming errors. Automatic garbage collection offers the potential of reducing the costs of developing large software systems by approximately 40% of the costs required to develop the same software without automatic garbage collection <ref> [11] </ref>. Besides reducing the complexity of dynamic memory management, some modern garbage collection algorithms offer storage throughputs that are often better or comparable to traditional heap management techniques. <p> A future improvement to the implementation will copy only those pointers that still describe memory cells containing pointers into the nursery. 4 Unlike techniques described previously <ref> [11] </ref>, this copying garbage collection implementation is not incremental. The choice to build a mark list instead of incremental copying was an accident of development. There is no reason why this system could not use the more traditional incremental copying technique. -24- 5.
Reference: 12. <author> SPARC International, Inc., </author> <title> The SPARC Architecture Manual, </title> <publisher> Published by Prentice Hall, </publisher> <year> 1992. </year>
Reference: 13. <author> W. J. Schmidt, </author> <title> Issues in the Design and Implementation of a Real-Time Garbage Collection Architecture, </title> <type> Ph.D. Dissertation, </type> <institution> Iowa State Univ. </institution> <type> Tech. Rep. </type> <pages> 92-25, </pages> <year> 1992. </year>
Reference: 14. <author> P. R. Wilson, M. S. Lam and T. G. Moher, </author> <title> Caching Considerations for Generational Garbage Collection: a Case for Large and Set-Associative Caches, </title> <type> Technical Report UIC-EECS-90-5, </type> <institution> University of Illinois at Chicago EECS Department, </institution> <month> December </month> <year> 1990. </year>
Reference: 15. <author> P. R. Wilson, </author> <title> Uniprocessor Garbage Collection Techniques, in Memory Management, </title> <editor> Y. Bekkers and J. Cohen (ed.), </editor> <publisher> Springer-Verlag , 1992, </publisher> <pages> 1-42. </pages>
Reference-contexts: Usually between 80 and 98 percent of all newly-allocated objects die within a few million instructions, or before another megabyte has been allocated; the majority of objects die even more quickly <ref> [15] </ref>. The pause times observed during garbage collection are proportional to the amount of live data and the size of the heap. Generational garbage collectors attempt to reduce pause times by concentrating on reclaiming recently allocated objects. <p> Most of the garbage collection work is interleaved with actual program execution. It is easy to make these collectors real-time ensuring that at most a bounded amount of garbage collection is done per unit of program execution <ref> [15] </ref> 2 2 Note that compliance with real-time constraints requires deferred reference counting, in which objects are placed onto the free list without decrementing the reference counts of the objects referenced by the newly freed object. <p> The from-space copy is copied to to-space after the object is completely scanned. The space remaining in to-space after the copying is available to satisfy future allocation requests. A ip is shown in Fig. 1.6. A copying garbage collector can be made arbitrarily efficient if sufficient memory is available <ref> [15] </ref>. The work done at each collection is proportional to the amount of live data at the time of garbage collection.
References-found: 15

