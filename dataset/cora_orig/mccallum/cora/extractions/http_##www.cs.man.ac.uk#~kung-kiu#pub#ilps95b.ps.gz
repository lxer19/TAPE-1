URL: http://www.cs.man.ac.uk/~kung-kiu/pub/ilps95b.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: kung-kiu@cs.man.ac.uk  ornaghi@hermes.mc.dsi.unimi.it  adp@iasi.rm.cnr.it  proietti@iasi.rm.cnr.it  
Title: Correctness of Logic Program Transformations Based on Existential Termination  
Author: Kung-Kiu Lau Mario Ornaghi Alberto Pettorossi Maurizio Proietti 
Address: Oxford Road, Manchester M13 9PL, United Kingdom.  Via Comelico 39/41, Milano, Italy.  Via della Ricerca Scientifica, 00133 Roma, Italy.  Viale Manzoni 30, 00185 Roma, Italy.  
Affiliation: Department of Computer Science, University of Manchester,  Dipartimento di Scienze dell'Informazione, Universita degli Studi di Milano,  Department of Electronic Engineering, University of Roma Tor Vergata,  IASI-CNR,  
Abstract: We study the relationships between the correctness of logic program transformation and program termination. We consider definite programs and we identify some `invariants' of the program transformation process. The validity of these invariants ensures the preservation of the success set semantics, provided that the existential termination of the initial program implies the existential termination of the final program. We also identify invariants for the preservation of the finite failure set semantics. We consider four very general transformation rules: definition introduction, definition elimination, iff-replacement, and finite failure. Many versions of the transformation rules proposed in the literature, including unfolding, folding, and goal replacement, are instances of the iff-replacement rule. By using our proposed invariants which are based on Clark completion, we prove, for our transformation rules, various results concerning the preservation of both the success set and finite failure set semantics. By exploiting some powerful properties of the Clark completion, we are able to derive simple proofs of these preservation results. These proofs are much simpler than those done by induction on the construction of the SLD-trees, like the ones proposed in the literature for related results. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Amtoft. </author> <title> Unfold/fold transformations preserving termination properties. </title> <booktitle> In Proc. </booktitle> <address> PLILP'92, Leuven, Belgium, </address> <booktitle> Lecture Notes in Computer Science 631, </booktitle> <pages> pages 187-201. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Recently, advances in the study of logic program termination (see [9] for a survey) have stimulated the investigation of the relationship between program transformation and program termination. For instance, Amtoft <ref> [1] </ref> attempts to give a general semantic framework where one can reason about the preservation of termination when transforming definite logic programs by unfolding and folding. However, more general transformation rules, such as our iff-replacement rule, are not taken into consideration.
Reference: [2] <author> K. R. Apt and D. Pedreschi. </author> <title> Studies in Pure Prolog: Termination. </title> <editor> In J. W. Lloyd, editor, </editor> <booktitle> Proceedings of the Symposium on Computational Logic, </booktitle> <address> Brussels, Belgium, </address> <pages> pages 150-176. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: However, more general transformation rules, such as our iff-replacement rule, are not taken into consideration. Bossi and Cocco [4] focus their study on definite logic programs which are evaluated using the Prolog leftmost computation rule. They consider the following notion, called left-termination in <ref> [2] </ref>: a program P left-terminates wrt a goal g iff P [ f:gg has a finite SLD-tree constructed using the leftmost computation rule. They prove that restricted versions of Tamaki and Sato's unfolding and folding rules preserve both the set of computed answer substitutions and left-termination.
Reference: [3] <author> A. Bossi and N. Cocco. </author> <title> Basic transformation operations which preserve computed answer substitutions of logic programs. </title> <journal> Journal of Logic Programming, </journal> 16(1&2):47-87, 1993. 
Reference-contexts: A rule similar to definition elimination is presented in [15], where it is called deletion, and also in <ref> [3] </ref>, where it is called restricting operation. Clause Replacement Rule. Let P 0 ; : : : ; P j be a transformation sequence and P 0 [ Def j be the extended initial program associated with P 0 ; : : : ; P j .
Reference: [4] <author> A. Bossi and N. Cocco. </author> <title> Preserving universal termination through unfold/fold. </title> <booktitle> In Proceedings ALP'94, </booktitle> <volume> LNCS 850, </volume> <pages> pages 269-286. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In some cases those restrictions are explicitly based on termination properties <ref> [4, 5, 8] </ref>. A similar approach has also been extended to general logic programs under various semantics (see [18] for a detailed discussion). <p> The total correctness of the transformation is then a consequence of Theorem 6. In contrast, the methods proposed in <ref> [4, 8] </ref> which require the existence of finite SLD-trees instead of existential termination, cannot be used to show the total correctness of this transformation, because there exists a goal g such that P 1 [ f:gg has an infinite SLD-tree independently of the choice of the selection rule. <p> Further comparisons with <ref> [4, 8] </ref> are made in the next section. <p> For instance, Amtoft [1] attempts to give a general semantic framework where one can reason about the preservation of termination when transforming definite logic programs by unfolding and folding. However, more general transformation rules, such as our iff-replacement rule, are not taken into consideration. Bossi and Cocco <ref> [4] </ref> focus their study on definite logic programs which are evaluated using the Prolog leftmost computation rule. They consider the following notion, called left-termination in [2]: a program P left-terminates wrt a goal g iff P [ f:gg has a finite SLD-tree constructed using the leftmost computation rule. <p> Bossi and Etalle [5] consider general logic programs and show that Tamaki and Sato's rules preserve acyclicity of programs [9]. This property is used to derive various correctness results for the unfolding and folding transformations. Our approach is quite different from those in <ref> [4, 5] </ref>. We do not deal with the preservation of termination during transformation, as done in those papers, but we study the preservation of properties which, together with the existential termination of the final programs, ensure the total correctness of the entire transformation. <p> Moreover, the notion of existential termination used in this paper is weaker than that of left-termination in <ref> [4] </ref>, and that of acyclicity in [5]. Notice also that the property that all answer substitutions computed by a given initial program are also computed by any derived program, which is used in [4] to show the correctness results, turns out to be redundant for our purposes here. <p> Moreover, the notion of existential termination used in this paper is weaker than that of left-termination in <ref> [4] </ref>, and that of acyclicity in [5]. Notice also that the property that all answer substitutions computed by a given initial program are also computed by any derived program, which is used in [4] to show the correctness results, turns out to be redundant for our purposes here. The paper by Cook and Gallagher [8] is closely related to ours. They provide some termination conditions that ensure the preservation of both the success set and the finite failure set of definite logic programs. <p> As noted in [8], a lot of work has recently been done in the area of automatic termination analysis, and one may take advantage of the proposed techniques for the verification of the total correctness of program transformations. Moreover, as shown in <ref> [4, 5, 8] </ref>, one may also find various syntactic conditions to ensure that the termination properties needed for the proof of correctness are preserved during the transformation process.
Reference: [5] <author> A. Bossi and S. Etalle. </author> <title> Transforming acyclic programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(4) </volume> <pages> 1081-796, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: In some cases those restrictions are explicitly based on termination properties <ref> [4, 5, 8] </ref>. A similar approach has also been extended to general logic programs under various semantics (see [18] for a detailed discussion). <p> They prove that restricted versions of Tamaki and Sato's unfolding and folding rules preserve both the set of computed answer substitutions and left-termination. Bossi and Etalle <ref> [5] </ref> consider general logic programs and show that Tamaki and Sato's rules preserve acyclicity of programs [9]. This property is used to derive various correctness results for the unfolding and folding transformations. Our approach is quite different from those in [4, 5]. <p> Bossi and Etalle [5] consider general logic programs and show that Tamaki and Sato's rules preserve acyclicity of programs [9]. This property is used to derive various correctness results for the unfolding and folding transformations. Our approach is quite different from those in <ref> [4, 5] </ref>. We do not deal with the preservation of termination during transformation, as done in those papers, but we study the preservation of properties which, together with the existential termination of the final programs, ensure the total correctness of the entire transformation. <p> Moreover, the notion of existential termination used in this paper is weaker than that of left-termination in [4], and that of acyclicity in <ref> [5] </ref>. Notice also that the property that all answer substitutions computed by a given initial program are also computed by any derived program, which is used in [4] to show the correctness results, turns out to be redundant for our purposes here. <p> As noted in [8], a lot of work has recently been done in the area of automatic termination analysis, and one may take advantage of the proposed techniques for the verification of the total correctness of program transformations. Moreover, as shown in <ref> [4, 5, 8] </ref>, one may also find various syntactic conditions to ensure that the termination properties needed for the proof of correctness are preserved during the transformation process.
Reference: [6] <author> R. M. Burstall and J. Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> Journal of the ACM, </journal> <volume> 24(1) </volume> <pages> 44-77, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: 1 Introduction When we derive a new program from an initial program by transformation, we need to keep the semantics unchanged. A very simple method to achieve this objective, in the case of recursive equation programs with the least fixpoint semantics, was proposed in Burstall and Darling-ton's pioneering paper <ref> [6] </ref>. This method for recursive equation programs can be described as follows. <p> Conclusions We have investigated in the case of logic programs the relationship between the correctness of the transformation rules and the existential termination of programs, and we have derived a method for ensuring totally correct transformations, which is similar to that originally proposed in <ref> [6] </ref>. We would like to make a general remark on the role of the termination analysis for program transformation. Indeed, since termination is an undecidable property, one may wonder about the usefulness of our approach wrt the one proposed in [20].
Reference: [7] <author> K. L. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Condition (2), since it is proof-theoretical, may be preferable to Condition (1) for the construction of an automatic transformation system. The formula F may include Comp (P 0 [ Def j ), or Clark Equality Theory <ref> [7] </ref>, or the Domain Closure Axiom [16]. <p> Since M (P 0 [ Def k ) j= g, by Lemma 4 all predicates occurring in g are defined in P k and, therefore, by Clark's characterization of Comp <ref> [7] </ref>, Comp (P k ) 6` :g is equivalent to saying that P k does not finitely fail wrt g. Since P k existentially terminates wrt g, P k [ f:gg has an SLD-refutation.
Reference: [8] <author> J. Cook and J. P. Gallagher. </author> <title> A transformation system for definite programs based on termination analysis. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proceedings of LOPSTR'94 and META'94, </booktitle> <address> Pisa, Italy, </address> <publisher> LNCS 883, </publisher> <pages> pages 51-78. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In some cases those restrictions are explicitly based on termination properties <ref> [4, 5, 8] </ref>. A similar approach has also been extended to general logic programs under various semantics (see [18] for a detailed discussion). <p> The total correctness of the transformation is then a consequence of Theorem 6. In contrast, the methods proposed in <ref> [4, 8] </ref> which require the existence of finite SLD-trees instead of existential termination, cannot be used to show the total correctness of this transformation, because there exists a goal g such that P 1 [ f:gg has an infinite SLD-tree independently of the choice of the selection rule. <p> Further comparisons with <ref> [4, 8] </ref> are made in the next section. <p> Notice also that the property that all answer substitutions computed by a given initial program are also computed by any derived program, which is used in [4] to show the correctness results, turns out to be redundant for our purposes here. The paper by Cook and Gallagher <ref> [8] </ref> is closely related to ours. They provide some termination conditions that ensure the preservation of both the success set and the finite failure set of definite logic programs. They consider two transformation rules only: unfolding and goal replacement. <p> We would like to make a general remark on the role of the termination analysis for program transformation. Indeed, since termination is an undecidable property, one may wonder about the usefulness of our approach wrt the one proposed in [20]. As noted in <ref> [8] </ref>, a lot of work has recently been done in the area of automatic termination analysis, and one may take advantage of the proposed techniques for the verification of the total correctness of program transformations. <p> As noted in [8], a lot of work has recently been done in the area of automatic termination analysis, and one may take advantage of the proposed techniques for the verification of the total correctness of program transformations. Moreover, as shown in <ref> [4, 5, 8] </ref>, one may also find various syntactic conditions to ensure that the termination properties needed for the proof of correctness are preserved during the transformation process.
Reference: [9] <author> D. De Schreye and S. Decorte. </author> <title> Termination of logic programs: The neverending story. </title> <journal> Journal of Logic Programming, </journal> <volume> 19, 20 </volume> <pages> 199-260, </pages> <year> 1994. </year>
Reference-contexts: Let us also consider the notion of universal termination <ref> [9] </ref>, which says that a program P universally terminates wrt a given goal g iff all SLD-derivations of P [f:gg are finite. <p> We have that M (P 0 ) j= p, but M (P 1 ) 6j= p. 4 Total Correctness In this section we establish a sufficient condition for total correctness, based on the completion of the final program and the notion of existential termination <ref> [9] </ref>, which is defined as follows. Definition 2 (Existential Termination) A definite program P existentially terminates wrt a goal g iff there exists an SLD-tree for P [ f:gg which either has at least one success branch or it is finitely failed. <p> One problem with this approach is that these restrictions are either very constraining or they require the verification of complex, sometimes undecidable, properties [18]. Recently, advances in the study of logic program termination (see <ref> [9] </ref> for a survey) have stimulated the investigation of the relationship between program transformation and program termination. For instance, Amtoft [1] attempts to give a general semantic framework where one can reason about the preservation of termination when transforming definite logic programs by unfolding and folding. <p> They prove that restricted versions of Tamaki and Sato's unfolding and folding rules preserve both the set of computed answer substitutions and left-termination. Bossi and Etalle [5] consider general logic programs and show that Tamaki and Sato's rules preserve acyclicity of programs <ref> [9] </ref>. This property is used to derive various correctness results for the unfolding and folding transformations. Our approach is quite different from those in [4, 5].
Reference: [10] <author> P. A. Gardner and J. C. Shepherdson. </author> <title> Unfold/fold transformations of logic programs. </title> <editor> In J.-L. Lassez and G. Plotkin, editors, </editor> <booktitle> Computational Logic, Essays in Honor of Alan Robinson, </booktitle> <pages> pages 565-583. </pages> <publisher> MIT, </publisher> <year> 1991. </year>
Reference-contexts: in Example 2 cannot be performed by using the iff-replacement rule with Condition (8), because Comp (P 0 ) 6` (p $ p) ! (p $ r). 6 Correctness Properties of the Unfold/Fold Rules In this section we show that many transformation rules presented in the literature (see, for instance, <ref> [10, 11, 15, 20] </ref>), including various forms of unfolding, folding, and goal replacement, can be viewed as instances of our iff-replacement rule. As a consequence, we can apply our correctness results to these rules, as we now show. <p> : ; C m ), to prove the lemma it is enough to show that Comp (P j ) ` iff (D 1 ; : : : ; D n ; C 2 ; : : : ; C m ): This is a consequence of Theorem 4.1 (a) of <ref> [10] </ref>, where it is shown that if P j+1 is obtained from P j by unfolding, then Comp (P j ) ` Comp (P j+1 ). 2 Folding Rule. <p> Maher's assumption makes the correctness proofs very simple, but it turns out to be a very severe restriction in practice, when one uses program transformation to improve efficiency (see [18] for a more detailed discussion of this issue). By generalizing analogous results in <ref> [10, 15, 17] </ref>, we may prove the following fact. Lemma 6 Suppose that we derive clause D 1 by folding clauses C 1 ; : : : ; C n using E 1 ; : : : ; E n in P 0 [ Def j . <p> ; : : : ; Y m : G 1 $ 9Z 1 ; : : : ; Z n : G 2 ): (11) Our formulation of the goal replacement rule with Condition (9) is similar to that in [20] (which, incidentally, was incorrectly stated as pointed out in <ref> [10] </ref> and later corrected in [21]). If we replace Condition (9) by Condition (11), then we essentially get the version of the goal replacement rule presented in [15]. Lemma 7 Suppose that by goal replacement from clause C 1 we derive clause D 1 .
Reference: [11] <author> M. Gergatsoulis and M. Katzouraki. </author> <title> Unfold/fold transformations for definite clause programs. </title> <booktitle> In Proceedings Sixth International Symposium on Programming Language Implementation and Logic Programming (PLILP'94), </booktitle> <volume> LNCS 844, </volume> <pages> pages 340-354. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: in Example 2 cannot be performed by using the iff-replacement rule with Condition (8), because Comp (P 0 ) 6` (p $ p) ! (p $ r). 6 Correctness Properties of the Unfold/Fold Rules In this section we show that many transformation rules presented in the literature (see, for instance, <ref> [10, 11, 15, 20] </ref>), including various forms of unfolding, folding, and goal replacement, can be viewed as instances of our iff-replacement rule. As a consequence, we can apply our correctness results to these rules, as we now show. <p> Our version of the folding rule is similar to the one in <ref> [11] </ref>, where simultaneous folding of n ( 1) clauses is allowed. However, in [11] some conditions on the transformation sequence are imposed for ensuring total correctness. We have achieved a similar total correctness result by requiring, instead of those conditions, the preservation of existential termination (see Section 4). <p> Our version of the folding rule is similar to the one in <ref> [11] </ref>, where simultaneous folding of n ( 1) clauses is allowed. However, in [11] some conditions on the transformation sequence are imposed for ensuring total correctness. We have achieved a similar total correctness result by requiring, instead of those conditions, the preservation of existential termination (see Section 4).
Reference: [12] <author> C. J. </author> <title> Hogger. Derivation of logic programs. </title> <journal> Journal of the ACM, </journal> <volume> 28(2) </volume> <pages> 372-392, </pages> <year> 1981. </year>
Reference-contexts: To see this, take, for instance, P 1 = fp (a) ; p (b) g and P 2 = fp (a) g. This difficulty may explain why in early papers on logic program transformation, such as those by Hogger <ref> [12] </ref> and Tamaki and Sato [20], the problem of verifying total correctness is not based on termination properties. In particular, in [12] total correctness is proved by first considering transformation rules which preserve partial correctness and then proving the inclusion of the least Herbrand model of P 1 in the least <p> This difficulty may explain why in early papers on logic program transformation, such as those by Hogger <ref> [12] </ref> and Tamaki and Sato [20], the problem of verifying total correctness is not based on termination properties. In particular, in [12] total correctness is proved by first considering transformation rules which preserve partial correctness and then proving the inclusion of the least Herbrand model of P 1 in the least Herbrand model of P 2 .
Reference: [13] <author> K.-K. Lau, M. Ornaghi, and S.- A.Tarnlund. </author> <title> The halting problem for deductive synthesis of logic programs. </title> <editor> In P. van Hentenryck, editor, </editor> <booktitle> Proc. 11 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 665-783. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: A similar approach has also been extended to general logic programs under various semantics (see [18] for a detailed discussion). In contrast, in this paper we propose a more flexible approach, which has been inspired by some of the ideas presented in <ref> [13] </ref> in the related field of logic program synthesis.
Reference: [14] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <note> Second Edition, </note> <year> 1987. </year>
Reference-contexts: Thus, we make it explicit that all atoms with predicates not occurring in the head of any clause of P are false in M (P ). Comp (P ) is the completion of P constructed as in <ref> [14] </ref>. iff (P ) is the formula constructed from program P exactly as Comp (P ), but: (i) without adding 8X::p (X) for every predicate p occurring in the body of a clause of P and not occurring in the head of any clause of P , and (ii) without adding <p> Proof. Let g be a goal in G such that M (P k ) j= g. By van Emden and Kowalski's result (see Theorem 6.2 in <ref> [14] </ref>), we have that P k j= g and therefore, by hypothesis, we get M (P 0 [ Def k ) j= g.
Reference: [15] <author> M. J. Maher. </author> <title> Correctness of a logic program transformation system. </title> <type> IBM Research Report RC 13496, </type> <institution> T. J. Watson Research Center, </institution> <year> 1987. </year>
Reference-contexts: This rule is similar to the definition rule given in <ref> [15] </ref> and it allows us to simultaneously introduce one or more new predicate definitions which possibly consist of mutually recursive clauses. <p> A rule similar to definition elimination is presented in <ref> [15] </ref>, where it is called deletion, and also in [3], where it is called restricting operation. Clause Replacement Rule. <p> in Example 2 cannot be performed by using the iff-replacement rule with Condition (8), because Comp (P 0 ) 6` (p $ p) ! (p $ r). 6 Correctness Properties of the Unfold/Fold Rules In this section we show that many transformation rules presented in the literature (see, for instance, <ref> [10, 11, 15, 20] </ref>), including various forms of unfolding, folding, and goal replacement, can be viewed as instances of our iff-replacement rule. As a consequence, we can apply our correctness results to these rules, as we now show. <p> Tamaki and Sato's folding rule [20] is much simpler than our folding rule and it basically corresponds to our rule for n = 1. They also impose some extra conditions on the transformation sequence for ensuring total correctness. The folding rules considered by Maher in <ref> [15, 17] </ref> differ from our folding rule because in Maher's rules the clauses E 1 ; : : : ; E n used for folding are all taken from program P j , instead of P 0 [ Def j . <p> Maher's assumption makes the correctness proofs very simple, but it turns out to be a very severe restriction in practice, when one uses program transformation to improve efficiency (see [18] for a more detailed discussion of this issue). By generalizing analogous results in <ref> [10, 15, 17] </ref>, we may prove the following fact. Lemma 6 Suppose that we derive clause D 1 by folding clauses C 1 ; : : : ; C n using E 1 ; : : : ; E n in P 0 [ Def j . <p> If we replace Condition (9) by Condition (11), then we essentially get the version of the goal replacement rule presented in <ref> [15] </ref>. Lemma 7 Suppose that by goal replacement from clause C 1 we derive clause D 1 .
Reference: [16] <author> M. J. Maher. </author> <title> Complete axiomatizations of the algebras of finite, rational and infinite trees. </title> <booktitle> In Proc. of the 3rd Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 348-357, </pages> <address> Edinburgh, 1988. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Condition (2), since it is proof-theoretical, may be preferable to Condition (1) for the construction of an automatic transformation system. The formula F may include Comp (P 0 [ Def j ), or Clark Equality Theory [7], or the Domain Closure Axiom <ref> [16] </ref>. F may also include any formula taken from the recursively enumerable set of formulas which express the first-order induction principle over the Herbrand universe of L. 3 Partial Correctness We now introduce the notions of partial correctness and total correctness of a transformation sequence.
Reference: [17] <author> M. J. Maher. </author> <title> A transformation system for deductive database modules with perfect model semantics. </title> <journal> Theoretical Computer Science, </journal> <volume> 110 </volume> <pages> 377-403, </pages> <year> 1993. </year>
Reference-contexts: Tamaki and Sato's folding rule [20] is much simpler than our folding rule and it basically corresponds to our rule for n = 1. They also impose some extra conditions on the transformation sequence for ensuring total correctness. The folding rules considered by Maher in <ref> [15, 17] </ref> differ from our folding rule because in Maher's rules the clauses E 1 ; : : : ; E n used for folding are all taken from program P j , instead of P 0 [ Def j . <p> Maher's assumption makes the correctness proofs very simple, but it turns out to be a very severe restriction in practice, when one uses program transformation to improve efficiency (see [18] for a more detailed discussion of this issue). By generalizing analogous results in <ref> [10, 15, 17] </ref>, we may prove the following fact. Lemma 6 Suppose that we derive clause D 1 by folding clauses C 1 ; : : : ; C n using E 1 ; : : : ; E n in P 0 [ Def j .
Reference: [18] <author> A. Pettorossi and M. Proietti. </author> <title> Transformation of logic programs: Foundations and techniques. </title> <journal> Journal of Logic Programming, </journal> <volume> 19,20:261-320, </volume> <year> 1994. </year>
Reference-contexts: In some cases those restrictions are explicitly based on termination properties [4, 5, 8]. A similar approach has also been extended to general logic programs under various semantics (see <ref> [18] </ref> for a detailed discussion). In contrast, in this paper we propose a more flexible approach, which has been inspired by some of the ideas presented in [13] in the related field of logic program synthesis. <p> Maher's assumption makes the correctness proofs very simple, but it turns out to be a very severe restriction in practice, when one uses program transformation to improve efficiency (see <ref> [18] </ref> for a more detailed discussion of this issue). By generalizing analogous results in [10, 15, 17], we may prove the following fact. <p> One problem with this approach is that these restrictions are either very constraining or they require the verification of complex, sometimes undecidable, properties <ref> [18] </ref>. Recently, advances in the study of logic program termination (see [9] for a survey) have stimulated the investigation of the relationship between program transformation and program termination.
Reference: [19] <author> T. Sato. </author> <title> An Equivalence Preserving First Order Unfold/Fold Transformation System. </title> <journal> Theoretical Computer Science, </journal> <volume> 105 </volume> <pages> 57-84, </pages> <year> 1992. </year>
Reference-contexts: However, this is equivalent to the introduction of 3-valued models, while in this paper we want to stick to 2-valued models. For results dealing with the preservation of 3-valued models during transformation, the reader may see, for instance, <ref> [19] </ref>. The structure of the paper is as follows. In Section 2 we consider three basic transformation rules: definition introduction, definition elimination, and clause replacement. Then, in Section 3 we show that, in general, these rules preserve partial correctness wrt the least Herbrand model semantics.
Reference: [20] <author> H. Tamaki and T. Sato. </author> <title> Unfold/fold transformation of logic programs. </title> <editor> In S.- A. Tarnlund, editor, </editor> <booktitle> Proceedings Second International Conference on Logic Programming, </booktitle> <address> Uppsala, Sweden, </address> <pages> pages 127-138. </pages> <institution> Uppsala University, </institution> <year> 1984. </year>
Reference-contexts: To see this, take, for instance, P 1 = fp (a) ; p (b) g and P 2 = fp (a) g. This difficulty may explain why in early papers on logic program transformation, such as those by Hogger [12] and Tamaki and Sato <ref> [20] </ref>, the problem of verifying total correctness is not based on termination properties. <p> In particular, in [12] total correctness is proved by first considering transformation rules which preserve partial correctness and then proving the inclusion of the least Herbrand model of P 1 in the least Herbrand model of P 2 . In order to ensure total correctness, Tamaki and Sato <ref> [20] </ref> adapt Burstall and Darlington's unfolding and folding transformation rules to logic programming by imposing some restrictions on the use of the rules, in particular, on the use of the folding rule. <p> In Section 6 we show that the iff-replacement rule is a generalization of the unfolding, folding, and goal replacement rules introduced in <ref> [20] </ref>, thus, the correctness results proved for the iff-replacement rule can be applied to the unfolding, folding, and goal replacement rules. <p> Our three rules are called definition introduction, definition elimination, and clause replacement. The rules introduced in <ref> [20] </ref> can all be viewed as instances of our rules. Also the iff-replacement and finite failure rules considered below, are instances of the clause replacement rule. <p> in Example 2 cannot be performed by using the iff-replacement rule with Condition (8), because Comp (P 0 ) 6` (p $ p) ! (p $ r). 6 Correctness Properties of the Unfold/Fold Rules In this section we show that many transformation rules presented in the literature (see, for instance, <ref> [10, 11, 15, 20] </ref>), including various forms of unfolding, folding, and goal replacement, can be viewed as instances of our iff-replacement rule. As a consequence, we can apply our correctness results to these rules, as we now show. <p> However, in [11] some conditions on the transformation sequence are imposed for ensuring total correctness. We have achieved a similar total correctness result by requiring, instead of those conditions, the preservation of existential termination (see Section 4). Tamaki and Sato's folding rule <ref> [20] </ref> is much simpler than our folding rule and it basically corresponds to our rule for n = 1. They also impose some extra conditions on the transformation sequence for ensuring total correctness. <p> ; : : : ; X k : (9Y 1 ; : : : ; Y m : G 1 $ 9Z 1 ; : : : ; Z n : G 2 ): (11) Our formulation of the goal replacement rule with Condition (9) is similar to that in <ref> [20] </ref> (which, incidentally, was incorrectly stated as pointed out in [10] and later corrected in [21]). If we replace Condition (9) by Condition (11), then we essentially get the version of the goal replacement rule presented in [15]. <p> However, the SLD-tree for P 1 [ f:t (a; a)g is infinite, independently of the choice of the selection rule. 7 Related Work Many authors have investigated the correctness of logic program transformation rules following the approach proposed by Tamaki and Sato <ref> [20] </ref>, which consists in imposing restrictions on the use of the rules so as to ensure total correctness. One problem with this approach is that these restrictions are either very constraining or they require the verification of complex, sometimes undecidable, properties [18]. <p> We would like to make a general remark on the role of the termination analysis for program transformation. Indeed, since termination is an undecidable property, one may wonder about the usefulness of our approach wrt the one proposed in <ref> [20] </ref>. As noted in [8], a lot of work has recently been done in the area of automatic termination analysis, and one may take advantage of the proposed techniques for the verification of the total correctness of program transformations.
Reference: [21] <author> H. Tamaki and T. Sato. </author> <title> A generalized correctness proof of the unfold/fold logic program transformation. </title> <type> Technical Report 86-4, </type> <institution> Ibaraki University, </institution> <address> Japan, </address> <year> 1986. </year>
Reference-contexts: Y m : G 1 $ 9Z 1 ; : : : ; Z n : G 2 ): (11) Our formulation of the goal replacement rule with Condition (9) is similar to that in [20] (which, incidentally, was incorrectly stated as pointed out in [10] and later corrected in <ref> [21] </ref>). If we replace Condition (9) by Condition (11), then we essentially get the version of the goal replacement rule presented in [15]. Lemma 7 Suppose that by goal replacement from clause C 1 we derive clause D 1 .
References-found: 21

