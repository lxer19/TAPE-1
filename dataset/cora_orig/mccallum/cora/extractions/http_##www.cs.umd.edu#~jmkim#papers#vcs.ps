URL: http://www.cs.umd.edu/~jmkim/papers/vcs.ps
Refering-URL: http://www.cs.umd.edu/users/jmkim/research.html
Root-URL: 
Email: tball@research.bell-labs.com aporter@cs.umd.edu hpsiy@research.bell-labs.com  
Title: If Your Version Control System Could Talk  
Author: Thomas Ball Jung-Min Kim Adam A. Porter Harvey P. Siy 
Affiliation: Bell Laboratories Dept. of Computer Sciences Bell Laboratories Lucent Technologies University of Maryland Lucent Technologies  
Abstract: Version control systems (VCSs) are used to store and reconstruct past versions of program source code. As a by-product they also capture a great deal of contextual information about each change. We will illustrate some ways to use this information to better understand a program's development history. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Ball and S. G. Eick. </author> <title> Software visualization in the large. </title> <journal> IEEE Computer, </journal> <volume> 29(4) </volume> <pages> 33-43, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: For example, all the member functions for type checking can be found in a particular set of files, while member functions for code generation can be found in another file set. The left panel in Figure 3 makes this clear, using the SeeSoft code visualization <ref> [1] </ref>. Each rectangle represents a file from the compiler. Only files containing code from the AST classes are shown. Each class is given a level of gray from the gray scale spectrum on the left, and each line of a file is colored to show which class it belongs to.
Reference: [2] <author> William S. Cleveland. </author> <title> Visualizing Data. </title> <publisher> Hobart Press, </publisher> <year> 1993. </year>
Reference-contexts: The visualizations we show in this paper are obviously static. Since we are inherently interested in system behavior over time we expect that visualizations must improve to capture this. Some possibilities include Trellis displays <ref> [2] </ref> and animation. * Static program analysis. The change history provides information about how different parts of a system are related. This information may be use ful for automatic restructuring.
Reference: [3] <author> Stephen G. Eick and Graham J. Wills. </author> <title> Navigating large networks with hierarchies. </title> <booktitle> In Visualization '93 Conference Proceedings, </booktitle> <pages> pages 204-210, </pages> <address> San Jose, California, </address> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: We generated this data for the current version of the P5CC compiler and ran it through a graph clustering algorithm which places nodes connected by links of higher weight closer together. We used the probability measure described above for the link weighting. For details on this algorithm, see <ref> [3] </ref>. resents a class. The shape of a node denotes the group that the class belongs to, as in Figure 2. Note that the clustering algorithm has identified clusters of semantically related classes.
Reference: [4] <author> Maurice H. Halstead. </author> <title> Elements of Software Science. </title> <publisher> Elsevier - North Holland, </publisher> <year> 1979. </year>
Reference-contexts: 1 Introduction There are many software-based metrics that one may use to assess the state of a software system. For example, the McCabe [7] and Halstead <ref> [4] </ref> software complexity metrics measure aspects of the structure of a static snapshot of source code to estimate its complexity.
Reference: [5] <author> David A. Ladd and J. Christopher Ramming. </author> <title> Software research and switch software. </title> <booktitle> In International Conference on Communications Technology, </booktitle> <address> Beijing, China, </address> <year> 1992. </year>
Reference-contexts: Some of these are logical constraints; for example, "call waiting and call forwarding/busy should never be active on the same line." Other constraints exist to document data design choices (redundancy, functional dependencies, distribution rules) that support efficient 5ESS operation and call processing. PRL5 <ref> [5] </ref> is a declarative SQL-like language, created to specify these data integrity constraints. PRL5 spec ifications are translated automatically into data audits and transaction guards in C, which is then compiled on multiple platforms.
Reference: [6] <author> David A. Ladd and J. Christopher Ramming. </author> <title> Two application languages in software production. </title> <booktitle> In USENIX Symposium on Very-High-Level Languages, </booktitle> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: More details may be found in Ladd and Ramming <ref> [6] </ref>. The 5ESS is Lucent Technologies' flagship local/toll switching system, containing an estimated 10 million lines of code in product and support tools. At the heart of the 5ESS software is a distributed relational database with information about hardware connections, software configuration, and customers.
Reference: [7] <author> Thomas J. McCabe. </author> <title> A complexity measure. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 2(4) </volume> <pages> 308-320, </pages> <month> Dec. </month> <year> 1976. </year>
Reference-contexts: 1 Introduction There are many software-based metrics that one may use to assess the state of a software system. For example, the McCabe <ref> [7] </ref> and Halstead [4] software complexity metrics measure aspects of the structure of a static snapshot of source code to estimate its complexity.
Reference: [8] <author> Martin Odersky and Philip Wadler. </author> <title> Pizza into Java: Translating theory into practice. </title> <booktitle> In Conference Record of 1997 ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 146-159, </pages> <address> Paris, France, </address> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: It is clear that certain programmers had ownership of particular aspects of the compiler and AST classes, although most files have accumulated modifications by several programmers. This partitioning illustrates the complex relationships among the views we are examining. For example, compiler literature <ref> [8] </ref> suggests that when prototyping a new programming language, it is useful to implement compiler phases as member functions of each AST class. To add new language constructs, one simply adds new classes to the set of AST classes.
Reference: [9] <author> Marc J. Rochkind. </author> <title> The Source Code Control System. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> SE-1(4):364-370, </volume> <month> December </month> <year> 1975. </year>
Reference-contexts: A version control system (VCS) tracks each change a developer makes to the system and, as a result, can recreate a consistent snapshot at any point in time. Examples of VCSs include RCS [10] and SCCS <ref> [9] </ref>. While this basic functionality of VCSs is essential for version control and measuring the evolution of metrics over time, there is much data in a VCS that is ignored when simply using it to extract snapshots of source code.
Reference: [10] <author> Walter Tichy. </author> <title> Design, implementation and evaluation of a revision control system. </title> <booktitle> In Proceedings of the 6th International Conference on Software Engineering, </booktitle> <pages> pages 58-67, </pages> <address> Tokyo, Japan, </address> <month> Sept. </month> <year> 1982. </year>
Reference-contexts: A version control system (VCS) tracks each change a developer makes to the system and, as a result, can recreate a consistent snapshot at any point in time. Examples of VCSs include RCS <ref> [10] </ref> and SCCS [9]. While this basic functionality of VCSs is essential for version control and measuring the evolution of metrics over time, there is much data in a VCS that is ignored when simply using it to extract snapshots of source code.
References-found: 10

