URL: http://www.cs.utexas.edu/users/boyer/mjrty.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/moore/best-ideas/mjrty/index.html
Root-URL: 
Title: Chapter 5 MJRTY|A Fast Majority Vote Algorithm 1  
Author: Robert S. Boyer and J Strother Moore 
Address: 1717 West Sixth Street, Suite 290 Austin, Texas  
Affiliation: Computer Sciences Department University of Texas at Austin and Computational Logic, Inc.  
Abstract: A new algorithm is presented for determining which, if any, of an arbitrary number of candidates has received a majority of the votes cast in an election. The number of comparisons required is at most twice the number of votes. Furthermore, the algorithm uses storage in a way that permits an efficient use of magnetic tape. A Fortran version of the algorithm is exhibited. The Fortran code has been proved correct by a mechanical verification system for Fortran. The system and the proof are discussed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> American National Standards Institute, Inc. </institution> <year> (1978): </year> <title> American National Standard Programming Language Fortran, ANSI X3.9-1978, </title> <address> 1430 Broadway, New York, N. Y. </address>
Reference-contexts: That system has been used to verify MJRTY and other subprograms. Before presenting the formal specifications that were verified, we briefly sketch our verification system. The system handles a subset of both ANSI Fortran 66 [10] and ANSI Fortran 77 <ref> [1] </ref>. The subset is described precisely in [4]. Informally stated, the MJRTY|A Fast Majority Vote Algorithm 111 subset includes all the statements of Fortran 66 except the i/o, DATA, BLOCK DATA, and EQUIVALENCE statements. Certain restrictions, however, are placed on some of the remaining statements.
Reference: [2] <author> R. B. </author> <title> Anderson (1979): Proving Programs Correct. </title> <address> New York: </address> <publisher> John Wiley and Sons. </publisher>
Reference-contexts: This statement is made more precise in [4]. Our Fortran verifier is a standard Floyd-King-style system <ref> [5, 6, 2, 8] </ref> consisting of two parts: a Fortran analyzer (syntax checker and verification condition generator) and a mechanical theorem-prover. For those readers unfamiliar with Floyd-King-style verification, we briefly describe our system below.
Reference: [3] <author> R. S. Boyer and J S. </author> <title> Moore (1979): A Computational Logic. </title> <address> New York: </address> <publisher> Academic Press. </publisher>
Reference-contexts: In addition to the input/output assertions, each loop in the subprogram must be cut by an inductive assertion|a mathematical formula describing the machine state each time execution arrives at the indicated point in the program. All the formulas are written in the formal logical language described in <ref> [3] </ref>. The analyzer checks that the program satisfies all our syntactic require 112 Robert S. <p> The theorem-prover, which is described in <ref> [3] </ref>, is entirely responsible for the correctness of each proof. 5.6 Formal Specification Below we denote the initial values of the Fortran variables A and N by A and n respectively.
Reference: [4] <author> R. S. Boyer and J S. </author> <title> Moore (1981): A Verification Condition Generator for Fortran. </title> <editor> In R. S. Boyer and J S. Moore, eds.: </editor> <booktitle> The Correctness Problem in Computer Science. </booktitle> <address> London: </address> <publisher> Academic Press. </publisher>
Reference-contexts: That system has been used to verify MJRTY and other subprograms. Before presenting the formal specifications that were verified, we briefly sketch our verification system. The system handles a subset of both ANSI Fortran 66 [10] and ANSI Fortran 77 [1]. The subset is described precisely in <ref> [4] </ref>. Informally stated, the MJRTY|A Fast Majority Vote Algorithm 111 subset includes all the statements of Fortran 66 except the i/o, DATA, BLOCK DATA, and EQUIVALENCE statements. Certain restrictions, however, are placed on some of the remaining statements. <p> This statement is made more precise in <ref> [4] </ref>. Our Fortran verifier is a standard Floyd-King-style system [5, 6, 2, 8] consisting of two parts: a Fortran analyzer (syntax checker and verification condition generator) and a mechanical theorem-prover. For those readers unfamiliar with Floyd-King-style verification, we briefly describe our system below. <p> In addition, formulas are generated to establish that no array bound errors, overflows, or other run time errors occur, and that the program terminates. (See <ref> [4] </ref>.) To permit consideration of arithmetic overflow, our verification system permits formal talk about the "least inexpressible positive integer" and the "greatest inexpressible negative integer" on the host Fortran processor. Typical input assertions for programs must specify the relations between the input variables and these otherwise unspecified constants. <p> The mechanical theorem-prover proved all 61 conjectures. Most of the proofs were immediate either from the axioms and definitions in the "basic Fortran theory" <ref> [4] </ref> (e.g., the definition of the negative integers in terms of the Peano numbers), from the definition of cnt (e.g., if x is A (i+ 1) and i 0 then cnt (x; A; 1; i + 1) is 1 + cnt (x; A; 1; i)), or from elementary arithmetic lemmas (e.g.,
Reference: [5] <author> R. W. </author> <title> Floyd (1967): Assigning Meanings to Programs. In: </title> <journal> Mathematical Aspects of Computer Science, Proc. Symp. Appl. Math., </journal> <volume> 19. </volume> <publisher> Providence, RI: American Mathematical Society. </publisher>
Reference-contexts: This statement is made more precise in [4]. Our Fortran verifier is a standard Floyd-King-style system <ref> [5, 6, 2, 8] </ref> consisting of two parts: a Fortran analyzer (syntax checker and verification condition generator) and a mechanical theorem-prover. For those readers unfamiliar with Floyd-King-style verification, we briefly describe our system below.
Reference: [6] <author> J. C. </author> <title> King (1969): A Program Verifier. </title> <type> Ph. D. thesis, </type> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <address> Pittsburgh, PA. </address>
Reference-contexts: This statement is made more precise in [4]. Our Fortran verifier is a standard Floyd-King-style system <ref> [5, 6, 2, 8] </ref> consisting of two parts: a Fortran analyzer (syntax checker and verification condition generator) and a mechanical theorem-prover. For those readers unfamiliar with Floyd-King-style verification, we briefly describe our system below.
Reference: [7] <author> D. E. </author> <title> Knuth (1973): The Art of Computer Programming, Volume 3: Sorting and Searching. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley. </publisher>
Reference-contexts: If the votes can be simply ordered, an algorithm with order n execution time can be coded first to find the median using the Rivest-Tarjan algorithm <ref> [7] </ref> and then to check whether the median received more than half the votes. The Rivest-Tarjan algorithm is bounded above by 5:43n 163 comparisons, when n &gt; 32. In this paper we describe an algorithm that requires at most 2n comparisons.
Reference: [8] <author> Z. </author> <title> Manna (1974): </title> <booktitle> Mathematical Theory of Computation. </booktitle> <address> New York: </address> <publisher> McGraw-Hill. </publisher>
Reference-contexts: This statement is made more precise in [4]. Our Fortran verifier is a standard Floyd-King-style system <ref> [5, 6, 2, 8] </ref> consisting of two parts: a Fortran analyzer (syntax checker and verification condition generator) and a mechanical theorem-prover. For those readers unfamiliar with Floyd-King-style verification, we briefly describe our system below.
Reference: [9] <author> J. Misra and D. </author> <title> Gries (1982): Finding Repeated Elements. </title> <booktitle> Science of Computer Programming 2, </booktitle> <pages> 143-152. </pages>
Reference-contexts: According to Misra (private communication, 1990): "I wondered how to generalize [the algorithm] to detect elements that occur more than n=k times, for all k, k 2. I developed algorithm 2 [given in Section 3 of <ref> [9] </ref>] which is directly inspired by your algorithm. Also, I showed that this algorithm is optimal [Section 5, op. cit.]. <p> Also, I showed that this algorithm is optimal [Section 5, op. cit.]. On a visit to Cornell, I showed all this to David Gries; he was inspired enough to contribute algorithm 1 [Section 2, op. cit.]." In 1982, Misra and Gries published their work <ref> [9] </ref>, citing our technical report appropriately as "submitted for publication." However, our paper was repeatedly rejected for publication, largely because of its emphasis on Fortran and mechanical verification.
Reference: [10] <institution> United States of America Standards Institute (1966): USA Standard Fortran, </institution> <address> USAS X3.9-1966, 10 East 40th Street, New York, N. Y. </address>
Reference-contexts: That system has been used to verify MJRTY and other subprograms. Before presenting the formal specifications that were verified, we briefly sketch our verification system. The system handles a subset of both ANSI Fortran 66 <ref> [10] </ref> and ANSI Fortran 77 [1]. The subset is described precisely in [4]. Informally stated, the MJRTY|A Fast Majority Vote Algorithm 111 subset includes all the statements of Fortran 66 except the i/o, DATA, BLOCK DATA, and EQUIVALENCE statements. Certain restrictions, however, are placed on some of the remaining statements.
Reference: [11] <author> J. Wensley, et al. </author> <year> (1978): </year> <title> SIFT: Design and Analysis of a Fault Tolerant Computer for Aircraft Control. </title> <booktitle> Proc. IEEE 66(10), </booktitle> <pages> 1240-1255. </pages>
Reference-contexts: RETURN END 110 Robert S. Boyer and J Strother Moore In some applications it may be assumed that a majority candidate exists. For example, in the SIFT aircraft control system <ref> [11] </ref>, where reliability is achieved with redundant processors and software voting, the failure rate of the individual processors is sufficiently low to permit the assumption that on a given flight a majority of the working processors agree on each vote.
References-found: 11

