URL: ftp://ftp.cs.columbia.edu/reports/reports-1988/cucs-352-88.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1988.html
Root-URL: http://www.cs.columbia.edu
Title: Incremental Dynamic Semantics for Language-based Programming Environments  
Author: Gail E. Kaiser 
Date: 10027.  
Address: CECOM COMM/ADP, Fort Monmouth, NJ and  New York, NY  
Note: This research was supported by a Fannie and John Hertz Foundation Fellowship, by the United States Army, Software  by ZTI-SOF of Siemens Corporation, Munich, Germany. Author's current address:  
Affiliation: Carnegie Mellon University  Technology Development Division of  Columbia University, Department of Computer Science,  
Abstract: Attribute grammars are a formal notation for expressing the static semantics of programming languages those properties that can be derived from inspection of the program text. Attribute grammars have become popular as a mechanism for generating language-based programming environments that incrementally perform symbol resolution, type checking, code generation and derivation of other static semantic properties as the program is modified. However, attribute grammars are not suitable for expressing dynamic semantics those properties that reflect the history of program execution and/or user interactions with the programming environment. This article presents action equations, an extension of attribute grammars suitable for specifying the static and the dynamic semantics of programming languages. It describes how action equations can be used to generate language-based programming environments that incrementally derive static and dynamic properties as the user modifies and debugs the program. Categories and Subject Descriptors: D.2.3 [Software Engineering]: Coding program editors; D.2.5 [Software Engineering]: Testing and Debugging debugging aids; D.2.6 [Software Engineering]: Programming Environments; D.3.1 [Programming Languages]: Formal Definitions and Theory semantics; D.3.4 [Programming Languages]: Processors interpreters, translator writing systems and compiler generators; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs specification techniques; F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages operational semantics General Terms: Algorithms, Design, Experimentation, Languages Additional Key Words and Phrases: Attribute grammars, dynamic semantics, generation of language-based environments, interpreters 
Abstract-found: 1
Intro-found: 1
Reference: <institution> u </institution>
Reference: 1. <author> Ambriola, Vincenzo, Kaiser, Gail E. and Ellison, Robert J. </author> <title> An action routine model for ALOE. </title> <type> Tech. </type> <institution> Rept. CMU-CS-84-156, Carnegie Mellon University, Department of Computer Science, </institution> <month> August, </month> <year> 1984. </year>
Reference-contexts: Action routines are based on the semantic routines used in compiler generation systems such as Yacc [31]. The semantics processing is written as a set of routines in either a conventional programming language or in a special purpose programming language designed for writing action routines <ref> [1] </ref>. A set of routines is associated with each production in the abstract syntax, one for each user command (such as Create, Delete, Enter, Exit, Execute, etc.) that can be applied to an instance of that production. <p> Expressions involving (potentially recursive) function calls and (multiple assignment) variables require a run-time stack, as discussed later in this section. 17 compound ::= body: sequence of STATEMENT Execute --&gt; Propagate Execute To body <ref> [1] </ref> Continue On body [any] --&gt; Propagate Execute To body [next] Continue On body [last] --&gt; Propagate Continue To self /* The event declarations are omitted, as they are in further examples. <p> But "Propagate Execute To body [next]" has no effect since body [next] evaluates to nil. compound ::= body: sequence of STATEMENT Execute --&gt; If body = nil Then Propagate Continue To self Else Propagate Execute To body <ref> [1] </ref> Continue On body [any] --&gt; Propagate Execute To body [next] Continue On body [last] --&gt; Propagate Continue To self This discussion of the compound statement, and the previous example involving the conditional statement and = operator, have been simplified in that they do not consider the possibility that the body <p> represent each data item as a node; this is much less efficient at execution time but much more expedient at environment description time. program - stack: sequence of frame - call ::= name: identifier actuals: sequence of EXPRESSION Execute --&gt; program.stack := Insert (@name.defsite).AR # program.stack Propagate Execute To actuals <ref> [1] </ref> Continue On actuals [any] --&gt; &lt;storage for parameter in top stack frame&gt; := actuals [any].value Propagate Execute To actuals [next] Continue On actuals [last] --&gt; &lt;storage for program counter in top stack frame&gt; := self Propagate Execute To @name.defsite /* Stack is an attribute of program. <p> Potential circular dependencies among constraints are handled as in attribute grammars, by separating into in and out attributes where the synthesized out attribute is the appropriate function of the inherited in attribute. return ::= Execute --&gt; program.stack := Delete program.stack <ref> [1] </ref> Propagate Continue To &lt;program counter in top stack frame&gt; /* The return production has no components. For a function rather than a procedure, the corresponding return would have an EXPRESSION component.
Reference: 2. <author> Archer, James E. Jr. and Devlin, Michael T. </author> <title> Rational's experience using Ada for very large systems. </title> <booktitle> First International Conference on Ada Programming Language Applications for the NASA Space Station, </booktitle> <month> June, </month> <year> 1986, </year> <pages> pp. </pages> <month> B.2.5.1-B.2.5.11. </month>
Reference-contexts: Some of the best known LBEs are Mentor [11], Interlisp [60], the Program Synthesizer [59], Gandalf [24], Pecan [50], and Rational <ref> [2] </ref>. Each of these environments consists of an integrated collection of tools that (1) can be viewed as a single tool [7] and (2) may be applied incrementally as the programmer writes and tests his programs. In some cases, the tools are automatically applied without explicit intervention by the programmer.
Reference: 3. <author> Bahlke, Rolf and Snelting, Gregor. </author> <title> "The PSG system: from formal language definitions to interactive programming environments". </title> <journal> ACM Transactions on Programming Languages and Systems 8, </journal> <month> 4 (October </month> <year> 1986), </year> <pages> 547-576. </pages>
Reference-contexts: However, Johnson has recently developed an incremental interpreter/debugger for GL [34], an expressional language based on denotational semantics. Other methods have been proposed (e.g., <ref> [3, 10, 13, 51] </ref>), but none fulfill all the requirements of an LBE. The basic problems are: The design, implementation and debugging of action routines, or any other procedural mechanism, is tedious and error-prone compared to the ease with which a syntax description can be developed.
Reference: 4. <author> Balzer, Robert. </author> <title> "A 15 year perspective on automatic programming". </title> <journal> IEEE Transactions on Software Engineering SE-11, </journal> <month> 11 (November </month> <year> 1985), </year> <pages> 1257-1268. </pages>
Reference-contexts: This argument assumes the programmer does not expect the programming environment to change his program, but exactly the opposite is true in transformational programming environments, formal <ref> [4, 19, 47, 57] </ref> or informal [62]. There is no reason the programmer should expect less from an LBE; in particular, manipulation of the program text by action equations is one mechanism for implementing transformations.
Reference: 5. <author> Barbuti, R., Bellia, M., Degano, P., Levi, G., Dameri, E., Simonelli, C. and Martelli, A. </author> <title> Programming environment generation based on denotational semantics. </title> <booktitle> In Theory and Practice of Software Technology, </booktitle> <publisher> North-Holland Pub. Co., </publisher> <address> New York, </address> <year> 1983. </year> <month> 29 </month>
Reference-contexts: Several research groups have applied denotational specifications to generation of compilers [6, 48, 49] and interpreters <ref> [5] </ref>, but none of these systems are effective in an incremental programming environment. However, Johnson has recently developed an incremental interpreter/debugger for GL [34], an expressional language based on denotational semantics. Other methods have been proposed (e.g., [3, 10, 13, 51]), but none fulfill all the requirements of an LBE.
Reference: 6. <author> Bodwin, James, Bradley, Laurette, Kanda, Kohji, Litle, Diane and Pleban, Uwe. </author> <title> Experience with an experimental compiler generator based on denotational semantics. </title> <booktitle> SIGPlan '82 Symposium on Compiler Construction, </booktitle> <month> June, </month> <year> 1982, </year> <pages> pp. 216-229. </pages>
Reference-contexts: Several research groups have applied denotational specifications to generation of compilers <ref> [6, 48, 49] </ref> and interpreters [5], but none of these systems are effective in an incremental programming environment. However, Johnson has recently developed an incremental interpreter/debugger for GL [34], an expressional language based on denotational semantics.
Reference: 7. <author> Delisle, Norman M., Menicosy, David E. and Schwartz, Mayer D. </author> <title> Viewing a programming environment as a single tool. </title> <booktitle> SIGSoft/SIGPlan Software Engineering Symposium on Practical Software Development Environments, </booktitle> <month> April, </month> <year> 1984, </year> <pages> pp. 49-56. </pages>
Reference-contexts: Some of the best known LBEs are Mentor [11], Interlisp [60], the Program Synthesizer [59], Gandalf [24], Pecan [50], and Rational [2]. Each of these environments consists of an integrated collection of tools that (1) can be viewed as a single tool <ref> [7] </ref> and (2) may be applied incrementally as the programmer writes and tests his programs. In some cases, the tools are automatically applied without explicit intervention by the programmer.
Reference: 8. <author> Demers, Alan, Reps, Thomas and Teitelbaum, Tim. </author> <title> Incremental evaluation for attribute grammars with applications to syntax-directed editors. </title> <booktitle> 8th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January, </month> <year> 1981, </year> <pages> pp. 105-116. </pages>
Reference-contexts: The second major group uses attribute grammars, which were introduced by Knuth [43] for specifying the context-sensitive properties of programming languages. Attribute grammars are an alternative to semantic routines in compiler-compilers [14, 20]. The generation of LBEs from attribute grammars [32, 53] was proposed by Demers, Reps and Teitelbaum <ref> [8] </ref>.
Reference: 9. <author> Demers, Alan, Rogers, Anne and Zadeck, Frank Kenneth. </author> <title> Attribute propagation by message passing. </title> <booktitle> SIGPlan '85 Symposium on Language Issues in Programming Environments, </booktitle> <month> June, </month> <year> 1985, </year> <pages> pp. 48-59. </pages>
Reference-contexts: This is done through identifier definition-use links. Several extensions to attribute grammars have been proposed <ref> [9, 27, 28] </ref> that improve the efficiency of incremental attribute evaluation by linking the definitions and uses for each identifier. A change in an attribute value at a definition site is propagated along the links to dependent attributes at its use sites.
Reference: 10. <author> Despeyroux, Thierry. </author> <title> Executable specification of static semantics. </title> <booktitle> Semantics of Data Types International Symposium, </booktitle> <address> New York, </address> <month> June, </month> <year> 1984, </year> <pages> pp. 215-233. </pages>
Reference-contexts: However, Johnson has recently developed an incremental interpreter/debugger for GL [34], an expressional language based on denotational semantics. Other methods have been proposed (e.g., <ref> [3, 10, 13, 51] </ref>), but none fulfill all the requirements of an LBE. The basic problems are: The design, implementation and debugging of action routines, or any other procedural mechanism, is tedious and error-prone compared to the ease with which a syntax description can be developed.
Reference: 11. <author> Donzeau-Gouge, Veronique, Huet, Gerard, Kahn, Gilles, and Lang, Bernard. </author> <title> Programming environments based on structured editors: the Mentor experience. </title> <editor> In Barstow, David R., Shrobe, Howard E. and Sandewall, Erik, Ed., </editor> <title> Interactive Programming Environments, </title> <publisher> McGraw-Hill Book Co., </publisher> <address> New York, </address> <year> 1984, </year> <pages> pp. 128-140. </pages>
Reference-contexts: The user interface consists of some mixture of template editing and text editing (supported by incremental parsing [23, 35, 63]); the program is represented as a parse tree or abstract syntax tree, where each node may be decorated with attributes. Some of the best known LBEs are Mentor <ref> [11] </ref>, Interlisp [60], the Program Synthesizer [59], Gandalf [24], Pecan [50], and Rational [2]. Each of these environments consists of an integrated collection of tools that (1) can be viewed as a single tool [7] and (2) may be applied incrementally as the programmer writes and tests his programs.
Reference: 12. <author> Donzeau-Gouge, Veronique, Kahn, Gilles, Lang, Bernard and Melese, B. </author> <title> Documents structure and modularity in Mentor. </title> <booktitle> SIGSoft/SIGPlan Software Engineering Symposium on Practical Software Development Environments, </booktitle> <month> April, </month> <year> 1984, </year> <pages> pp. 141-148. </pages>
Reference-contexts: For example, type checking and symbol resolution may be performed automatically as the program is created and modified; code generation and some code optimization may also be done incrementally. The early LBEs were hand-coded. Then several environment generators were developed, including ALOE [45], Metal <ref> [12] </ref> and the Synthesizer Generator [53]. An environment generator is a program that combines an environment description with the editor kernel to produce the desired LBE.
Reference: 13. <author> Engels, G., Gall, R., Nagl, M. and Schafer, W. </author> <title> "Software specification using graph grammars". </title> <booktitle> Computing 31 (1983), </booktitle> <pages> 317-346. </pages>
Reference-contexts: However, Johnson has recently developed an incremental interpreter/debugger for GL [34], an expressional language based on denotational semantics. Other methods have been proposed (e.g., <ref> [3, 10, 13, 51] </ref>), but none fulfill all the requirements of an LBE. The basic problems are: The design, implementation and debugging of action routines, or any other procedural mechanism, is tedious and error-prone compared to the ease with which a syntax description can be developed.
Reference: 14. <author> Farrow, Rodney. </author> <title> "Generating a production compiler from an attribute grammar". </title> <booktitle> IEEE Software 1, </booktitle> <month> 4 (October </month> <year> 1984). </year>
Reference-contexts: The second major group uses attribute grammars, which were introduced by Knuth [43] for specifying the context-sensitive properties of programming languages. Attribute grammars are an alternative to semantic routines in compiler-compilers <ref> [14, 20] </ref>. The generation of LBEs from attribute grammars [32, 53] was proposed by Demers, Reps and Teitelbaum [8].
Reference: 15. <author> Farrow, Rodney. </author> <title> Automatic generation of fixed-point-finding evaluators for circular, but well-defined, attribute grammars. </title> <booktitle> SIGPlan '86 Symposium on Compiler Construction, </booktitle> <month> June, </month> <year> 1986, </year> <pages> pp. 85-98. </pages>
Reference-contexts: Although circular attribute grammars are problematical for non-incremental evaluation <ref> [15] </ref> and rarely handled by incremental evaluators (work by Walz and Johnson is a notable exception [61]), circularities among propagate equations pose no difficulties.
Reference: 16. <author> Feiler, Peter H. and Medina-Mora, Raul. </author> <title> "An incremental programming environment". </title> <journal> IEEE Transactions on Software Engineering SE-7, </journal> <month> 5 (September </month> <year> 1981), </year> <pages> 472-482. </pages>
Reference-contexts: Figure 5-4 shows hows a breakpoint might be described. This example follows the precedent set by Feiler in his thesis [17] (and elsewhere <ref> [16] </ref>) as to how the user specifies a breakpoint before or after a particular statement. It assumes that the programming language has been extended by a special break statement. The user designates a breakpoint by inserting a break statement at the desired position in the program text.
Reference: 17. <author> Feiler, Peter H. </author> <title> LOIPE a language-oriented interactive programming environment based on compilation technology. </title> <type> Ph.D. </type> <institution> Th., Carnegie Mellon University, </institution> <month> May </month> <year> 1982. </year> <month> CMU-CS-82-117.. </month>
Reference-contexts: Program Suspension and Continuation break ::= Execute --&gt; Delay Until Continue At self The delay equation is also instrumental in specifying debugging facilities such as breakpoints and singlestepping. Figure 5-4 shows hows a breakpoint might be described. This example follows the precedent set by Feiler in his thesis <ref> [17] </ref> (and elsewhere [16]) as to how the user specifies a breakpoint before or after a particular statement. It assumes that the programming language has been extended by a special break statement. The user designates a breakpoint by inserting a break statement at the desired position in the program text.
Reference: 18. <author> Feiler, Peter H., Jalili, Fahimeh and Schlichter, Johann H. </author> <title> An interactive prototyping environment for language design. </title> <booktitle> 19th Hawaii International Conference on System Sciences, </booktitle> <month> January, </month> <year> 1986, </year> <pages> pp. 106-116. </pages>
Reference-contexts: These three methods are briefly described here and are explained in detail in the references. The first school uses action routines, which were proposed by Medina-Mora in his thesis [45] for use in LBEs <ref> [18, 24] </ref>. Action routines are based on the semantic routines used in compiler generation systems such as Yacc [31]. The semantics processing is written as a set of routines in either a conventional programming language or in a special purpose programming language designed for writing action routines [1].
Reference: 19. <author> Freeman, Peter. </author> <title> "A conceptual analysis of the Draco approach to constructing software systems". </title> <journal> IEEE Transactions on Software Engineering SE-13, </journal> <month> 7 (July </month> <year> 1987), </year> <pages> 830-844. </pages>
Reference-contexts: This argument assumes the programmer does not expect the programming environment to change his program, but exactly the opposite is true in transformational programming environments, formal <ref> [4, 19, 47, 57] </ref> or informal [62]. There is no reason the programmer should expect less from an LBE; in particular, manipulation of the program text by action equations is one mechanism for implementing transformations.
Reference: 20. <author> Ganzinger, Harald, Ripken, Knut and Wilhelm, Reinhard. </author> <title> Automatic generation of optimizing multipass compilers. </title> <booktitle> Information Processing 77, </booktitle> <address> New York, </address> <year> 1977, </year> <pages> pp. 535-540. 30 </pages>
Reference-contexts: The second major group uses attribute grammars, which were introduced by Knuth [43] for specifying the context-sensitive properties of programming languages. Attribute grammars are an alternative to semantic routines in compiler-compilers <ref> [14, 20] </ref>. The generation of LBEs from attribute grammars [32, 53] was proposed by Demers, Reps and Teitelbaum [8].
Reference: 21. <author> Garlan, David. </author> <title> Flexible unparsing in a structure editing environment. </title> <type> Tech. </type> <institution> Rept. CMU-CS-85-129, Carnegie Mellon University, Department of Computer Science, </institution> <month> April, </month> <year> 1985. </year>
Reference-contexts: The output stream is automatically redisplayed on the screen after every update. Various kinds of unparse schemes have been proposed for defining the concrete syntax necessary for displaying the program [24, 29, 53] or distinct views of the program <ref> [21, 50] </ref>. The action equations paradigm assumes the availability of one of these mechanisms for display purposes. The read statement is slightly more difficult and requires a delay equation.
Reference: 22. <author> Garlan, David. </author> <title> Views for tools in integrated environments. </title> <type> Ph.D. </type> <institution> Th., Carnegie Mellon University, </institution> <month> May </month> <year> 1987. </year> <month> CMU-CS-87-147.. </month>
Reference-contexts: I have more recently collaborated with David to develop Meld [37], an experimental language combining 28 object-oriented and dataflow programming paradigms; Meld's syntax and semantics are loosely based on action equations and on the views David proposed in his thesis <ref> [22] </ref>. Simon Kaplan pointed out an error in one of the examples given in my dissertation, which is corrected here; Simon has also worked with me on parallel and distributed incremental evaluation algorithms for attribute grammars [38].
Reference: 23. <author> Ghezzi, Carlo and Mandrioli, Dino. </author> <title> "Augmenting parsers to support incrementality". </title> <journal> Journal of the ACM 27, </journal> <month> 3 (July </month> <year> 1980), </year> <pages> 564-579. </pages>
Reference-contexts: The key components of an LBE are a standard user interface and a common program representation. Many programming environments have been built using structure editing technology, which supports both of these features. The user interface consists of some mixture of template editing and text editing (supported by incremental parsing <ref> [23, 35, 63] </ref>); the program is represented as a parse tree or abstract syntax tree, where each node may be decorated with attributes. Some of the best known LBEs are Mentor [11], Interlisp [60], the Program Synthesizer [59], Gandalf [24], Pecan [50], and Rational [2].
Reference: 24. <author> Habermann, A. N. and Notkin, D. </author> <title> "Gandalf: software development environments". </title> <journal> IEEE Transactions on Software Engineering SE-12, </journal> <month> 12 (December </month> <year> 1986), </year> <pages> 1117-1127. </pages>
Reference-contexts: Some of the best known LBEs are Mentor [11], Interlisp [60], the Program Synthesizer [59], Gandalf <ref> [24] </ref>, Pecan [50], and Rational [2]. Each of these environments consists of an integrated collection of tools that (1) can be viewed as a single tool [7] and (2) may be applied incrementally as the programmer writes and tests his programs. <p> These three methods are briefly described here and are explained in detail in the references. The first school uses action routines, which were proposed by Medina-Mora in his thesis [45] for use in LBEs <ref> [18, 24] </ref>. Action routines are based on the semantic routines used in compiler generation systems such as Yacc [31]. The semantics processing is written as a set of routines in either a conventional programming language or in a special purpose programming language designed for writing action routines [1]. <p> The output stream is automatically redisplayed on the screen after every update. Various kinds of unparse schemes have been proposed for defining the concrete syntax necessary for displaying the program <ref> [24, 29, 53] </ref> or distinct views of the program [21, 50]. The action equations paradigm assumes the availability of one of these mechanisms for display purposes. The read statement is slightly more difficult and requires a delay equation.
Reference: 25. <author> Henderson, Peter and Weiser, Mark. </author> <title> Continuous execution: the VisiProg environment. </title> <booktitle> 8th International Conference on Software Engineering, </booktitle> <month> August, </month> <year> 1985, </year> <pages> pp. 68-74. </pages>
Reference-contexts: IF a THEN ... ELSE ... This behavior does not depend on whether the interpreter tool is incremental or non 5 incremental. By analogy to the type checking tool, an `incremental' interpreter might follow along behind the user, executing the program as it is typed, as in VisiProg <ref> [25] </ref>. Instead, we think of an `incremental' interpreter as one that permits the user to select, for example, the then part of the if, the entire if statement, or an arbitrary program unit, and give a command to interpret that unit.
Reference: 26. <author> Hoover, Roger and Teitelbaum, Tim. </author> <title> Efficient incremental evaluation of aggregate values in attribute grammars. </title> <booktitle> SIGPlan '86 Symposium on Compiler Construction, </booktitle> <month> June, </month> <year> 1986, </year> <pages> pp. 39-50. </pages>
Reference-contexts: This second extension to pure attribute grammars has recently appeared in several `attribute grammar' systems <ref> [26, 54] </ref>. Together, these side-effects and the added dimension of events make it possible for action equations to support the expression of dynamic semantics in a style similar to how attribute grammars support the expression of static semantics. 8 3. Description of Dynamic Semantics 3.1.
Reference: 27. <author> Hoover, Roger. </author> <title> Dynamically bypassing copy rule chains in attribute grammars. </title> <booktitle> 13th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January, </month> <year> 1986, </year> <pages> pp. 14-25. </pages>
Reference-contexts: This is done through identifier definition-use links. Several extensions to attribute grammars have been proposed <ref> [9, 27, 28] </ref> that improve the efficiency of incremental attribute evaluation by linking the definitions and uses for each identifier. A change in an attribute value at a definition site is propagated along the links to dependent attributes at its use sites.
Reference: 28. <author> Horwitz, Susan and Teitelbaum, Tim. </author> <title> "Generating editing environments based on relations and attributes". </title> <journal> ACM Transactions on Programming Languages and Systems 8, </journal> <month> 4 (October </month> <year> 1986), </year> <pages> 577-608. </pages>
Reference-contexts: This is done through identifier definition-use links. Several extensions to attribute grammars have been proposed <ref> [9, 27, 28] </ref> that improve the efficiency of incremental attribute evaluation by linking the definitions and uses for each identifier. A change in an attribute value at a definition site is propagated along the links to dependent attributes at its use sites.
Reference: 29. <author> Hudson, Scott E. and King, Roger. </author> <title> Implementing a user interface as a system of attributes. </title> <booktitle> SIGSoft/SIGPlan Software Engineering Symposium on Practical Software Development Environments, </booktitle> <month> December, </month> <year> 1986, </year> <pages> pp. 143-149. </pages>
Reference-contexts: The output stream is automatically redisplayed on the screen after every update. Various kinds of unparse schemes have been proposed for defining the concrete syntax necessary for displaying the program <ref> [24, 29, 53] </ref> or distinct views of the program [21, 50]. The action equations paradigm assumes the availability of one of these mechanisms for display purposes. The read statement is slightly more difficult and requires a delay equation.
Reference: 30. <author> Jazayeri, M., Ogden, W. F. and Rounds, W. C. </author> <title> "The intrinsically exponential complexity of the circularity problem for attribute grammars". </title> <journal> Communications of the ACM 18, </journal> <month> 12 (December </month> <year> 1975). </year>
Reference-contexts: This process continues until the scheduling graph becomes empty, which is guaranteed to happen eventually if the attribute grammar is noncircular. (Algorithms to detect circularity in an attribute grammar are exponential <ref> [30] </ref>, so 26 whether or not a given attribute grammar is non-circular is often determined by inspection.) This evaluation algorithm is asymptotically optimal in the sense that the number of attribute evaluations is proportional to the number of attributes that are necessarily reevaluated. (The efficiency may be improved by maintaining additional
Reference: 31. <author> Johnson, S. C. and Lesk, M. E. </author> <title> "Language development tools". </title> <journal> The Bell System Technical Journal 57, </journal> <volume> 6 (July-August 1978), </volume> <pages> 2155-2175. </pages>
Reference-contexts: The first school uses action routines, which were proposed by Medina-Mora in his thesis [45] for use in LBEs [18, 24]. Action routines are based on the semantic routines used in compiler generation systems such as Yacc <ref> [31] </ref>. The semantics processing is written as a set of routines in either a conventional programming language or in a special purpose programming language designed for writing action routines [1].
Reference: 32. <author> Johnson, Gregory F. and Fischer, Charles N. </author> <title> Non-syntactic attribute flow in language based editors. </title> <booktitle> 9th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January, </month> <year> 1982, </year> <pages> pp. 185-195. </pages>
Reference-contexts: The second major group uses attribute grammars, which were introduced by Knuth [43] for specifying the context-sensitive properties of programming languages. Attribute grammars are an alternative to semantic routines in compiler-compilers [14, 20]. The generation of LBEs from attribute grammars <ref> [32, 53] </ref> was proposed by Demers, Reps and Teitelbaum [8].
Reference: 33. <author> Johnson, Gregory F. and Fischer, C. N. </author> <title> A meta-language and system for nonlocal incremental attribute evaluation in language-based editors. </title> <booktitle> 12th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January, </month> <year> 1985, </year> <pages> pp. 141-151. </pages>
Reference-contexts: The values of the attributes are determined by evaluating all the semantic equations as a set of simultaneous equations. During program editing, an incremental algorithm <ref> [33, 52] </ref> automatically reevaluates those attributes whose values may have changed as the result of a subtree replacement (editing operation). The third school uses denotational semantics, originally promoted by Scott and Strachey [55] for formal reasoning about programs.
Reference: 34. <author> Johnson, Gregory F. </author> <title> GL a denotational testbed with continuations and partial continuations as first-class objects. </title> <booktitle> SIGPlan '87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <month> June, </month> <year> 1987, </year> <pages> pp. 165-176. </pages>
Reference-contexts: Several research groups have applied denotational specifications to generation of compilers [6, 48, 49] and interpreters [5], but none of these systems are effective in an incremental programming environment. However, Johnson has recently developed an incremental interpreter/debugger for GL <ref> [34] </ref>, an expressional language based on denotational semantics. Other methods have been proposed (e.g., [3, 10, 13, 51]), but none fulfill all the requirements of an LBE.
Reference: 35. <author> Gail E. Kaiser and Elaine Kant. </author> <title> "Incremental Parsing Without A Parser". </title> <journal> The Journal of Systems and Software 5, </journal> <month> 2 (May </month> <year> 1985), </year> <pages> 121-144. </pages>
Reference-contexts: The key components of an LBE are a standard user interface and a common program representation. Many programming environments have been built using structure editing technology, which supports both of these features. The user interface consists of some mixture of template editing and text editing (supported by incremental parsing <ref> [23, 35, 63] </ref>); the program is represented as a parse tree or abstract syntax tree, where each node may be decorated with attributes. Some of the best known LBEs are Mentor [11], Interlisp [60], the Program Synthesizer [59], Gandalf [24], Pecan [50], and Rational [2].
Reference: 36. <author> Kaiser, Gail E. </author> <title> Semantics of structure editing environments. </title> <type> Ph.D. </type> <institution> Th., Carnegie Mellon University, </institution> <month> May </month> <year> 1985. </year> <note> CMU-CS-85-131.. 31 </note>
Reference-contexts: Action equations achieve a synthesis with most of the advantages of both paradigms but few of their disadvantages. Action equations were originally presented in the author's thesis <ref> [36] </ref>, and additional details can be found there. 7 2.2. Overview of Action Equations Attribute grammars are not suitable for the description of dynamic semantics because of the inherently static nature of their attributes. <p> Attribute grammars previously permitted generation of environments that support only static semantics. Action equations can also be applied outside LBEs to generate interpreters and debuggers, just as attribute grammars have been used to generate compilers. Acknowledgements The bulk of this research was conducted as part of my PhD thesis <ref> [36] </ref> at Carnegie Mellon University. I would like to thank my advisor, Nico Habermann, for his advice and support throughout my graduate student career. I would also like to thank the other members of my committee, Scott Fahlman, Elaine Kant and Bill Riddle, for their contributions.
Reference: 37. <author> Kaiser, Gail E. and Garlan, David. </author> <title> "Melding software systems from reusable building blocks". </title> <booktitle> IEEE Software (July 1987), </booktitle> <pages> 17-24. </pages>
Reference-contexts: I would also like to thank the other members of my committee, Scott Fahlman, Elaine Kant and Bill Riddle, for their contributions. Discussions with David Garlan helped me work out the details of the action equations paradigm. I have more recently collaborated with David to develop Meld <ref> [37] </ref>, an experimental language combining 28 object-oriented and dataflow programming paradigms; Meld's syntax and semantics are loosely based on action equations and on the views David proposed in his thesis [22].
Reference: 38. <author> Kaiser, Gail E., Kaplan, Simon M. and Micallef, Josephine. </author> <title> "Multiuser, distributed language-based environments". </title> <booktitle> IEEE Software (November 1987), </booktitle> <pages> 58-67. </pages>
Reference-contexts: Simon Kaplan pointed out an error in one of the examples given in my dissertation, which is corrected here; Simon has also worked with me on parallel and distributed incremental evaluation algorithms for attribute grammars <ref> [38] </ref>. We have recently applied this work to a concurrent extension of action equations [40].
Reference: 39. <author> Gail E. Kaiser, Peter H. Feiler, Fahimeh Jalili and Johann H. Schlichter. </author> <title> "A Retrospective on DOSE: An Interpretive Approach to Structure Editor Generation". </title> <journal> Software Practice & Experience 18, </journal> <month> 8 (August </month> <year> 1988), </year> <pages> 733-748. </pages>
Reference-contexts: Figure 3-1 illustrates the context-free grammar notation adopted for action equations. This notation is based on the Interface Description Language [44, 58] (IDL) developed as part of the Ada implementation effort, and has been used previously in DOSE <ref> [39] </ref>, an interpretive LBE generation system. Only the abstract syntax is shown; the concrete syntax, or `syntactic sugar', is omitted throughout this article.
Reference: 40. <author> Kaiser, Gail E. and Kaplan, Simon M. </author> <title> Rapid prototyping of concurrent programming languages. </title> <booktitle> 8th International Conference on Distributed Computing Systems, </booktitle> <month> June, </month> <year> 1988, </year> <pages> pp. 250-255. </pages>
Reference-contexts: Simon Kaplan pointed out an error in one of the examples given in my dissertation, which is corrected here; Simon has also worked with me on parallel and distributed incremental evaluation algorithms for attribute grammars [38]. We have recently applied this work to a concurrent extension of action equations <ref> [40] </ref>. Finally, I would like to thank Dave Ackley, Nico Habermann, Josephine Micallef and the anonymous referees for their critical comments on earlier versions of this article; the comments of one of the referees were particularly useful and led to vast improvements in the form and content of the article.
Reference: 41. <author> Kaiser, Gail E. </author> <title> Concurrent Meld. </title> <booktitle> Workshop on Object-Based Concurrent Programming, </booktitle> <month> September, </month> <year> 1988. </year> <note> To appear. </note>
Reference-contexts: A parallel/distributed implementation of Meld <ref> [41] </ref> has been completed by Nicholas Christopher, Seth Strumph and Shyhtsun (Felix) Wu under the direction of Wenwey Hseush and later Steve Popovich.
Reference: 42. <author> Kastens, U., Hutt, B. and Zimmermann, E.. </author> <booktitle> Lecture Notes in Computer Science. Volume 141:GAG: A Practical Compiler Generator. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1982. </year>
Reference-contexts: As with the arguments of semantic equations in attribute grammars, the destination is normally restricted to the children, siblings, parent and other ancestors (reached through uplevel addressing <ref> [42] </ref>). However, it is also possible to propagate from an identifier definition to its use (s) or from a use to its definition (s), as described in the next section.
Reference: 43. <author> Knuth, Donald E. </author> <title> "Semantics of context-free languages". </title> <booktitle> Mathematical Systems Theory 2, </booktitle> <month> 2 (June </month> <year> 1968), </year> <pages> 127-145. </pages>
Reference-contexts: The corresponding routine is automatically invoked by the editor kernel when an editing command is applied to a node in the syntax tree representing the program. The second major group uses attribute grammars, which were introduced by Knuth <ref> [43] </ref> for specifying the context-sensitive properties of programming languages. Attribute grammars are an alternative to semantic routines in compiler-compilers [14, 20]. The generation of LBEs from attribute grammars [32, 53] was proposed by Demers, Reps and Teitelbaum [8].
Reference: 44. <author> Lamb, David Alex . "IDL: </author> <title> sharing intermediate representations". </title> <journal> ACM Transactions on Programming Languages and Systems 9, </journal> <month> 3 (July </month> <year> 1987), </year> <pages> 297-318. </pages>
Reference-contexts: The productions define the composition of the non-terminal nodes in the syntax tree representing the program. Figure 3-1 illustrates the context-free grammar notation adopted for action equations. This notation is based on the Interface Description Language <ref> [44, 58] </ref> (IDL) developed as part of the Ada implementation effort, and has been used previously in DOSE [39], an interpretive LBE generation system. Only the abstract syntax is shown; the concrete syntax, or `syntactic sugar', is omitted throughout this article.
Reference: 45. <author> Medina-Mora, Raul. </author> <title> Syntax-directed editing: towards integrated programming environments. </title> <type> Ph.D. </type> <institution> Th., Carnegie Mellon University, </institution> <month> March </month> <year> 1982. </year> <month> CMU-CS-82-113.. </month>
Reference-contexts: For example, type checking and symbol resolution may be performed automatically as the program is created and modified; code generation and some code optimization may also be done incrementally. The early LBEs were hand-coded. Then several environment generators were developed, including ALOE <ref> [45] </ref>, Metal [12] and the Synthesizer Generator [53]. An environment generator is a program that combines an environment description with the editor kernel to produce the desired LBE. <p> These three methods are briefly described here and are explained in detail in the references. The first school uses action routines, which were proposed by Medina-Mora in his thesis <ref> [45] </ref> for use in LBEs [18, 24]. Action routines are based on the semantic routines used in compiler generation systems such as Yacc [31].
Reference: 46. <author> Notkin, David S. </author> <title> Interactive structure-oriented computing. </title> <type> Ph.D. </type> <institution> Th., Carnegie Mellon University, </institution> <month> February </month> <year> 1984. </year> <month> CMU-CS-84-103.. </month>
Reference-contexts: There are two major schools that support different methods of specifying the semantics processing of an LBE: action routines and attribute grammars. Both methods support interactive semantics processing, i.e., the integrated, incremental, nonsequential, structure-oriented computing style described by Notkin in his thesis <ref> [46] </ref>. Such interaction with the user is an essential requirement for modern programming environments. A third major school denotational semantics disagrees with this claim, and supports another method of specifying semantics processing for non-incremental, sequential programming environments.
Reference: 47. <author> Partsch, H. and Steinbruggen, R. </author> <title> "Program transformation systems". </title> <journal> Computing Surveys 15, </journal> <month> 3 (September </month> <year> 1983), </year> <pages> 199-236. </pages>
Reference-contexts: This argument assumes the programmer does not expect the programming environment to change his program, but exactly the opposite is true in transformational programming environments, formal <ref> [4, 19, 47, 57] </ref> or informal [62]. There is no reason the programmer should expect less from an LBE; in particular, manipulation of the program text by action equations is one mechanism for implementing transformations.
Reference: 48. <author> Paulson, Lawrence. </author> <title> A semantics-directed compiler generator. </title> <booktitle> 9th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January, </month> <year> 1982, </year> <pages> pp. 224-233. </pages>
Reference-contexts: Several research groups have applied denotational specifications to generation of compilers <ref> [6, 48, 49] </ref> and interpreters [5], but none of these systems are effective in an incremental programming environment. However, Johnson has recently developed an incremental interpreter/debugger for GL [34], an expressional language based on denotational semantics.
Reference: 49. <author> Raskovsky, Martin R. </author> <title> Denotational semantics as a specification of code generators. </title> <booktitle> SIGPlan '82 Symposium on Compiler Construction, </booktitle> <month> June, </month> <year> 1982, </year> <pages> pp. 230-244. </pages>
Reference-contexts: Several research groups have applied denotational specifications to generation of compilers <ref> [6, 48, 49] </ref> and interpreters [5], but none of these systems are effective in an incremental programming environment. However, Johnson has recently developed an incremental interpreter/debugger for GL [34], an expressional language based on denotational semantics.
Reference: 50. <author> Reiss, Steven P. </author> <title> Graphical program development with PECAN program development systems. </title> <booktitle> SIGSoft/SIGPlan Software Engineering Symposium on Practical Software Development Environments, </booktitle> <month> April, </month> <year> 1984, </year> <pages> pp. 30-41. </pages>
Reference-contexts: Some of the best known LBEs are Mentor [11], Interlisp [60], the Program Synthesizer [59], Gandalf [24], Pecan <ref> [50] </ref>, and Rational [2]. Each of these environments consists of an integrated collection of tools that (1) can be viewed as a single tool [7] and (2) may be applied incrementally as the programmer writes and tests his programs. <p> The output stream is automatically redisplayed on the screen after every update. Various kinds of unparse schemes have been proposed for defining the concrete syntax necessary for displaying the program [24, 29, 53] or distinct views of the program <ref> [21, 50] </ref>. The action equations paradigm assumes the availability of one of these mechanisms for display purposes. The read statement is slightly more difficult and requires a delay equation.
Reference: 51. <author> Reiss, Steven P. </author> <title> An approach to incremental compilation. </title> <booktitle> SIGPlan '84 Symposium on Compiler Construction, </booktitle> <month> June, </month> <year> 1984, </year> <pages> pp. 144-156. </pages>
Reference-contexts: However, Johnson has recently developed an incremental interpreter/debugger for GL [34], an expressional language based on denotational semantics. Other methods have been proposed (e.g., <ref> [3, 10, 13, 51] </ref>), but none fulfill all the requirements of an LBE. The basic problems are: The design, implementation and debugging of action routines, or any other procedural mechanism, is tedious and error-prone compared to the ease with which a syntax description can be developed.
Reference: 52. <author> Reps, Thomas, Teitelbaum, Tim and Demers, Alan. </author> <title> "Incremental context-dependent analysis for language-based editors". </title> <journal> ACM Transactions on Programming Languages and Systems 5, </journal> <month> 3 (July </month> <year> 1983), </year> <pages> 449-477. </pages>
Reference-contexts: The values of the attributes are determined by evaluating all the semantic equations as a set of simultaneous equations. During program editing, an incremental algorithm <ref> [33, 52] </ref> automatically reevaluates those attributes whose values may have changed as the result of a subtree replacement (editing operation). The third school uses denotational semantics, originally promoted by Scott and Strachey [55] for formal reasoning about programs. <p> Implementation Algorithms The implementation of action equations consists of two parts, translation and run-time support. Both parts involve an adaptation of the Reps, Teitelbaum and Demers algorithms <ref> [52] </ref> for generation of LBEs from attribute grammars. Reps' algorithms work roughly as follows.
Reference: 53. <author> Reps, Thomas and Teitelbaum, Tim. </author> <title> The Synthesizer Generator. </title> <booktitle> SIGSoft/SIGPlan Software Engineering Symposium on Practical Software Development Environments, </booktitle> <month> April, </month> <year> 1984, </year> <pages> pp. 41-48. 32 </pages>
Reference-contexts: For example, type checking and symbol resolution may be performed automatically as the program is created and modified; code generation and some code optimization may also be done incrementally. The early LBEs were hand-coded. Then several environment generators were developed, including ALOE [45], Metal [12] and the Synthesizer Generator <ref> [53] </ref>. An environment generator is a program that combines an environment description with the editor kernel to produce the desired LBE. <p> The second major group uses attribute grammars, which were introduced by Knuth [43] for specifying the context-sensitive properties of programming languages. Attribute grammars are an alternative to semantic routines in compiler-compilers [14, 20]. The generation of LBEs from attribute grammars <ref> [32, 53] </ref> was proposed by Demers, Reps and Teitelbaum [8]. <p> Calculation of expression values does not, however, necessarily require this rather cumbersome action equations apparatus. Purely applicative expressions are handled in a natural way by pure attribute grammars, as demonstrated by Reps' and Teitelbaum's desk calculator <ref> [53] </ref>, so this is not discussed further in this article. <p> The output stream is automatically redisplayed on the screen after every update. Various kinds of unparse schemes have been proposed for defining the concrete syntax necessary for displaying the program <ref> [24, 29, 53] </ref> or distinct views of the program [21, 50]. The action equations paradigm assumes the availability of one of these mechanisms for display purposes. The read statement is slightly more difficult and requires a delay equation.
Reference: 54. <author> Reps, Thomas, Marceau, Carla and Teitelbaum, Tim. </author> <title> Remote attribute updating for language-based editors. </title> <booktitle> 13th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January, </month> <year> 1986, </year> <pages> pp. 1-13. </pages>
Reference-contexts: This second extension to pure attribute grammars has recently appeared in several `attribute grammar' systems <ref> [26, 54] </ref>. Together, these side-effects and the added dimension of events make it possible for action equations to support the expression of dynamic semantics in a style similar to how attribute grammars support the expression of static semantics. 8 3. Description of Dynamic Semantics 3.1.
Reference: 55. <author> Scott, Dana and Strachey, Christopher. </author> <title> Toward a mathematical semantics for computer languages. </title> <type> Tech. </type> <institution> Rept. Technical Monograph PRG-6, Oxford University Computing Laboratory, </institution> <month> August, </month> <year> 1971. </year>
Reference-contexts: During program editing, an incremental algorithm [33, 52] automatically reevaluates those attributes whose values may have changed as the result of a subtree replacement (editing operation). The third school uses denotational semantics, originally promoted by Scott and Strachey <ref> [55] </ref> for formal reasoning about programs.
Reference: 56. <author> Shebs, Stan and Kessler, Robert. </author> <title> Automatic design and implementation of language datatypes. </title> <booktitle> SIGPlan '87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <month> June, </month> <year> 1987, </year> <pages> pp. 26-37. </pages>
Reference-contexts: This would require each implementor to define a suitable representation for each datatype in his language <ref> [56] </ref>.
Reference: 57. <author> Smith, Douglas R., Kotik, Gordon B. and Westfold, Stephen J. </author> <title> "Research on knowledge-based software environments at Kestrel Institute". </title> <journal> IEEE Transactions on Software Engineering SE-11, </journal> <month> 11 (November </month> <year> 1985), </year> <pages> 1278-1295. </pages>
Reference-contexts: This argument assumes the programmer does not expect the programming environment to change his program, but exactly the opposite is true in transformational programming environments, formal <ref> [4, 19, 47, 57] </ref> or informal [62]. There is no reason the programmer should expect less from an LBE; in particular, manipulation of the program text by action equations is one mechanism for implementing transformations.
Reference: 58. <author> Snodgrass, Richard and Shannon, Karen. </author> <title> Lecture Notes in Computer Science. Volume 244: Supporting flexible and efficient tool integration. In Advanced Programming Environments, Conradi, </title> <editor> Reidar, Didriksen, Tor M. and Wanvik, Dag H., Eds., </editor> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986, </year> <pages> pp. 290-313. </pages>
Reference-contexts: The productions define the composition of the non-terminal nodes in the syntax tree representing the program. Figure 3-1 illustrates the context-free grammar notation adopted for action equations. This notation is based on the Interface Description Language <ref> [44, 58] </ref> (IDL) developed as part of the Ada implementation effort, and has been used previously in DOSE [39], an interpretive LBE generation system. Only the abstract syntax is shown; the concrete syntax, or `syntactic sugar', is omitted throughout this article.
Reference: 59. <author> Teitelbaum, Tim and Reps, Thomas. </author> <title> "The Cornell Program Synthesizer: a syntax-directed programming environment". </title> <journal> Communications of the ACM 24, </journal> <month> 9 (September </month> <year> 1981), </year> <pages> 563-573. </pages>
Reference-contexts: Some of the best known LBEs are Mentor [11], Interlisp [60], the Program Synthesizer <ref> [59] </ref>, Gandalf [24], Pecan [50], and Rational [2]. Each of these environments consists of an integrated collection of tools that (1) can be viewed as a single tool [7] and (2) may be applied incrementally as the programmer writes and tests his programs.
Reference: 60. <author> Teitelman, Warren and Masinter, Larry. </author> <title> "The Interlisp programming environment". </title> <booktitle> IEEE Computer 14, </booktitle> <month> 4 (April </month> <year> 1981), </year> <pages> 25-34. </pages>
Reference-contexts: Some of the best known LBEs are Mentor [11], Interlisp <ref> [60] </ref>, the Program Synthesizer [59], Gandalf [24], Pecan [50], and Rational [2]. Each of these environments consists of an integrated collection of tools that (1) can be viewed as a single tool [7] and (2) may be applied incrementally as the programmer writes and tests his programs.
Reference: 61. <author> Walz, Janet A. and Johnson, Gregory F. </author> <title> Incremental evaluation for a general class of circular attribute grammars. </title> <booktitle> SIGPlan '88 Conference on Programming Language Design and Implementation, </booktitle> <month> June, </month> <year> 1988, </year> <pages> pp. 209-221. </pages>
Reference-contexts: Although circular attribute grammars are problematical for non-incremental evaluation [15] and rarely handled by incremental evaluators (work by Walz and Johnson is a notable exception <ref> [61] </ref>), circularities among propagate equations pose no difficulties. If the user of a generated environment writes an infinite loop, then the propagation never terminates, to preserve correct dynamic semantics processing; if the loop does terminate, then the propagation terminates accordingly. 4.2.
Reference: 62. <author> Waters, Richard C. "KBEmacs: </author> <booktitle> where's the AI?". The AI Magazine VII, 1 (Spring 1986), </booktitle> <pages> 47-56. </pages>
Reference-contexts: This argument assumes the programmer does not expect the programming environment to change his program, but exactly the opposite is true in transformational programming environments, formal [4, 19, 47, 57] or informal <ref> [62] </ref>. There is no reason the programmer should expect less from an LBE; in particular, manipulation of the program text by action equations is one mechanism for implementing transformations.
Reference: 63. <author> Wegman, Mark N. </author> <title> Parsing for structural editors. </title> <booktitle> 21st Annual Symposium on Foundations of Computer Science, </booktitle> <month> October, </month> <year> 1980, </year> <pages> pp. 320-327. </pages>
Reference-contexts: The key components of an LBE are a standard user interface and a common program representation. Many programming environments have been built using structure editing technology, which supports both of these features. The user interface consists of some mixture of template editing and text editing (supported by incremental parsing <ref> [23, 35, 63] </ref>); the program is represented as a parse tree or abstract syntax tree, where each node may be decorated with attributes. Some of the best known LBEs are Mentor [11], Interlisp [60], the Program Synthesizer [59], Gandalf [24], Pecan [50], and Rational [2].
References-found: 64

