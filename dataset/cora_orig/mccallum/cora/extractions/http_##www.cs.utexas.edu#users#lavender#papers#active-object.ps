URL: http://www.cs.utexas.edu/users/lavender/papers/active-object.ps
Refering-URL: http://www.cs.utexas.edu/users/lavender/papers/index.html
Root-URL: 
Email: g.lavender@isode.com schmidt@cs.wustl.edu  
Title: Active Object an Object Behavioral Pattern for Concurrent Programming  
Author: R. Greg Lavender Douglas C. Schmidt 
Address: Austin, TX Washington University, St. Louis  
Affiliation: ISODE Consortium Inc. Department of Computer Science  
Abstract: This paper has been submitted to the Pattern Languages of Programming conference in Monticello, Illinois, September 6-8, 1995. Abstract This paper describes the Active Object pattern, which decou-ples method execution from method invocation in order to simplify synchronized access to a shared resource by methods invoked in different threads of control. This pattern is commonly used in distributed systems requiring multi-threaded servers. In addition, client applications such as windowing systems and network browsers, are increasingly employing active objects to enable concurrent, asynchronous network operations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, </author> <title> Experience with a System of Reusable Design Patterns for Motorola Iridium Communication Software, in The Theory and Practice of Object Systems (special issue on Patterns and Pattern Languages) (S. </title> <editor> P. Berczuk, ed.), </editor> <publisher> Wiley and Sons, </publisher> <year> 1995. </year>
Reference-contexts: The gateway routes messages from one or more source processes to one or more destination processes in a distributed system <ref> [1] </ref>. Sources and destinations communicate with the gateway using TCP connections. Internally, the gateway contains a set of Input and Output Handler objects. Input Handlers receive messages from sources and use address fields in a message to determine the appropriate Output Handlers associated with the destination. <p> In addition, the Active Object pattern is increasingly finding use in client applications such as windowing systems and network browsers that employ multiple active objects to enable concurrent, asynchronous network operations. The gateway example from Section 3 is based on the communication services portion of the Motorola Iridium project <ref> [1] </ref>. Output Handler objects in Iridium gateways are implemented as active objects to simplify concurrent programming and improve performance on multi-processors. The active object version of the Iridium gateway uses the pre-emptive multi-tasking capabilities provided by Solaris threads [11].
Reference: [2] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: One way to ensure this is to design the gateway as a single-threaded reactive state machine that will not block on input or output connections. This design typically combines the Reactor pattern <ref> [2] </ref>, non-blocking sockets, and a set of message queues (one per Output Handler). The Reactor pattern and the non-blocking sockets provide a single-threaded cooperative event loop model of programming. The Reactor demultiplexes ok to send and ok to 1 receive events to multiple Input and Output Handler objects. <p> The Half-Sync/Half-Async pattern [15] is an architectural pattern that decouples synchronous I/O from asynchronous I/O in a system to simplify concurrent programming effort without degrading execution efficiency. This pattern typically uses the Active Object pattern to implement the Synchronous task layer and the Reactor pattern <ref> [2] </ref> to implement the Asynchronous task layer.
Reference: [3] <author> D. C. Schmidt and T. Suda, </author> <title> Measuring the Performance of Parallel Message-based Process Architectures, </title> <booktitle> in Proceedings of the Conference on Computer Communications (INFO-COM), </booktitle> <address> (Boston, MA), </address> <publisher> IEEE, </publisher> <month> April </month> <year> 1995. </year>
Reference-contexts: can differ from the order of method invocation this features can be used to implement task priorities in concurrent programs. * The operations on a shared object are relatively coarse-grained in contrast, if operations are very fine-grained then the synchronization, data movement, and context switching overhead may be too high <ref> [3] </ref>. 5 Structure The structure of the Active Object pattern is illustrated in the following Booch class diagram: 6 Participants The key participants in the Active Object pattern include the following: * Client Interface (Output Handler Interface) Presents a typed method interface to client applications.
Reference: [4] <author> R. H. Halstead, Jr., </author> <title> Multilisp: A Language for Concurrent Symbolic Computation, </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> vol. 7, </volume> <pages> pp. 501-538, </pages> <month> Oct. </month> <year> 1985. </year>
Reference-contexts: The Result Handle allows the eventual result value to be obtained after the Scheduler finishes executing the method. A Result Handle may be implemented using various mechanisms, all of which provide some type of synchronized reply channel. A particularly useful mechanism is a future <ref> [4] </ref> (or promise [5]). A future is a synchronization object that enforces write-once, read-many synchronization (futures are described further in Section 9). 7 Collaborations The following figure illustrates the three phases of collabo rations in the Active Object pattern: 1.
Reference: [5] <author> B. Liskov and L. Shrira, </author> <title> Promises: Linguistic Support for Efficient Asynchronous Procedure Calls in Distributed Systems, </title> <booktitle> in Proceedingsof the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 260-267, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: The Result Handle allows the eventual result value to be obtained after the Scheduler finishes executing the method. A Result Handle may be implemented using various mechanisms, all of which provide some type of synchronized reply channel. A particularly useful mechanism is a future [4] (or promise <ref> [5] </ref>). A future is a synchronization object that enforces write-once, read-many synchronization (futures are described further in Section 9). 7 Collaborations The following figure illustrates the three phases of collabo rations in the Active Object pattern: 1.
Reference: [6] <author> R. G. Lavender and D. G. Kafura, </author> <title> A Polymorphic Future and First-Class Function Type for Concurrent Object-Oriented Programming in C++, in Forthcoming, </title> <note> 1995. http://www.cs.utexas.edu/users/lavender/papers/futures.ps. </note>
Reference-contexts: If the method produces a result value then some form of future mechanism must be used to provide synchronized access to the value. In the context of the Active Object pattern, a polymorphic future pattern is required <ref> [6] </ref> for asynchronous invocations that return a value to the caller. A polymorphic future allows parameterization of the eventual result type represented by the future and enforces the necessary synchronization.
Reference: [7] <author> P. </author> <title> America, Inheritance and Subtyping in a Parallel Object-Oriented Language, </title> <booktitle> in ECOOP'87 Conference Proceedings, </booktitle> <pages> pp. 234-242, </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Inserting synchronization code into methods of a class representing a shared resource generally inhibits the ability to reuse that representation by a derived class. This problem is commonly referred to as the inheritance anomaly <ref> [7, 8, 9, 10] </ref>. This anomaly occurs when inheriting from a class whose implementation incorporates explicit synchronization code as part of the implementation of the shared abstraction. It is often the case that the synchronization requirements of the derived class are in conflict with those of the base class.
Reference: [8] <author> D. G. Kafura and K. H. Lee, </author> <title> Inheritance in Actor-Based Concurrent Object-Oriented Languages, </title> <booktitle> in ECOOP'89 Conference Proceedings, </booktitle> <pages> pp. 131-145, </pages> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: Inserting synchronization code into methods of a class representing a shared resource generally inhibits the ability to reuse that representation by a derived class. This problem is commonly referred to as the inheritance anomaly <ref> [7, 8, 9, 10] </ref>. This anomaly occurs when inheriting from a class whose implementation incorporates explicit synchronization code as part of the implementation of the shared abstraction. It is often the case that the synchronization requirements of the derived class are in conflict with those of the base class.
Reference: [9] <author> S. Matsuoka, K. Wakita, and A. Yonezawa, </author> <title> Analysis of Inheritance Anomaly in Concurrent Object-Oriented Languages, </title> <journal> OOPS Messenger, </journal> <year> 1991. </year> <month> 7 </month>
Reference-contexts: Inserting synchronization code into methods of a class representing a shared resource generally inhibits the ability to reuse that representation by a derived class. This problem is commonly referred to as the inheritance anomaly <ref> [7, 8, 9, 10] </ref>. This anomaly occurs when inheriting from a class whose implementation incorporates explicit synchronization code as part of the implementation of the shared abstraction. It is often the case that the synchronization requirements of the derived class are in conflict with those of the base class.
Reference: [10] <author> M. Papathomas, </author> <title> Concurrency issues in object-oriented lan-guages, in Object Oriented Development (D. Tsichritzis, </title> <publisher> ed.), </publisher> <pages> pp. 207-245, </pages> <institution> Centre Universitaire D'Informatique, University of Geneva, </institution> <year> 1989. </year>
Reference-contexts: Inserting synchronization code into methods of a class representing a shared resource generally inhibits the ability to reuse that representation by a derived class. This problem is commonly referred to as the inheritance anomaly <ref> [7, 8, 9, 10] </ref>. This anomaly occurs when inheriting from a class whose implementation incorporates explicit synchronization code as part of the implementation of the shared abstraction. It is often the case that the synchronization requirements of the derived class are in conflict with those of the base class.
Reference: [11] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin-giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Output Handler objects in Iridium gateways are implemented as active objects to simplify concurrent programming and improve performance on multi-processors. The active object version of the Iridium gateway uses the pre-emptive multi-tasking capabilities provided by Solaris threads <ref> [11] </ref>. An earlier version of the Iridium gateway used a reactive implementation described in Section 3. The reactive design relied upon cooperative event loop-driven dispatcher within a single thread. This design was more difficult to implement and did not perform as well as the active object version on multi-processor platforms.
Reference: [12] <author> G. Agha, </author> <title> A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: The reactive design relied upon cooperative event loop-driven dispatcher within a single thread. This design was more difficult to implement and did not perform as well as the active object version on multi-processor platforms. The Active Object pattern has also be used to implement Actors <ref> [12] </ref>. An Actor consists of a set of instance variables and behaviors that react to messages sent to an Actor by other Actors. Messages sent to an Actor are queued in the Actor's message queue and, in the simple model, are executed in order of arrival by the current behavior.
Reference: [13] <author> C. Tomlinson and V. Singh, </author> <title> Inheritance and synchronization with enabled-sets, </title> <booktitle> in OOPSLA'89 Conference Proceedings, </booktitle> <pages> pp. 103-112, </pages> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Each behavior nominates a replacement behavior to execute the next message, possibly before the nominating behavior has completed execution. Variations on the simple model allow messages in the message queue to be executed based on criteria other than arrival order <ref> [13] </ref>. In using the Active Object pattern to implement Actors, the Scheduler corresponds the the Actor scheduling mechanism, Method Objects correspond to the behaviors defined for an Actor, and the Resource Representation is the set of instance variables that collectively represent the state of an Actor [14].
Reference: [14] <author> D. Kafura, M. Mukherji, and G. Lavender, </author> <title> ACT++: A Class Library for Concurrent Programming in C++ using Actors, </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pp. 47-56, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In using the Active Object pattern to implement Actors, the Scheduler corresponds the the Actor scheduling mechanism, Method Objects correspond to the behaviors defined for an Actor, and the Resource Representation is the set of instance variables that collectively represent the state of an Actor <ref> [14] </ref>.
Reference: [15] <author> D. C. Schmidt and C. D. Cranor, Half-Sync/Half-Async: </author> <title> an Architectural Pattern for Efficient and Well-structured Concurrent I/O, </title> <booktitle> in Submitted to the proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monti-cello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-10, </pages> <month> September </month> <year> 1995. </year> <month> 8 </month>
Reference-contexts: Whether a caller blocks on a future depends on whether or not a result value has been computed. Hence, the future pattern is a hybrid pattern that is partly a reader-writer condition synchronization pattern and a producer-consumer synchronization pattern. The Half-Sync/Half-Async pattern <ref> [15] </ref> is an architectural pattern that decouples synchronous I/O from asynchronous I/O in a system to simplify concurrent programming effort without degrading execution efficiency. This pattern typically uses the Active Object pattern to implement the Synchronous task layer and the Reactor pattern [2] to implement the Asynchronous task layer.
References-found: 15

