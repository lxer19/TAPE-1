URL: ftp://ftp.cs.helsinki.fi/pub/Reports/by_Project/Vital/Problems_in_Interfacing_Tools_of_Different_Development_Environments.ps.gz
Refering-URL: http://www.cs.helsinki.fi/~verkamo/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Problems in Interfacing Tools of Different Development Environments  
Author: A. Inkeri Verkamo Greger Linden 
Date: June 1995, pages 429 437.  
Note: Engineering and Knowledge Engineering,  
Address: P.O. Box 26 (Teollisuuskatu 23), FIN-00014 Helsinki, Finland  
Affiliation: University of Helsinki, Department of Computer Science  
Abstract: This information transfer has usually been solved by applying ad hoc transformations to integrate the tools within a single development environment. We study the problem of making tools in different environments cooperate without modifying the tools or their environment. This requires building a permanent interfacing mechanism between the two environments. Problems particular to this context are incompatibility of the source and target languages, multiple views used within the environments, different naming conventions, and different ways of representing graphical information. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bruno Alabiso. </author> <title> Transformation of data flow analysis models to object oriented design. </title> <booktitle> In Proceedings of OOPSLA'88, </booktitle> <pages> pages 335 - 353, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: The source and target tools may handle the same or different levels of abstraction. The transformational approach to software development [13] concentrates on transformations from a higher level of abstraction to a lower level of abstraction, such as transformations from analysis to design models (see, e.g., <ref> [1, 6] </ref>). However, we may also want to interface source and target models on similar levels of abstraction. If we want to move entire software artifacts from an outdated tool to a new target environment (defined as immigration in [17]) only unidirectional information transfer is adequate.
Reference: [2] <author> Andersen Consulting. </author> <title> FOUNDATION Application Development, </title> <note> Version 2.0, </note> <year> 1993. </year>
Reference-contexts: included in the transfer. ;;; -*- Mode: Lisp, Design Domain Layer; ... (dale:defgraphics dale:coordinates dale::concept (private (505 132 585 182) client (275 35 355 85) ...)) (def-concept private ((":":": client dale::kldesign-isa-link dale::concept)) ((:slots age independent civil-status) (:inter-diag-alias))) ... 3.2 The CASE environment The CASE environment is Andersen Consulting's foundation 2 <ref> [2] </ref>, which is a typical example of advanced commercial CASE environments. foundation runs in PCs and uses the OS/2 operating system. The foundation toolset for the analysis and design phases, foundation Design, uses a repository that is built on the commercial database system DB2/2 3 .
Reference: [3] <author> Andersen Consulting. </author> <title> FOUNDATION Design, Analyze Application Requirements, </title> <note> Version 2.0, </note> <year> 1993. </year>
Reference-contexts: Since foundation Design supports object import and export [4] building an interface does not require changing the tool itself. foundation Design contains several tools for the analysis and design phase <ref> [3] </ref>, including diagramming tools for entity-relationship diagrams (ERD), data flow diagrams (DFD), and procedure diagrams (PD) (Figure 3). Importing and exporting repository information is based on using separate import/export files (exp-files, see Figure 4).
Reference: [4] <author> Andersen Consulting. </author> <title> FOUNDATION Design, Data Administration, </title> <note> Version 2.0, </note> <year> 1993. </year>
Reference-contexts: The foundation toolset for the analysis and design phases, foundation Design, uses a repository that is built on the commercial database system DB2/2 3 . Since foundation Design supports object import and export <ref> [4] </ref> building an interface does not require changing the tool itself. foundation Design contains several tools for the analysis and design phase [3], including diagramming tools for entity-relationship diagrams (ERD), data flow diagrams (DFD), and procedure diagrams (PD) (Figure 3).
Reference: [5] <author> Hany M. Atchan. </author> <title> An experiment in eliminating the separation between data, functional, and behavioral models during requirements specification. </title> <booktitle> In Proceedings of the Sixth International Conference on Software Engineering and Knowledge Engineering (SEKE '94), </booktitle> <pages> pages 2 - 9, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: In the requirements specification phase, an entity-relationship diagram is used for data modeling, a data-flow diagram for functional modeling and a flow chart for behavioral modeling. Although each fine-grained tool is easier to master a group of separate tools may have inconsistent or confusing notations <ref> [5] </ref>. Instead of separate tools we might use a single tool with a wider scope, such as high-level Petri nets for all three aspects of the requirements specification [5]. <p> Although each fine-grained tool is easier to master a group of separate tools may have inconsistent or confusing notations <ref> [5] </ref>. Instead of separate tools we might use a single tool with a wider scope, such as high-level Petri nets for all three aspects of the requirements specification [5]. An extended tool is probably more difficult to learn, but this may pay back in the long run, reducing inconsistency and improving productivity [5]. From the point of view of interfacing, if the tools have a small scope it is more probable to find close correspondence between them. <p> of separate tools we might use a single tool with a wider scope, such as high-level Petri nets for all three aspects of the requirements specification <ref> [5] </ref>. An extended tool is probably more difficult to learn, but this may pay back in the long run, reducing inconsistency and improving productivity [5]. From the point of view of interfacing, if the tools have a small scope it is more probable to find close correspondence between them.
Reference: [6] <author> Germinal Boloix, Paul G. Sorenson, and J. Paul Tremblay. </author> <title> Transformations using a meta-system approach to software development. </title> <journal> Software Engineering Journal, </journal> <volume> 7(6):425 - 437, </volume> <month> November </month> <year> 1992. </year>
Reference-contexts: The source and target tools may handle the same or different levels of abstraction. The transformational approach to software development [13] concentrates on transformations from a higher level of abstraction to a lower level of abstraction, such as transformations from analysis to design models (see, e.g., <ref> [1, 6] </ref>). However, we may also want to interface source and target models on similar levels of abstraction. If we want to move entire software artifacts from an outdated tool to a new target environment (defined as immigration in [17]) only unidirectional information transfer is adequate. <p> This usually requires user involvement, but the interface can assist by notifying when such additions are needed and by suggesting appropriate elements <ref> [6] </ref>. As an example, let us look at an OCML domain diagram that we want to transform into an ERD (Figure 5). The domain diagram includes a concept Client and an instance Mrs A. Client. In an ERD, instances are usually not presented.
Reference: [7] <editor> John Domingue, Marc Eisenstadt, and Blaine Price. </editor> <title> The VITAL bug location methodology. Internal Release OU/231/P/2, ESPRIT Project P5365 VITAL, </title> <month> April </month> <year> 1993. </year>
Reference-contexts: Compared to completely manual information transfer, any assistance from an automated transfer mechanism is welcome. 3 Introduction of our example envi ronment Our example environment originates from a research project, VITAL 1 , which aims at developing a methodology and a workbench for KBS application development <ref> [16, 7] </ref>. The openness of the VITAL workbench requires that information can be imported to as well as exported from the workbench. To try out this goal, an interface has been built between the VITAL workbench and a commercial CASE environment. <p> We shall briefly describe the essential features of both toolsets. 1 VITAL is an ESPRIT-II project funded by the Euro-pean Communities and the Technology Development Center of Finland. 3.1 The VITAL conceptual modeling tool The conceptual modeling tool of VITAL is the OCML (Operationalizable Conceptual Modeling Language) editor <ref> [7] </ref>. The OCML editor includes capabilities for presenting coarse level (GDM) models [8] as well as more refined diagrams that include domain data, domain knowledge, and problem solving behavior. As such, it covers the conceptual modeling phase and even part of the design phase of the KBS development.
Reference: [8] <author> Gertjan van Heijst, Peter Terpstra, Bob Wielinga, and Nigel Shadbolt. </author> <title> Using generalised directive models in knowledge acquisition. In Current Developments in Knowledge Acquisition, </title> <booktitle> 6th European Knowledge Acquisition Workshop EKAW '92, </booktitle> <pages> pages 112 - 132, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: The OCML editor includes capabilities for presenting coarse level (GDM) models <ref> [8] </ref> as well as more refined diagrams that include domain data, domain knowledge, and problem solving behavior. As such, it covers the conceptual modeling phase and even part of the design phase of the KBS development.
Reference: [9] <author> S. E. Keller, J. A Perkins, T. F. Payton, and S. P. Mardinly. </author> <title> Tree transformation techniques and experiences. </title> <booktitle> In Proceedings of the ACM SIGPLAN '84 Symposium on Compiler Construction, </booktitle> <pages> pages 190 - 201, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: The specification of the mapping is based on the notion of TT-grammars <ref> [9] </ref>. Informally, a TT-grammar may be viewed as generating subtrees over the target grammar from subtrees over the source grammar. alchemist generates the transformation code from the transformation specification (Figure 9). The result includes C++ code for a parser, a mapper, and an unparser.
Reference: [10] <author> Sandra A. Mamrak, Julie Barnes, and Conleth S. O'Connell. </author> <title> Benefits of automating data translation. </title> <journal> IEEE Software, </journal> <volume> 10(4):82 - 88, </volume> <month> July </month> <year> 1993. </year>
Reference-contexts: The result includes C++ code for a parser, a mapper, and an unparser. A similar approach to generating transformations has been used in the Integrated Chameleon Architecture <ref> [10] </ref>. During transformation execution, the transformation module builds a parse tree from the source file, maps the source parse tree to a target parse tree, and writes the result to a target file (Figure 10). The target file is then imported into the foundation repository.
Reference: [11] <author> Scott Meyers. </author> <title> Difficulties in integrating mul-tiview development systems. </title> <journal> IEEE Software, </journal> <volume> 8(1):49 - 57, </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: Several studies have considered the requirements for integrating tools of different developers into a common environment (see, e.g., <ref> [11, 20] </ref>). When designing an IPSE, the tools may be modified in order to better adjust to the environment. However, if we want to make use of a non-integrated set of commercial tools, the environments involved may not be changed. <p> Similarly, if only a small part of the development requires (local) use of a non-integrated tool we only need transfer from the primary environment to the tool. If the tools represent different views of the same system development phase <ref> [11] </ref> bidirectional information transfer is needed. This is the case in an embedded KBS where we want to use both environments in parallel, KBS tools for the KBS part and CASE tools for the rest of the application [19].
Reference: [12] <author> Bashar Nuseibeh, Jeff Kramer, and Anthony Finkelstein. </author> <title> Expressing the relationships between multiple views in requirements specification. </title> <booktitle> In Proceedings of the 15th International Conference on Software Engineering (ICSE'93), </booktitle> <pages> pages 187 - 196, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: A similar problem is faced by a team of software developers with a plethora of useful but separate tools available for their purposes. More often than not they have neither the time nor the means to switch into a fully integrated project support environment (IPSE) <ref> [12] </ref>. Recently reported experience indicates that the operational use of CASE integration is still far from straightforward [15]. A pragmatic solution is to use whatever tools are necessary to build the product. <p> The purpose and scope of the tools in a CASE environment may vary considerably. Often several tools are used during the same phase to model different aspects of the application <ref> [12] </ref>. In the requirements specification phase, an entity-relationship diagram is used for data modeling, a data-flow diagram for functional modeling and a flow chart for behavioral modeling. Although each fine-grained tool is easier to master a group of separate tools may have inconsistent or confusing notations [5].
Reference: [13] <author> H. Partsch and R. Steinbruggen. </author> <title> Program transformation systems. </title> <journal> Computing Surveys, </journal> <volume> 15(3):199 - 236, </volume> <year> 1983. </year>
Reference-contexts: The source and target tools may handle the same or different levels of abstraction. The transformational approach to software development <ref> [13] </ref> concentrates on transformations from a higher level of abstraction to a lower level of abstraction, such as transformations from analysis to design models (see, e.g., [1, 6]). However, we may also want to interface source and target models on similar levels of abstraction.
Reference: [14] <author> James Purtilo. </author> <title> The POLYLITH software bus. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1):151 - 174, </volume> <month> January </month> <year> 1994. </year>
Reference-contexts: In this paper we consider the problems involved in building an interface between tools in two indepen-dent environments, in order to transfer the necessary information. | Related problems in the context of interfacing mixed-language software components during execution time have been treated, e.g., in <ref> [14] </ref>. The paper has the following structure. In section 2, we describe some characteristics of the tools and development environments that affect the interfacing mechanism. In section 3, we present two tools that we use as a source of examples in the rest our presentation.
Reference: [15] <author> Jock A. Rader, Alan W. Brown, and Ed J. Mor-ris. </author> <title> Operational use of CASE integration: An investigation of the state of practice. </title> <journal> Journal of Systems and Software, </journal> <volume> 28:59 - 68, </volume> <year> 1995. </year>
Reference-contexts: More often than not they have neither the time nor the means to switch into a fully integrated project support environment (IPSE) [12]. Recently reported experience indicates that the operational use of CASE integration is still far from straightforward <ref> [15] </ref>. A pragmatic solution is to use whatever tools are necessary to build the product. If the tools are not a part of an integrated environment, information must be transferred from one tool to another.
Reference: [16] <author> Nigel Shadbolt, Enrico Motta, and Alain Rouge. </author> <title> Constructing knowledge-based systems. </title> <journal> IEEE Software, </journal> <volume> 10(6):34 - 39, </volume> <month> November </month> <year> 1993. </year>
Reference-contexts: As large embedded KBSs are being developed, there is an increasing need of systematic support for the KBS development. Some projects aiming at building KBS development environments are already under way (e.g., KADS and KADS II [21], and VITAL <ref> [16] </ref>). Presently, fl This research was supported by the Technology Development Center (TEKES) and in part by the Commission of the European Communities under ESPRIT-II project 5365 VITAL. This paper reflects the opinions of the authors and not necessarily those of the consortium. <p> In section 3, we present two tools that we use as a source of examples in the rest our presentation. The tool interface is part of a project developing a KBS development environment <ref> [16] </ref>. Section 4 describes the types of problems involved, supported by our example. In section 5 we propose an interfacing strategy to facilitate solving these problems. <p> Compared to completely manual information transfer, any assistance from an automated transfer mechanism is welcome. 3 Introduction of our example envi ronment Our example environment originates from a research project, VITAL 1 , which aims at developing a methodology and a workbench for KBS application development <ref> [16, 7] </ref>. The openness of the VITAL workbench requires that information can be imported to as well as exported from the workbench. To try out this goal, an interface has been built between the VITAL workbench and a commercial CASE environment.
Reference: [17] <author> Michael H. Sokolsky and Gail E. Kaiser. </author> <title> A framework for immigrating existing software to new software development environments. </title> <journal> Software Engineering Journal, </journal> <volume> 6(6):435 - 453, </volume> <month> November </month> <year> 1991. </year>
Reference-contexts: However, we may also want to interface source and target models on similar levels of abstraction. If we want to move entire software artifacts from an outdated tool to a new target environment (defined as immigration in <ref> [17] </ref>) only unidirectional information transfer is adequate. Similarly, if only a small part of the development requires (local) use of a non-integrated tool we only need transfer from the primary environment to the tool. <p> The scope of the transfer in software immigration is much larger than the scope of a local transfer. Immigration requires that all the information of the source model is contained in the transfer and that all the structures and attributes of the target environment are produced during the transfer <ref> [17] </ref>. To support local use of a tool, only a limited part of the source model is transferred to the target environment. Even though limited in scope, the transfer may still be bidirectional. <p> This also preserves any target model modifications outside the updated part. In a totally non-integrated environment, we may have to account for situations where the two environments run on different platforms. The physical and the low level logical differences require some additional complexity from the transformation mechanism. In <ref> [17] </ref>, a taxonomy of storage structure forms is presented, with respect to their usefulness for immigration. The least organized structure is a group of files within a directory system. If the information is stored in simple files the tools must interpret the structure of the files directly.
Reference: [18] <author> Henry Tirri and Greger Linden. </author> <title> ALCHEMIST | an object-oriented tool to build transformations between heterogeneous data representations. </title> <booktitle> In Proceedings of the Twenty-Seventh Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 226 - 235. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: In our example environments, information is transferred from Sun/Unix to PC/OS2 which requires transformation of certain control characters. 5 Some suggestions for the interfacing strategy We have built a prototype transformation between OCML and foundation Design by using the alchemist transformation generator <ref> [18] </ref>. alchemist is used in the following way: The user describes the source and target representations as context-free grammars and defines a mapping between the rules of the grammars (Figure 9). The specification of the mapping is based on the notion of TT-grammars [9].
Reference: [19] <author> A. Inkeri Verkamo. </author> <title> Cooperation of KBS development environments and CASE environments. </title> <booktitle> In Proceedings of the Sixth International Conference on Software Engineering and Knowledge Engineering (SEKE '94), </booktitle> <pages> pages 358 - 365, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: This is the case in an embedded KBS where we want to use both environments in parallel, KBS tools for the KBS part and CASE tools for the rest of the application <ref> [19] </ref>. The scope of the transfer in software immigration is much larger than the scope of a local transfer.
Reference: [20] <author> Anthony I. Wasserman. </author> <title> Tool integration in software engineering environments. </title> <editor> In F. Long, editor, </editor> <booktitle> Software Engineering Environments, Proceedings of the International Workshop on Environments, Chinon, France, number 467 in Lecture Notes in Computer Science, </booktitle> <pages> pages 137 - 149. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Several studies have considered the requirements for integrating tools of different developers into a common environment (see, e.g., <ref> [11, 20] </ref>). When designing an IPSE, the tools may be modified in order to better adjust to the environment. However, if we want to make use of a non-integrated set of commercial tools, the environments involved may not be changed. <p> In some environments, the full integration between development tools has been stressed, e.g., by requiring tools to use a common look-and-feel or a common repository <ref> [20] </ref>. Other environments are more open, emphasizing the possibility to include but not integrate external tools. Information transfer between tools is needed in order to make the software development proceed from analysis to executable code in a convenient way.
Reference: [21] <author> B. J. Wielinga, A. Th. Schreiber, and J. A. Breuker. KADS: </author> <title> A modelling approach to knowledge engineering. </title> <journal> Knowledge Acquisition, </journal> <volume> 4(1):5 - 53, </volume> <year> 1992. </year>
Reference-contexts: As large embedded KBSs are being developed, there is an increasing need of systematic support for the KBS development. Some projects aiming at building KBS development environments are already under way (e.g., KADS and KADS II <ref> [21] </ref>, and VITAL [16]). Presently, fl This research was supported by the Technology Development Center (TEKES) and in part by the Commission of the European Communities under ESPRIT-II project 5365 VITAL. This paper reflects the opinions of the authors and not necessarily those of the consortium.
References-found: 21

