URL: ftp://ftp.irisa.fr/local/lande/taxo015.ps.Z
Refering-URL: http://www.irisa.fr/lande/fradet/Fradet.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: [douence,fradet]@irisa.fr  
Title: Towards a Taxonomy of Functional Language Implementations Rmi Douence Pascal Fradet  
Author: INRIA/IRISA 
Address: 35042 Rennes Cedex, France  
Affiliation: Campus de Beaulieu,  
Abstract: We express implementations of functional languages as a succession of program transformations in a common framework. At each step, different transformations model fundamental choices or optimizations. A benefit of this approach is to structure and decompose the implementation process. The correctness proofs can be tackled independently for each step and amount to proving program transformations in the functional world. It also paves the way to formal comparisons by estimating the complexity of individual transformations or compositions of them. We focus on call-by-value implementations, describe and compare the diverse alternatives and classify well-known abstract machines. This work also aims to open the design space of functional language implementations and we suggest how distinct choices could be mixed to yield efficient hybrid abstract machines.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press. </publisher> <year> 1992. </year>
Reference-contexts: A second solution uses a transformation Sl between the control and the abstraction phases. It transforms the expression into continuation passing style. The continuation encodes return addresses and will be then abstracted in the environment as any variable. This solution, known as stackless, is chosen in Appels ML compiler <ref> [1] </ref>. It prevents the use of a control stack but relies heavily on the garbage collector. Appel claims that it is simple, not inefficient and well suited to implement callcc. <p> The data stack is also (uselessly) saved in the dump. Actually, our replica is closer to the idealized version derived in [13]. The ZAM [19] uses a slightly different compilation of control than Vm and has an accumulator and registers. The SML-NJ compiler <ref> [1] </ref> uses only the heap which is represented in our framework by a unique environment e. It also includes registers and many optimizations not described here. The TABAC compiler is a by-product of our work in [12] and has greatly inspired this study.
Reference: [2] <author> A. Asperti. </author> <title> A categorical understanding of environment machines. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(1), </volume> <year> pp.23-59,1992. </year>
Reference-contexts: A few works explore the relationship between two abstract machines such as TIM and the G-Machine [4][25] and CMCM and TIM [21]. The goal is to show the equivalence between seemingly very different implementations. Also, let us mention Asperti <ref> [2] </ref> who provides a categorical understanding of the Krivine machine and an extended CAM. Our approach focuses on the description and comparison of fundamental options. The use of program transformations appeared to be suited to model precisely and completely the compilation process.
Reference: [3] <author> G. Argo. </author> <title> Improving the three instruction machine. </title> <booktitle> In Proc. of FPCA89, </booktitle> <pages> pp. 100-115, </pages> <year> 1989. </year>
Reference: [4] <author> G. Burn, S.L. Peyton Jones and J.D. Robson. </author> <booktitle> The spineless G-machine. In Proc. of LFP88, </booktitle> <pages> pp. 244-258, </pages> <year> 1988. </year>
Reference: [5] <author> G. Burn and D. Le Mtayer. </author> <title> Proving the correctness of compiler optimisations based on a global analysis. </title> <journal> Journal of Functional Programming, </journal> <note> 1995. (to appear). </note>
Reference-contexts: Strictness analysis can be taken into account in order to produce mixed evaluation strategies. In fact, the most interesting optimization brought by strictness information is not the change of the evaluation order but avoiding thunks using unboxing <ref> [5] </ref>.
Reference: [6] <author> L. Cardelli. </author> <title> Compiling a functional language. </title> <booktitle> In Proc. of LFP84, </booktitle> <pages> pp. 208-217, </pages> <year> 1984. </year>
Reference-contexts: Since the seminal proposal of Landin, 30 years ago [18], a plethora of new abstract machines or compilation techniques have been proposed. The list of existing abstract machines includes (but is surely not limited to) the SECD [18], the FAM <ref> [6] </ref>, the CAM [7], the CMCM [20], the TIM [10], the ZAM [19], the G-machine [15] and the Krivine-machine [8]. Other implementations are not described via an abstract machine but as a collection of transformations or compilation techniques such as CPS-based compilers [1][12][17]. <p> Ac2 [[push s E]] r = Copy r o push s (Copy r o Ac2 [[E]] r) o mkclos Ac2 [[x i ]] (((r,x i ),x i-1 ),x 0 ) = get i o appclos A third solution is to copy the environment only when building closures (as in <ref> [6] </ref>). In order to be able to add new bindings after closure opening, a local environment r L is needed. When a closure is built, the concatenation of the two environments (r G ++r L ) is copied. The code for variables now has to specify which environment is accessed.
Reference: [7] <author> G. Cousineau, P.-L. Curien and M. Mauny, </author> <title> The categorical abstract machine. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8(2), </volume> <pages> pp. 173-202, </pages> <year> 1987. </year>
Reference-contexts: Since the seminal proposal of Landin, 30 years ago [18], a plethora of new abstract machines or compilation techniques have been proposed. The list of existing abstract machines includes (but is surely not limited to) the SECD [18], the FAM [6], the CAM <ref> [7] </ref>, the CMCM [20], the TIM [10], the ZAM [19], the G-machine [15] and the Krivine-machine [8]. Other implementations are not described via an abstract machine but as a collection of transformations or compilation techniques such as CPS-based compilers [1][12][17].
Reference: [8] <author> P. </author> <month> Crgut. </month> <institution> Machines environnement pour la rduction symbolique et lvaluation par-tielle. Thse de luniversit de Paris VII, </institution> <year> 1991. </year>
Reference-contexts: The list of existing abstract machines includes (but is surely not limited to) the SECD [18], the FAM [6], the CAM [7], the CMCM [20], the TIM [10], the ZAM [19], the G-machine [15] and the Krivine-machine <ref> [8] </ref>. Other implementations are not described via an abstract machine but as a collection of transformations or compilation techniques such as CPS-based compilers [1][12][17]. Furthermore, numerous papers present optimizations often adapted to a specific abstract machine or a specific approach [3][4][16]. <p> So the corresponding links in the environment can be collapsed without any loss of sharing <ref> [8] </ref>. The list-like environment can become a vector locally and variable accesses have to be modified consequently.
Reference: [9] <author> R. Douence and P. Fradet. </author> <title> A taxonomy of functional language implementations. Part I: Call-by-Value, </title> <note> INRIA Research Report, 1995. (to appear) </note>
Reference-contexts: Property 1 If a closed expression E:Rs has a normal form, there exist V such that E * push s V Due to the lack of space we do not display proofs here and refer the interested reader to a companion paper <ref> [9] </ref>. The reduction should be done modulo associativity if we allow an unrestricted use of (assoc) which may produce ill-typed programs.
Reference: [10] <author> J. Fairbairn and S. Wray. Tim: </author> <title> a simple, lazy abstract machine to execute supercombina-tors. </title> <booktitle> In Proc of FPCA87, </booktitle> <volume> LNCS 274, </volume> <pages> pp. 34-45, </pages> <year> 1987. </year>
Reference-contexts: Since the seminal proposal of Landin, 30 years ago [18], a plethora of new abstract machines or compilation techniques have been proposed. The list of existing abstract machines includes (but is surely not limited to) the SECD [18], the FAM [6], the CAM [7], the CMCM [20], the TIM <ref> [10] </ref>, the ZAM [19], the G-machine [15] and the Krivine-machine [8]. Other implementations are not described via an abstract machine but as a collection of transformations or compilation techniques such as CPS-based compilers [1][12][17]. <p> A more radical dichotomy is explicit applies vs. marks. The first option is the standard technique (e.g. used in the SECD or CAM) while the second was hinted at in <ref> [10] </ref> and used in ZINC. 3.1 Compilation of control using apply Applications E 1 E 2 are compiled by evaluating the argument E 2 , the function E 1 and finally applying the result of E 1 to the result of E 2 . <p> The list-like environment can become a vector locally and variable accesses have to be modified consequently. Also, the combinator mkclos can be avoided by an abstraction which unfolds the pair (code,env) in the environment itself, as in TIM <ref> [10] </ref>. 4.2 Copied environments Another choice is to provide a constant access time [1][12]. In this case, the structure of the environment must be a vector of closures. Code which copies the environment (a O (length r) operation) has to be inserted in As in order to avoid links. <p> There are several abstractions according to the time of the copies. We present only the rules differing from As scheme. A first solution (Figure 6) is to copy the environment just before adding a new binding (as in <ref> [10] </ref>). From the first step we know that n-ary functions (l s x 1 .l s x n .E) are never partially applied and cannot be shared: they need only one copy of the environment. The overhead is placed on function entry and closure building remains a constant time operation. <p> As far as data structures are concerned we can again choose to treat them as closures or separately. A more interesting choice is whether we represent them using tags or higher-order functions <ref> [10] </ref>. V [[rec f (lx.E)]] = push s (rec s f (l s x. <p> The TABAC compiler is a by-product of our work in [12] and has greatly inspired this study. It implements strict or non-strict languages by program transformations. Compared to the description above the environments are unfolded in the environment/data stack. The call-by-name TIM <ref> [10] </ref> unfolds closures in the environment as mentioned in 4.1. The transformation Ac1 has the same effect as the preliminary lambda-lifting phase of TIM. 8 Towards Hybrid Implementations The study of the different options proved that there is no universal best choice.
Reference: [11] <author> M. J. Fischer. </author> <title> Lambda-calculus schemata. </title> <booktitle> In Proc. of the ACM Conf. on Proving Properties about Programs, Sigplan Notices, </booktitle> <volume> Vol. 7(1), </volume> <pages> pp. </pages> <year> 104-109,1972. </year>
Reference-contexts: Our first intermediate language L s bears strong similarities with CPS-expressions. Indeed, if we take combinator definitions (DEF1) (section 2.5) we naturally get Fischers CPS transformation <ref> [11] </ref> from Va f (section 3.1). On the other hand, our combinators are not fully defined (they just have to respect a few properties) and we avoid issues such as administrative reductions. We see L s as a powerful and more abstract framework than CPS to express different reduction strategies.
Reference: [12] <author> P. Fradet and D. Le Mtayer. </author> <title> Compilation of functional languages by program transformation. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 13(1), </volume> <pages> pp. 21-51, </pages> <year> 1991. </year>
Reference-contexts: builds a vector environment made of a specialized copy of the previous environment and two new bindings (bind 2 ) ; the x 1 access is now coded by get 1 . r A second solution (Figure 7) is to copy the environment when building and opening closures (as in <ref> [12] </ref>). The copy at opening time is necessary in order to be able to add new bindings in contiguous memory (the environment has to remain a vector). <p> For example, environments can be unfolded so that the environment stack becomes a closure stack <ref> [12] </ref>. This avoids an indirection and provides a direct access to values. 4.4 Comparison The size of the abstracted expressions gives a first approximation of the overhead entailed by the encoding of the b-reduction. <p> Actually, more general forms of unboxing and optimizations (as in [26]) could be expressed as well. 6.3 Call-by-need and graph reduction Call by need brings yet other options. The update mechanism can be implemented by self-updat-able closures (as in [24]), by modifying the continuation (as in <ref> [12] </ref>). Updating is also central in implementations based on graph reduction. Expressing redex sharing and updating is notoriously difficult. In our framework, a straightforward idea is to add a store component along with new combinators. Each expression takes and returns the store; the sequencing ensures that the store is single-threaded. <p> The SML-NJ compiler [1] uses only the heap which is represented in our framework by a unique environment e. It also includes registers and many optimizations not described here. The TABAC compiler is a by-product of our work in <ref> [12] </ref> and has greatly inspired this study. It implements strict or non-strict languages by program transformations. Compared to the description above the environments are unfolded in the environment/data stack. The call-by-name TIM [10] unfolds closures in the environment as mentioned in 4.1.
Reference: [13] <author> J. Hannan. </author> <title> From operational semantics to abstract machines. </title> <journal> Math. Struct. in Comp. Sci., </journal> <volume> 2(4), </volume> <pages> pp. 415-459, </pages> <year> 1992. </year>
Reference-contexts: The SECD machine [18] saves environments a bit later than in our scheme. Furthermore, the control stack and the environment stack are gathered in a component called dump. The data stack is also (uselessly) saved in the dump. Actually, our replica is closer to the idealized version derived in <ref> [13] </ref>. The ZAM [19] uses a slightly different compilation of control than Vm and has an accumulator and registers. The SML-NJ compiler [1] uses only the heap which is represented in our framework by a unique environment e. It also includes registers and many optimizations not described here. <p> On the other hand, we disallow unrestricted applications and L s -expressions are more general than merely combinations of [ ] and lets. Related work also includes the derivation of abstract machines from denotational [30] or operational semantics <ref> [13] </ref> [27]. Their goal is to provide a methodology to formally derive implementations for a (potentially large) class of programming languages. A few works explore the relationship between two abstract machines such as TIM and the G-Machine [4][25] and CMCM and TIM [21].
Reference: [14] <author> J. Hatcliff and O. Danvy. </author> <title> A generic account of continuation-passing styles. </title> <booktitle> In Proc. of POPL94, </booktitle> <pages> pp. 458-471, </pages> <year> 1994. </year>
Reference-contexts: We see L s as a powerful and more abstract framework than CPS to express different reduction strategies. As pointed out by Hatcliff & Danvy <ref> [14] </ref>, Moggis computational metalanguage [23] is also a more abstract alternative language to CPS. Arising from different roots, L s is surprisingly close to Moggis.
Reference: [15] <author> T. Johnsson. </author> <title> Compiling Lazy Functional Languages. </title> <type> PhD Thesis, </type> <institution> Chalmers University, </institution> <year> 1987. </year>
Reference-contexts: The list of existing abstract machines includes (but is surely not limited to) the SECD [18], the FAM [6], the CAM [7], the CMCM [20], the TIM [10], the ZAM [19], the G-machine <ref> [15] </ref> and the Krivine-machine [8]. Other implementations are not described via an abstract machine but as a collection of transformations or compilation techniques such as CPS-based compilers [1][12][17]. Furthermore, numerous papers present optimizations often adapted to a specific abstract machine or a specific approach [3][4][16].
Reference: [16] <author> M. S. Joy, V. J. Rayward-Smith and F. W. Burton. </author> <title> Efficient combinator code. </title> <journal> Computer Languages, </journal> <volume> 10(3), </volume> <year> 1985. </year>
Reference-contexts: These complexities highlight the main difference between shared environments that favors building, and copied environments that favors access. Let us point out that these bounds are related to the quadratic growth implied by Turners abstraction algorithm [29]. Balancing expressions reduces this upper bound to O (nlogn) <ref> [16] </ref>. It is very likely that this technique could also be applied to l-expressions to get a O (nlogn) complexity for environment man agement. The abstractions can be compared according to their memory usage too. Ac2 copies the environment for every closure, where Ac1 may share a bigger copy.
Reference: [17] <author> D. Kranz, R. Kesley, J. Rees, P. Hudak, J.Philbin, and N. Adams. </author> <title> ORBIT: An optimizing compiler for Scheme. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(7), pp.219-233, </volume> <year> 1986. </year>
Reference: [18] <author> P. J. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> The Computer Journal, </journal> <volume> 6(4), pp.308-320, </volume> <year> 1964. </year>
Reference-contexts: 1 Introduction One of the most studied issues concerning functional languages is their implementation. Since the seminal proposal of Landin, 30 years ago <ref> [18] </ref>, a plethora of new abstract machines or compilation techniques have been proposed. The list of existing abstract machines includes (but is surely not limited to) the SECD [18], the FAM [6], the CAM [7], the CMCM [20], the TIM [10], the ZAM [19], the G-machine [15] and the Krivine-machine [8]. <p> Since the seminal proposal of Landin, 30 years ago <ref> [18] </ref>, a plethora of new abstract machines or compilation techniques have been proposed. The list of existing abstract machines includes (but is surely not limited to) the SECD [18], the FAM [6], the CAM [7], the CMCM [20], the TIM [10], the ZAM [19], the G-machine [15] and the Krivine-machine [8]. Other implementations are not described via an abstract machine but as a collection of transformations or compilation techniques such as CPS-based compilers [1][12][17]. <p> The SECD machine <ref> [18] </ref> saves environments a bit later than in our scheme. Furthermore, the control stack and the environment stack are gathered in a component called dump. The data stack is also (uselessly) saved in the dump. Actually, our replica is closer to the idealized version derived in [13].
Reference: [19] <author> X. Leroy. </author> <title> The Zinc experiment: an economical implementation of the ML language. </title> <type> INRIA Technical Report 117, </type> <year> 1990. </year>
Reference-contexts: The list of existing abstract machines includes (but is surely not limited to) the SECD [18], the FAM [6], the CAM [7], the CMCM [20], the TIM [10], the ZAM <ref> [19] </ref>, the G-machine [15] and the Krivine-machine [8]. Other implementations are not described via an abstract machine but as a collection of transformations or compilation techniques such as CPS-based compilers [1][12][17]. Furthermore, numerous papers present optimizations often adapted to a specific abstract machine or a specific approach [3][4][16]. <p> Furthermore, the control stack and the environment stack are gathered in a component called dump. The data stack is also (uselessly) saved in the dump. Actually, our replica is closer to the idealized version derived in [13]. The ZAM <ref> [19] </ref> uses a slightly different compilation of control than Vm and has an accumulator and registers. The SML-NJ compiler [1] uses only the heap which is represented in our framework by a unique environment e. It also includes registers and many optimizations not described here.
Reference: [20] <author> R. D. Lins. </author> <title> Categorical multi-combinators. </title> <booktitle> In Proc. of FPCA87, </booktitle> <volume> LNCS 274, </volume> <pages> pp. 60-79, </pages> <year> 1987. </year>
Reference-contexts: Since the seminal proposal of Landin, 30 years ago [18], a plethora of new abstract machines or compilation techniques have been proposed. The list of existing abstract machines includes (but is surely not limited to) the SECD [18], the FAM [6], the CAM [7], the CMCM <ref> [20] </ref>, the TIM [10], the ZAM [19], the G-machine [15] and the Krivine-machine [8]. Other implementations are not described via an abstract machine but as a collection of transformations or compilation techniques such as CPS-based compilers [1][12][17].
Reference: [21] <author> R. Lins, S. Thompson and S.L. Peyton Jones. </author> <title> On the equivalence between CMC and TIM. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(1), </volume> <pages> pp. 47-63, </pages> <year> 1992. </year>
Reference-contexts: Their goal is to provide a methodology to formally derive implementations for a (potentially large) class of programming languages. A few works explore the relationship between two abstract machines such as TIM and the G-Machine [4][25] and CMCM and TIM <ref> [21] </ref>. The goal is to show the equivalence between seemingly very different implementations. Also, let us mention Asperti [2] who provides a categorical understanding of the Krivine machine and an extended CAM. Our approach focuses on the description and comparison of fundamental options.
Reference: [22] <author> E. Meijer and R. Paterson. </author> <title> Down with lambda lifting. </title> <note> copies available at: erik@cs.kun.nl, </note> <year> 1991. </year>
Reference-contexts: The compilation can then switch from one world to another. In particular, switching from As to Ac1 creates a kind of strict display (by comparison to the lazy display of <ref> [22] </ref>). As [[E]] r = List2Vect r o Ac1 [[E]] r Another solution uses environments mixing lists and vectors (as in [28]).
Reference: [23] <author> E. Moggi. </author> <title> Notions of computation and monads. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 55-92, </pages> <year> 1991. </year>
Reference-contexts: We see L s as a powerful and more abstract framework than CPS to express different reduction strategies. As pointed out by Hatcliff & Danvy [14], Moggis computational metalanguage <ref> [23] </ref> is also a more abstract alternative language to CPS. Arising from different roots, L s is surprisingly close to Moggis. <p> In particular, we may interpret the monadic constructs [E] as push E and (let x E 1 in E 2 ) as E 1 o l s x.E 2 and get back the monadic laws (let.b), (let.h) and (ass) <ref> [23] </ref>. On the other hand, we disallow unrestricted applications and L s -expressions are more general than merely combinations of [ ] and lets. Related work also includes the derivation of abstract machines from denotational [30] or operational semantics [13] [27].
Reference: [24] <author> S.L. Peyton Jones. </author> <title> Implementing lazy functional languages on stock hardware: </title> <journal> the spineless tagless G-machine. Journal of Functional Programming, </journal> <volume> 2(2) </volume> <pages> 127-202, </pages> <year> 1992. </year>
Reference-contexts: Actually, more general forms of unboxing and optimizations (as in [26]) could be expressed as well. 6.3 Call-by-need and graph reduction Call by need brings yet other options. The update mechanism can be implemented by self-updat-able closures (as in <ref> [24] </ref>), by modifying the continuation (as in [12]). Updating is also central in implementations based on graph reduction. Expressing redex sharing and updating is notoriously difficult. In our framework, a straightforward idea is to add a store component along with new combinators.
Reference: [25] <author> S. L. Peyton Jones and D. Lester. </author> <title> Implementing functional languages, a tutorial. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Ac2 copies the environment for every closure, where Ac1 may share a bigger copy. So, the code generated by Ac2 consumes more memory and implies frequent garbage collections whereas the code generated by Ac1 may create space leaks and needs special tricks to plug them (see <ref> [25] </ref> section 4.2.6). 5 Compilation To Machine Code In this section, we make explicit control transfers and propose combinator definitions. After these steps the functional expressions can be seen as realistic machine code. 5.1 Control transfers A conventional machine executes linear code where each instruction is basic.
Reference: [26] <author> S. L. Peyton Jones and J. Launchbury. </author> <title> Unboxed values as first class citizens in a non-strict functional language. </title> <booktitle> In Proc. of FPCA91, LNCS 523, </booktitle> <address> pp.636-666, </address> <year> 1991. </year>
Reference-contexts: With strictness annotations we have push s 2 o (l s x. push s x o push s 1 o plus s ) and the evaluation is the same as with call-by-value (no closure is built). Actually, more general forms of unboxing and optimizations (as in <ref> [26] </ref>) could be expressed as well. 6.3 Call-by-need and graph reduction Call by need brings yet other options. The update mechanism can be implemented by self-updat-able closures (as in [24]), by modifying the continuation (as in [12]). Updating is also central in implementations based on graph reduction.
Reference: [27] <author> P. Sestoft. </author> <title> Deriving a lazy abstract machine. </title> <type> Technical Report 1994-146, </type> <institution> Technical University of Denmark, </institution> <year> 1994. </year>
Reference-contexts: On the other hand, we disallow unrestricted applications and L s -expressions are more general than merely combinations of [ ] and lets. Related work also includes the derivation of abstract machines from denotational [30] or operational semantics [13] <ref> [27] </ref>. Their goal is to provide a methodology to formally derive implementations for a (potentially large) class of programming languages. A few works explore the relationship between two abstract machines such as TIM and the G-Machine [4][25] and CMCM and TIM [21].
Reference: [28] <author> Z. Shao and A. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In Proc. of LFP94, </booktitle> <pages> pp. </pages> <year> 150-161,1994. </year>
Reference-contexts: In particular, switching from As to Ac1 creates a kind of strict display (by comparison to the lazy display of [22]). As [[E]] r = List2Vect r o Ac1 [[E]] r Another solution uses environments mixing lists and vectors (as in <ref> [28] </ref>).
Reference: [29] <author> D.A. Turner. </author> <title> A new implementation technique for applicative languages. </title> <journal> Soft. Pract. and Exper., </journal> <volume> 9, </volume> <pages> pp. 31-49, </pages> <year> 1979. </year>
Reference-contexts: These complexities highlight the main difference between shared environments that favors building, and copied environments that favors access. Let us point out that these bounds are related to the quadratic growth implied by Turners abstraction algorithm <ref> [29] </ref>. Balancing expressions reduces this upper bound to O (nlogn) [16]. It is very likely that this technique could also be applied to l-expressions to get a O (nlogn) complexity for environment man agement. The abstractions can be compared according to their memory usage too.
Reference: [30] <author> M. Wand. </author> <title> Deriving target code as a representation of continuation semantics. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 4(3), </volume> <pages> pp. 496-517, </pages> <year> 1982. </year>
Reference-contexts: On the other hand, we disallow unrestricted applications and L s -expressions are more general than merely combinations of [ ] and lets. Related work also includes the derivation of abstract machines from denotational <ref> [30] </ref> or operational semantics [13] [27]. Their goal is to provide a methodology to formally derive implementations for a (potentially large) class of programming languages. A few works explore the relationship between two abstract machines such as TIM and the G-Machine [4][25] and CMCM and TIM [21].
References-found: 30

