URL: http://http.cs.berkeley.edu/~dgay/papers/masters.ps
Refering-URL: http://http.cs.berkeley.edu/~dgay/
Root-URL: 
Title: Barrier Inference  
Author: by David Gay 
Note: Professor A. Aiken Research Advisor (Date) Professor S. Graham Second Reader (Date) F30602-95-C-0136, and by a Microsoft Graduate Fellowship. The information presented here does not necessarily reflect the position or the policy of the Government and no official endorsement should be inferred.  
Abstract: Research Project Submitted to the Department of Electrical Engineering and Computer Sciences, University of California at Berkeley, in partial satisfaction of the requirements for the degree of Master of Science, Plan II. Approval for the Report and Comprehensive Examination: Committee: 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Joel Auslander, Matthai Philipose, Craig Chambers, Susan J. Eggers, and Brian N. Bershad. </author> <title> Fast, Effective Dynamic Compilation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 149-159, </pages> <address> Philadelphia, Pennsylvania, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: The following algorithm is similar to that of Auslander et al <ref> [1] </ref>, a binding-time analysis for C. Finding single-valued variables Outline: To find the single-valued variables of a function f : 1. Build the static, single-assignment (SSA) form [6] for function f. <p> Our implementation follows the guidelines outlined in Section 4.3 for supporting C, except that we have not yet implemented the analysis of data structures (which was only needed by one of the Split-C programs). The algorithm for inferring single-valued variables is similar to that used by Auslander et al <ref> [1] </ref>. Table 5.1 presents the programs and summarizes the results of the checking process. The second column counts the static occurrences of barriers in the program, while the third column reports the number of branches that controlled the execution of a barrier and whose condition was single-valued. <p> As mentioned in Section 4.3, inference of single-valued variables is similar to binding-time analysis [12]. The main difference is that we do not require that these values be directly computable from the initial set. Our single-valued variable inference algorithm is close to that presented by Auslander et al <ref> [1] </ref>. There is a difference in the handling of control-flow dependencies, and of course the purpose is unrelated.
Reference: [2] <author> D. Callahan and J. Subhlok. </author> <title> Static Analysis of Low-Level Synchronization. </title> <booktitle> In Proceedings of the ACM SIGPLAN and SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 100-111, </pages> <address> Madison, WI USA, [1] 1989. </address> <publisher> ACM Press , New York, </publisher> <address> NY , USA. </address> <booktitle> Published as SIGPLAN Notices, </booktitle> <volume> volume 24, number 1. </volume>
Reference-contexts: Helmbold and McDowell [9] and McDowell [19] include data values in the concurrency states, and discuss a number of techniques for reducing the number of nodes. A different approach is to determine which statements are executed before others, based on the synchronization statements. Callahan and Subhlok <ref> [2] </ref> and Callahan, Kennedy and Subhlok [3] compute an approximation of this relation and extend it with dependence distance information for loops. Masticola and Ryder [18] employ this information, along with other techniques, to compute a "can't happen together" relation for statements.
Reference: [3] <author> David Callahan, Ken Kennedy, and Jaspal Subhlok. </author> <title> Analysis of Event Synchronization in a Parallel Programming Tool. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 21-30, </pages> <address> Seattle WA, </address> <month> March </month> <year> 1990. </year> <month> 21 </month>
Reference-contexts: A different approach is to determine which statements are executed before others, based on the synchronization statements. Callahan and Subhlok [2] and Callahan, Kennedy and Subhlok <ref> [3] </ref> compute an approximation of this relation and extend it with dependence distance information for loops. Masticola and Ryder [18] employ this information, along with other techniques, to compute a "can't happen together" relation for statements.
Reference: [4] <author> Cray Research Incorporated. </author> <title> The CRAY T3D Hardware Reference Manual, </title> <year> 1993. </year>
Reference-contexts: Usually named barriers are implemented using a broadcast (so the names can be compared) which is much slower than special-purpose barrier hardware (e.g., on the CM5 [17] and T3D <ref> [4] </ref>). But L already effectively has two barrier names: barrier and broadcast. Adding more names increases the alphabet of synchronization strings but has no impact on inference complexity. Our system thus allows named barriers to be checked at compile-time, allowing their implementation with the more efficient anonymous barriers.
Reference: [5] <author> David E. Culler, Andrea Dusseau, Seth Copen Goldstein, Arvind Krishnamurthy, Steven Lumetta, Thorsten von Eicken, and Katherine Yelick. </author> <title> Introduction to Split-C. </title> <institution> University of California, Berkeley, </institution> <year> 1993. </year>
Reference-contexts: Our system was developed in the context of a distributed memory, shared address space programming language (Split-C, an SPMD language developed at Berkeley <ref> [5] </ref>), but we found it equally applicable to checking the synchronization structure of shared memory, shared address space parallel programs; our method can show the synchronization correctness of the SPLASH-2 [25] benchmarks. <p> Finally, all variables declared single must be initialised by single values, to guarantee that such variables are initially consistent across processes. 5 Experiments We implemented a prototype of our inference system for Split-C <ref> [5] </ref>, an explicitly parallel extension to C. We tested our prototype on Split-C kernels and applications.
Reference: [6] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently Computing Static Single Assignment Form and the Control Dependence Graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The following algorithm is similar to that of Auslander et al [1], a binding-time analysis for C. Finding single-valued variables Outline: To find the single-valued variables of a function f : 1. Build the static, single-assignment (SSA) form <ref> [6] </ref> for function f. This has two advantages: (a) Each SSA variable is either single-valued or not. (b) The points where different values of variables merge are explicit. 2. Build the branch dependences for each statement, i.e. the list of branch outcomes that determine whether a statement is executed.
Reference: [7] <author> D. Gifford, P. Jouvelot, J. Lucassen, and M. Sheldon. </author> <title> FX-87 REFERENCE MANUAL. </title> <type> Technical Report MIT-LCS//MIT/LCS/TR-407, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> Sep-tember </month> <year> 1987. </year>
Reference-contexts: Our single-valued variable inference algorithm is close to that presented by Auslander et al [1]. There is a difference in the handling of control-flow dependencies, and of course the purpose is unrelated. Barrier Inference is an example of an effect system <ref> [7] </ref>, where the effects are synchronization sequences and the type of a variable represents its single-valuedness. 7 Conclusion We have identified an important property of SPMD programs that current languages do not explicitly support: The portion of control and data flow governing global synchronization is identical across all the processes.
Reference: [8] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: The synchronization kernel is sufficiently important that it should be explicitly visible in source code. We propose language features that make SPMD programs clearer and easier to check. We are integrating these language extensions into Titanium, a successor of Split-C based on Java <ref> [8] </ref>. This requires extending the application of the single-valued concept to more complex data structures, including references and objects, and handling language features such as exception handling.
Reference: [9] <author> David P. Helmbold and Charles E. McDowell. </author> <title> Computing Reachable States of Parallel Programs. </title> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, published in ACM SIGPLAN Notices, </booktitle> <volume> 26(12) </volume> <pages> 76-84, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Taylor [22] considers only control-flow and the resulting graph can be exponential in the number of tasks. Young and Taylor [26] attempt to increase the precision of the concurrency graph by employing symbolic execution. Helmbold and McDowell <ref> [9] </ref> and McDowell [19] include data values in the concurrency states, and discuss a number of techniques for reducing the number of nodes. A different approach is to determine which statements are executed before others, based on the synchronization statements.
Reference: [10] <author> T. Jeremiassen and S. Eggers. </author> <title> Computing Per-Process Summary Side-Effect Information. </title> <booktitle> In Proceedings of the 5th International Workshop on Languages and Compilers for Parallel Computing, number 757 in Lecture Notes in Computer Science, </booktitle> <pages> pages 175-191, </pages> <address> New Haven, Connecticut, </address> <month> August 3-5, </month> <title> 1992. </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: They do not attempt to verify the correctness of the synchronization. Their analysis relies on named barriers for precision and does not consider single-valued variables, though they do consider dependencies on multi-valued constants like pid <ref> [10] </ref>. A number of papers analyse 2-way synchronization, such as post/wait or the accept/call mechanism of Ada, between 20 explicitly specified tasks. As each task is specified with different code, there is no real analogue of single-valued variables.
Reference: [11] <author> Tor E. Jeremiassen and Susan J. Eggers. </author> <title> Static Analysis of Barrier Synchronization in Explicitly Parallel Systems. </title> <editor> In Michel Cosnard, Guang R. Gao, and Gabriel M. Silberman, editors, </editor> <booktitle> Proceedings of the IFIP WG 10.3 Working Conference on Parallel Architectures and Compilation Techniques, PACT '94, </booktitle> <pages> pages 171-180, </pages> <address> Montreal, Quebec, </address> <month> August 24-26, </month> <title> 1994. </title> <publisher> North-Holland Publishing Co. </publisher>
Reference-contexts: The programming model is also very different. Analysis of the synchronization of parallel programs has been extensively studied for the purposes of deadlock and data-race detection as well as for optimisation. Our survey of this work is necessarily partial, and covers only static techniques. Jeremiassen and Eggers <ref> [11] </ref> analyse barrier synchronization for SPMD programs to improve the precision of optimi-sation. They do not attempt to verify the correctness of the synchronization. Their analysis relies on named barriers for precision and does not consider single-valued variables, though they do consider dependencies on multi-valued constants like pid [10].
Reference: [12] <author> Neil D. Jones, Carsten K. Gomard, and Peter Sestoff. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice-Hall, </publisher> <year> 1993. </year>
Reference-contexts: The problem can be divided into three parts: finding the single-valued variables, computing the synchronization sequence of a function, and verifying multi-valued branches do not cause synchronization problems. The inference of single-valued variables is very similar to the problem of binding-time analysis in partial evaluation <ref> [12] </ref>: Given a set of variables whose value is assumed known (or single-valued in our case), determine which expressions and variables have a value that depends solely on these variables. The following algorithm is similar to that of Auslander et al [1], a binding-time analysis for C. <p> Masticola and Ryder [18] employ this information, along with other techniques, to compute a "can't happen together" relation for statements. As mentioned in Section 4.3, inference of single-valued variables is similar to binding-time analysis <ref> [12] </ref>. The main difference is that we do not require that these values be directly computable from the initial set. Our single-valued variable inference algorithm is close to that presented by Auslander et al [1].
Reference: [13] <author> A. Krishnamurthy, D. E. Culler, A. Dusseau, S. C. Goldstein, S. Lumetta, T. von Eicken, and K. Yelick. </author> <title> Parallel Programming in Split-C. </title> <booktitle> In Proceedings of the Supercomputing '93 Conference, </booktitle> <pages> pages 262-273, </pages> <address> Portland, OR, November 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Applications: * wator: Simulation of particle-like fish under current. * nbody: A simple n body simulation code. * em3d: 3-dimensional electro-magnetic simulation, described in <ref> [13] </ref>. * barnes: Simulate the interaction of a system of n bodies using the Barnes-Hut hierarchical method. Table 1: Results of checking Split-C programs These results show that our system is successful in verifying existing Split-C applications, with few changes and annotations.
Reference: [14] <author> Arvind Krishnamurthy and Katherine Yelick. </author> <title> Optimizing Parallel Programs with Explicit Synchronization. </title> <booktitle> In ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 196-204, </pages> <address> New York, NY, USA, June 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: We are also working on an algorithm that uses the results of our inference system to represent the portions of the code that may be executing simultaneously so that SPMD optimisations, such as those proposed by Krishnamuthy and Yelick <ref> [14] </ref>, may be more precise.
Reference: [15] <author> William Landi and Barbara G. Ryder. </author> <title> A Safe Approximate Algorithm for Interprocedural Pointer Aliasing. </title> <booktitle> In ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: If syncseq (b) = f then branch b is invalid. 4.3.2 Other Language Features The other language features mentioned above do not require such complex changes. In the presence of pointer values, detecting single-valued variables can require alias analysis, a well-known hard problem <ref> [15] </ref>. We have found that very conservative assumptions suffice in practice (see Section 5.1): a variable whose address is taken is multi-valued; any pointer dereference is multi-valued.
Reference: [16] <author> D. H. Lawrie, T. Layman, D. Baer, and J. M. Randal. </author> <title> Glypnir A Programming Language for Illiac IV. </title> <journal> Communications of the ACM, </journal> <volume> 18(3) </volume> <pages> 157-164, </pages> <month> March </month> <year> 1975. </year>
Reference-contexts: Control unit variables resemble our single-valued variables: they are variables that have only one value. Unlike single-valued variables, control unit variables are stored in only one location. Control unit variables are declared with a CU keyword in the Illiac IV programming language Glypnir <ref> [16] </ref>. The Connection Machine language C* [23] calls these variables scalar. There is no equivalent of our inference system for these languages, as the properties we are inferring are guaranteed by SIMD semantics. Our proposed single keyword provides similar advantages for SPMD languages.
Reference: [17] <author> C. E. Leiserson, Z. S. Abuhamdeh, D. C. Douglas, C. R. Feynman, M. N. Ganmukhi, J. V. Hill, W. D. Hillis, B. C. Kuszmaul, M. A. St. Pierre, D. S. Wells, M. C. Wong, S. Yang, and R. Zak. </author> <title> The Network Architecture of the CM-5. </title> <booktitle> In Symposium on Parallel and Distributed Algorithms '92, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Usually named barriers are implemented using a broadcast (so the names can be compared) which is much slower than special-purpose barrier hardware (e.g., on the CM5 <ref> [17] </ref> and T3D [4]). But L already effectively has two barrier names: barrier and broadcast. Adding more names increases the alphabet of synchronization strings but has no impact on inference complexity.
Reference: [18] <author> S. P. Masticola and B. G. Ryder. </author> <title> Non-concurrency Analysis. </title> <booktitle> In Fourth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 129-138, </pages> <address> New York, NY, USA, July 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: A different approach is to determine which statements are executed before others, based on the synchronization statements. Callahan and Subhlok [2] and Callahan, Kennedy and Subhlok [3] compute an approximation of this relation and extend it with dependence distance information for loops. Masticola and Ryder <ref> [18] </ref> employ this information, along with other techniques, to compute a "can't happen together" relation for statements. As mentioned in Section 4.3, inference of single-valued variables is similar to binding-time analysis [12].
Reference: [19] <author> C. E. McDowell. </author> <title> A Practical Algorithm for Static Analysis of Parallel Programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 6(3) </volume> <pages> 515-536, </pages> <month> [6] </month> <year> 1989. </year> <month> 22 </month>
Reference-contexts: Taylor [22] considers only control-flow and the resulting graph can be exponential in the number of tasks. Young and Taylor [26] attempt to increase the precision of the concurrency graph by employing symbolic execution. Helmbold and McDowell [9] and McDowell <ref> [19] </ref> include data values in the concurrency states, and discuss a number of techniques for reducing the number of nodes. A different approach is to determine which statements are executed before others, based on the synchronization statements.
Reference: [20] <author> Message Passing Interface Forum. </author> <title> Document for a standard message-passing interface. </title> <type> Technical report, </type> <institution> University of Tennessee, Knoxville, Tenn., </institution> <year> 1993. </year>
Reference-contexts: We expect a similar result should hold for pure message passing programs as well, but such programs may not rely on global synchronization to the same degree as programs written using a shared address space. Note, however, that standard message passing libraries such as MPI <ref> [20] </ref> include global synchronization primitives. 1.1 Global Synchronization A simple and popular parallel programming model is SPMD (for Single Program, Multiple Data). SPMD programs are explicitly-parallel programs written in sequential languages extended with communication and synchronization primitives.
Reference: [21] <author> M. A. Nichols, H. J. Siegel, and H. G. Dietz. </author> <title> Data Management and Control-Flow Aspects of an SIMD/SPMD Parallel Language/Compiler. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4(2) </volume> <pages> 222-234, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: The Connection Machine language C* [23] calls these variables scalar. There is no equivalent of our inference system for these languages, as the properties we are inferring are guaranteed by SIMD semantics. Our proposed single keyword provides similar advantages for SPMD languages. The ELP language <ref> [21] </ref> [24], a joint SIMD/SPMD programming language where both "modes" have the same semantics, allows declaration of single-valued variables with a mono keyword.
Reference: [22] <author> Richard N. Taylor. </author> <title> A General-Purpose Algorithm for Analyzing Concurrent Programs. </title> <journal> Communications of the ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: None of the following papers present exact solutions for more general situations. One technique is to build a concurrency graph where nodes represent parallel program states, and edges represent synchronization or other state modifications. Taylor <ref> [22] </ref> considers only control-flow and the resulting graph can be exponential in the number of tasks. Young and Taylor [26] attempt to increase the precision of the concurrency graph by employing symbolic execution.
Reference: [23] <institution> Thinking Machines Corporation. C fl Programming Guide, </institution> <year> 1993. </year>
Reference-contexts: Control unit variables resemble our single-valued variables: they are variables that have only one value. Unlike single-valued variables, control unit variables are stored in only one location. Control unit variables are declared with a CU keyword in the Illiac IV programming language Glypnir [16]. The Connection Machine language C* <ref> [23] </ref> calls these variables scalar. There is no equivalent of our inference system for these languages, as the properties we are inferring are guaranteed by SIMD semantics. Our proposed single keyword provides similar advantages for SPMD languages.
Reference: [24] <author> Lee Wang. </author> <title> ELP User's Manual. Parallel Processing Laboratory, </title> <institution> School of Electrical and Computer Engineering, Purdue University, </institution> <month> March </month> <year> 1996. </year>
Reference-contexts: The Connection Machine language C* [23] calls these variables scalar. There is no equivalent of our inference system for these languages, as the properties we are inferring are guaranteed by SIMD semantics. Our proposed single keyword provides similar advantages for SPMD languages. The ELP language [21] <ref> [24] </ref>, a joint SIMD/SPMD programming language where both "modes" have the same semantics, allows declaration of single-valued variables with a mono keyword.
Reference: [25] <author> Steven Cameron Woo, Moriyoshi Ohara, Evan Torrie, Jaswinder Pal Shingh, and Anoop Gupta. </author> <title> The SPLASH-2 Programs: Characterization and Methodological Considerations. </title> <booktitle> In Proceedings of the 22nd Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 24-36, </pages> <address> Santa Margherita Ligure, Italy, </address> <month> June 22-24, </month> <year> 1995. </year> <journal> ACM SIGARCH and IEEE Computer Society TCCA. Computer Architecture News, </journal> <volume> 23(2), </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: developed in the context of a distributed memory, shared address space programming language (Split-C, an SPMD language developed at Berkeley [5]), but we found it equally applicable to checking the synchronization structure of shared memory, shared address space parallel programs; our method can show the synchronization correctness of the SPLASH-2 <ref> [25] </ref> benchmarks. We expect a similar result should hold for pure message passing programs as well, but such programs may not rely on global synchronization to the same degree as programs written using a shared address space. <p> Experience with our implementation is positive; the system successfully checks the benchmarks with a few minor modifications to the programs, including one to correct a bug detected by our system. We have also examined the Splash-2 benchmarks <ref> [25] </ref> by hand and found that all but one can be checked with our system (Section 5.2). <p> (the times, measured on an HP 715/80, represent the time spent in our system, they do not include the time to build the standard SSA representation used by our prototype). 5.2 The SPLASH-2 Benchmarks As a further validation of our approach, we examined the synchronization structure of the SPLASH-2 benchmarks <ref> [25] </ref>, which are written in C extended with macros for writing parallel programs. The facilities provided by the macros include named barrier synchronization.
Reference: [26] <author> M. Young and R. N. Taylor. </author> <title> Combining Static Concurrency Analysis with Symbolic Execution. </title> <booktitle> In Proceedings Workshop on Software Testing, </booktitle> <pages> pages 10-18, </pages> <year> 1986. </year> <month> 23 </month>
Reference-contexts: One technique is to build a concurrency graph where nodes represent parallel program states, and edges represent synchronization or other state modifications. Taylor [22] considers only control-flow and the resulting graph can be exponential in the number of tasks. Young and Taylor <ref> [26] </ref> attempt to increase the precision of the concurrency graph by employing symbolic execution. Helmbold and McDowell [9] and McDowell [19] include data values in the concurrency states, and discuss a number of techniques for reducing the number of nodes.
References-found: 26

