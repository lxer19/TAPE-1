URL: http://www.it.kth.se/docs/Reports/se/boiler.ps.Z
Refering-URL: http://www.it.kth.se/docs/Reports/se/
Root-URL: http://www.it.kth.se
Email: tyugu]@it.kth.se  
Title: STRUCTURAL SYNTHESIS OF PROGRAMS FROM REFINED USER REQUIREMENTS (Programming boiler control in NUT)  
Author: M. Addibpour, E. Tyugu [mattin, 
Note: 1.0 Introduction  
Address: Electrum-204 KTH, 164 40 Kista, Sweden  
Affiliation: Department of Teleinformatics, Royal Institute of Technology  
Abstract: The aim of this work is to demonstrate the feasibility of using a declarative language as a tool for automated implementation of requirements written in a semiformal manner. The technique of structural synthesis of programs based on automatic proof search in intuitionistic propositional calculus implemented in the NUT system is used for solving the steam-boiler problem. The goal of the experiment is to bridge a gap between the language of requirements and an implementation. An appropriate set of concepts is developed for representing the problem, i.e. writing the requirements in a form understandable by the program synthesis tools. A complete implementation, including simulator of the actual steam-boiler and control panel, is written in NUT. This paper concerns automatic application of formal methods in implementation of industrial control systems. The idea is to use an extensible very high level language, extending it with a set of concepts sufficient for writing requirements specifications in a form close to a selected formal specification language. It is assumed that the specifications are already refined and verified, so we have to take only the responsibility for the correctness of the implementation. We considered the TLT specification language as a possible candidate for the requirements specification language, but have decided to take the specification directly as it has been presented in [Abr94, ABL95], although several other candidates (TLT [CW95], Z [BHW95]) were also possible. For solving the problem, a technique of deductive synthesis of programs based on automatic proof search in intuitionistic propositional calculus, implemented in the NUT system, has been used [Tyu94]. In the NUT system, an appropriate set of concepts represented as classes has to be developed for each kind of problems. The concepts for simulating the steam-boiler and programming a boiler model are: device, boiler, pump, pump controller, level meter, ow meter, etc. These concepts are represented as sets of equations taken directly from the requirements specification. Another set of concepts is required for implementing a control algorithm: propositions, rules and actions. The control algorithm is represented as a collection of rules written as relations in NUT. The rules are triggered by conjuctions of propositions describing a state of the system at an observable time moment. Also these rules are derived directly from the requirements specification after introducing a proper collection of propositions and predicates which are implicitly present in the text of requirements. With the present experiment, we demonstrate that the presentation of requirements as given in the steam-boiler example, enables us to extract rules immediately from the requirements text. 
Abstract-found: 1
Intro-found: 1
Reference: [Abr94] <author> J. -R. </author> <title> Abrial, Steam-boiler control specification problem. A problem suggestion for the Dagstuhl Meeting on Methodes for semantic and specification, </title> <month> August, </month> <year> 1994. </year>
Reference-contexts: We considered the TLT specification language as a possible candidate for the requirements specification language, but have decided to take the specification directly as it has been presented in <ref> [Abr94, ABL95] </ref>, although several other candidates (TLT [CW95], Z [BHW95]) were also possible. For solving the problem, a technique of deductive synthesis of programs based on automatic proof search in intuitionistic propositional calculus, implemented in the NUT system, has been used [Tyu94]. <p> This technique has been used earlier, in particular, for protocol simulation in NUT [Pen94]. As we were concerned with the method of implementation and not with the completeness of given initial specification, we took the specification as given in <ref> [Abr94, ABL95] </ref>, including the assumptions about the fixed time cycle and the transmission system. 2.0 Theory and tools 2.1 Structural synthesis of programs We are using a completely automatic deductive program synthesis as an implementation technique of semantics of specifications. <p> The Analyser can detect failures in pumps, pump controllers, level measuring unit and steam measuring unit, according to section 7 of <ref> [Abr94] </ref>. <p> The Analyser detects failures in the physical units. This is a direct implementation of section 7 of <ref> [Abr94] </ref>. The Analyser detects erroneous behaviour of physical units by observing the messages sent to the program and by saving and comparing them with previous states of the System. The failure detection messages are directly passed to the Actions. Below, we see the class specification of the Analyser. <p> Here we present the complete specification for analysing the water level and water-level-measuring-unit, steam level and steam-level-measuring-unit and also the external STOP message causing the program to enter emergency stop. Note that the text written in Courier is directly copied from requirements specification given in <ref> [Abr94] </ref>. <p> STOP, current_time, last_stop_time, stop_counter, Dt -&gt; STOP_DECISION -if current_time-last_stop_time ==Dt & stop_counter==3-&gt;STOP_DECISION:=true; || current_time-last_stop_time ==Dt -&gt;stop _counter:= stop_counter + 1; || true -&gt; last_stop_time:=current_time; stop _counter:= 1;- 4.3 Rules The overall behaviour of the control program, more specifically, the interpretation of section 4 of <ref> [Abr94] </ref>, is specified by a collection of rules. These rules are written directly in NUT, and are fired by performing the compute command repeatedly until a special rule fires notifying that no other rule can be fired. <p> Separating outgoing messages from the Rules plays the same role in the output interface. In the following, we see that section 4 of <ref> [Abr94] </ref> has been implemented by a set of rules directly taken from the requirements specification text and has been written almost sentence by sentence from the text. One can follow the axioms and compare them directly with the requirements specification. <p> The former represents only purely physical behaviour of the boiler. The latter contains also relations for making predictions about the behaviour of the boiler in the case of uncertainty about the correctness of signals. Boiler parameters. Both boiler models inherit specifications of variables representing boiler parameters according to <ref> [Abr94] </ref>.
Reference: [ABL95] <editor> J. -R. Abrial, E. Brger, H. Langmaack, </editor> <title> Additional Information Concerning the Physical Behaviour of the Steam Boiler. </title> <booktitle> For the Dagstuhl Meeting, </booktitle> <year> 1995. </year>
Reference-contexts: We considered the TLT specification language as a possible candidate for the requirements specification language, but have decided to take the specification directly as it has been presented in <ref> [Abr94, ABL95] </ref>, although several other candidates (TLT [CW95], Z [BHW95]) were also possible. For solving the problem, a technique of deductive synthesis of programs based on automatic proof search in intuitionistic propositional calculus, implemented in the NUT system, has been used [Tyu94]. <p> This technique has been used earlier, in particular, for protocol simulation in NUT [Pen94]. As we were concerned with the method of implementation and not with the completeness of given initial specification, we took the specification as given in <ref> [Abr94, ABL95] </ref>, including the assumptions about the fixed time cycle and the transmission system. 2.0 Theory and tools 2.1 Structural synthesis of programs We are using a completely automatic deductive program synthesis as an implementation technique of semantics of specifications. <p> LEVEL into the following internal propositions: STEAM_ZERO, STEAM_NOT_ZERO, LEVEL_N1 (level&lt;N1), LEVEL_N2 (N2&lt;level), LEVEL_M1 (level&lt;M1), LEVEL_M2 (level&gt;M2), LEVEL_N12 (N1&lt;level&lt;N2). (either true or nil) 11 The Analyser generates the following propositions on the basis of the information obtained from the SysModel, these propositions are used in the rescue mode of oper ation <ref> [ABL95] </ref>: LEVEL_CASE12 (case 1 and 2), LEVEL_CASE3 (case 3: shutdown decision), LEVEL_CASE4 (case 4: do nothing), LEVEL_CASE56 (case 5 and 6). (either true or nil) The Actions informs also other parts of the Controller about opening or closing pumps by means of messages which are sent to the pumps: OPEN_PUMPS. (array <p> -&gt;LEVEL_N1:=true; || LEVEL &gt; BoilerPar.N2 ->LEVEL_N2:=true; || LEVEL &gt; 0 & LEVEL &lt;BoilerPar.C ->LEVEL_N12:=true fi-; and if the water level measuring unit is defective, then the water level is estimated by the SysModel and the following four cases are decided which is used in the rescue mode as written in <ref> [ABL95] </ref>: LEVEL_FAIL, SysModel.qa1, SysModel.qa2 -&gt; LEVEL_CASE_12, LEVEL_CASE_3, , LEVEL_CASE_4, LEVEL_CASE_56 -if (SysModel.qa1&lt; BoilerPar.N1 & SysModel.qa2 < BoilerPar.N2) -&gt; LEVEL_CASE_12:=true || (SysModel.qa1&lt; BoilerPar.N1 & SysModel.qa2 &gt; BoilerPar.N2 & (SysModel.qa1&lt;=BoilerPar.M1 | SysModel.qa2&gt;=BoilerPar.M2 | SysModel.qc1&lt;=BoilerPar.M1 | SysModel.qc2&gt;=BoilerPar.M2)) -&gt; LEVEL_CASE_3:=true || (SysModel.qa1 &gt; BoilerPar.N1 & SysModel.qa2 > BoilerPar.N2) -&gt; LEVEL_CASE_56:=true || true -&gt; LEVEL_CASE_4 :=true <p> p_state: num; % (0-&gt;off, 1->on but not started, 2->on) C: num; % if pump is broken or still not long enough on then 0, else 1 22 D: num; % if pump is not broken or on then 1 else 0 init p_state:=0; Class PumpMod is implemented as described in <ref> [ABL95] </ref> and has the following speci fication: class PumpMod super Pump; var p1, p2: num; % min and max throughputs [l/sec] rel OK := ~Controller.PUMP_FAIL [id]; pc1 = (1-C)*P; p_state, OK , Control.OK-&gt; C, D -if ~OK | ~Controler.OK | p_state==1 | p_state==0 -&gt; C := 1; || true -> C:=0;
Reference: [BHW95] <author> R. Bssow, M. Heisel, M. Weber. </author> <title> A Steam-Boiler Control Specification with Statecharts and Z. </title> <booktitle> In the Dagstuhl Meeting, </booktitle> <year> 1995. </year>
Reference-contexts: We considered the TLT specification language as a possible candidate for the requirements specification language, but have decided to take the specification directly as it has been presented in [Abr94, ABL95], although several other candidates (TLT [CW95], Z <ref> [BHW95] </ref>) were also possible. For solving the problem, a technique of deductive synthesis of programs based on automatic proof search in intuitionistic propositional calculus, implemented in the NUT system, has been used [Tyu94].
Reference: [CW95] <author> J. Cuellar, I. Wildgruber. </author> <title> The Dagstuhl Steam Boiler Controller Problem, The TLT Solution. </title> <booktitle> In the Dagstuhl Meeting, </booktitle> <year> 1995. </year>
Reference-contexts: We considered the TLT specification language as a possible candidate for the requirements specification language, but have decided to take the specification directly as it has been presented in [Abr94, ABL95], although several other candidates (TLT <ref> [CW95] </ref>, Z [BHW95]) were also possible. For solving the problem, a technique of deductive synthesis of programs based on automatic proof search in intuitionistic propositional calculus, implemented in the NUT system, has been used [Tyu94].
Reference: [MT82] <author> Mints, E. Tyugu. </author> <title> Justification of the structural synthesis of programs. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> vol. 2, No.3, </volume> <pages> pp. 215 - 240, </pages> <year> 1982. </year>
Reference-contexts: We have chosen a restricted fragment of the intuitionistic propositional calculus (IPC) which is still universal with respect to the whole IPC. Transformation of an arbitrary formula of IPC into the fragment we use has been described in <ref> [MT82] </ref>. We use this logical language, hidden from the user, only for internal representation of specifications. We call our method structural synthesis of programs (SSP). The SSP can be explained in terms of lambda calculus or type theory as well. <p> The relations between different representations of the SSP are shown in figure 1. The equivalences shown in the figure can be proved according to Curry-Howard correspondence between intuitionistic logic and typed lambda calculus. An interested reader can find the theory of SSP in <ref> [MT82, Uus95] </ref>. FIGURE 1.
Reference: [Pen94] <author> J. Penjam. </author> <title> Attributed automata: A formal model for protocol specification. </title> <address> TRITA-IT-R 94:30, CSLab, Teleinformatics/KTH, </address> <year> 1994. </year>
Reference-contexts: This technique has been used earlier, in particular, for protocol simulation in NUT <ref> [Pen94] </ref>.
Reference: [Tyu94] <author> E. Tyugu. </author> <title> Using classes as specifications for automatic construction of pro grams in the NUT system. </title> <journal> Journal of Automated Software Engineering, v. </journal> <volume> 1, </volume> <year> 1994, </year> <pages> 315 - 334. </pages>
Reference-contexts: For solving the problem, a technique of deductive synthesis of programs based on automatic proof search in intuitionistic propositional calculus, implemented in the NUT system, has been used <ref> [Tyu94] </ref>. In the NUT system, an appropriate set of concepts represented as classes has to be developed for each kind of problems. The concepts for simulating the steam-boiler and programming a boiler model are: device, boiler, pump, pump controller, level meter, ow meter, etc.
Reference: [Uus95] <author> T. Uustalu, </author> <title> Aspects of Structural Synthesis of Programs. </title> <booktitle> Licentiate Thesis TRITA-IT-R 95:09, </booktitle> <address> CSLab, Teleinformatics/KTH, </address> <year> 1995. </year> <month> 25 </month>
Reference-contexts: The relations between different representations of the SSP are shown in figure 1. The equivalences shown in the figure can be proved according to Curry-Howard correspondence between intuitionistic logic and typed lambda calculus. An interested reader can find the theory of SSP in <ref> [MT82, Uus95] </ref>. FIGURE 1.
References-found: 8

