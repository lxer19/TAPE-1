URL: http://ptolemy.eecs.berkeley.edu/papers/96/visualizing/visualizing.ps
Refering-URL: http://ptolemy.eecs.berkeley.edu/papers/96/visualizing/
Root-URL: 
Title: Visualizing Architecture and Algorithm Interaction in Embedded Systems  
Author: E.A. Lee 
Note: Research Project Submitted to the  Plan II. Professor  Second Reader Date  
Address: Berkeley, California  
Affiliation: Department of Electrical Engineering and Computer Sciences University of California  Department of Electrical Engineering and Computer Sciences, University of California, Berkeley,  Research  
Pubnum: Memorandum UCB/ERL M96/50 Farhana Sheikh  
Phone: 94720  
Degree: in partial satisfaction of the requirements for the degree of Master of Science in Engineering,  Advisor Date Professor T. Henzinger  
Date: September 13, 1996  
Abstract: Approval for the Report and Comprehensive Examination: Committee: 
Abstract-found: 1
Intro-found: 1
Reference: <institution> 47 of 48 8 References </institution>
Reference: [1] <author> M. Abrams, N. Doraswamy, and A. Mathur, Chitra: </author> <title> Visual Analysis of Parallel and Distributed Programs in the Time, Event, and Frequency Domains, </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> Vol. 3, No. 6, </volume> <month> November </month> <year> 1992, </year> <note> pp.672 - 685. </note>
Reference-contexts: From this a user can create a trace file which like a schedule file can be displayed in graphical form. Visual representation of execution behaviour can reveal critical paths and help determine execution patterns <ref> [1] </ref>. Much like an oscilloscope records the evolution of a signal over time, the execution trace tracks system behaviour over time. It keeps a record of what tasks were executed, when they were executed, and how long they took to complete.
Reference: [2] <author> M. A. Bayoumi (ed.), </author> <title> VLSI Design Methodologies For Digital Signal Processing Architectures, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> USA, </address> <year> 1994. </year>
Reference: [3] <author> S. S. Battacharyya, P. K. Murthy, E. A. Lee, </author> <title> Software Synthesis From Dataow Graphs, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> USA, </address> <year> 1996. </year>
Reference-contexts: Looped Schedule A looped schedule is one which may contain any number of schedule loops. A schedule loop consists of m number of actors or functional blocks that are repeated in succession n times. Loops in a looped schedule may be nested <ref> [3] </ref>. Clustering For each node in a SDF graph, there are q corresponding nodes in an APEG. The number q represents how many times the SDF node must be invoked in order to satisfy data precedences in the SDF graph. <p> Buffers and Buffering Each edge in a SDF graph corresponds to first-in-first-out queue that buffers tokens that pass along the edge. The queue is known as the buffer for the edge; the process of maintaining the queue of tokens is known as buffering <ref> [3] </ref>. Single Appearance Schedule A single appearance schedule is one in which each actor or functional block appears only once in the entire schedule [3]. The Ptolemy and Tycho Frameworks 18 of 48 Table 4. Single Processor Schedulers in Ptolemy Scheduler Name Features Default SDF Scheduler Performed at compile time. <p> The queue is known as the buffer for the edge; the process of maintaining the queue of tokens is known as buffering <ref> [3] </ref>. Single Appearance Schedule A single appearance schedule is one in which each actor or functional block appears only once in the entire schedule [3]. The Ptolemy and Tycho Frameworks 18 of 48 Table 4. Single Processor Schedulers in Ptolemy Scheduler Name Features Default SDF Scheduler Performed at compile time. Many possible schedules but schedule is chosen based on a heuristic that minimizes resource costs and amount of buffering required.
Reference: [4] <author> J. P. Calvez, </author> <title> Embedded Real-Time Systems: A Specification and Design Methodology, </title> <publisher> John Wiley & Sons, </publisher> <address> West Sussex, England 1993. </address>
Reference: [5] <author> J. B. Dennis, </author> <title> First Version Data Flow Procedure Language, </title> <note> Technical Memo MAC TM61, </note> <month> May, </month> <year> 1975, </year> <institution> MIT Laboratory for Computer Science. </institution>
Reference-contexts: Summary of Domains in Ptolemy Domain Description Synchronous Data Flow (SDF) Oldest and most mature domain; it is a sub-domain of DDF, BDF, and PN. Special case of data ow model of computation developed by Dennis <ref> [5] </ref>. Flow is completely predictable at compile time thus allows for efficient scheduling. Allows for static scheduling. Good match for synchronous signal processing systems with sample rates that are rational multiples of one another. Supports multi-rate applications and has a rich star library. Range of applications is limited.
Reference: [6] <author> D. D. Gajski, F. Vahid, S. Narayan, and J. Gong, </author> <title> Specification and Design of Embedded Systems, </title> <publisher> PTR Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., USA, </address> <year> 1994. </year>
Reference: [7] <author> H. L. Gantt, </author> <title> Organizing for Work, </title> <institution> Industrial Management, </institution> <month> August, </month> <year> 1919, </year> <note> pp.89 - 93. </note>
Reference-contexts: An early example of how visualization was used to improve worker performance is given in Gantts 1919 paper, Organizing for Work, where he shows how charts visual representations of machine utilization, distribution of tasks across machines, and worker performance easily disclose possible reasons for poor worker performance <ref> [7] </ref>. Recently, system engineers have realized that visualization techniques can be very useful to the embedded- system design process. Poor algorithm design, problematic hardware-software interfaces, and other possible reasons for sub-optimal performance are easily discovered by using such techniques. <p> Normally, the engineer needs to quickly determine whether the mapping produced by a scheduler will cause the system to perform its intended function within the performance constraints at the lowest possible cost. Traditionally, Gantt Charts, based on concepts developed by Gantt in <ref> [7] </ref>, have been used to visually represent schedules. These charts show how software components are mapped onto processing units over time. A detailed discussion of Gantt Charts is presented in Section 2.4.2. <p> He developed three basic charts: Machine Record Chart, Progress Chart, and Man Record Chart. The first displays the amount of time a machine is working, the cumulative working time of an individual machine, the cumulative working time of a group of machines, and reasons for idleness <ref> [7] </ref>. The Progress Chart gives a distribution of tasks across machines, the rate of work, and the activities on the chart are measured by the amount of time needed to perform them. This chart defines a schedule as it maps tasks to machines and determines their the task execution order. <p> It keeps a record of what tasks were executed, when they were executed, and how long they took to complete. The trace may also be annotated with expected or estimated behaviour. Clearly, this is very similar to the Man Record Chart concept developed by Gantt <ref> [7] </ref>. A simple visualization of an execution trace is shown in Figure 4. Each task is listed along the vertical axis and time is given along the horizontal axis. The thick lines represent how long each task was expected to take and the thin lines below represent actual execution.
Reference: [8] <author> M. T. Heath, J. A. Etheridge, </author> <title> Visualizing the Performance of Parallel Programs, </title> <journal> IEEE Software, </journal> <note> September 1991 pp. 29 - 39. </note>
Reference: [9] <author> M. T. Heath, A. D. Malony, and D. T. </author> <title> Rover, Parallel Performance Visualization: From Practice to Theory, </title> <booktitle> IEEE Parallel and Distributed Technology, Winter 1995, </booktitle> <pages> pp. 44 - 60. </pages>
Reference-contexts: Communication overhead can also be described as the time spent sending and receiving messages between concurrent processes in relation to the overall execution time. Critical Paths A critical path is the longest serial thread, or chain of dependencies, running through an execution of an algorithm <ref> [9] </ref>. Critical paths are important performance analysis abstractions as the total execution time cannot be reduced without shortening the length of a critical path. Critical paths are potential places for performance bottlenecks. <p> Some of the forms that these visualizations take are circuit diagrams, signal traces, and architecture block diagrams. Comparable visualizations for systems implemented in software are few in number. For purely parallel systems, tools that visualize execution, schedules, and communication patterns exist <ref> [9] </ref> but are sometimes inadequate for complicated architectures. For uniprocessor and multiprocessor embedded systems, especially those that incorporate both hardware and software modules, very little exists in terms of visualizing architecture, execution, and performance. <p> Recent interest in visualizing software performance analysis of parallel systems has brought about the advent of some basic visualization concepts and principles. These concepts which are briey summarized in the following section can be used to create effective visual representations of design information. 2.4.1 Visualization Basics In <ref> [9] </ref> and [10] M. T. Heath et. al. outline basic concepts and principles that are necessary to produce effective graphical displays. Good visualization techniques can have dramatic impact in areas where they can lead to a discovery of unexpected phenomena. <p> Users are not interested in pretty pictures but something that will lead them to construct an empirical model of behaviour. Some of the basic principles that must be considered when developing visualization techniques are: Users should be able to relate the display of information to a context <ref> [9] </ref>. The visualization should allow a user to connect the display to an environment from which it is derived. Any visualization tool must be able to scale easily to large data sets and there must be a means for a user to give the tool feedback. <p> This is important for yielding insight into the behavioural characteristics of the system and their causes <ref> [9] </ref>. Techniques such as using colour or size to highlight useful information from large raw data sets are also necessary.
Reference: [10] <author> M. T. Heath, A. D. Malony, and D. T. </author> <title> Rover, The Visual Display of Parallel Performance Data, </title> <booktitle> IEEE Computer, </booktitle> <month> November </month> <year> 1995, </year> <pages> pp. 21 - 28. </pages>
Reference-contexts: Recent interest in visualizing software performance analysis of parallel systems has brought about the advent of some basic visualization concepts and principles. These concepts which are briey summarized in the following section can be used to create effective visual representations of design information. 2.4.1 Visualization Basics In [9] and <ref> [10] </ref> M. T. Heath et. al. outline basic concepts and principles that are necessary to produce effective graphical displays. Good visualization techniques can have dramatic impact in areas where they can lead to a discovery of unexpected phenomena. <p> Background and Theory 12 of 48 2.4.4 Space-Time Diagrams A space-time diagram shows message passing and communication between different processing units in a system <ref> [10] </ref>. Diagrams depicting communication behaviour can bring to light patterns of behaviour that can indicate program loops, or can allow a user to determine reasons for low utilization such as poor message-passing techniques and inadequate pipelining.
Reference: [11] <author> J. L. Hennessy and D. A. Patterson, </author> <title> Computer Architecture: A Quantitative Approach, </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, USA, </address> <year> 1990. </year>
Reference-contexts: Traditional Gantt Charts are normally used to display this information. Input or Output Accesses An input or output access occurs when data is either input to the system or output from the system. An input or output operations performance can be measured in terms of response time or throughput <ref> [11] </ref>. The response time is measured as the length of time taken for the operation to complete, starting from when the data was placed in a buffer until the time when it is finally output or input. <p> The memory access time is measured as the hit time plus the miss rate multiplied by the miss penalty (avg. Background and Theory 9 of 48 mem. access time = hit time + miss rate * miss penalty) <ref> [11] </ref>. It is clear that a memory operation that needs to access data residing in local memory on a processor will take less time than an operation that needs to access data residing at a remote location. Communication Overhead Communication overhead is usually considered important in evaluating multiple processor systems. <p> Other people, such as network managers, may use the total amount of work done in a given amount of time which is commonly referred to as throughput as a measure of performance. In all cases, time is the basis for measures of system performance <ref> [11] </ref>. A system that can perform a given task in the least amount of time is said to be the fastest or has the best performance. Performance models can be useful as they can be used to abstract system behaviour and can allow engineers to predict and analyze system performance.
Reference: [12] <author> D. D. Hils, </author> <title> Visual Languages and Computing Survey: Data Flow Visual Programming Languages, </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> Vol. 3, </volume> <year> 1992, </year> <month> pp.69-101. </month>
Reference: [13] <author> Hypertext Webster Interface. </author> <note> http://gs213.sp.cs.cmu.edu/prog/webster? </note>
Reference-contexts: and issues concerning the design of embedded systems that motivated the research presented in this report. 2.1 Embedded Systems and Their Design A system can be defined as a group of devices or artificial objects or an organization forming a network especially for distributing something or serving a common purpose <ref> [13] </ref>. To embed a system into some object means to make that system an integral part of the object. When an engineer talks about an embedded system, he or she is usually referring to a system that satisfies a well-defined need at a specific instant in time.
Reference: [14] <editor> [incr Tcl] and [incr Tk]. </editor> <address> http://www.tcltk.com/itcl/index.html </address>
Reference-contexts: The prototype is written in [incr Tcl] and [incr Tk] <ref> [14] </ref>, and is part of the Tycho project. As mentioned in the previous section, the two key classes are the Displayer and the View. The functionality of each was described in detail earlier.
Reference: [15] <author> M.-H. Jobin, P. Lefrancois, B. Montreuil, </author> <title> Using a Public 3-D Gantt Chart Communication Structure between Agents for Distributed Scheduling Architectures, </title> <journal> Integrated Computer-Aided Engineering, </journal> <volume> Vol. 1, No. 2, </volume> <pages> pp. 147 - 156, </pages> <year> 1993. </year>
Reference: [16] <author> G. M. Karam, </author> <title> Visualization using Timelines, </title> <booktitle> 1994 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <address> Seattle, WA, USA, </address> <month> August 17 19, </month> <year> 1994. </year>
Reference: [17] <author> J. Kodosky, J. MacCrisken, and G. Rymar, </author> <title> Visual Programming Using Structured Data Flow, </title> <booktitle> Proceedings of IEEE Workshop on Visual Languages, </booktitle> <month> October </month> <year> 1991, </year> <institution> Kobe Japan. </institution>
Reference: [18] <author> E. A. Lee, A. Kalavade, W.-T. Chang, </author> <title> Effective Heterogeneous Design and Co-simulation, </title> <booktitle> NATO Advanced Study Institute Workshop on Hardware/Software Codesign, </booktitle> <address> Lake Como, Italy, June 18 30, </address> <year> 1995. </year>
Reference-contexts: Many of these systems combine control-ow oriented processes with data-ow oriented processes resulting in subsystems that must be modeled using different models of computation. Ptolemy was designed to allow mixing of different models of computation to specify such systems <ref> [18] </ref>. A system, application, or algorithm can be specified in Ptolemy by representing it visually in terms of whichever semantics seem feasible for the problem.
Reference: [19] <author> A. D. Malony, D. H. Hammerslag, and D. J. Jablonowski, </author> <title> Traceview: A Trace Visualization Tool, </title> <journal> IEEE Software, </journal> <note> September 1991 pp. 19 - 28. References 48 of 48 </note>
Reference: [20] <author> P. Osmon and P. Sleat, IDRIS: </author> <title> Interactive Design of Reactive Information Systems, </title> <booktitle> Proceedings of Fourth International Conference on Advanced Information Systems Engineering, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Germany, </address> <year> 1992, </year> <pages> pp. 494 - 506. </pages>
Reference: [21] <author> E. K. Pauer and J. B. </author> <title> Prime, An Architecture Trade Capability Using the Ptolemy Kernel, </title> <booktitle> 1996 International Conference on Acousitics, Speech, and Signal Processing, </booktitle> <address> Atlanta, Georgia, </address> <month> May 7 - 10, </month> <year> 1996. </year>
Reference: [22] <author> J. L. Pino, S. S. Bhattacharyya, and E. A. Lee, </author> <title> A Hierarchical Multiprocessor Scheduling System for DSP Applications, </title> <booktitle> Twenty-Ninth Annual Asilomar Conference on Signals, Systems, and Computers, </booktitle> <month> October, </month> <year> 1995. </year>
Reference-contexts: This expansion can result in exponential growth of nodes in the APEG. Clustering SDF graph nodes into composite nodes can limit the expansion resulting in a simpler APEG. The clusters may be scheduled much like actors resulting in hierarchical schedules <ref> [22] </ref>. Buffers and Buffering Each edge in a SDF graph corresponds to first-in-first-out queue that buffers tokens that pass along the edge. The queue is known as the buffer for the edge; the process of maintaining the queue of tokens is known as buffering [3].
Reference: [23] <author> J. L. Pino, S. Ha, E. A. Lee and J. T. Buck, </author> <title> Software Synthesis for DSP Using Ptolemy, </title> <journal> Journal of VLSI Signal Processing, </journal> <volume> 9, </volume> <pages> 7-12, </pages> <year> 1995. </year>
Reference: [24] <author> Ptolemy Team, </author> <title> The Almagest, Vol.1-4, Ptolemy 0.5 Kernel Manual, </title> <institution> EECS, University of California, Berkeley, </institution> <year> 1990-1994. </year>
Reference-contexts: An interconnection of stars is known as a galaxy which may represent the entire system or a part of the system. A complete application is known as a universe which is an interconnection of stars and galaxies. Hierarchy is used to manage complexity and mix different models of computation <ref> [24] </ref>. A target is a modular object in Ptolemy which describes particular features of the target hardware architecture which will implement the design. It manages a simulation or synthesis process. A user can specify target-specific information either at run-time or choose from a standard set of pre-specified options. <p> A scheduler object is associated with each target and it determines how stars will be mapped onto available resources and their execution order. A domain is a collection of stars, schedulers, and targets. It implements a particular model of computation <ref> [24] </ref> and either performs simulation or code generation. Figure 2 clarifies the aforementioned terms and Table 3 [24] summarizes all the domains available within Ptolemy. <p> A domain is a collection of stars, schedulers, and targets. It implements a particular model of computation <ref> [24] </ref> and either performs simulation or code generation. Figure 2 clarifies the aforementioned terms and Table 3 [24] summarizes all the domains available within Ptolemy. Universe star star star star star star galaxy galaxy galaxy particle Domain star star star target target scheduler scheduler The Ptolemy and Tycho Frameworks 14 of 48 Table 3. <p> Currently, code generation facilities exist for Synchronous Data Flow (SDF), Boolean Data Flow (BDF), and Integer and State- controlled Data Flow (STDF) semantics <ref> [24] </ref>. Since all of the code generation domains support SDF semantics and due to the fact that the SDF domain is the most mature of all the domains, the following description of scheduling will be discussed with respect to SDF semantics. The concepts are easily extended to the other domains. <p> Table 3. Summary of Domains in Ptolemy Domain Description The Ptolemy and Tycho Frameworks 17 of 48 precedence relations between the invocations of the SDF functional blocks. All schedulers designed for multiprocessor systems use the generated APEG as input <ref> [24] </ref>. Several types of schedulers exist within the Ptolemy framework. Some schedulers ignore hierarchy that may be present in the SDF graph in order to maximize concurrency, whereas others use hierarchy to minimize complexity. <p> No single scheduler can handle all situations so Ptolemy allows a user to mix and match different schedulers for specific applications <ref> [24] </ref>. A summary of the types of schedulers available in Ptolemy is given in Table 4 and Table 5 [24]. The terminology used in the tables is described in the following section. 3.3.1 Scheduling Terminology This section briey describes some of the terms used in Table 4 and Table 5. <p> No single scheduler can handle all situations so Ptolemy allows a user to mix and match different schedulers for specific applications <ref> [24] </ref>. A summary of the types of schedulers available in Ptolemy is given in Table 4 and Table 5 [24]. The terminology used in the tables is described in the following section. 3.3.1 Scheduling Terminology This section briey describes some of the terms used in Table 4 and Table 5. APEG APEG abbreviates acyclic precedence graph.
Reference: [25] <author> J. Rambaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen, </author> <title> Object-Oriented Modeling and Design, </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., USA, </address> <year> 1991. </year>
Reference-contexts: The model consists of three key objects that allow for combinations of multiple views of design information: Displayer, View, and Data Filter. Each of these objects are described in detail in the following subsections. The notation used in the figures describing the object-oriented architecture is described in <ref> [25] </ref> and summarized in the figure below. An overview of the design is given in Figure 7. Two key issues that motivated the design are: Different views of information need to be easily combined in a single display.
Reference: [26] <author> G. C. Sih, </author> <title> Multiprocessor Scheduling to Account For Interprocessor Communication, </title> <type> Ph.D. </type> <institution> Dissertation UCB/ ERL M91/29, University of California, Berkeley, </institution> <year> 1991. </year>
Reference-contexts: The nodes in this graph represent tasks or computations and the directed arcs represent precedence constraints and data paths. Each arc has a label which specifies the amount of data that the source node passes to the destination node. An APEG can be derived from a SDF representation <ref> [26] </ref>. Looped Schedule A looped schedule is one which may contain any number of schedule loops. A schedule loop consists of m number of actors or functional blocks that are repeated in succession n times. Loops in a looped schedule may be nested [3].
Reference: [27] <author> C. M. Woodside, </author> <title> A Three-View Model for Performance Engineering of Concurrent Software, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> Sept. </month> <year> 1995, </year> <month> vol.21, No.9, </month> <pages> pp. 754 - 767. </pages>
Reference-contexts: This traditional approach to design is shown in Figure 1 and is contrasted to performance-based design. Performance-based design advocates evaluating performance at early stages of design <ref> [27] </ref> such as after functional testing is complete. <p> Evaluating the performance of a system requires gathering, sifting, and displaying many types of information: data from manufacturers, measurements on earlier systems, estimates made during analysis, and availability of logical and physical resources <ref> [27] </ref>. Scheduling descriptions for logical and physical resources and allocation of processes to hardware or software are emerging to be quite important factors in determining the performance of a system. <p> Performance-based design dictates that performance models should be integrated with functional design and resource scheduling. Models that use early estimates of processing costs of parts of a design can aid in planning software architectures, assessing needs to distribute data and functionality, and hardware planning <ref> [27] </ref>. In order to obtain adequate and predictable performance, it is important to characterize system behaviour: sequences of events, actions, and delays. In addition, it is important to provision and schedule physical and logical resources: hardware (processors, input or output devices, memory, interconnections) and things such as locks and semaphores. <p> Abstract models such as queuing networks, Petri nets, or other simulation models of available resources have been developed in order to aid in performance analysis which helps in determining contention delays, resource saturation at bottlenecks, load imbalance, and interprocessor or interprocess communication overhead <ref> [27] </ref>. Simulating a system can generate possible execution paths that may reveal critical paths which can lead to discovery of bottlenecks and other causes of low performance. Background and Theory 10 of 48 2.4 Visual Display of Design Information Design information comes in a multitude of avours.
Reference: [28] <author> J. Zhu, et. al., </author> <title> HaRTS: Performance-Based Design of Distributed Hard Real-Time Software, </title> <journal> Journal of Systems and Software, </journal> <month> February, </month> <year> 1996, </year> <pages> pp. 143 - 56. </pages>
Reference-contexts: A good visual display of data can lead the designer to quickly determine whether an algorithm and architecture will perform the given task optimally. There are very few tools available that allow for performance-based design analysis through visualization as well as analytical techniques <ref> [28] </ref>. There are even fewer tools that allow a designer to explore embedded software solutions for multiple existing off-the-shelf hardware architectures. An important part of fitting software to hardware resources is the scheduling process.
References-found: 29

