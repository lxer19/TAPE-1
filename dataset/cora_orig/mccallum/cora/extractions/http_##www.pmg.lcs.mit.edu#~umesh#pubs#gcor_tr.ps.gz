URL: http://www.pmg.lcs.mit.edu/~umesh/pubs/gcor_tr.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/~umesh/pubs/
Root-URL: 
Title: Partitioned Garbage Collection of a Large Object Store  
Author: Umesh Maheshwari Barbara Liskov 
Keyword: garbage collection, partitions, cyclic garbage, object database  
Date: October 1995  
Address: Cambridge, MA 02139  
Affiliation: MIT Laboratory for Computer Science,  
Pubnum: Technical Report MIT/LCS/TR-699  
Abstract: This paper describes a new garbage collection scheme for large persistent object stores that makes efficient use of the disk and main memory. The heap is divided into partitions that are collected independently using information about inter-partition references. We present efficient techniques to maintain this information stably using auxiliary data structures in memory and the log. The result is a scheme that truly preserves the localized and scalable nature of partitioned collection. Remembering inter-partition references does not collect garbage cycles that span partitions. We describe a new global marking scheme that collects such garbage. We believe that it is the first scheme that piggybacks global marking on partitioned collection, does not delay the collection of acyclic garbage, and is guaranteed to terminate correctly in the presence of concurrent mutations. Further, it preserves the disk-efficient nature of our collector. We have implemented the part of garbage collection responsible for maintaining information about inter-partition references. We present a benchmark to evaluate this work and give performance results to show the advantages of our scheme. 
Abstract-found: 1
Intro-found: 1
Reference: [AFFS95] <author> Laurent Amsaleg, P. Ferreira, Michael Franklin, and Marc Shapiro. </author> <title> Evaluating garbage collection for large persistent stores. </title> <booktitle> In Addendum to Proc. 1995 OOPSLA Workshop on Object Database Behavior. </booktitle> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: While these require care in implementing them correctly, we do not expect them to introduce a significant performance cost for the reasons given in Section 3.5. 5.3 Workload Amsaleg et al. pointed out the lack of a standard benchmark for garbage collectors <ref> [AFFS95] </ref>. They identified certain metrics to evaluate collectors; these include isolated costs and benefits such as bookkeeping overheads and the rate of collection, as well as the effect on the overall application performance.
Reference: [AGF95] <author> Laurent Amsaleg, Olivier Gruber, and Michael Franklin. </author> <title> Efficient incremental garbage collection for workstation-server database systems. </title> <booktitle> In Proc. 21st VLDB. </booktitle> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: Increasing the partition size helps reduce inter-partition references, but tracing very large partitions slows both the garbage collector and the applications due to increased contention for the cache and disk <ref> [AGF95] </ref>. We present a new partitioned scheme that uses a log and in-memory data structures to provide the following benefits: 1. Disk accesses for reading and updating information about inter-partition references are deferred and batched. 2. <p> Like a page, a segment is stored contiguously on disk and is the unit of disk access. A segment also provides opaque references for its objects so that objects can be moved within their segment without having to update references to them stored in other objects (as in <ref> [AGF95] </ref>). Refer- ences need not be completely opaque; for example, in Thor, each reference contains the segment number of the referenced object so that objects can be located efficiently without a global object table. <p> Most generational schemes solve this problem by remembering the exact objects or locations in other partitions that refer to a given object [Ung84], but this is too much information to maintain in a large heap. Therefore, we compact objects within each segment and thus preserve object names, as in <ref> [AGF95] </ref>. Note that objects that are not referenced from other partitions or applications (as given by the root set) could indeed be moved to other segments within the partition. <p> In particular, cleaning log segments, as in Sprite LFS, is similar to partitioned collection. However, inter-segment references need not be tracked because the liveness of a log record can be verified quickly given the file system structure. Amsaleg et al. designed a partitioned collector for a transactional, client-server database <ref> [AGF95] </ref>. The 12 work focuses on supporting transactional mechanisms such as rollback. The collector uses the log to pick up updates, and the authors point out the need for efficient maintenance of stable inlists. Maheshwari and Liskov proposed migrating objects suspected to be cyclic garbage [ML95].
Reference: [Ali85] <author> K. A. M. Ali. </author> <title> Garbage collection schemes for dis-tributed storage systems. </title> <booktitle> In Proc. of Workshop on Implementation of Functional Languages, </booktitle> <pages> pages 422-428, </pages> <year> 1985. </year>
Reference-contexts: Each partition trace propagates marks from the root set of the partition to the outlist. The marking phase terminates when marks are known to have propagated fully through all partitions. Similar schemes have been used in some distributed systems <ref> [Ali85, Hug85] </ref>, although these systems rely on global marking to collect both acyclic and cyclic inter- partition garbage. Other schemes either propagate global marks separately from regular partition traces [JJ92], or are not guaranteed to terminate correctly in the presence of concurrent mutations [LQP92].
Reference: [Bak78] <author> Henry G. Baker. </author> <title> List processing in real-time on a serial computer. </title> <journal> CACM, </journal> <volume> 21(4) </volume> <pages> 280-94, </pages> <year> 1978. </year>
Reference-contexts: In these systems, the heap resides on the disk because it is much larger than the main memory and must be recoverable after a crash. Applications access the objects through a memory cache and log updates for crash recovery. Schemes that trace the entire heap (e.g., <ref> [Bak78, KW93, ONG93] </ref>) do not scale to very large heaps because the non-local nature of tracing would cause random disk accesses.
Reference: [Bak93] <author> Henry G. Baker. </author> <title> `Infant mortality' and generational garbage collection. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(4), </volume> <year> 1993. </year>
Reference-contexts: This is also the approach taken in many distributed system [LQP92, LL92, ML94, FS96]. Generational collectors are a variant of partitioned collection that use the ages of objects to optimize the collection of younger, smaller partitions [LH83]; however, the age-based heuristics are not applicable to persistent stores <ref> [Bak93] </ref>. A major problem with partitioned collection is the efficient maintenance of information about inter-partition references, which is needed to trace partitions independently.
Reference: [Bis77] <author> Peter B. Bishop. </author> <title> Computer systems with a very large address space and garbage collection. </title> <type> Technical Report MIT/LCS/TR-178, </type> <institution> MIT, </institution> <year> 1977. </year>
Reference-contexts: Therefore, we relate our work to systems with large heaps as well as large distributed systems. Bishop proposed dividing a large address space into independently collectible partitions in 1977 <ref> [Bis77] </ref>. He proposed collecting cyclic garbage by migrating objects to partitions that reference them. Migration is also used in some distributed systems because it is fault tolerant and decentralized [SGP90, ML95]. The cost of migration is copying objects and patching up the references to the moved objects.
Reference: [CKWZ96] <author> Jonathan E. Cook, Artur W. Klauser, Alexander L. Wolf, and Benjamin G. Zorn. </author> <title> Semi-automatic, self-adaptive control of garbage collection rates in object databases. </title> <booktitle> In Proc. 1996 SIGMOD. </booktitle> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference: [CWZ94] <author> Jonathan E. Cook, Alexander L. Wolf, and Benjamin G. Zorn. </author> <title> Partition selection policies in object databases garbage collection. </title> <booktitle> In Proc. 1994 SIGMOD. </booktitle> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: The generation of the various lists is shown in 3.4 Collecting a Partition Any policy may be used to select partitions for collection. (Cook et al. showed that it is desirable to be flexible in selecting partitions <ref> [CWZ94] </ref>.) To trace a selected partition, we load all of its segments into the cache and process the log completely to generate the partition's full potential inlist. Since a partition is a fraction (say, 10%) of the cache, it does not disturb the cache much when loaded.
Reference: [FS96] <author> Paulo Ferreira and Marc Shapiro. Larchant: </author> <title> Persistence by reachability in distributed shared memory through garbage collection. </title> <booktitle> In Proc. 16th ICDCS, </booktitle> <year> 1996. </year>
Reference-contexts: HM92, YNY94, AGF95, MMH96, CKWZ96]. This is also the approach taken in many distributed system <ref> [LQP92, LL92, ML94, FS96] </ref>. Generational collectors are a variant of partitioned collection that use the ages of objects to optimize the collection of younger, smaller partitions [LH83]; however, the age-based heuristics are not applicable to persistent stores [Bak93]. <p> Conversely, a group may include many more partitions than necessary because garbage objects can point to live objects. Ferreira and Shapiro designed garbage collection for a distributed shared memory system with persistence <ref> [FS96] </ref>. Segments may be cached at multiple sites and collectors may work on them concurrently. The work focuses on avoiding costly synchronization between the collectors. Each segment has an inlist, but segments cached at a site can be dynamically grouped to form a partition that is traced as a unit.
Reference: [Ghe95] <author> S. Ghemawat. </author> <title> The Modified Object Buffer: A Storage Management Technique for Object-Oriented Databases. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1995. </year>
Reference-contexts: Applications fetch objects from servers into the client cache and access them locally. At commit, copies of modified objects are sent back to the servers. The modified objects are stored in an in- memory log that is intended to be stable through replication <ref> [Ghe95] </ref>. However, we simulate delays for log forces as if it were stored on a logging disk, separate from the database disk. Persistence of objects at the servers is governed by reachability from persistent roots.
Reference: [HM92] <author> Richard L. Hudson and J. Eliot B. Moss. </author> <title> Incremental garbage collection for mature objects. </title> <booktitle> In Proc. IWMM, vol-ume 637 of Lecture Notes in Computer Science. </booktitle> <address> SpringerVerlag, </address> <year> 1992. </year>
Reference-contexts: None of the above works addresses efficient maintenance of inter-partition references. The only previous work that addresses this issue is PMOS by Moss et al. <ref> [HM92, MMH96] </ref>. PMOS collects one segment at a time, which is the unit of both fetching and tracing. Each segment contains an inlist that identifies the source segments for incoming references.
Reference: [Hug85] <author> R. John M. Hughes. </author> <title> A distributed garbage collec-tion algorithm. </title> <booktitle> In Proc. 1985 FPCA, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 256-272. </pages> <address> SpringerVerlag, </address> <year> 1985. </year>
Reference-contexts: We prove that the scheme is correct and that a marking phase is sure to terminate in the presence of application modifications. Previous proposals for using global marking on top of partitioned collection either delay the collection of acyclic garbage <ref> [Hug85] </ref>, need to run separate traces for global marking and partitioned collection [JJ92], or are not guaranteed to terminate in the presence of modifications [LQP92]. We have implemented the part of garbage collection responsible for maintaining inter-partition references in the context of Thor [LAC + 96]. <p> Each partition trace propagates marks from the root set of the partition to the outlist. The marking phase terminates when marks are known to have propagated fully through all partitions. Similar schemes have been used in some distributed systems <ref> [Ali85, Hug85] </ref>, although these systems rely on global marking to collect both acyclic and cyclic inter- partition garbage. Other schemes either propagate global marks separately from regular partition traces [JJ92], or are not guaranteed to terminate correctly in the presence of concurrent mutations [LQP92]. <p> For example, a 1 MByte partition might contain up to 64K objects (allowing an average object size of 16 bytes). Thus we have 8 Kbyte markmap, which represents only 0.8% overhead on disk. Certain other schemes require mark bits for only inter-partition references <ref> [Hug85, LQP92] </ref>; we discuss the need for a mark bit per object in Section 4.5. The mark of a basic inlist entry is defined to be the mark of the object it references, as stored in the basic markmap.
Reference: [JJ92] <author> Neils-Christian Juul and Eric Jul. </author> <title> Comprehensive and robust garbage collection in a distributed system. </title> <booktitle> In Proc. IWMM, volume 637 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Previous proposals for using global marking on top of partitioned collection either delay the collection of acyclic garbage [Hug85], need to run separate traces for global marking and partitioned collection <ref> [JJ92] </ref>, or are not guaranteed to terminate in the presence of modifications [LQP92]. We have implemented the part of garbage collection responsible for maintaining inter-partition references in the context of Thor [LAC + 96]. <p> Similar schemes have been used in some distributed systems [Ali85, Hug85], although these systems rely on global marking to collect both acyclic and cyclic inter- partition garbage. Other schemes either propagate global marks separately from regular partition traces <ref> [JJ92] </ref>, or are not guaranteed to terminate correctly in the presence of concurrent mutations [LQP92]. We show that our scheme is correct and that it terminates in the presence of mutations. We found that a more sophisticated scheme is needed to meet these requirements than apparent at first. <p> It is unclear whether such a scheme has any advantage over global marking when partitions are collected sequentially. Juul and Jul designed a distributed collector with both partition traces and global marking <ref> [JJ92] </ref>. Inlist entries do not contain reference counts and are removed only by global marking. Thus, the system relies on global marking to collect both cyclic and acyclic inter-partition garbage. Global marking uses a mark bit per object; it is not piggybacked on partition traces and is conducted separately.
Reference: [KW93] <author> Elliot K. Kolodner and William E. Weihl. </author> <title> Atomic incremental garbage collection and recovery for large stable heap. </title> <booktitle> In Proc. 1993 SIGMOD, </booktitle> <pages> pages 177-186, </pages> <year> 1993. </year>
Reference-contexts: In these systems, the heap resides on the disk because it is much larger than the main memory and must be recoverable after a crash. Applications access the objects through a memory cache and log updates for crash recovery. Schemes that trace the entire heap (e.g., <ref> [Bak78, KW93, ONG93] </ref>) do not scale to very large heaps because the non-local nature of tracing would cause random disk accesses. <p> However, the scheme does not elaborate on concurrent execution with the mutator, and we believe that it would fail to terminate correctly in the presence of concurrent mutations. Kolodner proposed recoverable collection of a large heap using unpartitioned but incremental copying <ref> [KW93] </ref>. Like other unpartitioned schemes, this collector must make random accesses in the old space. O'Toole et al. proposed concurrent copying of a persistent heap by letting applications access the old space while the collector copies it to new space [NOPH92, ONG93].
Reference: [LAC + 96] <author> B. Liskov, A. Adya, M. Castro, M. Day, S. Ghemawat, R. Gruber, U. Maheshwari, A. Myers, and L. Shrira. </author> <title> Safe and efficient sharing of persistent objects in Thor. </title> <booktitle> In Proc. 1996 SIGMOD, </booktitle> <pages> pages 318-329. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: We have implemented the part of garbage collection responsible for maintaining inter-partition references in the context of Thor <ref> [LAC + 96] </ref>. We present a benchmark to evaluate the maintenance of inter-partition references, and we give performance results to show the advantages of our scheme. The remainder of the paper is organized as follows. Section 2 describes the system model. <p> Tracing of individual partitions is largely orthogonal to our scheme; as mentioned in Section 3.4, any of several existing techniques for concurrent collection could be used. Our implementation does not yet include support for collection of inter-partition cyclic garbage. 5.1 The Context Thor is a client-server object-oriented database <ref> [LAC + 96] </ref>. Servers provide persistent storage for objects, while applications running on client machines read and modify objects. Object accesses are grouped into transactions to tolerate concurrency and failures. Servers store objects on disk in fixed-sized segments, currently 32 Kbytes, which are the units of disk access.
Reference: [LH83] <author> Henry Lieberman and Carl E. Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> CACM, </journal> <volume> 26(6) </volume> <pages> 419-29, </pages> <year> 1983. </year>
Reference-contexts: HM92, YNY94, AGF95, MMH96, CKWZ96]. This is also the approach taken in many distributed system [LQP92, LL92, ML94, FS96]. Generational collectors are a variant of partitioned collection that use the ages of objects to optimize the collection of younger, smaller partitions <ref> [LH83] </ref>; however, the age-based heuristics are not applicable to persistent stores [Bak93]. A major problem with partitioned collection is the efficient maintenance of information about inter-partition references, which is needed to trace partitions independently.
Reference: [LL92] <author> Rivka Ladin and Barbara Liskov. </author> <title> Garbage collection of a distributed heap. </title> <booktitle> In Proc. International Conference on Distributed Computing Systems. </booktitle> <publisher> IEEE Press, </publisher> <year> 1992. </year>
Reference-contexts: HM92, YNY94, AGF95, MMH96, CKWZ96]. This is also the approach taken in many distributed system <ref> [LQP92, LL92, ML94, FS96] </ref>. Generational collectors are a variant of partitioned collection that use the ages of objects to optimize the collection of younger, smaller partitions [LH83]; however, the age-based heuristics are not applicable to persistent stores [Bak93].
Reference: [LQP92] <author> Bernard Lang, Christian Queinniec, and Jos e Piquer. </author> <title> Garbage collecting the world. </title> <booktitle> In Proc. POPL '92, </booktitle> <pages> pages 39-50. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: HM92, YNY94, AGF95, MMH96, CKWZ96]. This is also the approach taken in many distributed system <ref> [LQP92, LL92, ML94, FS96] </ref>. Generational collectors are a variant of partitioned collection that use the ages of objects to optimize the collection of younger, smaller partitions [LH83]; however, the age-based heuristics are not applicable to persistent stores [Bak93]. <p> Previous proposals for using global marking on top of partitioned collection either delay the collection of acyclic garbage [Hug85], need to run separate traces for global marking and partitioned collection [JJ92], or are not guaranteed to terminate in the presence of modifications <ref> [LQP92] </ref>. We have implemented the part of garbage collection responsible for maintaining inter-partition references in the context of Thor [LAC + 96]. We present a benchmark to evaluate the maintenance of inter-partition references, and we give performance results to show the advantages of our scheme. <p> Other schemes either propagate global marks separately from regular partition traces [JJ92], or are not guaranteed to terminate correctly in the presence of concurrent mutations <ref> [LQP92] </ref>. We show that our scheme is correct and that it terminates in the presence of mutations. We found that a more sophisticated scheme is needed to meet these requirements than apparent at first. <p> For example, a 1 MByte partition might contain up to 64K objects (allowing an average object size of 16 bytes). Thus we have 8 Kbyte markmap, which represents only 0.8% overhead on disk. Certain other schemes require mark bits for only inter-partition references <ref> [Hug85, LQP92] </ref>; we discuss the need for a mark bit per object in Section 4.5. The mark of a basic inlist entry is defined to be the mark of the object it references, as stored in the basic markmap. <p> Further, note that we unmark a partition only if we discover an unmarked object that should be marked (Rule 7 needed for termination). This is why we need a mark bit per object, while some previous schemes used mark bits in inlists and outlists only <ref> [LQP92] </ref>. All new objects must be marked; we accomplish this by storing them in the delta markmap. Note that this does not imply that these objects cannot be collected during this phase. As mentioned, untraced objects are collected even if they are not marked. <p> Global marking uses a mark bit per object; it is not piggybacked on partition traces and is conducted separately. Lang et al. proposed marking within a selected group of partitions to collect inter-partition cyclic garbage contained in the group <ref> [LQP92] </ref>. Marking is piggybacked on partition traces as in our scheme and comprises a marked trace followed by an unmarked trace. Only in- list and outlist entries need mark bits.
Reference: [ML94] <author> Umesh Maheshwari and Barbara Liskov. </author> <title> Faulttolerant distributed garbage collection in a client-server object-oriented database. </title> <booktitle> In Proc. 3rd Parallel and Distributed Information Systems. </booktitle> <publisher> IEEE Press, </publisher> <year> 1994. </year>
Reference-contexts: HM92, YNY94, AGF95, MMH96, CKWZ96]. This is also the approach taken in many distributed system <ref> [LQP92, LL92, ML94, FS96] </ref>. Generational collectors are a variant of partitioned collection that use the ages of objects to optimize the collection of younger, smaller partitions [LH83]; however, the age-based heuristics are not applicable to persistent stores [Bak93]. <p> However, we simulate delays for log forces as if it were stored on a logging disk, separate from the database disk. Persistence of objects at the servers is governed by reachability from persistent roots. The task of garbage collection in Thor is distributed across servers and clients <ref> [ML94, ML95] </ref>, but this paper pertains to garbage collection within a single server. 5.2 Partitioned Collection We perform garbage collection related work in a collector thread, which is run at low priority to avoid delaying application requests. The operating system ensures that the collector is not starved forever.
Reference: [ML95] <author> Umesh Maheshwari and Barbara Liskov. </author> <title> Collecting cyclic distributed garbage by controlled migration. </title> <booktitle> In Proceedings of PODC'95 Principles of Distributed Computing, </booktitle> <pages> pages 57-63, </pages> <year> 1995. </year>
Reference-contexts: Suppose that there are n partitions and the maximum inter-partition distance of any object from the global roots is l. The distance of an object is the smallest number of interpar- tition references in any path from a global root to the object <ref> [ML95] </ref>. We make another simplifying assumption that partitions are uniformly selected for tracing, for example, in round-robin order. Then, marks will propagate fully in l rounds, or n fi l partition traces. Note that this is the worst case bound given the round-robin order. <p> However, we simulate delays for log forces as if it were stored on a logging disk, separate from the database disk. Persistence of objects at the servers is governed by reachability from persistent roots. The task of garbage collection in Thor is distributed across servers and clients <ref> [ML94, ML95] </ref>, but this paper pertains to garbage collection within a single server. 5.2 Partitioned Collection We perform garbage collection related work in a collector thread, which is run at low priority to avoid delaying application requests. The operating system ensures that the collector is not starved forever. <p> Bishop proposed dividing a large address space into independently collectible partitions in 1977 [Bis77]. He proposed collecting cyclic garbage by migrating objects to partitions that reference them. Migration is also used in some distributed systems because it is fault tolerant and decentralized <ref> [SGP90, ML95] </ref>. The cost of migration is copying objects and patching up the references to the moved objects. Often, migration also requires inlists to track the identities of the source partitions for each incoming reference. <p> The 12 work focuses on supporting transactional mechanisms such as rollback. The collector uses the log to pick up updates, and the authors point out the need for efficient maintenance of stable inlists. Maheshwari and Liskov proposed migrating objects suspected to be cyclic garbage <ref> [ML95] </ref>. Suspects are found using the distance heuristic: The distance of an object is the minimum number of inter-partition references on any path from a global root to that object. An object with a large distance is highly likely to be cyclic garbage.
Reference: [MMH96] <author> J. Eliot B. Moss, David S. Munro, and Richard L. Hudson. Pmos: </author> <title> A complete and coarse-grained incremental garbage collector for persistent object stores. </title> <booktitle> In Proc. 7th Workshop on Persistent Object Systems, </booktitle> <year> 1996. </year>
Reference-contexts: Our work on using the log to maintain inlists and out- lists builds upon previous work by Ng [Ng96]. One other scheme, PMOS <ref> [MMH96] </ref>, makes use of a log to defer and batch processing of information about inter-partition references. However, PMOS processes garbage collection information when objects are fetched and evicted, which would slow down applications. Partitioned collection does not collect garbage cycles 1 that span partitions. <p> None of the above works addresses efficient maintenance of inter-partition references. The only previous work that addresses this issue is PMOS by Moss et al. <ref> [HM92, MMH96] </ref>. PMOS collects one segment at a time, which is the unit of both fetching and tracing. Each segment contains an inlist that identifies the source segments for incoming references.
Reference: [Ng96] <author> Tony Ng. </author> <title> Efficient garbage collection for large objectoriented databases. </title> <type> Technical Report MIT/LCS/TR-692, </type> <institution> MIT LCS, </institution> <year> 1996. </year>
Reference-contexts: The overall effect is that inter-partition references are handled efficiently, which makes it possible to use partitions that fit in a small fraction (say, a tenth) of the primary memory. Our work on using the log to maintain inlists and out- lists builds upon previous work by Ng <ref> [Ng96] </ref>. One other scheme, PMOS [MMH96], makes use of a log to defer and batch processing of information about inter-partition references. However, PMOS processes garbage collection information when objects are fetched and evicted, which would slow down applications. Partitioned collection does not collect garbage cycles 1 that span partitions. <p> While collecting a segment, objects are moved to the newest segments in the trains that refer to them. Thus, collecting a segment might involve accessing multiple target segments. Our work on using the log to maintain inlists and outlists builds upon previous work by Ng <ref> [Ng96] </ref>. His scheme scanned modified objects when they are truncated from the log, and put inter-partition references back into the log.
Reference: [NOPH92] <author> Scott M. Nettles, James W. O'Toole, David Pierce, and Nicholas Haines. </author> <title> Replication-based incremental copy-ing collection. </title> <booktitle> In Proc. IWMM, volume 637 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Tracing Scheme Our approach can be used in combination with various tracing schemes. For example, we could use a replicating collector like that described in <ref> [NOPH92] </ref>, in which applications access the old copies of segments while the collector is generating the new ones with the aid of the 4 modification log. Such a scheme requires little syn-chronization with applications, but needs space for two partitions in primary memory. <p> Like other unpartitioned schemes, this collector must make random accesses in the old space. O'Toole et al. proposed concurrent copying of a persistent heap by letting applications access the old space while the collector copies it to new space <ref> [NOPH92, ONG93] </ref>. The collector picks up the modifications made by the applications by using an update log. The scheme was designed for an unpartitioned heap that fit in the main memory.
Reference: [ONG93] <author> James W. O'Toole, Scott M. Nettles, and David Gifford. </author> <title> Concurrent compacting garbage collection of a persistent heap. </title> <booktitle> In Proc. 14th SOSP, </booktitle> <pages> pages 161-174, </pages> <year> 1993. </year>
Reference-contexts: In these systems, the heap resides on the disk because it is much larger than the main memory and must be recoverable after a crash. Applications access the objects through a memory cache and log updates for crash recovery. Schemes that trace the entire heap (e.g., <ref> [Bak78, KW93, ONG93] </ref>) do not scale to very large heaps because the non-local nature of tracing would cause random disk accesses. <p> Like other unpartitioned schemes, this collector must make random accesses in the old space. O'Toole et al. proposed concurrent copying of a persistent heap by letting applications access the old space while the collector copies it to new space <ref> [NOPH92, ONG93] </ref>. The collector picks up the modifications made by the applications by using an update log. The scheme was designed for an unpartitioned heap that fit in the main memory.
Reference: [RJ96] <author> Helena Rodrigues and Richard Jones. </author> <title> A cyclic dis-tributed garbage collector for network objects. </title> <booktitle> In Proc. 10th Workshop on Distributed Algorithms, </booktitle> <year> 1996. </year>
Reference-contexts: However, we cannot simply remove these inlist entries because that would break In- variant 2a and cause incorrect execution. Instead, we remove all references in the objects pointed by these entries, as in <ref> [RJ96] </ref>. This breaks garbage cycles and ultimately causes associated inlist entries to be removed. 4.4 Tracing a Partition Global marking is piggybacked on regular tracing of partitions. We set the mark bit of a partition after tracing it. <p> An object with a large distance is highly likely to be cyclic garbage. Although this reduces migration to the bare minimum, it still requires patching up references to the moved objects. Rodrigues and Jones collect cyclic garbage in a distributed system using a heuristic to group partitions <ref> [RJ96] </ref>. A group comprises partitions reached transitively from objects suspected to be cyclic garbage. Multiple sites on the same cycle may initiate separate groups simultaneously, which would fail to collect the cycle. Conversely, a group may include many more partitions than necessary because garbage objects can point to live objects.
Reference: [Ruf95] <author> Michel Ruffin. </author> <title> Log compaction and garbage col-lection: What could they bring to each other? In Proc. IWOOOS. </title> <publisher> IEEE Press, </publisher> <year> 1995. </year>
Reference-contexts: Yong et al. compared unpartitioned incremental copying, reference counting, and partitioned collection in a client-server object store and found partitioned collection to perform the best [YNY94]. Ruffin pointed out similarities between log compaction and garbage collection <ref> [Ruf95] </ref>. In particular, cleaning log segments, as in Sprite LFS, is similar to partitioned collection. However, inter-segment references need not be tracked because the liveness of a log record can be verified quickly given the file system structure.
Reference: [SGP90] <author> Marc Shapiro, O. Gruber, and David Plainfoss e. </author> <title> A garbage detection protocol for a realistic distributed objectsupport system. </title> <institution> Rapports de Recherche 1320, INRIARocquencourt, </institution> <year> 1990. </year>
Reference-contexts: Bishop proposed dividing a large address space into independently collectible partitions in 1977 [Bis77]. He proposed collecting cyclic garbage by migrating objects to partitions that reference them. Migration is also used in some distributed systems because it is fault tolerant and decentralized <ref> [SGP90, ML95] </ref>. The cost of migration is copying objects and patching up the references to the moved objects. Often, migration also requires inlists to track the identities of the source partitions for each incoming reference.
Reference: [Ung84] <author> David M. Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 19(5) </volume> <pages> 157-167, </pages> <year> 1984. </year>
Reference-contexts: Most generational schemes solve this problem by remembering the exact objects or locations in other partitions that refer to a given object <ref> [Ung84] </ref>, but this is too much information to maintain in a large heap. Therefore, we compact objects within each segment and thus preserve object names, as in [AGF95].
Reference: [YNY94] <author> V. Yong, J. Naughton, and J. Yu. </author> <title> Storage recla-mation and reorganization in clinet-server persistent object stores. </title> <booktitle> In Proc. Data Engineering, </booktitle> <pages> pages 120-133. </pages> <publisher> IEEE Press, </publisher> <year> 1994. </year> <month> 14 </month>
Reference-contexts: The scheme was designed for an unpartitioned heap that fit in the main memory. Yong et al. compared unpartitioned incremental copying, reference counting, and partitioned collection in a client-server object store and found partitioned collection to perform the best <ref> [YNY94] </ref>. Ruffin pointed out similarities between log compaction and garbage collection [Ruf95]. In particular, cleaning log segments, as in Sprite LFS, is similar to partitioned collection. However, inter-segment references need not be tracked because the liveness of a log record can be verified quickly given the file system structure.
References-found: 29

