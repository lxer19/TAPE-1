URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/elf-papers/rlf93.ps.gz
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/elf-papers/
Root-URL: 
Email: Internet: fp@cs.cmu.edu  
Title: Refinement Types for Logical Frameworks  
Author: Frank Pfenning 
Date: July 1993  
Address: Pittsburgh, Pennsylvania 15213-3891, U.S.A.  
Affiliation: Department of Computer Science Carnegie Mellon University  
Abstract: We propose a refinement of the type theory underlying the LF logical framework by a form of subtypes and intersection types. This refinement preserves desirable features of LF, such as decidability of type-checking, and at the same time considerably simplifies the representations of many deductive systems. A subtheory can be applied directly to hereditary Harrop formulas which form the basis of Prolog and Isabelle.
Abstract-found: 1
Intro-found: 1
Reference: [CDCV81] <author> Mario Coppo, Maria Dezani-Ciancaglini, and B. Venneri. </author> <title> Functional character of solvable terms. </title> <journal> Zeitschrift fur mathematische Logic und Grundlagen der Mathe-matik, </journal> <volume> 27 </volume> <pages> 45-58, </pages> <year> 1981. </year> <month> 12 </month>
Reference-contexts: Similar systems of simple subtypes have been used in programming languages, in particular in connection with record types and object-oriented programming, but such systems are not expressive enough for our purposes. More promising are enhancements of simple subtypes with intersection types <ref> [CDCV81] </ref>, which have been applied to programming languages [Rey91] and recently also in type theory [Hay91]. General decidability of type-checking or inference in such calculi is problematic, but under certain restrictions type checking is decidable and principal types exist [Rey88, FP91, CG92].
Reference: [CG92] <author> M. Coppo and P. Giannini. </author> <title> A complete type inference algorithm for simple intersec-tion types. </title> <editor> In J.-C. Raoult, editor, </editor> <booktitle> 17th Colloquium on Trees in Algebra and Programming, Rennes, France, </booktitle> <pages> pages 102-123, </pages> <address> Berlin, </address> <month> February </month> <year> 1992. </year> <note> Springer-Verlag LNCS 581. </note>
Reference-contexts: More promising are enhancements of simple subtypes with intersection types [CDCV81], which have been applied to programming languages [Rey91] and recently also in type theory [Hay91]. General decidability of type-checking or inference in such calculi is problematic, but under certain restrictions type checking is decidable and principal types exist <ref> [Rey88, FP91, CG92] </ref>. In this paper we tie together ideas from these threads of research and propose a refinement of the LF type theory by a version of bounded intersection types, or refinement types, as we call them.
Reference: [Fel89] <author> Amy Felty. </author> <title> Specifying and Implementing Theorem Provers in a Higher-Order Logic Programming Language. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <month> July </month> <year> 1989. </year> <note> Available as Technical Report MS-CIS-89-53. </note>
Reference-contexts: Natural Deductions in Normal Form. The next example illustrates that we often want to make subtype distinctions at the level of deductions and not only at the level of syntax. We follow the usual representation of natural deduction in LF [HHP93] and Felty's trick to enforce 3 normal forms <ref> [Fel89] </ref>. We restrict ourselves to the purely implicational fragment. x . . . I x A B A B The deduction in the premise of the implication introduction rule discharges the hypothesis A labelled x and is represented as a function from deductions of A to deductions of B.
Reference: [FP91] <author> Tim Freeman and Frank Pfenning. </author> <title> Refinement types for ML. </title> <booktitle> In Proceedings of the SIGPLAN '91 Symposium on Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pages 268-277. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: More promising are enhancements of simple subtypes with intersection types [CDCV81], which have been applied to programming languages [Rey91] and recently also in type theory [Hay91]. General decidability of type-checking or inference in such calculi is problematic, but under certain restrictions type checking is decidable and principal types exist <ref> [Rey88, FP91, CG92] </ref>. In this paper we tie together ideas from these threads of research and propose a refinement of the LF type theory by a version of bounded intersection types, or refinement types, as we call them. <p> We show that it has a decidable type-checking problem and is thus useful as a logical framework. We have not yet implemented this system, but experience with a related implementation of refinement types for ML <ref> [FP91] </ref> and the current Elf term reconstruction algorithm leads us to believe that type-checking will be practical. While similar in spirit to the work on refinement types for ML [FP91], the technical and practical issues in both systems are very different. <p> We have not yet implemented this system, but experience with a related implementation of refinement types for ML <ref> [FP91] </ref> and the current Elf term reconstruction algorithm leads us to believe that type-checking will be practical. While similar in spirit to the work on refinement types for ML [FP91], the technical and practical issues in both systems are very different. In ML, we are concerned with the decidability of type inference in the presence of general recursion and polymorphism. Here, we have to deal with type checking in a language without recursion or polymorphism, but with dependent types. <p> The type-checking algorithm which arises out of the proof of Theorem 6 works by bottom-up synthesis and is not practical. However, a top-down type-checking algorithm as in the implementation of refinement types for ML <ref> [FP91] </ref> promises to be of acceptable efficiency, especially since our language lacks recursion at the level of terms. We would also like to consider relaxing some of the restrictions currently in place to enforce orthogonality of conversion and subsorting.
Reference: [Gar92] <author> Philippa Gardner. </author> <title> Representing Logics in Type Theory. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <month> July </month> <year> 1992. </year> <note> Available as Technical Report CST-93-92. </note>
Reference-contexts: It is consistent with our system to allow refinement kinds, that is, declarations of the form k :: Type. This leads to a system which encompasses ELF + <ref> [Gar92] </ref> and could also yield a new view of type classes in the context of type theory. We plan to investigate the meta-theoretic properties of a type theory with refinement types and refinement kinds.
Reference: [Geu92] <author> Herman Geuvers. </author> <title> The Church-Rosser property for fi-reduction in typed -calculi. </title> <editor> In A. Scedrov, editor, </editor> <booktitle> Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 453-460, </pages> <address> Santa Cruz, California, June 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Lemma 3 The judgment U V is decidable on valid terms and every valid term U has a unique equivalent canonical form. Proof sketch: The corresponding judgment on LF is decidable on valid LF terms (see, for example, <ref> [Geu92] </ref>). Equivalence on types and kinds is structural and therefore trivially decidable, except for conversions among the embedded objects.
Reference: [Hay91] <author> Susumu Hayashi. </author> <title> Singleton, union and intersection types for program extraction. </title> <editor> In T. Ito and A. R. Meyer, editors, </editor> <booktitle> Proceedings of the International Conference on Theoretical Aspects of Software, </booktitle> <pages> pages 701-730, </pages> <address> Sendai, Japan, </address> <month> September </month> <year> 1991. </year> <note> Springer-Verlag LNCS 526. </note>
Reference-contexts: More promising are enhancements of simple subtypes with intersection types [CDCV81], which have been applied to programming languages [Rey91] and recently also in type theory <ref> [Hay91] </ref>. General decidability of type-checking or inference in such calculi is problematic, but under certain restrictions type checking is decidable and principal types exist [Rey88, FP91, CG92].
Reference: [HHP93] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Over the past two years we have carried out extensive experiments in the application of the LF Logical Framework <ref> [HHP93] </ref> to represent and implement deductive systems and their metathe-ory. Such systems arise naturally in the study of logic and the theory of programming languages. <p> Natural Deductions in Normal Form. The next example illustrates that we often want to make subtype distinctions at the level of deductions and not only at the level of syntax. We follow the usual representation of natural deduction in LF <ref> [HHP93] </ref> and Felty's trick to enforce 3 normal forms [Fel89]. We restrict ourselves to the purely implicational fragment. x . . . <p> Furthermore, every valid term U has a minimal type or kind. Proof sketch: Using the forgetful interpretation and the soundness and completeness of the algorithmic version of LF in <ref> [HHP93] </ref> we can show that each derivation can be transformed into one which eagerly applies normalization on types, but otherwise requires no type conversion.
Reference: [HP99] <author> Robert Harper and Frank Pfenning. </author> <title> A module system for a programming language based on the LF logical framework. </title> <journal> Journal of Functional Programming, </journal> <note> 199? To appear. </note>
Reference-contexts: One might also consider promotion of sorts to types and demotion of types to sorts which sometimes further economizes representations without making them less intuitive. We plan to investigate this in the context of the module system for LF described in <ref> [HP99] </ref>. Finally, there is the question of adequacy proofs for representations in & . The normal form theorem is useful here, but we would also like to give an interpretation which maps a signature in & into an equivalent signature in .
Reference: [HP92] <author> John Hannan and Frank Pfenning. </author> <title> Compiler verification in LF. </title> <editor> In Andre Scedrov, editor, </editor> <booktitle> Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 407-418, </pages> <address> Santa Cruz, California, June 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: For example, we have formalized the operational semantics and type system of Mini-ML and implemented a proof of type preservation [MP91] and the correctness of a compiler to a variant of the Categorical Abstract Machine <ref> [HP92] </ref>. LF is based on a predicative type theory with dependent types.
Reference: [Koh92] <author> Michael Kohlhase. </author> <title> Unification in order-sorted type theory. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Proceedings of the International Conference on Logic Programming and Automated Reasoning, </booktitle> <pages> pages 421-432, </pages> <address> St. Petersburg, Russia, July 1992. </address> <publisher> Springer-Verlag LNAI 624. </publisher>
Reference-contexts: However, it is not clear how to generalize these calculi to logics or type theories with higher-order functions, although recently some interesting work in this direction has begun <ref> [Koh92, NQ92] </ref>. Similar systems of simple subtypes have been used in programming languages, in particular in connection with record types and object-oriented programming, but such systems are not expressive enough for our purposes.
Reference: [KP93] <author> Michael Kohlhase and Frank Pfenning. </author> <title> Unification in a -calculus with intersection types. </title> <editor> In Dale Miller, editor, </editor> <booktitle> Proceedings of the International Logic Programming Symposium, </booktitle> <address> Vancouver, Canada, </address> <month> October </month> <year> 1993. </year> <note> MIT Press. To appear. </note>
Reference-contexts: The system we propose is relevant not only to LF and its Elf implementation, but a restricted version can be applied directly to Prolog [MNPS91] and Isabelle [PN90] with similar benefits. A unification algorithm for this restricted -calculus, !& is described in <ref> [KP93] </ref>. In future work, we plan to consider the operational aspects of this type theory so that it can be fully embedded into the current Elf implementation. This includes extending the constraint solving algorithm in [KP93] to account for dependencies in the style of [Pfe91a, Pfe91b], type reconstruction, and search. <p> A unification algorithm for this restricted -calculus, !& is described in <ref> [KP93] </ref>. In future work, we plan to consider the operational aspects of this type theory so that it can be fully embedded into the current Elf implementation. This includes extending the constraint solving algorithm in [KP93] to account for dependencies in the style of [Pfe91a, Pfe91b], type reconstruction, and search. <p> Many of the case studies of deductive systems in LF that we and others have carried out would benefit similarly. 10 5 Conclusion and Further Work We plan to implement the system & as an extension of Elf. This requires a generalization of the constraint solving algorithm in <ref> [KP93] </ref> to dependent types, and the development of a feasible type reconstruction algorithm. The type-checking algorithm which arises out of the proof of Theorem 6 works by bottom-up synthesis and is not practical.
Reference: [MNPS91] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: The system we propose is relevant not only to LF and its Elf implementation, but a restricted version can be applied directly to Prolog <ref> [MNPS91] </ref> and Isabelle [PN90] with similar benefits. A unification algorithm for this restricted -calculus, !& is described in [KP93]. In future work, we plan to consider the operational aspects of this type theory so that it can be fully embedded into the current Elf implementation. <p> Space only permits a rather sketchy discussion of these examples; the interested reader may find additional explanation in the indicated references. Hereditary Harrop Formulas. Here we consider, as an object logic, the language of hereditary Harrop formulas <ref> [MNPS91] </ref>, a fragment of logic suitable as a basis for a logic programming language. For the sake of brevity we restrict ourselves to the propositional formulas.
Reference: [MP91] <author> Spiro Michaylov and Frank Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <editor> In L.-H. Eriksson, L. Hallnas, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 299-344, </pages> <address> Stockholm, Sweden, </address> <month> January </month> <year> 1991. </year> <note> Springer-Verlag LNAI 596. </note>
Reference-contexts: Such systems arise naturally in the study of logic and the theory of programming languages. For example, we have formalized the operational semantics and type system of Mini-ML and implemented a proof of type preservation <ref> [MP91] </ref> and the correctness of a compiler to a variant of the Categorical Abstract Machine [HP92]. LF is based on a predicative type theory with dependent types.
Reference: [NQ92] <author> Tobias Nipkow and Zhenyu Qian. </author> <title> Reduction and unification in lambda calculi with subtypes. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 66-78, </pages> <address> Saratoga Springs, New York, June 1992. </address> <publisher> Springer-Verlag LNAI 607. </publisher>
Reference-contexts: However, it is not clear how to generalize these calculi to logics or type theories with higher-order functions, although recently some interesting work in this direction has begun <ref> [Koh92, NQ92] </ref>. Similar systems of simple subtypes have been used in programming languages, in particular in connection with record types and object-oriented programming, but such systems are not expressive enough for our purposes.
Reference: [Pfe91a] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: It has proved to be an excellent language for such formalization efforts, since it allows direct representation of deductions as objects and judgments as types and supports common concepts such as variable binding, substitution, and generic and hypothetical judgments. The logic programming language Elf <ref> [Pfe91a] </ref> implements LF and gives it an operational interpretation so that LF signatures can be executed as logic programs. It also provides sophisticated term reconstruction, which is important for realistic applications. Despite its expressive power, certain weaknesses of LF emerged during these experiments. <p> In future work, we plan to consider the operational aspects of this type theory so that it can be fully embedded into the current Elf implementation. This includes extending the constraint solving algorithm in [KP93] to account for dependencies in the style of <ref> [Pfe91a, Pfe91b] </ref>, type reconstruction, and search. Based on experience from first-order logic programming we conjecture that subtyping constraints can lead to improved operational behavior of many programs. 2 Two Motivating Examples In this section we give two prototypical examples which motivate our extension of the LF type theory.
Reference: [Pfe91b] <author> Frank Pfenning. </author> <title> Unification and anti-unification in the Calculus of Constructions. </title> <booktitle> In Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 74-85, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: In future work, we plan to consider the operational aspects of this type theory so that it can be fully embedded into the current Elf implementation. This includes extending the constraint solving algorithm in [KP93] to account for dependencies in the style of <ref> [Pfe91a, Pfe91b] </ref>, type reconstruction, and search. Based on experience from first-order logic programming we conjecture that subtyping constraints can lead to improved operational behavior of many programs. 2 Two Motivating Examples In this section we give two prototypical examples which motivate our extension of the LF type theory.
Reference: [Pie91] <author> Benjamin C. Pierce. </author> <title> Programming with Intersection Types and Bounded Polymor-phism. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <note> De-cember 1991. Available as Technical Report CMU-CS-91-205. </note>
Reference-contexts: Proof sketch: By an interpretation into the subtyping problem for Forsythe, for which a decidability proof has been given by Reynolds [personal communication, 1991]. The proof can be found in <ref> [Pie91] </ref> in a slightly different form. Each atomic type of the form a M 1 . . . M n is interpreted as a simple type a M 1 . . . M n which inherits its subsorting property from a.
Reference: [PN90] <author> Lawrence C. Paulson and Tobias Nipkow. </author> <title> Isabelle tutorial and user's manual. </title> <type> Technical Report 189, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: The system we propose is relevant not only to LF and its Elf implementation, but a restricted version can be applied directly to Prolog [MNPS91] and Isabelle <ref> [PN90] </ref> with similar benefits. A unification algorithm for this restricted -calculus, !& is described in [KP93]. In future work, we plan to consider the operational aspects of this type theory so that it can be fully embedded into the current Elf implementation.
Reference: [Rey88] <author> John C. Reynolds. </author> <title> Preliminary design of the programming language Forsythe. </title> <type> Technical Report CMU-CS-88-159, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylva-nia, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: More promising are enhancements of simple subtypes with intersection types [CDCV81], which have been applied to programming languages [Rey91] and recently also in type theory [Hay91]. General decidability of type-checking or inference in such calculi is problematic, but under certain restrictions type checking is decidable and principal types exist <ref> [Rey88, FP91, CG92] </ref>. In this paper we tie together ideas from these threads of research and propose a refinement of the LF type theory by a version of bounded intersection types, or refinement types, as we call them.
Reference: [Rey91] <author> John C. Reynolds. </author> <title> The coherence of languages with intersection types. </title> <editor> In T. Ito and A. R. Meyer, editors, </editor> <booktitle> International Conference on Theoretical Aspects of Computer Software, </booktitle> <pages> pages 675-700, </pages> <address> Sendai, Japan, </address> <month> September </month> <year> 1991. </year> <note> Springer-Verlag LNCS 526. </note>
Reference-contexts: Similar systems of simple subtypes have been used in programming languages, in particular in connection with record types and object-oriented programming, but such systems are not expressive enough for our purposes. More promising are enhancements of simple subtypes with intersection types [CDCV81], which have been applied to programming languages <ref> [Rey91] </ref> and recently also in type theory [Hay91]. General decidability of type-checking or inference in such calculi is problematic, but under certain restrictions type checking is decidable and principal types exist [Rey88, FP91, CG92].
Reference: [Smo89] <author> G. Smolka. </author> <title> Logic Programming over Polymorphically Order-Sorted Types. </title> <type> Dissertation, </type> <institution> Universitat Kaiserslautern, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Looking elsewhere, we find an extensive body 1 of work on order-sorted first-order calculi and their use in logic programming and automated theorem proving (see, for example, <ref> [Smo89, SS89] </ref>). However, it is not clear how to generalize these calculi to logics or type theories with higher-order functions, although recently some interesting work in this direction has begun [Koh92, NQ92].
Reference: [SS88] <author> Anne Salvesen and Jan M. Smith. </author> <title> The strength of the subset type in Martin-Lof's type theory. </title> <booktitle> In Third Annual Symposium on Logic in Computer Science, </booktitle> <address> Edinburgh, Scotland, </address> <pages> pages 384-391. </pages> <publisher> IEEE, </publisher> <month> July </month> <year> 1988. </year>
Reference-contexts: In practice, however, this becomes a significant burden, and encodings are further removed from informal mathematical practice than desirable. An obvious candidate for an extension of the type system are subset types as they are used for example in Martin-Lof type theory <ref> [SS88] </ref>. In a logical framework, however, they are problematic, because they lead to an undecidable type-checking problem. The methodology of LF reduces proof checking in the object language to type checking in the meta-language (the LF type theory), and thus decidability is important.
Reference: [SS89] <author> Manfred Schmidt-Schau. </author> <title> Computational Aspects of an Order-Sorted Logic with Term Declarations. </title> <publisher> Springer-Verlag LNAI 395, </publisher> <year> 1989. </year> <month> 14 </month>
Reference-contexts: Looking elsewhere, we find an extensive body 1 of work on order-sorted first-order calculi and their use in logic programming and automated theorem proving (see, for example, <ref> [Smo89, SS89] </ref>). However, it is not clear how to generalize these calculi to logics or type theories with higher-order functions, although recently some interesting work in this direction has begun [Koh92, NQ92].
References-found: 24

