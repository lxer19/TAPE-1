URL: http://www.cs.toronto.edu/~vassos/research/publications/LH97a/paper.ps.gz
Refering-URL: http://www.cs.toronto.edu/~vassos/research/list-of-publications.html
Root-URL: 
Email: wklo@cs.utoronto.ca  vassos@cs.utoronto.ca  
Title: wait-free hierarchies are not robust  
Author: Wai-Kau Lo Vassos Hadzilacos 
Note: All of us are smarter than any of us:  
Abstract: A wait-free hierarchy [Her91, Jay93] classifies object types on the basis of their strength in supporting wait-free implementations of other types. (In the context of the present paper, an implementation may use any number of objects of the given types, as well as read/write registers.) Such a hierarchy is robust if it is impossible to implement objects of types that it classifies as "strong" by combining objects of types that it classifies as "weak". We prove that, if nondeterministic types are allowed, the only wait-free hierarchy that is robust is the trivial one, which lumps all types into a single level. In particular, the Consensus hierarchy (the most closely studied wait-free hierarchy) is not robust. Our result implies that, in general, it is not possible to determine the power of a concurrent system that supports a given set of primitive object types by reasoning about the power of each primitive type in isolation. 
Abstract-found: 1
Intro-found: 1
Reference: [BGA94] <author> Elizabeth Borowsky, Eli Gafni, and Ye huda Afek. </author> <booktitle> Consensus power makes (some) sense! In Proceedings of the 13th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 363-372, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Borowsky et al. <ref> [BGA94] </ref>, and Peterson et al. [PBN94] proved that if we restrict our attention to deterministic types, the Consensus hierarchy is robust. <p> Due to space restrictions, in this extended abstract we focus exclusively on the (important) special case of the Consensus hierarchy. 1.2 Related work Jayanti was the first to raise and study the question of robustness of the Consensus hierarchy [Jay93]. As mentioned earlier, Borowsky et al. <ref> [BGA94] </ref> and Peterson et al. [PBN94] proved that the Consensus hierarchy, restricted to deterministic types, is robust. Under certain restrictions on how processes may use the base objects in an implementation, Chandra et al. [CHJT94] proved that the Consensus hierarchy is not robust if nondeterministic types are allowed.
Reference: [CHJT94] <author> Tushar Chandra, Vassos Hadzilacos, Prasad Jayanti, and Sam Toueg. </author> <title> Wait-freedom vs. t-resiliency and the robustness of the wait-free hierarchies. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 334-343, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: As mentioned earlier, Borowsky et al. [BGA94] and Peterson et al. [PBN94] proved that the Consensus hierarchy, restricted to deterministic types, is robust. Under certain restrictions on how processes may use the base objects in an implementation, Chandra et al. <ref> [CHJT94] </ref> proved that the Consensus hierarchy is not robust if nondeterministic types are allowed. This result was subsequently strengthened by Moran and Rappoport [MR96] who proved that (under the same restrictions on the use of base objects) the Consensus hierarchy is not robust even if only deterministic types are allowed.
Reference: [DDS87] <author> Danny Dolev, Cynthia Dwork, and Larry Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> 34(1) </volume> <pages> 77-97, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Limitations of the bivalence argument There is a standard technique for proving that there is no Consensus algorithm for n processes using a certain set of object types, known as "the bivalence argument" <ref> [FLP85, DDS87, LAA87, Her91] </ref>. Consider an assumed Consensus algorithm A c for two processes and focus on the full computation tree of A c from an initial configuration I in which the two processes have different initial values.
Reference: [FLP85] <author> Michael Fischer, Nancy Lynch, and Michael Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: In a seminal paper [Her91], Herlihy established an important link between a type's ability to support implementations of other types and its ability to solve the well-known Consensus problem <ref> [FLP85] </ref>. More specifically, he showed that, if objects of type T (together with registers) can be used to solve Consensus among n processes, then T can be used to implement any type in a system of n processes. We refer to this fact as "the universality of Consensus". <p> Limitations of the bivalence argument There is a standard technique for proving that there is no Consensus algorithm for n processes using a certain set of object types, known as "the bivalence argument" <ref> [FLP85, DDS87, LAA87, Her91] </ref>. Consider an assumed Consensus algorithm A c for two processes and focus on the full computation tree of A c from an initial configuration I in which the two processes have different initial values.
Reference: [Her91] <author> Maurice Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1) </volume> <pages> 124-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: In the rest of this paper, we consider only wait-free and linearisable implementations. A fundamental question is whether, in a system of n processes, it is possible to implement a type T from a given set of base types B. In a seminal paper <ref> [Her91] </ref>, Herlihy established an important link between a type's ability to support implementations of other types and its ability to solve the well-known Consensus problem [FLP85]. <p> Theorem 2 The algorithm in Figure 4 solves the Consensus problem for two processes using only negation objects, booster objects, and registers. Theorem 2 and the universality of Consensus (cf. <ref> [Her91] </ref>) imply that, in a system of two processes, we can implement any type using only booster and negation objects and registers. This means that by combining the two types, negation and booster, that are at level one of the Consensus hierarchy, we can implement any type at level two. <p> Limitations of the bivalence argument There is a standard technique for proving that there is no Consensus algorithm for n processes using a certain set of object types, known as "the bivalence argument" <ref> [FLP85, DDS87, LAA87, Her91] </ref>. Consider an assumed Consensus algorithm A c for two processes and focus on the full computation tree of A c from an initial configuration I in which the two processes have different initial values. <p> Theorem 4 Type booster has Consensus number one. Proof. Suppose, to the contrary, that booster has Consensus number at least two. Hence, we can solve Consensus for two processes using only booster objects and registers. By the universality of Consensus <ref> [Her91] </ref>, we can implement negation using only booster objects and registers in a system of two processes. Thus, we can solve Equality Negation between two processes using only booster objects and registers.
Reference: [HW92] <author> Maurice Herlihy and Jeannette Wing. Lin earizability: </author> <title> A correctness condition for concurrent objects. </title> <journal> ACM Transactions on Programming Language and System, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: All the shared objects used in the procedures written by the programmer must belong to types in B. We assume that the set of base types includes registers: any reasonable shared-memory system will provide at least this much. An implementation is required to be linearisable <ref> [HW92] </ref>: In any execution consisting of invocations of the procedures written by the programmer, where different procedures may be executing concurrently, each operation of the implemented object must appear to take effect atomically, at some point between the instant the corresponding procedure was called and the instant it returned.
Reference: [Jay93] <author> Prasad Jayanti. </author> <title> On the robustness of Her lihy's hierarchy. </title> <booktitle> In Proceedings of the 12th Annual ACM Symposium of Principles of Distributed Computing, </booktitle> <pages> pages 145-157, </pages> <year> 1993. </year>
Reference-contexts: Although Consensus numbers allow us to make pairwise comparisons on the strength of types, it is not clear whether they can also be used to answer the more general implementability question: Can we implement T from a set of base types B, in a system of n processes? Jayanti <ref> [Jay93] </ref> observed that Consensus numbers could be used to answer this question if the Consensus hierarchy has the property of robustness: i.e., no type at level n can be implemented from types at levels strictly below n, in a system of n processes. <p> Jayanti proved that only a coarsening of the Consensus hierarchy can have these properties <ref> [Jay93] </ref>. In the full paper we show that, in fact, the only hierarchy that has these properties is the trivial one in which all types are lumped into level one! We do this by exhibiting generalisations of the negation and booster types, called negation 1 and booster 1 . <p> Due to space restrictions, in this extended abstract we focus exclusively on the (important) special case of the Consensus hierarchy. 1.2 Related work Jayanti was the first to raise and study the question of robustness of the Consensus hierarchy <ref> [Jay93] </ref>. As mentioned earlier, Borowsky et al. [BGA94] and Peterson et al. [PBN94] proved that the Consensus hierarchy, restricted to deterministic types, is robust.
Reference: [LAA87] <author> Michael Loui and Hosame Abu-Amara. </author> <title> Memory requirements for agreement among unreliable asynchronous processes. </title> <booktitle> In Advances in Computer Research, </booktitle> <volume> volume 4, </volume> <pages> pages 163-183. </pages> <publisher> JAI Press Inc., </publisher> <year> 1987. </year>
Reference-contexts: Thus, by Lemma 2, there is a Consensus algorithm for two processes that uses only registers. It is well-known, however, that no such Consensus algorithm exists <ref> [LAA87] </ref>. Thus, Theorem 1 There is no algorithm that solves Equality Negation for two processes using registers alone. 5 Types negation and booster The specification of negation is given in Figure 2. The pseudocode describes the state transition relation of negation. <p> Limitations of the bivalence argument There is a standard technique for proving that there is no Consensus algorithm for n processes using a certain set of object types, known as "the bivalence argument" <ref> [FLP85, DDS87, LAA87, Her91] </ref>. Consider an assumed Consensus algorithm A c for two processes and focus on the full computation tree of A c from an initial configuration I in which the two processes have different initial values.
Reference: [LG86] <author> Barbara Liskov and John Guttag. </author> <title> Abstrac tion and specification in program development. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachu-setts, </address> <year> 1986. </year>
Reference-contexts: Although most types of practical interest are deterministic, some are best described nondeterminist-ically, and there are compelling reasons not to confine ourselves to deterministic restrictions of such types <ref> [LG86] </ref>. In this paper we prove that if we allow nondeterministic types, then the Consensus hierarchy is not robust.
Reference: [LH96a] <author> Wai-Kau Lo and Vassos Hadzilacos. </author> <title> All of us are smarter than any of us: more on the robustness of the Consensus hierarchy (Part I). </title> <type> Technical Report CSRI-348, </type> <institution> University of Toronto, Toronto, </institution> <address> Ontario, Canada, </address> <month> June </month> <year> 1996. </year> <note> Available at ftp://ftp.cs.utoronto.ca/pub/reports/csri/348. </note>
Reference-contexts: Due to space restrictions almost all proofs have been elided. Full details may be found in two technical reports (one dealing with our result for the Consensus hierarchy and another with the generalisation for arbitrary wait-free hierarchies) <ref> [LH96a, LH96b] </ref>. 2 The model of computation 2.1 Types and objects An object type is a tuple (Q; OP; RES; ffi).
Reference: [LH96b] <author> Wai-Kau Lo and Vassos Hadzilacos. </author> <title> All of us are smarter than any of us: more on the robustness of the Consensus hierarchy (Part II). </title> <type> Technical Report CSRI-351, </type> <institution> University of Toronto, Toronto, </institution> <address> Ontario, Canada, </address> <month> October </month> <year> 1996. </year> <note> Available at ftp://ftp.cs.utoronto.ca/pub/reports/csri/351. </note>
Reference-contexts: Due to space restrictions almost all proofs have been elided. Full details may be found in two technical reports (one dealing with our result for the Consensus hierarchy and another with the generalisation for arbitrary wait-free hierarchies) <ref> [LH96a, LH96b] </ref>. 2 The model of computation 2.1 Types and objects An object type is a tuple (Q; OP; RES; ffi).
Reference: [MR96] <author> Shlomo Moran and Lihu Rappoport. </author> <booktitle> On the robustness of h r m . In Proceedings of the 10th Workshop on Distributed Algorithms, </booktitle> <pages> pages 344-361, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Under certain restrictions on how processes may use the base objects in an implementation, Chandra et al. [CHJT94] proved that the Consensus hierarchy is not robust if nondeterministic types are allowed. This result was subsequently strengthened by Moran and Rappoport <ref> [MR96] </ref> who proved that (under the same restrictions on the use of base objects) the Consensus hierarchy is not robust even if only deterministic types are allowed. Closest to our work is a recent result of Schenk [Sch96], which preceded ours.
Reference: [PBN94] <author> Gary Peterson, Rida Bazzi, and Gil Nei ger. </author> <title> A gap theorem for consensus types. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 344-353, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Borowsky et al. [BGA94], and Peterson et al. <ref> [PBN94] </ref> proved that if we restrict our attention to deterministic types, the Consensus hierarchy is robust. A type is deterministic if, whenever we apply an operation to the type, the current state uniquely determines the response of the operation and the new state of the type. <p> As mentioned earlier, Borowsky et al. [BGA94] and Peterson et al. <ref> [PBN94] </ref> proved that the Consensus hierarchy, restricted to deterministic types, is robust. Under certain restrictions on how processes may use the base objects in an implementation, Chandra et al. [CHJT94] proved that the Consensus hierarchy is not robust if nondeterministic types are allowed.
Reference: [Sch96] <author> Eric Schenk. </author> <title> Computability and Complex ity Results for Agreement Problems in Shared Memory Distributed Systems. </title> <type> PhD thesis, </type> <institution> University of Toronto, </institution> <month> September </month> <year> 1996. </year>
Reference-contexts: This result was subsequently strengthened by Moran and Rappoport [MR96] who proved that (under the same restrictions on the use of base objects) the Consensus hierarchy is not robust even if only deterministic types are allowed. Closest to our work is a recent result of Schenk <ref> [Sch96] </ref>, which preceded ours. He also exhibits two nondeterministic object types each of which is individually too weak to solve Consensus between two processes, but which taken together can solve Consensus for any number of processes.
References-found: 14

