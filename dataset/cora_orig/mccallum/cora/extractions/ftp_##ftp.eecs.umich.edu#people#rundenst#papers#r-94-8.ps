URL: ftp://ftp.eecs.umich.edu/people/rundenst/papers/r-94-8.ps
Refering-URL: http://www.eecs.umich.edu/~rundenst/group/papers.html
Root-URL: http://www.cs.umich.edu
Email: e-mail: rundenst@eecs.umich.edu  
Title: A Classification Algorithm For Supporting Object-Oriented Views  
Author: Elke Angelika Rundensteiner 
Address: Ann Arbor, MI 48109-2122, 1301 Beal Avenue  
Affiliation: Dept. of Elect. Eng. and Computer Science; Software Systems Research Laboratory University of Michigan,  
Abstract: In recent years, object-oriented (OO) views have been recognized as a powerful mechanism for customizing the structural as well as behavioral aspects of interfaces to object-oriented databases (OODBs) for diverse users. In this context, classification is concerned with the integration of virtual classes derived using an OO query into one unifying schema. Existing approaches either require the user to explicitly specify the relationship between a virtual class and existing base classes, or they relate a virtual class directly with its source class(es) or with the root of the schema. In this paper, we propose a solution to this classification problem that accomplishes the following goals: (1) generate maximally informative, and thus comprehensible, schemas that explicitly model the subclass relationships between base and virtual classes, and (2) support efficient type resolution for shared property functions by supporting upwards inheritance for both base and virtual classes. Correctness and complexity of the classification algorithm are also discussed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abiteboul, S., and Bonner, A., </author> <title> "Objects and Views," </title> <booktitle> in Proc. SIGMOD'91, </booktitle> <pages> pp. 238 - 247. </pages>
Reference-contexts: Possible though not desirable solutions are to either duplicate code (no inheritance) or to replace the typical upwards method resolution by a more complex and inefficient upwards/downwards search strategy <ref> [1] </ref>. Instead, we propose a solution to this problem based on the idea of integrating intermediate classes into G that filter out the properties that are common to the existing classes in G and to the new class VC, so that they can be inherited by both. Example 2. <p> Due to space limitations, the reader is referred elsewhere for the proof and and further examples [15]. 8 RELATED WORK Our approach of providing for the integration of virtual classes into a unified global schema is distinct from others found in the literature <ref> [5, 18, 20, 1, 13, 3] </ref>. <p> In O2, while a global schema is not supported, select classes can be integrated into a view schema <ref> [1, 19] </ref>. However, they choose to enable selective upward versus downwards inheritance rather than creating intermediate classes and propagating methods. Hence, virtual classes do effectively not participate in the inheritance hierarchy. The third approach [3] ignores the issue of determining subclass relationships by introducing a parallel derived-from relationship hierarchy. <p> Our approach results in true upwards-inheritance of method code for both base and virtual classes, avoiding duplication of code and revision of the well-established inheritance search strategy (as proposed by others <ref> [1] </ref>). We have implemented a prototype of MultiView based on this classification approach using the Gemstone OODB marketed by Servio Corp.; as described elsewhere [7]. Acknowledgments. The author wishes to acknowledge Harumi A.
Reference: [2] <author> Beck, H. W., et al., </author> <title> "Classification as a Query Processing Technique in the CANDIDE Semantic Data Model," </title> <booktitle> SIGMOD, </booktitle> <year> 1989, </year> <pages> pp. 572 - 581. </pages>
Reference: [3] <author> Bertino, E., </author> <title> "A View Mechanism for OODBs," </title> <journal> EDBT, pp. </journal> <volume> 136 - 151, </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: Michigan Award Program, and Intel. itly the is-a relationship between a virtual class and existing base classes [20], or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [18]; or (3) simply relate a virtual class with its source class via a derived-from relationship <ref> [3] </ref>, or (4) with the root of the schema [5, 6]. The first approach is vulnerable to potential consistency problems, since the users might insert is-a arcs between two classes not related by a subclass relationship. <p> Due to space limitations, the reader is referred elsewhere for the proof and and further examples [15]. 8 RELATED WORK Our approach of providing for the integration of virtual classes into a unified global schema is distinct from others found in the literature <ref> [5, 18, 20, 1, 13, 3] </ref>. <p> the user to explicitly specify the subclass relationship between a virtual class and existing base classes [20, 9]; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [18]; or (3) simply relate a virtual class with its source class via a derived-from relationship <ref> [3] </ref>, (4) or with the root of the schema [5, 6]. <p> However, they choose to enable selective upward versus downwards inheritance rather than creating intermediate classes and propagating methods. Hence, virtual classes do effectively not participate in the inheritance hierarchy. The third approach <ref> [3] </ref> ignores the issue of determining subclass relationships by introducing a parallel derived-from relationship hierarchy. Property inheritance along these derivation (rather than generalization) relationships would have to be redefined. The fourth approach completely ignores the issue of classification, thus resulting in a flat class structure.
Reference: [4] <author> Brachman, R. J., and Schmolze, J. G., </author> <title> "An Overview of the KL-ONE Knowledge Representation System," </title> <journal> Cognitive Science, </journal> <volume> 9, </volume> <year> 1985. </year>
Reference: [5] <author> Heiler, S., and Zdonik, S. B., </author> <title> "Object views: Extending the vision," </title> <booktitle> In Proc. IEEE Data Engineering Conf., </booktitle> <address> Los Angeles, </address> <month> Feb. </month> <year> 1990, </year> <journal> pg. </journal> <volume> 86 - 93. </volume>
Reference-contexts: between a virtual class and existing base classes [20], or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [18]; or (3) simply relate a virtual class with its source class via a derived-from relationship [3], or (4) with the root of the schema <ref> [5, 6] </ref>. The first approach is vulnerable to potential consistency problems, since the users might insert is-a arcs between two classes not related by a subclass relationship. <p> Due to space limitations, the reader is referred elsewhere for the proof and and further examples [15]. 8 RELATED WORK Our approach of providing for the integration of virtual classes into a unified global schema is distinct from others found in the literature <ref> [5, 18, 20, 1, 13, 3] </ref>. <p> a virtual class and existing base classes [20, 9]; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [18]; or (3) simply relate a virtual class with its source class via a derived-from relationship [3], (4) or with the root of the schema <ref> [5, 6] </ref>. The first approach of view graph manipulation must deal with the issues of (a) possibly introducing inconsistencies into the view schema due to human error and of (b) unintentionally modifying the semantics of a virtual class due to side effects of graph manipulation.
Reference: [6] <author> Kim, W., </author> <title> A model of queries in object-oriented databases, </title> <booktitle> In Proc. Int. Conf. on Very Large Databases, </booktitle> <pages> pp. 423 - 432, </pages> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: Most research on OO views has focused on the definition of virtual classes using OO queries a direct parallel to view specification in relational databases. However, since an OO schema corresponds to a complex structure of classes interrelated via generalization and decomposition relationships <ref> [6] </ref>, we define an OO view (schema) to be a virtual, possibly restructured, subschema graph of the global schema [12]. Creating views in an OO model is thus not a simple transfer of the relational view solution to the OO model, rather several challenging new problems arise. <p> between a virtual class and existing base classes [20], or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [18]; or (3) simply relate a virtual class with its source class via a derived-from relationship [3], or (4) with the root of the schema <ref> [5, 6] </ref>. The first approach is vulnerable to potential consistency problems, since the users might insert is-a arcs between two classes not related by a subclass relationship. <p> In Section 6 we present algorithms to solve these two problems. We present related work, a discussion of MultiView, and conclusions in Sections 8, 9, and 10, respectively. 2 OBJECT-ORIENTED CONCEPTS 2.1 The Object Model Below we review terminology on object models <ref> [18, 9, 6] </ref> used in the remainder of the paper. A class C has a unique class name, a type and an extent 2 . The type of a class C, type (C), consists of a number of property functions, properties (type (C)), or short, properties (C). <p> For each p 2 properties t3 of t3, domain t3 (p) := domain t1 (p) [ domain t2 (p). 2 While there is no general agreement on whether a class construct should combine both type and extent concepts; many object models proposed in the literature follow this approach <ref> [9, 6] </ref>. (t1 t t2) is the greatest common subtype, and t1 u t2 the lowest common supertype of t1 and t2. <p> If this common supertype has additional properties besides those common to its two subtypes, then they would have also inherited them by the full inheritance principle <ref> [9, 6] </ref>. The later is clearly a contradiction. <p> a virtual class and existing base classes [20, 9]; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [18]; or (3) simply relate a virtual class with its source class via a derived-from relationship [3], (4) or with the root of the schema <ref> [5, 6] </ref>. The first approach of view graph manipulation must deal with the issues of (a) possibly introducing inconsistencies into the view schema due to human error and of (b) unintentionally modifying the semantics of a virtual class due to side effects of graph manipulation.
Reference: [7] <author> Kuno, H. A. and Rundensteiner, E. A., </author> <title> "Developing an Object-Oriented View Management System," IBM CASCON, </title> <address> Oct. </address> <year> 1993, </year> <pages> pp. 548 - 562. </pages> <institution> (also Univ. of Michi-gan, </institution> <type> Tech. Rep. </type> <institution> CSE-TR-191-93, </institution> <month> Aug. </month> <year> 1993). </year>
Reference-contexts: In this paper, we present the concepts and algorithms for our solution to this classification problem, which have lead to a successful implementation of MultiView <ref> [7] </ref>. The explicit capture of relationships between stored and derived classes in the form of a global schema graph brings numerous advantages. It is useful for sharing property functions (inheritance) and object instances among both base and virtual classes without unnecessary duplication of method code or data. <p> We have implemented a prototype of MultiView based on this classification approach using the Gemstone OODB marketed by Servio Corp.; as described elsewhere <ref> [7] </ref>. Acknowledgments. The author wishes to acknowledge Harumi A. Kuno, Young-Gook Ra and other students at the University of Michigan for their efforts in implementing the MultiView prototype.
Reference: [8] <author> Missikoff, M., and Scholl, M., </author> <title> "An Algorithm for Insertion into a Lattice: Application to Type Classification," </title> <booktitle> 3 rd Int. Conf. </booktitle> <address> FODD'89, </address> <month> June </month> <year> 1989, </year> <pages> pp. 64 - 82. </pages>
Reference-contexts: The result by Missikoff and Scholl <ref> [8] </ref> that the first set of types g i as specified in Lemma 1 is sufficient to guarantee the closure of the resulting type hierarchy is directly applicable to our research (See theorem below). <p> Proof: The proof is given in [15]. 5.3 Minimizing the Generation of Intermediate Classes Next, we discuss how to limit the number of intermediate classes g i generated for assuring closure of a schema <ref> [8] </ref>. Definition 12. Given a type hierarchy TG=(TV,TE) and a new type t V C to be integrated into TG. <p> For each equivalence group G i , there is one type t i 2 G i that is minimal and unique in G i . The proof of Theorem 1 can be found in <ref> [8] </ref>. Definition 13. Given G=(V,E) and VC to be integrated into G. <p> It can be shown that G* is isomorphic to GG defined above <ref> [8] </ref>. Theorem 4. Given a closed schema G=(V,E). The integration of a class C with type (C)=type (VC) and arbitrary extent results in a closed schema G'=(V',E') if we add the set of classes GG = fg i g as defined in Lemma 4. <p> is present in G, class integration of VC becomes a matter of finding the correct location for VC in G (Section 7). 6 TYPE HIERARCHY PREPARATION We now describe an algorithm for the creation of the intermediate classes required by the insertion of a new type into G based on <ref> [8] </ref>. We assume that G is represented by a table with four columns: class name C, the set of parents of C in G, a label "*" to mark members of G*, and the set of parents* of C in G*. <p> Thus, the creation of intermediate classes, as proposed in this paper, was not necessary for AI systems. The KL-ONE classifier deals with single-inheritance only, while our class placement algorithm handles multiple-inheritance schema graphs. Our work on classification is closely related to the research by Missikoff et al. <ref> [8] </ref> on inserting types into a lattice structure.
Reference: [9] <author> Morsi, M. M., Navathe, S. B., Kim, H. K., </author> <title> An Extensible Object-Oriented Database Testbed, </title> <booktitle> Int. Conf. on Data Engineering, </booktitle> <year> 1992, </year> <pages> pp. 150 - 157. </pages>
Reference-contexts: In Section 6 we present algorithms to solve these two problems. We present related work, a discussion of MultiView, and conclusions in Sections 8, 9, and 10, respectively. 2 OBJECT-ORIENTED CONCEPTS 2.1 The Object Model Below we review terminology on object models <ref> [18, 9, 6] </ref> used in the remainder of the paper. A class C has a unique class name, a type and an extent 2 . The type of a class C, type (C), consists of a number of property functions, properties (type (C)), or short, properties (C). <p> For each p 2 properties t3 of t3, domain t3 (p) := domain t1 (p) [ domain t2 (p). 2 While there is no general agreement on whether a class construct should combine both type and extent concepts; many object models proposed in the literature follow this approach <ref> [9, 6] </ref>. (t1 t t2) is the greatest common subtype, and t1 u t2 the lowest common supertype of t1 and t2. <p> without violating the set hierarchy constraints. 5 SOLVING THE TYPE INHERITANCE PROBLEM We now establish the foundation for a general approach to solve the type inheritance problem based on the strategy outlined in Example 2. 5.1 The Type Closure and Class Closure Properties In our object model and in others <ref> [9, 18] </ref>, a property is defined exactly once and, if used elsewhere, it is inherited from this original definition. This concept allows classes in a class hierarchy to share methods, rather than having to redefine them by coping the code. <p> If this common supertype has additional properties besides those common to its two subtypes, then they would have also inherited them by the full inheritance principle <ref> [9, 6] </ref>. The later is clearly a contradiction. <p> Existing approaches in the literature either: (1) require the user to explicitly specify the subclass relationship between a virtual class and existing base classes <ref> [20, 9] </ref>; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [18]; or (3) simply relate a virtual class with its source class via a derived-from relationship [3], (4) or with the root of the schema [5, 6]. <p> The first approach of view graph manipulation must deal with the issues of (a) possibly introducing inconsistencies into the view schema due to human error and of (b) unintentionally modifying the semantics of a virtual class due to side effects of graph manipulation. For example, in <ref> [9] </ref>, the addition of an is-a relationship may add new inherited attributes to the virtual type, so the specification of a virtual class (both type and extent) is dynamically recomputed for each view in which it is inserted.
Reference: [10] <editor> J. Mylopoulos, et. al., </editor> <title> "A Language Facility for Designing DB-Intensive Applications," </title> <journal> in ACM TODS, </journal> <volume> vol. 5, issue 2, </volume> <pages> pp. 185-207, </pages> <month> June </month> <year> 1980. </year>
Reference: [11] <author> Nebel, B., </author> <title> "Terminological Reasoning Is Inherently Intractable," </title> <booktitle> in AI, 43 (1990), </booktitle> <pages> pp. 235 - 249. </pages>
Reference-contexts: In addition, it solves two problems related to classification in OODBs that existing approaches <ref> [11] </ref> do not handle. They are (1) type inheritance mismatch for virtual classes and (2) is-a incompatibility for composed subset/subtype hierarchies.
Reference: [12] <author> Rundensteiner, E. A., </author> <title> "MultiView: A Methodology for Supporting Multiple View Schemata in OODBs," </title> <journal> VLDB'92, pp. </journal> <volume> 187 - 198, </volume> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: However, since an OO schema corresponds to a complex structure of classes interrelated via generalization and decomposition relationships [6], we define an OO view (schema) to be a virtual, possibly restructured, subschema graph of the global schema <ref> [12] </ref>. Creating views in an OO model is thus not a simple transfer of the relational view solution to the OO model, rather several challenging new problems arise. <p> The third approach ignores the issue of determining subclass relationships by introducing a parallel derived-from relationship hierarchy. Finally, the last approach completely ignores the issue of classification, thus resulting in a flat `relational-type' class structure. Our view system MultiView <ref> [12, 16] </ref> is unique in that it automatically organizes both base and virtual classes into one comprehensive global schema graph based on which object-oriented views virtual, possibly restructured, subschema graphs of the global schema can be specified in a consistent manner. <p> A view (schema) is defined to be a schema VS= (VV,VE) with the following properties: (a) VS has a unique view identifier denoted by &lt; V S &gt;, (b) VV V, and (c) VE transitive-closure (E). 3 THE MultiView METHODOLOGY We have developed the view methodology, MultiView <ref> [12] </ref>, which breaks view specification into the three tasks: 1. the generation of customized (virtual) classes using object-oriented queries, 2. the integration of derived classes into one consistent global schema graph, and 3. the specification of arbitrarily complex view schemas composed of both base and virtual classes on top of the <p> In this paper, we present a solution to the second task, while solutions to the other tasks of MultiView are given elsewhere <ref> [12, 16] </ref>. The separation of the view design process into a number of well-defined tasks has several advantages. First, it simplifies the view specification and maintenance, since each of the tasks can be solved independently from the others. <p> First, it simplifies the view specification and maintenance, since each of the tasks can be solved independently from the others. Second, it increases the level of schema design support by allowing for the automation of some tasks. The first task of MultiView <ref> [12] </ref> supports the customization of existing classes by deriving virtual classes with a modified type description and membership extent. Similar to other researchers (e.g., Scholl et al. [18]), we restrict the query language to be an object-preserving algebra, i.e., all objects in virtual classes are also members of base classes [12]. <p> <ref> [12] </ref> supports the customization of existing classes by deriving virtual classes with a modified type description and membership extent. Similar to other researchers (e.g., Scholl et al. [18]), we restrict the query language to be an object-preserving algebra, i.e., all objects in virtual classes are also members of base classes [12]. This guarantees that virtual classes in MultiView are updatable [18, 12]. The third task of MultiView utilizes the augmented global schema for the selection of (both base and virtual) classes and for arranging these view classes in a consistent class hierarchy, called a view schema. <p> Similar to other researchers (e.g., Scholl et al. [18]), we restrict the query language to be an object-preserving algebra, i.e., all objects in virtual classes are also members of base classes [12]. This guarantees that virtual classes in MultiView are updatable <ref> [18, 12] </ref>. The third task of MultiView utilizes the augmented global schema for the selection of (both base and virtual) classes and for arranging these view classes in a consistent class hierarchy, called a view schema.
Reference: [13] <author> Rundensteiner, E. A., and Bic, L., </author> <title> "Set Operations in Object-Based Data Models", </title> <journal> in IEEE Trans. on Data and Knowledge Eng. </journal> <volume> Vol. 4, Iss. 3, </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: A class is a container for a set of object instances, denoted by extent (C) <ref> [13] </ref>. 2.2 Type Hierarchy and Type Relationships Definition 1. <p> This would still be a correct but possibly not the most informative class arrangement. 4.1 The Type Inheritance Problem Based on our distinction between the type and the extent of a class <ref> [13] </ref>, we have identified two problems of classification in OO data models not handled by simple subsumption. The first problem is concerned with constructing a type hierarchy that assures the inheritance of property functions for both base and virtual classes after the insertion of new classes [18]. <p> Due to space limitations, the reader is referred elsewhere for the proof and and further examples [15]. 8 RELATED WORK Our approach of providing for the integration of virtual classes into a unified global schema is distinct from others found in the literature <ref> [5, 18, 20, 1, 13, 3] </ref>.
Reference: [14] <author> Rundensteiner, E. A., </author> <title> "Design Tool Integration Using Object-Oriented Database Views," </title> <booktitle> IEEE Int. Conf. on CAD' Nov. </booktitle> <year> 1993, </year> <pages> pp. 104 - 107. </pages>
Reference-contexts: However, we found that this was not a problem for the example views we studied for interfacing design tools with a CAD database using MultiView <ref> [14] </ref>. Two reasons were: (1) there generally is a limited number of views of interest for a given application, and (2) different views often share subparts of the global schema. The overhead involved in maintaining an intermediate (i.e., virtual) class is minimal.
Reference: [15] <author> Rundensteiner, E. A., </author> <title> "A Class Integration Algorithm and Its Application for Supporting Consistent Object Views," </title> <type> Info. </type> <institution> and Computer Science Dept., Univ. of Cal., Irvine, </institution> <type> Tech. Rep. </type> <pages> 92-50, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Our approach also supports the promotion of method code up to virtual classes, so that inheritance of properties can be achieved using the well-established search strategy of upwards method resolution for both base and virtual classes. Correctness and complexity for the classification algorithm have been shown <ref> [15] </ref>. In Section 2, we introduce OO concepts related to views. In Section 3, we introduce MultiView, and Section 4 characterizes the two class integration problems. Section 5 presents results concerning the type inheritance problem. In Section 6 we present algorithms to solve these two problems. <p> Proof: The proof is given in <ref> [15] </ref>. 5.3 Minimizing the Generation of Intermediate Classes Next, we discuss how to limit the number of intermediate classes g i generated for assuring closure of a schema [8]. Definition 12. Given a type hierarchy TG=(TV,TE) and a new type t V C to be integrated into TG. <p> Proof: The proof is given in <ref> [15] </ref>. Lemma 5. Assume that the integration of VC into the closed schema G=(V,E) forces the creation of intermediate classes GG = f g i j i = 1, ..., m g. <p> More formally, for all C j 2 G i , all classes C k 2 V with (C j is-a * C k ) and (C k is-a * rep (G i )) must also be members of G i . Proof: The proof is given in <ref> [15] </ref>. 5.4 Interconnecting Intermediate Classes Let f () denote the function defined by f (t j ) = (t j u V C) = g j . Then, the reverse function f 1 (g j ) turns the canonical representative t j of the group G i . <p> Proof: The proof of correctness is given in <ref> [15] </ref>. A detailed description of the algorithm in Figure 5 and its analysis can be found in [15]. Note that it handles multiple inheritance, which often has been ignored by other classification algorithms in the literature. <p> Proof: The proof of correctness is given in <ref> [15] </ref>. A detailed description of the algorithm in Figure 5 and its analysis can be found in [15]. Note that it handles multiple inheritance, which often has been ignored by other classification algorithms in the literature. Since both the computation of the direct parent and children set can be done in linear time, the complexity of the overall class placement algorithm is linear. <p> We put the algorithms presented in Sections 4.1 and above together to solve the complete classification problem (Figure 6). Detailed examples of applying the classification algorithm can be found in <ref> [15] </ref>. procedure Integration (G,VC) begin Generate-Intermediate-Classes (G,VC); Class-Placement (G,VC); end procedure 7.1 SOLVING SUBSET/TYPE INCOMPATIBILITY It can be shown that the algorithm designed to solve the type inheritance mismatch problem (Section 5) also successfully addresses the is-a incompatibility problem for the object algebra of MultiView [15]. <p> algorithm can be found in <ref> [15] </ref>. procedure Integration (G,VC) begin Generate-Intermediate-Classes (G,VC); Class-Placement (G,VC); end procedure 7.1 SOLVING SUBSET/TYPE INCOMPATIBILITY It can be shown that the algorithm designed to solve the type inheritance mismatch problem (Section 5) also successfully addresses the is-a incompatibility problem for the object algebra of MultiView [15]. Due to space limitations, the reader is referred elsewhere for the proof and and further examples [15]. 8 RELATED WORK Our approach of providing for the integration of virtual classes into a unified global schema is distinct from others found in the literature [5, 18, 20, 1, 13, 3]. <p> SOLVING SUBSET/TYPE INCOMPATIBILITY It can be shown that the algorithm designed to solve the type inheritance mismatch problem (Section 5) also successfully addresses the is-a incompatibility problem for the object algebra of MultiView <ref> [15] </ref>. Due to space limitations, the reader is referred elsewhere for the proof and and further examples [15]. 8 RELATED WORK Our approach of providing for the integration of virtual classes into a unified global schema is distinct from others found in the literature [5, 18, 20, 1, 13, 3].
Reference: [16] <author> Rundensteiner, E. A., </author> <title> "Tools for View Generation in OODBs," </title> <booktitle> ACM 2nd CIKM, </booktitle> <month> Nov. </month> <year> 1993, </year> <pages> pp. 635 - 644. </pages>
Reference-contexts: The third approach ignores the issue of determining subclass relationships by introducing a parallel derived-from relationship hierarchy. Finally, the last approach completely ignores the issue of classification, thus resulting in a flat `relational-type' class structure. Our view system MultiView <ref> [12, 16] </ref> is unique in that it automatically organizes both base and virtual classes into one comprehensive global schema graph based on which object-oriented views virtual, possibly restructured, subschema graphs of the global schema can be specified in a consistent manner. <p> Another advantage is improved performance for query processing. Finally, a comprehensive global schema reduces the problem of composing both base and virtual classes into a consistent view schema to a simple graph-theoretic algorithm <ref> [16] </ref>. Manual class integration would require the view definer to be knowledgeable about all classes in the global schema, even those that are not related to her view schema 1 . As the size of the schema graph grows, this becomes a more involved process. <p> In this paper, we present a solution to the second task, while solutions to the other tasks of MultiView are given elsewhere <ref> [12, 16] </ref>. The separation of the view design process into a number of well-defined tasks has several advantages. First, it simplifies the view specification and maintenance, since each of the tasks can be solved independently from the others. <p> This supports for instance the virtual restructuring of the is-a hierarchy by selectively hiding or exposing classes within a view schema. In <ref> [16] </ref>, we present a graph algorithm that augments a set of selected view classes to generate a valid view schema hierarchy. 4 CLASSIFICATION IN OODBs Classification is the process of taking a new class description and putting it where it belongs in the class hierarchy (Definition 6).
Reference: [17] <author> Schmolze, J. G., and Lipkis, T. A., </author> <title> Classification in the KL-ONE Knowledge Representation System, </title> <address> IJCAI'83, </address> <month> Aug. </month> <year> 1983, </year> <title> vol.1, </title> <journal> pg. </journal> <volume> 330 - 332. </volume>
Reference-contexts: For this purpose, we assume a boolean function subsumes (). Such a subsumes () function is not decidable in general since it may involve the comparison of arbitrary methods and predicates <ref> [17] </ref>. Therefore, our classification algorithm is sound but not complete. For instance, if two classes have methods with equivalent semantics but different code, then the subsumes () function will fail even though these two classes may indeed by equivalent. <p> Property inheritance along these derivation (rather than generalization) relationships would have to be redefined. The fourth approach completely ignores the issue of classification, thus resulting in a flat class structure. Schmolze and Lipkis <ref> [17] </ref> describe a classifier for `concepts' in KL-ONE. KL-ONE does not include behavioral abstractions and abstract data types as found in OO models. Hence, the type inheritance mismatch problem is not ad dressed by their solution.
Reference: [18] <author> Scholl, M. H., Laasch, C. and Tresch, M., </author> <title> Updatable Views in OODBs, </title> <booktitle> Proc. 2nd DOOD Conf., </booktitle> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: research was supported in part by NSF under grants RIA #IRI-9309076 and NYI #IRI-9457609, University of Michigan Award Program, and Intel. itly the is-a relationship between a virtual class and existing base classes [20], or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship <ref> [18] </ref>; or (3) simply relate a virtual class with its source class via a derived-from relationship [3], or (4) with the root of the schema [5, 6]. <p> In Section 6 we present algorithms to solve these two problems. We present related work, a discussion of MultiView, and conclusions in Sections 8, 9, and 10, respectively. 2 OBJECT-ORIENTED CONCEPTS 2.1 The Object Model Below we review terminology on object models <ref> [18, 9, 6] </ref> used in the remainder of the paper. A class C has a unique class name, a type and an extent 2 . The type of a class C, type (C), consists of a number of property functions, properties (type (C)), or short, properties (C). <p> Second, it increases the level of schema design support by allowing for the automation of some tasks. The first task of MultiView [12] supports the customization of existing classes by deriving virtual classes with a modified type description and membership extent. Similar to other researchers (e.g., Scholl et al. <ref> [18] </ref>), we restrict the query language to be an object-preserving algebra, i.e., all objects in virtual classes are also members of base classes [12]. This guarantees that virtual classes in MultiView are updatable [18, 12]. <p> Similar to other researchers (e.g., Scholl et al. [18]), we restrict the query language to be an object-preserving algebra, i.e., all objects in virtual classes are also members of base classes [12]. This guarantees that virtual classes in MultiView are updatable <ref> [18, 12] </ref>. The third task of MultiView utilizes the augmented global schema for the selection of (both base and virtual) classes and for arranging these view classes in a consistent class hierarchy, called a view schema. <p> The first problem is concerned with constructing a type hierarchy that assures the inheritance of property functions for both base and virtual classes after the insertion of new classes <ref> [18] </ref>. As we demonstrate below, in some cases there may be no correct placement for a virtual class VC. Example 1. <p> without violating the set hierarchy constraints. 5 SOLVING THE TYPE INHERITANCE PROBLEM We now establish the foundation for a general approach to solve the type inheritance problem based on the strategy outlined in Example 2. 5.1 The Type Closure and Class Closure Properties In our object model and in others <ref> [9, 18] </ref>, a property is defined exactly once and, if used elsewhere, it is inherited from this original definition. This concept allows classes in a class hierarchy to share methods, rather than having to redefine them by coping the code. <p> Due to space limitations, the reader is referred elsewhere for the proof and and further examples [15]. 8 RELATED WORK Our approach of providing for the integration of virtual classes into a unified global schema is distinct from others found in the literature <ref> [5, 18, 20, 1, 13, 3] </ref>. <p> Existing approaches in the literature either: (1) require the user to explicitly specify the subclass relationship between a virtual class and existing base classes [20, 9]; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship <ref> [18] </ref>; or (3) simply relate a virtual class with its source class via a derived-from relationship [3], (4) or with the root of the schema [5, 6]. <p> The second approach is prone to misrepresenting the subclass relationships because a derived class may not be is-a related to its immediate source class. It would at best result in a partial, hence less informative, classification of class extents. Scholl et al. <ref> [18] </ref> sketch the class integration process in the context of their COCOON system, i.e., they determine whether a derived class should be placed lower or higher than their source classes.
Reference: [19] <author> C. Souza dos Santos, S. Abitebou, and C. Delobel, </author> <title> Virtual schemas and bases, </title> <publisher> EDBT'94. </publisher>
Reference-contexts: In O2, while a global schema is not supported, select classes can be integrated into a view schema <ref> [1, 19] </ref>. However, they choose to enable selective upward versus downwards inheritance rather than creating intermediate classes and propagating methods. Hence, virtual classes do effectively not participate in the inheritance hierarchy. The third approach [3] ignores the issue of determining subclass relationships by introducing a parallel derived-from relationship hierarchy.
Reference: [20] <author> Tanaka, K., Yoshikawa, M., and Ishihara, K., </author> <title> "Schema Virtualization in Object-Oriented Databases," </title> <booktitle> In Proc. IEEE Data Engineering Conf., </booktitle> <month> Feb. </month> <year> 1988, </year> <journal> pg. </journal> <volume> 23 - 30. </volume>
Reference-contexts: Approaches in the literature either (1) require the user to specify explic 0 This research was supported in part by NSF under grants RIA #IRI-9309076 and NYI #IRI-9457609, University of Michigan Award Program, and Intel. itly the is-a relationship between a virtual class and existing base classes <ref> [20] </ref>, or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [18]; or (3) simply relate a virtual class with its source class via a derived-from relationship [3], or (4) with the root of the schema [5, 6]. <p> Due to space limitations, the reader is referred elsewhere for the proof and and further examples [15]. 8 RELATED WORK Our approach of providing for the integration of virtual classes into a unified global schema is distinct from others found in the literature <ref> [5, 18, 20, 1, 13, 3] </ref>. <p> Existing approaches in the literature either: (1) require the user to explicitly specify the subclass relationship between a virtual class and existing base classes <ref> [20, 9] </ref>; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [18]; or (3) simply relate a virtual class with its source class via a derived-from relationship [3], (4) or with the root of the schema [5, 6].
References-found: 20

