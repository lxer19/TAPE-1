URL: http://www.cs.princeton.edu/~appel/papers/inlining.ps
Refering-URL: http://www.cs.princeton.edu/~appel/papers/
Root-URL: http://www.cs.princeton.edu
Title: Lambda-Splitting: A Higher-Order Approach to Cross-Module Optimizations  
Author: Matthias Blume Andrew W. Appel 
Date: April 2, 1997  
Note: Princeton University,  
Abstract: We describe an algorithm for automatic inline expansion across module boundaries that works in the presence of higher-order functions and free variables; it rearranges bindings and scopes as necessary to move nonexpansive code from one module to another. We describe|and implement|the algorithm as transformations on -calculus. Our inliner interacts well with separate compilation and is efficient, robust, and practical enough for everyday use in the SML/NJ compiler. Inlining improves performance by 4-8% on existing code, and makes it possible to use much more data abstraction by consistently eliminating penalties for modularity. 
Abstract-found: 1
Intro-found: 1
Reference: [AM94] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Separate compilation for Standard ML. </title> <booktitle> In Proc. SIGPLAN '94 Symp. on Prog. Language Design and Implementation, </booktitle> <pages> pages 13-23. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: Type checking already imposes an ordering on compilation steps, guaranteeing that whenenver a module B refers to something exported from module A, then A must be compiled before B, thereby ensuring that inlining information from A will be available at the time when B is compiled. Appel and MacQueen <ref> [AM94] </ref> describe how Standard ML of New Jersey implements separate compilation. Since this is the basis for our approach we will summarize it here: 1 In this paper we use the term module to always refer to compilation units, not to elements of the SML module language.
Reference: [App92] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, England, </address> <year> 1992. </year>
Reference-contexts: Our framework can easily be adapted to take account of external hints. -splitting moves function bodies from one module to another, but ensuring that these functions are then inlined within the importing module is up to the existing intramod-ule inliner <ref> [App92] </ref>, which does a good but not perfect job. <p> A compilation unit consists of a number of definitions for types, values, signatures, structures, and functors. Types and signatures are relevant only for dealing with static semantics and can be ignored as far as linking, a dynamic concept, is concerned. The SML/NJ intermediate representation (-language <ref> [App92] </ref>) represents structures as records, and functors as functions, and does not distinguish between the core and module languages. Each compilation unit is turned into a -expression, where references to identifiers from other compilation units appear as free variables. <p> Thus, splitting decisions can be made with finer granularity. The structure of the intermediate language described in appendix A automatically enforces this. Continuation-passing style <ref> [Ste78, App92] </ref> would do as well; but the SML/NJ compiler transforms to CPS at a late stage after type information is discarded. We would rather preserve the ability to do monomorphic instantiation of polymorphic functions [SA95] after cross-module inlining has been done. <p> In order to obtain a better idea of how much cross-module inlining itself affects overall performance, we will use SML/NJ with -contract enabled as the baseline for our comparisons. This compiler already does aggressive in-tramodular inlining <ref> [App92] </ref>; we measure only the increased performance from inlining across module boundaries and from pulling inlinable code out of higher-order functions. 6.2 Timing results from -splitting with -splitting enabled. The numbers reported correspond to compiler passes that took at least one second of user time. <p> We believe our results are not due to "random" variations in cache-conflict performance. Functional programs with properly tuned garbage collectors are not subject to many data-cache conflicts [Rei94, GA95], and informal inspection of the results did not reveal the kind of instruction-cache conflict variability <ref> [App92, p. 194] </ref> to which SML/NJ was subject on previous-generation architectures. 6.3 SML/NJ without ad-hoc inlining Cross-module inlining is so crucial for performance that the implementors of SML/NJ decided to compromise abstraction and modularity in some places, because for a selection of the most important operations inline-expansion is absolutely necessary.
Reference: [App93] <author> Andrew W. Appel. </author> <title> A critique of Standard ML. </title> <journal> J. Functional Programming, </journal> <volume> 3(4) </volume> <pages> 391-430, </pages> <year> 1993. </year>
Reference-contexts: But we can do even more. Standard ML has always had the problem that efficient implementations of datatypes break down at functor-parameter boundaries <ref> [App93] </ref>. By representing concrete data types as abstract data types, so that constructors and pattern-matching represented using functions and function calls, we can solve this problem.
Reference: [BDGK94] <author> Koen De Bosschere, Saumya Debray, David Gune-man, and Sampath Kannan. </author> <title> Call forwarding: a simple interprocedural optimization technique for dynamically typed languages. </title> <booktitle> In POPL '94: 21ST ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 409-420, </pages> <year> 1994. </year>
Reference-contexts: Therefore, our al-gorithm never places expansive code or code that is deemed too big into the i-portion of a split. The idea of splitting functions into pieces can also be used to facilitate intramoduler optimizations like "call forwarding" <ref> [BDGK94] </ref> or partial inlining [Gou94]. 4.1 The basic algorithm In SML/NJ a compilation unit translates into a sequence of nested variable bindings (let-bindings), some of which can be recursive. The rightmost body of the rightmost let-expression then builds a record of exported values.
Reference: [Blu95] <author> Matthias Blume. </author> <title> Standard ML of New Jersey com pilation manager. </title> <booktitle> Manual accompanying SML/NJ software, </booktitle> <year> 1995. </year>
Reference-contexts: In particular, no changes had to be made to either the front-end (including symbol table management), the optimizer, or the various architecture-specific back-ends. -splitting fits neatly between existing compiler phases. We changed the format of object files to accommodate symbolic -code and modified SML/NJ's compilation manager <ref> [Blu95] </ref>. Dependency analysis now has to take into account that compilation units are connected via static environments (i.e., symbol tables) and inlinable code. This does not change the shape of the dependency graph, but it has an impact on how modifications to one unit propagate to other, dependent units.
Reference: [Blu97] <author> Matthias Blume. </author> <title> Hierarchical Modularity and Inter-modular Optimization. </title> <type> PhD thesis, </type> <institution> Princeton University, </institution> <note> expected 1997. </note>
Reference-contexts: This quantity cannot be calculated precisely, but we can use a static estimator N (: : :), which is able to identify many of the bad cases <ref> [Blu97] </ref>. Moreover, inherent imprecisions do not have any bearing on correctness of the overall algorithm. 4.5 B-decomposition algorithm Some bindings need not b appear in U i because the variables they bind are not referenced.
Reference: [CHT91] <author> Keith D. Cooper, Mary W. Hall, and Linda Torczon. </author> <title> An experiment with inline substitution. </title> <journal> Software| Practice and Experience, </journal> <volume> 21(6) </volume> <pages> 581-601, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: But the automatic cross-module inlining schemes used to date have not treated free variables, nested scopes, higher-order functions, or link-time side effects from module-level initializers <ref> [DH88, CHT91, CMCH92] </ref>. They cannot move a function-body from module A to module B if the function has a free variable that is not exported from A and cannot be copied into B. This limits the generality of existing approaches, especially when applied to higher-order functional languages. <p> Furthermore, by tuning a few compile-time parameters one can adjust the aggressiveness of cross-module inlining or turn it off completely. In contrast to previous experiments <ref> [Sch77, CHT91] </ref> that did not explain how to preserve efficient separate compilation while inlining, our technique is fully integrated with SML/NJ's separate compilation system: it cleanly exports inlinable portions of one compilation unit through the binary object file into the importing module.
Reference: [CMCH92] <author> Pohua P. Chang, Scott A. Mahlke, William Y. Chen, and Wen-Mei W. Hwu. </author> <title> Profile-guided automatic inline expansion for c programs. </title> <journal> Software|Practice and Experience, </journal> <volume> 22(5) </volume> <pages> 349-369, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: But the automatic cross-module inlining schemes used to date have not treated free variables, nested scopes, higher-order functions, or link-time side effects from module-level initializers <ref> [DH88, CHT91, CMCH92] </ref>. They cannot move a function-body from module A to module B if the function has a free variable that is not exported from A and cannot be copied into B. This limits the generality of existing approaches, especially when applied to higher-order functional languages. <p> Resource-conscious programmers often like to say explicitly that they believe certain procedure calls should be inline-expanded. Performance hints from a profiling feedback system <ref> [CMCH92] </ref> can play a similarly important role.
Reference: [DH88] <author> Jack W. Davidson and Anne M. Holler. </author> <title> A study of a C function inliner. </title> <journal> Software|Practice and Experience, </journal> <volume> 18(8) </volume> <pages> 775-790, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: But the automatic cross-module inlining schemes used to date have not treated free variables, nested scopes, higher-order functions, or link-time side effects from module-level initializers <ref> [DH88, CHT91, CMCH92] </ref>. They cannot move a function-body from module A to module B if the function has a free variable that is not exported from A and cannot be copied into B. This limits the generality of existing approaches, especially when applied to higher-order functional languages.
Reference: [FSDF93] <author> Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen. </author> <title> The Essence of Compiling with Continuations. </title> <booktitle> In 1993 Conference on Programming Language Design and Implementation., </booktitle> <pages> pages 21-25, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Of course, some of the bindings in U e may become unnecessary. But the intramodular optimizer will delete dead bindings. 4.2 A-normal form To break large expressions into inlinable pieces we use a variant of A-normal form <ref> [FSDF93] </ref> as our calculus for - splitting. The property we are interested in is that every intermediate result will be explicitly bound to a variable, because this increases the number of bindings while on average reducing the size of the expressions being bound.
Reference: [GA95] <author> Marcelo J. R. Gon~calves and Andrew W. Appel. </author> <title> Cache performance of fast-allocating programs. </title> <booktitle> In Proc. Seventh Int'l Conf. on Functional Programming and Computer Architecture, </booktitle> <pages> pages 293-305. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: Overall speedup due to cross-module inlining is at 6% with and 5% without counting effects from -contract. We believe our results are not due to "random" variations in cache-conflict performance. Functional programs with properly tuned garbage collectors are not subject to many data-cache conflicts <ref> [Rei94, GA95] </ref>, and informal inspection of the results did not reveal the kind of instruction-cache conflict variability [App92, p. 194] to which SML/NJ was subject on previous-generation architectures. 6.3 SML/NJ without ad-hoc inlining Cross-module inlining is so crucial for performance that the implementors of SML/NJ decided to compromise abstraction and modularity
Reference: [Gou94] <author> Jean Goubault. </author> <title> Generalized boxing, congruences and partial inlining. </title> <booktitle> In Static Analysis Symposium '94, number 864 in Lecture Notes in Computer Science, </booktitle> <pages> pages 147-161. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Therefore, our al-gorithm never places expansive code or code that is deemed too big into the i-portion of a split. The idea of splitting functions into pieces can also be used to facilitate intramoduler optimizations like "call forwarding" [BDGK94] or partial inlining <ref> [Gou94] </ref>. 4.1 The basic algorithm In SML/NJ a compilation unit translates into a sequence of nested variable bindings (let-bindings), some of which can be recursive. The rightmost body of the rightmost let-expression then builds a record of exported values.
Reference: [HM95] <author> Robert Harper and Greg Morrisett. </author> <title> Compiling poly-morphism using intensional type analysis. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 130-141, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: from the burden of having to worry about many "micro-optimizations." The relationship between functions to be inlined and source-level constructs is not always obvious to the programmer, especially in implementations that pass type information at runtime, and which therefore may encode polymorphism as abstraction and type specialization as function application <ref> [Oho92, Tol94, HM95] </ref>. Resource-conscious programmers often like to say explicitly that they believe certain procedure calls should be inline-expanded. Performance hints from a profiling feedback system [CMCH92] can play a similarly important role.
Reference: [JPS96] <author> Simon Peyton Jones, Will Partain, and Andre San-tos. Let-floating: </author> <title> moving bindings to give faster programs. </title> <booktitle> In 1996 SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 3-12, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: For example, if the right-hand side of a variable binding is another binding form itself, then the order of the two can be exchanged. This technique is knows as let-floating <ref> [JPS96] </ref>: let val a = in A end ) in let val a = A end No ff-conversion is necessary here because variable names are guaranteed to be distinct. <p> We hope to improve the situation with a better closure-conversion algorithm, much later in the compiler after - contract, -splitting, and intramodular optimization. Even without fi-reductions and with let-floating <ref> [JPS96] </ref> alone we sometimes found performance to be slightly diminished. Reordering let-bindings in itself does not change the size of any closure, it only moves bound variables closer to the expressions they are bound to.
Reference: [JW96] <author> Suresh Jagannathan and Andrew Wright. </author> <title> Flow-directed Inlining. </title> <booktitle> Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 193-205, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Since our intermodule inlining algorithm preserves separate compilation, it must make decisions without seeing the client modules, so we rely on simple syntactic cues instead of powerful dataflow analyses <ref> [JW96] </ref> that could aid inlining decisions. 2 Example Consider a simple procedure, which maintains the maximum of the values it has been presented with so far.
Reference: [KKR + 86] <author> D. Kranz, R. Kelsey, J. Rees, P. Hudak, J. Philbin, and N. Adams. </author> <title> ORBIT: An optimizing compiler for Scheme. </title> <booktitle> SIGPLAN Notices (Proc. Sigplan '86 Symp. on Compiler Construction), </booktitle> <volume> 21(7) </volume> <pages> 219-33, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Our approach should be applicable to a wide range of languages and compilers with intermediate languages based on -calculi <ref> [KKR + 86, Pey87] </ref>. -calculus has the advantage over competing intermediate representations of being a well-studied logical system. It also proved to be very convenient for expressing the necessary transformations in our prototype.
Reference: [Mac90] <author> David B. MacQueen. </author> <title> A higher-order type system for functional programming. </title> <booktitle> In Research Topics in Functional Programming, </booktitle> <pages> pages 353-68, </pages> <address> Reading, MA, 1990. </address> <publisher> Addison-Wesley. </publisher>
Reference-contexts: Standard ML provides only first-order functors, but this has been taken a step further in SML/NJ by offering a higher-order module system <ref> [Mac90, MT94] </ref>. Functors can be defined within functors, they can be passed as functor arguments, and they may be returned as part of functor 2 the functor into the client by copying FI into each client and fi-reducing it.
Reference: [MT94] <author> David B. MacQueen and Mads Tofte. </author> <title> A semantics for higher-order functors. </title> <booktitle> In Proc. European Symposium on Programming (ESOP'94), </booktitle> <pages> pages 409-423, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Standard ML provides only first-order functors, but this has been taken a step further in SML/NJ by offering a higher-order module system <ref> [Mac90, MT94] </ref>. Functors can be defined within functors, they can be passed as functor arguments, and they may be returned as part of functor 2 the functor into the client by copying FI into each client and fi-reducing it.
Reference: [Oho92] <author> Atsushi Ohori. </author> <title> A compilation method for ml-style polymorphic record calculi. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 154-165. </pages> <publisher> ACM Press, </publisher> <month> Jan </month> <year> 1992. </year>
Reference-contexts: from the burden of having to worry about many "micro-optimizations." The relationship between functions to be inlined and source-level constructs is not always obvious to the programmer, especially in implementations that pass type information at runtime, and which therefore may encode polymorphism as abstraction and type specialization as function application <ref> [Oho92, Tol94, HM95] </ref>. Resource-conscious programmers often like to say explicitly that they believe certain procedure calls should be inline-expanded. Performance hints from a profiling feedback system [CMCH92] can play a similarly important role.
Reference: [Pey87] <editor> Simon L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: Our approach should be applicable to a wide range of languages and compilers with intermediate languages based on -calculi <ref> [KKR + 86, Pey87] </ref>. -calculus has the advantage over competing intermediate representations of being a well-studied logical system. It also proved to be very convenient for expressing the necessary transformations in our prototype.
Reference: [Rei94] <author> Mark B. Reinhold. </author> <title> Cache performance of garbage-collected programs. </title> <booktitle> In Proc. SIGPLAN '94 Symp. on Prog. Language Design and Implementation, </booktitle> <pages> pages 206-217. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1994. </year> <month> 12 </month>
Reference-contexts: Overall speedup due to cross-module inlining is at 6% with and 5% without counting effects from -contract. We believe our results are not due to "random" variations in cache-conflict performance. Functional programs with properly tuned garbage collectors are not subject to many data-cache conflicts <ref> [Rei94, GA95] </ref>, and informal inspection of the results did not reveal the kind of instruction-cache conflict variability [App92, p. 194] to which SML/NJ was subject on previous-generation architectures. 6.3 SML/NJ without ad-hoc inlining Cross-module inlining is so crucial for performance that the implementors of SML/NJ decided to compromise abstraction and modularity
Reference: [SA94] <author> Zhong Shao and Andrew W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In Proc. 1994 ACM Conf. on Lisp and Functional Programming, </booktitle> <pages> pages 150-161, </pages> <address> New York, 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: If we start with cleanly structured code, then gains are substantial and competitive with previous ad-hoc approaches that resorted to sacrificing abstraction and modularity. 8 Future work We intend to find appropriate heuristics for 1-decomposition. The closure-conversion algorithm, though already quite sophisticated <ref> [SA94] </ref>, must be improved to undo harmful effects of -contract (fi-reductions and let-floating). Now that the penalties for using abstract data types across module boundaries have been eliminated, we can clean up all the ad-hoc inlining of arithmetic primitives that pervade SML/NJ. But we can do even more.
Reference: [SA95] <author> Zhong Shao and Andrew W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In Proc 1995 ACM Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 116-129. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: Continuation-passing style [Ste78, App92] would do as well; but the SML/NJ compiler transforms to CPS at a late stage after type information is discarded. We would rather preserve the ability to do monomorphic instantiation of polymorphic functions <ref> [SA95] </ref> after cross-module inlining has been done. As an example of how A-normal form helps inlining, consider that the expression bound to x in let val x = (1, ref 0) in (x, y) end is expansive, because ref 0 is expansive.
Reference: [Sch77] <author> Robert W. Scheifler. </author> <title> An analysis of inline substitution for a structured programming language. </title> <journal> Communications of the ACM, </journal> <volume> 20(9) </volume> <pages> 647-654, </pages> <year> 1977. </year>
Reference-contexts: Furthermore, by tuning a few compile-time parameters one can adjust the aggressiveness of cross-module inlining or turn it off completely. In contrast to previous experiments <ref> [Sch77, CHT91] </ref> that did not explain how to preserve efficient separate compilation while inlining, our technique is fully integrated with SML/NJ's separate compilation system: it cleanly exports inlinable portions of one compilation unit through the binary object file into the importing module.
Reference: [Ste78] <author> Guy L. Steele. Rabbit: </author> <title> a compiler for Scheme. </title> <type> Technical Report AI-TR-474, </type> <institution> MIT, </institution> <address> Cambridge, MA, </address> <year> 1978. </year>
Reference-contexts: Thus, splitting decisions can be made with finer granularity. The structure of the intermediate language described in appendix A automatically enforces this. Continuation-passing style <ref> [Ste78, App92] </ref> would do as well; but the SML/NJ compiler transforms to CPS at a late stage after type information is discarded. We would rather preserve the ability to do monomorphic instantiation of polymorphic functions [SA95] after cross-module inlining has been done.
Reference: [TMC + 96] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A Type-Directed Optimizing Compiler for ML. </title> <booktitle> In 1996 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <year> 1996. </year>
Reference-contexts: We run the -splitter early to be able to take advantage of type information that is not present in later stages of the current SML/NJ compiler. Perhaps, in compilers where the intermediate language is typed at all times <ref> [TMC + 96] </ref> - splitting can be moved to such a later stage, and the need for -contract and its associated redundancy can be eliminated. 4 4.4 Call counting One major soure of inefficiencies related to separate compilation is the need for a generic function call protocol, which has to be
Reference: [Tol94] <author> Andrew Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. 1994 ACM Conf. on Lisp and Functional Programming, </booktitle> <pages> pages 1-11. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year> <month> 13 </month>
Reference-contexts: from the burden of having to worry about many "micro-optimizations." The relationship between functions to be inlined and source-level constructs is not always obvious to the programmer, especially in implementations that pass type information at runtime, and which therefore may encode polymorphism as abstraction and type specialization as function application <ref> [Oho92, Tol94, HM95] </ref>. Resource-conscious programmers often like to say explicitly that they believe certain procedure calls should be inline-expanded. Performance hints from a profiling feedback system [CMCH92] can play a similarly important role.
References-found: 27

