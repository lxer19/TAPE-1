URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/ifl98.ps.gz
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/
Root-URL: http://www.cs.yale.edu
Email: reid-alastair@cs.yale.edu,  
Title: Putting the Spine back in the Spineless Tagless G-Machine: an implementation of revertible blackholes  
Author: Alastair Reid 
Web: http://www.cs.yale.edu/~reid-alastair/  
Address: New Haven CT 06520, USA,  
Affiliation: Yale University,  
Abstract: Interrupt handling is a tricky business in lazy functional languages: we have to make sure that thunks that are being evaluated can be halted and later restarted if and when they are required. This is a particular problem for implementations which use blackholing. Blackholing deliberately makes it impossible to revert such thunks to their original state to avoid a serious space leak. Interactive Haskell implementations such as Hugs and hbi catch interrupts and avoid the problem by omitting or disabling blackholing. Batch mode Haskell implementations such as HBC and the Glasgow Haskell Compiler (GHC) avoid this problem by disabling blackholing or by providing no way to catch interrupts. This paper describes a modification to GHC's abstract machine (the Spineless Tagless G-Machine) which simultaneously supports both interrupts and blackholing.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Jones. </author> <title> The implementation of the Gofer functional programming system. </title> <institution> Research Report YALEU/DCS/RR-1030, Yale University, </institution> <address> New Haven, Connecticut, USA, </address> <month> May </month> <year> 1994. </year> <note> Available on the World-Wide Web from http://www.cs.nott.ac.uk/Department/Staff/mpj/pubs.html. </note>
Reference-contexts: This section outlines three ways of catching interrupts. Only the first one has been implemented as yet. Fig. 1. Reverting Blackholes 4.1 Catching Interrupts in an Interpreter Catching interrupts is absolutely essential in an interactive system such as Gofer <ref> [1] </ref> or Hugs: we have to be able to terminate long-running programs or programs that have entered infinite loops and continue. We have written a modified version of Hugs which uses the STG machine for evaluation.
Reference: 2. <author> R. E. Jones. </author> <title> Tail recursion without space leaks. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(1) </volume> <pages> 73-79, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Blackholing <ref> [2] </ref> is an important technique for avoiding space leaks in lazy functional languages. When a program starts to evaluate an unevaluated thunk, it copies the contents of the thunk onto the stack (or into registers) and overwrites the thunk with an object known as a "black hole". <p> Jones <ref> [2] </ref> shows that simple tail-recursive functions such as last can run in constant space with blackholing but require linear space without. The problem with blackholing is that it assumes that evaluation of a thunk will not stop until the value of the thunk has been found.
Reference: 3. <author> S. Peyton Jones. </author> <title> Implementing lazy functional languages on stock hardware: </title> <journal> the Spineless Tagless G-machine. Journal of Functional Programming, </journal> <volume> 2(2) </volume> <pages> 127-202, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Our solution to these problems is not to revert the blackhole to its original form but to revert the blackhole to (a representation of) its current partially evaluated state. On the Spineless Tagless Graph-reduction Machine (STG machine) <ref> [3] </ref>, the state of a partially evaluated thunk is stored on the stack; nave implementations of graph reduction do not use the stack in this way: they store the entire state of a thunk on the "spine" of the thunk. <p> We therefore dub our technique "Putting the Spine back in the Spineless Tagless G-Machine." 2 Updates in the STG machine The STG machine is described in detail by Simon Peyton-Jones <ref> [3] </ref>; here we provide an overview of the most important parts of the evaluation and update machinery. On a nave implementation of graph reduction, an update is performed on each reduction step. <p> This section describes how reverting blackholes interacts with four such optimisations and extensions. 5.1 Lazy Blackholing Section 9.3.3 of the STG paper <ref> [3] </ref> describes an optimisation of blackholing known as "lazy blackholing" which delays blackholing a thunk until the next garbage collection. When garbage collection occurs, it is a simple matter to run down the list of updatees and blackhole any thunks which are not already blackholed.
Reference: 4. <author> S. Peyton Jones, A. Gordon, and S. Finne. </author> <title> Concurrent Haskell. </title> <booktitle> In Conference record of POPL '96: 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 295-308, </pages> <address> St. Petersburg Beach, FL, </address> <month> January </month> <year> 1996. </year> <note> ACM press. </note>
Reference-contexts: Every time the evaluator enters a node, it tests this flag to see whether it should terminate the current evaluation by reverting all blackholes on the update list. 4.2 Catching Interrupts in Concurrent Haskell To catch interrupts in Concurrent Haskell <ref> [4] </ref> we need to add two things: 1. The ability to terminate a thread; and 2. The ability to wait for an interrupt to occur. It is then straightforward to create threads which wait for interrupts and kill other threads when they occur. <p> The blackholes are reverted exactly as before and the exception handling frame has been turned into a CATCH node containing the handler h, the application node a and the data A. 5.4 Concurrency The STG machine has been extended to support concurrent threads <ref> [4] </ref>. In a concurrent system, blackholing is modified as follows. We add a queue of threads to every blackhole | this is the "blocking queue" of the blackhole. The first time a thunk is entered, it is overwritten with a blackhole with an empty queue.
Reference: 5. <author> A. Reid. </author> <title> Handling exceptions in Haskell. </title> <note> Submitted to PADL'99, </note> <year> 1998. </year>
Reference-contexts: The blackholes are reverted exactly as before and the seq frame has been turned into a SEQ node containing a pointer to a. 5.3 Exception handling We recently extended the STG machine with an exception handling mechanism <ref> [5] </ref> which uses the update list to store exception handlers as well as upda-tees. If the evaluator finds an exception handler on the update list when it is trying to return a value, it removes the exception handler and tries again.
References-found: 5

