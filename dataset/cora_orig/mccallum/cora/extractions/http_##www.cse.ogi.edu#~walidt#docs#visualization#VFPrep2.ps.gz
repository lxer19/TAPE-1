URL: http://www.cse.ogi.edu/~walidt/docs/visualization/VFPrep2.ps.gz
Refering-URL: http://www.cse.ogi.edu/~walidt/docs/visualization/
Root-URL: http://www.cse.ogi.edu
Email: joel@cs.murdoch.edu.au  
Title: A Visual Representation for Functional Programs visual representation for functional program expressions is defined: expressions
Author: Joel Kelso 
Note: A  
Date: December 1994  
Abstract: Functional programming languages have features that make them attractive for software development and for the teaching of programming concepts. Like all conventional programming languages they are tied to an inherently one-dimensional textual programming style. Visual programming seeks to enhance the development and understanding of software, by utilizing the human brain's natural visual/spatial processing abilities. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Report on the programming language Haskell, </institution> <year> 1992. </year>
Reference-contexts: A overview of the representation and editing system is given below, along with its relation to the existing work on visual functional languages. Throughout the report we use Haskell <ref> [1] </ref> as an archetypal functional language, although the representation could be used for similar languages such Miranda 1 [7] or Hope [2]. 1.1 Functional expressions as graphs The rationale behind using graphs for the representation of functional programs rests on two observations. <p> Representation for Functional Languages 8 J.K.Kelso A Visual Representation for Functional Languages 9 The actual type is represented simply by the ASCII string of a Haskell type declaration (the type notation used, including type variables and the curried representation of functions with multiple arguments, is described in the Haskell report <ref> [1] </ref>). It is possible to represent types pictorially, but this suffers from the same problem as for function names, as mentioned in the footnote to the previous section. 2.2.1 Type contexts Parametric polymorphism allows functions with types that are parameterized by type variables.
Reference: [2] <author> R.M. Burstall, D.B. MacQueen, and D.T. Sanella. </author> <title> Hope: and experimental applicative language. </title> <type> Technical Report CSR-62-80, </type> <institution> University of Edinburgh, </institution> <year> 1980. </year>
Reference-contexts: Throughout the report we use Haskell [1] as an archetypal functional language, although the representation could be used for similar languages such Miranda 1 [7] or Hope <ref> [2] </ref>. 1.1 Functional expressions as graphs The rationale behind using graphs for the representation of functional programs rests on two observations. Firstly, programming language expressions, because their syntax is defined by a grammar, are essentially tree-like; and secondly, that the common model of functional program execution is graph reduction.
Reference: [3] <author> M. Edel. </author> <title> The Tinkertoy graphical programming environment. </title> <booktitle> In IEEE Proceedings COMPSAC, </booktitle> <pages> pages 466-471. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1986. </year>
Reference-contexts: We represent individual functions as graph nodes; the application of a function to an argument sub-expression is represented by an arc between nodes. This is the most common representation for functional languages in the Visual Programming literature, and is used in various forms in <ref> [3] </ref>, [4] and [6]. The basic unit of program construction in our representation is the expression-graph: a function that has been applied to zero or more arguments. An expression-graph has an implicit value (which may be a ground data value or may be function valued) and an explicit type.
Reference: [4] <author> M. Najork and E. Golin. </author> <title> Enhancing Show-and-Tell with a polymorphic type system and higher-order functions. </title> <booktitle> In Proceedings of the 1990 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 215-220. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference-contexts: We represent individual functions as graph nodes; the application of a function to an argument sub-expression is represented by an arc between nodes. This is the most common representation for functional languages in the Visual Programming literature, and is used in various forms in [3], <ref> [4] </ref> and [6]. The basic unit of program construction in our representation is the expression-graph: a function that has been applied to zero or more arguments. An expression-graph has an implicit value (which may be a ground data value or may be function valued) and an explicit type. <p> VisaVis, introduced in [6], has been extended with an implicit incremental type system that allows a form of parametric polymorphism and function overloading [5]. Show-and-Tell, a visual teaching language, has also been extended to include an explicit polymorphic type system <ref> [4] </ref>. The proposed representation is based on Haskell's type system, with its parametric polymorphism and type class overloading scheme. 2 Anatomy of an expression-graph In this section we describe the visual syntax of our representation, starting with the basic arc-node structure. Figure 1 shows a simple expression-graph.
Reference: [5] <author> Jorg Poswig and Claudio Moraga. </author> <title> Incremental type systems and implicit parametric overloading in visual languages. </title> <booktitle> In Proceedings of the 1993 IEEE Symposium on Visual Languages, </booktitle> <pages> pages 126-133. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> August </month> <year> 1993. </year>
Reference-contexts: This is not seen as a serious limitation, since making type annotations for such functions is regarded as good programming practice in any case. VisaVis, introduced in [6], has been extended with an implicit incremental type system that allows a form of parametric polymorphism and function overloading <ref> [5] </ref>. Show-and-Tell, a visual teaching language, has also been extended to include an explicit polymorphic type system [4].
Reference: [6] <author> Jorg Poswig, Guido Vrankar, and Claudio Moraga. </author> <title> VisaVis contributions to practice and theory of highly interactive visual languages. </title> <booktitle> In Proceedings of the 1992 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 155-161. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: We represent individual functions as graph nodes; the application of a function to an argument sub-expression is represented by an arc between nodes. This is the most common representation for functional languages in the Visual Programming literature, and is used in various forms in [3], [4] and <ref> [6] </ref>. The basic unit of program construction in our representation is the expression-graph: a function that has been applied to zero or more arguments. An expression-graph has an implicit value (which may be a ground data value or may be function valued) and an explicit type. <p> This is not seen as a serious limitation, since making type annotations for such functions is regarded as good programming practice in any case. VisaVis, introduced in <ref> [6] </ref>, has been extended with an implicit incremental type system that allows a form of parametric polymorphism and function overloading [5]. Show-and-Tell, a visual teaching language, has also been extended to include an explicit polymorphic type system [4].
Reference: [7] <author> D.A. Turner. </author> <title> Miranda a non-strict functional language with polymorphic types. </title> <booktitle> In Proc. Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 1-16. </pages> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: A overview of the representation and editing system is given below, along with its relation to the existing work on visual functional languages. Throughout the report we use Haskell [1] as an archetypal functional language, although the representation could be used for similar languages such Miranda 1 <ref> [7] </ref> or Hope [2]. 1.1 Functional expressions as graphs The rationale behind using graphs for the representation of functional programs rests on two observations.
References-found: 7

