URL: http://www.cs.arizona.edu/people/will/papers/memcheck.ps.gz
Refering-URL: http://www.cs.arizona.edu/people/will/papers.html
Root-URL: http://www.cs.arizona.edu
Title: Checking the Correctness of Memories  
Author: Manuel Blum Will Evans Peter Gemmell Sampath Kannan Moni Naor 
Date: October 29, 1992  
Abstract: We extend the notion of program checking to include programs which alter their environment. In particular, we consider programs which store and retrieve data from memory. The model we consider allows the checker a small amount of reliable memory. The checker is presented with a sequence of requests (on-line) to a data structure which must reside in a large but unreliable memory. We view the data structure as being controlled by an adversary. We want the checker to perform each operation in the input sequence using its reliable memory and the unreliable data structure so that any error in the operation of the structure will be detected by the checker with high probability. We present checkers for various data structures. We prove lower bounds of log n on the amount of reliable memory needed by these checkers where n is the size of the structure. The lower bounds are information theoretic and apply under various assumptions. We also show time-space tradeoffs for checking random access memories as a generalization of those for coherent functions.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Adelman, M. Huang, and K. Kompella, </author> <title> Efficient checkers for number-theoretic computation. </title> <type> preprint. </type>
Reference-contexts: 1 Introduction The program checking model was introduced in [3] and several subsequent papers <ref> [4, 1, 14] </ref> have provided checkers for classical computational problems. The model was introduced as a practical means of checking that programs for these problems are correct. Rather than certifying that the program is always correct, a program checker certifies that on any given input the program is correct.
Reference: [2] <author> M. Blum, W. Evans, P. Gemmell, S. Kannan and M. Naor, </author> <title> Checking the correctness of memories, </title> <booktitle> Proc. 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 90-99, </pages> <year> 1991. </year>
Reference: [3] <author> M. Blum and S. Kannan, </author> <title> Designing programs that check their work, </title> <booktitle> Proc. 21st ACM Symposium on Theory of Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1989. </year> <month> 19 </month>
Reference-contexts: 1 Introduction The program checking model was introduced in <ref> [3] </ref> and several subsequent papers [4, 1, 14] have provided checkers for classical computational problems. The model was introduced as a practical means of checking that programs for these problems are correct.
Reference: [4] <author> M. Blum, M. Luby, and R. Rubinfeld, </author> <title> Self-testing and self-correcting programs with applications to numerical problems, </title> <booktitle> Proc. 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 73-83, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction The program checking model was introduced in [3] and several subsequent papers <ref> [4, 1, 14] </ref> have provided checkers for classical computational problems. The model was introduced as a practical means of checking that programs for these problems are correct. Rather than certifying that the program is always correct, a program checker certifies that on any given input the program is correct.
Reference: [5] <author> M. Blum, M. Luby, and R. Rubinfeld, </author> <title> Program result checking against adaptive programs and in cryptographic settings Proc. </title> <booktitle> of DIMACS Workshop on Cryptography and Distributed Algorithms, </booktitle> <year> 1990. </year>
Reference-contexts: Further, checking the correctness of these programs is of great practical importance. In this paper, we define a suitable model for checking such programs and present checkers for various problems of storage and retrieval. Our model differs from the adaptive checker model introduced by Blum, Luby, Rubin-feld <ref> [5] </ref> and the model of the program as a prover which is discussed by Fortnow, Rompel, and Sipser in [8]. These papers distinguish between provers which act as functions and provers which may adaptively alter their response to a particular question over time.
Reference: [6] <author> A. Condon, </author> <title> Space bounded probabilistic game automata, </title> <journal> Journal of the ACM, </journal> <volume> 38(2), </volume> <pages> pages 472-494, </pages> <month> April </month> <year> 1991 </year>
Reference-contexts: Another area in which data structure checking provides insight is in the context of interactive proofs. One application of our results is a direct method of simulating a polytime verifier by a logspace verifier. Condon <ref> [6] </ref>, Dwork and Stockmeyer [7] and Lipton [13] derive this result to show that logspace verifiers can verify essentially the same proofs as polytime verifiers. Given a polytime verifier V (a Turing machine), we simulate V by a logspace verifier V 0 .
Reference: [7] <author> C. Dwork and L. Stockmeyer, </author> <title> Finite state verifiers I: the power of interaction, </title> <journal> Journal of the ACM, </journal> <note> to appear. </note>
Reference-contexts: Another area in which data structure checking provides insight is in the context of interactive proofs. One application of our results is a direct method of simulating a polytime verifier by a logspace verifier. Condon [6], Dwork and Stockmeyer <ref> [7] </ref> and Lipton [13] derive this result to show that logspace verifiers can verify essentially the same proofs as polytime verifiers. Given a polytime verifier V (a Turing machine), we simulate V by a logspace verifier V 0 . V 0 maintains V 's head position on its logspace worktape.
Reference: [8] <author> L. Fortnow, J. Rompel, and M. Sipser, </author> <title> On the power of multi-prover interactive protocols, </title> <booktitle> Proc. 3rd IEEE Structure in Complexity Theory, </booktitle> <pages> pages 156-161, </pages> <year> 1988. </year>
Reference-contexts: Our model differs from the adaptive checker model introduced by Blum, Luby, Rubin-feld [5] and the model of the program as a prover which is discussed by Fortnow, Rompel, and Sipser in <ref> [8] </ref>. These papers distinguish between provers which act as functions and provers which may adaptively alter their response to a particular question over time. In our case, the manner in which the program alters its environment is prescribed by the definition of the data structure.
Reference: [9] <author> O. Goldreich, </author> <title> Towards a theory of software protection and simulation by oblivious rams, </title> <booktitle> Proc. 19th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 182-194, </pages> <year> 1987. </year>
Reference-contexts: The question of checking a sequence of stores and retrieves from a random access memory has been addressed by the papers of Goldreich <ref> [9] </ref> and Ostrovsky [18]. These two papers actually solve the harder problem of software protection against a very powerful adversary. Consequently, the overheads involved in checking the sequence of memory accesses is quite large. <p> This prevents the adversary from "making up" values for memory locations, but it does not prevent the write-once (or replay) attack. That is, the adversary might continue to return old, obsolete value, tag pairs from a location. A similar problem was addressed in <ref> [9] </ref> and [18]. We address the problem in section 5.1.2. 5 3.3 Universal one-way hash functions The advantage of this technique is that it assumes only a reliable but not secret memory for the checker.
Reference: [10] <author> O. Goldreich, S. Goldwasser, and S. Micali, </author> <title> How to construct random functions, </title> <journal> Journal of the ACM, </journal> <volume> 33(4) </volume> <pages> 792-807, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: We now list two (cryptographic) techniques for hashing. 3.2 Pseudorandom functions A family of pseudorandom functions, as defined by Goldreich, Goldwasser and Micali <ref> [10] </ref>, is a collection of functions that has the property that a random member of it is indistinguishable from a random function, yet it has a succinct representation and can be efficiently computed. <p> After a polynomial number of queries, A guesses whether it is in case (a) or (b). For all polynomials p, for sufficiently large n, Pr [A guesses (a) j case (a)] Pr [A guesses (a) j case (b)] &lt; 1 Goldreich, Goldwasser and Micali <ref> [10] </ref> show how to construct pseudorandom functions based on any pseudorandom generator, which in turn can be based on any one-way hash function [11, 12]. We assume that the reliable (and secret) memory of the checker can store the seed S of a pseudorandom function f S .
Reference: [11] <author> J. H-astad, </author> <title> Pseudo-random generators under uniform assumptions, </title> <booktitle> Proc. 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 395-405, </pages> <year> 1990. </year>
Reference-contexts: all polynomials p, for sufficiently large n, Pr [A guesses (a) j case (a)] Pr [A guesses (a) j case (b)] &lt; 1 Goldreich, Goldwasser and Micali [10] show how to construct pseudorandom functions based on any pseudorandom generator, which in turn can be based on any one-way hash function <ref> [11, 12] </ref>. We assume that the reliable (and secret) memory of the checker can store the seed S of a pseudorandom function f S .
Reference: [12] <author> R. Impagliazzo, L. A. Levin and M. </author> <title> Luby Pseudo-random generators from one-way functions, </title> <booktitle> Proc. 21st ACM Symposium on Theory of Computing, </booktitle> <pages> pages 12-24, </pages> <year> 1989. </year>
Reference-contexts: all polynomials p, for sufficiently large n, Pr [A guesses (a) j case (a)] Pr [A guesses (a) j case (b)] &lt; 1 Goldreich, Goldwasser and Micali [10] show how to construct pseudorandom functions based on any pseudorandom generator, which in turn can be based on any one-way hash function <ref> [11, 12] </ref>. We assume that the reliable (and secret) memory of the checker can store the seed S of a pseudorandom function f S .
Reference: [13] <author> R. Lipton, </author> <title> Efficient checking of computations, </title> <booktitle> Proc. 7th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 207-215, </pages> <year> 1990. </year>
Reference-contexts: Another area in which data structure checking provides insight is in the context of interactive proofs. One application of our results is a direct method of simulating a polytime verifier by a logspace verifier. Condon [6], Dwork and Stockmeyer [7] and Lipton <ref> [13] </ref> derive this result to show that logspace verifiers can verify essentially the same proofs as polytime verifiers. Given a polytime verifier V (a Turing machine), we simulate V by a logspace verifier V 0 . V 0 maintains V 's head position on its logspace worktape.
Reference: [14] <author> R. Lipton, </author> <title> New directions in testing, </title> <booktitle> Proc. of DIMACS Workshop on Cryptography and Distributed Algorithms, </booktitle> <year> 1990. </year>
Reference-contexts: 1 Introduction The program checking model was introduced in [3] and several subsequent papers <ref> [4, 1, 14] </ref> have provided checkers for classical computational problems. The model was introduced as a practical means of checking that programs for these problems are correct. Rather than certifying that the program is always correct, a program checker certifies that on any given input the program is correct.
Reference: [15] <author> R. Merkle. </author> <title> A certified digital signature, manuscript, </title> <booktitle> 1979, see also Advances in Cryptology, Crypto '89 Proceedings, Lecture Notes in Computer Science 435, </booktitle> <pages> pages 218-238, </pages> <year> 1990. </year>
Reference-contexts: The amount of computation is log n applications of a hash function. This scheme can be seen as a variant of Merkle's tree authentication scheme for digital signatures <ref> [15] </ref>. The signature scheme in [17] is based on it as well. To define security in our context, we must specify the power of an adversary that attempts to attack our scheme.
Reference: [16] <author> J. Naor and M. Naor, </author> <title> Small-bias probability spaces: efficient constructions and applications, </title> <booktitle> Proc. 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 213-223, </pages> <year> 1990. </year>
Reference-contexts: Some of them rely on cryptographic assumptions while others do not. We review these hashing techniques in this section. 3.1 *-biased hash functions This hashing scheme is drawn from <ref> [16] </ref>. We briefly describe the result in a communication complexity setting. Suppose two players A and B have n-bit strings x and y respectively and would like to decide if x = y. The scheme in [16] allows A to define a hash function h using O (log n + k) <p> techniques in this section. 3.1 *-biased hash functions This hashing scheme is drawn from <ref> [16] </ref>. We briefly describe the result in a communication complexity setting. Suppose two players A and B have n-bit strings x and y respectively and would like to decide if x = y. The scheme in [16] allows A to define a hash function h using O (log n + k) random bits such that h (x) is small (O (k) bits) and h (x) = h (y) with probability 1=2 k if x 6= y.
Reference: [17] <author> M. Naor and M. Yung, </author> <title> Universal one-way hash functions and their cryptographic applications, </title> <booktitle> Proc. 21st ACM Symposium on Theory of Computing, </booktitle> <pages> pages 33-43, </pages> <year> 1989. </year>
Reference-contexts: Let U be a family of functions where 8f 2 U , f : D 7! R. Following Naor and Yung <ref> [17] </ref> we say that U is a family of universal one-way hash functions (UOWHF) if 8x 2 D, for f chosen at random from U , it is hard to find y 6= x such that f (x) = f (y) (see exact definition below). <p> That is, h 2 H ` maps two strings of length ` and two descriptions of elements of H ` into a string of length `. From <ref> [17] </ref> we know that such a family can be constructed given any family that compresses one bit (which in turn can be based on any one-way function). <p> The amount of computation is log n applications of a hash function. This scheme can be seen as a variant of Merkle's tree authentication scheme for digital signatures [15]. The signature scheme in <ref> [17] </ref> is based on it as well. To define security in our context, we must specify the power of an adversary that attempts to attack our scheme. We assume that the adversary B is a probabilistic polynomial time machine that controls both the input and the memory.
Reference: [18] <author> R. Ostrovsky, </author> <title> Efficient computation on oblivious rams, </title> <booktitle> Proc. 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 514-523, </pages> <year> 1990. </year>
Reference-contexts: The question of checking a sequence of stores and retrieves from a random access memory has been addressed by the papers of Goldreich [9] and Ostrovsky <ref> [18] </ref>. These two papers actually solve the harder problem of software protection against a very powerful adversary. Consequently, the overheads involved in checking the sequence of memory accesses is quite large. <p> This prevents the adversary from "making up" values for memory locations, but it does not prevent the write-once (or replay) attack. That is, the adversary might continue to return old, obsolete value, tag pairs from a location. A similar problem was addressed in [9] and <ref> [18] </ref>. We address the problem in section 5.1.2. 5 3.3 Universal one-way hash functions The advantage of this technique is that it assumes only a reliable but not secret memory for the checker. Let U be a family of functions where 8f 2 U , f : D 7! R.
Reference: [19] <author> N. Pippinger and M.J. Fischer, </author> <title> Relations among complexity measures, </title> <journal> Journal of the ACM, </journal> <volume> 26(2) </volume> <pages> 361-381, </pages> <year> 1979. </year> <month> 20 </month>
Reference-contexts: The trick is the placement of the markers. We use an idea from the simulation by oblivious Turing machines of Pippenger and Fischer <ref> [19] </ref>. To simplify the explanation, we assume that we have h = log H stacks S 0 ; S 1 ; :::; S h1 . Each stack has its own h (W ) and h (R). We will see how to combine these stacks into one stack later.
Reference: [20] <author> J. Rompel, </author> <title> One way functions are necessary and sufficient for secure signatures, </title> <booktitle> Proc. 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 387-394, </pages> <year> 1990. </year>
Reference-contexts: It is possible to construct a family of UOWHF given any one-way function ([17] shows this for any 1-1 one-way function and Rompel <ref> [20] </ref> shows this for any one-way function.) Using UOWHF, there is a way to authenticate several memory cells with one memory cell, without assuming secrecy (but assuming that the contents of the authenticating cell are not altered).
Reference: [21] <author> A. Yao, </author> <title> Coherent functions and program checkers, </title> <booktitle> Proc. 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 84-94, </pages> <year> 1990. </year> <month> 21 </month>
Reference-contexts: Space is the size m of the checker's reliable memory. Let n be the size of the RAM. We show that n 2 O (mt). The proof is a generalization of Yao's tradeoffs for coherent functions in <ref> [21] </ref>. For the sake of simplicity we assume that each RAM cell holds just 1 bit. Once again we assume that the checker is correct with probability p whenever it certifies the contents of a memory location. Clearly, the interesting case is when p &gt; 1=2.
References-found: 21

