URL: http://www.cs.wustl.edu/~gokhale/Papers/oopsla97.ps.gz
Refering-URL: http://www.cs.wustl.edu/~gokhale/vita.html
Root-URL: 
Email: gokhale@cs.wustl.edu and schmidt@cs.wustl.edu  
Title: Design Principles and Optimizations for High Performance ORBs  
Author: Aniruddha Gokhale and Douglas C. Schmidt 
Keyword: Distributed object computing, CORBA, IIOP performance, demultiplexing, communication middleware protocol optimizations, high-speed networks.  
Address: St. Louis, MO 63130, USA 1  
Affiliation: Department of Computer Science, Washington University  
Abstract: The Internet Inter-ORB Protocol (IIOP) enables heterogeneous CORBA-compliant Object Request Brokers (ORBs) to interoperate over TCP/IP networks. The IIOP uses the Common Data Representation transfer syntax to map CORBA Interface Definition Language (IDL) data types into a portable network format. Due to the excessive marshaling/demarshaling overhead, data copying, and high-levels of function call overhead, conventional implementations of IIOP protocols have yielded relatively poor performance over high-speed networks. To meet the demands of emerging distributed multimedia applications, however, CORBA-compliant ORBs must support interoperable and highly efficient IIOP implementations. In addition, real-time ORB's must provide efficient and predictable demultiplexing of incoming requests. This paper describes the design principles and optimizations we are using to develop a high-performance implementation of CORBA called The ACE ORB (TAO). We provide two contributions to the study and design of high-performance, real-time CORBA endsystems. First, we empirically demonstrate the benefits of systematically applying protocol optimizations to a public domain implementation of IIOP from SunSoft. These optimizations include: optimizing for the common case; eliminating gratuitous waste; replacing general purpose methods with specialized, efficient ones; precomputing values; storing redundant state to speed up expensive operations; passing information between layers; and optimizing for better processor cache performance. The results of applying these optimizations to SunSoft IIOP improved its performance substantially for all data types. Second, we present an empirical study of demultiplexing strategies used by TAO's real-time Object Adapter. This study compares the performance of (1) linear search, (2) perfect hashing, and (3) active demultiplexing for a wide range of target objects and operations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abbott and L. Peterson. </author> <title> Increasing Network Throughput by Integrating Protocol Layers. </title> <journal> ACM Transactions on Networking, </journal> <volume> 1(5), </volume> <month> October </month> <year> 1993. </year>
Reference-contexts: This observation led to the creation of a template for the expected packet header. The optimizations reported in [4] are based on Principle 1, which optimizes for the common case and Principle 3, which is precompute, if possible. <ref> [5, 1, 3] </ref> describe the application of an optimization mechanism called Integrated Layer Processing (ILP). ILP is based on the observation that data manipulation loops that operate on the same protocol data are wasteful and expensive.
Reference: [2] <author> Mary L. Bailey, Burra Gopal, Prasenjit Sarkar, Michael A. Pagels, and Larry L. Peterson. Pathfinder: </author> <title> A pattern-based packet classifier. </title> <booktitle> In Proceedings of the 1 st Symposium on Operating System Design and Implementation. USENIX Association, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: The ILP mechanism integrates these loops into a smaller number of loops that perform all the protocol processing. The ILP optimization scheme is based on Principle 2, which gets rid of gratuitous waste. Packet filters <ref> [16, 2, 7] </ref> are a classic example of Principle 6, Number Principle 1 Optimizing for the common case 2 Eliminating gratuitous waste 3 Replacing inefficient general-purpose methods with efficient special-purpose ones 4 Precomputing values, if possible 5 Storing redundant state to speed up expensive operations 6 Passing information between layers 7 <p> These include the BSD Packet Filter (BPF) [16], the Mach Packet Filter (MPF) [25], PathFinder <ref> [2] </ref>, demulti-plexing based on automatic parsing [15], and the Dynamic Packet Filter (DPF) [7]. However, related work on demultiplexing deals with lower layers of the protocol stack (transport layer and below) as opposed to the CORBA middleware.
Reference: [3] <author> Torsten Braun and Christophe Diot. </author> <title> Protocol Implementation Using Integrated Layer Processnig. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM). ACM, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: This observation led to the creation of a template for the expected packet header. The optimizations reported in [4] are based on Principle 1, which optimizes for the common case and Principle 3, which is precompute, if possible. <ref> [5, 1, 3] </ref> describe the application of an optimization mechanism called Integrated Layer Processing (ILP). ILP is based on the observation that data manipulation loops that operate on the same protocol data are wasteful and expensive.
Reference: [4] <author> David D. Clark, Van Jacobson, John Romkey, and Howard Salwen. </author> <title> An Analysis of TCP Processing Overhead. </title> <journal> IEEE Communications Magazine, </journal> <volume> 27(6):2329, </volume> <month> June </month> <year> 1989. </year>
Reference-contexts: In addition, we discuss related work on CORBA performance measurements and demultiplexing. Related work based on optimization principles: <ref> [4] </ref> describes a technique called header prediction that predicts the message header of incoming TCP packets. This technique is based on the observation that many members in the header remaining constant between consecutive packets. This observation led to the creation of a template for the expected packet header. <p> This technique is based on the observation that many members in the header remaining constant between consecutive packets. This observation led to the creation of a template for the expected packet header. The optimizations reported in <ref> [4] </ref> are based on Principle 1, which optimizes for the common case and Principle 3, which is precompute, if possible. [5, 1, 3] describe the application of an optimization mechanism called Integrated Layer Processing (ILP).
Reference: [5] <author> David D. Clark and David L. Tennenhouse. </author> <title> Architectural Considerations for a New Generation of Protocols. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), pages 200208, </booktitle> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: This observation led to the creation of a template for the expected packet header. The optimizations reported in [4] are based on Principle 1, which optimizes for the common case and Principle 3, which is precompute, if possible. <ref> [5, 1, 3] </ref> describe the application of an optimization mechanism called Integrated Layer Processing (ILP). ILP is based on the observation that data manipulation loops that operate on the same protocol data are wasteful and expensive.
Reference: [6] <author> Zubin D. Dittia, Guru M. Parulkar, and Jr. Jerome R. Cox. </author> <title> The APIC Approach to High Performance Network Interface Design: Protected DMA and Other Techniques. </title> <booktitle> In IEEE INFO-COM '97, </booktitle> <address> Kobe, Japan, April 1997. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: These tests do not measure the run-time costs of interoperability between ORBs from different vendors. In addition, these papers do not provide solutions to reduce these overheads. In contrast, we have provided solutions that significantly improve performance by reducing marshaling/demarshaling overhead. Related work on demultiplexing <ref> [22, 8, 6] </ref> deal with de-multiplexing issues in communication systems. In addition, [22] shows how layered demultiplexing is not suitable for applications that require real-time quality of service guarantees. Packet filters are a mechanism for efficiently demultiplex-ing incoming packets to application endpoints [17].
Reference: [7] <author> Dawson R. Engler and M. Frans Kaashoek. DPF: </author> <title> Fast, Flexible Message Demultiplexing using Dynamic Code Generation. </title> <booktitle> In Proceedings of ACM SIGCOMM '96 Conference in Computer Communication Review, </booktitle> <pages> pages 5359, </pages> <institution> Stanford University, California, USA, </institution> <month> August </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: The ILP mechanism integrates these loops into a smaller number of loops that perform all the protocol processing. The ILP optimization scheme is based on Principle 2, which gets rid of gratuitous waste. Packet filters <ref> [16, 2, 7] </ref> are a classic example of Principle 6, Number Principle 1 Optimizing for the common case 2 Eliminating gratuitous waste 3 Replacing inefficient general-purpose methods with efficient special-purpose ones 4 Precomputing values, if possible 5 Storing redundant state to speed up expensive operations 6 Passing information between layers 7 <p> These include the BSD Packet Filter (BPF) [16], the Mach Packet Filter (MPF) [25], PathFinder [2], demulti-plexing based on automatic parsing [15], and the Dynamic Packet Filter (DPF) <ref> [7] </ref>. However, related work on demultiplexing deals with lower layers of the protocol stack (transport layer and below) as opposed to the CORBA middleware.
Reference: [8] <author> David C. Feldmeier. </author> <title> Multiplexing Issues in Communications System Design. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), pages 209219, </booktitle> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: These tests do not measure the run-time costs of interoperability between ORBs from different vendors. In addition, these papers do not provide solutions to reduce these overheads. In contrast, we have provided solutions that significantly improve performance by reducing marshaling/demarshaling overhead. Related work on demultiplexing <ref> [22, 8, 6] </ref> deal with de-multiplexing issues in communication systems. In addition, [22] shows how layered demultiplexing is not suitable for applications that require real-time quality of service guarantees. Packet filters are a mechanism for efficiently demultiplex-ing incoming packets to application endpoints [17].
Reference: [9] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks. </title> <booktitle> In Proceedings of SIGCOMM '96, </booktitle> <pages> pages 306317, </pages> <address> Stanford, CA, </address> <month> August </month> <year> 1996. </year> <note> ACM. </note>
Reference-contexts: The Common Object Request Broker Architecture (CORBA) is a distributed object computing middleware standard defined by the Object Management Group (OMG) [19]. CORBA is intended to support the production of flexible and reusable distributed services and applications. Many implementations of CORBA are now available. <ref> [9, 10, 11] </ref> show that the performance of conventional CORBA middleware implementations is relatively poor compared to lower-level implementations using C/C++ since the ORBs incur a significant amount of data copying, marshaling, demarshaling, and demultiplexing overhead. These results, however, focused entirely on the communication performance between homogeneous ORBs. <p> and how we are using it to build a high-performance, real-time CORBA implementation called The ACE ORB (TAO) [21]. 1.1 Improving the Performance of CORBA IIOP In [13], we measure the performance of the standard reference implementation of IIOP, freely available from Sun-Soft, using a CORBA/ATM testbed environment similar to <ref> [9, 10, 11] </ref>. We measure the performance of SunSoft IIOP and precisely pinpoint its performance overheads. In addition, we describe the results of systematically applying seven principle-driven optimizations [24] that substantially im 1 prove the performance of SunSoft IIOP. <p> Our optimized version of SunSoft IIOP is now comparable to existing commercial ORBs <ref> [9, 10, 11] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). <p> The Object Adaptor demultiplexes incoming requests, dispatches them to the target object, and invokes the designated operation on the selected object. Conventional implementations of CORBA incur significant demultiplexing overhead. In particular, <ref> [9, 11] </ref> have shown that on ~17% the total server processing time is demultiplexing requests. <p> Optimizing such software is hard, particularly since seemingly minor mistakes (such as copying data excessively) can significantly reduce performance <ref> [9] </ref>. Therefore, developing high performance ORBs requires an iterative, multi-step process. The first step involves measuring the performance of the system and pinpointing the sources of overhead. The second step involves a careful analysis of these sources of overhead and application of optimizations to remove them. <p> Related work on CORBA performance measurements: <ref> [9, 10, 11] </ref> show that the performance of CORBA middleware implementations is relatively poor, compared to lower-level implementations using C/C++. <p> Related work on CORBA performance measurements: [9, 10, 11] show that the performance of CORBA middleware implementations is relatively poor, compared to lower-level implementations using C/C++. The primary source of ORB-level overhead stems from marshaling and demarshaling. <ref> [9] </ref> measures the performance of the static invocation interface. [10] measures the performance of the dynamic invocation interface and the dynamic skeleton interface. [11] measures performance of CORBA implementations in terms of latency and support for very large number of objects. <p> The results of applying these optimization principles to Sun-Soft IIOP improved its performance 1.9 times for doubles, 3.3 times for longs, 4 times for shorts, 5 times for chars/octets, and 6.7 times for richly-typed structs over ATM networks. Our optimized implementation is now competitive with existing commercial ORBs <ref> [9, 11] </ref> using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) [10].
Reference: [10] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> The Performance of the CORBA Dynamic Invocation Interface and Dynamic Skeleton Interface over High-Speed ATM Networks. </title> <booktitle> In Proceedings of GLOBECOM '96, </booktitle> <pages> pages 5056, </pages> <address> London, England, </address> <month> November </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: The Common Object Request Broker Architecture (CORBA) is a distributed object computing middleware standard defined by the Object Management Group (OMG) [19]. CORBA is intended to support the production of flexible and reusable distributed services and applications. Many implementations of CORBA are now available. <ref> [9, 10, 11] </ref> show that the performance of conventional CORBA middleware implementations is relatively poor compared to lower-level implementations using C/C++ since the ORBs incur a significant amount of data copying, marshaling, demarshaling, and demultiplexing overhead. These results, however, focused entirely on the communication performance between homogeneous ORBs. <p> and how we are using it to build a high-performance, real-time CORBA implementation called The ACE ORB (TAO) [21]. 1.1 Improving the Performance of CORBA IIOP In [13], we measure the performance of the standard reference implementation of IIOP, freely available from Sun-Soft, using a CORBA/ATM testbed environment similar to <ref> [9, 10, 11] </ref>. We measure the performance of SunSoft IIOP and precisely pinpoint its performance overheads. In addition, we describe the results of systematically applying seven principle-driven optimizations [24] that substantially im 1 prove the performance of SunSoft IIOP. <p> Our optimized version of SunSoft IIOP is now comparable to existing commercial ORBs <ref> [9, 10, 11] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). <p> Related work on CORBA performance measurements: <ref> [9, 10, 11] </ref> show that the performance of CORBA middleware implementations is relatively poor, compared to lower-level implementations using C/C++. <p> Related work on CORBA performance measurements: [9, 10, 11] show that the performance of CORBA middleware implementations is relatively poor, compared to lower-level implementations using C/C++. The primary source of ORB-level overhead stems from marshaling and demarshaling. [9] measures the performance of the static invocation interface. <ref> [10] </ref> measures the performance of the dynamic invocation interface and the dynamic skeleton interface. [11] measures performance of CORBA implementations in terms of latency and support for very large number of objects. <p> Our optimized implementation is now competitive with existing commercial ORBs [9, 11] using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) <ref> [10] </ref>. The results of our optimizations provide sufficient proof that performance of complex distributed systems software can be improved by a systematic application of principle-driven optimizations. The demultiplexing results presented in this paper compare three demultiplexing strategies.
Reference: [11] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Evaluating Latency and Scalability of CORBA Over High-Speed ATM Networks. </title> <booktitle> In Proceedings of the International Conference on Distributed Computing Systems, </booktitle> <address> Baltimore, Maryland, </address> <month> May </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: The Common Object Request Broker Architecture (CORBA) is a distributed object computing middleware standard defined by the Object Management Group (OMG) [19]. CORBA is intended to support the production of flexible and reusable distributed services and applications. Many implementations of CORBA are now available. <ref> [9, 10, 11] </ref> show that the performance of conventional CORBA middleware implementations is relatively poor compared to lower-level implementations using C/C++ since the ORBs incur a significant amount of data copying, marshaling, demarshaling, and demultiplexing overhead. These results, however, focused entirely on the communication performance between homogeneous ORBs. <p> and how we are using it to build a high-performance, real-time CORBA implementation called The ACE ORB (TAO) [21]. 1.1 Improving the Performance of CORBA IIOP In [13], we measure the performance of the standard reference implementation of IIOP, freely available from Sun-Soft, using a CORBA/ATM testbed environment similar to <ref> [9, 10, 11] </ref>. We measure the performance of SunSoft IIOP and precisely pinpoint its performance overheads. In addition, we describe the results of systematically applying seven principle-driven optimizations [24] that substantially im 1 prove the performance of SunSoft IIOP. <p> Our optimized version of SunSoft IIOP is now comparable to existing commercial ORBs <ref> [9, 10, 11] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). <p> The Object Adaptor demultiplexes incoming requests, dispatches them to the target object, and invokes the designated operation on the selected object. Conventional implementations of CORBA incur significant demultiplexing overhead. In particular, <ref> [9, 11] </ref> have shown that on ~17% the total server processing time is demultiplexing requests. <p> Related work on CORBA performance measurements: <ref> [9, 10, 11] </ref> show that the performance of CORBA middleware implementations is relatively poor, compared to lower-level implementations using C/C++. <p> The primary source of ORB-level overhead stems from marshaling and demarshaling. [9] measures the performance of the static invocation interface. [10] measures the performance of the dynamic invocation interface and the dynamic skeleton interface. <ref> [11] </ref> measures performance of CORBA implementations in terms of latency and support for very large number of objects. However, the results of earlier CORBA benchmarking experiments were restricted to measuring the performance of communication between homogeneous ORBs. <p> The results of applying these optimization principles to Sun-Soft IIOP improved its performance 1.9 times for doubles, 3.3 times for longs, 4 times for shorts, 5 times for chars/octets, and 6.7 times for richly-typed structs over ATM networks. Our optimized implementation is now competitive with existing commercial ORBs <ref> [9, 11] </ref> using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) [10].
Reference: [12] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Evaluating the Performance of Demultiplexing Strategies for Real-time CORBA. </title> <booktitle> In Proceedings of GLOBECOM '97, </booktitle> <address> Phoenix, AZ, </address> <month> November </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: These results, however, focused entirely on the communication performance between homogeneous ORBs. They do not measure the run-time costs of interoperability between heterogeneous ORBs. In addition, earlier work on measuring CORBA performance did not present the results of optimizations to reduce key sources of ORB overhead. Our recent work <ref> [13, 12] </ref> extends our earlier work by focusing on optimizing the IIOP protocol and strategies for optimizing the CORBA demulti-plexing overhead. <p> In particular, [9, 11] have shown that on ~17% the total server processing time is demultiplexing requests. Unless this overhead is reduced and demultiplexing is performed predictably, CORBA cannot provide real-time quality of service guarantees to applications. tcpoa) to use three demultiplexing strategies shown in Figure 4. <ref> [12] </ref> describes these strategies and the parameter settings in detail. Section 3.2 presents the results of experiments with these demultiplexing strategies subjected to varying number of objects on the server and varying number of methods defined by the CORBA IDL interface. <p> Figures 9 and 10 illustrate the remaining high cost sender-side and receiver-side methods, respectively. 3.2 Performance Results for Demultiplexing Strategies This section presents the results of our experiments measuring the overhead of the three demultiplexing strategies shown in Figure 4. <ref> [12] </ref> provides detailed measurements and analysis of the results. Figures 11 and 12 illustrate the performance of the three demultiplexing strategies for the random and worst-case invocation strategies, respectively. These figures reveal that in both cases, the de-layered active demultiplexing and perfect hash-based demultiplexing strategies outperform the linear-search strategy. <p> We are using the de-layered active demultiplexing strategy in an ongoing work on a high performance, real-time ORB we are building <ref> [20, 12] </ref>. 4 Related Work This section describes results from existing work on protocol optimization based on one or more of the principles in Table though this is generally disparaged in hard real-time environments. 6 We assume that the security implications of using active demultiplexing are addressed via the CORBA security <p> TAO extends the SunSoft CORBA IDL compiler 7 to generate optimized stubs and skeletons from IDL interfaces. These generated stubs and skeletons transform C++ methods into/from CORBA requests via our optimized IIOP implementation. In addition, we have incorporated an Real-time Object Adapter <ref> [12] </ref> that supports de-layered active request demul-tiplexing and rate monotonic scheduling and dispatching of 7 The SunSoft front-end CORBA IDL compiler is also freely available from ftp://ftp.omg.org/pub/OMG IDL CFE 1.3/. <p> Therefore, TAO defines a set of Object Adapter strategies that dispatch requests to the correct skeleton of the target object. TAO's request demulti-plexing and dispatching process provides different strategies to demultiplex requests to skeletons, including linear search, dynamic hashing or perfect hashing of operation names, or direct demultiplexing <ref> [12] </ref>. A prototype of TAO is available at www.cs.wustl.edu/~schmidt/ACE wrappers/TAO.
Reference: [13] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Principles for Optimizing CORBA Internet Inter-ORB Protocol Performance. </title> <note> In Submitted to the Hawaiian International Conference on System Sciences (Washington University Technical Report #WUCS-97-10), </note> <month> January </month> <year> 1998. </year>
Reference-contexts: These results, however, focused entirely on the communication performance between homogeneous ORBs. They do not measure the run-time costs of interoperability between heterogeneous ORBs. In addition, earlier work on measuring CORBA performance did not present the results of optimizations to reduce key sources of ORB overhead. Our recent work <ref> [13, 12] </ref> extends our earlier work by focusing on optimizing the IIOP protocol and strategies for optimizing the CORBA demulti-plexing overhead. <p> This paper describes our recent work and how we are using it to build a high-performance, real-time CORBA implementation called The ACE ORB (TAO) [21]. 1.1 Improving the Performance of CORBA IIOP In <ref> [13] </ref>, we measure the performance of the standard reference implementation of IIOP, freely available from Sun-Soft, using a CORBA/ATM testbed environment similar to [9, 10, 11]. We measure the performance of SunSoft IIOP and precisely pinpoint its performance overheads. <p> The optimizations and the resulting speedups reported in our work <ref> [13] </ref> are essential for CORBA to be adopted as the standard for implementing high-bandwidth, low-latency distributed applications. The protocol optimizations described in this paper are based on a set of principles that have been used to improve the performance of communication protocols described in Section 4. <p> Optimizations for Processor Caches * Motivation: very large, monolithic interpreter * Solution: convert large, generic functions into specialized, efficient ones. Use outlining 4 to re duce improve cache performance. <ref> [13] </ref> provides detailed throughput measurements and analysis after every step of optimizations. 4 Outlining is a technique in which the code is arranged in such a way that seldom executed parts of conditional statements tend to be pushed towards the end of the function definition.
Reference: [14] <institution> Pure Software Inc. </institution> <note> Quantify User's Guide. </note> <institution> Pure Software Inc., </institution> <year> 1996. </year>
Reference-contexts: The profiling measurements reported in this paper were obtained using the Quantify <ref> [14] </ref> tool. 2 2.1 Traffic Generator for Measuring the Throughput IIOP Traffic for the experiments was generated and consumed by an extended version of the widely available ttcp [23] protocol benchmarking tool. We extended ttcp for use with SunSoft IIOP.
Reference: [15] <author> Mahesh Jayaram and Ron Cytron. </author> <title> Efficient Demultiplexing of Network Packets by Automatic Parsing. </title> <booktitle> In Proceedings of the Workshop on Compiler Support for System Software (WCSSS 96), </booktitle> <institution> University of Arizona, </institution> <address> Tucson, AZ, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: These include the BSD Packet Filter (BPF) [16], the Mach Packet Filter (MPF) [25], PathFinder [2], demulti-plexing based on automatic parsing <ref> [15] </ref>, and the Dynamic Packet Filter (DPF) [7]. However, related work on demultiplexing deals with lower layers of the protocol stack (transport layer and below) as opposed to the CORBA middleware.
Reference: [16] <author> Steven McCanne and Van Jacobson. </author> <title> The BSD Packet Filter: </title>
Reference-contexts: The ILP mechanism integrates these loops into a smaller number of loops that perform all the protocol processing. The ILP optimization scheme is based on Principle 2, which gets rid of gratuitous waste. Packet filters <ref> [16, 2, 7] </ref> are a classic example of Principle 6, Number Principle 1 Optimizing for the common case 2 Eliminating gratuitous waste 3 Replacing inefficient general-purpose methods with efficient special-purpose ones 4 Precomputing values, if possible 5 Storing redundant state to speed up expensive operations 6 Passing information between layers 7 <p> These include the BSD Packet Filter (BPF) <ref> [16] </ref>, the Mach Packet Filter (MPF) [25], PathFinder [2], demulti-plexing based on automatic parsing [15], and the Dynamic Packet Filter (DPF) [7]. However, related work on demultiplexing deals with lower layers of the protocol stack (transport layer and below) as opposed to the CORBA middleware.
References-found: 16

