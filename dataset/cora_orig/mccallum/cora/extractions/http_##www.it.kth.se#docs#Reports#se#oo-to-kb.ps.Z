URL: http://www.it.kth.se/docs/Reports/se/oo-to-kb.ps.Z
Refering-URL: http://www.it.kth.se/docs/Reports/se/
Root-URL: http://www.it.kth.se
Note: 1. Abstract  
Abstract-found: 0
Intro-found: 0
Reference: 1. <author> E. Tyugu. </author> <year> (1994). </year> <title> Using classes as specifications for automatic construction of programs in the NUT system. </title> <journal> Journal of Automated Software Engineering, v. </journal> <volume> 1, </volume> <pages> pp. 315 - 334. </pages>
Reference-contexts: It is compatible with C language, runs under X Windows System on Sun4 and DecSta-tions. It combines object-oriented programming, visual programming, and automatic program construction paradigms. Besides the ordinary usage, classes in NUT serve as specifications which can be used for constructing programs automatically <ref> [1] </ref>. In particular, a method compute is available by default in every user-defined class, and it can be sent to any object x as a request to compute some of its components, let us say, y. <p> Features like built-in equation solver, logic for constraint propagation and automatic coercion of units <ref> [1] </ref> enabled us, besides ordinary object-oriented programming, to build packages for calcula tions in electrical and mechanical engineering domains some of which are discussed in paper [7]. These packages use extensively delegation in specifications of classes.
Reference: 2. <author> G. Booch. </author> <year> (1991). </year> <title> Object-Oriented Design with Applications. </title> <address> Redwood City: Benjamin/Cummings. </address>
Reference: 3. <author> J. Rumbaugh, M. Blaha, W. Premerlani, E. Lorensen. </author> <year> (1991). </year> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall. </publisher>
Reference: 4. <author> M. Stickel, R. Waldinger, M. Lowry, T. Pressburger, I. Underwood. </author> <year> (1993). </year> <title> Deductive composition from astronomical software libraries. </title> <type> Tech. Report, </type> <institution> SRI International and NASA Ames Research Center. </institution>
Reference-contexts: This has helped us to find applications in the areas like discrete event simulation and network management. This has also added a avour of generality to our tools. Our program synthesizer is conceptually similar to the domain-oriented synthesizers of scientific programs like SNARK <ref> [4] </ref> and SINAPSE [5]. But we do not consider our programming environment as a purely domain-oriented (specialized) system, due to its object-oriented part which serves well for general-purpose programming tasks. NUT has a scheme editor for specifying classes graphically, by drawing their schemes.
Reference: 5. <author> E. Kant, F. Daube, W. MacGregor, J. Wald. </author> <year> (1991). </year> <title> Scientific programming by automated synthesis. </title> <editor> In: M. Lowry, R. McCartney (eds.) </editor> <title> Automating Software Design. </title> <publisher> AAAI Press/MIT Press. </publisher> <pages> pp. 169 - 205. </pages>
Reference-contexts: This has helped us to find applications in the areas like discrete event simulation and network management. This has also added a avour of generality to our tools. Our program synthesizer is conceptually similar to the domain-oriented synthesizers of scientific programs like SNARK [4] and SINAPSE <ref> [5] </ref>. But we do not consider our programming environment as a purely domain-oriented (specialized) system, due to its object-oriented part which serves well for general-purpose programming tasks. NUT has a scheme editor for specifying classes graphically, by drawing their schemes.
Reference: 6. <author> V. Vlassov, E. Tyugu, M. Addibpour. </author> <year> (1994). </year> <title> Distributed programming toolkit for NUT. </title> <type> Technical Report 94:34-SE, </type> <institution> Dept. of Teleinformatics, Royal Institute of Technology, Sweden. </institution>
Reference-contexts: Using the scheme editor, a user can develop its own graphical language and use it for specifying programs in his problem domain. The most recent extension of the NUT system is a parallel programming toolkit rNUT for distributed computing and agent-based software development <ref> [6] </ref>. The NUT system together with its documentation is available by anonymous ftp from it.kth.se where it is in the directory Software/CSlab/Software-Engineering/NUT. Papers related to he NUT system can be found in www under http://www.it.kth.se/CSlab/ Software-Engineering/Projectpage.html. <p> Distributed computing The most recent extension of NUT is a distributed computing toolkit rNUT <ref> [6] </ref> built on top of PVM [14] which is a quite popular integrated framework for distributed heterogeneous computing. A distributed program developed by means of the present toolkit represents a collection of dynamically created communicating processes running on PVM in a network.
Reference: 7. <author> E. Tyugu. </author> <year> (1991). </year> <title> Three New-Generation Software Environments. </title> <journal> Communications of the ACM, </journal> <volume> v.34, </volume> <pages> pp. 46-59. </pages>
Reference-contexts: Papers related to he NUT system can be found in www under http://www.it.kth.se/CSlab/ Software-Engineering/Projectpage.html. The first version of NUT was developed in the framework of a new generation computer project START <ref> [7] </ref> under the conditions of abundance of resources. At that time we already had some experience of practical application of structural synthesis of programs which became also the basis for synthesis of programs in NUT. In 1990 the development almost stopped. <p> Features like built-in equation solver, logic for constraint propagation and automatic coercion of units [1] enabled us, besides ordinary object-oriented programming, to build packages for calcula tions in electrical and mechanical engineering domains some of which are discussed in paper <ref> [7] </ref>. These packages use extensively delegation in specifications of classes. The construction x:T; where x is a new name and T is a name of a known class has an obvious meaning x is a T. <p> We had one rather impressive implementation with good graphical interface. This was a package for simulating hydraulic systems specified simply by drawing their schemes, briey described in <ref> [7] </ref>. Success of the hydraulics package encouraged us to build a general-purpose scheme editor which became an essential step in development of the NUT system. Our experiences with simulation of hydraulic systems lead us to the development of a general-purpose scheme editor.
Reference: 8. <author> G. Mints. </author> <year> (1991). </year> <title> Propositional Logic Programming. </title> <editor> In: J. Hayes, D. Michie, E. Tyugu (eds.) </editor> <booktitle> Machine Intelligence 12. </booktitle> <publisher> Clarendon Press. Oxford, </publisher> <pages> pp. 17 - 37. </pages>
Reference-contexts: The main features of the first version were: object-orientedness and usage of classes as specifications for program synthesis. Our synthesis technique has been described in terms of pure logic <ref> [8] </ref> as well as in terms of higher-order constrain solving [9]. NUT language is an object-oriented language with multiple inheritance, parametric polymorphism, and a exible mechanism for message passing [10].
Reference: 9. <author> E. Tyugu, T. Uustalu. </author> <year> (1994). </year> <title> Higher-order functional constraint networks. Constraint programming. NATO ASI Series F: </title> <journal> Computer and System Sciences, </journal> <volume> Vol. 131. </volume> <publisher> Springer Verlag, </publisher> <pages> pp. 116 - 139. </pages>
Reference-contexts: The main features of the first version were: object-orientedness and usage of classes as specifications for program synthesis. Our synthesis technique has been described in terms of pure logic [8] as well as in terms of higher-order constrain solving <ref> [9] </ref>. NUT language is an object-oriented language with multiple inheritance, parametric polymorphism, and a exible mechanism for message passing [10].
Reference: 10. <author> T. Uustalu, U. Kopra, V. Kotkas, M. Matskin and E Tyugu. </author> <year> (1994). </year> <title> The NUT Language Report. </title> <type> Technical Report 94:14-SE, </type> <institution> Dept. of Teleinformatics, Royal Institute of Technology, Sweden. </institution>
Reference-contexts: Our synthesis technique has been described in terms of pure logic [8] as well as in terms of higher-order constrain solving [9]. NUT language is an object-oriented language with multiple inheritance, parametric polymorphism, and a exible mechanism for message passing <ref> [10] </ref>. Poly-morphism is supported by a type system where a generic type any can be used in almost any position, and later made precise either at the following stages of specification or during computations. Encapsulation in NUT is different from the conventional encapsulation in object-oriented languages.
Reference: 11. <author> M. Burnett, M. Baker, C. Bohus, P. Carlson, S. Yang, P. van Zee. </author> <year> (1995). </year> <title> Scalin up Visual Programming Languages. </title> <journal> Computer, </journal> <volume> No. 3, </volume> <pages> pp. 45 - 54. </pages>
Reference-contexts: Scheme editor Visual programming is a rapidly developing technique for building complex application software <ref> [11] </ref>. Also the first version of NUT contained functions for interactive graphics allowing us to build a dashboard of a car and to simulate driving. Graphical images could be bound to objects, reecting their changes during the computations.
Reference: 12. <author> H. Gottler. </author> <year> (1982). </year> <title> Attributed graph grammars for graphics. </title> <publisher> LNCS, </publisher> <editor> v. </editor> <volume> 153, 130 - 142. </volume>
Reference-contexts: Sufficiently powerful tools of automatic program construction in NUT serve for this purpose. The idea of representing semantics of graphics computationally has been expressed already in <ref> [12] </ref> where attribute grammars were used for this purpose. Here we consider the architecture of a semantic processor of schemes. Its main components and levels of representation of semantics are shown in figure 3. At the topmost level we have a drawing representing a scheme.
Reference: 13. <author> V. Kotkas, E. Tyugu. </author> <year> (1994). </year> <title> Knowledge-Based Techniques for Network Management. </title> <type> Technical Report 94:09-SE. </type> <institution> Dept. of Teleinformatics, Royal Institute of Technology, Sweden. </institution>
Reference-contexts: Functions for ana-lysing classes are the following: find components of a class find relations of a class find name of the class of a given entity. As an application example of this approach, we mention experiments with intelligent network management <ref> [13] </ref> where a network configuration model is being changed by network daemons, and management tasks are described declaratively on the network model used for management action planning. 6.
Reference: 14. <author> G.A. Geist, et al. </author> <year> (1994). </year> <title> PVM3 Users Guide and Reference Manual. </title> <institution> ORNL/TM-12187, Oak Ridge National Lab. </institution>
Reference-contexts: Distributed computing The most recent extension of NUT is a distributed computing toolkit rNUT [6] built on top of PVM <ref> [14] </ref> which is a quite popular integrated framework for distributed heterogeneous computing. A distributed program developed by means of the present toolkit represents a collection of dynamically created communicating processes running on PVM in a network. Each process runs in a separate NUT environment consisting of a NUT package.
Reference: 15. <author> P. Fishwick. </author> <year> (1992). </year> <title> Simpack: Getting Started with Simulation Programming in C and C++. </title> <type> Techn. Report TR 92-022. </type> <institution> Computer and Information Sciences. Univ. of Florida. </institution>
Reference-contexts: Our present experience in this field is restricted to development of a discrete event simulation package based on the library of C functions taken from Simpack <ref> [15] </ref>.
References-found: 15

