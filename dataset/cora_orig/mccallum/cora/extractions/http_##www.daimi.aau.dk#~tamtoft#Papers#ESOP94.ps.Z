URL: http://www.daimi.aau.dk/~tamtoft/Papers/ESOP94.ps.Z
Refering-URL: http://www.daimi.aau.dk/~tamtoft/papers.html
Root-URL: http://www.daimi.aau.dk
Email: internet: tamtoft@daimi.aau.dk  
Title: Local Type Reconstruction by means of Symbolic Fixed Point Iteration  
Author: Torben Amtoft 
Address: Ny Munkegade, DK-8000 Arhus C, Denmark  
Affiliation: DAIMI, Aarhus University  
Abstract: We convert, via a version that uses constraints, a type inference system for strictness analysis into an algorithm which given an expression finds the set of possible typings. Although this set in general does not possess a minimal element, it can be represented compactly by means of symbolic expressions in normal form such expressions have the property that once values for the constraint variables with negative polarity have been supplied it is straight-forward to compute the minimal values for the constraint variables with positive polarity. The normalization process works on the fly, i.e. by a leaf-to-root traversal of the inference tree. 
Abstract-found: 1
Intro-found: 1
Reference: [Amt93a] <author> Torben Amtoft. </author> <title> Minimal thunkification. </title> <booktitle> In 3rd International Workshop on Static Analysis (WSA '93), </booktitle> <month> September </month> <year> 1993, </year> <title> Padova, Italy, </title> <booktitle> number 724 in LNCS, </booktitle> <pages> pages 218-229. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In this paper we shall continue this trend, the type system in question being one for strictness analysis (the system has also been presented in <ref> [Amt93a] </ref>). <p> An Inference System: In Fig. 1 we present the inference system the implementation of which is the topic of this paper. An application of the inference system can be found in <ref> [Amt93a] </ref>, where it is shown how one by means of an infer ence tree can produce a (provably correct) translation from call-by-name into call-by-value which inserts fewer "suspensions" than the naive translation. <p> Fig. 1 is a specification of an analysis (and in <ref> [Amt93a] </ref> the specification is proven "correct" wrt. an operational semantics); in particular no clue is given on how to implement the analysis, that is how to construct a type for a given expression (and its subexpressions). <p> Approximating Solutions: We are not satisfied by only knowing the annotations of the arrows occurring in the overall type; we would like to know the typing of the subexpressions also (as this is needed by e.g. the translation algorithm in <ref> [Amt93a] </ref>). As an example, consider the term ((twice id) 7) (with twice as before and with id = x:x).
Reference: [Amt93b] <author> Torben Amtoft. </author> <title> Strictness types: An inference algorithm and an application. </title> <type> Technical Report PB-448, DAIMI, </type> <institution> University of Aarhus, Denmark, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Now let us focus upon the remaining constructs, where for space reasons we omit conditionals (can be found in <ref> [Amt93b] </ref>). Normalizing the Rule for Application. <p> Next the user provides the values of the constraint variables occurring negatively in the overall type; and finally the system produces an inference tree where all subexpressions are assigned the least possible strictness type. For a full documentation see <ref> [Amt93b] </ref>. Future work includes investigating the complexity of the algorithm just developed. This involves choosing an appropriate input size parameter (could be the size of the expression, the size of its type, the maximal size of a subexpression's type etc.).
Reference: [BHA86] <author> Geoffrey L. Burn, Chris Hankin, and Samson Abramsky. </author> <title> Strictness analysis for higher-order functions. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 7 </volume> <pages> 249-278, </pages> <year> 1986. </year>
Reference-contexts: Recent years have seen many approaches to strictness analysis, most based on abstract interpretation the starting point being the work of Mycroft [Myc80] which was extended to higher order functions by Burn, Hankin and Abramsky <ref> [BHA86] </ref>. Kuo and Mishra [KM89] presented a type system where types t are formed from 0 (denoting non-termination), 1 (denoting non-termination or termination, i.e. any term) and t 1 !t 2 .
Reference: [CJ93] <author> Charles Consel and Pierre Jouvelot. </author> <title> Separate polyvariant binding-time analysis. </title> <type> Technical Report CS/E 93-006, </type> <institution> Oregon Graduate Institute, Department of Computer Science and Engineering, </institution> <year> 1993. </year>
Reference-contexts: It would be interesting to see if the method described in this paper could be used on other kinds of inference systems. A work bearing strong similarities to ours is described in <ref> [CJ93] </ref>. Here a type inference system for binding time analysis is presented. <p> The price to be paid for the increased precision is that the type reconstruction algorithm presented in <ref> [CJ93] </ref> requires the user to supply the full type for bound variables in our framework, this essentially means that the user has to supply the values of the negative variables (and some of the positive ones too).
Reference: [Con91] <author> Charles Consel. </author> <title> Fast strictness analysis via symbolic fixpoint iteration. </title> <type> Technical Report YALEU/DCS/RR-867, </type> <institution> Yale University, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: This paradigm seems rather widely applicable; previous examples include <ref> [Con91] </ref> (for a first-order strictness analysis) and [Ros79] (for a flow-analysis of an imperative language). Fixed Point Solving: An important technique to be applied during normalization is fixed point iteration.
Reference: [Hen91] <author> Fritz Henglein. </author> <title> Efficient type inference for higher-order binding-time analysis. </title> <editor> In John Hughes, editor, </editor> <booktitle> International Conference on Functional Programming Languages and Computer Architecture, number 523 in LNCS, </booktitle> <pages> pages 448-472. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: This approach is appealing since it separates the question "what is done?" from the question "how is it done?". Of course, the latter issue (that is, implementation of the inference system) has to be dealt with, and a very popular method (often inspired by <ref> [Hen91] </ref>) is to (re)formulate the inference system in terms of constraints and then come up with an algorithm for solving these. In this paper we shall continue this trend, the type system in question being one for strictness analysis (the system has also been presented in [Amt93a]).
Reference: [Jen91] <author> Thomas P. Jensen. </author> <title> Strictness analysis in logical form. </title> <editor> In John Hughes, editor, </editor> <booktitle> International Conference on Functional Programming Languages and Computer Architecture, number 523 in LNCS, </booktitle> <pages> pages 352-366. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: 1 Background and Motivation Recently much interest has been devoted to the formulation of program analysis in terms of inference systems, as opposed to e.g. abstract interpretation (for the relationship between those methods see e.g. <ref> [Jen91] </ref>). This approach is appealing since it separates the question "what is done?" from the question "how is it done?".
Reference: [KM89] <author> Tsung-Min Kuo and Prateek Mishra. </author> <title> Strictness analysis: A new perspective based on type inference. </title> <booktitle> In International Conference on Functional Programming Languages and Computer Architecture '89, </booktitle> <pages> pages 260-272. </pages> <publisher> ACM Press, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: Recent years have seen many approaches to strictness analysis, most based on abstract interpretation the starting point being the work of Mycroft [Myc80] which was extended to higher order functions by Burn, Hankin and Abramsky [BHA86]. Kuo and Mishra <ref> [KM89] </ref> presented a type system where types t are formed from 0 (denoting non-termination), 1 (denoting non-termination or termination, i.e. any term) and t 1 !t 2 . Accordingly, if it is possible to assign a function the type 0!0 we know that the function is strict.
Reference: [Myc80] <author> Alan Mycroft. </author> <title> The theory of transforming call-by-need to call-by-value. </title> <editor> In B. Robinet, editor, </editor> <booktitle> International Symposium on Programming, Paris, number 83 in LNCS, </booktitle> <pages> pages 269-281. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1980. </year>
Reference-contexts: Strictness Analysis: The analysis we want to perform is strictness analysis, that is the task of detecting whether a function needs its argument (s). Recent years have seen many approaches to strictness analysis, most based on abstract interpretation the starting point being the work of Mycroft <ref> [Myc80] </ref> which was extended to higher order functions by Burn, Hankin and Abramsky [BHA86]. Kuo and Mishra [KM89] presented a type system where types t are formed from 0 (denoting non-termination), 1 (denoting non-termination or termination, i.e. any term) and t 1 !t 2 .
Reference: [Ros79] <author> Barry K. Rosen. </author> <title> Data flow analysis for procedural languages. </title> <journal> Journal of the ACM, </journal> <volume> 26(2) </volume> <pages> 322-344, </pages> <month> April </month> <year> 1979. </year>
Reference-contexts: This paradigm seems rather widely applicable; previous examples include [Con91] (for a first-order strictness analysis) and <ref> [Ros79] </ref> (for a flow-analysis of an imperative language). Fixed Point Solving: An important technique to be applied during normalization is fixed point iteration.
Reference: [SNN92] <author> Kirsten Lackner Solberg, Hanne Riis Nielson, and Flemming Nielson. </author> <title> Inference systems for binding time analysis. </title> <editor> In M. Billaud et al., editor, Analyse statique, </editor> <booktitle> Bordeaux 92 (WSA '92), </booktitle> <pages> pages 247-254, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The result of inlining the subsumption rule. 1 This inlining of the non-structural rules into the structural rules is a very common technique for getting an implementable system; another (more complex) example can be found in <ref> [SNN92] </ref>. The next step is to make the annotations on arrows more explicit; at the same time distinguishing between positive/negative polarity.
Reference: [Wri91] <author> David A. Wright. </author> <title> A new technique for strictness analysis. </title> <booktitle> In TAPSOFT '91, number 494 in LNCS, </booktitle> <pages> pages 235-258. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1991. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Accordingly, if it is possible to assign a function the type 0!0 we know that the function is strict. Wright has proposed alternative type systems <ref> [Wri91] </ref> where the idea is to annotate the arrows, according to whether a function is strict or not. Strictness Types: The type system used in this paper is the one of Wright, except that we use subtyping instead of polymorphism.
References-found: 12

