URL: http://www.cs.brown.edu/orgs/usys/spin.ps
Refering-URL: http://www.cs.brown.edu/orgs/usys/
Root-URL: http://www.cs.brown.edu
Title: SPIN An Extensible Microkernel for Application-specific Operating System Services  
Author: Brian N. Bershad Craig Chambers Susan Eggers Chris Maeda Dylan McNamee Przemysaw Pardyak Stefan Savage Emin Gun Sirer 
Date: February 28, 1994  
Address: Seattle, WA 98195  
Affiliation: Dept. of Computer Science and Engineering FR-35 University of Washington  
Pubnum: Technical Report 94-03-03  
Abstract: Application domains, such as multimedia, databases, and parallel computing, require operating system services with high performance and high functionality. Existing operating systems provide fixed interfaces and implementations to system services and resources. This makes them inappropriate for applications whose resource demands and usage patterns are poorly matched by the services provided. The SPIN operating system enables system services to be defined in an application-specific fashion through an extensible microkernel. It offers fine-grained control over a machine's logical and physical resources to applications through run-time adaptation of the system to application requirements. 
Abstract-found: 1
Intro-found: 1
Reference: [Accetta et al. 86] <author> Accetta, M. J., Baron, R. V., Bolosky, W., Golub, D. B., Rashid, R. F., Tevanian, Jr., A., and Young, M. W. </author> <title> Mach: A New Kernel Foundation for Unix Development. </title> <booktitle> In Proceedings of the 1986 Summer USENIX Conference, </booktitle> <pages> pages 93-113, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: In the third case, the application can enforce constraints that deny priority inversion. Although the code sequences execute in kernel-mode, their safety is verified by a trusted compiler. 1.3 Alternatives Microkernel technology has been promoted as a solution to many of the adaptability requirements of demanding applications <ref> [Accetta et al. 86] </ref>, and in the past few years there has been dramatic growth in the number and quality of microkernels [Phelan et al. 93, Hildebrand 92, Rozier et al. 88].
Reference: [Alemany & Felten 92] <author> Alemany, J. and Felten, E. W. </author> <title> Performance Issues in Non-blocking Synchronization on Shared-Memory Multiprocessors. </title> <booktitle> In Proceedings of the 1992 Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: In the general case, these optimistic strategies require some form of kernel support to ensure correctness in the presence of an oblivious kernel scheduler <ref> [Bershad et al. 92, Bershad 93, Alemany & Felten 92] </ref>. SPIN will make arbitrary synchronization strategies possible by reflecting scheduling decisions up to applications as they occur, or by providing an in-kernel rollback mechanism.
Reference: [Anderson 93] <author> Anderson, D. P. </author> <title> Metascheduling for Continuous Media. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(3) </volume> <pages> 226-252, </pages> <month> August </month> <year> 1993. </year> <month> 13 </month>
Reference-contexts: Some systems provide multiple scheduling policies but only from among a few fixed policies set at kernel-build time [Tokuda et al. 90]. Flexible, application-specific scheduling, though, has been shown to provide critical performance benefits for both time-constrained and non real-time activities <ref> [Anderson 93, Anderson et al. 92] </ref>. In terms of memory resources, multimedia applications use large amounts of data (audio and video streams) with access patterns that interact poorly with locality-based page replacement algorithms [Anderson 93, Nakajima et al. 92]. Application-specific virtual memory management policies can solve this problem. <p> In terms of memory resources, multimedia applications use large amounts of data (audio and video streams) with access patterns that interact poorly with locality-based page replacement algorithms <ref> [Anderson 93, Nakajima et al. 92] </ref>. Application-specific virtual memory management policies can solve this problem. High-level information about media direction, edit cuts, and temporal constraints are directly relevant to page replacement decisions.
Reference: [Anderson et al. 89] <author> Anderson, T. E., Lazowska, E. D., and Levy, H. M. </author> <title> The Performance Implications of Thread Management Alternatives for Shared-Memory Multiprocessors. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 38(12) </volume> <pages> 1631-1644, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Application-specific virtual memory services can ensure that unanticipated page faults do not delay processors involved in a cooperative computation, thereby delaying other processors. Shared memory multiprocessing applications require fine-grained scheduling control, lightweight threads [Anderson et al. 92], synchronization <ref> [Anderson et al. 89] </ref>, and information about memory system behavior. Multiprocessor applications can rely on application-specific thread schedulers, or user-level thread management packages, for high performance in the presence of relatively fine-grain parallelism [Anderson et al. 89]. <p> Shared memory multiprocessing applications require fine-grained scheduling control, lightweight threads [Anderson et al. 92], synchronization <ref> [Anderson et al. 89] </ref>, and information about memory system behavior. Multiprocessor applications can rely on application-specific thread schedulers, or user-level thread management packages, for high performance in the presence of relatively fine-grain parallelism [Anderson et al. 89]. Implementing user-level threads on top of 8 existing operating system mechanisms (such as kernel threads) can be difficult. In previous work, we addressed these difficulties with a mechanism called scheduler activations.
Reference: [Anderson et al. 92] <author> Anderson, T. E., Bershad, B. N., Lazowska, E. D., and Levy, H. M. </author> <title> Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Application-specific virtual memory services can ensure that unanticipated page faults do not delay processors involved in a cooperative computation, thereby delaying other processors. Shared memory multiprocessing applications require fine-grained scheduling control, lightweight threads <ref> [Anderson et al. 92] </ref>, synchronization [Anderson et al. 89], and information about memory system behavior. Multiprocessor applications can rely on application-specific thread schedulers, or user-level thread management packages, for high performance in the presence of relatively fine-grain parallelism [Anderson et al. 89]. <p> Implementing user-level threads on top of 8 existing operating system mechanisms (such as kernel threads) can be difficult. In previous work, we addressed these difficulties with a mechanism called scheduler activations. Scheduler activations rely on the operating system kernel to convey information about kernel-level scheduling events to applications <ref> [Anderson et al. 92] </ref>. Multimedia Multimedia applications, such as video-on-demand, video-conferencing, virtual reality, and interactive learning, impose special demands on the scheduling, communication and memory allocation policies of an operating system. In general, real-time systems implement a simple fixed priority ordering [Hildebrand 92]. <p> Some systems provide multiple scheduling policies but only from among a few fixed policies set at kernel-build time [Tokuda et al. 90]. Flexible, application-specific scheduling, though, has been shown to provide critical performance benefits for both time-constrained and non real-time activities <ref> [Anderson 93, Anderson et al. 92] </ref>. In terms of memory resources, multimedia applications use large amounts of data (audio and video streams) with access patterns that interact poorly with locality-based page replacement algorithms [Anderson 93, Nakajima et al. 92]. Application-specific virtual memory management policies can solve this problem. <p> However, these systems offered no protection against rogue or buggy applications, making them inappropriate for multiuser environments. 11 Extensible services Previous research into extensible system services has addressed file systems [Rees et al. 86, Bershad & Pinkerton 88], scheduling <ref> [Anderson et al. 92] </ref>, communication [Bershad et al. 91], and user-level memory management [Krueger et al. 93, McNamee & Armstrong 90, Harty & Cheriton 92, Sechrest & Park 91]. No system has provided an efficient way to compose multiple resources in a coherent manner.
Reference: [Babaoglu & Joy 81] <author> Babaoglu, Ozalp. and Joy, W. </author> <title> Converting a Swap-Based System to do Paging in an Architecture Lacking Page-Referenced Bits. </title> <booktitle> In Proceedings of the Eighth Symposium on Operating Systems Principles, </booktitle> <pages> pages 78-86, </pages> <month> December </month> <year> 1981. </year>
Reference-contexts: The key problem facing operating systems is how to support efficiently a range of applications with widely varying service demands. For example, current virtual memory page-replacement policies are based on application mixes from the 1970's and early 1980's <ref> [Babaoglu & Joy 81] </ref> that have good reference locality. These policies, though, are poorly suited for newer applications, such as information retrieval and multimedia, where page access patterns are seemingly random, or strictly sequential and temporally constrained [Kearns & DeFazio 89].
Reference: [Bershad & Pinkerton 88] <author> Bershad, B. N. and Pinkerton, C. B. </author> <title> Watchdogs Extending the UNIX File System. </title> <journal> Computing Systems, </journal> <volume> 1(2) </volume> <pages> 169-188, </pages> <month> Spring </month> <year> 1988. </year>
Reference-contexts: However, these systems offered no protection against rogue or buggy applications, making them inappropriate for multiuser environments. 11 Extensible services Previous research into extensible system services has addressed file systems <ref> [Rees et al. 86, Bershad & Pinkerton 88] </ref>, scheduling [Anderson et al. 92], communication [Bershad et al. 91], and user-level memory management [Krueger et al. 93, McNamee & Armstrong 90, Harty & Cheriton 92, Sechrest & Park 91].
Reference: [Bershad 93] <author> Bershad, B. N. </author> <title> Practical Considerations for Non-Blocking Concurrent Objects. </title> <booktitle> In Proceedings of the 13th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 264-274, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: In the general case, these optimistic strategies require some form of kernel support to ensure correctness in the presence of an oblivious kernel scheduler <ref> [Bershad et al. 92, Bershad 93, Alemany & Felten 92] </ref>. SPIN will make arbitrary synchronization strategies possible by reflecting scheduling decisions up to applications as they occur, or by providing an in-kernel rollback mechanism.
Reference: [Bershad et al. 90] <author> Bershad, B. N., Anderson, T. E., Lazowska, E. D., and Levy, H. M. </author> <title> Lightweight Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 37-55, </pages> <month> February </month> <year> 1990. </year> <booktitle> Also appeared in Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1989. </year>
Reference-contexts: For example, any program that uses threads internally as a program structuring device [Hauser et al. 93] can benefit from fast synchronization [Bershad et al. 92]. Any program that interacts with an operating system server can benefit from fast interprocess communication <ref> [Bershad et al. 90, Draves et al. 91] </ref>. Many applications have become sensitive to the degree to which their memory access patterns are satisfied by an architecture's fast memory system (cache and translation lookaside buffer) [Chen & Bershad 93].
Reference: [Bershad et al. 91] <author> Bershad, B. N., Anderson, T. E., Lazowska, E. D., and Levy, H. M. </author> <title> User-Level Interprocess Communication for Shared Memory Multiprocessors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 175-198, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: However, these systems offered no protection against rogue or buggy applications, making them inappropriate for multiuser environments. 11 Extensible services Previous research into extensible system services has addressed file systems [Rees et al. 86, Bershad & Pinkerton 88], scheduling [Anderson et al. 92], communication <ref> [Bershad et al. 91] </ref>, and user-level memory management [Krueger et al. 93, McNamee & Armstrong 90, Harty & Cheriton 92, Sechrest & Park 91]. No system has provided an efficient way to compose multiple resources in a coherent manner.
Reference: [Bershad et al. 92] <author> Bershad, B. N., Redell, D. D., and Ellis, J. R. </author> <title> Fast Mutual Exclusion for Uniprocessors. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <pages> pages 223-233, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: General purpose high-performance computing Many operating system services such as synchronization and scheduling, virtual memory and interprocess communication are generally important for any application requiring high performance. For example, any program that uses threads internally as a program structuring device [Hauser et al. 93] can benefit from fast synchronization <ref> [Bershad et al. 92] </ref>. Any program that interacts with an operating system server can benefit from fast interprocess communication [Bershad et al. 90, Draves et al. 91]. <p> In the general case, these optimistic strategies require some form of kernel support to ensure correctness in the presence of an oblivious kernel scheduler <ref> [Bershad et al. 92, Bershad 93, Alemany & Felten 92] </ref>. SPIN will make arbitrary synchronization strategies possible by reflecting scheduling decisions up to applications as they occur, or by providing an in-kernel rollback mechanism.
Reference: [Black 90] <author> Black, D. L. </author> <title> Scheduling and Resource Management Techniques for Multiprocessors. </title> <type> PhD dissertation, </type> <institution> Carnegie Mellon University, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: In general, real-time systems implement a simple fixed priority ordering [Hildebrand 92]. Conventional operating systems, however, support either a single scheduling policy to arbitrate among competing activities, or multiple policies that promote fairness but favor interactive activities <ref> [Black 90] </ref>. Some systems provide multiple scheduling policies but only from among a few fixed policies set at kernel-build time [Tokuda et al. 90]. Flexible, application-specific scheduling, though, has been shown to provide critical performance benefits for both time-constrained and non real-time activities [Anderson 93, Anderson et al. 92].
Reference: [Chambers & Ungar 91] <author> Chambers, C. and Ungar, D. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> In Proceedings of OOPSLA '91, </booktitle> <pages> pages 1-15, </pages> <month> October </month> <year> 1991. </year> <journal> SIGPLAN Notices 26(10). </journal>
Reference: [Chambers 92] <author> Chambers, C. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <booktitle> In Proceedings of ECOOP '92, </booktitle> <pages> pages 33-56, </pages> <month> June </month> <year> 1992. </year> <note> LNCS 615. </note>
Reference: [Chambers 93] <author> Chambers, C. </author> <title> Analysis and Optimization of Object-Oriented Languages. </title> <type> Technical report, </type> <institution> University of Washing-ton, </institution> <year> 1993. </year> <note> LNCS 615. </note>
Reference: [Chen & Bershad 93] <author> Chen, J. B. and Bershad, B. N. </author> <title> The Impact of Operating System Structure on Memory System Performance. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 120-133, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Many applications have become sensitive to the degree to which their memory access patterns are satisfied by an architecture's fast memory system (cache and translation lookaside buffer) <ref> [Chen & Bershad 93] </ref>. For example, some compilers now use static blocking algorithms based on the cache size in order to maximize the cache hit rate during well-formed data intensive computations [Lam et al. 91].
Reference: [Consel 90] <author> Consel, C. </author> <title> Binding Time Analysis for Higher Order Untyped Functional Languages. </title> <booktitle> In Conference on Lisp and Functional Programming, </booktitle> <pages> pages 264-272, </pages> <year> 1990. </year>
Reference: [Cooper et al. 91] <author> Cooper, E., Harper, R., and Lee, P. </author> <title> The Fox Project: Advanced Developement of Systems Software. </title> <type> Technical Report CMU-CS-91-187, </type> <institution> Carnegie Mellon University, </institution> <year> 1991. </year>
Reference-contexts: Hence, a SPIN application could create a file open interface whose implementation is optimized not only for the particular file, but also for the access patterns of the application. 5.2 Language and compiler work The Fox Project The Fox project <ref> [Cooper et al. 91] </ref> applies advanced compiler technology to system software development. The primary focus of the research is on the extensions necessary to use the Standard ML programming language [Milner et al. 89] in support of systems programming.
Reference: [Deutsch & Schiffman 84] <author> Deutsch, P. and Schiffman, A. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297-302, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: Previous reflective systems have suffered high overhead from the extra layers of abstraction. SPIN relies on dynamic compilation and partial evaluation to ensure good performance. Compiler optimization techniques Runtime compilation of code has been explored in several experimental systems, ranging from a Smalltalk environment <ref> [Deutsch & Schiffman 84] </ref> to the implementation of bit-transfer operations in raster graphics systems [Pike et al. 85] to debugging [Kessler 90]. Runtime code generation and optimization has also been used to produce speedups in traditional applications [Keppel et al. 93].
Reference: [Dijkstra 66] <author> Dijkstra, E. W. </author> <title> The Structure of the THE Multiprogramming System. </title> <journal> Communications of the ACM, </journal> <volume> 9(3) </volume> <pages> 341-346, </pages> <month> March </month> <year> 1966. </year>
Reference-contexts: One tick denotes some applicability, two ticks denote significant improvements in performance, and three ticks denote critical improvements. 5 Related work 5.1 Extensibility and the operating system Extensibility has been the holy grail of operating systems design since THE, one of the first modular operating systems <ref> [Dijkstra 66] </ref>. An inflexible module structure and poor performance proved to be a substantial drawback of these systems.
Reference: [Draves et al. 91] <author> Draves, R. P., Bershad, B. N., Rashid, R. F., and Dean, R. W. </author> <title> Using Continuations to Implement Thread Management and Communication in Operating Systems. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 122-136, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: For example, any program that uses threads internally as a program structuring device [Hauser et al. 93] can benefit from fast synchronization [Bershad et al. 92]. Any program that interacts with an operating system server can benefit from fast interprocess communication <ref> [Bershad et al. 90, Draves et al. 91] </ref>. Many applications have become sensitive to the degree to which their memory access patterns are satisfied by an architecture's fast memory system (cache and translation lookaside buffer) [Chen & Bershad 93].
Reference: [Felten 92] <author> Felten, E. </author> <title> The Case for Application-Specific Communication Protocols. </title> <booktitle> In Proceedings of Intel Supercomputer Systems Division Technology Focus Conference, </booktitle> <pages> pages 171-181, </pages> <year> 1992. </year>
Reference-contexts: These miss rates may be easy to determine, but potentially expensive to communicate to the application. Application-specific code in the kernel that can track a program's memory system behavior and provide guidance and feedback to the runtime can result in improved program performance. Parallel processing Application-specific communication protocols <ref> [Felten 92] </ref>, scheduling, and virtual memory management can improve the performance of parallel programs running on a distributed memory multicomputer. Fast communication is required to transmit messages from one processor to another.
Reference: [Felten 93] <author> Felten, E. W. </author> <title> High-Performance Communication for Parallel Programs. </title> <type> PhD dissertation, </type> <institution> University of Washington, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Spindles implement low-level data packet dispatching mechanisms that couple remote communication with application-level protocol processing. Fast, simple communication For many multicomputer applications, the per-message processing required by an application is substantially less than that needed to transmit the message reliably <ref> [Felten 93] </ref>. Low-latency message passing spindles that run at interrupt-level can substantially improve parallel system performance.
Reference: [Gibson et al. 92] <author> Gibson, G., Patterson, H., and Satyanarayanan, M. </author> <title> Disk Reads with DRAM Latency. </title> <booktitle> Operating Systems Review, </booktitle> <month> April </month> <year> 1992. </year> <month> 14 </month>
Reference-contexts: Filesystem performance can benefit from application-specific information in several ways. The application can provide hints about future usage to the filesystem to help it schedule disk traffic <ref> [Gibson et al. 92] </ref>. This can result in more effective prefetching policies and lower buffer cache miss rates. An effective prefetching policy can also remove virtual memory remapping operations from the critical path, since disk blocks are already mapped into the application address space when they are needed.
Reference: [Golub et al. 90] <author> Golub, D., Dean, R., Forin, A., and Rashid, R. </author> <title> Unix as an Application Program. </title> <booktitle> In Proceedings of the 1990 Summer USENIX Conference, </booktitle> <pages> pages 87-95, </pages> <month> June </month> <year> 1990. </year>
Reference: [Gray & Reuter 92] <author> Gray, J. and Reuter, A. </author> <title> Transaction Processing. </title> <publisher> Morgan Kaufman, </publisher> <year> 1992. </year>
Reference-contexts: Similarly, current file system implementations assume that most files are accessed sequentially [Ousterhout et al. 85]. However, important applications such as information retrieval have file access patterns that are quite non-sequential <ref> [Gray & Reuter 92] </ref>. As a result, many database systems manage in-core disk caches manually because existing operating systems do such a poor job of meeting their needs [Stonebraker 81].
Reference: [Harty & Cheriton 92] <author> Harty, K. and Cheriton, D. R. </author> <title> Application-Controlled Physical Memory using External Page-Cache Management. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <pages> pages 187-197, </pages> <year> 1992. </year>
Reference-contexts: Conventional microkernels with fixed interfaces can use the first optimization, but the other two require new capabilities that are provided by the spindle mechanism. 2.4 An example As an example of how components of SPIN fit together, consider the structure of a user-level virtual memory manager <ref> [McNamee & Armstrong 90, Harty & Cheriton 92] </ref>. A user-level virtual memory manager enables an application to control the set and contents of physical page frames that are currently backing a given piece of virtual memory.
Reference: [Hauser et al. 93] <author> Hauser, C., Jacobi, C., Theimer, M., Welch, B., and Weiser, M. </author> <title> Using Threads in Interactive Systems: A Case Study. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 94-105, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: General purpose high-performance computing Many operating system services such as synchronization and scheduling, virtual memory and interprocess communication are generally important for any application requiring high performance. For example, any program that uses threads internally as a program structuring device <ref> [Hauser et al. 93] </ref> can benefit from fast synchronization [Bershad et al. 92]. Any program that interacts with an operating system server can benefit from fast interprocess communication [Bershad et al. 90, Draves et al. 91].
Reference: [Hildebrand 92] <author> Hildebrand, D. </author> <title> An Architectural Overview of QNX. </title> <booktitle> In Proceedings of the Usenix Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: kernel-mode, their safety is verified by a trusted compiler. 1.3 Alternatives Microkernel technology has been promoted as a solution to many of the adaptability requirements of demanding applications [Accetta et al. 86], and in the past few years there has been dramatic growth in the number and quality of microkernels <ref> [Phelan et al. 93, Hildebrand 92, Rozier et al. 88] </ref>. Current practice is to structure a microkernel-based operating system as one or more server address spaces that collectively implement operating system services [Golub et al. 90, Julin et al. 91, Rozier et al. 88, Khalidi & Nelson 93, Hildebrand 92]. <p> Multimedia Multimedia applications, such as video-on-demand, video-conferencing, virtual reality, and interactive learning, impose special demands on the scheduling, communication and memory allocation policies of an operating system. In general, real-time systems implement a simple fixed priority ordering <ref> [Hildebrand 92] </ref>. Conventional operating systems, however, support either a single scheduling policy to arbitrate among competing activities, or multiple policies that promote fairness but favor interactive activities [Black 90].
Reference: [Hosking & Moss 93] <author> Hosking, A. L. and Moss, J. E. B. </author> <title> Protection Traps and Alternatives for Memory Management of an Object-Oriented Language. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 106-119, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The pager can even define logical pages that are smaller than the machine's physical pages, detecting writes, for example, to sub-pages in order to collect fine-grained reference information <ref> [Hosking & Moss 93] </ref>. 6 3 Spindle language and compiler issues An operating system interface is much like a programming language in that it defines a primitive set of operations available to the programmer [Lampson 84].
Reference: [Jones et al. 89] <author> Jones, N., Sestoft, P., and Sondergaard, H. </author> <title> MIX: A Self-Applicable Partial Evaluator for Experiments in Compiler Generation. </title> <journal> Lisp & Symbolic Computing, </journal> <volume> 2(1) </volume> <pages> 9-50, </pages> <month> February </month> <year> 1989. </year>
Reference: [Jones et al. 93] <author> Jones, N., Gomard, C., and Sestoft, P. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference: [Julin et al. 91] <author> Julin, D. P., Chew, J. J., Stevenson, J. M., Guedes, P., Neves, P., and Roy, P. </author> <title> Generalized Emulation Services for Mach 3.0: Overview, Experiences and Current Status. </title> <booktitle> In Proceedings of the Second Usenix Mach Symposium, </booktitle> <pages> pages 13-26, </pages> <year> 1991. </year>
Reference: [Kearns & DeFazio 89] <author> Kearns, J. and DeFazio, S. </author> <title> Diversity in Database Reference Behavior. Performance Evaluation Review, </title> <year> 1989. </year>
Reference-contexts: These policies, though, are poorly suited for newer applications, such as information retrieval and multimedia, where page access patterns are seemingly random, or strictly sequential and temporally constrained <ref> [Kearns & DeFazio 89] </ref>. Similarly, current file system implementations assume that most files are accessed sequentially [Ousterhout et al. 85]. However, important applications such as information retrieval have file access patterns that are quite non-sequential [Gray & Reuter 92].
Reference: [Keppel et al. 93] <author> Keppel, D., Eggers, S., and Henry, R. </author> <title> Evaluating Runtime-Compiled, Value-Specific Optimizations, </title> <note> 1993. Submitted for publication. </note>
Reference-contexts: Runtime code generation and optimization has also been used to produce speedups in traditional applications <ref> [Keppel et al. 93] </ref>. The Self and Cecil systems [Ungar & Smith 87, Chambers & Ungar 91, Chambers 93, Chambers 92] include automatic mechanisms for determining where optimizations can be cost effective, and may choose not to optimize in cases where performance will not be improved.
Reference: [Kessler 90] <author> Kessler, P. </author> <title> Fast Breakpoints: </title> <booktitle> Design and Implementation. In ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 78-84, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Compiler optimization techniques Runtime compilation of code has been explored in several experimental systems, ranging from a Smalltalk environment [Deutsch & Schiffman 84] to the implementation of bit-transfer operations in raster graphics systems [Pike et al. 85] to debugging <ref> [Kessler 90] </ref>. Runtime code generation and optimization has also been used to produce speedups in traditional applications [Keppel et al. 93].
Reference: [Khalidi & Nelson 93] <author> Khalidi, Y. A. and Nelson, M. N. </author> <title> An Implementation of UNIX on an Object-Oriented Operating System. </title> <booktitle> In Proceedings of the 1993 Winter USENIX Conference, </booktitle> <pages> pages 469-480, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: SPIN generalizes on the notion of the packet filter, enabling richer, more complex services to be safely installed into the kernel. Dynamic linking In systems such as Spring <ref> [Khalidi & Nelson 93] </ref>, Chorus [Rozier et al. 88], and OSF/1 the kernel can be modified at run time with a new set of interface implementations for heavyweight services like device drivers or the Unix file system.
Reference: [Kiczales et al. 91] <author> Kiczales, G., des Rivieres, J., and Bobrow, D. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Kiczales 12 et al. have studied general meta-object protocols, which are interfaces to languages and systems that enable users to customize and extend the system's behavior <ref> [Kiczales et al. 91] </ref>. Although SPIN does not support general reflection, it does provide a controlled mechanism by which services can augment the kernel with their own specialized code sequences (spindles). Previous reflective systems have suffered high overhead from the extra layers of abstraction.
Reference: [Krueger et al. 93] <author> Krueger, K., Loftesness, D., Vahdat, A., and Anderson, T. </author> <title> Tools for the Developement of Application-Specific Virtual Memory Management. </title> <booktitle> In Proceedings of the 1993 OOPSLA, </booktitle> <pages> pages 48-64, </pages> <year> 1993. </year>
Reference: [Lam et al. 91] <author> Lam, M. S., Rothberg, E. E., and Wolf, M. E. </author> <title> The Cache Performance and Optimizations of Blocked Algorithms. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: For example, some compilers now use static blocking algorithms based on the cache size in order to maximize the cache hit rate during well-formed data intensive computations <ref> [Lam et al. 91] </ref>. Programs with irregular structure must rely on more dynamic information, for example, cache, TLB, or page fault rates. These miss rates may be easy to determine, but potentially expensive to communicate to the application.
Reference: [Lampson 84] <author> Lampson, B. W. </author> <title> Hints for Computer System Design. </title> <journal> IEEE Software, </journal> <volume> 1(1) </volume> <pages> 11-28, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: machine's physical pages, detecting writes, for example, to sub-pages in order to collect fine-grained reference information [Hosking & Moss 93]. 6 3 Spindle language and compiler issues An operating system interface is much like a programming language in that it defines a primitive set of operations available to the programmer <ref> [Lampson 84] </ref>. In SPIN, the operating system interface is in fact an actual programming language through which applications can define and install new interfaces that match their requirements. The language and its implementation have the following goals: * Expressiveness.
Reference: [Maeda & Bershad 92] <author> Maeda, C. and Bershad, B. N. </author> <title> Networking Performance for Microkernels. </title> <booktitle> In Proceedings of the Third Workshop on Workstation Operating Systems, </booktitle> <pages> pages 154-159, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: However, it is often as difficult to modify a service in another address space as it is to modify one placed in the kernel, diminishing many of the flexibility advantages that favor microkernel architectures. In addition, the communication overhead incurred when contacting servers can result in poor performance <ref> [Maeda & Bershad 92, Maeda & Bershad 93] </ref>. These facts make it quite difficult to tailor an operating system service to the requirements of a particular resource intensive application using conventional microkernel technology. 1.4 The rest of this paper The rest of this paper is structured as follows.
Reference: [Maeda & Bershad 93] <author> Maeda, C. and Bershad, B. N. </author> <title> Protocol Service Decomposition for High-Performance Networking. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 244-255, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: However, it is often as difficult to modify a service in another address space as it is to modify one placed in the kernel, diminishing many of the flexibility advantages that favor microkernel architectures. In addition, the communication overhead incurred when contacting servers can result in poor performance <ref> [Maeda & Bershad 92, Maeda & Bershad 93] </ref>. These facts make it quite difficult to tailor an operating system service to the requirements of a particular resource intensive application using conventional microkernel technology. 1.4 The rest of this paper The rest of this paper is structured as follows.
Reference: [Massalin & Pu 89] <author> Massalin, H. and Pu, C. </author> <title> Threads and Input/Output in the Synthesis Kernel. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: A user-level library, in turn, implements application-specific thread management primitives. Synchronization Synchronization mechanisms coordinate the activity of multiple threads of control that share memory. Synchronization mechanisms that assume no contention for shared resources can have lower overhead than pessimistic ones that assume that contention will occur <ref> [Massalin & Pu 89, Stodolsky et al. 93] </ref>. In the general case, these optimistic strategies require some form of kernel support to ensure correctness in the presence of an oblivious kernel scheduler [Bershad et al. 92, Bershad 93, Alemany & Felten 92]. <p> In contrast, with SPIN, extensibility is at the interface level (new kernel interfaces can be defined by applications), fine-grained (particular events within particular applications and threads), and safe (the extensions are validated both dynamically and statically). Synthesis The Synthesis system <ref> [Massalin & Pu 89] </ref> improved performance through the use of highly specialized and dynamically constructed interface implementations. For instance, a file open operation in Synthesis would return a handle to a piece of code optimized for accessing the opened file.
Reference: [McNamee & Armstrong 90] <author> McNamee, D. and Armstrong, K. </author> <title> Extending the Mach External Pager Interface to Accommodate User-Level Page Replacement Policies. </title> <booktitle> In Proceedings of the Usenix Mach Symposium, </booktitle> <pages> pages 17-29, </pages> <year> 1990. </year>
Reference-contexts: Conventional microkernels with fixed interfaces can use the first optimization, but the other two require new capabilities that are provided by the spindle mechanism. 2.4 An example As an example of how components of SPIN fit together, consider the structure of a user-level virtual memory manager <ref> [McNamee & Armstrong 90, Harty & Cheriton 92] </ref>. A user-level virtual memory manager enables an application to control the set and contents of physical page frames that are currently backing a given piece of virtual memory.
Reference: [Milner et al. 89] <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: The primary focus of the research is on the extensions necessary to use the Standard ML programming language <ref> [Milner et al. 89] </ref> in support of systems programming. Standard ML is a type-safe programming language with a rich module system that enables many of types of extensions that are available in SPIN.
Reference: [Mogul et al. 87] <author> Mogul, J. C., Rashid, R. F., and Accetta, M. J. </author> <title> The Packet Filter: An Efficient Mechanism for User-level Network Code. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: This context switching overhead can put a high lower bound on the allocation granularity possible in the system. In contrast to this approach, SPIN provides a single framework in which extensible services can be build. Packet filters The packet filter offers an example of kernel extensibility <ref> [Mogul et al. 87] </ref>. A packet filter is run against each incoming network packet to demultiplex data packets to higher level protocol software. With careful design, the packet filter is able to support protocol processing for a large number of applications [Yuhara et al. 94].
Reference: [Nakajima et al. 92] <author> Nakajima, J., Yazaki, M., and Matsumoto, H. </author> <title> Multimedia/Realtime Extensions for Mach 3.0. </title> <booktitle> In Proceedings of the Usenix Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: In terms of memory resources, multimedia applications use large amounts of data (audio and video streams) with access patterns that interact poorly with locality-based page replacement algorithms <ref> [Anderson 93, Nakajima et al. 92] </ref>. Application-specific virtual memory management policies can solve this problem. High-level information about media direction, edit cuts, and temporal constraints are directly relevant to page replacement decisions.
Reference: [Ousterhout 84] <author> Ousterhout, J. </author> <title> Scheduling Techniques for Concurrent Systems. </title> <booktitle> In Proceedings of the 3rd IEEE International Conference on Distributed Computing, </booktitle> <year> 1984. </year>
Reference-contexts: Fast communication is required to transmit messages from one processor to another. Appropriate scheduling and synchronization support can ensure that all threads in a multicomputer program run at the same time to avoid unnecessary stalls due to scheduling anomalies <ref> [Zahorjan & McCann 90, Ousterhout 84] </ref>. Application-specific virtual memory services can ensure that unanticipated page faults do not delay processors involved in a cooperative computation, thereby delaying other processors.
Reference: [Ousterhout et al. 85] <author> Ousterhout, J. K., Costa, H. D., Harrison, D., Kunze, J. A., Kupfer, M., and Thompson, J. G. </author> <title> A Trace-Driven Analysis of the UNIX 4.2 BSD File System. </title> <booktitle> In Proceedings of the Tenth Symposium on Operating Systems Principles, </booktitle> <pages> pages 15-24, </pages> <year> 1985. </year>
Reference-contexts: These policies, though, are poorly suited for newer applications, such as information retrieval and multimedia, where page access patterns are seemingly random, or strictly sequential and temporally constrained [Kearns & DeFazio 89]. Similarly, current file system implementations assume that most files are accessed sequentially <ref> [Ousterhout et al. 85] </ref>. However, important applications such as information retrieval have file access patterns that are quite non-sequential [Gray & Reuter 92]. As a result, many database systems manage in-core disk caches manually because existing operating systems do such a poor job of meeting their needs [Stonebraker 81].
Reference: [Phelan et al. 93] <author> Phelan, J. M., Arendt, J., and Ormsby, G. R. </author> <title> An OS/2 Personality on Mach. </title> <booktitle> In Proceedings of the Third Usenix Mach Symposium, </booktitle> <pages> pages 191-201, </pages> <year> 1993. </year>
Reference-contexts: kernel-mode, their safety is verified by a trusted compiler. 1.3 Alternatives Microkernel technology has been promoted as a solution to many of the adaptability requirements of demanding applications [Accetta et al. 86], and in the past few years there has been dramatic growth in the number and quality of microkernels <ref> [Phelan et al. 93, Hildebrand 92, Rozier et al. 88] </ref>. Current practice is to structure a microkernel-based operating system as one or more server address spaces that collectively implement operating system services [Golub et al. 90, Julin et al. 91, Rozier et al. 88, Khalidi & Nelson 93, Hildebrand 92].
Reference: [Pike et al. 85] <author> Pike, R., Locanthi, B., and Reiser, J. </author> <title> Hardware/Software Trade-offs for Bitmap Graphics on the Blit. </title> <journal> Software Practice and Experience, </journal> <volume> 15(2) </volume> <pages> 131-151, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: SPIN relies on dynamic compilation and partial evaluation to ensure good performance. Compiler optimization techniques Runtime compilation of code has been explored in several experimental systems, ranging from a Smalltalk environment [Deutsch & Schiffman 84] to the implementation of bit-transfer operations in raster graphics systems <ref> [Pike et al. 85] </ref> to debugging [Kessler 90]. Runtime code generation and optimization has also been used to produce speedups in traditional applications [Keppel et al. 93].
Reference: [Redell et al. 80] <author> Redell, D. D., Dalal, Y. K., Horsley, T. R., Lauer, H. C., Lynch, W. C., McJones, P. R., Murray, H. G., and Purcell, S. C. </author> <title> Pilot: An Operating System for a Personal Computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: An inflexible module structure and poor performance proved to be a substantial drawback of these systems. Early personal computer operating systems <ref> [Redell et al. 80] </ref>, which ran all system services and applications in a single address space, enabled applications to have good performance while being tightly coupled with the operating system.
Reference: [Rees et al. 86] <author> Rees, J., Levine, P. H., Mishkin, N., and Leach, P. J. </author> <title> An Extensible I/O System. </title> <booktitle> In USENIX Association Summer Conference Proceedings, </booktitle> <pages> pages 114-125, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: However, these systems offered no protection against rogue or buggy applications, making them inappropriate for multiuser environments. 11 Extensible services Previous research into extensible system services has addressed file systems <ref> [Rees et al. 86, Bershad & Pinkerton 88] </ref>, scheduling [Anderson et al. 92], communication [Bershad et al. 91], and user-level memory management [Krueger et al. 93, McNamee & Armstrong 90, Harty & Cheriton 92, Sechrest & Park 91].
Reference: [Rozier et al. 88] <author> Rozier, M., Abrossimov, V., Armand, F., Boule, I., Giend, M., Guillemont, M., Herrmann, F., Leonard, P., Langlois, S., and Neuhauser, W. </author> <title> The Chorus Distributed Operating System. </title> <journal> Computing Systems, </journal> <volume> 1(4), </volume> <year> 1988. </year>
Reference-contexts: kernel-mode, their safety is verified by a trusted compiler. 1.3 Alternatives Microkernel technology has been promoted as a solution to many of the adaptability requirements of demanding applications [Accetta et al. 86], and in the past few years there has been dramatic growth in the number and quality of microkernels <ref> [Phelan et al. 93, Hildebrand 92, Rozier et al. 88] </ref>. Current practice is to structure a microkernel-based operating system as one or more server address spaces that collectively implement operating system services [Golub et al. 90, Julin et al. 91, Rozier et al. 88, Khalidi & Nelson 93, Hildebrand 92]. <p> SPIN generalizes on the notion of the packet filter, enabling richer, more complex services to be safely installed into the kernel. Dynamic linking In systems such as Spring [Khalidi & Nelson 93], Chorus <ref> [Rozier et al. 88] </ref>, and OSF/1 the kernel can be modified at run time with a new set of interface implementations for heavyweight services like device drivers or the Unix file system. Pure object code is downloaded on-the-fly from user-level into the kernel, exposing the kernel to protection violations.
Reference: [Sechrest & Park 91] <author> Sechrest, S. and Park, Y. </author> <title> User-Level Physical Memory Management for Mach. </title> <booktitle> In Proceedings of the Second Usenix Mach Symposium, </booktitle> <pages> pages 189-199, </pages> <year> 1991. </year>
Reference: [Stodolsky et al. 93] <author> Stodolsky, D., Bershad, B. N., and Chen, B. </author> <title> Fast Interrupt Priority Management for Operating System Kernels. </title> <booktitle> In Proceedings of the Second Usenix Workshop on Microkernels and Other Kernel Architectures, </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: A user-level library, in turn, implements application-specific thread management primitives. Synchronization Synchronization mechanisms coordinate the activity of multiple threads of control that share memory. Synchronization mechanisms that assume no contention for shared resources can have lower overhead than pessimistic ones that assume that contention will occur <ref> [Massalin & Pu 89, Stodolsky et al. 93] </ref>. In the general case, these optimistic strategies require some form of kernel support to ensure correctness in the presence of an oblivious kernel scheduler [Bershad et al. 92, Bershad 93, Alemany & Felten 92].
Reference: [Stonebraker 81] <author> Stonebraker, M. </author> <title> Operating System Support for Database Management. </title> <journal> Communications of the ACM, </journal> <volume> 24(7) </volume> <pages> 412-418, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: However, important applications such as information retrieval have file access patterns that are quite non-sequential [Gray & Reuter 92]. As a result, many database systems manage in-core disk caches manually because existing operating systems do such a poor job of meeting their needs <ref> [Stonebraker 81] </ref>. We believe that other performance-critical applications will follow the same route because no current operating system allows system resources to be efficiently and safely managed through tailored interfaces and implementations. <p> In addition, the application can inform the kernel about how it will use the buffer cache, so that the kernel can make informed decisions about physical memory allocation <ref> [Stonebraker 81] </ref>. 4.1 Some application-specific services enabled by SPIN The application domains described in the previous subsection can be enabled by operating system services that are customized to the program's needs. Below, we detail some specific techniques.
Reference: [Thekkath et al. 93] <author> Thekkath, C. A., Nguyen, T. D., Moy, E., and Lazowska, E. D. </author> <title> Implementing network protocols at user level. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(5) </volume> <pages> 554-565, </pages> <month> October </month> <year> 1993. </year>
Reference: [Tokuda et al. 90] <author> Tokuda, H., Nakajima, T., and Rao, P. </author> <title> Real-Time Mach: Toward a Predictable Real-Time System. </title> <booktitle> In Proceedings of the Usenix Mach Symposium, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: Conventional operating systems, however, support either a single scheduling policy to arbitrate among competing activities, or multiple policies that promote fairness but favor interactive activities [Black 90]. Some systems provide multiple scheduling policies but only from among a few fixed policies set at kernel-build time <ref> [Tokuda et al. 90] </ref>. Flexible, application-specific scheduling, though, has been shown to provide critical performance benefits for both time-constrained and non real-time activities [Anderson 93, Anderson et al. 92].
Reference: [Ungar & Smith 87] <author> Ungar, D. and Smith, R. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In Proceedings of OOPSLA '87, </booktitle> <pages> pages 227-241, </pages> <month> October </month> <year> 1987. </year> <note> Lisp and Symbolic Computation 4(3). </note> <author> [von Eicken et al. 92] von Eicken, T., Culler, D. E., Goldstein, S. C., and Schauser, K. E. </author> <title> Active Messages: A Mechanism for Integrated Communication and Computation. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 256-266, </pages> <month> May </month> <year> 1992. </year>
Reference: [Weise et al. 91] <author> Weise, D., Conybeare, R., Ruf, E., and Seligman, S. </author> <title> Automatic Online Partial Evaluation. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 165-191. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year> <note> LNCS 202. </note>
Reference: [Wheeler & Bershad 92] <author> Wheeler, B. and Bershad, B. N. </author> <title> Consistency Management for Virtually Indexed Caches. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <month> October </month> <year> 1992. </year>
Reference: [Yokote et al. 91] <author> Yokote, Y., Mitsuzawa, A., Fujinami, N., and Tokoro, M. </author> <title> Reflective Object Management in the Muse Operating System. </title> <booktitle> In Proceedings of the Second International Workshop on Object Orientation in Operating Systems, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: Reflective systems Several systems have used reflection to create adaptable systems. A reflective system is one that includes mechanisms to monitor and modify its own behavior as it executes. In the Apertos operating system <ref> [Yokote et al. 91] </ref>, for example, users customize the system's behavior by choosing among several reflective mechanisms for kernel services. Kiczales 12 et al. have studied general meta-object protocols, which are interfaces to languages and systems that enable users to customize and extend the system's behavior [Kiczales et al. 91].
Reference: [Young 89] <author> Young, M. W. </author> <title> Exporting a User Interface to Memory Management from a Communication-Oriented Operating System. </title> <type> Technical Report CMU-CS-89-202, </type> <institution> Carnegie Mellon University, </institution> <month> November </month> <year> 1989. </year>
Reference: [Yuhara et al. 94] <author> Yuhara, M., Bershad, B. N., Maeda, C., and Moss, J. E. B. </author> <title> Efficient Packet Demultiplexing for Multiple Endpoints and Large Messages. </title> <booktitle> In Proceedings of the 1994 Winter USENIX Conference, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: A packet filter is run against each incoming network packet to demultiplex data packets to higher level protocol software. With careful design, the packet filter is able to support protocol processing for a large number of applications <ref> [Yuhara et al. 94] </ref>. SPIN generalizes on the notion of the packet filter, enabling richer, more complex services to be safely installed into the kernel.
Reference: [Zahorjan & McCann 90] <author> Zahorjan, J. and McCann, C. </author> <title> Processor Scheduling in Shared Memory Multiprocessors. </title> <booktitle> In Proceedings of the ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 214-225, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Fast communication is required to transmit messages from one processor to another. Appropriate scheduling and synchronization support can ensure that all threads in a multicomputer program run at the same time to avoid unnecessary stalls due to scheduling anomalies <ref> [Zahorjan & McCann 90, Ousterhout 84] </ref>. Application-specific virtual memory services can ensure that unanticipated page faults do not delay processors involved in a cooperative computation, thereby delaying other processors.
References-found: 67

