URL: http://www.cs.nmsu.edu/lldap/download/jicslp/zoltan.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/jicslp/zolt.html
Root-URL: http://www.cs.nmsu.edu
Email: fzs,fjh,conway,bromage,trd,dgj,petdr,petsg@cs.mu.oz.au  
Phone: Phone: +61 3 9287 9160 Fax: +61 3 9348  
Title: Status of the Mercury system  
Author: Zoltan Somogyi, Fergus Henderson, Thomas Conway, Andrew Bromage, Tyson Dowd, David Jeffery, Peter Ross, Peter Schachte and Simon Taylor 
Keyword: Mercury, types, modes, determinism, functions, higher-order, implementation, optimizations, portability, performance.  
Address: Parkville, 3052 Victoria, Australia  1184  
Affiliation: Department of Computer Science, University of Melbourne  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> H. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18 </volume> <pages> 807-820, </pages> <year> 1988. </year>
Reference-contexts: The current Mercury implementation can run without a garbage collector, or it can use Hans Boehm's conservative garbage collector <ref> [1] </ref>; we do not yet have a garbage collector native to Mercury. The figure in table 1 significantly understates the performance of Mercury when using the Boehm collector.
Reference: [2] <author> T. Conway, F. Henderson, and Z. Somogyi. </author> <title> Code generation for Mercury. </title> <booktitle> In Proceedings of the Twelfth International Conference on Logic Programming, </booktitle> <pages> pages 242-256, </pages> <address> Portland, Oregon, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: For more details on the language, please see our previous papers <ref> [2, 6, 8] </ref> or the language reference manual [4]. 3. What is new in the Mercury system We have continued our development of the language after version 0.5 of the Mercury system was released in February 1996.
Reference: [3] <author> S. Graham, P. Kessler, and M. McKusick. </author> <title> Gprof: a call graph execution profiler. </title> <booktitle> In Proceedings of the 1982 SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 120-126, </pages> <address> Boston, Massacusetts, </address> <month> June </month> <year> 1982. </year> <booktitle> 12 1996 Compulog Net Meeting on Parallelism and Implementation Technology </booktitle>
Reference-contexts: The Mercury system already has a profiler [5] which produces output very similar to the output of gprof <ref> [3] </ref>. This profiler gives feedback to programmers not only about which predicates and functions the program is spending most of its time in, but also where these predicates and functions are called from.
Reference: [4] <author> F. Henderson, T. Conway, Z. Somogyi, and D. Jeffery. </author> <title> The Mercury language reference manual. </title> <type> Technical Report 96/10, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: The semantics of Mercury programs is discussed in some detail in the Semantics chapter of the Mercury language reference manual <ref> [4] </ref>. The language design makes it significantly easier to create efficient implementations whose operational semantics is sound with respect to this declarative semantics. <p> For more details on the language, please see our previous papers [2, 6, 8] or the language reference manual <ref> [4] </ref>. 3. What is new in the Mercury system We have continued our development of the language after version 0.5 of the Mercury system was released in February 1996.
Reference: [5] <author> F. Henderson, T. Conway, Z. Somogyi, and P. Ross. </author> <title> The Mercury user's guide. </title> <type> Technical Report 96/11, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: The Mercury system already has a profiler <ref> [5] </ref> which produces output very similar to the output of gprof [3]. This profiler gives feedback to programmers not only about which predicates and functions the program is spending most of its time in, but also where these predicates and functions are called from.
Reference: [6] <author> F. Henderson, Z. Somogyi, and T. Conway. </author> <title> Determinism analysis in the Mercury compiler. </title> <booktitle> In Proceedings of the Nineteenth Australasian Computer Science Conference, </booktitle> <pages> pages 337-346, </pages> <address> Melbourne, Victoria, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: Note that different modes of a predicate or function will in general be reordered differently. In fact, the compiler treats each mode of a predicate independently after mode analysis, even generating separate code for each mode. * Mercury has a strong determinism system <ref> [6] </ref>. For each mode of each predicate or function, the programmer should declare whether it will succeed exactly once (det), at most once (semidet), at least once (multi) or an arbitrary number of times (nondet). <p> map (Pred, Xs, Ys). (It would be possible to add other modes and determinisms for map as well.) The next two calls to map demonstrate the use of currying and lambda expressions: map (append ([1]), [[2,3], [4,5]], A) map ((pred (Old::in, New::out) is det :- New is Old + 1), <ref> [6, 7] </ref>, B) 4 1996 Compulog Net Meeting on Parallelism and Implementation Technology * Mercury has a modern module system. Programs consist of one or more modules. <p> For more details on the language, please see our previous papers <ref> [2, 6, 8] </ref> or the language reference manual [4]. 3. What is new in the Mercury system We have continued our development of the language after version 0.5 of the Mercury system was released in February 1996.
Reference: [7] <author> J. F. Nilsson. </author> <title> On the compilation of a domain-based Prolog. </title> <booktitle> In Proceedings of the Ninth IFIP Congress, </booktitle> <pages> pages 293-298, </pages> <address> Paris, France, </address> <year> 1983. </year>
Reference-contexts: map (Pred, Xs, Ys). (It would be possible to add other modes and determinisms for map as well.) The next two calls to map demonstrate the use of currying and lambda expressions: map (append ([1]), [[2,3], [4,5]], A) map ((pred (Old::in, New::out) is det :- New is Old + 1), <ref> [6, 7] </ref>, B) 4 1996 Compulog Net Meeting on Parallelism and Implementation Technology * Mercury has a modern module system. Programs consist of one or more modules. <p> We are also working a new execution model based on the translation of Mercury to imperative languages in a much more natural manner (e.g. with a one-to-one correspondence between Mercury variables and imperative language variables.) This model resembles the work of Nilsson <ref> [7] </ref>. Parallelism We are investigating the stream AND-parallel implementation of Mercury. This involves generalizing the mode system as well as the modification of the execution algorithm and runtime system. Constraints We have already linked the CLP (R) constraint solver to Mercury via the Mercury foreign function interface.
Reference: [8] <author> Z. Somogyi, F. Henderson, and T. Conway. </author> <title> The execution algorithm of Mercury, an efficient purely declarative logic programming language. </title> <journal> Journal of Logic Programming, </journal> <note> to appear. </note>
Reference-contexts: For more details on the language, please see our previous papers <ref> [2, 6, 8] </ref> or the language reference manual [4]. 3. What is new in the Mercury system We have continued our development of the language after version 0.5 of the Mercury system was released in February 1996.
Reference: [9] <author> A. Taylor. </author> <title> LIPS on a MIPS: results from a Prolog compiler for a RISC. </title> <booktitle> In Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <pages> pages 174-185, </pages> <address> Jerusalem, Israel, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Some Prolog implementations (e.g. Aquarius [10], Parma <ref> [9] </ref>) perform extensive analysis of the program in order to obtain some of these benefits.
Reference: [10] <author> P. Van Roy and A. Despain. </author> <title> High-performance logic programming with the Aquarius Prolog compiler. </title> <journal> IEEE Computer, </journal> <volume> 25(1) </volume> <pages> 54-68, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: The code we emit for each mode is small because it need not contain any code either to test the initial state of instantiation of any argument or to handle any initial state of instantiation other than the one given in the mode declaration. Some Prolog implementations (e.g. Aquarius <ref> [10] </ref>, Parma [9]) perform extensive analysis of the program in order to obtain some of these benefits.
Reference: [11] <author> D. H. D. Warren. </author> <title> Higher-order extensions to Prolog: are they needed? In J. </title> <editor> E. Hayes, D. Michie, and Y.-H. Pao, editors, </editor> <booktitle> Machine Intelligence 10, </booktitle> <pages> pages 441-454. </pages> <publisher> Ellis Horwood, </publisher> <year> 1982. </year>
Reference-contexts: Mercury programs have a straightforward declarative semantics, which is the Clark completion of a transformed version of the program; the transformations required are the standard DCG transformation, module qualification, and transformations to convert programs containing higher-order terms into first-order programs <ref> [11] </ref> and typed programs into untyped programs. Alternatively, one could omit the last transformation and give a semantics directly in terms of a parametric polymorphic version of many-sorted logic, and/or omit the second last transformation and give a semantics directly in terms of a higher-order logic.
References-found: 11

