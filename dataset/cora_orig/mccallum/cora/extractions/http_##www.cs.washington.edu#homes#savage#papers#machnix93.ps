URL: http://www.cs.washington.edu/homes/savage/papers/machnix93.ps
Refering-URL: http://www.cs.washington.edu/homes/savage/
Root-URL: http://www.cs.washington.edu
Email: fsavage,hxtg@cs.cmu.edu  
Title: Real-Time Mach Timers: Exporting Time to the User  
Author: Stefan Savage and Hideyuki Tokuda 
Address: Pittsburgh, Pennsylvania 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: The current CMU Mach 3.0 microkernel exports simple timestamp and delay abstractions through host get time() and a timeout parameter to mach msg(). While this is sufficient for many purposes, it does not provide the precision or generality required for a variety of real-time applications. In this paper we describe extensions to CMU's Mach 3.0 which provide users with flexible time-based synchronization and timestamp services. Additionally, we will describe how timing and scheduling services are integrated to allow real-time applications to handle timing faults. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> Alpha Logic Technolgies. </editor> <title> STAT! System Timing Analysis Tool User Guide, </title> <year> 1992. </year>
Reference: [2] <author> T.E. Anderson, B. Bershad, E.D. Lazowska, and H.M. Levy. </author> <title> Scheduler Activations: Effective Kernel Support for the User-Level Mangement of Parallelism. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating System Principles, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: In addition to removing duplication of effort this will simplify machine independent support for particular timing functionality, such as BSD's relatively prime profiling timer [7]. Lastly, we are examining ways in which the timer mechanisms can be integrated with first class user level threads <ref> [6, 2, 3] </ref> to provide low overhead real-time threads. 8 Conclusion We have shown that there are three requirements for providing time services for real-time programs. These are, high accuracy time measurement, synchronization to these time sources, and integration with scheduling.
Reference: [3] <author> P. Barton-Davis, D. McNamee, R. Vaswani, and E.D. Lazowska. </author> <title> Adding Scheduler Activations to Mach 3.0. </title> <type> Technical Report 92-08-03, </type> <institution> University of Washington, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: In addition to removing duplication of effort this will simplify machine independent support for particular timing functionality, such as BSD's relatively prime profiling timer [7]. Lastly, we are examining ways in which the timer mechanisms can be integrated with first class user level threads <ref> [6, 2, 3] </ref> to provide low overhead real-time threads. 8 Conclusion We have shown that there are three requirements for providing time services for real-time programs. These are, high accuracy time measurement, synchronization to these time sources, and integration with scheduling.
Reference: [4] <author> V. Blazquez, L. Redono, and J.L. Freniche. </author> <title> Experiences with Delay Until for Avionics Computers. </title> <journal> Ada Letters, </journal> <volume> 12(1) </volume> <pages> 65-72, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: The caller specifies a time to wakeup and indicates whether that time is relative or absolute. Relative times are less useful for real-time software since program-wide accuracy may be skewed by preemption <ref> [4] </ref>. For example, a thread which samples data and then sleeps for five seconds may be preempted between sampling and sleeping, causing a steadily increasing skew from the correct time base.
Reference: [5] <author> H. Custer. </author> <title> Inside Windows NT. </title> <publisher> Microsoft Press, </publisher> <year> 1992. </year>
Reference-contexts: Real-Time Mach's clocks and timers provide a superset of POSIX functionality, including the ability to change clock granularity dynamically and to effect scheduling decisions via the timing fault mechanism. Otherwise the interfaces are very similar. Microsoft's NT executive provides timer objects for the purposes of time based synchronization <ref> [5, 11] </ref>. In addition to blocking time synchronization, timer objects may be associated with APC's (Asynchronous Procedure Calls) which allow the kernel to asynchronously set a thread's context to execute a particular function when a timer expires.
Reference: [6] <author> R. Govindan and D.P. Anderson. </author> <title> Scheduling and IPC Mechanisms for Continuous Media. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating System Principles, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: Real-time applications may be loosely defined as applications in which the relationship between execution behavior and the passage of time directly impacts program correctness. Included in this class of software are applications for factory automation, military command and control, robotics, and the rapidly growning field of continuous media <ref> [6] </ref>. Timestamps, exact delays, periodic signals and timeouts are among the services which may be demanded by these types of applications. There are several requirements for providing this kind of support. First, it is important to be able to measure time with a high degree of precision. <p> In addition to removing duplication of effort this will simplify machine independent support for particular timing functionality, such as BSD's relatively prime profiling timer [7]. Lastly, we are examining ways in which the timer mechanisms can be integrated with first class user level threads <ref> [6, 2, 3] </ref> to provide low overhead real-time threads. 8 Conclusion We have shown that there are three requirements for providing time services for real-time programs. These are, high accuracy time measurement, synchronization to these time sources, and integration with scheduling.
Reference: [7] <author> S. Leffler, M. McKusick, M. Karels, and J. Quarterman. </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Modern operating systems are expected to provide services to allow application programs to synchronize with the passage of time. The BSD UNIX interface includes gettimeofday (), sleep (), signal () and select () to provide this functionality <ref> [7] </ref>. Similarly, Mach 3.0 exports host get time () and a timeout parameter to mach msg ()[8]. While these timing services are sufficient for a broad range of general purpose applications, real-time applications frequently require greater precision and flexibility. <p> Additionally, we hope that all kernel timing, such as device timeouts and pc sampling, can be subsumed by this single mechanism. In addition to removing duplication of effort this will simplify machine independent support for particular timing functionality, such as BSD's relatively prime profiling timer <ref> [7] </ref>. Lastly, we are examining ways in which the timer mechanisms can be integrated with first class user level threads [6, 2, 3] to provide low overhead real-time threads. 8 Conclusion We have shown that there are three requirements for providing time services for real-time programs.
Reference: [8] <author> K. Loepere. </author> <title> Mach 3 Kernel Interfaces. </title> <institution> Open Software Foundation and Carnegie-Mellon University, </institution> <month> January </month> <year> 1992. </year>
Reference: [9] <author> K. Loepere. </author> <title> OSF Mach Draft Kernel Interfaces. </title> <institution> Open Software Foundation and Carnegie-Mellon University, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: Unlike our system however, NT does not provide the user with the ability to bind these objects to different clock devices. The OSF RI has designed and implemented a similar set of interfaces for their microkernel called "clocks" <ref> [10, 9] </ref>. The OSF interfaces export services for getting timestamps, setting clock resolution, exact delays, and setting alarm messages. Alarms which are found to have expired at interrupt time are copied to a special alarm queue.
Reference: [10] <author> K. Loepere. </author> <title> OSF Mach Draft Kernel Principles. </title> <institution> Open Software Foundation and Carnegie-Mellon University, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: Unlike our system however, NT does not provide the user with the ability to bind these objects to different clock devices. The OSF RI has designed and implemented a similar set of interfaces for their microkernel called "clocks" <ref> [10, 9] </ref>. The OSF interfaces export services for getting timestamps, setting clock resolution, exact delays, and setting alarm messages. Alarms which are found to have expired at interrupt time are copied to a special alarm queue.
Reference: [11] <author> Microsoft Corporation. </author> <title> Preliminary Windows NT Device Driver Kit, </title> <year> 1992. </year>
Reference-contexts: Real-Time Mach's clocks and timers provide a superset of POSIX functionality, including the ability to change clock granularity dynamically and to effect scheduling decisions via the timing fault mechanism. Otherwise the interfaces are very similar. Microsoft's NT executive provides timer objects for the purposes of time based synchronization <ref> [5, 11] </ref>. In addition to blocking time synchronization, timer objects may be associated with APC's (Asynchronous Procedure Calls) which allow the kernel to asynchronously set a thread's context to execute a particular function when a timer expires.
Reference: [12] <author> D. Mills. </author> <title> Experiments in Network Clock Synchronization. DARPA Network Working Group Report RFC-957, </title> <month> August </month> <year> 1985. </year>
Reference-contexts: Second, we encountered a problem with the lack of resolution stability in Mach 3.0's representation of the host time. In order to support synchronized time in a distributed environment while still preserving monotonicity <ref> [12] </ref>, Mach 3.0 provides the host adjust time () interface. This interface allows the host time to be skewed at resolutions under one scheduling clock tick. Consequently, the time between two scheduling clock ticks is not always measured as such.
Reference: [13] <institution> Realtime Extension for Portable Operating Systems. Proposed Standard IEEE P1003.4/D12, </institution> <month> February </month> <year> 1992. </year>
Reference: [14] <author> H. Tokuda and T. Nakajima. </author> <title> Evaluation of Real-Time Synchronization in Real-Time Mach. </title> <booktitle> In Proceedings of the USENIX Mach Symposium, </booktitle> <month> November </month> <year> 1991. </year>
Reference-contexts: Government. We have developed this necessary functionality in Real-Time Mach, an extension to CMU's Mach 3.0 which provides predictable scheduling and priority consistent synchronization <ref> [15, 14] </ref>. Time services are exported to the user in the form of two abstractions: clocks and timers. Timers are active objects which allow users to synchronize with time in a variety of ways.
Reference: [15] <author> H. Tokuda, T. Nakajima, and P. Rao. </author> <title> Real-Time Mach: Towards a Predictable Real-Time System. </title> <booktitle> In Proceedings of the USENIX Mach Workshop, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: Government. We have developed this necessary functionality in Real-Time Mach, an extension to CMU's Mach 3.0 which provides predictable scheduling and priority consistent synchronization <ref> [15, 14] </ref>. Time services are exported to the user in the form of two abstractions: clocks and timers. Timers are active objects which allow users to synchronize with time in a variety of ways. <p> This action is left to the user, although in practice the most frequent actions include a change of scheduling parameters, user notification, or for hard real-time programs, thread termination. To simplify programming we have added library support for deadline handling in the context of our rt thread package <ref> [15] </ref>.
Reference: [16] <author> G. Varghese and T. Lauck. </author> <title> Hashed and Hierarchical timing Wheels: Data Structures for the Efficient Implementation of a Timer Facility. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating System Principles, </booktitle> <month> November </month> <year> 1987. </year>
Reference-contexts: These numbers could be improved using tree-based or timing wheel algorithms <ref> [16] </ref>. The timer create () and timer terminate () are substantially slower than other primitives largely because they are involved and allocating memory and port structures. Additionally both of these operations are implemented using IPC while the rest of the timer operations are invoked directly through traps.
References-found: 16

