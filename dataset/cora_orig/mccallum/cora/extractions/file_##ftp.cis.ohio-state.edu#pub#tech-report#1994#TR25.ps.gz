URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1994/TR25.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: Skeletons and Techniques as a Normative Approach to Program Development in Logic-based Languages  
Author: Marc Kirschenbaum Spiro Michaylov Leon Sterling 
Date: May 13, 1994  
Pubnum: Technical Report OSU-CISRC-5/94-TR25  
Abstract: To help encourage the wide use of a variety of logic-based languages, we advocate the identification and use of systematic program construction methods. Our approach is to capture programming idioms in the form of skeletons, or basic control flows, and standard programming techniques for construction and manipulation of data structures. We argue that the approach, coming initially from Prolog and logic grammars, is equally applicable in the context of constraints, committed-choice and higher order constructs, and indeed logic-based languages in general. This paper introduces our generalized view of skeletons and techniques, gives examples of the breadth of their applicability, and explores positive consequences for program develop ment.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bansal and L. Sterling. </author> <title> Classifying Generate-and-Test Logic Programs. </title> <journal> International Journal of Parallel Processing, </journal> <volume> 8 </volume> <pages> 401-446, </pages> <year> 1989. </year>
Reference-contexts: By software analysis, we refer to issues such as (formal) correctness of programs and analysis of programs to allow better compiler optimizations, and the ability to exploit parallelism for example as in <ref> [1] </ref>. By software maintenance, we refer not only to low-level program changes, but also to broader `software evolution', where some parts of a software systems are re-designed, but most are re-used.
Reference: [2] <author> A. Bansal and L. Sterling. </author> <title> An Abstract Interpretation Scheme for Identifying Inherent Parallelism in Logic Programs. </title> <journal> New Generation Computing, </journal> <volume> 7: </volume> <pages> 273-324, </pages> <year> 1990. </year>
Reference: [3] <author> M. Bruynooghe and G. Janssens. </author> <title> An Instance of Abstract Interpretation Integrating Type and Mode Inferencing. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pp. 669-683, </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference: [4] <author> I. Foster and S. Taylor. Strand: </author> <title> New Concepts in Parallel Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: The terms that a meta-interpreter traverses, conjunctive goals, are dynamic. The following meta-interpreter for Flat Concurrent Prolog, taken from [15], essentially spawns a number of goal processes. A similar meta-interpreter for Strand is given in <ref> [4] </ref>. reduce (Program,true). % halt reduce (Program,(A,B)) :- % fork reduce (Program?,A?), reduce (Program?,B?). reduce (Program,Goal) :- % reduce Goal "= true,Goal "= (A,B), clause (Goal?,Program?,Body) | reduce (Program?,Body?). clause (Goal,[C|Cs],B) :- % a clause new_copy (C?,(H,G,B)), Goal = H,G | true. clause (Goal,[C|Cs],B) :- % the rest clause (Goal,Cs?,B) |
Reference: [5] <author> Marc Kirschenbaum, Leon Sterling, and Ashish Jain. </author> <title> Relating logic programs via program maps. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <year> 1993. </year>
Reference-contexts: We discuss basic programming idioms that have emerged from programming experience, and which we have previously categorized for Prolog into skeletons or basic control flows and techniques, which implement programming segments for construction and manipulation of data structures <ref> [16, 5] </ref>. In this paper, we point out that the language of skeletons and techniques, developed for Prolog and implicit in discussion of logic grammars [13], is applicable to logic-based languages in general. <p> There is a role for investigating the theoretical underpinnings of skeletons and techniques. One approach we advocate is program maps as introduced in <ref> [5] </ref> and continued in [6]. This paper is concerned with the development of clear, effective programming practice for logic programming languages. 2 Skeletons In a logic-based language, a skeleton is a piece of code that describes how a term from the language is to be "traversed".
Reference: [6] <author> M. Kirschenbaum, A. Jain and L. Sterling. </author> <title> Relative Correctness of Prolog Programs. </title> <booktitle> Proc. Third Int'l. Symp. on Artificial Intelligence and Mathematics, </booktitle> <address> Florida, </address> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: There is a role for investigating the theoretical underpinnings of skeletons and techniques. One approach we advocate is program maps as introduced in [5] and continued in <ref> [6] </ref>. This paper is concerned with the development of clear, effective programming practice for logic programming languages. 2 Skeletons In a logic-based language, a skeleton is a piece of code that describes how a term from the language is to be "traversed". <p> This topic is addressed in detail in <ref> [6] </ref>. For example, consider the following program which computes the number of nodes and the depth of a ground binary tree.
Reference: [7] <author> A. Lakhotia. </author> <title> Incorporating `Programming Techniques' into Prolog Programs. </title> <booktitle> Proc. North American Conference on Logic Programming, </booktitle> <editor> (eds. Lusk and Overbeek), </editor> <booktitle> pp. </booktitle> <pages> 426-440, </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Facilitating program modification by replaying operations that have not changed is certainly viable. A prototype system was demonstrated by Komorowski at a logic programming workshop in 1991. His system was based on a poorer version of techniques proposed by Lakhotia <ref> [7] </ref>. The broadest issue of program maintenance is the status of skeletons and techniques as reusable software components. Indeed in a literal sense, skeletons are reused. The same simple Prolog meta-interpreter has been the starting point for expert system shells and a program tracer.
Reference: [8] <author> C.S. Mellish. </author> <title> Some Global Optimizations for a Prolog Compiler. </title> <journal> Journal of Logic Programming, </journal> <volume> 2 </volume> <pages> 43-65, </pages> <year> 1985. </year>
Reference: [9] <author> Spiro Michaylov. </author> <title> Repeated redundant inequalities in constraint logic programming. </title> <type> Technical Report forthcoming, </type> <institution> Department of Computer and Information Science, The Ohio State University, </institution> <year> 1994. </year>
Reference-contexts: Thus, the knowledge that a program component was constructed using a particular skeleton and a particular technique can be used to trigger the use of a particular optimization. A number of such optimizations have already been described for constraint logic programming. In <ref> [9] </ref>, it is shown how it is possible to avoid deciding large numbers of linear arithmetic inequalities in an important class of recursive procedures utilizing a constraint iteration technique that imposes an early termination check.
Reference: [10] <author> Spiro Michaylov. </author> <title> Skeletons and techniques for the systematic development of constraint logic programs. </title> <type> Technical Report forthcoming, </type> <institution> Department of Computer and Information Science, The Ohio State University, </institution> <year> 1994. </year>
Reference-contexts: It is influenced by the syntax of the language, 2 its computational primitives (unification, constraint satisfaction, etc.) and its control features. In the following discussion, we will frequently make a distinction (introduced in <ref> [10] </ref>) between terms of a language on the basis of their being "structural" or "non-structural". <p> Next we consider a case of threading arithmetic constraints over a structural skeleton. The skeleton circuit/1 is given in the previous section. By threading arithmetic constraints over the data structure we get a simple program for modeling resistive DC circuits. The threading technique is discussed in greater detail in <ref> [10] </ref>. circuit (res (R), V, I) :- V = I * R. circuit (ser (C1, C2), V, I) :- V = V1 + V2, I = I1, I = I2, circuit (C1, V1, I1), circuit (C2, V2, I2). circuit (par (C1, C2), V, I) :- V = V1, V = V2,
Reference: [11] <author> Spiro Michaylov and Bill Pippin. </author> <title> Optimizing compilation of linear constraints in a class of constraint logic programs. </title> <type> Technical Report forthcoming, </type> <institution> Department of Computer and Information Science, The Ohio State University, </institution> <year> 1994. </year>
Reference-contexts: For certain query patterns this termination check is inexpensive but useful, while for others it is expensive but in all but one iteration useless. The optimization can render usable programs that were previously considered totally impractical. In <ref> [11] </ref>, it is shown that some linear constraint iteration techniques for some basic skeletons allow a compiler to replace most linear equation solving with ground computation, again resulting in major performance improvements.
Reference: [12] <author> Dale A. Miller and Gopalan Nadathur. </author> <title> Higher-order logic programming. </title> <editor> In Ehud Shapiro, editor, </editor> <booktitle> Proceedings of the Third International Conference on Logic Programming, </booktitle> <pages> pages 448-462, </pages> <address> London, July 1986. </address> <publisher> Springer Verlag LNCS 225. </publisher>
Reference-contexts: As we consider a wide variety of logic-based languages, we see that the distinction between structural and non-structural terms is often not clear. Conjunctive goals traversed by the meta-interpreter are not as clearly structural as a binary tree. For a further example, in Prolog <ref> [12] </ref> we have the usual terms of Prolog (although with a strong type system and unusual applicative syntax) but in addition we have abstraction over a special kind of variable. Traversing such terms introduces a complication when the abstraction case is encountered in the inductive definition of a data structure.
Reference: [13] <author> F.C.N. Pereira and S.M. Shieber. </author> <title> Prolog and Natural language Analysis. </title> <publisher> CSLI Lecture Notes No. 10, CSLI, </publisher> <year> 1987. </year>
Reference-contexts: In this paper, we point out that the language of skeletons and techniques, developed for Prolog and implicit in discussion of logic grammars <ref> [13] </ref>, is applicable to logic-based languages in general. Sections 2 and 3 explain what we mean by skeletons and techniques and give examples from a range of languages including Prolog, CLP (R), Flat Concurrent Prolog and Prolog.
Reference: [14] <author> Frank Pfenning and Conal Elliott. </author> <title> Higher-order abstract syntax. </title> <booktitle> In Proceedings of the SIG-PLAN '88 Symposium on Language Design and Implementation, Atlanta, Georgia, </booktitle> <pages> pages 199-208. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: However, the idiom for traversing such structures is well-known to Prolog programmers. As an example, we consider a skeleton where the data structure defined is the higher-order abstract syntax for expressions, with Prolog being used in its natural application domain as a 5 meta-language. For an overview, see <ref> [14] </ref>. Object language variables are represented by -bound variables in the meta language, and the apply and lambda functors of the meta language represent object language application and abstraction respectively.
Reference: [15] <author> S. Safra and E.Y. Shapiro. </author> <title> Meta Interpreters for Real. in Concurrent Prolog, Collected Papers (E. Shapiro, </title> <publisher> ed.), </publisher> <pages> pp. 166-179, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year> <month> 13 </month>
Reference-contexts: Another example of a skeleton that is useful both for Prolog and parallel languages is a meta-interpreter. The terms that a meta-interpreter traverses, conjunctive goals, are dynamic. The following meta-interpreter for Flat Concurrent Prolog, taken from <ref> [15] </ref>, essentially spawns a number of goal processes. <p> The difference-list technique is also useful for committed choice languages. A related technique is the short circuit technique which can be used to synchronize goals and detect termination. We demonstrate the technique on the reduce clauses of the meta-interpreter given earlier for Flat Concurrent Prolog. Again our account follows <ref> [15] </ref>. Many other techniques, including aborting computations and deadlock detection, are given in Safra and Shapiro's paper. reduce (Program,true,Chain-Chain). % halt reduce (Program,(A,B),Left-Right) :- % fork reduce (Program?,A?,Left-Middle), reduce (Program?,B?,Middle-Right). reduce (Program,Goal,Left-Right) :- % reduce Goal "= true,Goal "= (A,B), clause (Goal?,Program?,Body) | reduce (Program?,Body?,Left-Right). <p> The meta-interpreter for Flat Concurrent Prolog given in Section 2 is amenable to partial evaluation, as is advocated in <ref> [15] </ref>. Partial evaluation as a means of easy incorporation of techniques is also applicable to rule-based interpreters as presented in [17]. 5 Discussion and Conclusions We begin with an observation about the maturation of programming languages.
Reference: [16] <author> Leon Sterling and Marc Kirschenbaum. </author> <title> Applying techniques to skeletons. </title> <editor> In J.-M. Jacquet, editor, </editor> <booktitle> Constructing Logic Programs, </booktitle> <pages> pages 127-140. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: We discuss basic programming idioms that have emerged from programming experience, and which we have previously categorized for Prolog into skeletons or basic control flows and techniques, which implement programming segments for construction and manipulation of data structures <ref> [16, 5] </ref>. In this paper, we point out that the language of skeletons and techniques, developed for Prolog and implicit in discussion of logic grammars [13], is applicable to logic-based languages in general. <p> We present two techniques for producing the same effect, namely collecting information gained during traversal into a list. The techniques are illustrated with respect to the inorder traversal skeleton for a binary tree tree io. The first, called the build technique <ref> [16] </ref>, adds a single argument, and relates the recursive results to the desired result with a call to append. tree_io (leaf, []). tree_io (node (K,L,R), LL) :- tree_io (L, L1), tree_io (R, L2), append (L1, [K|L2], LL).
Reference: [17] <author> Leon Sterling and Randall Beer. </author> <title> Meta-interpreters for expert systems. </title> <journal> Journal of Logic Programming, </journal> <volume> 6 </volume> <pages> 163-178, </pages> <year> 1989. </year>
Reference-contexts: The meta-interpreter for Flat Concurrent Prolog given in Section 2 is amenable to partial evaluation, as is advocated in [15]. Partial evaluation as a means of easy incorporation of techniques is also applicable to rule-based interpreters as presented in <ref> [17] </ref>. 5 Discussion and Conclusions We begin with an observation about the maturation of programming languages. When a radically different programming language is first introduced, there is an exciting period of experimentation. Some people find clever ways of programming interesting examples.
Reference: [18] <author> Leon Sterling and Ehud Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <address> 2 nd edition, </address> <year> 1994. </year>
Reference-contexts: That requires an understanding of the technique and its relation to the skeleton. Another way of removing the explicit call to append, accomplishing a more efficient program, is to use the difference-list technique <ref> [18] </ref>. The difference-list technique is also useful for committed choice languages. A related technique is the short circuit technique which can be used to synchronize goals and detect termination. We demonstrate the technique on the reduce clauses of the meta-interpreter given earlier for Flat Concurrent Prolog. <p> The broadest issue of program maintenance is the status of skeletons and techniques as reusable software components. Indeed in a literal sense, skeletons are reused. The same simple Prolog meta-interpreter has been the starting point for expert system shells and a program tracer. The grammar from Chapter 24 of <ref> [18] </ref> was the starting point of software testing programs. It would be desirable to easily transfer techniques from one skeleton to another. For example, a prototype system for instrumenting data coverage testing for Pascal was developed at Case Western Reserve University. <p> The two most notable examples are experience of Arun Lakhotia building a graphical debugger for Prolog and the two-layer interpreter for success and failure developed by Umit Yal~cinalp and applied for explanation [22] and uncertainty reasoning [23], which appears in the second edition of "The Art of Prolog" <ref> [18] </ref>. Acknowledgements The authors wish to thank Frank Pfenning for corrections to the Prolog examples and Ashish Jain for useful discussions about skeletons and techniques. This work was partially supported by NSF grant CCR-9303484. 12
Reference: [19] <author> L. Sterling and Chok Sitt Sen. </author> <title> A Tool to Support Stepwise Enhancement in Prolog. </title> <booktitle> Proc. Workshop on Logic programming Environments, </booktitle> <address> Vancouver, </address> <month> October, </month> <year> 1993. </year>
Reference-contexts: This nontrivial programming task would almost certainly not have been accomplished without the structuring. 4.3 Programming Tools An environment supporting Prolog program development using skeletons, techniques and composition has been designed, and a prototype implemented <ref> [19] </ref>. The environment allows the application of four techniques to skeletons calculate, build, accumulate-calculate and accumulate-build. Seven skeletons are pre-defined with the environment, and the user can add her own. Limited error checking has been incorporated. The prototype currently facilitates construction of programs concerned with recursive data structure traversal.
Reference: [20] <author> P. Van Roy and A.M. Despain. </author> <title> High-Performance Logic programming with the Aquarius Prolog Compiler. </title> <journal> IEEE Computer, </journal> <volume> 25 </volume> <pages> 54-68, </pages> <month> Jan. </month> <year> 1992. </year>
Reference: [21] <author> R. Warren, M. Hermenegildo, and S.K. Debray. </author> <title> On the Practicality of Global Flow Analysis of Logic Programs. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pp. 684-699, </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference: [22] <author> L. U. Yal~cinalp and L.S. Sterling. </author> <title> Building Embedded Languages and Expert System Shells in Prolog. </title> <booktitle> In Proc. Tools for AI, </booktitle> <pages> pp. 147-158, </pages> <address> Washington, DC, </address> <month> November, </month> <year> 1990. </year>
Reference-contexts: The two most notable examples are experience of Arun Lakhotia building a graphical debugger for Prolog and the two-layer interpreter for success and failure developed by Umit Yal~cinalp and applied for explanation <ref> [22] </ref> and uncertainty reasoning [23], which appears in the second edition of "The Art of Prolog" [18]. Acknowledgements The authors wish to thank Frank Pfenning for corrections to the Prolog examples and Ashish Jain for useful discussions about skeletons and techniques. This work was partially supported by NSF grant CCR-9303484. 12
Reference: [23] <author> L. U. Yal~cinalp and L.S. Sterling. </author> <title> Uncertainty Reasoning in Prolog with Layered Meta-Interpreters. </title> <booktitle> In Proc. 7th Conference on Artificial Intelligence Applications, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 398-402, </pages> <month> February, </month> <year> 1991. </year> <month> 14 </month>
Reference-contexts: The two most notable examples are experience of Arun Lakhotia building a graphical debugger for Prolog and the two-layer interpreter for success and failure developed by Umit Yal~cinalp and applied for explanation [22] and uncertainty reasoning <ref> [23] </ref>, which appears in the second edition of "The Art of Prolog" [18]. Acknowledgements The authors wish to thank Frank Pfenning for corrections to the Prolog examples and Ashish Jain for useful discussions about skeletons and techniques. This work was partially supported by NSF grant CCR-9303484. 12
References-found: 23

