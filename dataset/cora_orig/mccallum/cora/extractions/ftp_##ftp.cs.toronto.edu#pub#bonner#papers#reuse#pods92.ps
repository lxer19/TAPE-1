URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/reuse/pods92.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  
Title: The Complexity of Reusing and Modifying Rulebases  
Author: Anthony J. Bonner 
Address: Toronto, Ontario M5S 1A4 Canada  
Affiliation: University of Toronto Department of Computer Science  
Abstract: This paper develops a method for reusing and modifying deductive databases. Such methods are needed when new rulebased applications differ only slightly from existing ones or when an application is to be incrementally updated. In order to facilitate reuse, we extend deductive databases by the concept of predicate substitution. In this way, during query evaluation, not only variables, but also predicates can be substituted. This paper continues our earlier work on predicate substitution in two directions: (i) We extend the concept to a wider class of rulebase modifications, and (ii) we establish tight bounds on the data complexity of Datalog augmented with substitution, showing it to be EXPTIME-complete. Predicate substitution thus increases the power of Datalog to express database queries. The paper presents a proof theory and model theory for the language, including a fixpoint semantics. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K.R. Apt and M.H. Van Emden. </author> <title> Contributions to the Theory of Logic Programming. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <year> 1982. </year>
Reference-contexts: We refer 13 the interested reader to [3] and [2] for more detailed developments. 6.1 Sketch of the Fixpoint Semantics In the tradition of logic-programming <ref> [9, 1] </ref>, we define a "T-operator" that can be applied to a rulebase in a bottom-up fashion to generate a minimal model (or least fixpoint). In Horn logic, the T-operator takes a database as input and returns another database as output.
Reference: [2] <author> A.J. Bonner. </author> <title> Hypothetical Reasoning in Deductive Databases. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Rutgers University, </institution> <address> New Brunswick, NJ 08903, USA, </address> <month> October </month> <year> 1991. </year> <note> Published as Rutgers Technical Report DCS-TR-283. </note>
Reference-contexts: Again, these rules are generated automatically. 2 The above example is simple in that there is only one derived predicate and no recursion. The next two examples show how substitution operates in more complex situations. For more examples, see [3] and <ref> [2] </ref>. Example 5. Consider the following rulebase, where C and D are base predicates: A (x) C (x); B (x): Notice that the predicate A is defined not just in terms of base predicates, but also in terms of a defined predicate B. <p> That is, all models are built from a fixed, finite set of predicate and constant symbols. Besides providing a convenient device for establishing an upper complexity bound, a model theory for predicate substitution needs to be developed anyway, to complete the logical development of predicate substitution. In <ref> [3, 2] </ref>, a model theory was developed for "basic" substitution, i.e., for the case in which a predicate may only substitute for predicates of equal arity. In this section, we extend that theory to the general case, in which a predicate can substitute for predicates of different arity. <p> Because of space limitations, however, we present the model theory with a minimum of discussion, and with no proofs, providing an example to illustrate the theory 12 in the general case. We refer the interested reader to [3] and <ref> [2] </ref> for more detailed developments. 5.1 the Model Theory This section outlines the model theory for full predicate substitution, i.e., for the case in which a predicate may substitute for predicates of different arity. In this theory, a model is a Horn rulebase without substitution. <p> The following definition formalizes this idea. In this definition, R fl is the rulebase specified by Definition 3. It provides Horn rules defining every predicate with substitution fi. An extensive discussion of this definition may be found in <ref> [2] </ref>. Definition 6 (Models) Let R be a set of Horn rules, let ff be an atomic formula, and let fi 1 :::fi n be predicates with substitution. <p> Then S; DB j= fi iff R; DB j= fi for every model R of S. Proofs of the following two theorems are given in <ref> [2] </ref>. Theorem 4 (Soundness) Suppose fi is a predicate with substitution, S is a Horn rulebase with substitution, and DB is a database. If S; DB ` fi then S; DB j= fi. <p> Because of space limitations, however, we present the fixpoint theory with a minimum of discussion, and with no proofs, providing an example to illustrate the theory in the general case. We refer 13 the interested reader to [3] and <ref> [2] </ref> for more detailed developments. 6.1 Sketch of the Fixpoint Semantics In the tradition of logic-programming [9, 1], we define a "T-operator" that can be applied to a rulebase in a bottom-up fashion to generate a minimal model (or least fixpoint). <p> We now state the basic results about Toperators without proof. The main idea is to prove that the operator T S is monotonic and continuous, so that the Tarski fixpoint theorem can be invoked [8]. Detailed proofs of these results are presented in <ref> [2] </ref>. Lemma 8 T S is monotonic: If R 1 R 2 then T S (R 1 ) T S (R 2 ). Corollary 9 The operator T S has a least fixpoint lfp (T S ).
Reference: [3] <author> A.J. Bonner and T. Imielinski. </author> <title> The Reuse and Modification of Rulebases by Predicate Substitution. </title> <booktitle> In Proceedings of the International Conference on Extending Database Technology (EDBT), </booktitle> <pages> pages 437-451, </pages> <address> Venice, Italy, </address> <month> March 26-30 </month> <year> 1990. </year> <note> Springer-Verlag. Published as volume 416 of Lecture Notes in Computer Science. </note>
Reference-contexts: Rulebases defined in this way can themselves be reused and modified, so that the process of constructing rulebases is closed under predicate substitution. In an earlier paper, we developed a preliminary version of this logic and established a lower bound of NP on its data complexity <ref> [3] </ref>. In the present paper, we continue this development in two ways: (i) we extend the logic to include a wider class of rulebase modifications, and (ii) we establish tight bounds on the data complexity of both the preliminary and extended logics. <p> To achieve this, predicate substitution modifies programs before reusing them. We present a novel semantics reflecting this capability. 1.1 Extending the Logic Our earlier work on predicate substitution addressed only a limited class of rulebase modifications <ref> [3] </ref>. In particular, it required that a predicate substitute only for predicates of equal arity. <p> Hence, it can be argued that in going from Datalog to Datalog-with-substitution, we achieve an upgrade similar to that in going from relational algebra to Datalog. By combining recursion and substitution, it is possible to reuse and modify rule sets infinitely many times. In <ref> [3] </ref>, we used this idea to prove a qualified theorem: A 3 finite set of rules with substitution can specify an infinite set of rules without substitution, assuming that P 6= NP. In the present paper, we eliminate the qualification and show that the theorem is unequivocally true. <p> The expression [P=Q](x; y) is called a predicate substitution, or simply a substitution. For clarity, when P and Q have equal arity, we write [P=Q] instead of [P=Q](). Expressions of the form [P=Q] are called basic predicate substitutions. Basic substitution was introduced in <ref> [3] </ref>. The rest of this section generalizes basic substitution so that a predicate can substitute for predicates of different arity. In the expression [P=Q](y 1 :::y k ), the variables y 1 :::y k denote the extra arguments of Q that do not appear in P . <p> Again, these rules are generated automatically. 2 The above example is simple in that there is only one derived predicate and no recursion. The next two examples show how substitution operates in more complex situations. For more examples, see <ref> [3] </ref> and [2]. Example 5. Consider the following rulebase, where C and D are base predicates: A (x) C (x); B (x): Notice that the predicate A is defined not just in terms of base predicates, but also in terms of a defined predicate B. <p> Since the three rules above are to be treated classically, we can combine them to give the following inferences: A (x; y) Q (x; y); D (x): 2 The above examples illustrate the idea of predicate substitution. The following definition makes the idea precise, generalizing the definition given in <ref> [3] </ref>. Definition 3 Let S be a Horn rulebase with substitution. Then S fl is the set of rules with substitution constructed from S as follows: 3 3 To be precise, S fl is the smallest set of rules with substitution closed under these operations. 1. <p> That is, all models are built from a fixed, finite set of predicate and constant symbols. Besides providing a convenient device for establishing an upper complexity bound, a model theory for predicate substitution needs to be developed anyway, to complete the logical development of predicate substitution. In <ref> [3, 2] </ref>, a model theory was developed for "basic" substitution, i.e., for the case in which a predicate may only substitute for predicates of equal arity. In this section, we extend that theory to the general case, in which a predicate can substitute for predicates of different arity. <p> Because of space limitations, however, we present the model theory with a minimum of discussion, and with no proofs, providing an example to illustrate the theory 12 in the general case. We refer the interested reader to <ref> [3] </ref> and [2] for more detailed developments. 5.1 the Model Theory This section outlines the model theory for full predicate substitution, i.e., for the case in which a predicate may substitute for predicates of different arity. In this theory, a model is a Horn rulebase without substitution. <p> Besides providing a convenient device for establishing an upper complexity bound, a fixpoint theory for predicate substitution needs to be developed anyway. Such a theory, if properly developed, is an essential part of our goal of developing a logic programming language for reusing and modifying rulebases. In <ref> [3] </ref>, a fixpoint theory was introduced for "basic" predicate substitution, i.e., for the case in which a predicate may only substitute for predicates of equal arity. In this section, we extend that theory to the general case, in which a predicate can substitute for predicates of different arity. <p> Because of space limitations, however, we present the fixpoint theory with a minimum of discussion, and with no proofs, providing an example to illustrate the theory in the general case. We refer 13 the interested reader to <ref> [3] </ref> and [2] for more detailed developments. 6.1 Sketch of the Fixpoint Semantics In the tradition of logic-programming [9, 1], we define a "T-operator" that can be applied to a rulebase in a bottom-up fashion to generate a minimal model (or least fixpoint).
Reference: [4] <author> A.K. Chandra, D. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the ACM, </journal> <volume> 28 </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: We show that this mechanism runs in exponential time (exponential in the size of the database). To prove that EXPTIME is also a lower bound, we use predicate substitution to encode the computations of alternating PSPACE machines (APSPACE machines). The lower bound then follows, since APSPACE = EXPTIME <ref> [4] </ref>. Because the encoding is rather unusual, we briefly describe it here. There are three stages. First, we represent the initial configuration of the machine as a database predicate, in a fairly standard way. <p> Corollary 3 The data complexity of Datalog rulebases augmented with full predicate substitution is EXPTIME-hard. To prove Theorem 2, we use Datalog with basic substitution to encode the computations of alternating PSPACE machines (APSPACE machines). The EXP-TIME result follows since APSPACE = EXPTIME <ref> [4] </ref>. For clarity, we break the proof into two parts. First, to illustrate the techniques involved, we encode the computations of deterministic PSPACE machines. <p> Unlike ordinary non-deterministic machines, however, alternating machines may require that all transitions be successful, not just one. Evidence suggests that alternation increases the power of a machine. For instance, alternation gives PSPACE machines the power of EXPTIME machines. That is, APSPACE = EXPTIME <ref> [4] </ref>. Therefore, by encoding the computations of APSPACE machines, we can solve EXPTIME-complete problems. In this way, we complete the proof of Theorem 2. To state the main result of this section precisely, suppose that M is an alternating PSPACE machine. <p> As before, these functions specify string transformations. Formally, a string a 1 :::a n has two successors b 1 n and b 2 n where b i b i b i 6 See <ref> [4] </ref> for examples of such languages.
Reference: [5] <author> W. Chen, M. Kifer, and D.S. Warren. </author> <month> Hilog: </month>
Reference-contexts: This distinguishes predicate substitution from other systems presented in the literature, especially those in which function symbols are used to represent higher-order functions. This is the case, for instance, in the HiLog system of Chen, Kifer and Warren <ref> [5] </ref>, and in the meta-programming methodology of Kwok and Sergot [7]. Although these systems can apply a logic program to different predicates, their use of function symbols gives these systems a great deal of power, so that inference is undecidable.
References-found: 5

