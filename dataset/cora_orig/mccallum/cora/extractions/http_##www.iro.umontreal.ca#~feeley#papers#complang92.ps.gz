URL: http://www.iro.umontreal.ca/~feeley/papers/complang92.ps.gz
Refering-URL: http://www.iro.umontreal.ca/~feeley/
Root-URL: http://www.iro.umontreal.ca
Title: Closure generation based on viewing LAMBDA as EPSILON plus COMPILE  
Author: Marc Feeley Guy Lapalme 
Address: 415 South Street Waltham, MA 02254  P.O.B. 6128, Station A, Montreal, Quebec, H3C 3J7 (Canada)  
Affiliation: Computer Science Dept. Brandeis University  Departement d'informatique et de recherche operationnelle, Universite de Montreal  
Abstract: This paper describes a way of expressing -expressions (which produce closures) in terms of *-expressions (-expressions containing only local and global variable references) and calls to an interactive compiler that compiles *-expressions. This point of view is an interesting way of describing the semantics of -expressions and closure generation. It also leads to an efficient closure implementation both in time and space. A closure is uniformly represented as a piece of code instead of a compound object containing a code and environment pointer. This method can also be used to simulate closures in conventional dialects of Lisp. KEY WORDS Closure implementation Compiling Lisp Scheme Published in: Journal of Computer Languages, Vol. 17, No. 4, pp. 251-267, Pergamon Press, 1992. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Abelson, H., Sussman, G. J., Sussman, J., </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1985. </year>
Reference-contexts: We speak of the resulting procedure as being a closure. In fact, we shall consider them to be synonymous in this paper. Closures are a useful programming feature. They can be used to express data abstractions <ref> [1] </ref>, to implement actors [7,8] and also to implement classes and provide data protection [9]. The work of Atkinson and Morrison [10] discusses their usefulness in implementing modules, separate compilation and database views. Closures have also been used to represent code in a Scheme compiler [11,12]. <p> If our method stayed as it is, assignment to *-expression variables would only modify the corresponding local variable. But an assignment to a closed variable must affect all closures in which it participates. This is essential to implement mutable data abstractions with closures <ref> [1] </ref>. A closed variable that is assigned to, will be called a mutable variable. Assignment to such a variable can be handled in the following way.
Reference: 2. <author> Rees, J. A., Clinger, W., </author> <title> (editors) The Revised 3 Report on the Algorithmic Language Scheme. </title> <journal> ACM SIGPLAN Notices 21, </journal> <volume> 12, </volume> <pages> pages 37-79, </pages> <month> December </month> <year> 1986. </year>
Reference: 3. <author> Steele, G. L., Rabbit: </author> <title> a compiler for Scheme. </title> <booktitle> MIT Artificial Intelligence Memo 474, </booktitle> <address> Cambridge, Massachusetts, </address> <month> May </month> <year> 1978. </year>
Reference: 4. <author> Rees, J. A., Adams, N. I., </author> <title> T: A Dialect of Lisp or, LAMBDA: The Ultimate Software Tool. </title> <booktitle> In Conference record of the 1982 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 114-122, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> August </month> <year> 1982. </year>
Reference: 5. <author> Rees, J. A., Adams, N. I., Meehan, J. R., </author> <title> The T Manual. </title> <institution> Computer Science Department, Yale University, </institution> <address> New Haven, Connecticut, </address> <month> January </month> <year> 1984. </year>
Reference: 6. <author> Steele, G. L., </author> <title> Common Lisp: the Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: 1 INTRODUCTION In many lexically scoped dialects of Lisp, e.g. Scheme [1-3], T [4,5] and Common Lisp <ref> [6] </ref>, procedures are first class objects. They are defined by -expressions of the form (lambda formal-argument-list body).
Reference: 7. <author> Steele, G. L., </author> <title> Lambda: the ultimate declarative. </title> <booktitle> MIT Artificial Intelligence Memo 379, </booktitle> <address> Cambridge, Massachusetts, </address> <month> November </month> <year> 1976. </year>
Reference: 8. <author> Sussman, G. J., Steele, G. L., </author> <title> Scheme: An Interpreter for extended Lambda Calculus. </title> <booktitle> MIT Artificial Intelligence Memo 349, </booktitle> <address> Cambridge, Massachusetts, </address> <month> December </month> <year> 1975. </year>
Reference: 9. <author> Wand, M., </author> <title> Continuation-Based Multiprocessing. </title> <booktitle> In Conference record of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 19-28, </pages> <address> Stanford, California, </address> <month> August </month> <year> 1980. </year> <month> 22 </month>
Reference-contexts: In fact, we shall consider them to be synonymous in this paper. Closures are a useful programming feature. They can be used to express data abstractions [1], to implement actors [7,8] and also to implement classes and provide data protection <ref> [9] </ref>. The work of Atkinson and Morrison [10] discusses their usefulness in implementing modules, separate compilation and database views. Closures have also been used to represent code in a Scheme compiler [11,12].
Reference: 10. <author> Atkinson, M. P., Morrison, R., </author> <title> Procedures as Persistent Data Objects. </title> <booktitle> In ACM Transac--tions on Programming Languages and Systems, </booktitle> <volume> vol. 7, no. 4, </volume> <pages> pages 539-559, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: In fact, we shall consider them to be synonymous in this paper. Closures are a useful programming feature. They can be used to express data abstractions [1], to implement actors [7,8] and also to implement classes and provide data protection [9]. The work of Atkinson and Morrison <ref> [10] </ref> discusses their usefulness in implementing modules, separate compilation and database views. Closures have also been used to represent code in a Scheme compiler [11,12]. Unfortunately, -expressions give little insight into the method used to allocate and reference formal argument variables and into the way closures are represented and generated.
Reference: 11. <author> Feeley, M., </author> <title> Deux approches a l'implantation du langage Scheme. Document de travail no 183, </title> <institution> Departement d'informatique et de recherche operationnelle, Universite de Mon-treal, </institution> <month> May </month> <year> 1986. </year>
Reference: 12. <author> Feeley, M., Lapalme, G., </author> <title> Using Closures for Code Generation. </title> <journal> Computer Languages, </journal> <volume> vol. 12, no. 1, </volume> <pages> pages 47-66, </pages> <year> 1987. </year>
Reference: 13. <author> Brooks, R. A., Gabriel, R. P., Steele, G. L., </author> <title> An Optimizing Compiler for lexically Scoped Lisp. </title> <booktitle> In Proceedings of the SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <pages> pages 261-275, </pages> <month> June </month> <year> 1982. </year>
Reference: 14. <author> Griss, M. L., Hearn, A. C., </author> <title> A Portable Lisp Compiler. </title> <journal> In Software-Practice and Experience, </journal> <volume> vol. 11, </volume> <pages> pages 541-605, </pages> <year> 1981. </year>
Reference: 15. <author> Aho, A. V., Ullman, J. D., </author> <title> Principles of Compiler Design. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1977. </year>
Reference: 16. <author> Randell, B., Russell, L. J., </author> <title> Algol 60 implementation. </title> <publisher> Academic Press, </publisher> <address> New York, New York, </address> <year> 1964. </year>
Reference: 17. <author> Dijkstra, E. W., </author> <title> Recursive Programming. </title> <booktitle> In Programming Systems and Languages, </booktitle> <publisher> McGraw-Hill, </publisher> <address> New York, New York, </address> <year> 1967. </year>
Reference-contexts: This can be alleviated by using a vector of pointers to the frames (known as a display) instead of linking them with static links <ref> [17] </ref>. Variable access then consists of an indirect addressing through the appropriate display pointer.
Reference: 18. <author> McDermott, D., </author> <title> An efficient Environment Allocation Scheme in an Interpreter for a Lexically-scoped Lisp. </title> <booktitle> In Conference record of the 1980 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 154-162, </pages> <address> Stanford, California, </address> <month> August </month> <year> 1980. </year>
Reference-contexts: To perform such an optimization, the compiler must have some knowledge of the semantics of -expressions, closure invocation and data manipulation primitives. Another possible optimization is to consistently allocate environments on the control stack and to move them to the heap only when necessary <ref> [18] </ref>. This last method is particularly well suited for an interpreter based system because the decision to move the environment to the heap can be taken at run time. 6 Certain implementation tricks can be used to represent environments more efficiently.
Reference: 19. <author> Church, A., </author> <title> The Calculi of Lambda-Conversion. Annals of Mathematics Studies Number 6, </title> <publisher> Princeton University Press, </publisher> <address> Princeton, New Jersey, </address> <year> 1941. </year>
Reference-contexts: The compile procedure can be thought of as a procedure constructor. Thus it shares some common points with the evaluation of a -expression which also creates procedures. This aspect will be exploited in our closure implementation method. The transformation process uses the fi-conversion principle of the -calculus <ref> [19] </ref>. The fi-conversion principle states that when an abstraction (i.e. the -calculus equivalent of a procedure) is applied to some argument, every occurrence of the formal argument in the body of the abstraction can be replaced by the actual argument value.
Reference: 20. <editor> Peyton Jones, S.L., </editor> <booktitle> The Implementation of Functional Programming Languages, </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Compilation needs only to be performed on the *-expression corresponding to the I-procedure when a closure is generated. The resulting I-procedure is the closure corresponding to the -expression that has been transformed. This transformation corresponds to the "lambda-lifting" transformation which is used in supercombinator graph reduction <ref> [20] </ref>. This article shows how it can be applied in the environment based approach to programming language implementation. 3.3 Internal aspect of closure generation To fully explain the transformation process, consider the code that needs to be generated when a closure is created.
Reference: 21. <author> Cardelli, L., </author> <title> The Functional Abstract Machine. </title> <institution> Bell Labs Tech. Report TR-107, </institution> <year> 1983. </year>
Reference: 22. <author> Cardelli, L., </author> <title> Compiling a Functional Language. </title> <booktitle> In Conference record of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <address> Austin, Texas, </address> <month> August </month> <year> 1984. </year>
Reference: 23. <author> Feeley, M., Miller, J. S., </author> <title> A Parallel Virtual Machine for Efficient Scheme Compilation. </title> <booktitle> In Conference record of the 1990 ACM Symposium on Lisp and Functional Programming, </booktitle> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: This address can then be used to access the closed variables of the closure. This approach was used in the Gambit compiler with good results <ref> [23] </ref>. Another interesting use of our method is to implement closures in dialects of Lisp which do not have them.

References-found: 23

