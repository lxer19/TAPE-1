URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/petel/pub/www/papers/pcc/pcc-mobile.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/petel/pub/www/papers/pcc/pcc.html
Root-URL: http://www.cs.cmu.edu
Email: fpetel,neculag@cs.cmu.edu  
Title: Research on Proof-Carrying Code for Mobile-Code Security A Position Paper  
Author: Peter Lee George Necula 
Date: March 26-28, 1997  
Note: DARPA Workshop on Foundations for Secure Mobile Code  
Address: Pittsburgh, Pennsylvania 15213  
Affiliation: Carnegie Mellon University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. Feigenbaum and P. Lee. </author> <title> Trust management and proof-carrying code in secure mobile-code applications (A position paper). Submitted to the DARPA Workshop on Foundations for Secure Mobile Code, </title> <address> Monterey, California, </address> <month> March, </month> <year> 1997. </year>
Reference-contexts: these assurances without undue effort and delete rious effect on overall system performance? There are, of course, many other practical problems, such as how to establish accountability and authentication in such large-scale mobile-code environments. 1 Some of our thoughts regarding these kinds of issues are presented in a separate essay <ref> [1] </ref>. For this position paper, we will focus on the problem of how to establish guarantees about the intrinsic behavior of mobile programs. <p> Fourth, no cryptography or trusted third parties are required because PCC is checking intrinsic properties of the code and not its origin. In this sense, PCC programs are "self-certifying." On the other hand, PCC is completely compatible with other approaches to mobile-code security. For example, in another essay <ref> [1] </ref>, we discuss how trust management and PCC can be used together for mobile code security. We also have some experience in using PCC to determine the correctness of applying Software Fault Isolation [3] to network packet filters [4].
Reference: [2] <author> R. Harper, F. Honsell, and G. Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> vol. 40, no. 1, Jan-uary, </volume> <year> 1993, </year> <pages> 143-184. 5 </pages>
Reference-contexts: This predicate must then be proved by the code producer using axioms and inference rules supplied by the code consumer as part of the safety policy. Finally, we use the Edinburgh Logical Framework (LF) <ref> [2] </ref>, which is essentially a typed lambda calculus, to encode and check the proofs. The basic tenet of LF is that proofs are represented as expressions and predicates as types. In order to check the validity of a proof we only need to typecheck its representation.
Reference: [3] <author> R. Wahbe and S. Lucco and T. E. Anderson and S. L. Graham. </author> <title> Efficient Software-Based Fault Isolation. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <month> December, </month> <year> 1993, </year> <pages> 203-216. </pages>
Reference-contexts: For example, in another essay [1], we discuss how trust management and PCC can be used together for mobile code security. We also have some experience in using PCC to determine the correctness of applying Software Fault Isolation <ref> [3] </ref> to network packet filters [4]. In engineering terms, combining approaches leads to different tradeoffs (e.g., less effort required in proof generation at the cost of slower run-time performance) that lead to greater system design flexibility.
Reference: [4] <author> G. Necula and P. Lee. </author> <title> Safe kernel extensions without run-time checking. </title> <booktitle> In Proceedings of the 2nd Symposium on Operating System Design and Implementation (OSDI'96), </booktitle> <address> Seattle, </address> <month> October, </month> <year> 1996, </year> <pages> 229-243. </pages>
Reference-contexts: For example, in another essay [1], we discuss how trust management and PCC can be used together for mobile code security. We also have some experience in using PCC to determine the correctness of applying Software Fault Isolation [3] to network packet filters <ref> [4] </ref>. In engineering terms, combining approaches leads to different tradeoffs (e.g., less effort required in proof generation at the cost of slower run-time performance) that lead to greater system design flexibility. <p> Our packet filters were about 30% to 10 times faster than comparable filters implemented using other approaches, while the safety proofs were smaller than 800 bytes and required no more than 3ms on a DEC Alpha to be validated <ref> [4] </ref>. We continued our experimentation with more complex safety policies. In one experiment, the "active ping," we write extensions of packet filters that can also allocate and deallocate memory, acquire and release locks and send network packets.
Reference: [5] <author> G. Necula and P. Lee. </author> <title> Proof-Carrying Code. </title> <type> Technical Report CMU-CS-96-165, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> September, </month> <year> 1996. </year>
Reference-contexts: The proof validator is therefore an LF typechecker, which is not only extremely simple and efficient but independent of the particular safety policy or logic used. This realization of PCC is described in detail in <ref> [5] </ref>. 2 Note the many instances where elements from logic, type theory and pro-gramming language semantics arise in a realization of PCC. Extended use of these formal systems is required in order to be able to make any guarantees about the safety of the approach.
Reference: [6] <author> G. Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Proceedings of the 24th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'97), </booktitle> <address> Paris, </address> <month> January, </month> <year> 1997. </year>
Reference-contexts: In fact, we are able to prove theorems that guarantee the safety of the PCC technique modulo a correct implementation of the LF typecheker and a sound safety policy <ref> [6] </ref>. 2.1 Advantages of proof-carrying code There are many advantages in using PCC for mobile code. First, although there might be a large amount of effort in establishing and formally proving the safety of the mobile code, almost the entire burden of doing this is shifted to the code producer.
Reference: [7] <author> D. Tennenhouse and D. Wetherall. </author> <title> Towards an active network architecture. </title> <journal> Computer Communication Review, </journal> <volume> vol. 26, no. 2, </volume> <month> April, </month> <year> 1996. </year> <month> 6 </month>
Reference-contexts: What is new, however, is the potential for a large number of anonymous agents to use the Internet to deliver an extremely large number of code objects to hosts. Indeed, in some applications, such as the recently proposed "active networks," <ref> [7] </ref> it is possible for every network packet that is transmitted through a network bridge or router to contain code to be installed and executed in that bridge or router. There are many problems to be solved before such uses of mobile code can become practical.
References-found: 7

