URL: http://www.cs.wustl.edu/cs/playground/papers/handles2.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/playground/papers.html
Root-URL: 
Email: bs@stl.nexen.com kjg@cs.wustl.edu  
Title: Data Handles and Virtual Connections: High-level Support for Anonymous Reconfiguration context of I/O abstraction, a
Author: Bala Swaminathan Kenneth J. Goldman 
Note: The work is presented in the  
Address: St. Louis, MO 63146 Washington University St. Louis, MO 63130-4899  
Affiliation: Ascom Nexion Department of Computer Science  
Abstract: Data handles and virtual connections are presented as a solution to the problem of supporting application-driven reconfiguration without sacrificing the separation of communication and computation. The solution supports anonymous reconfiguration, meaning that the module performing the reconfiguration and the modules affected by the reconfiguration need not be aware of each other's presence in the system. The solution allows modules to reconfigure the system within the limits of a specified communication structure while retaining support for dynamic end-user reconfiguration. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. R. Barbacci, D. L. Doubleday, C. B. Weinstock, and J. M. Wing. </author> <title> Developing applications for heterogeneous machine networks: The Durra environment. </title> <journal> Computer Systems, </journal> <volume> 2(1), </volume> <month> March </month> <year> 1988. </year>
Reference-contexts: Configuration of distributed systems has been an important area of research, and a number of mechanisms for configuring systems have been developed. For example, the task description of a Durra <ref> [1, 2] </ref> application has a static number of ports it uses to communicate with other tasks. Darwin [11, 14, 16] supports logical reconfiguration where the programmer adds code that adapts program modules to participate in reconfiguration.
Reference: [2] <author> Mario R. Barbacci and Jeannette M. Wing. </author> <title> A language for distributed applications. </title> <booktitle> In International Conference on Computer Languages, </booktitle> <address> New Orleans, LA, USA, </address> <pages> pages 59-68, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Configuration of distributed systems has been an important area of research, and a number of mechanisms for configuring systems have been developed. For example, the task description of a Durra <ref> [1, 2] </ref> application has a static number of ports it uses to communicate with other tasks. Darwin [11, 14, 16] supports logical reconfiguration where the programmer adds code that adapts program modules to participate in reconfiguration.
Reference: [3] <author> Naeem Bari and Jerome R. Cox, Jr. </author> <title> Distributed radiological multimedia conference. </title> <type> Technical Report WUCS-95-28, </type> <institution> Washington University in St. Louis, </institution> <year> 1995. </year>
Reference-contexts: The application uses cursor sharing to enable a group of geographically separated physicians to discuss an x-ray image <ref> [3] </ref>. In the shared cursor application, two or more users run modules that display an image and a cursor. The "active" cursor and the user's name are highlighted in every user's image. In this section, we show two approaches to cursor sharing.
Reference: [4] <author> Kenneth J. Goldman. </author> <note> Welcome to The Programmers' Playground! http://www.cs.wustl.edu/cs/playground. </note>
Reference-contexts: The following overview includes information necessary to present our approach to application-driven reconfiguration. Further details on I/O abstraction, The Programmers Playground, and related work may be found elsewhere <ref> [4, 5, 6, 7, 17, 18] </ref>. Data: Each data item in a module is either private or published for external access. A published data item has an associated data type and protection. Playground provides a library of publishable data types such as integer, real, tuple, and array.
Reference: [5] <author> Kenneth J. Goldman, Michael D. Anderson, and Bala Swaminathan. </author> <title> The Programmers' Playground: I/O abstraction for heterogeneous distributed systems. </title> <booktitle> In Proceedings of the 27th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 363-372, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: The following overview includes information necessary to present our approach to application-driven reconfiguration. Further details on I/O abstraction, The Programmers Playground, and related work may be found elsewhere <ref> [4, 5, 6, 7, 17, 18] </ref>. Data: Each data item in a module is either private or published for external access. A published data item has an associated data type and protection. Playground provides a library of publishable data types such as integer, real, tuple, and array.
Reference: [6] <author> Kenneth J. Goldman, T. Paul McCartney, Bala Swaminathan, Ram Sethuraman, and Todd Rodgers. </author> <title> Building interactive distributed applications in C++ with The Programmers' Playground. </title> <type> Technical Report WUCS-95-20, </type> <institution> Washington University in St. Louis, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: The following overview includes information necessary to present our approach to application-driven reconfiguration. Further details on I/O abstraction, The Programmers Playground, and related work may be found elsewhere <ref> [4, 5, 6, 7, 17, 18] </ref>. Data: Each data item in a module is either private or published for external access. A published data item has an associated data type and protection. Playground provides a library of publishable data types such as integer, real, tuple, and array.
Reference: [7] <author> Kenneth J. Goldman, Bala Swaminathan, Michael D. Anderson, T. Paul McCartney, and Ramachandran Sethuraman. </author> <title> The Programmers' Playground: I/O abstraction for user-configurable distributed applications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(9) </volume> <pages> 735-746, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Systems supporting only static connections cannot be reconfigured without recompilation, whereas the second and third categories of connections enable dynamic reconfiguration, the act of modifying the configuration of a system while the modules are executing and interacting. This paper builds on previous work on The Programmers' Playground <ref> [7] </ref>, an implementation of I/O Abstraction that was designed to support dynamic end-user configuration. This paper describes how we have added dynamic module-driven configuration to The Programmers' Playground by introducing three simple mechanisms: handles, internal connections, and virtual connections. <p> The following overview includes information necessary to present our approach to application-driven reconfiguration. Further details on I/O abstraction, The Programmers Playground, and related work may be found elsewhere <ref> [4, 5, 6, 7, 17, 18] </ref>. Data: Each data item in a module is either private or published for external access. A published data item has an associated data type and protection. Playground provides a library of publishable data types such as integer, real, tuple, and array. <p> Communication is asynchronous and pairwise FIFO. For a discussion of element-to-aggregate connections, see <ref> [7, 18] </ref>. 2.1 Playground Implementation A basic understanding of the Playground implementation is necessary for an understanding of how anonymous reconfiguration is implemented. An overview of a Playground system is shown in Figure 1. A running module consists of three components: the application, the protocol, and the veneer.
Reference: [8] <author> Brent Hailpern and Gail E. Kaiser. </author> <title> Dynamic reconfiguration in an object-based programming language with distributed shared data. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 73-80, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Both Durra and Darwin allow adding or deleting interconnections between processes. PROFIT [9] is a language that provides a mixture of RPC and data sharing for communication, and permits dynamic binding of slots in special cases <ref> [8] </ref>. Dynamic binding of ports in Durra or slots in PROFIT is accomplished externally, and not initiated by the application itself. Darwin allows an application to change its bindings, provided that the application receives the references of service interfaces through messages (RPC's) before making a transactional binding.
Reference: [9] <author> Gail E. Kaiser and Brent Hailpern. </author> <title> An object-based programming model for shared data. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(2) </volume> <pages> 201-264, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Conic [12, 10, 13], Dar-win's predecessor, provided a graphical user interface for configuring the structure of communication among system components. Both Durra and Darwin allow adding or deleting interconnections between processes. PROFIT <ref> [9] </ref> is a language that provides a mixture of RPC and data sharing for communication, and permits dynamic binding of slots in special cases [8]. Dynamic binding of ports in Durra or slots in PROFIT is accomplished externally, and not initiated by the application itself.
Reference: [10] <author> Jeff Kramer and Jeff Magee. </author> <title> Dynamic configuration for distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(4) </volume> <pages> 1293-1306, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: For example, the task description of a Durra [1, 2] application has a static number of ports it uses to communicate with other tasks. Darwin [11, 14, 16] supports logical reconfiguration where the programmer adds code that adapts program modules to participate in reconfiguration. Conic <ref> [12, 10, 13] </ref>, Dar-win's predecessor, provided a graphical user interface for configuring the structure of communication among system components. Both Durra and Darwin allow adding or deleting interconnections between processes.
Reference: [11] <author> Jeff Kramer and Jeff Magee. </author> <title> Evolving philosophers problem: Dynamic change management. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(11) </volume> <pages> 1293-1306, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Configuration of distributed systems has been an important area of research, and a number of mechanisms for configuring systems have been developed. For example, the task description of a Durra [1, 2] application has a static number of ports it uses to communicate with other tasks. Darwin <ref> [11, 14, 16] </ref> supports logical reconfiguration where the programmer adds code that adapts program modules to participate in reconfiguration. Conic [12, 10, 13], Dar-win's predecessor, provided a graphical user interface for configuring the structure of communication among system components. Both Durra and Darwin allow adding or deleting interconnections between processes.
Reference: [12] <author> Jeff Kramer, Jeff Magee, and Anthony Finkelstein. </author> <title> A constructive approach to the design of distributed systems. </title> <booktitle> In Proceedings of the 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 580-587, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: For example, the task description of a Durra [1, 2] application has a static number of ports it uses to communicate with other tasks. Darwin [11, 14, 16] supports logical reconfiguration where the programmer adds code that adapts program modules to participate in reconfiguration. Conic <ref> [12, 10, 13] </ref>, Dar-win's predecessor, provided a graphical user interface for configuring the structure of communication among system components. Both Durra and Darwin allow adding or deleting interconnections between processes.
Reference: [13] <author> Jeff Kramer, Jeff Magee, and Keng Ng. </author> <title> Graphical configuration programming. </title> <journal> IEEE Computer, </journal> <volume> 22(10) </volume> <pages> 53-65, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: For example, the task description of a Durra [1, 2] application has a static number of ports it uses to communicate with other tasks. Darwin [11, 14, 16] supports logical reconfiguration where the programmer adds code that adapts program modules to participate in reconfiguration. Conic <ref> [12, 10, 13] </ref>, Dar-win's predecessor, provided a graphical user interface for configuring the structure of communication among system components. Both Durra and Darwin allow adding or deleting interconnections between processes. <p> Although this kind of component provides switch-like behavior, it has the disadvantage that the data actually must pass through the component on its way to the various destinations. The Conic configuration tools <ref> [13] </ref> allow a hierarchy of modules to be constructed, where one module may represent a collection of several other modules. Ports of the internal modules may be exposed as ports of the parent module.
Reference: [14] <author> Jeff Kramer, Jeff Magee, and Morris Sloman. </author> <title> Configuring distributed systems. </title> <booktitle> In 5th ACM SIGOPS European Workshop, </booktitle> <address> St. Michel, France, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: Configuration of distributed systems has been an important area of research, and a number of mechanisms for configuring systems have been developed. For example, the task description of a Durra [1, 2] application has a static number of ports it uses to communicate with other tasks. Darwin <ref> [11, 14, 16] </ref> supports logical reconfiguration where the programmer adds code that adapts program modules to participate in reconfiguration. Conic [12, 10, 13], Dar-win's predecessor, provided a graphical user interface for configuring the structure of communication among system components. Both Durra and Darwin allow adding or deleting interconnections between processes.
Reference: [15] <author> B. Liskov. </author> <title> Distributed programming in Argus. </title> <journal> CACM, </journal> <volume> 31(3) </volume> <pages> 300-313, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Dynamic binding of ports in Durra or slots in PROFIT is accomplished externally, and not initiated by the application itself. Darwin allows an application to change its bindings, provided that the application receives the references of service interfaces through messages (RPC's) before making a transactional binding. Argus <ref> [15] </ref> supports reconfiguration with two phase locking over atomic objects and version management recovery techniques.
Reference: [16] <author> Jeff Magee, Naranker Dulay, and Jeff Kramer. </author> <title> Structuring parallel and distributed programs. </title> <booktitle> In International Workshop on Configurable Distributed Systems, </booktitle> <pages> pages 102-117, </pages> <month> March </month> <year> 1992. </year> <institution> Imperial College of Science, Technology and Medicine, UK. </institution>
Reference-contexts: Configuration of distributed systems has been an important area of research, and a number of mechanisms for configuring systems have been developed. For example, the task description of a Durra [1, 2] application has a static number of ports it uses to communicate with other tasks. Darwin <ref> [11, 14, 16] </ref> supports logical reconfiguration where the programmer adds code that adapts program modules to participate in reconfiguration. Conic [12, 10, 13], Dar-win's predecessor, provided a graphical user interface for configuring the structure of communication among system components. Both Durra and Darwin allow adding or deleting interconnections between processes.
Reference: [17] <author> T. Paul McCartney and Kenneth Goldman. </author> <title> Visual specification of interprocess and intraprocess communication. </title> <booktitle> In Proceedings of the 10th International Symposium on Visual Languages (VL'94), </booktitle> <address> St. Louis, MO, USA, </address> <pages> pages 80-87, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The following overview includes information necessary to present our approach to application-driven reconfiguration. Further details on I/O abstraction, The Programmers Playground, and related work may be found elsewhere <ref> [4, 5, 6, 7, 17, 18] </ref>. Data: Each data item in a module is either private or published for external access. A published data item has an associated data type and protection. Playground provides a library of publishable data types such as integer, real, tuple, and array.
Reference: [18] <author> Bala Swaminathan. </author> <title> Connection management in reconfigurable distributed systems. D.Sc. dissertation, </title> <address> Washington University, St. Louis, MO, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: The following overview includes information necessary to present our approach to application-driven reconfiguration. Further details on I/O abstraction, The Programmers Playground, and related work may be found elsewhere <ref> [4, 5, 6, 7, 17, 18] </ref>. Data: Each data item in a module is either private or published for external access. A published data item has an associated data type and protection. Playground provides a library of publishable data types such as integer, real, tuple, and array. <p> Communication is asynchronous and pairwise FIFO. For a discussion of element-to-aggregate connections, see <ref> [7, 18] </ref>. 2.1 Playground Implementation A basic understanding of the Playground implementation is necessary for an understanding of how anonymous reconfiguration is implemented. An overview of a Playground system is shown in Figure 1. A running module consists of three components: the application, the protocol, and the veneer.
Reference: [19] <author> Bala Swaminathan and Kenneth J. Goldman. </author> <title> Dynamic reconfiguration with I/O abstraction. </title> <booktitle> In Proceedings of the Seventh IEEE Symposium on Parallel and Distributed Processing (SPDP'95), </booktitle> <address> San Antonio, Texas, </address> <month> October 25-28, </month> <year> 1995, </year> <pages> pages 496-501, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: knowledge of the number and the locations of other participants. 4.2 Application-Driven Module Migra tion In the module migration mechanism of The Programmers' Playground, end-users specify migration by establishing a connection from a distinguished presentation entry called MIG in the running module to a similar entry in the waiting module <ref> [19] </ref>. We assume that the presentation of each relocatable module is static. Since MIG is a simple data variable, it can be connected to a handle variable in the same module or in another module.
References-found: 19

