URL: http://www.cms.dmu.ac.uk/~sp/postscripts/rum.ps
Refering-URL: http://www.cms.dmu.ac.uk:80/~sp/
Root-URL: 
Email: email: sp/zedan/luker]@dmu.ac.uk  
Title: Resource Usage Matrix in Object Identification and Design Transformation of Legacy Procedural Software  
Author: Sagar Pidaparthi, Hussein Zedan, Paul Luker 
Address: UK,  
Affiliation: School of Computing Sciences, DeMontfort University, Leicester,  
Note: Submitted to 14 th Automatic Software Engineering Conference Length to be reduced to about 9 Pages. printed on 28/07/97 09:31:30  
Abstract: This paper provides a novel technique for object identification from legacy procedural software, which can also be applied in partitioning of classes in object oriented software systems. Currently there is a movement towards object oriented design and programming , from algorithmic decomposition, structured design and procedural implementation . It is more economic to restructure existing software into object oriented topology by identifying objects within the subject system than to redesign software starting from requirements. Such object identification relies upon program analysis and a study of inter component relationships. This paper initially provides a conceptual foundation for migration from procedural to object oriented software architecture for legacy software. It relies upon a view of software life cycle, in which all software development is considered to be evolutionary activity with reengineering/restructuring as an important process applied repeatedly on the artefacts of development at various stages in this evolution. Secondly, it introduces a novel approach of viewing a procedural program from an object oriented perspective in which there is a single god class which has a large number of global variables & methods, supported by several user defined classes which have no behaviour but data definitions. This view, coupled with repeated restructuring, enables a seamless migration of behaviour from the god class to other classes using design transformation methods. This paper distinguishes between the processes of translation and transformation and states that these two are orthogonal to each other, thus enabling us to concentrate on design transformations to migrate from one design to another, leaving the language issues to be handled by translators. It describes some basic design transformations which permit partitioning of classes while preserving the system behaviour, enabling a series of heuristics to be used in conjunction with design transforms to migrate to a better software structure. The main contribution of this paper is in the proposal of a new algorithm for object identification called resource usage matrix, a visualisation of resource usage within the system for object identification. A case study in object identification is presented to highlight the usefulness of resource usage matrix in object identification.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Chikofsky, E.J., Cross II, J.H., </author> <year> (1990), </year> <title> Reverse engineering and design recovery : A taxonomy", </title> <journal> IEEE Software,Vol. </journal> <volume> 7, No. 1, </volume> <pages> pp 13-17. </pages>
Reference-contexts: Submitted to 14 th Automatic Software Engineering Conference Length to be reduced to about 9 Pages. printed on 28/07/97 09:31:30 Chikofsky and Cross <ref> [1] </ref> define reverse engineering as the "process of analysing a subject system to identify the system's components and their interrelationships, to create representations of the system in another or at higher level of abstraction".
Reference: 2. <author> Livadas,P.E.,Roy,P.K.,(1992), </author> <title> Program dependence analysis",IEEE Conference on Software Maintenance. </title>
Reference-contexts: RESTRUCT is a project which uses reverse engineering to transform poorly structured programs into programs with objectoriented structure. An object in a conventional programming language can be defined as a collection of routines, types and data items <ref> [2] </ref>. The routines implement the methods associated with objects; types represent object attributes, and data items represent or point to actual instances of the object class es. <p> Sneed [3] describes 10 steps to deriving objectoriented design from program structure. RESTRUCT is a CASE tool which works on Sneed's third step, which defines objects in three ways which are based on the algorithms proposed by Livadas & Roy <ref> [2] </ref> and Liu & Wilde [4], these are global based, type based and receiver based object identifiers. In this tool a relational database is used to store information about subject program structure. <p> Object Identification Heuristics 6.1 Reported techniques for object Identification Once the basic design transformations have been identified, the main task that remains is to select the heuristics that need to be used to identify the candidate objects. T hree algorithms described by Livadas and Roy <ref> [2] </ref>, Liu and Wilde,[4] analyse calling and functional dependencies between program components and then identify classes in a subject program. <p> The second step is based on the intuition that if a routine must be clustered with one of its parameter types, it should be clustered with the most complex of these types [4]. The third algorithm, is a receiver based object identifier ( rboi ) <ref> [2] </ref> which clusters together types and functions which modify variables of these types. Receiver based object identifier ( rboi ) algorithm defines a candidate object as a pair (F, T), where F is a set of routines that modify variables of type T.
Reference: 3. <author> Sneed, H.M., </author> <title> (1992),Migration of Procedurally Oriented COBOL Programs in an ObjectOriented Architecture, </title> <booktitle> Proc. IEEE Conference on Software Maintenance., </booktitle> <address> San Deigo, </address> <pages> pp 266-271. </pages>
Reference-contexts: Finding and defining such objects is a natural way to create a representation of the system in another form and in a higher level of abstraction. Sneed <ref> [3] </ref> describes 10 steps to deriving objectoriented design from program structure.
Reference: 4. <author> Liu, S.S., Wilde, N., </author> <title> (1990) Identifying Objects in a Conventional Procedural Language : An Example of Data Design Recovery", </title> <booktitle> Proc. of the Conference on Software Maintenance. </booktitle>
Reference-contexts: Sneed [3] describes 10 steps to deriving objectoriented design from program structure. RESTRUCT is a CASE tool which works on Sneed's third step, which defines objects in three ways which are based on the algorithms proposed by Livadas & Roy [2] and Liu & Wilde <ref> [4] </ref>, these are global based, type based and receiver based object identifiers. In this tool a relational database is used to store information about subject program structure. Object identification algorithms use the information from the database to restructure the program and to store the new structure in the database. <p> The second step is based on the intuition that if a routine must be clustered with one of its parameter types, it should be clustered with the most complex of these types <ref> [4] </ref>. The third algorithm, is a receiver based object identifier ( rboi ) [2] which clusters together types and functions which modify variables of these types.
Reference: 5. <author> Booch, G.,(1991), </author> <title> ObjectOriented Design with Applications, </title> <publisher> The Benjamin/Cummings Publishing Company. </publisher>
Reference-contexts: Structured methodologies of the 70s and 80s advocated linear design processes which were unrealistic in their approach. It is now accepted that software design and development requires cyclic or iterative approaches. Booch <ref> [5] </ref> proposes a life cycle in which there are two kinds of processes for software design, one of which is the macro design process and the second being the micro design process. Each phase in the macro design process has a complete iteration of a micro design processes. <p> Usually there is one component which is called the system, which represents the system to be developed. Components in a software system are: classes, procedures, functions, types, variables. Design can be developed using design languages, which can be graphical like OMT [9], UML [10], or Booch <ref> [5] </ref> notation or by using languages like Language for ObjectOriented Modelling (LOOM)[11], alternatively they can be specified using formal languages like COLD-K [7,8] as in the Meteor Project.
Reference: 6. <author> Feijs, L. </author> <title> (1993) Formalisation of Design Methods, Ellis Horwood Series in Computers and their Applications. </title>
Reference-contexts: However, it is important to note that the design transformations discussed by Feijs <ref> [6] </ref>, are at a very high level of abstraction and are not suitable for our purpose of migration from procedural to objectoriented programs.
Reference: 7. <author> Feijs, L. And Jonkers, H.B.M. </author> <title> (1989) METEOR and beyond: industrialising formal methods, </title> <editor> In: K.H. Bennet (ED.) </editor> <booktitle> Software Engineering Environments: Research and Practice, </booktitle> <publisher> Ellis Horwood Limited, </publisher> <pages> pp. </pages> <month> 255-274.. </month>
Reference: 8. <author> Bergstra, J.A., Heering, J., Klint,, </author> <title> P (1990) Module Algebra, </title> <journal> JACM Vol. </journal> <volume> 37 No 2 pp. </volume> <pages> 335-372. </pages>
Reference: 9. <author> Rumbaugh, J.,Blaha, M., Premerlani, W., Eddy, F., Lorensen, W., </author> <title> (1991)Object-Oriented Modelling and design, </title> <publisher> Prentice-Hall. </publisher>
Reference-contexts: Usually there is one component which is called the system, which represents the system to be developed. Components in a software system are: classes, procedures, functions, types, variables. Design can be developed using design languages, which can be graphical like OMT <ref> [9] </ref>, UML [10], or Booch [5] notation or by using languages like Language for ObjectOriented Modelling (LOOM)[11], alternatively they can be specified using formal languages like COLD-K [7,8] as in the Meteor Project.
Reference: 10. <institution> UML </institution>
Reference-contexts: Usually there is one component which is called the system, which represents the system to be developed. Components in a software system are: classes, procedures, functions, types, variables. Design can be developed using design languages, which can be graphical like OMT [9], UML <ref> [10] </ref>, or Booch [5] notation or by using languages like Language for ObjectOriented Modelling (LOOM)[11], alternatively they can be specified using formal languages like COLD-K [7,8] as in the Meteor Project.
Reference: 11. <institution> LOOM </institution>
Reference: 12. <author> Choi, S.C. and Scacchi, W., </author> <year> (1990), </year> <title> Extracting and Restructuring the design of large systems, </title> <journal> IEEE Software. </journal>
Reference: 13. <author> Chen, Y.F., Nishimoto, M.Y., Ramamoorthy, </author> <title> C.V.,(1990) The C Information Abstraction System, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 16, No. </volume> <pages> 3. </pages>
Reference: 14. <author> Dietrich, S.W., Calliss, F.W., </author> <title> (1991) The Application of Deductive Databases to Inter-Module Code Analysis", </title> <booktitle> Proceedings of IEEE conference on software maintenance, </booktitle> <pages> pp 120-128. </pages>
Reference: 15. <author> Harandi, M.T., Ning, J.Q., </author> <year> (1990), </year> <title> Knowledge Based Program Analysis", </title> <journal> IEEE Software. </journal>
Reference: 16. <author> Linton, M.A.,1984, </author> <title> Implementing relational views of programs, </title> <booktitle> Proc. ACM SIGSOFT/SIGPLAN Software Engineering Symposium Practical Software Development Environment, Pittsburgh, </booktitle> <pages> pp. 65-72. </pages>
Reference: 17. <author> Pidaparthi, S., </author> <title> (1994) Forward and Reverse Engineering CASE Tool Supporting Multiple Views for Software Development". </title> <institution> Internal Report for De Montfort University, Leicester, U.K. </institution>
Reference-contexts: Since this Submitted to 14 th Automatic Software Engineering Conference Length to be reduced to about 9 Pages. printed on 28/07/97 09:31:30 technique is used in conjunction with basic design transforms, which preserve behaviour <ref> [17] </ref>, we state that we can migrate from a procedural program to an object oriented program while preserving the behaviour of a system. 7. Transformation of Event Processor Simulator Design 7.1 Subject System Event processor simulator was taken as an example for design extraction and transformation using RESTRUCT.
Reference: 18. <author> Pidaparthi, S., Cysewski, </author> <title> G.,(1996) Migration to ObjectOriented System Structure Using Design Transformation Methods, </title> <booktitle> Proceedings of The Fifth International Conference Information Systems Development - ISD96.pp 555-571. </booktitle>
Reference: 19. <author> Pidaparthi, S, Cysewski, </author> <title> G.,(1997) Case Study in Migration to ObjectOriented System Structure Using Design Transformation Methods, </title> <booktitle> Proceedings of First Euro-Micro Working Conference on Software Maintenance and Re-engineering, </booktitle> <address> 17-19,March, </address> <year> 1997. </year> <pages> pp 128-135. </pages>
Reference: 20. <author> Zedan, H., Pidaparthi, S., </author> <title> (1997) Formalisation of Design Transformations, </title> <institution> Internal Report for DeMontfort University, Leicester, U.K. </institution>
References-found: 20

