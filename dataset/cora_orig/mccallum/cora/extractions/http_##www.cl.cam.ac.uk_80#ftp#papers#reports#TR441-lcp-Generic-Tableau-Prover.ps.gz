URL: http://www.cl.cam.ac.uk:80/ftp/papers/reports/TR441-lcp-Generic-Tableau-Prover.ps.gz
Refering-URL: http://www.cl.cam.ac.uk:80/ftp/papers/reports/
Root-URL: 
Email: lcp@cl.cam.ac.uk  
Title: A Generic Tableau Prover and its Integration with Isabelle  
Author: Lawrence C. Paulson 
Date: 9 January 1998  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Baaz, M., Leitsch, A., </author> <title> On Skolemization and proof complexity, </title> <note> Fundamenta Informaticae 20 (1994), 353-379 </note>
Reference-contexts: With Skolemization and the liberalized ffi-rules, the obvious method of proof reconstruction involves manipulating *-terms in Isabelle. This method would be prohibitively inefficient: the terms are large. Finally, there is the question of prenexing. Baaz and Leitsch <ref> [1] </ref> have proved the folklore result that prenexing a formula makes its proof longer. Quantifiers should be pushed in, not pulled out. Isabelle's tableau prover can expect that task to have been done for it beforehand. <p> such as 8x ((x) _ ) $ (8x (x)) _ and even [ A (x) " B = x2A Omitted is the distributive law 8x ((x) ^ (x)) $ (8x (x)) ^ (8x (x)) and its 9-_ dual, which by increasing the number of Skolem functions can sometimes be harmful <ref> [1] </ref>. 6 Types and Overloading Isabelle's framework for specifying formalisms is typed. Some of its logics, such as ZF set theory [19], are essentially typeless: types serve only to prevent absurd expressions like S S ).
Reference: [2] <author> Beckert, B., Hahnle, R., Schmitt, P. H., </author> <title> The even more liberalized ffi-rule in free variable semantic tableaux, In Computational Logic and Proof Theory: </title> <booktitle> Third Kurt Godel Colloquium, KGC'93 Colloquium (1993), </booktitle> <editor> G. Gottlob, A. Leitsch, D. Mundici, Eds., </editor> <publisher> LNCS 713, Springer, </publisher> <pages> pp. 108-119 </pages>
Reference-contexts: Note that 8x 9z 8y A requires retention of the subformula 8y A because each instance of it will contain a different term for z, generated by a ffi-rule. So, the optimization works even better for provers that employ Skolemiza-tion or the ffi + + -rule <ref> [2] </ref>. Rules that Close Branches. In a first-order tableau, the only way to close a branch is by unifying complementary literals. But in generic tableau theorem-proving, many rules can close branches. <p> The first [6] is to apply the Skolem function only to the variables free in the formula 9x (x) 7 rather than to all those of the branch; having fewer variables lets the Skolem term take part in more successful unifications. The second liberalization <ref> [2] </ref> goes further by allowing 9x and 9x to share one Skolem function provided the two formulas are identical up to variable renaming. (This includes the important case where both have arisen through expansion of a formula such as 8y 9x .) Both liberalizations can be understood intuitively as the replacement
Reference: [3] <author> Beckert, B., Posegga, J., leanTAP: </author> <title> Lean tableau-based deduction, </title> <journal> Journal of Automated Reasoning 15, </journal> <volume> 3 (1995), </volume> <pages> 339-358 </pages>
Reference-contexts: Binding constructs such as S x2A B (x) and fx j (x)g are common in set theory, which is as fundamental to Isabelle/HOL as it is to Isabelle/ZF. A generic tableau prover therefore needs a higher-order syntax: a syntax that includes the -calculus. Leantap <ref> [3] </ref> uses negation normal form, but a generic tableau prover cannot easily use a normal form. The notion of normal form would depend upon the precise set of primitives being supported in a particular call to the prover. <p> The new tactic (which is called Blast_tac) must let Isabelle check the proof it finds and must behave reasonably to users accustomed to Fast_tac. 3 Designing the Prover As the starting point, I adopted leantap <ref> [3] </ref>, a tableau prover consisting of five Prolog clauses. Although it is far from being the top-performing prover, it is much better than Fast_tac on standard benchmarks such as Pelletier's problems [20].
Reference: [4] <author> Dafa, L., </author> <title> Unification algorithms for eliminating and introducing quantifiers in natural deduction automated theorem proving, </title> <journal> Journal of Automated Reasoning 18, </journal> <volume> 1 (1997), </volume> <pages> 105-134 </pages>
Reference-contexts: The numbered problems are those of Pelletier [20]; problem 34 is also known as Andrews' Challenge. Halting II refers to the halting problem presented by Dafa <ref> [4] </ref>. 4 The last four problems are formulated in the set theory of Isabelle/HOL. [ [ [ (B"C) Union-image " " " (B"C) Inter-image 8 x2S 8 y2S x y ! 9z S fzg Singleton I 8 x2S (S) x ! 9z S fzg Singleton II Here " is the image
Reference: [5] <author> Davis, M., </author> <title> Obvious logical inferences, </title> <booktitle> In 7th International Joint Conference on Artificial Intelligence (IJCAI '81) (Aug. </booktitle> <year> 1981), </year> <pages> pp. 530-531 </pages>
Reference-contexts: This paper describes a new tableau prover and its integration with Isabelle. I have previously [17] described Fast_tac, a tableaux-like proof tactic for Isabelle. Fast_tac automatically finds proofs that consist only of so-called obvious inferences <ref> [5, 21] </ref>. Crucially, the tactic is itself generic. It works in most of Isabelle's classical logics and reasons directly with user-defined primitives. New concepts from the application domain can be supported without the search-space explosion that would result from simply adding their definitions to the tableau. <p> Several features of leantap still remain in Blast_tac. * Depth-first iterative deepening [9] is now the search strategy of choice for such systems. Fast_tac can use depth-first search because of its incomplete treatment of fl-rules, which ensures termination but proves only obvious <ref> [5] </ref> theorems. * The resource bounded by iterative deepening is mainly the number of fl-rule applications, but it includes other `costs' of the proof. (For Stickel's Prolog Technology Theorem Prover [22], the resource is the number of subgoals allowed in a proof.) * Formulas in a branch are considered in a
Reference: [6] <author> Hahnle, R., Schmitt, P. H., </author> <title> The liberalized ffi-rule in free variable semantic tableaux, </title> <journal> Journal of Automated Reasoning 13, </journal> <month> 2 (Oct. </month> <year> 1994), </year> <pages> 211-221 </pages>
Reference-contexts: Although it may resemble Skolemizing the formula before calling the prover, this form of ffi-rule poses no problems for proof reconstruction: it corresponds (in the example above) to the standard 9-elimination rule. Two liberalizations of the ffi-rule have been published. The first <ref> [6] </ref> is to apply the Skolem function only to the variables free in the formula 9x (x) 7 rather than to all those of the branch; having fewer variables lets the Skolem term take part in more successful unifications.
Reference: [7] <author> Harrison, J., </author> <title> Binary decision diagrams as a HOL derived rule, </title> <journal> Computer Journal 38, </journal> <volume> 2 (1995), </volume> <pages> 162-170 </pages>
Reference-contexts: For example, John Harrison has shown how to translate OBDD derivations into proofs acceptable to the HOL system <ref> [7] </ref>. Translating proofs can be difficult and slow, so I have taken pains to make the tableau proofs closely resemble Isabelle proofs. The main advantage of the tableau prover over Isabelle is its greater search speed.
Reference: [8] <author> Huet, G. P., </author> <title> A unification algorithm for typed -calculus, </title> <journal> Theoretical Comput. Sci. </journal> <volume> 1 (1975), </volume> <pages> 27-57 </pages>
Reference-contexts: Fast_tac is not really an integration between automatic and interactive tools because it runs on the same generalized Prolog engine that Isabelle uses for single-step inferences. Isabelle itself provides the automation. This engine is rather slow, in part because it performs higher-order unification <ref> [8] </ref>. To improve decisively over Fast_tac, I decided to code a separate tableau prover and arrange that only a successful proof (rather than the full search) went through Isabelle's engine. This paper makes two contributions. <p> To keep the prover simple, it represents Isabelle types using its data structure for terms; unification propagates type constraints. 7 Minor Points Now, let us briefly consider some additional features of the prover. 9 Unification. Isabelle uses higher-order unification <ref> [8] </ref>. For efficiency, the tableau prover uses first-order unification. Bound variables, represented by de Bruijn indices, are handled in the obvious way: a bound variable unifies only with itself. Unification between two -abstractions fails. Detecting that x:x is not unifiable with x:?y would complicate the algorithm and is not necessary.
Reference: [9] <author> Korf, R. E., </author> <title> Depth-first iterative-deepening: an optimal admissible tree search, </title> <booktitle> Artificial Intelligence 27 (1985), </booktitle> <pages> 97-109 </pages>
Reference-contexts: Leantap's simplicity and clarity make it a good framework on which to build other provers. Several features of leantap still remain in Blast_tac. * Depth-first iterative deepening <ref> [9] </ref> is now the search strategy of choice for such systems.
Reference: [10] <author> Lifschitz, V., </author> <title> What is the inverse method?, </title> <journal> Journal of Automated Reasoning 5, </journal> <volume> 1 (1989), </volume> <pages> 1-23 </pages>
Reference-contexts: One proof (problem 43) got shorter, but the runtime actually rose due to the increased branching factor! I did not investigate the second liberalization. I did find that Skolemization made a big improvement in the proof of a problem discussed by Lifschitz <ref> [10] </ref>. With Skolemization and the liberalized ffi-rules, the obvious method of proof reconstruction involves manipulating *-terms in Isabelle. This method would be prohibitively inefficient: the terms are large. Finally, there is the question of prenexing.
Reference: [11] <author> Miller, D., </author> <title> Unification under a mixed prefix, </title> <journal> Journal of Symbolic Computation 14, </journal> <volume> 4 (1992), </volume> <pages> 321-358 </pages>
Reference-contexts: The rule is represented in Isabelle as a generalized Horn clause: ^ Here, V is Isabelle's meta-universal quantifier, Tr is a meta-level predicate to recognize true formulas, and All is the constant for the first-order universal quantifier. Isabelle's treatment of Skolemization (which is its dual <ref> [11] </ref>) must be converted to conventional Skolemization.
Reference: [12] <author> Nipkow, T., </author> <title> More Church-Rosser proofs (in Isabelle/HOL), </title> <booktitle> In Automated Deduction | CADE-13 International Conference (1996), </booktitle> <editor> M. McRobbie J. K. Slaney, Eds., </editor> <publisher> LNAI 1104, Springer, </publisher> <pages> pp. 733-747 </pages>
Reference-contexts: A preliminary rewriting phase could eliminate these symbols, but many application domains cannot easily be reduced to first-order logic. Examples are those involving inductive definitions, such as the -calculus <ref> [12] </ref> and my models of security protocols [18]. Binding constructs such as S x2A B (x) and fx j (x)g are common in set theory, which is as fundamental to Isabelle/HOL as it is to Isabelle/ZF.
Reference: [13] <author> Paulson, L. C., </author> <title> Set theory for verification: I. From foundations to functions, </title> <journal> Journal of Automated Reasoning 11, </journal> <volume> 3 (1993), </volume> <pages> 353-389 16 REFERENCES </pages>
Reference-contexts: A new formula is expanded last rather than first. The stack/queue distinction refers not to the search strategy but to the method used to select the next formula for expansion.) Extensive experimentation with problems in first-order logic (largely Pel-letier's) and ZF set theory <ref> [13, 15] </ref> suggested extensions to leantap's strategy. Though many of these extensions were driven by the need for Blast_tac to handle generic rules, most of them can be explained in terms of first-order logic, which may be clearer to some readers. Deferral of fl-Formulas.
Reference: [14] <author> Paulson, L. C., </author> <title> Isabelle: A Generic Theorem Prover, </title> <publisher> Springer, </publisher> <year> 1994, </year> <note> LNCS 828 </note>
Reference-contexts: 1 Introduction Interactive proof tools obviously benefit from the addition of automatic proof procedures, provided they are well integrated. Interactive tools are popular because of their flexibility: they support expressive formalisms and large developments. The user must guide the proof, but would like to have straightforward subgoals proved automatically. Isabelle <ref> [14] </ref> is an interactive theorem prover. Unusually, Isabelle is generic: it supports numerous formalisms, including higher-order logic (Isa-belle/HOL), first-order logic, set theory (Isabelle/ZF), some modal logics and linear logic. This paper describes a new tableau prover and its integration with Isabelle. <p> I have elsewhere described the connection between Isabelle and tableau rules [17], and more details are available in the documentation <ref> [14, Chap. 14] </ref>. Some further points can be seen in the treatment of the natural deduction rule (8I). This inference rule takes the premise to the conclusion 8x , subject to the usual proviso that x is not free in the assumptions.
Reference: [15] <author> Paulson, L. C., </author> <title> Set theory for verification: II. Induction and recursion, </title> <journal> Journal of Automated Reasoning 15, </journal> <volume> 2 (1995), </volume> <pages> 167-215 </pages>
Reference-contexts: A new formula is expanded last rather than first. The stack/queue distinction refers not to the search strategy but to the method used to select the next formula for expansion.) Extensive experimentation with problems in first-order logic (largely Pel-letier's) and ZF set theory <ref> [13, 15] </ref> suggested extensions to leantap's strategy. Though many of these extensions were driven by the need for Blast_tac to handle generic rules, most of them can be explained in terms of first-order logic, which may be clearer to some readers. Deferral of fl-Formulas.
Reference: [16] <author> Paulson, L. C., </author> <title> ML for the Working Programmer, 2nd ed., </title> <publisher> Cambridge University Press, </publisher> <year> 1996 </year>
Reference-contexts: Search-Space Pruning. A limited form of intelligent backtracking takes place whenever a branch is closed. The prover is coded in ML <ref> [16] </ref> and manages backtracking with an explicit list of choice points. Closing a branch typically proves a number of parent subgoals.
Reference: [17] <author> Paulson, L. C., </author> <title> Generic automatic proof tools, In Automated Reasoning and its Applications: Essays in Honor of Larry Wos, </title> <editor> R. Veroff, Ed. </editor> <publisher> MIT Press, </publisher> <year> 1997, </year> <note> ch. 3 </note>
Reference-contexts: Isabelle [14] is an interactive theorem prover. Unusually, Isabelle is generic: it supports numerous formalisms, including higher-order logic (Isa-belle/HOL), first-order logic, set theory (Isabelle/ZF), some modal logics and linear logic. This paper describes a new tableau prover and its integration with Isabelle. I have previously <ref> [17] </ref> described Fast_tac, a tableaux-like proof tactic for Isabelle. Fast_tac automatically finds proofs that consist only of so-called obvious inferences [5, 21]. Crucially, the tactic is itself generic. It works in most of Isabelle's classical logics and reasons directly with user-defined primitives. <p> The notion of normal form would depend upon the precise set of primitives being supported in a particular call to the prover. Tableau rules can be expressed in Isabelle's meta-logic and given to tools such as Fast_tac for execution on Isabelle's proof engine <ref> [17] </ref>. To improve upon Fast_tac, I have written a generic tableau prover from scratch. It is independent of Isabelle's proof mechanisms, but its design is constrained by the requirements of integration and compatibility. <p> Both of these complications could render the resulting tableau proof incorrect; Isabelle must check the tableau proof to ensure soundness. 8.1 The Translation of Isabelle Rules The translation from Isabelle rules to tableau rules is largely straightforward. I have elsewhere described the connection between Isabelle and tableau rules <ref> [17] </ref>, and more details are available in the documentation [14, Chap. 14]. Some further points can be seen in the treatment of the natural deduction rule (8I).
Reference: [18] <author> Paulson, L. C., </author> <title> Proving properties of security protocols by induction, </title> <booktitle> In 10th Computer Security Foundations Workshop (1997), </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 70-83 </pages>
Reference-contexts: Second, it describes the prover's integration with Isabelle and how compatibility constraints were overcome. Both aspects of the work are pragmatic. The goal was to improve upon Isabelle's performance on hard problems arising in domains such as the verification of cryptographic protocols <ref> [18] </ref>. Some well-known theoretical refinements turned out to have little measurable benefit. Even the most basic theoretical properties, soundness and completeness, are not paramount. Soundness is not essential because the final proof is given to Isabelle for checking, though we want few proofs to fail. <p> A preliminary rewriting phase could eliminate these symbols, but many application domains cannot easily be reduced to first-order logic. Examples are those involving inductive definitions, such as the -calculus [12] and my models of security protocols <ref> [18] </ref>. Binding constructs such as S x2A B (x) and fx j (x)g are common in set theory, which is as fundamental to Isabelle/HOL as it is to Isabelle/ZF. A generic tableau prover therefore needs a higher-order syntax: a syntax that includes the -calculus. <p> First-order problems allow comparison with other systems, but are of little relevance to Isabelle. Set theory problems are more relevant. Blast_tac is most important in application domains such as security protocols <ref> [18] </ref>, whose use of inductive definitions cannot easily be reduced to first-order logic. <p> Regarding (2), Blast_tac is certainly useful, though it is not a killer tool. Its complete treatment of quantifiers makes little difference in practice, which comes as a surprise. It makes some proofs significantly faster, and some proof scripts shorter. Most security protocol proofs <ref> [18] </ref> consist of calls to Blast_tac on the simplified subgoals arising from induction. Each subgoal corresponds to one protocol action, and typically is proved by one Blast_tac call, using relevant lemmas.
Reference: [19] <author> Paulson, L. C., Gr~abczewski, K., </author> <title> Mechanizing set theory: Cardinal arithmetic and the axiom of choice, </title> <note> Journal of Automated Reasoning 17, 3 (Dec. </note> <year> 1996), </year> <pages> 291-323 </pages>
Reference-contexts: Some of its logics, such as ZF set theory <ref> [19] </ref>, are essentially typeless: types serve only to prevent absurd expressions like S S ). Other logics, such as higher-order logic (HOL), are not only typed but provide polymorphism and overloading. Omitting types helps make the tableau prover more efficient than Isa-belle's proof engine.
Reference: [20] <author> Pelletier, F. J., </author> <title> Seventy-five problems for testing automatic theorem provers, </title> <note> Journal of Automated Reasoning 2 (1986), 191-216, Errata, JAR 4 (1988), 235-236 and JAR 18 (1997), 135 </note>
Reference-contexts: Although it is far from being the top-performing prover, it is much better than Fast_tac on standard benchmarks such as Pelletier's problems <ref> [20] </ref>. Leantap proves the first 46 problems in under half a second each, while Fast_tac takes several seconds for some of them and 4 3 DESIGNING THE PROVER cannot prove others at all. Leantap's simplicity and clarity make it a good framework on which to build other provers. <p> Experiments, mainly on Pelletier's examples <ref> [20] </ref>, found that the first example made little difference in practice. One proof (problem 43) got shorter, but the runtime actually rose due to the increased branching factor! I did not investigate the second liberalization. <p> The numbered problems are those of Pelletier <ref> [20] </ref>; problem 34 is also known as Andrews' Challenge.
Reference: [21] <author> Rudnicki, P., </author> <title> Obvious inferences, </title> <journal> Journal of Automated Reasoning 3, </journal> <volume> 4 (1987), </volume> <pages> 383-393 </pages>
Reference-contexts: This paper describes a new tableau prover and its integration with Isabelle. I have previously [17] described Fast_tac, a tableaux-like proof tactic for Isabelle. Fast_tac automatically finds proofs that consist only of so-called obvious inferences <ref> [5, 21] </ref>. Crucially, the tactic is itself generic. It works in most of Isabelle's classical logics and reasons directly with user-defined primitives. New concepts from the application domain can be supported without the search-space explosion that would result from simply adding their definitions to the tableau.
Reference: [22] <author> Stickel, M. E., </author> <title> A Prolog technology theorem prover: Implementation by an extended Prolog compiler, </title> <journal> Journal of Automated Reasoning 4, </journal> <volume> 4 (1988), </volume> <pages> 353-380 </pages>
Reference-contexts: Fast_tac can use depth-first search because of its incomplete treatment of fl-rules, which ensures termination but proves only obvious [5] theorems. * The resource bounded by iterative deepening is mainly the number of fl-rule applications, but it includes other `costs' of the proof. (For Stickel's Prolog Technology Theorem Prover <ref> [22] </ref>, the resource is the number of subgoals allowed in a proof.) * Formulas in a branch are considered in a stack discipline.
References-found: 22

