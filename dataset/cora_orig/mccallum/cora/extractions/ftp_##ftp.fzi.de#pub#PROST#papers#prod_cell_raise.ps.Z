URL: ftp://ftp.fzi.de/pub/PROST/papers/prod_cell_raise.ps.Z
Refering-URL: http://www.fzi.de/prost/publications/overview.html
Root-URL: http://www.fzi.de
Title: Stepwise Refinement of Control Software A Case Study Using RAISE  
Author: Francois Erasmy Emil Sekerinski 
Address: Haid-und-Neu Strasse 10-14, 76131 Karlsruhe, Germany  
Affiliation: Forschungszentrum Informatik Karlsruhe,  
Abstract: We develop a control program for a realistic automation problem by stepwise refinement. We focus on exemplifying appropriate levels of abstraction for the refinement steps. By using phases as a means for abstraction, safety requirements are specified on a high level of abstraction and can be verified using process algebra. The case study is carried out using the RAISE specification language, and we report on some experiences using the RAISE tool set. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. J. R. </author> <title> Back: Refinement Calculus Part II: Parallel and Reactive Programs. </title> <editor> In J. W. deBakker, W. P. deRoever (eds.): </editor> <booktitle> Stepwise Refinement of Distributed Systems. Lecture Notes in Computer Science 430, </booktitle> <publisher> Springer 1990. </publisher>
Reference-contexts: Only the interaction requirements have to be expressed in a slightly different form without interlocking. Viewing the initial interaction of a phase as a guard, there is a strong similarity between phases and guarded commands as used by the Unity logic [3] and action systems <ref> [1] </ref>. We expect that a similar development can be expressed with those formalisms. Finally, we propose a number of extensions to the approach. Further Refinement Steps. If channel operations were supported by the hardware and the compiler (e.g. as in occam on the Transputer), no additional steps would be necessary.
Reference: 2. <author> G. Berry, G. Gonthier: </author> <title> The Esterel synchronous programming language: Design, semantics, </title> <booktitle> implementation. Science of Computer Programming 19 (1992). </booktitle>
Reference-contexts: on j off; Motor == run j halt; BiMotor == fwd j back j halt channel beltSensorOn; beltSensorOff : Sensor; beltMotor : Motor; tableUp; tableDown; tableAtBelt; tableAtRobot : Sensor; 6 The same approach is used in occam [7]. 7 This assumption is common in approaches for reactive systems like Esterel <ref> [2] </ref> and StateCharts [4]. 12 tableRot; tableElev : BiMotor; pressUp; pressDown : Sensor; pressMotor : BiMotor; robotPos1; robotPos2; robotPos3 : Sensor; arm1Extended; arm1Retracted; arm2Extended; arm2Retracted : Sensor; robotRot; arm1Motor; arm2Motor : BiMotor; arm1Gripper; arm2Gripper : Gripper For the conveyor-belt, the actions moveBelt and deliverBelt simply mean letting the belt motor run
Reference: 3. <author> K. M. Chandy, J. Misra: </author> <title> Parallel Program Design A Foundation. </title> <publisher> Addison-Wesley 1988. </publisher>
Reference-contexts: Only the interaction requirements have to be expressed in a slightly different form without interlocking. Viewing the initial interaction of a phase as a guard, there is a strong similarity between phases and guarded commands as used by the Unity logic <ref> [3] </ref> and action systems [1]. We expect that a similar development can be expressed with those formalisms. Finally, we propose a number of extensions to the approach. Further Refinement Steps.
Reference: 4. <author> D. Harel: StateCharts: </author> <title> A Visual Formalism for Complex Systems. </title> <booktitle> Science of Computer Programming 8 (1987). </booktitle>
Reference-contexts: Motor == run j halt; BiMotor == fwd j back j halt channel beltSensorOn; beltSensorOff : Sensor; beltMotor : Motor; tableUp; tableDown; tableAtBelt; tableAtRobot : Sensor; 6 The same approach is used in occam [7]. 7 This assumption is common in approaches for reactive systems like Esterel [2] and StateCharts <ref> [4] </ref>. 12 tableRot; tableElev : BiMotor; pressUp; pressDown : Sensor; pressMotor : BiMotor; robotPos1; robotPos2; robotPos3 : Sensor; arm1Extended; arm1Retracted; arm2Extended; arm2Retracted : Sensor; robotRot; arm1Motor; arm2Motor : BiMotor; arm1Gripper; arm2Gripper : Gripper For the conveyor-belt, the actions moveBelt and deliverBelt simply mean letting the belt motor run until the belt
Reference: 5. <author> A. Haxthausen, C. George: </author> <title> A Concurrency Case Study Using RAISE. </title> <editor> In J. C. P. Woodcock, P. G. Larsen (eds.): </editor> <booktitle> Proceedings of FME'93: Industrial Strength Formal Methods, Odense, Denmark, Lecture Notes in Computer Science 670, </booktitle> <publisher> Springer 1993. </publisher>
Reference-contexts: The development is carried out using the RAISE specification language (RSL) [12] and all proofs were done with the RAISE tool set. RAISE was developed at CRI Denmark as part of an ESPRIT project with the goal of an industrial-strength formal development method. It has been applied in <ref> [5] </ref> to the development of a control program for a gas burner. RSL is a very rich language supporting many different specification styles. We use axiomatic definition of communicating (recursive) functions in the initial steps and imperative constructs later on. <p> It might even be interesting to arrange the machines in an "inheritance hierarchy" depending on their capabilities. For combining modules, RSL provides extension, hiding, renaming and parameterization. Their use for extracting reusable components in the example of a control program for a gas burner is presented in <ref> [5] </ref>. Acknowledgements. We are indebted to C. Lewerentz, A. Ruping and Th. Lind-ner for many stimulating discussions and to the reviewers for their valuable comments. This work is supported by the German Ministry of Research and Technology (BMFT) under grant number 01 IS 203 M, project KorSo.
Reference: 6. <author> C. A. R. Hoare: </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International 1985. </booktitle>
Reference-contexts: A phase represents the behaviour of a machine in a certain time span. Using phases, there is no need to explicitly introduce time. Interaction requirements can be expressed with process languages like CSP <ref> [6] </ref> or CCS [10], and their corresponding algebra can be used for verification. In later steps, phases are refined into sequences of movements. Due to the compositionality of the proof technique, the verified properties also hold for the refined specification. <p> Although the method of describing the production cell by parallel processes structured in phases is presented here using RSL, a similar development can be carried out using CSP <ref> [6] </ref> or CCS [10]. Only the interaction requirements have to be expressed in a slightly different form without interlocking. Viewing the initial interaction of a phase as a guard, there is a strong similarity between phases and guarded commands as used by the Unity logic [3] and action systems [1].
Reference: 7. <author> INMOS Limited: </author> <title> occam Programming Manual. </title> <booktitle> Prentice-Hall International 1984. </booktitle>
Reference-contexts: The actuators and sensors are defined by: type Sensor = Unit; Gripper == on j off; Motor == run j halt; BiMotor == fwd j back j halt channel beltSensorOn; beltSensorOff : Sensor; beltMotor : Motor; tableUp; tableDown; tableAtBelt; tableAtRobot : Sensor; 6 The same approach is used in occam <ref> [7] </ref>. 7 This assumption is common in approaches for reactive systems like Esterel [2] and StateCharts [4]. 12 tableRot; tableElev : BiMotor; pressUp; pressDown : Sensor; pressMotor : BiMotor; robotPos1; robotPos2; robotPos3 : Sensor; arm1Extended; arm1Retracted; arm2Extended; arm2Retracted : Sensor; robotRot; arm1Motor; arm2Motor : BiMotor; arm1Gripper; arm2Gripper : Gripper For the
Reference: 8. <author> C. Lewerentz, Th. Lindner (eds.): </author> <title> Case Study "Production Cell": A Comparative Study in Formal Software Development, </title> <note> in preparation. </note>
Reference-contexts: The production cell is installed in an industrial plant in Karlsruhe. It has been rebuilt in a slightly modified form as a model on which this case study is based, and which now serves as a test case for comparing and evaluating formal methods <ref> [8, 11] </ref>. 2 Structure of the paper. The next section presents the case study informally. The following five sections successively develop the control program, each step refining the previous one.
Reference: 9. <author> Z. Manna, A. Pnueli: </author> <title> A Temporal Proof Methodology for Reactive Systems. </title> <editor> In M. Broy (ed.) </editor> <booktitle> Program Design Calculi. NATO ASI Series, </booktitle> <publisher> Springer 1993. </publisher>
Reference-contexts: In later steps, phases are refined into sequences of movements. Due to the compositionality of the proof technique, the verified properties also hold for the refined specification. Alternatively, interaction requirements can be expressed using temporal logic <ref> [9] </ref>: With the "always" operator, the requirement that "the motor closing the press must never be turned on if the robot arm is in or near the press" can be formalized, if the state of the machines is given by (global) variables.
Reference: 10. <author> R. Milner: </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International 1989. </booktitle>
Reference-contexts: A phase represents the behaviour of a machine in a certain time span. Using phases, there is no need to explicitly introduce time. Interaction requirements can be expressed with process languages like CSP [6] or CCS <ref> [10] </ref>, and their corresponding algebra can be used for verification. In later steps, phases are refined into sequences of movements. Due to the compositionality of the proof technique, the verified properties also hold for the refined specification. <p> Although the method of describing the production cell by parallel processes structured in phases is presented here using RSL, a similar development can be carried out using CSP [6] or CCS <ref> [10] </ref>. Only the interaction requirements have to be expressed in a slightly different form without interlocking. Viewing the initial interaction of a phase as a guard, there is a strong similarity between phases and guarded commands as used by the Unity logic [3] and action systems [1].
Reference: 11. <author> J. L. Petersen: </author> <title> A computer controlled forging machine. </title> <institution> Department of Computer Science, DTH Lyngby, </institution> <note> in preparation. 17 </note>
Reference-contexts: The production cell is installed in an industrial plant in Karlsruhe. It has been rebuilt in a slightly modified form as a model on which this case study is based, and which now serves as a test case for comparing and evaluating formal methods <ref> [8, 11] </ref>. 2 Structure of the paper. The next section presents the case study informally. The following five sections successively develop the control program, each step refining the previous one.
Reference: 12. <editor> The RAISE Language Group: </editor> <booktitle> The RAISE Specification Language. BCS Practi--tioner Series, Prentice-Hall International 1992. </booktitle>
Reference-contexts: The method presented is applicable for controlling interacting machines as they are typically found in production plants. In general, it is applicable to cooperating agents, where certain concurrent combinations of their actions must be prevented. The development is carried out using the RAISE specification language (RSL) <ref> [12] </ref> and all proofs were done with the RAISE tool set. RAISE was developed at CRI Denmark as part of an ESPRIT project with the goal of an industrial-strength formal development method. It has been applied in [5] to the development of a control program for a gas burner.
Reference: 13. <author> N. Wirth: </author> <title> Program Development by Stepwise Refinement. </title> <booktitle> Communications of the ACM 14 (1971). </booktitle>
Reference-contexts: This approach makes the development intellectually manageable by revealing the complexity gradually, thus keeping the correctness proof for each refinement steps simple and allowing for separate development of the components. This is well established for sequential programs <ref> [13] </ref>, but less well understood for reactive programs, i.e. programs maintaining a continuous interaction with their environment. The key problem is to find the right abstractions at each step.
References-found: 13

