URL: http://nugget.cs.ucla.edu:8001/~kenneth/research/csd-980033.ps
Refering-URL: http://nugget.cs.ucla.edu:8001/~kenneth/personal/research.html
Root-URL: http://www.cs.ucla.edu
Email: fkenneth,zwang,muntzg@cs.ucla.edu  
Title: Dynamic Reconfiguration of Sub-Optimal Parallel Query Execution Plans  
Author: Kenneth W. Ng Zhenghao Wang Richard R. Muntz 
Date: September 21, 1998  
Address: Los Angeles, CA 90095-1596  
Affiliation: Computer Science Department University of California  
Abstract: Existing query optimization methods do not satisfy some of today's query processing requirements. Typically, only coarse or inaccurate estimates of database statistics are available prior to query evaluation. On the other hand, massive database sizes and growing demands for sophisticated processing result in long-running queries in extensible Object-Relational DBMS, particularly in decision support, and in data warehousing analysis applications. Therefore changes in system configuration and resource availability during query evaluation are not unexpected and can result in deteriorated query performance. Considering a parallel query evaluation environment, we propose dynamic reconfiguration of sub-optimal parallel query execution plans (QEPs) to adapt QEPs to the environment as well as to refined estimates of data and query characteristics. To ensure correct query evaluation in the face of modification of the QEP, we propose an algorithm to coordinate the steps in a reconfiguration. We also present a taxonomy of user-defined operators which allow the dynamic optimizer to plan a reconfiguration and systematically evaluate alternatives for execution context checkpointing and restoration. A syntactic extension of SQL to expose the relevant characteristics of user defined functions in support of dynamic reconfiguration is proposed. An example from the experimental system is presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Antoshenkov. </author> <title> Dynamic query optimization in Rdb/VMS. </title> <booktitle> In Proceedings of the 9th International Conference on Data Engineering, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: low as possible makes the dynamic reconfiguring QEPs more beneficial. 5 Related Work There is some related work in this area (<ref> [1] </ref>, [16], [23]). Yet none of the existing work is completely satisfactory either only limited changes are allowed to QEPs or changes are restricted to built-in functions. For example, [1] allows only the change of built-in scan operator replacement. [16] proposed mid-query re-optimization of QEPs in a relational database environment. This work mainly addresses the inaccurate estimation of data characteristics such as selectivity.
Reference: [2] <author> A. Bricker, M. Litzkow, and M. Livny. </author> <type> Condor technical report. Technical Report CS-TR-92-1069, </type> <institution> Department of Computer Science, University of Wisconsin, Madison, </institution> <month> January </month> <year> 1992. </year> <title> Dynamic Reconfiguration of Sub-Optimal Parallel Query Execution Plans 31 </title>
Reference-contexts: For example, if the workload on machine Y becomes heavier, we might want to move the local aggregation UDF (provided it is the bottleneck) to another machine, say Z. operator relocation is similar to the process migration facility provided in other systems (e.g. Condor <ref> [2] </ref>, Utopia [26]). The major difference is that the semantics of operators may be exploited in the context of data processing to more efficiently implement migration. 2. <p> Therefore, a possible strategy is to delay the operation of capturing/restoring the execution context until a "context-free" point at which the operator returns to its initial context. Check-Point Checkpointing is a well-known technique (e.g., <ref> [2] </ref>) we can utilize. For dynamic QEP reconfiguration, instead of doing checkpoints periodically as in other systems, the reconfig-urator takes checkpoint record of scratchpad when this option is chosen for context management.
Reference: [3] <author> D. DeWitt. </author> <title> Parallel object-relational database systems: Challenges and opportunities. In Invited Talk, </title> <address> PDIS, </address> <year> 1996. </year>
Reference-contexts: On the other hand, we considered the dynamic reconfiguration of QEPs in a parallel execution environment. The reason is that users are going to expect full parallel support for all ADT extensions in an ORDBMS <ref> [3] </ref>. Parallelization is important for performance improvement to long running queries. As a consequence, more reconfiguration options are considered in our research. Further, we consider reconfiguration involving not only the built-in operators but also user-defined functions in an ORDBMS.
Reference: [4] <author> F. Fabbrocino, E. Shek, and R. Muntz. </author> <title> The design and implementation of the conquest query execution environment. </title> <type> Technical Report CSD-970029, </type> <institution> UCLA, </institution> <month> June </month> <year> 1997. </year>
Reference: [5] <author> P. Gassner, G.M. Lohman, K.B. Schiefer, and Y. Wang. </author> <title> Query optimization in the IBM DB2 family. </title> <journal> Data Engineering Bulletin, </journal> <volume> 16(4) </volume> <pages> 4-18, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: For example, the typical built-in functions available in DB2/SQL include: numeric operators +; ; fl; =, string operator jj (concatenation), SUBSTR (substring), and aggregate functions COUNT, SUM, AVG, MAX, MIN ([12]). Knowledge about an operation and input ordering can be exploited for efficient performance. A simple example from <ref> [5] </ref> SELECT MAX (ORDER NUMBER) FROM SALES illustrates a case in which only the first data object needs to be retrieved by using a descending index on ORDER NUMBER.
Reference: [6] <author> K.M. Goudarzi and J. Kramer. </author> <title> Maintaining node consistency in the face of dynamic change. </title> <booktitle> In Proceedings of ICCDS, Annapolis, Maryland, </booktitle> <pages> pages 62-69, </pages> <month> May </month> <year> 1996. </year>
Reference: [7] <author> G. Graefe, R.L. Cole, D.L. Davison, W.J. McKenna, and R.H. Wolniewicz. </author> <title> Extensible Query Optimization and Parallel Execution in Volcano. </title> <booktitle> In Query Processing for Advanced Database Systems, </booktitle> <pages> pages 305-335. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, California, </address> <year> 1994. </year>
Reference: [8] <author> G. Graefe and W.J. McKenna. </author> <title> The Volcano Optimizer Generator: Extensibility and Efficient Search. </title> <booktitle> In Proceedings of the Ninth International Conference on Data Engineering, </booktitle> <address> April 19-23, 1993, Vienna, Austria, </address> <publisher> IEEE Computer Society, </publisher> <pages> pages 209-218, </pages> <month> April </month> <year> 1993. </year>
Reference: [9] <author> L.M. Haas, W. Chang, G.M. Lohman, J. McPherson, P.F. Wilms, G. Lapis, B.G. Lindsay, H. Pirahesh, M.J. Carey, and E.J. Shekita. </author> <title> Starburst mid-flight: As the dust clears. </title> <journal> IEEE Transaction on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 143-160, </pages> <year> 1990. </year>
Reference-contexts: Phase 2 creates a new plan for processing the remainder of the query. Our work considers more generic reconfiguration cases and provides methods for context capturing and restoring other than intermediate results materialization. User-Defined Functions are widely studied in recent years ([11], [10], <ref> [9] </ref>, [21], [20], [19], [15]). Yet most published work discusses only optimization before query evaluation starts.
Reference: [10] <author> J.M. Hellerstein and J.F. Naughton. </author> <title> Query execution techniques for caching expensive methods. </title> <booktitle> In Proceedings of ACM SIGMOD, </booktitle> <pages> pages 423-434, </pages> <year> 1996. </year>
Reference-contexts: Phase 2 creates a new plan for processing the remainder of the query. Our work considers more generic reconfiguration cases and provides methods for context capturing and restoring other than intermediate results materialization. User-Defined Functions are widely studied in recent years ([11], <ref> [10] </ref>, [9], [21], [20], [19], [15]). Yet most published work discusses only optimization before query evaluation starts.
Reference: [11] <author> J.M. Hellerstein and M. Stonebraker. </author> <title> Predicate migration: Optimizing queries with expensive predicates. </title> <booktitle> In Proceedings of ACM SIGMOD, </booktitle> <pages> pages 267-276, </pages> <year> 1993. </year>
Reference: [12] <author> IBM. </author> <title> SQL Reference. </title> <note> http://www.software.ibm.com/data/db2/library, 1998. </note>
Reference: [13] <author> Informix. </author> <title> Illustra User Manual. </title> <note> http://www.informix.com/answers, February 1998. </note>
Reference-contexts: It allows the summary information concerning previously processed data items to be carried forward to the next execution of the same UDF, and influence the behavior of future computations. Further, an ORDBMS such as Informix Illustra supports operators that compute a function in an object-at-a-time fashion <ref> [13] </ref>. This design resembles the Open-Next-Close query evaluation paradigm [7][8][4][22] that supports data stream processing. In this paper, we assume that all operators run in a stream processing environment and each execution of an operator is called an iteration.
Reference: [14] <author> IONA. </author> <title> OrbixWeb Programmer's Reference. </title> <booktitle> IONA Technologies PLC, </booktitle> <month> November </month> <year> 1997. </year>
Reference-contexts: For efficiency output records are normally batched for transmission to consumer. A receive operation starts when the input thread receives a data transmission request from the 1 In practice, we implemented input threads with Orbix's thread-per-request technology <ref> [14] </ref>. Therefore input threads are dynamically created upon request for data dispatch and are deleted after each request is processed. Dynamic Reconfiguration of Sub-Optimal Parallel Query Execution Plans 13 producer.
Reference: [15] <author> M. Jaedicke and B. Mitschang. </author> <title> On parallel processing of aggregate and scalar functions in object-relational dbms. </title> <booktitle> In Proceedings of ACM SIGMOD, </booktitle> <pages> pages 379-389, </pages> <year> 1998. </year> <title> Dynamic Reconfiguration of Sub-Optimal Parallel Query Execution Plans 32 </title>
Reference-contexts: Phase 2 creates a new plan for processing the remainder of the query. Our work considers more generic reconfiguration cases and provides methods for context capturing and restoring other than intermediate results materialization. User-Defined Functions are widely studied in recent years ([11], [10], [9], [21], [20], [19], <ref> [15] </ref>). Yet most published work discusses only optimization before query evaluation starts. In [21], the PREDATOR database system, which views the world as an integrated collection of data types, each of which supports a declarative, optimizable query language, proposed optimizing queries in an ORDBMS with enhanced abstract data types [20]. <p> These efforts also focus their attention on the optimization with UDFs before the query evaluation starts. <ref> [15] </ref> studied the execution of user-defined functions using data parallelism. It is interesting to compare our classification of UDFs for reconfiguration to their classification for parallelization. [15] can be considered as an extension of [18] where the intrinsic characteristics of stream processing were analyzed. <p> These efforts also focus their attention on the optimization with UDFs before the query evaluation starts. <ref> [15] </ref> studied the execution of user-defined functions using data parallelism. It is interesting to compare our classification of UDFs for reconfiguration to their classification for parallelization. [15] can be considered as an extension of [18] where the intrinsic characteristics of stream processing were analyzed. Similar reasoning is used in our UDF classification.
Reference: [16] <author> N. Kabra and D.J. DeWitt. </author> <title> Efficient mid-query re-optimization of sub-optimal query execution plans. </title> <booktitle> In Proceedings of ACM SIGMOD, </booktitle> <year> 1998. </year>
Reference-contexts: In practice, since the plan search cost and configuration prediction cost are relative fixed for all QEPs and reconfiguration forms, to keep the reconfiguration cost as low as possible makes the dynamic reconfiguring QEPs more beneficial. 5 Related Work There is some related work in this area ([1], <ref> [16] </ref>, [23]). Yet none of the existing work is completely satisfactory either only limited changes are allowed to QEPs or changes are restricted to built-in functions. For example, [1] allows only the change of built-in scan operator replacement. [16] proposed mid-query re-optimization of QEPs in a relational database environment. <p> 5 Related Work There is some related work in this area ([1], <ref> [16] </ref>, [23]). Yet none of the existing work is completely satisfactory either only limited changes are allowed to QEPs or changes are restricted to built-in functions. For example, [1] allows only the change of built-in scan operator replacement. [16] proposed mid-query re-optimization of QEPs in a relational database environment. This work mainly addresses the inaccurate estimation of data characteristics such as selectivity. Using statistics collected at run-time, the system reconfigures the unprocessed portion of a QEP, hence improving the performance. Intermediate results are materialized for plan modification. <p> Lastly, to materialize intermediate results may not be Dynamic Reconfiguration of Sub-Optimal Parallel Query Execution Plans 29 practical in the case of the large volume data sets. Therefore, other methods for capturing/restoring execution context are desired. Using a similar reconfiguration technique as in <ref> [16] </ref> (materializing intermediate results), [23] proposed a two-phase (plan rescheduling and operator synthesis) scrambling method to modify a query plan which is discovered to be suboptimal due to data arrival delays. Phase 1 identifies the non-blocked sub-trees and materializes the results produced by sub-tress.
Reference: [17] <author> J. Kramer and J. Magee. </author> <title> The evolving philosophers problem: Dynamic change management. </title> <journal> IEEE Transactions On Software Engineering, </journal> <volume> 15(11) </volume> <pages> 1293-1306, </pages> <month> November </month> <year> 1990. </year>
Reference: [18] <author> T.Y.Cliff Leung and Richard R. Muntz. </author> <title> Query processing for temporal databases. </title> <type> Technical Report CSD-890024, </type> <institution> UCLA, </institution> <month> April </month> <year> 1989. </year>
Reference-contexts: It is interesting to compare our classification of UDFs for reconfiguration to their classification for parallelization. [15] can be considered as an extension of <ref> [18] </ref> where the intrinsic characteristics of stream processing were analyzed. Similar reasoning is used in our UDF classification. Context rebuildable UDFs usually require input streams in a certain sort ordering such that the effect of the records read first will disappear before the effect of those records read latter.
Reference: [19] <author> A.P. Marathe and K. Salem. </author> <title> A language for manipulating arrays. </title> <booktitle> In Proc. of the 23rd VLDB Conference, </booktitle> <address> Athens, Greece, </address> <pages> pages 46-55, </pages> <year> 1997. </year>
Reference-contexts: Phase 2 creates a new plan for processing the remainder of the query. Our work considers more generic reconfiguration cases and provides methods for context capturing and restoring other than intermediate results materialization. User-Defined Functions are widely studied in recent years ([11], [10], [9], [21], [20], <ref> [19] </ref>, [15]). Yet most published work discusses only optimization before query evaluation starts. <p> A similar effort, but more specific to the data type of multi-dimensional array, can be found in <ref> [19] </ref>, which proposed an algebra for multidimensional array data (AML) such that optimizer can apply rewrite rules to those operators specific to array operations. These efforts also focus their attention on the optimization with UDFs before the query evaluation starts. [15] studied the execution of user-defined functions using data parallelism.
Reference: [20] <author> P. Seshadri, M. Livny, and R. Ramakrishnan. </author> <title> The case for enhanced abstract data types. </title> <booktitle> In Proc. of 1997 VLDB conference, </booktitle> <pages> pages 66-75, </pages> <year> 1997. </year>
Reference-contexts: Phase 2 creates a new plan for processing the remainder of the query. Our work considers more generic reconfiguration cases and provides methods for context capturing and restoring other than intermediate results materialization. User-Defined Functions are widely studied in recent years ([11], [10], [9], [21], <ref> [20] </ref>, [19], [15]). Yet most published work discusses only optimization before query evaluation starts. <p> Yet most published work discusses only optimization before query evaluation starts. In [21], the PREDATOR database system, which views the world as an integrated collection of data types, each of which supports a declarative, optimizable query language, proposed optimizing queries in an ORDBMS with enhanced abstract data types <ref> [20] </ref>. A similar effort, but more specific to the data type of multi-dimensional array, can be found in [19], which proposed an algebra for multidimensional array data (AML) such that optimizer can apply rewrite rules to those operators specific to array operations.
Reference: [21] <author> P. Seshadri and M. Paskin. </author> <title> Predator: An OR-DBMS with Enhanced Data Types. </title> <booktitle> In Proc. of 1997 ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1997. </year>
Reference-contexts: Phase 2 creates a new plan for processing the remainder of the query. Our work considers more generic reconfiguration cases and provides methods for context capturing and restoring other than intermediate results materialization. User-Defined Functions are widely studied in recent years ([11], [10], [9], <ref> [21] </ref>, [20], [19], [15]). Yet most published work discusses only optimization before query evaluation starts. In [21], the PREDATOR database system, which views the world as an integrated collection of data types, each of which supports a declarative, optimizable query language, proposed optimizing queries in an ORDBMS with enhanced abstract data <p> Our work considers more generic reconfiguration cases and provides methods for context capturing and restoring other than intermediate results materialization. User-Defined Functions are widely studied in recent years ([11], [10], [9], <ref> [21] </ref>, [20], [19], [15]). Yet most published work discusses only optimization before query evaluation starts. In [21], the PREDATOR database system, which views the world as an integrated collection of data types, each of which supports a declarative, optimizable query language, proposed optimizing queries in an ORDBMS with enhanced abstract data types [20].
Reference: [22] <author> E. Shek, R.R. Muntz, M. Mesrobian, and K. Ng. </author> <title> Scalable exploratory data mining of distributed geoscientific data. </title> <booktitle> In Second International Conference on Knowledge Discovery and Data Mining, </booktitle> <address> Portland, Oregon, </address> <month> August </month> <year> 1996. </year>
Reference: [23] <author> T. Urhan, M.J. Franklin, and L. Amsaleg. </author> <title> Cost-based query scrambling for initial delays. </title> <booktitle> In Proceedings of ACM SIGMOD, </booktitle> <year> 1998. </year>
Reference-contexts: In practice, since the plan search cost and configuration prediction cost are relative fixed for all QEPs and reconfiguration forms, to keep the reconfiguration cost as low as possible makes the dynamic reconfiguring QEPs more beneficial. 5 Related Work There is some related work in this area ([1], [16], <ref> [23] </ref>). Yet none of the existing work is completely satisfactory either only limited changes are allowed to QEPs or changes are restricted to built-in functions. For example, [1] allows only the change of built-in scan operator replacement. [16] proposed mid-query re-optimization of QEPs in a relational database environment. <p> Lastly, to materialize intermediate results may not be Dynamic Reconfiguration of Sub-Optimal Parallel Query Execution Plans 29 practical in the case of the large volume data sets. Therefore, other methods for capturing/restoring execution context are desired. Using a similar reconfiguration technique as in [16] (materializing intermediate results), <ref> [23] </ref> proposed a two-phase (plan rescheduling and operator synthesis) scrambling method to modify a query plan which is discovered to be suboptimal due to data arrival delays. Phase 1 identifies the non-blocked sub-trees and materializes the results produced by sub-tress.
Reference: [24] <author> Z. Wang. </author> <title> Conquest Dynamic Optimizer Design. </title> <institution> Computer Science Department, UCLA, </institution> <note> http://dml.cs.ucla.edu/~zwang/research/Conquest, July 1998. </note>
Reference-contexts: We use a dynamic programming technique to find the plan with maximum estimated throughput for a finite number of future time periods. We describe the algorithm briefly here, and the details can be found in <ref> [24] </ref> [25]. The (estimated) residual execution time from the point at which the reoptimization starts is divided into fixed length time periods. System statistics and query characteristics at the beginning of each period are estimated based on run-time measurement information.
Reference: [25] <author> J. Yang, K. Ng, F. Fabbrocino, and R. Muntz. </author> <title> Dynamic query optimization with imprecise probabilities. </title> <institution> http://dml.cs.ucla.edu/~kenneth/research/dqo.ps, Computer Science Department, UCLA, </institution> <month> February </month> <year> 1998. </year>
Reference-contexts: We use a dynamic programming technique to find the plan with maximum estimated throughput for a finite number of future time periods. We describe the algorithm briefly here, and the details can be found in [24] <ref> [25] </ref>. The (estimated) residual execution time from the point at which the reoptimization starts is divided into fixed length time periods. System statistics and query characteristics at the beginning of each period are estimated based on run-time measurement information.
Reference: [26] <author> S. Zhou, J. Wang, X. Zheng, and P. Delisle. </author> <title> Utopia: A load sharing facility for large, heterogeneous distributed computer systems. </title> <type> Technical Report CSRI-257, </type> <institution> University of Toronto, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: For example, if the workload on machine Y becomes heavier, we might want to move the local aggregation UDF (provided it is the bottleneck) to another machine, say Z. operator relocation is similar to the process migration facility provided in other systems (e.g. Condor [2], Utopia <ref> [26] </ref>). The major difference is that the semantics of operators may be exploited in the context of data processing to more efficiently implement migration. 2.
References-found: 26

