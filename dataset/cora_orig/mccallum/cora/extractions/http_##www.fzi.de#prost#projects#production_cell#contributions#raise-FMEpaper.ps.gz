URL: http://www.fzi.de/prost/projects/production_cell/contributions/raise-FMEpaper.ps.gz
Refering-URL: http://www.fzi.de/prost/projects/production_cell/contributions/RAISE.html
Root-URL: http://www.fzi.de
Email: erasmy,sekerinski@fzi.de  
Title: Stepwise Refinement of Control Software A Case Study Using RAISE  
Author: Francois Erasmy Emil Sekerinski 
Address: Haid-und-Neu Strasse 10-14, 76131 Karlsruhe, Germany  
Affiliation: Forschungszentrum Informatik Karlsruhe,  
Abstract: We develop a control program for a realistic automatization problem by stepwise refinement. Doing so, we exemplify appropriate levels of abstraction for the refinement steps. By using phases, safety requirements are specified on a high level of abstraction and verified using process algebra. The case study is carried out using the RAISE specification language. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Back, R. J. R. </author> <title> Refinement Calculus Part II: Parallel and Reactive Programs. </title> <editor> In J. W. deBakker, W. P. deRoever (Eds.) </editor> <booktitle> Stepwise Refinement of Distributed Systems. Lecture Notes in Computer Science 430, </booktitle> <publisher> Springer-Verlag 1990. </publisher>
Reference-contexts: Only the interaction requirements have to be expressed in a slightly different form without interlocking. Viewing the initial interaction of a phase as a guard, there is a strong similarity between phases and guarded commands as used by the Unity logic [2] and action systems <ref> [1] </ref>. We expect that a similar development can be expressed with those formalisms. Finally, we propose a number of extension to the approach. Further Refinement Steps If channel operations were supported by the hardware and the compiler (e.g. as in OCCAM on the Transputer), no additional steps would be necessary.
Reference: 2. <author> Chandy, K. M. and J. Misra. </author> <title> Parallel Program Design A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Only the interaction requirements have to be expressed in a slightly different form without interlocking. Viewing the initial interaction of a phase as a guard, there is a strong similarity between phases and guarded commands as used by the Unity logic <ref> [2] </ref> and action systems [1]. We expect that a similar development can be expressed with those formalisms. Finally, we propose a number of extension to the approach.
Reference: 3. <author> Haxthausen, A. and C. George. </author> <title> A Concurrency Case Study Using RAISE. </title> <editor> In J. C. P. Woodcock, P. G. Larsen (Eds.) </editor> <booktitle> Proceedings of FME'93: Industrial Strength Formal Methods, Odense, Denmark, Lecture Notes in Computer Science 670, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: We use axiomatic definition of communicating (recursive) functions in the initial steps and imperative constructs later on. Especially, we make use of the interlocking operator (-k) for expressing interaction requirements, and of the refinement relation provided by RAISE. RAISE has also been used in <ref> [3] </ref> for developing a control program for a gas burner. From our view, the gas burner is a single machine, with complex dependencies between its sensors and actuators. The production cell consists of several simpler machines, where complexity arises in their interaction, which is the focus of this work.
Reference: 4. <author> Hoare, C. A. R. </author> <title> Communicating Sequential Processes, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1985. </year>
Reference-contexts: Using phases, there is no need to explicitly introduce time. Interaction require-ments can be expressed with process languages like CSP <ref> [4] </ref> or CCS [7], and their corresponding algebra can be used for verification. In later steps, phases are refined into sequences of movements. Due to the compositionality of the proof technique, the verified properties also hold for the refined specification. <p> Although the method of describing the production cell by parallel processes structured in phases is presented here using RSL, a similar development can be carried out using CSP <ref> [4] </ref> or CCS [7]. Only the interaction requirements have to be expressed in a slightly different form without interlocking. Viewing the initial interaction of a phase as a guard, there is a strong similarity between phases and guarded commands as used by the Unity logic [2] and action systems [1].
Reference: 5. <author> Lewerentz, C. and T. Lindner (Eds.), </author> <title> Case Study "Production Cell": A Comparative Study in Formal Software Development, </title> <note> accepted for publication. </note>
Reference-contexts: The production cell is installed in an industrial plant in Karlsruhe and was our main initial motivation. It has been rebuilt in a slightly modified form as a model which now serves as a test case for comparing and evaluating formal methods <ref> [5, 8] </ref>. Structure of the paper. The next section presents the case study informally. The following five sections successively develop the control program, each step refining the previous one.
Reference: 6. <author> Manna, Z. and A. </author> <title> Pnueli A Temporal Proof Methodology for Reactive Systems. </title> <editor> In M. Broy (Ed.) </editor> <booktitle> Program Design Calculi, NATO ASI Series, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In later steps, phases are refined into sequences of movements. Due to the compositionality of the proof technique, the verified properties also hold for the refined specification. Alternatively, interaction requirements can be expressed using temporal logic <ref> [6] </ref>: With the "always" operator, we can formalize the requirement that "the motor closing the press must never be turned on if the robot arm is in or near the press". By using an abstraction by phases, we can express this requirement without explicitly referring to time.
Reference: 7. <author> Milner, R. </author> <title> Communication and Concurrency, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1989. </year>
Reference-contexts: Using phases, there is no need to explicitly introduce time. Interaction require-ments can be expressed with process languages like CSP [4] or CCS <ref> [7] </ref>, and their corresponding algebra can be used for verification. In later steps, phases are refined into sequences of movements. Due to the compositionality of the proof technique, the verified properties also hold for the refined specification. <p> Although the method of describing the production cell by parallel processes structured in phases is presented here using RSL, a similar development can be carried out using CSP [4] or CCS <ref> [7] </ref>. Only the interaction requirements have to be expressed in a slightly different form without interlocking. Viewing the initial interaction of a phase as a guard, there is a strong similarity between phases and guarded commands as used by the Unity logic [2] and action systems [1].
Reference: 8. <author> Petersen, J. L. </author> <note> A computer controlled forging machine Department of Computer Science, DTH Lyngby. in preparation. </note>
Reference-contexts: The production cell is installed in an industrial plant in Karlsruhe and was our main initial motivation. It has been rebuilt in a slightly modified form as a model which now serves as a test case for comparing and evaluating formal methods <ref> [5, 8] </ref>. Structure of the paper. The next section presents the case study informally. The following five sections successively develop the control program, each step refining the previous one.
Reference: 9. <author> The RAISE Language Group. </author> <title> The RAISE Specification Language, BCS Practitioner Series, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1992. </year> <month> 15 </month>
Reference-contexts: The technical contribution of this paper can be seen as a way of expressing these type of temporal invariance requirements without temporal logic. The development is carried out using the RAISE specification language (RSL) <ref> [9] </ref> and all proofs were done with the RAISE tool set. RAISE was developed at CRI Denmark as part of an ESPRIT project with the goal of an industrial-strength formal development method. RSL supports many different specification styles.
Reference: 10. <author> Wirth, N. </author> <title> Program Development by Stepwise Refinement. </title> <journal> Communications of the ACM 14, </journal> <year> 1971. </year>
Reference-contexts: This approach makes the development intellectually manageable by keeping the proof obligation for the refinement steps simple and by allowing for separate development. The key problem is to find the right abstractions at each step. This is well understood for sequential programs <ref> [10] </ref>, but less understood for reactive programs, i.e. programs maintaining a continuous interaction with their environment. This paper exemplifies appropriate abstractions using the production cell. The crucial point is that safety requirements arise due to the interaction of machines.
References-found: 10

