URL: http://www.cs.dartmouth.edu/~cliff/papers/Contraction.ps.Z
Refering-URL: http://www.cs.dartmouth.edu/~cliff/papers/
Root-URL: http://www.cs.dartmouth.edu
Email: karger@theory.lcs.mit.edu  cliff@cs.dartmouth.edu  
Title: A New Approach to the Minimum Cut Problem  
Author: David R. Karger Clifford Stein 
Date: December 23, 1996  
Address: College  
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  Department of Computer Science Dartmouth  
Abstract: This paper presents a new approach to finding minimum cuts in undirected graphs. The fundamental principle is simple: the edges in a graph's minimum cut form an extremely small fraction of the graph's edges. Using this idea, we give a randomized, strongly polynomial algorithm that finds the minimum cut in an arbitrarily weighted undi-rected graph with high probability. The algorithm runs in O(n 2 log 3 n) time, a significant improvement over the previous ~ O(mn) time bounds based on maximum flows. It is simple and intuitive and uses no complex data structures. Our algorithm can be parallelized to run in RN C with n 2 processors; this gives the first proof that the minimum cut problem can be solved in RN C. The algorithm does more than find a single minimum cut; it finds all of them. With minor modifications, our algorithm solves two other problems of interest. Our algorithm finds all cuts with value within a multiplicative factor of ff of the minimum cut's in expected ~ O(n 2ff ) time, or in RN C with n 2ff processors. The problem of finding a minimum multiway cut of a graph into r pieces is solved in expected ~ O(n 2(r1) ) time, or in RN C with n 2(r1) processors. The "trace" of the algorithm's execution on these two problems forms a new compact data structure for representing all small cuts and all multiway cuts in a graph. This data structure can be efficiently transformed into the more standard cactus representation for minimum cuts. 
Abstract-found: 1
Intro-found: 1
Reference: [ABCC95] <author> David Appelgate, Robert Bixby, Vasek Chvaatal, and William Cook. </author> <title> Finding cuts in the tsp. </title> <type> Technical Report 95-05, </type> <institution> DIMACS, Rutgers University, </institution> <address> New Brunswick, NJ, </address> <year> 1995. </year>
Reference-contexts: They also reported that minimum cut problems are the bottleneck in many other cutting-plane based algorithms for combinatorial problems whose solutions induce connected graphs. Applegate et al. <ref> [App92, ABCC95] </ref> made similar observations and also noted that an algorithm to find all nearly minimum cuts might be even more useful. 1.3 History Several different approaches to finding minimum cuts have been investigated. Until recently, the most efficient algorithms used maximum flow computations. <p> This is made even worse by the fact that some minimum cuts may be produced many times by the algorithm. Applegate <ref> [App92, ABCC95] </ref> observed that there is a simple hashing technique that can be used to avoid outputting a cut more than once. At the beginning, assign to each vertex a random O (log n)-bit key. Whenever two vertices are merged by contractions, combine their keys with an exclusive-or.
Reference: [ACM92] <editor> ACM. </editor> <booktitle> Proceedings of the 24 th ACM Symposium on Theory of Computing. </booktitle> <publisher> ACM Press, </publisher> <month> May </month> <year> 1992. </year>
Reference: [ACM93] <editor> ACM-SIAM. </editor> <booktitle> Proceedings of the 4 th Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <month> January </month> <year> 1993. </year>
Reference: [ACM94] <editor> ACM. </editor> <booktitle> Proceedings of the 26 th ACM Symposium on Theory of Computing. </booktitle> <publisher> ACM Press, </publisher> <month> May </month> <year> 1994. </year>
Reference: [ACM96] <editor> ACM. </editor> <booktitle> Proceedings of the 28 th ACM Symposium on Theory of Computing. </booktitle> <publisher> ACM Press, </publisher> <month> May </month> <year> 1996. </year>
Reference: [App92] <institution> David Applegate. AT&T Bell Labs, </institution> <year> 1992. </year> <type> Personal Communication. </type>
Reference-contexts: They also reported that minimum cut problems are the bottleneck in many other cutting-plane based algorithms for combinatorial problems whose solutions induce connected graphs. Applegate et al. <ref> [App92, ABCC95] </ref> made similar observations and also noted that an algorithm to find all nearly minimum cuts might be even more useful. 1.3 History Several different approaches to finding minimum cuts have been investigated. Until recently, the most efficient algorithms used maximum flow computations. <p> This is made even worse by the fact that some minimum cuts may be produced many times by the algorithm. Applegate <ref> [App92, ABCC95] </ref> observed that there is a simple hashing technique that can be used to avoid outputting a cut more than once. At the beginning, assign to each vertex a random O (log n)-bit key. Whenever two vertices are merged by contractions, combine their keys with an exclusive-or.
Reference: [Ben94] <author> Andras A. Benczur. </author> <title> Augmenting undirected connectivity in RN C and in randomized ~ O(n 3 ) time. </title> <booktitle> In Proceedings of the 26 th ACM Symposium on Theory of Computing [ACM94], </booktitle> <pages> pages 658-667. </pages>
Reference-contexts: Karger and Motwani [KM96] have shown that in fact the minimum cut problem for weighted graphs is in N C. Rather than derandomizing the algorithms presented here, they develop a new algorithm based on the combinatorial aspects of minimum cuts that follow from this work. Benczur <ref> [Ben94] </ref> has used the Contraction Algorithm to get improved sequential and parallel algorithms for augmenting the connectivity of a graph to a given value. 1.6 Presentation Overview The starting point of our work is an abstract formulation of the Contraction Algorithm in Section 2.
Reference: [BK96] <author> Andras A. Benczur and David R. Karger. </author> <title> Approximate s-t min-cuts in ~ O(n 2 ) time. </title> <booktitle> In Proceedings of the 28 th ACM Symposium on Theory of Computing [ACM96], </booktitle> <pages> pages 47-55. </pages>
Reference-contexts: It also gives techniques for solving other cut-related problems such as network design. Most recently, [Kar96] has given sampling-based minimum cut algorithms with running times of O (n 2 log n) and O (m log 3 n). Karger and Benczur <ref> [BK96] </ref> 6 have given fast sampling-based algorithms for approximating s-t minimum cuts. In [Kar95], the structure of minimum cuts is used to obtain bounds on the reliability of a network with random edge failures.
Reference: [Bol86] <author> Bela Bollobas. </author> <title> Extremal Graph Theory with Emphasis on Probabilistic Methods. </title> <booktitle> Number 62 in Regional Conference Series in Mathematics. </booktitle> <publisher> American Mathematical Society, </publisher> <address> Providence, RI, </address> <year> 1986. </year>
Reference-contexts: A minor of graph G is a graph that can be derived from G by deleting edges and vertices and contracting edges. A minor-excluded graph is one that does not contain some particular graph as a minor. Mader ([Mad68], see also <ref> [Bol86] </ref>) proved that in any minor-excluded graph, all r-vertex minors have O (r) edges (thanks to Uri Zwick for pointing this out). Planar graphs fall into the class just discussed, as they exclude K 5 . Assume that we have a minor-excluded graph.
Reference: [Bot93] <author> Rodrigo A. Botafogo. </author> <title> Cluster analysis for hypertext systems. </title> <booktitle> In Proceedings of the 16 th Annual International ACM SIGIR Conference on Research and Development in Information Retrieval, </booktitle> <pages> pages 116-125, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In a more recent application [Kar95], this enumeration is used in a fully polynomial time approximation scheme for the all terminal network reliability problem. In information retrieval, minimum cuts have been used to identify clusters of topically related documents in hypertext systems <ref> [Bot93] </ref>. If the links in a hypertext collection are treated as edges in a graph, then small cuts correspond to groups of documents that have few links between them and are thus likely to be unrelated. Minimum cut problems arise in the design of compilers for parallel languages [CGSS96].
Reference: [CDR86] <author> Stephen Cook, Cynthia Dwork, and Rudiger Reischuk. </author> <title> Upper and lower bounds for parallel random access machines without simultaneous writes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 15(1) </volume> <pages> 87-97, </pages> <month> February </month> <year> 1986. </year>
Reference: [CH95] <author> Joseph Cheriyan and Torben Hagerup. </author> <title> A randomized maximum-flow algorithm. </title> <journal> SIAM Journal on Computing, </journal> <volume> 24(2) </volume> <pages> 203-226, </pages> <month> April </month> <year> 1995. </year> <note> A preliminary version appeared in FOCS 1989. </note>
Reference-contexts: Currently, the fastest deterministic algorithms, independently developed by King, Rao and Tarjan [KRT94] and by Phillips and Westbrook [PW92]) run in O (nm (log m n log n n)) time. Randomization has not helped signifi cantly. The fastest randomized maximum flow algorithm, developed by Cheriyan, Hagerup and Mehlhorn <ref> [CH95] </ref> runs in expected O (mn + n 2 log 2 n) time. Finding a minimum cut by directly applying any of these algorithms in the Gomory-Hu approach requires (mn 2 ) time.
Reference: [CGSS96] <author> S. Chaterjee, J. R. Gilver, R. Schreiber and T. J. She*er. </author> <title> "Array Distribution in Parallel Programs." </title> <booktitle> In Languages and Compilers for Parallel Computing. Lecture Notes in Computer Science series, </booktitle> <volume> vol. 369, Springer-Verlage, </volume> <pages> pp. 76-91, </pages> <year> 1996. </year>
Reference-contexts: If the links in a hypertext collection are treated as edges in a graph, then small cuts correspond to groups of documents that have few links between them and are thus likely to be unrelated. Minimum cut problems arise in the design of compilers for parallel languages <ref> [CGSS96] </ref>. Consider a parallel program which we are trying to execute on a distributed memory machine. In the alignment distribution graph for this program, vertices correspond to program operations and edges corresponds to flows of data between program operations.
Reference: [Che52] <author> H. Chernoff. </author> <title> A measure of the asymptotic efficiency for tests of a hypothesis based on the sum of observations. </title> <journal> Annals of Mathematical Statistics, </journal> <volume> 23 </volume> <pages> 493-509, </pages> <year> 1952. </year>
Reference-contexts: It follows that each time an edge is selected, the probability that it will be a good edge exceeds 2n=s. Given that we perform s selections, the expected number of good selections exceeds 2n. Then by the Chernoff bound <ref> [Che52, Mul94] </ref>, the probability that fewer than n good edges are selected is exponentially small in n. The number of contractions performed in an iteration is simply the number of good edges selected. Thus, by performing more than n good selections, the iteration will necessarily finish contracting the graph.
Reference: [CLR90] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: This is just the minimum weight of an edge in a maximum spanning tree of G, and can thus be identified in O (m log n) time using any standard minimum spanning tree algorithm <ref> [CLR90] </ref>. Even better, it can be identified in O (m) time by the Compact subroutine if we use the inverses of the actual edge weights as edge scores to determine the order of edge contraction.
Reference: [Col87] <author> Charles J. Colbourn. </author> <title> The Combinatorics of Network Reliability, </title> <booktitle> volume 4 of The International Series of Monographs on Computer Science. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1987. </year>
Reference-contexts: We discuss others here. The problem of determining the connectivity of a network arises frequently in issues of network design and network reliability <ref> [Col87] </ref>: in a network with random edge failures, the network is most likely to be partitioned at the minimum cuts. For example, consider an undirected graph in which each edge fails with some probability p, and suppose we wish to determine the probability that the graph becomes disconnected.
Reference: [DFJ54] <author> G. B. Dantzig, D. R. Fulkerson, and S. M. Johnson. </author> <title> Solution of a large-scale traveling salesman problem. </title> <journal> Operations Research, </journal> <volume> 2 </volume> <pages> 393-410, </pages> <year> 1954. </year>
Reference-contexts: Cutting plane algorithms find the optimum tour by repeatedly generating linear inequalities that cut off undesirable parts of the polytope until only the optimum tour remains. The inequalities that have been most useful are subtour elimination constraints, first introduced by Dantzig, Fulkerson and Johnson <ref> [DFJ54] </ref>. The problem of identifying a subtour elimination constraint can be rephrased as the problem of finding a minimum cut in a graph with real-valued edge weights.
Reference: [DJP + 94] <author> E. Dahlhaus, David S. Johnson, Christos H. Papadimitriou, P. D. Seymour, and Mihalis Yannakakis. </author> <title> The complexity of multiway cuts. </title> <journal> SIAM Journal on Computing, </journal> <volume> 23(4) </volume> <pages> 864-894, </pages> <year> 1994. </year> <note> A preliminary version appeared in STOC 1992. </note>
Reference-contexts: Our algorithm runs in expected ~ O (n 2 (r1) ) time, and in RN C using n 2 (r1) processors. This shows that the minimum r-way cut problem is in RN C for any constant r. In contrast, it is shown in <ref> [DJP + 94] </ref> that the multiway cut problem in which r specified vertices are required to be separated (i.e., a generalization of the s-t minimum cut problem) is N P-complete for any r &gt; 2.
Reference: [DKL76] <author> Efim A. Dinitz, A. V. Karzanov, and Micael V. Lomonosov. </author> <title> On the structure of a family of minimum weighted cuts in a graph. </title> <editor> In A. A. Fridman, editor, </editor> <booktitle> Studies in Discrete Optimization, </booktitle> <pages> pages 290-306. </pages> <publisher> Nauka Publishers, </publisher> <year> 1976. </year>
Reference-contexts: They have also been used in the development of fast algorithms for approximate solutions to minimum cut, maximum flow, and other graph problems [Kar94c, Kar94a]. A minor modification of our algorithm lets us use it to construct the cactus representation of minimum cuts introduced in <ref> [DKL76] </ref>. We improve the sequential time bound of this construction to ~ O (n 2 ). We give the first RN C algorithm for weighted graphs, improving the previous (unweighted graph) processor bound from mn 4:5 to n 4 . <p> This gives us improved sequential time bounds on certain classes of graphs and a more efficient parallel algorithm. In Sections 8 and 9 we show how to find minimum multiway cuts and approximate minimum cuts. In Section 10 we discuss the cactus representation for minimum cuts <ref> [DKL76] </ref>, and show how the Contraction Algorithm leads to more efficient algorithms for constructing it. <p> By Corollary 8.3, every such cut has an ((2n) 2ff ) probability of being produced by the Contraction Algorithm. The bound on the possible number of cuts follows. A previous bound of O (n 2 ) for the number of minimum cuts was proved by other means in <ref> [DKL76] </ref>. No previous bound on the number of cuts of by value was known. <p> Desirable properties of such representations include small space requirements and, perhaps more importantly, the ability to quickly answer queries about the minimum cuts in the graph. Several representations are known <ref> [DKL76, Gab91] </ref>. We concentrate on the cactus representation [DKL76]. This data structure represents all n minimum cuts via an n-node, O (n)-edge graph. It can be used to quickly identify, for example, all minimum cuts separating a particular pair of vertices. <p> Desirable properties of such representations include small space requirements and, perhaps more importantly, the ability to quickly answer queries about the minimum cuts in the graph. Several representations are known [DKL76, Gab91]. We concentrate on the cactus representation <ref> [DKL76] </ref>. This data structure represents all n minimum cuts via an n-node, O (n)-edge graph. It can be used to quickly identify, for example, all minimum cuts separating a particular pair of vertices.
Reference: [EFS56] <author> P. Elias, A. Feinstein, and C. E. Shannon. </author> <title> Note on maximum flow through a network. </title> <journal> IRE Transactions on Information Theory IT-2, </journal> <pages> pages 117-199, </pages> <year> 1956. </year>
Reference-contexts: Previously best results, together with our new bounds, are summarized in Figure 1, where c denotes the value of the minimum cut. 1.3.1 Flow based approaches The first algorithm for finding minimum cuts used the duality between s-t minimum cuts and s-t maximum flows <ref> [FF56, EFS56] </ref>.
Reference: [EK72] <author> Jack Edmonds and Richard M. Karp. </author> <title> Theoretical improvements in algorithmic efficiency for network flow problems. </title> <journal> Journal of the ACM, </journal> <volume> 19 </volume> <pages> 248-264, </pages> <year> 1972. </year>
Reference-contexts: If we combine these algorithms with the scaling techniques of Edmonds and Karp <ref> [EK72] </ref>, as suggested in [KUW86], the processor count is mn 4:37 and the running times are proportional to log W . Hence, the algorithms are not in RN C unless W = n log O (1) n . The lack of an RN C algorithm is not surprising.
Reference: [FF56] <author> Lester R. Ford, Jr. and D. R. Fulkerson. </author> <title> Maximal flow through a network. </title> <journal> Canadian Journal of Mathematics, </journal> <volume> 8 </volume> <pages> 399-404, </pages> <year> 1956. </year>
Reference-contexts: Previously best results, together with our new bounds, are summarized in Figure 1, where c denotes the value of the minimum cut. 1.3.1 Flow based approaches The first algorithm for finding minimum cuts used the duality between s-t minimum cuts and s-t maximum flows <ref> [FF56, EFS56] </ref>.
Reference: [FF62] <author> Lester R. Ford, Jr. and D. R. Fulkerson. </author> <title> Flows in Networks. </title> <publisher> Princeton University Press, </publisher> <address> Princeton, New Jersey, </address> <year> 1962. </year>
Reference-contexts: In 1961, Gomory and Hu [GH61] introduced the concept of a flow equivalent tree and observed that the minimum cut could be found by solving only n 1 maximum flow problems. In their classic book Flows in Networks <ref> [FF62] </ref>, Ford and Fulkerson comment on the method of Gomory and Hu: Their procedure involved the successive solution of precisely n 1 maximal flow problems. Moreover, many of these problems involve smaller networks than the original one. Thus one could hardly ask for anything better.
Reference: [Fra94] <author> Andras Frank. </author> <title> On the edge-connectivity algorithm of Nagamochi and Ibaraki. </title> <institution> Labarotoire Artemis, IMAG, Universite J. Fourier, Grenoble, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: This yields an algorithm that computes the minimum cut in O (mn + n 2 log n) time. Stoer and Wagner [SW94] subsequently gave a simplified version of the Nagamochi and Ibaraki algorithm with the same running time (this simplification was subsequently discovered independently by Frank <ref> [Fra94] </ref>). Scan-first search is also used by Gabow [Gab95] to improve the running time of his matroid algorithm to O (m+c 2 n log (n=c)) on undirected graphs.
Reference: [Gab91] <author> Harold N. Gabow. </author> <title> Applications of a poset representation to edge connectivity and graph rigidity. </title> <booktitle> In Proceedings of the 32 nd Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 812-821. </pages> <publisher> IEEE, IEEE Computer Society Press, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: Desirable properties of such representations include small space requirements and, perhaps more importantly, the ability to quickly answer queries about the minimum cuts in the graph. Several representations are known <ref> [DKL76, Gab91] </ref>. We concentrate on the cactus representation [DKL76]. This data structure represents all n minimum cuts via an n-node, O (n)-edge graph. It can be used to quickly identify, for example, all minimum cuts separating a particular pair of vertices.
Reference: [Gab95] <author> Harold N. Gabow. </author> <title> A matroid approach to finding edge connectivity and packing arborescences. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 50(2) </volume> <pages> 259-273, </pages> <month> April </month> <year> 1995. </year> <note> A preliminary version appeared in STOC 1991. </note>
Reference-contexts: Padberg and Rinaldi [PR90] reported that the solution of minimum cut problems was the 2 minimum cut bounds unweighted weighted undirected directed undirected directed sequential previous c 2 n log n cm log m n 2 time <ref> [Gab95] </ref> [NI92] [HO94] this paper n 2 log 3 n n 2 log 3 n processors previous n 4:37 Unknown P-complete used [KUW86, GP88] [GSS82] in RN C this paper n 2 n 2 computational bottleneck in their state-of-the-art cutting-plane based algorithm. <p> They used the fastest such algorithm, that of Goldberg and Tarjan, to find a minimum cut in O (mn log (n 2 =m)) time. 1.3.2 Cuts without flows Recently, two approaches to finding minimum cuts without computing any maximum flows have appeared. One approach, developed by Gabow <ref> [Gab95] </ref>, is based on a matroid characterization of the minimum cut problem. According to this characterization, the minimum cut in a graph is equal to the maximum number of disjoint directed spanning trees that can be found in it. <p> Stoer and Wagner [SW94] subsequently gave a simplified version of the Nagamochi and Ibaraki algorithm with the same running time (this simplification was subsequently discovered independently by Frank [Fra94]). Scan-first search is also used by Gabow <ref> [Gab95] </ref> to improve the running time of his matroid algorithm to O (m+c 2 n log (n=c)) on undirected graphs. <p> This turns the Monte Carlo algorithms into Las Vegas algorithms that are guaranteed to produce the right answer but have a small probability of taking a long time to do so. Unfortunately, all presently known minimum cut certificates (such as maximum flows, or the complete intersections of <ref> [Gab95] </ref>) take just as long to construct when the minimum cut is known as when it is unknown. Thus we can provide no speedup if a guarantee of the minimum cut value is desired. <p> The Recursive Contraction Algorithm has a very high probability of finding a minimum cut, but there is no fast way to prove that it has done so, as all known certificates for a minimum cut, such as a maximum flow, or Gabow's the complete intersections <ref> [Gab95] </ref>, take too long to compute. The Contraction Algorithm is thus Monte Carlo. The same applies to the faster algorithms of [Kar96]. A fast Las Vegas Algorithm for unweighted graphs is given in [Kar94a], but the running time does not match the Monte Carlo algorithms'.
Reference: [GH61] <author> R. E. Gomory and T. C. Hu. </author> <title> Multi-terminal network flows. </title> <journal> Journal of the Society of Industrial and Applied Mathematics, </journal> <volume> 9(4) </volume> <pages> 551-570, </pages> <month> December </month> <year> 1961. </year>
Reference-contexts: An s-t maximum flow algorithm can thus be used to find an s-t minimum cut, and minimizing over all n possible choices of s and t yields a minimum cut. In 1961, Gomory and Hu <ref> [GH61] </ref> introduced the concept of a flow equivalent tree and observed that the minimum cut could be found by solving only n 1 maximum flow problems. <p> However, the question of whether it is easier to find a minimum cut than a maximum flow in directed graphs remains open. The minimum cut algorithm of Gomory and Hu <ref> [GH61] </ref> not only found the minimum cut, but found a flow equivalent tree that succinctly represented the values of the n minimum cuts.
Reference: [GH88] <author> Oliver Goldschmidt and Dorit Hochbaum. </author> <title> Polynomial algorithm for the k-cut problem. </title> <booktitle> In Proceedings of the 29 th Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 444-451. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: The minimum r-way cut problem is to find a minimum weight set of edges whose removal partitions a given graph into r separate components. Previ 5 ously, the best known sequential bound, due to Goldschmidt and Hochbaum <ref> [GH88] </ref>, was O (n r 2 =2r+11=2 ), and no parallel algorithm was known. Our algorithm runs in expected ~ O (n 2 (r1) ) time, and in RN C using n 2 (r1) processors. <p> The fact that all cuts are found follows as in the approximately minimal cuts case. This is a significant improvement over the previously best known sequential time bound of O (n r 2 r+11=2 ) reported in <ref> [GH88] </ref>. This also provides the first proof that the multiway cut problem is in RN C for constant r.
Reference: [GJ79] <author> Michael R. Garey and David S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference-contexts: Throughout this paper, the graph is assumed to be connected, since otherwise the problem is trivial. We also require that all edge weights be non-negative because otherwise the problem is N P-complete by a trivial transformation from the maximum-cut problem <ref> [GJ79, page 210] </ref>. We distinguish the minimum cut problem from the s-t minimum cut problem in which we require that two specified vertices s and t be on opposite sides of the cut; in the minimum cut problem there is no such restriction.
Reference: [GP88] <author> Zvi Galil and Victor Pan. </author> <title> Improved processor bounds for combinatorial problems in RN C. </title> <journal> Combinatorica, </journal> <volume> 8 </volume> <pages> 189-200, </pages> <year> 1988. </year>
Reference-contexts: minimum cut problems was the 2 minimum cut bounds unweighted weighted undirected directed undirected directed sequential previous c 2 n log n cm log m n 2 time [Gab95] [NI92] [HO94] this paper n 2 log 3 n n 2 log 3 n processors previous n 4:37 Unknown P-complete used <ref> [KUW86, GP88] </ref> [GSS82] in RN C this paper n 2 n 2 computational bottleneck in their state-of-the-art cutting-plane based algorithm. They also reported that minimum cut problems are the bottleneck in many other cutting-plane based algorithms for combinatorial problems whose solutions induce connected graphs. <p> We can find a minimum cut by performing n of these s-t cut computations in parallel (number the vertices, and find a minimum v i ; v (i+1) mod n -cut for each i). Unfortunately, the processor bounds are quite large|the best bound, using Galil and Pan's <ref> [GP88] </ref> adaptation of [KUW86], is n 4:37 . These unweighted directed graph algorithms can be extended to work for weighted graphs by treating an edge of weight w as a set of w parallel edges.
Reference: [GSS82] <author> L. M. Goldschlager, R. A. Shaw, and J. </author> <title> Staples. The maximum flow problem is logspace complete for P. </title> <journal> Theoretical Computer Science, </journal> <volume> 21 </volume> <pages> 105-111, </pages> <year> 1982. </year>
Reference-contexts: problems was the 2 minimum cut bounds unweighted weighted undirected directed undirected directed sequential previous c 2 n log n cm log m n 2 time [Gab95] [NI92] [HO94] this paper n 2 log 3 n n 2 log 3 n processors previous n 4:37 Unknown P-complete used [KUW86, GP88] <ref> [GSS82] </ref> in RN C this paper n 2 n 2 computational bottleneck in their state-of-the-art cutting-plane based algorithm. They also reported that minimum cut problems are the bottleneck in many other cutting-plane based algorithms for combinatorial problems whose solutions induce connected graphs. <p> Hence, the algorithms are not in RN C unless W = n log O (1) n . The lack of an RN C algorithm is not surprising. Goldschlager, Shaw, and Staples <ref> [GSS82] </ref> showed that the s-t minimum cut problem on weighted directed graphs is P-complete. In Section 6.5 we note a simple reduction to their result that proves that the weighted directed minimum cut problem is also P-complete. <p> Note that the weights of edges going from T to S is not counted in the value of the cut. The s-t minimum cut problem on directed graphs was shown to be P-complete <ref> [GSS82] </ref>. A similar result holds for the global minimum cut problem: Lemma 6.4 The global minimum cut problem is P-complete for directed graphs. Proof: Given an algorithm the finds global minimum cuts, we find a minimum s-t cut as follows.
Reference: [GT88] <author> Andrew V. Goldberg and Robert E. Tarjan. </author> <title> A new approach to the maximum flow problem. </title> <journal> Journal of the ACM, </journal> <volume> 35 </volume> <pages> 921-940, </pages> <year> 1988. </year>
Reference-contexts: The focus in minimum cut algorithms was on developing better maximum flow algorithms and better methods of performing series of maximum flow computations. 3 Maximum flow algorithms have become progressively faster over the years. Currently, the fastest algorithms are based on the push-relabel method of Goldberg and Tarjan <ref> [GT88] </ref>. Their early implementation of this method runs in O (nm log (n 2 =m)) time. Incrementally faster implementations appeared subsequently.
Reference: [Has89] <author> J. Hastad. </author> <title> Almost optimal lower bounds for small depth circuits. </title> <booktitle> Advances in Computing Research, </booktitle> <volume> 5, </volume> <year> 1989. </year> <editor> Miscale, S. ed. </editor> <publisher> JAI Press, </publisher> <address> Greenwich, CT, </address> <year> 1989, </year> <pages> pp. 143-170. </pages> <note> A preliminary version appeared in STOC 1986. </note>
Reference-contexts: This is in fact the best possible asymptotic running time, since even distinguishing whether a graph is connected (positive connectivity) or unconnected (0 connectivity) takes (log n) time ([HZ94], based on a reduction from [CDR86]|a similar lower bound of (log n= log log n) for the CRCW model follows from <ref> [Has89] </ref>). However, the processor bounds are quite large. 6.5 Related Problem are P -complete The previous section indicates a distinction between minimum cut problems on directed and undirected graphs.
Reference: [HO94] <author> Hao and Orlin. </author> <title> A faster algorithm for finding the minimum cut in a directed graph. </title> <journal> Journal of Algorithms, </journal> <volume> 17(3) </volume> <pages> 424-446, </pages> <year> 1994. </year> <note> A preliminary version appeared in SODA 1992. </note>
Reference-contexts: Padberg and Rinaldi [PR90] reported that the solution of minimum cut problems was the 2 minimum cut bounds unweighted weighted undirected directed undirected directed sequential previous c 2 n log n cm log m n 2 time [Gab95] [NI92] <ref> [HO94] </ref> this paper n 2 log 3 n n 2 log 3 n processors previous n 4:37 Unknown P-complete used [KUW86, GP88] [GSS82] in RN C this paper n 2 n 2 computational bottleneck in their state-of-the-art cutting-plane based algorithm. <p> Applying this idea, Podderyugin [Pod73], Karzanov and Timofeev [KT86], and Matula [Mat87] independently discovered several algorithms which determine edge connectivity in unweighted graphs in O (mn) time. Hao and Orlin <ref> [HO94] </ref> obtained similar types of results for weighted graphs. They showed that the series of n 1 related maximum flow computations needed to find a minimum cut can all be performed in roughly the same amount of time that it takes to perform one maximum flow computation.
Reference: [HZ94] <author> Shay Halperin and Uri Zwick. </author> <title> An optimal randomized logarithmic time connectivity algorithm for the EREW PRAM. </title> <booktitle> In Proceedings of the 6 th Annual ACM-SIAM Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 1-10. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: Given the permutation, it is easy to run Compact in parallel. RN C algorithms for connected components exist that use m= log n processors and run in O (log n) time on a CRCW PRAM [SV82] or even on the EREW PRAM <ref> [HZ94] </ref>. Procedure Compact, which terminates after O (log n) iterations, is thus easily seen to be parallelizable to run in O (log 2 n) time using m processors. <p> After generating the permutation, instead of using Compact to identify the correct permutation prefix, we examine all prefixes in parallel. Each prefix requires a single connected components computation, which can be performed in O (log n) time, even on an EREW PRAM, using m= log n processors <ref> [HZ94] </ref>. We can therefore perform a single trial of the Contraction Algorithm in O (log n) time using m 2 processors. As was mentioned in the overview, running this algorithm n 2 log n times in parallel yields the minimum cut with high probability.
Reference: [Kar93] <author> David R. Karger. </author> <title> Global min-cuts in RN C and other ramifications of a simple mincut algorithm. </title> <booktitle> In Proceedings of the 4 th Annual ACM-SIAM Symposium on Discrete Algorithms [ACM93], </booktitle> <pages> pages 21-30. </pages>
Reference-contexts: The original Contraction Algorithm with an ~ O (mn 2 ) running time and processor bound, as well as the connections to multiway and approximately minimum cuts and analyses of network reliability, originally appeared in <ref> [Kar93] </ref>. The improved algorithm with faster running times and processor bounds originally appeared in [KS93]. This paper combines results from those two conference papers. <p> This paper combines results from those two conference papers. Lomonosov [Lom94] independently developed some of the basic intuitions leading to the Contraction Algorithm, using them to investigate questions of network reliability. 1.5 Related Work Subsequent to the initial presentation of this work <ref> [Kar93, KS93] </ref>, several related papers based upon it have appeared. Karger [Kar94a] used the Contraction Algorithm to prove theorems about the structure and enumeration of near-minimum cuts. <p> Thus by checking whether an identifier has already been encountered we can avoid outputting any cut that has already been output. An alternative approach to outputting all minimum cuts is to output a concise representation of them; this issue is taken up in Section 10. In <ref> [Kar93] </ref>, several simple implementation of the Contraction Algorithm for unweighted multigraphs were given. However, in the context of the Recursive Contraction Algorithm the unweighted graph algorithms are no longer useful. This is because our time bound depends on the many subproblems deep in the recursion tree being small.
Reference: [Kar94a] <author> David R. Karger. </author> <title> Random sampling in cut, flow, and network design problems. </title> <booktitle> In Proceedings of the 26 th ACM Symposium on Theory of Computing [ACM94], </booktitle> <pages> pages 648-657. </pages> <note> Submitted for publication.. </note>
Reference-contexts: Although flows are not used, the trees are constructed through a sequence of augmenting path computations. Rather than computing the minimum cut directly, Gabow's algorithm computes a flow-like structure that saturates the minimum cut of the graph. In <ref> [Kar94a] </ref>, randomization is used to speed up Gabow's algorithm to run in ~ O (m p c) time with high probability, where ~ O (f ) denote O (f polylog f ). <p> These results have important applications in the study of network reliability [RC87]. They have also been used in the development of fast algorithms for approximate solutions to minimum cut, maximum flow, and other graph problems <ref> [Kar94c, Kar94a] </ref>. A minor modification of our algorithm lets us use it to construct the cactus representation of minimum cuts introduced in [DKL76]. We improve the sequential time bound of this construction to ~ O (n 2 ). <p> Lomonosov [Lom94] independently developed some of the basic intuitions leading to the Contraction Algorithm, using them to investigate questions of network reliability. 1.5 Related Work Subsequent to the initial presentation of this work [Kar93, KS93], several related papers based upon it have appeared. Karger <ref> [Kar94a] </ref> used the Contraction Algorithm to prove theorems about the structure and enumeration of near-minimum cuts. <p> Algorithms for dynamically maintaining approximate minimum cuts during edge insertions and deletions are also presented. <ref> [Kar94a] </ref> gives an ~ O (m p c)-time Las Vegas algorithm for finding minimum cuts in unweighted undirected graphs. It also gives techniques for solving other cut-related problems such as network design. <p> Karger [Kar95] uses small-cut enumeration is the basis of a fully polynomial time approximation scheme for the all-terminal reliability problem. We begin with some cut-counting results from <ref> [Kar94a] </ref>. Definition 8.1 An ff-minimal cut is a cut of value within a multiplicative factor of ff of the minimum. <p> The Contraction Algorithm is thus Monte Carlo. The same applies to the faster algorithms of [Kar96]. A fast Las Vegas Algorithm for unweighted graphs is given in <ref> [Kar94a] </ref>, but the running time does not match the Monte Carlo algorithms'. Since we are now able to find a minimum cut faster than a maximum flow, it is natural to ask whether it is any easier to compute a maximum flow given a minimum cut.
Reference: [Kar94b] <author> David R. Karger. </author> <title> Random Sampling in Graph Optimization Problems. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, </institution> <address> CA 94305, </address> <year> 1994. </year> <note> Contact at karger@lcs.mit.edu. Available by ftp from theory.lcs.mit.edu, directory pub/karger. </note>
Reference-contexts: An alternative scheme due to Von Neumann [Neu51] generates a random variate with the exact exponential distribution in constant expected time given a uniform random number generator. Details can be found in <ref> [Kar94b] </ref>. 6.3 Parallelizing the Contraction Algorithm Parallelizing the previous algorithms is simple. To generate the permutation, given a list of edges, we simply assign one processor to each edge and have it generate the (approximately) exponentially distributed score for that edge in polylogarithmic time.
Reference: [Kar94c] <author> David R. Karger. </author> <title> Using randomized sparsification to approximate minimum cuts. </title> <booktitle> In Proceedings of the 5 th Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 424-432. ACM-SIAM, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: These results have important applications in the study of network reliability [RC87]. They have also been used in the development of fast algorithms for approximate solutions to minimum cut, maximum flow, and other graph problems <ref> [Kar94c, Kar94a] </ref>. A minor modification of our algorithm lets us use it to construct the cactus representation of minimum cuts introduced in [DKL76]. We improve the sequential time bound of this construction to ~ O (n 2 ). <p> Karger [Kar94a] used the Contraction Algorithm to prove theorems about the structure and enumeration of near-minimum cuts. These have led to a random-sampling approach to cut problems. <ref> [Kar94c] </ref> shows how to approximate the minimum cut to within any constant factor in O (m + n log 2 n) time sequentially, and to within a factor of 2 in parallel using a linear number of processors. <p> The first step towards proving this is a corollary regarding the number of such cuts that can exist in a graph. This corollary has other important applications which are investigated in <ref> [Kar94c, KM96] </ref>. Further exploration of this theorem can be found in those papers. Theorem 8.4 In any graph, the number of ff-minimal cuts is O ((2n) 2ff ). Proof: Since the above algorithm outputs only one cut, the survivals of the different cuts are disjoint events.
Reference: [Kar95] <author> David R. Karger. </author> <title> A randomized fully polynomial approximation scheme for the all terminal network reliability problem. </title> <booktitle> In Proceedings of the 27 th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 11-17. </pages> <publisher> ACM, ACM Press, </publisher> <month> May </month> <year> 1995. </year>
Reference-contexts: If p is very small, then the value can be accurately approximated by considering f k only for small values of k. It therefore becomes important to to enumerate all minimum cuts and, if possible, all nearly minimum cuts [RC87]. In a more recent application <ref> [Kar95] </ref>, this enumeration is used in a fully polynomial time approximation scheme for the all terminal network reliability problem. In information retrieval, minimum cuts have been used to identify clusters of topically related documents in hypertext systems [Bot93]. <p> Most recently, [Kar96] has given sampling-based minimum cut algorithms with running times of O (n 2 log n) and O (m log 3 n). Karger and Benczur [BK96] 6 have given fast sampling-based algorithms for approximating s-t minimum cuts. In <ref> [Kar95] </ref>, the structure of minimum cuts is used to obtain bounds on the reliability of a network with random edge failures. Karger and Motwani [KM96] have shown that in fact the minimum cut problem for weighted graphs is in N C. <p> Karger <ref> [Kar95] </ref> uses small-cut enumeration is the basis of a fully polynomial time approximation scheme for the all-terminal reliability problem. We begin with some cut-counting results from [Kar94a]. Definition 8.1 An ff-minimal cut is a cut of value within a multiplicative factor of ff of the minimum.
Reference: [Kar96] <author> David R. Karger. </author> <title> Minimum cuts in near-linear time. </title> <booktitle> In Proceedings of the 28 th ACM Symposium on Theory of Computing [ACM96], </booktitle> <pages> pages 56-63. </pages>
Reference-contexts: Algorithms for dynamically maintaining approximate minimum cuts during edge insertions and deletions are also presented. [Kar94a] gives an ~ O (m p c)-time Las Vegas algorithm for finding minimum cuts in unweighted undirected graphs. It also gives techniques for solving other cut-related problems such as network design. Most recently, <ref> [Kar96] </ref> has given sampling-based minimum cut algorithms with running times of O (n 2 log n) and O (m log 3 n). Karger and Benczur [BK96] 6 have given fast sampling-based algorithms for approximating s-t minimum cuts. <p> The bound on the possible number of cuts follows. A previous bound of O (n 2 ) for the number of minimum cuts was proved by other means in [DKL76]. No previous bound on the number of cuts of by value was known. Karger <ref> [Kar96] </ref> has sine improved the bound to O ( n Our efficient implementation of the contraction algorithm can be applied to approximately minimum cuts: Theorem 8.5 All cuts with weight within a multiplicative factor ff of the minimum cut can be found in O (n 2ff log 2 n) time. <p> After time t we sample only from among those edges that have weight less than this threshold. This gives a running time of O (m log W ). 12 Conclusions We have given efficient and simple algorithms for the minimum cut problem, yet several interesting open questions remain. Karger <ref> [Kar96] </ref> has given faster minimum cut algorithms: one with running time O (m log 3 n) and a simpler one with running time O (n 2 log n). <p> The Contraction Algorithm is thus Monte Carlo. The same applies to the faster algorithms of <ref> [Kar96] </ref>. A fast Las Vegas Algorithm for unweighted graphs is given in [Kar94a], but the running time does not match the Monte Carlo algorithms'.
Reference: [KM96] <author> David R. Karger and Rajeev Motwani. </author> <title> Derandomization through approximation: An N C algorithm for minimum cuts. </title> <journal> SIAM Journal on Computing, </journal> <note> 1996. To appear.A preliminary version appeared in STOC 1993, p. 497. </note>
Reference-contexts: Karger and Benczur [BK96] 6 have given fast sampling-based algorithms for approximating s-t minimum cuts. In [Kar95], the structure of minimum cuts is used to obtain bounds on the reliability of a network with random edge failures. Karger and Motwani <ref> [KM96] </ref> have shown that in fact the minimum cut problem for weighted graphs is in N C. Rather than derandomizing the algorithms presented here, they develop a new algorithm based on the combinatorial aspects of minimum cuts that follow from this work. <p> The first step towards proving this is a corollary regarding the number of such cuts that can exist in a graph. This corollary has other important applications which are investigated in <ref> [Kar94c, KM96] </ref>. Further exploration of this theorem can be found in those papers. Theorem 8.4 In any graph, the number of ff-minimal cuts is O ((2n) 2ff ). Proof: Since the above algorithm outputs only one cut, the survivals of the different cuts are disjoint events. <p> Thus an algorithm that finds all approximately minimum cuts will find the original minimum cut. We arrange that the relative change in any cut value is 1=n, so that the running time is changed only by a constant factor. This method is necessary in the derandomization of <ref> [KM96] </ref>. 9 Multiway Cuts The Contraction Algorithm can also be used to find a minimum weight r-way cut that partitions the graph into r pieces rather than 2. <p> An obvious open question is therefore: how close to linear-time can we get in solving the minimum cut problem in theory and in practice? Another question is the extent to which randomization is needed. Karger and Mot-wani <ref> [KM96] </ref> have used the Contraction Algorithm to prove that the minimum cut can be found in N C; however, the resulting processor bounds are prohibitively large for practical purposes. An important first step towards derandomization would be a so-called Las Vegas algorithm for minimum cuts.
Reference: [Knu73] <author> Donald E. Knuth. </author> <title> Fundamental Algorithms, </title> <booktitle> volume 1 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <address> 2nd edition, </address> <year> 1973. </year>
Reference-contexts: the resulting graph uniformly at random. 26 The probability that a particular k-minimal cut survives the contraction to r vertices is (1 n 2k ) (1 r + 1 n2k nr = 2k n ; where in the above equations we use generalized binomial coefficients for non-integral arguments (see Knuth <ref> [Knu73, Sections 1.2.5-6] </ref> for details). From [Knu73, Exercise 1.2.6.45], we know that n = fi (n 2k ) for fixed k. Since r is a constant independent of n, the overall probability is fi (n 2k ). <p> From <ref> [Knu73, Exercise 1.2.6.45] </ref>, we know that n = fi (n 2k ) for fixed k. Since r is a constant independent of n, the overall probability is fi (n 2k ).
Reference: [KPST94] <author> Philip Klein, Serge A. Plotkin, Clifford Stein, and Eva Tardos. </author> <title> Faster approximation algorithms for the unit capacity concurrent flow problem with applications to routing and finding sparse cuts. </title> <journal> SIAM Journal on Computing, </journal> <volume> 23(3) </volume> <pages> 466-487, </pages> <year> 1994. </year> <note> A preliminary version appeared in STOC 90. 35 </note>
Reference-contexts: Each of these two choices requires O (n) time to construct a cumulative weight array plus one O (log n)-time call to Random-Select, for a total time bound of O (n). The following lemma, similar to one used by Klein, Plotkin, Stein and Tardos <ref> [KPST94] </ref>, proves the correctness of this procedure. Lemma 3.1 If an edge is chosen as described above, then Pr [(u; v) is chosen] is proportional to W (u; v): Proof: Let = P v D (v).
Reference: [KR90] <author> Richard M. Karp and Vijaya Ramachandran. </author> <title> Parallel algorithms for shared memory machines. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume A, </booktitle> <pages> pages 869-932. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Step 1 of the algorithm can be implemented easily: find a spanning tree of G and then number the vertices according to a preorder traversal. This can be done in O (m) time sequentially and also in O (log n) time using m= log n processors in parallel <ref> [KR90] </ref>. Step 3 can also be implemented relatively efficiently. Karzanov and Timofeev [KT86] describe a sequential implementation that, given the set of chains for each S i , takes O (n 2 ) time.
Reference: [KRT94] <author> Valerie King, Satish Rao, and Robert E. Tarjan. </author> <title> A faster deterministic maximum flow algorithm. </title> <journal> Journal of Algorithms, </journal> <volume> 17(3) </volume> <pages> 447-474, </pages> <month> November </month> <year> 1994. </year> <note> A preliminary version appeared in SODA 1992. </note>
Reference-contexts: Currently, the fastest algorithms are based on the push-relabel method of Goldberg and Tarjan [GT88]. Their early implementation of this method runs in O (nm log (n 2 =m)) time. Incrementally faster implementations appeared subsequently. Currently, the fastest deterministic algorithms, independently developed by King, Rao and Tarjan <ref> [KRT94] </ref> and by Phillips and Westbrook [PW92]) run in O (nm (log m n log n n)) time. Randomization has not helped signifi cantly. The fastest randomized maximum flow algorithm, developed by Cheriyan, Hagerup and Mehlhorn [CH95] runs in expected O (mn + n 2 log 2 n) time.
Reference: [Kru56] <author> J. B. Kruskal, Jr. </author> <title> On the shortest spanning subtree of a graph and the traveling salesman problem. </title> <journal> Proceedings of the American Mathematical Society, </journal> <volume> 7(1) </volume> <pages> 48-50, </pages> <year> 1956. </year>
Reference-contexts: these minimum cuts is produced by the Contraction Algorithm with equal probability, namely n 1 An alternative interpretation of the Contraction Algorithm is that we are randomly ranking the edges and then constructing a minimum spanning tree of the graph based on these ranks (using Kruskal's minimum spanning tree algorithm <ref> [Kru56] </ref>). If we remove the heaviest edge in the minimum spanning tree, the two components that result have an (n 2 ) chance of defining a particular minimum cut. This intuition forms the basis of the implementation in Section 7. The Contraction Algorithm can be halted when k vertices remain.
Reference: [KS91] <author> Samir Khuller and Baruch Schieber. </author> <title> Efficient parallel algorithms for testing connectivity and finding disjoint s-t paths in graphs. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(2) </volume> <pages> 352-375, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: For undirected unweighted graphs, Khuller and Schieber <ref> [KS91] </ref> gave an algorithm that uses cn 2 processors to find a minimum cut of value c in ~ O (c) time; this algorithm is therefore in RN C when c is polylogarithmic in n (RN C is the class of problems that can be solved by a randomized algorithm in
Reference: [KS93] <author> David R. Karger and Clifford Stein. </author> <title> An ~ O(n 2 ) algorithm for minimum cuts. </title> <booktitle> In Proceedings of the 25 th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 757-765. </pages> <publisher> ACM, ACM Press, </publisher> <month> May </month> <year> 1993. </year>
Reference-contexts: The original Contraction Algorithm with an ~ O (mn 2 ) running time and processor bound, as well as the connections to multiway and approximately minimum cuts and analyses of network reliability, originally appeared in [Kar93]. The improved algorithm with faster running times and processor bounds originally appeared in <ref> [KS93] </ref>. This paper combines results from those two conference papers. <p> This paper combines results from those two conference papers. Lomonosov [Lom94] independently developed some of the basic intuitions leading to the Contraction Algorithm, using them to investigate questions of network reliability. 1.5 Related Work Subsequent to the initial presentation of this work <ref> [Kar93, KS93] </ref>, several related papers based upon it have appeared. Karger [Kar94a] used the Contraction Algorithm to prove theorems about the structure and enumeration of near-minimum cuts.
Reference: [KT86] <author> A. V. Karzanov and E. A. Timofeev. </author> <title> Efficient algorithm for finding all minimal edge cuts of a non-oriented graph. </title> <journal> Cybernetics, </journal> <volume> 22 </volume> <pages> 156-162, </pages> <year> 1986. </year>
Reference-contexts: The basic technique is to pass information among the various flow computations, so that computing all n maximum flows together takes less time than computing each one separately. Applying this idea, Podderyugin [Pod73], Karzanov and Timofeev <ref> [KT86] </ref>, and Matula [Mat87] independently discovered several algorithms which determine edge connectivity in unweighted graphs in O (mn) time. Hao and Orlin [HO94] obtained similar types of results for weighted graphs. <p> Several representations are known [DKL76, Gab91]. We concentrate on the cactus representation [DKL76]. This data structure represents all n minimum cuts via an n-node, O (n)-edge graph. It can be used to quickly identify, for example, all minimum cuts separating a particular pair of vertices. Karzanov and Timofeev <ref> [KT86] </ref> give an algorithm for constructing the cactus sequentially; their algorithm is parallelized by Naor and Vazi-rani [NV91]. We describe the general framework of both algorithms below. The reader is referred to [NV91] for a much more detailed description. 1. <p> This can be done in O (m) time sequentially and also in O (log n) time using m= log n processors in parallel [KR90]. Step 3 can also be implemented relatively efficiently. Karzanov and Timofeev <ref> [KT86] </ref> describe a sequential implementation that, given the set of chains for each S i , takes O (n 2 ) time. <p> This led to a sequential algorithm that took ~ O (n 2 m) time <ref> [KT86] </ref> and an O (log 2 n) time randomized algorithm that used n 4:5 m processors on unweighted graphs [NV91].
Reference: [KUW86] <author> Richard M. Karp, Eli Upfal, and Avi Wigderson. </author> <title> Constructing a perfect matching is in random N C. </title> <journal> Combinatorica, </journal> <volume> 6(1) </volume> <pages> 35-48, </pages> <year> 1986. </year>
Reference-contexts: minimum cut problems was the 2 minimum cut bounds unweighted weighted undirected directed undirected directed sequential previous c 2 n log n cm log m n 2 time [Gab95] [NI92] [HO94] this paper n 2 log 3 n n 2 log 3 n processors previous n 4:37 Unknown P-complete used <ref> [KUW86, GP88] </ref> [GSS82] in RN C this paper n 2 n 2 computational bottleneck in their state-of-the-art cutting-plane based algorithm. They also reported that minimum cut problems are the bottleneck in many other cutting-plane based algorithms for combinatorial problems whose solutions induce connected graphs. <p> For directed unweighted graphs, the RN C matching algorithms of Karp, Upfal, and Wigderson <ref> [KUW86] </ref> or Mulmuley, Vazi-rani, and Vazirani [MVV87] can be combined with a reduction of s-t maximum flow to matching [KUW86] to yield RN C algorithms for s-t minimum cuts. <p> For directed unweighted graphs, the RN C matching algorithms of Karp, Upfal, and Wigderson <ref> [KUW86] </ref> or Mulmuley, Vazi-rani, and Vazirani [MVV87] can be combined with a reduction of s-t maximum flow to matching [KUW86] to yield RN C algorithms for s-t minimum cuts. We can find a minimum cut by performing n of these s-t cut computations in parallel (number the vertices, and find a minimum v i ; v (i+1) mod n -cut for each i). <p> Unfortunately, the processor bounds are quite large|the best bound, using Galil and Pan's [GP88] adaptation of <ref> [KUW86] </ref>, is n 4:37 . These unweighted directed graph algorithms can be extended to work for weighted graphs by treating an edge of weight w as a set of w parallel edges. <p> If we combine these algorithms with the scaling techniques of Edmonds and Karp [EK72], as suggested in <ref> [KUW86] </ref>, the processor count is mn 4:37 and the running times are proportional to log W . Hence, the algorithms are not in RN C unless W = n log O (1) n . The lack of an RN C algorithm is not surprising.
Reference: [KY76] <author> Donald E. Knuth and Andrew C. Yao. </author> <title> The complexity of nonuniform random number generation. </title> <editor> In Joseph F. Traub, editor, </editor> <booktitle> Algorithms and Complexity: New Directions and Recent Results, </booktitle> <pages> pages 357-428. </pages> <publisher> Academic Press, </publisher> <year> 1976. </year>
Reference-contexts: The system supplied random number generator and rounding will probably suffice. This problem of nonuniform selection is not new. It has been known for some time <ref> [KY76] </ref> that the fastest possible algorithm for nonuniform random selection has expected running time proportional to the entropy of the distribution being sampled; this section essentially 16 uses similar techniques to get high probability amortized bounds. Let M = W n be the sum of all weights.
Reference: [LLKS85] <author> Eugene L. Lawler, J. K. Lenstra, A. H. G. Rinooy Kan, and David B. Shmoys, </author> <title> editors. The Traveling Salesman Problem. </title> <publisher> John Wiley & Sons, </publisher> <year> 1985. </year>
Reference-contexts: The problem of identifying a subtour elimination constraint can be rephrased as the problem of finding a minimum cut in a graph with real-valued edge weights. Thus, cutting plane algorithms for the traveling salesman problem must solve a large number of minimum cut problems (see <ref> [LLKS85] </ref> for a survey of the area).
Reference: [Lom94] <author> Micael V. Lomonosov. </author> <title> On Monte Carlo estimates in network reliability. </title> <journal> Probability in the Engineering and Informational Sciences, </journal> <volume> 8 </volume> <pages> 245-264, </pages> <year> 1994. </year>
Reference-contexts: The improved algorithm with faster running times and processor bounds originally appeared in [KS93]. This paper combines results from those two conference papers. Lomonosov <ref> [Lom94] </ref> independently developed some of the basic intuitions leading to the Contraction Algorithm, using them to investigate questions of network reliability. 1.5 Related Work Subsequent to the initial presentation of this work [Kar93, KS93], several related papers based upon it have appeared.
Reference: [Mad68] <author> W. </author> <title> Mader. </title> <journal> Homomorphiesatze fur graphen. Math. Ann., </journal> <volume> 178 </volume> <pages> 154-168, </pages> <year> 1968. </year>
Reference: [Mat87] <author> D. W. Matula. </author> <title> Determining edge connectivity in O(nm). </title> <booktitle> In Proceedings of the 28 th Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 249-251. </pages> <publisher> IEEE, IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference-contexts: The basic technique is to pass information among the various flow computations, so that computing all n maximum flows together takes less time than computing each one separately. Applying this idea, Podderyugin [Pod73], Karzanov and Timofeev [KT86], and Matula <ref> [Mat87] </ref> independently discovered several algorithms which determine edge connectivity in unweighted graphs in O (mn) time. Hao and Orlin [HO94] obtained similar types of results for weighted graphs.
Reference: [Mat93] <author> D. W. Matula. </author> <title> A linear time 2+* approximation algorithm for edge connectivity. </title> <booktitle> In Proceedings of the 4 th Annual ACM-SIAM Symposium on Discrete Algorithms [ACM93], </booktitle> <pages> pages 500-504. </pages>
Reference-contexts: Scan-first search is also used by Gabow [Gab95] to improve the running time of his matroid algorithm to O (m+c 2 n log (n=c)) on undirected graphs. Matula <ref> [Mat93] </ref> uses scan-first search in an algorithm that approximates the minimum cut to within a multiplicative factor of (2 + *) in O (m) time. 4 1.3.3 Parallel algorithms Parallel algorithms for the minimum cut problem have also been explored, though with much less satisfactory results.
Reference: [Mul94] <author> Ketan Mulmuley. </author> <title> Computational Geometry. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: This number is simply the negative binomial distribution for the t th success with probability 1=2. Since the chances of success and failure are equal, we expect to see roughly the same number of successes as failures, namely t, for a total of 2t trials. The Chernoff bound (cf. <ref> [Mul94, page 427] </ref>) proves the probability that the number of trials exceeds 3t is exponentially small in t. <p> It follows that each time an edge is selected, the probability that it will be a good edge exceeds 2n=s. Given that we perform s selections, the expected number of good selections exceeds 2n. Then by the Chernoff bound <ref> [Che52, Mul94] </ref>, the probability that fewer than n good edges are selected is exponentially small in n. The number of contractions performed in an iteration is simply the number of good edges selected. Thus, by performing more than n good selections, the iteration will necessarily finish contracting the graph.
Reference: [MVV87] <author> Ketan Mulmuley, Umesh V. Vazirani, and Vijay V. Vazirani. </author> <title> Matching is as easy as matrix inversion. </title> <journal> Combinatorica, </journal> <volume> 7(1) </volume> <pages> 105-113, </pages> <year> 1987. </year>
Reference-contexts: For directed unweighted graphs, the RN C matching algorithms of Karp, Upfal, and Wigderson [KUW86] or Mulmuley, Vazi-rani, and Vazirani <ref> [MVV87] </ref> can be combined with a reduction of s-t maximum flow to matching [KUW86] to yield RN C algorithms for s-t minimum cuts.
Reference: [Neu51] <author> J. Von Neumann. </author> <title> Various techniques used in connection with random digits. National Bureau of Standards, </title> <journal> Applied Math Series, </journal> <volume> 12 </volume> <pages> 36-38, </pages> <year> 1951. </year>
Reference-contexts: An alternative scheme due to Von Neumann <ref> [Neu51] </ref> generates a random variate with the exact exponential distribution in constant expected time given a uniform random number generator. Details can be found in [Kar94b]. 6.3 Parallelizing the Contraction Algorithm Parallelizing the previous algorithms is simple.
Reference: [NI92] <author> Hiroshi Nagamochi and Toshihide Ibaraki. </author> <title> Computing edge connectivity in multigraphs and capacitated graphs. </title> <journal> SIAM Journal of Discrete Mathematics, </journal> <volume> 5(1) </volume> <pages> 54-66, </pages> <month> February </month> <year> 1992. </year> <month> 36 </month>
Reference-contexts: Padberg and Rinaldi [PR90] reported that the solution of minimum cut problems was the 2 minimum cut bounds unweighted weighted undirected directed undirected directed sequential previous c 2 n log n cm log m n 2 time [Gab95] <ref> [NI92] </ref> [HO94] this paper n 2 log 3 n n 2 log 3 n processors previous n 4:37 Unknown P-complete used [KUW86, GP88] [GSS82] in RN C this paper n 2 n 2 computational bottleneck in their state-of-the-art cutting-plane based algorithm. <p> The central idea is to repeatedly identify and contract edges that are not in the minimum cut until the minimum cut becomes apparent. It applies only to undi-rected graphs, but they may be weighted. Nagamochi and Ibaraki <ref> [NI92] </ref> give a procedure called scan-first search that identifies and contracts an edge that is not in the minimum cut in O (m + n log n) time. This yields an algorithm that computes the minimum cut in O (mn + n 2 log n) time. <p> However, any path between them crosses (A; B), so an edge crossing cut (A; B) would have had to be contracted. This contradicts our hypothesis. Lemma 2.1 is also the basis of Nagamochi and Ibaraki's minimum cut algorithm <ref> [NI92] </ref>. They give a linear-time deterministic algorithm for identifying and contracting a non-minimum-cut edge. Doing this n times (for a total running time of O (mn)) yields two vertices which by Lemma 2.1 define the minimum cut of the graph. <p> We might improve our chances of success if, after partially contracting the graph, we switched to a (possibly slower) algorithm with a better chance of success on what remains. One possibility is to use one of the deterministic minimum cut algorithms, such as that of <ref> [NI92] </ref>, and this indeed yields some improvement. However, a better observation is that an algorithm that is more likely to succeed than the Contraction Algorithm is two trials of the Contraction Algorithm. This suggests the Recursive Contraction Algorithm described in Figure 6.
Reference: [NV91] <author> Dalit Naor and Vijay V. Vazirani. </author> <title> Representing and enumerating edge connec-tivity cuts in RN C. </title> <editor> In F. Dehne, J. R. Sack, and N. Santoro, editors, </editor> <booktitle> Proceedings of the 2 nd Workshop on Algorithms and Data Structures, volume 519 of Lecture Notes in Computer Science, </booktitle> <pages> pages 273-285. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: It can be used to quickly identify, for example, all minimum cuts separating a particular pair of vertices. Karzanov and Timofeev [KT86] give an algorithm for constructing the cactus sequentially; their algorithm is parallelized by Naor and Vazi-rani <ref> [NV91] </ref>. We describe the general framework of both algorithms below. The reader is referred to [NV91] for a much more detailed description. 1. Number the vertices so that for each vertex (except vertex 1) is connected to at least one lower numbered vertex. 2. <p> Karzanov and Timofeev [KT86] give an algorithm for constructing the cactus sequentially; their algorithm is parallelized by Naor and Vazi-rani <ref> [NV91] </ref>. We describe the general framework of both algorithms below. The reader is referred to [NV91] for a much more detailed description. 1. Number the vertices so that for each vertex (except vertex 1) is connected to at least one lower numbered vertex. 2. <p> Step 3 can also be implemented relatively efficiently. Karzanov and Timofeev [KT86] describe a sequential implementation that, given the set of chains for each S i , takes O (n 2 ) time. Naor and Vazirani <ref> [NV91] </ref> do not explicitly bound their implementation of Step 3, but it can be shown to run in O (log 2 n) time using n 4 processors. <p> This led to a sequential algorithm that took ~ O (n 2 m) time [KT86] and an O (log 2 n) time randomized algorithm that used n 4:5 m processors on unweighted graphs <ref> [NV91] </ref>. We will explain how to implement Step 2 to run using the same amount of resources as the Recursive Contraction Algorithm (up to constant factors), thus leading to improved sequential time and parallel processor bounds.
Reference: [Pod73] <author> V. D. Podderyugin. </author> <title> An algorithm for finding the edge connectivity of graphs. </title> <address> Vopr. Kibern., 2:136, </address> <year> 1973. </year>
Reference-contexts: The basic technique is to pass information among the various flow computations, so that computing all n maximum flows together takes less time than computing each one separately. Applying this idea, Podderyugin <ref> [Pod73] </ref>, Karzanov and Timofeev [KT86], and Matula [Mat87] independently discovered several algorithms which determine edge connectivity in unweighted graphs in O (mn) time. Hao and Orlin [HO94] obtained similar types of results for weighted graphs.
Reference: [PQ82] <author> J. C. Picard and M. Queyranne. </author> <title> Selected applications of minimum cuts in networks. </title> <journal> I.N.F.O.R: Canadian Journal of Operations Research and Information Processing, </journal> <volume> 20 </volume> <pages> 394-422, </pages> <month> November </month> <year> 1982. </year>
Reference-contexts: is sometimes referred to as finding the connectivity of a graph, that is, determining the minimum number of edges (or minimum total edge weight) that must be removed to disconnect the graph. 1.2 Applications The minimum cut problem has many applications, some of which are surveyed by Picard and Queyranne <ref> [PQ82] </ref>. We discuss others here. The problem of determining the connectivity of a network arises frequently in issues of network design and network reliability [Col87]: in a network with random edge failures, the network is most likely to be partitioned at the minimum cuts.
Reference: [PR75] <author> J.C. Picard and H.D. Ratliff. </author> <title> Minimum cuts and related problems. </title> <journal> Networks, </journal> <volume> 5 </volume> <pages> 357-370, </pages> <year> 1975. </year>
Reference-contexts: Hence the global minimum cut must be a minimum s-t cut of the original graph. A different reduction <ref> [PR75] </ref> transforms a directed minimum s-t cut problem into an undirected minimum s-t cut problem.
Reference: [PR90] <author> M. Padberg and G. Rinaldi. </author> <title> An efficient algorithm for the minimum capacity cut problem. </title> <journal> Mathematical Programming, </journal> <volume> 47 </volume> <pages> 19-39, </pages> <year> 1990. </year>
Reference-contexts: Thus, cutting plane algorithms for the traveling salesman problem must solve a large number of minimum cut problems (see [LLKS85] for a survey of the area). Padberg and Rinaldi <ref> [PR90] </ref> reported that the solution of minimum cut problems was the 2 minimum cut bounds unweighted weighted undirected directed undirected directed sequential previous c 2 n log n cm log m n 2 time [Gab95] [NI92] [HO94] this paper n 2 log 3 n n 2 log 3 n processors previous
Reference: [PW92] <author> Steven Phillips and Jeffrey Westbrook. </author> <title> Online load balancing and network flow. </title> <booktitle> In Proceedings of the 24 th ACM Symposium on Theory of Computing [ACM92], </booktitle> <pages> pages 402-411. </pages>
Reference-contexts: Their early implementation of this method runs in O (nm log (n 2 =m)) time. Incrementally faster implementations appeared subsequently. Currently, the fastest deterministic algorithms, independently developed by King, Rao and Tarjan [KRT94] and by Phillips and Westbrook <ref> [PW92] </ref>) run in O (nm (log m n log n n)) time. Randomization has not helped signifi cantly. The fastest randomized maximum flow algorithm, developed by Cheriyan, Hagerup and Mehlhorn [CH95] runs in expected O (mn + n 2 log 2 n) time.
Reference: [Ram87] <author> Vijaya Ramachandran. </author> <title> Flow value, minimum cuts and maximum flows. </title> <type> Manuscript., </type> <year> 1987. </year>
Reference-contexts: Since we are now able to find a minimum cut faster than a maximum flow, it is natural to ask whether it is any easier to compute a maximum flow given a minimum cut. Ra-machandran <ref> [Ram87] </ref> has shown that knowing an s-t minimum cut is not helpful in finding an s-t maximum flow. However, the question of whether knowing any or all minimum cuts may help to find an s-t maximum flow remains open.
Reference: [RC87] <author> A. Ramanathan and Charles Colbourn. </author> <title> Counting almost minimum cutsets with reliability applications. </title> <journal> Mathematical Programming, </journal> <volume> 39(3) </volume> <pages> 253-61, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: If p is very small, then the value can be accurately approximated by considering f k only for small values of k. It therefore becomes important to to enumerate all minimum cuts and, if possible, all nearly minimum cuts <ref> [RC87] </ref>. In a more recent application [Kar95], this enumeration is used in a fully polynomial time approximation scheme for the all terminal network reliability problem. In information retrieval, minimum cuts have been used to identify clusters of topically related documents in hypertext systems [Bot93]. <p> In particular, we give tight bounds on the number of approximately minimum and multiway cuts in a graph. These results have important applications in the study of network reliability <ref> [RC87] </ref>. They have also been used in the development of fast algorithms for approximate solutions to minimum cut, maximum flow, and other graph problems [Kar94c, Kar94a]. A minor modification of our algorithm lets us use it to construct the cactus representation of minimum cuts introduced in [DKL76]. <p> The problem of finding all nearly minimum cuts has been shown to have important ramifications in the study of network reliability, since such enumerations allow one to drastically improve estimates of the reliability of a network. This was shown in <ref> [RC87] </ref>, where an O (n k+2 m k ) bound was given for the number of cuts of value c + k in a graph with minimum cut c, and an algorithm with running time O (n k+2 m k ) was given for finding them.
Reference: [ST83] <author> Daniel D. Sleator and Robert E. Tarjan. </author> <title> A data structure for dynamic trees. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 26(3) </volume> <pages> 362-391, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: In a contrasting result, we show that the directed minimum cut problem is P-complete and thus appears unlikely to have an RN C solution. Our algorithm is extremely simple and, unlike the best flow-based approaches, does not rely on any complicated data structures such as dynamic trees <ref> [ST83] </ref>. The most time consuming steps of the sequential version are simple computations on arrays, while the most time consuming steps in the parallel version are sorting and computing connected components. All of these computations can be performed practically and efficiently.
Reference: [SV82] <author> Y. Shiloach and Uzi Vishkin. </author> <title> An O(log n) parallel connectivity algorithm. </title> <journal> Journal of Algorithms, </journal> <volume> 3 </volume> <pages> 57-67, </pages> <year> 1982. </year>
Reference-contexts: We then use a parallel sorting algorithm on the resulting scores. Given the permutation, it is easy to run Compact in parallel. RN C algorithms for connected components exist that use m= log n processors and run in O (log n) time on a CRCW PRAM <ref> [SV82] </ref> or even on the EREW PRAM [HZ94]. Procedure Compact, which terminates after O (log n) iterations, is thus easily seen to be parallelizable to run in O (log 2 n) time using m processors.
Reference: [SW94] <author> Methchild Stoer and F. Wagner. </author> <title> A simple min cut algorithm. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Proceedings of the 1994 European Symposium on Algorithms, </booktitle> <pages> pages 141-147. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: This yields an algorithm that computes the minimum cut in O (mn + n 2 log n) time. Stoer and Wagner <ref> [SW94] </ref> subsequently gave a simplified version of the Nagamochi and Ibaraki algorithm with the same running time (this simplification was subsequently discovered independently by Frank [Fra94]).
Reference: [Tar83] <author> Robert E. Tarjan. </author> <title> Data Structures and Network Algorithms, </title> <booktitle> volume 44 of CBMS-NSF Regional Conference Series in Applied Mathematics. </booktitle> <publisher> SIAM, </publisher> <year> 1983. </year>
Reference-contexts: The Union-Find data structure of <ref> [Tar83, page 23] </ref> provides for an implementation of the Contraction Algorithm. We use the Union-Find data structure to identify sets of vertices that have been merged by the contractions. Initially, each vertex is in its own set. <p> This gives an overall running time of ~ O ((m + s)n 2 =s) = ~ O (n 2 + mn 2 =s). We can extend this unweighted-graph approach to weighted graphs, although the time bound becomes worse. As before, we use the union-find data structure of <ref> [Tar83] </ref> to contract edges as we select them. Instead of maintaining a list of all unsampled edges, we maintain a threshold X (t) such that any edge of weight exceeding X (t) has a high probability of being sampled within t trials.
Reference: [VY92] <author> Vijay V. Vazirani and Mihalis Yannakakis. </author> <title> Suboptimal cuts: Their enumeration, weight, and number. </title> <booktitle> In Automata, Languages and Programming. 19 th International Colloquium Proceedings, volume 623 of Lecture Notes in Computer Science, </booktitle> <pages> pages 366-377. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1992. </year> <month> 37 </month>
Reference-contexts: Remark: The disappearance of an O (log n) factor that was present in the 2-way cut case was brought to our attention by Jan Hvid Sorensen. Vazirani and Yannakakis <ref> [VY92] </ref> give algorithms for enumerating cuts by rank, finding the k th smallest cut in O (n 3k ) time, while we derive bounds based on the value of a cut relative to the others.
References-found: 74

