URL: ftp://ftp.cs.huji.ac.il/users/transis/TR96-7.ps.gz
Refering-URL: http://www.cs.huji.ac.il/~idish/Abstracts/tr96-7.html
Root-URL: http://www.cs.huji.ac.il
Email: Email: fdolev,idish,estig@cs.huji.ac.il  
Title: Dynamic Voting for Consistent Primary Components  
Author: Danny Dolev Idit Keidar Esti Yeger Lotem 
Note: 1 This work was supported by the United States Israel Binational Science Foundation, Grant No. 92 00189  
Date: June, 1996  
Address: Jerusalem, Israel  
Affiliation: Institute of Computer Science The Hebrew University of Jerusalem  
Web: Url: http://www.cs.huji.ac.il/f~dolev,~idish,~estig  
Pubnum: Technical Report CS96-7  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Y. Amir. </author> <title> Replication Using Group Communication Over a Dynamic Network. </title> <type> PhD thesis, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel, </institution> <year> 1995. </year>
Reference-contexts: It may be incorporated in many distributed applications that make progress in a primary component, e.g. replication algorithms [16, 9], transaction management [15], and even infrastructure systems like the ISIS toolkit [5]. If a failure occurs in the course of the protocol, some previously suggested protocols (e.g. <ref> [14, 1] </ref>) block until all the members of the last quorum become reconnected, while our protocol requires only a majority of the members that attempted to form the last quorum to become reconnected in order to make progress. <p> Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in <ref> [8, 12, 18, 14, 9, 1] </ref>. Each process is equipped with an underlying membership module, e.g. [2, 3, 10]. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected.
Reference: [2] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. </author> <title> Membership Algorithms for Multicast Communication Groups. </title> <booktitle> In Intl. Workshop on Distributed Algorithms proceedings (WDAG-6), (LNCS, </booktitle> <volume> 647), number 6, </volume> <pages> pages 292-312, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in [8, 12, 18, 14, 9, 1]. Each process is equipped with an underlying membership module, e.g. <ref> [2, 3, 10] </ref>. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected. Membership changes are reported to the process via special membership messages.
Reference: [3] <author> Y. Amir, L. E. Moser, P. M. Melliar-Smith, D. A. Agarwal, and P. Ciarfella. </author> <title> Fast Message Ordering and Membership using a Logical Token-Passing Ring. </title> <booktitle> In International Conference on Distributed Computing Systems, </booktitle> <volume> number 13, </volume> <pages> pages 551-560, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in [8, 12, 18, 14, 9, 1]. Each process is equipped with an underlying membership module, e.g. <ref> [2, 3, 10] </ref>. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected. Membership changes are reported to the process via special membership messages.
Reference: [4] <author> Y. Amir and A. Wool. </author> <title> Evaluating Quorum Systems over the Internet. </title> <booktitle> In The Fault-Tolerant Computing Symposium(FTCS), </booktitle> <pages> pages 26-35, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Thus, each newly formed quorum must contain a majority of the previous one, but not necessarily a majority of the sites. Stochastic models analysis [14], simulations [18], and empirical results <ref> [4] </ref> show that dynamic voting increases system availability, by increasing the probability that a primary component exists. In fact, the results in [4] show that dynamic voting is more available than any other paradigm for maintaining a primary component. <p> Stochastic models analysis [14], simulations [18], and empirical results <ref> [4] </ref> show that dynamic voting increases system availability, by increasing the probability that a primary component exists. In fact, the results in [4] show that dynamic voting is more available than any other paradigm for maintaining a primary component. Another important benefit of the dynamic voting paradigm is in its flexibility to support a dynamically changing set of processes.
Reference: [5] <author> K. Birman and R. V. Renesse. </author> <title> Reliable Distributed Computing with the Isis Toolkit. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Numerous fault tolerant distributed systems, e.g. ISIS <ref> [5] </ref>, use the primary component 1 paradigm to allow a subset of the processes to function when failures occur. A majority (or quorum) of the processes is usually chosen to be the primary component in the system. <p> Our protocol's communication and memory requirements are small and it is simple to implement. It may be incorporated in many distributed applications that make progress in a primary component, e.g. replication algorithms [16, 9], transaction management [15], and even infrastructure systems like the ISIS toolkit <ref> [5] </ref>.
Reference: [6] <author> T. Chandra, V. Hadzilacos, S. Toueg, and B. Charron-Bost. </author> <title> On the Impossibility of Group Membership. </title> <booktitle> In ACM Symp. on Prin. of Distributed Computing (PODC), </booktitle> <pages> pages 322-330, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: As shown in <ref> [6] </ref>, it is impossible to reach agreement upon the current membership in an asynchronous system without failure detection. Consequently, agreement on the primary component in the network is also impossible. Therefore, any protocol for this problem must assume some (not necessarily perfect) failure detection mechanism.
Reference: [7] <author> T. D. Chandra and S. Toueg. </author> <title> Unreliable Failure Detectors for Reliable Distributed Systems. </title> <journal> Journal of ACM, </journal> <volume> 43(2) </volume> <pages> 225-267, </pages> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: A similar idea was suggested in [17], where Chandra and Toueg's three phase consensus protocol <ref> [7] </ref> is employed. The status of past quorums is resolved before the installation of new ones. When a majority of the previous quorum reconnects, at least five communication rounds are needed in order to form a new quorum.
Reference: [8] <author> D. Davcev and W. Burkhard. </author> <title> Consistency and Recovery Control for Replicated Files. </title> <booktitle> In ACM Symp. on Operating Systems Principles, </booktitle> <volume> number 10, </volume> <pages> pages 87-96, </pages> <year> 1985. </year>
Reference-contexts: When partitions occur, such knowledge differences are inevitable: Once a site detaches, it is impossible for other sites to know whether it received a specific message before its detachment, or not. Some past protocols (e.g. <ref> [8, 18, 9] </ref>) lead to inconsistent results in such cases, as demonstrated by the following typical scenario: * The systems consists of five processes: a; b; c; d and e. <p> Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in <ref> [8, 12, 18, 14, 9, 1] </ref>. Each process is equipped with an underlying membership module, e.g. [2, 3, 10]. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected.
Reference: [9] <author> A. El Abbadi and S. Dani. </author> <title> A Dynamic Accessibility Protocol for Replicated Databases. </title> <journal> Data and Knowledge Engineering, </journal> (6):319-332, 1991. <volume> 16 </volume>
Reference-contexts: Our protocol's communication and memory requirements are small and it is simple to implement. It may be incorporated in many distributed applications that make progress in a primary component, e.g. replication algorithms <ref> [16, 9] </ref>, transaction management [15], and even infrastructure systems like the ISIS toolkit [5]. <p> When partitions occur, such knowledge differences are inevitable: Once a site detaches, it is impossible for other sites to know whether it received a specific message before its detachment, or not. Some past protocols (e.g. <ref> [8, 18, 9] </ref>) lead to inconsistent results in such cases, as demonstrated by the following typical scenario: * The systems consists of five processes: a; b; c; d and e. <p> Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in <ref> [8, 12, 18, 14, 9, 1] </ref>. Each process is equipped with an underlying membership module, e.g. [2, 3, 10]. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected.
Reference: [10] <author> P. D. Ezhilchelvan, A. Macedo, and S. K. Shrivastava. Newtop: </author> <title> a Fault Tolerant Group Communication Protocol. </title> <booktitle> In International Conference on Distributed Computing Systems, </booktitle> <volume> number 15, </volume> <pages> pages 296-306. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in [8, 12, 18, 14, 9, 1]. Each process is equipped with an underlying membership module, e.g. <ref> [2, 3, 10] </ref>. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected. Membership changes are reported to the process via special membership messages.
Reference: [11] <author> M. Herlihy. </author> <title> A Quorum-Consensus Replication Method for Abstract Data Types. </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> 4(1) </volume> <pages> 32-53, </pages> <month> Feb. </month> <year> 1986. </year>
Reference: [12] <author> S. Jajodia. </author> <title> Managing Replicated Files in Partitioned Distributed Database Systems. </title> <booktitle> In IEEE Int'l. Conf. on Data Engineering, </booktitle> <volume> number 3, </volume> <pages> pages 412-418, </pages> <year> 1987. </year>
Reference-contexts: Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in <ref> [8, 12, 18, 14, 9, 1] </ref>. Each process is equipped with an underlying membership module, e.g. [2, 3, 10]. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected. <p> Dynamic linear voting, first presented in <ref> [12] </ref>, optimizes the above with the following mechanism to break ties between groups of equal size: A linear order, L, is imposed on all the potential processes in the system, e.g. L can be the lexicographical order over an infinite name space.
Reference: [13] <author> S. Jajodia and D. Mutchler. </author> <title> A Hybrid Replica Control Algorithm Combining Static and Dynamic Voting. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(4), </volume> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: In our protocol, we incorporate a novel mechanism for providing this feature, in environments which allow new processes to join on the fly. Jajodia and Mutchler <ref> [13] </ref> suggest a similar idea in their hybrid algorithm. The hybrid algorithm combines dynamic voting in large quorums with static voting in quorums of size three, ruling out quorums consisting of a single process. <p> Neither algorithm is strictly better than the other: There are situations in which our algorithm allows the system to make progress while the algorithm in <ref> [13] </ref> does not, and vice versa. 2 Problem Definition In this paper we present a primary component maintenance service, that allows a group of processes to form a primary component in a consistent way.
Reference: [14] <author> S. Jajodia and D. Mutchler. </author> <title> Dynamic Voting Algorithms for Maintaining the Consistency of a Replicated Database. </title> <journal> ACM Trans. Database Systems, </journal> <volume> 15(2) </volume> <pages> 230-280, </pages> <year> 1990. </year>
Reference-contexts: Thus, each newly formed quorum must contain a majority of the previous one, but not necessarily a majority of the sites. Stochastic models analysis <ref> [14] </ref>, simulations [18], and empirical results [4] show that dynamic voting increases system availability, by increasing the probability that a primary component exists. In fact, the results in [4] show that dynamic voting is more available than any other paradigm for maintaining a primary component. <p> It may be incorporated in many distributed applications that make progress in a primary component, e.g. replication algorithms [16, 9], transaction management [15], and even infrastructure systems like the ISIS toolkit [5]. If a failure occurs in the course of the protocol, some previously suggested protocols (e.g. <ref> [14, 1] </ref>) block until all the members of the last quorum become reconnected, while our protocol requires only a majority of the members that attempted to form the last quorum to become reconnected in order to make progress. <p> Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in <ref> [8, 12, 18, 14, 9, 1] </ref>. Each process is equipped with an underlying membership module, e.g. [2, 3, 10]. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected.
Reference: [15] <author> I. Keidar and D. Dolev. </author> <title> Increasing the Resilience of Atomic Commit, at No Additional Cost. </title> <booktitle> In ACM Symp. on Prin. of Database Systems (PODS), </booktitle> <pages> pages 245-254, </pages> <month> May </month> <year> 1995. </year> <note> Previous version available as Technical Report CS94-18, </note> <institution> The Hebrew University, Jerusalem, Isreal. </institution>
Reference-contexts: Our protocol's communication and memory requirements are small and it is simple to implement. It may be incorporated in many distributed applications that make progress in a primary component, e.g. replication algorithms [16, 9], transaction management <ref> [15] </ref>, and even infrastructure systems like the ISIS toolkit [5]. <p> These protocols do not record historical information, and therefore, in case of failures, must consider all possible histories. This imposes severe limitations on the system's ability to make progress. Our protocol uses ideas similar to those used in the majority based Three Phase Commit (3PC) <ref> [21, 15] </ref> protocols to allow a majority in the system to make progress. <p> If they succeed, then at the end of the session they form a new primary component P , which persists until the next membership change. Each process independently invokes the protocol once it receives the membership message. The protocol we present resembles Three Phase Commit (3PC) protocols <ref> [20, 21, 15] </ref>. Each session of the protocol is conducted in three steps: In the first step the connected processes exchange information about quorums in past sessions.
Reference: [16] <author> I. Keidar and D. Dolev. </author> <title> Efficient Message Ordering in Dynamic Networks. </title> <booktitle> In ACM Symp. on Prin. of Distributed Computing (PODC), </booktitle> <volume> number 15, </volume> <pages> pages 68-76, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Our protocol's communication and memory requirements are small and it is simple to implement. It may be incorporated in many distributed applications that make progress in a primary component, e.g. replication algorithms <ref> [16, 9] </ref>, transaction management [15], and even infrastructure systems like the ISIS toolkit [5].
Reference: [17] <author> C. Malloth and A. Schiper. </author> <title> View Synchronous Communication in large scale networks. In Proceedings 2nd Open Workshop of the ESPRIT project BROADCAST (number 6360), </title> <note> July 1995 (also available as a Technical Report Nr. </note> <institution> 94/84 at Ecole Polytechnique Federale de Lausanne (Switzerland), </institution> <month> October </month> <year> 1994). </year>
Reference-contexts: However, explicitly running the 3PC recovery protocol to resolve the status of past quorums before forming new ones would induce a high overhead that would make the protocol infeasible for use in practice, and also increase the chance of failure during the protocol. A similar idea was suggested in <ref> [17] </ref>, where Chandra and Toueg's three phase consensus protocol [7] is employed. The status of past quorums is resolved before the installation of new ones. When a majority of the previous quorum reconnects, at least five communication rounds are needed in order to form a new quorum.
Reference: [18] <author> J. Paris and D. </author> <title> Long. Efficient Dynamic Voting Algorithms. </title> <booktitle> Proceedings 13th Int'l. Conf. on Very Large Data Bases, </booktitle> <pages> pages 268-275, </pages> <year> 1988. </year>
Reference-contexts: Thus, each newly formed quorum must contain a majority of the previous one, but not necessarily a majority of the sites. Stochastic models analysis [14], simulations <ref> [18] </ref>, and empirical results [4] show that dynamic voting increases system availability, by increasing the probability that a primary component exists. In fact, the results in [4] show that dynamic voting is more available than any other paradigm for maintaining a primary component. <p> When partitions occur, such knowledge differences are inevitable: Once a site detaches, it is impossible for other sites to know whether it received a specific message before its detachment, or not. Some past protocols (e.g. <ref> [8, 18, 9] </ref>) lead to inconsistent results in such cases, as demonstrated by the following typical scenario: * The systems consists of five processes: a; b; c; d and e. <p> Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in <ref> [8, 12, 18, 14, 9, 1] </ref>. Each process is equipped with an underlying membership module, e.g. [2, 3, 10]. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected.
Reference: [19] <author> A. M. Ricciardi and K. P. Birman. </author> <title> Using Process Groups to Implement Failure Detection in Asynchronous Environments. </title> <booktitle> In ACM Symp. on Prin. of Distributed Computing (PODC), </booktitle> <pages> pages 341-352, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: This approach is even more problematic in applications in which the set of participants is dynamic: one process that voluntarily leaves the system may cause all the other participants to block. Unlike some previous protocols (e.g. the protocols implemented in ISIS and Horus <ref> [19] </ref>), our protocol recovers from situations in which the primary component was lost (e.g. when the primary component partitions into three minority groups) without requiring a cold start of the entire system. 1 A component is sometimes called a partition.
Reference: [20] <author> D. Skeen. </author> <title> Nonblocking Commit Protocols. </title> <booktitle> In SIGMOD Intl. Conf. Management of Data, </booktitle> <pages> pages 133-142, </pages> <year> 1981. </year>
Reference-contexts: If they succeed, then at the end of the session they form a new primary component P , which persists until the next membership change. Each process independently invokes the protocol once it receives the membership message. The protocol we present resembles Three Phase Commit (3PC) protocols <ref> [20, 21, 15] </ref>. Each session of the protocol is conducted in three steps: In the first step the connected processes exchange information about quorums in past sessions.
Reference: [21] <author> D. Skeen. </author> <title> A Quorum-Based Commit Protocol. </title> <booktitle> In Berkeley Workshop on Distributed Data Management and Computer Networks, </booktitle> <volume> number 6, </volume> <pages> pages 69-80, </pages> <month> Feb. </month> <year> 1982. </year> <month> 17 </month>
Reference-contexts: These protocols do not record historical information, and therefore, in case of failures, must consider all possible histories. This imposes severe limitations on the system's ability to make progress. Our protocol uses ideas similar to those used in the majority based Three Phase Commit (3PC) <ref> [21, 15] </ref> protocols to allow a majority in the system to make progress. <p> If they succeed, then at the end of the session they form a new primary component P , which persists until the next membership change. Each process independently invokes the protocol once it receives the membership message. The protocol we present resembles Three Phase Commit (3PC) protocols <ref> [20, 21, 15] </ref>. Each session of the protocol is conducted in three steps: In the first step the connected processes exchange information about quorums in past sessions.
References-found: 21

