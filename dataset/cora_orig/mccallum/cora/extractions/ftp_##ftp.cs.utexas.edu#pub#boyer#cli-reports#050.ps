URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/050.ps
Refering-URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/index.html
Root-URL: 
Title: The Verification of a Minimum Node Algorithm  
Phone: (512) 322-9951  
Author: David M. Goldschlag 
Note: This work was supported in part at Computational Logic, Inc., by the Defense Advanced Research Projects Agency, ARPA Orders 6082 and 9151. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency or the U.S. Government.  
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic Inc.  
Abstract: Technical Report 50 November, 1989 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Bowen Alpern and Fred B. Schneider. </author> <title> "Defining Liveness". </title> <booktitle> Information Processing Letters 21 (1985), </booktitle> <pages> 181-185. </pages>
Reference-contexts: Specification Predicates The interesting properties of concurrent programs are safety and liveness (progress). Safety properties are those which state that something bad will never happen [2]; examples are invariant properties such as mutual exclusion and freedom from deadlock. Liveness properties guarantee that something good will eventually happen <ref> [1] </ref>; examples are termination and freedom from starvation. Unity defines predicates which specify subsets of these properties. Stable properties, a subset of safety properties, are specified using UNLESS; progress properties, a subset of liveness properties, are specified using ENSURES and LEADS-TO.
Reference: 2. <author> Bowen Alpern, Alan J. Demers, and Fred B. Schneider. </author> <title> "Safety Without Stuttering". </title> <booktitle> Information Processing Letters 23 (1986), </booktitle> <pages> 177-180. </pages>
Reference-contexts: Specification Predicates The interesting properties of concurrent programs are safety and liveness (progress). Safety properties are those which state that something bad will never happen <ref> [2] </ref>; examples are invariant properties such as mutual exclusion and freedom from deadlock. Liveness properties guarantee that something good will eventually happen [1]; examples are termination and freedom from starvation. Unity defines predicates which specify subsets of these properties.
Reference: 3. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: This question, which may be difficult to answer, need be answered only once for all proofs validated by the theorem prover. The theorem prover used in this work is the Boyer-Moore prover <ref> [3, 5] </ref> extended by the Kaufmann Proof Checker [15]. This prover has been carefully coded and extensively tested. The Boyer-Moore logic, which is mechanized by the Boyer-Moore prover, has been proved sound [14, 4].
Reference: 4. <author> R. S. Boyer and J S. Moore. Metafunctions: </author> <title> Proving Them Correct and Using Them Efficiently as New Proof Procedures. In The Correctness Problem in Computer Science, </title> <editor> R. S. Boyer and J S. Moore, Eds., </editor> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: The theorem prover used in this work is the Boyer-Moore prover [3, 5] extended by the Kaufmann Proof Checker [15]. This prover has been carefully coded and extensively tested. The Boyer-Moore logic, which is mechanized by the Boyer-Moore prover, has been proved sound <ref> [14, 4] </ref>. All of the definitions and theorems presented in this paper have been validated by the Boyer-Moore prover; many of the intermediate lemmas used in this process are not described. The rest of this paper requires some familiarity with the Boyer-Moore logic and its theorem prover.
Reference: 5. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: This question, which may be difficult to answer, need be answered only once for all proofs validated by the theorem prover. The theorem prover used in this work is the Boyer-Moore prover <ref> [3, 5] </ref> extended by the Kaufmann Proof Checker [15]. This prover has been carefully coded and extensively tested. The Boyer-Moore logic, which is mechanized by the Boyer-Moore prover, has been proved sound [14, 4]. <p> Examples of such theorems are Goedel's Incompleteness Theorem [24, 25], and the verification of a microprocessor [12]. 2.1 The Boyer-Moore Logic This proof system is specified in the Nqthm version of the Boyer-Moore logic <ref> [5, 6] </ref>. Nqthm is a quantifier free first order logic that permits recursive definitions. It also defines an interpreter function for the quotation of terms in the logic. Nqthm uses a prefix syntax similar to pure Lisp.
Reference: 6. <author> R. S. Boyer and J S. Moore. </author> <title> The Addition of Bounded Quantification and Partial Functions to A Computational Logic and Its Theorem Prover. </title> <type> Tech. </type> <institution> Rept. ICSCA-CMP-52, Institute for Computer Science, University of Texas at Austin, </institution> <month> January, </month> <year> 1988. </year> <note> To appear in the Journal of Automated Reasoning, 1988. Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703.. </address>
Reference-contexts: Examples of such theorems are Goedel's Incompleteness Theorem [24, 25], and the verification of a microprocessor [12]. 2.1 The Boyer-Moore Logic This proof system is specified in the Nqthm version of the Boyer-Moore logic <ref> [5, 6] </ref>. Nqthm is a quantifier free first order logic that permits recursive definitions. It also defines an interpreter function for the quotation of terms in the logic. Nqthm uses a prefix syntax similar to pure Lisp. <p> function FUNC to the arguments ARGS. 2 For example, (APPLY$ 'PLUS (LIST 1 2)) is (PLUS 1 2) which is 3. 1 Actually, the quote mechanism is a facility of the Lisp reader [27]. 2 This simple definition is only true for total functions but is sufficient for this paper <ref> [6] </ref>. 3 Recursive definitions are permitted, provided termination can be proved.
Reference: 7. <author> R.S. Boyer, D. Goldschlag, M. Kaufmann, J Strother Moore. </author> <title> Functional Instantiation in First Order Logic. </title> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <year> 1991, </year> <pages> pp. 7-26. </pages>
Reference-contexts: To ensure the consistency of partially constrained function symbols, one must present one old function symbol as a model for each new symbol. Every constraint, with each new symbol substituted by its model, must be provable <ref> [7] </ref>. 2.4 The Kaufmann Proof Checker The Boyer-Moore prover automatically proves a lemma by heuristically applying sound inference rules to simplify it to a value other than F. Sometimes, it is easier to direct the proof process at a lower level.
Reference: 8. <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley, </publisher> <address> Massachusetts, </address> <year> 1988. </year>
Reference-contexts: In the example in this paper, the specification is completely described in under two pages; the proof and program are incompletely summarized in fourteen. The proof system for concurrent programs presented in this paper is based on Unity <ref> [8] </ref>, which has two important characteristics: Unity provides predicates for specifications, and proof rules to derive specifications directly from the program text. This type of proof strategy is often clearer and more succinct than an argument about a program's operational behavior. Unity separates the concerns of algorithm and architecture. <p> Therefore, (FORALL X (FORALL Y (EQUAL X Y))) may be abbreviated to (FORALL (X Y) (EQUAL X Y)). Nested EXISTS's may be shortened similarly. 3. The Operational Semantics The first level of this proof system formalizes an operational definition of concurrency based on the transition system model <ref> [20, 19, 8] </ref>. A transition system is a set of statements that effect transitions on the system state. A computation is the sequence of states generated by the composition of an infinite sequence of transitions on an initial state. <p> A computation is the sequence of states generated by the composition of an infinite sequence of transitions on an initial state. Fair computations are computations where every statement is responsible for an infinite number of transitions. This type of fairness is often called weak fairness <ref> [8] </ref>; the corresponding computations are often called just computations [20]. We are only interested in fair computations, since those permit the proof of liveness properties (if a statement is ignored forever, certain properties may not be provable). <p> In this proof system, Unity's substitution axiom only applies to computation properties [23, 22]; these are LEADS-TO, INVARIANT, and EVENTUALLY-INVARIANT. The last theorem of this section, the PSP theorem, combines a progress and a safety property to yield a progress property <ref> [8] </ref>. Theorem: Psp (IMPLIES (AND (LEADS-TO P Q PRG) (UNLESS R B PRG) (LISTP PRG)) (LEADS-TO (LIST 'AND P R) (LIST 'OR (LIST 'AND Q R) B) PRG)) This theorem is proved by induction on the computation. <p> However, if the theorem prover is trusted, then one can simply believe the (expensive) mechanically verified proof and focus on the more difficult issue of analyzing whether the specification that was proved is appropriate for the problem being solved. The proof rules of Unity's LEADS-TO <ref> [8] </ref> are theorems of the LEADS-TO presented here. This augments the conceptual simplicity of non-operational correctness arguments with the soundness provided by an operational semantics. No axioms are present in this proof system; all concepts are developed from first principles.
Reference: 9. <author> E.M. Clarke and O. Grumberg. </author> <title> Research on Automatic Verification of Finite State Systems. </title> <type> Tech. </type> <address> Rept. CS-87-105, CMU, </address> <month> January, </month> <year> 1987. </year>
Reference-contexts: Hence, this proof system is suitable for the mechanical verification of many concurrent programs [10]. Completely automatic systems for the mechanical verification of concurrent programs are cheaper to use <ref> [9] </ref>; however these proof checkers use decision procedures which are necessarily restricted to certain classes of theorems.
Reference: 10. <author> David Goldschlag. </author> <title> A Mechanically Verified Proof System for Concurrent Programs. Computational Logic, </title> <publisher> Inc. </publisher> <address> Austin Texas 78703, </address> <month> January, </month> <year> 1989. </year> <type> Technical Report 32. </type>
Reference-contexts: Because of this, the complexity of theorems which may be proved depends on the skill of the user, rather than the theorem being in some class suitable for a decision procedure. Hence, this proof system is suitable for the mechanical verification of many concurrent programs <ref> [10] </ref>. Completely automatic systems for the mechanical verification of concurrent programs are cheaper to use [9]; however these proof checkers use decision procedures which are necessarily restricted to certain classes of theorems.
Reference: 11. <author> C.A.R. Hoare. </author> <title> "An Axiomatic Basis for Computer Programming". </title> <booktitle> CACM 12 (1969), </booktitle> <pages> 271-281. </pages>
Reference-contexts: Aside from this, however, the definition of ENSURES here differs slightly from Unity's. In Unity, using Hoare triples <ref> [11] </ref>, the definition of ENSURES is: P ENSURES Q (P UNLESS Q $S : S IN PRG :: -PQ- S -Q-) Our ENSURES does not imply UNLESS; to achieve the same effect, one states that both hold (e.g., (AND (UNLESS P Q PRG) (ENSURES P Q PRG))). 8 Unity does not
Reference: 12. <author> Warren A. Hunt, Jr. </author> <title> "Microprocessor Design Verification". </title> <journal> Journal of Automated Reasoning 5, </journal> <month> 4 (December </month> <year> 1989), </year> <pages> 429-460. </pages>
Reference-contexts: By the judicious choice of lemmas and the order of their presentation, a user may guide the theorem prover through the verification of complicated theorems. Examples of such theorems are Goedel's Incompleteness Theorem [24, 25], and the verification of a microprocessor <ref> [12] </ref>. 2.1 The Boyer-Moore Logic This proof system is specified in the Nqthm version of the Boyer-Moore logic [5, 6]. Nqthm is a quantifier free first order logic that permits recursive definitions. It also defines an interpreter function for the quotation of terms in the logic.
Reference: 13. <author> Charanjit S. Jutla, Edgar Knapp, and Josyula R. Rao. </author> <title> Extensional Semantics of Parallel Programs. </title> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <month> November, </month> <year> 1988. </year>
Reference-contexts: Furthermore, Unity's method for defining LEADS-TO allows one to use induction on the length of the proof (structural induction) to prove theorems about LEADS-TO. The soundness and completeness of Unity's LEADS-TO are discussed in <ref> [13] </ref>. However, if an operational semantics is formalized, and LEADS-TO is correctly defined using those functions, then the definition is sound. Furthermore, it is easy to infer the meaning of this LEADS-TO, and to see that it is the predicate that Unity's axioms mean to define.
Reference: 14. <author> M. Kaufmann. </author> <title> A Formal Semantics and Proof of Soundness for the Logic of the NQTHM Version of the Boyer-Moore Theorem Prover. </title> <institution> Institute for Computing Science, University of Texas at Austin, Austin, </institution> <address> TX 78712, </address> <year> 1986. </year> <note> ICSCA Internal Note 229. </note>
Reference-contexts: The theorem prover used in this work is the Boyer-Moore prover [3, 5] extended by the Kaufmann Proof Checker [15]. This prover has been carefully coded and extensively tested. The Boyer-Moore logic, which is mechanized by the Boyer-Moore prover, has been proved sound <ref> [14, 4] </ref>. All of the definitions and theorems presented in this paper have been validated by the Boyer-Moore prover; many of the intermediate lemmas used in this process are not described. The rest of this paper requires some familiarity with the Boyer-Moore logic and its theorem prover.
Reference: 15. <author> M. Kaufmann. </author> <title> A User's Manual for an Interactive Enhancement to the Boyer-Moore Theorem Prover. </title> <type> Tech. </type> <institution> Rept. ICSCA-CMP-60, Institute for Computing Science, University of Texas at Austin, Austin, </institution> <address> TX 78712, </address> <year> 1987. </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. </address>
Reference-contexts: This question, which may be difficult to answer, need be answered only once for all proofs validated by the theorem prover. The theorem prover used in this work is the Boyer-Moore prover [3, 5] extended by the Kaufmann Proof Checker <ref> [15] </ref>. This prover has been carefully coded and extensively tested. The Boyer-Moore logic, which is mechanized by the Boyer-Moore prover, has been proved sound [14, 4]. <p> Sometimes, it is easier to direct the proof process at a lower level. The Kaufmann Proof Checker <ref> [15] </ref> is an interactive enhancement to the Boyer-Moore prover. It allows the user to manipulate a formula (the original goal) using sound operations; once all remaining goals have been proved, the original formula has been proved.
Reference: 16. <author> Matt Kaufmann. DEFN-SK: </author> <title> An Extension of the Boyer-Moore Theorem Prover to Handle First-Order Quantifiers. </title> <type> Tech. </type> <institution> Rept. </institution> <month> 43, </month> <title> Computational Logic, </title> <publisher> Inc., </publisher> <month> May, </month> <year> 1989. </year> <note> Draft. </note>
Reference-contexts: Since the Boyer-Moore logic does not define quantifiers, the quantifiers must be removed by a technique called skolemization. If the definition is not recursive, adding the skolemized definition preserves the theory's consistency <ref> [16] </ref>. For example, suppose we wish to define: Definition. (P X 1 X 2 . . .
Reference: 17. <author> Leslie Lamport. </author> . . <type> Personal Communication. </type>
Reference-contexts: A Sample Program This section presents a mechanically verified distributed algorithm that computes the minimum node value in a tree <ref> [17] </ref>. The purpose of this section is to describe, by means of a simple example, how to mechanically verify a concurrent program on the Boyer-Moore prover using the theorems presented earlier. Although the algorithm is relatively simple, the proof was quite difficult.
Reference: 18. <author> Leslie Lamport. </author> <title> "A Simple Approach to Specifying Concurrent Systems". </title> <booktitle> Communications of the ACM 32 (1989), </booktitle> <pages> 32-45. </pages>
Reference-contexts: Since atomicity is implementation dependent, we will not be concerned with the atomicity of statements here. 5 3.1 A Concurrent Program To permit non-deterministic program statements, 4 each statement is a relation from previous states to next states <ref> [18] </ref>. We define the function N so the term (N OLD NEW E) is true if and only if NEW is a possible successor state to OLD under the transition specified by E.
Reference: 19. <author> Z. Manna and A. Pnueli. </author> <title> Verification of Concurrent Programs: The Temporal Framework. In The Correctness Problem in Computer Science, </title> <editor> R. S. Boyer and J S. Moore, Eds., </editor> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year> <month> 35 </month>
Reference-contexts: Therefore, (FORALL X (FORALL Y (EQUAL X Y))) may be abbreviated to (FORALL (X Y) (EQUAL X Y)). Nested EXISTS's may be shortened similarly. 3. The Operational Semantics The first level of this proof system formalizes an operational definition of concurrency based on the transition system model <ref> [20, 19, 8] </ref>. A transition system is a set of statements that effect transitions on the system state. A computation is the sequence of states generated by the composition of an infinite sequence of transitions on an initial state.
Reference: 20. <author> Zohar Manna and Amir Pnueli. </author> <title> "Adequate Proof Principles for Invariance and Liveness Properties of Concurrent Programs". </title> <booktitle> Science of Computer Programming 4 (1984), </booktitle> <pages> 257-289. </pages>
Reference-contexts: Therefore, (FORALL X (FORALL Y (EQUAL X Y))) may be abbreviated to (FORALL (X Y) (EQUAL X Y)). Nested EXISTS's may be shortened similarly. 3. The Operational Semantics The first level of this proof system formalizes an operational definition of concurrency based on the transition system model <ref> [20, 19, 8] </ref>. A transition system is a set of statements that effect transitions on the system state. A computation is the sequence of states generated by the composition of an infinite sequence of transitions on an initial state. <p> Fair computations are computations where every statement is responsible for an infinite number of transitions. This type of fairness is often called weak fairness [8]; the corresponding computations are often called just computations <ref> [20] </ref>. We are only interested in fair computations, since those permit the proof of liveness properties (if a statement is ignored forever, certain properties may not be provable). Notice however, that fairness is a very weak restriction on the scheduling of statements.
Reference: 21. <author> Jayadev Misra. </author> <title> Preserving Progress Under Program Composition. </title> <booktitle> Tech. Rept. Notes on UNITY: </booktitle> <pages> 17-90, </pages> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <month> July, </month> <year> 1990. </year>
Reference-contexts: Furthermore, it is easy to infer the meaning of this LEADS-TO, and to see that it is the predicate that Unity's axioms mean to define. Also, LEADS-TO may be meaningfully negated; this negation implies eventual stability. All theorems (except for several new compositional theorems <ref> [21, 26] </ref>) about Unity's LEADS-TO are theorems of the LEADS-TO presented here and are proved by induction on the second argument to S (the index in the computation). Such theorems allow the proof of progress properties without appealing to the operational semantics and are equivalent to Unity's proof rules. 5.
Reference: 22. <author> Jayadev Misra. </author> <title> Soundess of the Substitution Axiom. </title> <booktitle> Tech. Rept. Notes on UNITY: </booktitle> <pages> 14-90, </pages> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <month> March, </month> <year> 1990. </year>
Reference-contexts: This satisfies the second proof obligation, so we may conclude that (LEADS-TO Q R PRG) is true. This use of the two theorems Invariant-Implies and Leads-To-Strengthen-Left (or Leads-To-Weaken-Right) replaces Unity's substitution axiom. In this proof system, Unity's substitution axiom only applies to computation properties <ref> [23, 22] </ref>; these are LEADS-TO, INVARIANT, and EVENTUALLY-INVARIANT. The last theorem of this section, the PSP theorem, combines a progress and a safety property to yield a progress property [8].
Reference: 23. <author> B. A. Sanders. </author> <title> Stepwise Refinement of Mixed Specifications of Concurrent Programs. In Programming Concepts and Methods, </title> <editor> M. Broy and C. B. Jones, Eds., </editor> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: This satisfies the second proof obligation, so we may conclude that (LEADS-TO Q R PRG) is true. This use of the two theorems Invariant-Implies and Leads-To-Strengthen-Left (or Leads-To-Weaken-Right) replaces Unity's substitution axiom. In this proof system, Unity's substitution axiom only applies to computation properties <ref> [23, 22] </ref>; these are LEADS-TO, INVARIANT, and EVENTUALLY-INVARIANT. The last theorem of this section, the PSP theorem, combines a progress and a safety property to yield a progress property [8].
Reference: 24. <author> N. Shankar. </author> <title> Proof Checking Metamathematics: Volumes I and II. </title> <type> Technical Report 9, </type> <institution> Computational Logic, Inc., </institution> <month> April, </month> <year> 1987. </year>
Reference-contexts: By the judicious choice of lemmas and the order of their presentation, a user may guide the theorem prover through the verification of complicated theorems. Examples of such theorems are Goedel's Incompleteness Theorem <ref> [24, 25] </ref>, and the verification of a microprocessor [12]. 2.1 The Boyer-Moore Logic This proof system is specified in the Nqthm version of the Boyer-Moore logic [5, 6]. Nqthm is a quantifier free first order logic that permits recursive definitions.
Reference: 25. <author> N. Shankar. </author> <title> "A Mechanical Proof of the Church-Rosser Theorem". </title> <journal> Journal of the ACM 35 (1988), </journal> <pages> 475-522. </pages>
Reference-contexts: By the judicious choice of lemmas and the order of their presentation, a user may guide the theorem prover through the verification of complicated theorems. Examples of such theorems are Goedel's Incompleteness Theorem <ref> [24, 25] </ref>, and the verification of a microprocessor [12]. 2.1 The Boyer-Moore Logic This proof system is specified in the Nqthm version of the Boyer-Moore logic [5, 6]. Nqthm is a quantifier free first order logic that permits recursive definitions.
Reference: 26. <author> Ambuj Singh. </author> <title> Leads-To and Program Union. </title> <booktitle> Tech. Rept. Notes on UNITY: </booktitle> <pages> 06-89, </pages> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <month> June, </month> <year> 1989. </year>
Reference-contexts: Furthermore, it is easy to infer the meaning of this LEADS-TO, and to see that it is the predicate that Unity's axioms mean to define. Also, LEADS-TO may be meaningfully negated; this negation implies eventual stability. All theorems (except for several new compositional theorems <ref> [21, 26] </ref>) about Unity's LEADS-TO are theorems of the LEADS-TO presented here and are proved by induction on the second argument to S (the index in the computation). Such theorems allow the proof of progress properties without appealing to the operational semantics and are equivalent to Unity's proof rules. 5.
Reference: 27. <author> G. L. Steele, Jr. </author> <title> Common Lisp The Language. </title> <publisher> Digital Press, </publisher> <address> 30 North Avenue, Burlington, MA 01803, </address> <year> 1984. </year> <title> i Table of Contents </title>
Reference-contexts: X is an element of the list L. (APPLY$ FUNC ARGS) is the result of applying the function FUNC to the arguments ARGS. 2 For example, (APPLY$ 'PLUS (LIST 1 2)) is (PLUS 1 2) which is 3. 1 Actually, the quote mechanism is a facility of the Lisp reader <ref> [27] </ref>. 2 This simple definition is only true for total functions but is sufficient for this paper [6]. 3 Recursive definitions are permitted, provided termination can be proved. <p> For instance, (EVAL$ T (LIST 'PLUS 'X (LIST 'QUOTE Y)) (LIST (CONS 'X 5))) is (PLUS 5 Y). Unfortunately, (EVAL$ T (LIST 'PLUS 'X (LIST 'QUOTE Y)) (LIST (CONS 'X 5))) is somewhat difficult to read. The Lisp backquote syntax <ref> [27] </ref> can be used to write an equivalent expression. 3 Backquote (`) is similar to quote (') except that under backquote, terms preceded by a comma are not evaluated, which is precisely the desired effect. <p> follows: Definition: (ALL-EMPTY CHANNELS STATE) = (IF (LISTP CHANNELS) (AND (EMPTY (CAR CHANNELS) STATE) (ALL-EMPTY (CDR CHANNELS) STATE)) T) ALL-CHANNELS is defined as follows: Definition: (ALL-CHANNELS TREE) = (APPEND (UP-LINKS (CDR (NODES TREE)) TREE) (DOWN-LINKS (NODES TREE) TREE)) where UP-LINKS and DOWN-LINKS are defined as follows: 11 Lisp dot notation <ref> [27] </ref>. 25 Definition: (UP-LINKS NODES TREE) = (IF (LISTP NODES) (CONS (CONS (CAR NODES) (PARENT (CAR NODES) TREE)) (UP-LINKS (CDR NODES) TREE)) NIL) Definition: (DOWN-LINKS NODES TREE) = (IF (LISTP NODES) (APPEND (DOWN-LINKS-1 (CAR NODES) (CHILDREN (CAR NODES) TREE)) (DOWN-LINKS (CDR NODES) TREE)) NIL) Definition: 12 (DOWN-LINKS-1 PARENT CHILDREN) = (IF
Reference: 1. <institution> Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 </institution>
Reference-contexts: Specification Predicates The interesting properties of concurrent programs are safety and liveness (progress). Safety properties are those which state that something bad will never happen [2]; examples are invariant properties such as mutual exclusion and freedom from deadlock. Liveness properties guarantee that something good will eventually happen <ref> [1] </ref>; examples are termination and freedom from starvation. Unity defines predicates which specify subsets of these properties. Stable properties, a subset of safety properties, are specified using UNLESS; progress properties, a subset of liveness properties, are specified using ENSURES and LEADS-TO.






References-found: 28

