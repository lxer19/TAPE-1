URL: http://www.cs.rice.edu/CS/PLT/Publications/popl92-cf.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Observable Sequentiality and Full Abstraction  
Author: Robert Cartwright Matthias Felleisen 
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: One of the major challenges in denotational semantics is the construction of fully abstract models for sequential programming languages. For the past fifteen years, research on this problem has focused on developing models for PCF, an idealized functional programming language based on the typed lambda calculus. Unlike most practical languages, PCF has no facilities for observing and exploiting the evaluation order of arguments in procedures. Since we believe that such facilities are crucial for understanding the nature of sequential computation, this paper focuses on a sequential extension of PCF (called SPCF) that includes two classes of control operators: error generators and escape handlers. These new control operators enable us to construct a fully abstract model for SPCF that interprets higher types as sets of error-sensitive functions instead of continuous functions. The error-sensitive functions form a Scott domain that is isomorphic to a domain of decision trees. We believe that the same construction will yield fully abstract models for functional languages with different control operators for observing the order of evaluation. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Barendregt, </author> <title> H.P. The Lambda Calculus: Its Syntax and Semantics. Revised Edition. </title> <booktitle> Studies in Logic and the Foundations of Mathematics 103. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: By induction on n for each approximation K n and S n . This implies that the fi axiom for bracket abstractions is valid in this model <ref> [1] </ref>. Corollary 4.8 ((fi)) For combinator terms M , M 0 , ( fl x:M )M 0 = M [x M 0 ].
Reference: 2. <author> Berry, G. </author> <title> Modeles completement adequats et stables des lambda-calculus type. </title> <type> Ph.D. dissertation, </type> <institution> Universite Paris VII, </institution> <year> 1979. </year>
Reference-contexts: Unfortunately, neither Mil-ner's nor Plotkin's result showed how to construct fully abstract denotational models for sequential languages. In a later effort to understand the semantics of sequential languages, Berry and Curien <ref> [2, 3, 5, 8] </ref> constructed models for PCF with more restrictive domains of procedure denotations. Berry eliminated many parallel functions from the domain of procedure denotations by forcing functions to be stable.
Reference: 3. <author> Berry, G. and P-L. Curien. </author> <title> Sequential algorithms on concrete data structures. </title> <journal> Theor. Comput. Sci. </journal> <volume> 20, </volume> <year> 1982, </year> <pages> 265-321. </pages>
Reference-contexts: Unfortunately, neither Mil-ner's nor Plotkin's result showed how to construct fully abstract denotational models for sequential languages. In a later effort to understand the semantics of sequential languages, Berry and Curien <ref> [2, 3, 5, 8] </ref> constructed models for PCF with more restrictive domains of procedure denotations. Berry eliminated many parallel functions from the domain of procedure denotations by forcing functions to be stable. <p> Berry eliminated many parallel functions from the domain of procedure denotations by forcing functions to be stable. This construction eliminated some of the spurious distinctions between phrases in the conventional model, but it introduced some new ones. 2 To address this problem, Berry and Curien <ref> [3, 4] </ref> imposed further restrictions on the space of procedure denotations by interpreting procedures as sequential algorithms over concrete domains [12]. A sequential algorithm is a function plus a strategy for evaluating its arguments. <p> Each meaning function E t is a map from closed SPCF terms to trees in the appropriate domain. To define these meaning functions, we rely on extensions of the translation and abstraction algorithms, [] CL and fl for PCF (see 3 Berry and Curien <ref> [3] </ref> proposed representing procedures as trees in their work on concrete sequential algorithms. Since their domains do not include error elements, they associate distinct trees with the same function. For example, + l and + r denote distinct concrete sequential algorithms but denote the same function [3:316].
Reference: 4. <author> Berry, G. and P-L. Curien. </author> <title> Theory and practice of sequential algorithms: the kernel of the applicative language cds. In Algebraic Methods in Semantics, edited by J. </title> <editor> Reynolds and M.Nivat. </editor> <publisher> Cam-bridge University Press. </publisher> <address> London, </address> <year> 1985, </year> <pages> 35-88. </pages>
Reference-contexts: Berry eliminated many parallel functions from the domain of procedure denotations by forcing functions to be stable. This construction eliminated some of the spurious distinctions between phrases in the conventional model, but it introduced some new ones. 2 To address this problem, Berry and Curien <ref> [3, 4] </ref> imposed further restrictions on the space of procedure denotations by interpreting procedures as sequential algorithms over concrete domains [12]. A sequential algorithm is a function plus a strategy for evaluating its arguments. <p> Since their domains do not include error elements, they associate distinct trees with the same function. For example, + l and + r denote distinct concrete sequential algorithms but denote the same function [3:316]. In this framework, evaluation information is intensional. In later work <ref> [4, 8] </ref>, Berry and Curien noted that sequential algorithms can distinguish different algorithms for the same function [8:210]. But they did not make a connection between intensional procedures and control operators like catch. <p> SPCF is not the first observably sequential language that has been studied in the context of the full abstraction problem. In their work on sequential algorithms, Berry and Currien defined an observably sequential language called CDS0 <ref> [4] </ref>. The sequential algorithms model for CDS0 is fully abstract, but it is not extensional or error-sensitive. Obviously, PCF and PPCF (PCF with parallel operations) are not observably sequential. We conjecture that our construction of a fully abstract model carries over to other observably sequential programming languages.
Reference: 5. <author> Berry, G., P-L. Curien, and P.-P. L evy. </author> <title> Full-abstraction of sequential languages: the state of the art. In Algebraic Methods in Semantics, edited by J. </title> <editor> Reynolds and M.Nivat. </editor> <publisher> Cambridge University Press. </publisher> <address> London, </address> <year> 1985, </year> <pages> 89-131. </pages>
Reference-contexts: Unfortunately, neither Mil-ner's nor Plotkin's result showed how to construct fully abstract denotational models for sequential languages. In a later effort to understand the semantics of sequential languages, Berry and Curien <ref> [2, 3, 5, 8] </ref> constructed models for PCF with more restrictive domains of procedure denotations. Berry eliminated many parallel functions from the domain of procedure denotations by forcing functions to be stable. <p> However, like Milner's original fully abstract model, Mulmuley's model is "syntactic" in flavor because his construction relies on the syntactic notion of observational equivalence. For more details on the history of the full abstraction problem for sequential languages, we refer the reader to two extensive surveys <ref> [5, 23] </ref>. 1.2 Summary of Results Fifteen years after Milner's and Plotkin's original work, the fundamental question still remains: Are there fully abstract denotational models for sequential programming languages? In this paper, we answer the question affirmatively by showing how to construct fully abstract denotational models for an observably sequential functional
Reference: 6. <author> Cartwright, R. and A. Demers. </author> <title> The topology of program termination. </title> <booktitle> In Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1988, </year> <pages> 296-308. </pages>
Reference-contexts: In the third and fourth subsection, we assign interpretations to the procedural constants and the combinators associated with SPCF, and prove the basic equational properties of the tree model. 4.1 Domains A Scott domain is the ideal completion of a finitary basis <ref> [6, 18, 19] </ref>. A finitary basis B is a countable, partially ordered set such that every finite, bounded subset has a least upper bound; the principal ideals corresponding to elements of B are the finite elements of the domain determined by B (the set of ideals over B).
Reference: 7. <author> Cartwright, R.S. and M. Felleisen. </author> <title> Observable sequentiality and full abstraction. </title> <type> Technical Report TR91-167. </type> <institution> Rice University Department of Computer Science, </institution> <year> 1991. </year>
Reference-contexts: Due to space limitations, this paper only sketches the construction of the model and the proof of the full abstraction theorem. We refer the interested reader to an extended version of the paper <ref> [7] </ref>. 2 PCF PCF is a simple functional language based on the typed -calculus with numerals, increment and decrement procedures on numerals, conditionals, and a family of fixed-point combinators. <p> This sketch omits a proof that the term M indeed represents the subtree e, but given the term, this proof can be constructed based on the equations about catch in the previous section. For a more detailed proof, we refer the reader to our technical report <ref> [7] </ref>. 6 Observable Sequentiality in PCF It is easy to show that SPCF is sequential.
Reference: 8. <author> Curien, P-L. </author> <title> Categorical Combinators, Sequential Algorithms, </title> <booktitle> and Functional Programming. Research Notes in Theoretical Computer Science. </booktitle> <address> Pi-man, London. </address> <year> 1986. </year>
Reference-contexts: Unfortunately, neither Mil-ner's nor Plotkin's result showed how to construct fully abstract denotational models for sequential languages. In a later effort to understand the semantics of sequential languages, Berry and Curien <ref> [2, 3, 5, 8] </ref> constructed models for PCF with more restrictive domains of procedure denotations. Berry eliminated many parallel functions from the domain of procedure denotations by forcing functions to be stable. <p> Since their domains do not include error elements, they associate distinct trees with the same function. For example, + l and + r denote distinct concrete sequential algorithms but denote the same function [3:316]. In this framework, evaluation information is intensional. In later work <ref> [4, 8] </ref>, Berry and Curien noted that sequential algorithms can distinguish different algorithms for the same function [8:210]. But they did not make a connection between intensional procedures and control operators like catch.
Reference: 9. <author> Felleisen, M. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1988, </year> <pages> 180-190. </pages>
Reference-contexts: However, it does not yield fully abstract models for sequential languages that include control de-limiters <ref> [9] </ref> (such as prompt). The inclusion of control delimiters in a language prevents it from being error-sensitive, because delimiters swallow all errors generated within their dynamic extent. Consequently, there 14 is still an important class of sequential functional lan-guages for which the full abstraction problem remains open. Acknowledgements.
Reference: 10. <author> Felleisen, M. and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Technical Report 100, </type> <institution> Rice University, </institution> <month> June </month> <year> 1989. </year> <institution> Theor. Comput. Sci., </institution> <year> 1991, </year> <note> to appear. </note>
Reference-contexts: Corollary 4.8 ((fi)) For combinator terms M , M 0 , ( fl x:M )M 0 = M [x M 0 ]. To determine the important equations for catch and error values, we draw on our operational intuition about capturing the behavior of control operators with reduction rules <ref> [10, 11] </ref>. The main idea is to formalize the notion of a program counter for program text, that is, a tool that determines which term in a program must be evaluated next in order to determine the program's answer. <p> The rest follows directly. 11 The equations for catch, the natural equations for the numerical primitives, and fi completely determine an operational reduction semantics for SPCF <ref> [10, 11] </ref>.
Reference: 11. <author> Felleisen, M., D. Friedman, E. Kohlbecker, and B. Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theor. Comput. Sci. </journal> <volume> 52(3), </volume> <year> 1987, </year> <pages> 205-237. </pages> <note> Preliminary version in: Proc. Symposium on Logic in Computer Science, </note> <year> 1986, </year> <pages> 131-141. </pages>
Reference-contexts: Corollary 4.8 ((fi)) For combinator terms M , M 0 , ( fl x:M )M 0 = M [x M 0 ]. To determine the important equations for catch and error values, we draw on our operational intuition about capturing the behavior of control operators with reduction rules <ref> [10, 11] </ref>. The main idea is to formalize the notion of a program counter for program text, that is, a tool that determines which term in a program must be evaluated next in order to determine the program's answer. <p> The rest follows directly. 11 The equations for catch, the natural equations for the numerical primitives, and fi completely determine an operational reduction semantics for SPCF <ref> [10, 11] </ref>.
Reference: 12. <author> Kahn, G. and G. Plotkin. </author> <note> Structures des donnes concretes. INRIA Report 336. </note> <year> 1978. </year>
Reference-contexts: This construction eliminated some of the spurious distinctions between phrases in the conventional model, but it introduced some new ones. 2 To address this problem, Berry and Curien [3, 4] imposed further restrictions on the space of procedure denotations by interpreting procedures as sequential algorithms over concrete domains <ref> [12] </ref>. A sequential algorithm is a function plus a strategy for evaluating its arguments. While this approach eliminates all parallel functions, the resulting model is not extensional because it contains different procedure denotations with exactly the same behavior under application.
Reference: 13. <author> Meyer, A. R. and K. Sieber. </author> <title> Towards a fully abstract semantics for local variables. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1988, </year> <pages> 191-203. </pages>
Reference-contexts: Consequently, the conventional model for such functional languages fails to identify p i and p. Essentially the same example can be constructed in any practical deterministic programming language where procedures can be passed as parameters <ref> [13, 20] </ref>. For example, in call-by-value languages, the procedures p i can be rewritten so that the parameter f takes constant procedures as arguments and uses these procedures to simulate call-by-name boolean arguments [20]. Indeed, all commonly used deterministic languages are sequential.
Reference: 14. <author> Milner, R. </author> <title> Fully abstract models of typed - calculi. </title> <journal> Theor. Comput. Sci. </journal> <volume> 4, </volume> <year> 1977, </year> <pages> 1-22. </pages>
Reference-contexts: Practical languages eschew parallel operations like parallel-and because they are painful to implement and encourage hideously inefficient programming. Even deterministic languages for parallel machines like C fl [17] are sequential. 1.1 Summary of Previous Work Milner <ref> [14] </ref> and Plotkin [16] were the first researchers to study the full abstraction problem for sequential languages. They focused on constructing fully abstract models for PCF, a call-by-name functional language based on the typed -calculus. The above example shows that the continuous function model for PCF is not fully abstract. <p> Figure 1 contains the conventional function model of PCF; it interprets each type ! t as the set of all continuous functions from type into type t . Given a denotational model M for the language L, we define the notion of observational equivalence and full abstraction as follows <ref> [14] </ref>. Definition 2.1. (Denotational Equivalence, Observational Equivalence, Full Abstraction) Two closed expressions, M and M 0 , in L are denotationally equivalent in a model M, written M M M 0 iff E [[M ]] = E [[M 0 ]].
Reference: 15. <author> Mulmuley, K. </author> <title> Full Abstraction and Semantic Equivalences. </title> <type> Ph.D. dissertation, </type> <institution> Carnegie Mel-lon University, </institution> <address> 1985. </address> <publisher> MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1986. </year>
Reference-contexts: In addition, PCF cannot express all of the observations that characterize sequential algorithms, such as the order of argument evaluation. As a result, the sequential algorithm model for PCF is not fully abstract. Recently, Mulmuley <ref> [15] </ref> generalized Milner's work by showing how to construct a fully abstract model for PCF as a quotient of a conventional model based on lattices instead of cpos. Mulmuley defined a retraction on the conventional model that equates all parallel functions with the "overdefined" element top (&gt;).
Reference: 16. <author> Plotkin, G.D. </author> <title> LCF considered as a programming language. </title> <journal> Theor. Comput. Sci. </journal> <volume> 5, </volume> <year> 1977, </year> <pages> 223-255. </pages>
Reference-contexts: Practical languages eschew parallel operations like parallel-and because they are painful to implement and encourage hideously inefficient programming. Even deterministic languages for parallel machines like C fl [17] are sequential. 1.1 Summary of Previous Work Milner [14] and Plotkin <ref> [16] </ref> were the first researchers to study the full abstraction problem for sequential languages. They focused on constructing fully abstract models for PCF, a call-by-name functional language based on the typed -calculus. The above example shows that the continuous function model for PCF is not fully abstract. <p> The equations also suffice to show in the representability lemma of the following section that certain terms represent given finite elements. 5 The Full Abstraction Theorem Plotkin <ref> [16] </ref> showed that an order-extensional model of PCF with parallel operations is fully abstract if the language can define all finite elements in the model. Exactly the same argument carries over to SPCF.
Reference: 17. <author> Rose, J.R. and G.L. Steele Jr. </author> <title> C*: An extended C language for data parallel programming. </title> <booktitle> In Proc. Second International Conference on Supercomputing. International Supercomputing Institute, </booktitle> <publisher> Inc. </publisher> <address> (Santa Clara, </address> <booktitle> 1987) Volume II, </booktitle> <pages> 2-16. </pages> <note> Also available as: Technical Report No. </note> <institution> PL87-5, Thinking Machines Corporation, </institution> <year> 1987. </year>
Reference-contexts: In informal terms, a language is sequential if it can be implemented without timeslicing among multiple threads of control. Practical languages eschew parallel operations like parallel-and because they are painful to implement and encourage hideously inefficient programming. Even deterministic languages for parallel machines like C fl <ref> [17] </ref> are sequential. 1.1 Summary of Previous Work Milner [14] and Plotkin [16] were the first researchers to study the full abstraction problem for sequential languages. They focused on constructing fully abstract models for PCF, a call-by-name functional language based on the typed -calculus.
Reference: 18. <author> Scott, D. S. </author> <title> Domains for denotational semantics. </title> <booktitle> In Proc. International Conference on Automata, Languages, and Programming, Lecture Notes in Mathematics 140, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1982. </year>
Reference-contexts: In the third and fourth subsection, we assign interpretations to the procedural constants and the combinators associated with SPCF, and prove the basic equational properties of the tree model. 4.1 Domains A Scott domain is the ideal completion of a finitary basis <ref> [6, 18, 19] </ref>. A finitary basis B is a countable, partially ordered set such that every finite, bounded subset has a least upper bound; the principal ideals corresponding to elements of B are the finite elements of the domain determined by B (the set of ideals over B).
Reference: 19. <author> Scott, </author> <title> D.S. Lectures on a Mathematical Theory of Computation. </title> <type> Techn. Monograph PRG-19, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <year> 1981. </year>
Reference-contexts: In the third and fourth subsection, we assign interpretations to the procedural constants and the combinators associated with SPCF, and prove the basic equational properties of the tree model. 4.1 Domains A Scott domain is the ideal completion of a finitary basis <ref> [6, 18, 19] </ref>. A finitary basis B is a countable, partially ordered set such that every finite, bounded subset has a least upper bound; the principal ideals corresponding to elements of B are the finite elements of the domain determined by B (the set of ideals over B). <p> It is easy to show that apply and match are well-defined, i.e., apply only uses match on arguments for which it is defined, and apply returns a subtree of the stipulated type and tree context. The function apply determines an approximable mapping on finite decision trees <ref> [19] </ref>. Consequently, we can extend apply to a continuous function on arbitrary elements. More importantly, we can prove that the model is order-extensional . 4 4 P.L. Curien (ENS) [personal communication, August 1991] pointed out that the order-extensionality theorem does not hold if the model only contains one error value.
Reference: 20. <author> Sitaram, D. and M. Felleisen. </author> <title> Reasoning with continuations II: Full abstraction for models of control. </title> <booktitle> In Proc. 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990, </year> <pages> 161-175. </pages>
Reference-contexts: Consequently, the conventional model for such functional languages fails to identify p i and p. Essentially the same example can be constructed in any practical deterministic programming language where procedures can be passed as parameters <ref> [13, 20] </ref>. For example, in call-by-value languages, the procedures p i can be rewritten so that the parameter f takes constant procedures as arguments and uses these procedures to simulate call-by-name boolean arguments [20]. Indeed, all commonly used deterministic languages are sequential. <p> For example, in call-by-value languages, the procedures p i can be rewritten so that the parameter f takes constant procedures as arguments and uses these procedures to simulate call-by-name boolean arguments <ref> [20] </ref>. Indeed, all commonly used deterministic languages are sequential. In informal terms, a language is sequential if it can be implemented without timeslicing among multiple threads of control. Practical languages eschew parallel operations like parallel-and because they are painful to implement and encourage hideously inefficient programming. <p> Consequently, a program cannot determine the order of evaluation among the arguments in a procedure application. To express these computations, the program must be able to delimit the dynamic extent of control actions such as generating 4 errors <ref> [20] </ref>. For this reason, many practical languages include an error handling facility or a non-local control operator. The original version of Scheme [22], for example, contained a lexically-scoped catch construct for implementing non-local exits from expressions. <p> Procedure denotations contain more computational structure than ordinary function graphs. Conventional models for languages like SPCF are written in "continuation-passing style" to cope with the behavior of control operators. Since this form of model contains parallel functions, it is not fully abstract for sequential languages <ref> [20] </ref>. To construct a fully abstract model for SPCF, we need to develop a new form of model that excludes parallel functions. The informal operational semantics of SPCF (particularly the catch operator) suggests that procedure denotations should have more internal structure than function graphs.
Reference: 21. <author> Steele, G.L., Jr. </author> <title> Common Lisp|The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference: 22. <author> Steele, G.L., Jr. and G.J. Sussman. </author> <title> The revised report on Scheme, a dialect of Lisp. Memo 452, </title> <publisher> MIT AI-Lab, </publisher> <year> 1978. </year>
Reference-contexts: To express these computations, the program must be able to delimit the dynamic extent of control actions such as generating 4 errors [20]. For this reason, many practical languages include an error handling facility or a non-local control operator. The original version of Scheme <ref> [22] </ref>, for example, contained a lexically-scoped catch construct for implementing non-local exits from expressions.
Reference: 23. <author> Stoughton, A. </author> <title> Fully Abstract Models of Programming Languages. </title> <booktitle> Research Notes in Theoretical Computer Science. </booktitle> <address> Piman, London. </address> <year> 1986. </year> <month> 15 </month>
Reference-contexts: However, like Milner's original fully abstract model, Mulmuley's model is "syntactic" in flavor because his construction relies on the syntactic notion of observational equivalence. For more details on the history of the full abstraction problem for sequential languages, we refer the reader to two extensive surveys <ref> [5, 23] </ref>. 1.2 Summary of Results Fifteen years after Milner's and Plotkin's original work, the fundamental question still remains: Are there fully abstract denotational models for sequential programming languages? In this paper, we answer the question affirmatively by showing how to construct fully abstract denotational models for an observably sequential functional
References-found: 23

