URL: ftp://ftp.cs.utexas.edu/pub/predator/tr-95-04.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/jthomas/publications.html
Root-URL: 
Email: -jthomas, batory-@cs.utexas.edu  
Title: P2: An Extensible Lightweight DBMS  
Author: Jeff Thomas and Don Batory 
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: A lightweight database system (LWDB) is a high-performance, application-specific DBMS. It differs from a general-purpose (heavyweight) DBMS in that it omits one or more features and specializes the implementation of its features to maximize performance. Although heavyweight monolithic and extensible DBMSs might be able to emulate LWDB capabilities, they cannot match LWDB performance. In this paper, we explore LWDB applications, systems, and implementation techniques. We describe P2, an extensible lightweight DBMS, and explain how it was used to reengineer a hand-coded, highly-tuned LWDB used in a production system compiler (LEAPS). We present results that show P2-generated LWDBs for LEAPS executes substantially faster than versions built by hand or that use an extensible heavyweight DBMS.
Abstract-found: 1
Intro-found: 1
Reference: [Bat88] <author> D. Batory, J. Barnett, J. Garza, K. Smith, K. Tsukuda, B. Twichell, and T. Wise, </author> <title> Genesis: An Extensible Database Management System, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> November </month> <year> 1988, </year> <pages> pages 1711-1730. </pages>
Reference-contexts: Extensible or open database systems were a major step toward DBMS customization (e.g., TIs Open OODB [Wel92], IBMs Starburst [Haa90], Berkeleys Postgres/Miro/Illustra [Sto91-93], Wisconsins Exodus [Car90], and Texass Genesis <ref> [Bat88] </ref>). Extensible DBMSs enabled individual features or groups of features to be added or removed from a general-purpose DBMS to produce a database system that more closely matched the needs of target applications. <p> LEAPS persistent used Jupiter, the heavyweight extensible file manager of Genesis <ref> [Bat88] </ref>, for persistent storage. We used RL to generate a single P2 program for each OPS5 rule set.
Reference: [Bat92] <author> D. Batory and S. OMalley, </author> <title> The Design and Implementation of Hierarchical Software Systems with Reusable Components, </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> Vol. 1, No. 4, </volume> <month> October </month> <year> 1992, </year> <pages> pages 355-398. </pages>
Reference-contexts: Consequently, P2 must rely on a powerful model of software generation. P2 is based on GenVoca, a scalable model of software construction <ref> [Bat92, Bat94b] </ref>. GenVoca is a distillation and generalization of the concepts that were originally developed in Genesis (a database system generator), and later in Avoca/x-kernel (communications protocol generator [Hut91]), Ficus (file system generator [Hei94]), and ADAGE (avionics generator [Cog93]).
Reference: [Bat93] <author> D. Batory, V. Singhal, M. Sirkin, and J. Thomas, </author> <title> Scalable Software Libraries, </title> <booktitle> ACM SIGSOFT, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: Such a library would be exponential in size (i.e., the number of distinct LWDBs that have some subset of n fea tures is 2 n ), and would constantly be growing (i.e., n would always increase) <ref> [Bat93, Big94] </ref>. The key to solving this mismatch problem is one of generation: to cover a wide spectrum of LWDB implementations, there needs to be a tool to construct any member of a large family of LWDBs automatically. <p> Thus, GenVoca does not eliminate the problem of feature combinatorics, but simply makes it explicit. Combinations of components are called type equations, and P2 type equations occupy only a few lines of any P2 application. P2 is a sophisticated preprocessor and component library comprising over 50,000 lines of C <ref> [Bat93, Bat94c] </ref>. It works by translating an abstract P2 program into a concrete C program. The P2 program is abstract and not executable, as it is a C program that references P2 data types and programming constructs that have no implementation. <p> Such functions are evaluated as soon as possible in P2-generated code (i.e., immediately after the joins where all cursor arguments have been found [Hel93]). Further details about type equations and the design and implementation of P2 components are discussed in <ref> [Bat93, Bat94c] </ref>. 5 LEAPS The LEAPS (Lazy Evaluation Algorithm for Production Systems) production system compiler produces the fastest sequential executables of OPS5 rule sets [Mir90-91]. A LEAPS executable is a database application, because it represents its database of assertions as a set of containers.
Reference: [Bat94a] <author> D. Batory, </author> <title> The LEAPS Algorithms, </title> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <type> Technical Report 94-28. </type>
Reference-contexts: To reduce string matching time, symbol tables are created so that fast pointer comparisons can be used in place of string comparisons, and so on. Further details of the features of LEAPS LWDBs are discussed in <ref> [Bat94a] </ref>. 6 Results There are two different hand-coded versions of LEAPS: LEAPS transient (also called OPS5c) produces executables that store containers in transient memory [Mir90-91]; LEAPS persistent (also called DATEX) produces executables that store containers in persistent memory [Bra93]. <p> The LEAPS algorithms have long been known to be difficult to understand; expressing them in P2 substantially clarified their explanation <ref> [Bat94a] </ref>. Our last experiment demonstrated the value of being able to easily modify LWDB implementations (Figure 11). The vast majority of execution time in LEAPS is spent joining containers.
Reference: [Bat94b] <author> D. Batory, V. Singhal, J. Thomas, S. Dasari, B. Geraci, and M. Sirkin, </author> <title> The GenVoca Model of Software System Generators, </title> <journal> IEEE Software, </journal> <month> September </month> <year> 1994, </year> <pages> pages 89-94. </pages>
Reference-contexts: Consequently, P2 must rely on a powerful model of software generation. P2 is based on GenVoca, a scalable model of software construction <ref> [Bat92, Bat94b] </ref>. GenVoca is a distillation and generalization of the concepts that were originally developed in Genesis (a database system generator), and later in Avoca/x-kernel (communications protocol generator [Hut91]), Ficus (file system generator [Hei94]), and ADAGE (avionics generator [Cog93]).
Reference: [Bat94c] <author> D. Batory, J. Thomas, and M. Sirkin, </author> <title> Reengineering a Complex Application Using a Scalable Data Structure Compiler, </title> <booktitle> ACM SIGSOFT, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: Thus, GenVoca does not eliminate the problem of feature combinatorics, but simply makes it explicit. Combinations of components are called type equations, and P2 type equations occupy only a few lines of any P2 application. P2 is a sophisticated preprocessor and component library comprising over 50,000 lines of C <ref> [Bat93, Bat94c] </ref>. It works by translating an abstract P2 program into a concrete C program. The P2 program is abstract and not executable, as it is a C program that references P2 data types and programming constructs that have no implementation. <p> Such functions are evaluated as soon as possible in P2-generated code (i.e., immediately after the joins where all cursor arguments have been found [Hel93]). Further details about type equations and the design and implementation of P2 components are discussed in <ref> [Bat93, Bat94c] </ref>. 5 LEAPS The LEAPS (Lazy Evaluation Algorithm for Production Systems) production system compiler produces the fastest sequential executables of OPS5 rule sets [Mir90-91]. A LEAPS executable is a database application, because it represents its database of assertions as a set of containers. <p> The timing results presented here were obtained on a SPARCstation 5 with 32 MB of RAM running SunOS 4.1.3 using the gcc 2.5.8 compiler with the -O2 option. Similar results have been obtained on other architectures <ref> [Bat94c] </ref>. Our first experiment revealed the overheads imposed by heavyweight systems (Figure 9). We compared the performance of LEAPS persistent executables to RL persistent executables; persistence of RL persistent containers was achieved by merely swapping the transient storage component in the P2 type equations with a memory-mapped component.
Reference: [Big94] <author> T. Biggerstaff, </author> <title> The Library Scaling Problem and the Limits of Concrete Component Reuse, </title> <booktitle> Proceedings of the Third International Conference on Reuse, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: Such a library would be exponential in size (i.e., the number of distinct LWDBs that have some subset of n fea tures is 2 n ), and would constantly be growing (i.e., n would always increase) <ref> [Bat93, Big94] </ref>. The key to solving this mismatch problem is one of generation: to cover a wide spectrum of LWDB implementations, there needs to be a tool to construct any member of a large family of LWDBs automatically.
Reference: [Boo87] <author> G. Booch, </author> <title> Software Components with Ada, </title> <address> Benjamin/Cummings, </address> <year> 1987. </year> <month> 16 </month>
Reference: [Bra91] <author> D. Brant, T. Grose, B Lofaso, and D. Miranker, </author> <title> Effects of Database Size on Rule System Performance: Five Case Studies, </title> <booktitle> Proceedings of the 17th International Conference on Very Large Data Bases (VLDB), </booktitle> <year> 1991. </year>
Reference-contexts: In all cases, modifying the type equations of a P2 program took minutes; no other source code had to be modified. For our evaluation, we used a collection of OPS5 rule setstripl, manners, waltz, and waltzdbthat have become standard benchmarks for evaluating the performance of OPS5 execution engines <ref> [Bra91] </ref>. We ran each benchmark with a series of different input file sizes, where size is measured by the number of initial assertions.
Reference: [Bra93] <author> D. Brant and D. Miranker, </author> <title> Index Support for Rule Activation, </title> <booktitle> ACM SIGMOD, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Further details of the features of LEAPS LWDBs are discussed in [Bat94a]. 6 Results There are two different hand-coded versions of LEAPS: LEAPS transient (also called OPS5c) produces executables that store containers in transient memory [Mir90-91]; LEAPS persistent (also called DATEX) produces executables that store containers in persistent memory <ref> [Bra93] </ref>. LEAPS persistent used Jupiter, the heavyweight extensible file manager of Genesis [Bat88], for persistent storage. We used RL to generate a single P2 program for each OPS5 rule set.
Reference: [Car90] <author> M. J. Carey, D. J. DeWitt, G. Graefe, D. M. Haight, J. E. Richardson, D. T. Schuh, E. J. Shekita, and S. Vandenberg, </author> <title> The Exodus Extensible DBMS Project: An Overview, </title> <editor> in D. Maier and S. Zdonik (editors), </editor> <booktitle> Readings on Object-Oriented Database Systems, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: Extensible or open database systems were a major step toward DBMS customization (e.g., TIs Open OODB [Wel92], IBMs Starburst [Haa90], Berkeleys Postgres/Miro/Illustra [Sto91-93], Wisconsins Exodus <ref> [Car90] </ref>, and Texass Genesis [Bat88]). Extensible DBMSs enabled individual features or groups of features to be added or removed from a general-purpose DBMS to produce a database system that more closely matched the needs of target applications.
Reference: [Cog93] <author> L. Coglianese and R. Szymanski, </author> <title> DSSA-ADAGE: An Environment for Architecture-based Avionics Development, </title> <booktitle> Proceedings of AGARD 1993. </booktitle>
Reference-contexts: P2 is based on GenVoca, a scalable model of software construction [Bat92, Bat94b]. GenVoca is a distillation and generalization of the concepts that were originally developed in Genesis (a database system generator), and later in Avoca/x-kernel (communications protocol generator [Hut91]), Ficus (file system generator [Hei94]), and ADAGE (avionics generator <ref> [Cog93] </ref>). GenVoca is scalable, because it is possible to build vast families of software systems from a small number of components. The key is that GenVoca components encapsulate individual features; combinations of features are expressed as compositions of components.
Reference: [Coo88] <author> T. Cooper and Nancy Wogrin, </author> <title> Rule-based Programming with OPS5, </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: LEAPS is typical of a LWDB application, because it uses unusual search algorithms and novel container implementations to enhance 10 rule processing efficiency; no heavyweight DBMS could offer the performance or features needed by LEAPS. OPS5 is a forward-chaining rule programming language <ref> [Coo88] </ref>. An OPS5 program is a set of rules; an OPS5 rule named done is shown below.
Reference: [Haa90] <author> L. Haas, W. Chang, G. Lohman, J. McPherson, P. Wilms, G. Lapis, B. Lindsay, H. Pirahesh, M. Carey, and E. Shekita, </author> <title> Starburst Mid-Flight: As the Dust Clears, </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990, </year> <pages> pages 143-161. </pages>
Reference-contexts: It is well-known that there are many applications that, in principle, could use a database system, but are precluded from doing so by performance constraints (e.g., LEAPS [Mir90-91]). Extensible or open database systems were a major step toward DBMS customization (e.g., TIs Open OODB [Wel92], IBMs Starburst <ref> [Haa90] </ref>, Berkeleys Postgres/Miro/Illustra [Sto91-93], Wisconsins Exodus [Car90], and Texass Genesis [Bat88]). Extensible DBMSs enabled individual features or groups of features to be added or removed from a general-purpose DBMS to produce a database system that more closely matched the needs of target applications.
Reference: [Hey94] <author> M. Heytens, S. Listgarten, M. Neimat, K. Wilkinson, Smallbase: </author> <title> A Main-Memory DBMS for High-Performance Applications, </title> <type> HP Labs Technical Report, </type> <month> December </month> <year> 1994. </year>
Reference-contexts: A lightweight DBMS is an application-specific, high-performance DBMS that omits one or more features of a heavyweight DBMS and specializes the implementations of its features to maximize performance. Examples of LWDBs include main memory DBMSs (e.g., Smallbase <ref> [Hey94] </ref>), persistent stores (e.g., Texas [Sin92]), and primitive code libraries (e.g., Booch Components [Boo88]).
Reference: [Hei94] <author> J.S. Heideman and G.J. Popek, </author> <title> File-System Development with Stackable Layers, </title> <journal> ACM Transactions on Computer Systems, </journal> <month> February </month> <year> 1994. </year>
Reference-contexts: P2 is based on GenVoca, a scalable model of software construction [Bat92, Bat94b]. GenVoca is a distillation and generalization of the concepts that were originally developed in Genesis (a database system generator), and later in Avoca/x-kernel (communications protocol generator [Hut91]), Ficus (file system generator <ref> [Hei94] </ref>), and ADAGE (avionics generator [Cog93]). GenVoca is scalable, because it is possible to build vast families of software systems from a small number of components. The key is that GenVoca components encapsulate individual features; combinations of features are expressed as compositions of components.
Reference: [Hel94] <author> J.M. Hellerstein, </author> <title> Practical Predicate Placement, </title> <booktitle> ACM SIGMOD 1994. </booktitle>
Reference: [Hut91] <author> N. Hutchinson and L. Peterson, </author> <title> The x-kernel: an Architecture for Implementing Network Protocols, </title> <journal> IEEE Trans. Software Engineering, </journal> <month> January </month> <year> 1991. </year>
Reference-contexts: P2 is based on GenVoca, a scalable model of software construction [Bat92, Bat94b]. GenVoca is a distillation and generalization of the concepts that were originally developed in Genesis (a database system generator), and later in Avoca/x-kernel (communications protocol generator <ref> [Hut91] </ref>), Ficus (file system generator [Hei94]), and ADAGE (avionics generator [Cog93]). GenVoca is scalable, because it is possible to build vast families of software systems from a small number of components. The key is that GenVoca components encapsulate individual features; combinations of features are expressed as compositions of components.
Reference: [Kel82] <author> A. Keller, </author> <title> Updates to Relational Database Through Views Involving Joins, </title> <editor> in P. Scheuermann (editor), </editor> <title> Improving Database Usability and Responsiveness, </title> <publisher> Academic Press, </publisher> <year> 1982. </year>
Reference-contexts: // typical usage--print names of // each element of all 3-tuples foreach ( k ) - printf (( %s, %s, %s )"n, k.x.name, k.y.name, k.z.name); - (c) Cursor Declaration and Usage 7 Akin to modifying tuples through database views, P2 permits the elements of a composite cursor to be updated <ref> [Kel82] </ref>. Instead of restricting the updates that can be performed, our analysis of LWDB applications suggested a very different approach was needed: updates should not be restricted, but updates may effect the tuples that are subsequently retrieved.
Reference: [Leh86] <author> T. Lehman and M. Carey, </author> <title> Query Processing in Main Memory Database Management Systems, </title> <booktitle> ACM SIGMOD, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: We are currently extending the capabilities of P2. New components will offer additional DBMS features (e.g., concurrency control, client/server architecture, set-oriented queries) as well as a greater variety of implementations of existing features (e.g., t-trees <ref> [Leh86] </ref> and sort-merge joins). This will allow us to use P2 to generate LWDBs for a broader range of applications. One feature in particular that would be important would be a SQL front-end to P2.
Reference: [Mir90] <author> D. Miranker, D. Brant, B. Lofaso, and D. Gadbois, </author> <title> On the Performance of Lazy Matching in Production Systems, </title> <booktitle> Proc. National Conference on Artificial Intelligence, </booktitle> <year> 1990. </year>
Reference: [Mir91] <author> D. Miranker and B. Lofaso, </author> <title> The Organization and Performance of a TREAT Based Production System Compiler, </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1991. </year>
Reference: [Sha86] <author> L.D. Shapiro, </author> <title> Join Processing in Database Systems with Large Main Memories, </title> <journal> ACM Transactions on Database Systems, </journal> <month> September </month> <year> 1986. </year>
Reference-contexts: As the use of nested loops is required by LEAPS, this did not preclude us from storing elements of a container using a hashed structure. Combining nested loops with hashed structures effectively allowed us to emulate performance of hash-join algorithm <ref> [Sha86] </ref>. To achieve this modification required two extra P2 components to be written and added to the type equations of RL transient source files. (These components took a few days to write; the type equations took a few minutes to edit).
Reference: [Sin92] <author> V. Singhal, S. Kakkad, and P. Wilson, </author> <title> Texas: An Efficient, Portable Persistent Store, Persistent Object Systems: </title> <booktitle> Proc. Fifth International Workshop on Persistent Object Systems (San Miniato, </booktitle> <address> Italy), </address> <month> September </month> <year> 1992, </year> <pages> pages 11-33. </pages>
Reference-contexts: A lightweight DBMS is an application-specific, high-performance DBMS that omits one or more features of a heavyweight DBMS and specializes the implementations of its features to maximize performance. Examples of LWDBs include main memory DBMSs (e.g., Smallbase [Hey94]), persistent stores (e.g., Texas <ref> [Sin92] </ref>), and primitive code libraries (e.g., Booch Components [Boo88]).
Reference: [Sto91] <author> M. Stonebraker and G. Kemnitz, </author> <title> The Postgress Next-Generation Database Management System, </title> <journal> Communications of the ACM, </journal> <month> October </month> <year> 1991, </year> <pages> pages 78-92. </pages>
Reference: [Sto93] <author> M. Stonebraker, </author> <title> The Miro DBMS, </title> <booktitle> ACM SIGMOD, </booktitle> <year> 1993. </year>
Reference: [Wel92] <author> D. Wells, J. Blakeley, C. Thompson, </author> <title> Architecture of an Open Object-Oriented Database Management System, </title> <booktitle> IEEE Computer, </booktitle> <month> October </month> <year> 1992, </year> <pages> pages 74-82. </pages>
Reference-contexts: It is well-known that there are many applications that, in principle, could use a database system, but are precluded from doing so by performance constraints (e.g., LEAPS [Mir90-91]). Extensible or open database systems were a major step toward DBMS customization (e.g., TIs Open OODB <ref> [Wel92] </ref>, IBMs Starburst [Haa90], Berkeleys Postgres/Miro/Illustra [Sto91-93], Wisconsins Exodus [Car90], and Texass Genesis [Bat88]). Extensible DBMSs enabled individual features or groups of features to be added or removed from a general-purpose DBMS to produce a database system that more closely matched the needs of target applications.
References-found: 27

