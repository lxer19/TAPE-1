URL: http://www.cs.nmsu.edu/~epontell/ilps97/8.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/ilps97/programme.html
Root-URL: http://www.cs.nmsu.edu
Email: fjuliana,warreng@cs.sunysb.edu  
Title: Combining Scheduling Strategies in Tabled Evaluations  
Author: Juliana Freire David S. Warren 
Address: NY 11794-4400  
Affiliation: Department of Computer Science State University of New York at Stony Brook Stony Brook,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the Power of Magic. </title> <journal> JLP, </journal> <volume> 10(3) </volume> <pages> 255-299, </pages> <year> 1991. </year>
Reference-contexts: The importance of providing this kind of flexibility in the evaluation has been identified in deductive databases. In bottom-up systems, the search can be controlled through the use of different rewriting techniques <ref> [1] </ref>. In Aditi [11], for instance, users may specify at the pred 1 2 Workshop on Parallelism and Implementation Technology icate level not only which transformation to use, but also the evaluation algorithm (e.g., variations of semi-naive [10]).
Reference: [2] <author> M. Bruynooghe. </author> <title> A practical framework for the abstract interpretation of logic programs. </title> <journal> JLP, </journal> <volume> 10 </volume> <pages> 91-124, </pages> <year> 1991. </year>
Reference-contexts: the strategy used in the first implementation of the SLG-WAM [9] both in running time and in memory usage; Local Scheduling has applications to non-monotonic reasoning, and it can arbitrarily improve the performance of some programs that benefit from answer subsumption, such as many aggregate computations [12] and program analyses <ref> [2] </ref>. Even though a specific strategy can result in considerable speedups for some applications, for others it may add overheads and even lead to unacceptable inefficiency. Since different applications have different requirements, the ability to use multiple strategies in an evaluation is likely to be beneficial.
Reference: [3] <author> W. Chen, M. Kifer, and D.S. Warren. HiLog: </author> <title> A foundation for higher-order logic programming. </title> <journal> JLP, </journal> <volume> 15(3) </volume> <pages> 187-230, </pages> <year> 1993. </year> <booktitle> Workshop on Parallelism and Implementation Technology 15 </booktitle>
Reference-contexts: The following example illustrates the actions of Local Scheduling. Example 3.2 Consider the following program p (X) :- subsumes (min)(q,X),long computation (X). q (X) :- r (X). r (X) :- q (X). SDG where subsumes (min) is a tabled HiLog <ref> [3] </ref> predicate that performs answer subsumption and deletes non-minimal answers every time a new answer is added to the table. 1 Given the query :- p (X), the 1 It is worth pointing out that XSB provides an efficient implementation aggregates using HiLog syntax.
Reference: [4] <author> W. Chen and D.S. Warren. </author> <title> Tabled Evaluation with Delaying for General Logic Programs. </title> <journal> JACM, </journal> <volume> 43(1) </volume> <pages> 20-74, </pages> <year> 1996. </year>
Reference-contexts: This section provides a brief (and informal) overview of SLG; for a more detailed discussion see <ref> [4] </ref>.
Reference: [5] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Beyond depth-first: Improving tabled logic programs through alternative scheduling strategies. </title> <journal> Journal of Functional and Logic Programming, </journal> <year> 1997. </year>
Reference-contexts: Each of these strategies has very specific characteristics. Breadth-First, for instance, performs a breadth-first (set-at-a-time) search, and in [6] we have shown this strategy is very efficient for evaluating queries which involve relations in external databases while incurring small overheads for in-memory data. Two other strategies were proposed in <ref> [5] </ref>: Batched Scheduling and Local Scheduling. <p> Single Stack Scheduling schedules answers eagerly, as soon as they are created, whereas Batched Scheduling delays the return of answers | favoring the execution of Program Clause Resolution and batching the return of answers until no more program clauses are available. Different strategies have different performance behaviors. In <ref> [5] </ref> we compared implementations of Single Stack Scheduling and Batched Scheduling (for definite programs), and not only Batched Scheduling has proven to be faster, but it also uses significantly less memory than Single Stack Scheduling for a representative set of benchmarks. 2 Other strategies are possible. <p> In what follows we describe Workshop on Parallelism and Implementation Technology 9 a prototype implementation of this hybrid strategy. For more details on the implementation of Batched Scheduling and Local Scheduling the reader is referred to <ref> [5] </ref>. In the previous section we introduced Local Scheduling, a strategy that evaluates one SCC at a time, following the dynamic dependencies between subgoals. <p> For example, the AnswerReturn instruction for a subgoal S could be specialized with respect to the scheduling strategy of S. 5 Experimental Results In this section we compare the performance of the following engines, which differ only in the scheduling strategy used: 5 * XSB v. 1.7: uses Batched Scheduling <ref> [5] </ref>. * XSB-Local: uses Local Scheduling [5]. * XSB-Integ: combines Batched Scheduling and Local Scheduling at the predicate level (Sec tion 4). We consider both execution time and memory usage of SLG-WAM engines as well as the dynamic count of SLG-WAM instructions and operations. <p> a subgoal S could be specialized with respect to the scheduling strategy of S. 5 Experimental Results In this section we compare the performance of the following engines, which differ only in the scheduling strategy used: 5 * XSB v. 1.7: uses Batched Scheduling <ref> [5] </ref>. * XSB-Local: uses Local Scheduling [5]. * XSB-Integ: combines Batched Scheduling and Local Scheduling at the predicate level (Sec tion 4). We consider both execution time and memory usage of SLG-WAM engines as well as the dynamic count of SLG-WAM instructions and operations. Benches were run on a SPARC2 with 64MB RAM under SUNOS.
Reference: [6] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Taking I/O seriously: Resolution reconsidered for disk. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 198-212, </pages> <year> 1997. </year>
Reference-contexts: Each of these strategies has very specific characteristics. Breadth-First, for instance, performs a breadth-first (set-at-a-time) search, and in <ref> [6] </ref> we have shown this strategy is very efficient for evaluating queries which involve relations in external databases while incurring small overheads for in-memory data. Two other strategies were proposed in [5]: Batched Scheduling and Local Scheduling. <p> There are a number of issues we plan to address in future work: we would like to add Breadth-First <ref> [6] </ref> as another scheduling option for the mixed-strategy evaluation; we intend to explore the possibility of adding strategy-specific SLG-WAM instructions to reduce the number of run-time checks to support the mixed-strategy evaluation, as well as investigate compile-time analyses to further improve the efficiency of the evaluation.
Reference: [7] <editor> E. Lusk et al. </editor> <title> The Aurora or-parallel Prolog system. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 819-830. </pages> <publisher> ICOT, </publisher> <year> 1988. </year>
Reference-contexts: The SLG-WAM achieves this by freezing the various WAM stacks at the point a new consuming node is created. In fact, the SLG-WAM keeps a linearized version of the search space in its stacks (similar to the cactus stacks of OR-parallel implementations such as Aurora <ref> [7] </ref>). Switching from one environment to another is performed by backtracking to a common ancestor, and then using a forward trail to reconstitute the environments of consuming nodes. The second change arises from the need to approximate the subgoal dependency graph (SDG), and thus provide incremental completion.
Reference: [8] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> An abstract machine for computing the well-founded semantics. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming (JICSLP), </booktitle> <pages> pages 274-289, </pages> <year> 1996. </year>
Reference-contexts: So, during the CheckComplete instruction, if negative dependencies are present, the engine explicitly builds the exact SDG of the program to rule out false negative loops <ref> [8] </ref>. In contrast, an engine based on Local Scheduling can avoid this step: since SCCs are preserved during the evaluation, the completion stack in fact keeps exact dependencies, and negative dependencies are only created if there are actual loops through negation.
Reference: [9] <author> T. Swift and D.S. Warren. </author> <title> An Abstract Machine for SLG Resolution: Definite Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 633-654, </pages> <year> 1994. </year>
Reference-contexts: Two other strategies were proposed in [5]: Batched Scheduling and Local Scheduling. Batched Scheduling improved on the strategy used in the first implementation of the SLG-WAM <ref> [9] </ref> both in running time and in memory usage; Local Scheduling has applications to non-monotonic reasoning, and it can arbitrarily improve the performance of some programs that benefit from answer subsumption, such as many aggregate computations [12] and program analyses [2]. <p> (a)j can be made unconditional (i.e., q (a) succeeds); and as a consequence the answer p (a) which is conditional Workshop on Parallelism and Implementation Technology 5 on ~q (a) fails (Figure 2 (d)). 2 The SLG-WAM The data structures and instruction set used by the SLG-WAM are described in <ref> [9] </ref>; here we briefly summarize aspects of the SLG-WAM needed to describe scheduling strategies. As mentioned above, there are several types of nodes: generator, consuming, interior and answer. Interior nodes are represented in the SLG-WAM by Prolog-style (or interior) choice points.
Reference: [10] <author> J. Ullman. </author> <title> Principles of Data and Knowledge-base Systems Vol I. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: In Aditi [11], for instance, users may specify at the pred 1 2 Workshop on Parallelism and Implementation Technology icate level not only which transformation to use, but also the evaluation algorithm (e.g., variations of semi-naive <ref> [10] </ref>). In this paper, we discuss the issues involved in providing engine support for different scheduling strategies at the predicate level as means of controlling the search in an SLG evaluation.
Reference: [11] <author> J. Vaghani, K. Ramamohanarao, D.B. Kemp, Z. Somogyi, P.J. Stuckey, T.S. Leask, and J. Harland. </author> <title> The Aditi deductive database system. </title> <journal> The VLDB Journal, </journal> <volume> 3(2) </volume> <pages> 245-288, </pages> <year> 1994. </year>
Reference-contexts: The importance of providing this kind of flexibility in the evaluation has been identified in deductive databases. In bottom-up systems, the search can be controlled through the use of different rewriting techniques [1]. In Aditi <ref> [11] </ref>, for instance, users may specify at the pred 1 2 Workshop on Parallelism and Implementation Technology icate level not only which transformation to use, but also the evaluation algorithm (e.g., variations of semi-naive [10]).
Reference: [12] <author> A. van Gelder. </author> <title> Foundations of Aggregation in Deductive Databases. </title> <booktitle> In Proceedings of the International Conference on Deductive and Object-Oriented Databases (DOOD), </booktitle> <pages> pages 13-34, </pages> <year> 1993. </year>
Reference-contexts: Batched Scheduling improved on the strategy used in the first implementation of the SLG-WAM [9] both in running time and in memory usage; Local Scheduling has applications to non-monotonic reasoning, and it can arbitrarily improve the performance of some programs that benefit from answer subsumption, such as many aggregate computations <ref> [12] </ref> and program analyses [2]. Even though a specific strategy can result in considerable speedups for some applications, for others it may add overheads and even lead to unacceptable inefficiency. Since different applications have different requirements, the ability to use multiple strategies in an evaluation is likely to be beneficial.
References-found: 12

