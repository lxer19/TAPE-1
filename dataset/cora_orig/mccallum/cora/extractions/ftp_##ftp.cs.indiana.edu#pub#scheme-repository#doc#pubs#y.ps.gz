URL: ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/y.ps.gz
Refering-URL: http://www.cs.indiana.edu/scheme-repository/doc.publications.html
Root-URL: http://www.cs.indiana.edu
Email: email: jinx@zurich.ai.mit.edu  
Title: Taming the Y operator  
Author: Guillermo Juan Rozas 
Address: Cambridge, MA  
Affiliation: MIT AI Laboratory,  
Abstract: In this paper I present a set of conceptually simple but involved techniques used by Liar 1 , the MIT Scheme compiler, to generate good code when recursive procedures are specified in terms of suitable versions of the Y operator. The techniques presented are general-purpose analysis and optimization tools, similar to well-known techniques used in the analysis and optimization of applicative languages, that combine synergistically to enable Liar to generate identical machine code for ordinary recursive definitions written using letrec and those written using suitable forms of Y. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Harold Abelson, Gerald Jay Sussman, and Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Termination analysis is, of course, undecidable in the general case (see [9], for example), and attempting to make code such as the above behave as when compiled naively (as, for example, by the compiler in <ref> [1] </ref>) would in all likelihood break the optimization for the cases in which it is not controversial. Whether optimization under these circumstances is allowable is debatable, but defensible.
Reference: [2] <author> Alonzo Church. </author> <title> The calculi of lambda-conversion. </title> <publisher> Princeton University Press, </publisher> <year> 1941. </year>
Reference-contexts: Treating letrec as a primitive form is effective, but aesthetically unsatisfying. Lisp is notationally and semantically based on Church's lambda calculus <ref> [2] </ref>, which does not include letrec or assignment. The Y combina-tor, written in the lambda calculus itself, can be used to express recursive procedures. For example, the expression in Fig. 2 uses an applicative-order version of the Y operator to specify a recursive procedure.
Reference: [3] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fix-points. </title> <booktitle> In Proc. 4th Principles of Programming Languages, </booktitle> <address> Los Angeles, California, </address> <year> 1977. </year>
Reference-contexts: other hand, if we are only interested in replacing letrec by macro-expanding it into uses of Y, the writer of the macro could choose expansions that do not confuse the compiler. 8 Comparisons with other work The data flow analysis method mentioned above is an example of abstract interpretation (see <ref> [3] </ref>) of the program at compile time. It is essentially the same as Olin Shivers's 0CFA as described in his Ph.D. dissertation [15] but they were developed independently. Our version has been in place in the Liar compiler since late 1983 [14].
Reference: [4] <institution> Digital Equipment Corp. Alpha Architecture Reference, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: For example, [5] describes an aggressive optimizer based on partial evaluation which does not preserve the termination properties of the input program. This tension is also present in modern computer architecture. See, for example, <ref> [4] </ref> for a description of an architecture with imprecise traps. 9 Conclusion In this paper I have presented a set of simple techniques that allow Liar to effectively eliminate uses of the Y combinator.
Reference: [5] <author> D. Weise et al. </author> <title> Automatic online partial evaluation. </title> <booktitle> In Proc. of the Conference on Functional Programming Languages and Architectures. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: With respect to eliminating Y, the simple side-effect analysis described appears to suffice. The tension in Liar between aggressive optimization and conformance with low-level models of execution is present in other compiler and optimization work. For example, <ref> [5] </ref> describes an aggressive optimizer based on partial evaluation which does not preserve the termination properties of the input program. This tension is also present in modern computer architecture.
Reference: [6] <author> Peter Naur et al. </author> <title> Revised report on the algorithmic language Algol-60. </title> <journal> Communications of the ACM, </journal> <volume> 6(1) </volume> <pages> 1-17, </pages> <month> January </month> <year> 1963. </year>
Reference-contexts: Common Lisp [17] provides the labels special form for this purpose. Scheme [13] provides the similar letrec special form, as well as internal definitions, a syntactic alternative more akin to the internal procedure declarations of Algol-60 <ref> [6] </ref>. Recursive procedures are described, and sometimes implemented, particularly for top-level procedures, in terms of assignment. For example, the first expression in Fig. 1 can be considered shorthand for the second. Lisp compilers typically treat letrec (or labels) as a primitive special form in order to generate good code.
Reference: [7] <author> Chris Hanson. </author> <title> Efficient stack allocation for tail--recursive languages. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: The environment optimization technique described is only one of several present in Liar and is also used to reduce the number of static and dynamic links <ref> [7] </ref>. The most closely related technique is lambda lifting [12]. Both techniques migrate lambda expressions toward the root of the environment tree in order to simplify environment structure. When lambda lifting, parameter lists of migrated procedures are extended to include their free variables.
Reference: [8] <author> P. Jouvelot and D. K. Gifford. </author> <title> Algebraic reconstruction of types and effects. </title> <booktitle> In Proc. 18th Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: The side-effect analysis in the front end of Liar is straightforward and was added with Y in mind. Other Scheme compilers [16] have used more complex analysis to reorder expressions at the source level. The FX language <ref> [10, 8] </ref>, a derivative of Scheme, has been designed with effect analysis and effect masking at its core, and its syntax includes effect declarations that are propagated and checked statically by the compiler much in the same way that types are propagated and checked.
Reference: [9] <author> H. R. Lewis and C. H. Papadimitriou. </author> <title> Elements of the Theory of Computation. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: The compiler has not really proven that a particular value will be returned, but has proven instead that no other value can be returned, and takes this to mean that the value is in fact returned. Termination analysis is, of course, undecidable in the general case (see <ref> [9] </ref>, for example), and attempting to make code such as the above behave as when compiled naively (as, for example, by the compiler in [1]) would in all likelihood break the optimization for the cases in which it is not controversial.
Reference: [10] <author> J. M. Lucassen and D. K. Gifford. </author> <title> Polymorphic effect systems. </title> <booktitle> In Proc. 15th Principles of Programming Languages, </booktitle> <year> 1988. </year>
Reference-contexts: The side-effect analysis in the front end of Liar is straightforward and was added with Y in mind. Other Scheme compilers [16] have used more complex analysis to reorder expressions at the source level. The FX language <ref> [10, 8] </ref>, a derivative of Scheme, has been designed with effect analysis and effect masking at its core, and its syntax includes effect declarations that are propagated and checked statically by the compiler much in the same way that types are propagated and checked.
Reference: [11] <author> Ketan Mulmuley. </author> <title> Full abstraction and semantic equivalence. </title> <publisher> MIT Press, </publisher> <year> 1986. </year> <note> ACM Doctoral Dissertation Award, </note> <year> 1986. </year>
Reference-contexts: This non-standard notion of program equivalence is related to the concept of observational equivalence (see <ref> [11] </ref>). To satisfy those who desire more predictability from their compiler, Liar currently provides a switch that turns off the side-effect analysis pass by marking everything as potentially side-effecting.
Reference: [12] <editor> Simon L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: The environment optimization technique described is only one of several present in Liar and is also used to reduce the number of static and dynamic links [7]. The most closely related technique is lambda lifting <ref> [12] </ref>. Both techniques migrate lambda expressions toward the root of the environment tree in order to simplify environment structure. When lambda lifting, parameter lists of migrated procedures are extended to include their free variables. Calls to migrated procedures must pass their values in addition to the original arguments.
Reference: [13] <editor> Jonathan Rees and William Clinger (editors). </editor> <title> Revised 3 report on the algorithmic language Scheme. </title> <journal> ACM Sigplan Notices, </journal> <volume> 21(12), </volume> <month> December </month> <year> 1986. </year> <note> Also available as MIT AI Memo 818a. </note>
Reference-contexts: 1 Introduction: The problem Modern programming languages allow programmers to write local recursive procedure definitions. Common Lisp [17] provides the labels special form for this purpose. Scheme <ref> [13] </ref> provides the similar letrec special form, as well as internal definitions, a syntactic alternative more akin to the internal procedure declarations of Algol-60 [6]. Recursive procedures are described, and sometimes implemented, particularly for top-level procedures, in terms of assignment.
Reference: [14] <author> Guillermo J. Rozas. </author> <title> Liar, an Algol-like compiler for Scheme. </title> <type> S.B. thesis, </type> <institution> Mass. Inst. of Technology, Dept. of Electrical Engineering and Computer Science, </institution> <month> January </month> <year> 1984. </year>
Reference-contexts: It is essentially the same as Olin Shivers's 0CFA as described in his Ph.D. dissertation [15] but they were developed independently. Our version has been in place in the Liar compiler since late 1983 <ref> [14] </ref>. In [15] Shivers also describes a finer resolution analysis, which he calls 1CFA, adding some finite trace information to the propagated representative values that allows him to resolve cases where the simpler analysis described here fails.
Reference: [15] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages, or Taming Lambda. </title> <type> Ph.D. thesis, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1991. </year> <note> Available as CMU-CS-91-145. </note>
Reference-contexts: It is essentially the same as Olin Shivers's 0CFA as described in his Ph.D. dissertation <ref> [15] </ref> but they were developed independently. Our version has been in place in the Liar compiler since late 1983 [14]. In [15] Shivers also describes a finer resolution analysis, which he calls 1CFA, adding some finite trace information to the propagated representative values that allows him to resolve cases where the <p> It is essentially the same as Olin Shivers's 0CFA as described in his Ph.D. dissertation <ref> [15] </ref> but they were developed independently. Our version has been in place in the Liar compiler since late 1983 [14]. In [15] Shivers also describes a finer resolution analysis, which he calls 1CFA, adding some finite trace information to the propagated representative values that allows him to resolve cases where the simpler analysis described here fails. He also discusses how to use the results of the analysis to implement several optimizations.
Reference: [16] <author> Guy Lewis Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> S.M. thesis, </type> <institution> Mass. Inst. of Technology, </institution> <year> 1978. </year> <note> Also available as MIT AI Memo 474. </note>
Reference-contexts: See <ref> [16] </ref> for a description of the rewriting process and its use it in a compiler. (let ((Y (lambda (f) ; lambda-1 ((lambda (x) ; lambda-3a (f (lambda () ; lambda-4a (x x)))) (lambda (x) ; lambda-3b (f (lambda () ; lambda-4b (x x)))))))) (Y (lambda (fg) ; lambda-5 (lambda (n) ; <p> Liar implicitly performs lambda lifting when designing the format of procedure objects after using lambda drifting. The side-effect analysis in the front end of Liar is straightforward and was added with Y in mind. Other Scheme compilers <ref> [16] </ref> have used more complex analysis to reorder expressions at the source level.
Reference: [17] <author> Guy Lewis Steele Jr. </author> <title> Common LISP The Language, 2nd Edition. </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction: The problem Modern programming languages allow programmers to write local recursive procedure definitions. Common Lisp <ref> [17] </ref> provides the labels special form for this purpose. Scheme [13] provides the similar letrec special form, as well as internal definitions, a syntactic alternative more akin to the internal procedure declarations of Algol-60 [6]. Recursive procedures are described, and sometimes implemented, particularly for top-level procedures, in terms of assignment.
References-found: 17

