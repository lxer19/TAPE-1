URL: http://www-csag.cs.uiuc.edu/papers/pldi97.ps
Refering-URL: http://www-csag.cs.uiuc.edu/papers/index.html
Root-URL: http://www.cs.uiuc.edu
Email: dolby@cs.uiuc.edu  
Title: Automatic Inline Allocation of Objects  
Author: Julian Dolby 
Keyword: Concurrent Systems Architecture Group  
Address: 1304 West Springfield Avenue Urbana, IL 61801  
Affiliation: Department of Computer Science University of Illinois  
Abstract: Object-oriented languages like Java and Smalltalk provide a uniform object model that simplifies programming by providing a consistent, abstract model of object behavior. But direct implementations introduce overhead, removal of which requires aggressive implementation techniques (e.g. type inference, function specialization); in this paper, we introduce object inlining, an optimization that automatically inline allocates objects within containers (as is done by hand in C++) within a uniform model. We present our technique, which includes novel program analyses that track how inlinable objects are used throughout the program. We evaluated object inlining on several object-oriented benchmarks. It produces performance up to three times as fast as a dynamic model without inlining and roughly equal to that of manually-inlined codes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> O. Agesen, J. Palsberg, and M. Schwartzbach. </author> <title> Type inference of Self: Analysis of objects with dynamic and multiple inheritance. </title> <booktitle> In Proceedings of ECOOP '93, </booktitle> <year> 1993. </year>
Reference-contexts: Java [27], NewtonScript [3], Cecil [7]). This leaves eliding abstraction overhead to aggressive implementations. Dynamic dispatches are optimized statically by type inference To appear in the 1997 ACM SIGPLAN Conference on Programming Language Design and Implementation, June 1997, Las Vegas, Nevada. <ref> [1, 6, 21, 23] </ref>, dynamically by inline caching [16] or with hybrid approaches like type feedback [17]. Static or hybrid type analysis is combined with method specialization [10, 24] to allow inlining, removing the small functions common in object-oriented code.
Reference: [2] <author> Jennifer M. Anderson, Saman P. Amarasinghe, and Monica S. Lam. </author> <title> Data and computation transformations for multiprocessors. </title> <booktitle> In Proceedings of Fifth Symposium on Principles and Practice of Parallel Programming, </booktitle> <year> 1995. </year>
Reference-contexts: This provides two simplifications: it eliminates the difficulties created by assigning inlined object into other containers, and it obviates the need to prove inline allocation is safe. Fortran Optimizing array layout for cache performance <ref> [2, 29] </ref> also involves transforming data layout. Arrays and loops that operate upon them are tiled; that is, the inner loops are strip-mined to operate upon small portions of the arrays that will fit in cache.
Reference: [3] <institution> Apple Computer Inc. </institution> <note> The NewtonScript Programming Language, December 1995. Available online from ftp://ftpdev.info.apple.com/ Developer Services/ Newton Development/DOCS PDF/NSCRIPTR.ZIP. </note>
Reference-contexts: However, the original notion of a clean, simple semantics is re-emerging in recent object-oriented languages (e.g. Java [27], NewtonScript <ref> [3] </ref>, Cecil [7]). This leaves eliding abstraction overhead to aggressive implementations.
Reference: [4] <author> A. Black, N. Hutchinson, E. Jul, and H. Levy. </author> <title> Object structure in the emerald system. </title> <booktitle> In Proceedings of OOPSLA '86, </booktitle> <pages> pages 78-86. </pages> <publisher> ACM, </publisher> <month> September </month> <year> 1986. </year>
Reference-contexts: Object-Oriented Systems The impetus for object inlining came from the ability to specify such inlining by hand in hybrid-object languages like C++ and Oberon-2 [14, 20] that distinguish between objects and object references. But the idea of doing inline allocation automatically is by no means new; the Emerald <ref> [4, 18] </ref> object system was designed with this goal in mind. Indeed, they wanted to automatically generate specialized representations of objects and transform the code that used them. This is exactly what we do. However, their compiler was not capable of the requisite analysis (Section 4).
Reference: [5] <author> Brad Calder, Dirk Grunwald, and Benjamin Zorn. </author> <title> Quantifying differences between C and C++ programs. </title> <type> Technical Report CU-CS-698-94, </type> <institution> University of Col-orado, Boulder, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: This abstract model, however, introduces overhead: even simple field accesses become dynamic dispatches, indirection through references is required to accesses every object, and individual functions shrink <ref> [5] </ref>. Hybrid languages like C++ [11] provide multitudinous low-level features (e.g virtual vs non-virtual functions, inline directives, and explicit stack, inline or heap allocation) so programmers can manually reduce overhead by removing unused abstraction. However, the original notion of a clean, simple semantics is re-emerging in recent object-oriented languages (e.g.
Reference: [6] <author> C. Chambers and D. Ungar. </author> <title> Iterative type analysis and extended message splitting. </title> <booktitle> In Proceedings of the SIG-PLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 150-60, </pages> <year> 1990. </year>
Reference-contexts: Java [27], NewtonScript [3], Cecil [7]). This leaves eliding abstraction overhead to aggressive implementations. Dynamic dispatches are optimized statically by type inference To appear in the 1997 ACM SIGPLAN Conference on Programming Language Design and Implementation, June 1997, Las Vegas, Nevada. <ref> [1, 6, 21, 23] </ref>, dynamically by inline caching [16] or with hybrid approaches like type feedback [17]. Static or hybrid type analysis is combined with method specialization [10, 24] to allow inlining, removing the small functions common in object-oriented code.
Reference: [7] <author> Craig Chambers. </author> <title> The Cecil language: Specification and rationale, version 2.0. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <address> Seattle, Washington, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: However, the original notion of a clean, simple semantics is re-emerging in recent object-oriented languages (e.g. Java [27], NewtonScript [3], Cecil <ref> [7] </ref>). This leaves eliding abstraction overhead to aggressive implementations.
Reference: [8] <author> Andrew Chien, Julian Dolby, Bishwaroop Ganguly, Vi-jay Karamcheti, and Xingbin Zhang. </author> <title> Supporting high level programming with high performance: The illinois concert system. </title> <booktitle> In Proceedings of the Second International Workshop on High-level Parallel Programming Models and Supportive Environments, </booktitle> <month> April </month> <year> 1997. </year>
Reference-contexts: This requires data-flow analysis that can flow properties through fields (Sec Point::area (p) - return abs (x_pos - p.x_pos) * abs (y_pos - p.y_pos); Point::abs () - return sqrt (x_pos*x_pos + y_pos*y_pos); Rectangle::area () - return lower_left.area (upper_right); - tion 3.2.1). Our Concert <ref> [8] </ref> analysis framework is, to our knowledge, the only one that can do this. do_rectangle (ll, ur) - r = new Rectangle (ll, ur); cout &lt;< r.area (); ll = new List (r.lower_left, nil); l2 = new List (r.upper_right, nil); cout &lt;< head (l1).abs (); cout &lt;< head (l2).abs (); - <p> On the other hand, because we want to preserve a uniform model and our analysis opens up other optimization opportunities, our inline allocation is done automatically by the compiler. 3.2 The Concert Compiler This works was done in the Concert <ref> [8] </ref> compiler, so subsequent discussion of our optimization relies heavily on the framework of that compiler.
Reference: [9] <author> Andrew A. Chien, Uday S. Reddy, John Plevyak, and Julian Dolby. </author> <title> ICC++ a C++ dialect for high-performance parallel computation. </title> <booktitle> In Proceedings of the 2nd International Symposium on Object Technologies for Advanced Software, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: These cells stored references to each other, and hence inlining them requires our analysis' ability to flow thru data. The arrays are inline allocated in C++, but the cons cells cannot be. These benchmarks are all pre-existing C++ codes; since the Concert Compiler accepts ICC++ <ref> [9] </ref>, a C++-derived language, only minor changes were required for our compiler to accept them. These were mostly declaration and array access syntax.
Reference: [10] <author> Jeffrey Dean, Craig Chambers, and David Grove. </author> <title> Selective specialization for object-oriented languages. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programmin g Language Design and Implementation, </booktitle> <pages> pages 93-102, </pages> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Static or hybrid type analysis is combined with method specialization <ref> [10, 24] </ref> to allow inlining, removing the small functions common in object-oriented code. The combination of static type analysis and specialization also permits inline allocation of objects within containers, thereby eliminating many object references and reducing object allocation.
Reference: [11] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: This abstract model, however, introduces overhead: even simple field accesses become dynamic dispatches, indirection through references is required to accesses every object, and individual functions shrink [5]. Hybrid languages like C++ <ref> [11] </ref> provide multitudinous low-level features (e.g virtual vs non-virtual functions, inline directives, and explicit stack, inline or heap allocation) so programmers can manually reduce overhead by removing unused abstraction. However, the original notion of a clean, simple semantics is re-emerging in recent object-oriented languages (e.g.
Reference: [12] <author> Tim Freeman and Frank Pfenning. </author> <title> Refinement types for ml. </title> <booktitle> In Proceedings of the 1991 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: The propagation of "unboxedness" resembles the propagation of tags our use analysis defines; however, it only works for immediate types. In [25], Shao et al. unroll linked lists-essentially inline allocating tail pointers-in a functional subset of ML. Their analysis works using refinement types <ref> [12] </ref> that distinguish odd and even length lists. These refined types are propagated using an abstract interpretation, with rules for the refined types generated by cons statements. All functions that take list parameters are cloned and specialized with all possible combinations of refinement types for their list parameters.
Reference: [13] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The language and its implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: 1 Introduction Traditional object-oriented languages (e.g. SmallTalk <ref> [13] </ref>) sport a simple, uniform, abstract programming model; all objects are accessed via references and all calls are dynamic message sends. This simplifies programming, as the programmer faces a single model of object behavior, and because different portions of programs can be isolated behind opaque interfaces.
Reference: [14] <author> H. Mossenbock. </author> <title> Object-Oriented Programming in Oberon-2. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Object-Oriented Systems The impetus for object inlining came from the ability to specify such inlining by hand in hybrid-object languages like C++ and Oberon-2 <ref> [14, 20] </ref> that distinguish between objects and object references. But the idea of doing inline allocation automatically is by no means new; the Emerald [4, 18] object system was designed with this goal in mind.
Reference: [15] <author> Cordelia Hall, Simon L. Peyton-Jones, and Patrick M. Sansom. </author> <title> Functional Programming, Glasgow 1994, chapter Unboxing Using Specialization. </title> <booktitle> Workshops in Computing Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Functional Languages There has been much work in the functional community on unboxing, in which specialized representations are used to reduce storage and access overhead. Of particular relevance to our work is unboxing in the presence of polymorphism <ref> [19, 15] </ref>. In [15], Cordelia Hall and company present a transformation for Haskell that, upon being told what variables to unbox, generates specialized code to exploit the unboxing, even for polymorphic functions. They generate specialized function versions using a partial evaluator to propagate "unboxedness" through the program. <p> Functional Languages There has been much work in the functional community on unboxing, in which specialized representations are used to reduce storage and access overhead. Of particular relevance to our work is unboxing in the presence of polymorphism [19, 15]. In <ref> [15] </ref>, Cordelia Hall and company present a transformation for Haskell that, upon being told what variables to unbox, generates specialized code to exploit the unboxing, even for polymorphic functions. They generate specialized function versions using a partial evaluator to propagate "unboxedness" through the program.
Reference: [16] <author> Urs Holzle, Craig Chambers, and David Ungar. </author> <title> Optimizing dynamically-typed object-oriented languages with polymorphic inline caches. </title> <booktitle> In ECOOP'91 Conference Proceedings. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> Lecture Notes in Computer Science 512. </note>
Reference-contexts: Java [27], NewtonScript [3], Cecil [7]). This leaves eliding abstraction overhead to aggressive implementations. Dynamic dispatches are optimized statically by type inference To appear in the 1997 ACM SIGPLAN Conference on Programming Language Design and Implementation, June 1997, Las Vegas, Nevada. [1, 6, 21, 23], dynamically by inline caching <ref> [16] </ref> or with hybrid approaches like type feedback [17]. Static or hybrid type analysis is combined with method specialization [10, 24] to allow inlining, removing the small functions common in object-oriented code.
Reference: [17] <author> Urs Holzle and David Ungar. </author> <title> Optimizing dynamically-dispatched calls with run-time type feedback. </title> <booktitle> In Proceedings of the 1994 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 326-336, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Dynamic dispatches are optimized statically by type inference To appear in the 1997 ACM SIGPLAN Conference on Programming Language Design and Implementation, June 1997, Las Vegas, Nevada. [1, 6, 21, 23], dynamically by inline caching [16] or with hybrid approaches like type feedback <ref> [17] </ref>. Static or hybrid type analysis is combined with method specialization [10, 24] to allow inlining, removing the small functions common in object-oriented code. The combination of static type analysis and specialization also permits inline allocation of objects within containers, thereby eliminating many object references and reducing object allocation.
Reference: [18] <author> Norman C. Hutchinson. </author> <title> Emerald: An Object-Based Language for Distributed Programming. </title> <type> PhD thesis, </type> <institution> University of Washington, Department of Computer Science, </institution> <address> Seattle, Washington, </address> <year> 1987. </year> <month> TR-87-01-01. </month>
Reference-contexts: Object-Oriented Systems The impetus for object inlining came from the ability to specify such inlining by hand in hybrid-object languages like C++ and Oberon-2 [14, 20] that distinguish between objects and object references. But the idea of doing inline allocation automatically is by no means new; the Emerald <ref> [4, 18] </ref> object system was designed with this goal in mind. Indeed, they wanted to automatically generate specialized representations of objects and transform the code that used them. This is exactly what we do. However, their compiler was not capable of the requisite analysis (Section 4).
Reference: [19] <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Proceedings of the 19th Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 177-188, </pages> <year> 1992. </year>
Reference-contexts: Functional Languages There has been much work in the functional community on unboxing, in which specialized representations are used to reduce storage and access overhead. Of particular relevance to our work is unboxing in the presence of polymorphism <ref> [19, 15] </ref>. In [15], Cordelia Hall and company present a transformation for Haskell that, upon being told what variables to unbox, generates specialized code to exploit the unboxing, even for polymorphic functions. They generate specialized function versions using a partial evaluator to propagate "unboxedness" through the program.
Reference: [20] <author> N. Wirth and J. Gutknecht. </author> <title> Project Oberon: The Design of an Operating System and Compiler. </title> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Object-Oriented Systems The impetus for object inlining came from the ability to specify such inlining by hand in hybrid-object languages like C++ and Oberon-2 <ref> [14, 20] </ref> that distinguish between objects and object references. But the idea of doing inline allocation automatically is by no means new; the Emerald [4, 18] object system was designed with this goal in mind.
Reference: [21] <author> J. Palsberg and M. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proceedings of OOPSLA '91, </booktitle> <pages> pages 146-61, </pages> <year> 1991. </year>
Reference-contexts: Java [27], NewtonScript [3], Cecil [7]). This leaves eliding abstraction overhead to aggressive implementations. Dynamic dispatches are optimized statically by type inference To appear in the 1997 ACM SIGPLAN Conference on Programming Language Design and Implementation, June 1997, Las Vegas, Nevada. <ref> [1, 6, 21, 23] </ref>, dynamically by inline caching [16] or with hybrid approaches like type feedback [17]. Static or hybrid type analysis is combined with method specialization [10, 24] to allow inlining, removing the small functions common in object-oriented code.
Reference: [22] <author> John Plevyak. </author> <title> Optimization of Object-Oriented and Concurrent Programs. </title> <type> PhD thesis, </type> <institution> University of Illi-nois at Urbana-Champaign, Urbana, Illinois, </institution> <year> 1996. </year>
Reference-contexts: Therefore, a brief overview is given of the two portions that we use: the analysis and cloning modules. 3.2.1 The Analysis Framework The Concert compiler has a global analysis framework (see <ref> [23, 22] </ref> for more detail) that does context sensitive flow analysis. Context sensitivity adapts, in a demand-driven manner, to program structure. A method contour [26] represents execution environments for a method, i.e. it is the unit of context sensitivity.
Reference: [23] <author> John Plevyak and Andrew A. Chien. </author> <title> Precise concrete type inference of object-oriented programs. </title> <booktitle> In Proceedings of OOPSLA'94, Object-Oriented Programming Systems, Languages and Architectures, </booktitle> <pages> pages 324-340, </pages> <year> 1994. </year>
Reference-contexts: Java [27], NewtonScript [3], Cecil [7]). This leaves eliding abstraction overhead to aggressive implementations. Dynamic dispatches are optimized statically by type inference To appear in the 1997 ACM SIGPLAN Conference on Programming Language Design and Implementation, June 1997, Las Vegas, Nevada. <ref> [1, 6, 21, 23] </ref>, dynamically by inline caching [16] or with hybrid approaches like type feedback [17]. Static or hybrid type analysis is combined with method specialization [10, 24] to allow inlining, removing the small functions common in object-oriented code. <p> We present object inlining, the first fully automatic optimization for doing inline allocation in an object-oriented language. We exploit the power of analysis and cloning that can handle data flow through object state <ref> [23, 24] </ref> to inline allocate child objects even for polymorphic containers and to systematically exploit such allocation wherever the child objects are used. class Point - x_pos, y_pos; class Rectangle - lower_left, upper_right; -; To make the problem concrete, consider the example in inlined allocation, as in C++, would produce Figure <p> Therefore, a brief overview is given of the two portions that we use: the analysis and cloning modules. 3.2.1 The Analysis Framework The Concert compiler has a global analysis framework (see <ref> [23, 22] </ref> for more detail) that does context sensitive flow analysis. Context sensitivity adapts, in a demand-driven manner, to program structure. A method contour [26] represents execution environments for a method, i.e. it is the unit of context sensitivity.
Reference: [24] <author> John Plevyak and Andrew A. Chien. </author> <title> Type directed cloning for object-oriented programs. </title> <booktitle> In Proceedings of the Workshop for Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 566-580, </pages> <year> 1995. </year>
Reference-contexts: Static or hybrid type analysis is combined with method specialization <ref> [10, 24] </ref> to allow inlining, removing the small functions common in object-oriented code. The combination of static type analysis and specialization also permits inline allocation of objects within containers, thereby eliminating many object references and reducing object allocation. <p> We present object inlining, the first fully automatic optimization for doing inline allocation in an object-oriented language. We exploit the power of analysis and cloning that can handle data flow through object state <ref> [23, 24] </ref> to inline allocate child objects even for polymorphic containers and to systematically exploit such allocation wherever the child objects are used. class Point - x_pos, y_pos; class Rectangle - lower_left, upper_right; -; To make the problem concrete, consider the example in inlined allocation, as in C++, would produce Figure <p> This results in Figure 7. 3.2.2 The Cloning Framework The Concert compiler includes a mechanism for cloning based upon data-flow properties discovered by analysis <ref> [24] </ref>, which works on the contours. The mechanism uses a generic function that determines, for two given contours, whether they are compatible. Cloning is done upon both methods and classes.
Reference: [25] <author> Zhong Shao, John H. Reppy, and Andrew W. Appel. </author> <title> Unrolling lists. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: They generate specialized function versions using a partial evaluator to propagate "unboxedness" through the program. The propagation of "unboxedness" resembles the propagation of tags our use analysis defines; however, it only works for immediate types. In <ref> [25] </ref>, Shao et al. unroll linked lists-essentially inline allocating tail pointers-in a functional subset of ML. Their analysis works using refinement types [12] that distinguish odd and even length lists. These refined types are propagated using an abstract interpretation, with rules for the refined types generated by cons statements.
Reference: [26] <author> Olin Shivers. </author> <title> Topics in Advanced Language Implementation, chapter Data-Flow Analysis and Type Recovery in Scheme, </title> <address> pages 47-88. </address> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: Context sensitivity adapts, in a demand-driven manner, to program structure. A method contour <ref> [26] </ref> represents execution environments for a method, i.e. it is the unit of context sensitivity. Method contours can discriminate arbitrary data-flow properties of its caller and creator. An object contour represents method contours of the statements that created a given object. For method contours: caller the calling statement and contour.
Reference: [27] <author> Sun Microsystems Computer Corporation. </author> <title> The Java Language Specification, </title> <month> March </month> <year> 1995. </year> <note> Available at http://java.sun.com/1.0alpha2/doc/java-whitepaper.ps. </note>
Reference-contexts: However, the original notion of a clean, simple semantics is re-emerging in recent object-oriented languages (e.g. Java <ref> [27] </ref>, NewtonScript [3], Cecil [7]). This leaves eliding abstraction overhead to aggressive implementations.
Reference: [28] <author> Gregory V. Wilson and Paul Lu, </author> <title> editors. Parallel Programming Using C++. </title> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Some wrapper objects for queues can be inlined into their containers, and list items (essentially cons cells) can be eliminated by combining them with their data. The queue wrappers are inline allocated in C++, but the cons cells cannot be. polyOver is the benchmark from <ref> [28] </ref>; it computes an overlay of two polygon maps; it uses several algorithms employing arrays and lists of polygons. Our transformation inlines cons cells as in Silo, contents of arrays, and, most interestingly, an array of cons cells.
Reference: [29] <author> Micheal E. Wolf and Monica S. Lam. </author> <title> A data locality optimizing algorithm. </title> <booktitle> In Proceedings of the 1991 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1991. </year> <month> 11 </month>
Reference-contexts: This provides two simplifications: it eliminates the difficulties created by assigning inlined object into other containers, and it obviates the need to prove inline allocation is safe. Fortran Optimizing array layout for cache performance <ref> [2, 29] </ref> also involves transforming data layout. Arrays and loops that operate upon them are tiled; that is, the inner loops are strip-mined to operate upon small portions of the arrays that will fit in cache.
References-found: 29

