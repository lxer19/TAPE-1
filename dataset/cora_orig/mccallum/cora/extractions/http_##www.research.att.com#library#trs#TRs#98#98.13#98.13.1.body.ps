URL: http://www.research.att.com/library/trs/TRs/98/98.13/98.13.1.body.ps
Refering-URL: http://www.research.att.com/library/trs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: jf@research.att.com  petel@cs.cmu.edu  
Title: Trust Management and Proof-Carrying Code in Secure Mobile-Code Applications A Position Paper  
Author: Joan Feigenbaum Peter Lee 
Date: March 26-28, 1997  
Note: DARPA Workshop on Foundations for Secure Mobile Code  
Address: Murray Hill, NJ 07974  Pittsburgh, PA 15213  
Affiliation: AT&T Labs  Carnegie Mellon University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Blaze, J. Feigenbaum, and J. Lacy, </author> <title> "Decentralized Trust Management," </title> <booktitle> in Proceedings of the 17th Symposium on Security and Privacy, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <year> 1996, </year> <pages> pp. 164-173. </pages>
Reference-contexts: We then briefly explain two approaches to mobile-code security: trust management and proof-carrying code. (More complete explanations of these approaches can be found in <ref> [1, 6, 7] </ref>.) Although both of these approaches are only in embryonic stages of development, we believe the early experimental results give some basis for speculating on larger-scale applications. <p> Not surprisingly, both trust management and proof-carrying code are based on the use of formal language to address the problem of mobile-code security. We now give brief descriptions of these approaches. More complete descriptions are given in <ref> [1, 6, 7] </ref>. 3 3.1 Proof-Carrying Code Proof-carrying code (PCC) is a mechanism that supports the construction of easily checkable mathematical proofs of program properties, as well as the formal specification of behavioral safety properties. <p> The most general definition of trust management is policy-controlled processing of standardized metadata, using trusted third parties. We will flesh out what this definition means in the mobile-code context. For more information about trust management in other domains, refer to, e.g., <ref> [1, 2, 3, 5] </ref>. Policy control is the way in which the individual characteristics of the host's environment are formally encoded in a security policy with which all incoming mobile programs must comply. <p> Only if P 0 says "ok to run P " does the host do so. This scenario illustrates an important feature of trust management systems such as PolicyMaker <ref> [1] </ref> and REFEREE [3]: These systems support programmable metadata such as the auxiliary programs P 0 .
Reference: [2] <author> M. Blaze, J. Feigenbaum, P. Resnick, and M. Strauss, </author> <title> "Managing Trust in an Information-Labeling System," </title> <note> to appear in European Transactions on Telecommuncations. Available in preprint form as AT&T Technical Report 96.15.1. </note>
Reference-contexts: The most general definition of trust management is policy-controlled processing of standardized metadata, using trusted third parties. We will flesh out what this definition means in the mobile-code context. For more information about trust management in other domains, refer to, e.g., <ref> [1, 2, 3, 5] </ref>. Policy control is the way in which the individual characteristics of the host's environment are formally encoded in a security policy with which all incoming mobile programs must comply.
Reference: [3] <author> Y.-h. Chu, J. Feigenbaum, B. LaMacchia, P. Resnick, and M. Strauss, "REFEREE: </author> <title> Trust Management for Web Applications," </title> <booktitle> to appear in Proceedings of the 6th World Wide Web Conference, </booktitle> <address> Santa Clara CA, </address> <month> April </month> <year> 1997. </year> <note> Available in preliminary form as AT&T Technical Report 97.2.1. </note>
Reference-contexts: The most general definition of trust management is policy-controlled processing of standardized metadata, using trusted third parties. We will flesh out what this definition means in the mobile-code context. For more information about trust management in other domains, refer to, e.g., <ref> [1, 2, 3, 5] </ref>. Policy control is the way in which the individual characteristics of the host's environment are formally encoded in a security policy with which all incoming mobile programs must comply. <p> Only if P 0 says "ok to run P " does the host do so. This scenario illustrates an important feature of trust management systems such as PolicyMaker [1] and REFEREE <ref> [3] </ref>: These systems support programmable metadata such as the auxiliary programs P 0 .
Reference: [4] <author> R. Harper, F. Honsell, and G. Plotkin. </author> <title> "A Framework for Defining Logics," </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> vol. 40, no. 1, </volume> <month> January, </month> <year> 1993, </year> <pages> 143-184. </pages>
Reference-contexts: The host can then quickly validate with certainty that the proof does indeed establish the specified safety properties. For more information about the applications and principles underlying proof-carrying code, see [6, 7]. PCC works by encoding the proofs in a language based on the typed - calculus, called LF <ref> [4] </ref>. 2 The encoding is performed in such a way that checking the validity of a proof reduces to typechecking in LF. In practice, typechecking LF is fast, and so almost all of the burden of constructing the proof is shifted to the code producer.
Reference: [5] <author> R. Levien, L. McCarthy, and M. </author> <title> Blaze, "Transparent Internet E-mail Secu--rity," </title> <address> http://www.cs.umass.edu/ lmccarth/crypto/papers/email.ps </address>
Reference-contexts: The most general definition of trust management is policy-controlled processing of standardized metadata, using trusted third parties. We will flesh out what this definition means in the mobile-code context. For more information about trust management in other domains, refer to, e.g., <ref> [1, 2, 3, 5] </ref>. Policy control is the way in which the individual characteristics of the host's environment are formally encoded in a security policy with which all incoming mobile programs must comply.
Reference: [6] <author> G. Necula and P. Lee, </author> <title> "Safe Kernel Extensions Without Run-Time Checking," </title> <booktitle> in Proceedings of the 2nd Symposium on Operating System Design and Implementation (OSDI'96), </booktitle> <address> Seattle, </address> <month> October, </month> <year> 1996, </year> <pages> 229-243. </pages>
Reference-contexts: We then briefly explain two approaches to mobile-code security: trust management and proof-carrying code. (More complete explanations of these approaches can be found in <ref> [1, 6, 7] </ref>.) Although both of these approaches are only in embryonic stages of development, we believe the early experimental results give some basis for speculating on larger-scale applications. <p> Not surprisingly, both trust management and proof-carrying code are based on the use of formal language to address the problem of mobile-code security. We now give brief descriptions of these approaches. More complete descriptions are given in <ref> [1, 6, 7] </ref>. 3 3.1 Proof-Carrying Code Proof-carrying code (PCC) is a mechanism that supports the construction of easily checkable mathematical proofs of program properties, as well as the formal specification of behavioral safety properties. <p> Once this is done, the proofs can be written out and sent along with the code to the host. The host can then quickly validate with certainty that the proof does indeed establish the specified safety properties. For more information about the applications and principles underlying proof-carrying code, see <ref> [6, 7] </ref>. PCC works by encoding the proofs in a language based on the typed - calculus, called LF [4]. 2 The encoding is performed in such a way that checking the validity of a proof reduces to typechecking in LF. <p> By metadata, we mean anything that is used in the decision-making process besides P itself. Important examples of metadata include digital signatures by trusted parties, public-key "certificates" guaranteeing the validity of signature-verification keys, PCC proofs <ref> [6, 7] </ref>, and information about the path travelled by P before it reached the host. Finally, trusted third parties are those whom the host trusts to make certain statements without supplying proofs that they are true.
Reference: [7] <author> G. Necula and P. Lee, </author> <title> "Proof-Carrying Code," </title> <type> Technical Report CMU-CS-96-165, </type> <institution> School of Computer Science, Carnegie Mellon University, Septem-ber, </institution> <year> 1996. </year>
Reference-contexts: We then briefly explain two approaches to mobile-code security: trust management and proof-carrying code. (More complete explanations of these approaches can be found in <ref> [1, 6, 7] </ref>.) Although both of these approaches are only in embryonic stages of development, we believe the early experimental results give some basis for speculating on larger-scale applications. <p> Not surprisingly, both trust management and proof-carrying code are based on the use of formal language to address the problem of mobile-code security. We now give brief descriptions of these approaches. More complete descriptions are given in <ref> [1, 6, 7] </ref>. 3 3.1 Proof-Carrying Code Proof-carrying code (PCC) is a mechanism that supports the construction of easily checkable mathematical proofs of program properties, as well as the formal specification of behavioral safety properties. <p> Once this is done, the proofs can be written out and sent along with the code to the host. The host can then quickly validate with certainty that the proof does indeed establish the specified safety properties. For more information about the applications and principles underlying proof-carrying code, see <ref> [6, 7] </ref>. PCC works by encoding the proofs in a language based on the typed - calculus, called LF [4]. 2 The encoding is performed in such a way that checking the validity of a proof reduces to typechecking in LF. <p> By metadata, we mean anything that is used in the decision-making process besides P itself. Important examples of metadata include digital signatures by trusted parties, public-key "certificates" guaranteeing the validity of signature-verification keys, PCC proofs <ref> [6, 7] </ref>, and information about the path travelled by P before it reached the host. Finally, trusted third parties are those whom the host trusts to make certain statements without supplying proofs that they are true.
Reference: [8] <author> D. Tennenhouse and D. Wetherall, </author> <title> "Towards an Active Network Architecture," </title> <journal> Computer Communication Review, </journal> <volume> vol. 26, no. 2, </volume> <month> April, </month> <year> 1996. </year> <month> 8 </month>
Reference-contexts: for some reason C's certification is not good enough, then again host A will have to insist that B use PCC to attach a proof that its programs are indeed are in domain S. 4.2 Active Networks The notion of an active network switch was proposed by Tennenhouse and Wetherall <ref> [8] </ref> and is now the basis for a major DARPA research initiative. The basic idea is to allow users to inject programs into the nodes of a network, even the Internet. <p> A typical example is a user who uploads into a network switch a program to do translation of video streams to suit the needs of the recipients of the video. In <ref> [8] </ref>, the performance factor leads to a design in which the mobile code actually runs in the unprotected kernel address space, and hence the code must be guaranteed not to corrupt the network switch's operating system.
References-found: 8

