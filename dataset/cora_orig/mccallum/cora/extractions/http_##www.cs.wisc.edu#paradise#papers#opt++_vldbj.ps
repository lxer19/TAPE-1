URL: http://www.cs.wisc.edu/paradise/papers/opt++_vldbj.ps
Refering-URL: http://www.cs.wisc.edu/paradise/paradise.papers.html
Root-URL: 
Email: fnavin, dewittg@cs.wisc.edu  
Title: OPT++ An Object-Oriented Implementation for Extensible Database Query Optimization  
Author: Navin Kabra David J. DeWitt 
Address: Wisconsin, Madison  
Affiliation: Computer Sciences Department University of  
Abstract: In this paper we describe the design and implementation of OPT++, a tool for Extensible Database Query Optimization that uses an object-oriented design to simplify the task of implementing, extending, and modifying an optimizer. Building an optimizer using OPT++ makes it easy to extend the query algebra (to add new query algebra operators and physical implementation algorithms to the system), easy to change the search space, and also to change the search strategy. Furthermore, OPT++ comes equipped with a number of search strategies that are available for use by an OI. OPT++ considerably simplifies both, the task of implementing an optimizer for a new database system, and the task of evaluating alternative optimization techniques and strategies to decide what techniques are best suited for that database system. We present the results of a series of performance studies. These results validate our design and show that, in spite of its flexibility, OPT++ can be used to build efficient optimizers. 
Abstract-found: 1
Intro-found: 1
Reference: [BG92] <author> Ludger Becker and Ralf Harmut Guting. </author> <title> "Rule-Based Optimization and Query Processing in an Extensible Geometric Database System". </title> <journal> In ACM Transactions on Database Systems, </journal> <volume> volume 17:2, </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: This makes it much easier to write an optimizer from scratch. In spite of these assumptions, a number of different search strategies can easily be implemented in OPT++ quite easily. 35 The query optimizer used in the <ref> [BG92] </ref> system uses a formal concept of a many-sorted relational algebra to design a rule-based optimizer that is extensible and can handle new data types. However, the architecture is based on algebraic equivalence rules. Hence, unlike OPT++, it limits the OI to implement only transformation based optimization schemes.
Reference: [BMG93] <author> Jose A. Blakeley, William J. McKenna, and Goetz Graefe. </author> <title> "Experiences Building the Open OODB Query Optimizer". </title> <booktitle> In Proceedings of the 1993 ACM-SIGMOD Conference, </booktitle> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The new algebra allows reference-valued attributes, set-valued attributes, and the use of path-indices. We extended the optimizer to implement the optimization techniques described in <ref> [BMG93] </ref>. We added a MATERIALIZE query algebra operator that represents materialization of a reference-valued attribute (in other words, dereferencing a pointer). A corresponding ASSEMBLY algorithm class is used to represent the physical execution algorithm used to implement MATERIALIZE [KGM91]. <p> For example, if a path-index exists on city.mayor.name, the predicate city.mayor.name = "Lee" can be evaluated without having to materialize the city or mayor objects (see <ref> [BMG93] </ref> for details). A new PATHINDEXSELECT algorithm was derived from the ALGORITHM class to capture such path-index scans. <p> The implementation is very similar to the scheme described in <ref> [BMG93] </ref>. 7 In the next section we shall see that a switch from the Transformative strategy to one of the Randomized strategies is much easier than this. 22 mization Times (Log-scale) ory Requirements Figures 19 and 20 compare the two optimizers in terms of optimization times and memory consumed for randomly <p> An assembly enforcer is required to make this work. 9 There can be more than one materialize operations between the select and the filescan. 30 Increase in Optimization Times Improvement in Estimated Costs (Scaled) 31 See <ref> [BMG93] </ref> for a detailed discussion of this issue. We have incorporated in our optimizer the assembly enforcer as described in [BMG93]. We conducted experiments to study the effect of path indexes upon optimization time and the estimated execution cost. <p> make this work. 9 There can be more than one materialize operations between the select and the filescan. 30 Increase in Optimization Times Improvement in Estimated Costs (Scaled) 31 See <ref> [BMG93] </ref> for a detailed discussion of this issue. We have incorporated in our optimizer the assembly enforcer as described in [BMG93]. We conducted experiments to study the effect of path indexes upon optimization time and the estimated execution cost. In these experiments, there was a 20% chance of a path index being available for evaluating any given predicate. The selectivity of these predicates varied uniformly from 0 to 100%.
Reference: [FG91] <author> Beatrice Finance and Georges Gardarin. </author> <title> "A Rule Based Query Rewriter in an Extensible DBMS". </title> <booktitle> In Proceedings of the 7th International Conference on Data Engineering. IEEE, </booktitle> <year> 1991. </year>
Reference-contexts: Most optimizers that allow extensibility of the query algebra employ some form of a rule-based system that uses rewrite rules to describe transformations that can be performed to optimize a query expression <ref> [Fre87, Gra87, PHH92, FG91] </ref>. These systems usually offer a more-or-less fixed search strategy that is difficult to modify or extend. Freytag [Fre87] describes an architecture in which the translation of a query into an executable plan is completely based on rules.
Reference: [Fre87] <author> Johann Christoph Freytag. </author> <title> "A Rule-Based View of Query Optimization". </title> <booktitle> In Proceedings of the 1987 ACM-SIGMOD Conference, </booktitle> <address> San Francisco, California, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: Most optimizers that allow extensibility of the query algebra employ some form of a rule-based system that uses rewrite rules to describe transformations that can be performed to optimize a query expression <ref> [Fre87, Gra87, PHH92, FG91] </ref>. These systems usually offer a more-or-less fixed search strategy that is difficult to modify or extend. Freytag [Fre87] describes an architecture in which the translation of a query into an executable plan is completely based on rules. <p> These systems usually offer a more-or-less fixed search strategy that is difficult to modify or extend. Freytag <ref> [Fre87] </ref> describes an architecture in which the translation of a query into an executable plan is completely based on rules. He describes a System-R style optimizer that can be built using various sets of rules. One set of rules is used to convert the query into an algebraic tree.
Reference: [GD87] <author> G. Graefe and D. J. DeWitt. </author> <title> "The EXODUS Optimizer Generator". </title> <booktitle> In Proceedings of the 1987 ACM-SIGMOD Conference, </booktitle> <address> San Francisco, California, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: While this approach is well suited for access method and join enumeration, it is not clear how this can be used to optimize queries containing non-relational operators and complicated 34 transformations. The optimizers generated by the Exodus Optimizer Generator <ref> [GD87] </ref>, the Volcano Optimizer Generator [GM93] and the Cascades Framework [Gra95] use algebraic equivalence rules to transform an operator tree for a query into other, equivalent operator trees. Implementation rules are used to determine what algorithms can be used to implement the various operators.
Reference: [GLPK94] <author> Cesar Galindo-Legaria, Arjan Pellenkoft, and Martin L. Kersten. </author> <title> "Fast, Randomized, Join-Order Selection Why Use Transformations". </title> <booktitle> In Proc. of the 20th VLDB Conf., </booktitle> <address> Santiago de Chile, Chile, </address> <year> 1994. </year>
Reference-contexts: The abstractions in OPT++ were made restrictive for the purposes of efficiency. Consequently, there are some special-purpose non-standard optimization algorithms that cannot be modelled using the OPT++ abstractions. Thus, the join order enumeration algorithms described in <ref> [GLPK94] </ref>, [VM96] and [KBZ86] the cannot be easily incorporated into OPT++. While some of the ideas and data-structures of these algorithms can be incorporated into search strategies implemented in OPT++, the algorithms in their entirety cannot be incorporated in a reasonably extensible way.
Reference: [GM93] <author> G. Graefe and W. J. McKenna. </author> <title> "The Volcano Optimizer Generator: Extensibility and Efficient Search". </title> <booktitle> In Proc. IEEE Conf. on Data Eng., </booktitle> <address> Vienna, Austria, </address> <year> 1993. </year>
Reference-contexts: The purpose of these algorithms is not to perform any logical data manipulation but to enforce physical properties in their outputs that are required for subsequent query processing algorithms. These are referred to as enforcers by the Volcano Optimizer Generator <ref> [GM93] </ref>, and are comparable to the glue operators in Starburst [LFL88]. Classes corresponding to such enforcers should also be derived from the ALGORITHM class. <p> The "Bottom-up" search strategy is similar to the one used by the System-R optimizer [SAC + 79]. The "Transformative" search strategy is based upon the search engine of the Volcano Optimizer Generator <ref> [GM93] </ref>. Finally, three randomized search strategies, Iterated Improvement [SG88], Simulated Annealing [IW87], and Two Phase Optimization [IK90], have been implemented. 2.4.1 The Bottom-up Search Strategy This search strategy can be used to implement optimizers that use bottom-up dynamic-programming similar to the System-R optimizer [SAC + 79]. <p> The procedure for generation of access plans corresponding to an operator tree, and for their pruning is similar to that used in the bottom-up search strategy. Note that our TREETOPLANGENERATOR classes are analogous to the implementation rules of the Volcano Optimizer Generator <ref> [GM93] </ref>. Optimization is complete when none of the existing operator trees can be further transformed. 2.4.3 Randomized Search Strategies In this section, we briefly describe the implementation of the randomized search strategies in OPT++. <p> This was done with the intention of illustrating the ease of use and extensibility of OPT++. We also report on several performance studies including a performance comparison with an optimizer generated using the Volcano Optimizer Generator <ref> [GM93] </ref> - to show that, in spite of its flexibility, OPT++ is efficient. We also performed a study of the various search strategies and optimization techniques that have been implemented in OPT++ to study their relative effectiveness in the presence of the object-relational operators. <p> While this approach is well suited for access method and join enumeration, it is not clear how this can be used to optimize queries containing non-relational operators and complicated 34 transformations. The optimizers generated by the Exodus Optimizer Generator [GD87], the Volcano Optimizer Generator <ref> [GM93] </ref> and the Cascades Framework [Gra95] use algebraic equivalence rules to transform an operator tree for a query into other, equivalent operator trees. Implementation rules are used to determine what algorithms can be used to implement the various operators.
Reference: [Gra87] <author> Goetz Graefe. </author> <title> "Rule-Based Query Optimization in Extensible Database Systems". </title> <type> PhD thesis, </type> <institution> University of Wisconsin-Madison, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: Most optimizers that allow extensibility of the query algebra employ some form of a rule-based system that uses rewrite rules to describe transformations that can be performed to optimize a query expression <ref> [Fre87, Gra87, PHH92, FG91] </ref>. These systems usually offer a more-or-less fixed search strategy that is difficult to modify or extend. Freytag [Fre87] describes an architecture in which the translation of a query into an executable plan is completely based on rules.
Reference: [Gra95] <author> Goetz Graefe. </author> <title> "The Cascades Framework for Query Optimization". </title> <journal> In Bulletin of the Technical Committee on Data Engineering, </journal> <volume> volume 18-3, </volume> <pages> pages 19-29, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: While this approach is well suited for access method and join enumeration, it is not clear how this can be used to optimize queries containing non-relational operators and complicated 34 transformations. The optimizers generated by the Exodus Optimizer Generator [GD87], the Volcano Optimizer Generator [GM93] and the Cascades Framework <ref> [Gra95] </ref> use algebraic equivalence rules to transform an operator tree for a query into other, equivalent operator trees. Implementation rules are used to determine what algorithms can be used to implement the various operators. <p> In addition, the search strategy in OPT++ is extensible and can be modified to fit the optimization problem, if necessary. Our experience with the implementation of an optimizer using OPT++ shows that this flexibility is achieved without sacrificing performance. The Cascades Framework <ref> [Gra95] </ref> is similar to the Volcano Optimizer Generator, but it uses C++ classes to represent the transformation rules, implementation rules and predicates. It also allows the search strategy to be "guided" through the use of user defined Guidance classes that can heuristically control the application of the transformation rules.
Reference: [Hel94] <author> Joseph M. Hellerstein. </author> <title> "Practical Predicate Placement". </title> <booktitle> In Proceedings of the 1994 ACM-SIGMOD Conference, </booktitle> <address> Minneapolis, Minnesota, </address> <month> May </month> <year> 1994. </year>
Reference: [HP88] <author> Waqar Hasan and Hamid Pirahesh. </author> <title> "Query Rewrite Optimization in Starburst". </title> <type> Research Report RJ 6367 (62349), </type> <institution> IBM, </institution> <year> 1988. </year> <month> 37 </month>
Reference-contexts: One set of rules is used to convert the query into an algebraic tree. Other sets of rules are used to generate access paths, join orderings, and join methods in that order. The optimizer developed as a part of the Starburst project <ref> [LFL88, HP88] </ref> uses a two step process to optimize queries. The first phase uses a set of production rules to heuristically transform the query into an equivalent query that (hopefully) offers both faster execution than the old query and is better suited for cost-based optimization.
Reference: [IK90] <author> Yannis E. Ioannidis and Younkyung Cha Kang. </author> <title> "Randomized Algorithms for Optimizing Large Join Queries". </title> <booktitle> In Proceedings of the 1990 ACM-SIGMOD Conference, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: The "Bottom-up" search strategy is similar to the one used by the System-R optimizer [SAC + 79]. The "Transformative" search strategy is based upon the search engine of the Volcano Optimizer Generator [GM93]. Finally, three randomized search strategies, Iterated Improvement [SG88], Simulated Annealing [IW87], and Two Phase Optimization <ref> [IK90] </ref>, have been implemented. 2.4.1 The Bottom-up Search Strategy This search strategy can be used to implement optimizers that use bottom-up dynamic-programming similar to the System-R optimizer [SAC + 79]. The INITIALTREEGENERATOR is invoked to initialize the collection of operator trees. <p> The stopping conditions and other parameters for the randomized search strategies were as described in <ref> [IK90] </ref>. Figures 21 and 22 show the performance results obtained. Since the Bottom-up and the Transformative strategies produce exactly the same plans, Figure 22 shows only one curve for both of them. <p> They also confirm the findings of <ref> [IK90] </ref> that Two Phase Optimization performs better than either Simulated Annealing or Iterated Improvement. In Figure 23, the memory requirements of the different strategies are presented.
Reference: [IW87] <author> Yannis E. Ioannidis and Eugene Wong. </author> <title> "Query Optimization by Simulated Annealing". </title> <booktitle> In Proceedings of the 1987 ACM-SIGMOD Conference, </booktitle> <address> San Francisco, California, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: The "Bottom-up" search strategy is similar to the one used by the System-R optimizer [SAC + 79]. The "Transformative" search strategy is based upon the search engine of the Volcano Optimizer Generator [GM93]. Finally, three randomized search strategies, Iterated Improvement [SG88], Simulated Annealing <ref> [IW87] </ref>, and Two Phase Optimization [IK90], have been implemented. 2.4.1 The Bottom-up Search Strategy This search strategy can be used to implement optimizers that use bottom-up dynamic-programming similar to the System-R optimizer [SAC + 79]. The INITIALTREEGENERATOR is invoked to initialize the collection of operator trees.
Reference: [Kan91] <author> Younkyung Cha Kang. </author> <title> "Randomized Algorithms for Query Optimization". </title> <type> Technical Report TR-1053, </type> <institution> Computer Sciences Department, University of Wisconsin-Madison, </institution> <year> 1991. </year>
Reference-contexts: Figures 21 and 22 show the performance results obtained. Since the Bottom-up and the Transformative strategies produce exactly the same plans, Figure 22 shows only one curve for both of them. Qualitatively, they confirm the findings of <ref> [Kan91] </ref> that for smaller queries the exhaustive 23 Optimization Times (Log-scale) Estimated Costs (Scaled) 24 algorithms consume much less time for optimization than the randomized algorithms and yet produce equivalent or better plans, while for larger queries, the randomized algorithms take much less time to find plans that are almost as
Reference: [KBZ86] <author> Ravi Krishnamurthy, Haran Boral, and Carlo Zaniolo. </author> <title> "Optimization of Nonrecursive Queries". </title> <booktitle> In Proc. of the 12th VLDB Conf., </booktitle> <address> Kyoto, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: The abstractions in OPT++ were made restrictive for the purposes of efficiency. Consequently, there are some special-purpose non-standard optimization algorithms that cannot be modelled using the OPT++ abstractions. Thus, the join order enumeration algorithms described in [GLPK94], [VM96] and <ref> [KBZ86] </ref> the cannot be easily incorporated into OPT++. While some of the ideas and data-structures of these algorithms can be incorporated into search strategies implemented in OPT++, the algorithms in their entirety cannot be incorporated in a reasonably extensible way.
Reference: [KGM91] <author> Tom Keller, Goetz Graefe, and David Maier. </author> <title> "Efficient Assembly of Complex Objects". </title> <booktitle> In Proceedings of the 1991 ACM-SIGMOD Conference, </booktitle> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: We extended the optimizer to implement the optimization techniques described in [BMG93]. We added a MATERIALIZE query algebra operator that represents materialization of a reference-valued attribute (in other words, dereferencing a pointer). A corresponding ASSEMBLY algorithm class is used to represent the physical execution algorithm used to implement MATERIALIZE <ref> [KGM91] </ref>. An UNNEST operator class and the corresponding UNNESTALGORITHM class is used to represent unnesting of set-valued attributes. The MATERIALIZEEXPAND class derived from the TREETOTREEGENERATOR class takes an operator tree and expands it by adding a materialize operation that dereferences a reference-valued attribute present in its input.
Reference: [KMP93] <author> Alfons Kemper, Guido Moerkotte, and Klaus Peithner. </author> <title> "A Blackboard Architecture for Query Optimization in Object Bases". </title> <booktitle> In Proc. of the 19th VLDB Conf., </booktitle> <year> 1993. </year>
Reference-contexts: Various architectures have been proposed to allow extensible control over the search strategy of an optimizer. The region-based optimizer architecture of Mitchell et al. [MDZ93], the modular optimizer architecture by Sciore and Sieg [SJ90], the blackboard architecture of Kemper, Moerkotte and Peith-ner <ref> [KMP93] </ref>, are all based on the concept of dividing an optimizer into regions that carry out different parts of the optimization. A query then has to pass through these various regions to be optimized. These architectures differ in the methods used to pass control between the various regions. <p> In [SJ90], control passes from one region to another in a fixed sequence. [MDZ93] uses a hierarchy of regions in which the parent region dynamically controls the sequence of regions through which the query passes while being optimized. In the blackboard approach <ref> [KMP93] </ref>, knowledge sources are responsible for moving the queries between regions. All these architectures describe very general frameworks for extensible query optimization that support multiple optimizer control strategies and allow the addition of new control strategies. <p> Thus OPT++ can be used to build a smart query optimizer that dynamically customizes its optimization strategy depending upon the input. We plan to add some additional search strategies to the repertoire of strategies available in OPT++. In particular, the A* heuristic <ref> [Pea84, KMP93] </ref>, and the heuristics described in [Swa89] seem promising. We also plan to add debugging support to OPT++. Debugging an optimizer remains a complex and time-consuming task.
Reference: [LFL88] <author> Mavis K. Lee, Johann Christoph Freytag, and Guy M. Lohman. </author> <title> "Implementing an Interpreter for Functional Rules in a Query Optimizer". </title> <booktitle> In Proc. of the 14th VLDB Conf., </booktitle> <address> Los Angeles, California, </address> <year> 1988. </year>
Reference-contexts: These are referred to as enforcers by the Volcano Optimizer Generator [GM93], and are comparable to the glue operators in Starburst <ref> [LFL88] </ref>. Classes corresponding to such enforcers should also be derived from the ALGORITHM class. For example, in a relational query optimizer, the SORT algorithm is an enforcer that can be used to ensure that the inputs of the MERGEJOIN algorithm are sorted on the join attribute. <p> One set of rules is used to convert the query into an algebraic tree. Other sets of rules are used to generate access paths, join orderings, and join methods in that order. The optimizer developed as a part of the Starburst project <ref> [LFL88, HP88] </ref> uses a two step process to optimize queries. The first phase uses a set of production rules to heuristically transform the query into an equivalent query that (hopefully) offers both faster execution than the old query and is better suited for cost-based optimization.
Reference: [LV91] <author> Rosana S. G. Lanzelotte and Patrick Valduriez. </author> <title> "Extending the Search Strategy in a Query Optimizer". </title> <booktitle> In Proc. of the 17th VLDB Conf., </booktitle> <address> Barcelona, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: A number of search strategies have been implemented in OPT++ in this query-algebra-independent manner. The implementation of the various search strategies is loosely modeled on the object-oriented scheme described in <ref> [LV91] </ref>. OPT++ defines a SEARCHSTRATEGY abstract class with virtual methods, and each of the search strategies in OPT++ is actually implemented as a class derived from the SE-ARCHSTRATEGY abstract class. <p> Another consequence of this design is that OI can modify the behavior of any search strategy by deriving a new class from it and redefining some of the virtual methods. See <ref> [LV91] </ref> to see how this is accomplished. In this section we concentrate on describing how the various search strategies are implemented in terms of the OPERATOR, ALGORITHM, and GENERATOR abstract classes, and in the next section we describe how the OI can easily switch from one search strategy to another. <p> However, the architecture is based on algebraic equivalence rules. Hence, unlike OPT++, it limits the OI to implement only transformation based optimization schemes. Lanzelotte and Valduriez <ref> [LV91] </ref> also describe an object-oriented design for an extensible query optimizer. The design of the search strategy code in OPT++ is inspired by this work. However, OPT++ differs in its modeling of the query algebra and the search space. <p> In particular, OPT++ has a clear separation between the logical algebra (operator trees) and the physical algebra (access plans). We believe this separation is necessary for the efficiency of the optimizer as well as for clarity and extensibility. Although <ref> [LV91] </ref> discusses extensibility of the search strategy in detail, it is not clear how extensible their design is in terms of adding new operators and algorithms, modifying the search space, or how such changes would interact with one another or with the search strategy.
Reference: [MBHT96] <author> William J. McKenna, Louis Burger, Chi Hoang, and Melissa Truong. "EROC: </author> <title> A Toolkit for Building NEATO Query Optimizers". </title> <booktitle> In Proc. of the 22nd VLDB Conf., </booktitle> <address> Mumbai (Bombay), India, </address> <year> 1996. </year>
Reference-contexts: The EROC toolkit for building optimizers <ref> [MBHT96] </ref> was developed concurrently with OPT++ and comes closest in terms of design philosophy to OPT++. EROC is a toolkit for building query optimizers based on components that are C++ abstract classes that they have identified as central to query optimization.
Reference: [MDZ93] <author> Gail Mitchell, Umeshwar Dayal, and Stanley B. Zdonik. </author> <title> "Control of an Extensible Query Optimizer: </title>
Reference-contexts: It can be "guided", but cannot be changed or replaced. For example, a System-R style bottom-up optimizer cannot be implemented using the Cascades Framework. Various architectures have been proposed to allow extensible control over the search strategy of an optimizer. The region-based optimizer architecture of Mitchell et al. <ref> [MDZ93] </ref>, the modular optimizer architecture by Sciore and Sieg [SJ90], the blackboard architecture of Kemper, Moerkotte and Peith-ner [KMP93], are all based on the concept of dividing an optimizer into regions that carry out different parts of the optimization. <p> A query then has to pass through these various regions to be optimized. These architectures differ in the methods used to pass control between the various regions. In [SJ90], control passes from one region to another in a fixed sequence. <ref> [MDZ93] </ref> uses a hierarchy of regions in which the parent region dynamically controls the sequence of regions through which the query passes while being optimized. In the blackboard approach [KMP93], knowledge sources are responsible for moving the queries between regions.
References-found: 21

