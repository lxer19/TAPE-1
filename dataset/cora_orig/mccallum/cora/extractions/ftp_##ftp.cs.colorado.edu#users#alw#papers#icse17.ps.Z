URL: ftp://ftp.cs.colorado.edu/users/alw/papers/icse17.ps.Z
Refering-URL: http://www.cs.colorado.edu/~arcadia/Papers/metrics/cu_metrics_papers.html
Root-URL: http://www.cs.colorado.edu
Email: fjcook,alwg@cs.colorado.edu  
Title: Automating Process Discovery through Event-Data Analysis  
Author: Jonathan E. Cook and Alexander L. Wolf 
Date: April 1995  
Address: Seattle, Washington, USA,  Boulder, CO 80309 USA  
Affiliation: Engineering,  Department of Computer Science University of Colorado  
Note: From the Proc. of the 17th Inter. Conf. on Software  
Abstract: Many software process methods and tools presuppose the existence of a formal model of a process. Unfortunately, developing a formal model for an on-going, complex process can be difficult, costly, and error prone. This presents a practical barrier to the adoption of process technologies. The barrier would be lowered by automating the creation of formal models. We are currently exploring techniques that can use basic event data captured from an on-going process to generate a formal model of process behavior. We term this kind of data analysis process discovery. This paper describes and illustrates three methods with which we have been experimenting: algorithmic grammar inference, Markov models, and neural networks. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Angluin and C.H. Smith. </author> <title> Inductive Inference: Theory and Methods. </title> <journal> ACM Computing Surveys, </journal> <volume> 15(3) </volume> <pages> 237-269, </pages> <month> Septem-ber </month> <year> 1983. </year>
Reference-contexts: To develop our initial set of methods, we have cast the process discovery problem in terms of another, previously investigated FSM discovery problem. That problem is the discovery of a grammar for a regular language given example sentences in that language <ref> [1] </ref>. If one interprets events as tokens and event streams as sentences, then the problems converge on somewhat similar solutions. <p> Others also use negative examples, which are sentences known to be illegal in the language. In this section we describe three inference methods that can be used in process discovery. The methods represent 1 A good survey of algorithmic methods is provided by Angluin and Smith <ref> [1] </ref>. 74 ABCABCBACBACABCBACBACABCBACABCABCBACBA three points on the spectrum from algorithmic to statistical techniques. Since we are dealing with data collected from process executions, we have only positive samples with which to work. The methods can be characterized by the manner in which they examine those samples.
Reference: [2] <author> G.S. Avrunin, U.A. Buy, J.C. Corbett, L.K. Dillon, and J.C. Wileden. </author> <title> Automated Analysis of Concurrent Systems with the Constrained Expression Toolset. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: The overlapping activities of a process, then, are represented by a sequence of events, which we refer to as an event stream. Using event data to characterize behavior is widely accepted in other areas of software engineering, such as program visualization [23], concurrent-system analysis <ref> [2] </ref>, and distributed debugging [5, 10]. Our approach in the work described here is to analyze a trace of a process execution|in the form of an event stream|and infer a formal model that can account for the behavior of the process (see Figure 1).
Reference: [3] <author> S. Bandinelli, A. Fuggetta, and C. Ghezzi. </author> <title> Software Process Model Evolution in the SPADE Environement. </title> <journal> IEEE Transactions on Software Engineering, </journal> 19(12) 1128-1144, Decem-ber 1993. 
Reference-contexts: In response, new methods and tools for supporting various aspects of the software process have been devised. Many of the technologies, including process automation [4, 12, 27, 29], process analysis [15, 16, 20, 28], process evolution <ref> [3, 19] </ref>, and process validation [9], assume the existence of some sort of formal model of a process in order for those technologies to be applied.
Reference: [4] <author> N.S. Barghouti and G.E. Kaiser. </author> <title> Scaling Up Rule-based Development Environments. </title> <booktitle> In Proceedings of the Third Euro-pean Software Engineering Conference, number 550 in Lecture Notes in Computer Science, </booktitle> <pages> pages 380-395. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The issues of managing and improving the process of developing and maintaining software have come to the forefront of software engineering research. In response, new methods and tools for supporting various aspects of the software process have been devised. Many of the technologies, including process automation <ref> [4, 12, 27, 29] </ref>, process analysis [15, 16, 20, 28], process evolution [3, 19], and process validation [9], assume the existence of some sort of formal model of a process in order for those technologies to be applied.
Reference: [5] <author> P. Bates. </author> <title> Debugging Heterogenous Systems Using Event-Based Models of Behavior. </title> <booktitle> In Proceedings of a Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 11-22. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: The overlapping activities of a process, then, are represented by a sequence of events, which we refer to as an event stream. Using event data to characterize behavior is widely accepted in other areas of software engineering, such as program visualization [23], concurrent-system analysis [2], and distributed debugging <ref> [5, 10] </ref>. Our approach in the work described here is to analyze a trace of a process execution|in the form of an event stream|and infer a formal model that can account for the behavior of the process (see Figure 1).
Reference: [6] <author> A.W. Biermann and J.A. Feldman. </author> <title> On the Synthesis of Finite State Machines from Samples of Their Behavior. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 21(6) </volume> <pages> 592-597, </pages> <month> June </month> <year> 1972. </year>
Reference-contexts: An advantage of the RNet method is that, since it is statistical in nature, it has the potential of being robust with respect to input stream noise (e.g., collection errors or abnormal process events). 3.2 Ktail The next method is purely algorithmic and based on work by Biermann and Feldman <ref> [6] </ref>. Their original presentation was formulated in terms of sample strings and output values for the FSM at the end of the strings. Our formulation of this algorithm does not make use of the output values, and is thus presented as just operating on the sample strings themselves.
Reference: [7] <author> M.G. Bradac, D.E. Perry, and L.G. Votta. </author> <title> Prototyping a Process Monitoring Experiment. </title> <journal> IEEE Transactions on Software Engineering, </journal> 20(10) 774-784, October 1994. 
Reference-contexts: As mentioned in the introduction, we assume that event data are being collected on the executing process. Methods already exist and are being used to collect such data <ref> [7, 30] </ref>. Once collected, the data can be viewed as a window onto the execution. In general, this window will not show the whole execution, since there will be some activities for which no event data are collected at all.
Reference: [8] <author> D. Brand and P. Zafiropulo. </author> <title> On Communicating Finite-State Machines. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 323-342, </pages> <year> 1983. </year> <month> 81 </month>
Reference-contexts: that we plan to explore: * preprocess the event stream to separate unrelated events based on their attributes; * modify the data collection method to generate separate event streams for different threads; and * develop inference methods that use formalisms having concurrent behavioral models, such as communicating finite state machines <ref> [8] </ref>. Process discovery is not restricted to creating new formal process models. Any organization's process will evolve over time, and thus their process models will need to evolve as well.
Reference: [9] <author> J.E. Cook and A.L. Wolf. </author> <title> Toward Metrics for Process Vali--dation. </title> <booktitle> In Proceedings of the Third International Conference on the Software Process, </booktitle> <pages> pages 33-44. </pages> <publisher> IEEE Computer Society, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: In response, new methods and tools for supporting various aspects of the software process have been devised. Many of the technologies, including process automation [4, 12, 27, 29], process analysis [15, 16, 20, 28], process evolution [3, 19], and process validation <ref> [9] </ref>, assume the existence of some sort of formal model of a process in order for those technologies to be applied. The need to develop a formal model as a prerequisite to using a new technology is a daunting prospect to the managers of large, on-going projects.
Reference: [10] <author> J. Cuny, G. Forman, A. Hough, J. Kundu, C. Lin, L. Sny-der, and D. Stemple. </author> <title> The Adriane Debugger: Scalable Application of Event-Based Abstraction. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 85-95. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: The overlapping activities of a process, then, are represented by a sequence of events, which we refer to as an event stream. Using event data to characterize behavior is widely accepted in other areas of software engineering, such as program visualization [23], concurrent-system analysis [2], and distributed debugging <ref> [5, 10] </ref>. Our approach in the work described here is to analyze a trace of a process execution|in the form of an event stream|and infer a formal model that can account for the behavior of the process (see Figure 1).
Reference: [11] <author> S. Das and M.C. Mozer. </author> <title> A Unified Gradient-Descent/Clustering Architecture for Finite State Machine Induction. </title> <booktitle> In Proceedings of the 1993 Conference, number 6 in Advances in Neural Information Processing Systems, </booktitle> <pages> pages 19-26. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: Finally, the Markov method is a hybrid statistical and algorithmic approach that looks at the neighboring past and future behavior to define a state. To experiment with the methods, we have implemented Ktail and Markov, and for RNet we have extended an implementation by Das <ref> [11] </ref>. All of the graphical representations presented in this paper have been automatically generated by the dot directed-graph drawing tool [22] from the output of the discovery tools. To explain and illustrate the three methods in this section, we use the simple event stream of Figure 2. <p> This recently developed method is due to Das and Mozer <ref> [11] </ref>. We refer to it here as the RNet method. In a standard feed-forward neural network, neurons are split into layers, with all the outputs of the neurons in one layer feeding forward into all the neurons of the next layer (see Figure 3a).
Reference: [12] <author> W. Deiters and V. Gruhn. </author> <title> Managing Software Processes in the Environment MELMAC. </title> <booktitle> In SIGSOFT '90: Proceedings of the Fourth Symposium on Software Development Environments, </booktitle> <pages> pages 193-205. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> December </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The issues of managing and improving the process of developing and maintaining software have come to the forefront of software engineering research. In response, new methods and tools for supporting various aspects of the software process have been devised. Many of the technologies, including process automation <ref> [4, 12, 27, 29] </ref>, process analysis [15, 16, 20, 28], process evolution [3, 19], and process validation [9], assume the existence of some sort of formal model of a process in order for those technologies to be applied.
Reference: [13] <author> P.K. Garg and S. Bhansali. </author> <title> Process Programming by Hindsight. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <pages> pages 280-293. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1992. </year>
Reference-contexts: There seems to be little related work in the area of process discovery. The most closely related efforts take a rather different view from that described in this paper. We summarize that work below. * Garg and Bhansali <ref> [13] </ref> describe a method that uses explanation-based learning to discover aspects and fragments of the underlying process model from process history data and rules of operations and their effects. This work centers on using a rule base and goals to derive a generalized execution flow from a specific process history.
Reference: [14] <author> P.K. Garg, M. Jazayeri, </author> <title> and M.L. Creech. A Meta-Process for Software Reuse, Process Discovery, and Evolution. </title> <booktitle> In Proceedings of the 6th International Workshop on Software Reuse, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: The use of this is to help interactively guide software developers along action sequences that achieve the correct goal, rather than to infer a model of the process. * Garg et al. <ref> [14] </ref> employ process history analysis (mostly human-centered data validation and analysis) in the context of a meta-process for creating and validating domain-specific processes and software kits.
Reference: [15] <author> R.M. Greenwood. </author> <title> Using CSP and System Dynamics as Process Engineering Tools. </title> <booktitle> In Proceedings of the Second Eu-ropean Workshop on Software Process Technology, number 635 in Lecture Notes in Computer Science, </booktitle> <pages> pages 138-145. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: In response, new methods and tools for supporting various aspects of the software process have been devised. Many of the technologies, including process automation [4, 12, 27, 29], process analysis <ref> [15, 16, 20, 28] </ref>, process evolution [3, 19], and process validation [9], assume the existence of some sort of formal model of a process in order for those technologies to be applied.
Reference: [16] <author> V. Gruhn and R. Jegelka. </author> <title> An Evaluation of FUNSOFT Nets. </title> <booktitle> In Proceedings of the Second European Workshop on Software Process Technology, number 635 in Lecture Notes in Computer Science, </booktitle> <pages> pages 196-214. </pages> <publisher> Springer-Verlag, </publisher> <month> Septem-ber </month> <year> 1992. </year>
Reference-contexts: In response, new methods and tools for supporting various aspects of the software process have been devised. Many of the technologies, including process automation [4, 12, 27, 29], process analysis <ref> [15, 16, 20, 28] </ref>, process evolution [3, 19], and process validation [9], assume the existence of some sort of formal model of a process in order for those technologies to be applied.
Reference: [17] <author> K.E. Huff and V.R. Lesser. </author> <title> A Plan-based Intelligent Assistant that Supports the Software Development Process. </title> <booktitle> In SIGSOFT '88: Proceedings of the Third Symposium on Software Development Environments, </booktitle> <pages> pages 97-106. </pages> <publisher> ACM SIG-SOFT, </publisher> <month> February </month> <year> 1989. </year>
Reference-contexts: This work centers on using a rule base and goals to derive a generalized execution flow from a specific process history. By having enough rules, they show that a complete and correct process fragment could be generated from execution data. * Huff and Lesser <ref> [17] </ref> describe plan recognition, whereby a plan and its goal are inferred from a sequence of actions and an initial state.
Reference: [18] <author> W.S. Humphrey. </author> <title> Managing the Software Process. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: We are assuming, of course, that a project is already willing and able to collect data on the current process as part of a process improvement strategy <ref> [18] </ref>. The challenge in process discovery is to use those data to describe the process in a form suitable for formal-model-based process technologies. In general, this is a very difficult challenge to meet.
Reference: [19] <author> M.L. Jaccheri and R. Conradi. </author> <title> Techniques for Process Model Evolution in EPOS. </title> <journal> IEEE Transactions on Software Engineering, </journal> 19(12) 1145-1156, December 1993. 
Reference-contexts: In response, new methods and tools for supporting various aspects of the software process have been devised. Many of the technologies, including process automation [4, 12, 27, 29], process analysis [15, 16, 20, 28], process evolution <ref> [3, 19] </ref>, and process validation [9], assume the existence of some sort of formal model of a process in order for those technologies to be applied.
Reference: [20] <author> M.I. Kellner. </author> <title> Software Process Modeling Support for Management Planning and Control. </title> <booktitle> In Proceedings of the First International Conference on the Software Process, </booktitle> <pages> pages 8-28. </pages> <publisher> IEEE Computer Society, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: In response, new methods and tools for supporting various aspects of the software process have been devised. Many of the technologies, including process automation [4, 12, 27, 29], process analysis <ref> [15, 16, 20, 28] </ref>, process evolution [3, 19], and process validation [9], assume the existence of some sort of formal model of a process in order for those technologies to be applied. <p> The example in this section is taken from the ISPW 6/7 process problem [21]. We describe the process using an FSM that is based on Kellner's Statemate solution <ref> [20] </ref>. Our version is shown in Figure 8. The idea is to see how well the methods perform at reproducing this FSM and, thereby, discovering the process. At a high level, the ISPW 6/7 process proceeds as follows.
Reference: [21] <author> M.I. Kellner, P.H. Feiler, A. Finkelstein, T. Katayama, L.J. Osterweil, M.H. Penedo, and H.D. Rombach. </author> <title> Software Process Modeling Example Problem. </title> <booktitle> In Proceedings of the 6th International Software Process Workshop, </booktitle> <pages> pages 19-29, </pages> <month> Oc-tober </month> <year> 1990. </year>
Reference-contexts: In this section we show how the three methods perform on a rather more complex process than the simple example of the previous section. The example in this section is taken from the ISPW 6/7 process problem <ref> [21] </ref>. We describe the process using an FSM that is based on Kellner's Statemate solution [20]. Our version is shown in Figure 8. The idea is to see how well the methods perform at reproducing this FSM and, thereby, discovering the process.
Reference: [22] <author> E. </author> <title> Koutsofios and S.C. North. Drawing Graphs with Dot. </title> <institution> AT&T Bell Laboratories, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: To experiment with the methods, we have implemented Ktail and Markov, and for RNet we have extended an implementation by Das [11]. All of the graphical representations presented in this paper have been automatically generated by the dot directed-graph drawing tool <ref> [22] </ref> from the output of the discovery tools. To explain and illustrate the three methods in this section, we use the simple event stream of Figure 2. The stream is a sentence in a three-token language and is used as sample input for each of the methods.
Reference: [23] <author> R.J. LeBlanc and A.D. Robbins. </author> <title> Event-Driven Monitoring of Distributed Programs. </title> <booktitle> In Proceedings of the Fifth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 515-522. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1985. </year>
Reference-contexts: The overlapping activities of a process, then, are represented by a sequence of events, which we refer to as an event stream. Using event data to characterize behavior is widely accepted in other areas of software engineering, such as program visualization <ref> [23] </ref>, concurrent-system analysis [2], and distributed debugging [5, 10]. Our approach in the work described here is to analyze a trace of a process execution|in the form of an event stream|and infer a formal model that can account for the behavior of the process (see Figure 1).
Reference: [24] <author> L. Miclet and J. Quinqueton. </author> <title> Learning from Examples in Sequences and Grammatical Inference. </title> <editor> In G. Ferrate, T. Pavlidis, A. Sanfeliu, and H. Bunke, editors, </editor> <title> Syntactic and Structural Pattern Recognition, </title> <booktitle> volume 45 of NATO ASI Series F: Computer and Systems Sciences, </booktitle> <pages> pages 153-171. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: This method uses Markov models to find the most probable event sequence productions, and algorithmically converts those probabilities into states and state transitions. Although our method is new, there is previous work that has used similar methods. For example, Miclet and Quinqueton <ref> [24] </ref> use transition probabilities to create FSM recognizers of protein sequences, and then use the Markov models to predict the center point of new protein sequences.
Reference: [25] <author> N.H. Madhavji and D. Holtje and W. Hong and T. Bruck-haus. Elicit: </author> <title> A Method for Eliciting Process Models. </title> <booktitle> In Proceedings of the Third International Conference on the Software Process, </booktitle> <pages> pages 111-122. </pages> <publisher> IEEE Computer Society, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: This work is more along the lines of a process post-mortem that analyzes, through participant discussion, the changes that a process should undergo for the next cycle. * Madhavji et al. <ref> [25] </ref>, present a rigorous method (and corresponding tool) to help people elicit a process model from their collective knowledge about the executions of that process. It does not make an attempt to infer any portion of a formal process model from data.
Reference: [26] <author> D.E. Perry, N.A. Staudenmayer, and L.G. Votta. </author> <title> People, Organizations, and Process Improvement. </title> <journal> IEEE Software, </journal> <volume> 11(4) </volume> <pages> 36-45, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: For example, a chance meeting in a hallway might preclude the occurrence of a scheduled meeting for which events would have been recorded; or a decision might be made to focus the data collection effort on one particular aspect of the process, such as simple duration of work periods <ref> [26] </ref>. Hence, just as for any other data analysis technique, the results obtained by discovery methods strongly depend upon the content and quality of the data that are collected. What we seek from the data are recurring patterns of behavior.
Reference: [27] <author> B. Peuschel and W. Schafer. </author> <title> Concepts and Implementation of a Rule-based Process Engine. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <pages> pages 262-279. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction The issues of managing and improving the process of developing and maintaining software have come to the forefront of software engineering research. In response, new methods and tools for supporting various aspects of the software process have been devised. Many of the technologies, including process automation <ref> [4, 12, 27, 29] </ref>, process analysis [15, 16, 20, 28], process evolution [3, 19], and process validation [9], assume the existence of some sort of formal model of a process in order for those technologies to be applied.
Reference: [28] <author> M. Saeki, T. Kaneko, and M. Sakamoto. </author> <title> A Method for Software Process Modeling and Description Using LOTOS. </title> <booktitle> In Proceedings of the First International Conference on the Software Process, </booktitle> <pages> pages 90-104. </pages> <publisher> IEEE Computer Society, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: In response, new methods and tools for supporting various aspects of the software process have been devised. Many of the technologies, including process automation [4, 12, 27, 29], process analysis <ref> [15, 16, 20, 28] </ref>, process evolution [3, 19], and process validation [9], assume the existence of some sort of formal model of a process in order for those technologies to be applied.
Reference: [29] <author> S.M. Sutton, Jr., H. Ziv, D. Heimbigner, H.E. Yessayan, M. Maybee, , L.J. Osterweil, and X. Song. </author> <title> Programming a Software Requirements-specification Process. </title> <booktitle> In Proceedings of the First International Conference on the Software Process, </booktitle> <pages> pages 68-89. </pages> <publisher> IEEE Computer Society, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The issues of managing and improving the process of developing and maintaining software have come to the forefront of software engineering research. In response, new methods and tools for supporting various aspects of the software process have been devised. Many of the technologies, including process automation <ref> [4, 12, 27, 29] </ref>, process analysis [15, 16, 20, 28], process evolution [3, 19], and process validation [9], assume the existence of some sort of formal model of a process in order for those technologies to be applied.
Reference: [30] <author> A.L. Wolf and D.S. Rosenblum. </author> <title> A Study in Software Process Data Capture and Analysis. </title> <booktitle> In Proceedings of the Second International Conference on the Software Process, </booktitle> <pages> pages 115-124. </pages> <publisher> IEEE Computer Society, </publisher> <month> February </month> <year> 1993. </year> <month> 82 </month>
Reference-contexts: This reflects our current focus on behavioral aspects of processes. Following Wolf and Rosenblum <ref> [30] </ref>, we use an event-based model of process actions, where an event is used to characterize the dynamic behavior of a process in terms of identifiable, instantaneous actions such as invoking a development tool or deciding upon the next activity to be performed. <p> As mentioned in the introduction, we assume that event data are being collected on the executing process. Methods already exist and are being used to collect such data <ref> [7, 30] </ref>. Once collected, the data can be viewed as a window onto the execution. In general, this window will not show the whole execution, since there will be some activities for which no event data are collected at all.
References-found: 30

