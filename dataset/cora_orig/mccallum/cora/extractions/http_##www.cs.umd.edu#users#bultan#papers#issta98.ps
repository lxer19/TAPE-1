URL: http://www.cs.umd.edu/users/bultan/papers/issta98.ps
Refering-URL: http://www.cs.umd.edu/users/bultan/publications-abstracts.html
Root-URL: 
Email: fbultan,rich,leagueg@cs.umd.edu  
Title: Verifying Systems with Integer Constraints and Boolean Predicates: A Composite Approach  
Author: Tevfik Bultan Richard Gerber Christopher League 
Address: College Park, MD 20742, USA  
Affiliation: Department of Computer Science University of Maryland  
Abstract: Alternatively, we recently proposed a model checker for integer-based systems that uses Presburger constraints as the underlying state representation. While this approach easily verified some subtle, infinite-state concurrency problems, it proved inefficient in its treatment of Boolean and (unordered) enumerated types which possess no natural mapping to the Euclidean coordinate space. In this paper we describe a model checker which combines the strengths of both approaches. We use a composite model, in which a formula's valuations are encoded in a mixed BDD-Presburger form, depending on the variables used. We demonstrate our technique's effectiveness on a nontrivial requirements specification, which includes a mixture of Booleans, integers and enumerated types. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, C. Courcoubetis, N. Halbwachs, T. A. Hen-zinger, P. H. Ho, X. Nicollin, A. Olivero, J. Sifakis, S. Yovine. </author> <title> The algorithmic analysis of hybrid systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 138(1) </volume> <pages> 3-34, </pages> <year> 1995. </year>
Reference-contexts: Other state-encodings have been explored for model checking in various domains, and we note some of these efforts here. For example Alur et al. used arithmetic constraints on real variables to check properties of hybrid systems <ref> [1, 2] </ref>. Other recent results deal with analyzing particular systems, e.g., for systems with FIFO queues (Queue Decision Diagrams [8]), for simultaneous control/datapath verification in VLSI domains (Binary Moment Diagrams [10] and Hybrid Decision Diagrams [15]), etc.
Reference: [2] <author> R. Alur, T. A. Henzinger, and P. Ho. </author> <title> Automatic symbolic verification of embedded systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(3) </volume> <pages> 181-201, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Other state-encodings have been explored for model checking in various domains, and we note some of these efforts here. For example Alur et al. used arithmetic constraints on real variables to check properties of hybrid systems <ref> [1, 2] </ref>. Other recent results deal with analyzing particular systems, e.g., for systems with FIFO queues (Queue Decision Diagrams [8]), for simultaneous control/datapath verification in VLSI domains (Binary Moment Diagrams [10] and Hybrid Decision Diagrams [15]), etc.
Reference: [3] <author> R. J. Anderson, P. Beame, S. Burns, W. Chan, F. Mod-ugno, D. Notkin, and J. D. Reese. </author> <title> Model checking large software specifications. </title> <booktitle> In Proceedings of the Fourth ACM SIGSOFT symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 156-166, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: and predicates appearing in an SCR specification; hence, the model checker automatically deduces inferences such as: (temp &gt; High ! Alarm) ! (9 x &lt; 0 :: temp + x = High ! Alarm): With this capability, we need not map SCR integer predicates to Boolean literals (e.g., as in <ref> [3, 4, 5, 13] </ref>); moreover, for our model checker this type of inference comes at no additional cost. Finally, our framework allows us to test mixed integer-Boolean environmental hypotheses. <p> Since SMV is a symbolic, BDD-based model checker, it generates more efficient encodings of the SCR state space, which makes it possible to check larger systems. The same tool was also used to analyze parts of the RSML specification of the TCAS II system <ref> [3] </ref>. The main difficulty in using SMV for checking requirements specifications seems to be that every variable gets represented in the same symbolic format, namely BDDs.
Reference: [4] <author> J. M. Atlee, and M. A. Buckley. </author> <title> A logic-model semantics for SCR software requirements. </title> <booktitle> In Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA '96) pages 280-292. </booktitle>
Reference-contexts: and predicates appearing in an SCR specification; hence, the model checker automatically deduces inferences such as: (temp &gt; High ! Alarm) ! (9 x &lt; 0 :: temp + x = High ! Alarm): With this capability, we need not map SCR integer predicates to Boolean literals (e.g., as in <ref> [3, 4, 5, 13] </ref>); moreover, for our model checker this type of inference comes at no additional cost. Finally, our framework allows us to test mixed integer-Boolean environmental hypotheses. <p> There has been significant work in using model checking to verify tabular-style SCR requirements. In [5] Atlee and Gannon mapped queries about SCR mode-transition tables to the MCB model checker, which uses explicit state enumeration as its underlying representation. Later, Atlee and Buckley improved this process, by using SMV <ref> [4] </ref> for the same purpose. Since SMV is a symbolic, BDD-based model checker, it generates more efficient encodings of the SCR state space, which makes it possible to check larger systems. The same tool was also used to analyze parts of the RSML specification of the TCAS II system [3]. <p> In [13], Chan et al. report that representing integers using bitwise BDD representations is not efficient when the input system contains non-linear constraints. They present a technique in which (both linear and non-linear) constraints are mapped to BDD variables (similar representations were also used in <ref> [4, 5] </ref>). These constraints are used for specifying guarding conditions of transitions. A constraint solver is used during model checking computations (in conjunction with SMV) to prune infeasible combinations of these constraints.
Reference: [5] <author> J. M. Atlee, and J. Gannon. </author> <title> State-Based Model Checking of Event-Driven System Requirements. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(1) </volume> <pages> 24-40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: and predicates appearing in an SCR specification; hence, the model checker automatically deduces inferences such as: (temp &gt; High ! Alarm) ! (9 x &lt; 0 :: temp + x = High ! Alarm): With this capability, we need not map SCR integer predicates to Boolean literals (e.g., as in <ref> [3, 4, 5, 13] </ref>); moreover, for our model checker this type of inference comes at no additional cost. Finally, our framework allows us to test mixed integer-Boolean environmental hypotheses. <p> These tests involve queries on possible feedback relationships between values conveyed to actuators (i.e., "controlled variables") and subsequent samples on sensors (i.e., "monitored variables"). There has been significant work in using model checking to verify tabular-style SCR requirements. In <ref> [5] </ref> Atlee and Gannon mapped queries about SCR mode-transition tables to the MCB model checker, which uses explicit state enumeration as its underlying representation. Later, Atlee and Buckley improved this process, by using SMV [4] for the same purpose. <p> In [13], Chan et al. report that representing integers using bitwise BDD representations is not efficient when the input system contains non-linear constraints. They present a technique in which (both linear and non-linear) constraints are mapped to BDD variables (similar representations were also used in <ref> [4, 5] </ref>). These constraints are used for specifying guarding conditions of transitions. A constraint solver is used during model checking computations (in conjunction with SMV) to prune infeasible combinations of these constraints.
Reference: [6] <author> A. Arnold. </author> <title> Finite transition systems: semantics of communicating Systems. </title> <address> New Jersey, 1994, </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: Unlike Clarke et al. [14], we do not require the transition relation X to be total. Rather, the semantics is defined using maximal paths <ref> [6] </ref> (as opposed to infinite paths). A maximal path is one which is either infinite, or it ends with a state that has no successors.
Reference: [7] <author> R. Bharadwaj, and C. Heitmeyer. </author> <title> Verifying SCR requirements specifications using state exploration. </title> <booktitle> In Proceedings of First ACM SIGPLAN Workshop on Automatic Analysis of Software, </booktitle> <month> Jan </month> <year> 1997. </year>
Reference-contexts: Our approach to mixed constraints and their orthogonal implementations will hopefully allow us to expand to additional datatypes in the future. In the sequel, we demonstrate our results using an "enhanced" version of a known SCR specification, which states the requirements for a reactor's water pressure system <ref> [7, 16, 18] </ref>. The underlying model contains a good mixture of Booleans, unbounded integers and enumerated types, each of which retain their exact semantic interpretation in our composite model checker. <p> Hence, even a transition which increments a variable (i.e., x 0 = x + 1) is ruled out. It is reported in [13] that this restriction is partly motivated by the semantics of RSML, and it allows modeling of a significant portion of TCAS II system. In <ref> [7] </ref> Bharadwaj and Heitmeyer used the SPIN model checker to analyze behaviors of SCR specifications as a whole, including all conditions and events, as well as mode transition tables. But since SPIN relies on a finite-state model (like SMV), it can not check systems with unbounded variables. <p> We conclude with some remarks on the results, and outline our future research directions. 2 An Example: Safety Injection System As an example, we analyze the requirements for a reactor's cooling system; this example was adapted from previous specifications in <ref> [7, 16, 18] </ref> and in fact, we take a super-set of these requirements, as well as add a few of our own. The target application is called an "Engineered Safety Feature Actuation System," for a PWR Nuclear Power Plant. <p> However, the operator may use a manual control (called the "block" switch) to override safety injection during normal start-up or cool-down phases. Moreover (as in <ref> [7] </ref>), the operator also has a "reset switch," which results in the controller program clearing any state triggered by outstanding "block" signals. In [16] and [7] this specification is rendered using the SCR tabular notation although the system given in [7] uses only one pressure sensor. <p> Moreover (as in <ref> [7] </ref>), the operator also has a "reset switch," which results in the controller program clearing any state triggered by outstanding "block" signals. In [16] and [7] this specification is rendered using the SCR tabular notation although the system given in [7] uses only one pressure sensor. Here, we adapt the original three-sensor system to the style of requirements in [7], assuming that an action is taken when two out of three sensors agree on a condition. <p> Moreover (as in <ref> [7] </ref>), the operator also has a "reset switch," which results in the controller program clearing any state triggered by outstanding "block" signals. In [16] and [7] this specification is rendered using the SCR tabular notation although the system given in [7] uses only one pressure sensor. Here, we adapt the original three-sensor system to the style of requirements in [7], assuming that an action is taken when two out of three sensors agree on a condition. <p> In [16] and <ref> [7] </ref> this specification is rendered using the SCR tabular notation although the system given in [7] uses only one pressure sensor. Here, we adapt the original three-sensor system to the style of requirements in [7], assuming that an action is taken when two out of three sensors agree on a condition. Additionally, we have complicated the system somewhat, by adding an actuator called "damp," which is similar to "safety inection" but conveys the opposite meaning. <p> However, we assume the pressure sensors are read in on a vector hence, we treat them as one input. We also place environmental constraints on the fluctuations of the pressure readings, as in <ref> [7] </ref>. Here, we ensure that readings can change within a certain range, bound. Note that in the specification given in Figure 1 values of the constants min, max, low, high, toohigh, and bound are unspecified. <p> However, we have also developed some conservative techniques which often work when exact results are unobtainable. For lack of space we do not present them here; instead the reader is referred to [11]. 6 Experimental Results Two properties of the safety injection system verified in <ref> [7] </ref> are: (P1) 82 ((Reset ^ :High) ! :Over) (P2) 82 ((Reset ^ T Low) ! Inject) We verified these properties on the system model presented in Figures 1 and 2. (P1) and (P2) required 2.71 seconds and 2.58 seconds, respectively, as run on a Sun Ultra. <p> Note that, our safety injection system is significantly more complicated than that in <ref> [7] </ref>; in fact, it models the three-way voting scheme as originally specified in [16]. This complicates the transition system considerably, since the actions are taken by a majority vote on three different readings which can range over the entire space of integers. <p> On the other hand, it would be impossible to validate our system model in a finite-state model checker, without either bounding the pressure-reading domains, or using some other abstraction. The SCR example we selected was an extended version of those reported in <ref> [7, 16] </ref> and [18], and we were able to check various properties of the specification. We verified several of system's intrinsic invariants (which had been previously checked on abstractions of the model); and we verified several new properties as well, having to do with additional features we added.
Reference: [8] <author> B. Boigelot, and P. Godefroid. </author> <title> Symbolic verification of communication protocols with infinite state spaces using QDDs. </title> <booktitle> In Proceedings of the 8th International Conference on Computer Aided Verification (CAV '96). </booktitle>
Reference-contexts: For example Alur et al. used arithmetic constraints on real variables to check properties of hybrid systems [1, 2]. Other recent results deal with analyzing particular systems, e.g., for systems with FIFO queues (Queue Decision Diagrams <ref> [8] </ref>), for simultaneous control/datapath verification in VLSI domains (Binary Moment Diagrams [10] and Hybrid Decision Diagrams [15]), etc. Again, our preliminary results suggest that we could potentially combine all these symbolic representations in one composite representation.
Reference: [9] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 35(8) </volume> <pages> 677-691. </pages>
Reference-contexts: 1 Introduction Symbolic model checking has proved highly successful for verifying large finite-state systems [12, 20]. This success is partially due to the advent of innovative data structures like Binary Decision Diagrams (or BDDs), which can encode huge sets of bit-vector states in a highly compact format <ref> [9] </ref>. A fortunate consequence of the BDD structure is that it immediately supports efficient Boolean-algebraic operators (e.g., conjunction, negation, etc.) which also happen to be the main operators used in symbolic model checking. This research is supported in part by ONR grant N00014-94-10228 and NSF Young Investigator Award CCR-9357850. <p> In carrying out these operations, the composite-model library interacts with two underlying libraries, whose key exported operations are defined in Figure 3. We refer inter ested readers to [19] for relevant background on the Pres--burger solver, and to <ref> [9, 20] </ref> for details on how general BDD formulas are manipulated (however the BDD library we use is our own).
Reference: [10] <author> R. E. Bryant , and Y. Chen. </author> <title> Verification of arithmetic functions with binary moment diagrams. </title> <booktitle> In Proceedings of the 32nd ACM/IEEE Design Automation Conference. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: For example Alur et al. used arithmetic constraints on real variables to check properties of hybrid systems [1, 2]. Other recent results deal with analyzing particular systems, e.g., for systems with FIFO queues (Queue Decision Diagrams [8]), for simultaneous control/datapath verification in VLSI domains (Binary Moment Diagrams <ref> [10] </ref> and Hybrid Decision Diagrams [15]), etc. Again, our preliminary results suggest that we could potentially combine all these symbolic representations in one composite representation.
Reference: [11] <author> T. Bultan, R. Gerber, and W. Pugh. </author> <title> Symbolic model checking of infinite state systems using Presburger arithmetic. </title> <booktitle> In Proceedings of the 9th International Conference on Computer Aided Verification (CAV '97), </booktitle> <volume> LNCS 1254, </volume> <pages> pages 400-411. </pages>
Reference-contexts: BDDs encode all underlying datatypes as Boolean variables; hence all BDD-based model checkers inherently require the underlying types to be bounded. Recently, we proposed a model checker for general integer based systems, which uses Presburger constraints as its underlying state representation <ref> [11] </ref>. As with BDDs for Boolean arrays, Presburger constraints can compactly represent huge (even unbounded) sets of integer states over multiple dimensions. Specifically, our model checker represents sets of state-valuations using unions of convex polytopes, each of which is formed by affine constraints over the system's variables. <p> However, we have also developed some conservative techniques which often work when exact results are unobtainable. For lack of space we do not present them here; instead the reader is referred to <ref> [11] </ref>. 6 Experimental Results Two properties of the safety injection system verified in [7] are: (P1) 82 ((Reset ^ :High) ! :Over) (P2) 82 ((Reset ^ T Low) ! Inject) We verified these properties on the system model presented in Figures 1 and 2. (P1) and (P2) required 2.71 seconds and
Reference: [12] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. H. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proc. of the 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Symbolic model checking has proved highly successful for verifying large finite-state systems <ref> [12, 20] </ref>. This success is partially due to the advent of innovative data structures like Binary Decision Diagrams (or BDDs), which can encode huge sets of bit-vector states in a highly compact format [9].
Reference: [13] <author> W. Chan, R. Anderson, P. Beame, and D. Notkin. </author> <title> Combining Constraint Solving and Symbolic Model Checking for a Class of Systems with Non-linear Constraints. </title> <booktitle> In Proceedings of the 9th International Conference on Computer Aided Verification (CAV '97), </booktitle> <volume> LNCS 1254, </volume> <pages> pages 316-327. </pages>
Reference-contexts: and predicates appearing in an SCR specification; hence, the model checker automatically deduces inferences such as: (temp &gt; High ! Alarm) ! (9 x &lt; 0 :: temp + x = High ! Alarm): With this capability, we need not map SCR integer predicates to Boolean literals (e.g., as in <ref> [3, 4, 5, 13] </ref>); moreover, for our model checker this type of inference comes at no additional cost. Finally, our framework allows us to test mixed integer-Boolean environmental hypotheses. <p> This can easily result in inefficient encodings of totally-ordered variables; moreover, the resulting number of BDD nodes (not to mention their inherent finiteness) often makes verification untenable, at least without human-guided abstractions. In <ref> [13] </ref>, Chan et al. report that representing integers using bitwise BDD representations is not efficient when the input system contains non-linear constraints. They present a technique in which (both linear and non-linear) constraints are mapped to BDD variables (similar representations were also used in [4, 5]). <p> Hence, even a transition which increments a variable (i.e., x 0 = x + 1) is ruled out. It is reported in <ref> [13] </ref> that this restriction is partly motivated by the semantics of RSML, and it allows modeling of a significant portion of TCAS II system.
Reference: [14] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: A path (s 0 ; s 1 ; s 2 ; : : :) is a (finite or infinite) sequence of states, such that for each successive pair of states (s i ; s i+1 ) 2 X. Unlike Clarke et al. <ref> [14] </ref>, we do not require the transition relation X to be total. Rather, the semantics is defined using maximal paths [6] (as opposed to infinite paths). A maximal path is one which is either infinite, or it ends with a state that has no successors.
Reference: [15] <author> E. Clarke, X. Zhao. </author> <title> Word level symbolic model checking: A new approach for verifying arithmetic circuits. </title> <type> Technical Report CMU-CS-95-161, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: Other recent results deal with analyzing particular systems, e.g., for systems with FIFO queues (Queue Decision Diagrams [8]), for simultaneous control/datapath verification in VLSI domains (Binary Moment Diagrams [10] and Hybrid Decision Diagrams <ref> [15] </ref>), etc. Again, our preliminary results suggest that we could potentially combine all these symbolic representations in one composite representation.
Reference: [16] <author> P. J. Courtois and D. L. Parnas. </author> <title> Documentation for safety critical software. </title> <booktitle> In Proceedings of the 15th International Conference on Software Engineering, </booktitle> <pages> pages 315-323, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Our approach to mixed constraints and their orthogonal implementations will hopefully allow us to expand to additional datatypes in the future. In the sequel, we demonstrate our results using an "enhanced" version of a known SCR specification, which states the requirements for a reactor's water pressure system <ref> [7, 16, 18] </ref>. The underlying model contains a good mixture of Booleans, unbounded integers and enumerated types, each of which retain their exact semantic interpretation in our composite model checker. <p> We conclude with some remarks on the results, and outline our future research directions. 2 An Example: Safety Injection System As an example, we analyze the requirements for a reactor's cooling system; this example was adapted from previous specifications in <ref> [7, 16, 18] </ref> and in fact, we take a super-set of these requirements, as well as add a few of our own. The target application is called an "Engineered Safety Feature Actuation System," for a PWR Nuclear Power Plant. <p> However, the operator may use a manual control (called the "block" switch) to override safety injection during normal start-up or cool-down phases. Moreover (as in [7]), the operator also has a "reset switch," which results in the controller program clearing any state triggered by outstanding "block" signals. In <ref> [16] </ref> and [7] this specification is rendered using the SCR tabular notation although the system given in [7] uses only one pressure sensor. <p> Note that, our safety injection system is significantly more complicated than that in [7]; in fact, it models the three-way voting scheme as originally specified in <ref> [16] </ref>. This complicates the transition system considerably, since the actions are taken by a majority vote on three different readings which can range over the entire space of integers. <p> On the other hand, it would be impossible to validate our system model in a finite-state model checker, without either bounding the pressure-reading domains, or using some other abstraction. The SCR example we selected was an extended version of those reported in <ref> [7, 16] </ref> and [18], and we were able to check various properties of the specification. We verified several of system's intrinsic invariants (which had been previously checked on abstractions of the model); and we verified several new properties as well, having to do with additional features we added.
Reference: [17] <author> P. Godefroid, and D. </author> <title> Long. Symbolic protocol verification with queue BDDs. </title> <booktitle> In Proceedings of the 11th Symposium on Logic in Computer Science, </booktitle> <pages> 198-206, </pages> <month> July </month> <year> 1996. </year>
Reference: [18] <author> C. L. Heitmeyer, R. D. Jeffords, and B. G. Labaw. </author> <title> Automated Consistency Checking of Requirements Specifications. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(3) </volume> <pages> 231-261, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: Our approach to mixed constraints and their orthogonal implementations will hopefully allow us to expand to additional datatypes in the future. In the sequel, we demonstrate our results using an "enhanced" version of a known SCR specification, which states the requirements for a reactor's water pressure system <ref> [7, 16, 18] </ref>. The underlying model contains a good mixture of Booleans, unbounded integers and enumerated types, each of which retain their exact semantic interpretation in our composite model checker. <p> We conclude with some remarks on the results, and outline our future research directions. 2 An Example: Safety Injection System As an example, we analyze the requirements for a reactor's cooling system; this example was adapted from previous specifications in <ref> [7, 16, 18] </ref> and in fact, we take a super-set of these requirements, as well as add a few of our own. The target application is called an "Engineered Safety Feature Actuation System," for a PWR Nuclear Power Plant. <p> As for Inject, the condition table states that it can only be actuated when the system is in mode TooLow and it is not overriden. The conditions for Damp are analogous. The semantics of SCR is defined in <ref> [18] </ref>. An important re striction of the model is the One Input Assumption, which states that only one monitored variable can change at a time. <p> Note that if a variable v is not mentioned in the action of an event, then that event does not change its value, i.e., v 0 = v. Using the formal semantics of SCR requirements specifications given in <ref> [18] </ref>, any specification in SCR notation can be automatically converted to our event-action language and any theorems we prove valid in our model will be true for the original SCR requirements. We use Boolean variables to encode unordered enumerated SCR variables. <p> On the other hand, it would be impossible to validate our system model in a finite-state model checker, without either bounding the pressure-reading domains, or using some other abstraction. The SCR example we selected was an extended version of those reported in [7, 16] and <ref> [18] </ref>, and we were able to check various properties of the specification. We verified several of system's intrinsic invariants (which had been previously checked on abstractions of the model); and we verified several new properties as well, having to do with additional features we added.
Reference: [19] <author> W. Kelly, V. Maslov, W. Pugh, E. Rosser, T. Shpeisman and D. Wonnacott. </author> <title> The Omega Library (version 1.00) interface guide. </title> <note> Available at &lt;http://www.cs.umd.edu/projects/omega&gt;. </note>
Reference-contexts: Specifically, our model checker represents sets of state-valuations using unions of convex polytopes, each of which is formed by affine constraints over the system's variables. And like BDDs, this representation also affords efficient techniques for carrying out pertinent set-theoretic operations (we use a Presburger solver called the Omega library <ref> [19, 21] </ref> for this purpose). While many model checking queries are undecidable for general infinite-state theories, we often appeal to conservative approximation techniques, many of which guarantee convergence by allowing false negatives. With this approach we were able to easily verify some nontrivial infinite-state programs from the concurrency literature. <p> We have found that the Omega library <ref> [19, 21] </ref> can easily handle these types of constraints, when purely integer-valued expressions are involved. 3.2 Temporal Properties We use four CTL-style modal operators as the basis for our temporal logic the "quantified-next-state" operators (9fl and 8fl), and "quantified-eventuality" operators (93 and 83). <p> In carrying out these operations, the composite-model library interacts with two underlying libraries, whose key exported operations are defined in Figure 3. We refer inter ested readers to <ref> [19] </ref> for relevant background on the Pres--burger solver, and to [9, 20] for details on how general BDD formulas are manipulated (however the BDD library we use is our own).
Reference: [20] <author> K. L. McMillan. </author> <title> Symbolic model checking. </title> <booktitle> Mas-sachusetts, 1993, </booktitle> <publisher> Kluwer Academic Publishers. </publisher>
Reference-contexts: 1 Introduction Symbolic model checking has proved highly successful for verifying large finite-state systems <ref> [12, 20] </ref>. This success is partially due to the advent of innovative data structures like Binary Decision Diagrams (or BDDs), which can encode huge sets of bit-vector states in a highly compact format [9]. <p> In carrying out these operations, the composite-model library interacts with two underlying libraries, whose key exported operations are defined in Figure 3. We refer inter ested readers to [19] for relevant background on the Pres--burger solver, and to <ref> [9, 20] </ref> for details on how general BDD formulas are manipulated (however the BDD library we use is our own).
Reference: [21] <author> W. Pugh. </author> <title> The Omega test: a fast and practical integer programming algorithm for dependence analysis. </title> <journal> Communications of the ACM, </journal> <volume> 8 </volume> <pages> 102-104, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Specifically, our model checker represents sets of state-valuations using unions of convex polytopes, each of which is formed by affine constraints over the system's variables. And like BDDs, this representation also affords efficient techniques for carrying out pertinent set-theoretic operations (we use a Presburger solver called the Omega library <ref> [19, 21] </ref> for this purpose). While many model checking queries are undecidable for general infinite-state theories, we often appeal to conservative approximation techniques, many of which guarantee convergence by allowing false negatives. With this approach we were able to easily verify some nontrivial infinite-state programs from the concurrency literature. <p> We have found that the Omega library <ref> [19, 21] </ref> can easily handle these types of constraints, when purely integer-valued expressions are involved. 3.2 Temporal Properties We use four CTL-style modal operators as the basis for our temporal logic the "quantified-next-state" operators (9fl and 8fl), and "quantified-eventuality" operators (93 and 83).
Reference: [22] <author> A. Udaya Shankar. </author> <title> An introduction to assertional reasoning for concurrent systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(3) </volume> <pages> 225-262, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: A concurrent system C = (V; I; E) is represented by (1) a finite set of data and control variables V ; (2) an initial condition I, which specifies the starting states of the program; and (3) a finite set of events E, where each event is considered atomic <ref> [22] </ref>. A system state is determined by the values of its data and control variables, where we assume that the domain of each variable is a countable set. Each event defines a transformation on the variables of the program.
References-found: 22

