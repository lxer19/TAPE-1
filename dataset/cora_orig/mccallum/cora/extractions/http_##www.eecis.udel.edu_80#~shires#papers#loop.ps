URL: http://www.eecis.udel.edu:80/~shires/papers/loop.ps
Refering-URL: http://www.eecis.udel.edu:80/~shires/professional.html
Root-URL: http://www.cis.udel.edu
Email: dshires@arl.mil  
Title: Effects of loop unrolling and loop fusion on register pressure and code performance.  
Author: Dale Shires 
Address: MD 21005,  
Note: Army Research Laboratory, Aberdeen Proving Ground,  
Date: July 10, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. L. Lo and S. J. Eggers. </author> <title> Improving balanced scheduling with compiler optimizations that increase instruction-level parallelism. </title> <booktitle> In ACM SIGPLAN 1995, </booktitle> <pages> pages 151-162, </pages> <year> 1995. </year>
Reference-contexts: One way they increase performance is by taking advantage of parallelism found in algorithms. To this end, many of these systems offer multiprocessor parallelism. Furthermore, many also offer software pipelining to take full advantage of low-level, or code-level, parallelism <ref> [1] </ref>. This is parallelism actually present in the way machine instructions are dispatched. Also of paramount importance is that these machines take full advantage of their complicated memory systems.
Reference: [2] <author> C. Norris and L. Pollock. </author> <title> An experimental study of several cooperative register allocation and instruction scheduling strategies. </title> <booktitle> In MICRO 28. The 28th International Symposium on Micro Architecture, </booktitle> <month> November </month> <year> 1995. </year>
Reference-contexts: The register allocator tries to assign a register to each register candidate. Since register access is very fast, the compiler should generate code that reuses these assigned registers as much as possible. To do this, the register allocator and scheduler should work closely together <ref> [2] </ref>. This is actually a very complicated phase-ordering problem. At the least, the scheduler should order code in a way that instruction-level parallelism can be exploited, and the register allocator should give top priority to assigning a register to frequently used variables.
Reference: [3] <author> G. Chaitin, M. Auslander, and A. Chandra. </author> <title> Register allocation via coloring. </title> <booktitle> In Computer Languages, </booktitle> <volume> volume 6, </volume> <pages> pages 47-57. </pages> <year> 1981. </year> <note> 8 INTENTIONALLY LEFT BLANK 9 </note>
Reference-contexts: When the compiler starts to run out of available registers to use, register pressure is said to be high. At the point where registers are no longer available, the register allocator must actually "spill" a register's content to memory to free it for other uses <ref> [3] </ref>. On tiered memory machines, such an action can be detrimental to varying degrees. If the value is written to cache, the access time is very small, but the cache manager may still have to invalidate the cache line.
References-found: 3

