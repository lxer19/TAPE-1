URL: http://www.cs.arizona.edu/people/debray/papers/pgcsens.ps
Refering-URL: http://www.cs.arizona.edu/alto/
Root-URL: http://www.cs.arizona.edu
Email: debray@cs.arizona.edu  
Title: Profile-Guided Context-Sensitive Program Analysis  
Author: Saumya Debray 
Address: Tucson, AZ 85721, U.S.A.  
Affiliation: Department of Computer Science University of Arizona  
Abstract: Interprocedural analyses can be classified as either context-insensitive, which tend to sacrifice precision to gain efficiency, or context-sensitive, which are more precise but also more expensive. This paper discusses a profile-guided approach to interprocedural analysis that is context-sensitive, and hence more precise, for the "important" call sites for a function, and context-insensitive, and hence more efficient, for the "unimportant" call sites. Experiments indicate that this approach can be significantly more efficient than a traditional context-sensitive analysis without sacrificing much of the pragmatic value of the dataflow information gathered.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi and J. D. Ullman, </author> <booktitle> Compilers Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction For code analysis and optimization purposes, compilers typically construct a control flow graph for each function in a program <ref> [1] </ref>. Control flow across function boundaries is often represented using an interprocedural control flow graph (e.g., see [15]), which consists of the control flow graphs of all the functions in the program, together with edges representing calls and returns that link the flow graphs of different functions.
Reference: [2] <author> G. Ammons and J. R. Larus, </author> <title> "Improving Data-flow Analysis with Path Profiles", </title> <booktitle> Proc. SIG-PLAN '98 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1998, </year> <pages> pp. 72-84. </pages>
Reference-contexts: The only work that we are aware of on this topic, and the work that is most closely related to ours, is that of Ammons and Larus <ref> [2] </ref>, who consider how dataflow analyses may be modified to invest extra effort in analyzing frequently executed paths within a procedure in order to obtain better information along 9 Program Standard Callsite Freq.
Reference: [3] <author> R. Bodk, R. Gupta, and M. L. Soffa, </author> <title> "Complete Removal of Redundant Expressions", </title> <booktitle> Proc. SIGPLAN '98 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1998, </year> <pages> pp. 1-14. </pages>
Reference-contexts: We expect to have more complete empirical results shortly. 5 Related Work While there is a considerable body of work on context-sensitive interprocedural analyses (e.g., see [10, 13, 18]) and profile-guided program optimization (e.g., see <ref> [3, 5, 6, 11, 16] </ref>), there does not seem to be a great deal of work on the use of execution profiles to guide program analyses.
Reference: [4] <author> C. Chambers, J. Dean, and D. Grove, </author> <title> "Frameworks for Intra- and Interprocedural Dataflow Analysis", </title> <type> Technical Report 96-11-02, </type> <institution> Dept. of Computer Science and Engineering, University of Washington, </institution> <address> Seattle, </address> <year> 1996. </year>
Reference-contexts: Chambers et al. have observed that the degree of context-sensitivity of an inter-procedural analysis can be controlled by selective merging of calling contexts <ref> [4, 12] </ref>. However, they don't consider using profile information to control the processing of different call sites to a function.
Reference: [5] <author> P. P. Chang, S. A. Mahlke, W. Y. Chen, and W. W. Hwu, </author> <title> "Profile-guided automatic inline expansion for C programs", </title> <journal> Software Practice and Experience vol. </journal> <volume> 22 no. 5, </volume> <month> May </month> <year> 1992, </year> <pages> pp. 349-369. </pages>
Reference-contexts: We expect to have more complete empirical results shortly. 5 Related Work While there is a considerable body of work on context-sensitive interprocedural analyses (e.g., see [10, 13, 18]) and profile-guided program optimization (e.g., see <ref> [3, 5, 6, 11, 16] </ref>), there does not seem to be a great deal of work on the use of execution profiles to guide program analyses.
Reference: [6] <author> R. Cohn and P. G. Lowney, </author> <title> "Hot Cold Optimization of Large Windows/NT Applications", </title> <booktitle> Proc. MICRO 29, </booktitle> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: We expect to have more complete empirical results shortly. 5 Related Work While there is a considerable body of work on context-sensitive interprocedural analyses (e.g., see [10, 13, 18]) and profile-guided program optimization (e.g., see <ref> [3, 5, 6, 11, 16] </ref>), there does not seem to be a great deal of work on the use of execution profiles to guide program analyses.
Reference: [7] <author> K. D. Cooper, M. W. Hall, and K. Kennedy, </author> <title> "Procedure Cloning", </title> <booktitle> Proc. 1992 International Conference on Computer Languages, </booktitle> <pages> pp. 96-105. </pages>
Reference-contexts: Our approach to cloning is conceptually similar to that of Cooper et al. <ref> [7, 8] </ref>, except that we use profile-guided considerations for low level code improvements to guide our cloning decisions, rather than focusing on inter-procedural constant propagation. To limit the amount of code growth, cloning is considered only for important call sites.
Reference: [8] <author> K. D. Cooper, M. W. Hall, and K. Kennedy, </author> <title> "A Methodology for Procedure Cloning", </title> <booktitle> Computer Languages 19(2), </booktitle> <month> April </month> <year> 1993, </year> <pages> pp. 105-118. 11 </pages>
Reference-contexts: Our approach to cloning is conceptually similar to that of Cooper et al. <ref> [7, 8] </ref>, except that we use profile-guided considerations for low level code improvements to guide our cloning decisions, rather than focusing on inter-procedural constant propagation. To limit the amount of code growth, cloning is considered only for important call sites.
Reference: [9] <author> S. K. Debray, R. Muth, and M. Weippert, </author> <title> "Alias Analysis of Executable Code", </title> <booktitle> Proc. 1998 ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 12-24. </pages>
Reference-contexts: The intermediate points of this spectrum, which have cost-benefit tradeoffs in between the two extremes, can be interesting and useful from a pragmatic perspective. We illustrate our ideas using an alias analysis for executable code <ref> [9] </ref>, where the alias information is used for instruction scheduling; however, the underlying ideas are quite general and applicable to other context-sensitive interprocedural analyses as well. 2 Profile-Guided Context-Sensitive Analysis The intuition behind our idea is very simple. <p> An evaluation of specific criteria we tested is given after a quick overview of our analysis problem. The ideas described in this paper were motivated by an alias analysis algorithm we have developed for executable code <ref> [9] </ref>. <p> Overall, this leads to a reasonably time and space efficient analysis algorithm. The original formulation of our analysis was context-insensitive <ref> [9] </ref>. This turns out to lead to an undesirable loss in precision in a number of situations. An example of this can be seen in the function alignd () in the SPEC-95 benchmark m88ksim. <p> This significantly constrains the quality of instruction scheduling possible in this block. It turns out, unfortunately, that the context-insensitive version of our alias analysis <ref> [9] </ref> doesn't help us in this situation. The problem is that, since registers r17 and r18 are loaded with pointers into the caller's stack frame at each call site to alignd (), the defining instruction for each of these registers is different at each call site.
Reference: [10] <author> M. Emami, R. Ghiya and L. J. Hendren, </author> <title> "Context-Sensitive Interprocedural Points-to Analysis in the Presence of Function Pointers", </title> <booktitle> Proc. SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1994, </year> <pages> pp. 242-256. </pages>
Reference-contexts: We expect to have more complete empirical results shortly. 5 Related Work While there is a considerable body of work on context-sensitive interprocedural analyses (e.g., see <ref> [10, 13, 18] </ref>) and profile-guided program optimization (e.g., see [3, 5, 6, 11, 16]), there does not seem to be a great deal of work on the use of execution profiles to guide program analyses.
Reference: [11] <author> J. A. Fisher, </author> <title> "Trace Scheduling: A Technique for Global Microcode Compaction", </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-30(7):478-490, </volume> <month> July </month> <year> 1981. </year>
Reference-contexts: We expect to have more complete empirical results shortly. 5 Related Work While there is a considerable body of work on context-sensitive interprocedural analyses (e.g., see [10, 13, 18]) and profile-guided program optimization (e.g., see <ref> [3, 5, 6, 11, 16] </ref>), there does not seem to be a great deal of work on the use of execution profiles to guide program analyses.
Reference: [12] <author> D. Grove, G. DeFouw, J. Dean, and C. Chambers, </author> <title> "Call Graph Construction in Object-Oriented Languages", </title> <booktitle> Proc. 12th. Annual Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), </booktitle> <month> Oct. </month> <year> 1997, </year> <pages> pp. 108-124. </pages>
Reference-contexts: fl This work was supported in part by the National Science Foundation under grant CCR-9711166. 1 The discussion here is couched in terms of a forward analysis; the situation is analogous for backward analyses. 1 MB of memory to over 24 hours (!) of time and/or 450 MB of memory <ref> [12] </ref>. Comparing pointer alias analyses for C programs, Ruf reports that the context-sensitive version is 2-3 orders of magnitude slower than the context-insensitive version [17]. <p> Chambers et al. have observed that the degree of context-sensitivity of an inter-procedural analysis can be controlled by selective merging of calling contexts <ref> [4, 12] </ref>. However, they don't consider using profile information to control the processing of different call sites to a function.
Reference: [13] <author> W. Landi and B. G. Ryder, </author> <title> "A Safe Approximate Algorithm for Interprocedural Pointer Aliasing", </title> <booktitle> Proc. SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992, </year> <pages> pp. 235-248. </pages>
Reference-contexts: We expect to have more complete empirical results shortly. 5 Related Work While there is a considerable body of work on context-sensitive interprocedural analyses (e.g., see <ref> [10, 13, 18] </ref>) and profile-guided program optimization (e.g., see [3, 5, 6, 11, 16]), there does not seem to be a great deal of work on the use of execution profiles to guide program analyses.
Reference: [14] <author> R. Muth, S. K. Debray, S. Watterson, and K. De Bosschere, </author> <title> "alto : A Link-Time Optimizer for the DEC Alpha", </title> <type> Draft, </type> <month> Sept. </month> <year> 1998. </year> <note> Available at www.cs.arizona.edu/people/debray/papers/alto.ps. </note>
Reference-contexts: Our experiments were carried out in the context of alto, a link-time optimizer we have constructed for the DEC Alpha architecture <ref> [14] </ref>. Programs were compiled with the DEC C compiler V5.2-036 invoked as cc -O4, with linker options to retain relocation information and to produce statically linked executables. Low-level profile information was generated with pixie, using the SPEC training inputs.
Reference: [15] <author> E. W. Myers, </author> <title> "A Precise Inter-Procedural Data Flow Algorithm", </title> <booktitle> Proc. 8th ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1981, </year> <pages> pp. 219-230. </pages>
Reference-contexts: 1 Introduction For code analysis and optimization purposes, compilers typically construct a control flow graph for each function in a program [1]. Control flow across function boundaries is often represented using an interprocedural control flow graph (e.g., see <ref> [15] </ref>), which consists of the control flow graphs of all the functions in the program, together with edges representing calls and returns that link the flow graphs of different functions.
Reference: [16] <author> K. Pettis and R. C. Hansen, </author> <title> "Profile-Guided Code Positioning", </title> <booktitle> Proc. SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1990, </year> <pages> pp. 16-27. </pages>
Reference-contexts: We expect to have more complete empirical results shortly. 5 Related Work While there is a considerable body of work on context-sensitive interprocedural analyses (e.g., see [10, 13, 18]) and profile-guided program optimization (e.g., see <ref> [3, 5, 6, 11, 16] </ref>), there does not seem to be a great deal of work on the use of execution profiles to guide program analyses.
Reference: [17] <author> E. Ruf, </author> <title> "Context-Insensitive Alias Analysis Reconsidered", </title> <booktitle> Proc. SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 13-22. </pages>
Reference-contexts: Comparing pointer alias analyses for C programs, Ruf reports that the context-sensitive version is 2-3 orders of magnitude slower than the context-insensitive version <ref> [17] </ref>. These experiences suggest that it would be worthwhile to try and reduce the cost of context-sensitive analyses if this could be done without significantly affecting the pragmatic utility of the information produced by them.
Reference: [18] <author> R. P. Wilson and M. S. Lam, </author> <title> "Efficient Context-Sensitive Pointer Analysis for C Programs", </title> <booktitle> Proc. SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 1-12. </pages>
Reference-contexts: We expect to have more complete empirical results shortly. 5 Related Work While there is a considerable body of work on context-sensitive interprocedural analyses (e.g., see <ref> [10, 13, 18] </ref>) and profile-guided program optimization (e.g., see [3, 5, 6, 11, 16]), there does not seem to be a great deal of work on the use of execution profiles to guide program analyses.
Reference: [19] <author> S. Zhang, B. G. Ryder, and W. Landi, </author> <title> "Program Decomposition for Pointer Aliasing: A Step toward Practical Analyses", </title> <booktitle> Proc. Fourth Symposium on the Foundations of Software Engineering, </booktitle> <month> Oct. </month> <year> 1996. </year> <month> 12 </month>
Reference-contexts: program while expending a comparable analysis effort and remaining within a particular time or space "budget." Zhang et al. describe how, for pointer alias analysis of C programs, a program can be partitioned such that objects in different partitions can be analyzed independently of each other, possibly using different algorithms <ref> [19] </ref>. They show that a judicious mix of flow-sensitive and flow-insensitive pointer alias analyses can reduce analysis costs without significantly sacrificing the quality of the information obtained. While their goals are conceptually very similar to ours, the technical details are very different.
References-found: 19

