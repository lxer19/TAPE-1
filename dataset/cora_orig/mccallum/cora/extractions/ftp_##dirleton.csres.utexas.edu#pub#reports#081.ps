URL: ftp://dirleton.csres.utexas.edu/pub/reports/081.ps
Refering-URL: http://www.cli.com/reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Quantification in Nqthm: a Recognizer and Some Constructive Implementations  
Phone: (512) 322-9951  
Author: Matt Kaufmann 
Note: This research was supported in part by ONR Contract N00014-91-C-0130. The views and conclusions contained in this document are those of the author(s) and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Office of Naval Research or the U.S. Government.  
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic Inc.  
Abstract: Technical Report 81 August, 1992 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. S. Boyer and J S. Moore, </author> <title> A Computational Logic, </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: 1. Introduction It is often the case that users of Nqthm <ref> [1, 2] </ref> want to be able to express first-order quantified notions in Nqthm, or in Pc-Nqthm [3, 4]. 1 Quantifiers can be useful in creating elegant specifications: from a specification standpoint it is sometimes more appropriate to assert that a certain value exists, than to specify that a particular ``witnessing'' function
Reference: 2. <author> R. S. Boyer and J S. Moore, </author> <title> A Computational Logic Handbook, </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: 1. Introduction It is often the case that users of Nqthm <ref> [1, 2] </ref> want to be able to express first-order quantified notions in Nqthm, or in Pc-Nqthm [3, 4]. 1 Quantifiers can be useful in creating elegant specifications: from a specification standpoint it is sometimes more appropriate to assert that a certain value exists, than to specify that a particular ``witnessing'' function <p> Thus, BDD-FORALL is likely to be easily portable to the Acl2 system [9] that is currently under development, unlike the implementation of bounded quantification in [8], which is based on the EVAL$ construct of Nqthm <ref> [2] </ref> that is not likely to be ported to Acl2. 3.1 DEFN-SK-CONSTRUCTIVE Suppose that one wants the elegance and rewrite rules provided by DEFN-SK but wishes to stay within the ``constructive'' world. For example, consider again the notion that every member of a given list is a natural number.
Reference: 3. <author> Matt Kaufmann, </author> <title> ``A User's Manual for an Interactive Enhancement to the Boyer-Moore Theorem Prover'', </title> <type> Technical Report 19, </type> <institution> Computational Logic, Inc., </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: 1. Introduction It is often the case that users of Nqthm [1, 2] want to be able to express first-order quantified notions in Nqthm, or in Pc-Nqthm <ref> [3, 4] </ref>. 1 Quantifiers can be useful in creating elegant specifications: from a specification standpoint it is sometimes more appropriate to assert that a certain value exists, than to specify that a particular ``witnessing'' function (Skolem function) serves to provide that value.
Reference: 4. <author> M. Kaufmann, </author> <title> ``Addition of Free Variables to an Interactive Enchancement of the Boyer-Moore Theorem Prover'', </title> <type> Tech. report 42, </type> <institution> Computational Logic, Inc., </institution> <address> 1717 West Sixth Street, Suite 290 Austin, TX 78703, </address> <year> 1990. </year>
Reference-contexts: 1. Introduction It is often the case that users of Nqthm [1, 2] want to be able to express first-order quantified notions in Nqthm, or in Pc-Nqthm <ref> [3, 4] </ref>. 1 Quantifiers can be useful in creating elegant specifications: from a specification standpoint it is sometimes more appropriate to assert that a certain value exists, than to specify that a particular ``witnessing'' function (Skolem function) serves to provide that value.
Reference: 5. <author> Matt Kaufmann, </author> <title> ``An Extension of the Boyer-Moore Theorem Prover to Support First-Order Quantification'', </title> <journal> Journal of Automated Reasoning, </journal> <note> (to appear), See also CLI Technical Report 43, May, 1989 for an expanded version </note>
Reference-contexts: In some cases, the quantifiers are in fact necessary both for the specification and the proof; see for example the discussion of Ramsey's theorem in <ref> [5] </ref>. In fact, Pc-Nqthm provides the DEFN-SK feature [5] as a direct implementation of first-order quantification, but not all Nqthm users want to use DEFN-SK for representing quantified notions. <p> In some cases, the quantifiers are in fact necessary both for the specification and the proof; see for example the discussion of Ramsey's theorem in <ref> [5] </ref>. In fact, Pc-Nqthm provides the DEFN-SK feature [5] as a direct implementation of first-order quantification, but not all Nqthm users want to use DEFN-SK for representing quantified notions. For example, both Nqthm and Pc-Nqthm users often prefer to use recursive functions to model bounded quantification, for at least two reasons. <p> Proof. We have to show that G |- [f (x 1 ,...,x n ) f]. Now a basic property of Skolemization (see for example Lemma 2 (2) of [7], or Proposition 1 in the second appendix of the technical report version of <ref> [5] </ref>) is that each Skolemization (actually its universal closure) implies the formula from which it comes. It is routine to check that in fact, this argument does not depend on the choice of Skolem function symbols. <p> Therefore, it is also logically valid that (y' fi equiv)"fs, i.e. that ((y"fs)' fi equiv). -| 3. Generating quantified notions Recall that DEFN-SK <ref> [5] </ref> allows the user to introduce quantified notions into the Boyer-Moore paradigm. In the preceding section we introduced a recognizer for when one has correctly represented quantified notions, and in fact we believe that DEFN-SK always produces functions that represent desired quantified notions.
Reference: 6. <author> R.S. Boyer, D. Goldschlag, M. Kaufmann, J S. Moore, </author> <title> ``Functional Instantiation in First Order Logic'', </title> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <publisher> Academic Press, </publisher> <year> 1991, </year> <pages> pp. 7-26, </pages> <note> Versions also published as CLI Technical Report 44 and in proceedings of the 1989 Workshop on Programming Logic, </note> <institution> Programming Methodology Group, University of Goteborg, West Germany. </institution>
Reference-contexts: First we present DEFN-SK-CONSTRUCTIVE, a macro similar to DEFN-SK except that it requires witnessing functions and then generates an appropriate CONSTRAIN event <ref> [6] </ref>. Then we present an implementation BDD-FORALL of bounded universal quantification. The first appendix is a transcript of a session using BDD-FORALL. The second appendix contains the Lisp code. 2. Recognizing quantified notions. <p> If this form returns T then the following condition must be met (but not necessarily conversely); otherwise this form returns NIL. (See <ref> [6] </ref> for a discussion of functional instances and functional substitutions.) CHECK-QUANT CRITERION: A Skolemization of the equivalence (iff (function . arguments) formula) is a functional instance of the Nqthm term 3 associated with previous-event-name. 3 technically, the FORMULA-OF 5 Finally, as a convenience we allow previous-event-name to be a functional substitution <p> Then the domain of fs must consist of the Skolem functions generated by DEFN-SK in producing y, and its range should contain only symbols 4 . In addition, application of f to y, i.e. y " fs must be a theorem of the given history. (See <ref> [6] </ref> for more about functional substitutions.) For the rest of this section we will consider only the case above where previous-event-name is a previous event name, rather than a functional substitution. <p> In this section we present two tools for this purpose. The first, DEFN-SK-CONSTRUCTIVE, is quite general: it behaves just like DEFN-SK, except that it requires the user to provide existing ``witnessing functions'' (in the spirit of CONSTRAIN, cf. <ref> [6] </ref>) for each of the newly-introduced functions. The second, BDD-FORALL, is an implementation of bounded universal quantification by way of primitive recursive functions. <p> This latter construct is somewhat similar in intent to the more sophisticated and far-reaching ideas for bounded quantification in [8], but is simpler and is based on the DEFN-SK-CONSTRUCTIVE mechanism mentioned above, which in turn is based on CONSTRAIN <ref> [6] </ref>.
Reference: 7. <author> Matt Kaufmann, </author> <title> ``Skolemization Explained Simply'', Internal Note 27, Computational Logic, </title> <publisher> Inc., </publisher> <month> November </month> <year> 1987. </year>
Reference-contexts: Then f (x 1 ,...,x n ) represents f in G. Proof. We have to show that G |- [f (x 1 ,...,x n ) f]. Now a basic property of Skolemization (see for example Lemma 2 (2) of <ref> [7] </ref>, or Proposition 1 in the second appendix of the technical report version of [5]) is that each Skolemization (actually its universal closure) implies the formula from which it comes. It is routine to check that in fact, this argument does not depend on the choice of Skolem function symbols.
Reference: 8. <author> R. S. Boyer and J S. Moore, </author> <title> ``The Addition of Bounded Quantification and Partial Functions to A Computational Logic and Its Theorem Prover'', </title> <journal> Journal of Automated Reasoning, </journal> <volume> Vol. 4, No. 2, </volume> <year> 1988, </year> <pages> pp. 117-172. </pages>
Reference-contexts: The second, BDD-FORALL, is an implementation of bounded universal quantification by way of primitive recursive functions. This latter construct is somewhat similar in intent to the more sophisticated and far-reaching ideas for bounded quantification in <ref> [8] </ref>, but is simpler and is based on the DEFN-SK-CONSTRUCTIVE mechanism mentioned above, which in turn is based on CONSTRAIN [6]. Thus, BDD-FORALL is likely to be easily portable to the Acl2 system [9] that is currently under development, unlike the implementation of bounded quantification in [8], which is based on <p> for bounded quantification in <ref> [8] </ref>, but is simpler and is based on the DEFN-SK-CONSTRUCTIVE mechanism mentioned above, which in turn is based on CONSTRAIN [6]. Thus, BDD-FORALL is likely to be easily portable to the Acl2 system [9] that is currently under development, unlike the implementation of bounded quantification in [8], which is based on the EVAL$ construct of Nqthm [2] that is not likely to be ported to Acl2. 3.1 DEFN-SK-CONSTRUCTIVE Suppose that one wants the elegance and rewrite rules provided by DEFN-SK but wishes to stay within the ``constructive'' world.
Reference: 9. <author> R.S. Boyer, J S. Moore, </author> <title> ``A Theorem Prover for a Computational Logic'', </title> <type> Technical Report 54, </type> <institution> Computational Logic, Inc., </institution> <year> 1990, </year> <booktitle> Published in proceedings of 10th International Conference on Automated Deduction, </booktitle> <address> Kaiserslautern, West Germany, </address> <note> July 1990 i Table of Contents </note>
Reference-contexts: Thus, BDD-FORALL is likely to be easily portable to the Acl2 system <ref> [9] </ref> that is currently under development, unlike the implementation of bounded quantification in [8], which is based on the EVAL$ construct of Nqthm [2] that is not likely to be ported to Acl2. 3.1 DEFN-SK-CONSTRUCTIVE Suppose that one wants the elegance and rewrite rules provided by DEFN-SK but wishes to stay
Reference: 1. <institution> Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 </institution>
Reference-contexts: 1. Introduction It is often the case that users of Nqthm <ref> [1, 2] </ref> want to be able to express first-order quantified notions in Nqthm, or in Pc-Nqthm [3, 4]. 1 Quantifiers can be useful in creating elegant specifications: from a specification standpoint it is sometimes more appropriate to assert that a certain value exists, than to specify that a particular ``witnessing'' function


References-found: 10

