URL: http://www.eecs.berkeley.edu/~varaiya/papers_ps.dir/rabin_index_cav95.ps
Refering-URL: http://www.eecs.berkeley.edu/~varaiya/
Root-URL: 
Email: Email: fkrishnan,anuj,brayton,varaiyag@eecs.berkeley.edu  
Title: The Rabin Index and Chain automata, with applications to automata and games  
Author: Sriram C. Krishnan Anuj Puri Robert. K. Brayton, Pravin P. Varaiya 
Address: Berkeley, CA-94720  
Affiliation: Department of EECS, University of California,  
Abstract: In this paper we relate the Rabin Index of an !-language to the complexity of translation amongst automata, strategies for two-person regular games, and the complexity of controller-synthesis and verification for real systems, via a new construction to transform Rabin automata to Chain automata. The Rabin Index is the minimum number of pairs required to realize the language as a deterministic Rabin automaton (DRA), and is a measure of the inherent complexity of the !-language. Chain automata are a special kind of Rabin automata where the sets comprising the acceptance condition form a chain. Our main construction translates a DRA with n states and h pairs to a deterministic chain automaton (DCA) with n:h k states, where k is the Rabin Index of the language. Using this construction, we can transform a DRA into a minimum-pair DRA or deterministic Streett automaton (DSA), each with n:h k states. Using a simple correspondence between tree automata (TA) and games, we extend the constructions to translate between nondeterministic Rabin and Streett TA while simultaneously reducing the number of pairs; for the class of "trim" deterministic Rabin TA our construction gives a minimum-index deterministic Chain TA, or a minimum-pair DRTA or DSTA, each with n:h k states, where k is RI of the tree-language. Using these results, we obtain upper bounds on the memory required to implement strategies in infinite games. In particular, the amount of memory required in a game presented as a DRA, or DSA, is bounded by nh k , where k is the RI of the game language. Our constructions are of computational and practical significance, since in practice systems usually have a large number of pairs (due to the composi tional nature of most systems), but often a small Rabin Index.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> O. Carton. </author> <title> Chain Automata. </title> <booktitle> In IFIP 13th World Computer Congress, </booktitle> <pages> pages 451-458, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Our pair minimization algorithms also have applications in the context of compositional verification. There have been two previously published algorithms to convert DRA to DCA. For a DRA with n states and h pairs, Carton's <ref> [1] </ref> construction gives a DCA with O (n h 4 2h 2 ) states. Emerson and Jutla [5] observe that an algorithm of Safra [17] to convert DRA to DSA can be modified to yield a DCA with n:h h states. <p> The acceptance condition in chain form is: 1 1 (F 1 ) : : : 1 k (F k ) (2) Our transformation from DRA to DCA has complexity DR (n; h) ! DC (n:h k ; k). Carton's <ref> [1] </ref> transformation gives an equivalent DCA with n h 4 2h 2 states. <p> When the procedure finishes we have exactly twice the RI number of sets, and a positive chain attesting to the RI of the language (see <ref> [1] </ref> for more details). Using the transformation from DRA to minimum-chain-length DCA and the properties of DCA outlined above we have a means to convert a DRA to either a minimum-pair DRA or DSA, as shown in Figure 2.
Reference: 2. <author> E. S. Chang, Z. Manna, and A. Pnueli. </author> <title> The Safety-Progress Classification. </title> <editor> In F. L. Bauer, W. Bauer, and H. Schwichtenberg, editors, </editor> <booktitle> Logic and Algebra of Specification, </booktitle> <pages> pages 143-202, </pages> <year> 1993. </year>
Reference-contexts: The number of alternations between accepting and ? supported by NSF/DARPA Grant MIP-8719546 ?? supported by NSF grant ECS 9111907 and California PATH program non-accepting sets is an indication of the inherent complexity in the !-automata, and has a firm topological basis <ref> [20, 9, 11, 2] </ref>. It is also closely related to the Rabin Index|the minimum number of pairs required for a deterministic Rabin automata (DRA) to accept the same language.
Reference: 3. <author> E. A. Emerson. </author> <title> Automata, tableaux, and temporal logics. In Logics of Programs, </title> <publisher> LNCS, </publisher> <pages> pages 79-88. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: A -valued tree accepted by a tree automaton can be viewed as a strategy for the -player in the corresponding game automaton. Hence, Player I has a winning strategy in the game automaton iff the corresponding tree automaton has a non-empty language. Emerson <ref> [3] </ref> showed that every RTA with non-empty language accepts a tree that can be "embedded" in the automaton. <p> In a game presented as a Rabin automaton, if player I has a winning strategy, then I also has a memory-less winning strategy <ref> [3] </ref>. If player II has a winning strategy, the question is how complex is the strategy function. Gurevich and Harrington [7] showed that it is sufficient to remember the latest appearance record (LAR) of the states visited and not the entire sequence of states.
Reference: 4. <author> E. A. Emerson and C. S. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proc. of the Symp. on Foundations of Computer Science, </booktitle> <pages> pages 328-337, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: For example, determining the winner in a game on a DRA or DSA is exponential in the number of pairs <ref> [4, 14] </ref>. Our results make the algorithm a function of the Rabin Index|of practical importance when the game language has small Rabin Index. Our pair minimization algorithms also have applications in the context of compositional verification. There have been two previously published algorithms to convert DRA to DCA. <p> The set f0; 1g fl can be viewed as the infinite binary tree, where the root node is the empty string * and each node has two successors: the 0-successor 0 and the 1-successor 1 <ref> [4] </ref>. An infinite path through the tree is a sequence 2 f0; 1g ! . If is a finite alphabet, a -valued tree is a labeling t : f0; 1g fl ! . <p> There exist algorithms to check if an RTA or STA has nonempty language that are exponential only in the number of pairs, of complexity (nh) O (h) , where n is the number of states and h the number of pairs <ref> [4, 14] </ref>. On the other hand, nonemptiness of Chain TA is exponential only in the RI k (of complexity n O (k) [8]), and Buchi TA nonemptiness is in polynomial time. In practice, hardware designs and protocols are conceived of a system of interacting components. <p> We are currently trying to devise an algorithm for Rabin tree automata nonempti-ness that is exponential in the RI and is no worse than that in <ref> [4, 14] </ref> even in the worst case.
Reference: 5. <author> E. A. Emerson and C. S. Jutla. </author> <title> Trees automata, Mu-calculus and determinacy. </title> <booktitle> In Proc. of the Symp. on Foundations of Computer Science, </booktitle> <pages> pages 368-377, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: It is also closely related to the Rabin Index|the minimum number of pairs required for a deterministic Rabin automata (DRA) to accept the same language. Chain automata (a syntactic variant of Parity automata <ref> [5, 6] </ref>) are of fundamental interest because they capture the alternation in the structure of their acceptance condition. A deterministic Chain automaton can be trivially complemented, and admits a straightforward minimization in the number of pairs to the Rabin Index of the language it accepts. <p> In general, due to the infinite nature of the game, the strategies must be functions of the states that have been visited in the past. But for chain automata, both players have strategies that are functions of only the current state of the game (also called memory-less strategies) <ref> [5, 13, 19] </ref>. Using our construction, it is possible to get upper bounds on the amount of memory needed by the players to implement their strategies. <p> There have been two previously published algorithms to convert DRA to DCA. For a DRA with n states and h pairs, Carton's [1] construction gives a DCA with O (n h 4 2h 2 ) states. Emerson and Jutla <ref> [5] </ref> observe that an algorithm of Safra [17] to convert DRA to DSA can be modified to yield a DCA with n:h h states. In general our transformation yields fewer states and pairs, and is never worse. Section 2 presents our notation and definitions. <p> Carton's [1] transformation gives an equivalent DCA with n h 4 2h 2 states. Emerson and Jutla <ref> [5] </ref> suggest an adaptation of a construction of Safra from [17] to convert a DRA to DSA, to transform DRA to DCA; they achieve a transformation DR (n; h) ! DRC (n:h h ; h). Our transformation is better when k &lt; h and matches theirs in the worst case. <p> Furthermore, the chain length in a DCA can be easily minimized to yield an equivalent DCA on the same transition structure with chain length twice RI of the language. We briefly sketch the basic idea behind a polynomial time algorithm below. We first define the parity acceptance condition <ref> [5, 6] </ref>. It consists of disjoint sets M 1 ; N 1 ;M 2 ; N 2 ;: : : ; M h ; N h .
Reference: 6. <author> E. A. Emerson, C. S. Jutla, and A. P. Sistla. </author> <title> On model-checking for fragments of mu -calculus. </title> <booktitle> In Computer Aided Verification, volume 697 of LNCS, </booktitle> <pages> pages 385-396. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: It is also closely related to the Rabin Index|the minimum number of pairs required for a deterministic Rabin automata (DRA) to accept the same language. Chain automata (a syntactic variant of Parity automata <ref> [5, 6] </ref>) are of fundamental interest because they capture the alternation in the structure of their acceptance condition. A deterministic Chain automaton can be trivially complemented, and admits a straightforward minimization in the number of pairs to the Rabin Index of the language it accepts. <p> A deterministic Chain automaton can be trivially complemented, and admits a straightforward minimization in the number of pairs to the Rabin Index of the language it accepts. The chain acceptance condition is also significant because -calculus model checking is polynomially equivalent to chain TA-emptiness <ref> [6] </ref>. Our main construction converts a DRA with n states and h pairs, into a deterministic Chain automaton with nh k states and k pairs where k is the Rabin Index of the language. <p> Furthermore, the chain length in a DCA can be easily minimized to yield an equivalent DCA on the same transition structure with chain length twice RI of the language. We briefly sketch the basic idea behind a polynomial time algorithm below. We first define the parity acceptance condition <ref> [5, 6] </ref>. It consists of disjoint sets M 1 ; N 1 ;M 2 ; N 2 ;: : : ; M h ; N h .
Reference: 7. <author> Y. Gurevich and L. Harrington. </author> <title> Trees, automata, and games. </title> <booktitle> In Proc. of the ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 60-65, </pages> <month> May </month> <year> 1982. </year>
Reference-contexts: In a game presented as a Rabin automaton, if player I has a winning strategy, then I also has a memory-less winning strategy [3]. If player II has a winning strategy, the question is how complex is the strategy function. Gurevich and Harrington <ref> [7] </ref> showed that it is sufficient to remember the latest appearance record (LAR) of the states visited and not the entire sequence of states. This bounds the memory required to implement the strategy by jQ!j.
Reference: 8. <author> C. S. Jutla. </author> <type> Personal communication, </type> <month> February </month> <year> 1995. </year>
Reference-contexts: On the other hand, nonemptiness of Chain TA is exponential only in the RI k (of complexity n O (k) <ref> [8] </ref>), and Buchi TA nonemptiness is in polynomial time. In practice, hardware designs and protocols are conceived of a system of interacting components. Each component is typically simple and small, and has associated with it a simple fairness constraints such as Buchi or Co-Buchi, each expressible with a single Streett-pair.
Reference: 9. <author> M. Kaminski. </author> <title> A Classification of !-regular languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 36 </volume> <pages> 217-229, </pages> <year> 1985. </year>
Reference-contexts: The number of alternations between accepting and ? supported by NSF/DARPA Grant MIP-8719546 ?? supported by NSF grant ECS 9111907 and California PATH program non-accepting sets is an indication of the inherent complexity in the !-automata, and has a firm topological basis <ref> [20, 9, 11, 2] </ref>. It is also closely related to the Rabin Index|the minimum number of pairs required for a deterministic Rabin automata (DRA) to accept the same language. <p> The Rabin Index (RI) of a Deterministic !-automaton is the index of the longest positive chain. The Streett Index (SI) is the index of the longest negative chain. The difference between the SI and RI (and vice-versa) is at most one. Wagner [20] and Kaminski <ref> [9] </ref> showed that the RI (SI) is also the minimum number of pairs in a deterministic Rabin (Streett) automaton required to realize the same language. i j. The longest negative chain is (1; 2; 5; 6), and the longest positive chain is (4; 5; 6).
Reference: 10. <author> S. C. Krishnan, A. Puri, and R. K. Brayton. </author> <title> Deterministic !-automata vis-a-vis Deterministic Buchi Automata. </title> <booktitle> In Algorithms and Computation, volume 834 of LNCS, </booktitle> <pages> pages 378-386. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: We term this construction the exclusion construction; RabExcl is the exclusion construction for Rabin automata and StrExcl for Streett automata. Rabin automata We defined the notion of a final state in Section 2. We showed in <ref> [10] </ref> how to determine in polynomial time if a state in a RA is final. Lemma 8 [11]. Given a DRA A, a SCS C is superset closed if and only if C "F 6= ;, where F is the set of final states of the DRA.
Reference: 11. <author> S. C. Krishnan, A. Puri, and R. K. Brayton. </author> <title> Structural Complexity of !-automata. </title> <booktitle> In Symposium on Theoretical Aspects of Computer Science, volume 900 of LNCS, </booktitle> <pages> pages 143-156. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The number of alternations between accepting and ? supported by NSF/DARPA Grant MIP-8719546 ?? supported by NSF grant ECS 9111907 and California PATH program non-accepting sets is an indication of the inherent complexity in the !-automata, and has a firm topological basis <ref> [20, 9, 11, 2] </ref>. It is also closely related to the Rabin Index|the minimum number of pairs required for a deterministic Rabin automata (DRA) to accept the same language. <p> Using this construction, it becomes possible to transform a deterministic Rabin or Streett !-automaton with n states and h pairs into a minimum-pair deterministic Rabin or Streett automaton with nh k states. Our construction using Chain automata also simplifies the construction in <ref> [11] </ref>. By employing a simple correspondence between tree-automata and !-automata, we show that a "trim" deterministic Rabin tree automaton or Streett tree automaton can be converted to a minimum-pair deterministic chain tree automaton (DCTA), DRTA, or DSTA with the same complexity as before. <p> It follows that in such an automaton the -player has a strategy that is just a function from Q ! , termed a memory-less strategy by McNaughton [13]. 3 Converting DRA to Deterministic Chain automata We first review some constructions from <ref> [11] </ref> to isolate the superset closed sublanguage of Rabin automata and Streett automata. 3.1 Isolating the superset closed sublanguage Our basic constructions achieve the following: Given a deterministic automaton A = hT; i, we construct a deterministic automaton A 0 = hT 0 ; 0 i and identify a subset of <p> Rabin automata We defined the notion of a final state in Section 2. We showed in [10] how to determine in polynomial time if a state in a RA is final. Lemma 8 <ref> [11] </ref>. Given a DRA A, a SCS C is superset closed if and only if C "F 6= ;, where F is the set of final states of the DRA. <p> OUTPUT: DRA A 0 = hT; 0 i where 0 consists of h pairs, (L 0 i ; U 0 F; U i n F ), and F is the set of final states of A. Lemma 9 <ref> [11] </ref>. RabExcl has the property that L (A 0 ) = L (A) n supLan (A), and L (hT; F i) = supLan (A), where hT; F i is a DBA with final states F . <p> Without loss of generality we can assume L i " U i = ;. Let A i = hT; i i denote the DSA with a single pair: the i th pair, (L i ; U i ), of . Lemma 10 <ref> [11] </ref>. For DSA A i , a SCS C is superset closed if and only if C " F i 6= ;, where F i is the set of final states of A i . Theorem 11 [11]. <p> Lemma 10 <ref> [11] </ref>. For DSA A i , a SCS C is superset closed if and only if C " F i 6= ;, where F i is the set of final states of A i . Theorem 11 [11]. For a DSA A, a SCS C is superset closed if and only if C "F i 6= ; for each i, where F i is the set of final states of A i . The Streett exclusion construction is given below. <p> There is an exponential lower bound on translating DSA to DRA [16]. We show in the next section that we can obtain a transformation from DSA to DRA of the same complexity as for DRA to DCA. 2. We showed in <ref> [11] </ref> that it is NP-hard to determine the RI of a language specified as a DRA or DSA. 4 Translating between different automata In this section we use the construction to transform a DRA to a DCA, to translate a DRA or DSA into a minimum-pair DRA or DSA. <p> Translation map While the constructions presented in the previous section shared the same spirit as those in <ref> [11] </ref>, using chain automata provides for a more elegant and uniform treatment of the conversion between different automata. 5 Translating Tree automata In this section we extend the applicability of the constructions of the previous two sections to nondeterministic TA. Lemma 19.
Reference: 12. <author> R. P. Kurshan. </author> <title> Automata-Theoretic Verification of Coordinating Processes . Prince-ton University Press, </title> <year> 1994. </year>
Reference-contexts: Therefore the controller-synthesis problem for a compositionally specified plant can be decided more efficiently for systems of low RI. The constructions also have applications to testing language emptiness of a set of coordinating automata <ref> [12] </ref> that arises in the context of verification. As the product automaton is formed incrementally, by including more component automata, the number of pairs may be minimized.
Reference: 13. <author> R. McNaughton. </author> <title> Infinite gmaes played on finite graphs. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 65 </volume> <pages> 149-184, </pages> <year> 1993. </year>
Reference-contexts: In general, due to the infinite nature of the game, the strategies must be functions of the states that have been visited in the past. But for chain automata, both players have strategies that are functions of only the current state of the game (also called memory-less strategies) <ref> [5, 13, 19] </ref>. Using our construction, it is possible to get upper bounds on the amount of memory needed by the players to implement their strategies. <p> Emerson [3] showed that every RTA with non-empty language accepts a tree that can be "embedded" in the automaton. It follows that in such an automaton the -player has a strategy that is just a function from Q ! , termed a memory-less strategy by McNaughton <ref> [13] </ref>. 3 Converting DRA to Deterministic Chain automata We first review some constructions from [11] to isolate the superset closed sublanguage of Rabin automata and Streett automata. 3.1 Isolating the superset closed sublanguage Our basic constructions achieve the following: Given a deterministic automaton A = hT; i, we construct a deterministic <p> Depending on the acceptance condition used, the strategy can be implemented with less memory than the complete LAR. The chain acceptance condition has the special property that the union of two rejecting (accepting) SCSs cannot be accepting (rejecting); McNaughton <ref> [13] </ref> calls such a condition as lacking splits. He showed that in such a case the state set of the automaton can be partitioned into two sets, one which from player I has a memory-less winning strategy and the other from which player II has a memory-less winning strategy.
Reference: 14. <author> A. Pnueli and R. Rosner. </author> <title> On the synthesis of a reactive module. </title> <booktitle> In Proc. of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 179-180, </pages> <year> 1989. </year>
Reference-contexts: For example, determining the winner in a game on a DRA or DSA is exponential in the number of pairs <ref> [4, 14] </ref>. Our results make the algorithm a function of the Rabin Index|of practical importance when the game language has small Rabin Index. Our pair minimization algorithms also have applications in the context of compositional verification. There have been two previously published algorithms to convert DRA to DCA. <p> There exist algorithms to check if an RTA or STA has nonempty language that are exponential only in the number of pairs, of complexity (nh) O (h) , where n is the number of states and h the number of pairs <ref> [4, 14] </ref>. On the other hand, nonemptiness of Chain TA is exponential only in the RI k (of complexity n O (k) [8]), and Buchi TA nonemptiness is in polynomial time. In practice, hardware designs and protocols are conceived of a system of interacting components. <p> We are currently trying to devise an algorithm for Rabin tree automata nonempti-ness that is exponential in the RI and is no worse than that in <ref> [4, 14] </ref> even in the worst case.
Reference: 15. <author> M. O. Rabin. </author> <title> Automata on Infinite Objects and Church's Problem, </title> <booktitle> volume 13 of Regional Conf. Series in Mathematics. </booktitle> <publisher> American Mathematical Society, </publisher> <address> Providence, Rhode Island, </address> <year> 1972. </year>
Reference-contexts: Since the GA is exactly the set of accepting sequential runs it follows that L (B G ) = L (M G ). ut 6 Strategies in Games Two-person games are interesting from an applications viewpoint because the synthesis-problem <ref> [15] </ref> can be seen as a game between the controller and the disturbance [19]. Strategies that are easier to implement are desirable. A particularly simple form of a strategy is a memory-less strategy where the strategy is a function of just the current state set of the game automaton.
Reference: 16. <author> S. Safra and M. Y. Vardi. </author> <title> On !-Automata and Temporal Logic. </title> <booktitle> In Proc. of the ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 127-137, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Our transformation is better when k &lt; h and matches theirs in the worst case. Also, our construction is optimum in the sense that we cannot hope to get a transformation that is polynomial in k because: 1. There is an exponential lower bound on translating DSA to DRA <ref> [16] </ref>. We show in the next section that we can obtain a transformation from DSA to DRA of the same complexity as for DRA to DCA. 2.
Reference: 17. <author> Shmuel Safra. </author> <title> Complexity of Automata on Infinite Objects. </title> <type> PhD thesis, </type> <institution> The Weiz-mann Institute of Science, Rehovot, Israel, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: There have been two previously published algorithms to convert DRA to DCA. For a DRA with n states and h pairs, Carton's [1] construction gives a DCA with O (n h 4 2h 2 ) states. Emerson and Jutla [5] observe that an algorithm of Safra <ref> [17] </ref> to convert DRA to DSA can be modified to yield a DCA with n:h h states. In general our transformation yields fewer states and pairs, and is never worse. Section 2 presents our notation and definitions. <p> Carton's [1] transformation gives an equivalent DCA with n h 4 2h 2 states. Emerson and Jutla [5] suggest an adaptation of a construction of Safra from <ref> [17] </ref> to convert a DRA to DSA, to transform DRA to DCA; they achieve a transformation DR (n; h) ! DRC (n:h h ; h). Our transformation is better when k &lt; h and matches theirs in the worst case.
Reference: 18. <author> W. Thomas. </author> <title> Automata on Infinite Objects. </title> <editor> In J. van Leeuwen, editor, </editor> <title> Formal Models and Semantics, </title> <booktitle> volume B of Handbook of Theoretical Computer Science, </booktitle> <pages> pages 133-191. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: In Section 6, we discuss the relevance of our results to two-person games. In Section 7, we discuss the practical significance of the Rabin Index to the complexity of synthesis and verification. 2 Preliminaries 2.1 !-automata An !-automaton <ref> [18] </ref> over a finite alphabet, , is A = hT; i, where T is a transition structure and is the acceptance condition. <p> The terminology, final state, comes from BA where every SCS containing a final state is accepting; every accepting SCS is superset closed. Landweber <ref> [18] </ref> showed 3 C Q is a SCS if there is a path in the STG between any two states of C Fig. 1. <p> Therefore the class of languages accepted by DBA form a strict subset of the class of !-regular languages, and are contained in the Borel class G ffi <ref> [18] </ref> (the !-regular languages are the class of languages accepted by DRA or DSA). 2.3 Tree automata and Games We consider finite automata on labeled, infinite binary trees 4 . <p> There is a close relation between tree automata and two-person Gale-Stewart games. Definition 7. Given finite alphabets A and B, a regular two-person Gale-Stewart game is represented by an !-regular language (A fi B) ! (the game language) <ref> [18] </ref>. A single play of the game is as follows: player I picks some a 0 2 A, then II 4 extension to k-ary trees is straightforward picks some b 0 2 B, followed by I picking some a 1 2 A, and so on in turns.
Reference: 19. <author> W. Thomas. </author> <title> On the synthesis of strategies in infinite games. </title> <booktitle> In Symposium on Theoretical Aspects of Computer Science, volume 900 of LNCS, </booktitle> <pages> pages 1-13. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: In general, due to the infinite nature of the game, the strategies must be functions of the states that have been visited in the past. But for chain automata, both players have strategies that are functions of only the current state of the game (also called memory-less strategies) <ref> [5, 13, 19] </ref>. Using our construction, it is possible to get upper bounds on the amount of memory needed by the players to implement their strategies. <p> Complementing U i translates between the standard syntax and ours. 2.2 Rabin Index and Chain automata Definition 5. The chain acceptance condition <ref> [19] </ref> is represented by a formula = _ n i=1 (F i ^:E i ) where F i ; E i ; 1 i n are DF, and E 1 F 1 E 2 F 2 : : : E n F n . <p> GA is exactly the set of accepting sequential runs it follows that L (B G ) = L (M G ). ut 6 Strategies in Games Two-person games are interesting from an applications viewpoint because the synthesis-problem [15] can be seen as a game between the controller and the disturbance <ref> [19] </ref>. Strategies that are easier to implement are desirable. A particularly simple form of a strategy is a memory-less strategy where the strategy is a function of just the current state set of the game automaton.
Reference: 20. <author> K. Wagner. </author> <title> On !-Regular Sets. </title> <journal> Information and Control, </journal> <volume> 43 </volume> <pages> 123-177, </pages> <year> 1979. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: The number of alternations between accepting and ? supported by NSF/DARPA Grant MIP-8719546 ?? supported by NSF grant ECS 9111907 and California PATH program non-accepting sets is an indication of the inherent complexity in the !-automata, and has a firm topological basis <ref> [20, 9, 11, 2] </ref>. It is also closely related to the Rabin Index|the minimum number of pairs required for a deterministic Rabin automata (DRA) to accept the same language. <p> The Rabin Index (RI) of a Deterministic !-automaton is the index of the longest positive chain. The Streett Index (SI) is the index of the longest negative chain. The difference between the SI and RI (and vice-versa) is at most one. Wagner <ref> [20] </ref> and Kaminski [9] showed that the RI (SI) is also the minimum number of pairs in a deterministic Rabin (Streett) automaton required to realize the same language. i j. The longest negative chain is (1; 2; 5; 6), and the longest positive chain is (4; 5; 6).
References-found: 20

