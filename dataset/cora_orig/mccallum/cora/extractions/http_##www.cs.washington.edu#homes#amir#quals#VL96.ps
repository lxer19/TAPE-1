URL: http://www.cs.washington.edu/homes/amir/quals/VL96.ps
Refering-URL: http://www.cs.washington.edu/homes/amir/opsis/
Root-URL: http://www.cs.washington.edu
Email: amir@cs.washington.edu  
Title: Teaching Binary Tree Algorithms through Visual Programming  
Author: Amir Michail 
Note: States of America  
Address: Box 352350 Seattle, Washington 98195, United  
Affiliation: Department of Computer Science and Engineering University of Washington,  
Abstract: In this paper, we show how visual programming can be used to teach binary tree algorithms. In our approach, the student implements a binary tree algorithm by manipulating abstract tree fragments (not necessarily just single nodes) in a visual way. This work contributes to visual programming research by combining elements of animation, programming, and proof to produce an educational visual programming tool. In addition, we describe our experiences with Opsis, a system we built to demonstrate the ideas in this paper. (Opsis is a Java applet and can be accessed at http://www.cs.washington.edu/homes/amir/Opsis.html.) Finally, we make the claim that visual programming is an ideal way to teach data structure algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. H. Brown. Zeus: </author> <title> A system for algorithm animation and multi-view editing. </title> <booktitle> In IEEE Workshop on Visual Languages, </booktitle> <pages> pages 4-9, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Moreover, we believe our approach is enhanced from the synergy of many disparate ideas encountered throughout the literature. Much work has been done in algorithm animation. As an example, the Zeus <ref> [1] </ref> system animates many fundamental algorithms and does so in several ways. However, as we are interested in abstract representations of trees (i.e, depicting a class of trees, not just one), we draw upon more abstract tree diagrams found in many algorithms and data structures texts (such as [10, 4]).
Reference: [2] <author> C. Christensen. </author> <title> An example of the manipulation of directed graphs in the AMBIT/G programming language. </title> <editor> In M. Klerer and J. Reinfelds, editors, </editor> <booktitle> Interactive Systems for Experimental Applied Mathematics, </booktitle> <pages> pages 423-435. </pages> <publisher> Academic Press, </publisher> <year> 1968. </year>
Reference-contexts: However, in both groups, the systems are not designed to teach algorithms, nor do they allow easy construction of complicated algorithms (such as AVL tree insertions or deletions). Some visual programming systems have been designed with more advanced programmers in mind. For example, Christensen's AMBIT/G <ref> [2] </ref> and AMBIT/L [3] languages have been used to manipulate directed graphs and lists, respectively. However, these languages are essentially a visual version of Snobol with static pictures to indicate the pattern matching rules; the resultant programs can be difficult to read and manipulate.
Reference: [3] <author> C. Christensen. </author> <title> An introduction to AMBIT/L, a diagrammatic language for list processing. </title> <booktitle> In Proceeding of the 2nd Symposium on Symbolic and Algebraic Manipulation, </booktitle> <pages> pages 248-260, </pages> <year> 1971. </year>
Reference-contexts: However, in both groups, the systems are not designed to teach algorithms, nor do they allow easy construction of complicated algorithms (such as AVL tree insertions or deletions). Some visual programming systems have been designed with more advanced programmers in mind. For example, Christensen's AMBIT/G [2] and AMBIT/L <ref> [3] </ref> languages have been used to manipulate directed graphs and lists, respectively. However, these languages are essentially a visual version of Snobol with static pictures to indicate the pattern matching rules; the resultant programs can be difficult to read and manipulate.
Reference: [4] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: However, as we are interested in abstract representations of trees (i.e, depicting a class of trees, not just one), we draw upon more abstract tree diagrams found in many algorithms and data structures texts (such as <ref> [10, 4] </ref>). Many visual programming systems have been designed for beginning programmers or application end-users. In the former group, we find systems like Glinert's PICT [7], in which a programmer uses icons and flowcharts to program simple arithmetic computations.
Reference: [5] <author> G. A. Curry. </author> <title> Programming by Abstract Demonstration. </title> <type> Technical Report 78-03-02, </type> <institution> University of Washington, </institution> <year> 1978. </year>
Reference-contexts: The idea is to specify the algorithm in full generality and not just on a specific example. For this reason, our approach is not programming by example [14, 12, 6] but is similar to programming by abstract demonstration <ref> [5] </ref>. 3.1 State Types For our computation model, we use an abstract state, which is an abstract visual diagram that represents a set of concrete states (e.g., a set of binary trees). Two abstract states are identical if and only if their respective abstract visual diagrams match exactly.
Reference: [6] <author> A. Cypher, </author> <title> editor. Watch What I Do. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: A user specifies transitions from one state to another by manipulating abstract objects in a visual manner. The idea is to specify the algorithm in full generality and not just on a specific example. For this reason, our approach is not programming by example <ref> [14, 12, 6] </ref> but is similar to programming by abstract demonstration [5]. 3.1 State Types For our computation model, we use an abstract state, which is an abstract visual diagram that represents a set of concrete states (e.g., a set of binary trees).
Reference: [7] <author> E. P. Glinert. </author> <title> PICT: Experiments in the Design of Interactive, Graphical Programming Environments. </title> <type> Technical Report 85-01-01, </type> <institution> University of Washington, </institution> <month> January </month> <year> 1985. </year>
Reference-contexts: Many visual programming systems have been designed for beginning programmers or application end-users. In the former group, we find systems like Glinert's PICT <ref> [7] </ref>, in which a programmer uses icons and flowcharts to program simple arithmetic computations. In the latter group, we find systems like Modugno's Pursuit [11], which allows end-users to visually program simple shell scripts by example.
Reference: [8] <author> E. C. R. Hehner. </author> <title> A Practical Theory of Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [9] <author> A. W. Lawrence, A. M. Badre, and J. T. Stasko. </author> <title> Empirically evaluating the use of animations to teach algorithms. </title> <booktitle> In Sympsoium on Visual Languages. IEEE, </booktitle> <month> October </month> <year> 1994. </year>
Reference: [10] <author> H. R. Lewis and L. Denenberg. </author> <title> Data Structures and Their Algorithms. </title> <address> Haper Collins, </address> <year> 1991. </year>
Reference-contexts: However, as we are interested in abstract representations of trees (i.e, depicting a class of trees, not just one), we draw upon more abstract tree diagrams found in many algorithms and data structures texts (such as <ref> [10, 4] </ref>). Many visual programming systems have been designed for beginning programmers or application end-users. In the former group, we find systems like Glinert's PICT [7], in which a programmer uses icons and flowcharts to program simple arithmetic computations.
Reference: [11] <author> F. Modugno and B. Myers. </author> <title> A state-based visual language for a demonstrational visual shell. </title> <booktitle> In Sympsoium on Visual Languages. IEEE, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: Many visual programming systems have been designed for beginning programmers or application end-users. In the former group, we find systems like Glinert's PICT [7], in which a programmer uses icons and flowcharts to program simple arithmetic computations. In the latter group, we find systems like Modugno's Pursuit <ref> [11] </ref>, which allows end-users to visually program simple shell scripts by example. However, in both groups, the systems are not designed to teach algorithms, nor do they allow easy construction of complicated algorithms (such as AVL tree insertions or deletions).
Reference: [12] <author> B. Myers. </author> <title> Visual programming, programming by example, and program visualization; A taxonomy. </title> <booktitle> In Proceedings of CHI '86, </booktitle> <pages> pages 59-66. </pages> <publisher> ACM, </publisher> <month> April </month> <year> 1986. </year>
Reference-contexts: A user specifies transitions from one state to another by manipulating abstract objects in a visual manner. The idea is to specify the algorithm in full generality and not just on a specific example. For this reason, our approach is not programming by example <ref> [14, 12, 6] </ref> but is similar to programming by abstract demonstration [5]. 3.1 State Types For our computation model, we use an abstract state, which is an abstract visual diagram that represents a set of concrete states (e.g., a set of binary trees).
Reference: [13] <author> R. V. Rubin, E. J. Colin, and S. P. Reiss. </author> <title> Think pad: A graphical system for programming by demonstration. </title> <journal> IEEE Software, </journal> <volume> 3 </volume> <pages> 73-78, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: However, these languages are essentially a visual version of Snobol with static pictures to indicate the pattern matching rules; the resultant programs can be difficult to read and manipulate. Our approach is more dynamic, similar in style to the data structure programming system Think Pad <ref> [13] </ref>, but easier to use and more abstract. As we are also interested in visually proving various properties of the binary tree algorithms, we borrow some concepts (primarily loop invariants) from the area of programming methodology (i.e., formal methods).
Reference: [14] <author> S. D. Smith. Pygmalion: </author> <title> A Creative Programming Environment. </title> <type> Technical Report STAN-CS-75-499, </type> <institution> Stanford University, </institution> <year> 1975. </year>
Reference-contexts: A user specifies transitions from one state to another by manipulating abstract objects in a visual manner. The idea is to specify the algorithm in full generality and not just on a specific example. For this reason, our approach is not programming by example <ref> [14, 12, 6] </ref> but is similar to programming by abstract demonstration [5]. 3.1 State Types For our computation model, we use an abstract state, which is an abstract visual diagram that represents a set of concrete states (e.g., a set of binary trees).
References-found: 14

