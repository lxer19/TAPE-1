URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1102/CS-TR-92-1102.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1102/
Root-URL: http://www.cs.wisc.edu
Email: rn@cs.brown.edu bart@cs.wisc.edu  
Title: Optimal Tracing and Replay for Debugging Message-Passing Parallel Programs  
Author: Robert H. B. Netzer Barton P. Miller 
Address: Box 1910 1210 W. Dayton St. Providence, RI 02912 Madison, WI 53706  
Affiliation: Dept. of Computer Science Computer Sciences Dept. Brown University University of Wisconsin-Madison  
Note: Appears in Supercomputing 92, November 1992, Minneapolis, MN  
Abstract: A common debugging strategy involves re-executing a program (on a given input) over and over, each time gaining more information about bugs. Such techniques can fail on message-passing parallel programs. Because of variations in message latencies and process scheduling, different runs on the given input may produce different results. This non-repeatability is a serious debugging problem, since an execution cannot always be reproduced to track down bugs. This paper presents a technique for tracing and replaying message-passing programs for debugging. Our technique is optimal in the common case and has good performance in the worst case. By making run-time tracing decisions, we trace only a fraction of the total number of messages, gaining two orders of magnitude reduction over traditional techniques which trace every message. Experiments indicate that only 1% of the messages often need be traced. These traces are sufficient to provide replay, allowing an execution to be reproduced any number of times for debugging. Our work is novel in that we use run-time decisions to detect and trace only those messages that introduce non-determinacy. With our strategy, large reductions in trace size allow long-running programs to be replayed that were previously unmanageable. In addition, the reduced tracing requirements alleviate tracing bottlenecks, allowing executions to be debugged with substantially lower execution-time overhead. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Curtis, R. and L. Wittie, ``BugNet: </author> <title> A Debugging System for Parallel Programming Environments,'' </title> <booktitle> Proc. of the 3rd Intl. Conf. on Dist. Computing Systems, </booktitle> <pages> pp. </pages> <month> 394-399 </month> <year> (1982). </year>
Reference-contexts: Our work is novel in that only the racing messages are traced. In contrast, earlier trace and replay schemes for message-passing programs require tracing every message. Replay was first introduced by Curtis and Wittie in the BugNet system for debugging distributed C programs <ref> [1] </ref>. LeBlanc and Mellor-Crummey [4] also addressed replay but considered both shared-memory and message-passing parallel programs. They trace only the order in which messages are delivered (and not their contents). By reproducing only the order of message deliveries, their contents (and hence the original computation) will also be reproduced. <p> To replay the execution for debugging, we must first trace the order in which the messages are delivered, and then use this trace to force a re-execution to exhibit the same message deliveries. Earlier trace and replay schemes propose tracing the order in which all messages are delivered <ref> [1, 4] </ref>. For example, they would record that Msg1 was delivered to the first Recv in P 2 and that Msg2 was delivered to the second Recv. During replay, the receive operations are modified to accept only the appropriate messages.
Reference: [2] <author> Fidge, C. J., </author> <title> ``Partial Orders for Parallel Debugging,'' </title> <booktitle> SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <address> 183-194 Madis-on, WI, </address> <month> (May </month> <year> 1988). </year> <note> Also appears in SIGPLAN Notices 24(1) (January 1989). </note>
Reference-contexts: Our imple mentation of this algorithm maintains the HB relation during execution with a vector timestamp in each process. A vector timestamp is a vector of length p (the number of processes) containing event serial numbers <ref> [2] </ref>. These timestamps are maintained by appending them onto user messages and updating them after each receive operation. The tracing algorithm detects races by comparing times-tamp values and event serial numbers to determine whether the previous receive happened before the sender of the current message.
Reference: [3] <author> Lamport, Leslie, </author> <title> ``Time, Clocks, and the Ordering of Events in a Distributed System,'' </title> <journal> CACM 21(7) pp. </journal> <month> 558-565 (July </month> <year> 1978). </year>
Reference-contexts: Using logical channels is very general; any message-passing scheme (such as ports, mailboxes, or links) can be represented. We attach the attributes SEND (e ) and RECEIVE (e) to synchronization events to denote these channels. The happened-before relation, HB , shows how events potentially affect one another <ref> [3] </ref>, and is defined as the irreflexive transitive closure of the union of two other relations: HB XO M XO relation shows the order in which events in the same process execute.
Reference: [4] <author> LeBlanc, Thomas J. and John M. Mellor-Crummey, </author> <title> ``Debugging Parallel Programs with Instant Replay,'' </title> <journal> IEEE Trans. on Computers C-36(4) pp. </journal> <month> 471-482 (April </month> <year> 1987). </year>
Reference-contexts: Our work is novel in that only the racing messages are traced. In contrast, earlier trace and replay schemes for message-passing programs require tracing every message. Replay was first introduced by Curtis and Wittie in the BugNet system for debugging distributed C programs [1]. LeBlanc and Mellor-Crummey <ref> [4] </ref> also addressed replay but considered both shared-memory and message-passing parallel programs. They trace only the order in which messages are delivered (and not their contents). By reproducing only the order of message deliveries, their contents (and hence the original computation) will also be reproduced. <p> To replay the execution for debugging, we must first trace the order in which the messages are delivered, and then use this trace to force a re-execution to exhibit the same message deliveries. Earlier trace and replay schemes propose tracing the order in which all messages are delivered <ref> [1, 4] </ref>. For example, they would record that Msg1 was delivered to the first Recv in P 2 and that Msg2 was delivered to the second Recv. During replay, the receive operations are modified to accept only the appropriate messages. <p> The traces only need identify the sending and receiving events of the racing message. These events can be identified by maintaining in each process a local counter (incremented after every synchronization operation) that is used to assign serial numbers to events <ref> [4] </ref>. It suffices to trace the event serial numbers of the sender and receiver and the process number of the sender. If one trace file is maintained for each process in the program execution, the process number of the receiver is implicit and need not be recorded.
References-found: 4

