URL: http://seclab.cs.ucdavis.edu/~devanbu/lassie.ps.Z
Refering-URL: http://seclab.cs.ucdavis.edu/~devanbu/prem_papers.html
Root-URL: http://www.cs.ucdavis.edu
Title: LaSSIE: a Knowledge-Based Software Information System  
Author: Premkumar Devanbu Ronald J. Brachman Peter G. Selfridge Bruce W. Ballard 
Abstract: Invisibility is an inherent and significant problem in the task of developing large software systems. There are no direct solutions to this problem; however, there are several categories of systems|relational code analyzers, reuse librarians, and project management databases-that can be seen as addressing aspects of the invisibility problem. We argue that these systems do not adequately deal with certain important aspects of the problem, namely, semantic proliferation, multiple views, and the need for intelligent indexing. We have built a system called LaSSIE, which uses knowledge representation and reasoning mechanisms to directly address each of these issues. LaSSIE provides a knowledge base explicitly representing a large software system, and an interactive interface to give programmers direct access to the software through several semantically-based views. LaSSIE is limited in a number of ways, but it illustrates how representation and reasoning mechanisms can be used to alleviate invisibility and complexity.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Adelson, B. and Soloway, E.. </author> <title> The Role of Domain Experience in Software Design. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(11), </volume> <year> 1985. </year>
Reference-contexts: In two different studies, Soloway, Adelson, and Ehrlich showed how a lack of knowledge affects the quality of the results in design tasks <ref> [ 1 ] </ref> and in small programming-related tasks [ 43 ] . Without proper knowledge of the architecture of the system, developers can make mistakes and produce incorrectly functioning code. In large systems, the impact of poor discovery is of a different form, but much more insidious. <p> For example, 1 (define individual Add-User-Action 2 (ACTION) 3 (has-actor Call-Control-Process) 4 (has-agent Bus-Controller) 5 (has-operand Generic-User) 6 (has-recipient Generic-Call) 7 (has-environment Generic-Call-State) 8 (has-result Talking-State) 9 (implemented-by /Usr/Pgs/Gp/Tgpall/Profum.c) 10 (calls-function Signal-Add-Error-Action) 11 (accesses-variable *Call-Record*)) In other words, Add-User-Action <ref> [1] </ref> is an action [2] that is performed by the call control process [3] using the bus-controller [4]; its operand is any user [5], and its recipient is a call [6]; it takes its operand from any call state [7] to the talking state [8]; it is implemented by the source
Reference: [2] <author> Arango, G., </author> <title> Domain Analysis: From Art Form to Engineering Discipline, </title> <booktitle> Proceedings of the Fifth International Workshop on Software Specification and Design, </booktitle> <address> Pittsburgh, PA, </address> <month> May, </month> <year> 1989. </year>
Reference-contexts: Our choice was influenced by three different factors: existing work in the field of Domain Analysis, empirical studies of programming knowledge, and vocabulary used by programmers in Definity 75/85 7 . Reverse knowledge engineering is closely related to the notion of Domain Analysis <ref> [ 2; 36; 29 ] </ref> . <p> Items in all lower case are roles, which represent relationships between individu 9 In particular a TRUNK IS-A COMMUNICATIONS-DEVICE, a RESOURCE-OBJECT, and a DOER. als. Thus, the interpretation of this frame is as follows: USER-CONNECT-ACTION [Line 1] is by definition [3] a network action <ref> [2] </ref> and a call-control-action [2] that is done by a process [4], using the bus-controller [5] on a user [6], and which takes the user from some call state [7] to the talking state [8]. <p> Items in all lower case are roles, which represent relationships between individu 9 In particular a TRUNK IS-A COMMUNICATIONS-DEVICE, a RESOURCE-OBJECT, and a DOER. als. Thus, the interpretation of this frame is as follows: USER-CONNECT-ACTION [Line 1] is by definition [3] a network action <ref> [2] </ref> and a call-control-action [2] that is done by a process [4], using the bus-controller [5] on a user [6], and which takes the user from some call state [7] to the talking state [8]. LaSSIE's KB contains 102 action concept descriptions of this type, which are classified into a conceptual hierarchy. <p> For example, 1 (define individual Add-User-Action 2 (ACTION) 3 (has-actor Call-Control-Process) 4 (has-agent Bus-Controller) 5 (has-operand Generic-User) 6 (has-recipient Generic-Call) 7 (has-environment Generic-Call-State) 8 (has-result Talking-State) 9 (implemented-by /Usr/Pgs/Gp/Tgpall/Profum.c) 10 (calls-function Signal-Add-Error-Action) 11 (accesses-variable *Call-Record*)) In other words, Add-User-Action [1] is an action <ref> [2] </ref> that is performed by the call control process [3] using the bus-controller [4]; its operand is any user [5], and its recipient is a call [6]; it takes its operand from any call state [7] to the talking state [8]; it is implemented by the source file /Usr/Pgs/Gp/Tgpall/Profum.c [9], calls <p> The user can specialize the above query by replacing either OBJECT or DOER with their children in the taxonomy, either by using a menu choice, or by looking it up in the graph. This is the 13 The retrieved individual is an instance of a CALL-MERGE-ACTION <ref> [2] </ref> done by the Attd-Monitor process [3], using the System-Fabric-Manager [4] process, which connects one CALL [5] to another [6], leaving both calls in a Talking-State; this action is caused by the attendant pushing a button [9], it is implemented by the source file listed in line 10; it calls the
Reference: [3] <editor> AT&T Technical Journal, </editor> <booktitle> Special Issue on the System 75 Digital Communications System, </booktitle> <volume> Vol. 64, No. 1, Part 2, </volume> <month> January, </month> <year> 1985. </year>
Reference-contexts: LaSSIE is intended to help programmers find useful information about a large software system|in our case the AT&T Definity T M 75/85 1 <ref> [ 3 ] </ref> . <p> Items in all lower case are roles, which represent relationships between individu 9 In particular a TRUNK IS-A COMMUNICATIONS-DEVICE, a RESOURCE-OBJECT, and a DOER. als. Thus, the interpretation of this frame is as follows: USER-CONNECT-ACTION [Line 1] is by definition <ref> [3] </ref> a network action [2] and a call-control-action [2] that is done by a process [4], using the bus-controller [5] on a user [6], and which takes the user from some call state [7] to the talking state [8]. <p> 1 (define individual Add-User-Action 2 (ACTION) 3 (has-actor Call-Control-Process) 4 (has-agent Bus-Controller) 5 (has-operand Generic-User) 6 (has-recipient Generic-Call) 7 (has-environment Generic-Call-State) 8 (has-result Talking-State) 9 (implemented-by /Usr/Pgs/Gp/Tgpall/Profum.c) 10 (calls-function Signal-Add-Error-Action) 11 (accesses-variable *Call-Record*)) In other words, Add-User-Action [1] is an action [2] that is performed by the call control process <ref> [3] </ref> using the bus-controller [4]; its operand is any user [5], and its recipient is a call [6]; it takes its operand from any call state [7] to the talking state [8]; it is implemented by the source file /Usr/Pgs/Gp/Tgpall/Profum.c [9], calls the function Signal-Add-Error- Action [10], and uses the global <p> This is the 13 The retrieved individual is an instance of a CALL-MERGE-ACTION [2] done by the Attd-Monitor process <ref> [3] </ref>, using the System-Fabric-Manager [4] process, which connects one CALL [5] to another [6], leaving both calls in a Talking-State; this action is caused by the attendant pushing a button [9], it is implemented by the source file listed in line 10; it calls the function Signal-Error-Action and uses the global
Reference: [4] <author> Ballard, B. W., </author> <title> A Lexical, Syntactic, and Semantic Framework for a User-Customized Natural Language Question-Answering System, Lexical-Semantic Relational Models, Martha Evens, Editor, </title> <publisher> Cambridge University Press, </publisher> <year> 1988. </year>
Reference-contexts: Thus, the interpretation of this frame is as follows: USER-CONNECT-ACTION [Line 1] is by definition [3] a network action [2] and a call-control-action [2] that is done by a process <ref> [4] </ref>, using the bus-controller [5] on a user [6], and which takes the user from some call state [7] to the talking state [8]. LaSSIE's KB contains 102 action concept descriptions of this type, which are classified into a conceptual hierarchy. <p> 2 (ACTION) 3 (has-actor Call-Control-Process) 4 (has-agent Bus-Controller) 5 (has-operand Generic-User) 6 (has-recipient Generic-Call) 7 (has-environment Generic-Call-State) 8 (has-result Talking-State) 9 (implemented-by /Usr/Pgs/Gp/Tgpall/Profum.c) 10 (calls-function Signal-Add-Error-Action) 11 (accesses-variable *Call-Record*)) In other words, Add-User-Action [1] is an action [2] that is performed by the call control process [3] using the bus-controller <ref> [4] </ref>; its operand is any user [5], and its recipient is a call [6]; it takes its operand from any call state [7] to the talking state [8]; it is implemented by the source file /Usr/Pgs/Gp/Tgpall/Profum.c [9], calls the function Signal-Add-Error- Action [10], and uses the global variable *Call-Record* [11]. <p> This is the 13 The retrieved individual is an instance of a CALL-MERGE-ACTION [2] done by the Attd-Monitor process [3], using the System-Fabric-Manager <ref> [4] </ref> process, which connects one CALL [5] to another [6], leaving both calls in a Talking-State; this action is caused by the attendant pushing a button [9], it is implemented by the source file listed in line 10; it calls the function Signal-Error-Action and uses the global variable *Call-Record* 14 This <p> Thus, if there are no (or an insufficient number of) answers, the user can generalize parts of the query. In addition to its graphical interface, LaSSIE also has a natural language query interface based on TELI <ref> [ 4 ] </ref> , which we now describe. 5.7 Adding a Natural Language Interface To provide a natural language interface for LaSSIE, we customized the TELI system, which maintains data structures for each of several types of knowledge [ 4 ] . <p> interface, LaSSIE also has a natural language query interface based on TELI <ref> [ 4 ] </ref> , which we now describe. 5.7 Adding a Natural Language Interface To provide a natural language interface for LaSSIE, we customized the TELI system, which maintains data structures for each of several types of knowledge [ 4 ] .
Reference: [5] <author> Beck, H.W., Gala, S. K., Navathe, S. B., </author> <title> Classification as a Query Processing Technique in the CANDIDE Semantic Data Model Fifth International Conference on Data Engineering, </title> <address> Los Ange-les, CA, </address> <year> 1989. </year>
Reference-contexts: Thus, the interpretation of this frame is as follows: USER-CONNECT-ACTION [Line 1] is by definition [3] a network action [2] and a call-control-action [2] that is done by a process [4], using the bus-controller <ref> [5] </ref> on a user [6], and which takes the user from some call state [7] to the talking state [8]. LaSSIE's KB contains 102 action concept descriptions of this type, which are classified into a conceptual hierarchy. Farther down in the hierarchy, the action concepts become very specific. <p> (has-agent Bus-Controller) 5 (has-operand Generic-User) 6 (has-recipient Generic-Call) 7 (has-environment Generic-Call-State) 8 (has-result Talking-State) 9 (implemented-by /Usr/Pgs/Gp/Tgpall/Profum.c) 10 (calls-function Signal-Add-Error-Action) 11 (accesses-variable *Call-Record*)) In other words, Add-User-Action [1] is an action [2] that is performed by the call control process [3] using the bus-controller [4]; its operand is any user <ref> [5] </ref>, and its recipient is a call [6]; it takes its operand from any call state [7] to the talking state [8]; it is implemented by the source file /Usr/Pgs/Gp/Tgpall/Profum.c [9], calls the function Signal-Add-Error- Action [10], and uses the global variable *Call-Record* [11]. <p> This is the 13 The retrieved individual is an instance of a CALL-MERGE-ACTION [2] done by the Attd-Monitor process [3], using the System-Fabric-Manager [4] process, which connects one CALL <ref> [5] </ref> to another [6], leaving both calls in a Talking-State; this action is caused by the attendant pushing a button [9], it is implemented by the source file listed in line 10; it calls the function Signal-Error-Action and uses the global variable *Call-Record* 14 This would be specified by the inclusion <p> This point has been made by Beck, Gala and Navathe (and others): "... the user can describe a query in terms which may be different from the exact terms under which the desired information is stored, as long as the meaning is simi lar". <ref> [ 5 ] </ref> Essentially, classification is a logically defined operation that allows semantic retrieval in a simple yet principled manner. * Use of classification and inheritance to support updates|When new information is added to the knowledge base, the system automatically classifies the new items, thereby giving the developer an integrity check.
Reference: [6] <author> Bellin, </author> <title> S, </title> <type> Personal Communication. </type>
Reference-contexts: In addition, Bellin <ref> [ 6 ] </ref> suggests that the description of each component should include constraints on how it should be reused; without this information, the reuser is liable to violate the architecture and contribute to increased complexity of the system. <p> Thus, the interpretation of this frame is as follows: USER-CONNECT-ACTION [Line 1] is by definition [3] a network action [2] and a call-control-action [2] that is done by a process [4], using the bus-controller [5] on a user <ref> [6] </ref>, and which takes the user from some call state [7] to the talking state [8]. LaSSIE's KB contains 102 action concept descriptions of this type, which are classified into a conceptual hierarchy. Farther down in the hierarchy, the action concepts become very specific. <p> Generic-Call) 7 (has-environment Generic-Call-State) 8 (has-result Talking-State) 9 (implemented-by /Usr/Pgs/Gp/Tgpall/Profum.c) 10 (calls-function Signal-Add-Error-Action) 11 (accesses-variable *Call-Record*)) In other words, Add-User-Action [1] is an action [2] that is performed by the call control process [3] using the bus-controller [4]; its operand is any user [5], and its recipient is a call <ref> [6] </ref>; it takes its operand from any call state [7] to the talking state [8]; it is implemented by the source file /Usr/Pgs/Gp/Tgpall/Profum.c [9], calls the function Signal-Add-Error- Action [10], and uses the global variable *Call-Record* [11]. <p> This is the 13 The retrieved individual is an instance of a CALL-MERGE-ACTION [2] done by the Attd-Monitor process [3], using the System-Fabric-Manager [4] process, which connects one CALL [5] to another <ref> [6] </ref>, leaving both calls in a Talking-State; this action is caused by the attendant pushing a button [9], it is implemented by the source file listed in line 10; it calls the function Signal-Error-Action and uses the global variable *Call-Record* 14 This would be specified by the inclusion of the restriction
Reference: [7] <author> Biggerstaff, T.J., </author> <title> Design Recovery for Maintenance and Reuse, </title> <type> MCC Technical Report STP-378-88, </type> <institution> Austin TX, </institution> <year> 1988 </year>
Reference-contexts: Thus, the interpretation of this frame is as follows: USER-CONNECT-ACTION [Line 1] is by definition [3] a network action [2] and a call-control-action [2] that is done by a process [4], using the bus-controller [5] on a user [6], and which takes the user from some call state <ref> [7] </ref> to the talking state [8]. LaSSIE's KB contains 102 action concept descriptions of this type, which are classified into a conceptual hierarchy. Farther down in the hierarchy, the action concepts become very specific. <p> /Usr/Pgs/Gp/Tgpall/Profum.c) 10 (calls-function Signal-Add-Error-Action) 11 (accesses-variable *Call-Record*)) In other words, Add-User-Action [1] is an action [2] that is performed by the call control process [3] using the bus-controller [4]; its operand is any user [5], and its recipient is a call [6]; it takes its operand from any call state <ref> [7] </ref> to the talking state [8]; it is implemented by the source file /Usr/Pgs/Gp/Tgpall/Profum.c [9], calls the function Signal-Add-Error- Action [10], and uses the global variable *Call-Record* [11]. <p> Various researchers <ref> [ 7; 49; 24 ] </ref> have addressed the task of scanning code automatically and deriving various kinds of information about the function of the code. <p> Letovsky [ 24 ] and Wills [ 49 ] are concerned with recognizing pieces of code that correspond to simple algorithmic fragments, such as loops, accumulations, etc. Bigger-staff <ref> [ 7 ] </ref> attacks a different problem; he seeks to mimic the process by which a programmer experienced in writing, say, device drivers, might scan the code for a new device driver (previously unknown to him/her) and use various clues such as typical variable names, characteristic data structures, etc., to explain
Reference: [8] <author> Borgida, A., Brachman, R. J., Alperin Resnick, L. McGuinness, D. </author> <title> CLASSIC: A Structural Data Model for Objects. </title> <booktitle> Proc. ACM SIGMOD-89, </booktitle> <address> Port-land, OR, May-June, </address> <year> 1989. </year>
Reference-contexts: of this frame is as follows: USER-CONNECT-ACTION [Line 1] is by definition [3] a network action [2] and a call-control-action [2] that is done by a process [4], using the bus-controller [5] on a user [6], and which takes the user from some call state [7] to the talking state <ref> [8] </ref>. LaSSIE's KB contains 102 action concept descriptions of this type, which are classified into a conceptual hierarchy. Farther down in the hierarchy, the action concepts become very specific. The most specific action types, which each correspond to a particular function/source file, 10 are coded as individuals. <p> (accesses-variable *Call-Record*)) In other words, Add-User-Action [1] is an action [2] that is performed by the call control process [3] using the bus-controller [4]; its operand is any user [5], and its recipient is a call [6]; it takes its operand from any call state [7] to the talking state <ref> [8] </ref>; it is implemented by the source file /Usr/Pgs/Gp/Tgpall/Profum.c [9], calls the function Signal-Add-Error- Action [10], and uses the global variable *Call-Record* [11]. It should also be noted here that the KANDOR classification algorithm will ensure that this individual gets classified under the frame USER-CONNECT-ACTION mentioned above.
Reference: [9] <author> Brachman, R., and Devanbu, P., </author> <title> Domain Modeling in a Software Information System, </title> <booktitle> OOPSLA Workshop on Domain Modeling in Software Engineering, 1989, </booktitle> <address> New Orleans, LA. </address>
Reference-contexts: Descriptions that programmers generate and use also reflect this model. As a normal coding practice, many source files in Definity 75/85 include a short one-line description of the function implemented in that source 7 The discussion on ontology is abbreviated here; a longer discussion can be found in <ref> [ 9 ] </ref> . 8 The precise role played by the domain model in the knowledge base is described later, in Section 5.4. file. <p> action [2] that is performed by the call control process [3] using the bus-controller [4]; its operand is any user [5], and its recipient is a call [6]; it takes its operand from any call state [7] to the talking state [8]; it is implemented by the source file /Usr/Pgs/Gp/Tgpall/Profum.c <ref> [9] </ref>, calls the function Signal-Add-Error- Action [10], and uses the global variable *Call-Record* [11]. It should also be noted here that the KANDOR classification algorithm will ensure that this individual gets classified under the frame USER-CONNECT-ACTION mentioned above. <p> This is the 13 The retrieved individual is an instance of a CALL-MERGE-ACTION [2] done by the Attd-Monitor process [3], using the System-Fabric-Manager [4] process, which connects one CALL [5] to another [6], leaving both calls in a Talking-State; this action is caused by the attendant pushing a button <ref> [9] </ref>, it is implemented by the source file listed in line 10; it calls the function Signal-Error-Action and uses the global variable *Call-Record* 14 This would be specified by the inclusion of the restriction (all has-actor (value Attd-Monitor-Process)) in the concept definition of ATTD-CAUSED-ACTION. advantage gained by having an intelligent index.
Reference: [10] <author> Brachman, R.J., and Schmolze, J. G., </author> <title> An overview of the KL-ONE Knowledge Representation System. </title> <journal> Cognitive Science, </journal> <volume> 9 </volume> <pages> 171-216, </pages> <year> 1985. </year>
Reference-contexts: In the case of AIRS and RLF, the representational framework is based on KL-ONE <ref> [ 10 ] </ref> ; the RLF work is based on a similar language called KNET. <p> the call control process [3] using the bus-controller [4]; its operand is any user [5], and its recipient is a call [6]; it takes its operand from any call state [7] to the talking state [8]; it is implemented by the source file /Usr/Pgs/Gp/Tgpall/Profum.c [9], calls the function Signal-Add-Error- Action <ref> [10] </ref>, and uses the global variable *Call-Record* [11]. It should also be noted here that the KANDOR classification algorithm will ensure that this individual gets classified under the frame USER-CONNECT-ACTION mentioned above.
Reference: [11] <author> Brooks, F. P., </author> <title> No Silver Bullet: </title> <journal> Essence and Accidents of Software Engineering, IEEE Computer Magazine, </journal> <month> April, </month> <year> 1987. </year>
Reference-contexts: 1 Introduction The growing cost of software development, particularly in larger systems, is well documented. Efforts at containing this growth have met with limited success. In his classic paper, "No Silver Bullet" <ref> [ 11 ] </ref> , Brooks attempts to explain this; he argues that existing developments in software engineering, such as high-level languages, timesharing and integrated programming environments have overcome certain accidental difficulties in the software development process; certain other problems, that are the essence of the software process, still remain. <p> The design of the AT&T Definity 75/85 is a good example of this. Unfortunately, the structure and principles underlying large systems are invisible; there is no clear presentation of the architecture for programmers to examine, and thus to honor, as they extend the system. In <ref> [ 11 ] </ref> , Brooks points out that in civil engineering, geometric abstractions such as scale drawings and stick-figure models capture the essence of the design for everyone involved in a large construction project. <p> one, but several graphs superimposed one upon another. 2 These graphs represent the flow of control, the flow of data, patterns of dependency, time sequence, name-space relationships. : : : In spite of the progress in restricting and simplifying the structures of software, they remain essentially unvisualizable: : : " <ref> [ 11 ] </ref> 2 Brooks suggests that software must be understood from multiple points of view (we amplify this below, in Section 3.) Invisibility is thus an inherent property of large software projects; programmers find it difficult to get needed information. <p> bus-controller [4]; its operand is any user [5], and its recipient is a call [6]; it takes its operand from any call state [7] to the talking state [8]; it is implemented by the source file /Usr/Pgs/Gp/Tgpall/Profum.c [9], calls the function Signal-Add-Error- Action [10], and uses the global variable *Call-Record* <ref> [11] </ref>. It should also be noted here that the KANDOR classification algorithm will ensure that this individual gets classified under the frame USER-CONNECT-ACTION mentioned above. It is this kind of classification that organizes the large number of frames and individuals in LaSSIE into a usable form.
Reference: [12] <author> Chen, Y.-F., M. Nishimoto, and C.V. Ramamoor-thy, </author> <title> The C Information Abstraction System, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> March, </month> <year> 1990. </year>
Reference-contexts: They seem to fall into three main categories: relational code analyzers, project management databases, and reuse librarians. 4.1 Relational Code Analyzers Relational Code Analyzers (RCA's) such as Master-Scope [ 47 ] , CScope [ 46 ] , and CIA <ref> [ 12 ] </ref> derive certain code-level relationships (such as function-calls-function, function-uses-variable, etc.) directly from source code. This information is generally stored in a relational database. One can query this database using a typical relational language.
Reference: [13] <author> Curtis, W., </author> <title> Cognitive Issues in Reusing Software Artifacts, in Vol II, Software Reusability, </title> <editor> T. J. Big-gerstaff and A. J. Perlis, Editors, </editor> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Curtis argues: "The effective use of a reusable library will require an indexing scheme similar to the knowl 6 We defer this discussion until after we have described our classification-based knowledge representation technique and its application in LaSSIE. edge structures possessed by most program mers working in an application area". <ref> [ 13 ] </ref> Thus, a library of reusable components within a large system needs an intelligent indexing scheme that includes specific knowledge about the architecture within which these components are embedded. <p> Both Neigh-bours [ 29 ] and Prieto-Diaz [ 36 ] suggest a model based on objects and actions. Our KB is concerned with storing knowledge about a large software system, and using this knowledge as an index into a library of reusable components. As Cur-tis <ref> [ 13 ] </ref> suggests, the way programmers think about the system is an important determinant of the structure of the KB. Shneiderman [ 40 ] has conducted empirical studies of programmers, and developed a syntactic/semantic model of programming knowledge. <p> Without classification, the knowledge engineer would have to figure out the proper placement by hand| a daunting task with such a large knowledge base. Thus, classification plays a crucial role in assembling the taxonomic KB that provides intelligent indexing, as called for by Curtis <ref> [ 13 ] </ref> . Constructing a very large KB in the KL-ONE style language used in AIRS and RLF would be easier with a classifier. Unfortunately, because of the power of KL-ONE [ 39 ] , a complete classification algorithm is impossible.
Reference: [14] <author> Curtis, W., Krasner, H., and Iscoe, N., </author> <title> A Field Study of the Software Design Process for Large Systems, </title> <journal> Communications of the ACM, </journal> <volume> 31(11), Novem-ber, </volume> <year> 1988. </year>
Reference-contexts: It has various causes: a large, complex (perhaps even inconsistent) set of requirements, long system lifetimes (due to prohibitive costs of redevelopment), difficulties in interpersonal and interorga-nizational relationships (see <ref> [ 14 ] </ref> for a comprehensive survey), etc. For a descriptive analysis of the nature of complexity in large software systems, see Perry [ 35 ] . <p> Field studies by Curtis, Krasner and Iscoe <ref> [ 14 ] </ref> have shown that programmers by and large fail to develop this kind of understanding; they talk about the problem of "thin spread of application domain knowledge".
Reference: [15] <author> Devanbu, P., and Litman, D. </author> <title> A Plan and Scenario Classification System, </title> <institution> AT&T Bell Laboratories Technical Report, </institution> <year> 1990. </year>
Reference-contexts: We have built a plan classification system <ref> [ 15 ] </ref> to experiment with various relationships that can be defined between plans, and inference algorithms that can derive these relationships. 8.2 Knowledge Acquisition We have discussed how the invisibility problem can be addressed by properly storing and retrieving knowledge of various kinds about the architecture of a system.
Reference: [16] <author> Devanbu, P., Brachman, R., and Selfridge, P., </author> <title> Inference in Support of Retrieval for Reuse in Large Software Systems, </title> <booktitle> IEEE/SPS Workshop on Software Reuse, 1989, </booktitle> <address> Indialantic, FL. </address>
Reference-contexts: Proper knowledge of the system could have prevented this. Thus, we would like to build into our system a library of reusable parts, along with a helpful access mechanism. These points are discussed in more detail in <ref> [ 16 ] </ref> . In this section, we have described the problem of invisibility and its deleterious effects.
Reference: [17] <author> Doyle, J. and Patil, R. S., </author> <title> Language Restrictions, Taxonomic Classification, and the Utility of Representation Services. </title> <note> MIT/LCS/Technical Memo 387, </note> <year> 1989. </year>
Reference: [18] <author> Embley, D.W., and Woodfield, S. N., </author> <title> A Knowledge Structure for Re-Using Abstract Data Types, </title> <booktitle> Proceedings, Ninth Annual Software Engineering Conference, 1987, </booktitle> <address> Monterey, CA. </address>
Reference-contexts: Additionally, the representation scheme used here is rather weak; one cannot express constraints (e.g., "password files can only be changed by a process with root privileges.") in this faceted language. The abstract data-type (ADT) library proposed by Embley and Woodfield <ref> [ 18 ] </ref> uses aspects of faceted indexing as well as keywords|they propose a software library consisting of a collection of general purpose ADT's, each with a special descriptor. The descriptor includes facets such as Domain and Operations; it lists several aliases, and descriptive keywords.
Reference: [19] <author> Fischer, G., and Schneider, M., </author> <booktitle> Knowledge-Based Communication Processes in Software Engineering, Proceedings, Seventh International Software Engineering Conference, </booktitle> <address> Orlando, FL, </address> <year> 1984. </year>
Reference-contexts: Thus, a KB describing the architecture in these terms could serve as a common baseline of information for all developers; such a view has also been advocated by Fischer and Schneider <ref> [ 19 ] </ref> . Descriptions that programmers generate and use also reflect this model.
Reference: [20] <author> Frakes, W. B., and Nejmeh, B. A., </author> <title> An Information System for Software Reuse, </title> <booktitle> Proceedings of the Tenth Minnowbrook Workshop on Software Reuse, p. </booktitle> <pages> 142-151, </pages> <year> 1987. </year>
Reference-contexts: A variety of libraries and retrieval methods are available. The retrieved components can either be directly reused, or adapted as necessary. The retrieval mechanisms in these systems are usually one of three types: keyword, faceted-index, or semantic-net. CATALOG <ref> [ 20 ] </ref> is an example of the keyword-based approach typical of standard information retrieval systems.
Reference: [21] <author> Horowitz, E., and Williamson, R. </author> <title> SODOS A Software Documentation Support Environment: Its Use, </title> <booktitle> Eighth International Conference on Software Engineering, </booktitle> <address> London, UK, </address> <year> 1985. </year>
Reference-contexts: The information system is based on the entity-relationship model to characterize the artifacts and activities of a software project, with their attributes and inter-relationships. Another example is the SODOS system <ref> [ 21 ] </ref> , which is intended to "support the definition and manipulation of documents" used in developing software. For this purpose, source code files are considered documents. Features include the management of documentation templates and cross-indexing documents based on their life cycle interrelationships 5 .
Reference: [22] <author> Huff, K. E., </author> <title> Software Process Instantiation and the Planning Paradigm, </title> <booktitle> Proceedings of the Fifth International Software Process Workshop, </booktitle> <address> Kenneb-unkport, ME, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Knowledge about the software process, that is, information about the tools and methods used in development, which is not currently available in LaSSIE, could also be stored as plan knowledge (see Huff <ref> [ 22 ] </ref> for a plan-based approach to software process representation).
Reference: [23] <author> Johnson, W., and Soloway, E., </author> <title> PROUST: Knowledge-Based Program Understanding, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> March, </month> <year> 1981. </year>
Reference: [24] <author> Letovsky, S., </author> <title> Plan Analysis of Programs, </title> <type> Ph.D. Thesis, </type> <institution> Yale University, </institution> <address> New Haven, CT, </address> <year> 1988. </year>
Reference-contexts: Various researchers <ref> [ 7; 49; 24 ] </ref> have addressed the task of scanning code automatically and deriving various kinds of information about the function of the code. <p> Various researchers [ 7; 49; 24 ] have addressed the task of scanning code automatically and deriving various kinds of information about the function of the code. Letovsky <ref> [ 24 ] </ref> and Wills [ 49 ] are concerned with recognizing pieces of code that correspond to simple algorithmic fragments, such as loops, accumulations, etc.
Reference: [25] <author> Letovsky, S., </author> <booktitle> Cognitive Processes in Program Comprehension in Proceedings of the Second Workshop on Empirical Studies of Programmers, </booktitle> <editor> E. Soloway and S. Iyengar, Editors, </editor> <publisher> Ablex Publishers, </publisher> <address> Nor-wood, NJ, </address> <year> 1986. </year>
Reference-contexts: There is a considerable body of literature linking plan knowledge to the cognitive processes involved in software design/development. Soloway, et al., [ 44; 43; 42 ] have established the importance of plans in programming knowledge; Letovsky <ref> [ 26; 25 ] </ref> has shown that plans are important for program comprehension and 16 e.g., transitive closure over causality 17 e.g., relating the result post-condition of one action to the environment pre-condition of another 18 Establishing the context or rationale for an action inspection.
Reference: [26] <author> Letovsky, S., Pinto, J., Lampert, R., and Soloway, E., </author> <title> A Cognitive analysis of a Code Inspection, </title> <booktitle> in Proceedings of the Second Workshop on Empirical Studies of Programmers, </booktitle> <address> Washington, </address> <publisher> DC, </publisher> <editor> E. Soloway and S. Iyengar, Editors, </editor> <publisher> Ablex Publishers, </publisher> <address> Norwood, NJ, </address> <year> 1986. </year>
Reference-contexts: There is a considerable body of literature linking plan knowledge to the cognitive processes involved in software design/development. Soloway, et al., [ 44; 43; 42 ] have established the importance of plans in programming knowledge; Letovsky <ref> [ 26; 25 ] </ref> has shown that plans are important for program comprehension and 16 e.g., transitive closure over causality 17 e.g., relating the result post-condition of one action to the environment pre-condition of another 18 Establishing the context or rationale for an action inspection.
Reference: [27] <author> Levesque, H. J., and Brachman, R. J., </author> <title> Expressiveness and Tractability in Knowledge Representation and Reasoning. </title> <journal> Computational Intelligence, </journal> <volume> 3 </volume> <pages> 78-93, </pages> <year> 1987. </year>
Reference: [28] <author> Modica, L. </author> <type> Personal Communication, </type> <year> 1989. </year>
Reference-contexts: This phenomenon has recently been the subject of study at AT&T Bell Laboratories <ref> [ 28 ] </ref> and elsewhere [ 44 ] . Modica [ 28 ] has called this the discovery task. Discovery has impacts on both productivity and quality of the software produced. <p> This phenomenon has recently been the subject of study at AT&T Bell Laboratories <ref> [ 28 ] </ref> and elsewhere [ 44 ] . Modica [ 28 ] has called this the discovery task. Discovery has impacts on both productivity and quality of the software produced.
Reference: [29] <author> Neighbors, J., </author> <title> Software Construction using Components, </title> <type> Ph.D. Thesis, </type> <institution> University of California, </institution> <address> Irvine, CA, </address> <year> 1981. </year>
Reference-contexts: Our choice was influenced by three different factors: existing work in the field of Domain Analysis, empirical studies of programming knowledge, and vocabulary used by programmers in Definity 75/85 7 . Reverse knowledge engineering is closely related to the notion of Domain Analysis <ref> [ 2; 36; 29 ] </ref> . <p> Despite the differences, the result of both kinds of analyses includes a description of a set of components. Thus the terminology used by domain analysts to describe the results of their efforts is pertinent to a reverse knowledge engineering effort. Both Neigh-bours <ref> [ 29 ] </ref> and Prieto-Diaz [ 36 ] suggest a model based on objects and actions. Our KB is concerned with storing knowledge about a large software system, and using this knowledge as an index into a library of reusable components.
Reference: [30] <author> Ostertag, E., and Hendler, J.A. AIRS: </author> <title> An AI-based Ada Reuse System. </title> <type> Technical Report CS-TR 2197, </type> <institution> Computer Science Center, University of Maryland, </institution> <year> 1987. </year>
Reference-contexts: Unfortunately, these derivations are not inferences, in the sense that they are not formally defined, or based on semantics. The AIRS <ref> [ 30 ] </ref> system, and other semantic-net based systems such as that of Woods and Somerville [ 50 ] , and the RLF [ 41 ] work at UNISYS, all provide some version of structural representation of knowledge. <p> We can now compare our work to the other semantic-net reuse library systems listed in Section 4.3. RLF does not have a built-in classifier; the KNET language is used to describe the components, and the retrieval/browsing algorithm is left to the application developer. The AIRS <ref> [ 30 ] </ref> system uses a heuristic retrieval algorithm based on a numerical "conceptual-distance" measure, which the user has to specify. Woods and Somerville use conceptual dependency (CD) diagrams. Their query mechanism is based on a set of verbs.
Reference: [31] <author> Parnas, </author> <title> D.L Designing Software for Ease of Extension and Construction, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol SE-5, No. 2, </volume> <month> March, </month> <year> 1979. </year>
Reference-contexts: These are generally experienced designers and architects who have considerable exposure to the application domain; they have a deep understanding of the relationship between the needs of the domain and the design rationale. The initial architecture often structures a system in a "virtual machine" (VM) style <ref> [ 31 ] </ref> : the system is implemented as a layered set of VM's, each VM implementing reusable primitives for the VM's above it. These primitives have a simple, well-defined relationship to the needs of the application domain.
Reference: [32] <author> Patel-Schneider, P. F., </author> <title> Small can be Beautiful in Knowledge Representation. </title> <booktitle> In Proc. IEEE Workshop on Principles of Knowledge-Based Systems, </booktitle> <address> Denver, </address> <month> December, </month> <year> 1984, </year> <note> Extended version appears as AI Technical Report No. 37, </note> <institution> Schlumberger Palo Alto Research, </institution> <address> Palo Alto, CA, </address> <month> October, </month> <year> 1984, </year> <pages> pp. 11-16. </pages>
Reference-contexts: The KB is built using a classification-based knowledge representation language, KANDOR <ref> [ 32 ] </ref> , to provide semantic retrieval. Besides serving as a repository of information about the system, the KB serves as an intelligent index for reusable components. LaSSIE also provides a user interface with a graphical browser and a natural language query processing system. <p> In this style of representation, frames represent classes of objects; they do so in an "object-centered" way, by clustering all information about a given object in one place. In KAN-DOR <ref> [ 32 ] </ref> , our language, a frame is considered a complex description, which expresses constraints on members of the class that it denotes.
Reference: [33] <author> Patel-Schneider, P. F., Brachman, R. J., and Levesque, H. J. Argon: </author> <title> Knowledge Representation meets Information Retrieval. </title> <booktitle> In Proc. First Conference on Artificial Intelligence Applications, </booktitle> <year> 1984, </year> <pages> pp. 280-286. </pages>
Reference-contexts: LaSSIE also has an interactive graphical user interface that includes a modified version of the ARGON <ref> [ 33 ] </ref> system, and the ISI-Grapher [ 38 ] . In this section, we present examples that illustrate how the retrieval system works. The core of the retrieval system is the classification algorithm; it simplifies the task of querying a large knowledge base. <p> For example, the following individual would be retrieved by the above query: 1 (define individual Attd-Merge-Call-Action 2 (CALL-MERGE-ACTION ATTD-CAUSED-ACTION) 3 (has-actor Attd-Monitor-Process) 4 (has-agent System-Fabric-Manager-Process) 5 (has-operand Generic-Call) 6 (has-recipient Generic-Call) 7 (has-environment Generic-Call-State) 12 The actual query language in ARGON <ref> [ 33 ] </ref> , the system that LaSSIE is based on, includes negation, disjunction, etc; we illustrate just a simple query here. 8 (has-result Talking-State) 9 (has-cause Attd-Button-Push) 10 (implemented-by /Src/Ugp/Attd/Atd-Au-Im.c) 11 (calls-function Signal-Error-Action) 12 (accesses-variable *Call-Record*)) The advantages of semantic retrieval are illustrated in this example 13 .
Reference: [34] <author> Penedo, Maria H. </author> <title> Prototyping a Project Master Database for Software Engineering Environments. </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> Palo Alto, CA, </address> <month> Decem--ber </month> <year> 1986. </year>
Reference-contexts: They are intended to provide database support for all lifecycle activities, beginning with requirements specification right through to system test. PMDB <ref> [ 34 ] </ref> is a typical example of such a system. It aims to collect almost all of the information about a project into one central information system, which can be queried and updated.
Reference: [35] <author> Perry, D. E., </author> <title> Industrial Strength Software Development Environments, </title> <booktitle> Proceedings of IFIP Congress '89, The 11th World Computer Congress, August/September, 1989, </booktitle> <address> San Francisco CA. </address>
Reference-contexts: For a descriptive analysis of the nature of complexity in large software systems, see Perry <ref> [ 35 ] </ref> . For our purposes, it is instructive to consider how invisibility and complexity interact in large systems. 2.1 Invisibility and the Evolution of Complexity In many cases, the initial design and architecture of a system is derived after careful analysis of the requirements.
Reference: [36] <author> Prieto-Diaz, R. </author> <title> Domain Analysis for Reusability, </title> <booktitle> Proceedings IEEE COMPSAC-87, </booktitle> <address> Tokyo, Japan, </address> <month> October, </month> <year> 1987. </year>
Reference-contexts: Our choice was influenced by three different factors: existing work in the field of Domain Analysis, empirical studies of programming knowledge, and vocabulary used by programmers in Definity 75/85 7 . Reverse knowledge engineering is closely related to the notion of Domain Analysis <ref> [ 2; 36; 29 ] </ref> . <p> Despite the differences, the result of both kinds of analyses includes a description of a set of components. Thus the terminology used by domain analysts to describe the results of their efforts is pertinent to a reverse knowledge engineering effort. Both Neigh-bours [ 29 ] and Prieto-Diaz <ref> [ 36 ] </ref> suggest a model based on objects and actions. Our KB is concerned with storing knowledge about a large software system, and using this knowledge as an index into a library of reusable components. <p> call," "Translate the dialled digits," and "Display a number on the Attendant's console." These key primitive building blocks are combined and sequenced in various ways to implement the customer features; the descriptions of these operations, with their operands and precise effects constitute the "domain model" (in the spirit of Prieto-Diaz <ref> [ 36 ] </ref> ) of the PBX switching features supported by the Definity 75/85.
Reference: [37] <author> Prieto-Diaz, R. and Freeman, P., </author> <title> Classifying Software for Reusability, </title> <booktitle> IEEE Software 4: </booktitle> <pages> 6-16, </pages> <address> Jan-uary, </address> <year> 1987. </year>
Reference-contexts: Given the size of software systems, and the variety of naming styles, it is important for a library of reusable components of a large system to provide semantic retrieval, i.e., retrieval based on meaning. The classification and retrieval library scheme suggested by Prieto-Diaz and Freeman <ref> [ 37 ] </ref> involves the construction of a domain model and its subsequent use in query formulation/reformulation. In their paper, Prieto-Diaz and Freeman developed a taxonomic domain model for the set of data operations embodied in a library of software components, categorized along different facets.
Reference: [38] <author> Robins, G., </author> <title> The ISI Grapher Manual, </title> <institution> University of Southern California Information Sciences Institute, </institution> <note> Technical Manual ISI/TM-88-197, </note> <month> February, </month> <year> 1988. </year>
Reference-contexts: LaSSIE also has an interactive graphical user interface that includes a modified version of the ARGON [ 33 ] system, and the ISI-Grapher <ref> [ 38 ] </ref> . In this section, we present examples that illustrate how the retrieval system works. The core of the retrieval system is the classification algorithm; it simplifies the task of querying a large knowledge base.
Reference: [39] <author> Schmidt-Schauss, M., </author> <title> Subsumption in KL-ONE is Undecidable, </title> <booktitle> Proceedings, First International Conference on Principles of Knowledge Representation and Reasoning, 1989, </booktitle> <address> Toronto, Canada. </address>
Reference-contexts: Constructing a very large KB in the KL-ONE style language used in AIRS and RLF would be easier with a classifier. Unfortunately, because of the power of KL-ONE <ref> [ 39 ] </ref> , a complete classification algorithm is impossible. The CD diagrams used in Woods and Somerville do not have a taxonomic organization; the matching is done by keyword associations.
Reference: [40] <author> Shneiderman, B., </author> <title> Empirical Studies of Programmers, </title> <booktitle> in in Proceedings of the Second Workshop on Empirical Studies of Programmers, </booktitle> <editor> E. Soloway and S. Iyengar, Editors, </editor> <publisher> Ablex Publishers, </publisher> <address> Norwood, NJ, </address> <year> 1986. </year>
Reference-contexts: Our KB is concerned with storing knowledge about a large software system, and using this knowledge as an index into a library of reusable components. As Cur-tis [ 13 ] suggests, the way programmers think about the system is an important determinant of the structure of the KB. Shneiderman <ref> [ 40 ] </ref> has conducted empirical studies of programmers, and developed a syntactic/semantic model of programming knowledge. The syntactic part is mainly the structural details of the programming language itself. For the semantic part, he proposes a cognitive model based on the action-object paradigm.
Reference: [41] <author> Solderitsch, J., Wallnau, K., Thalhamer, J., </author> <title> Constructing Domain-Specific Ada Reuse Libraries, </title> <booktitle> Proceedings, Seventh Annual National Conference on ADA Technology, </booktitle> <address> March, 1989, Atlantic City, NJ. </address>
Reference-contexts: Unfortunately, these derivations are not inferences, in the sense that they are not formally defined, or based on semantics. The AIRS [ 30 ] system, and other semantic-net based systems such as that of Woods and Somerville [ 50 ] , and the RLF <ref> [ 41 ] </ref> work at UNISYS, all provide some version of structural representation of knowledge. In the case of AIRS and RLF, the representational framework is based on KL-ONE [ 10 ] ; the RLF work is based on a similar language called KNET. <p> In all of the systems mentioned above, with the exception of <ref> [ 41 ] </ref> , the languages can be used to specify mere associations; they are not intended to specify constraints.
Reference: [42] <author> Soloway, E., </author> <title> Learning to Program = Learning to Construct Mechanisms and Explanations, </title> <journal> Communications of the ACM, </journal> <volume> 29(9), </volume> <year> 1986. </year>
Reference-contexts: There is a considerable body of literature linking plan knowledge to the cognitive processes involved in software design/development. Soloway, et al., <ref> [ 44; 43; 42 ] </ref> have established the importance of plans in programming knowledge; Letovsky [ 26; 25 ] has shown that plans are important for program comprehension and 16 e.g., transitive closure over causality 17 e.g., relating the result post-condition of one action to the environment pre-condition of another 18
Reference: [43] <author> Soloway, E., and Ehrlich, </author> <title> K. </title> <journal> Empirical Studies of Programming Knowledge IEEE Transactions on Software Engineering, </journal> <volume> Vol SE-10, No. 5, </volume> <month> September, </month> <year> 1984. </year>
Reference-contexts: In two different studies, Soloway, Adelson, and Ehrlich showed how a lack of knowledge affects the quality of the results in design tasks [ 1 ] and in small programming-related tasks <ref> [ 43 ] </ref> . Without proper knowledge of the architecture of the system, developers can make mistakes and produce incorrectly functioning code. In large systems, the impact of poor discovery is of a different form, but much more insidious. <p> There is a considerable body of literature linking plan knowledge to the cognitive processes involved in software design/development. Soloway, et al., <ref> [ 44; 43; 42 ] </ref> have established the importance of plans in programming knowledge; Letovsky [ 26; 25 ] has shown that plans are important for program comprehension and 16 e.g., transitive closure over causality 17 e.g., relating the result post-condition of one action to the environment pre-condition of another 18
Reference: [44] <author> Soloway, E., Pinto, J., Letovsky, S., Littman, D., and Lampert, R. </author> <title> Designing Documentation to Compensate for De-localized Plans, </title> <journal> Communications of the ACM, </journal> <volume> 31(11), </volume> <month> November, </month> <year> 1988. </year>
Reference-contexts: This phenomenon has recently been the subject of study at AT&T Bell Laboratories [ 28 ] and elsewhere <ref> [ 44 ] </ref> . Modica [ 28 ] has called this the discovery task. Discovery has impacts on both productivity and quality of the software produced. <p> Thus, discovery adversely impacts a developer's productivity. The quality impact of discovery arises from a developer's action upon incorrect or insufficient information. Soloway et al., in <ref> [ 44 ] </ref> , document cases (actually in a very small task) where programmers made mistakes when they used documentation that presented information in one way, and not when it presented information in another form. <p> There is a considerable body of literature linking plan knowledge to the cognitive processes involved in software design/development. Soloway, et al., <ref> [ 44; 43; 42 ] </ref> have established the importance of plans in programming knowledge; Letovsky [ 26; 25 ] has shown that plans are important for program comprehension and 16 e.g., transitive closure over causality 17 e.g., relating the result post-condition of one action to the environment pre-condition of another 18
Reference: [45] <author> Smoliar, S.W., and Swartout, W., </author> <title> A Report from the Frontiers of Knowledge Representation, </title> <type> Draft Manuscript, </type> <institution> USC/ISI, </institution> <year> 1988. </year>
Reference: [46] <author> J.L. Steffen, </author> <title> "Interactive examination of a C program with Cscope", </title> <booktitle> Proc. USENIX Assoc. winter Conference, </booktitle> <month> Jan, </month> <year> 1985. </year>
Reference-contexts: They seem to fall into three main categories: relational code analyzers, project management databases, and reuse librarians. 4.1 Relational Code Analyzers Relational Code Analyzers (RCA's) such as Master-Scope [ 47 ] , CScope <ref> [ 46 ] </ref> , and CIA [ 12 ] derive certain code-level relationships (such as function-calls-function, function-uses-variable, etc.) directly from source code. This information is generally stored in a relational database. One can query this database using a typical relational language. <p> The domain model and its relationship to the architecture of the system is built manually into the LaSSIE knowledge base. In addition to this, we also capture the code view of the system, which is, happily, mostly automatically derived, using CScope <ref> [ 46 ] </ref> , as described below. 5.5 Integrating Code-level Information We enhanced the conceptual action-object-actor level of representation with certain simple but important code-level relationships such as function-calls-function, sourcefile-includes-headerfile, etc., which are syntactically derived by scanning the code.
Reference: [47] <author> Teitelman, W., </author> <title> The INTERLISP Reference Manual, </title> <type> Bolt, </type> <institution> Beranek and Newman, </institution> <year> 1974. </year> <note> Section 20 describes MasterScope, which was written by L. M. Masinter. </note>
Reference-contexts: They seem to fall into three main categories: relational code analyzers, project management databases, and reuse librarians. 4.1 Relational Code Analyzers Relational Code Analyzers (RCA's) such as Master-Scope <ref> [ 47 ] </ref> , CScope [ 46 ] , and CIA [ 12 ] derive certain code-level relationships (such as function-calls-function, function-uses-variable, etc.) directly from source code. This information is generally stored in a relational database. One can query this database using a typical relational language.
Reference: [48] <author> Van Lamsveerde, A., Delcourt, B., Delor, E., Schayes, M-C., and Champagne, R., </author> <title> Generic Life-cycle Support in the ALMA environment, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(6), </volume> <month> June </month> <year> 1988. </year>
Reference-contexts: For this purpose, source code files are considered documents. Features include the management of documentation templates and cross-indexing documents based on their life cycle interrelationships 5 . There is a query-by-example retrieval mechanism which combines the use of relations such as "implemented-by" with keyword matching. ALMA <ref> [ 48 ] </ref> is a generic (or meta-level) kernel that can be used to implement customized database support for a variety of software engineering environments.
Reference: [49] <author> Wills, L.M., </author> <title> Automated Program Recognition, </title> <type> MIT Technical Report 904, </type> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: Various researchers <ref> [ 7; 49; 24 ] </ref> have addressed the task of scanning code automatically and deriving various kinds of information about the function of the code. <p> Various researchers [ 7; 49; 24 ] have addressed the task of scanning code automatically and deriving various kinds of information about the function of the code. Letovsky [ 24 ] and Wills <ref> [ 49 ] </ref> are concerned with recognizing pieces of code that correspond to simple algorithmic fragments, such as loops, accumulations, etc.
Reference: [50] <author> Woods, M., and Somerville, I., </author> <title> An Information System for Software Components, </title> <booktitle> ACM SIGIR Forum, </booktitle> <address> 22:3, Spring/Summer, </address> <year> 1988. </year>
Reference-contexts: Unfortunately, these derivations are not inferences, in the sense that they are not formally defined, or based on semantics. The AIRS [ 30 ] system, and other semantic-net based systems such as that of Woods and Somerville <ref> [ 50 ] </ref> , and the RLF [ 41 ] work at UNISYS, all provide some version of structural representation of knowledge.
References-found: 50

