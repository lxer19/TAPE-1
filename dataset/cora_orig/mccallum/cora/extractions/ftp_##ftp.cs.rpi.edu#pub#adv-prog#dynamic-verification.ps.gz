URL: ftp://ftp.cs.rpi.edu/pub/adv-prog/dynamic-verification.ps.gz
Refering-URL: http://www.cs.rpi.edu/~musser/Tecton/
Root-URL: http://www.cs.rpi.edu
Email: E-Mail: cwang@gte.com.  
Title: Dynamic Verification of C++ Generic Algorithms  
Author: Changqing Wang and David R. Musser 
Keyword: Key Words and Phrases: Specification, verification, generic algorithms, software libraries, C++, templates, Standard Template Library.  
Note: Present address:  
Address: Troy, NY 12180  40 Sylvan Road, Waltham MA 02254,  
Affiliation: Computer Science Department Rensselaer Polytechnic Institute  GTE Labs Inc., Software Systems Lab,  
Abstract: Dynamic verification is a new approach to formal verification, applicable to generic algorithms such as those found in the Standard Template Library (STL, part of the Draft ANSI/ISO C++ Standard Library). Using behavioral abstraction and symbolic execution techniques, verifications are carried out at a meta-level such that the results can be used in a variety of instances of the generic algorithms without repeating the proofs. This is achieved by substituting for type parameters of generic algorithms special data types that model generic concepts by accepting symbolic inputs and deducing outputs using inference methods. By itself, this symbolic execution technique supports testing of programs with symbolic values at a meta-level. For formal verification we also need to generate multiple program execution paths and use assertions (to handle while loops, for example), but we show how this can be achieved via directives to a conventional debugger program and an analysis database. The assertions must still be supplied, but they can be packaged separately and evaluated as needed by appropriate transfers of control orchestrated via the debugger. Unlike all previous verification methods, the dynamic verification method thus works without having to transform source code or process it with special interpreters. We include an example of the formal verification of an STL generic algorithm. fl Partially supported by National Science Foundation Grant Number CCR-9308016 and subcontract CB0204 of SRI Contract MDA904-92-C-5186 with The Maryland Procurement Office. This is an expanded version of "Dynamic Verification of C++ Generic Components: A Practical Method and Its Support System," Proc. Formal Methods in Software Practice, San Diego, CA, January 10-11, 1996. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. S. Boyer, B. Elspas, K. N. Levitt, </author> <title> "SELECT|A Formal System for Testing and Debugging Programs by Symbolic Execution," </title> <booktitle> Proc. of the International Conference on Reliable Software, </booktitle> <month> April </month> <year> 1975. </year>
Reference-contexts: For example, int a [100], double b [100]; // ... code to initialize array a // Call 1: copy all of array a to array b: copy (&a [0], &a [100], &b [0]); // Call 2: shift a <ref> [1] </ref>,...,a [99] left one position: copy (&a [1], &a [100], &a [0]); // Call 3: shift b [10],...,b [19] left ten positions: copy (&b [10], &b [20], &b [0]); // Call 4: copy a [0],...,a [9] to a [10],...,a [19]: copy (&a [0], &a [10], &a [10]); Based on these calls three different instances of the copy algorithm
Reference: [2] <author> D. Evans, J. Guttag, J. Horning, and Y.M. Tan, "LCLint: </author> <title> A Tool for Using Specifications to Check Code," </title> <booktitle> Proc. POPL Workshop on Interface Definition Lang, </booktitle> <address> Portland, Oregon, </address> <month> Jan. </month> <year> 1994. </year>
Reference: [3] <author> P. Fritzson, M. Auguston, N. Shahmehri, </author> <title> "Using Assertions in Declarative and Operational Models for Automated Debugging," </title> <journal> Journal Of Systems and Software, </journal> <volume> vol. 6, no. 3, </volume> <year> 1994. </year>
Reference: [4] <author> Norbert E. Fuchs, </author> <title> "Specifications Are (Preferably) Executable," </title> <journal> Software Engineering Journal, </journal> <month> September </month> <year> 1992. </year>
Reference-contexts: It is based on constructive (executable) specifications consisting of a set of axioms and inference rules. The IEs used in this paper are derived, in a way similar to that described in <ref> [4] </ref>, from a set of Tecton concept specifications, which are not necessarily constructive. An IE usually consists of several parts. The interface is a set of functions that receive queries and commands from clients and send results back to clients.
Reference: [5] <editor> D. Gries, </editor> <booktitle> The Science of Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: operation might be coded as a template function in C++: template &lt;class T, class U&gt; 1 Although the use of symbolic execution in software verification goes back to some of the earliest program verification systems [11, 12, 13], and forward assignment axioms are sometimes mentioned in the literature (e.g., see <ref> [5, p. 120] </ref>), we are not aware of any axiomatic system with this approach as its basis. 2 U* copy (T* first, T* last, U* r) - while (f != last) *result++ = *first++; return result; - Instances of this algorithm can be created using any types T and U such
Reference: [6] <author> John V. Guttag, James J. Horning et al, </author> <title> Larch: Languages and Tools for Formal Specification. </title> <address> Spring-Verlag. </address> <year> 1993. </year>
Reference-contexts: We organize the part of the symbolic execution method that deals with types into a library of RAOs. Each RAO has two distinct levels, which we call the interface level and the inference level, a structure similar to that of Larch specifications <ref> [6, 31] </ref>. The major difference is that Larch specifications do not have to be executable, but that is a requirement for dynamic verification. <p> In our dynamic verification system, a program (segment) is specified by describing its precondition state and post-condition state. Like Larch specifications <ref> [6, 31] </ref>, specifications for dynamic verification are two-tiered. The interface specifications, which consist of assertions about program states, make up one tier. The abstract concept specifications that define the semantics of symbolic values and primitive concepts, on which the assertions depend, constitute the other tier.
Reference: [7] <author> C.A.R. Hoare, </author> <title> "An Axiomatic Basis for Computer Programming," </title> <journal> Comm. ACM, </journal> <volume> Vol. 12, No. 10, </volume> <month> October </month> <year> 1969, </year> <pages> 576-583. </pages>
Reference-contexts: The logical foundation for the way dynamic verification deals with imperative program constructs (e.g., assignment, conditional, and loop statements) is based on axioms and inference rules similar in spirit to Hoare's axiomatic approach <ref> [7] </ref> but different in important details.
Reference: [8] <author> D. Kapur and D. R. Musser, Tecton: </author> <title> a framework for specifying and verifying generic system components, </title> <institution> Rensselaer Polytechnic Institute Computer Science Technical Report 92-20, </institution> <month> July, </month> <year> 1992. </year>
Reference-contexts: In the next section, we show how to formally capture and represent the semantic properties common to all the data types that can be used to replace type parameters (such as InputIterator and OutputIterator) of a generic algorithm. 3 Overview of Tecton Concept Specifications Tecton <ref> [8, 9, 10] </ref> is a specification language for describing and using abstract concepts in formal software development and hardware design. One of the main goals of Tecton is to reduce the need for proof. Tecton achieves this goal by supporting behavioral abstraction and data abstraction as well. <p> For an explanation of the other kinds of Tecton statements, see <ref> [8] </ref>. 4 Abstract Implementations Unless it contains a generates-clause, a Tecton concept definition does not necessarily define a single abstract data type or even a set of isomorphic abstract data types.
Reference: [9] <author> D. Kapur, D. R. Musser, and A. A. Stepanov, "Tecton, </author> <title> A Language for Manipulating Generic Objects" Proc. </title> <booktitle> of Workshop on Program Specification, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1981, </year> <note> LNCS, vol. 134, </note> <year> 1982. </year>
Reference-contexts: to array b: copy (&a [0], &a [100], &b [0]); // Call 2: shift a [1],...,a [99] left one position: copy (&a [1], &a [100], &a [0]); // Call 3: shift b [10],...,b [19] left ten positions: copy (&b [10], &b [20], &b [0]); // Call 4: copy a [0],...,a <ref> [9] </ref> to a [10],...,a [19]: copy (&a [0], &a [10], &a [10]); Based on these calls three different instances of the copy algorithm are created by the C++ compiler, with type signatures double* copy (int*, int*, double*) int* copy (int*, int*, int*) double* copy (double*, double*, double*) The first of these <p> In the next section, we show how to formally capture and represent the semantic properties common to all the data types that can be used to replace type parameters (such as InputIterator and OutputIterator) of a generic algorithm. 3 Overview of Tecton Concept Specifications Tecton <ref> [8, 9, 10] </ref> is a specification language for describing and using abstract concepts in formal software development and hardware design. One of the main goals of Tecton is to reduce the need for proof. Tecton achieves this goal by supporting behavioral abstraction and data abstraction as well.
Reference: [10] <author> D. Kapur, D. R. Musser, and X. Nie, </author> <title> "An Overview of the Tecton Proof System," </title> <note> Theoretical Computer Science 133 (1994) 307-339. </note>
Reference-contexts: initialize array a // Call 1: copy all of array a to array b: copy (&a [0], &a [100], &b [0]); // Call 2: shift a [1],...,a [99] left one position: copy (&a [1], &a [100], &a [0]); // Call 3: shift b <ref> [10] </ref>,...,b [19] left ten positions: copy (&b [10], &b [20], &b [0]); // Call 4: copy a [0],...,a [9] to a [10],...,a [19]: copy (&a [0], &a [10], &a [10]); Based on these calls three different instances of the copy algorithm are created by the C++ compiler, with type signatures double* copy (int*, int*, double*) int* copy (int*, <p> [0]); // Call 2: shift a [1],...,a [99] left one position: copy (&a [1], &a [100], &a [0]); // Call 3: shift b <ref> [10] </ref>,...,b [19] left ten positions: copy (&b [10], &b [20], &b [0]); // Call 4: copy a [0],...,a [9] to a [10],...,a [19]: copy (&a [0], &a [10], &a [10]); Based on these calls three different instances of the copy algorithm are created by the C++ compiler, with type signatures double* copy (int*, int*, double*) int* copy (int*, int*, int*) double* copy (double*, double*, double*) The first of these instances is used in call 1, the second in <p> Call 2: shift a [1],...,a [99] left one position: copy (&a [1], &a [100], &a [0]); // Call 3: shift b <ref> [10] </ref>,...,b [19] left ten positions: copy (&b [10], &b [20], &b [0]); // Call 4: copy a [0],...,a [9] to a [10],...,a [19]: copy (&a [0], &a [10], &a [10]); Based on these calls three different instances of the copy algorithm are created by the C++ compiler, with type signatures double* copy (int*, int*, double*) int* copy (int*, int*, int*) double* copy (double*, double*, double*) The first of these instances is used in call 1, the second in calls 2 <p> In the next section, we show how to formally capture and represent the semantic properties common to all the data types that can be used to replace type parameters (such as InputIterator and OutputIterator) of a generic algorithm. 3 Overview of Tecton Concept Specifications Tecton <ref> [8, 9, 10] </ref> is a specification language for describing and using abstract concepts in formal software development and hardware design. One of the main goals of Tecton is to reduce the need for proof. Tecton achieves this goal by supporting behavioral abstraction and data abstraction as well.
Reference: [11] <author> J. C. King, </author> <title> A Program Verifier, </title> <type> Ph.D. thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1969. </year>
Reference-contexts: Here is how such a copy operation might be coded as a template function in C++: template &lt;class T, class U&gt; 1 Although the use of symbolic execution in software verification goes back to some of the earliest program verification systems <ref> [11, 12, 13] </ref>, and forward assignment axioms are sometimes mentioned in the literature (e.g., see [5, p. 120]), we are not aware of any axiomatic system with this approach as its basis. 2 U* copy (T* first, T* last, U* r) - while (f != last) *result++ = *first++; return result;
Reference: [12] <author> J. C. King, </author> <title> "A New Approach to Program Testing," </title> <booktitle> Proc. of the International Conference on Reliable Software, </booktitle> <month> April </month> <year> 1975. </year>
Reference-contexts: Here is how such a copy operation might be coded as a template function in C++: template &lt;class T, class U&gt; 1 Although the use of symbolic execution in software verification goes back to some of the earliest program verification systems <ref> [11, 12, 13] </ref>, and forward assignment axioms are sometimes mentioned in the literature (e.g., see [5, p. 120]), we are not aware of any axiomatic system with this approach as its basis. 2 U* copy (T* first, T* last, U* r) - while (f != last) *result++ = *first++; return result;
Reference: [13] <author> R.L. London and D.R. Musser, </author> <title> "The Application of a Symbolic Mathematical System to Program Verification," </title> <booktitle> Proc. of ACM Annual Conference, </booktitle> <month> November </month> <year> 1974. </year>
Reference-contexts: Here is how such a copy operation might be coded as a template function in C++: template &lt;class T, class U&gt; 1 Although the use of symbolic execution in software verification goes back to some of the earliest program verification systems <ref> [11, 12, 13] </ref>, and forward assignment axioms are sometimes mentioned in the literature (e.g., see [5, p. 120]), we are not aware of any axiomatic system with this approach as its basis. 2 U* copy (T* first, T* last, U* r) - while (f != last) *result++ = *first++; return result;
Reference: [14] <author> D. Luckham, S. Sankar, S. Takahashi, </author> <title> "Two-Dimensional Pinpointing: Debugging With Formal Specifications," </title> <journal> IEEE Software, </journal> <month> Jan. </month> <year> 1991. </year>
Reference: [15] <author> Luqi, H. Yang, X. Zhang, </author> <title> "Constructing an automated testing oracle : an effort to produce reliable software," </title> <booktitle> Proc. 8th Annual International Computer Software and Applications Conference, </booktitle> <year> 1994. </year>
Reference: [16] <author> J.H. Morris and B. Wegbreit, </author> <title> "Program Verification by Subgoal Induction," in Current Trends in Programming Methodology, </title> <editor> R. T. Yeh, ed., </editor> <volume> Vol. II, Ch. 8, </volume> <publisher> Prentice-Hall, </publisher> <year> 1977. </year>
Reference-contexts: in the normal forward order (as opposed to the backward order necessary with the usual assignment axiom in Hoare's system). 1 We also treat while loops differently from Hoare's approach: instead of using loop invariant assertions, we use pre/post conditions and an inference rule akin to the subgoal induction method <ref> [16] </ref>. Details of this formal foundation can be found in [18] and [28]. 2 Generic Algorithms Generic algorithms are called generic because they are expressed in terms of type or function parameters that can be instantiated in many different ways to produce different versions of the algorithms.
Reference: [17] <author> D. R. Musser and A. A. Stepanov, </author> <title> The Ada Generic Library: Linear List Processing Packages, </title> <address> Spring-Verlag, </address> <year> 1989. </year>
Reference: [18] <author> D. R. Musser and Changqing Wang, </author> <title> A Basis for Formal Specification and Verification of Generic Algorithms in the C++ Standard Template Library, </title> <institution> Dept of Computer Science, Rensselaer Polytechnic Institute, </institution> <type> Technical Report 95-1, </type> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Details of this formal foundation can be found in <ref> [18] </ref> and [28]. 2 Generic Algorithms Generic algorithms are called generic because they are expressed in terms of type or function parameters that can be instantiated in many different ways to produce different versions of the algorithms.
Reference: [19] <author> Wolfgang Polak, </author> <title> "Program Verification Based on Denotational Semantics," </title> <booktitle> 8th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1981. </year>
Reference-contexts: b [100]; // ... code to initialize array a // Call 1: copy all of array a to array b: copy (&a [0], &a [100], &b [0]); // Call 2: shift a [1],...,a [99] left one position: copy (&a [1], &a [100], &a [0]); // Call 3: shift b [10],...,b <ref> [19] </ref> left ten positions: copy (&b [10], &b [20], &b [0]); // Call 4: copy a [0],...,a [9] to a [10],...,a [19]: copy (&a [0], &a [10], &a [10]); Based on these calls three different instances of the copy algorithm are created by the C++ compiler, with type signatures double* copy <p> (&a [0], &a [100], &b [0]); // Call 2: shift a [1],...,a [99] left one position: copy (&a [1], &a [100], &a [0]); // Call 3: shift b [10],...,b <ref> [19] </ref> left ten positions: copy (&b [10], &b [20], &b [0]); // Call 4: copy a [0],...,a [9] to a [10],...,a [19]: copy (&a [0], &a [10], &a [10]); Based on these calls three different instances of the copy algorithm are created by the C++ compiler, with type signatures double* copy (int*, int*, double*) int* copy (int*, int*, int*) double* copy (double*, double*, double*) The first of these instances is used in
Reference: [20] <author> D.J. Richardson, "TAOS: </author> <title> Testing with Analysis and Oracle Support," </title> <booktitle> 1994 International Symposium on Software Testing and Analysis, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: a // Call 1: copy all of array a to array b: copy (&a [0], &a [100], &b [0]); // Call 2: shift a [1],...,a [99] left one position: copy (&a [1], &a [100], &a [0]); // Call 3: shift b [10],...,b [19] left ten positions: copy (&b [10], &b <ref> [20] </ref>, &b [0]); // Call 4: copy a [0],...,a [9] to a [10],...,a [19]: copy (&a [0], &a [10], &a [10]); Based on these calls three different instances of the copy algorithm are created by the C++ compiler, with type signatures double* copy (int*, int*, double*) int* copy (int*, int*, int*)
Reference: [21] <author> David S. Resenblum, </author> <title> "A Practical Approach to Programming With Assertions," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 21, No. 1, </volume> <month> Jan. </month> <year> 1995. </year>
Reference: [22] <author> N. Shankar, S. Owre and J.M. Rushby, </author> <title> The PVS Specification Language, </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, March 1, </address> <year> 1993. </year>
Reference: [23] <author> N. Shankar, S. Owre and J. M. Rushby, </author> <title> The PVS Proof Checker: A Reference Manual (Draft), </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, March 1, </address> <year> 1993. </year>
Reference: [24] <author> S. Sankar, R. Hayes, </author> <title> Specifying and Testing Software Components using ADL, </title> <institution> Sun Microsystems Lab, Inc. </institution> <type> Technical Report, </type> <institution> SMLI TR-94-23, </institution> <month> April </month> <year> 1994. </year>
Reference: [25] <author> R. M. Stallman, R. H. Pesch, </author> <title> Debugging with GDB, GDB user's manual, Free Software Foundation, </title> <publisher> Inc., </publisher> <year> 1993. </year>
Reference: [26] <author> A. Stepanov and M. Lee, </author> <title> The Standard Template Library, </title> <type> Technical Report, </type> <institution> Hewlett-Packard Laboratories, </institution> <month> Sept. 20, </month> <year> 1994. </year>
Reference-contexts: MELAS is still under development, but a preliminary version has sufficient capabilities to formally verify simple generic algorithms taken directly from the ANSI/ISO C++ Standard Template Library (STL) <ref> [26, 28, 29] </ref>. We give one such example in this paper and relate some of our experience with other examples. <p> One example is the generic copy algorithm discussed in this paper. Another is the STL generic adjacent_find algorithm, for searching a sequence for the first pair of adjacent equal elements. An interesting point about adjacent_find is that it is not correct as originally specified in <ref> [26] </ref>. The original specification said that adjacent_find could be used with input iterators, but input iterators do not have all the properties necessary for correctness of the algorithm; it needs forward iterators, which are input iterators with some additional properties. This error was noticed and corrected in later versions of [26]. <p> <ref> [26] </ref>. The original specification said that adjacent_find could be used with input iterators, but input iterators do not have all the properties necessary for correctness of the algorithm; it needs forward iterators, which are input iterators with some additional properties. This error was noticed and corrected in later versions of [26]. Attempting to use MELAS to verify the original version fails, but with the revised specification we are able to complete the proof.
Reference: [27] <author> A. A. Stepanov, M. Lee, and D. R. Musser, </author> <title> Hewlett-Packard Laboratories reference implementation of the Standard Template Library, </title> <note> source files available via anonymous ftp from butler:hpl:hp:com in =stl=sharf ile:Z. </note>
Reference-contexts: The above definition of copy works with parameters of many different types, but the actual definition of copy used in the Hewlett-Packard implementation of STL <ref> [27] </ref> is even more general: template &lt;class InputIterator, class OutputIterator&gt; OutputIterator copy (InputIterator first, InputIterator last, OutputIterator result) - while (first != last) *result++ = *first++; return result; - Instead of pointer types T* and U*, this algorithm is written in terms of types called InputIterator and OutputIterator.
Reference: [28] <author> Changqing Wang, </author> <title> Integrating Tools and Methods For Rigorous Analysis of C++ Generic Library Components, </title> <institution> Dept of Computer Science, Rensselaer Polytechnic Institute, </institution> <type> Ph.D Thesis, </type> <month> July, </month> <year> 1996. </year> <month> 21 </month>
Reference-contexts: The method depends on two key insights. First, rather than viewing type parameters of generic algorithms as a complication, we can turn them to advantage by substituting for them special data types called Run-time Analysis Oracles (RAOs) <ref> [28] </ref>, which work with symbolic inputs and compute outputs using inference methods. By itself, this technique is a form of symbolic execution that supports testing with symbolic values, thereby covering large or infinite sets of inputs in each individual test. <p> MELAS is still under development, but a preliminary version has sufficient capabilities to formally verify simple generic algorithms taken directly from the ANSI/ISO C++ Standard Template Library (STL) <ref> [26, 28, 29] </ref>. We give one such example in this paper and relate some of our experience with other examples. <p> Details of this formal foundation can be found in [18] and <ref> [28] </ref>. 2 Generic Algorithms Generic algorithms are called generic because they are expressed in terms of type or function parameters that can be instantiated in many different ways to produce different versions of the algorithms. <p> This error was noticed and corrected in later versions of [26]. Attempting to use MELAS to verify the original version fails, but with the revised specification we are able to complete the proof. A third, more complex, example <ref> [28] </ref> that has been verified with MELAS is the STL merge algorithm, which contains a while loop and an if-then-else statement; it also makes two calls of the copy algorithm, one nested in the argument list of the other.
Reference: [29] <author> Changqing Wang, David R. Musser, </author> <title> "Dynamic Verification of C++ Generic Compo--nents: A Practical Method And Its Support System," </title> <booktitle> Proc. of The First Workshop on Formal Methods in Software Practice, </booktitle> <address> San Diego, California, USA, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: MELAS is still under development, but a preliminary version has sufficient capabilities to formally verify simple generic algorithms taken directly from the ANSI/ISO C++ Standard Template Library (STL) <ref> [26, 28, 29] </ref>. We give one such example in this paper and relate some of our experience with other examples.
Reference: [30] <author> J.M. Wing, </author> <title> "A Specifier's Introduction to Formal Methods." </title> <journal> IEEE Computer, </journal> <volume> 23 </volume> (9):8-24, Sept. 1990. 
Reference: [31] <author> J.M. Wing, </author> <title> A Two-Tiered Approach to Specifying Programs, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Electrical Engineering and Computer Science, MIT, TR MIT/LCS/TR-299, </institution> <month> May </month> <year> 1983. </year> <month> 22 </month>
Reference-contexts: We organize the part of the symbolic execution method that deals with types into a library of RAOs. Each RAO has two distinct levels, which we call the interface level and the inference level, a structure similar to that of Larch specifications <ref> [6, 31] </ref>. The major difference is that Larch specifications do not have to be executable, but that is a requirement for dynamic verification. <p> In our dynamic verification system, a program (segment) is specified by describing its precondition state and post-condition state. Like Larch specifications <ref> [6, 31] </ref>, specifications for dynamic verification are two-tiered. The interface specifications, which consist of assertions about program states, make up one tier. The abstract concept specifications that define the semantics of symbolic values and primitive concepts, on which the assertions depend, constitute the other tier.
References-found: 31

