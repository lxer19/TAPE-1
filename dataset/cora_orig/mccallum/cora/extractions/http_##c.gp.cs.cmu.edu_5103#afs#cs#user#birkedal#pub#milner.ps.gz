URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/birkedal/pub/milner.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/birkedal/www/papers.html
Root-URL: http://www.cs.cmu.edu
Title: Unification and Polymorphism in Region Inference  
Author: Mads Tofte, Lars Birkedal, 
Note: Dedicated to Robin Milner on the occasion of his 60th birthday.  
Affiliation: Department of Computer Science, University of Copenhagen  School of Computer Science, Carnegie Mellon University  
Abstract: Region Inference is a technique for inferring lifetimes of values in strict, higher-order programming languages such as Standard ML. The purpose of this paper is to show how ideas from Milner's polymorphic type discipline can serve as a basis for region inference, even in the presence of a limited form of polymorphic recursion.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken, M. Fahndrich, and R. Levien. </author> <title> Better static memory management: Improving region-based analysis of higher-order languages. </title> <booktitle> In Proc. of the ACM SIGPLAN '95 Conference on Programming Languages and Implementation (PLDI), </booktitle> <pages> pages 174-185, </pages> <address> La Jolla, CA, June 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: However, the strict separation between allocation and de-allocation means that there is no language support for reasoning about the lifetimes of storage cells, and thus it is in general very difficult for programmers to reason about how much memory their programs will use. Region-based memory management <ref> [23, 1, 2] </ref> is yet a form of automatic management of dynamic allocation. Conceptually, the store consists of a stack of regions. A region can be thought of as a heap which can grow dynamically depending on how many values it needs to hold. <p> An extended version, including a proof that the region inference rules are sound, may be found in [24]. Other analysis which have been combined with region inference are described in <ref> [1, 2] </ref>.
Reference: [2] <author> L. Birkedal, M. Tofte, and M. Vejlstrup. </author> <title> From region inference to von Neumann machines via region representation inference. </title> <booktitle> In Proceedings of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 171-183. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1996. </year> <note> (accepted). </note>
Reference-contexts: However, the strict separation between allocation and de-allocation means that there is no language support for reasoning about the lifetimes of storage cells, and thus it is in general very difficult for programmers to reason about how much memory their programs will use. Region-based memory management <ref> [23, 1, 2] </ref> is yet a form of automatic management of dynamic allocation. Conceptually, the store consists of a stack of regions. A region can be thought of as a heap which can grow dynamically depending on how many values it needs to hold. <p> An extended version, including a proof that the region inference rules are sound, may be found in [24]. Other analysis which have been combined with region inference are described in <ref> [1, 2] </ref>. <p> This distinction is useful for other analyses and optimisations which can be combined with region inference <ref> [2] </ref>; however, for the purpose of this paper, the distinction between put and get is not important and is therefore omitted. 5.2 Effect Variables and Arrow Effects In the type scheme for hanoi we use * and "where" as meta-notation to make the type scheme easier to read.
Reference: [3] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proc. 9th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <month> Jan. </month> <year> 1982. </year>
Reference-contexts: These unifiers lead to smaller effects than the most general unifier, but they also lead to unnecessary identifications of regions and are therefore undesirable. 9 Type Schemes Type schemes resemble the type schemes of Damas and Milner <ref> [3] </ref> but with additional quantification over region variables and effect variables: ::= 8ff 1 ff n 1 k * 1 * m :t (n 0, k 0 and m 0) Here t is the body of , written body (). <p> Then Below (B; B 0 ) is defined to be (Q 1 ; 1 ). 12.2 The RegEffClos operation Damas and Milner <ref> [3] </ref> define a closure operation, let us write it Clos TE (t ), which forms a type scheme from a type t and a type environment TE. We now define the corresponding operation for forming region-annotated type schemes. Let t be a type and let ' 1 be an effect. <p> Also, B 1 ` ' holds by the definition of Q 0 0 and 0 An example of the use of RegEffClos was provided in Example 10.1. 13 Conclusion A comparison between the type inference rules of Milner's polymorphic type discipline <ref> [3] </ref> and the region inference rules in Section 4 leads to the conclusion that upon something simple, something complicated will inevitably be erected.
Reference: [4] <author> Y. Fuh and P. Mishra. </author> <title> Type inference with subtypes. </title> <journal> Theoretical Computer Science (TCS), </journal> <volume> 73 </volume> <pages> 155-175, </pages> <year> 1990. </year>
Reference-contexts: It is a syntax-directed algorithm, similar to Milner's algorithm W , and it relies on the results about unification proved in the present paper. A different approach to region inference is to use constraints. Constraints have been used in previous work on ML type inference [5], subtyping <ref> [12, 4] </ref> and effect systems [19, 18, 14, 13]. We are currently exploring using constraints for region inference. The relative merits of the two approaches to region inference (syntax-directed region inference versus constraint generation and constraint solving) are not clear at the time of writing.
Reference: [5] <author> F. Henglein. </author> <title> Type inference with polymorphic recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2):253, </volume> <month> April </month> <year> 1993. </year>
Reference-contexts: It is a syntax-directed algorithm, similar to Milner's algorithm W , and it relies on the results about unification proved in the present paper. A different approach to region inference is to use constraints. Constraints have been used in previous work on ML type inference <ref> [5] </ref>, subtyping [12, 4] and effect systems [19, 18, 14, 13]. We are currently exploring using constraints for region inference. The relative merits of the two approaches to region inference (syntax-directed region inference versus constraint generation and constraint solving) are not clear at the time of writing. <p> Thus the region rules are faithful to the treatment of recursive functions in ML as far as type polymorphism is concerned [10]. The reason for this limitation is that type inference for (type-) polymorphic recursion is equivalent to semi-unification <ref> [5, 8] </ref>, which is undecidable [7]. However, it can be proved that every well-typed source expression can be region-annotated in accordance with the region inference rules [24]. Moreover, in the absence of region-polymorphic recursion, Milner's notion of principal type schemes extends to region inference [22].
Reference: [6] <author> R. Hindley. </author> <title> The principal type-scheme of an object in combinatory logic. </title> <journal> Trans. Amer. Math. Soc., </journal> <volume> 146 </volume> <pages> 29-60, </pages> <month> Dec. </month> <year> 1969. </year>
Reference-contexts: In order to satisfy the premises of the inference rule, the region inference algorithm needs to be able to unify types which contain region and effect information. Hindley <ref> [6] </ref> and Milner [10] discovered that Robinson's unification algorithm can be used for unifying types. We assume that type inference has already been carried out by the time region inference is performed.
Reference: [7] <author> A. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> The undecidability of the semi-unification problem. </title> <booktitle> Information and Computation, </booktitle> <pages> pages 83-101, </pages> <year> 1993. </year>
Reference-contexts: Thus the region rules are faithful to the treatment of recursive functions in ML as far as type polymorphism is concerned [10]. The reason for this limitation is that type inference for (type-) polymorphic recursion is equivalent to semi-unification [5, 8], which is undecidable <ref> [7] </ref>. However, it can be proved that every well-typed source expression can be region-annotated in accordance with the region inference rules [24]. Moreover, in the absence of region-polymorphic recursion, Milner's notion of principal type schemes extends to region inference [22].
Reference: [8] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> Type reconstruction in the presence of polymorphic recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 290-311, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Thus the region rules are faithful to the treatment of recursive functions in ML as far as type polymorphism is concerned [10]. The reason for this limitation is that type inference for (type-) polymorphic recursion is equivalent to semi-unification <ref> [5, 8] </ref>, which is undecidable [7]. However, it can be proved that every well-typed source expression can be region-annotated in accordance with the region inference rules [24]. Moreover, in the absence of region-polymorphic recursion, Milner's notion of principal type schemes extends to region inference [22].
Reference: [9] <author> X. Leroy. </author> <title> Typage polymorphe d'un langage algorithmique. </title> <type> PhD thesis, </type> <institution> University Paris VII, </institution> <year> 1992. </year> <title> English version: Polymorphic Typing of an Algorithmic Language, </title> <note> INRIA Research Report no. 1778, </note> <month> October </month> <year> 1992. </year>
Reference-contexts: Similar forms of unification have been studied in record typing [16] and in type systems for polymorphic references <ref> [9] </ref>. 4 The region inference algorithm that is currently used in the ML Kit is described and proved correct in [20]. It is a syntax-directed algorithm, similar to Milner's algorithm W , and it relies on the results about unification proved in the present paper.
Reference: [10] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> J. Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: The relevance of region inference to this Festschrift is that Milner's work on type inference and type checking <ref> [10] </ref> has provided many of the technical insights which underlie region inference. (Other origins of region inference are listed in Section 3.) In particular, the idea of using unification in type checking and the notions of polymorphic type schemes and generic instance are heavily exploited in work on regions. <p> In order to satisfy the premises of the inference rule, the region inference algorithm needs to be able to unify types which contain region and effect information. Hindley [6] and Milner <ref> [10] </ref> discovered that Robinson's unification algorithm can be used for unifying types. We assume that type inference has already been carried out by the time region inference is performed. <p> Thus the region rules are faithful to the treatment of recursive functions in ML as far as type polymorphism is concerned <ref> [10] </ref>. The reason for this limitation is that type inference for (type-) polymorphic recursion is equivalent to semi-unification [5, 8], which is undecidable [7]. However, it can be proved that every well-typed source expression can be region-annotated in accordance with the region inference rules [24].
Reference: [11] <author> R. Milner, M. Tofte, R. Harper, and D. MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: The only mechanism for freeing memory is to pop the region stack, which is a constant time operation, for a suitable choice of concrete representation of regions. Rather than forcing the programmer to introduce and eliminate regions, we have taken the approach to use an existing language, Standard ML <ref> [11] </ref>, as the source language. The region scheme, including the algorithms presented in this paper, are implemented in the ML Kit with Regions [21] which compiles Standard ML Core Language programs to C and HP PA-RISC code. The ML Kit subjects source programs to a particular static analysis, region inference.
Reference: [12] <author> J. Mitchell. </author> <title> Coercion and type inference. </title> <booktitle> In Proc. 11th ACM Symp. on Principles of Programming Languages (POPL), </booktitle> <year> 1984. </year>
Reference-contexts: It is a syntax-directed algorithm, similar to Milner's algorithm W , and it relies on the results about unification proved in the present paper. A different approach to region inference is to use constraints. Constraints have been used in previous work on ML type inference [5], subtyping <ref> [12, 4] </ref> and effect systems [19, 18, 14, 13]. We are currently exploring using constraints for region inference. The relative merits of the two approaches to region inference (syntax-directed region inference versus constraint generation and constraint solving) are not clear at the time of writing.
Reference: [13] <author> F. Nielson, H. R. Nielson, and T. Amtoft. </author> <title> Polymorphic subtyping for effect analysis: the algorithm. </title> <type> Technical Report LOMAPS-DAIMI-16, </type> <institution> Department of Computer Science, University of Aarhus (DAIMI), </institution> <month> April </month> <year> 1996. </year>
Reference-contexts: A different approach to region inference is to use constraints. Constraints have been used in previous work on ML type inference [5], subtyping [12, 4] and effect systems <ref> [19, 18, 14, 13] </ref>. We are currently exploring using constraints for region inference. The relative merits of the two approaches to region inference (syntax-directed region inference versus constraint generation and constraint solving) are not clear at the time of writing.
Reference: [14] <author> H. R. Nielson and F. Nielson. </author> <title> Higher-order concurrent programs with finite communication topology. </title> <booktitle> In Conference Record of POPL'94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-97. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: A different approach to region inference is to use constraints. Constraints have been used in previous work on ML type inference [5], subtyping [12, 4] and effect systems <ref> [19, 18, 14, 13] </ref>. We are currently exploring using constraints for region inference. The relative merits of the two approaches to region inference (syntax-directed region inference versus constraint generation and constraint solving) are not clear at the time of writing.
Reference: [15] <author> Peter Naur (ed.). </author> <title> Revised report on the algorithmic language Algol 60. </title> <journal> Comm. ACM, </journal> <volume> 1 </volume> <pages> 1-17, </pages> <year> 1963. </year>
Reference-contexts: The stack discipline which originated with Algol 60 <ref> [15] </ref> is a particularly elegant discipline for dynamic memory management. Restricted versions of the original stack discipline are used in many languages in current use, e.g., C and Pascal.
Reference: [16] <author> D. Remy. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> In Proc. 16th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 77-88. </pages> <publisher> ACM, </publisher> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: Similar forms of unification have been studied in record typing <ref> [16] </ref> and in type systems for polymorphic references [9]. 4 The region inference algorithm that is currently used in the ML Kit is described and proved correct in [20].
Reference: [17] <author> J. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: We then introduce a technical notion, consistency, which is required for the statement and proof of a key lemma. Informally speaking, this lemma (Lemma 6) says that Robinson's result <ref> [17] </ref> concerning most general unifiers of terms generalises to the case where terms are types which are annotated with regions and effects, provided the annotation is done consistently.
Reference: [18] <author> J.-P. Talpin and P. Jouvelot. </author> <title> Polymorphic type, region and effect inference. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3), </volume> <year> 1992. </year>
Reference-contexts: A different approach to region inference is to use constraints. Constraints have been used in previous work on ML type inference [5], subtyping [12, 4] and effect systems <ref> [19, 18, 14, 13] </ref>. We are currently exploring using constraints for region inference. The relative merits of the two approaches to region inference (syntax-directed region inference versus constraint generation and constraint solving) are not clear at the time of writing. <p> A crucial next step, invented in work on effect inference <ref> [18] </ref>, is to make effect variables part of the language of types, on a par with type variables and region variables. <p> unification After unification @ @ @ @R S S In the picture, S is a substitution. (Substitutions will be defined in Section 7.) Another way of thinking of * 1 :' 1 and * 2 :' 2 is as two constraints * 1 ' 1 and * 2 ' 2 <ref> [18] </ref>; then the "unification" of the two arrow effect corresponds to replacing * 2 by * 1 everywhere and replacing the two constraints by a single constraint * 1 (' 1 [ ' 2 ). <p> Although the region inference rules (1) - (6) can be expressed using constraints rather than arrow effects along the lines of <ref> [18] </ref>, constraint sets complicate the definitions of type schemes, generic instance, generalisation and the Observe operation given later in this paper.
Reference: [19] <author> J.-P. Talpin and P. Jouvelot. </author> <title> The type and effect discipline. </title> <booktitle> In Proceedings of the seventh IEEE Conference on Logic in Computer Science, </booktitle> <pages> pages 162-173, </pages> <month> June </month> <year> 1992. </year> <note> Also, (extended version) technical report EMP/CRI/A-206, </note> <institution> Ecole des Mines de Paris, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: A different approach to region inference is to use constraints. Constraints have been used in previous work on ML type inference [5], subtyping [12, 4] and effect systems <ref> [19, 18, 14, 13] </ref>. We are currently exploring using constraints for region inference. The relative merits of the two approaches to region inference (syntax-directed region inference versus constraint generation and constraint solving) are not clear at the time of writing.
Reference: [20] <author> M. Tofte and L. Birkedal. </author> <title> A region inference algorithm. </title> <note> (Submitted for publication; available at http://www.diku.dk/users/tofte/publ/toplassubm.a4.ps.Z ), November 1996. </note>
Reference-contexts: Similar forms of unification have been studied in record typing [16] and in type systems for polymorphic references [9]. 4 The region inference algorithm that is currently used in the ML Kit is described and proved correct in <ref> [20] </ref>. It is a syntax-directed algorithm, similar to Milner's algorithm W , and it relies on the results about unification proved in the present paper. A different approach to region inference is to use constraints. <p> Lemma 3 Let B 0 be a finite, consistent basis. There exists no infinite descending chain: B 0 &gt; B 1 &gt; B 2 &gt; A proof of the above lemma may be found in <ref> [20] </ref>. The lemma plays a crucial role in the proof that the region inference algorithm terminates. The region inference algorithm iterates over the program, contracting the basis and modifying the program annotations in the process. <p> 0 3 (S 3 (*:')) (19) By (17), (18) and (19) we get the desired 8 2 Q:S () = S 0 3 (S fl (*:')) (20) It turns out that the premises of lemma 6 are always met in the region inference algorithm we use (this is proved in <ref> [20] </ref>). Therefore, unification never fails. <p> We have chosen to resolve this (alleged) tension in the favour of termination: the algorithm described in <ref> [20] </ref> always finds a region annotation which is legal according to the region inference rules, although in doing so, it may fail to give every recursive function in the program a region type scheme which is the most general one permitted by the region inference rules. The algorithm in [20] handles <p> in <ref> [20] </ref> always finds a region annotation which is legal according to the region inference rules, although in doing so, it may fail to give every recursive function in the program a region type scheme which is the most general one permitted by the region inference rules. The algorithm in [20] handles polymorphic recursion using a two-phase approach. The first phase, called spreading, generates a (possibly large) basis by choosing fresh region and effect variables wherever a region or effect annotation is required in the target program.
Reference: [21] <author> M. Tofte, L. Birkedal, M. Elsman, N. Hallenberg, T. H. Olesen, P. Sestoft, and P. Ber-telsen. </author> <title> Programming with regions in the ML Kit. </title> <type> Technical Report DIKU-TR-97/12, </type> <institution> Department of Computer Science, University of Copenhagen, </institution> <year> 1997. </year> <note> (http://www.diku.dk/research-groups/topps/activities/topps/kit2). </note>
Reference-contexts: Rather than forcing the programmer to introduce and eliminate regions, we have taken the approach to use an existing language, Standard ML [11], as the source language. The region scheme, including the algorithms presented in this paper, are implemented in the ML Kit with Regions <ref> [21] </ref> which compiles Standard ML Core Language programs to C and HP PA-RISC code. The ML Kit subjects source programs to a particular static analysis, region inference. The analysis decides where regions should be allocated and de-allocated.
Reference: [22] <author> M. Tofte and J.-P. Talpin. </author> <title> Data region inference for polymorphic functional languages (technical summary). </title> <type> Technical Report EMP/CRI/A-229, </type> <institution> Ecole des Mines de Paris, </institution> <year> 1992. </year>
Reference-contexts: However, it can be proved that every well-typed source expression can be region-annotated in accordance with the region inference rules [24]. Moreover, in the absence of region-polymorphic recursion, Milner's notion of principal type schemes extends to region inference <ref> [22] </ref>. In the presence of polymorphic recursion, however, it is not known whether (in some sense) it is possible to infer a principal region type scheme for every ML-typable expression.
Reference: [23] <author> M. Tofte and J.-P. Talpin. </author> <title> Implementing the call-by-value lambda-calculus using a stack of regions. </title> <booktitle> In Proceedings of the 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 188-201. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: However, the strict separation between allocation and de-allocation means that there is no language support for reasoning about the lifetimes of storage cells, and thus it is in general very difficult for programmers to reason about how much memory their programs will use. Region-based memory management <ref> [23, 1, 2] </ref> is yet a form of automatic management of dynamic allocation. Conceptually, the store consists of a stack of regions. A region can be thought of as a heap which can grow dynamically depending on how many values it needs to hold. <p> particularly noteworthy when one considers that the ML Kit boxes all tuples, including the tuples of region variables that are passed to region-polymorphic functions; that is what regions 16 , 22 and 27 are used for. 3 Related Work The basic ideas of the region inference scheme are described in <ref> [23] </ref>. An extended version, including a proof that the region inference rules are sound, may be found in [24]. Other analysis which have been combined with region inference are described in [1, 2]. <p> The effect reveals that hanoi does not access 10 at all. In <ref> [23] </ref> there is a distinction between put and get effects; for example, the above effect would be written fget ( 6 ); put ( 7 ); put ( 8 ); put ( 9 ); get ( 11 )g. <p> We emphasise that consistency of type schemes is introduced for algorithmic reasons only. Soundness of the region inference rules has been proved without assuming consistency <ref> [23, 24] </ref>. Also, we have not found the restriction to consistent type schemes (and the loss in polymorphism it entails) to be serious in practice.
Reference: [24] <author> M. Tofte and J.-P. Talpin. </author> <title> Region-based memory management. </title> <journal> Information and Computation, </journal> <volume> 132(2) </volume> <pages> 109-176, </pages> <year> 1997. </year>
Reference-contexts: An extended version, including a proof that the region inference rules are sound, may be found in <ref> [24] </ref>. Other analysis which have been combined with region inference are described in [1, 2]. <p> The reason for this limitation is that type inference for (type-) polymorphic recursion is equivalent to semi-unification [5, 8], which is undecidable [7]. However, it can be proved that every well-typed source expression can be region-annotated in accordance with the region inference rules <ref> [24] </ref>. Moreover, in the absence of region-polymorphic recursion, Milner's notion of principal type schemes extends to region inference [22]. In the presence of polymorphic recursion, however, it is not known whether (in some sense) it is possible to infer a principal region type scheme for every ML-typable expression. <p> We emphasise that consistency of type schemes is introduced for algorithmic reasons only. Soundness of the region inference rules has been proved without assuming consistency <ref> [23, 24] </ref>. Also, we have not found the restriction to consistent type schemes (and the loss in polymorphism it entails) to be serious in practice.
Reference: [25] <author> P. R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <editor> In Y. Bekkers and J. Cohen, editors, </editor> <booktitle> Memory Management, Proceedings, International Workshop IWMM92, </booktitle> <pages> pages 1-42. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1992. </year> <month> 26 </month>
Reference-contexts: Moreover, unlike what is the case for the stack discipline, the programming language does not help the programmer in reasoning about lifetimes of storage cells. The term "garbage collection" is traditionally used for a range of heap memory management techniques, including reference counting, copying collection and generational collection (see <ref> [25] </ref> for an excellent overview). 1 Common to all of these techniques is that there is a strict separation between the program which allocates memory, called the mutator, and the part of the runtime system, called the garbage collector, which manages recycling of memory.
References-found: 25

