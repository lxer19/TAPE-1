URL: http://www.cs.rpi.edu/~blythes/docs/tvlsi97.ps
Refering-URL: http://www.cs.rpi.edu/~blythes/pubs.html
Root-URL: http://www.cs.rpi.edu
Title: IEEE TRANSACTIONS ON VERY LARGE SCALE INTEGRATION (VLSI) SYSTEMS, VOL. A Solution Methodology for Exact
Author: Samit Chaudhuri Stephen A. Blythe Robert A. Walker 
Address: San Jose, CA 95134 Troy, NY 12180 Kent, OH 44242  
Affiliation: Cadence Design Systems Rensselaer Polytechnic Institute Kent State University  
Date: 1, MARCH 1997 1  
Pubnum: 5, NO.  
Abstract: This paper describes an exact solution methodology, implemented in Rensselaer's Voyager design space exploration system, for solving the scheduling problem in a 3-dimensional (3D) design space: the usual 2D design space (which trades off area and schedule length), plus a third dimension representing clock length. Unlike design space exploration methodologies which rely on bounds or estimates, this methodology is guaranteed to find the globally optimal solution to a 3D scheduling problem. Furthermore, this methodology efficiently prunes the search space, eliminating provably inferior design points through: (1) a careful selection of candidate clock lengths, and (2) tight bounds on the number of functional units or on the schedule length. Both chaining and multi-cycle operations are supported. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. De Micheli, </author> <title> Synthesis and Optimization of Digital Circuits. </title> <booktitle> McGraw-Hill series in electrical and computer engineering, </booktitle> <address> New York, NY, USA: </address> <publisher> McGraw-Hill, </publisher> <year> 1994. </year>
Reference-contexts: The Usual 2-Dimensional (2D) Design Space Fig. 2. The Larger 3-Dimensional (3D) Design Space A. The 3D Design Space In reality, however, this 2D design space is only a small part of a much larger design space. One such larger design space is presented by De Micheli in <ref> [1] </ref>, and is illustrated in viewed as a 3-dimensional (3D) space, with axes not only representing schedule length and area, but clock (cycle) length as well.
Reference: [2] <author> C. E. Leiserson and J. B. Saxe, </author> <title> "Retiming synchronous circuitry," </title> <journal> Algorithmica, </journal> <volume> no. 6, </volume> <pages> pp. 5-35, </pages> <year> 1991. </year>
Reference-contexts: Lacking detailed information, the designer is forced to make an ad hoc and frequently arbitrary guess at the clock length 1 . Unfortunately, this ad hoc 1 The designer may be relying on retiming <ref> [2] </ref>, clock skew optimiza 2 IEEE TRANSACTIONS ON VERY LARGE SCALE INTEGRATION (VLSI) SYSTEMS, VOL. 5, NO. 1, MARCH 1997 3 Mult, 3 Add 2 Mult, 2 Add 1 Mult, 2 Add Clock Csteps ns Csteps ns Csteps ns 163 14 2282 16 2608 16 2608 55 21 1155 22 1210
Reference: [3] <author> R. B. Deokar and S. S. Sapatnekar, </author> <title> "A fresh look at retiming via clock skew optimization," </title> <booktitle> in [44], </booktitle> <pages> pp. 310-315. </pages>
Reference-contexts: In general, the tradeoff between these three types of methodologies is one of solution quality versus computation tion <ref> [3] </ref>, or reclocking [4] to determine the final clock length. However, these techniques generally do not change the relative scheduling of the operations, and do not perform tradeoffs involving resource sharing, so they do not explore the high-level design space as fully as scheduling techniques.
Reference: [4] <author> P. Jha, S. Parameswaran, and N. Dutt, </author> <title> "Reclocking for High Level Synthesis," </title> <booktitle> in Proc. of the Asia-South Pacific Conference on Design Automation (ASP-DAC), (Makuhari Messe, Chiba, </booktitle> <address> Japan), </address> <publisher> IEEE Computer Society Press, </publisher> <address> Aug. 29-Sept. </address> <month> 1 </month> <year> 1995. </year>
Reference-contexts: In general, the tradeoff between these three types of methodologies is one of solution quality versus computation tion [3], or reclocking <ref> [4] </ref> to determine the final clock length. However, these techniques generally do not change the relative scheduling of the operations, and do not perform tradeoffs involving resource sharing, so they do not explore the high-level design space as fully as scheduling techniques.
Reference: [5] <author> M. Potkonjak and J. M. Rabaey, </author> <title> "Optimizing resource utilization using transformations," </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> vol. 13, </volume> <pages> pp. 277-292, </pages> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: However, these techniques generally do not change the relative scheduling of the operations, and do not perform tradeoffs involving resource sharing, so they do not explore the high-level design space as fully as scheduling techniques. Nevertheless, the later use of these techniques, possibly in conjunction with other transformations <ref> [5] </ref>, can serve as a valuable complement to our methodologies. 2 This small clock length also results in a larger number of control steps, and thus a larger and more complex control unit.
Reference: [6] <author> D. E. Thomas, E. D. Lagnese, R. A. Walker, J. A. Nestor, J. V. Rajan, and R. L. Blackburn, </author> <title> Algorithmic and Register Transfer Level Synthesis: The System Architect's Workbench. 101 Philip Drive, </title> <address> Assinippi Park, Norwell, MA 02061: </address> <publisher> Kluwer Academic Publishers Group, </publisher> <year> 1990. </year>
Reference-contexts: A better schedule may exist for a different clock length, but will not be found. To motivate the need to explore this 3D design space, consider the problem of scheduling the well-known Elliptic Wave Filter <ref> [6, p.206] </ref> (EWF) benchmark, under a variety of resource constraints, to find the fastest possible schedule. Assume that the VDP100 module library [7], [8] is used, which has a multiplication delay of 163ns, and an addition delay of 48ns. <p> Experimental Results To demonstrate the accuracy and performance of Voyager's 3D scheduling methodology, we conducted a series of experiments using the well-known AR-lattice Filter (AR) [19], Elliptic Wave Filter (EWF) <ref> [6, p.206] </ref>, and Discrete Cosine Transform (DCT) [43] benchmarks. We used the VDP100 module library from [7], [8], giving a datapath delay of 48ns for addition, 56ns for subtraction, and 163ns for multiplication.
Reference: [7] <author> S. Narayan and D. D. Gajski, </author> <title> "System Clock Estimation based on Clock Slack Minimization," </title> <booktitle> in [45], </booktitle> <pages> pp. 66-71. </pages>
Reference-contexts: To motivate the need to explore this 3D design space, consider the problem of scheduling the well-known Elliptic Wave Filter [6, p.206] (EWF) benchmark, under a variety of resource constraints, to find the fastest possible schedule. Assume that the VDP100 module library <ref> [7] </ref>, [8] is used, which has a multiplication delay of 163ns, and an addition delay of 48ns. Forced to select a clock length for the scheduling algorithm, the designer would probably choose either a clock length of 48ns or 163ns the execution delay of either addition or multiplication. <p> For example, several previous clock estimation schemes [15], [16] use the delay of the slowest functional unit as the estimated clock length. A CHAUDHURI, ET AL: A SOLUTION METHODOLOGY FOR EXACT DESIGN SPACE EXPLORATION IN A 3D DESIGN SPACE 5 more realistic approach is used in <ref> [7] </ref>, in which a contiguous range of integer candidate clock lengths is heuristically evaluated in an attempt to provide some guidance as to the "best" clock length to choose. However, all of these approaches choose the clock length before, and independent of, scheduling. <p> The AR-Lattice Filter DFG in the range [c; c]. In practice, the size of CK is less than 10% of that of the integer range [c; c]. For example, consider the AR lattice filter [19] benchmark (see Figure 6), the VDP100 module library <ref> [7] </ref>, [8] (with datapath delays of 48ns for addition and 163ns for multiplication), and a technology lower bound on the clock length of 19ns. <p> Experimental Results To demonstrate the accuracy and performance of Voyager's 3D scheduling methodology, we conducted a series of experiments using the well-known AR-lattice Filter (AR) [19], Elliptic Wave Filter (EWF) [6, p.206], and Discrete Cosine Transform (DCT) [43] benchmarks. We used the VDP100 module library from <ref> [7] </ref>, [8], giving a datapath delay of 48ns for addition, 56ns for subtraction, and 163ns for multiplication. For each benchmark, we performed Time-Constrained 3D Scheduling (TCS-3D), and Resource-Constrained 3D Scheduling (RCS-3D) with and without chaining, using the methodologies presented in Section II. A.
Reference: [8] <institution> VLSI Technologies Inc., </institution> <address> VDP100 1.5 Micron CMOS Datapath Cell Library, </address> <year> 1988. </year>
Reference-contexts: To motivate the need to explore this 3D design space, consider the problem of scheduling the well-known Elliptic Wave Filter [6, p.206] (EWF) benchmark, under a variety of resource constraints, to find the fastest possible schedule. Assume that the VDP100 module library [7], <ref> [8] </ref> is used, which has a multiplication delay of 163ns, and an addition delay of 48ns. Forced to select a clock length for the scheduling algorithm, the designer would probably choose either a clock length of 48ns or 163ns the execution delay of either addition or multiplication. <p> The AR-Lattice Filter DFG in the range [c; c]. In practice, the size of CK is less than 10% of that of the integer range [c; c]. For example, consider the AR lattice filter [19] benchmark (see Figure 6), the VDP100 module library [7], <ref> [8] </ref> (with datapath delays of 48ns for addition and 163ns for multiplication), and a technology lower bound on the clock length of 19ns. <p> The algorithm runs in O (n l ) time, where n is the number of operations in the DFG, and l is the maximum allowable chain length. For the AR-lattice filter benchmark [19] and the VDP100 <ref> [8] </ref> module library, the algorithm returns the set D ch = f211; 96g, corresponding to the operation sequences ffl; +g and f+; +g. 5 Note that we do not consider type IV chaining, in which all operations in the chain are multicycled, since this is not really chaining one operation is <p> Experimental Results To demonstrate the accuracy and performance of Voyager's 3D scheduling methodology, we conducted a series of experiments using the well-known AR-lattice Filter (AR) [19], Elliptic Wave Filter (EWF) [6, p.206], and Discrete Cosine Transform (DCT) [43] benchmarks. We used the VDP100 module library from [7], <ref> [8] </ref>, giving a datapath delay of 48ns for addition, 56ns for subtraction, and 163ns for multiplication. For each benchmark, we performed Time-Constrained 3D Scheduling (TCS-3D), and Resource-Constrained 3D Scheduling (RCS-3D) with and without chaining, using the methodologies presented in Section II. A.
Reference: [9] <author> S. Chaudhuri, R. A. Walker, and J. E. Mitchell, </author> <title> "Analyzing and Exploiting the Structure of the Constraints in the ILP Approach to the Scheduling Problem," </title> <journal> IEEE Transactions on VLSI Systems, </journal> <volume> vol. 2, </volume> <pages> pp. 456-471, </pages> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Forced to select a clock length for the scheduling algorithm, the designer would probably choose either a clock length of 48ns or 163ns the execution delay of either addition or multiplication. Given those clock lengths, an optimal scheduler that supports multi-cycle operations (such as the ILP-based scheduler <ref> [9] </ref> in our Voyager design space exploration system) would produce the results shown on the rows labeled "48" and "163" in Table I. Now consider the other rows of Table I, which represent other, perhaps less obvious, choices for the clock length. <p> To solve the scheduling problem, both methodologies use an Integer Linear Programming (ILP) formulation (Section IV) that was developed after a careful formal analysis of that problem. This analysis was presented earlier in <ref> [9] </ref>, where we proved that this formulation, in particular the formulation of the TRCS problem, was well-structured and can be solved efficiently. <p> First, the functional unit lower bounds can be computed in polynomial time, by solving at most two Linear Programs (LPs). Second, TRCS is solved as a decision problem, rather than an optimization problem, using a formulation that is well-structured, and requires few, if any, branches in a branch-and-bound search <ref> [9] </ref>. Finally, the functional unit lower bounds are highly accurate [11] (in almost every case they lead immediately to a feasible solution), so in practice the lower bounds seldom have to be increased to solve TRCS again. <p> Second, instead of directly solving the TCS or RCS problem, the missing constraints are generated, converting that problem into a TRCS problem with a smaller search space; moreover, those constraints are tight, and are also generated efficiently. Finally, a TRCS formulation is used that is well-structured <ref> [9] </ref>, and therefore usually finds an optimal solution with few branches. III. Determining Candidate Clock Lengths One of the most important parameters needed by any scheduling algorithm is the length of the system clock 4 . <p> For pipelined controllers, care must be taken to prevent chaining over conditional statements. IV. Optimally Solving the Scheduling Problem In high-level synthesis, the basic scheduling problem is the problem of determining the control step in which each operation will execute. After a careful formal analysis of the scheduling problem <ref> [9] </ref>, we were able to develop well-structured formulations of those problems, in particular the TRCS problem. We began by characterizing the set of feasible schedules in terms of assignment, precedence, and resource constraints. <p> In contrast, this section describes how all three types of chaining can be incorporated into our ILP formulation while still allowing mul-ticycling of non-chained operations. For a more detailed description of this formulation in the absence of chaining, see <ref> [9] </ref>. A. ILP Formulation of the Scheduling Problem Voyager's formulation of the TRCS problem can be summarized as follows. <p> After adding the new arcs for chaining, we use the modified discrete-time relation (1) to generate the precedence constraints in a similar manner as the non-chained precedence constraints. A detailed description of the non-chained precedence constraints can be found in <ref> [9] </ref>. V.
Reference: [10] <author> S. A. Blythe and R. A. Walker, </author> <title> "Towards a Practical Methodology for Completely Characterizing the Optimal Design Space," </title> <booktitle> in Proc. of the 9th International Symposium on System-Level Synthesis, </booktitle> <address> (La Jolla, California), </address> <publisher> IEEE Computer Society Press, </publisher> <month> Nov. 6-8 </month> <year> 1996. </year>
Reference-contexts: Thus it is important to (1) solve the scheduling problem for only a small, provably minimal set of candidate clock lengths, and (2) solve the scheduling 3 However, module selection has since been incorporated <ref> [10] </ref>, and conditionals and register area are currently being investigated. <p> Such an LP-based relaxation is chosen because we want as tight as possible bounds to increase the efficiency of solving the TCS problem. However, Voyager also has a suite of more efficient heuristic algorithms <ref> [10] </ref> that may produce less accurate bounds and are suitable for a quick first pass over the design space. VI.
Reference: [11] <author> S. Chaudhuri and R. A. Walker, </author> <title> "Computing Lower Bounds on Functional Units before Scheduling," </title> <journal> IEEE Transactions on VLSI Systems, </journal> <volume> vol. 4, </volume> <pages> pp. 273-279, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Second, TRCS is solved as a decision problem, rather than an optimization problem, using a formulation that is well-structured, and requires few, if any, branches in a branch-and-bound search [9]. Finally, the functional unit lower bounds are highly accurate <ref> [11] </ref> (in almost every case they lead immediately to a feasible solution), so in practice the lower bounds seldom have to be increased to solve TRCS again. Thus the TCS-3D problem can be solved quickly, even for medium-sized benchmarks (see Section VII). <p> Precedence constraints have been relaxed in [19] (and a similar relaxation in [33]), and in the tighter relaxations described in [34], [35], [36], and [37] (based on a method originally proposed by Fernandez and Bussell in [38, Theorem 1]). A different approach, described more formally in <ref> [11] </ref>, is used in Voyager. This approach starts with an ILP formulation of the FU minimization problem (minimize the number m k of FUs of type k 2 K).
Reference: [12] <author> B. Rouzeyre, D. Dupont, and G. Sagnes, </author> <title> "Component Selection, Scheduling and Control Schemes for High Level Synthesis," </title> <booktitle> in [46]. </booktitle>
Reference-contexts: Fortunately, although such a detailed analysis is necessary later in the design process, it is not 4 In this section, we will assume that a fixed clock length is used for every control step, in contrast to the method presented by Rouzeyre in <ref> [12] </ref> in which the clock length is dynamically changed during execution to reduce the slack in the current control step. needed during high-level synthesis, where only the macroscopic structure of the circuit is determined.
Reference: [13] <author> H. B. Bakoglu, </author> <title> Circuits, Interconnections, and Packaging for VLSI. Addison-Wesley VLSI systems series, </title> <address> Reading, MA, USA: </address> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Determining this clock length requires a detailed analysis of the clock skew, wire delays, glue logic delays, setup and propagation delays of the storage elements, etc. <ref> [13] </ref>. However, all such quantities are largely unknown during high-level synthesis.
Reference: [14] <author> V. Chaiyakul, A. C.-H. Wu, and D. D. Gajski, </author> <title> "Timing Models for High Level Synthesis," </title> <booktitle> in [45], </booktitle> <pages> pp. 60-65. </pages>
Reference-contexts: One appropriate model of the clock length during high-level synthesis is presented by Chaiyakul and Gajski in <ref> [14] </ref>. Here the clock length is assumed to have 3 components: datapath delay, control delay, and wire delay. <p> A similar definition of register-transfer delay is given by Gajski et al. <ref> [14] </ref>, [21]. Modifications can also be made for other (e.g., microcoded or pipelined) types of controllers.
Reference: [15] <author> N. Park and A. C. Parker, </author> <title> "Synthesis of Optimal Clocking Schemes," </title> <booktitle> in Proc. of the 23rd ACM/IEEE Design Automation Conf., </booktitle> <address> (Las Vegas), </address> <pages> pp. 454-460, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: Unfortunately, the clock determination problem is usually ignored in favor of ad hoc decisions or estimates, which, as demonstrated later, can ignore much of the design space and lead to an inferior design. For example, several previous clock estimation schemes <ref> [15] </ref>, [16] use the delay of the slowest functional unit as the estimated clock length.
Reference: [16] <author> R. Jain, A. C. Parker, and N. Park, </author> <title> "Module Selection for Pipeline Synthesis," </title> <booktitle> in Proc. of the 25th ACM/IEEE Design Automation Conf., </booktitle> <address> (Anaheim, California), </address> <pages> pp. 542-547, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June 12-15 </month> <year> 1988. </year>
Reference-contexts: Unfortunately, the clock determination problem is usually ignored in favor of ad hoc decisions or estimates, which, as demonstrated later, can ignore much of the design space and lead to an inferior design. For example, several previous clock estimation schemes [15], <ref> [16] </ref> use the delay of the slowest functional unit as the estimated clock length.
Reference: [17] <author> M. Corazao, M. Khalaf, L. Guerra, M. Potkonjak, and J. M. Rabaey, </author> <title> "Instruction Set Mapping for Performance Optimization ," in Proc. </title> <booktitle> of the IEEE/ACM International Conference on Computer-Aided Design, </booktitle> <address> (Santa Clara, California), </address> <pages> pp. 518-521, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> Nov. 7-11 </month> <year> 1993. </year>
Reference-contexts: Therefore it may seem at first that the globally optimal solution to the 3D scheduling problem cannot be found without optimally solving the scheduling problem for every possible clock length a prohibitively expensive exhaustive search. Fortunately, this exhaustive search is not necessary. In <ref> [17] </ref>, Corazao et al. combined clock length determination with the problem of operation template matching, and made some suggestions to reduce the number of candidate clock lengths.
Reference: [18] <author> L.-G. Chen and L.-G. Jeng, </author> <title> "Optimal Module Set and Clock Cycle Selection for DSP Synthesis," </title> <booktitle> in Proc. of 1991 IEEE International Symp. on Circuits and Systems., (Singapore), </booktitle> <pages> pp. 2200-2203, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June 11-14 </month> <year> 1991. </year>
Reference-contexts: However, the number of candidate clock lengths can be reduced even further, as shown in our Theorem 1 below (a similar observation was made by Chen et al. in <ref> [18] </ref>, but presented without proof).
Reference: [19] <author> R. Jain, A. C. Parker, and N. Park, </author> <title> "Predicting System-Level Area and Delay for Pipelined and Nonpipelined Designs," </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> vol. 11, </volume> <pages> pp. 955-965, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: The AR-Lattice Filter DFG in the range [c; c]. In practice, the size of CK is less than 10% of that of the integer range [c; c]. For example, consider the AR lattice filter <ref> [19] </ref> benchmark (see Figure 6), the VDP100 module library [7], [8] (with datapath delays of 48ns for addition and 163ns for multiplication), and a technology lower bound on the clock length of 19ns. <p> The algorithm runs in O (n l ) time, where n is the number of operations in the DFG, and l is the maximum allowable chain length. For the AR-lattice filter benchmark <ref> [19] </ref> and the VDP100 [8] module library, the algorithm returns the set D ch = f211; 96g, corresponding to the operation sequences ffl; +g and f+; +g. 5 Note that we do not consider type IV chaining, in which all operations in the chain are multicycled, since this is not really <p> Precedence constraints have been relaxed in <ref> [19] </ref> (and a similar relaxation in [33]), and in the tighter relaxations described in [34], [35], [36], and [37] (based on a method originally proposed by Fernandez and Bussell in [38, Theorem 1]). A different approach, described more formally in [11], is used in Voyager. <p> The method is similar in principle to the method presented in the previous section for solving the FU lower-bounding problem. One early formulation of the schedule length lower-bounding problem in presence of resource constraints is presented in <ref> [19] </ref>; however, the bounds produced by that approach are very loose. <p> Experimental Results To demonstrate the accuracy and performance of Voyager's 3D scheduling methodology, we conducted a series of experiments using the well-known AR-lattice Filter (AR) <ref> [19] </ref>, Elliptic Wave Filter (EWF) [6, p.206], and Discrete Cosine Transform (DCT) [43] benchmarks. We used the VDP100 module library from [7], [8], giving a datapath delay of 48ns for addition, 56ns for subtraction, and 163ns for multiplication.
Reference: [20] <author> B. M. Pangrle and D. D. Gajski, </author> <title> "Design Tools for Intelligent Silicon Compilation," </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> vol. 6, </volume> <pages> pp. 1098-112, </pages> <month> Nov. </month> <year> 1987. </year>
Reference-contexts: CK = f163; 82; 55; 48; 41; 33; 28; 24; 21; 19g. B. Determining Candidate Clock Lengths When Chaining First mentioned in high-level synthesis literature in <ref> [20] </ref>, chaining refers to the technique of scheduling two or more data-dependent operations into the same control step, using the otherwise wasted "slack" time that remains in the clock period after the first operation finishes.
Reference: [21] <author> D. D. Gajski, N. D. Dutt, A. Wu, and S. Lin, </author> <title> High-Level Synthesis: Introduction to Chip and System Design. </title> <booktitle> Kluwer international series in engineering and computer science; VLSI, computer architecture, and digital signal processing, </booktitle> <address> 101 Philip Drive, Assinippi Park, Norwell, MA 02061: </address> <publisher> Kluwer Academic Publishers Group, </publisher> <year> 1992. </year>
Reference-contexts: A similar definition of register-transfer delay is given by Gajski et al. [14], <ref> [21] </ref>. Modifications can also be made for other (e.g., microcoded or pipelined) types of controllers.
Reference: [22] <author> B. Gregory, D. MacMillen, and D. Fogg, </author> <title> "ISIS: A System for Performance Driven Resource Sharing," </title> <booktitle> in [47], </booktitle> <pages> pp. 285-290. </pages>
Reference-contexts: However, even rough estimates of those additional delays, determined from a previous iteration of the design process and treated as constants in the current iteration, can sometimes be exploited to produce a better schedule. The additional controller-related delays can be accurately determined after logic synthesis <ref> [22] </ref>, or estimated from an RT-level design [23], and then used in the current design iteration.
Reference: [23] <author> C. Ramachandran, F. J. Kurdahi, D. D. Gajski, V. Chaiyakul, and A. C.-H. Wu, </author> <title> "Accurate layout area and delay modelling for system level design," </title> <booktitle> in Proc. of the IEEE/ACM International Conference on Computer-Aided Design, </booktitle> <address> (Santa Clara, </address> <publisher> Califor-nia), </publisher> <pages> pp. 355-361, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> Nov. 8-12 </month> <year> 1992. </year>
Reference-contexts: The additional controller-related delays can be accurately determined after logic synthesis [22], or estimated from an RT-level design <ref> [23] </ref>, and then used in the current design iteration.
Reference: [24] <author> D. Mintz and C. Dangelo, </author> <title> "Timing Estimation for Behavioral Descriptions," </title> <booktitle> in Proc. of the 7th International Symposium on High-Level Synthesis, (Niagara-on-the-Lake, Canada), </booktitle> <pages> pp. 42-47, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May 18-20 </month> <year> 1994. </year>
Reference-contexts: The additional controller-related delays can be accurately determined after logic synthesis [22], or estimated from an RT-level design [23], and then used in the current design iteration. For example, the controller delays determined in the previous iteration can be used in the current iteration <ref> [24] </ref>, or the system can attempt to predict the incremental change over the previous delays (the work presented in [25] is a first step in this direction). Similarly, the interconnect delays can be determined from the maximum value in the previous iteration [24], or from models of the layout tools [26], <p> iteration can be used in the current iteration <ref> [24] </ref>, or the system can attempt to predict the incremental change over the previous delays (the work presented in [25] is a first step in this direction). Similarly, the interconnect delays can be determined from the maximum value in the previous iteration [24], or from models of the layout tools [26], and the register delays can be treated as constants, or measured more accurately in conjunction with a detailed retiming model [27].
Reference: [25] <author> C. Ramachandran and F. J. Kurdahi, </author> <title> "Incorporating the controller effects during register transfer level synthesis," </title> <booktitle> in [46], </booktitle> <pages> pp. 308-313. </pages>
Reference-contexts: For example, the controller delays determined in the previous iteration can be used in the current iteration [24], or the system can attempt to predict the incremental change over the previous delays (the work presented in <ref> [25] </ref> is a first step in this direction).
Reference: [26] <author> D. Gelosh and D. E. Setliff, </author> <title> "Deriving Efficient Area and Delay Estimates by Modelling Layout Tools," </title> <booktitle> in [44], </booktitle> <pages> pp. 402-407. </pages>
Reference-contexts: Similarly, the interconnect delays can be determined from the maximum value in the previous iteration [24], or from models of the layout tools <ref> [26] </ref>, and the register delays can be treated as constants, or measured more accurately in conjunction with a detailed retiming model [27].
Reference: [27] <author> K. N. Lalgudi and M. C. Papaefthymiou, </author> <title> "DELAY: An Efficient Tool for Retiming with Realistic Delay Modeling," </title> <booktitle> in [44], </booktitle> <pages> pp. 304 - 309. </pages>
Reference-contexts: Similarly, the interconnect delays can be determined from the maximum value in the previous iteration [24], or from models of the layout tools [26], and the register delays can be treated as constants, or measured more accurately in conjunction with a detailed retiming model <ref> [27] </ref>. Once the controller and interconnect related delays have been determined, the new values of d k and d ch can be used with the techniques described in III-A and III-B to more accurately calculate the candidate clock lengths.
Reference: [28] <author> R. M. Russell, </author> <title> "The CRAY-1 Computer System," </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, </volume> <pages> pp. 63-72, </pages> <month> Jan. </month> <year> 1978. </year> <editor> CHAUDHURI, ET AL: </editor> <title> A SOLUTION METHODOLOGY FOR EXACT DESIGN SPACE EXPLORATION IN A 3D DESIGN SPACE 13 </title>
Reference-contexts: Finally, once this analysis was complete, that structure was exploited to develop a provably well-structured Integer Linear Programming (ILP) formulation of the TRCS problem. This section briefly introduces Voyager's ILP formulation of the scheduling problem, and describes the modifications necessary to support chaining <ref> [28] </ref>. Most previous ILP formulations have considered only type I chaining [29], [30], or a combination of types I and II [31].
Reference: [29] <author> C.-T. Hwang, J.-H. Lee, and Y.-C. Hsu, </author> <title> "A Formal Approach to the Scheduling Problem in High-Level Synthesis," </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> vol. 10, </volume> <pages> pp. 464-475, </pages> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: This section briefly introduces Voyager's ILP formulation of the scheduling problem, and describes the modifications necessary to support chaining [28]. Most previous ILP formulations have considered only type I chaining <ref> [29] </ref>, [30], or a combination of types I and II [31]. An ILP formulation that supports all three types of chaining is presented in [32], but the encompassing methodology does not allow for multicycling of non-chained operations due to clock length restrictions in the ILP formulation.
Reference: [30] <author> B. Landwehr, P. Marwedel, and R. Domer, "OSCAR: </author> <title> Optimum Simultaneous Scheduling, Allocation adn Resource Binding Based on Integer Programing," </title> <booktitle> in [46]. </booktitle>
Reference-contexts: This section briefly introduces Voyager's ILP formulation of the scheduling problem, and describes the modifications necessary to support chaining [28]. Most previous ILP formulations have considered only type I chaining [29], <ref> [30] </ref>, or a combination of types I and II [31]. An ILP formulation that supports all three types of chaining is presented in [32], but the encompassing methodology does not allow for multicycling of non-chained operations due to clock length restrictions in the ILP formulation.
Reference: [31] <author> M. Rim and R. Jain, </author> <title> "Estimating lower-bound performance of schedules using a relaxation technique," </title> <booktitle> in Proc. of the IEEE International Conference on Computer Design, </booktitle> <address> (Cambridge, Massachusetts), </address> <pages> pp. 290-294, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> Oct. 11-14 </month> <year> 1992. </year>
Reference-contexts: This section briefly introduces Voyager's ILP formulation of the scheduling problem, and describes the modifications necessary to support chaining [28]. Most previous ILP formulations have considered only type I chaining [29], [30], or a combination of types I and II <ref> [31] </ref>. An ILP formulation that supports all three types of chaining is presented in [32], but the encompassing methodology does not allow for multicycling of non-chained operations due to clock length restrictions in the ILP formulation.
Reference: [32] <author> C. H. Gebotys, </author> <title> "Optimal Scheduling and Allocation of Embedded VLSI Chips," </title> <booktitle> in [47], </booktitle> <pages> pp. 116-119. </pages>
Reference-contexts: Most previous ILP formulations have considered only type I chaining [29], [30], or a combination of types I and II [31]. An ILP formulation that supports all three types of chaining is presented in <ref> [32] </ref>, but the encompassing methodology does not allow for multicycling of non-chained operations due to clock length restrictions in the ILP formulation. In contrast, this section describes how all three types of chaining can be incorporated into our ILP formulation while still allowing mul-ticycling of non-chained operations.
Reference: [33] <author> K. Ku~cuk~cakar, </author> <title> System-Level Synthesis Techiques with Emphasis on Partitioning and Design Timing. </title> <type> PhD thesis, </type> <institution> Electrical Engineering Systems Department, University of Southern Cal-ifornia, </institution> <year> 1991. </year>
Reference-contexts: Precedence constraints have been relaxed in [19] (and a similar relaxation in <ref> [33] </ref>), and in the tighter relaxations described in [34], [35], [36], and [37] (based on a method originally proposed by Fernandez and Bussell in [38, Theorem 1]). A different approach, described more formally in [11], is used in Voyager.
Reference: [34] <author> A. Sharma and R. Jain, </author> <title> "Estimating Architectural Resources and Performance for High-Level Synthesis Applications," </title> <journal> IEEE Transactions on VLSI Systems, </journal> <volume> vol. 1, </volume> <pages> pp. 175-190, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Precedence constraints have been relaxed in [19] (and a similar relaxation in [33]), and in the tighter relaxations described in <ref> [34] </ref>, [35], [36], and [37] (based on a method originally proposed by Fernandez and Bussell in [38, Theorem 1]). A different approach, described more formally in [11], is used in Voyager. <p> More recent algorithms that produce tighter bounds are those in [39] and [37] (based on Jackson's earliest deadline rule (ED-Rule) [40]), and those in <ref> [34] </ref> and [36] (based on a theorem originally given by Fernandez and Bussell in [38, Theorem 2]).
Reference: [35] <author> S. Y. Ohm, F. J. Kurdahi, and N. Dutt, </author> <title> "Comprehensive Lower Bound Estimation from Behavioral Descriptions," </title> <booktitle> in Proc. of the IEEE/ACM International Conference on Computer-Aided Design, </booktitle> <address> (San Jose, California), </address> <pages> pp. 182-187, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> Nov. 6-10 </month> <year> 1994. </year>
Reference-contexts: Precedence constraints have been relaxed in [19] (and a similar relaxation in [33]), and in the tighter relaxations described in [34], <ref> [35] </ref>, [36], and [37] (based on a method originally proposed by Fernandez and Bussell in [38, Theorem 1]). A different approach, described more formally in [11], is used in Voyager.
Reference: [36] <author> Y. Hu, A. Ghouse, and B. S. Carlson, </author> <title> "Lower Bounds on the Iteration Time and the number of Resources for Functional Pipelined Data Flow Graphs," </title> <booktitle> in [48], </booktitle> <pages> pp. 21-24. </pages>
Reference-contexts: Precedence constraints have been relaxed in [19] (and a similar relaxation in [33]), and in the tighter relaxations described in [34], [35], <ref> [36] </ref>, and [37] (based on a method originally proposed by Fernandez and Bussell in [38, Theorem 1]). A different approach, described more formally in [11], is used in Voyager. <p> More recent algorithms that produce tighter bounds are those in [39] and [37] (based on Jackson's earliest deadline rule (ED-Rule) [40]), and those in [34] and <ref> [36] </ref> (based on a theorem originally given by Fernandez and Bussell in [38, Theorem 2]). Furthermore, those algorithms can be applied iteratively (Hu et al. apply Fernandez's Theorem 2 in [41], and Langevin applies ED-Rule in [42]), producing even tighter bounds, although at the cost of increased algorithmic complexity.
Reference: [37] <author> J. M. Rabaey and M. Potkonjak, </author> <title> "Estimating Implementation Bounds for Real Time DSP Application Specific Circuits," </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> vol. 13, </volume> <pages> pp. 669-683, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Precedence constraints have been relaxed in [19] (and a similar relaxation in [33]), and in the tighter relaxations described in [34], [35], [36], and <ref> [37] </ref> (based on a method originally proposed by Fernandez and Bussell in [38, Theorem 1]). A different approach, described more formally in [11], is used in Voyager. <p> One early formulation of the schedule length lower-bounding problem in presence of resource constraints is presented in [19]; however, the bounds produced by that approach are very loose. More recent algorithms that produce tighter bounds are those in [39] and <ref> [37] </ref> (based on Jackson's earliest deadline rule (ED-Rule) [40]), and those in [34] and [36] (based on a theorem originally given by Fernandez and Bussell in [38, Theorem 2]).
Reference: [38] <author> E. B. Fernandez and B. Bussell, </author> <title> "Bounds on the number of Processors and Time for Multiprocessor Optimal Schedule," </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-22, </volume> <pages> pp. 745-751, </pages> <month> Aug. </month> <year> 1973. </year>
Reference-contexts: Precedence constraints have been relaxed in [19] (and a similar relaxation in [33]), and in the tighter relaxations described in [34], [35], [36], and [37] (based on a method originally proposed by Fernandez and Bussell in <ref> [38, Theorem 1] </ref>). A different approach, described more formally in [11], is used in Voyager. This approach starts with an ILP formulation of the FU minimization problem (minimize the number m k of FUs of type k 2 K). <p> More recent algorithms that produce tighter bounds are those in [39] and [37] (based on Jackson's earliest deadline rule (ED-Rule) [40]), and those in [34] and [36] (based on a theorem originally given by Fernandez and Bussell in <ref> [38, Theorem 2] </ref>). Furthermore, those algorithms can be applied iteratively (Hu et al. apply Fernandez's Theorem 2 in [41], and Langevin applies ED-Rule in [42]), producing even tighter bounds, although at the cost of increased algorithmic complexity.
Reference: [39] <author> M. Rim and R. Jain, </author> <title> "Lower-Bound Performance Estimation for the High-Level Synthesis Scheduling Problem," </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> vol. 13, </volume> <pages> pp. 451-458, </pages> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: One early formulation of the schedule length lower-bounding problem in presence of resource constraints is presented in [19]; however, the bounds produced by that approach are very loose. More recent algorithms that produce tighter bounds are those in <ref> [39] </ref> and [37] (based on Jackson's earliest deadline rule (ED-Rule) [40]), and those in [34] and [36] (based on a theorem originally given by Fernandez and Bussell in [38, Theorem 2]).
Reference: [40] <author> J. B la_zewicz, </author> <title> "Simple Algorithms for Multiprocessor Scheduling to Meet Deadlines," </title> <journal> Information Processing Letters, </journal> <volume> vol. 6, </volume> <pages> pp. 162 - 164, </pages> <month> Oct. </month> <year> 1977. </year>
Reference-contexts: One early formulation of the schedule length lower-bounding problem in presence of resource constraints is presented in [19]; however, the bounds produced by that approach are very loose. More recent algorithms that produce tighter bounds are those in [39] and [37] (based on Jackson's earliest deadline rule (ED-Rule) <ref> [40] </ref>), and those in [34] and [36] (based on a theorem originally given by Fernandez and Bussell in [38, Theorem 2]).
Reference: [41] <author> Y. Hu and B. S. Carlson, </author> <title> "Improved Lower Bounds for the Scheduling Optimization Problem," </title> <booktitle> in Proc. of 1994 IEEE International Symp. on Circuits and Systems., (London, Eng-land), </booktitle> <pages> pp. 295-298, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May 30-June 2 </month> <year> 1994. </year>
Reference-contexts: Furthermore, those algorithms can be applied iteratively (Hu et al. apply Fernandez's Theorem 2 in <ref> [41] </ref>, and Langevin applies ED-Rule in [42]), producing even tighter bounds, although at the cost of increased algorithmic complexity. In much the same manner as FU-lower bounding, the ILP formulation of the schedule-length minimization problem can be relaxed to a generic description of an entire class of schedule-length lower-bounding problems.
Reference: [42] <author> M. Langevin and E. Cerny, </author> <title> "A Recursive Technique for Computing Lower-Bound Performance of Schedules," </title> <booktitle> in [48], </booktitle> <pages> pp. 16-20. </pages>
Reference-contexts: Furthermore, those algorithms can be applied iteratively (Hu et al. apply Fernandez's Theorem 2 in [41], and Langevin applies ED-Rule in <ref> [42] </ref>), producing even tighter bounds, although at the cost of increased algorithmic complexity. In much the same manner as FU-lower bounding, the ILP formulation of the schedule-length minimization problem can be relaxed to a generic description of an entire class of schedule-length lower-bounding problems.
Reference: [43] <author> J. A. Nestor and G. Krishnamoorthy, "SALSA: </author> <title> A New Approach to Scheduling with Timing Constraints," </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> vol. 12, </volume> <pages> pp. 1107-1122, </pages> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: Experimental Results To demonstrate the accuracy and performance of Voyager's 3D scheduling methodology, we conducted a series of experiments using the well-known AR-lattice Filter (AR) [19], Elliptic Wave Filter (EWF) [6, p.206], and Discrete Cosine Transform (DCT) <ref> [43] </ref> benchmarks. We used the VDP100 module library from [7], [8], giving a datapath delay of 48ns for addition, 56ns for subtraction, and 163ns for multiplication.
Reference: [44] <editor> Proc. </editor> <booktitle> of the 32nd ACM/IEEE Design Automation Conf., </booktitle> <address> (San Fransisco, California), </address> <publisher> IEEE Computer Society Press, </publisher> <month> June 12-16 </month> <year> 1995. </year>
Reference: [45] <editor> Proc. </editor> <booktitle> of the European Design Automation Conference (Euro-DAC), </booktitle> <address> (Hamburg, Germany), </address> <publisher> IEEE Computer Society Press, </publisher> <month> Feb. </month> <year> 1992. </year>
Reference: [46] <editor> Proc. </editor> <booktitle> of the European Design and Test Conference, </booktitle> <address> (Paris, France), </address> <publisher> IEEE Computer Society Press, </publisher> <address> Feb. 8-Mar. </address> <month> 3 </month> <year> 1994. </year>
Reference: [47] <editor> Proc. </editor> <booktitle> of the 29th ACM/IEEE Design Automation Conf., </booktitle> <address> (Ana-heim, California), </address> <publisher> IEEE Computer Society Press, </publisher> <month> June 8-12 </month> <year> 1992. </year>
Reference: [48] <editor> Proc. </editor> <booktitle> of the IEEE International Conference on Computer Design, </booktitle> <address> (Cambridge, Massachusetts), </address> <publisher> IEEE Computer Society Press, </publisher> <month> Oct. 3-6 </month> <year> 1993. </year>
References-found: 48

