URL: http://www-cad.eecs.berkeley.edu/~gms/pub/gmsIlcIccad.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu:80/~gms/projects/research.html
Root-URL: 
Title: Incremental Formal Design Verification  
Author: Gitanjali M. Swamy Robert K. Brayton 
Abstract: Design verification is the processof ensuring that a designed system satisfies its original requirements. Language containment, a method for performing design verification, involves checking if the behavior of the system to be verified is a subset of the behavior of the specifications(properties or requirements). If the language containment condition is not met then the process returns a subset of states involved in behavior that the system exhibits but the specification does not. This subset is called the set of `Bad' or `Fair' states and they are used to indicate that the system failed verification. In practice, the process of design is incremental and the designer repeatedly modifies and re-verifies his/her design. Current techniques for language containment do not take advantage of this, resulting in unnecessary recomputation that can be cumbersome if small changes are made to a large system. We present an alternate method, which takes advantage of the incremental nature of the design process by successively modifying the original result of verification each time the design is modified. The first step in this Incremental algorithm consists of identifying the changes that the designer may make to the system or the properties to be verified. Next, every change is translated to an addition & subtraction of edges, states and constraints (on acceptable behavior) from the transition behavior or specification of the problem. These changes are used to update the set of `Bad' states previously computed. Thus, the incremental technique successively updates the set of `Bad' behaviors instead of recomputing the behavior after every change. This results in a faster and more efficient algorithm and makes our incremental algorithm superior to the current techniques for language containment. fl This work is supported in part by the National Science Foundation, the California Micro program, Bell Northern Research and Fujitsu
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Bryant. </author> <title> Graph-based Algorithms for Boolean Function Manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35:677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: It is important to keep in mind that all operations are to be carried out in the context of the Binary Decision Diagram (BDD) data structure <ref> [1] </ref>.
Reference: [2] <author> E. M. Clarke, J. R. Burch, O. Grumberg, D. E. Long, and K. L. McMillan. </author> <title> Automatic Verification of Sequential Circuit Designs. </title> <journal> Phil. Trans. of the Royal Society of London, </journal> <volume> 339 </volume> <pages> 105-120, </pages> <year> 1992. </year>
Reference-contexts: The presence of a non-empty set F air + indicates that the automaton has non-empty behavior. 2.1 Some Important Computations This sections describes the significance and computation procedure for all important operators required for language containment. 1. Least Fixed Point Computation <ref> [2] </ref>: Given an initial set of states S 0 , a Transition relation T , and a variable set x, the least fixed point returns a function LF P (x; T; S 0 ) where LF P is computed as follows. <p> LFP (x; T; S n ) if (S n+1 = S n ) return S n else return LF P (x; T; S n+1 ) 2. Greatest Fixed Point Computation <ref> [2] </ref>: Given an initial set of states S 0 , a Transition relation T , and a variable set x, the greatest fixed point returns a function GF P (x; T; S 0 ) where GF P is computed as follows.
Reference: [3] <author> R. Hojati, T. R. Shiple, R. K. Brayton, and R. P. Kurshan. </author> <title> A Unified Environment for Language Containment and Fair CTL Model Checking. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 475-481, </pages> <address> Dallas, Texas, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The problem of language containment needs to be solved in this environment of interacting finite state machines. i 1 i 2 y 2 x 2 o 3 T 1 i 3 Current techniques [7] <ref> [3] </ref> perform language containment as a single pass. If the designer modifies the design after a solution has been obtained for it, then the entire language containment algorithm is repeated for the new problem. <p> In general, the aim for an incremental algorithm for a design verification is getting the same yes or no answer as a non-incremental algorithm while spending less time and effort. Our algorithm recognizes that the language containment algorithms of [8] and <ref> [3] </ref> begin by taking all reachable states and successively reduce this set until only the bad or fair states remain. An examination of these algorithms show that they are monotonic in nature; i.e. once a state is removed from the set of potential bad states, it is never added back. <p> Our algorithm uses information about the change in the system and the original set of bad states to derive a smaller superset of bad states than the set of all reachable states. Then it reduces this superset with an algorithm similar to <ref> [3] </ref>. Since this superset is much smaller than the set of all reachable states, the incremental algorithm converges faster. The paper is organized as follows: The basic terms used in the paper are given in Section 2. Previous work is described in Section 3. <p> Cycles : The set of states in A that are involved in some cycle ( not necessarily contained within A) are computed as Cycles (T; A) R = F R (T; A) return R " R 0 8. Forward Stable Set Operator <ref> [3] </ref>: Given a transition relation T (x; y) and a set of vertices A (x), the Forward Stable Set Operator or F SS (T; A) returns a set of states in A, which are on a cycle or can reach a cycle in A. <p> The following algorithm is used to compute the Forward Stable Set operator F SS : FSS (T; A) return (GF P (y; T; A)) June 24, 1994 - 13 : 54 DRAFT: Please do not circulate! 8 9. Forward Bad Path Operator <ref> [3] </ref>: Given T (x; y), the transition relation, A (x), a set of states and C, a set of fairness constraints, the Forward Bad Path Operator or F BP (T; C; A), returns a subset of states in A (x) which are on a path satisfying the constraints C. <p> This set is also called the set of Fair states. In general, we compute a superset of this set called F air + , which consists of all states which are on a path to a bad cycle. In <ref> [3] </ref> an algorithm for computation of F air + are given for Streett automatons. The algorithm computes F air + June 24, 1994 - 13 : 54 DRAFT: Please do not circulate! 9 by starting with the set of reachable states and alternately applying the FSS and the FBP operators. <p> Transition Relation T (x; y) to the set of reachable states Remove negative fair edges Set S 0 = Reachable states While S n+1 6= S n S 0 = F SS (T; S n ) return S n The proof of correctness of this algorithm can be found in <ref> [3] </ref>. Though not explicitly stated in the above algorithm, the set of reachable states can also be used to minimize the transition relation BDD. This simplification results in a considerable speedup and will be used throughout this paper without an explicit mention. <p> A = F SS (T sub ; F air n ) return F air n Theorem 4.2 If the only changes induced in the system consist of removal of edges from the state transition graph then algorithm 4.3 is correct and returns F air +new Proof From lemma 4.1 and <ref> [3] </ref> 4.4 Addition of Edges Consider the addition of a set of edges to the state transition graph. Addition of edges may result in the creation of a new reachable cycle whose states satisfy the fairness constraints. These states are not necessarily in F air + . <p> Proof From Lemma 4.3 and <ref> [3] </ref>. June 24, 1994 - 13 : 54 DRAFT: Please do not circulate! 14 As noted in section 3 the set of reachable states can be used to simplify the BDD for the transition relation. <p> Proof From Lemma 4.5 and <ref> [3] </ref>. The addition of constraints can very easily be used in conjunction with the addition and subtraction of edges. If edges are deleted, in addition to adding constraints, algorithm 4.3 can be used with the modified FBP operator to compute the new set F air new .
Reference: [4] <author> R. Hojati, V. Singhal, and R. K. Brayton. </author> <title> Edge-Streett/Edge-Rabin Automata Environment for Formal Verification Using Language Containment. </title> <type> Technical Report UCB/ERL M94/12, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1994. </year>
Reference-contexts: In our system, the designer is allowed to directly change the individual transition relations and input process constraints, new processes by using the intermediate `Pif' <ref> [4] </ref> format. 5.2 Incremental Language Containment The general algorithm for computation of the new F air + is based on 4.3 and 4.4, with the additional caveat that the F BP is modified to include the additional constraints. As described previously, the algorithm has two stages for its computation.
Reference: [5] <author> R. P. Kurshan. </author> <title> Automata-Theoretic Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: Definition 7 Rabin Automaton: A Rabin automaton is identical to a Streett automaton, in all but the fairness conditions. The fairness conditions for a Rabin Automaton are the complements of the fairness conditions for a street automaton. Definition 8 L-Automaton: The L automaton <ref> [5] </ref> acceptance condition consists of a pair hR; Zi. R Q fi Q, is termed the recur edges, and Z 2 Q is the set of cycle sets.
Reference: [6] <author> W. Thomas. </author> <title> Automata on Infinite Objects. </title> <editor> In J. van Leeuwen, editor, </editor> <title> Formal Models and Semantics, </title> <booktitle> volume B of Handbook of Theoretical Computer Science, </booktitle> <pages> pages 133-191. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: This directed graph is called a State Transition Graph. Definition 2 Run: A sequence of states, r = r o : : : r i : : : ; r 2 Q ! , is a run <ref> [6] </ref> or a Path of T for a word = ( 1 : : : i : : :), 2 S ! , if r 0 2 I and for i 0, T (r i ; i ; fl i ; r i+1 ) = 1.
Reference: [7] <author> H. Touati, R. K. Brayton, and R. P. Kurshan. </author> <title> Checking Language Containment using BDDs. </title> <booktitle> In Proc. of Intl. Workshop on Formal Methods in VLSI Design, </booktitle> <address> Miami, FL, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: The problem of language containment needs to be solved in this environment of interacting finite state machines. i 1 i 2 y 2 x 2 o 3 T 1 i 3 Current techniques <ref> [7] </ref> [3] perform language containment as a single pass. If the designer modifies the design after a solution has been obtained for it, then the entire language containment algorithm is repeated for the new problem. <p> Checking whether L (M ) L (P ) is the same as checking whether the language of D = M " P is empty. When P is expressed as an L-automaton, the problem of complementing P is solved by expressing it as an L-process <ref> [7] </ref>. The acceptance condition for L-processes and L-automata are complementary and representing P by a L-process is easily done (if P is deterministic) by just keeping the same transition structure and complementing the acceptance conditions (the complementation has been done implicitly by the choice of representation). <p> All successive discussions in this report, though centered around Streett and Rabin automata, are also applicable to other classes of automata. A Language Emptiness check remains at this point and it is performed by checking the product automata, D for acceptable infinite behavior <ref> [7] </ref>, which indicates that the language for the system-property product machine is not empty. A cycle is an integral part of any infinite behavior in a finite graph and in order for this infinite behavior to be acceptable this cycle must also satisfy the fairness constraints.
Reference: [8] <author> H. Touati, H. Savoj, B. Lin, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Implicit State Enumeration of Finite State Machines using BDD's. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 130-133, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: In general, the aim for an incremental algorithm for a design verification is getting the same yes or no answer as a non-incremental algorithm while spending less time and effort. Our algorithm recognizes that the language containment algorithms of <ref> [8] </ref> and [3] begin by taking all reachable states and successively reduce this set until only the bad or fair states remain. <p> It is important to keep in mind that all operations are to be carried out in the context of the Binary Decision Diagram (BDD) data structure [1]. Even though not explicitly expressed, all quantities are represented as their BDD's <ref> [8] </ref>. 2 Definitions Definition 1 Finite State Machine: A finite state machine or finite automaton M is a 5-tuple (Q; S; G; T; I) where * Q is a finite set of states * S is a finite set of inputs * G is a finite set of outputs * T
Reference: [9] <author> M. Y. Vardi and P. L. Wolper. </author> <title> An Automata-Theoretic Approach to Program Verification. </title> <booktitle> In Proc. IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 332-334, </pages> <year> 1986. </year>
Reference-contexts: (T; C; A) return (( Q Q 3 Previous Work in Language Containment The problem of verifying whether a machine (M ) satisfies a given property (P ) reduces to the problem of checking whether the language of the machine automaton is contained in the language of the property automaton <ref> [9] </ref>. This language containment check in turn reduces to a language emptiness check for the product of the system automaton and the complement of the property automaton.
References-found: 9

