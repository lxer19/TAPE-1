URL: http://www.cs.virginia.edu/~nr/pubs/xform-a4.ps
Refering-URL: http://www.cs.virginia.edu/~nr/pubs/xform-abstract.html
Root-URL: http://www.cs.virginia.edu
Email: nr@cs.virginia.edu  cristina@csee.uq.edu.au  
Title: A Transformational Approach to Binary Translation of Delayed Branches (4980-word technical summary)  
Author: Norman Ramsey Cristina Cifuentes 
Date: October 9, 1998  
Address: Charlottesville, VA 22903 USA  4072 Australia  
Affiliation: Department of Computer Science University of Virginia,  Department of Computer Science and Electrical Engineering University of Queensland, Brisbane, QLD  
Abstract: The three big steps in binary translation are distinguishing code from data, mapping data from source to target, and translating instructions. Translating instructions presents few problems, except when the source instruction set has features not present in typical compiler intermediate codes. The most common such feature is the delayed branch. Standard code-generation technology can handle delayed branches in the target language, but not in the source. Translating delayed branches can involve tricky case analyses to figure out what happens if there is a branch instruction in a delay slot. This paper presents a disciplined method for deriving such case analyses. The method identifies problematic cases, shows the translations for the non-problematic cases, and gives confidence that all cases are considered. The method also applies to other tools that analyze machine instructions. We begin by writing a very simple interpreter for the source machine. It specifies, at the register-transfer level, how the source machine executes instructions, including delayed branches. We then transform the interpreter into an interpreter for a target machine without delayed branches. To maintain the semantics of the program being interpreted, we simultaneously transform the sequence of source-machine instructions into a sequence of target-machine instructions. The transformation of the instructions becomes our algorithm for binary translation. We show the translation is correct by using a correspondence between source and target states, and showing if the source and target machines begin execution in corresponding states, they reach new corresponding states in a few instructions. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Aho, Alfred V., Ravi Sethi, and Jeffrey D. Ullman. </author> <year> 1986. </year> <title> Compilers: Principles, Techniques, and Tools. </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: This transformation of the sequence of instructions becomes our algorithm for binary translation. Many of the ideas in this paper are not new. Register-transfer languages have been used to describe instructions for years (Bell and Newell 1971; Bar-bacci and Siewiorek 1982). Our program transformations draw from standard compiler-optimization techniques <ref> (Aho, Sethi, and Ullman 1986) </ref> and standard partial-evaluation techniques (Jones, Gomard, and Sestoft 1993).
Reference: <author> Barbacci, Mario R. and Daniel P. Siewiorek. </author> <year> 1982. </year> <title> The Design and Analysis of Instruction Set Processors. </title> <address> New York, NY: </address> <publisher> McGraw-Hill. </publisher>
Reference: <author> Bell, C. Gordon and Allen Newell. </author> <year> 1971. </year> <title> Computer Structures: Readings and Examples. </title> <address> New York: McGraw-Hill. </address> <note> 21 Cifuentes, </note> <author> Cristina and K. John Gough. </author> <year> 1995 </year> <month> (July). </month> <title> Decompilation of binary programs. </title> <journal> Software|Practice & Experience, </journal> <volume> 25(7) </volume> <pages> 811-829. </pages>
Reference: <author> Cifuentes, Cristina, Doug Simon, and Antoine Fraboulet. </author> <year> 1998. </year> <title> Assembly to high-level language translation. </title> <booktitle> In Proceedings of the International Conference on Software Maintenance. To appear. </booktitle>
Reference-contexts: not put branches in delay slots (Kane 1988, Appendix A), and a I false always, so a single instance of this strategy applies to every branch instruction (Srivastava and Wall 1993). 18 5 Experience We have used translators for delayed branches in two tools: a binary translator and a decompiler <ref> (Cifuentes, Simon, and Fraboulet 1998) </ref>. In both tools, we translate machine instructions into a low-level, machine-independent intermediate form without delayed branches. The binary translator uses this form to generate target code, applying standard optimization techniques. The de-compiler analyzes the intermediate form to recover high-level information like structured control flow.
Reference: <author> Cmelik, Bob and David Keppel. </author> <year> 1994 </year> <month> (May). </month> <title> Shade: A fast instruction-set simulator for execution profiling. </title> <booktitle> In Proceedings of the 1994 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 128-137. </pages>
Reference: <author> Danvy, Olivier, Karoline Malmkjr, and Jens Palsberg. </author> <year> 1996 </year> <month> (November). </month> <title> Eta-expansion does The Trick. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 18(6) </volume> <pages> 730-751. </pages>
Reference-contexts: We then use "The Trick" from partial evaluation <ref> (Danvy, Malmkjr, and Palsberg 1996) </ref>: whenever [[a I ]] is free in a statement S, we replace S with if [[a I ]] then S else S fi. The Trick enables us to replace several calls to loop with calls to stable.
Reference: <author> Hoffman, Thomas. </author> <year> 1997 </year> <month> (March 24). </month> <title> Recovery firm hot on heels of missing source code. </title> <publisher> Computer World. </publisher>
Reference: <author> Jones, Neil D., Carsten K. Gomard, and Peter Sestoft. </author> <year> 1993 </year> <month> (June). </month> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> International Series in Computer Science: </booktitle> <publisher> Prentice Hall International. </publisher> <address> ISBN number 0-13-020249-5 (pbk). </address>
Reference-contexts: Many of the ideas in this paper are not new. Register-transfer languages have been used to describe instructions for years (Bell and Newell 1971; Bar-bacci and Siewiorek 1982). Our program transformations draw from standard compiler-optimization techniques (Aho, Sethi, and Ullman 1986) and standard partial-evaluation techniques <ref> (Jones, Gomard, and Sestoft 1993) </ref>.
Reference: <author> Kane, Gerry. </author> <year> 1988. </year> <title> MIPS RISC Architecture. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: Interestingly, the MIPS architecture manual specifies that the machine's behavior in this case is undefined <ref> (Kane 1988, Appendix A) </ref>. <p> The last three entries in Table 1 show how this strategy is applied to the unconditional (SD), conditional (SCD ), and conditional annuled (SCDA) branches on the SPARC. On the MIPS, programmers may not put branches in delay slots <ref> (Kane 1988, Appendix A) </ref>, and a I false always, so a single instance of this strategy applies to every branch instruction (Srivastava and Wall 1993). 18 5 Experience We have used translators for delayed branches in two tools: a binary translator and a decompiler (Cifuentes, Simon, and Fraboulet 1998).
Reference: <author> Larus, James R. and Thomas Ball. </author> <year> 1994 </year> <month> (February). </month> <title> Rewriting executable files to measure program behavior. </title> <journal> Software|Practice & Experience, </journal> <volume> 24(2) </volume> <pages> 197-218. </pages>
Reference: <author> Larus, James R. and Eric Schnarr. </author> <year> 1995 </year> <month> (June). </month> <title> EEL: machine-independent executable editing. </title> <booktitle> Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 30(6) </volume> <pages> 291-300. </pages>
Reference: <author> Milner, Robin. </author> <year> 1990. </year> <title> Operational and algebraic semantics of concurrent processes. </title> <editor> In van Leewen, J., editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. </volume> <editor> B: </editor> <title> Formal Models and Semantics, </title> <booktitle> chapter 19, </booktitle> <pages> pages 1201-1242. </pages> <address> New York, N.Y.: </address> <publisher> The MIT Press. </publisher>
Reference: <author> Ramsey, Norman and Jack W. Davidson. </author> <year> 1998 </year> <month> (June). </month> <title> Machine descriptions to build tools for embedded systems. </title> <booktitle> In ACM SIGPLAN Workshop on Languages, Compilers, and Tools for Embedded Systems (LCTES'98), Vol. 1474 of LNCS, </booktitle> <pages> pages 172-188. </pages> <publisher> Springer Verlag. </publisher>
Reference-contexts: Our method uses register-transfer lists (RTLs) as a semantic framework in which to reason about instructions on both the source and target machines <ref> (Ramsey and Davidson 1998) </ref>. We divide a machine's semantics into two parts. We specify semantics common to most instructions (e.g., the advancement of the program counter) as part of a simple imperative program representing the execution loop of a machine. <p> RTLs provide a uniform framework that can express source instructions, target instructions, and their interpretations by the source and target processors. 2.1 Register transfer lists Our RTL formalism is designed for use in tools and component generators, and it makes machine-dependent computation explicit <ref> (Ramsey and Davidson 1998) </ref>.
Reference: <author> Shankar, Natarajan. </author> <year> 1996 </year> <month> (May). </month> <title> Steps towards mechanizing program transformations using PVS. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 26(1-3):33-57. </address> <note> 22 Sites, </note> <author> Richard L., Anton Chernoff, Matthew B. Kirk, Maurice P. Marks, and Scott G. Robinson. </author> <year> 1993 </year> <month> (February). </month> <title> Binary translation. </title> <journal> Communications of the ACM, </journal> <volume> 36(2) </volume> <pages> 69-81. </pages> <note> SPARC International. </note> <year> 1992. </year> <title> The SPARC Architecture Manual, </title> <type> Version 8. </type> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: All the transformations discussed in this paper were done by hand. We investigated tools that might have helped us transform stable, but we were left with the impression that this is still a research problem <ref> (Shankar 1996) </ref>, and it was easy enough to transform stable by hand. By contrast, it would be very useful to automate the derivation of the translator from stable and the discovery of the translations of the a I 's, b I 's, and I c 's.
Reference: <author> Srivastava, Amitabh and David W. Wall. </author> <year> 1993 </year> <month> (March). </month> <title> A practical system for intermodule code optimization. </title> <journal> Journal of Programming Languages, </journal> <volume> 1 </volume> <pages> 1-18. </pages> <note> Also available as WRL Research Report 92/6, </note> <month> December </month> <year> 1992. </year>
Reference-contexts: The results of the method are being applied to a binary translator, and they could profitably be applied to other tools that analyze machine instructions, including optimizers <ref> (Srivastava and Wall 1993) </ref>, code instrumentors (Wall 1992; Larus and Ball 1994; Larus and Schnarr 1995), fault isolators (Wahbe et al. 1993), and decompilers (Cifuentes and Gough 1995; Hoffman 1997; Cifuentes, Simon, and Fraboulet 1998). <p> On the MIPS, programmers may not put branches in delay slots (Kane 1988, Appendix A), and a I false always, so a single instance of this strategy applies to every branch instruction <ref> (Srivastava and Wall 1993) </ref>. 18 5 Experience We have used translators for delayed branches in two tools: a binary translator and a decompiler (Cifuentes, Simon, and Fraboulet 1998). In both tools, we translate machine instructions into a low-level, machine-independent intermediate form without delayed branches.
Reference: <author> Wahbe, Robert, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. </author> <year> 1993 </year> <month> (December). </month> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 203-216. </pages>
Reference-contexts: The results of the method are being applied to a binary translator, and they could profitably be applied to other tools that analyze machine instructions, including optimizers (Srivastava and Wall 1993), code instrumentors (Wall 1992; Larus and Ball 1994; Larus and Schnarr 1995), fault isolators <ref> (Wahbe et al. 1993) </ref>, and decompilers (Cifuentes and Gough 1995; Hoffman 1997; Cifuentes, Simon, and Fraboulet 1998). Our method uses register-transfer lists (RTLs) as a semantic framework in which to reason about instructions on both the source and target machines (Ramsey and Davidson 1998).
Reference: <author> Wall, David W. </author> <year> 1992. </year> <title> Systems for late code modification. </title> <editor> In Giegerich, Robert and Susan L. Graham, editors, </editor> <title> Code Generation - Concepts, </title> <booktitle> Tools, Techniques, </booktitle> <pages> pages 275-293. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This transformation leads to a translation in which I 0 c moves ahead of the branch, and I 0 c 's successor follows the branch. Epoxie and Noxie use this translation <ref> (Wall 1992) </ref>. The problem is that, if the branch condition b I tests condition codes, and I 0 c sets condition codes, it will be necessary to save and restore the condition codes in order to get the correct branch instruction.
Reference: <author> Witchel, Emmett and Mendel Rosenblum. </author> <year> 1996 </year> <month> (May23-26 ). Embra: </month> <title> Fast and flexible machine simulation. </title> <booktitle> In Proceedings of the ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems, Vol. 24,1 of ACM SIG-METRICS Performance Evaluation Review, </booktitle> <pages> pages 68-79, </pages> <address> New York. </address> <month> 23 </month>
References-found: 18

