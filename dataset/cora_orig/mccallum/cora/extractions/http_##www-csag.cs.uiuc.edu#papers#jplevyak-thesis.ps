URL: http://www-csag.cs.uiuc.edu/papers/jplevyak-thesis.ps
Refering-URL: http://www-csag.cs.uiuc.edu/papers/index.html
Root-URL: http://www.cs.uiuc.edu
Title: c  
Author: flCopyright by John Bradley Plevyak 
Date: 1996  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> O. Agesen, J. Palsberg, and M. Schwartzbach. </author> <title> Type inference of Self: Analysis of objects with dynamic and multiple inheritance. </title> <booktitle> In Proceedings of ECOOP '93, </booktitle> <year> 1993. </year>
Reference-contexts: Type inference in object-oriented languages in particular has been studied for many years [169, 78]. Constraint-based type inference is described by Palsberg, Schwartzbach and Oxhtj in [136, 135]. Their approach was limited to a single level of discrimination and motivated our efforts to develop an extendible approach. Agesen <ref> [1, 3] </ref> extended the basic one level approach to handle the features of SELF [176]. His technique is limited to eager splitting, and is incapable of handling polymorphic data structures which are destructively updated as a result of his single pass approach. <p> In general, the optimization criteria can depend on any analyzed property. Also, analysis may distinguish method contours by arbitrary aspects of the calling environment including: the contours from which they were invoked [135], the types of all the arguments <ref> [1] </ref> and other criteria [105]. As a result, a call graph on contours cannot, in general, be realized by the standard dispatch mechanism. 110 6.3 Modified Dynamic Dispatch Mechanism Cloning modifies the call graph by replicating subgraphs which are then called by only a subset of the previous callers. <p> In theory, flow analyses produce O (N ), O (N 2 ), O (N 6 ) or more contours for a program of size N <ref> [136, 135, 1, 105] </ref> and can require large amounts of space [3]. The adaptive analysis in Chapter 5 creates contours in response to imprecisions discovered in previous iterations.
Reference: [2] <author> Ole Agesen. </author> <title> The cartesian product algorithm: Simple and precise type inference of parametric polymorphism. </title> <booktitle> In Proceedings of ECOOP '95, </booktitle> <pages> pages 2-26. </pages> <note> Springer-Verlag Lecture Notes in Computer Science No. 952, </note> <year> 1995. </year>
Reference-contexts: It remains the only practical and demonstrated analysis capable of analyzing both polymorphic methods and polymorphic classes in the presence of imperative update (i.e. real object-oriented programs as opposed to functional or functional object-oriented 9 programs). The most powerful comparable analysis <ref> [2] </ref> is limited to polymorphic methods and has not been used for context sensitive optimization (in [3] context sensitive information was summarized before optimization). 2. A new cloning algorithm [142] which represents the first application of whole program cloning to object-oriented programs. <p> Environments are composed of the values of the arguments at the time of the invocation. The classes and methods associated with arguments therefore represent a useful basis of distinction. For example, the Cartesian Product Algorithm <ref> [2] </ref> differentiates contours based on the cross-product of the classes of the arguments. Likewise, Jagannathan and Weeks [105] differentiate contours based on the abstract values of the arguments. The Cartesian Product Algorithm and Jagannathan and Weeks' solutions determine the contour abstraction immediately.
Reference: [3] <author> Ole Agesen and Urs Holzle. </author> <title> Type feedback vs. concrete type analysis: A comparison of optimization techniques for object-oriented languages. </title> <booktitle> In Proceedings of OOPSLA'95, </booktitle> <pages> pages 91-107, </pages> <year> 1995. </year>
Reference-contexts: The most powerful comparable analysis [2] is limited to polymorphic methods and has not been used for context sensitive optimization (in <ref> [3] </ref> context sensitive information was summarized before optimization). 2. A new cloning algorithm [142] which represents the first application of whole program cloning to object-oriented programs. <p> Type inference in object-oriented languages in particular has been studied for many years [169, 78]. Constraint-based type inference is described by Palsberg, Schwartzbach and Oxhtj in [136, 135]. Their approach was limited to a single level of discrimination and motivated our efforts to develop an extendible approach. Agesen <ref> [1, 3] </ref> extended the basic one level approach to handle the features of SELF [176]. His technique is limited to eager splitting, and is incapable of handling polymorphic data structures which are destructively updated as a result of his single pass approach. <p> In theory, flow analyses produce O (N ), O (N 2 ), O (N 6 ) or more contours for a program of size N [136, 135, 1, 105] and can require large amounts of space <ref> [3] </ref>. The adaptive analysis in Chapter 5 creates contours in response to imprecisions discovered in previous iterations. <p> While this can remove dynamic dispatches across method invocations, it does not handle polymorphic instance variables. Finally, Agesen and Holzle have recently used the results of 124 global analysis in the Self compiler <ref> [3] </ref>. However, the information for all the contours for each customized method is combined before being used by the optimizer. The cloning algorithm we have presented is general enough to enable optimization based on any data flow information provided by global flow analysis.
Reference: [4] <author> G. Agha and C. Hewitt. </author> <title> Object-Oriented Concurrent Programming, chapter on Actors: </title>
Reference-contexts: Generally speaking, the more dynamic the language the more powerful and the more difficult to compile for efficient execution. 2.4.2 Concurrent Object-Oriented Programming Concurrent object-oriented programming extends the object-oriented paradigm for concurrent, parallel and/or distributed computing. The Actors <ref> [92, 46, 5, 4] </ref> model, is based on a simple but powerful semantics. A number of different systems using this model have been created. For example, languages based on Actors include: the dialects of ABCL [183, 170, 186], HAL [101, 115], ACORE [126] and Rosette [174].
References-found: 4

