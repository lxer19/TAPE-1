URL: http://www.cs.iastate.edu/tech-reports/TR94-04.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Synthesizing Structured Analysis and Object-Oriented Specifications  
Author: David L. Coleman and Albert L. Baker David L. Coleman and Albert L. Baker, 
Keyword: Categories and Subject Descriptors: D.2.1 [Software Engineering] Requirements/Specifications languages, methodologies; D.2.2 [Software Engineering] Tools and Techniques computer-aided software engineering (CASE); D.4.7 [Operating Systems] Organization and Design distributed systems Additional Key Words and Phrases: distributed systems specifications, formalized structured analysis, data flow diagrams  
Note: TR #94-04 March 1994  Submitted to IEEE Transactions on Software Engineering c  1994. All rights reserved.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. L. Baker, J. M. Bieman, and P. N. Clites. </author> <title> Implications for formal specifications: Results of specifying a software engineering tool. </title> <booktitle> In Proceedings of the Eleventh Annual International Computer Software & Applications Conference (COMPSAC-87), </booktitle> <address> Tokyo, Japan, </address> <month> October </month> <year> 1987. </year> <journal> IEEE Computer Society and Information Processing Society of Japan. </journal>
Reference-contexts: The graphical representations provide convenient high-level views of system functionality. However, the underlying functionality of individual graphic elements, as well as the specific semantics of the element interfaces, are not rigorously defined [15, 7, 6]. Thus a traditional SA specification is not formal. SPECS <ref> [1] </ref> is a formal, model-based specification language analogous to Z [11], VDM [13] and Larch/C++ [5, 18, 17]. Model-based specifications use discrete mathematical structures to model the state of a system and to define the operations that transform system state. <p> The example DFD-SPEC is for a client-server application. The clients in this example can view "the services provided" as a simple ADT Table. This ADT Table is the example we use in this section to introduce SPECS. A complete definition of SPECS is found in <ref> [1, 2] </ref>. 11 3.1 An Example ADT The ADT below illustrates the syntax and semantics of SPECS. Note the two main sections of the specification of ADT Table: domain and operations.
Reference: [2] <author> Albert L. Baker and David D. Riley. </author> <title> Data Abstraction and Object-Oriented Software Development. </title> <institution> University Level Computer Science Program, IBM Corporation, </institution> <year> 1993. </year> <note> (Course Notes). </note>
Reference-contexts: The example DFD-SPEC is for a client-server application. The clients in this example can view "the services provided" as a simple ADT Table. This ADT Table is the example we use in this section to introduce SPECS. A complete definition of SPECS is found in <ref> [1, 2] </ref>. 11 3.1 An Example ADT The ADT below illustrates the syntax and semantics of SPECS. Note the two main sections of the specification of ADT Table: domain and operations.
Reference: [3] <author> Jean-Pierre Ban^atre and Daniel Le Metayer. </author> <title> Programming by multiset transformation. </title> <journal> Communications of the ACM, </journal> <volume> 36(1) </volume> <pages> 98-111, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: We have developed a semantic notion of what it means for a DFD process to execute, and an assertional 1 In <ref> [3] </ref>, Ban^atre and Metayer make the distinction between logical parallelism, the possibility of describing a program as a composition of several independent tasks, and physical parallelism, the distribution of tasks on several processors. 3 approach to defining when a process executes and what "values" are produced.
Reference: [4] <author> Barry Boehm. </author> <title> Software Engineering Economics. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1981. </year>
Reference-contexts: request and Alpha will eventually grant lock approval so Beta can complete it's write request. 6 Conclusions It has been over 13 years since Boehm first documented that fixing errors during the specification phase of software development is orders of magnitude cheaper than fixing these errors in the maintenance phase <ref> [4] </ref>. And in the interim, considerable progress has been made in more formal and practical specification techniques for traditional, sequential software systems. However, more and more systems are not simply sequential. Every application that uses a network-based licensing scheme must deal with this evolving world of distributed and concurrent systems.
Reference: [5] <author> Yoonsik Cheon and Gary T. Leavens. </author> <title> A quick overview of Larch/C++. </title> <type> Technical Report 93-18, </type> <institution> Department of Computer Science, Iowa State University, </institution> <month> June </month> <year> 1993. </year> <note> To appear in the Journal of Object-Oriented Programming. Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: However, the underlying functionality of individual graphic elements, as well as the specific semantics of the element interfaces, are not rigorously defined [15, 7, 6]. Thus a traditional SA specification is not formal. SPECS [1] is a formal, model-based specification language analogous to Z [11], VDM [13] and Larch/C++ <ref> [5, 18, 17] </ref>. Model-based specifications use discrete mathematical structures to model the state of a system and to define the operations that transform system state. Model-based specification methods are well-suited to the specification of Abstract Data Types (ADT's). Hence they foster an object-oriented approach to software development.
Reference: [6] <author> David L. Coleman. </author> <title> Formalized Structured Analysis Specifications. </title> <type> PhD thesis, </type> <institution> Iowa State University, Ames, Iowa 50011, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: SA specifications are often touted as easily comprehensible to both users and technicians. The graphical representations provide convenient high-level views of system functionality. However, the underlying functionality of individual graphic elements, as well as the specific semantics of the element interfaces, are not rigorously defined <ref> [15, 7, 6] </ref>. Thus a traditional SA specification is not formal. SPECS [1] is a formal, model-based specification language analogous to Z [11], VDM [13] and Larch/C++ [5, 18, 17]. <p> With respect to flows, we have resolved issues like formal abstract data type (ADT) specifications for flow values, continuous vs. discrete flows, flow convergence, flow divergence, and balancing flows across different levels of decomposition. Our initial results are contained in <ref> [6] </ref>. In this paper, we focus on our results pertaining to "what bubbles mean". (However, this requires resolution of some of the issues pertaining to flows enumerated in the preceding paragraph.) Bubbles in DFD-SPECS actually warrant the label "process", as opposed to "procedure". <p> There are analogous ambiguities in the interpretation of convergences and dialogue flows. <ref> [6] </ref> contains a resolution to these semantic ambiguities in these flow constructs. The resolution of these ambiguities is based on labeling flows with both flow names and types and providing formal specifications of the flow types in the DDE's. <p> How do stores represent data? 8 2. When, and by what stimulus, do stores produce values on their out-flows? 3. When, and by what mechanism, do stores receive values on their in-flows? 4. Do stores process data like a bubble or are they in some sense more passive? Again, <ref> [6] </ref> contains a resolution to these questions concerning stores. We suggest that stores are not "primitive" in the same sense as bubbles and flows in that stores can be modeled as DFD's that contain only bubbles and flows. <p> Bubbles specified using P-Specs are called primitive bubbles. In fact, the more formal semantics we provide for DFD's requires that we view a DFD as a network of primitive bubbles. Thus, for the purpose of this paper, we deal with DFD's containing only primitive bubbles. See <ref> [6] </ref> for further discussion of the issues in providing a more formal semantics for leveled DFD's. 3 SPECS SPECS is a model-based language for specifying ADT's. It was developed at Iowa State University as a research tool and for use in Software Engineering courses at the graduate and undergraduate level.
Reference: [7] <author> David L. Coleman and Albert L. Baker. </author> <title> Deliberations on Kung's process interface modeling. </title> <journal> The Journal of Systems and Software, </journal> <volume> 15(2) </volume> <pages> 193-198, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: SA specifications are often touted as easily comprehensible to both users and technicians. The graphical representations provide convenient high-level views of system functionality. However, the underlying functionality of individual graphic elements, as well as the specific semantics of the element interfaces, are not rigorously defined <ref> [15, 7, 6] </ref>. Thus a traditional SA specification is not formal. SPECS [1] is a formal, model-based specification language analogous to Z [11], VDM [13] and Larch/C++ [5, 18, 17]. <p> In effect, the control transformation hierarchy provides a representation of control structure similar to a calling chart for imperative programs, or a master-slave implementation architecture for concurrent or distributed systems. Our research and research by Kung lead us to question whether control transformations are necessary for specifications <ref> [7, 15] </ref>. In DFD-SPECS, the specification of a process bubble provides self-determination of when a process bubble executes. Kung developed an expression notation for representing when a process bubble could "do it's work" and what outputs would be produced. <p> able to fully specify their functional behavior. (If one of our readers has a complete specification for the ubiquitous terminator USER, please send us a copy immediately.) However, modeling the temporal behavior of terminators does allow us to check the consistency of the system's temporal interaction with its external environment <ref> [7] </ref>. In the case where a terminator represents an external system or device, such as a file system, then the functional behavior of the terminator is just the specification of that system.
Reference: [8] <author> Tom DeMarco. </author> <title> Structured Analysis and System Specification. </title> <publisher> Yourdon, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1978. </year>
Reference-contexts: DFD-SPECS is a formal method that is well-suited to the specification of distributed or concurrent systems. It is essentially a synthesis of Structured Analysis (SA) and formal Object-Oriented (OO) specification techniques. SA specifications are a commonly used, graphical technique for describing system architecture <ref> [8, 26] </ref>. SA specifications are often touted as easily comprehensible to both users and technicians. The graphical representations provide convenient high-level views of system functionality. However, the underlying functionality of individual graphic elements, as well as the specific semantics of the element interfaces, are not rigorously defined [15, 7, 6]. <p> A DFD is data-focused, as opposed to procedural-focused, and represents information flow in systems. A DFD depicts the source of each process's information and the destination of 4 each process's output. In this section we adopt the graphical and syntactic notation for DFD's used by De Marco <ref> [8] </ref> and Yourdon [26]. Figure 1 provides a simple DFD. 2 The four components of a DFD are: 1. Bubbles, represented by circles with an associated P-Spec (or DFD refinement, if dealing with hierarchical DFD's), 2. Flows, represented by directed edges with an associated DD entry (DDE), 3. <p> Various representations of this functionality have appeared in the traditional SA literature, including decision tables and decision trees, structured English (pseudo code), flowcharts and Nassi-Shneiderman diagrams, and even informal English [9]. The first three methods represent those traditionally used by De Marco <ref> [8] </ref>. Use of these techniques result in either ambiguity or over specification|in the sense that the specification contains data structure design and implementation details.
Reference: [9] <author> Marvin Gore and John Stubble. </author> <title> Elements of Systems Analysis. Wm. </title> <address> C. </address> <publisher> Brown Company, </publisher> <address> Debuque, Iowa, </address> <year> 1983. </year> <month> 48 </month>
Reference-contexts: Thus an individual P-Spec should define the relation of out-flow values to in-flow values. Various representations of this functionality have appeared in the traditional SA literature, including decision tables and decision trees, structured English (pseudo code), flowcharts and Nassi-Shneiderman diagrams, and even informal English <ref> [9] </ref>. The first three methods represent those traditionally used by De Marco [8]. Use of these techniques result in either ambiguity or over specification|in the sense that the specification contains data structure design and implementation details.
Reference: [10] <author> D. Hatley and E. Pirbhai. </author> <title> Strategies for Real-Time System Specification. </title> <publisher> Dorset House, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: Thus continuous flows behave much like a shared variable in a concurrent system. On the other hand, Hatley and Pirbhai also use the terms discrete and continuous to describe the way in which flow values change <ref> [10] </ref>. In their usage, each discrete flow describes a function mapping time to a set of discrete values. Each continuous flow describes a function mapping time to a continuous set of values.
Reference: [11] <author> Ian Hayes, </author> <title> editor. Specification Case Studies. </title> <publisher> Prentice-Hall, </publisher> <address> London, </address> <year> 1987. </year>
Reference-contexts: However, the underlying functionality of individual graphic elements, as well as the specific semantics of the element interfaces, are not rigorously defined [15, 7, 6]. Thus a traditional SA specification is not formal. SPECS [1] is a formal, model-based specification language analogous to Z <ref> [11] </ref>, VDM [13] and Larch/C++ [5, 18, 17]. Model-based specifications use discrete mathematical structures to model the state of a system and to define the operations that transform system state. Model-based specification methods are well-suited to the specification of Abstract Data Types (ADT's).
Reference: [12] <author> John E. Hopcroft and Jeffery D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison Wesley, </publisher> <year> 1979. </year>
Reference-contexts: We then added formal assertions to specify process functionality. 4.5 Assertional P-Specs In DFD-SPECS, a bubble is an abstraction of a true concurrent process. P-Specs are expressed using a variation of state transition machines referred to as Mealy machines <ref> [12] </ref>. The behavior of a bubble is defined by the labeling of the state transitions in the P-Spec. Each transition labeling has the following form: &lt;enabling-condition&gt;:&lt;precondition&gt;j=&lt;postcondition&gt; 19 The enabling-condition provides the specification of when a bubble may execute.
Reference: [13] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Prentice-Hall International Ltd, </publisher> <address> London, </address> <year> 1986. </year>
Reference-contexts: However, the underlying functionality of individual graphic elements, as well as the specific semantics of the element interfaces, are not rigorously defined [15, 7, 6]. Thus a traditional SA specification is not formal. SPECS [1] is a formal, model-based specification language analogous to Z [11], VDM <ref> [13] </ref> and Larch/C++ [5, 18, 17]. Model-based specifications use discrete mathematical structures to model the state of a system and to define the operations that transform system state. Model-based specification methods are well-suited to the specification of Abstract Data Types (ADT's). Hence they foster an object-oriented approach to software development.
Reference: [14] <author> M. Kong and et. al. </author> <title> Network Computing System Reference Manual. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1990. </year>
Reference-contexts: The 46 view of the replicated server system as simply ADT Table is not acceptable, particularly for the implementers of the replicated server system. However, a prototype written in C, and using even a high-level network implementation platform like NCS-RPC <ref> [14] </ref>, will contain too much detail for systematic analysis of issues like synchronization primitives. We think DFD-SPECS provides an appropriate middle ground well-suited to the specification phase of software development.
Reference: [15] <author> Chenho Kung. </author> <title> Process interface modeling and consistency checking. </title> <journal> The Journal of Systems and Software, </journal> <volume> 15(2), </volume> <month> May </month> <year> 1991. </year>
Reference-contexts: SA specifications are often touted as easily comprehensible to both users and technicians. The graphical representations provide convenient high-level views of system functionality. However, the underlying functionality of individual graphic elements, as well as the specific semantics of the element interfaces, are not rigorously defined <ref> [15, 7, 6] </ref>. Thus a traditional SA specification is not formal. SPECS [1] is a formal, model-based specification language analogous to Z [11], VDM [13] and Larch/C++ [5, 18, 17]. <p> In effect, the control transformation hierarchy provides a representation of control structure similar to a calling chart for imperative programs, or a master-slave implementation architecture for concurrent or distributed systems. Our research and research by Kung lead us to question whether control transformations are necessary for specifications <ref> [7, 15] </ref>. In DFD-SPECS, the specification of a process bubble provides self-determination of when a process bubble executes. Kung developed an expression notation for representing when a process bubble could "do it's work" and what outputs would be produced.
Reference: [16] <author> G. T. Leavens, T. Wahls, A. L. Baker, and K. Lyle. </author> <title> An operational semantics of firing rules for structured analysis style data flow diagrams. </title> <note> 1993. (submitted). </note>
Reference-contexts: This operational semantics, or execution, of a DFD-SPEC is derived from the enabling and firing of processes. A two step firing rule is used to model computation <ref> [16] </ref>. Each process is either in a working meta-state or an idle meta-state. In an idle meta-state, the process is monitoring its in-flows and waiting to become enabled. In a working meta-state, the process has already consumed its enabling in-flows and has yet to produce its out-flows. <p> For example, we could have just as easily used our more recently developed SPECS-C++ language and specified each DDE as a C++ class. We could have also used any of the Larch interface specification languages. <ref> [16] </ref> is based on the work presented in this paper and contains a formal operational semantics of formalized data flow diagrams that is independent of the particular specification language used in the DDE's. <p> Note that this two step firing is needed to appropriately model the concurrent behavior of systems. (See <ref> [16] </ref> for further discussion.) However, we have to view the interface behavior of a DFD, i.e., its interface with the terminators, through a sequence of such bubble firings. In fact, the enabling rules (and bubble states) precisely capture the synchronization primitives of the concurrent system.
Reference: [17] <author> Gary T. Leavens and Yoonsik Cheon. </author> <note> Larch/C++ reference manual. Available by anonymous ftp from ftp.cs.iastate.edu., </note> <year> 1993. </year>
Reference-contexts: However, the underlying functionality of individual graphic elements, as well as the specific semantics of the element interfaces, are not rigorously defined [15, 7, 6]. Thus a traditional SA specification is not formal. SPECS [1] is a formal, model-based specification language analogous to Z [11], VDM [13] and Larch/C++ <ref> [5, 18, 17] </ref>. Model-based specifications use discrete mathematical structures to model the state of a system and to define the operations that transform system state. Model-based specification methods are well-suited to the specification of Abstract Data Types (ADT's). Hence they foster an object-oriented approach to software development.
Reference: [18] <author> Gary T. Leavens and Yoonsik Cheon. </author> <title> Preliminary design of Larch/C++. </title> <editor> In U. Martin and J. Wing, editors, </editor> <booktitle> Proceedings of the First International Workshop on Larch, </booktitle> <month> July, </month> <year> 1992, </year> <booktitle> Workshops in Computing, </booktitle> <pages> pages 159-184. </pages> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1993. </year>
Reference-contexts: However, the underlying functionality of individual graphic elements, as well as the specific semantics of the element interfaces, are not rigorously defined [15, 7, 6]. Thus a traditional SA specification is not formal. SPECS [1] is a formal, model-based specification language analogous to Z [11], VDM [13] and Larch/C++ <ref> [5, 18, 17] </ref>. Model-based specifications use discrete mathematical structures to model the state of a system and to define the operations that transform system state. Model-based specification methods are well-suited to the specification of Abstract Data Types (ADT's). Hence they foster an object-oriented approach to software development.
Reference: [19] <author> Tadao Murata. </author> <title> Modeling and analysis of concurrent systems. </title> <editor> In C. R. Vick and C. V. Ra-mamoorthy, editors, </editor> <booktitle> Handbook of Software Engineering, </booktitle> <pages> pages 39-63. </pages> <publisher> Van Nostrand Reinhold Company Inc., </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: There are some graphics-based specification techniques for distributed or concurrent systems, several of which are variations on petri nets [20, 25]. Petri net specifications can be mathematically analyzed for synchronization issues like deadlock, liveliness, etc., <ref> [19] </ref>. However, petri net specifications generally lack a representation for functionality. They address only synchronization issues and do not describe the explicit functionality of a system. DFD-SPECS provides a model of concurrency similar to petri nets, but also supports the precise specification of system functionality.
Reference: [20] <author> James L. Peterson. </author> <title> Petri Net Theory and the Modeling of Systems. </title> <publisher> Prentice Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1981. </year> <month> 49 </month>
Reference-contexts: While such techniques provide the requisite rigor, they may require a level of mathematical sophistication that is simply not cost-effectively achieved in production software development environments. There are some graphics-based specification techniques for distributed or concurrent systems, several of which are variations on petri nets <ref> [20, 25] </ref>. Petri net specifications can be mathematically analyzed for synchronization issues like deadlock, liveliness, etc., [19]. However, petri net specifications generally lack a representation for functionality. They address only synchronization issues and do not describe the explicit functionality of a system. <p> The out-flow values produced propagate through the DFD according to the semantics of consumable and persistent flows described earlier. This execution interpretation is similar to the execution of a petri net <ref> [20] </ref>. Thus DFD-SPECS are well suited to the specification of the synchronization primitives of concurrent or distributed systems [25]. 5 A Replicated Server Example Recall the ADT Table from Section 3. In this section we specify a distributed implementation of Table using two servers.
Reference: [21] <author> John Rushby, Friedrich von Henke, and Sam Owre. </author> <title> An introduction to formal specification and verification using EHDM. </title> <type> Technical report, </type> <institution> Computer Science Laboratory, SRI International, </institution> <year> 1991. </year>
Reference-contexts: While this design level perspective must subsequently be addressed, specifications should be able to represent potential for concurrency independent of these design-level concerns. 1 Existing formal specification techniques for distributed or concurrent systems are often text-based and incorporate forms of temporal logic <ref> [21] </ref>. While such techniques provide the requisite rigor, they may require a level of mathematical sophistication that is simply not cost-effectively achieved in production software development environments. There are some graphics-based specification techniques for distributed or concurrent systems, several of which are variations on petri nets [20, 25].
Reference: [22] <author> T. Wahls, A. L. Baker, and Leavens G. T. </author> <title> A formal (and executable) semantics for rt-specs. </title> <note> 1993. (submitted). </note>
Reference-contexts: We think DFD-SPECS provides an appropriate middle ground well-suited to the specification phase of software development. There are two recent research developments stemming from the work described in this paper that may be worth highlighting. <ref> [22] </ref> contains a description of an executable formal semantics for a variation of DFD-SPECS. One can think of the operational semantics provided in [22] paper as an interpreter for DFD-SPECS. The operational semantics is written in the programming language Standard ML, and requires input in an ML-like syntax. <p> There are two recent research developments stemming from the work described in this paper that may be worth highlighting. <ref> [22] </ref> contains a description of an executable formal semantics for a variation of DFD-SPECS. One can think of the operational semantics provided in [22] paper as an interpreter for DFD-SPECS. The operational semantics is written in the programming language Standard ML, and requires input in an ML-like syntax.
Reference: [23] <author> Paul T. Ward. </author> <title> The transformation schema: An extension of the data flow diagram to represent control and timing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(2):198-210, </volume> <month> February </month> <year> 1986. </year>
Reference-contexts: A formalization of stores, not provided in this paper, may contribute additional varieties of DDE's. 4.3 Flow Value Behaviors Ward uses the terms discrete and continuous to describe flows <ref> [23] </ref>. A discrete flow may contain zero or more instances of a flow value at any point in time. Discrete flow values are produced by the flow's source and destructively consumed by the flow's destination. Thus discrete flows behave much like a time-ordered message channel in a distributed system. <p> A process, since it may always be active, can remember previous results. This is not necessarily a definitive list of differences, but does serve to distinguish the concepts. 18 Real-time extensions to SA do provide for the direct specification of when a DFD bubble can execute <ref> [23] </ref>. Ward provides two types of DFD bubbles; one a traditional "data transformation" bubble; the other a "control transformation." Control transformations serve to activate and deactivate data transformations. Typically, only one control transformation may activate or deactivate a data transformation.
Reference: [24] <author> Paul T. Ward and Stephen J. Mellor. </author> <title> Structured Development for Real-Time Systems, volume 3: Implementation Modeling Techniques. </title> <publisher> Yourdon, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1986. </year>
Reference-contexts: Most widely-known specification techniques, both formal and informal, do not readily lend themselves to the specification of distributed or concurrent systems. Those practical techniques that do claim to specify distributed or concurrent systems typically operate at a design level, 2 e.g., requiring a master-slave process architecture <ref> [24] </ref>. While this design level perspective must subsequently be addressed, specifications should be able to represent potential for concurrency independent of these design-level concerns. 1 Existing formal specification techniques for distributed or concurrent systems are often text-based and incorporate forms of temporal logic [21].
Reference: [25] <author> Stephen S. Yau and Mehmet U. Cadayan. </author> <title> Distributed software system design representation using modified petri nets. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-9(6):733-745, </volume> <month> November </month> <year> 1983. </year>
Reference-contexts: While such techniques provide the requisite rigor, they may require a level of mathematical sophistication that is simply not cost-effectively achieved in production software development environments. There are some graphics-based specification techniques for distributed or concurrent systems, several of which are variations on petri nets <ref> [20, 25] </ref>. Petri net specifications can be mathematically analyzed for synchronization issues like deadlock, liveliness, etc., [19]. However, petri net specifications generally lack a representation for functionality. They address only synchronization issues and do not describe the explicit functionality of a system. <p> The out-flow values produced propagate through the DFD according to the semantics of consumable and persistent flows described earlier. This execution interpretation is similar to the execution of a petri net [20]. Thus DFD-SPECS are well suited to the specification of the synchronization primitives of concurrent or distributed systems <ref> [25] </ref>. 5 A Replicated Server Example Recall the ADT Table from Section 3. In this section we specify a distributed implementation of Table using two servers. We assume processes do not fail and have not specified system error recovery.
Reference: [26] <author> Edward Yourdon. </author> <title> Modern Structured Analysis. </title> <publisher> Yourdon Press computing series. Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1989. </year> <month> 50 </month>
Reference-contexts: DFD-SPECS is a formal method that is well-suited to the specification of distributed or concurrent systems. It is essentially a synthesis of Structured Analysis (SA) and formal Object-Oriented (OO) specification techniques. SA specifications are a commonly used, graphical technique for describing system architecture <ref> [8, 26] </ref>. SA specifications are often touted as easily comprehensible to both users and technicians. The graphical representations provide convenient high-level views of system functionality. However, the underlying functionality of individual graphic elements, as well as the specific semantics of the element interfaces, are not rigorously defined [15, 7, 6]. <p> A DFD depicts the source of each process's information and the destination of 4 each process's output. In this section we adopt the graphical and syntactic notation for DFD's used by De Marco [8] and Yourdon <ref> [26] </ref>. Figure 1 provides a simple DFD. 2 The four components of a DFD are: 1. Bubbles, represented by circles with an associated P-Spec (or DFD refinement, if dealing with hierarchical DFD's), 2. Flows, represented by directed edges with an associated DD entry (DDE), 3.
References-found: 26

