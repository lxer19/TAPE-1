URL: ftp://cse.ogi.edu/pub/pacsoft/papers/compaper.ps
Refering-URL: http://www.cse.ogi.edu/PacSoft/projects/FM/publicat.htm
Root-URL: http://www.cse.ogi.edu
Email: (simonpj@dcs.gla.ac.uk)  (erik@cs.ruu.nl)  (leijen@wins.uva.nl)  
Title: Scripting COM components in Haskell community a new opportunity. Because the interface between objects is
Author: Simon Peyton Jones Erik Meijer 
Keyword: Microsoft's Component Object Model (COM)  Haskell, COM, CORBA, software components, lazy evaluation, functional programming, strong typing, polymor-phism, scripting, interoperability, equational reasoning.  
Note: offers this  
Date: December 15, 1997  
Address: Daan Leijen  
Affiliation: University of Glasgow and Oregon Graduate Institute  University of Utrecht and Oregon Graduate Institute  University of Amsterdam and Oregon Graduate Institute  
Abstract: We describe our experience of exploiting this opportunity in the purely-functional language Haskell. We describe a design for integrating COM components into Haskell programs, and we demonstrate why someone might want to script their COM components in this way. This paper has been submitted to Software Reuse 1998. keywords
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Kraig Brockschmidt. </author> <title> Inside OLE (second edition). </title> <publisher> Mi-crosoft Press, </publisher> <year> 1995. </year>
Reference-contexts: These are not COM's only advantages. For example, one of the primary motivations for using COM concerns version control and upgrade paths for software components, which we have not mentioned at all so far. However, these additional properties are well described elsewhere, <ref> [11, 12, 1, 2, 3] </ref> and do not concern us further in this paper, except in so far as they serve as motivators for people to write and use COM components. Also, COM is not alone in having these properties. Numerous research projects had similar goals, in particular CORBA [13].
Reference: [2] <author> David Chappel. </author> <title> Understanding ActiveX and OLE. </title> <publisher> Mi-crosoft Press, </publisher> <year> 1996. </year>
Reference-contexts: These are not COM's only advantages. For example, one of the primary motivations for using COM concerns version control and upgrade paths for software components, which we have not mentioned at all so far. However, these additional properties are well described elsewhere, <ref> [11, 12, 1, 2, 3] </ref> and do not concern us further in this paper, except in so far as they serve as motivators for people to write and use COM components. Also, COM is not alone in having these properties. Numerous research projects had similar goals, in particular CORBA [13].
Reference: [3] <author> Adam Denning. </author> <title> ActiveX Controls Inside Out (second edition). </title> <publisher> Microsoft Press, </publisher> <year> 1997. </year>
Reference-contexts: These are not COM's only advantages. For example, one of the primary motivations for using COM concerns version control and upgrade paths for software components, which we have not mentioned at all so far. However, these additional properties are well described elsewhere, <ref> [11, 12, 1, 2, 3] </ref> and do not concern us further in this paper, except in so far as they serve as motivators for people to write and use COM components. Also, COM is not alone in having these properties. Numerous research projects had similar goals, in particular CORBA [13].
Reference: [4] <author> J. Peterson (editor). </author> <title> Report on the programming language HASKELL version 1.4. </title> <type> Technical report, </type> <note> http://www.haskell.org/, April 6 1997. </note>
Reference-contexts: We have begun to exploit the first of these opportunities in the context of the purely functional programming language Haskell <ref> [4] </ref>. In this paper we describe an interface between Haskell and COM that makes it easy to script COM components from a Haskell program. We make two main contributions: * A graceful and strongly typed accommodation of COM within the host language is important.
Reference: [5] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: In Java, C++, or VB it is much harder to define custom control structures such as sequence. For example in Java 1.1 one would use the package java.lang.reflect to reify classes and methods into first class values, or use the Command pattern <ref> [5] </ref> to implement a command interpreter on top of the underlying language. Note that in our case sequence [...] is another composite method on agents, just as dancesAndSings, and is called in exactly the same way as a native method.
Reference: [6] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification (revision 1.2). Object Management Group, 1993. OMG Document Number 93.12.43. </title>
Reference-contexts: All the client does is make correct calls to AddRef and Release. 3.4 Describing interfaces Since every IID uniquely identifies the signature of the interface, it is useful to have a common language in which to describe that signature. COM has such a language, called IDL (Interface Definition Language) <ref> [6] </ref>, but IDL is not part of the core COM standard.
Reference: [7] <author> John Hughes. </author> <title> Why Functional Programming Matters. </title> <journal> Computer Journal, </journal> <volume> 32(2) </volume> <pages> 98-107, </pages> <year> 1989. </year>
Reference-contexts: Lazy evaluation and higher order functions are essential for this kind of extensibility <ref> [7] </ref>.
Reference: [8] <editor> Simon L. Peyton Jones and Philip Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In POPL 20, </booktitle> <pages> pages 71-84, </pages> <year> 1993. </year>
Reference-contexts: In particular it cannot perform any input/output. All functions that can perform I/O have a result type of the form IO t . This so-called monadic I/O has become the standard way to do in put/output in purely functional languages <ref> [8] </ref>. tool from the IDL. The Microsoft tool does all the parsing and type-checking of the IDL. The type-library object it produces is essentially a parse tree with methods that allow its clients to navigate the parse tree. <p> It is much more syntactically convenient than using the bind and unit functions of the monad, as the first papers about monadic I/O did <ref> [8, 10] </ref>. The statement robby &lt;- server # getCharacter rob_id binds the result of performing the action server # getCharacter rob_id to the name robby. Now we can read the example.
Reference: [9] <author> Simon Peyton Jones, Thomas Nordin, and Alastair Reid. Green card: </author> <title> a foreign-language interface for haskell. </title> <booktitle> In Proc. Haskell Workshop, </booktitle> <year> 1997. </year>
Reference-contexts: the C world (adding 1 In fact, rather than reading the IDL text directly, the tool interrogates the type library for M, a COM object generated by a Microsoft yet another level of indirection), and are accessed in the Haskell world using our previously developed foreign language interface to C <ref> [9] </ref>. Green Card automatically generates all required stub procedures and marshalling code to call C.
Reference: [10] <author> SL Peyton Jones and J Launchbury. </author> <title> State in Haskell. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 293-341, </pages> <year> 1995. </year>
Reference-contexts: It is much more syntactically convenient than using the bind and unit functions of the monad, as the first papers about monadic I/O did <ref> [8, 10] </ref>. The statement robby &lt;- server # getCharacter rob_id binds the result of performing the action server # getCharacter rob_id to the name robby. Now we can read the example.
Reference: [11] <author> Microsoft Press. </author> <title> Automation Programmers Reference, </title> <year> 1997. </year>
Reference-contexts: These are not COM's only advantages. For example, one of the primary motivations for using COM concerns version control and upgrade paths for software components, which we have not mentioned at all so far. However, these additional properties are well described elsewhere, <ref> [11, 12, 1, 2, 3] </ref> and do not concern us further in this paper, except in so far as they serve as motivators for people to write and use COM components. Also, COM is not alone in having these properties. Numerous research projects had similar goals, in particular CORBA [13].
Reference: [12] <author> Dale Rogerson. </author> <title> Inside COM. </title> <publisher> Microsoft Press, </publisher> <year> 1997. </year>
Reference-contexts: Despite some work on foreign language interfaces, it has been hard to provide an evolutionary path that would enable a potential customer to experiment with a new language at a low level of commitment. Microsoft's Component Object Model (COM) is a widely-deployed, binary standard for software components <ref> [12] </ref>. Because its language independence, COM presents two new opportunities for programming-language researchers. <p> These are not COM's only advantages. For example, one of the primary motivations for using COM concerns version control and upgrade paths for software components, which we have not mentioned at all so far. However, these additional properties are well described elsewhere, <ref> [11, 12, 1, 2, 3] </ref> and do not concern us further in this paper, except in so far as they serve as motivators for people to write and use COM components. Also, COM is not alone in having these properties. Numerous research projects had similar goals, in particular CORBA [13]. <p> With more than 200 million systems worldwide using it, COM offers designers of advanced languages the best opportunities for reusing software components. 3 How COM works Although there are many very fat books about COM (e.g. <ref> [12] </ref>), the core technology is quite simple, a notable achievement. This section briefly introduces the key ideas. We concentrate exclusively on how COM works, rather on why it works that deal; the COM literature deals with the latter topic in detail.
Reference: [13] <author> Jon Siegel. </author> <title> CORBA Fundamentals and Programming. </title> <publisher> John Wiley & Sons, </publisher> <year> 1996. </year>
Reference-contexts: Also, COM is not alone in having these properties. Numerous research projects had similar goals, in particular CORBA <ref> [13] </ref>. In fact, almost everything in the rest of this paper would apply to CORBA as well as COM, because CORBA is largely compatible with COM. We stick to COM for the sake of being concrete (it has a well-defined, mature and stable specification) and because of its widespread use.
References-found: 13

