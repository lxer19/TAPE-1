URL: ftp://ftp.cs.washington.edu/tr/1997/12/UW-CSE-97-12-04.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: The Design and Implementation of a Database Environment for Vision Research system supports multi-level queries
Author: Rex M. Jakobovits 
Note: The  
Address: Seattle, Washington 98195  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington  
Abstract: The Database Environment for Vision Research (DEVR) is an entity-oriented scientific database system based on a hierarchical relational data model (HRS). This paper describes the design and implementation of the data definition language, the application programmer's interface, and the query mechanism of the DEVR system. DEVR provides a dynamic data definition language for modeling image and vision data, which can be integrated with existing image processing and vision applications. Schema definitions can be fully interleaved with data manipulation, without requiring recompilation. In addition, DEVR provides a powerful application programmer's interface that regulates data access and schema definition, maintains indexes, and enforces type safety and data integrity. fl Submitted in fulfillment of the Ph.D. Qualifying Project requirement. This research was sponsored by the National Science Foundation under grant IRI-9116809, and by the Washing-ton Technology Center. A shorter version of this paper to appear in IS&T/SPIE Symposium on Electronic Imaging: Science and Technology, February 1995. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal and N. Gehani. </author> <title> Ode: Object database & environment. </title> <address> SIG-MOD, </address> <year> 1989. </year>
Reference-contexts: Select&gt; : 1 (View Schema) Enter type: Object_3D SCHEMA: Object_3D NUMBER OF INSTANCES: 2 PROPERTIES: [0] name &lt;fixed_string&gt; <ref> [1] </ref> model &lt;Model_3D&gt; PARTS: [0] views &lt;View_Class&gt; [1] experiments &lt;Experiment&gt; NO RELATIONS Select&gt; : 1 (View Schema) Enter type: Model_3D SCHEMA: Model_3D NUMBER OF INSTANCES: 2 PROPERTIES: [0] the_object &lt;Object_3D&gt; PARTS: [0] faces &lt;Face_3D&gt; [1] edges &lt;Edge_3D&gt; [2] points &lt;Point_3D&gt; NO RELATIONS A.2 A Query over Object 3D Entities The user <p> Select&gt; : 1 (View Schema) Enter type: Object_3D SCHEMA: Object_3D NUMBER OF INSTANCES: 2 PROPERTIES: [0] name &lt;fixed_string&gt; <ref> [1] </ref> model &lt;Model_3D&gt; PARTS: [0] views &lt;View_Class&gt; [1] experiments &lt;Experiment&gt; NO RELATIONS Select&gt; : 1 (View Schema) Enter type: Model_3D SCHEMA: Model_3D NUMBER OF INSTANCES: 2 PROPERTIES: [0] the_object &lt;Object_3D&gt; PARTS: [0] faces &lt;Face_3D&gt; [1] edges &lt;Edge_3D&gt; [2] points &lt;Point_3D&gt; NO RELATIONS A.2 A Query over Object 3D Entities The user now wishes to find all Object 3D <p> 1 (View Schema) Enter type: Object_3D SCHEMA: Object_3D NUMBER OF INSTANCES: 2 PROPERTIES: [0] name &lt;fixed_string&gt; <ref> [1] </ref> model &lt;Model_3D&gt; PARTS: [0] views &lt;View_Class&gt; [1] experiments &lt;Experiment&gt; NO RELATIONS Select&gt; : 1 (View Schema) Enter type: Model_3D SCHEMA: Model_3D NUMBER OF INSTANCES: 2 PROPERTIES: [0] the_object &lt;Object_3D&gt; PARTS: [0] faces &lt;Face_3D&gt; [1] edges &lt;Edge_3D&gt; [2] points &lt;Point_3D&gt; NO RELATIONS A.2 A Query over Object 3D Entities The user now wishes to find all Object 3D entities with 2 or more view classes, whose CAD model has at least 40 edges and between 10 and 20 faces. <p> Edit this query [y/n]: y The query currently selected for editing is: query#1&lt;Model_3D&gt; Constraints on Properties: [0] the_object &lt;Object_3D&gt; : NULL Constraints on Parts: [0] faces &lt;Face_3D&gt; : unconstrained. <ref> [1] </ref> edges &lt;Edge_3D&gt; : unconstrained. [2] points &lt;Point_3D&gt; : unconstrained. [Edit Query] 1: Select New Query to Edit 2: View Selected Query 3: Edit Property Constraint 4: Edit Parts Constraint 5: Edit Relation Constraint 6: Edit Constraint Expression 9: Return Select&gt; : 4 (Edit Parts Constraint) Enter slot number of part <p> Select&gt; : 2 (Define New Query) Enter type: Object_3D Created query#2&lt;Object_3D&gt;. Edit this query [y/n]: y The query currently selected for editing is: query#2&lt;Object_3D&gt; Constraints on Properties: [0] name &lt;fixed_string&gt; : NULL <ref> [1] </ref> model &lt;Model_3D&gt; : NULL Constraints on Parts: [0] views &lt;View_Class&gt; : unconstrained. [1] experiments &lt;Experiment&gt; : unconstrained. [Edit Query] 1: Select New Query to Edit 2: View Selected Query 3: Edit Property Constraint 4: Edit Parts Constraint 5: Edit Relation Constraint 6: Edit Constraint Expression 9: Return Select&gt; : 3 <p> Select&gt; : 2 (Define New Query) Enter type: Object_3D Created query#2&lt;Object_3D&gt;. Edit this query [y/n]: y The query currently selected for editing is: query#2&lt;Object_3D&gt; Constraints on Properties: [0] name &lt;fixed_string&gt; : NULL <ref> [1] </ref> model &lt;Model_3D&gt; : NULL Constraints on Parts: [0] views &lt;View_Class&gt; : unconstrained. [1] experiments &lt;Experiment&gt; : unconstrained. [Edit Query] 1: Select New Query to Edit 2: View Selected Query 3: Edit Property Constraint 4: Edit Parts Constraint 5: Edit Relation Constraint 6: Edit Constraint Expression 9: Return Select&gt; : 3 (Edit Property Constraint) Enter slot number of property to constrain: 1 Enter query <p> Select&gt; : 4 (Edit Parts Constraint) Enter slot number of part to constrain: 0 Enter constraint on cardinality of views: &gt;= 2 17 Slot 0 has been updated. Select&gt; : 2 (View Selected Query) The currently selected query: query#2&lt;Object_3D&gt; Constraints on Properties: [0] name &lt;fixed_string&gt; : NULL <ref> [1] </ref> model &lt;Model_3D&gt; : query#1&lt;Model_3D&gt; Constraints on Properties: [0] the_object &lt;Object_3D&gt; : NULL Constraints on Parts: [0] faces &lt;Face_3D&gt; : (((&gt;= 10)) AND ((&lt;= 20))) [1] edges &lt;Edge_3D&gt; : (((&gt;= 40))) [2] points &lt;Point_3D&gt; : unconstrained. Constraints on Parts: [0] views &lt;View_Class&gt; : (((&gt;= 2))) [1] experiments &lt;Experiment&gt; : unconstrained. <p> Select&gt; : 2 (View Selected Query) The currently selected query: query#2&lt;Object_3D&gt; Constraints on Properties: [0] name &lt;fixed_string&gt; : NULL <ref> [1] </ref> model &lt;Model_3D&gt; : query#1&lt;Model_3D&gt; Constraints on Properties: [0] the_object &lt;Object_3D&gt; : NULL Constraints on Parts: [0] faces &lt;Face_3D&gt; : (((&gt;= 10)) AND ((&lt;= 20))) [1] edges &lt;Edge_3D&gt; : (((&gt;= 40))) [2] points &lt;Point_3D&gt; : unconstrained. Constraints on Parts: [0] views &lt;View_Class&gt; : (((&gt;= 2))) [1] experiments &lt;Experiment&gt; : unconstrained. <p> [0] name &lt;fixed_string&gt; : NULL <ref> [1] </ref> model &lt;Model_3D&gt; : query#1&lt;Model_3D&gt; Constraints on Properties: [0] the_object &lt;Object_3D&gt; : NULL Constraints on Parts: [0] faces &lt;Face_3D&gt; : (((&gt;= 10)) AND ((&lt;= 20))) [1] edges &lt;Edge_3D&gt; : (((&gt;= 40))) [2] points &lt;Point_3D&gt; : unconstrained. Constraints on Parts: [0] views &lt;View_Class&gt; : (((&gt;= 2))) [1] experiments &lt;Experiment&gt; : unconstrained. <p> Query over all entities of this type [y/n]: y 18 input set: set of 2 items. - Object_3D#1, Object_3D#2 - ** testing an item: Object_3D#1 ** PROPERTIES: [0] name &lt;fixed_string&gt; : Fork <ref> [1] </ref> model &lt;Model_3D&gt; : Model_3D#1 PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#1 PARTS: [0] faces &lt;Face_3D&gt; : set of 14 items. [1] edges &lt;Edge_3D&gt; : set of 36 items. [2] points &lt;Point_3D&gt; : set of 24 items. PARTS: [0] views &lt;View_Class&gt; : set of 2 items. [1] experiments &lt;Experiment&gt; : set of <p> all entities of this type [y/n]: y 18 input set: set of 2 items. - Object_3D#1, Object_3D#2 - ** testing an item: Object_3D#1 ** PROPERTIES: [0] name &lt;fixed_string&gt; : Fork <ref> [1] </ref> model &lt;Model_3D&gt; : Model_3D#1 PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#1 PARTS: [0] faces &lt;Face_3D&gt; : set of 14 items. [1] edges &lt;Edge_3D&gt; : set of 36 items. [2] points &lt;Point_3D&gt; : set of 24 items. PARTS: [0] views &lt;View_Class&gt; : set of 2 items. [1] experiments &lt;Experiment&gt; : set of 0 items. ** Object_3D#1 did not satisfy ** ** testing an item: Object_3D#2 ** PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut <p> [0] name &lt;fixed_string&gt; : Fork <ref> [1] </ref> model &lt;Model_3D&gt; : Model_3D#1 PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#1 PARTS: [0] faces &lt;Face_3D&gt; : set of 14 items. [1] edges &lt;Edge_3D&gt; : set of 36 items. [2] points &lt;Point_3D&gt; : set of 24 items. PARTS: [0] views &lt;View_Class&gt; : set of 2 items. [1] experiments &lt;Experiment&gt; : set of 0 items. ** Object_3D#1 did not satisfy ** ** testing an item: Object_3D#2 ** PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] model &lt;Model_3D&gt; : Model_3D#2 PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PARTS: [0] faces &lt;Face_3D&gt; : set of 18 items. [1] edges &lt;Edge_3D&gt; : set <p> PARTS: [0] views &lt;View_Class&gt; : set of 2 items. <ref> [1] </ref> experiments &lt;Experiment&gt; : set of 0 items. ** Object_3D#1 did not satisfy ** ** testing an item: Object_3D#2 ** PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] model &lt;Model_3D&gt; : Model_3D#2 PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PARTS: [0] faces &lt;Face_3D&gt; : set of 18 items. [1] edges &lt;Edge_3D&gt; : set of 48 items. [2] points &lt;Point_3D&gt; : set of 32 items. PARTS: [0] views &lt;View_Class&gt; : set of 3 items. [1] experiments &lt;Experiment&gt; : set of <p> set of 2 items. <ref> [1] </ref> experiments &lt;Experiment&gt; : set of 0 items. ** Object_3D#1 did not satisfy ** ** testing an item: Object_3D#2 ** PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] model &lt;Model_3D&gt; : Model_3D#2 PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PARTS: [0] faces &lt;Face_3D&gt; : set of 18 items. [1] edges &lt;Edge_3D&gt; : set of 48 items. [2] points &lt;Point_3D&gt; : set of 32 items. PARTS: [0] views &lt;View_Class&gt; : set of 3 items. [1] experiments &lt;Experiment&gt; : set of 0 items. ** Object_3D#2 satisfies ** set#183 created with 1 elements. - Object_3D#2 - A.3 A Query over View Classes <p> [0] name &lt;fixed_string&gt; : Cube3Cut <ref> [1] </ref> model &lt;Model_3D&gt; : Model_3D#2 PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PARTS: [0] faces &lt;Face_3D&gt; : set of 18 items. [1] edges &lt;Edge_3D&gt; : set of 48 items. [2] points &lt;Point_3D&gt; : set of 32 items. PARTS: [0] views &lt;View_Class&gt; : set of 3 items. [1] experiments &lt;Experiment&gt; : set of 0 items. ** Object_3D#2 satisfies ** set#183 created with 1 elements. - Object_3D#2 - A.3 A Query over View Classes Only the Object 3D named "Cube3Cut" satisfied the constraints of query #1. Cube3Cut's Model 3D contains 3 distinct view classes. <p> First, the user constructs the query "Find all 3D objects named Cube3Cut". (Define New Query) Enter type: Object_3D Created query#3&lt;Object_3D&gt;. Edit this query [y/n]: y The query currently selected for editing is: query#3&lt;Object_3D&gt; Constraints on Properties: [0] name &lt;fixed_string&gt; : NULL <ref> [1] </ref> model &lt;Model_3D&gt; : NULL Constraints on Parts: [0] views &lt;View_Class&gt; : unconstrained. [1] experiments &lt;Experiment&gt; : unconstrained. Select&gt; : 3 (Edit Property Constraint) Enter slot number of property to constrain: 0 Enter constraint for name&lt;fixed_string&gt;: == Cube3Cut Slot 0 has been updated. <p> Edit this query [y/n]: y The query currently selected for editing is: query#3&lt;Object_3D&gt; Constraints on Properties: [0] name &lt;fixed_string&gt; : NULL <ref> [1] </ref> model &lt;Model_3D&gt; : NULL Constraints on Parts: [0] views &lt;View_Class&gt; : unconstrained. [1] experiments &lt;Experiment&gt; : unconstrained. Select&gt; : 3 (Edit Property Constraint) Enter slot number of property to constrain: 0 Enter constraint for name&lt;fixed_string&gt;: == Cube3Cut Slot 0 has been updated. Next, the root level query is constructed, of type View Class. <p> Select&gt; : 2 (View Selected Query) The currently selected query: query#4&lt;View_Class&gt; Constraints on Properties: [0] the_object &lt;Object_3D&gt; : query#3&lt;Object_3D&gt; Constraints on Properties: [0] name &lt;fixed_string&gt; : (((== Cube3Cut))) <ref> [1] </ref> min_lat &lt;integer&gt; : (((&gt; 50))) [2] max_lat &lt;integer&gt; : NULL [3] min_long &lt;integer&gt; : NULL [4] max_long &lt;integer&gt; : (((&lt; 100))) Constraints on Parts: [0] model_edges &lt;Edge_3D&gt; : unconstrained. [1] real_images &lt;Real_Image&gt; : (((&gt;= 15))) [2] synth_images &lt;Synth_Image&gt; : unconstrained. <p> selected query: query#4&lt;View_Class&gt; Constraints on Properties: [0] the_object &lt;Object_3D&gt; : query#3&lt;Object_3D&gt; Constraints on Properties: [0] name &lt;fixed_string&gt; : (((== Cube3Cut))) <ref> [1] </ref> min_lat &lt;integer&gt; : (((&gt; 50))) [2] max_lat &lt;integer&gt; : NULL [3] min_long &lt;integer&gt; : NULL [4] max_long &lt;integer&gt; : (((&lt; 100))) Constraints on Parts: [0] model_edges &lt;Edge_3D&gt; : unconstrained. [1] real_images &lt;Real_Image&gt; : (((&gt;= 15))) [2] synth_images &lt;Synth_Image&gt; : unconstrained. Now the query is used to filter all view classes of the system. <p> name &lt;fixed_string&gt; : Fork ** did not satisfy. ** Of the remaining three view classes, two satisfy the entire constraint tree, while one is rejected because the max long property exceeds 100. ** testing an item: View_Class#3 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut <ref> [1] </ref> min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 55 PARTS: 22 [1] real_images &lt;Real_Image&gt; : set of 20 items. ** satisfies! ** ** testing an item: View_Class#4 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 180 <p> three view classes, two satisfy the entire constraint tree, while one is rejected because the max long property exceeds 100. ** testing an item: View_Class#3 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut <ref> [1] </ref> min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 55 PARTS: 22 [1] real_images &lt;Real_Image&gt; : set of 20 items. ** satisfies! ** ** testing an item: View_Class#4 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 180 PARTS: [1] real_images &lt;Real_Image&gt; : set of 20 items. ** did not <p> &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut <ref> [1] </ref> min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 55 PARTS: 22 [1] real_images &lt;Real_Image&gt; : set of 20 items. ** satisfies! ** ** testing an item: View_Class#4 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 180 PARTS: [1] real_images &lt;Real_Image&gt; : set of 20 items. ** did not satisfy. ** ** testing an item: View_Class#5 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : <p> &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 55 PARTS: 22 <ref> [1] </ref> real_images &lt;Real_Image&gt; : set of 20 items. ** satisfies! ** ** testing an item: View_Class#4 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 180 PARTS: [1] real_images &lt;Real_Image&gt; : set of 20 items. ** did not satisfy. ** ** testing an item: View_Class#5 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 30 ** satisfies! ** set#189 created with 2 elements. 23 <p> : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut <ref> [1] </ref> min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 180 PARTS: [1] real_images &lt;Real_Image&gt; : set of 20 items. ** did not satisfy. ** ** testing an item: View_Class#5 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 30 ** satisfies! ** set#189 created with 2 elements. 23
Reference: [2] <editor> F. Bancilhon and P. Buneman. </editor> <booktitle> Advances in Database Programing Languages. </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: The new schema starts with all the components of the template schema, and can then be edited as necessary. Similarly, the MetaMas-ter has methods to create an identical copy of an entity. Unlike traditional query languages which tend to impose restrictions on the generality of data processing <ref> [2] </ref>, the MetaMaster interface is a self-contained C++ object that can interact seamlessly in any C++ program. It provides all the flexibility of a general programming language, thereby avoiding the impedance mismatch problem associated with embedded query languages. <p> Enter type: Object_3D SCHEMA: Object_3D NUMBER OF INSTANCES: 2 PROPERTIES: [0] name &lt;fixed_string&gt; [1] model &lt;Model_3D&gt; PARTS: [0] views &lt;View_Class&gt; [1] experiments &lt;Experiment&gt; NO RELATIONS Select&gt; : 1 (View Schema) Enter type: Model_3D SCHEMA: Model_3D NUMBER OF INSTANCES: 2 PROPERTIES: [0] the_object &lt;Object_3D&gt; PARTS: [0] faces &lt;Face_3D&gt; [1] edges &lt;Edge_3D&gt; <ref> [2] </ref> points &lt;Point_3D&gt; NO RELATIONS A.2 A Query over Object 3D Entities The user now wishes to find all Object 3D entities with 2 or more view classes, whose CAD model has at least 40 edges and between 10 and 20 faces. <p> Edit this query [y/n]: y The query currently selected for editing is: query#1&lt;Model_3D&gt; Constraints on Properties: [0] the_object &lt;Object_3D&gt; : NULL Constraints on Parts: [0] faces &lt;Face_3D&gt; : unconstrained. [1] edges &lt;Edge_3D&gt; : unconstrained. <ref> [2] </ref> points &lt;Point_3D&gt; : unconstrained. [Edit Query] 1: Select New Query to Edit 2: View Selected Query 3: Edit Property Constraint 4: Edit Parts Constraint 5: Edit Relation Constraint 6: Edit Constraint Expression 9: Return Select&gt; : 4 (Edit Parts Constraint) Enter slot number of part to constrain: 0 Enter constraint <p> Select&gt; : 2 (View Selected Query) The currently selected query: query#2&lt;Object_3D&gt; Constraints on Properties: [0] name &lt;fixed_string&gt; : NULL [1] model &lt;Model_3D&gt; : query#1&lt;Model_3D&gt; Constraints on Properties: [0] the_object &lt;Object_3D&gt; : NULL Constraints on Parts: [0] faces &lt;Face_3D&gt; : (((&gt;= 10)) AND ((&lt;= 20))) [1] edges &lt;Edge_3D&gt; : (((&gt;= 40))) <ref> [2] </ref> points &lt;Point_3D&gt; : unconstrained. Constraints on Parts: [0] views &lt;View_Class&gt; : (((&gt;= 2))) [1] experiments &lt;Experiment&gt; : unconstrained. <p> input set: set of 2 items. - Object_3D#1, Object_3D#2 - ** testing an item: Object_3D#1 ** PROPERTIES: [0] name &lt;fixed_string&gt; : Fork [1] model &lt;Model_3D&gt; : Model_3D#1 PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#1 PARTS: [0] faces &lt;Face_3D&gt; : set of 14 items. [1] edges &lt;Edge_3D&gt; : set of 36 items. <ref> [2] </ref> points &lt;Point_3D&gt; : set of 24 items. <p> set of 0 items. ** Object_3D#1 did not satisfy ** ** testing an item: Object_3D#2 ** PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] model &lt;Model_3D&gt; : Model_3D#2 PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PARTS: [0] faces &lt;Face_3D&gt; : set of 18 items. [1] edges &lt;Edge_3D&gt; : set of 48 items. <ref> [2] </ref> points &lt;Point_3D&gt; : set of 32 items. <p> Select&gt; : 2 (View Selected Query) The currently selected query: query#4&lt;View_Class&gt; Constraints on Properties: [0] the_object &lt;Object_3D&gt; : query#3&lt;Object_3D&gt; Constraints on Properties: [0] name &lt;fixed_string&gt; : (((== Cube3Cut))) [1] min_lat &lt;integer&gt; : (((&gt; 50))) <ref> [2] </ref> max_lat &lt;integer&gt; : NULL [3] min_long &lt;integer&gt; : NULL [4] max_long &lt;integer&gt; : (((&lt; 100))) Constraints on Parts: [0] model_edges &lt;Edge_3D&gt; : unconstrained. [1] real_images &lt;Real_Image&gt; : (((&gt;= 15))) [2] synth_images &lt;Synth_Image&gt; : unconstrained. Now the query is used to filter all view classes of the system. <p> [0] the_object &lt;Object_3D&gt; : query#3&lt;Object_3D&gt; Constraints on Properties: [0] name &lt;fixed_string&gt; : (((== Cube3Cut))) [1] min_lat &lt;integer&gt; : (((&gt; 50))) <ref> [2] </ref> max_lat &lt;integer&gt; : NULL [3] min_long &lt;integer&gt; : NULL [4] max_long &lt;integer&gt; : (((&lt; 100))) Constraints on Parts: [0] model_edges &lt;Edge_3D&gt; : unconstrained. [1] real_images &lt;Real_Image&gt; : (((&gt;= 15))) [2] synth_images &lt;Synth_Image&gt; : unconstrained. Now the query is used to filter all view classes of the system.
Reference: [3] <author> A. Biliris, N. Gehani, et al. </author> <title> Ode 3.0.3 User Manual. </title> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, New Jersey. </address>
Reference-contexts: I implemented DEVR on top of the Object Database Environment (ODE)[1], a persistent C++ system. Objects are saved to disk automatically, and retrieved 2 into memory whenever they are referenced within an application. The DEVR library consists of over 5000 lines of O++ code <ref> [3] </ref>, including the application programmer's interface and the textual user interface. DEVR offers a dynamic data definition language for modeling image and vision data. I have designed and implemented a powerful application programmer's interface, which allows users to integrate the database with existing image processing and vision applications. <p> Select&gt; : 2 (View Selected Query) The currently selected query: query#4&lt;View_Class&gt; Constraints on Properties: [0] the_object &lt;Object_3D&gt; : query#3&lt;Object_3D&gt; Constraints on Properties: [0] name &lt;fixed_string&gt; : (((== Cube3Cut))) [1] min_lat &lt;integer&gt; : (((&gt; 50))) [2] max_lat &lt;integer&gt; : NULL <ref> [3] </ref> min_long &lt;integer&gt; : NULL [4] max_long &lt;integer&gt; : (((&lt; 100))) Constraints on Parts: [0] model_edges &lt;Edge_3D&gt; : unconstrained. [1] real_images &lt;Real_Image&gt; : (((&gt;= 15))) [2] synth_images &lt;Synth_Image&gt; : unconstrained. Now the query is used to filter all view classes of the system.
Reference: [4] <author> R. Jakobovits, L. Shapiro, and S. Tanimoto. </author> <title> Implementing multi-level queries in a database environment for vision research. </title> <booktitle> In IS&T/SPIE Symposium on Electronic Imaging: Science & Technology, </booktitle> <month> February </month> <year> 1995. </year>
Reference-contexts: Select&gt; : 2 (View Selected Query) The currently selected query: query#4&lt;View_Class&gt; Constraints on Properties: [0] the_object &lt;Object_3D&gt; : query#3&lt;Object_3D&gt; Constraints on Properties: [0] name &lt;fixed_string&gt; : (((== Cube3Cut))) [1] min_lat &lt;integer&gt; : (((&gt; 50))) [2] max_lat &lt;integer&gt; : NULL [3] min_long &lt;integer&gt; : NULL <ref> [4] </ref> max_long &lt;integer&gt; : (((&lt; 100))) Constraints on Parts: [0] model_edges &lt;Edge_3D&gt; : unconstrained. [1] real_images &lt;Real_Image&gt; : (((&gt;= 15))) [2] synth_images &lt;Synth_Image&gt; : unconstrained. Now the query is used to filter all view classes of the system. <p> did not satisfy. ** Of the remaining three view classes, two satisfy the entire constraint tree, while one is rejected because the max long property exceeds 100. ** testing an item: View_Class#3 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 <ref> [4] </ref> max_long &lt;integer&gt; : 55 PARTS: 22 [1] real_images &lt;Real_Image&gt; : set of 20 items. ** satisfies! ** ** testing an item: View_Class#4 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 180 PARTS: [1] real_images &lt;Real_Image&gt; : <p> name &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 <ref> [4] </ref> max_long &lt;integer&gt; : 55 PARTS: 22 [1] real_images &lt;Real_Image&gt; : set of 20 items. ** satisfies! ** ** testing an item: View_Class#4 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 180 PARTS: [1] real_images &lt;Real_Image&gt; : set of 20 items. ** did not satisfy. ** ** testing an item: View_Class#5 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 30 ** satisfies! ** set#189 <p> &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 <ref> [4] </ref> max_long &lt;integer&gt; : 180 PARTS: [1] real_images &lt;Real_Image&gt; : set of 20 items. ** did not satisfy. ** ** testing an item: View_Class#5 ** PROPERTIES: [0] the_object &lt;Object_3D&gt; : Object_3D#2 PROPERTIES: [0] name &lt;fixed_string&gt; : Cube3Cut [1] min_lat &lt;integer&gt; : 62 [4] max_long &lt;integer&gt; : 30 ** satisfies! ** set#189 created with 2 elements. 23
Reference: [5] <author> H. Korth and A. Silberschatz. </author> <title> Database System Concepts. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: DEVR provides a good environment for research in query optimization because it is a hybrid of relational and object-oriented systems. Queries over the relations component of an HRS could rely on traditional relational query processing techniques <ref> [5] </ref>. Since the tuple fields are restricted to the members of the part sets of a given entity, joins could be easily optimized and local indexes could be maintained with little overhead.
Reference: [6] <author> L. Lewis, L. Shapiro, and S. Tanimoto. </author> <title> Flexible data organization with visualization support for a visual database system. </title> <booktitle> In IS&T/SPIE Symposium on Electronic Imaging: Science & Technology, </booktitle> <month> February </month> <year> 1995. </year>
Reference-contexts: TRIBORS), and has been tested on experiments involving over one hundred images and their extracted spatial entities. In addition, it has proven to be expedient in developing new applications. The Textual User Interface itself was implemented using the MetaMaster interface. A graphical interface is being developed <ref> [6] </ref>, which will enhance the system's querying and browsing facilities, and enable the user to design types and construct queries visually. Future work will involve testing the system on large volumes of data (e.g. satellite images), and analyzing the performance of the query processor.
Reference: [7] <author> K. Pulli. Tribors: </author> <title> A triplet-based object recognition system. </title> <type> Technical Report 95-01-01, </type> <institution> Deptartment of Computer Science and Engineering, University of Washington, </institution> <address> Seattle, WA, </address> <month> January </month> <year> 1995. </year>
Reference: [8] <author> L. Shapiro, S. Tanimoto, J. Brinkley, J. Ahrens, R. Jakobovits, and L. Lewis. </author> <title> A visual database system for data and experiment management in model-based computer vision. </title> <booktitle> In Proceedings of the Second CAD-Based Vision Workshop, </booktitle> <pages> pages 64-72, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Furthermore, it tends to result in an unwieldy collection of cryptic disk files that the researcher must manage, making it difficult to browse and correlate the intermediate data. The Database Environment for Vision Research (DEVR) is an entity-oriented scientific database system designed to facilitate experimentation with image-related data <ref> [8] </ref>. The system provides a framework in which computer vision researchers may structure their internal data to promote interoperability between applications.
Reference: [9] <author> L. G. Shapiro and R. M. Haralick. </author> <title> A spatial data structure. </title> <booktitle> In Geo-Processing 1, </booktitle> <pages> pages 313-337, </pages> <year> 1980. </year>
Reference-contexts: DEVR's query processor supports a wide range of multi-level queries on complex user-defined types. 2 THE HRS DATA MODEL 2.1 Components of the HRS DEVR is based on a hierarchical relational data model (HRS) which has evolved from the Relational Data Structure (RDS) of Shapiro and Haralick <ref> [9] </ref>. Every entity in the system (images, regions, edges, etc.) is described by a schema consisting of three components: properties, parts, and relations. The properties component of a schema is a table of attribute definitions, where each entry specifies an attribute label and declares its type.
Reference: [10] <author> B. Stroustrup. </author> <title> The C++ Programming Language, 2nd Ed. </title> <institution> AT&T Bell Labs, Inc., </institution> <address> Murray Hill, NJ, </address> <year> 1993. </year> <month> 24 </month>
Reference-contexts: Actual CAD models from TRIBORS experiments has been successfully imported into DEVR, including multiple view classes consisting of over a hundred images and their corresponding spatial entities. 3 IMPLEMENTING THE HRS The HRS model is implemented as a hierarchy of C++ classes <ref> [10] </ref>, as shown in figure 2. All objects stored in the database descend from the pBase class, which defines generic methods for printing and identification.
References-found: 10

