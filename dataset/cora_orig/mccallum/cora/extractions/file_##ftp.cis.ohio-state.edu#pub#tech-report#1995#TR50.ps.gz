URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1995/TR50.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: Multi-Frame Thrashless Ray Casting with Advancing Ray-Front  
Author: Asish Law and Roni Yagel 
Address: Columbus, Ohio  
Affiliation: Department of Computer and Information Science The Ohio State University  
Abstract: Coherency (data locality) is one of the most important factors that inuences the performance of distributed ray tracing systems, especially when object dataow approach is employed. The enormous cost associated with remote fetches must be reduced to improve the efficiency of the parallel renderer. Objects once fetched should be maximally utilized before replacing them with other objects. In this paper we describe a parallel volume ray caster that eliminates thrashing by efficiently advancing a ray-front in a front-to-back manner. The method adopts an image-order approach, but capitalizes on the advantages of object-order algorithms as well to almost eliminate the communication overheads. Unlike previous algorithms, we have successfully preserved the thrashless property across a number of incrementally changing screen positions also. The use of efficient data structures and object ordering scheme has enabled complete latency hiding of non-local objects. The sum total of all these result in a scalable parallel volume renderer with the most coherent screen traversal. Comparison with other existing screen traversal schemes delineates the advantages of our approach. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. Arvo. </author> <title> Space-Filling Curves and a Measure of Coherence. Graphics Gems II, </title> <booktitle> Chapter 1.8, </booktitle> <pages> pp. 26-30. </pages>
Reference: 2. <author> D. Badouel, K. Bouatouch, T. Priol. </author> <title> Ray Tracing on Distributed Memory Parallel Computers: Strategies for Distributing Computations and Data, SIGGRAPH 90, Parallel Algorithms and Architecture for 3D Image Generation, </title> <booktitle> Course Notes. </booktitle> <pages> pp. 185-198. </pages>
Reference-contexts: The local memory is partitioned into two segments: the first segment is used to store the home cells, while the other segment is used as a cache. A very similar memory partitioning was used by Badouel et al <ref> [2] </ref>. If we denote by H the size of the home memory in number of cells, then H equals the total number of cells in the volume divided by the number of processors.
Reference: 3. <author> J. Challinger. </author> <title> Parallel Volume Rendering on a Shared-Memory Multiprocessor, </title> <institution> Department of Computer and Information Sciences, UC Santa Cruz, </institution> <note> Technical Report UCSC-CRL-91-23, revised March 1992. 20 </note>
Reference: 4. <author> B. Corrie, P. Mackerras. </author> <title> Parallel Volume Rendering and Data Coherence, </title> <booktitle> Proceedings of Parallel Rendering Symposium, </booktitle> <address> San Jose, California, </address> <month> October </month> <year> 1993, </year> <pages> pp. 23-26. </pages>
Reference-contexts: If the cache is large enough, then the system can even take advantage of frame-to-frame coherency. If the cache is not large enough, then it starts to thrash. Thrashing is manifested as the repeated transfer of the same data to the same processing node <ref> [4] </ref>. If a processors cache cannot hold the number of blocks that it needs to render a single ray, then a cyclic refill of the cache will occur for each ray. As the size of the database increases, the effect of thrashing becomes more visible.
Reference: 5. <author> T. von Eicken, D.E. Culler, S.C. Goldstein, K.E. Schauser. </author> <title> Active Messages: a Mechanism for Integrated Communication and Computation, </title> <journal> ACM Transactions 1992, </journal> <pages> pp. 256-266. </pages>
Reference-contexts: After advancing each ray through a cell, the buffers are polled for messages with a non-blocking probe. A software handler is provided for each kind of message that works similar to Active Messages <ref> [5] </ref>. Depending on the type of message a corresponding action is taken. For example, if the message con 9 tains cell information, it is read from the buffers and directly put in proper place in memory (cache).
Reference: 6. <author> S. Green, D. Paddon. </author> <title> Exploiting Coherence for Multiprocessor Ray Tracing, </title> <journal> IEEE Computer Graphics and Applications 9, </journal> <volume> (6), </volume> <pages> pp. 12-26, </pages> <month> November </month> <year> 1989. </year>
Reference: 7. <author> A. Law, R. Yagel. CellFlow: </author> <title> A Parallel Rendering Scheme for Distributed Memory Architec tures, </title> <booktitle> International Conference on Parallel and Distributed Techniques and Applications, </booktitle> <address> Atlanta, </address> <month> November, </month> <year> 1995. </year>
Reference: 8. <author> M. Levoy. </author> <title> Display of Surfaces from Volume Data, </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> Vol. 8, No. 5, </volume> <month> May </month> <year> 1988, </year> <pages> pp. 29-37. </pages>
Reference-contexts: Such volume data may be scanned by MRI (Magnetic Resonance Imaging) or CT (Computed Tomography), or simulated by CFD (Computational Fluid Dynamics) programs. Two of the most popular approaches used in volume rendering are based on image-order <ref> [8] </ref> and object-order [13] traversals. In image-order traversal, a ray is shot from the eye point and through each screen pixel. This method is also referred to as a forward-projection or ray-casting. The volume is sampled at regular intervals along the ray.
Reference: 9. <author> K.L. Ma, J.S. Painter, C.D. Hansen, M.F. Krough. </author> <title> A Data Distributed, Parallel Algorithm for Ray-Traced Volume Rendering, </title> <booktitle> Proceedings of Parallel Rendering Symposium, </booktitle> <address> San Jose, California, </address> <month> October </month> <year> 1993, </year> <pages> pp. 15-22. </pages>
Reference-contexts: Also, it is more difficult to generate high quality images (e.g., anti-aliased images), especially when viewed in perspective. On the other hand, As each voxel in the volume has to be projected, parallel object-order techniques are inherently load-balanced in the projection stage and in the compos 3 iting stage <ref> [9] </ref>. Moreover, object-order methods do not suffer from thrashing within a single frame generation. Voxels once brought in and processed are not needed again for the generation of the current frame.
Reference: 10. <author> R. Machiraju, R.Yagel. </author> <title> Efficient Feed-Forward Volume Rendering Techniques for Vector and Par allel Processors, </title> <booktitle> Proceedings of Supercomputing 93, </booktitle> <address> Portland, OR, </address> <pages> pp. 699-708. </pages>
Reference-contexts: The object-order rendering approach is more data coherent, as voxels in the volume are traversed in a regular manner, making this approach more amenable to parallelization or vectorization <ref> [10] </ref>. Each voxel is projected onto the screen and its color and opacity are composited to the appropriate pixels.
Reference: 11. <author> I.E. Sutherland, R.F. Sproull, R.A. Schumacker. </author> <title> A Characterization of Ten Hidden-Surface Algo rithms, </title> <journal> Computing Surveys, </journal> <volume> Vol. 6, No. 1, </volume> <month> March </month> <year> 1974, </year> <pages> pp. 1-55. </pages>
Reference-contexts: The results of the implementation on the Cray T3D, including comparisons with existing screen traversal methods, are shown in Section 4. The advantages, disadvantages, and some of our future goals are summarized in Section 5. 2. Exploiting Coherency for Efficient Rendering In their classic paper Sutherland et al., <ref> [11] </ref> have described coherency as the extent to which the environment, or the picture of it, is locally constant.
Reference: 12. <author> R. Westermann, S. </author> <title> Augustin. </title> <booktitle> Parallel Volume Rendering, Proceedings of International Parallel Processing Symposium, </booktitle> <year> 1995, </year> <pages> pp. 693-699. </pages>
Reference: 13. <author> L. Westover. </author> <title> Footprint Evaluation for Volume Rendering., </title> <booktitle> Computer Graphics (SIGGRAPH 90 Proceedings), </booktitle> <volume> Vol. 24, </volume> <year> 1990, </year> <pages> pp. </pages> <month> 367--376. </month>
Reference-contexts: Such volume data may be scanned by MRI (Magnetic Resonance Imaging) or CT (Computed Tomography), or simulated by CFD (Computational Fluid Dynamics) programs. Two of the most popular approaches used in volume rendering are based on image-order [8] and object-order <ref> [13] </ref> traversals. In image-order traversal, a ray is shot from the eye point and through each screen pixel. This method is also referred to as a forward-projection or ray-casting. The volume is sampled at regular intervals along the ray.
Reference: 14. <author> R. Yagel, Z. Shi. </author> <title> Accelerating Volume Animation by Space-Leaping, </title> <booktitle> Proceedings of Visualiza tion93, </booktitle> <address> San Jose, California, </address> <month> October </month> <year> 1993, </year> <pages> pp. 62-69. </pages>
Reference-contexts: For example, rays can be made to terminate as soon as the accumulated opacity exceeds a pre-specified threshold value. This is known as early ray termination or opacity clipping. The sampling of the volume along the ray can also be adapted to rapidly traverse empty spaces <ref> [14] </ref>, leading to significant savings in computation. The disadvantage of the image order approach, however, is that the data access is highly irregular and unpredictable, leading to low object-space coherency.
Reference: 15. <author> H. Zhang, S. Liu. </author> <title> Order of Pixel Traversal and Parallel Volume Ray Tracing on the Distributed Volume Buffer. To be presented at the Eurographics Workshop on Volume Visualization, </title> <booktitle> 1995. </booktitle> <volume> 21 22 </volume>
Reference-contexts: For example, for rendering using compression caches, 35000 cells will undergo compression and decompression in the case of 1 frame/phase as opposed to 4000 cells in the case of 30 frames/phase. 4.2 Comparison coherent screen-traversal scheme <ref> [15] </ref>. It is evident from these graphs that the screen traversal used for the RayFront algorithm outclasses the others at all cache sizes for parallel projection ray casting.
References-found: 15

