URL: ftp://ftp.cs.ruu.nl/pub/RUU/CS/techreps/CS-1996/1996-44.ps.gz
Refering-URL: http://www.inferenzsysteme.informatik.tu-darmstadt.de/~giesl/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Automatically Proving Termination Where Simplification Orderings Fail  
Author: Thomas Arts Jurgen Giesl 
Abstract: To prove termination of term rewriting systems (TRSs), several methods have been developed to synthesize suitable well-founded orderings automatically. However, virtually all orderings that are amenable to automation are so-called simplification orderings. Unfortunately, there exist numerous interesting and relevant TRSs that cannot be oriented by orderings of this restricted class and therefore their termination cannot be proved automatically with the existing techniques. In this paper we present a new automatic approach which allows to apply the standard techniques for automated termination proofs to those TRSs where these techniques failed up to now. For that purpose we have developed a procedure which, given a TRS, generates a set of inequalities (constraints) automatically. If there exists a well-founded ordering satisfying these constraints, then the TRS is terminating. It turns out that for many TRSs where a direct application of standard techniques fails, these standard techniques can nevertheless synthesize a well-founded ordering satisfying the generated constraints. In this way, termination of numerous (also non-simply terminating) term rewriting systems can be proved fully automatically.
Abstract-found: 1
Intro-found: 1
Reference: [AG96a] <author> T. Arts and J. Giesl. </author> <title> Termination of constructor systems. </title> <type> Technical Report UU-CS-1996-07, </type> <institution> Utrecht University, </institution> <address> PO box 80.089, 3508 TB Utrecht, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: Note that there exist only finitely many (and only few) different possibilities to eliminate arguments of function symbols. Therefore, all these possibilities can be checked automatically. First, the described technique is used to prove termination of all examples from <ref> [AG96a] </ref> (Ex. 8.1 - 8.14). While the method of [AG96b, AG96a] is restricted to non-overlapping constructor systems without nested recursion, the approach used in this paper can handle arbitrary term rewriting systems. <p> Note that there exist only finitely many (and only few) different possibilities to eliminate arguments of function symbols. Therefore, all these possibilities can be checked automatically. First, the described technique is used to prove termination of all examples from [AG96a] (Ex. 8.1 - 8.14). While the method of <ref> [AG96b, AG96a] </ref> is restricted to non-overlapping constructor systems without nested recursion, the approach used in this paper can handle arbitrary term rewriting systems. Therefore, subsequently several examples are listed where the technique has been successfully applied to TRSs that do not meet the above restrictions. 8.1. <p> Selection Sort This TRS from [Wal94], which is a slight modification of the corresponding TRS in <ref> [AG96a] </ref>, is obviously not simply terminating. The TRS can be used to sort a list by repeatedly replacing the minimum of the list by the head of the list.
Reference: [AG96b] <author> T. Arts and J. Giesl. </author> <title> Termination of constructor systems. </title> <editor> In Harald Ganzinger, editor, </editor> <booktitle> Proceedings of the 7th International Conference on Rewriting Techniques and Applications, RTA-96, volume 1103 of Lecture Notes in Computer Science, </booktitle> <pages> pages 63-77, </pages> <address> New Brunswick, NJ, USA, July 1996. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: Related Work The concept of dependency pairs was introduced in [Art96] and a first method for the automation of the dependency pair approach was proposed in <ref> [AG96b] </ref>. In the present paper we formulated an alternative version of the termination criterion using 10 dependency pairs which is better suited for automation than the original criterion of [Art96]. <p> By the introduction of dependency graphs we obtained a considerably more powerful automated technique than the method proposed in <ref> [AG96b] </ref>. Most significant, while in [Art96, AG96b] dependency pairs were only used for termination proofs of non-overlapping constructor systems without nested recursion, we extended the technique to arbitrary term rewriting systems. <p> By the introduction of dependency graphs we obtained a considerably more powerful automated technique than the method proposed in [AG96b]. Most significant, while in <ref> [Art96, AG96b] </ref> dependency pairs were only used for termination proofs of non-overlapping constructor systems without nested recursion, we extended the technique to arbitrary term rewriting systems. Recently, we also developed a method to use dependency pairs for proving innermost normalisation, which is applicable to arbitrary TRSs [AG96c]. <p> Note that there exist only finitely many (and only few) different possibilities to eliminate arguments of function symbols. Therefore, all these possibilities can be checked automatically. First, the described technique is used to prove termination of all examples from [AG96a] (Ex. 8.1 - 8.14). While the method of <ref> [AG96b, AG96a] </ref> is restricted to non-overlapping constructor systems without nested recursion, the approach used in this paper can handle arbitrary term rewriting systems. Therefore, subsequently several examples are listed where the technique has been successfully applied to TRSs that do not meet the above restrictions. 8.1. <p> Therefore, subsequently several examples are listed where the technique has been successfully applied to TRSs that do not meet the above restrictions. 8.1. Division, Version 1 This is the running example of the article <ref> [AG96b] </ref>, which is not simply terminating. minus (x; 0) ! x minus (s (x); s (y)) ! minus (x; y) quot (0; s (y)) ! 0 quot (s (x); s (y)) ! s (quot (minus (x; y); s (y))) 13 In this example, apart from the four inequalities corresponding to the
Reference: [AG96c] <author> T. Arts and J. Giesl. </author> <title> Proving innermost normalisation automatically. </title> <type> Technical Report IBN 96/39, </type> <institution> Technische Hochschule Darmstadt, Ger-many, </institution> <month> October </month> <year> 1996. </year> <month> 31 </month>
Reference-contexts: Recently, we also developed a method to use dependency pairs for proving innermost normalisation, which is applicable to arbitrary TRSs <ref> [AG96c] </ref>. By restricting the notion of chains, considering normal substitutions and innermost reductions only, we obtain a soundness and completeness result for innermost normalisation. Adapting the restrictions to the notion of dependency graphs as well results in a powerful technique to prove innermost normalisation of TRSs automatically.
Reference: [Art96] <author> T. </author> <title> Arts. Termination by absence of infinite chains of dependency pairs. </title> <editor> In Helene Kirchner, editor, </editor> <booktitle> Proceedings of the 21st International Colloquium on Trees in Algebra and Programming, CAAP'96, volume 1059 of Lecture Notes in Computer Science, </booktitle> <pages> pages 196-210, </pages> <address> Linkoping, Sweden, April 1996. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: Since by the definition of ren, the variables in ren (cap (t i )) are disjoint from the variables in ren (cap (t j )) for all i 6= j, ren (cap (t)) also matches v. ut 6. Related Work The concept of dependency pairs was introduced in <ref> [Art96] </ref> and a first method for the automation of the dependency pair approach was proposed in [AG96b]. In the present paper we formulated an alternative version of the termination criterion using 10 dependency pairs which is better suited for automation than the original criterion of [Art96]. <p> dependency pairs was introduced in <ref> [Art96] </ref> and a first method for the automation of the dependency pair approach was proposed in [AG96b]. In the present paper we formulated an alternative version of the termination criterion using 10 dependency pairs which is better suited for automation than the original criterion of [Art96]. Moreover, in this way we could prove the soundness of the criterion in a very easy and short way (while the corresponding proof in [Art96] used semantic labelling [Zan95]) and we could also prove its completeness. <p> paper we formulated an alternative version of the termination criterion using 10 dependency pairs which is better suited for automation than the original criterion of <ref> [Art96] </ref>. Moreover, in this way we could prove the soundness of the criterion in a very easy and short way (while the corresponding proof in [Art96] used semantic labelling [Zan95]) and we could also prove its completeness. By having the theory based on semantic labelling, in earlier approaches we were forced to construct a semantic interpretation for the TRS, which is undecidable in general. <p> By the introduction of dependency graphs we obtained a considerably more powerful automated technique than the method proposed in [AG96b]. Most significant, while in <ref> [Art96, AG96b] </ref> dependency pairs were only used for termination proofs of non-overlapping constructor systems without nested recursion, we extended the technique to arbitrary term rewriting systems. Recently, we also developed a method to use dependency pairs for proving innermost normalisation, which is applicable to arbitrary TRSs [AG96c].
Reference: [BD86] <author> L. Bachmair and N. Dershowitz. </author> <title> Commutation, transformation and termination. </title> <editor> In Jorg H. Siekmann, editor, </editor> <booktitle> Proceedings of the 8th International Conference on Automated Deduction, volume 230 of Lecture Notes in Computer Science, </booktitle> <pages> pages 5-20, </pages> <address> Oxford, England, July 1986. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings <ref> [BD86, BL90, Ste95a] </ref>, semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs. <p> The only other sound and complete criterion that has been used for automatic termination proofs (by J. Steinbach [Ste92, Ste95a]) is the approach of transformation orderings <ref> [BD86, BL90] </ref>. It turns out that the termination of several examples where the automation of Steinbach failed [Ste92] can be proved by our technique automatically (Sect. 8).
Reference: [BL87] <author> A. Ben Cherifa and P. Lescanne. </author> <title> Termination of rewriting systems by polynomial interpretations and its implementation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9 </volume> <pages> 137-159, </pages> <year> 1987. </year>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations <ref> [Lan79, BL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs.
Reference: [BL88] <author> F. Bellegarde and P. Lescanne. </author> <title> Termination proofs based on transformation techniques. </title> <type> Technical report, </type> <institution> Centre de Recherche en Informatique de Nancy, </institution> <address> Nancy (France), </address> <month> March </month> <year> 1988. </year>
Reference-contexts: In a completely analogous way, we can also prove termination of the system f (g (x)) ! f (h (g (x))): from <ref> [BL88] </ref>. 8.36. Reversing Lists The following system is a slight variant of a TRS proposed in [HH82, `brev'].
Reference: [BL90] <author> F. Bellegarde and P. Lescanne. </author> <title> Termination by completion. Applicable Algebra in Engineering, </title> <journal> Communication and Computing, </journal> <volume> 1 </volume> <pages> 79-96, </pages> <year> 1990. </year>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings <ref> [BD86, BL90, Ste95a] </ref>, semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs. <p> The only other sound and complete criterion that has been used for automatic termination proofs (by J. Steinbach [Ste92, Ste95a]) is the approach of transformation orderings <ref> [BD86, BL90] </ref>. It turns out that the termination of several examples where the automation of Steinbach failed [Ste92] can be proved by our technique automatically (Sect. 8).
Reference: [BL93] <author> E. Bevers and J. Lewi. </author> <title> Proving termination of (conditional) rewrite systems. </title> <journal> Acta Informatica, </journal> <volume> 30 </volume> <pages> 537-568, </pages> <year> 1993. </year>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations <ref> [Lan79, BL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs.
Reference: [BM79] <author> R.S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: This example was taken from <ref> [BM79] </ref> resp. [Wal91]. A variant of this example could be proved terminating using Steinbach's method for the automated generation of transformation orderings [Ste95a], but there the rules for le and minus were missing. 8.6. <p> This example is inspired by an algorithm from <ref> [BM79] </ref> and [Wal94]. In the corresponding example from [Ste92] the rules for le, eq, if rm and if min were missing. 8.11. Quicksort The quicksort TRS is used to sort a list by the well-known quicksort-algorithm.
Reference: [Der79] <author> N. Dershowitz. </author> <title> A note on simplification orderings. </title> <journal> Information Processing Letters, </journal> <volume> 9(5) </volume> <pages> 212-215, </pages> <year> 1979. </year>
Reference-contexts: A TRS is terminating if there does not exist a term that starts an infinite reduction. Unfortunately, most methods for automated termination proofs are restricted to simplification orderings <ref> [Der79, Ste95b] </ref>. These methods cannot be used to prove termination of systems like the TRS above, because the left-hand side of the last rule is homeomorphically embedded in its right-hand side.
Reference: [Der81] <author> N. Dershowitz. </author> <title> Termination of linear rewriting systems. </title> <editor> In S. Even and O. Kariv, editors, </editor> <booktitle> Proceedings of the 8th International Colloquium on Automata, Languages and Programming (ALP), volume 115 of Lecture Notes in Computer Science, </booktitle> <pages> pages 448-458, </pages> <address> Acre, Israel, July 1981. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: However, these terms nevertheless have to be considered in the forward closure approach. 11 Compared to the forward closure approach, the dependency pair technique has the advantage that it can be used for arbitrary TRSs, whereas the absence of infinite forwards closures only implies termination for right-linear <ref> [Der81] </ref> or non-overlapping [Geu89] TRSs. Moreover, in contrast to the dependency pair method, we do not know of any attempt to automate the forward closure approach. 7. Conclusion We have developed a method for automated termination proofs of term rewriting systems.
Reference: [Der82] <author> N. Dershowitz. </author> <title> Orderings for term-rewriting systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 17 </volume> <pages> 279-301, </pages> <year> 1982. </year>
Reference-contexts: 1. Introduction Termination is one of the most fundamental properties of a term rewriting system, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings <ref> [Pla78, Der82, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs. <p> Moreover, we can map any function symbol to a constant. The second approach is based on path orderings (e.g. recursive or lexicographic path orderings) <ref> [Pla78, Der82, DH95, Ste95b] </ref>. The path orderings are simplification orderings that are easily generated automatically. Note that path orderings are always strictly monotonic, whereas in our method we only need a weakly monotonic ordering.
Reference: [Der87] <author> N. Dershowitz. </author> <title> Termination of rewriting. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3(1 and </volume> 2):69-116, 1987. 
Reference-contexts: this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. <ref> [Der87, Ste95b] </ref>). In this paper we present a new approach for the automation of termination proofs. Previous methods for proving termination usually tried to find a well-founded ordering (with certain additional features) such that left-hand sides of rules are greater than right-hand sides. <p> Therefore this polynomial ordering cannot be used for a direct termination proof, but it nevertheless satisfies the inequalities generated by our method. In this way, termination can easily be proved. 8.22. Multiplication and Addition The following example is taken from <ref> [Der87, p. 101] </ref>. 26 x fi (y + 1) ! (x fi (y + (1 fi 0))) + x x + 0 ! x The inequalities resulting from dependency pairs on a cycle of the dependency graph are TIMES (x; y + 1) TIMES (x; y + (1 fi 0)) This <p> 1) ! (x fi (y + (1 fi 0))) + x x + 0 ! x The inequalities resulting from dependency pairs on a cycle of the dependency graph are TIMES (x; y + 1) TIMES (x; y + (1 fi 0)) This system is not simply terminating (and in <ref> [Der87] </ref> it is used to illustrate the use of the semantic path ordering). However, with our method termination of this example can be proved automatically. The inequalities obtained are satisfied by the natural polynomial ordering, where TIMES (x; y) is mapped to y. 8.23. <p> A TRS which is not totally terminating 1 The most famous example of a TRS that is terminating, but not totally terminating is the following <ref> [Der87] </ref>. f (a) ! f (b) With our approach, termination of this system is again obvious, because the dependency graph does not contain any cycles (as F (b) is not connectable to F (a) and G (a) is not connectable to G (b)). <p> Systems with `Undefined' Function Symbols The following well-known system from <ref> [Der87] </ref> is one of the smallest non-simply terminating TRSs. f (f (x)) ! f (g (f (x))) As F (g (f (x))) is not connectable to F (f (x)), the only dependency pair on a cycle of the dependency graph is hF (f (x)); F (x)i.
Reference: [Der93] <author> N. Dershowitz. </author> <title> 33 examples of termination. </title> <editor> In Hubert Comon and Jean-Pierre Jouannaud, editors, </editor> <booktitle> Term Rewriting, Proceedings Spring School of Theoretical Computer Science, volume 909 of Lecture Notes in Computer Science, </booktitle> <pages> pages 16-27, </pages> <address> Font Romeux, France, May 1993. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: Nested Symbols on Left-hand Sides The following example is from <ref> [Der93] </ref>. <p> Nested Symbols on Both Sides of Rules The following TRS cannot be shown terminating by the lexicographic path ordering and is therefore one of the systems for which the semantic path ordering has been used in literature <ref> [Der93] </ref>. However, the system can be shown to terminate using the lexicographic path ordering after applying the described technique, since the demanded ordering may now be a weakly monotonic ordering instead of a monotonic ordering.
Reference: [DH95] <author> N. Dershowitz and C. Hoot. </author> <title> Natural termination. </title> <journal> Theoretical Computer Science, </journal> <volume> 142(2) </volume> <pages> 179-207, </pages> <year> 1995. </year>
Reference-contexts: 1. Introduction Termination is one of the most fundamental properties of a term rewriting system, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings <ref> [Pla78, Der82, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs. <p> 1. Introduction Termination is one of the most fundamental properties of a term rewriting system, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures <ref> [LM78, DH95] </ref>, semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs. <p> In this paper we presented a sound and complete criterion for termination. In contrast to most other complete approaches (semantic path ordering [KL80], general path ordering <ref> [DH95] </ref>, semantic labelling [Zan95] etc.) our method is particularly well suited for automation as has been demonstrated in this paper. The only other sound and complete criterion that has been used for automatic termination proofs (by J. Steinbach [Ste92, Ste95a]) is the approach of transformation orderings [BD86, BL90]. <p> However, the semantic labelling method presupposes a semantic interpretation, which in general cannot be found automatically, whereas the dependency pair approach does not rely on any semantical interpretation. At first sight there seem to be some similarities between our method and forward closures <ref> [LM78, DH95] </ref>. The idea of forward closures is to restrict the application of rules to that part of a term created by previous rewrites. Similar to our notion of chains, this notion also results in a sequence of terms, but the semantics of these sequences are completely different. <p> Moreover, we can map any function symbol to a constant. The second approach is based on path orderings (e.g. recursive or lexicographic path orderings) <ref> [Pla78, Der82, DH95, Ste95b] </ref>. The path orderings are simplification orderings that are easily generated automatically. Note that path orderings are always strictly monotonic, whereas in our method we only need a weakly monotonic ordering. <p> Average of Naturals The following overlay system, which computes the average of two numbers <ref> [DH95] </ref>, is locally confluent and therefore innermost termination suffices for proving termination. <p> In this way, termination of this TRS is easily proved by mapping 0 to 0, s (x) to x + 1, average (x; y) to x + y, and AVERAGE (x; y) to 2x + y. 8.16. Plus and Times The following TRS <ref> [DH95] </ref> is again a locally confluent overlay system.
Reference: [DJ90] <author> N. Dershowitz and J.-P. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> volume B, </volume> <pages> pages 243-320. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: 1. Introduction Termination is one of the most fundamental properties of a term rewriting system, cf. e.g. <ref> [DJ90] </ref>.
Reference: [DKM90] <author> J. Dick, J. Kalmus, and U. Martin. </author> <title> Automating the Knuth Bendix ordering. </title> <journal> Acta Informatica, </journal> <volume> 28 </volume> <pages> 95-119, </pages> <year> 1990. </year> <month> 32 </month>
Reference-contexts: 1. Introduction Termination is one of the most fundamental properties of a term rewriting system, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings <ref> [KB70, DKM90] </ref>, forward closures [LM78, DH95], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs.
Reference: [Fer95] <author> M. Ferreira. </author> <title> Termination of Term Rewriting,Well-foundedness, Totality and Transformations. </title> <type> PhD thesis, </type> <institution> Utrecht University, </institution> <address> PO Box 80.089, 3508 TB Utrecht, The Netherlands, </address> <year> 1995. </year>
Reference-contexts: A System which is not left-linear The following TRS, originally from Geerling [Gee91], cannot be proved terminating by the recursive path ordering (but one needs a generalisation of the recursive path ordering as defined in <ref> [Fer95] </ref>). <p> The mapping of f (x) and g (x) to 0 satisfies these two inequalities. 8.34. A TRS which is not totally terminating 2 A TRS introduced in <ref> [Fer95] </ref> as an example of a TRS that is not totally terminating and in particular for which the recursive path ordering and the Knuth-Bendix ordering cannot be used to prove termination, is given by: p (f (f (x))) ! q (f (g (x))) q (f (f (x))) ! p (f (g
Reference: [FZ93] <author> M. Ferreira and H. Zantema. </author> <title> Total termination of term rewriting. </title> <editor> In Claude Kirchner, editor, </editor> <booktitle> Proceedings of the 5th Conference on Rewrite Techniques and Applications, RTA-93, volume 690 of Lecture Notes in Computer Science, </booktitle> <pages> pages 213-227, </pages> <address> Montreal, Canada, June 1993. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: Nested Recursion 3 As an example of a string rewrite system with minimal ordinal ! ! associated to it, Hans Zantema and Maria Ferreira presented the following TRS <ref> [FZ93] </ref>. f (g (x)) ! g (f (f (x))) The inequalities corresponding to this system, except for the inequalities corresponding to the two rules, are F (g (x)) F (f (x)) All inequalities are satisfied by the polynomial interpretation mapping f (x) and F (x) to x, h (x) to 0
Reference: [FZ95] <author> M. Ferreira and H. Zantema. </author> <title> Dummy elimination: making termination easier. </title> <editor> In Horst Reichel, editor, </editor> <booktitle> Proceedings of the 10th International Conference on Fundamentals of Computation Theory, FCT'95, volume 965 of Lecture Notes in Computer Science, </booktitle> <pages> pages 243-252, </pages> <address> Dresden, Ger-many, August 1995. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: Systems without Cycles in Dependency Graphs 2 Another example in which the dependency graph plays an important role is a TRS introduced in <ref> [FZ95] </ref> to demonstrate the technique of `dummy elimination'. f (g (x)) ! f (a (g (g (f (x))); g (f (x)))) Since a (x; y) does not unify with g (x), the only two inequalities to satisfy are f (g (x)) % f (a (g (g (f (x))); g (f (x))))
Reference: [Gee91] <author> M. Geerling. </author> <title> Termination of term rewriting systems. </title> <type> Master's thesis, </type> <institution> Utrecht University, </institution> <address> PO Box 80.089, 3508 TB Utrecht, The Netherlands, </address> <year> 1991. </year>
Reference-contexts: A System which is not left-linear The following TRS, originally from Geerling <ref> [Gee91] </ref>, cannot be proved terminating by the recursive path ordering (but one needs a generalisation of the recursive path ordering as defined in [Fer95]).
Reference: [Geu89] <author> O. Geupel. </author> <title> Overlap closures and termination of term rewriting systems. </title> <type> Technical Report MIP-8922 283, </type> <institution> Universitat Passau, Passau, Germany, </institution> <year> 1989. </year>
Reference-contexts: However, these terms nevertheless have to be considered in the forward closure approach. 11 Compared to the forward closure approach, the dependency pair technique has the advantage that it can be used for arbitrary TRSs, whereas the absence of infinite forwards closures only implies termination for right-linear [Der81] or non-overlapping <ref> [Geu89] </ref> TRSs. Moreover, in contrast to the dependency pair method, we do not know of any attempt to automate the forward closure approach. 7. Conclusion We have developed a method for automated termination proofs of term rewriting systems.
Reference: [Gie95a] <author> J. Giesl. </author> <title> Automatisierung von Terminierungsbeweisen fur rekursiv definierte Algorithmen. </title> <type> PhD thesis, </type> <institution> Technische Hochschule Darmstadt, Germany, </institution> <year> 1995. </year> <note> In German. </note>
Reference-contexts: Reachability on Directed Graphs To check whether there is a path from the node x to the node y in a directed graph g, the term reach (x; y; g; *) must be reducible to true with the rules of the TRS of this example from <ref> [Gie95a] </ref>. The fourth argument of reach is used to store edges that have already been examined but that are not included in the actual solution path. If an edge from u to v (with x 6= u) is found, then it is rejected at first.
Reference: [Gie95b] <author> J. Giesl. </author> <title> Generating polynomial orderings for termination proofs. </title> <editor> In Jieh Hsiang, editor, </editor> <booktitle> Proceedings of the 6th International Conference on Rewriting Techniques and Applications, RTA-95, volume 914 of Lecture Notes in Computer Science, </booktitle> <pages> pages 426-431, </pages> <address> Kaiserslautern, Germany, April 1995. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations <ref> [Lan79, BL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs. <p> Methods for the automated generation of polynomial orderings have for instance been developed in <ref> [Ste94, Gie95b] </ref>. In this way, termination of this TRS can be proved fully automatically, although a direct termination proof with simplification orderings was not possible. <p> After having obtained the inequalities, a well-founded weakly monotonic quasi-ordering satisfying these inequalities is generated. In the following collection of examples we use two different methods for that purpose. The first approach is the well-known approach of synthesizing polynomial orderings [Lan79]. Several techniques exist to derive polynomial interpretations automatically <ref> [Ste94, Gie95b] </ref>. In contrast to the use of polynomial orderings for direct termination proofs, we can use polynomial interpretations with weakly monotonic polynomials. For instance, we can map a binary function symbol f (x; y) to the polynomial x + 1 which is not strictly monotonic in its second argument.
Reference: [Gie96] <author> J. Giesl. </author> <title> Termination of nested and mutually recursive algorithms. </title> <journal> Journal of Automated Reasoning, </journal> <note> 1996. To appear. </note>
Reference-contexts: Nested Recursion 1 The following system was introduced in <ref> [Gie96, `nest2'] </ref> as an example for a small TRS with nested recursion where all simplification orderings fail. f (0; y) ! 0 With our approach, however, an automated termination proof is directly possible.
Reference: [HH82] <author> G. Huet and J.-M. Hullot. </author> <title> Proofs by induction in equational theories with constructors. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25 </volume> <pages> 239-299, </pages> <year> 1982. </year>
Reference-contexts: In a completely analogous way, we can also prove termination of the system f (g (x)) ! f (h (g (x))): from [BL88]. 8.36. Reversing Lists The following system is a slight variant of a TRS proposed in <ref> [HH82, `brev'] </ref>. Given a list x. l, the function rev calls two other functions rev1 and rev2, where rev1 (x; l) returns the last element of x. l and rev2 (x; l) returns the reversed list rev (x. l) without its first element.
Reference: [HL78] <author> G. Huet and D. Lankford. </author> <title> On the uniform halting problem for term rewriting systems. </title> <type> Technical Report 283, </type> <institution> INRIA, Le Chesnay, France, </institution> <year> 1978. </year>
Reference-contexts: 1. Introduction Termination is one of the most fundamental properties of a term rewriting system, cf. e.g. [DJ90]. While in general this problem is undecidable <ref> [HL78] </ref>, several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]).
Reference: [KB70] <author> D. E. Knuth and P. B. Bendix. </author> <title> Simple word problems in universal algebras. </title> <booktitle> Computational problems in abstract algebra, </booktitle> <pages> pages 263-297, </pages> <year> 1970. </year>
Reference-contexts: 1. Introduction Termination is one of the most fundamental properties of a term rewriting system, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings <ref> [KB70, DKM90] </ref>, forward closures [LM78, DH95], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs.
Reference: [KL80] <author> S. Kamin and J.-J. Levy. </author> <title> Two generalizations of the recursive path ordering. </title> <institution> Department of Computer Science, University of Illinois, IL, </institution> <year> 1980. </year>
Reference-contexts: In this paper we presented a sound and complete criterion for termination. In contrast to most other complete approaches (semantic path ordering <ref> [KL80] </ref>, general path ordering [DH95], semantic labelling [Zan95] etc.) our method is particularly well suited for automation as has been demonstrated in this paper. The only other sound and complete criterion that has been used for automatic termination proofs (by J.
Reference: [Kri95] <author> M.R.K. Krishna Rao. </author> <title> Modular proofs for completeness of hierarchical term rewriting systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 151 </volume> <pages> 487-512, </pages> <year> 1995. </year>
Reference-contexts: The following definition extends these notions to arbitrary term rewriting systems R (F ; R) (with the rules R over a signature F ). Here, the root of a term f (: : :) denotes the leading function symbol f . 2.1 Definition (Defined Symbols and Constructors, cf. <ref> [Kri95] </ref>). The set D R of defined symbols of a TRS R (F ; R) is defined as froot (l)jl ! r 2 Rg and the set C R of constructor symbols of R (F ; R) is defined as F n D R .
Reference: [Lan79] <author> D. S. Lankford. </author> <title> On proving term rewriting systems are noetherian. </title> <type> Technical Report Memo MTP-3, </type> <institution> Louisiana Tech. University, Ruston, LA, </institution> <year> 1979. </year>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations <ref> [Lan79, BL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs. <p> (l; k) sum (x. y. l) % sum ((x + y). l) APP (x. l; k) APP (l; k) SUM (x. y. l) SUM ((x + y). l) SUM (app (l; x. y. k)) APP (l; sum (x. y. k)) For example, these inequalities are satisfied by the polynomial ordering <ref> [Lan79] </ref> where nil is mapped to the constant 0, x. l is mapped to l + 1, (x + y) is mapped to x + y, app (l; k) is mapped to l + k + 1, sum (l) is mapped to the constant 1, and APP (l; k) and SUM <p> After having obtained the inequalities, a well-founded weakly monotonic quasi-ordering satisfying these inequalities is generated. In the following collection of examples we use two different methods for that purpose. The first approach is the well-known approach of synthesizing polynomial orderings <ref> [Lan79] </ref>. Several techniques exist to derive polynomial interpretations automatically [Ste94, Gie95b]. In contrast to the use of polynomial orderings for direct termination proofs, we can use polynomial interpretations with weakly monotonic polynomials.
Reference: [LM78] <author> D. S. Lankford and D. R. Musser. </author> <title> A finite termination criterion, </title> <year> 1978. </year>
Reference-contexts: 1. Introduction Termination is one of the most fundamental properties of a term rewriting system, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures <ref> [LM78, DH95] </ref>, semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs. <p> However, the semantic labelling method presupposes a semantic interpretation, which in general cannot be found automatically, whereas the dependency pair approach does not rely on any semantical interpretation. At first sight there seem to be some similarities between our method and forward closures <ref> [LM78, DH95] </ref>. The idea of forward closures is to restrict the application of rules to that part of a term created by previous rewrites. Similar to our notion of chains, this notion also results in a sequence of terms, but the semantics of these sequences are completely different.
Reference: [Pla78] <author> D. A. Plaisted. </author> <title> A recursively defined ordering for proving termination of term rewriting systems. </title> <type> Technical Report R-78-943, </type> <institution> Dept. of Computer Science, University of Illinois, Urbana, IL, </institution> <year> 1978. </year>
Reference-contexts: 1. Introduction Termination is one of the most fundamental properties of a term rewriting system, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings <ref> [Pla78, Der82, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs. <p> Moreover, we can map any function symbol to a constant. The second approach is based on path orderings (e.g. recursive or lexicographic path orderings) <ref> [Pla78, Der82, DH95, Ste95b] </ref>. The path orderings are simplification orderings that are easily generated automatically. Note that path orderings are always strictly monotonic, whereas in our method we only need a weakly monotonic ordering.
Reference: [Ste92] <author> J. Steinbach. </author> <title> Notes on transformation orderings. </title> <type> Technical Report SR-92-23, </type> <institution> Universitat Kaiserslautern, Kaiserslautern, Germany, </institution> <year> 1992. </year>
Reference-contexts: The only other sound and complete criterion that has been used for automatic termination proofs (by J. Steinbach <ref> [Ste92, Ste95a] </ref>) is the approach of transformation orderings [BD86, BL90]. It turns out that the termination of several examples where the automation of Steinbach failed [Ste92] can be proved by our technique automatically (Sect. 8). <p> The only other sound and complete criterion that has been used for automatic termination proofs (by J. Steinbach [Ste92, Ste95a]) is the approach of transformation orderings [BD86, BL90]. It turns out that the termination of several examples where the automation of Steinbach failed <ref> [Ste92] </ref> can be proved by our technique automatically (Sect. 8). There is a relation between the dependency pair approach and semantic labelling [Zan95], because the dependency pairs correspond to the labels of a TRS labelled by the process of self-labelling. <p> This example is inspired by an algorithm from [BM79] and [Wal94]. In the corresponding example from <ref> [Ste92] </ref> the rules for le, eq, if rm and if min were missing. 8.11. Quicksort The quicksort TRS is used to sort a list by the well-known quicksort-algorithm. <p> Addition with Nested Recursion Version 2 The following alternative TRS for addition from <ref> [Ste92] </ref> has nested recursion, too. 0 + y ! y s (x) + s (y) ! s (s (x) + (y + 0)) The `natural' polynomial interpretation (where + is mapped to the addition) maps left and right-hand sides of the rules to the same numbers. <p> Nested Recursion 2 This system (by Christoph Walther), which is similar system to the preceding one, has been examined in <ref> [Ste92] </ref>. f (0) ! s (0) f (s (s (x))) ! f (f (s (x))) The inequalities resulting from our transformation are satisfied by the polynomial ordering, where f (x) is mapped to the constant 1, F (x) is mapped to x, and where 0 and s are interpreted as usual. <p> Systems without Cycles in Dependency Graphs 1 The following system is from <ref> [Ste92] </ref>. f (a; b) ! f (a; c) With our method, the termination proof for this system is trivial, because its dependency graph does not contain any cycles.
Reference: [Ste94] <author> J. Steinbach. </author> <title> Generating polynomial orderings. </title> <journal> Information Processing Letters, </journal> <volume> 49 </volume> <pages> 85-93, </pages> <year> 1994. </year>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations <ref> [Lan79, BL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs. <p> Methods for the automated generation of polynomial orderings have for instance been developed in <ref> [Ste94, Gie95b] </ref>. In this way, termination of this TRS can be proved fully automatically, although a direct termination proof with simplification orderings was not possible. <p> After having obtained the inequalities, a well-founded weakly monotonic quasi-ordering satisfying these inequalities is generated. In the following collection of examples we use two different methods for that purpose. The first approach is the well-known approach of synthesizing polynomial orderings [Lan79]. Several techniques exist to derive polynomial interpretations automatically <ref> [Ste94, Gie95b] </ref>. In contrast to the use of polynomial orderings for direct termination proofs, we can use polynomial interpretations with weakly monotonic polynomials. For instance, we can map a binary function symbol f (x; y) to the polynomial x + 1 which is not strictly monotonic in its second argument.
Reference: [Ste95a] <author> J. Steinbach. </author> <title> Automatic termination proofs with transformation order-ings. </title> <editor> In Jieh Hsiang, editor, </editor> <booktitle> Proceedings of the 6th International Conference on Rewriting Techniques and Applications, RTA-95, volume 914 of Lecture Notes in Computer Science, </booktitle> <pages> pages 11-25, </pages> <address> Kaiserslautern, Ger-many, April 1995. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings <ref> [BD86, BL90, Ste95a] </ref>, semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs. <p> The only other sound and complete criterion that has been used for automatic termination proofs (by J. Steinbach <ref> [Ste92, Ste95a] </ref>) is the approach of transformation orderings [BD86, BL90]. It turns out that the termination of several examples where the automation of Steinbach failed [Ste92] can be proved by our technique automatically (Sect. 8). <p> This example was taken from [BM79] resp. [Wal91]. A variant of this example could be proved terminating using Steinbach's method for the automated generation of transformation orderings <ref> [Ste95a] </ref>, but there the rules for le and minus were missing. 8.6. <p> This example comes from [Wal91] and a similar example was mentioned in <ref> [Ste95a] </ref>, but in Steinbach's version the rules for eq and if rm were missing. <p> Steinbach could prove termination of a corresponding example with transformation orderings <ref> [Ste95a] </ref>, but in his example the rules for le, if low if high and app were omitted.
Reference: [Ste95b] <author> J. Steinbach. </author> <title> Simplification orderings: history of results. </title> <journal> Fundamenta Informaticae, </journal> <volume> 24 </volume> <pages> 47-87, </pages> <year> 1995. </year>
Reference-contexts: 1. Introduction Termination is one of the most fundamental properties of a term rewriting system, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings <ref> [Pla78, Der82, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs. <p> this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. <ref> [Der87, Ste95b] </ref>). In this paper we present a new approach for the automation of termination proofs. Previous methods for proving termination usually tried to find a well-founded ordering (with certain additional features) such that left-hand sides of rules are greater than right-hand sides. <p> A TRS is terminating if there does not exist a term that starts an infinite reduction. Unfortunately, most methods for automated termination proofs are restricted to simplification orderings <ref> [Der79, Ste95b] </ref>. These methods cannot be used to prove termination of systems like the TRS above, because the left-hand side of the last rule is homeomorphically embedded in its right-hand side. <p> Moreover, we can map any function symbol to a constant. The second approach is based on path orderings (e.g. recursive or lexicographic path orderings) <ref> [Pla78, Der82, DH95, Ste95b] </ref>. The path orderings are simplification orderings that are easily generated automatically. Note that path orderings are always strictly monotonic, whereas in our method we only need a weakly monotonic ordering.
Reference: [Toy87] <author> Y. Toyama. </author> <title> Counterexamples to the termination for the direct sum of term rewriting systems. </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 141-143, </pages> <year> 1987. </year>
Reference-contexts: In order to ensure that t is connectable to u whenever there exists a substitution such that t ! fl R u, before unification we also have to rename multiple occurrences of the same variable. As an example consider the following well-known TRS from <ref> [Toy87] </ref>. g (x; y) ! x 9 The only dependency pair, viz. hF (0; 1; x); F (x; x; x)i, is on a cycle of the dependency graph, because F (x; x; x) reduces to F (0; 1; x 0 ), if replaces x and x 0 by g (0; 1).
Reference: [Wal91] <author> C. Walther. </author> <title> Automatisierung von Terminierungsbeweisen. </title> <publisher> Vieweg Verlag, </publisher> <address> Braunschweig, </address> <year> 1991. </year>
Reference-contexts: This example was taken from [BM79] resp. <ref> [Wal91] </ref>. A variant of this example could be proved terminating using Steinbach's method for the automated generation of transformation orderings [Ste95a], but there the rules for le and minus were missing. 8.6. <p> This example comes from <ref> [Wal91] </ref> and a similar example was mentioned in [Ste95a], but in Steinbach's version the rules for eq and if rm were missing.
Reference: [Wal94] <author> C. Walther. </author> <title> On proving the termination of algorithms by machine. </title> <journal> Artificial Intelligence, </journal> <volume> 71(1) </volume> <pages> 101-157, </pages> <year> 1994. </year>
Reference-contexts: But this version here is even more difficult: Termination of the corresponding algorithm cannot be proved by the method of <ref> [Wal94] </ref>, because this method cannot deal with permutations of arguments.) The relevant inequalities of this TRS are LE (s (x); s (y)) LE (x; y) MINUS (x; s (y)) MINUS (x; y) GCD (s (x); s (y)) % IF gcd (le (y; x); s (x); s (y)) IF gcd (true; s <p> Selection Sort This TRS from <ref> [Wal94] </ref>, which is a slight modification of the corresponding TRS in [AG96a], is obviously not simply terminating. The TRS can be used to sort a list by repeatedly replacing the minimum of the list by the head of the list. <p> This example is inspired by an algorithm from [BM79] and <ref> [Wal94] </ref>. In the corresponding example from [Ste92] the rules for le, eq, if rm and if min were missing. 8.11. Quicksort The quicksort TRS is used to sort a list by the well-known quicksort-algorithm. <p> With our method, termination could still be proved in the same way. 8.12. Permutation of Lists This example is a TRS from <ref> [Wal94] </ref> to compute a permutation of a list, for instance, shu*e ([1; 2; 3; 4; 5]) reduces to [1; 5; 2; 4; 3]. app (nil; y) ! y reverse (nil) ! nil reverse (add (n; x)) ! app (reverse (x); add (n; nil)) shu*e (nil) ! nil shu*e (add (n; x))
Reference: [Zan94] <author> H. Zantema. </author> <title> Termination of term rewriting: interpretation and type elimination. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 17 </volume> <pages> 23-50, </pages> <year> 1994. </year>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations <ref> [Lan79, BL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs.
Reference: [Zan95] <author> H. Zantema. </author> <title> Termination of term rewriting by semantic labelling. </title> <journal> Fun-damenta Informaticae, </journal> <volume> 24 </volume> <pages> 89-105, </pages> <year> 1995. </year> <month> 34 </month>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], forward closures [LM78, DH95], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling <ref> [Zan95] </ref> etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we present a new approach for the automation of termination proofs. Previous methods for proving termination usually tried to find a well-founded ordering (with certain additional features) such that left-hand sides of rules are greater than right-hand sides. <p> Moreover, in this way we could prove the soundness of the criterion in a very easy and short way (while the corresponding proof in [Art96] used semantic labelling <ref> [Zan95] </ref>) and we could also prove its completeness. By having the theory based on semantic labelling, in earlier approaches we were forced to construct a semantic interpretation for the TRS, which is undecidable in general. <p> In this paper we presented a sound and complete criterion for termination. In contrast to most other complete approaches (semantic path ordering [KL80], general path ordering [DH95], semantic labelling <ref> [Zan95] </ref> etc.) our method is particularly well suited for automation as has been demonstrated in this paper. The only other sound and complete criterion that has been used for automatic termination proofs (by J. Steinbach [Ste92, Ste95a]) is the approach of transformation orderings [BD86, BL90]. <p> Steinbach [Ste92, Ste95a]) is the approach of transformation orderings [BD86, BL90]. It turns out that the termination of several examples where the automation of Steinbach failed [Ste92] can be proved by our technique automatically (Sect. 8). There is a relation between the dependency pair approach and semantic labelling <ref> [Zan95] </ref>, because the dependency pairs correspond to the labels of a TRS labelled by the process of self-labelling. However, the semantic labelling method presupposes a semantic interpretation, which in general cannot be found automatically, whereas the dependency pair approach does not rely on any semantical interpretation.
References-found: 43

