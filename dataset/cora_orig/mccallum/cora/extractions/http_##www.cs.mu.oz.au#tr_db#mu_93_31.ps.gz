URL: http://www.cs.mu.oz.au/tr_db/mu_93_31.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: zs@cs.mu.oz.au  
Phone: Phone: +61 3 282 2401, Fax: +61 3 348 1184  
Title: Managing don't-know nondeterminism in parallel logic operating systems  
Author: Zoltan Somogyi 
Address: Parkville, 3052 Victoria, Australia  
Affiliation: Department of Computer Science, University of Melbourne  
Abstract: The ideals of logic programming are best served by languages whose operational semantics is close to their declarative semantics. The standard declarative semantics allows a goal to have any number of solutions; the ideal language therefore needs don't-know nondeterminism. Nevertheless, no research in parallel logic operating systems has been based on such languages so far. The reason is that programs written in such languages may generate a hundred solutions for one set of inputs and none for another; this prevents their outputs from being interpreted as commands for real- world devices. We define three properties that a logic program must have if it is to avoid such problems: functionality, monotonicity and totality. We then present a mechanism that can guarantee at compile-time that a program written in a don't-know nondeterministic language has these properties. 
Abstract-found: 1
Intro-found: 1
Reference: [ArEV86] <author> J.L. Armstrong, N.A. Elshiewy and R. Virding, </author> <title> `The phoning philosopher's problem or logic programming for telecommunication applications', </title> <booktitle> Proceedings of the Third IEEE Symposium on Logic Programming, </booktitle> <address> Salt Lake City, Utah, </address> <pages> pages 28-33, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: In a logic operating system the devices will be terminals, disks, tapes, networks, or any of the other peripherals of a computer system [FoKu86]. In industrial and other applications they will be embedded computers controlling machinery, e.g. a phone switching system in <ref> [ArEV86] </ref>. Note that the main program produces side-effects not by invoking special system primitives (as in Prolog) but by instantiating variables whose values are monitored outside the logic programming system itself.
Reference: [BaGr89] <author> Reem Bahgat and Steve Gregory, `Pandora: </author> <title> non-deterministic parallel logic programming', </title> <booktitle> Proceedings of the Sixth International Conference on Logic Programming, Lisboa, Portugal, </booktitle> <pages> pages 471-486, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: There are two reasons for this restriction. One is that these systems need dependent or stream AND- parallelism to represent concurrent communicating processes [EmLu79], and the integration of don't- know nondeterminism with dependent AND-parallelism poses some difficult implementation problems that have only recently been addressed <ref> [ClGr87, BaGr89, HaBr88, Nais88, SoRV88] </ref>. The other reason is that the connection of don't-know nondeterministic logic programs and deterministic devices presents three persistent problems. These problems involve the variables whose values are monitored by device drivers. We call these real-world-state variables, or state variables for short. 1. <p> One can write search-type don't-know nondeterministic programs in the same language that one uses to write the operating system. Committed choice languages [ClGr86, Shap84, Ueda85] do not support the former; languages based on the Andorra principle <ref> [HaBr88, BaGr89] </ref> do not support the latter. In this paper we have concentrated on global stability, but local stability is a useful concept as well.
Reference: [BeLM93] <author> Johan Bevemyr, Thomas Lindgren and Hakan Millroth, </author> <title> `Reform Prolog: the language and its implementation', </title> <booktitle> Proceedings of the Tenth International Conference on Logic Programming, </booktitle> <address> Budapest, Hungary, </address> <pages> pages 283-298, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The definition of binding determinacy in [Nais88] is roughly equivalent to the combination of our functionality and monotonicity: in PNU-Prolog, the syntactic sugar of lazyDet and eagerDet declarations hides the non-logical primitives used to implement them. The notion of unconditional variable binding in Reform-Prolog <ref> [BeLM93] </ref> is equivalent to binding determinacy, and is used for a similar purpose. Our notion of functionality differs from the one in [Smol84]. In Smolka's system, a predicate declared to be functional may in fact have multiple solutions, but all solutions following the first will be discarded.
Reference: [Card85] <author> L. Cardelli, </author> <title> `Amber', </title> <booktitle> Proceedings of the Thirteenth Spring School of the LITP: Combinators and functional programming languages, Val d'Ajol, France, </booktitle> <pages> pages 21-47, </pages> <month> May </month> <year> 1985. </year> <month> - 22 </month> - 
Reference-contexts: comes from the fact that objects of all types, including univ, can be converted to type univ by bundling them up with their types in what we call a cocoon. (As far as we know, this idea is due to Cardelli, whose name for the concept is the dynamic type <ref> [Card85] </ref>.) One can convert any object to the universal type through make_cocoon (Origobj, Univobj), and later recover it through break_cocoon (Univobj, Recobj).
Reference: [Chik84] <author> Takashi Chikayama, </author> <title> `Unique features of ESP', </title> <booktitle> Proceedings of the 1984 International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo, Japan, </address> <pages> pages 292-298, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: Most macros will come from a standard library that contains definitions for the built-in predicates (e.g. cmp and bindingstate), but there is no reason why some cannot be defined by the user, perhaps using the mechanisms of <ref> [Chik84] </ref> and [KoCh88]. The compiler analyzes the output of these macros, so the user cannot use them to subvert the stability checks (or the type and mode checks for that matter).
Reference: [ChSM88] <author> Takashi Chikayama, Hiroyuli Sato and Toshihiko Miyazaki, </author> <title> `Overview of the parallel inference machine operating system (PIMOS)', </title> <booktitle> Proceedings of the 1988 International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo, Japan, </address> <pages> pages 230-251, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: The resulting systems (e.g. SIMPOS [TYUK84]) rely on side-effects even more extensively than other Prolog programs. The second approach is based on parallel languages such as Parlog, Concurrent Prolog, GHC and their at versions as described in [ClGr84, Shap84, Kusa86, FoKu86, Fost87]. The resulting systems (e.g. PIMOS <ref> [ChSM88] </ref> and Logix [SHHS86]) communicate with the world via streams whose values are monitored by device drivers; the operating system itself can therefore be much more declarative.
Reference: [ClGr86] <author> Keith L. Clark and Steve Gregory, </author> <title> `PARLOG: parallel programming in logic', </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8:1, </volume> <pages> pages 1-49, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: Note, though, that any occurrences of X outside the expression p (X) [] q (X,Y) itself would not necessarily be stable; if such occurrences exist then the guard is unsafe <ref> [ClGr86] </ref>. In the rest of the paper we will often talk about a predicate being stable (functional, etc) but this is only shorthand for a predicate in a given mode being stable. <p> One can write search-type don't-know nondeterministic programs in the same language that one uses to write the operating system. Committed choice languages <ref> [ClGr86, Shap84, Ueda85] </ref> do not support the former; languages based on the Andorra principle [HaBr88, BaGr89] do not support the latter. In this paper we have concentrated on global stability, but local stability is a useful concept as well.
Reference: [ClGr87] <author> Keith L. Clark and Steve Gregory, </author> <title> `Parlog and Prolog united', </title> <booktitle> Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <address> Melbourne, Australia, </address> <pages> pages 927-961, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: There are two reasons for this restriction. One is that these systems need dependent or stream AND- parallelism to represent concurrent communicating processes [EmLu79], and the integration of don't- know nondeterminism with dependent AND-parallelism poses some difficult implementation problems that have only recently been addressed <ref> [ClGr87, BaGr89, HaBr88, Nais88, SoRV88] </ref>. The other reason is that the connection of don't-know nondeterministic logic programs and deterministic devices presents three persistent problems. These problems involve the variables whose values are monitored by device drivers. We call these real-world-state variables, or state variables for short. 1.
Reference: [ClGr84] <author> Keith Clark and Steve Gregory, </author> <booktitle> `Notes on systems programming in PARLOG', Proceedings of the 1984 International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo, Japan, </address> <pages> pages 299-306, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: The resulting systems (e.g. SIMPOS [TYUK84]) rely on side-effects even more extensively than other Prolog programs. The second approach is based on parallel languages such as Parlog, Concurrent Prolog, GHC and their at versions as described in <ref> [ClGr84, Shap84, Kusa86, FoKu86, Fost87] </ref>. The resulting systems (e.g. PIMOS [ChSM88] and Logix [SHHS86]) communicate with the world via streams whose values are monitored by device drivers; the operating system itself can therefore be much more declarative. <p> In the context of logic operating systems, though, a variant of the metacall primitive that never fails is indispensable, so <ref> [ClGr84] </ref> introduced two-argument metacalls. Their call (e,S) always succeeds, binding the status variable S to either succeeded or failed according to whether e succeeded or failed. (That paper also introduced three-argument metacalls, while [Fost87] introduced five-argument metacalls; these are versions of the two argument metacall with added control mechanisms.
Reference: [Cone83] <author> John S. Conery, </author> <title> The AND/OR process model for parallel interpretation of logic programs, </title> <type> Ph.D. thesis, </type> <institution> Department of Information and Computer Science, University of California, Irvine, </institution> <month> June </month> <year> 1983. </year>
Reference-contexts: Forms of nondeterminism The background required for a full understanding of this paper is knowledge of the notions of don't-know and don't-care nondeterminism [Kowa79; p. 113] and of dependent or stream AND-parallelism [Greg85]. These concepts are best explained in the context of the AND/OR process model <ref> [Cone83] </ref>. This model views logic programs as being executed by a tree of alternating levels of AND and OR processes. AND processes are responsible for solving the bodies of clauses; OR processes are responsible for solving individual calls.
Reference: [DRRS93] <author> S. Dawson, C.R. Ramakrishnan, I.V. Ramakrishnan and R.C. Sekar, </author> <title> `Extracting determinacy in logic programs', </title> <booktitle> Proceedings of the Tenth International Conference on Logic Programming, </booktitle> <address> Budapest, Hungary, </address> <pages> pages 424-438, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: We could possibly make the compiler call a stability inference system (along the lines of type and mode inference systems), and accept the possibility that the inference system returns maybe as an answer. This approach is pursued in e.g. <ref> [Mell85, DRRS93] </ref>. We adopt what we feel to be a better solution: to cut the Gordian knot by requiring programmers to declare the stability properties of each mode of each predicate if they expect to use the predicate in a context that requires some aspect of stability.
Reference: [DeWa86] <author> Saumya K. Debray and David S. Warren, </author> <title> `Detection and optimisation of functional computations in Prolog', </title> <booktitle> Proceedings of the Third International Conference on Logic Programming, </booktitle> <address> London, England, </address> <pages> pages 490-504, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: When a functional predicate succeeds, we know that the remaining clauses (if any) cannot contribute to another success; we can therefore discard any remaining choice-points. In this it is similar to the notion of functionality as defined in <ref> [DeWa86] </ref> and to the notion of logically deterministic predicates as defined in [Naka86]. The definition of binding determinacy in [Nais88] is roughly equivalent to the combination of our functionality and monotonicity: in PNU-Prolog, the syntactic sugar of lazyDet and eagerDet declarations hides the non-logical primitives used to implement them.
Reference: [EmLu79] <author> M.H. van Emden and D.J. de Lucena, </author> <title> Predicate logic as a language for parallel programming, </title> <institution> Research Report CS-79-15, Department of Computer Science, University of Waterloo, </institution> <address> Ontario, Canada, </address> <year> 1979. </year>
Reference-contexts: This is an important loss; the search paradigm is one of the major advantages of logic over functional programming. There are two reasons for this restriction. One is that these systems need dependent or stream AND- parallelism to represent concurrent communicating processes <ref> [EmLu79] </ref>, and the integration of don't- know nondeterminism with dependent AND-parallelism poses some difficult implementation problems that have only recently been addressed [ClGr87, BaGr89, HaBr88, Nais88, SoRV88]. The other reason is that the connection of don't-know nondeterministic logic programs and deterministic devices presents three persistent problems.
Reference: [Fost87] <author> Ian T. Foster, </author> ` <booktitle> Logic operating systems: design issues', Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <address> Melbourne, Australia, </address> <pages> pages 910-926, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: The resulting systems (e.g. SIMPOS [TYUK84]) rely on side-effects even more extensively than other Prolog programs. The second approach is based on parallel languages such as Parlog, Concurrent Prolog, GHC and their at versions as described in <ref> [ClGr84, Shap84, Kusa86, FoKu86, Fost87] </ref>. The resulting systems (e.g. PIMOS [ChSM88] and Logix [SHHS86]) communicate with the world via streams whose values are monitored by device drivers; the operating system itself can therefore be much more declarative. <p> Their call (e,S) always succeeds, binding the status variable S to either succeeded or failed according to whether e succeeded or failed. (That paper also introduced three-argument metacalls, while <ref> [Fost87] </ref> introduced five-argument metacalls; these are versions of the two argument metacall with added control mechanisms. In this paper we are concerned only with stability, not with control aspects.) This arrangement makes perfect sense if e has no outputs.
Reference: [FoKu86] <author> Ian T. Foster and Anthony J. Kusalik, </author> <title> `A logical treatment of secondary storage', </title> <booktitle> Proceedings of the Third IEEE Symposium on Logic Programming, </booktitle> <address> Salt Lake City, Utah, </address> <pages> pages 58-67, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: The resulting systems (e.g. SIMPOS [TYUK84]) rely on side-effects even more extensively than other Prolog programs. The second approach is based on parallel languages such as Parlog, Concurrent Prolog, GHC and their at versions as described in <ref> [ClGr84, Shap84, Kusa86, FoKu86, Fost87] </ref>. The resulting systems (e.g. PIMOS [ChSM88] and Logix [SHHS86]) communicate with the world via streams whose values are monitored by device drivers; the operating system itself can therefore be much more declarative. <p> In a logic operating system the devices will be terminals, disks, tapes, networks, or any of the other peripherals of a computer system <ref> [FoKu86] </ref>. In industrial and other applications they will be embedded computers controlling machinery, e.g. a phone switching system in [ArEV86]. Note that the main program produces side-effects not by invoking special system primitives (as in Prolog) but by instantiating variables whose values are monitored outside the logic programming system itself.
Reference: [Greg85] <author> Steven Gregory, </author> <title> Design, application and implementation of a parallel logic programming language, </title> <type> Ph.D. thesis, </type> <institution> Department of Computing, Imperial College of Science and Technology, University of London, </institution> <address> England, </address> <month> September </month> <year> 1985. </year>
Reference-contexts: Section 5 shows how program transformations can enhance stability properties. - 1 - 1.1. Forms of nondeterminism The background required for a full understanding of this paper is knowledge of the notions of don't-know and don't-care nondeterminism [Kowa79; p. 113] and of dependent or stream AND-parallelism <ref> [Greg85] </ref>. These concepts are best explained in the context of the AND/OR process model [Cone83]. This model views logic programs as being executed by a tree of alternating levels of AND and OR processes.
Reference: [HaBr88] <author> Seif Haridi and Per Brand, </author> <title> `Andorra Prolog - an integration of Prolog and committed choice languages', </title> <booktitle> Proceedings of the 1988 International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo, Japan, </address> <pages> pages 745-754, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: There are two reasons for this restriction. One is that these systems need dependent or stream AND- parallelism to represent concurrent communicating processes [EmLu79], and the integration of don't- know nondeterminism with dependent AND-parallelism poses some difficult implementation problems that have only recently been addressed <ref> [ClGr87, BaGr89, HaBr88, Nais88, SoRV88] </ref>. The other reason is that the connection of don't-know nondeterministic logic programs and deterministic devices presents three persistent problems. These problems involve the variables whose values are monitored by device drivers. We call these real-world-state variables, or state variables for short. 1. <p> One can write search-type don't-know nondeterministic programs in the same language that one uses to write the operating system. Committed choice languages [ClGr86, Shap84, Ueda85] do not support the former; languages based on the Andorra principle <ref> [HaBr88, BaGr89] </ref> do not support the latter. In this paper we have concentrated on global stability, but local stability is a useful concept as well.
Reference: [Hend93] <author> Fergus J. Henderson, </author> <title> Strong modes can change the world!, </title> <type> Technical Report 93/25, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: As we shall see later, the mechanisms we present in this paper also contribute to reliability by encouraging defensive programming. For further details of the mode system, including efficient algorithms for checking the mode declarations, we refer the reader to <ref> [Somo87, Hend93] </ref>. We now turn to the main subject of this paper, s tability. 2. Stability 2.1. Definitions We wish to know what conditions we should impose on don't-know nondeterministic programs that are to be connected to the outside world; we wish to know what makes such programs stable.
Reference: [HiLl91] <author> Pat M. Hill and John W. Lloyd, </author> <title> The Goedel report, </title> <type> Technical Report 91-02, </type> <institution> Department of Computer Science, University of Bristol, Bristol, </institution> <address> England, </address> <year> 1991. </year> <month> - 23 </month> - 
Reference-contexts: Our type system is based on a polymorphic many-sorted logic. It is essentially equivalent to the Mycroft-O'Keefe type system [MyKe84] and to the type system of Godel <ref> [HiLl91] </ref>. We borrow our syntax from the NU-Prolog [ThZo86] type checkers. The basic method of defining types is with declarations such as :- type bool ---&gt; true ; false. :- type list (T) ---&gt; nil ; cons (T, list (T)).
Reference: [IcMT87] <author> N. Ichiyoshi, T. Miyazaki and K. Taki, </author> <title> `A distributed implementation of at GHC on the multi-PSI', </title> <booktitle> Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <address> Melbourne, Australia, </address> <pages> pages 257-275, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: After all, with appropriate macro libraries our system should be able to recognize the stability of the relevant constructs of the at concurrent logic programming languages FCP [MTSL85] and FGHC <ref> [IcMT87] </ref> and their variants.
Reference: [KoCh88] <author> Sei-ichi Kondoh and Takashi Chikayama, </author> <title> `Macro processing in Prolog', </title> <booktitle> Proceedings of the Fifth International Conference/Symposium on Logic Programming, </booktitle> <address> Seattle, Washington, </address> <pages> pages 466-480, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Most macros will come from a standard library that contains definitions for the built-in predicates (e.g. cmp and bindingstate), but there is no reason why some cannot be defined by the user, perhaps using the mechanisms of [Chik84] and <ref> [KoCh88] </ref>. The compiler analyzes the output of these macros, so the user cannot use them to subvert the stability checks (or the type and mode checks for that matter).
Reference: [Kowa79] <author> Kowalski, R., </author> <title> Logic for problem solving, </title> <publisher> Elsevier North Holland, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Section 5 shows how program transformations can enhance stability properties. - 1 - 1.1. Forms of nondeterminism The background required for a full understanding of this paper is knowledge of the notions of don't-know and don't-care nondeterminism <ref> [Kowa79; p. 113] </ref> and of dependent or stream AND-parallelism [Greg85]. These concepts are best explained in the context of the AND/OR process model [Cone83]. This model views logic programs as being executed by a tree of alternating levels of AND and OR processes.
Reference: [Kusa86] <author> Anthony J. Kusalik, </author> <title> `Specification and initialization of a logic computer system', </title> <journal> New Generation Computing, </journal> <volume> 4:2, </volume> <pages> pages 189-209, </pages> <year> 1986. </year>
Reference-contexts: The resulting systems (e.g. SIMPOS [TYUK84]) rely on side-effects even more extensively than other Prolog programs. The second approach is based on parallel languages such as Parlog, Concurrent Prolog, GHC and their at versions as described in <ref> [ClGr84, Shap84, Kusa86, FoKu86, Fost87] </ref>. The resulting systems (e.g. PIMOS [ChSM88] and Logix [SHHS86]) communicate with the world via streams whose values are monitored by device drivers; the operating system itself can therefore be much more declarative. <p> These circumstances can best be illustrated by a query such as :- device_1 (S1), ..., device_n (Sn), operating_system (S1, ..., Sn). where the device predicates are device drivers implemented outside the logic programming system itself and the S variables are streams of commands and data <ref> [Kusa86] </ref>. In a logic operating system the devices will be terminals, disks, tapes, networks, or any of the other peripherals of a computer system [FoKu86]. In industrial and other applications they will be embedded computers controlling machinery, e.g. a phone switching system in [ArEV86].
Reference: [LlTo85] <author> J.W. Lloyd and R.W. Topor, </author> <title> `A basis for deductive database systems', </title> <journal> Journal of Logic Programming, </journal> <volume> 2:2, </volume> <pages> pages 93-109, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: Syntax, types and modes In this paper we consider queries and the bodies of predicates to be first-order formulas extended with operations such as sequential AND and guards; we call these formulas expressions (they can be translated to (possibly guarded) normal clauses through an algorithm like the one in <ref> [LlTo85] </ref>). An expression is built up by connectives from primitive expressions (predicate calls, including calls to built-in predicates). We denote the AND connective by a comma.
Reference: [Mell85] <author> C.S. Mellish, </author> <title> `Some global optimisations for a Prolog compiler', </title> <journal> Journal of Logic Programming, </journal> <volume> 2:1, </volume> <pages> pages 43-66, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: If a predicate is total in mode m, it is also total in any modes that imply m (if p (a,Y) is guaranteed to succeed, so is p (X,Y), because it has at least the solutions p (a,Y) has). The standard Prolog notion of determinacy <ref> [Mell85, Nais85b] </ref> is similar to our notion of functionality. The difference between them is nevertheless significant. The definition of determinacy relies only on implementation considerations, i.e. on whether there is a choice point left on the stack. It is not related to the program text in any clean way. <p> The first program proves that we need to be able to solve the halting problem to solve the decision problem of functionality; the second and the third do the same for monotonicity and totality. (Our first program also proves the undecidability of determinacy as defined in <ref> [Mell85, Nais85b] </ref>, a property closely related to functionality; this proof is simpler than the one in [SaTa85].) However, the undecidability of these problems need not prevent us from achieving our objective: to be able to guarantee a program's stability at compile time. <p> We could possibly make the compiler call a stability inference system (along the lines of type and mode inference systems), and accept the possibility that the inference system returns maybe as an answer. This approach is pursued in e.g. <ref> [Mell85, DRRS93] </ref>. We adopt what we feel to be a better solution: to cut the Gordian knot by requiring programmers to declare the stability properties of each mode of each predicate if they expect to use the predicate in a context that requires some aspect of stability.
Reference: [MTSL85] <author> C. Mierowsky, S. Taylor, E. Shapiro, J. Levy and S. Safra, </author> <title> The design and implementation of Flat Concurrent Prolog, </title> <institution> Research Report CS85-09, Department of Applied Mathematics, Weizmann Institute of Science, Rehovot, Israel, </institution> <month> July </month> <year> 1985. </year>
Reference-contexts: After all, with appropriate macro libraries our system should be able to recognize the stability of the relevant constructs of the at concurrent logic programming languages FCP <ref> [MTSL85] </ref> and FGHC [IcMT87] and their variants.
Reference: [MiHa88] <author> John C. Mitchell and Robert Harper, </author> <title> `The essence of ML', </title> <booktitle> Conference Record of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California, </address> <pages> pages 28-46, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: To guarantee that the above code will be stable, the compiler must know the type of P, either from a declaration supplied by the user or (preferably) by deterministic type inference as in ML <ref> [MiHa88] </ref>. 4. Stability analysis The decision problems of the functionality, monotonicity and totality properties (and hence of the three scenarios of section 1) are all unsolvable.
Reference: [MyKe84] <author> Alan Mycroft and Richard A. O'Keefe, </author> <title> `A polymorphic type system for Prolog', </title> <journal> Artificial Intelligence, </journal> <volume> vol. 23, </volume> <pages> pages 295-307, </pages> <year> 1984. </year>
Reference-contexts: In particular, w e want to be able to assign different generators to different parts of a variable, since this is essential for support of the paradigm of incomplete messages. Our type system is based on a polymorphic many-sorted logic. It is essentially equivalent to the Mycroft-O'Keefe type system <ref> [MyKe84] </ref> and to the type system of Godel [HiLl91]. We borrow our syntax from the NU-Prolog [ThZo86] type checkers. The basic method of defining types is with declarations such as :- type bool ---&gt; true ; false. :- type list (T) ---&gt; nil ; cons (T, list (T)). <p> Type systems of this nature have been the subject of much research, so we omit - 3 - a description of the type checking algorithm and refer the reader to papers describing type checking algorithms for equivalent and related type systems (see e.g. <ref> [MyKe84, Pfen92] </ref>). We consider the mode of a predicate to be a mapping from the initial state of instantiation of the arguments of the predicate to their final state of instantiation. To describe states of instantiation, we use information provided by the type system.
Reference: [Nais85a] <author> Lee Naish, </author> <title> `All solutions predicates in Prolog', </title> <booktitle> Proceedings of the Second IEEE Symposium on Logic Programming, </booktitle> <address> Boston, Massachusetts, </address> <pages> pages 73-77, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: set_of; variables that occur outside e must be either input to e or appear in T. set_of should be total; even if e has no solutions, set_of should have one, with S being the empty set. (Unfortunately, in most implementations of Prolog the all-solutions predicate fails when e itself fails <ref> [Nais85a] </ref>.) If S is represented as a list, the programmer can look inside it, and therefore it must be sorted if set_of is to be functional [Nais85a]. We can easily make set_of monotonic as well: we just wait until we have all the solutions before we bind S. <p> set_of should have one, with S being the empty set. (Unfortunately, in most implementations of Prolog the all-solutions predicate fails when e itself fails <ref> [Nais85a] </ref>.) If S is represented as a list, the programmer can look inside it, and therefore it must be sorted if set_of is to be functional [Nais85a]. We can easily make set_of monotonic as well: we just wait until we have all the solutions before we bind S. It may be useful, though, to make parts of S available before the computation of set_of terminates.
Reference: [Nais85b] <author> Lee Naish, </author> <title> `Automating control of logic programs', </title> <journal> Journal of Logic Programming, </journal> <volume> 2:3, </volume> <pages> pages 167-183, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: If a predicate is total in mode m, it is also total in any modes that imply m (if p (a,Y) is guaranteed to succeed, so is p (X,Y), because it has at least the solutions p (a,Y) has). The standard Prolog notion of determinacy <ref> [Mell85, Nais85b] </ref> is similar to our notion of functionality. The difference between them is nevertheless significant. The definition of determinacy relies only on implementation considerations, i.e. on whether there is a choice point left on the stack. It is not related to the program text in any clean way. <p> The first program proves that we need to be able to solve the halting problem to solve the decision problem of functionality; the second and the third do the same for monotonicity and totality. (Our first program also proves the undecidability of determinacy as defined in <ref> [Mell85, Nais85b] </ref>, a property closely related to functionality; this proof is simpler than the one in [SaTa85].) However, the undecidability of these problems need not prevent us from achieving our objective: to be able to guarantee a program's stability at compile time.
Reference: [Nais88] <author> Lee Naish, </author> <title> `Parallelizing NU-Prolog', </title> <booktitle> Proceedings of the Fifth International Conference/Symposium on Logic Programming, </booktitle> <address> Seattle, Washington, </address> <pages> pages 1546-1564, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: There are two reasons for this restriction. One is that these systems need dependent or stream AND- parallelism to represent concurrent communicating processes [EmLu79], and the integration of don't- know nondeterminism with dependent AND-parallelism poses some difficult implementation problems that have only recently been addressed <ref> [ClGr87, BaGr89, HaBr88, Nais88, SoRV88] </ref>. The other reason is that the connection of don't-know nondeterministic logic programs and deterministic devices presents three persistent problems. These problems involve the variables whose values are monitored by device drivers. We call these real-world-state variables, or state variables for short. 1. <p> In this it is similar to the notion of functionality as defined in [DeWa86] and to the notion of logically deterministic predicates as defined in [Naka86]. The definition of binding determinacy in <ref> [Nais88] </ref> is roughly equivalent to the combination of our functionality and monotonicity: in PNU-Prolog, the syntactic sugar of lazyDet and eagerDet declarations hides the non-logical primitives used to implement them.
Reference: [Naka86] <author> Katsuhiko Nakamura, </author> <title> `Control of logic program execution based on the functional relations', </title> <booktitle> Proceedings of the Third International Conference on Logic Programming, </booktitle> <address> London, England, </address> <pages> pages 505-512, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: In this it is similar to the notion of functionality as defined in [DeWa86] and to the notion of logically deterministic predicates as defined in <ref> [Naka86] </ref>. The definition of binding determinacy in [Nais88] is roughly equivalent to the combination of our functionality and monotonicity: in PNU-Prolog, the syntactic sugar of lazyDet and eagerDet declarations hides the non-logical primitives used to implement them.
Reference: [Nich88] <author> A.E. Nicholson, </author> <booktitle> `Declarative debugging of the parallel logic programming language GHC', Proceedings of the Eleventh Australian Computer Science Conference, </booktitle> <address> Brisbane, Australia, </address> <pages> pages 225-236, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: For conditional expressions, this history can be reconstructed at any time. For guard expressions, traces must be stored, since otherwise there is no guarantee that a second execution of a guard construct would have the same effect as the first <ref> [Nich88] </ref>. A compiler analysis proving that the guards of a predicate are mutually exclusive can reduce the volume of these traces, but such analysis can be difficult to perform without the help of a strong mode system. 4.4.
Reference: [Pfen92] <author> Frank Pfenning, ed., </author> <title> Types in logic programming, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: Type systems of this nature have been the subject of much research, so we omit - 3 - a description of the type checking algorithm and refer the reader to papers describing type checking algorithms for equivalent and related type systems (see e.g. <ref> [MyKe84, Pfen92] </ref>). We consider the mode of a predicate to be a mapping from the initial state of instantiation of the arguments of the predicate to their final state of instantiation. To describe states of instantiation, we use information provided by the type system.
Reference: [SaTa85] <author> Hajime Sawamura and Taku Takeshima, </author> <title> `Recursive unsolvability of determinacy, solvable cases of determinacy and their applications to Prolog optimization', </title> <booktitle> Proceedings of the Second IEEE Symposium on Logic Programming, </booktitle> <address> Boston, Massachusetts, </address> <pages> pages 200-207, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: It is not related to the program text in any clean way. From the text itself, a predicate in (standard) Prolog can be called determinate only if it has cuts in all of its clauses, except possibly the last one <ref> [SaTa85] </ref>. Functionality is a cleaner concept in that it does not rely on non-logical primitives. When a functional predicate succeeds, we know that the remaining clauses (if any) cannot contribute to another success; we can therefore discard any remaining choice-points. <p> the halting problem to solve the decision problem of functionality; the second and the third do the same for monotonicity and totality. (Our first program also proves the undecidability of determinacy as defined in [Mell85, Nais85b], a property closely related to functionality; this proof is simpler than the one in <ref> [SaTa85] </ref>.) However, the undecidability of these problems need not prevent us from achieving our objective: to be able to guarantee a program's stability at compile time.
Reference: [Shap84] <author> Ehud Shapiro, </author> <title> `Systems programming in Concurrent Prolog', </title> <booktitle> Conference Record of the Eleventh ACM Symposium on Principles of Programming Languages, </booktitle> <address> Salt Lake City, Utah, </address> <pages> pages 93-105, </pages> <month> January </month> <year> 1984. </year> <month> - 24 </month> - 
Reference-contexts: The resulting systems (e.g. SIMPOS [TYUK84]) rely on side-effects even more extensively than other Prolog programs. The second approach is based on parallel languages such as Parlog, Concurrent Prolog, GHC and their at versions as described in <ref> [ClGr84, Shap84, Kusa86, FoKu86, Fost87] </ref>. The resulting systems (e.g. PIMOS [ChSM88] and Logix [SHHS86]) communicate with the world via streams whose values are monitored by device drivers; the operating system itself can therefore be much more declarative. <p> One can write search-type don't-know nondeterministic programs in the same language that one uses to write the operating system. Committed choice languages <ref> [ClGr86, Shap84, Ueda85] </ref> do not support the former; languages based on the Andorra principle [HaBr88, BaGr89] do not support the latter. In this paper we have concentrated on global stability, but local stability is a useful concept as well.
Reference: [SHHS86] <author> W. Silverman, M. Hirsch, A. Houri and E.Y. Shapiro, </author> <title> The Logix system user manual, </title> <note> version 1.2, Research Report CS86-21, </note> <institution> Department of Applied Mathematics, Weizmann Institute of Science, Rehovot, Israel, </institution> <year> 1986. </year>
Reference-contexts: SIMPOS [TYUK84]) rely on side-effects even more extensively than other Prolog programs. The second approach is based on parallel languages such as Parlog, Concurrent Prolog, GHC and their at versions as described in [ClGr84, Shap84, Kusa86, FoKu86, Fost87]. The resulting systems (e.g. PIMOS [ChSM88] and Logix <ref> [SHHS86] </ref>) communicate with the world via streams whose values are monitored by device drivers; the operating system itself can therefore be much more declarative.
Reference: [Smol84] <author> Gert Smolka, </author> <title> `Making control and data ow in logic programs explicit', </title> <booktitle> Conference Record of the ACM Symposium on LISP and Functional Programming, </booktitle> <address> Austin, Texas, </address> <pages> pages 311-322, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: The notion of unconditional variable binding in Reform-Prolog [BeLM93] is equivalent to binding determinacy, and is used for a similar purpose. Our notion of functionality differs from the one in <ref> [Smol84] </ref>. In Smolka's system, a predicate declared to be functional may in fact have multiple solutions, but all solutions following the first will be discarded. <p> The second of these effects can be avoided by writing - g1 [] b1 - or ... or - gn [] bn -; the first cannot. To get the second effect without the first, a construct like Smolka's exit clauses is necessary <ref> [Smol84] </ref>, though in principle it could be emulated using a primitive like set_of (see below). GHC [Ueda85] allows a body to start executing before its alternative is selected for commitment, subject to the condition that it should not instantiate the parent environment before commitment.
Reference: [Somo87] <author> Zoltan Somogyi, </author> <title> `A system of precise modes for logic programs', </title> <booktitle> Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <address> Melbourne, Australia, </address> <pages> pages 769-787, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: The children of an or-node are the function symbols that can be used to construct terms of that type; the children of an and-node are the types of the arguments of the function symbol. Following <ref> [Somo87] </ref>, we attach mode information to the or-nodes type trees. Definition: An instantiatedness tree is an assignment of an instantiatedness either free or bound to each or-node of a type tree. <p> As we shall see later, the mechanisms we present in this paper also contribute to reliability by encouraging defensive programming. For further details of the mode system, including efficient algorithms for checking the mode declarations, we refer the reader to <ref> [Somo87, Hend93] </ref>. We now turn to the main subject of this paper, s tability. 2. Stability 2.1. Definitions We wish to know what conditions we should impose on don't-know nondeterministic programs that are to be connected to the outside world; we wish to know what makes such programs stable.
Reference: [SoHe93] <author> Zoltan Somogyi and Fergus J. Henderson, </author> <title> Fast implementation of strongly moded logic programs, </title> <type> Technical Report 93/27, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: We then present a mechanism that can prove at compile time and for all possible input data the correctness of these stability declarations. This mechanism is also useful in program optimization. In a companion paper <ref> [SoHe93] </ref> we have shown how the stable parts of strongly moded programs can be compiled into code that is as fast as the code generated for a program handwritten in an imperative language such as C; with our implementation the naive reverse benchmark reaches almost 4 Megalips on a SPARCstation 2. <p> Just as global stability enables us to update the real world destructively (the only way it can be updated), local stability enables us to do the same for computational data structures. As we have demonstrated in another paper <ref> [SoHe93] </ref>, we can use stability analysis to help us compile predicates into imperative code that is as efficient as as imperative programmers would code by hand.
Reference: [SKHR93] <author> Zoltan Somogyi, David Kemp, James Harland and Kotagiri Ramamohanarao, </author> <title> Subsumption- free bottom-up evaluation of logic programs with partially instantiated data structures, </title> <type> Technical Report 93/26, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: This second property implies that if two solutions are unifiable, they must be identical. (This property is proven in <ref> [SKHR93] </ref>). 4.6. Metacall expressions In Prolog, metacall refers to a goal call (e) that acts (or at least aims to act) as if the program text read just e, but with the difference that e may be supplied at run-time.
Reference: [SoRV88] <author> Zoltan Somogyi, Kotagiri Ramamohanarao and Jayen Vaghani, </author> <title> `A backtracking algorithm for the stream AND-parallel execution of logic programs', </title> <journal> International Journal of Parallel Programming, </journal> <volume> 17:3, </volume> <pages> pages 207-257, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: There are two reasons for this restriction. One is that these systems need dependent or stream AND- parallelism to represent concurrent communicating processes [EmLu79], and the integration of don't- know nondeterminism with dependent AND-parallelism poses some difficult implementation problems that have only recently been addressed <ref> [ClGr87, BaGr89, HaBr88, Nais88, SoRV88] </ref>. The other reason is that the connection of don't-know nondeterministic logic programs and deterministic devices presents three persistent problems. These problems involve the variables whose values are monitored by device drivers. We call these real-world-state variables, or state variables for short. 1.
Reference: [TYUK84] <author> Shigeyuki Takagi, Toshio Yokoi, Shunichi Uchida, Toshiaki Kuorkawa, Takashi Hattori, Takashi Chikayama, Ko Sakai and Junichuro Tsuji, </author> <title> `Overall design of SIMPOS', </title> <booktitle> Proceedings of the Second International Logic Programming Conference, </booktitle> <address> Uppsala, Sweden, </address> <pages> pages 1-12, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: 1. Introduction Research in operating systems for logic machines has so far concentrated on two approaches. One is based on versions of Prolog enhanced with the necessary primitives for process handling and interfacing to the hardware. The resulting systems (e.g. SIMPOS <ref> [TYUK84] </ref>) rely on side-effects even more extensively than other Prolog programs. The second approach is based on parallel languages such as Parlog, Concurrent Prolog, GHC and their at versions as described in [ClGr84, Shap84, Kusa86, FoKu86, Fost87]. The resulting systems (e.g.
Reference: [ThZo86] <author> James Thom, Justin Zobel, eds., </author> <title> NU-Prolog reference manual, version 1.0, </title> <type> Technical Report 86/10, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1986. </year>
Reference-contexts: Our type system is based on a polymorphic many-sorted logic. It is essentially equivalent to the Mycroft-O'Keefe type system [MyKe84] and to the type system of Godel [HiLl91]. We borrow our syntax from the NU-Prolog <ref> [ThZo86] </ref> type checkers. The basic method of defining types is with declarations such as :- type bool ---&gt; true ; false. :- type list (T) ---&gt; nil ; cons (T, list (T)).
Reference: [Ueda85] <author> Kazunori Ueda, </author> <title> `Guarded Horn Clauses', </title> <booktitle> Proceedings of the Fourth Logic Programming Conference, </booktitle> <address> Tokyo, Japan, </address> <pages> pages 168-179, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: To get the second effect without the first, a construct like Smolka's exit clauses is necessary [Smol84], though in principle it could be emulated using a primitive like set_of (see below). GHC <ref> [Ueda85] </ref> allows a body to start executing before its alternative is selected for commitment, subject to the condition that it should not instantiate the parent environment before commitment. If the corresponding guard fails, or another alternative succeeds in committing first, the time and resources spent on this body are wasted. <p> One can write search-type don't-know nondeterministic programs in the same language that one uses to write the operating system. Committed choice languages <ref> [ClGr86, Shap84, Ueda85] </ref> do not support the former; languages based on the Andorra principle [HaBr88, BaGr89] do not support the latter. In this paper we have concentrated on global stability, but local stability is a useful concept as well.
Reference: [YaAi86] <author> Rong Yang and Hideo Aiso, `P-Prolog: </author> <title> a parallel language based on exclusive relation', </title> <booktitle> Proceedings of the Third International Conference on Logic Programming, </booktitle> <address> London, England, </address> <pages> pages 255-269, </pages> <month> July </month> <year> 1986. </year> <month> - 25 </month> - 
Reference-contexts: This is the case in the example of section 3. Conditional expressions bear a syntactic resemblance to sets of guarded commands, though semantically they are closer to if and case statements. (They also have the same effect as the all- single-neck predicates of P-Prolog <ref> [YaAi86] </ref>, although the underlying mechanisms have almost nothing in common.) Unlike guards, they do not involve don't-care nondeterminism. Their semantics can therefore be much cleaner; programmers should use them instead of guards whenever possible.
References-found: 46

