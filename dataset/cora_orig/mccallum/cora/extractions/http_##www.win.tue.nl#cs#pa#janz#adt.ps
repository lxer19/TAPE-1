URL: http://www.win.tue.nl/cs/pa/janz/adt.ps
Refering-URL: http://www.win.tue.nl/cs/pa/janz/publications.html
Root-URL: http://www.win.tue.nl
Email: 1 E.Poll@ukc.ac.uk  janz@win.tue.nl  
Phone: 2  
Title: A Logic for Abstract Data Types as Existential Types  
Author: Erik Poll and Jan Zwanenburg 
Note: c Springer-Verlag  
Address: England  Netherlands  
Affiliation: Computing Lab, University of Kent at Canterbury,  Eindhoven University of Technology, The  
Abstract: The second-order lambda calculus allows an elegant formal-isation of abstract data types (ADT's) using existential types. Plotkin and Abadi's logic for parametricity [PA93] then provides the useful proof principle of simulation for ADT's, which can be used to show equivalence of data representations. However, we show that this logic is not sufficient for reasoning about specifications of ADT's, and we present an extension of the logic that does provide the proof principles for ADT's that we want. 
Abstract-found: 1
Intro-found: 1
Reference: [Bar92] <author> H.P. Barendregt. </author> <title> Lambda calculi with types. In D.M. </title> <editor> Gabbai, S. Abram-sky, and T.S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 1. </volume> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: Leibniz' equality will be written infix. Other relations will sometimes also be written infix, and sometimes "postfix", i.e. (t 1 ; t 2 ) 2 P for P t 1 t 2 . ut Remark 1. For readers familiar with Pure Type Systems (PTS's) <ref> [Bar92] </ref>, we note that the logic L of Takeuti can be concisely described as a PTS, namely the PTS (S; A; R) with S = ffl s ; 2 s ; fl p ; 2 p g, A = f (fl s : 2 s ) ; (fl p : 2
Reference: [BFSS90] <author> E.S. Bainbridge, P.J. Freyd, A. Scedrov, and P.J. Scott. </author> <title> Functorial poly-morphism. </title> <journal> Theoretical Computer Science, </journal> <volume> 70(1) </volume> <pages> 35-64, </pages> <year> 1990. </year>
Reference-contexts: = Q (inj r 0 ) ^ (opsX; opsQ) 2 A (r:X; q:Q: q = Q (inj r)) for all type expressions A (X) built using ! and fi from X and closed type expressions. ut The same PER model used in [PA93] as a semantics for their logic, viz. <ref> [BFSS90] </ref>, quite trivially justifies these additional axioms. Indeed, in a PER model all types are "quotient types"! Theorem 4. In the logic ParQuot it can be proved that 8imp : BagImp: WeakSpec 9 (imp) ) Spec 9 (imp): Proof. Assume that WeakSpec 9 (imp) holds.
Reference: [BG96] <author> G. Barthe and J.H. </author> <title> Geuvers. Congruence types. </title> <booktitle> In CSL'95, volume 1092 of Lecture Notes in Computer Science, </booktitle> <pages> pages 36-51. </pages> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: Quotient types are available in some type theories, e.g. Nuprl [Con86], and have been proposed as extensions of other type theories, see e.g. [Hof95] <ref> [BG96] </ref>. We will first give the general idea of how quotient types could be used to prove the property above. Suppose WeakSpec 9 (imp), i.e. GenSpec (Rep; ops; ) ^ (ops; ops) 2 BagSig () ^ Equiv () for some pack hRep; opsi = BagImp imp and some .
Reference: [Con86] <editor> R.L. Constable et al. </editor> <title> Implementing Mathematics in the Nuprl proof development system. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Intuitively the property (fl) seems OK. (Indeed, it is true in the PER model.) It turns out that if we have quotient types then (fl) could be proved. Quotient types are available in some type theories, e.g. Nuprl <ref> [Con86] </ref>, and have been proposed as extensions of other type theories, see e.g. [Hof95] [BG96]. We will first give the general idea of how quotient types could be used to prove the property above. Suppose WeakSpec 9 (imp), i.e.
Reference: [CP90] <author> Thierry Coquand and Christine Paulin. </author> <title> Inductively Defined Types. </title> <editor> In P. Martin-Lof and G. Mints, editors, </editor> <booktitle> COLOG-88, volume 417 of Lecture Notes in Computer Science, </booktitle> <pages> pages 50-66. </pages> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: In fact, this would be inconsistent with parametricity, following the example given in Remark 3.) Remark 2. It is tempting to extend the "open as h i in " construction that we have for programs to predicates, c.f. the inductive types proposed in <ref> [CP90] </ref>. This so-called "strong" elimination principle is included in Coq [PM93].
Reference: [GM93] <author> M. J. Gordon and T. F. Melham. </author> <title> Introduction to HOL. </title> <address> Cambridge, </address> <year> 1993. </year>
Reference: [Hof95] <author> Martin Hofmann. </author> <title> A simple model for quotient types. </title> <booktitle> In TLCA'95, volume 902 of Lecture Notes in Computer Science, </booktitle> <pages> pages 216-234, </pages> <year> 1995. </year>
Reference-contexts: Quotient types are available in some type theories, e.g. Nuprl [Con86], and have been proposed as extensions of other type theories, see e.g. <ref> [Hof95] </ref> [BG96]. We will first give the general idea of how quotient types could be used to prove the property above. Suppose WeakSpec 9 (imp), i.e. GenSpec (Rep; ops; ) ^ (ops; ops) 2 BagSig () ^ Equiv () for some pack hRep; opsi = BagImp imp and some .
Reference: [Mit91] <author> John C. Mitchell. </author> <title> On the equivalence of data representations. </title> <booktitle> In Artificial Intelligence and Mathematical Theory of Computation, </booktitle> <pages> pages 305-330. </pages> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: This description of ADT's provides a useful basis to investigate properties of ADT's. In particular, it has been successfully used to investigate a notion of equivalence of implementations of ADT's. <ref> [Mit91] </ref> considers a semantic notion of equivalence of data representations, which suggests a method for proving the equivalence of data representations, namely by showing that there exists a simulation relation between the representations. We will refer to this proof principle as simulation. <p> Plotkin and Abadi's logic for parametricity [PA93] is a logic for reasoning about the second order lambda calculus (system F). It formalises the notion of para-metricity, and for the existential types this logic does indeed provide the proof principle of simulation envisaged in <ref> [Mit91] </ref>. Unfortunately, it turns out that this proof principle of simulation for existential types is not enough for reasoning about specifications of ADT's, in particular specifications that use equality. <p> To prove that such an implementation of bags satisfies an equational specification we may therefore use permutation of lists as the notion of equality. This principle of abstraction is a well-known reasoning principle for ADT's. Parametricity provides the proof principle of simulation for existential types <ref> [Mit91] </ref> [PA93]. This is a useful proof principle if existential types are used for abstract data types: it provides a method to prove that different implementations of an ADT are equivalent, namely by showing that there exists a simulation relation between them.
Reference: [MP88] <author> John C. Mitchell and Gordon D. Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Trans. on Prog. Lang. and Syst., </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction The second-order lambda calculus allows an elegant formalisation of abstract data types (ADT's), as shown in <ref> [MP88] </ref>, using existential types. This description of ADT's provides a useful basis to investigate properties of ADT's. <p> Finally, we will sometimes use a "pattern-matching" style notation for tuples, e.g. writing (y; z):A fi B: c instead of x:A fi B: c [x:1=y; x:2=z]. Abstract Data Types as Existential Types Existential types allow an elegant formalisation of abstract data types (ADT's), as shown in <ref> [MP88] </ref>. This formalisation provides a clean separation between using an ADT on the one hand and implementing an ADT on the other hand. <p> equality of implementations of ADT's just like we can talk about equality of other values. (This will be useful later, in Section 3, when we consider proof rules for ADT's.) The remainder of this section briefly explains the use of existential types for ADT's (for a more extensive discussion see <ref> [MP88] </ref>), and introduces our running example of bags.
Reference: [PA93] <author> Gordon Plotkin and Martin Abadi. </author> <title> A logic for parametric polymorphism. </title> <booktitle> In TLCA'93, volume 664 of Lecture Notes in Computer Science, </booktitle> <pages> pages 361-375, </pages> <year> 1993. </year>
Reference-contexts: We will refer to this proof principle as simulation. Plotkin and Abadi's logic for parametricity <ref> [PA93] </ref> is a logic for reasoning about the second order lambda calculus (system F). It formalises the notion of para-metricity, and for the existential types this logic does indeed provide the proof principle of simulation envisaged in [Mit91]. <p> Unfortunately, it turns out that this proof principle of simulation for existential types is not enough for reasoning about specifications of ADT's, in particular specifications that use equality. We propose an extension of the logic of <ref> [PA93] </ref> (with axioms stating the existence of quotients, to be precise) that does provide all the proof principles one would like for reasoning about ADT's. The same PER model used in [PA93] as a semantics for their logic immediately justifies these additional axioms. (Indeed, in the PER model all types are <p> We propose an extension of the logic of <ref> [PA93] </ref> (with axioms stating the existence of quotients, to be precise) that does provide all the proof principles one would like for reasoning about ADT's. The same PER model used in [PA93] as a semantics for their logic immediately justifies these additional axioms. (Indeed, in the PER model all types are "quotient types".) The remainder of this introduction discusses one of the proof principles we want for ADT's. <p> In particular, here one would want to be able to prove that (ii) implies (i). We will refer to a proof principle that would allow us to deduce (i) from (ii) as abstraction. The logic for parametricity of <ref> [PA93] </ref> does not quite provide this proof principle of abstraction for arbitrary ADT's and specifications. <p> But extending the logic with axioms stating the existence of quotients solves this problem: we will show that then the proof principle of abstraction can be obtained from the proof principle of simulation, which is provided by the logic for parametricity of <ref> [PA93] </ref>. (For this particular example, we would want the existence of lists quotiented by perm .) The organisation of this paper is as follows. Section 2 defines our notation for the second-order lambda calculus and gives a quick recap on how existential types can be used for ADT's. <p> Section 2 defines our notation for the second-order lambda calculus and gives a quick recap on how existential types can be used for ADT's. Section 3 discusses the logic for parametricity of [Tak97], which is a slightly different formulation of the logic as first introduced in <ref> [PA93] </ref>; in particular, we discuss the proof principle of simulation for proving equivalence of data representations that this logic provides. Section 4 then considers a simple example of a specification of an ADT for bags and illustrates the problem with reasoning about ADT's hinted at above. <p> The program b has to be typed under the assumptions that empty : Bag; add : Nat fi Bag ! Bag; card : Nat fi Bag ! Nat; where Bag is a type variable. 3 The logic for parametricity Plotkin and Ababi's logic for parametric polymorphism <ref> [PA93] </ref> is a logic for reasoning about the second-order lambda calculus that exploits the notion of parametricity. We will use the somewhat different presentation of the logic given by Takeuti [Tak97]. We only describe the fragment of the logic that is of interest to us. <p> 0 :X: r r 0 () (inj r) = Q (inj r 0 ) ^ (opsX; opsQ) 2 A (r:X; q:Q: q = Q (inj r)) for all type expressions A (X) built using ! and fi from X and closed type expressions. ut The same PER model used in <ref> [PA93] </ref> as a semantics for their logic, viz. [BFSS90], quite trivially justifies these additional axioms. Indeed, in a PER model all types are "quotient types"! Theorem 4. In the logic ParQuot it can be proved that 8imp : BagImp: WeakSpec 9 (imp) ) Spec 9 (imp): Proof. <p> using some relation (similar to WeakSpec 9 ) and the strong version using Leibniz' equality (similar to Spec 9 ) can be related in exactly the same way as in the theorem above. 6 Conclusion In this paper we have explored the gap between the formal notion of parametric-ity of <ref> [PA93] </ref> and the important "folk" reasoning principle about ADT's, which we have called abstraction. Roughly, this principle of abstraction says that elements of the concrete representation type of an ADT can be considered equal if they are not distinguishable using the ADT-operations. <p> To prove that such an implementation of bags satisfies an equational specification we may therefore use permutation of lists as the notion of equality. This principle of abstraction is a well-known reasoning principle for ADT's. Parametricity provides the proof principle of simulation for existential types [Mit91] <ref> [PA93] </ref>. This is a useful proof principle if existential types are used for abstract data types: it provides a method to prove that different implementations of an ADT are equivalent, namely by showing that there exists a simulation relation between them. <p> However, we have shown that this principle of simulation alone is not enough to reason about ADT's, since in general it does not provide the proof principle of abstraction that we want. This observation is new, as far as we know. However, extending the logic for parametricity of <ref> [PA93] </ref> with axioms stating the existence of quotients is enough to solve this problem. Like the original logic for parametricity of [PA93] these additional axioms can be justified by a PER model. <p> This observation is new, as far as we know. However, extending the logic for parametricity of <ref> [PA93] </ref> with axioms stating the existence of quotients is enough to solve this problem. Like the original logic for parametricity of [PA93] these additional axioms can be justified by a PER model. Proofs for the example of the specification for bags have all been verified using the interactive theorem prover Yarrow [Zwa97].
Reference: [PM93] <author> Christine Paulin-Mohring. </author> <title> Inductive definitions in the system Coq. </title> <booktitle> In TLCA'93, volume 664 of Lecture Notes in Computer Science, </booktitle> <pages> pages 328-345. </pages> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: It is tempting to extend the "open as h i in " construction that we have for programs to predicates, c.f. the inductive types proposed in [CP90]. This so-called "strong" elimination principle is included in Coq <ref> [PM93] </ref>.
Reference: [Pol94] <author> Erik Poll. </author> <title> A Programming Logic based on Type Theory. </title> <type> PhD thesis, </type> <institution> Technische Universiteit Eindhoven, </institution> <year> 1994. </year>
Reference-contexts: L is a subsystem of the logic ! L introduced in <ref> [Pol94] </ref> as a logic for reasoning about the higher-order typed lambda calculus (system F ! ). ! L includes a few more PTS rules, so that it includes the higher-order rather than the second order lambda calculus as "programming language" and allows more powerful abstractions in the logic (such as polymorphic
Reference: [Tak97] <author> Izumi Takeuti. </author> <title> An axiomatic system of parametricity. </title> <booktitle> In TLCA'97, volume 1130 of Lecture Notes in Computer Science, </booktitle> <pages> pages 354-372, </pages> <year> 1997. </year>
Reference-contexts: Section 2 defines our notation for the second-order lambda calculus and gives a quick recap on how existential types can be used for ADT's. Section 3 discusses the logic for parametricity of <ref> [Tak97] </ref>, which is a slightly different formulation of the logic as first introduced in [PA93]; in particular, we discuss the proof principle of simulation for proving equivalence of data representations that this logic provides. <p> We will use the somewhat different presentation of the logic given by Takeuti <ref> [Tak97] </ref>. We only describe the fragment of the logic that is of interest to us. <p> We have the standard structural rules, and the standard elimination and introduction for the logical connective ) and the quantifiers 8 (for details see <ref> [Tak97] </ref>). The second-order universal quantification over propositions and predicates enables the definition of the logical connectives _, ^ and 9 in the usual way. It also enables Leibniz' equality for datatypes T to be defined in the standard way: Definition 1 (Leibniz' equality).
Reference: [Zwa97] <author> Jan Zwanenburg. </author> <title> The proof assistant Yarrow. </title> <note> Submitted for publication. See also http://www.win.tue.nl/cs/pa/janz/yarrow/, 1997. </note>
Reference-contexts: The fact that L is a PTS is the main reason why we chose Takeuti's presentation of the logic rather than Plotkin & Abadi's; it enabled us to verify some examples using the theorem prover Yarrow <ref> [Zwa97] </ref> which implements arbitrary PTS's. <p> Like the original logic for parametricity of [PA93] these additional axioms can be justified by a PER model. Proofs for the example of the specification for bags have all been verified using the interactive theorem prover Yarrow <ref> [Zwa97] </ref>. Indeed, it was only in the course of formalising specifications for ADT's in Yarrow that we noticed that more was needed than just the proof principle of simulation to reason about specifications of ADT's.
References-found: 14

