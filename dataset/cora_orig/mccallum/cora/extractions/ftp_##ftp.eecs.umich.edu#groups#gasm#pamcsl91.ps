URL: ftp://ftp.eecs.umich.edu/groups/gasm/pamcsl91.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: beierle@ds;lilog.bitnet boerger@dipisa.di.unipi.it  
Title: Correctness proof for the WAM with types  
Author: Christoph Beierle Egon Borger E. Borger, G. Jager, H. Kleine Buning, and M. Richter (eds): 
Note: To appear in:  Logic CSL'91. Lecture Notes in Com puter Science, Springer-Verlag, Berlin, 1992.  
Address: P.O. Box 80 08 80 Corso Italia 40 D-7000 Stuttgart 80, Germany I-56100 Pisa, Italia  
Affiliation: IBM Germany, Scientific Center Dipartimento di Informatica Inst. for Knowledge Based Systems Universita di Pisa  Computer Science  
Abstract: We provide a mathematical specification of an extension of Warren's Abstract Machine for executing Prolog to type-constraint logic programming and prove its correctness. In this paper, we keep the notion of types and dynamic type constraints rather abstract to allow applications to different constraint formalisms like Prolog III or CLP(R). This generality permits us to introduce modular extensions of Borger's and Ro-senzweig's formal derivation of the WAM. Starting from type-constraint Prolog algebras that are derived from Borger's standard Prolog algebras, the specification of the type-constraint WAM extension is given by a sequence of evolving algebras, each representing a refinement level. For each refinement step a correctness proof is given. Thus, we obtain the theorem that for every such abstract type-constraint logic programming system L and for every compiler satisfying the specified conditions, the WAM extension with an abstract notion of types is correct w.r.t. L. This is a first step towards our aim to provide a full specification and correctness proof of a concrete system, the PROTOS Abstract Machine (PAM), an extension of the WAM by polymorphic order-sorted unification as required by the logic programming language PROTOS-L. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. At-Kaci. </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: ([11]) has not only been used for the description of the (operational) semantics of various programming languages (Modula-2, Occam, Prolog, Prolog III, Smalltalk, Parlog, C; see [10]), but also for the description and analysis of implementation methods: Borger and Rosenzweig ([7,8]) provide a mathematical elaboration of Warren's Abstract Machine ([16], <ref> [1] </ref>) for executing Prolog. The description consists of several refinement levels together with correctness proofs, and a correctness proof w.r.t. Borger's phenomenological Prolog description ([5,6]). <p> if unbound (l) type-prefix (deref (l)) if tag (l) = REF P1 [ . . . [ Pn if tag (l) = STRUC and n = arity (val (ref (l))) Pi = type-prefix (ref (l)+i) 4.2 Unification Unification in the PAM can be carried out as in the WAM (see <ref> [1] </ref>) if we refine the bind operation into one that takes into account also the type constraints of the variables ([4]). The bind operation may thus also fail and initiate backtracking if the type constraints are not satisfied. <p> on the Propagation Condition when binding a variable to a non-variable term (Bind-3). 22 6 Additional WAM optimizations in the PAM 6.1 Environment Trimming and Last Call Optimization Environment trimming and last call optimization (LCO) are among the most important optimizations in the WAM; for a discussion we refer to <ref> [1] </ref> and [8]. The necessary ARGUMENT REGISTERS PROPERTY as formulated in [8] can be ensured by the compiler by generating a put unsafe value (yn, xj) instruction instead of put value (yn, xj) for each unsafe occurrence of Yn. <p> [4] for variables with monomorphic, polymorphic, or with no type restriction are introduced as an optimization in [3].) Both temporary and permanent variables can be initialized "on the fly"; for a discussion of the classification of variables into temporary and permanent ones which was introduced by [16] we refer to <ref> [1] </ref> and [8].
Reference: [2] <author> C. Beierle. </author> <title> Types, modules and databases in the logic programming language PROTOS-L. </title> <editor> In K. H. Blasius, U. Hedtstuck, and C.-R. Rollinger, editors, </editor> <booktitle> Sorts and Types for Artificial Intelligence. </booktitle> <publisher> LNAI 418, Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1990. </year>
Reference: [3] <author> C. Beierle and E. Borger. </author> <title> A WAM extension for type-constraint logic programming: Specification and correctness proof. </title> <type> IWBS Report, </type> <institution> IBM Germany, Scientific Center, Inst. for Knowledge Based Systems, Stuttgart, </institution> <year> 1991. </year>
Reference-contexts: The notions of type constraint and constraint solving have been kept abstract through all refinement levels so far; thus, the development carried out in this paper applies to any type system satisfying the given abstract conditions. The introduction of PROTOS-L specific type constraint representation is carried out in <ref> [3] </ref>. To keep this paper within reasonable limits, we definitely suppose that the reader is familiar with [6] and [7,8] to which we will refer for many definitions and notations, including those concerning evolving algebras. <p> The natural modularity of our approach will come out from presenting in this paper only those extensions and refinements which are needed in the presence of types. Due to severe space restrictions, examples could not be included in this paper; we refer the reader to <ref> [3] </ref>. 2 PROTOS-L Algebras 2.1 Universes and Functions The basic universes and functions in PROTOS-L algebras can be taken directly from the standard Prolog algebras ([5], [6]). <p> However, as explained in [4], the first occurrence of a variable in a PROTOS-L clause is sufficient to consider the statically available type restriction. (The specialized instructions of [4] for variables with monomorphic, polymorphic, or with no type restriction are introduced as an optimization in <ref> [3] </ref>.) Both temporary and permanent variables can be initialized "on the fly"; for a discussion of the classification of variables into temporary and permanent ones which was introduced by [16] we refer to [1] and [8]. <p> L. Thus, any type system satisfying the minimal preconditions on the inf and solution functions stated in Section 2 is covered by the development above. In <ref> [3] </ref> the universe TYPETERM together with its functions is refined in several levels. Furthermore, [3] also deals with some PAM specific optimizations, namely a switch on typed variables and a special representation of typed variables. <p> L. Thus, any type system satisfying the minimal preconditions on the inf and solution functions stated in Section 2 is covered by the development above. In <ref> [3] </ref> the universe TYPETERM together with its functions is refined in several levels. Furthermore, [3] also deals with some PAM specific optimizations, namely a switch on typed variables and a special representation of typed variables.
Reference: [4] <author> C. Beierle, G. Meyer, and H. Semle. </author> <title> Extending the Warren Abstract Machine to polymorphic order-sorted resolution. </title> <editor> In V. Saraswat and K. Ueda, editors, </editor> <booktitle> Logic Programming: Proceedings of the 1991 International Symposium, </booktitle> <pages> pages 272-286, </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: PROTOS-L ([2]) is a logic programming language that has a polymorphic, order-sorted type concept (derived from the slightly more general type concept of TEL [15], [14]) and a complete abstract machine implementation, called PAM ([13], <ref> [4] </ref>) that is an extension of the WAM by the required polymorphic order-sorted unification. Our final aim is to provide a full specification and correctness proof of the concrete PAM system ([3]). <p> (P), Call (G 1 ),. . . ,Call (G n ),Proceed] Note that this treatment of constraints will be refined later by distributing the clause constraint over the individual literals such that each type constraint for a variable is only considered when the variable occurs for the first time (c.f. <ref> [4] </ref>). But we will postpone this until the explicit representation of terms is introduced. The substitution component s from [7] becomes now c: STATE ! CSS. <p> A sequence of corresponding put constraint (yj, ttj) instructions initialized the type restriction on the variables yj to ttj found in the clause's type prefix. However, as explained in <ref> [4] </ref>, the first occurrence of a variable in a PROTOS-L clause is sufficient to consider the statically available type restriction. (The specialized instructions of [4] for variables with monomorphic, polymorphic, or with no type restriction are introduced as an optimization in [3].) Both temporary and permanent variables can be initialized "on <p> However, as explained in <ref> [4] </ref>, the first occurrence of a variable in a PROTOS-L clause is sufficient to consider the statically available type restriction. (The specialized instructions of [4] for variables with monomorphic, polymorphic, or with no type restriction are introduced as an optimization in [3].) Both temporary and permanent variables can be initialized "on the fly"; for a discussion of the classification of variables into temporary and permanent ones which was introduced by [16] we refer to [1] <p> The latter refinement leads to a situation where when only variables with trivial TOP restriction are used this corresponds to the untyped case theWAM comes out a special case <ref> [4] </ref>. 25
Reference: [5] <author> E. Borger. </author> <title> A logical operational semantics of full Prolog. Part I. Selection core and control. </title> <editor> In E. Borger, H. Kleine Buning, and M. M. Richter, editors, </editor> <booktitle> CSL'89 - 3rd Workshop on Computer Science Logic. </booktitle> <volume> LNCS 440, </volume> <pages> pages 36-64, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1990. </year>
Reference: [6] <author> E. Borger. </author> <title> A logical operational semantics of full Prolog. Part II. Built-in predicates for database manipulations. </title> <editor> In B. Rovan, editor, </editor> <booktitle> MFCS'90 Mathematical Foundations of Computer Science. </booktitle> <volume> LNCS 452, </volume> <pages> pages 1-14, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1990. </year>
Reference-contexts: The introduction of PROTOS-L specific type constraint representation is carried out in [3]. To keep this paper within reasonable limits, we definitely suppose that the reader is familiar with <ref> [6] </ref> and [7,8] to which we will refer for many definitions and notations, including those concerning evolving algebras. The natural modularity of our approach will come out from presenting in this paper only those extensions and refinements which are needed in the presence of types. <p> Due to severe space restrictions, examples could not be included in this paper; we refer the reader to [3]. 2 PROTOS-L Algebras 2.1 Universes and Functions The basic universes and functions in PROTOS-L algebras can be taken directly from the standard Prolog algebras ([5], <ref> [6] </ref>). In particular, we have the universes TERM and SUBST of terms and substitutions with a function subres: TERM fi SUBST ! TERM yielding subres (t,s), the result of applying s to t. <p> Thus, at this point we assume that the compiler has done already static type checking and inferencing. The procdef function of <ref> [6] </ref> now assumes the form procdef: CLAUSE fl fi INDEX fi TERM fi SUBST fi TYPEPREFIX ! CLAUSE fl where procdef (db, i, g, s, P) is a list of clauses from db, renamed with variable index i, that might be relevant for solving the literal g under the substitution s <p> As in <ref> [6] </ref> this abstracts away from any indexing mechanism, but it does allow for a preselection of clauses both with regard to the given substitution as well as with regard to the variable types obtained so far in the deduction process. <p> any relevant clauses, i.e. given procdef (db, i, g, s, P) = l we have: 8 cl 2 db . cl 62 l solvable (fg : = rename (clhead (cl), i)g [ s [ P [ rename (clconstraint (cl), i)) = false 5 The basic part of Prolog algebras in <ref> [6] </ref> that holds the resolution state is a predecessor structure with universe RESSTATE and with functions currstate: RESSTATE nil: RESSTATE choicepoint: RESSTATE ! RESSTATE declglseq: RESSTATE ! DECGOAL fl where DECGOAL GOAL fi RESSTATE. <p> (currconstraint) For an initially given goal fPg G 1 & . . . & G n the PROTOS-L algebra has as initial values currdecglseq = [&lt;[SolveConstraint (P) & G 1 & . . . & G n ], nil&gt;] currconstraint = ; and all other initial values are as in <ref> [6] </ref>. 2.2 PROTOS-L Transition Rules Since the universe TYPETERM until now is abstract the constraints we considered so far can be treated as in [9]. <p> The unify rule of <ref> [6] </ref> is refined such that instead of instantiating the continuation sequence of goals with the most general unifier, the unification requirement is added to the current constraint system, provided it will still be solvable: Unify if still working correctly & curractivator = (G1 = G2) & solvable (currconstraint | solvable (currconstraint <p> currconstraint := currconstraint | backtrack [ P | currdecglseq := [tail (currdecgl) | | tail (currdecglseq)] | Since we add a constraint to the current constraint system only if it remains solvable, we do not have to add a condition on its solvability to any of the other rules of <ref> [6] </ref>, or to add a second backtracking rule, as in [9]: All other rules for 'pure' Prolog can be taken unchanged from [6]. <p> to the current constraint system only if it remains solvable, we do not have to add a condition on its solvability to any of the other rules of <ref> [6] </ref>, or to add a second backtracking rule, as in [9]: All other rules for 'pure' Prolog can be taken unchanged from [6].
Reference: [7] <author> E. Borger and D. Rosenzweig. </author> <title> From Prolog algebras towards WAM a mathematical study of implementation. </title> <editor> In E. Borger, H. Kleine Buning, M. M. Richter, and W. Schonfeld, editors, </editor> <booktitle> Computer Science Logic. </booktitle> <volume> LNCS 533, </volume> <pages> pages 31-66, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1991. </year>
Reference-contexts: For proving the correctness of the AND/OR structure in the PAM, we proceed along the lines of <ref> [7] </ref>, presenting only the modifications and extensions needed for our PROTOS-L algebras, since the separation of the WAM specification development in [7] into several refinement levels enables us to locate the required modifications quite naturally with all correctness proofs obtained by straightforward adaptations. <p> For proving the correctness of the AND/OR structure in the PAM, we proceed along the lines of <ref> [7] </ref>, presenting only the modifications and extensions needed for our PROTOS-L algebras, since the separation of the WAM specification development in [7] into several refinement levels enables us to locate the required modifications quite naturally with all correctness proofs obtained by straightforward adaptations. Our compilation refines the compile function compile: TERM ! INSTR fl of [7] by introducing a new instruction PutConstraint for dealing with constraints. <p> and extensions needed for our PROTOS-L algebras, since the separation of the WAM specification development in <ref> [7] </ref> into several refinement levels enables us to locate the required modifications quite naturally with all correctness proofs obtained by straightforward adaptations. Our compilation refines the compile function compile: TERM ! INSTR fl of [7] by introducing a new instruction PutConstraint for dealing with constraints. <p> But we will postpone this until the explicit representation of terms is introduced. The substitution component s from <ref> [7] </ref> becomes now c: STATE ! CSS. <p> Furthermore, at this level of refinement the information on the variable renaming index is formalized in the rule conditions. Therefore, following <ref> [7] </ref>, the procdef function is now typed without INDEX as follows (c.f. <p> Proof: The proof is an easy adaption of the correctness proof of Section 2.1 in <ref> [7] </ref> by modifying the resolution state and decorated goal sequence recovering functions F and G (since our goal sequences in RESSTATE are not instantiated) and including the recovery of SolveConstraint (P) from PutConstraint (P): F: STATE ! RESSTATE G: ENV ! DECGLSEQ F (nil) = nil decglseq (F (St)) = [&lt;goal_seq <p> All remaining parts of <ref> [7] </ref> can be adopted almost directly to our treatment of PROTOS-L algebras. For the explicit allocation and deallocation of environments and the last call optimization one just has to bear in mind that a PutConstraint instruction has to be generated for every clause.
Reference: [8] <author> E. Borger and D. Rosenzweig. </author> <title> WAM algebras a mathematical study of implementation, Part II. </title> <booktitle> In Russian Conference on Logic Programming '91. </booktitle> <publisher> LNCS , Springer-Verlag, </publisher> <year> 1992. </year> <note> (to appear). Preliminary version in: Technical Report CSE-TR-88-91, </note> <institution> The University of Michigan, Department of Electrical Engineering and Computer Science, Ann Arbor, Michigan. </institution>
Reference-contexts: Also the compilation of the predicate structure carries over to our setting, as well as all corresponding correctness proofs. 4 Term representation 4.1 Universes and Functions We adopt the notions of <ref> [8] </ref> and adding a universe SYMBOLTABLE use the pointer algebra (DATAAREA, PO + MEMORY + SYMBOLTABLE; top, bottom; +, -; val) The functions tag and ref are defined on 10 tag: PO ! TAGS ref: PO ! DATAAREA + TYPETERM where, because of the type constraint treatment, a new tag VAR <p> The tag FUNC from <ref> [8] </ref> has been removed since it is not needed. The codomain of ref contains the universe TYPETERM since we will keep the type term representation abstract here; it will be refined later (see Section 7). <p> Here are some new resp. modified abbreviations, integrity constraints, and functions which we add to the ones from <ref> [8] </ref>: unbound (l) == tag (l) = VAR mk_unbound (l) == mk_unbound (l,TOP) mk_unbound (l,t) == tag (l) := VAR insert_type (l,t) insert_type (l,t) == ref (l) := t Note that an unconstrained free variable gets the trivial type restriction TOP, representing no restriction at all (c.f. Section 2.1). <p> The bind operation may thus also fail and initiate backtracking if the type constraints are not satisfied. Thus, we can use the treatment of unification as described in <ref> [8] </ref>, while leaving the bind operation abstract for the moment, not only in order to postpone the discussion of occur check and trailing but also to stress the fact that the bind operation will take care of the type constraints for the variables. <p> Then we have: LET CS = fterm (left) = term (right)g [ type-prefix (left) [ type-prefix (right) if solvable (CS) = true then (term', prefix') = conres (term, prefix, CS) else backtrack update will be executed Proof: As in <ref> [8] </ref> the proof of the Unification Lemma is by induction, this time relying on our generalized Binding Condition. 4.3 Putting of terms In the code for generating terms on the heap we have to consider our slightly modified term representation: The value cell pointed to by a STRUC reference does not <p> Thus we assume that in the generated code every pair (f,a) is replaced by entry (f,a). The code developed in Section 1.2 of <ref> [8] </ref> for constructing terms in body goals uses put instructions which assume that, for all variables Yi of the term t to be built on the heap, there is already a term denoting yi 2 DATAAREA available. <p> t), More)) with subsequent fresh indices generated by nfs being non-top level, is that the pair (term (xi), type-prefix (xi)) 13 at the moment of passing to More, gets value of conres (t, ;, CS) Proof: The proof is a direct generalization of the proof of the Putting Lemma in <ref> [8] </ref>, observing that no type related actions like variable creation or variable binding is involved here. 4.4 Getting of terms Unlike putting of terms that does not involve unification the getting of terms does involve unification where parts of it are compiled into the getting instructions (like get structure followed by <p> The get value, unify value, and unify variable (the latter both in Read and Write mode) are as in <ref> [8] </ref>, where for the generation of a heap variable in Write mode of unify variable we use mk_heap_var (l) == mk_unbound (h) bind (l, h) h := h+ Note that we assume that the bind update will require several rule applications that will be triggered by the abbreviation bind (l,h) this <p> This point had been left open in <ref> [8] </ref> where the bind abbreviation in mk heap var is not consistent with the use of it in the unify rules. <p> Proof: The proof is an easy adaption of the proof in <ref> [8] </ref>. Note that if CS is solvable, then conres (term, typeprefix, CS) 6= nil because CS [ typeprefix is also solvable since the intersection between typeprefix and any type-prefix (yn) is already contained in CS. <p> to the PROTOS-L case. 16 4.5 Putting of Constraints In this section we will still keep the type constraint representation abstract, while specifying the conditions about the constraint handling code (for realization of PutConstraint of Section 3) in order to prove a theorem corrresponding to the Pure Prolog Theorem of <ref> [8] </ref> (see 5). <p> This is done as in <ref> [8] </ref> since the only type-related action is in the allocation of n free variable cells in the rule for Allocate: This situation is covered by our modified mk unbound abbreviation that assigns the TOP type restriction to it. 17 5.2 Trailing Since variables in PROTOS-L carry a type restriction represented in <p> The trail update, to be executed when binding a location l, is then: trail (l) == ref''(tr) := (l, val (l)) tr := tr+ Note that this is a non-optimized version of the trailing operation; as in <ref> [8] </ref> we could have also used a conditional trailing governed by the condition l : heap & l &lt; hb OR l : stack & l &lt; b . <p> As in <ref> [8] </ref> all our rules given up to now satisfy the STACK VARIABLE PROPERTY. <p> This generalizes the proof of the PURE PROLOG THEOREM of Section 2.1.4 of <ref> [8] </ref> from which we take the notation and all auxiliary functions with the following modifications and extensions (Note that all functions on the PROTOS-L level thus have the suffix '1'): compile ( -P- H &lt;-- G1 & ... & Gn ) = splice ( [Allocate (r), put_constraint_seq (P) | get_seq (H)], <p> the constraint system is defined by c1 := css (tr) The correspondence between the rules is extended by associating the sequence of put constraint instructions to the PutConstraint rule of the PROTOS-L algebras: put constraint seq --&gt; PutConstraint The rest of the proof is a generalization of the proof in <ref> [8] </ref>, relying on our (modified) conditions and lemmas. In particular, we observe the fact that Allocate allocates a new variable location (with TOP restriction) for every variable occurring in the clause. <p> := Bind_direction bind_success == what_to_do := return_from_bind BIND == OK & what_to_do = Bind trail (l1,l2) == ref''(tr) := (l1, val (l1)) ref''(tr+) := (l2, val (l2)) 20 In order to reset also the constant what to do upon backtracking, we refine the backtrack update p := val (b-2) of <ref> [8] </ref> which sets the next-instruction-pointer p to the next alternative of the current choicepoint b (which happens to be stored in location b-2), to backtrack == p := val (b-2) what_to_do := Run For unbound (l1) there are two alternative conditions on the update occur check (l1,l2), depending on whether the <p> Propagation Condition when binding a variable to a non-variable term (Bind-3). 22 6 Additional WAM optimizations in the PAM 6.1 Environment Trimming and Last Call Optimization Environment trimming and last call optimization (LCO) are among the most important optimizations in the WAM; for a discussion we refer to [1] and <ref> [8] </ref>. The necessary ARGUMENT REGISTERS PROPERTY as formulated in [8] can be ensured by the compiler by generating a put unsafe value (yn, xj) instruction instead of put value (yn, xj) for each unsafe occurrence of Yn. <p> term (Bind-3). 22 6 Additional WAM optimizations in the PAM 6.1 Environment Trimming and Last Call Optimization Environment trimming and last call optimization (LCO) are among the most important optimizations in the WAM; for a discussion we refer to [1] and <ref> [8] </ref>. The necessary ARGUMENT REGISTERS PROPERTY as formulated in [8] can be ensured by the compiler by generating a put unsafe value (yn, xj) instruction instead of put value (yn, xj) for each unsafe occurrence of Yn. Instead of using the mk heap var abbreviation with more than one argument as in [8] which leads to problems with multiple invocations <p> necessary ARGUMENT REGISTERS PROPERTY as formulated in <ref> [8] </ref> can be ensured by the compiler by generating a put unsafe value (yn, xj) instruction instead of put value (yn, xj) for each unsafe occurrence of Yn. Instead of using the mk heap var abbreviation with more than one argument as in [8] which leads to problems with multiple invocations of the bind update (c.f. <p> Unlike in Prolog, in PROTOS-L the type restriction of yi must be copied to the new heap variable this is already taken into account by the bind update in our mk heap var abbreviation introduced in Section 4.4. Therefore, following the argumentation in <ref> [8] </ref>, we can savely assume that the compiler enforces environment trimming and also last call optimization. 6.2 Initializing Temporary and Permanent Variables By following the development in [8], up to now, when allocating an environment, we have allocated r value cells in that environment, where r is the number of variables <p> Therefore, following the argumentation in <ref> [8] </ref>, we can savely assume that the compiler enforces environment trimming and also last call optimization. 6.2 Initializing Temporary and Permanent Variables By following the development in [8], up to now, when allocating an environment, we have allocated r value cells in that environment, where r is the number of variables occurring in the clause. <p> variables with monomorphic, polymorphic, or with no type restriction are introduced as an optimization in [3].) Both temporary and permanent variables can be initialized "on the fly"; for a discussion of the classification of variables into temporary and permanent ones which was introduced by [16] we refer to [1] and <ref> [8] </ref>. <p> Thus, the rule for allocate looses its initialization update, and the compile function is modified such that no put constraint instruction is generated any more. Moreover, the argumentation of Section3.2 and 3.2 of <ref> [8] </ref> can be applied to our modified setting, implying its correctness as well as the correctness of special compilation of facts and chain rules where no environment needs to be allocated at all. 6.3 Switching instructions The PAM contains all switching instructions known from the WAM, and since no type specific <p> of special compilation of facts and chain rules where no environment needs to be allocated at all. 6.3 Switching instructions The PAM contains all switching instructions known from the WAM, and since no type specific considerations have to be taken into account, their treatment in the evolving algebra approach in <ref> [8] </ref> carries over to the PAM as well. However, in PROTOS-L additionally a switch on the type restriction of a variable is possible ([3]). 7 Conclusions and Outlook Putting everything together, we obtain the Main Theorem: The PAM algebras developed so far are correct w.r.t. PROTOS-L algebras.
Reference: [9] <author> E. Borger and P. H. Schmitt. </author> <title> A formal operational semantics for languages of type Prolog III. </title> <editor> In E. Borger, H. Kleine Buning, M. M. Richter, and W. Schonfeld, editors, </editor> <booktitle> Computer Science Logic. </booktitle> <volume> LNCS 533, </volume> <pages> pages 67-79, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1991. </year>
Reference-contexts: As in <ref> [9] </ref> we use three obvious projection functions clhead: CLAUSE ! TERM clbody: CLAUSE ! TERM fl clconstraint: CLAUSE ! TYPEPREFIX Every element of the universe GOAL comes with a type prefix for its variables and is written as fPg G 1 & . . . & G n . <p> As in <ref> [9] </ref> we add a function constraint: RESSTATE ! CSS to hold the constraint system (which includes its substitution part) accumulated so far. <p> = [&lt;[SolveConstraint (P) & G 1 & . . . & G n ], nil&gt;] currconstraint = ; and all other initial values are as in [6]. 2.2 PROTOS-L Transition Rules Since the universe TYPETERM until now is abstract the constraints we considered so far can be treated as in <ref> [9] </ref>. However, whereas [9] deliberately takes unification and constraint solving as one abstract unit, for use in later refinements we distinguish here between adding an equation asking for unification and adding a clause's constraint. <p> & G 1 & . . . & G n ], nil&gt;] currconstraint = ; and all other initial values are as in [6]. 2.2 PROTOS-L Transition Rules Since the universe TYPETERM until now is abstract the constraints we considered so far can be treated as in <ref> [9] </ref>. However, whereas [9] deliberately takes unification and constraint solving as one abstract unit, for use in later refinements we distinguish here between adding an equation asking for unification and adding a clause's constraint. <p> [tail (currdecgl) | | tail (currdecglseq)] | Since we add a constraint to the current constraint system only if it remains solvable, we do not have to add a condition on its solvability to any of the other rules of [6], or to add a second backtracking rule, as in <ref> [9] </ref>: All other rules for 'pure' Prolog can be taken unchanged from [6].
Reference: [10] <author> Y. Gurevich. </author> <title> Evolving algebras. A tutorial introduction. </title> <journal> EATCS Bulletin, </journal> <volume> 43, </volume> <month> Fe-bruary </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Recently, Gurevich's evolving algebra approach ([11]) has not only been used for the description of the (operational) semantics of various programming languages (Modula-2, Occam, Prolog, Prolog III, Smalltalk, Parlog, C; see <ref> [10] </ref>), but also for the description and analysis of implementation methods: Borger and Rosenzweig ([7,8]) provide a mathematical elaboration of Warren's Abstract Machine ([16], [1]) for executing Prolog. The description consists of several refinement levels together with correctness proofs, and a correctness proof w.r.t. Borger's phenomenological Prolog description ([5,6]).
Reference: [11] <author> Y. Gurevich. </author> <title> Logic and the challenge of computer science. </title> <editor> In E. Borger, editor, </editor> <booktitle> Trends in Theoretical Computer Science, </booktitle> <pages> pages 1-57, </pages> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference: [12] <author> D. M. Russinoff. </author> <title> A Verified Prolog Compiler for the Warren Abstract Machine. </title> <type> Technical Report ACT-ST-292-89, </type> <institution> MCC, Austin, Texas, </institution> <year> 1989. </year> <note> (To appear in Journal of Logic Programming). </note>
Reference-contexts: Based on Borger and Rosenzweig's WAM description we provide a mathematical specification of a WAM extension to type-constraint logic programming and prove its correctness. Note that thereby our treatment covers also all extra-logical features (like the Prolog cut) whereas the WAM correctness proof of <ref> [12] </ref> deals merely with SLD resolution for Horn clauses. The extension of logic programming by types requires in general not only static type checking, but types are also present at run time.
Reference: [13] <author> H. Semle. </author> <title> Extension of an Abstract Machine for Order-Sorted Prolog to Polymor-phism. Diplomarbeit Nr. </title> <type> 583, </type> <institution> Universitat Stuttgart und IBM Deutschland GmbH, </institution> <address> 26 Stuttgart, </address> <month> April </month> <year> 1989. </year> <note> (in German). </note>
Reference: [14] <author> G. Smolka. </author> <title> Logic Programming over Polymorphically Order-Sorted Types. </title> <type> PhD thesis, </type> <institution> FB Informatik, Univ. Kaiserslautern, </institution> <year> 1989. </year>
Reference-contexts: For instance, if there are types and sub-types, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming. PROTOS-L ([2]) is a logic programming language that has a polymorphic, order-sorted type concept (derived from the slightly more general type concept of TEL [15], <ref> [14] </ref>) and a complete abstract machine implementation, called PAM ([13], [4]) that is an extension of the WAM by the required polymorphic order-sorted unification. Our final aim is to provide a full specification and correctness proof of the concrete PAM system ([3]).
Reference: [15] <author> G. Smolka. </author> <title> TEL (Version 0.9), Report and User Manual. </title> <type> SEKI-Report SR 87-17, </type> <institution> FB Informatik, Universitat Kaiserslautern, </institution> <year> 1988. </year>
Reference-contexts: For instance, if there are types and sub-types, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming. PROTOS-L ([2]) is a logic programming language that has a polymorphic, order-sorted type concept (derived from the slightly more general type concept of TEL <ref> [15] </ref>, [14]) and a complete abstract machine implementation, called PAM ([13], [4]) that is an extension of the WAM by the required polymorphic order-sorted unification. Our final aim is to provide a full specification and correctness proof of the concrete PAM system ([3]).
Reference: [16] <author> D. Warren. </author> <title> An Abstract PROLOG Instruction Set. </title> <type> Technical Report 309, </type> <institution> SRI, </institution> <year> 1983. </year> <month> 27 </month>
Reference-contexts: (The specialized instructions of [4] for variables with monomorphic, polymorphic, or with no type restriction are introduced as an optimization in [3].) Both temporary and permanent variables can be initialized "on the fly"; for a discussion of the classification of variables into temporary and permanent ones which was introduced by <ref> [16] </ref> we refer to [1] and [8].
References-found: 16

