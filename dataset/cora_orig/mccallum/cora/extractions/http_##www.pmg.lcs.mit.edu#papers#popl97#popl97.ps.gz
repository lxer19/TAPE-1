URL: http://www.pmg.lcs.mit.edu/papers/popl97/popl97.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/papers/popl97/
Root-URL: 
Email: fandru,jbank,liskovg@lcs.mit.edu  
Title: Parameterized Types for Java  
Author: Andrew C. Myers Joseph A. Bank Barbara Liskov 
Address: 545 Technology Square, Cambridge, MA 02139  
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Date: January 1997  
Note: Proceedings of the 24th ACM Symposium on Principles of Programming Languages, Paris, France,  
Abstract: Java offers the real possibility that most programs can be written in a type-safe language. However, for Java to be broadly useful, it needs additional expressive power. This paper extends Java in one area where more power is needed: support for parametric polymorphism, which allows the definition and implementation of generic abstractions. We discuss both the rationale for our design decisions and the impact of the extension on other parts of Java, including arrays and the class library. We also describe optional extensions to the Java virtual machine to allow parameterized bytecodes, and how to verify them efficiently. We have extended the Java bytecode interpreter to provide good performance for parameterized code in both execution speed and code size, without slowing down non-parameterized code. 
Abstract-found: 1
Intro-found: 1
Reference: [BLM96] <author> Joseph A. Bank, Barbara Liskov, and Andrew C. Myers. </author> <title> Parameterized types and Java. </title> <type> Technical Memo MIT/LCS/TM-553, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1996. </year>
Reference-contexts: The non-quick version of such an instruction performs a one-time initialization, including dynamic type checking, and then turns itself into the quick version. Our implementation makes extensive use of this self-modifying code technique in order to improve performance. A more detailed discussion of the implementation technique is available <ref> [BLM96] </ref>. The presence of subclasses makes ipools substantially more complicated than implementing parametric polymor-phism for languages like CLU or ML [MTH90], which are not object-oriented.
Reference: [Car88] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 138-164, </pages> <year> 1988. </year> <note> Also in Readings in Object-Oriented Database Systems, </note> <editor> S. Zdonik and D. Maier, eds., </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: Therefore, an instantiation can be legal even if the signatures of constructors and methods of the actual type do not match exactly with those in the constraints. Instead we require only compatibility, using the standard contra/covariance rules for routine matching <ref> [Car88] </ref>. The only extension to these rules is that any exceptions thrown by the provided method must be subtypes of the exceptions given for that method in the where clause.
Reference: [CCH + 89] <author> Peter Canning, William Cook, Walter Hill, John Mitchell, and Walter Olthoff. </author> <title> F-bounded polymorphism for object-oriented programming. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: Note also that interfaces cannot express constructor and static method constraints, which are both possible with where clauses. 2.8.3 Parameterized Interfaces To address some weaknesses of interfaces, parameterized interfaces can be used instead. This approach, related to F-bounded polymorphism <ref> [CCH + 89] </ref>, is used by some other statically-typed programming languages [KLMM94, OL92, Omo93]. In these schemes, the contravariance problem is avoided by adding parameters to the constraint interface.
Reference: [DGLM95] <author> Mark Day, Robert Gruber, Barbara Liskov, and Andrew C. Myers. </author> <title> Subtypes vs. where clauses: Constraining parametric polymorphism. </title> <booktitle> In Proc. of OOPSLA '95, </booktitle> <pages> pages 156-158, </pages> <address> Austin TX, </address> <month> October </month> <year> 1995. </year> <journal> ACM SIGPLAN Notices 30(10). </journal>
Reference-contexts: We extended Java by adapting an existing, working mechanism with as few changes as possible. We supported the Java philosophy of providing separate compilation with complete inter-module type checking, which also seemed important for pragmatic reasons. We used the Theta mechanism <ref> [DGLM95, LCD + 94] </ref> as the basis of our language design, because Theta has important similarities to Java. Like Java, it uses declared rather than structural subtyping, and it also supports complete inter-module type checking. <p> In particular, subtype relations between different instantiations of the same parameterized class are disallowed. Thus SortedList [BigNum] is not a subtype of SortedList [Num], even if BigNum is a subtype of Num. The reasons for this rule are discussed in Section 4.2 and elsewhere <ref> [DGLM95] </ref>. 2.6 Implementations A Java class can implement one or more interfaces, using the implements clause. The rule for legality of an implements declaration is the same as that for extends. For example, Map using a hash table. <p> We briefly examine some of these choices to show why they do not work well for extending Java. Further discussion of constraint mechanisms is available in an earlier paper <ref> [DGLM95] </ref>. 2.8.1 Procedures One simple approach is to avoid constraints and instead pass the needed routines explicitly when objects are created (as arguments to constructors and the procedures would be stored in instance variables so that they would be accessible to the methods). <p> For example, we might try to write interface SortedList [T] where T extends Ordered f . . . interface Ordered f boolean lt (Ordered x); g The problem with this approach is that it cannot express con straints (such as lt) that mention the type parameter <ref> [DGLM95] </ref>. 136 Because lt is a binary method, contravariance of arguments prevents most types from being subtypes of Ordered. <p> The object has a pointer to its instantiation class object, which contains the ipool for the methods of that class. Since the method may be inherited from another class, an additional indirection is required to obtain the correct ipool. Our implementation technique resembles an earlier approach <ref> [DGLM95] </ref>, but extended to provide support for static methods, static variables, and dynamic type discrimination. <p> It would be possible to allow such subtyping if no methods of the supertype take arguments of the parameter type, but such types are rare. (A more complete discussion of these issues is available <ref> [DGLM95] </ref>.) Furthermore, covariant-parameter subtyping creates implementation difficulties for efficient dispatch mechanisms [Str87, Mye95]. We believe that the Java rule for arrays should be changed so that all parameterized types have the same rule.
Reference: [KLMM94] <author> Dinesh Katiyar, David Luckham, John Mitchell, and Sigurd Melda. </author> <title> Polymorphism and subtyping in interfaces. </title> <journal> ACM SIG-PLAN Notices, </journal> <volume> 29(9) </volume> <pages> 22-34, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: This approach, related to F-bounded polymorphism [CCH + 89], is used by some other statically-typed programming languages <ref> [KLMM94, OL92, Omo93] </ref>. In these schemes, the contravariance problem is avoided by adding parameters to the constraint interface.
Reference: [L + 81] <author> B. Liskov et al. </author> <title> CLU reference manual. </title> <editor> In Goos and Hartma-nis, editors, </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 114. </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: != null) && (!b.key.equals (k))) b = b.next; if (b == null) throw new not in (); else return b.value; g // other methods go here g class HashBucket [Key,Value] f public Key key; public Value value; public HashBucket [Key,Value] next; g ual methods, a feature originally provided by CLU <ref> [L + 81] </ref>. Any where clause from the header of the class still applies, but additional methods can be required of the parameter type. <p> Essentially, it becomes a clumsy way of bundling where clauses together. A separate interface to constrain parameters might seem to offer economy of expression in some cases: one interface can be used to constrain several different parameterized definitions, rather than restating the where clauses for each definition. CLU <ref> [L + 81] </ref> has a construct called a typeset that was provided for just this purpose. Yet, our experience with CLU is that typesets are almost never used primarily because most constraints are very short (just one or two methods).
Reference: [LCD + 94] <author> Barbara Liskov, Dorothy Curtis, Mark Day, Sanjay Ghe-mawat, Robert Gruber, Paul Johnson, and Andrew C. My-ers. </author> <title> Theta Reference Manual. Programming Methodology Group Memo 88, </title> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> February </month> <year> 1994. </year> <note> Available at http://www.pmg.lcs.mit.edu/papers/thetaref/. </note>
Reference-contexts: We extended Java by adapting an existing, working mechanism with as few changes as possible. We supported the Java philosophy of providing separate compilation with complete inter-module type checking, which also seemed important for pragmatic reasons. We used the Theta mechanism <ref> [DGLM95, LCD + 94] </ref> as the basis of our language design, because Theta has important similarities to Java. Like Java, it uses declared rather than structural subtyping, and it also supports complete inter-module type checking. <p> We largely ignore the issue of compiling the extended Java language described in Section 2, since there are many languages with parametric polymorphism <ref> [MTH90, LCD + 94, S + 86] </ref>. Instead, we focus on what is new: extensions to the bytecodes of the Java Virtual Machine (JVM) that support parametric poly-morphism, and the effect of these extensions on both the bytecode verifier and interpreter. Extensions to the JVM are not required.
Reference: [LY96] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine. </title> <publisher> Addison-Wesley, </publisher> <address> Englewood Cliffs, NJ, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Because of the widespread interest in Java, its similarity to C and C++, and its industrial support, many organizations may make Java their language of choice. Java is also interesting because of its machine-independent target architecture, the Java Virtual Machine (JVM) <ref> [LY96] </ref>. Java is attractive for web applications, in part because Java bytecodes can be statically verified, preventing violations of type safety that might access private information. <p> For this reason, we have chosen to extend the virtual machine. The Java compiler generates .class files, containing code in a bytecode format, along with other information needed to interpret and verify the code. The format of a .class file is described by the JVM specification <ref> [LY96] </ref>. We extended the JVM in a backwards-compatible way, as described in Section 3.2, so existing binaries can run without modification. <p> there is exactly one class object for each instantiation being used in the running system. 3.4.2 Quick Instructions The Sun implementation of the JVM includes an optimization that dynamically modifies the code the first time an instruction is executed, replacing some ordinary bytecodes with quick equivalents that do less work <ref> [LY96] </ref>. These quick instructions are not part of the bytecode specification and are not visible outside of the implementation. The non-quick version of such an instruction performs a one-time initialization, including dynamic type checking, and then turns itself into the quick version.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Pren-tice Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: The virtue of this approach is that some constraints can be expressed using the subtype notion that already exists; several languages have taken this approach <ref> [Mey88, MMPN93, S + 86] </ref>.
Reference: [MMPN93] <author> O. Lehrmann Madsen, B. Moller-Pedersen, and K. Nygaard. </author> <title> Object Oriented Programming in the BETA Programming Language. </title> <publisher> Addison-Wesley, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: The virtue of this approach is that some constraints can be expressed using the subtype notion that already exists; several languages have taken this approach <ref> [Mey88, MMPN93, S + 86] </ref>.
Reference: [MTH90] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: We largely ignore the issue of compiling the extended Java language described in Section 2, since there are many languages with parametric polymorphism <ref> [MTH90, LCD + 94, S + 86] </ref>. Instead, we focus on what is new: extensions to the bytecodes of the Java Virtual Machine (JVM) that support parametric poly-morphism, and the effect of these extensions on both the bytecode verifier and interpreter. Extensions to the JVM are not required. <p> Our implementation makes extensive use of this self-modifying code technique in order to improve performance. A more detailed discussion of the implementation technique is available [BLM96]. The presence of subclasses makes ipools substantially more complicated than implementing parametric polymor-phism for languages like CLU or ML <ref> [MTH90] </ref>, which are not object-oriented. Consider a method call: the compiler and dynamic linker cannot tell which piece of code is run, so they cannot determine the corresponding ipool to use, either.
Reference: [Mye95] <author> Andrew C. Myers. </author> <title> Bidirectional object layout for separate compilation. </title> <booktitle> In Proc. of OOPSLA '95, </booktitle> <pages> pages 124-139, </pages> <month> October </month> <year> 1995. </year> <journal> ACM SIGPLAN Notices 30(10). </journal>
Reference-contexts: It would be possible to allow such subtyping if no methods of the supertype take arguments of the parameter type, but such types are rare. (A more complete discussion of these issues is available [DGLM95].) Furthermore, covariant-parameter subtyping creates implementation difficulties for efficient dispatch mechanisms <ref> [Str87, Mye95] </ref>. We believe that the Java rule for arrays should be changed so that all parameterized types have the same rule.
Reference: [Nel91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Like Java, it uses declared rather than structural subtyping, and it also supports complete inter-module type checking. We rejected the C++ template mechanism [Sto87] and the Modula-3 <ref> [Nel91] </ref> generic module mechanism because they do not support our type-checking goal; they require that a generic module must be type checked separately for every distinct use.
Reference: [OL92] <author> Stephen M. Omohundro and Chu-Cheow Lim. </author> <title> The Sather language and libraries. </title> <type> Technical Report TR-92-017, </type> <institution> International Computer Science Institute, Berkeley, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: This approach, related to F-bounded polymorphism [CCH + 89], is used by some other statically-typed programming languages <ref> [KLMM94, OL92, Omo93] </ref>. In these schemes, the contravariance problem is avoided by adding parameters to the constraint interface.
Reference: [Omo93] <author> Stephen M. Omohundro. </author> <title> The Sather programming language. </title> <journal> Dr. Dobb's Journal, </journal> <volume> 18(11) </volume> <pages> 42-48, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: This approach, related to F-bounded polymorphism [CCH + 89], is used by some other statically-typed programming languages <ref> [KLMM94, OL92, Omo93] </ref>. In these schemes, the contravariance problem is avoided by adding parameters to the constraint interface. <p> Further, the need for a constraint may only be known later, because new parameterized classes (and constraints) can be added to the system. Existing types cannot be used as parameters because they do not declare their satisfaction of the new constraint. Sather <ref> [Omo93] </ref> addresses this problem by allowing new subtype declarations to be added to the system at any time.
Reference: [S + 86] <author> C. Schaffert et al. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proc. of OOPSLA '86, </booktitle> <address> Portland, OR, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: The virtue of this approach is that some constraints can be expressed using the subtype notion that already exists; several languages have taken this approach <ref> [Mey88, MMPN93, S + 86] </ref>. <p> We largely ignore the issue of compiling the extended Java language described in Section 2, since there are many languages with parametric polymorphism <ref> [MTH90, LCD + 94, S + 86] </ref>. Instead, we focus on what is new: extensions to the bytecodes of the Java Virtual Machine (JVM) that support parametric poly-morphism, and the effect of these extensions on both the bytecode verifier and interpreter. Extensions to the JVM are not required.
Reference: [Sto87] <author> B. Stoustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: We used the Theta mechanism [DGLM95, LCD + 94] as the basis of our language design, because Theta has important similarities to Java. Like Java, it uses declared rather than structural subtyping, and it also supports complete inter-module type checking. We rejected the C++ template mechanism <ref> [Sto87] </ref> and the Modula-3 [Nel91] generic module mechanism because they do not support our type-checking goal; they require that a generic module must be type checked separately for every distinct use.
Reference: [Str87] <author> B. Stroustrup. </author> <title> Multiple inheritance for C++. </title> <booktitle> In Proceedings of the Spring '87 European Unix Systems User's Group Conference, </booktitle> <address> Helsinki, Finland, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: It would be possible to allow such subtyping if no methods of the supertype take arguments of the parameter type, but such types are rare. (A more complete discussion of these issues is available [DGLM95].) Furthermore, covariant-parameter subtyping creates implementation difficulties for efficient dispatch mechanisms <ref> [Str87, Mye95] </ref>. We believe that the Java rule for arrays should be changed so that all parameterized types have the same rule.
Reference: [Sun95a] <author> Sun Microsystems. </author> <title> Java Language Specification, </title> <note> version 1.0 beta edition, October 1995. Available at ftp://ftp.javasoft.com/docs/javaspec.ps.zip. </note>
Reference-contexts: 1 Introduction Java <ref> [Sun95a] </ref> is a type-safe, object-oriented programming language that is interesting because of its potential for WWW applications. Because of the widespread interest in Java, its similarity to C and C++, and its industrial support, many organizations may make Java their language of choice. <p> Variables directly denote objects in the heap; there are no pointers. For safety, Java programs are statically type checked, and storage is managed by a garbage collector. Java allows new types to be defined by both interfaces and classes <ref> [Sun95a] </ref>. An interface contains just the names and signatures of methods, but no implementations. A class defines methods and constructors, as well as fields and implementations. <p> We have not attempted to give a full syntax for Java, but rather we just focus on the parts that are affected by the addition of parameterization. Capitalized non-terminals are defined by the Java language grammar <ref> [Sun95a] </ref> and are not repeated here.
Reference: [Sun95b] <author> Sun Microsystems. </author> <title> The Java Virtual Machine Specification, release 1.0 beta edition, </title> <month> August </month> <year> 1995. </year> <note> Available at ftp://ftp.javasoft.com/docs/vmspec.ps.zip. </note>
Reference-contexts: In the following specification, we include section numbers from the original JVM specification <ref> [Sun95b] </ref> to indicate where changes are being made. (1.4) Objects whose type is statically understood to be a parameter type are always stored as 32-bit quantities on the stack and in local variables. The aload and astore bytecodes are used to access these variables, effectively treating them as references.
Reference: [Yel95] <author> Frank Yellin. </author> <title> Low-level security in Java, December 1995. </title> <booktitle> Presented at the Fourth International World Wide Web Conference, </booktitle> <month> Dec. </month> <year> 1995. </year> <month> 145 </month>
Reference-contexts: It is important that extensions for parameterized types not remove the ability to statically type check bytecodes. The standard Java bytecode verifier works by verifying one class at a time <ref> [Yel95] </ref>. A call to a method of another class is checked using a declaration of the signature of that method, which is inserted in the .class file by the compiler. When the other class is loaded dynamically, these declarations are checked to ensure that they match the actual class signature.
References-found: 21

