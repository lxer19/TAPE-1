URL: http://www.cs.indiana.edu/~dyb/papers/arity.ps
Refering-URL: http://www.cs.indiana.edu/~dyb/pubs.html
Root-URL: http://www.cs.indiana.edu
Email: (dyb@iuvax.cs.indiana.edu)  (hieb@iuvax.cs.indiana.edu)  
Title: A New Approach to Procedures with Variable Arity  
Author: R. KENT DYBVIG ROBERT HIEB 
Address: Bloomington, IN 47405  
Affiliation: Indiana University Computer Science Department  
Date: 3:3: 229-244, 1990  (Received: September, 1989) (Revised: January, 1990)  
Note: LISP AND SYMBOLIC COMPUTATION: An International Journal  c 1990 Kluwer Academic Publishers Manufactured in The Netherlands  Keywords:  
Abstract: This article presents a convenient and efficient procedural interface that allows the definition and use of procedures with optional arguments and indefinite numbers of arguments without resorting to the use of a language-dependent data structure in which to store the arguments. This interface solves many of the problems inherent in the use of lists in Lisp and Scheme to store indefinite numbers of arguments. Simple recursion can be used to consume such arguments without the complexity problems that are caused by the use of the Lisp procedure apply on argument lists. A natural extension to the interface to support multiple return values is presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bellot, P. and Jay, V. </author> <title> A theory for natural modelisation and implementation of functions with variable arity. </title> <booktitle> In Proceedings of the 1987 Conference on Functional Programming and Computer Architecture, </booktitle> <editor> Kahn, G., editor, </editor> <booktitle> Lecture Notes in Computer Science No. </booktitle> <month> 274 (September </month> <year> 1987) </year> <month> 212-233. </month>
Reference-contexts: We find fl expressions both simpler and more elegant in many cases. Bellot and Jay provide a combinator-based semantics for the equivalent of the lambda calculus extended to allow variable-arity functions <ref> [1] </ref>. They support "rest" arguments by extending the syntax and semantics of the 242 R. KENT DYBVIG, ROBERT HIEB lambda calculus to handle variable-arity functions directly. They also avoid commitment to a data structure for passing extra arguments.
Reference: [2] <author> Hewitt, C. E. and Smith, B. </author> <title> Towards a programming apprentice. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1, </volume> <month> 1 (March </month> <year> 1975) </year> <month> 26-45. </month>
Reference-contexts: For instance, Hewitt's PLASMA supports a mechanism superficially similar to ours, but defines all procedures to accept one argument. The argument may be an arbitrary list structure that the target procedure decomposes by pattern matching <ref> [2] </ref>. However, a more general solution is to proceed in the opposite direction, to totally divorce the fundamental control structures of a language from data structures and operations on those data structures.
Reference: [3] <author> Landin, P. J. </author> <booktitle> The next 700 programming languages. Communications of the ACM , 9, </booktitle> <month> 3 (March </month> <year> 1966) </year> <month> 157-166. </month>
Reference-contexts: We also describe a natural extension of this interface to handle multiple return values. In a 1965 paper, Landin calls ISWIM "an attempt to deliver Lisp from its eponymous commitment to lists" <ref> [3] </ref>. Although the concept of Lisp without lists seems paradoxical, most Lisp dialects provide alternative data structures and mechanisms for defining new data structures. It should be possible, ideally, to create a dialect of Lisp without lists.
Reference: [4] <author> Milner, R. </author> <title> A proposal for Standard ML. </title> <booktitle> Conference Record of the 1984 ACM Symposium on LISP and Functional Programming (August 1984) 184-197. </booktitle>
Reference-contexts: It is tempting to view fl as providing a limited sort of pattern matching and argument destructuring, such as provided by ML <ref> [4] </ref>. However, fl is intended to provide a representation-independent way to manipulate indefinite numbers of arguments without regard to the structure of the arguments themselves.
Reference: [5] <editor> Rees, J. A. and Clinger, W. (Ed.), </editor> <title> The revised 3 report on the algorithmic language scheme. </title> <journal> SIGPLAN Notices, </journal> <volume> 21, </volume> <month> 12 (December </month> <year> 1986) </year> <month> 37-79. </month>
Reference-contexts: 1 Introduction Many programming languages provide primitive procedures that are defined for variable numbers of arguments. Typically, however, the programmer is not provided with a convenient way to create new variable-arity procedures. Although Common Lisp [6] and Scheme <ref> [5] </ref> both allow the programmer to define variable-arity procedures, the resulting definitions are often unreadable or inefficient. <p> The generalization to a semantics with continuations, stores, and the extended value domain necessitated by a full treatment of Scheme is straightforward. A description of the syntax and semantics of Scheme can be found in <ref> [5] </ref>. The significant feature of the semantics for fl is that environments map variables to sequences of values rather than to single values. A fl expression with only one clause is comparable to a Scheme expression and evaluates to a procedure.
Reference: [6] <author> Steele, G. L. Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press (1984). </publisher>
Reference-contexts: 1 Introduction Many programming languages provide primitive procedures that are defined for variable numbers of arguments. Typically, however, the programmer is not provided with a convenient way to create new variable-arity procedures. Although Common Lisp <ref> [6] </ref> and Scheme [5] both allow the programmer to define variable-arity procedures, the resulting definitions are often unreadable or inefficient. <p> This copying will be done at most once for a given parameter list if procedures that pass rest values to unknown procedures maintain the values as a linked list. 5 Multiple Return Values The section on multiple return values in Common LISP: The Language <ref> [6] </ref> begins, "Normally, multiple values are not used." Although this may be because multiple values are not often useful, a further reason might be that none of the ordinary Lisp constructs are easily adapted for receiving multiple values. Fortunately, the fl interface adapts easily to multiple return values.
References-found: 6

