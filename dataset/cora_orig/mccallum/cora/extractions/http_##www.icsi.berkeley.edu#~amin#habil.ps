URL: http://www.icsi.berkeley.edu/~amin/habil.ps
Refering-URL: http://www.icsi.berkeley.edu/~amin/RES.html
Root-URL: http://www.icsi.berkeley.edu
Title: Preface  
Abstract: The past few years have witnessed exciting discoveries in different areas of coding theory and computational number theory. The present monograph, which exhibits the author's "Habilitationsschrift," is a collection of five different topics dealing with these two important fields. We will start with a purely coding theoretic question and finish with a discussion of some problems from computational number theory. Along the way, we will gradually change our focus from coding theory to number theory. Our emphasis is almost entirely on the development of fast and practical algorithms for the problems involved. In many cases it turns out that having a view for both number theory and coding theory is a clear advantage. This is best demonstrated by Chapters 2 and 3, where we encounter most of the interrelations between coding and number theory. We start our journey with one of the most exciting modern communication media, the Internet. Studies show that the Internet exhibits bursty and transient packet losses, and that the situation has become worse in recent years. Many applications, like video multicast, or simple data distribution suffer seriously from this difficulty. One of the strategies to solve this problem is to use linear codes. Demanding new applications such as multimedia, disk farms, or NC-computers are making this strategy exceedingly attractive. However, use of existing codes to protect large amounts of information like one or several video frames calls for expensive hardware solutions. In Chapter 1 we design a new class of codes that have extremely efficient encoding and loss-recovery algorithms. This makes them excellent candidates for protection of information against losses in high speed computer networks. The codes are built from a cascade of random sparse bipartite graphs, with carefully chosen node-degree distributions. These distributions are obtained from a simulation of the recovery process as a discrete random process. An exact analysis of the behavior of this process, paired with a sharp concentration result yields explicit conditions on the node-degree distributions which each of the bipartite graphs has to satisfy in order for the recovery process to finish successfully. On high quality workstations, first implementations of these codes reach throughputs of up to 250 Mbit/sec, which is far above the throughput required for many of the targeted applications, like transmission of high quality video (requiring throughputs of 30MB/sec). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R.C. Agarwal and C.S. Burrus. </author> <title> Fast convolution using Fermat number transforms with applications to digital filtering. </title> <journal> IEEE Trans. Acoust., Speech, Signal Processing, </journal> <volume> ASSP-22:87-97, </volume> <year> 1974. </year>
Reference-contexts: Taking the derivative we obtain g 0 (x) = (3N 1)(6N 1)x 3N2 3N (6N 3)x 3N1 + 1 &lt; 0 for x 2 <ref> [0; 1] </ref>. Hence, g is monotonically decreasing in [0; 1]. Furthermore, g 0 (1) = 1, and g (1) = 0. Hence, g (x) is positive in [0; 1]. <p> Taking the derivative we obtain g 0 (x) = (3N 1)(6N 1)x 3N2 3N (6N 3)x 3N1 + 1 &lt; 0 for x 2 <ref> [0; 1] </ref>. Hence, g is monotonically decreasing in [0; 1]. Furthermore, g 0 (1) = 1, and g (1) = 0. Hence, g (x) is positive in [0; 1]. <p> the derivative we obtain g 0 (x) = (3N 1)(6N 1)x 3N2 3N (6N 3)x 3N1 + 1 &lt; 0 for x 2 <ref> [0; 1] </ref>. Hence, g is monotonically decreasing in [0; 1]. Furthermore, g 0 (1) = 1, and g (1) = 0. Hence, g (x) is positive in [0; 1]. Since f is decreasing in the right neighborhood of 0, and it is convex, it follows that f has exactly one local minimum in [0; 1) which is its absolute minimum. (2) Next we prove that f 0 ( N p 2=3) &gt; 0. <p> For N with 2 N 22 we can check (1.28) directly. (3) Note that ffi (1 x 3N1 ) 2 =N &lt; 1 x for all x 2 <ref> [0; 1] </ref> if and only if (1 ffix 2 =N ) 3N1 &gt; 1 x for all x 2 [0; 1]. Furthermore, (1 a=n) n e a (1 a=n) a e a (1 a 2 =n). Now let ffi := 0:81. <p> For N with 2 N 22 we can check (1.28) directly. (3) Note that ffi (1 x 3N1 ) 2 =N &lt; 1 x for all x 2 <ref> [0; 1] </ref> if and only if (1 ffix 2 =N ) 3N1 &gt; 1 x for all x 2 [0; 1]. Furthermore, (1 a=n) n e a (1 a=n) a e a (1 a 2 =n). Now let ffi := 0:81. We have (1 ffix 2 =N ) 3N1 1 + x ffi 2 e 3ffix 2 1 + x 0:99e 3ffix 2 1 + x for N 66. <p> We have (1 ffix 2 =N ) 3N1 1 + x ffi 2 e 3ffix 2 1 + x 0:99e 3ffix 2 1 + x for N 66. It is easily seen that the right hand side of the above inequality is positive in the interval <ref> [0; 1] </ref>, which proves the assertion for N 66. For N &lt; 66 the result can be verified directly. 2 Note that Part (3) of the last proposition proves the second part of Theo rem (1.26). <p> An [n; k; e; b] q -code is an [n; k] q -code such that the Hamming sphere of radius e around any y 2 F n q contains at most b codewords. * For example, note that an [n; k; 2e + 1] q -code is an <ref> [n; k; e; 1] </ref> q -code. The decoding task associated with an [n; k; e; b] q -code requires methods quite different from those customarily employed for error-correction. This task was first considered by Sudan [149, 150], who investigated alternative decoding algorithms for Reed-Solomon codes. <p> This application is carried out in Section 2.5. The bottleneck of our algorithm is the factorization routine. In Section 2.6 we derive for small b variants of our general algorithm in which the factorization step has been eliminated. One variant, which corresponds to the case of decoding <ref> [n; k; e; 1] </ref> q -codes (i.e., conventional decoding), is particularly interesting. It is slightly less powerful than existing AG-decoding algorithms, as it can correct only up to (d fl 1)=2 g errors. However, its implementation only requires solving an n fi (n + 1) system of linear equations. <p> Moreover, we will show in Section 2.8 that, if a large fraction of the letters of a codeword are corrupted by noise which is random in a specified sense, it may be possible to uniquely decode. This inspires us to speak of an <ref> [n; k; e; 1] </ref> p q -code, which is defined to be an [n; k] q -code such that, with probability of failure p, a codeword may be uniquely reconstructed after up to e of its letters have been replaced with uniform-random letters. <p> <ref> [n; k; e; 1] </ref> p q -code, which is defined to be an [n; k] q -code such that, with probability of failure p, a codeword may be uniquely reconstructed after up to e of its letters have been replaced with uniform-random letters. We will demonstrate that there exist constant-rate [n; k; e; 1] p q -AG-codes for which e is surprisingly close to n while p is very small. We also specify a corresponding decoding algorithm, which does not require polynomial factorization and hence is particularly efficient. <p> In Section 2.10 we investigate asymptotic properties of [n; k; e; b] q -codes. We define analogues of the function ff q [83, Def. 5.1.2] for our new classes of [n; k; e; b] q - codes and <ref> [n; k; e; 1] </ref> p q -codes, and derive lower bounds for these functions by creating asymptotically good sequences of AG-codes. One of the crucial time-parameters of our decoding algorithms is the size of the basis functions used for encoding. <p> Proof. The proof is as for Theorem (2.2), except that we use s := b and the new value of fi. 2 The cases b = 1 and b = 2 of the above theorem will be of particular interest. Recall that <ref> [n; k; e; 1] </ref> q -codes are those for which a codeword may be conventionally (i.e., uniquely) reconstructed after the corruption of up to e letters. Therefore, we will refer to the case b = 1 as the unique reconstruction case. <p> We start with the unique reconstruction case. Setting b = 1 in the previous theorem yields the following. (2.14) Corollary. Let C be an [n; k; d] q -AG-code built over an algebraic function field of genus g, and let ff := k+g1. Then C is an <ref> [n; k; b (nff1)=2gc; 1] </ref> q -code. We saw in Section 2.2 that AG-codes have designed distance d fl = n ff, and thus have designed error-correction bound e fl := b (d fl 1)=2c = b (n ff 1)=2c. <p> In the next two sections, we respond to this argument. Here we consider the possibility that, if noise is assumed to be random in a specified sense, then a codeword x may be uniquely reconstructed from its highly noisy corruption y. We fix the following definition: (2.19) Definition. An <ref> [n; k; e; 1] </ref> p q -code is an [n; k] q -code such that, after up to e letters of a codeword x have been replaced with uniform-random letters, x may be uniquely reconstructed, with probability of failure at most p. * Our model of random noise is thus that <p> Let C be an [n; k; d] q -AG-code built over an algebraic function field of genus g. Let ff := k + g 1 and fi := d p ffn + g 1e. Then for any ffi &gt; 0, C is an <ref> [n; k; e; 1] </ref> p q -code, where e := bn ffin 2fi fin=(ffq) ff 2g 1c;(2.22) p := 2 exp (ffi 2 n=2) + 2 exp (ffi 2 n):(2.23) Moreover, the associated decoding task can be accomplished efficiently using Algo rithm (2.24) below. Proof. <p> Theorem (2.21) then tells us that, using this 59 2.9. Unique Decoding via Cryptographic Signatures field and picking n := 10 6 , k := 10 4 , ffi := 0:01, we can create an <ref> [n; k; 642790; 1] </ref> p code, where p is less than 10 21 . <p> We also set ! q := b=1 b q . We similarly define R q to be the set of all (*; R) such that for any n 0 2 N there exist <ref> [n; k; e; 1] </ref> p q -codes for which n n 0 , (e=n; k=n) is arbitrarily close to (*; R), and p is upper-bounded by an exponentially small function of n. 60 Chapter 2. <p> Decoding Algebraic Geometric Codes Observe that 1 q is precisely the set of all (*; R) such that (2*; R) 2 q . Fur thermore, we have obvious inclusions 1 q R q b 0 The function ff q : <ref> [0; 1] </ref> ! [0; 1], defined in [83, Def. 5.1.2], describes the boundary of q . To be precise, q is the set of all (ffi; R) such that R ff q (ffi). <p> Decoding Algebraic Geometric Codes Observe that 1 q is precisely the set of all (*; R) such that (2*; R) 2 q . Fur thermore, we have obvious inclusions 1 q R q b 0 The function ff q : <ref> [0; 1] </ref> ! [0; 1], defined in [83, Def. 5.1.2], describes the boundary of q . To be precise, q is the set of all (ffi; R) such that R ff q (ffi). <p> Hence we also ask: (5) Is there a variant of our conventional decoding algorithm which can correct up to (d fl 1)=2 errors? Restricting ourselves to a model of random noise, we have also introduced <ref> [n; k; e; 1] </ref> p q -codes, and have demonstrated that there exist [n; k; e; 1] p q -AG-codes for which e is close to n while k=n is bounded away from zero and p is very small. <p> Hence we also ask: (5) Is there a variant of our conventional decoding algorithm which can correct up to (d fl 1)=2 errors? Restricting ourselves to a model of random noise, we have also introduced <ref> [n; k; e; 1] </ref> p q -codes, and have demonstrated that there exist [n; k; e; 1] p q -AG-codes for which e is close to n while k=n is bounded away from zero and p is very small. <p> In Section 2.10 we constructed asymptotically good sequences of [n; k; e; b] q - codes and <ref> [n; k; e; 1] </ref> p q -codes over a fixed field F q . We introduced the functions fi b q , q , and fi R q , which are natural variants of the well-known function ff q . Manin [88] has proved the continuity of ff q . <p> Any improvement of fixed-point computation so as to be more robust and accurate could lead to significantly less expensive chips in high precision FFT processors. These issues have led to suggestions for alternate FFT computations by many scientists <ref> [1, 30, 35, 114, 116, 117, 118] </ref>. Much of the research has concentrated on Residue Number System (RNS) processors. <p> T 1 = 8 B @ 2 3 2 1 2 3 2 1 C A : * P 2 n2 1 n let L 1 (a) := max jff i j fi o Stated in terms of this function, our problem is to approximate a given real number in <ref> [0; 1] </ref> by an element a 2 Z [ n ] + with L 1 (a) M . L 1 (a) is related to the different conjugates of a in the following way. (4.10) Lemma. For a 2 K + n we have L 1 (a) 2 n2 i=0 Proof. <p> Since ` is a nonzero integer, we have j`j 1, which implies the assertion. 2 105 4.5. Approximation by 8th Roots of Unity 4.5 Approximation by 8th Roots of Unity As a warm-up, we will in this section design an algorithm for approximating real numbers in the interval <ref> [0; 1] </ref> by real elements in the ring of 8th roots of unity. In particular, we will prove Theorem (4.2) for the case n = 3. As was described earlier in the introduction, our algorithm will work in levels, using constant time at each level. <p> Let k 1, M P k , a = ff 0 + ff 1 p p " i := (1 + 2) i . If (1) k ff 0 0, then a + " k1 2 Z [ p then a + " k 2 Z <ref> [ p Proof. Since a 2 [0; 1] </ref>, ff 0 0 is equivalent to ff 1 0. Suppose that (1) k ff 0 0. <p> If (1) k ff 0 0, then a + " k1 2 Z [ p then a + " k 2 Z [ p Proof. Since a 2 <ref> [0; 1] </ref>, ff 0 0 is equivalent to ff 1 0. Suppose that (1) k ff 0 0. Then ff 0 (1) k1 P k1 &lt; 0, which shows that jff 0 + (1) k1 P k1 j &lt; maxfjff 0 j; P k1 g M . <p> Similarly, jff 1 (1) k1 Q k1 j M . The case (1) k ff 0 &lt; 0 is handled analogously. 2 (4.21) Theorem. On input ! 2 <ref> [0; 1] </ref>, Algorithm ABS8 computes a with 0 ! a (1 + 2)=P ` in at most 3` iterations. Proof. Let M := P ` . Lemma (4.20) assures that a 2 Z [ p 2] M . <p> The General Approximation Algorithm ABS8 (!; M) Precomputation: " 0 ; : : : ; " ` where " i = (1 + p Input: ! 2 <ref> [0; 1] </ref>. <p> tion, and one for computing the distance to !), we obtain the upper bound of 12 log 1+ 2 (M ) &lt; 10 log (M ) given in the introduction. 4.6 The General Approximation Algorithm In this section we describe a general procedure to approximate real numbers in the interval <ref> [0; 1] </ref> by real elements of Z [ n ], and prove Theorem (4.2). We adopt the notation of the previous sections, and set m = 2 n2 . Given ! 2 [0; 1] and some M 2 N, our aim is to find a = P i ff i i <p> General Approximation Algorithm In this section we describe a general procedure to approximate real numbers in the interval <ref> [0; 1] </ref> by real elements of Z [ n ], and prove Theorem (4.2). We adopt the notation of the previous sections, and set m = 2 n2 . Given ! 2 [0; 1] and some M 2 N, our aim is to find a = P i ff i i 2 Z [ n ] + such that L 1 (a) M and j! aj c M m1 for some constant c (possibly depending on n). <p> k+m1 ) = " (k) (b) 8" 2 E: i=0 j" (i) j 2 maxconj ("), (c) max 2m2 l=1 maxconj (" l ) M , We first show that if E has the above properties, then for an arbitrary element a in Z [ n ] + M " <ref> [0; 1] </ref> there always exists " 2 E such that a + " 2 Z [ n ] + M . Roughly speaking, one has to choose from E an element " that has its maximum conjugate at the same position as a, but with a different sign. <p> The General Approximation Algorithm GAA (!; M) Precomputation: Sets E 2 k for 0 k blog (L)c as described above. Input: ! 2 <ref> [0; 1] </ref>, M L, M 2 N. <p> It should be noted that restriction to ! 2 <ref> [0; 1] </ref> is not essential. Actually, for any ! 2 [0; M=2] we can compute an approximation a 2 Z [ n ] + M in the following way. <p> Hence wt (1 3 ) = f3; 2; 1g. The following properties of the sgn-function can be easily verified. (4.30) Remark. Let a = P 3 i=0 ff i i 2 Z [] + " <ref> [0; 1] </ref>. <p> This reduced computing the value of an approximation to floating point addition. 118 Chapter 4. Precise and Fast Fourier Transforms ABS16 (!; M ) Precomputation: Sets E 2 k for 0 k blog (L)c as described above. Input: ! 2 <ref> [0; 1] </ref>, M L, M 2 N. <p> The first column corresponds to M , the second contains the theoretical upper bound on the number of iterations as given in Theorem (4.21), and the third column gives the maximum number of iterations encountered for 1000 runs on random numbers in <ref> [0; 1] </ref>. The fourth column shows the upper bound on the worst case error which is equal to 3 (1 + p 2) 2 =(2M ), and finally, the last column shows the maximum error observed during the approximation of the random numbers. <p> Using this technique, we get, e.g., the approximation 1 (8120 2856e 2i=8 4080e 4i=8 + 8626e 6i=8 ) with an error less than 10 9 . Our algorithm runs fast in practice. For instance, 100000 approximations of random numbers in the interval <ref> [0; 1] </ref> took 0.7 seconds on a SPARC-5. Due to its simple form, it is well suited for real time applications when combined with scaling methods. 119 4.8. <p> The results are summarized in Table 4.4. The entry in the third column in that table gives the maximum number of iterations performed for 1000 random numbers in the interval <ref> [0; 1] </ref>. For the implementation of ABS16 we deviated a little from the algorithm given in Section 4.7 by replacing the single addition steps by multi-steps obtained from multiplying the current unit by an appropriate multiple. <p> The theoretical upper bounds for the worst case running time (obtained via Theorem (4.23)) for different M are compared in Table 4.5 with the maximum number of iterations performed for 1000 random numbers in the interval <ref> [0; 1] </ref>. Again, we used our algorithm to approximate e 2i=1024 by elements of Z [e 2i=32 ] M for various M . Our approximation results are summarized in Table 4.6. <p> This table clearly shows the impressive change in dynamic range requirements when we switch from Z [e 2i=16 ] to Z [e 2i=32 ]. Compilation of Table 4.5 took 17 seconds on an ULTRASPARC-1. Note that it consists of 22000 approximations of real numbers in <ref> [0; 1] </ref>. Table 4.6 used 0.04 seconds. The tables also show that the bounds we have obtained on the range of the approximation is quite pessimistic. <p> Suppose that g is not normal. Then the number of "witnesses" p in the interval <ref> [1; k] </ref>, i.e., the number of p unramified in L and not dividing the discriminant of g such that g mod p has an inhomogeneous factorization pattern, is at least ff 3 (#W (U )=#G)(k= ln (k)) by Corollary (5.4). <p> Hence the condition in line (8) is never fulfilled, which means that Normal-Subfield always returns SUBFIELD. Suppose that K 6 M . Then using Corollary (5.5) and Part (3) of the above proposition, we see that the number of primes p in the interval <ref> [1; k] </ref> which fail the test in line (8) is at least ff 3 k=(2n ln (k)). (Note that we have the inequality k ff 2 (n!m ln (disc (g)disc (h)) ff 1 .) We obtain the assertion on the error probability of our algorithm as in the proof of Theorem
Reference: [2] <author> A. Albanese, J. Blomer, J. Edmonds, M. Luby, and M. Sudan. </author> <title> Priority encoding transmission. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 42 </volume> <pages> 1737-1744, </pages> <year> 1996. </year>
Reference-contexts: Such a scheme can be used as the basic building block for the more robust and general protection scheme described in <ref> [2] </ref>. To demonstrate the benefits of forward error-correction in a simplified setting, consider the Internet loss measurements performed by [169] involving a multicast by one sender to a number of geographically distributed receivers. <p> These codes have recently been customized to compensate for Internet packet loss in real-time transmission of moderate-quality video <ref> [2] </ref>. Even this optimized 1 This is twice the average loss rate, but due to the bursty nature of losses in the Internet it is still likely that the maximum loss rate per block exceeds 20%. One can use the results of [2] to simultaneously protect against various levels of loss <p> packet loss in real-time transmission of moderate-quality video <ref> [2] </ref>. Even this optimized 1 This is twice the average loss rate, but due to the bursty nature of losses in the Internet it is still likely that the maximum loss rate per block exceeds 20%. One can use the results of [2] to simultaneously protect against various levels of loss while still keeping the overall redundancy modest. 3 1.1. Introduction implementation required the use of dedicated workstations. Transmission of significantly higher quality video requires faster coding algorithms. <p> However, its implementation only requires solving an n fi (n + 1) system of linear equations. Because of its simplicity, we feel that this algorithm is of independent interest. Another variant corresponds to the case of de coding <ref> [n; k; e; 2] </ref> q -codes. We find that the small increase from b = 1 to b = 2 leads 45 2.2. AG-Codes to a substantial result, allowing us to reconstruct after a number of errors which may approach 2n=3.
Reference: [3] <author> N. Alon and M. Luby. </author> <title> A linear time erasure-resilient code with nearly optimal recovery. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 42 </volume> <pages> 1732-1736, </pages> <year> 1996. </year>
Reference-contexts: They can also be encoded in time proportional to n ln (1=*). The fastest previously known encoding and decoding algorithms <ref> [3] </ref> with such a performance guarantee have run times proportional to n ln (1=*)=*. The overall structure of our codes are related to codes introduced in [145] for error-correction. We explain the general construction along with the encoding and decoding algorithms in Section 1.3.
Reference: [4] <author> E. Bach and J. Shallit. </author> <title> Algorithmic Number Theory. </title> <publisher> MIT Press, </publisher> <address> Cambridge MA, </address> <year> 1996. </year>
Reference-contexts: Proof. We may suppose that M 6= Q since the number (x) of primes less than or equal to x is lower bounded by x= ln (x) for x 17, see <ref> [4, Th. 8.8.1] </ref>. <p> Then K is cyclic if and only if W 6= ;. Hence, every prime p unramified in K such that Frob K (p) W is a witness for K being cyclic. Proof. Easy (for a lower bound on '(n) see <ref> [4, Th. 8.8.7] </ref>). 2 Algorithm Cyclic (g) is given in Figure 5.6. We first test whether K is normal. If we can assume that K is normal with a sufficiently high probability, then we try to sample a prime p such that g mod p is irreducible.
Reference: [5] <author> E. Bach and J. Shallit. </author> <title> Explicit bounds for primes in residue classes. </title> <journal> Math. Comp., </journal> <volume> 65 </volume> <pages> 1717-1735, </pages> <year> 1996. </year>
Reference-contexts: The constants given in the last theorem are far from optimal. One could use techniques from <ref> [5] </ref> to optimize them. * 138 Chapter 5.
Reference: [6] <author> C. Batut, D. Bernardi, H. Cohen, and M. Olivier. </author> <title> User's Guide to PARI-GP. </title> <institution> Universite Bordeaux, 351 Cours de la Liberation, </institution> <month> May </month> <year> 1995. </year> <note> Obtainable via anonymous ftp from megrez.math.u-bordeaux.fr. </note>
Reference-contexts: We checked these values against those computed independently by the classno () routine of PARI <ref> [6] </ref>, and did not observe any mismatches. <p> The resulting ILP's were solved by the integer linear programming Package lp_solve [7]. All the computations in the field Q (e 2i=32 ) including those of the units were done with the package PARI <ref> [6] </ref>. For each element found in this way, we also computed and stored all the conjugates. This data was used by the approximation algorithm to reduce computing the conjugates of the approximations to table-lookups and additions/subtractions.
Reference: [7] <author> M. Berkelaar. </author> <note> lp_solve 2.0 release. michel@es.ele.tue.nl. </note>
Reference-contexts: The same comment applies to the implementations described below. 4.8.2 16th roots of Unity The units giving rise to the sets E 2 k were computed by solving the integer linear programming problems of Section 4.7. The resulting ILP's were solved by the integer linear programming Package lp_solve <ref> [7] </ref>. Using these units we computed upper bounds for theoretical worst case running times (in terms of the number of iterations) of the approximation algorithm as given in Theorems (4.23) and (4.37). The results are summarized in Table 4.4. <p> The resulting ILP's were solved by the integer linear programming Package lp_solve <ref> [7] </ref>. All the computations in the field Q (e 2i=32 ) including those of the units were done with the package PARI [6]. For each element found in this way, we also computed and stored all the conjugates.
Reference: [8] <author> E.R. Berlekamp. </author> <title> Algebraic Coding Theory. </title> <publisher> Mc Graw-Hill, </publisher> <address> New York, </address> <year> 1968. </year>
Reference-contexts: Furthermore, there exist very efficient software and hardware encoding and decoding algorithms for these codes which can correct up to the true minimum distance. Decoding RS-codes boils down to finding the generating polynomial of a linearly generated sequence. For this, one usually employs the so-called Berlekamp-Massey algorithm <ref> [8, 89] </ref>. The running time of this algorithm is quadratic in the block-length of the code, but it has a very efficient hardware implementation, as it only uses linear feed back shift registers, see [8] and [87, Ch. 9,x6]. <p> For this, one usually employs the so-called Berlekamp-Massey algorithm [8, 89]. The running time of this algorithm is quadratic in the block-length of the code, but it has a very efficient hardware implementation, as it only uses linear feed back shift registers, see <ref> [8] </ref> and [87, Ch. 9,x6].
Reference: [9] <author> E.R. Berlekamp. </author> <title> Bounded distance+1 soft decision Reed-Solomon decoding. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 42 </volume> <pages> 704-720, </pages> <year> 1996. </year>
Reference-contexts: We remark that in the case of the rational function field, this simplified algorithm is almost identical to the Welch-Berlekamp algorithm for decoding Reed-Solomon codes <ref> [9] </ref>. In fact, the Welch-Berlekamp algorithm computes the functions u 0 and u 1 (which are polynomials in this case) with O (n 2 ) F q -operations (instead of O (n 3 )).
Reference: [10] <author> E.R. Berlekamp, R.J. McEliece, and H.C.A. van Tilborg. </author> <title> On the inherent intracability of certain coding problems. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 24 </volume> <pages> 384-386, </pages> <year> 1978. </year>
Reference-contexts: Codes for which equality holds in (1.2) are called maximum distance separable codes, or MDS-codes for short. From an algorithmic point of view, erasure recovery and decoding are completely different in nature. The decoding problem for general linear codes is NP-complete <ref> [10, 156] </ref>. However, erasure recovery can be performed efficiently for any linear code, as is shown by the next result. (See also [39].) (1.3) Proposition. <p> Section 2.11 provides a hint in this direction: we will prove that, for the case of F 3 , S is indeed polynomial in n. * (2.12) Example. Using F m =F 101 2 and setting k := b0:01nc, we can create an <ref> [n; k; b0:79nc; 10] </ref> 101 2-AG-code.
Reference: [11] <author> E.R. Berlekamp, R.E. Peile, and S.P. Pope. </author> <title> The application of error control to communications. </title> <journal> IEEE Communications Magazine, </journal> <volume> 25 </volume> <pages> 44-57, </pages> <year> 1987. </year> <note> 159 BIBLIOGRAPHY </note>
Reference-contexts: However, RS-codes are usually used for their excellent error correction capabilities, rather than as erasure codes. Typical applications of these codes include CD-players, DAT-recorders, or satellite and deep space communication. For an excellent survey on practical uses of this important class of codes, the reader is referred to <ref> [11, 168, 165] </ref>. RS-codes are very attractive for various reasons: they are MDS-codes which means that they have the largest possible minimum distance for a given block length and a given dimension; this makes them natural candidates for decoding bursts of errors [87, Ch. 10,x6].
Reference: [12] <author> J. Blomer, M. Kalfane, R. Karp, M. Karpinski, M. Luby, and D. Zuckerman. </author> <title> An XOR-based erasure-resilient coding scheme. </title> <type> Technical Report TR-95-048, </type> <institution> International Computer Science Institute, </institution> <year> 1995. </year>
Reference-contexts: It is well-known that this matrix is totally regular. Furthermore, inverses of `fi`-Cauchy matrices can be determined explicitly in time O (` 2 ) <ref> [12, 113] </ref>. Based on this, the authors of [12] have designed a systematic encoder for an [n; k] q -MDS-code. Their particular implementation requires q to be a power of 2. This makes the encoding and loss recovery particularly efficient in software, as only XOR-operations are used. <p> It is well-known that this matrix is totally regular. Furthermore, inverses of `fi`-Cauchy matrices can be determined explicitly in time O (` 2 ) [12, 113]. Based on this, the authors of <ref> [12] </ref> have designed a systematic encoder for an [n; k] q -MDS-code. Their particular implementation requires q to be a power of 2. This makes the encoding and loss recovery particularly efficient in software, as only XOR-operations are used. For this reason, the authors call these codes XOR-Codes.
Reference: [13] <author> L.I. </author> <title> Bluestein. A linear filtering approach to the computation of the discrete Fourier transform. </title> <journal> IEEE Trans. Electroacoustics, </journal> <volume> 18 </volume> <pages> 451-455, </pages> <year> 1970. </year>
Reference-contexts: The standard procedure to solve this problem is to employ a technique known as Bluestein's trick <ref> [13] </ref>: as 77 3.6. Values of Polynomials on Cosets of Subgroups of F fi q (p 1)=d is even, there exists v 2 F q such that v 2 = u.
Reference: [14] <author> A. Borodin and R. Moenck. </author> <title> Fast modular transforms. </title> <journal> J. Comp. Syst. Sci., </journal> <volume> 8 </volume> <pages> 366-386, </pages> <year> 1974. </year>
Reference-contexts: We will design in Section 3.6 fast algorithms for evaluating a polynomial over a finite field at a given coset of a subgroup of the group of nonzero elements of the field. This algorithm is inspired by the multiple evaluation algorithm of Borodin and Moenck <ref> [14] </ref>. The new idea that makes the algorithm practically fast is the use of the roots of unity which already exist in the finite field. This evaluation algorithm is the main subroutine for computing both irregular primes, and the relative class number of cyclotomic fields. <p> this algorithm is clearly dominated by the time needed to multiply two integers of bit-length dm, which, using the Schonhage-Strassen algorithm [130], is O 3.6.2 Second Version of the Algorithm A major improvement can be gained by employing an idea related to the multiple evaluation algorithm of Borodin and Moenck <ref> [14] </ref> and [21, Chapter 3]. Let d = q 1 q t .
Reference: [15] <author> J. Buchmann. </author> <title> Complexity of algorithms in algebraic number theory. </title> <editor> In R.A. Mollin, editor, </editor> <booktitle> Proceedings of the First Conference of the Canadian Number Theory Association held in Banff, Alberta, </booktitle> <pages> pages 37-53. </pages> <publisher> de Gruyter, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: Furthermore, the definition of the discriminant shows that given the ring of integers, we can easily compute the discriminant in polynomial time which shows that DISC ROI. Another result we will need later for our investigations is the following one, due to Buchmann and Lenstra [16]. (See also <ref> [15, pp. 47-48] </ref>.) (5.25) Fact.
Reference: [16] <author> J. Buchmann and H.W. Lenstra. </author> <title> Approximating rings of integers in number fields. </title> <editor> J. de Theorie des Nombres de Bordeaux, </editor> <volume> 6 </volume> <pages> 221-260, </pages> <year> 1994. </year>
Reference-contexts: prove that this problem is polynomial time equivalent to that of computing the largest squarefree divisor of an integer, for which there is no efficient algorithm known at the present time. (For some practical advice on how to compute such a divisor, the reader is referred to Section 7 of <ref> [16] </ref>.) The model of computation that we will be using is that of a Turing machine. <p> of a number field; (DISC) Computing the discriminant of a number field; (OPF) Computing the product of primes dividing an integer to an odd power. * The equivalence of ROI and OPF is due to Chistov [24]. (The reduction used in this equivalence has been improved by Buchmann and Lenstra <ref> [16] </ref>.) Considering quadratic fields we see that OPF DISC. Furthermore, the definition of the discriminant shows that given the ring of integers, we can easily compute the discriminant in polynomial time which shows that DISC ROI. <p> Furthermore, the definition of the discriminant shows that given the ring of integers, we can easily compute the discriminant in polynomial time which shows that DISC ROI. Another result we will need later for our investigations is the following one, due to Buchmann and Lenstra <ref> [16] </ref>. (See also [15, pp. 47-48].) (5.25) Fact.
Reference: [17] <author> J. Buhler, R. Crandall, R. Ernvall, T. Metsankyla, and M.A. Shokrollahi. </author> <title> Irregular primes below 8 million. </title> <journal> J. Symb. Comp., </journal> <note> 1997. Submitted for publication. </note>
Reference-contexts: In addition, the computations of irregular pairs are the starting point for a verification of the Vandiver conjecture, see Section 3.7.2. Meanwhile we have extended these computation of irregular pairs to all primes below eight million <ref> [17, 135] </ref>. Our algorithm, which we will describe in later sections, is in part based on the following proposition. (3.16) Proposition.
Reference: [18] <author> J. Buhler, M.A. Shokrollahi, and V. Stemann. </author> <title> Fast and precise computations of Fourier transforms using cyclotomic integers. </title> <booktitle> In Proc. 29th STOC, </booktitle> <pages> pages 40-47, </pages> <year> 1997. </year>
Reference: [19] <author> J.P. Buhler, R.E. Crandall, R. Ernvall, and T. Metsankyla. </author> <title> Irregular primes and cyclotomic invariants to four million. </title> <journal> Math. Comp., </journal> <volume> 61 </volume> <pages> 151-153, </pages> <year> 1993. </year>
Reference-contexts: Associated to each irregular prime p there are the so-called cyclotomic invariants which describe the class groups of the cyclotomic fields with p-power conductor. These invariants are known up to four million as well, thanks to the work in <ref> [159, 40, 41, 19] </ref>. In addition, the computations of irregular pairs are the starting point for a verification of the Vandiver conjecture, see Section 3.7.2. Meanwhile we have extended these computation of irregular pairs to all primes below eight million [17, 135]. <p> We also implemented a pure C-version of the third version. This version contained several strategies to deal with the huge amounts of memory needed for handling large d. The final convolution step at the leaves of the factor tree of d were performed using multisectioning strategies, see <ref> [19] </ref>. We ran this program on an ULTRASPARC with 167 MHz. <p> In this section we will report on two such applications, which, up to now have always accompanied the computations of the irregular pairs, see <ref> [19, 40, 41, 151, 159] </ref>. For n 1 let K n denote the cyclotomic field Q ( p n+1 ), and let h n and A n be the class number and p-class group of K n , respectively. <p> The same implementation has been used to compute the cyclotomic invariants up to four million <ref> [19] </ref>. It is clear that this method requires at least 4N bytes of memory for storing the quotients q a . Our slightly modified method reduces the memory requirement by a factor of 1/32, at the expense of some overhead in the computation. <p> Computation of the generator polynomial of Stickelberger codes combined with modern algorithms for basic computational problems resulted in the fastest known algorithms for computing irregular primes and relative class numbers. One of the main problems in previous approaches to computing irregular pairs <ref> [20, 19] </ref> was the management of memory issues for performing the convolutions. Our new method 92 Chapter 3.
Reference: [20] <author> J.P. Buhler, R.E. Crandall, and R.W. Sompolski. </author> <title> Irregular primes to one million. </title> <journal> Math. Comp., </journal> <volume> 59 </volume> <pages> 717-722, </pages> <year> 1992. </year>
Reference-contexts: The asymptotic running time of this algorithm is comparable to that of Buhler et al. <ref> [20] </ref>; however, if p 1 is only divisible by "small" prime divisors, this algorithm runs much faster. <p> The irregular pairs were computed for primes less than 125000 by [159] and then to 150000 by [151]. These algorithms were quadratic in the sense that the running time for a fixed prime p is proportional to p 2 : Buhler, Crandall, and Sompolski <ref> [20] </ref> were the first to invent an O (p 1+" )-algorithm for this task and used their method to extend the computations of irregular pairs to one million. <p> We used the two implementations to randomly cross-check the results of the two different algorithms. Besides these checks, we incorporated internal check-sum identities: the power series method of Buhler et al. used the identity P p3 1)B n 4 mod p derived in <ref> [20] </ref>. Our method was checked with the identity P t f (t) = (p 1)f (0)=2 holding for all polynomials f over F p of degree less than (p 1)=2, where t runs over the quadratic residues of F p . <p> Computation of the generator polynomial of Stickelberger codes combined with modern algorithms for basic computational problems resulted in the fastest known algorithms for computing irregular primes and relative class numbers. One of the main problems in previous approaches to computing irregular pairs <ref> [20, 19] </ref> was the management of memory issues for performing the convolutions. Our new method 92 Chapter 3.
Reference: [21] <author> P. Burgisser, M. Clausen, and M.A. Shokrollahi. </author> <title> Algebraic Complexity Theory, volume 315 of Grundlehren der Mathematischen Wissenschaften. </title> <publisher> Springer Verlag Heidelberg, </publisher> <year> 1996. </year>
Reference-contexts: Encoding of RS-codes is quite easy: separate evaluation of f at the ff i uses O (nk) operations over F q . This is comparable to the general encoding algorithm described above. However, one can use multiple evaluation techniques <ref> [21, Chap. 3] </ref> to obtain asymptotically better algorithms which use O (n log 2 (k) log log (k)) F q -operations. (This running time is obtained by applying the multiple evaluation algorithm of Horowitz [21, Cor. 3.22] dn=ke times.) By the Singleton inequality (1.2), the minimum distance of the above Reed-Solomon <p> However, one can use multiple evaluation techniques [21, Chap. 3] to obtain asymptotically better algorithms which use O (n log 2 (k) log log (k)) F q -operations. (This running time is obtained by applying the multiple evaluation algorithm of Horowitz <ref> [21, Cor. 3.22] </ref> dn=ke times.) By the Singleton inequality (1.2), the minimum distance of the above Reed-Solomon code is at most n k + 1. <p> This is already a substantial improvement over the general algorithm given in Proposition (1.3), at least if k is O (n). Here again, there exist asymptotically faster algorithms which use O (k log 2 (k) log log (k)) operations over F q <ref> [21, Cor. 3.20] </ref>. Summarizing our results we obtain: (1.4) Theorem. An [n; k] q -RS-code is capable of recovering up to n k erasures. Encoding and loss recovery can be performed using O (nk) and O (k 2 ) F q -operations, respectively. <p> Whether or not faster algorithms exist is an open problem. However, loss recovery for RS-codes amounts to polynomial interpolation, and there 9 1.3. Graph Codes is a lower bound of (n log (n)) for the nonscalar complexity of this problem <ref> [21, Ch. 8] </ref>. This makes the existence of faster recovery algorithms highly unlikely. To protect huge amounts of information without reference to the size of the packets used in a specific network, one has to look for other encoding schemes. <p> Asymptotically fast software implementations are based on variants of the extended Euclidean algorithm [23, 34, 91, 163]. (See also <ref> [21, Ex. 3.9] </ref>.) Their running time is O (n log 2 (n) log log (n)), where n is the block length of the code [21, Chap. 3]. The decoding algorithms of last section can be specialized to RS-codes in the following way. <p> Asymptotically fast software implementations are based on variants of the extended Euclidean algorithm [23, 34, 91, 163]. (See also [21, Ex. 3.9].) Their running time is O (n log 2 (n) log log (n)), where n is the block length of the code <ref> [21, Chap. 3] </ref>. The decoding algorithms of last section can be specialized to RS-codes in the following way. <p> Our algorithm uses O (n 2 + log (q)) operations in F q . This is obtained by adding the number of operations in each of the different steps: we need O (n 1+* ) F q - operations to compute the u i using fast interpolation <ref> [21, Chap. 3] </ref>. Further, we need O (n 2 ) operations to compute the coefficients of f from (2.18), as this is equivalent to solving a system of b equations which are in upper triangular form. <p> Its main step is an interpolation over an algebraic function field. Using standard matrix methods, this step can be performed in O (n 3 ) F q -operations. But observe that univariate interpolation takes only O (n 1+* ) F q -operations <ref> [21, Chap. 3] </ref>. This observation inspires us to ask: (4) Can the interpolation step of our algorithm be performed in O (n 2 ) or O (n 1+* ) F q -operations? 65 2.12. <p> is clearly dominated by the time needed to multiply two integers of bit-length dm, which, using the Schonhage-Strassen algorithm [130], is O 3.6.2 Second Version of the Algorithm A major improvement can be gained by employing an idea related to the multiple evaluation algorithm of Borodin and Moenck [14] and <ref> [21, Chapter 3] </ref>. Let d = q 1 q t . We first show how to recursively compute ~ f j := f mod j = 0; 1; : : : ; d=q t 1: start with f 0;0 := f = f mod (x d ff d ). <p> Patching all the information for various j together, we obtain a solution to Problem (3.18). The algorithm gives rise to a factor tree for d, similar to the tree obtained from the multiple evaluation algorithm of Borodin and Moenck. (Compare also <ref> [21, Chapter 3.3] </ref>.) A simple induction shows that computing the polynomials f i;j uses O (q 1 + + q t1 )d operations in F q . As described above, the evaluation at 78 Chapter 3. <p> A similar approach has been independently suggested by Jha [59]. As was described in the previous section, the running time of our algorithm is O which is comparable to the running time when using gcd-techniques <ref> [21, Chapter 3] </ref>. However, as our method is easier to implement, it is likely to be significantly faster than gcd-strategies. <p> Although we can not prove interesting lower bounds that are valid in the model of bit-complexity, we can prove reasonable lower bounds in the model of straight-line programs. For instance, Strassen's Degree Bound <ref> [21, Chapter 8] </ref> immediately yields an (d log d) lower bound for the problem of evaluating a generic polynomial of degree less than d at d points. <p> Below we shall derive an O (p log p) lower bound for this problem in the model of non-scalar complexity. In the sequel we will use the terminology of <ref> [21] </ref>. Let f be a polynomial of degree n with indeterminate coefficients over a field k and denote the field generated over k by the coefficients of f by K. <p> We are interested in a lower bound for the nonscalar complexity L (F ) of F over K. Let @ i denote the derivation morphism @=@x i of K (x 0 ; : : : ; x n1 ). By the Baur-Strassen derivative inequality <ref> [21, Chapter 7] </ref> we have 3L (F ) L (F; @ 0 F; : : :; @ n1 F ): Note that @ i F = F f 0 (x i )=f (x i ). <p> Our new method 92 Chapter 3. Cyclic Codes and Cyclotomic Fields has the advantage of allowing scalable memory usage in the following sense: adaptation of bilinear algorithms <ref> [21, Chapter 14] </ref> for multiplication of polynomials to our case reduces the degree of the polynomials to be multiplied to any desired degree. The overhead involved is the use of virtual memory to store the intermediate results in a bilinear computation. <p> For the analysis of our algorithms we will use some well known results gathered in this section. The reader can consult <ref> [21, Chapters 2 and 3] </ref> for a discussion of these topics and further references.
Reference: [22] <author> N.G. Chebotarev. </author> <title> Die Bestimmung der Dichtigkeit einer Menge von Primzahlen, welche zu einer gegebenen Substitutionsklasse gehoren. </title> <journal> Math. Ann., </journal> <volume> 95 </volume> <pages> 191-228, </pages> <year> 1926. </year>
Reference-contexts: To analyze the error probability of such an algorithm, we need to know W (x) := #fp 2 Pj p x; p unramified in L; Frob L (p) W g: A celebrated theorem of Chebotarev <ref> [22] </ref> states that asymptotically, as x goes to infinity, W (x) ~ (#W=#G)x= ln (x). In this section we will be interested in quantitative versions of this result for bounded x. 136 Chapter 5. Deciding Properties of Number Fields without Factoring (5.3) Lemma.
Reference: [23] <author> U. Cheng. </author> <title> On the continued fraction and Berlekamp's algorithm. </title> <journal> IEEE Trans. Inform. Theory, </journal> <pages> pages 541-544, </pages> <year> 1984. </year>
Reference-contexts: Asymptotically fast software implementations are based on variants of the extended Euclidean algorithm <ref> [23, 34, 91, 163] </ref>. (See also [21, Ex. 3.9].) Their running time is O (n log 2 (n) log log (n)), where n is the block length of the code [21, Chap. 3]. The decoding algorithms of last section can be specialized to RS-codes in the following way.
Reference: [24] <author> A.L. Chistov. </author> <title> The complexity of constructing the ring of integers of a global field. </title> <journal> Dokl. Akad. Nauk. SSSR, </journal> <volume> 306 </volume> <pages> 1063-1067, </pages> <year> 1989. </year> <title> English Translation: </title> <journal> Soviet Math. Dokl., </journal> 39:597-600, 1989. <volume> 160 </volume> BIBLIOGRAPHY 
Reference-contexts: Deciding Properties of Number Fields without Factoring (ROI) Computing the ring of integers of a number field; (DISC) Computing the discriminant of a number field; (OPF) Computing the product of primes dividing an integer to an odd power. * The equivalence of ROI and OPF is due to Chistov <ref> [24] </ref>. (The reduction used in this equivalence has been improved by Buchmann and Lenstra [16].) Considering quadratic fields we see that OPF DISC. Furthermore, the definition of the discriminant shows that given the ring of integers, we can easily compute the discriminant in polynomial time which shows that DISC ROI.
Reference: [25] <author> A.L. Chistov and D.Yu. Grigoriev. </author> <title> Polynomial-time factoring of multivariable polynomials over a general field. </title> <type> Technical report, </type> <institution> USSR Academy of Sciences, Steklov Mathematical Institute Leningrad, </institution> <year> 1982. </year>
Reference-contexts: This problem can be decided in polynomial time, by using factorization of polynomials over algebraic number fields <ref> [25, 74, 76, 69] </ref>: one factors g 2 K [T ], where K = Q [x]=(g) is the field generated by a root of g over Q.
Reference: [26] <author> M. Clausen and M.A. Shokrollahi. </author> <title> Dense Z-modules in C . Unpublished manuscript, </title> <year> 1988. </year>
Reference-contexts: We will start with the characterization of those complex numbers w such that Z [w] is dense in C , see Theorem (4.38). This theorem has been taken from Clausen and Shokrollahi <ref> [26] </ref>. It turns out that the necessary conditions for this to hold are also sufficient: if w is neither real nor an algebraic integer of degree 2 (in which case Z [w] is a lattice), then Z [w] is dense. (4.38) Theorem.
Reference: [27] <author> H. Cohen. </author> <title> A Course in Computational Algebraic Number Theory, volume 138 of Graduate Texts in Mathematics. </title> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Our algorithm for this task is an adaptation of a well-known procedure for factoring polynomials over number fields, as described in, e.g., <ref> [27, 69, 74] </ref>. Applying Theorem (2.2) to the asymptotically good sequence of Garcia-Stichtenoth function fields [48] allows us to construct sequences of [n; k; e; b] q 2 -codes having excellent parameters. This application is carried out in Section 2.5. The bottleneck of our algorithm is the factorization routine. <p> This example should serve as a prototype for how to proceed in the case of a general separable extension. 48 Chapter 2. Decoding Algebraic Geometric Codes We now continue with our solution, which adapts a well-known procedure for factoring univariate polynomials over number fields <ref> [27, 69, 74] </ref>. To each 2 K there corresponds a unique g 2 L [Y ] of degree less than deg (f) such that = g (!). <p> Alternatively, N () = a deg (f) Res (f; g ), where a is the leading coefficient of g and Res (f; g ) is the resultant of f and g <ref> [27, p. 332] </ref>. Note that N () is an element of L. Similarly, for G := P i T i 2 K [T ], N (G) 2 L [T ] is defined to be Q where runs over the same set as above. <p> The following lemma shows that factorization in K [T ] can be reduced to factor ization in L [T ]. Its proof can be found in <ref> [27, Lem. 3.6.3] </ref>. (2.6) Lemma. Suppose that G 2 K [T ] and its norm N 2 L [T ] are squarefree. Let N = N 1 N s be the factorization of N into irreducible elements of L [T ]. <p> Polynomial-Time Algorithms Proof. For each appearing in the definition of N (G) (there are [K: L] such 's), let (fi ;i ) be the roots of (G). By <ref> [27, Lem. 3.6.2] </ref>, N (G (T !)) is not squarefree iff there exist ; t; i; j such that = (fi ;i fi t;j )=(t (!) (!)). Hence the number of such is polynomial in [K: L] and deg (G). 2 (2.8) Theorem. <p> The proposition shows that the decomposition pattern of an unramified prime depends only on Frob L (p). How can we compute decomposition patterns? This is done by means of the following classical result due to Dedekind (see, e.g. <ref> [27, Th. 4.8.13] </ref>). (5.2) Fact. Suppose K is a number field given by g. Let p be a prime not dividing disc (g).
Reference: [28] <author> G.E. Collins, M. Mignotte, and F. Winkler. </author> <title> Arithmetic in basic algebraic domains. </title> <editor> In B. Buchberger, G. Collins, and R. Loos, editors, </editor> <booktitle> Computer Algebra. Symbolic and Algebraic Computation, </booktitle> <pages> pages 189-220. </pages> <publisher> Springer Verlag, </publisher> <address> second edition, </address> <year> 1982. </year>
Reference-contexts: Using fast methods, this step can be performed in time proportional to the length of the result multiplied by logarithmic factors, i.e., in time O (p log 4 (p)) <ref> [28] </ref>. As the number of divisors of p 1 is o (p), the Chinese remaindering step is negligible. Once the h e have been found, we compute the gcd of h and the different h e to obtain a partial factorization of h .
Reference: [29] <author> J.W. Cooley and J.W. Tukey. </author> <title> An algorithm for the machine calculation of complex Fourier series. </title> <journal> Math. Comp., </journal> <volume> 19 </volume> <pages> 297-301, </pages> <year> 1965. </year>
Reference-contexts: Evidently, direct computation of ^v uses O (L 2 ) complex operations. In their celebrated 1965 paper, Cooley and Tukey <ref> [29] </ref> (re-)discovered a method with cost O (L log (L)) for computing the discrete Fourier transform of a vector whose length L is a power of 2.
Reference: [30] <author> J.H. Cozzens and L.A. Finkelstein. </author> <title> Computing the discrete Fourier transform using residue number systems in a ring of algebraic integers. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 31(5) </volume> <pages> 580-588, </pages> <year> 1985. </year>
Reference-contexts: Any improvement of fixed-point computation so as to be more robust and accurate could lead to significantly less expensive chips in high precision FFT processors. These issues have led to suggestions for alternate FFT computations by many scientists <ref> [1, 30, 35, 114, 116, 117, 118] </ref>. Much of the research has concentrated on Residue Number System (RNS) processors. <p> The bottleneck of the standard RNS-approach is that it is not possible to approximate complex numbers by Gaussian integers with arbitrary precision, since the Gaussian integers form a discrete subset of the set C of complex numbers. In a pioneering paper Cozzens and Finkelstein <ref> [30] </ref> suggested that the fourth root of unity i could be replaced by a 2 n th root , n 3. Hence, Gaussian integers are replaced by integral linear combinations of . These constitute a ring which we call Z [].
Reference: [31] <author> R.E. Crandall. </author> <booktitle> Topics in Advanced Scientific Computing. </booktitle> <address> TELOS-publisher, </address> <publisher> Springer Verlag New York, </publisher> <year> 1996. </year>
Reference-contexts: However, as our method is easier to implement, it is likely to be significantly faster than gcd-strategies. Furthermore, as our algorithm can use prime factors of p 1, it is according to Crandall <ref> [31] </ref> most likely the "fastest algorithm known for completely resolving the irregular pairs." We employed Version 3 of our algorithm described in the last section to compute irregular pairs for 157,049 primes among the 256,631 primes between 4 and 8 million. <p> The remaining 99,582 primes were handled by the power series method run on a cluster of 100 Pentium based workstations at NeXT headquarters in Redwood City, California. The convolution algorithms involved are described in detail (including C source code) in <ref> [31] </ref>. We used the two implementations to randomly cross-check the results of the two different algorithms. Besides these checks, we incorporated internal check-sum identities: the power series method of Buhler et al. used the identity P p3 1)B n 4 mod p derived in [20].
Reference: [32] <author> C. Dahl. </author> <title> Fast decoding of codes from algebraic curves. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 40 </volume> <pages> 223-229, </pages> <year> 1994. </year>
Reference-contexts: This result was extended by Vladut [158] to any AG-code. Later, Justesen et al. [62] improved on their original procedure by designing an algorithm which could correct up to (d fl g=2 1)=2 errors using O (n 7=3 ) arithmetic operations. This result was generalized by Dahl <ref> [32] </ref> to arbitrary AG-codes. A separate algorithm was developed by Feng and Rao [42]. Their algorithm can correct up to (d fl 1)=2 errors using O (n 3 ) arithmetic operations.
Reference: [33] <author> H. Davenport and H. Hasse. </author> <title> Die Nullstellen der Kongruenzzetafunktion in gewissen zyklischen Fallen. </title> <journal> Journal reine angew. Math., </journal> <volume> 172 </volume> <pages> 151-182, </pages> <year> 1935. </year>
Reference-contexts: The number of rational points of these curves can be explicitly computed, once one knows their so-called Hasse-Weil numbers. It is more than a mere coincidence that these numbers have already been determined by Davenport-Hasse in the 1930's <ref> [33] </ref>: they are essentially the above Gaussian sums! This gives a more substantial insight into the deep connection between cyclic codes and cyclotomic fields. (See the papers [155, 67, 166] for a discussion of these and related results.) Inspired by these results the author took in [136] a different approach to
Reference: [34] <author> J.L. Dornstetter. </author> <title> On the equivalence between Berlekamp's and Euclid's algorithms. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 33 </volume> <pages> 428-431, </pages> <year> 1987. </year>
Reference-contexts: Asymptotically fast software implementations are based on variants of the extended Euclidean algorithm <ref> [23, 34, 91, 163] </ref>. (See also [21, Ex. 3.9].) Their running time is O (n log 2 (n) log log (n)), where n is the block length of the code [21, Chap. 3]. The decoding algorithms of last section can be specialized to RS-codes in the following way.
Reference: [35] <author> E. </author> <title> Dubois and A.N. Venetsanopoulos. The discrete Fourier transform over finite rings with application to fast convolution. </title> <journal> IEEE Trans. Comp., </journal> <volume> C-27:586-593, </volume> <year> 1978. </year>
Reference-contexts: Any improvement of fixed-point computation so as to be more robust and accurate could lead to significantly less expensive chips in high precision FFT processors. These issues have led to suggestions for alternate FFT computations by many scientists <ref> [1, 30, 35, 114, 116, 117, 118] </ref>. Much of the research has concentrated on Residue Number System (RNS) processors.
Reference: [36] <author> I. Duursma. </author> <title> Algebraic decoding using special divisors. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 39 </volume> <pages> 694-698, </pages> <year> 1993. </year>
Reference-contexts: Remarkably, their work also gives an improved bound on the minimum distance of AG-codes and shows that their algorithm can actually correct up to this bound. Since then several other papers have appeared on the subject of decoding, see <ref> [36, 37, 105, 112, 122] </ref> Most of these algorithms fail if the number of errors exceeds the designed error-correction bound (d fl 1)=2, and all of them fail if the number of errors is larger than the true error-correction bound (d 1)=2, where d is the minimum distance of the code.
Reference: [37] <author> D. Ehrhard. </author> <title> Achieving the designed error capacity in decoding algebraic-geometric codes. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 39 </volume> <pages> 743-751, </pages> <year> 1993. </year>
Reference-contexts: Remarkably, their work also gives an improved bound on the minimum distance of AG-codes and shows that their algorithm can actually correct up to this bound. Since then several other papers have appeared on the subject of decoding, see <ref> [36, 37, 105, 112, 122] </ref> Most of these algorithms fail if the number of errors exceeds the designed error-correction bound (d fl 1)=2, and all of them fail if the number of errors is larger than the true error-correction bound (d 1)=2, where d is the minimum distance of the code.
Reference: [38] <author> M. Eichler. </author> <title> Eine Bemerkung zur Fermatschen Vermutung. </title> <journal> Acta Arith., </journal> <volume> 11 </volume> <pages> 129-131, </pages> <year> 1965. </year> <title> BIBLIOGRAPHY </title>
Reference-contexts: If one can show that there always exist "short" relations, this would indicate that the dimension of these codes is probably not too small, and would yield an upper bound on the rank of the p-part of the class group. In the light of Eichler's result <ref> [38] </ref> this could also lead to a new proof of the first case of Fermat's Last Theorem. Computation of the generator polynomial of Stickelberger codes combined with modern algorithms for basic computational problems resulted in the fastest known algorithms for computing irregular primes and relative class numbers.
Reference: [39] <author> P. Elias. </author> <title> Coding for two noisy channels. </title> <booktitle> In Information Theory, Third London Symposium, </booktitle> <pages> pages 61-76, </pages> <year> 1955. </year>
Reference-contexts: We assume that the receiver knows the position of each received symbol within the stream of all encoding symbols. This is appropriate for the Internet, where packets are indexed. We adopt as our model of losses the erasure channel, introduced by Elias <ref> [39] </ref>, in which each encoding symbol is lost with a fixed constant probability p in transit independent of all the other symbols. This assumption is not appropriate for the Internet, where losses can be highly correlated and bursty. <p> However, losses on the Internet in general are not sensitive to the actual contents of each packet, and thus if we place the encoding into the packets in a random order then the independent loss assumption is valid. Elias <ref> [39] </ref> showed that the capacity of the erasure channel is 1 p and that a random linear code can be used to transmit over the erasure channel at any rate R &lt; 1 p. <p> From an algorithmic point of view, erasure recovery and decoding are completely different in nature. The decoding problem for general linear codes is NP-complete [10, 156]. However, erasure recovery can be performed efficiently for any linear code, as is shown by the next result. (See also <ref> [39] </ref>.) (1.3) Proposition. Encoding of codewords of an [n; k; d] q -code given by a generator matrix can be performed with O (nk), and recovery of d 1 or less erasures can be performed with O operations over F q . Proof.
Reference: [40] <author> R. Ernvall and T. Metsankyla. </author> <title> Cyclotomic invariants for primes between 125000 and 150000. </title> <journal> Math. Comp., </journal> <volume> 56 </volume> <pages> 851-858, </pages> <year> 1991. </year>
Reference-contexts: Associated to each irregular prime p there are the so-called cyclotomic invariants which describe the class groups of the cyclotomic fields with p-power conductor. These invariants are known up to four million as well, thanks to the work in <ref> [159, 40, 41, 19] </ref>. In addition, the computations of irregular pairs are the starting point for a verification of the Vandiver conjecture, see Section 3.7.2. Meanwhile we have extended these computation of irregular pairs to all primes below eight million [17, 135]. <p> In this section we will report on two such applications, which, up to now have always accompanied the computations of the irregular pairs, see <ref> [19, 40, 41, 151, 159] </ref>. For n 1 let K n denote the cyclotomic field Q ( p n+1 ), and let h n and A n be the class number and p-class group of K n , respectively. <p> We call p the -invariant. Suppose that A ord p (h Then, if Vandiver's conjecture is true for p, we obtain p = p = i (p); minimal n p = 0: (We refer to <ref> [40] </ref> and the references therein.) Ernvall and Metsankyla develop in [40] a computational method to decide whether (3.19) and (3.20) are true: for an integer a prime to p let q a denote the Fermat quotient of a, i.e., q a = p 83 3.7. <p> We call p the -invariant. Suppose that A ord p (h Then, if Vandiver's conjecture is true for p, we obtain p = p = i (p); minimal n p = 0: (We refer to <ref> [40] </ref> and the references therein.) Ernvall and Metsankyla develop in [40] a computational method to decide whether (3.19) and (3.20) are true: for an integer a prime to p let q a denote the Fermat quotient of a, i.e., q a = p 83 3.7.
Reference: [41] <author> R. Ernvall and T. Metsankyla. </author> <title> Cyclotomic invariants for primes to one million. </title> <journal> Math. Comp., </journal> <volume> 59 </volume> <pages> 249-250, </pages> <year> 1992. </year>
Reference-contexts: Associated to each irregular prime p there are the so-called cyclotomic invariants which describe the class groups of the cyclotomic fields with p-power conductor. These invariants are known up to four million as well, thanks to the work in <ref> [159, 40, 41, 19] </ref>. In addition, the computations of irregular pairs are the starting point for a verification of the Vandiver conjecture, see Section 3.7.2. Meanwhile we have extended these computation of irregular pairs to all primes below eight million [17, 135]. <p> In this section we will report on two such applications, which, up to now have always accompanied the computations of the irregular pairs, see <ref> [19, 40, 41, 151, 159] </ref>. For n 1 let K n denote the cyclotomic field Q ( p n+1 ), and let h n and A n be the class number and p-class group of K n , respectively.
Reference: [42] <author> G.L. Feng and T.R.N. Rao. </author> <title> Decoding algebraic-geometric codes up to the designed minimum distance. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 39 </volume> <pages> 37-45, </pages> <year> 1993. </year>
Reference-contexts: This result was generalized by Dahl [32] to arbitrary AG-codes. A separate algorithm was developed by Feng and Rao <ref> [42] </ref>. Their algorithm can correct up to (d fl 1)=2 errors using O (n 3 ) arithmetic operations. Remarkably, their work also gives an improved bound on the minimum distance of AG-codes and shows that their algorithm can actually correct up to this bound.
Reference: [43] <author> A. Frieze and S. Suen. </author> <title> Analysis of two simple heuristics on a random instance of k-SAT. </title> <journal> J. of Alg., </journal> <volume> 20 </volume> <pages> 312-355, </pages> <year> 1996. </year>
Reference-contexts: In the fist part of this section, we will state a general sharp concentration result. Such results have been obtained by Kurtz [66] who studied Markov jump processes, and have been used previously by many researchers, see <ref> [43, 64, 94, 95, 111, 167] </ref> and the references therein. We will, however, use a version due to Wormald [167] which has the advantage of being directly applicable to our situation. Next we will set up the appropriate system of differential equations, and solve them explicitly.
Reference: [44] <author> G. Fung, A. Granville, and H.C. Williams. </author> <title> Computation of the first factor of the class number of cyclotomic fields. </title> <journal> J. Number Theory, </journal> <volume> 42 </volume> <pages> 297-312, </pages> <year> 1992. </year>
Reference-contexts: This improves the algorithm of Fung et al. <ref> [44] </ref> which had a running time of O (p 2 log 4 (p)). <p> For instance, if p 3 mod 4, then h (p1)=2 is the class number of the quadratic field Q ( p p). Relative class numbers of cyclotomic fields of prime conductor have been computed for all primes below 3000 <ref> [44] </ref>. In the next sections we report on a new algorithm with which we could improve these computations to all primes below 10000. (3.17) Proposition. <p> In fact, Kummer conjectured in 1851 [65] that h (p) ~ 2p 4 2 =: G (p);(3.21) i.e., lim p!1 h (p)=G (p) = 1. No proof of this assertion is known. In fact, Fung et al. argue in <ref> [44] </ref> that this conjecture is probably false. However, Lepisto [81] proved 86 Chapter 3. Cyclic Codes and Cyclotomic Fields in 1974 the bounds 2 4:66 ln h (p) 4:66 ;(3.22) which shows that the growth of h is really fast. <p> Later, Newman [98], Pa-junen [106], and Lehmer and Masley [73] extended these calculations to all primes below 512. The running time of the most sophisticated of these algorithms was O (p 5 log 2 p), see <ref> [44] </ref>. Fung et al. [44] could considerably improve upon this running time, and extended the computation to all primes below 3000. Their method has an asymptotic running time of O (p 2 log 4 p) and has the advantage that it computes a partial factorization of h . <p> Later, Newman [98], Pa-junen [106], and Lehmer and Masley [73] extended these calculations to all primes below 512. The running time of the most sophisticated of these algorithms was O (p 5 log 2 p), see <ref> [44] </ref>. Fung et al. [44] could considerably improve upon this running time, and extended the computation to all primes below 3000. Their method has an asymptotic running time of O (p 2 log 4 p) and has the advantage that it computes a partial factorization of h . <p> In doing so we observed a mismatch between our results and Table VII in <ref> [44] </ref>. After contacting the authors, it turned out that Table VII contained errors, and that in all the mismatches our program had computed the correct data. (3) We checked divisibility properties of h e by the prime p and cross checked that with the results of the Bernoulli computations. <p> We checked these values against those computed independently by the classno () routine of PARI [6], and did not observe any mismatches. All these tests were quite helpful in catching bugs during the development of the program. 3.8.3 Results We basically performed the same statistics as Fung et al. <ref> [44] </ref>, only omitting the computation of "high and low champions." Furthermore, we did not attempt to completely factor the relative class numbers we obtained. However, we did compute the growth of h (p) and compared it against G (p) defined in (3.21).
Reference: [45] <author> R. G. Gallager. </author> <title> Low Density Parity-Check Codes. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1963. </year>
Reference-contexts: Although the idea of using sparse bipartite graphs for constructing codes is not new <ref> [45, 145] </ref>, the construction of the graphs in each of the layers is novel. We obtained the construction by analyzing a simple loss 39 1.8. Conclusions and Open Problems recovery algorithm. The analysis used results asserting the sharp concentration of parameters in a discrete random process around their means.
Reference: [46] <author> R.A. </author> <title> Games. An algorithm for complex approximation in Z[e 2i=8 ]. IEEE Trans. </title> <journal> Inform. Theory, </journal> <volume> 32(4) </volume> <pages> 603-607, </pages> <year> 1986. </year>
Reference-contexts: Furthermore, the worst case error of the approximations algorithm is optimal. The only prior approximation algorithm, due to Games <ref> [46] </ref>, is for the case n = 3. It has a worst case approximation error of O (1=M ), and a running time of O (M ). <p> In this way we make sure that the coefficients of the new approximation will be less than M in absolute value. Construction of the magic set uses the continued fraction expansion of p this respect, and only in this, our algorithm is similar to that of Games <ref> [46] </ref>.
Reference: [47] <author> R.A. Games, D. Moulin, S.D. O'Neil, and J.J. Rushanan. </author> <title> Algebraic integer quantization and residue number system processing. </title> <booktitle> In ICASSP 89, </booktitle> <pages> pages 948-951, </pages> <year> 1989. </year>
Reference-contexts: Furthermore, the worst case error of the approximations algorithm is optimal. The only prior approximation algorithm, due to Games [46], is for the case n = 3. It has a worst case approximation error of O (1=M ), and a running time of O (M ). Games et al. <ref> [47] </ref> also report on the design of a brass board for filtering data based on approximation by 8th roots of unity. The approximation unit in their board is replaced by a ROM which contains approximations of 2 j for various j by integral linear combinations of 1 and p 2.
Reference: [48] <author> A. Garcia and H. Stichtenoth. </author> <title> A tower of Artin-Schreier extensions of function fields attaining the Drinfeld-Vladut bound. </title> <journal> Invent. Math., </journal> <volume> 121 </volume> <pages> 211-222, </pages> <year> 1995. </year>
Reference-contexts: Our algorithm for this task is an adaptation of a well-known procedure for factoring polynomials over number fields, as described in, e.g., [27, 69, 74]. Applying Theorem (2.2) to the asymptotically good sequence of Garcia-Stichtenoth function fields <ref> [48] </ref> allows us to construct sequences of [n; k; e; b] q 2 -codes having excellent parameters. This application is carried out in Section 2.5. The bottleneck of our algorithm is the factorization routine. <p> Also note that, if these parameters were on the contrary very large, this would make difficult any encoding or decoding of the AG-code. Hence this would not be a problem specific to our algorithm. * 2.5 Application to Asymptotically Good AG-Codes Garcia and Stichtenoth <ref> [48] </ref> give an explicit sequence of function fields F m =F q 2 having more than q m1 (q 2 1) prime divisors of degree one and genus g m &lt; q m1 (q+1). <p> It has q 3 + 1 prime divisors of degree one and its genus is q (q 1)=2 <ref> [48] </ref>. We set n := q 3 . Then size (f ) and [K: L] are both o (n). Let Q be the common zero of X and Y . Then 1=X 2 L (qQ) and 1=Y 2 L ((q + 1)Q). <p> from Section 2.5 that F 3 =F q 2 is the extension of the Hermitian function field F 2 generated by the polynomial Z q +Z (Y =X) q+1 . (We have changed our notation slightly.) F 3 has more than q 4 q 2 prime divisors of degree one <ref> [48, Prop. 3.1] </ref> and its genus is q 3 2q + 1 [48, Thm. 2.10]. Let n := q 4 q 2 . To show that our decoding algorithm takes time poly (n), we need only prove that basis size S is polynomial in n. <p> of the Hermitian function field F 2 generated by the polynomial Z q +Z (Y =X) q+1 . (We have changed our notation slightly.) F 3 has more than q 4 q 2 prime divisors of degree one [48, Prop. 3.1] and its genus is q 3 2q + 1 <ref> [48, Thm. 2.10] </ref>. Let n := q 4 q 2 . To show that our decoding algorithm takes time poly (n), we need only prove that basis size S is polynomial in n. <p> Again, we will do this by exhibiting an explicit prime divisor Q and explicit basis functions ' i . For Q we choose the unique common zero of the functions X; Y; Z <ref> [48, Lem. 2.3] </ref>. We will now employ the notation of [48]. The divisor D (3) can be written as D (3) = E 1 + E 2 , for effective divisors E 1 ; E 2 such that E 1 " F 1 is the divisor of poles of X. <p> Again, we will do this by exhibiting an explicit prime divisor Q and explicit basis functions ' i . For Q we choose the unique common zero of the functions X; Y; Z [48, Lem. 2.3]. We will now employ the notation of <ref> [48] </ref>. The divisor D (3) can be written as D (3) = E 1 + E 2 , for effective divisors E 1 ; E 2 such that E 1 " F 1 is the divisor of poles of X. The discussion in Section 2 of [48] implies that we have <p> employ the notation of <ref> [48] </ref>. The divisor D (3) can be written as D (3) = E 1 + E 2 , for effective divisors E 1 ; E 2 such that E 1 " F 1 is the divisor of poles of X. The discussion in Section 2 of [48] implies that we have the following divisor 63 2.11.
Reference: [49] <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-completeness. W.H. </title> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: We say that a language L is polynomial time reducible to a language L 0 , and denote it by L L 0 , if there is a polynomial time reduction from L to L 0 in the usual sense. (See, e.g., <ref> [49] </ref> or [107].) 5.10.1 Known Results In this subsection we will gather some well-known results about the complexity of various computational problems in algebraic number theory. (5.24) Fact. The following problems are equivalent under polynomial time reduc tion: 150 Chapter 5.
Reference: [50] <author> J. von zur Gathen and E. Kaltofen. </author> <title> Factorization of multivariate polynomials over finite fields. </title> <journal> Math. Comp., </journal> <volume> 45 </volume> <pages> 251-261, </pages> <year> 1985. </year>
Reference-contexts: We then factor the numerator and denominator of g 2 F q (X), and ~ N (X; T ) 2 F q [X; T ], using a univariate and a bivariate factorization algorithm, respectively. This takes deterministic time polynomial in q and in the degrees of the polynomials involved <ref> [50, 75] </ref>. By the Gau Lemma [71, Chap. IV, Thm. 2.1], the irreducible factors of N in L [T ] exactly correspond to the irreducible factors of ~ N in F q [X; T ]. <p> To obtain an overall polylogarithmic contribution of q one could employ a probabilistic rather than a deterministic factorization algorithm: refer to <ref> [50] </ref>. (2) If the curve defined by the algebraic function field K is a plane curve with only ordinary singularities, then it follows from the work in [57] that the 50 Chapter 2.
Reference: [51] <author> J. von zur Gathen and V. Shoup. </author> <title> Computing Frobenius maps and factoring polynomials. </title> <journal> Comput. Complexity, </journal> <volume> 2 </volume> <pages> 187-224, </pages> <year> 1992. </year>
Reference-contexts: If f has degree at most n, its DDF can be computed with ~ O (n 2 log (p) + n log (p) 2 ) <ref> [51, Algorithm 3.1] </ref>. For an integer polynomial g we denote by L 1 (g) the maximum of the absolute values of the coefficients of g, and by (g) the quantity ln (L 1 (g)).
Reference: [52] <author> O. Goldreich, R. Rubinfeld, and M. Sudan. </author> <title> Learning polynomials with queries: the highly noisy case. </title> <booktitle> In Proc. 36th FOCS, </booktitle> <pages> pages 294-303, </pages> <year> 1995. </year>
Reference-contexts: The existence of a unique solution in the presence of large quantities of random noise has been considered previously, e.g., in <ref> [52, Sec. 6] </ref>. Here we shall accompany our existence result with an efficient decoding algorithm. Indeed, this algorithm will have the advantage of being more efficient than our main algorithm of Section 2.4. 57 2.8.
Reference: [53] <author> V.D. Goppa. </author> <title> Codes on algebraic curves. </title> <journal> Sov. Math. Dokl., </journal> <volume> 24 </volume> <pages> 170-172, </pages> <year> 1981. </year>
Reference-contexts: In particular, we construct sequences 43 2.1. Introduction of constant rate AG-codes over a fixed finite field that can uniquely correct errors in many more than half the positions of a codeword. 2.1 Introduction Following a construction of Goppa <ref> [53] </ref>, one can use algebraic curves over finite fields to design linear error-correcting codes called algebraic-geometric codes or AG-codes. These codes can be viewed as a generalization of Reed-Solomon codes, for an AG-codeword is formed by evaluating at specified rational points a function in the function field of a curve. <p> The quantity d fl := nff is called the designed distance of C. For further information on AG-codes, we refer the reader to <ref> [53, 54, 133, 147, 153] </ref>. The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [56, 57].
Reference: [54] <author> V.D. Goppa. </author> <title> Geometry and Codes. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1988. </year>
Reference-contexts: The quantity d fl := nff is called the designed distance of C. For further information on AG-codes, we refer the reader to <ref> [53, 54, 133, 147, 153] </ref>. The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [56, 57].
Reference: [55] <author> U. Heute. </author> <title> Fehler im DFT und FFT: Neue Aspekte in Theorie und Anwendung. </title> <type> PhD thesis, </type> <institution> Universitat Erlangen, </institution> <year> 1982. </year> <note> 162 BIBLIOGRAPHY </note>
Reference-contexts: Random quantization error of this kind tends to produce less problems in FFT algorithms than computational noise ([148]); a standard stochastic analysis says that on average this sort of error contaminates p ` bits of the result <ref> [55] </ref>. Since this applies equally to the usual fixed-point model and to our model (and even to floating point models), and since it gives lower order terms in any complexity analysis, we have ignored this kind of quantization error throughout. * 129 4.11.
Reference: [56] <author> M. Huang and D. Ierardi. </author> <title> Efficient algorithms for the Riemann-Roch problem and for addition in the Jacobian of a curve. </title> <booktitle> In Proc. 32nd FOCS, </booktitle> <pages> pages 678-687, </pages> <year> 1991. </year>
Reference-contexts: The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities <ref> [56, 57] </ref>. The following lemma shows that it suffices to know a special basis of L ((2g+1)Q). (See also [112, Prop. 3].) (2.3) Lemma.
Reference: [57] <author> M. Huang and D. Ierardi. </author> <title> Efficient algorithms for the Riemann-Roch problem and for addition in the Jacobian of a curve. </title> <journal> J. Symb. Comp., </journal> <volume> 18 </volume> <pages> 519-539, </pages> <year> 1994. </year>
Reference-contexts: The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities <ref> [56, 57] </ref>. The following lemma shows that it suffices to know a special basis of L ((2g+1)Q). (See also [112, Prop. 3].) (2.3) Lemma. <p> To obtain an overall polylogarithmic contribution of q one could employ a probabilistic rather than a deterministic factorization algorithm: refer to [50]. (2) If the curve defined by the algebraic function field K is a plane curve with only ordinary singularities, then it follows from the work in <ref> [57] </ref> that the 50 Chapter 2. Decoding Algebraic Geometric Codes parameter S in the above theorem is polynomial in n, [K: L], and size (f).
Reference: [58] <author> G.J. Janusz. </author> <title> Algebraic Number Fields. </title> <journal> American Mathematical Society, </journal> <note> second edition, </note> <year> 1996. </year>
Reference-contexts: Denote by P a prime divisor of p in L. Then there exists a unique 2 G, called the Frobenius automorphism of P and denoted by P such that (x) x p mod P for all x in the ring O L of integers of L. (See, e.g., <ref> [58, pp. 125-130] </ref>.) This automorphism is the link to the Effective Chebotarev Density Theorem which will allow us to obtain quantitative estimates about the number of primes in a given interval which have a certain decomposition behavior. <p> Then p is the product of s prime divisors in K of degrees f 1 ; : : : f s . Proof. See <ref> [58, Proposition 2.7] </ref>. 2 We call the list [f 1 ; : : : ; f s ] the decomposition pattern of p in K. We call such a decomposition pattern homogeneous, if f i = f j for 1 i; j s, and call it inhomogeneous otherwise.
Reference: [59] <author> V. Jha. </author> <title> Faster computation of irregular pairs corresponding to an odd prime. </title> <journal> J. Indian Math. Soc., </journal> <volume> 59 </volume> <pages> 149-152, </pages> <year> 1993. </year>
Reference-contexts: A similar approach has been independently suggested by Jha <ref> [59] </ref>. As was described in the previous section, the running time of our algorithm is O which is comparable to the running time when using gcd-techniques [21, Chapter 3]. However, as our method is easier to implement, it is likely to be significantly faster than gcd-strategies.
Reference: [60] <author> V. Jha. </author> <title> Faster computation of the first factor of the class number of Q( p ). Math. </title> <journal> Comp., </journal> <volume> 64 </volume> <pages> 1705-1710, </pages> <year> 1995. </year>
Reference-contexts: In this section, we develop an algorithm for computing h itself. Our algorithm is very similar to the one suggested by Jha <ref> [60] </ref>. <p> In summary, assuming ERH, our algorithm runs in time O (p 2 log 2 (p) log log (p)). It might seem that our algorithm is slower than Jha's <ref> [60] </ref>. This is due to an error in that paper. <p> Cyclic Codes and Cyclotomic Fields of bit-operations for this task is O (p log 2 (p) log log (p)), and this turns Jha's (and our) algorithm into an O (p log 2 (p) log log (p)) algorithm instead of an O (p 2 log (p))- algorithm, as claimed in <ref> [60] </ref>. 3.8.2 Implementations and Result Checking The main routines of our algorithm, namely the evaluation routines, Chinese remaindering routines, and gcd-routines, were implemented in TP. The I/O routines were handled by C-programs. The Chinese remaindering routine was written by G. Sauer and was kindly provided to us by D. Reischert.
Reference: [61] <author> J. Justesen, K.J. Larsen, A. Havemose, H.E. Jensen, and T. Htholdt. </author> <title> Construction and decoding of a class of algebraic geometry codes. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 35 </volume> <pages> 811-821, </pages> <year> 1989. </year>
Reference-contexts: They perform between O (n 2 ) and O (n 3 ) operations over the base field F q . The seminal work on decoding was done by Justesen et al. <ref> [61] </ref> who presented a decoding algorithm for codes from nonsingular plane algebraic curves which could correct up to (d fl g 1)=2 errors, where d fl is the designed distance of the code, and g is the genus of the curve used in the construction.
Reference: [62] <author> J. Justesen, K.J. Larsen, H.E. Jensen, and T. Htholdt. </author> <title> Fast decoding of codes from algebraic plane curves. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 38 </volume> <pages> 111-119, </pages> <year> 1992. </year>
Reference-contexts: Based on their results, Pellikaan [109] gave a polynomial time algorithm for decoding up to (d fl 1)=2 errors for codes constructed on maximal curves. This result was extended by Vladut [158] to any AG-code. Later, Justesen et al. <ref> [62] </ref> improved on their original procedure by designing an algorithm which could correct up to (d fl g=2 1)=2 errors using O (n 7=3 ) arithmetic operations. This result was generalized by Dahl [32] to arbitrary AG-codes. A separate algorithm was developed by Feng and Rao [42].
Reference: [63] <author> J.H. Karl. </author> <title> An Introduction to Digital Signal Processing. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1989. </year>
Reference-contexts: This method, called the Fast Fourier Transform (FFT), and variants thereof have ever since been an indispensable tool in many different areas that deal with processing of digital signals <ref> [63, 104] </ref>. Many applications of FFT's such as computer-tomography, geophysical signal processing, and high resolution imaging radars require high precision output.
Reference: [64] <author> R. Karp and M. Sipser. </author> <title> Maximum matchings in sparse random graphs. </title> <booktitle> In Proc. 22nd FOCS, </booktitle> <pages> pages 364-375, </pages> <year> 1981. </year>
Reference-contexts: In the fist part of this section, we will state a general sharp concentration result. Such results have been obtained by Kurtz [66] who studied Markov jump processes, and have been used previously by many researchers, see <ref> [43, 64, 94, 95, 111, 167] </ref> and the references therein. We will, however, use a version due to Wormald [167] which has the advantage of being directly applicable to our situation. Next we will set up the appropriate system of differential equations, and solve them explicitly.
Reference: [65] <institution> E.E. Kummer. Memoire sur la theorie des nombres complexes composes de racines de l'unite et des nombres entiers. </institution> <note> J. Math. Pures Appl., 16 377-498, 1851. "Collected Works," Vol. I, p. 459. </note>
Reference-contexts: This group is canonically isomorphic to the group of characters of G, the Galois group of Q ( p )=Q. The following result, originally due to Kummer <ref> [65] </ref>, shows that generalized Bernoulli numbers can be obtained as values of the polynomial . (3.9) Proposition. Let be defined as in (3.5), and let be a primitive (p 1)st root of unity over Q. Furthermore, let t be the generator of X given by t (w) = . <p> The task of computing the relative class number is more complicated than that of computing irregular pairs. The main difficulty is the fact that h grows more than exponentially with p. In fact, Kummer conjectured in 1851 <ref> [65] </ref> that h (p) ~ 2p 4 2 =: G (p);(3.21) i.e., lim p!1 h (p)=G (p) = 1. No proof of this assertion is known. In fact, Fung et al. argue in [44] that this conjecture is probably false. However, Lepisto [81] proved 86 Chapter 3. <p> However, Lepisto [81] proved 86 Chapter 3. Cyclic Codes and Cyclotomic Fields in 1974 the bounds 2 4:66 ln h (p) 4:66 ;(3.22) which shows that the growth of h is really fast. First calculations of the relative class number were done by Kummer <ref> [65] </ref>, who computed these numbers for all primes below 163. Later, Newman [98], Pa-junen [106], and Lehmer and Masley [73] extended these calculations to all primes below 512. The running time of the most sophisticated of these algorithms was O (p 5 log 2 p), see [44].
Reference: [66] <author> T.G. Kurtz. </author> <title> Approximation of Population Processes. </title> <booktitle> CBMS-NSF Regional Conf. Series in Applied Math. </booktitle> <publisher> SIAM, </publisher> <year> 1981. </year>
Reference-contexts: In the fist part of this section, we will state a general sharp concentration result. Such results have been obtained by Kurtz <ref> [66] </ref> who studied Markov jump processes, and have been used previously by many researchers, see [43, 64, 94, 95, 111, 167] and the references therein. We will, however, use a version due to Wormald [167] which has the advantage of being directly applicable to our situation.
Reference: [67] <author> G. Lachaud. </author> <title> Artin-Schreier curves, exponential sums, and the Carlitz-Uchiyama bound for geometric codes. </title> <journal> J. Number Theory, </journal> <volume> 39 </volume> <pages> 18-40, </pages> <year> 1991. </year>
Reference-contexts: It is more than a mere coincidence that these numbers have already been determined by Davenport-Hasse in the 1930's [33]: they are essentially the above Gaussian sums! This gives a more substantial insight into the deep connection between cyclic codes and cyclotomic fields. (See the papers <ref> [155, 67, 166] </ref> for a discussion of these and related results.) Inspired by these results the author took in [136] a different approach to study possible other relationships between cyclic codes and Gaussian sums. The main topic of that paper was the study of reductions of Stickelberger ideals modulo primes.
Reference: [68] <editor> J.C. Lagarias and A.M. Odlyzko. </editor> <title> Effective versions of the Chebotarev density theorem. </title> <editor> In A. Frohlich, editor, </editor> <booktitle> Algebraic Number Fields, </booktitle> <pages> pages 409-464. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1977. </year>
Reference-contexts: The estimate is based on k and the size of a certain subset of the Galois group of L. The proof of this lemma uses tools from analytic number theory, like effective versions of the Chebotarev Theorem <ref> [68, 103] </ref>, and Odlyzko's bound on the discriminant of number fields [102]. We then proceed in sections 5.5-5.9 with the description and analysis of our algorithms. <p> Proof. We may suppose that M 6= Q since the number (x) of primes less than or equal to x is lower bounded by x= ln (x) for x 17, see [4, Th. 8.8.1]. Effective versions of the Chebotarev Density Theorem due to Lagarias and Odlyzko <ref> [68] </ref>, and Oesterle [103] give W (x) #G Li (x) x 2 ln (jdj) + m ln (x) ; where m = [L : Q], d is the discriminant of L, and Li (x) = R x 2 dt =t is the logarithmic integral.
Reference: [69] <author> S. Landau. </author> <title> Factoring polynomials over algebraic number fields. </title> <journal> SIAM J. Comput., </journal> <volume> 14 </volume> <pages> 184-195, </pages> <year> 1985. </year>
Reference-contexts: Our algorithm for this task is an adaptation of a well-known procedure for factoring polynomials over number fields, as described in, e.g., <ref> [27, 69, 74] </ref>. Applying Theorem (2.2) to the asymptotically good sequence of Garcia-Stichtenoth function fields [48] allows us to construct sequences of [n; k; e; b] q 2 -codes having excellent parameters. This application is carried out in Section 2.5. The bottleneck of our algorithm is the factorization routine. <p> This example should serve as a prototype for how to proceed in the case of a general separable extension. 48 Chapter 2. Decoding Algebraic Geometric Codes We now continue with our solution, which adapts a well-known procedure for factoring univariate polynomials over number fields <ref> [27, 69, 74] </ref>. To each 2 K there corresponds a unique g 2 L [Y ] of degree less than deg (f) such that = g (!). <p> This problem can be decided in polynomial time, by using factorization of polynomials over algebraic number fields <ref> [25, 74, 76, 69] </ref>: one factors g 2 K [T ], where K = Q [x]=(g) is the field generated by a root of g over Q.
Reference: [70] <author> S. Landau. </author> <title> Some remarks on computing the square parts of integers. </title> <journal> Inform. and Comput., </journal> <volume> 78 </volume> <pages> 246-253, </pages> <year> 1988. </year> <note> 163 BIBLIOGRAPHY </note>
Reference-contexts: How hard is it to compute any of these data from m? We will prove in this section that these problems are equivalent under polynomial time reductions. We remark that Landau <ref> [70] </ref> has also considered the problem EOF below. Her interest has been in showing that this problem can be reduced to that of computing the Euler '-function of an integer.
Reference: [71] <author> S. Lang. </author> <title> Algebra. </title> <publisher> Addison-Wesley, </publisher> <address> third edition, </address> <year> 1993. </year>
Reference-contexts: This takes deterministic time polynomial in q and in the degrees of the polynomials involved [50, 75]. By the Gau Lemma <ref> [71, Chap. IV, Thm. 2.1] </ref>, the irreducible factors of N in L [T ] exactly correspond to the irreducible factors of ~ N in F q [X; T ].
Reference: [72] <author> C.G. Latimer. </author> <title> On the units in a cyclic field. </title> <journal> Amer. J. Math., </journal> <volume> 56 </volume> <pages> 69-74, </pages> <year> 1934. </year>
Reference-contexts: The following proposition is due to Latimer <ref> [72, Theorem 1] </ref>. The proof we present here is due to H.W. Lenstra [78]. (3.2) Proposition. For any imaginary subfield of Q ( p ) we have Q = 1. Proof.
Reference: [73] <author> D.H. Lehmer and J.M. Masley. </author> <title> Table of cyclotomic class numbers h fl (p) and their factors for 200 &lt; p &lt; 251. </title> <journal> Math. Comp., </journal> <volume> 32 </volume> <pages> 577-582, </pages> <year> 1978. </year>
Reference-contexts: First calculations of the relative class number were done by Kummer [65], who computed these numbers for all primes below 163. Later, Newman [98], Pa-junen [106], and Lehmer and Masley <ref> [73] </ref> extended these calculations to all primes below 512. The running time of the most sophisticated of these algorithms was O (p 5 log 2 p), see [44]. Fung et al. [44] could considerably improve upon this running time, and extended the computation to all primes below 3000.
Reference: [74] <author> A.K. Lenstra. </author> <title> Factoring polynomials over algebraic number fields. </title> <type> Technical Report IW213/82, </type> <institution> Dept. Comp. Science, Stichting Mathematisch Centrum, </institution> <address> Amsterdam, </address> <year> 1982. </year>
Reference-contexts: Our algorithm for this task is an adaptation of a well-known procedure for factoring polynomials over number fields, as described in, e.g., <ref> [27, 69, 74] </ref>. Applying Theorem (2.2) to the asymptotically good sequence of Garcia-Stichtenoth function fields [48] allows us to construct sequences of [n; k; e; b] q 2 -codes having excellent parameters. This application is carried out in Section 2.5. The bottleneck of our algorithm is the factorization routine. <p> This example should serve as a prototype for how to proceed in the case of a general separable extension. 48 Chapter 2. Decoding Algebraic Geometric Codes We now continue with our solution, which adapts a well-known procedure for factoring univariate polynomials over number fields <ref> [27, 69, 74] </ref>. To each 2 K there corresponds a unique g 2 L [Y ] of degree less than deg (f) such that = g (!). <p> This problem can be decided in polynomial time, by using factorization of polynomials over algebraic number fields <ref> [25, 74, 76, 69] </ref>: one factors g 2 K [T ], where K = Q [x]=(g) is the field generated by a root of g over Q.
Reference: [75] <author> A.K. Lenstra. </author> <title> Factoring multivariate polynomials over finite fields. </title> <booktitle> In Proc. 15th STOC, </booktitle> <pages> pages 189-192, </pages> <year> 1983. </year>
Reference-contexts: We then factor the numerator and denominator of g 2 F q (X), and ~ N (X; T ) 2 F q [X; T ], using a univariate and a bivariate factorization algorithm, respectively. This takes deterministic time polynomial in q and in the degrees of the polynomials involved <ref> [50, 75] </ref>. By the Gau Lemma [71, Chap. IV, Thm. 2.1], the irreducible factors of N in L [T ] exactly correspond to the irreducible factors of ~ N in F q [X; T ].
Reference: [76] <author> A.K. Lenstra. </author> <title> Factoring multivariate polynomials over algebraic number fields. </title> <journal> SIAM J. Comput., </journal> <volume> 16(3) </volume> <pages> 591-598, </pages> <year> 1987. </year>
Reference-contexts: This problem can be decided in polynomial time, by using factorization of polynomials over algebraic number fields <ref> [25, 74, 76, 69] </ref>: one factors g 2 K [T ], where K = Q [x]=(g) is the field generated by a root of g over Q.
Reference: [77] <author> H.W. Lenstra. </author> <title> Algorithms in algebraic number theory. </title> <journal> Bulletin of the AMS, </journal> <volume> 26 </volume> <pages> 211-244, </pages> <year> 1992. </year>
Reference-contexts: instance, given a normal polynomial g of degree n!, can we decide in random polynomial time whether the Galois group of G is the symmetric group? Note that the question whether a degree n polynomial has Galois group S n or A n can be decided in polynomial time, see <ref> [77, Th. 3.6] </ref>. (4) In the algorithm Abelian we can drop the assumption that g is irreducible if we know that it is normal.
Reference: [78] <author> H.W. Lenstra. </author> <title> Private communication. </title> <year> 1997. </year>
Reference-contexts: The following proposition is due to Latimer [72, Theorem 1]. The proof we present here is due to H.W. Lenstra <ref> [78] </ref>. (3.2) Proposition. For any imaginary subfield of Q ( p ) we have Q = 1. Proof. Let H be the Galois group of K=Q, be a generator of H, and u be a unit of K.
Reference: [79] <author> H.W. Lenstra. </author> <title> Private communication. </title> <year> 1997. </year>
Reference-contexts: Then (U n H) [ (U n H) W 1 (U ), and we obtain #W 1 (U ) 2 (#U #H). Since H is a proper subgroup of U , we have #W (U ) #W 1 (U ) #U = #G=n. 2 H. W. Lenstra <ref> [79] </ref> has given a characterization of all groups G for which the bound in Part (3) of the last proposition is sharp. (5.8) Proposition.
Reference: [80] <author> H. W. Leopoldt. </author> <title> Eine Verallgemeinerung der Bernoullischen Zahlen. </title> <journal> Abh. math. Sem. Univ. Hamburg, </journal> <volume> 22 </volume> <pages> 131-140, </pages> <year> 1958. </year>
Reference-contexts: Often we regard as a map Z! W p1 [ f0g, by setting (a) := 0 for pja and (a) := (a mod p) otherwise. The generalized Bernoulli numbers B n; , n 0, introduced by Leopoldt <ref> [80] </ref>, are defined by p X (a)te at =: n=0 t n : A short calculation yields B 1;1 = 2 1 p1 X (a)a; for 6= 1. Since ((1)) 2 = (1) = 1, we have (1) 2 f1g for all Dirichlet characters .
Reference: [81] <author> T. </author> <title> Lepisto. On the growth of the first factor of the class number of the prime cyclotomic field. </title> <institution> Ann. Acad. Sci. Fenn., A1(577):21, </institution> <year> 1974. </year>
Reference-contexts: In fact, Kummer conjectured in 1851 [65] that h (p) ~ 2p 4 2 =: G (p);(3.21) i.e., lim p!1 h (p)=G (p) = 1. No proof of this assertion is known. In fact, Fung et al. argue in [44] that this conjecture is probably false. However, Lepisto <ref> [81] </ref> proved 86 Chapter 3. Cyclic Codes and Cyclotomic Fields in 1974 the bounds 2 4:66 ln h (p) 4:66 ;(3.22) which shows that the growth of h is really fast.
Reference: [82] <author> R. Lidl and H. Niederreiter. </author> <title> Introduction to Finite Fields and their Applications. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1986. </year>
Reference-contexts: Then there exists v 2 F 2 m such that Tr (X) X + v mod (X 2 + X + c) and v 2 Proof. (1) This is well known. Refer to <ref> [82, Thm. 2.25] </ref>. (2) There exist u ; v 2 F 2 m such that Tr (X) u X + v mod (X 2 + X + c). Since Tr (c) = 0, there exists 2 F 2 m such that 2 + + c = 0.
Reference: [83] <author> J.H. van Lint. </author> <title> Introduction to Coding Theory, volume 86 of Graduate Texts in Mathematics. </title> <publisher> Springer Verlag, </publisher> <year> 1982. </year>
Reference-contexts: In Section 2.10 we investigate asymptotic properties of [n; k; e; b] q -codes. We define analogues of the function ff q <ref> [83, Def. 5.1.2] </ref> for our new classes of [n; k; e; b] q - codes and [n; k; e; 1] p q -codes, and derive lower bounds for these functions by creating asymptotically good sequences of AG-codes. <p> Decoding Algebraic Geometric Codes Observe that 1 q is precisely the set of all (*; R) such that (2*; R) 2 q . Fur thermore, we have obvious inclusions 1 q R q b 0 The function ff q : [0; 1] ! [0; 1], defined in <ref> [83, Def. 5.1.2] </ref>, describes the boundary of q . To be precise, q is the set of all (ffi; R) such that R ff q (ffi). <p> Stichtenoth fields and then applying: (1) Theorem (2.13); (2) Theorem (2.10); (3) Theorem (2.21). 2 that q is rather large. (Specifically, the figure was made for q = 101.) The figure also juxtaposes a simple upper bound on fi 1 q 2 , which was derived from the Plotkin bound <ref> [83, Thm. 5.2.5] </ref> via the evident identity fi 1 q (R) = 1 2 fi q (R). Observe that, when q is large, known upper and lower bounds on fi 1 q 2 nearly match.
Reference: [84] <author> M. Luby, M. Mitzenmacher, and M.A. Shokrollahi. </author> <title> Analysis of random processes via and-or tree evaluation. </title> <note> In preparation, </note> <year> 1997. </year>
Reference-contexts: In the next two sections, we develop techniques for the analysis of the process for general degree sequences. 1.4 Sharp Concentration and Analysis of the Decoding We will analyze the decoding algorithm in (1.5) by viewing it as a discrete random process. (For an alternative analysis, see <ref> [84] </ref>.) We model the evolution of the main parameters of this system by a system of differential equations. These parameters include the number of edges of different right and left degrees, as well as the total number of edges and the average degrees of the bipartite graph on both sides.
Reference: [85] <author> M. Luby, M. Mitzenmacher, M.A. Shokrollahi, and D. Spielman. </author> <title> Codes close to the Shannon Bound from cascades of bipartite graphs. </title> <note> In preparation, </note> <year> 1997. </year>
Reference-contexts: For example, one could use belief-propagation techniques to decode the codes described in this section. A work in this direction is in progress <ref> [85] </ref>. There are many other applications of forward error-correction schemes, which we have not included here for limitations of space. Some examples include error recovery on long delay paths, power saving in mobile equipment, and various multicast applications.
Reference: [86] <author> M. Luby, M. Mitzenmacher, M.A. Shokrollahi, D. Spielman, and V. Stemann. </author> <title> Practical loss-resilient codes. </title> <booktitle> In Proc. 29th STOC, </booktitle> <pages> pages 150-159, </pages> <year> 1997. </year>
Reference: [87] <author> F.J. MacWilliams and N.J.A. Sloane. </author> <title> The Theory of Error-Correcting Codes. </title> <publisher> North-Holland, </publisher> <year> 1988. </year> <note> 164 BIBLIOGRAPHY </note>
Reference-contexts: However, this seems to be the end of the road: the MDS-conjecture, formulated by finite geometers and coding theorists, states that the block length of an MDS-code over F q is at most q + 1, except for trivial cases; we refer the reader to <ref> [87, Ch. 11] </ref> for an exact formulation of this conjecture, and on proofs of some cases thereof. <p> RS-codes are very attractive for various reasons: they are MDS-codes which means that they have the largest possible minimum distance for a given block length and a given dimension; this makes them natural candidates for decoding bursts of errors <ref> [87, Ch. 10,x6] </ref>. Furthermore, there exist very efficient software and hardware encoding and decoding algorithms for these codes which can correct up to the true minimum distance. Decoding RS-codes boils down to finding the generating polynomial of a linearly generated sequence. <p> For this, one usually employs the so-called Berlekamp-Massey algorithm [8, 89]. The running time of this algorithm is quadratic in the block-length of the code, but it has a very efficient hardware implementation, as it only uses linear feed back shift registers, see [8] and <ref> [87, Ch. 9,x6] </ref>. Asymptotically fast software implementations are based on variants of the extended Euclidean algorithm [23, 34, 91, 163]. (See also [21, Ex. 3.9].) Their running time is O (n log 2 (n) log log (n)), where n is the block length of the code [21, Chap. 3]. <p> From the generator polynomial we obtain the assertion on the minimum distance. (The lower bound of 4 is obtained by, e.g., the BCH-bound <ref> [87, Ch. 8,x6,Thm. 28] </ref>, and the upper bound in case i p (q) = 1 is given by the codeword corresponding to the polynomial (x ff j )(x (p1)=2 1) of weight 4.) In addition, we obtain that dim S p (q) = (p + 1)=2 ord q (h ) iff
Reference: [88] <author> Yu.I. Manin. </author> <title> What is the maximum number of points on a curve over F 2 ? J. </title> <journal> Fac. Sci. Tokio, </journal> <volume> 28 </volume> <pages> 715-720, </pages> <year> 1981. </year>
Reference-contexts: We introduced the functions fi b q , q , and fi R q , which are natural variants of the well-known function ff q . Manin <ref> [88] </ref> has proved the continuity of ff q . This motivates us to ask: (6) Are fi b q , and fi R q continuous? We have proved lower bounds analogous to the Tsfasman-Vladut-Zink bound [154] for fi b q , and fi R q .
Reference: [89] <author> J.L. Massey. </author> <title> Shift register synthesis and BCH decoding. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 15 </volume> <pages> 122-127, </pages> <year> 1969. </year>
Reference-contexts: Furthermore, there exist very efficient software and hardware encoding and decoding algorithms for these codes which can correct up to the true minimum distance. Decoding RS-codes boils down to finding the generating polynomial of a linearly generated sequence. For this, one usually employs the so-called Berlekamp-Massey algorithm <ref> [8, 89] </ref>. The running time of this algorithm is quadratic in the block-length of the code, but it has a very efficient hardware implementation, as it only uses linear feed back shift registers, see [8] and [87, Ch. 9,x6].
Reference: [90] <author> J.H. </author> <title> McClellan and C.M. Rader. Number Theory in Digital Signal Processing. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice-Hall, </publisher> <year> 1979. </year>
Reference-contexts: This phenomenon, often referred to as computational noise, causes major problems for arithmetic units with limited precision which are often used for real time applications. Several researchers have noted that calculation of FFT's with algebraic integers avoids computational noise entirely, see, e.g., <ref> [90] </ref>. We will combine a new algorithm for approximating complex numbers by cyclotomic integers with Chinese remaindering strategies to give an efficient algorithm to compute b-bit precision FFT's of length L.
Reference: [91] <author> R.J. </author> <title> McEliece. The Theory of Information and Coding. Encyclopedia of Mathematics and its Applications. </title> <publisher> Addison-Wesley, </publisher> <year> 1977. </year>
Reference-contexts: Asymptotically fast software implementations are based on variants of the extended Euclidean algorithm <ref> [23, 34, 91, 163] </ref>. (See also [21, Ex. 3.9].) Their running time is O (n log 2 (n) log log (n)), where n is the block length of the code [21, Chap. 3]. The decoding algorithms of last section can be specialized to RS-codes in the following way.
Reference: [92] <author> R.J. McEliece and H.C. Rumsey. </author> <title> Euler products, cyclotomy, and coding. </title> <journal> J. Number Theory, </journal> <volume> 4 </volume> <pages> 302-311, </pages> <year> 1972. </year>
Reference-contexts: Codewords in cyclic codes and their weights are related to many fascinating objects in number theory and algebraic geometry. In the early 1970's it was observed by McEliece and Rumsey <ref> [92] </ref>, that the weight distribution of irreducible cyclic codes is closely related to the behavior of Gaussian sums. Hence, they were the first to establish a connection between cyclic codes on the one hand, and cyclotomic fields on the other.
Reference: [93] <author> G. Miller. </author> <title> Riemann's hypothesis and tests for primality. </title> <journal> J. Comput. System Sci., </journal> <volume> 13 </volume> <pages> 300-317, </pages> <year> 1976. </year>
Reference-contexts: We will need at most roughly p 3=2 primality tests on integers of size O (log (p)) to obtain all the primes q we need. Assuming ERH, primes can be certified in poly-logarithmic time <ref> [93] </ref>. Hence, assuming ERH, the cost of this step is negligible as well. For each of the primes q we first reduce (x) modulo q. Next, we identify the group of (p 1)st roots of unity in F q . <p> (n)+(g)). (The bound for the discriminant is obtained by applying the Hadamard inequality to the Sylvester matrix.) Finally, we mention that, assuming the Extended Riemann Hypothesis (ERH), one can deterministically decide primality of an integer m in time ~ O (log (m) 4 ) using, e.g., Miller's primality testing algorithm <ref> [93] </ref>. 5.3 Decomposition of Primes and the Frobenius Automor phism Let L be a Galois number field with group G. Let p 2 Zbe a prime unramified in L. Denote by P a prime divisor of p in L.
Reference: [94] <author> M. Mitzenmacher. </author> <title> The Power of Two Choices in Randomized Load Balancing. </title> <type> PhD thesis, </type> <institution> UC Berkeley, </institution> <year> 1996. </year>
Reference-contexts: In the fist part of this section, we will state a general sharp concentration result. Such results have been obtained by Kurtz [66] who studied Markov jump processes, and have been used previously by many researchers, see <ref> [43, 64, 94, 95, 111, 167] </ref> and the references therein. We will, however, use a version due to Wormald [167] which has the advantage of being directly applicable to our situation. Next we will set up the appropriate system of differential equations, and solve them explicitly.
Reference: [95] <author> M. Mitzenmacher. </author> <title> Tight thresholds for the pure literal rule. </title> <type> Technical Report 1997-011, </type> <institution> DEC/SRC, </institution> <year> 1997. </year>
Reference-contexts: In the fist part of this section, we will state a general sharp concentration result. Such results have been obtained by Kurtz [66] who studied Markov jump processes, and have been used previously by many researchers, see <ref> [43, 64, 94, 95, 111, 167] </ref> and the references therein. We will, however, use a version due to Wormald [167] which has the advantage of being directly applicable to our situation. Next we will set up the appropriate system of differential equations, and solve them explicitly.
Reference: [96] <author> R. Motwani and P. Raghavan. </author> <title> Randomized Algorithms. </title> <publisher> Cambridge University Press, </publisher> <year> 1995. </year>
Reference-contexts: This is a typical example of a so-called sharp concentration result which we will derive in this subsection. We will assume that the reader is familiar with basic concepts such as (super- and sub-)martingales <ref> [96] </ref>. In the sequel we will follow [167] rather closely. The evolution of the number of nodes of different degrees on the graphs considered is a typical example of a discrete time random process. Let denote a probability space and S a measurable space. <p> steps. (See Remark (1.6).) Next we bound the probability that there is some j such that the fraction of left nodes lost on the left side of the graph B j is larger than ffi 0 := ffi + 1= 8 p a version of the Chernoff bounds given in <ref> [96, Prob. 4.7 (c), pp. 98] </ref>. <p> Proof. (1) From <ref> [96, Prob. 4.7 (c), p. 98] </ref>. (2) The specified tail-probability is evidently upper-bounded by the probability, if we threw the items into two bins so that each item had independent probability 0.5 of landing in the first bin, that the first bin would receive more than e=2 + ffin bad items. <p> Using (1) and <ref> [96, Prob. 4.6] </ref>, this probability is at most exp (2ffi 2 n). 2 (2.21) Theorem. Let C be an [n; k; d] q -AG-code built over an algebraic function field of genus g. Let ff := k + g 1 and fi := d p ffn + g 1e.
Reference: [97] <author> J. Neukirch. </author> <title> Class Field Theory. </title> <publisher> Springer Verlag, </publisher> <address> Heidelberg, Berlin, </address> <year> 1986. </year>
Reference-contexts: The basis for our algorithm is the following well-known theorem of M. Bauer (see, e.g. <ref> [97, Cor. 6.8] </ref>): K is a subfield of M if and only if all primes which split a factor of degree one in M do so in K. To apply this theorem, we randomly select primes, and test whether they split a factor of degree one in M . <p> Galois group of a normal irreducible polynomial g, if we know that the group is Abelian? (See also the paper [162].) (6) A well-known theorem (which is a consequence of the Chebotarev Density Theorem) states that Galois number fields are uniquely determined by the set of split rational primes (see <ref> [97, Cor. 6.9] </ref>). What kind of results can be obtained from this set of primes in random polynomial time? 155 5.12. Appendix: Bounding the Discriminant of the Normal Closure 5.12 Appendix: Bounding the Discriminant of the Normal Closure This section has been written by Joe Buhler.
Reference: [98] <author> M. Newman. </author> <title> A table of the first factor for prime cyclotomic fields. </title> <journal> Math. Comp., </journal> <volume> 24 </volume> <pages> 215-219, </pages> <year> 1970. </year>
Reference-contexts: Cyclic Codes and Cyclotomic Fields in 1974 the bounds 2 4:66 ln h (p) 4:66 ;(3.22) which shows that the growth of h is really fast. First calculations of the relative class number were done by Kummer [65], who computed these numbers for all primes below 163. Later, Newman <ref> [98] </ref>, Pa-junen [106], and Lehmer and Masley [73] extended these calculations to all primes below 512. The running time of the most sophisticated of these algorithms was O (p 5 log 2 p), see [44].
Reference: [99] <author> I. Niven and H.S. Zuckerman. </author> <title> An Introduction to the Theory of Numbers. </title> <publisher> Wiley, </publisher> <address> New York, 4th edition, </address> <year> 1980. </year>
Reference-contexts: Proof. (a) This is obvious from the recursion formulas. (b) The right hand inequality is well known, see <ref> [99] </ref>. For the left hand inequality observe first that (1 p p 2). Hence, by (a) we get P 2 k 2Q 2 (1) k .
Reference: [100] <author> J. </author> <title> Nonnenmacher and E.W. Biersack. Reliable multicast: Where to use forward error correction. </title> <booktitle> In Proc. 5th Workshop on Protocols for High Speed Networks, </booktitle> <institution> Sophia Antipolis, France, </institution> <year> 1996. </year>
Reference-contexts: There are many other applications of forward error-correction schemes, which we have not included here for limitations of space. Some examples include error recovery on long delay paths, power saving in mobile equipment, and various multicast applications. We refer the interested reader to the (incomplete) list of papers <ref> [100, 101, 120, 121] </ref> and the references therein. 42 Chapter 2 Decoding Algebraic Geometric Codes One of the most important developments in the theory of linear error-correcting codes has been the discovery of algebraic-geometric codes, AG-codes for short. They are arguably the most powerful codes known.
Reference: [101] <author> J. Nonnenmacher, E.W. Biersack, and D. Towsley. </author> <title> Parity-based loss recovery for reliable multicast transmission. </title> <booktitle> In SIGCOMM '97, </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: There are many other applications of forward error-correction schemes, which we have not included here for limitations of space. Some examples include error recovery on long delay paths, power saving in mobile equipment, and various multicast applications. We refer the interested reader to the (incomplete) list of papers <ref> [100, 101, 120, 121] </ref> and the references therein. 42 Chapter 2 Decoding Algebraic Geometric Codes One of the most important developments in the theory of linear error-correcting codes has been the discovery of algebraic-geometric codes, AG-codes for short. They are arguably the most powerful codes known.
Reference: [102] <editor> A.M. Odlyzko. On conductors and discriminants. In A. Frohlich, editor, </editor> <booktitle> Algebraic Number Fields, </booktitle> <pages> pages 377-407, </pages> <address> London, 1977. </address> <publisher> Academic Press. </publisher>
Reference-contexts: The estimate is based on k and the size of a certain subset of the Galois group of L. The proof of this lemma uses tools from analytic number theory, like effective versions of the Chebotarev Theorem [68, 103], and Odlyzko's bound on the discriminant of number fields <ref> [102] </ref>. We then proceed in sections 5.5-5.9 with the description and analysis of our algorithms. Section 5.10 contains a hardness result: we show that computing the smallest m such that K Q ( m ) is as hard as computing the largest square-free divisor of an integer. <p> From Odlyzko's bound on discriminants <ref> [102, pp. 381, (1.13)] </ref> we deduce that m (254 + ln (jdj))=20 13 ln (jdj), since L 6= Q. It follows that W (x) #G Li (x) 13 x ln (jdj) ln (x) : Let ff 1 := 5=2, ff 2 := (13000) ff 1 .
Reference: [103] <editor> J. Oesterle. Versions effectives du theoreme de Chebotarev sous l'hypothese de Riemann generalisee. Asterisque, </editor> <volume> 61 </volume> <pages> 165-167, </pages> <year> 1979. </year> <note> 165 BIBLIOGRAPHY </note>
Reference-contexts: In practice, it is easy to find the necessary primes. We can also easily prove that there are enough primes, at least if we assume the Extended Riemann Hypothesis. Indeed, the effective version of Dirichlet's theorem on arithmetic progressions in <ref> [103] </ref> says that the number of primes up to x that are congruent to 1 mod 2 n is within an error E (x) of its asymptotic value 2x=m log (x), where the error term is E (x) = 2 x log (x) + 4n log (2) log (x): (Compare also <p> The estimate is based on k and the size of a certain subset of the Galois group of L. The proof of this lemma uses tools from analytic number theory, like effective versions of the Chebotarev Theorem <ref> [68, 103] </ref>, and Odlyzko's bound on the discriminant of number fields [102]. We then proceed in sections 5.5-5.9 with the description and analysis of our algorithms. <p> Proof. We may suppose that M 6= Q since the number (x) of primes less than or equal to x is lower bounded by x= ln (x) for x 17, see [4, Th. 8.8.1]. Effective versions of the Chebotarev Density Theorem due to Lagarias and Odlyzko [68], and Oesterle <ref> [103] </ref> give W (x) #G Li (x) x 2 ln (jdj) + m ln (x) ; where m = [L : Q], d is the discriminant of L, and Li (x) = R x 2 dt =t is the logarithmic integral.
Reference: [104] <author> A.V. Oppenheim and R.W. Schafer. </author> <title> Digital Signal Processing. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1975. </year>
Reference-contexts: This method, called the Fast Fourier Transform (FFT), and variants thereof have ever since been an indispensable tool in many different areas that deal with processing of digital signals <ref> [63, 104] </ref>. Many applications of FFT's such as computer-tomography, geophysical signal processing, and high resolution imaging radars require high precision output. <p> Precise and Fast Fourier Transforms the calculation will require O (L log (L)) arithmetic operations, and one expects to lose `=2 bits in each component due to computational noise <ref> [104, 148] </ref>. Fix an integer n 3 as in Theorem (4.2), and let m = 2 n2 .
Reference: [105] <author> M.E. O'Sullivan. </author> <title> Decoding of codes defined by a single point on a curve. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 41 </volume> <pages> 1709-1719, </pages> <year> 1995. </year>
Reference-contexts: Remarkably, their work also gives an improved bound on the minimum distance of AG-codes and shows that their algorithm can actually correct up to this bound. Since then several other papers have appeared on the subject of decoding, see <ref> [36, 37, 105, 112, 122] </ref> Most of these algorithms fail if the number of errors exceeds the designed error-correction bound (d fl 1)=2, and all of them fail if the number of errors is larger than the true error-correction bound (d 1)=2, where d is the minimum distance of the code.
Reference: [106] <author> S. Pajunen. </author> <title> Computation of the growth of the first factor for prime cyclotomic fields. </title> <journal> BIT, </journal> <volume> 16 </volume> <pages> 85-87, </pages> <year> 1976. </year>
Reference-contexts: First calculations of the relative class number were done by Kummer [65], who computed these numbers for all primes below 163. Later, Newman [98], Pa-junen <ref> [106] </ref>, and Lehmer and Masley [73] extended these calculations to all primes below 512. The running time of the most sophisticated of these algorithms was O (p 5 log 2 p), see [44].
Reference: [107] <author> C.H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: We say that a language L is polynomial time reducible to a language L 0 , and denote it by L L 0 , if there is a polynomial time reduction from L to L 0 in the usual sense. (See, e.g., [49] or <ref> [107] </ref>.) 5.10.1 Known Results In this subsection we will gather some well-known results about the complexity of various computational problems in algebraic number theory. (5.24) Fact. The following problems are equivalent under polynomial time reduc tion: 150 Chapter 5.
Reference: [108] <author> V. Paxson. </author> <title> Measurements and Analysis of End-to-End Internet Dynamics. </title> <type> PhD thesis, </type> <institution> UC Berkeley, </institution> <year> 1997. </year>
Reference-contexts: We will also report on implementations of these codes and on strategies to enhance their performance. Throughout this chapter we will often ignore ceils (d e) and floors (b c). 1.1 Introduction Studies show that the Internet exhibits packet loss, and the measurements in <ref> [108] </ref> show that the situation has become worse over the past few years. A standard solution to this problem is to request retransmission of data that is not received. When some of this retransmission is lost, another request is made, and so on. In some applications, this introduces technical difficulties.
Reference: [109] <author> R. Pellikaan. </author> <title> On a decoding algorithm for codes on maximal curves. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 35 </volume> <pages> 1228-1232, </pages> <year> 1989. </year>
Reference-contexts: Denoting by n the block length of the code, the algorithm uses O (n 3 ) arithmetic operations. Skorbogatov and Vladut [144] generalized the ideas to arbitrary algebraic curves. Based on their results, Pellikaan <ref> [109] </ref> gave a polynomial time algorithm for decoding up to (d fl 1)=2 errors for codes constructed on maximal curves. This result was extended by Vladut [158] to any AG-code.
Reference: [110] <author> A. Peralta. </author> <title> A simple and fast probabilistic algorithm for computing square roots modulo a prime number. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 32 </volume> <pages> 846-847, </pages> <year> 1986. </year>
Reference-contexts: Chapter 2. Decoding Algebraic Geometric Codes If the characteristic of F q is not 2, then this problem may be readily solved, e.g., using an algorithm of <ref> [110] </ref>. (Although this algorithm is stated only for the case of prime q, it is in fact valid for any power of an odd prime.) This algorithm is probabilistic and requires an expected O (d log (q)) F q d -operations.
Reference: [111] <author> B. Pittel, J. Spencer, and N. Wormald. </author> <title> Sudden emergence of a giant k-core in a random graph. </title> <journal> J. Comb. Theory, Series B, </journal> <volume> 67 </volume> <pages> 111-151, </pages> <year> 1996. </year>
Reference-contexts: In the fist part of this section, we will state a general sharp concentration result. Such results have been obtained by Kurtz [66] who studied Markov jump processes, and have been used previously by many researchers, see <ref> [43, 64, 94, 95, 111, 167] </ref> and the references therein. We will, however, use a version due to Wormald [167] which has the advantage of being directly applicable to our situation. Next we will set up the appropriate system of differential equations, and solve them explicitly.
Reference: [112] <author> S.C. Porter, B.Z. Shen, and R. Pellikaan. </author> <title> Decoding geometric Goppa codes using an extra place. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 38 </volume> <pages> 1663-1676, </pages> <year> 1992. </year>
Reference-contexts: Remarkably, their work also gives an improved bound on the minimum distance of AG-codes and shows that their algorithm can actually correct up to this bound. Since then several other papers have appeared on the subject of decoding, see <ref> [36, 37, 105, 112, 122] </ref> Most of these algorithms fail if the number of errors exceeds the designed error-correction bound (d fl 1)=2, and all of them fail if the number of errors is larger than the true error-correction bound (d 1)=2, where d is the minimum distance of the code. <p> Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [56, 57]. The following lemma shows that it suffices to know a special basis of L ((2g+1)Q). (See also <ref> [112, Prop. 3] </ref>.) (2.3) Lemma. There exist ' 1 ; : : : ; ' g+2 in L ((2g + 1)Q) which have distinct pole orders at Q and thus form a basis of L ((2g + 1)Q).
Reference: [113] <author> M.O. Rabin. </author> <title> Efficient dispersal of information for security, load balancing, and fault tolerance. </title> <journal> J. ACM, </journal> <volume> 36 </volume> <pages> 335-348, </pages> <year> 1989. </year>
Reference-contexts: It is well-known that this matrix is totally regular. Furthermore, inverses of `fi`-Cauchy matrices can be determined explicitly in time O (` 2 ) <ref> [12, 113] </ref>. Based on this, the authors of [12] have designed a systematic encoder for an [n; k] q -MDS-code. Their particular implementation requires q to be a power of 2. This makes the encoding and loss recovery particularly efficient in software, as only XOR-operations are used.
Reference: [114] <author> C.M. Rader. </author> <title> Discrete convolution via Mersenne transforms. </title> <journal> IEEE Trans. Comp., </journal> <volume> C-21:1269-1273, </volume> <year> 1972. </year>
Reference-contexts: Any improvement of fixed-point computation so as to be more robust and accurate could lead to significantly less expensive chips in high precision FFT processors. These issues have led to suggestions for alternate FFT computations by many scientists <ref> [1, 30, 35, 114, 116, 117, 118] </ref>. Much of the research has concentrated on Residue Number System (RNS) processors.
Reference: [115] <author> I.S. Reed and G. Solomon. </author> <title> Polynomial codes over certain finite fields. </title> <journal> SIAM J. Appl. Math., </journal> <volume> 8 </volume> <pages> 300-304, </pages> <year> 1960. </year>
Reference-contexts: We then proceed with discussing one of the most well-known classes of linear codes, the so-called Reed-Solomon codes. In the decades since their discovery by Irving Reed and Gus Solomon <ref> [115] </ref>, Reed-Solomon codes have enjoyed countless applications, from compact disc players to spacecrafts and satellite communication. (For an interesting account of these codes and their use the reader is referred to [165].) Moreover, these can be used to transmit at the capacity of the erasure channel with O (n 1+* )
Reference: [116] <author> I.S. Reed and T.K. Truong. </author> <title> The use of finite fields to compute convolutions. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 21 </volume> <pages> 208-213, </pages> <year> 1975. </year>
Reference-contexts: Any improvement of fixed-point computation so as to be more robust and accurate could lead to significantly less expensive chips in high precision FFT processors. These issues have led to suggestions for alternate FFT computations by many scientists <ref> [1, 30, 35, 114, 116, 117, 118] </ref>. Much of the research has concentrated on Residue Number System (RNS) processors.
Reference: [117] <author> I.S. Reed and T.K. Truong. </author> <title> Complex integer convolution over a direct sum of Galois fields. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT-22:568-475, </volume> <year> 1976. </year>
Reference-contexts: Any improvement of fixed-point computation so as to be more robust and accurate could lead to significantly less expensive chips in high precision FFT processors. These issues have led to suggestions for alternate FFT computations by many scientists <ref> [1, 30, 35, 114, 116, 117, 118] </ref>. Much of the research has concentrated on Residue Number System (RNS) processors.
Reference: [118] <author> I.S. Reed and T.K. Truong. </author> <title> Convolutions over residue classes of quadratic integers. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> ASSP-24:343-344, </volume> <year> 1976. </year>
Reference-contexts: Any improvement of fixed-point computation so as to be more robust and accurate could lead to significantly less expensive chips in high precision FFT processors. These issues have led to suggestions for alternate FFT computations by many scientists <ref> [1, 30, 35, 114, 116, 117, 118] </ref>. Much of the research has concentrated on Residue Number System (RNS) processors.
Reference: [119] <author> D. Reischert. </author> <title> Private communication. </title> <year> 1995. </year>
Reference-contexts: Then, for each h encountered, we compute its transform, multiply it with the transform of v, and transform the product back. This reduces the number of Fourier transforms per polynomial multiplication from three to two. Another improvement can be gained using an idea of D. Reischert <ref> [119] </ref>. If p is not a Fermat prime, then the largest prime factor q t of p 1 is odd, hence we have to perform a negacyclic convolution of h (x) and v (x).
Reference: [120] <author> L. </author> <title> Rizzo. Effective erasure codes for reliable computer communication protocols. </title> <note> Obtainable from http://www.iet.unipi.it/~luigi/fec.ps, 1997. 166 BIBLIOGRAPHY </note>
Reference-contexts: There are many other applications of forward error-correction schemes, which we have not included here for limitations of space. Some examples include error recovery on long delay paths, power saving in mobile equipment, and various multicast applications. We refer the interested reader to the (incomplete) list of papers <ref> [100, 101, 120, 121] </ref> and the references therein. 42 Chapter 2 Decoding Algebraic Geometric Codes One of the most important developments in the theory of linear error-correcting codes has been the discovery of algebraic-geometric codes, AG-codes for short. They are arguably the most powerful codes known.
Reference: [121] <author> L. Rizzo and L. Vicisano. </author> <title> A reliable multicast data distribution protocol based on software FEC techniques. </title> <note> Obtainable from http://www.iet.unipi.it/~luigi, 1997. </note>
Reference-contexts: There are many other applications of forward error-correction schemes, which we have not included here for limitations of space. Some examples include error recovery on long delay paths, power saving in mobile equipment, and various multicast applications. We refer the interested reader to the (incomplete) list of papers <ref> [100, 101, 120, 121] </ref> and the references therein. 42 Chapter 2 Decoding Algebraic Geometric Codes One of the most important developments in the theory of linear error-correcting codes has been the discovery of algebraic-geometric codes, AG-codes for short. They are arguably the most powerful codes known.
Reference: [122] <author> S. Sakata, J. Justesen, Y. Madelung, H.E. Jensen, and T. Htholdt. </author> <title> Fast decoding of algebraic-geometric codes up to the designed minimum distance. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 41 </volume> <pages> 1672-1677, </pages> <year> 1995. </year>
Reference-contexts: Remarkably, their work also gives an improved bound on the minimum distance of AG-codes and shows that their algorithm can actually correct up to this bound. Since then several other papers have appeared on the subject of decoding, see <ref> [36, 37, 105, 112, 122] </ref> Most of these algorithms fail if the number of errors exceeds the designed error-correction bound (d fl 1)=2, and all of them fail if the number of errors is larger than the true error-correction bound (d 1)=2, where d is the minimum distance of the code.
Reference: [123] <author> T. Sander and M.A. Shokrollahi. </author> <title> Deciding properties of polynomials without factoring. </title> <type> Technical Report TR-97-027, </type> <institution> International Computer Science Institute, </institution> <year> 1997. </year>
Reference: [124] <author> T. Sander and M.A. Shokrollahi. </author> <title> Deciding properties of polynomials without factoring. </title> <booktitle> In Proc. 38th FOCS, </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference: [125] <author> A. Schonhage. </author> <title> Schnelle Berechnung von Kettenbruchentwicklungen. Act. </title> <journal> Inf., </journal> <volume> 1 </volume> <pages> 139-144, </pages> <year> 1971. </year>
Reference-contexts: Once the h e have been found, we compute the gcd of h and the different h e to obtain a partial factorization of h . The numbers involved have bit-length O (p log (p)), and fast gcd-algorithms <ref> [125] </ref> show that the running time of this step is negligible too. In summary, assuming ERH, our algorithm runs in time O (p 2 log 2 (p) log log (p)). It might seem that our algorithm is slower than Jha's [60]. This is due to an error in that paper.
Reference: [126] <author> A. Schonhage. </author> <title> Schnelle Multiplikation von Polynomen uber Korpern der Charakteristik 2. </title> <journal> Acta Inform., </journal> <volume> 7 </volume> <pages> 395-398, </pages> <year> 1977. </year>
Reference-contexts: Half of the elements of F 2 m have trace 1, so this algorithm requires an expected O (m) F 2 m -operations. Using fast algorithms for multiplication of polynomials over fields of characteristic 2 <ref> [126] </ref>, the expected number of bit-operations is O (m 2 log (m) log log (m)). 55 2.7. Decoding Reed-Solomon Codes 2.7 Decoding Reed-Solomon Codes Reed-Solomon codes (RS-codes) form a very important subclass of both the class of AG-codes and the class of cyclic codes.
Reference: [127] <author> A. Schonhage. </author> <title> Asymptotically fast algorithms for the numerical multiplication and division of polynomials with complex coefficients. </title> <editor> In J. Calmet, editor, </editor> <booktitle> Computer algebra EUROCAM'82, number 144 in Lecture Notes in Computer Science, </booktitle> <pages> pages 3-15, </pages> <year> 1982. </year>
Reference-contexts: We have thus reduced the problem to that of multiplying two polynomials of degree less than d over F q . We now use Schonhage's technique as presented in <ref> [127] </ref> to reduce this problem to that of multiplying integers.
Reference: [128] <author> A. Schonhage. </author> <title> Factorization of univariate integer polynomials by diophantine approximation and an improved basis reduction algorithm. </title> <booktitle> In Proc. 11th ICALP, </booktitle> <volume> volume LNCS 172, </volume> <pages> pages 437-447, </pages> <year> 1984. </year>
Reference-contexts: This makes the problem hard even for small input sizes. (One may be able to reduce this to O (n 12 ) using faster versions of the LLL-algorithm due to Schonhage <ref> [128] </ref>; however, we did not find an explicit reference to such an improvement in the literature.) Suppose now that you are given a pool of irreducible integer polynomials, from which you want to extract one that is normal, and in that case, to compute the roots of that polynomial as rational
Reference: [129] <author> A. Schonhage, A. Grotefeld, and E. Vetter. </author> <title> Fast Algorithms. </title> <publisher> Bibliographisches Institut, Mannheim, </publisher> <year> 1994. </year>
Reference-contexts: Translated into integer multiplication, this means that we are performing multiplication modulo 2 m + 1 for some m. If m is such that 32m = 2 k l &lt; (2k 1)2 2k , then one can perform the Schonhage-Strassen multiplication algorithm to compute this integer product. (See <ref> [129, p. 32] </ref>.) The advantage over the method which multiplies h and v as integers and reduces the product mod x q t + 1 is that the length of the numbers to be multiplied is smaller. (We do not need zero-padding in this version.) However, since 32m might contain a <p> These clean and efficient implementations made TP the natural choice to implement our algorithm in. For more information on this software and how to obtain it via ftp, the reader is referred to the TP-book <ref> [129] </ref>. Some timings of our program on different primes are provided in Table 3.1. The computations were done on a SPARC-10 with 40 MHz. The TP-code was compiled with E. <p> Some timings of our program on different primes are provided in Table 3.1. The computations were done on a SPARC-10 with 40 MHz. The TP-code was compiled with E. Vetter's tpc, which is a portable TPAL-compiler based on the GNU C-compiler. (See <ref> [129, Chapter 3] </ref>.) All the timings are in seconds. They were measured with the UNIX time-command. We also implemented a pure C-version of the third version. This version contained several strategies to deal with the huge amounts of memory needed for handling large d.
Reference: [130] <author> A. Schonhage and V. </author> <title> Strassen. </title> <journal> Schnelle Multiplikation groer Zahlen. Computing, </journal> <volume> 7 </volume> <pages> 281-292, </pages> <year> 1971. </year>
Reference-contexts: The running time of this algorithm is clearly dominated by the time needed to multiply two integers of bit-length dm, which, using the Schonhage-Strassen algorithm <ref> [130] </ref>, is O 3.6.2 Second Version of the Algorithm A major improvement can be gained by employing an idea related to the multiple evaluation algorithm of Borodin and Moenck [14] and [21, Chapter 3]. Let d = q 1 q t . <p> This proves Theorem (4.2). (4.40) Remark. The most realistic value for M (a) with reasonable values of the parameters is M (a) = a 2 ; in theory, one might replace this with the asymptotically fast value M (a) = O (a log (a) log log (a)) <ref> [130] </ref>. It is also conceivable that special-purpose chips would be constructed, so that M (a) would represent a more general notion of complexity, such as chip area, running time, or dollars. <p> For the analysis of our algorithms we will use some well known results gathered in this section. The reader can consult [21, Chapters 2 and 3] for a discussion of these topics and further references. Using the Schonhage-Strassen algorithm <ref> [130] </ref>, addition, subtraction, multiplication, and the remainder of the division of an `-bit integer and a k-bit integer can be computed with ~ O () operations, where is the maximum of ` and k.
Reference: [131] <author> I.R. Shafarevich. </author> <title> Construction of fields of algebraic numbers with given solvable Galois group. </title> <journal> Izv. Akad. Nauk SSSR. Ser. Mat., </journal> <volume> 18 </volume> <pages> 525-578, </pages> <year> 1954. </year>
Reference-contexts: Set U := ht i fi 1. A famous theorem of Shafarevich <ref> [131] </ref> states that every solvable group G is realizable over Q as the Galois group of a number field L. Hence, we obtain K as the fixed field of U . * 140 Chapter 5.
Reference: [132] <author> M.A. Shokrollahi. </author> <title> Codes on Hermitian curves. </title> <editor> In Th. Beth and M. Clausen, editors, </editor> <booktitle> Proc. AAECC-4, number 307 in Lecture Notes in Computer Science, </booktitle> <pages> pages 168-176. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: In all of these cases the crucial assertion is that S is polynomial in n. To prove this, we will explicitly construct the functions ' i . The basis computation for elliptic function fields is trivial. The basis computation for Hermitian function fields is well known: e.g., refer to <ref> [132, 146] </ref>. However, our basis computation for the case of F 3 seems to be novel. Throughout this section we assume familiarity with the theory of algebraic function fields as presented in [147]. 62 Chapter 2.
Reference: [133] <author> M.A. Shokrollahi. </author> <title> Beitrage zur Codierungs- und Komplexitatstheorie mittels algebraischer Funktionenkorper. </title> <journal> Bayreuth. math. Schriften, </journal> <volume> 39 </volume> <pages> 1-236, </pages> <year> 1992. </year>
Reference-contexts: The quantity d fl := nff is called the designed distance of C. For further information on AG-codes, we refer the reader to <ref> [53, 54, 133, 147, 153] </ref>. The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [56, 57].
Reference: [134] <author> M.A. Shokrollahi. </author> <title> Efficient randomized generation of algorithms for multiplication in certain finite fields. </title> <journal> Comp. Compl., </journal> <volume> 2 </volume> <pages> 67-96, </pages> <year> 1992. </year> <note> 167 BIBLIOGRAPHY </note>
Reference-contexts: This step depends on the presentation of the algebraic function field (or the curve) and can be performed off-line using probabilistic methods. (For a demonstration of how to do this in the case of elliptic curves, for instance, the reader may consult <ref> [134] </ref>.) Now suppose that ' 1 ; : : : ; ' ` is a basis of the space L (ffQ).
Reference: [135] <author> M.A. Shokrollahi. </author> <title> Computation of irregular primes up to eight million. </title> <type> Technical Report TR-96-002, </type> <institution> International Computer Science Institute, </institution> <year> 1995. </year>
Reference-contexts: In addition, the computations of irregular pairs are the starting point for a verification of the Vandiver conjecture, see Section 3.7.2. Meanwhile we have extended these computation of irregular pairs to all primes below eight million <ref> [17, 135] </ref>. Our algorithm, which we will describe in later sections, is in part based on the following proposition. (3.16) Proposition.
Reference: [136] <author> M.A. Shokrollahi. </author> <title> Stickelberger codes. Designs, </title> <journal> Codes and Cryptography, </journal> <volume> 9 </volume> <pages> 1-11, </pages> <year> 1996. </year>
Reference-contexts: Davenport-Hasse in the 1930's [33]: they are essentially the above Gaussian sums! This gives a more substantial insight into the deep connection between cyclic codes and cyclotomic fields. (See the papers [155, 67, 166] for a discussion of these and related results.) Inspired by these results the author took in <ref> [136] </ref> a different approach to study possible other relationships between cyclic codes and Gaussian sums. The main topic of that paper was the study of reductions of Stickelberger ideals modulo primes. We call them Stickelberger codes. These codes and their main parameters will be reviewed in Section 3.3. <p> So, the only possible zero of w (x) among the nonzero elements of F fi p , which is not a zero of S p (p), is w. Hence, the result follows. 2 The following theorem contains information on the parameters of Stickelberger codes. (Compare also <ref> [136] </ref>.) (3.13) Theorem. (1) Let q be a prime ideal of Q ( p1 ) above the prime q.
Reference: [137] <author> M.A. Shokrollahi and V. Stemann. </author> <title> Approximation of complex numbers by algebraic integers. </title> <type> Technical Report TR-96-033, </type> <institution> International Computer Science Institute, </institution> <year> 1996. </year>
Reference: [138] <author> M.A. Shokrollahi and V. Stemann. </author> <title> A simple approximation algorithm in Z[e 2i=8 ]. Technical Report TR-96-032, </title> <booktitle> International Computer Science Institute, </booktitle> <year> 1996. </year>
Reference: [139] <author> J.H. Silverman. </author> <title> The Arithmetic of Elliptic Curves, volume 106 of Graduate Texts in Mathematics. </title> <publisher> Springer Verlag, </publisher> <year> 1986. </year>
Reference-contexts: It is well known that K has genus 1. (For these and related facts about elliptic curves, the reader may consult standard texts such as <ref> [139] </ref>.) Evidently, the size of f as well as [K: L] are constants. Thus we need only construct basis functions ' 1 ; : : : ; ' n and show that S, the sum of their sizes, is polynomial in n.
Reference: [140] <author> W. Sinnott. </author> <title> On the Stickelberger ideal and the circular units of a cyclotomic field. </title> <journal> Ann. of Math., </journal> <pages> pages 107-134, </pages> <year> 1978. </year>
Reference-contexts: Several questions remain: (1) Stickelberger codes do not yield interesting codes for coding theorists. One reason for this may be that we are only working over cyclotomic fields. Is it possible to obtain better codes as reductions of more general Stickelberger ideals, for instance those discussed in <ref> [140, 141, 142] </ref>? The next remark is highly speculative. (2) On the other hand, is it possible to use a coding theory approach to S p (q) to prove interesting number theoretic results? One possible direction to go would be to realize the Stickelberger codes as algebraic geometric codes.
Reference: [141] <author> W. Sinnott. </author> <title> On the Stickelberger ideal and the circular units of an abelian field. </title> <journal> Invent. Math., </journal> <pages> pages 181-234, </pages> <year> 1980. </year>
Reference-contexts: Several questions remain: (1) Stickelberger codes do not yield interesting codes for coding theorists. One reason for this may be that we are only working over cyclotomic fields. Is it possible to obtain better codes as reductions of more general Stickelberger ideals, for instance those discussed in <ref> [140, 141, 142] </ref>? The next remark is highly speculative. (2) On the other hand, is it possible to use a coding theory approach to S p (q) to prove interesting number theoretic results? One possible direction to go would be to realize the Stickelberger codes as algebraic geometric codes.
Reference: [142] <author> W. Sinnott. </author> <title> On the Stickelberger ideal and the circular units of an abelian field. In Sem. de Theorie des Nombres, </title> <address> Paris 1979-1980, </address> <pages> pages 277-286. </pages> <publisher> Birkhauser: </publisher> <address> Boston-Basel-Stuttgart, </address> <year> 1981. </year>
Reference-contexts: Several questions remain: (1) Stickelberger codes do not yield interesting codes for coding theorists. One reason for this may be that we are only working over cyclotomic fields. Is it possible to obtain better codes as reductions of more general Stickelberger ideals, for instance those discussed in <ref> [140, 141, 142] </ref>? The next remark is highly speculative. (2) On the other hand, is it possible to use a coding theory approach to S p (q) to prove interesting number theoretic results? One possible direction to go would be to realize the Stickelberger codes as algebraic geometric codes.
Reference: [143] <author> M. Sipser and D. Spielman. </author> <title> Expander codes. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 42 </volume> <pages> 1710-1722, </pages> <year> 1996. </year>
Reference-contexts: However, our construction can be modified using pre-fetching strategies to yield linear time algorithms for random access machines with logarithmic cost. The modification is quite similar to that given in <ref> [143] </ref>. The simplicity of our algorithms makes these codes excellent candidates for forward error-correction techniques in high speed networks. However, implementations suggest that our codes are good only for large block lengths.
Reference: [144] <author> A.N. Skorbogatov and S.G. Vladut. </author> <title> On decoding of algebraic-geometric codes. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 36 </volume> <pages> 1051-1060, </pages> <year> 1990. </year>
Reference-contexts: Denoting by n the block length of the code, the algorithm uses O (n 3 ) arithmetic operations. Skorbogatov and Vladut <ref> [144] </ref> generalized the ideas to arbitrary algebraic curves. Based on their results, Pellikaan [109] gave a polynomial time algorithm for decoding up to (d fl 1)=2 errors for codes constructed on maximal curves. This result was extended by Vladut [158] to any AG-code.
Reference: [145] <author> D. Spielman. </author> <title> Linear-time encodable and decodable error-correcting codes. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 42 </volume> <pages> 1723-1731, </pages> <year> 1996. </year>
Reference-contexts: They can also be encoded in time proportional to n ln (1=*). The fastest previously known encoding and decoding algorithms [3] with such a performance guarantee have run times proportional to n ln (1=*)=*. The overall structure of our codes are related to codes introduced in <ref> [145] </ref> for error-correction. We explain the general construction along with the encoding and decoding algorithms in Section 1.3. Our encoding and decoding algorithms are almost symmetrical. Both are extremely simple, computing exactly one exclusive-or operation for each edge in a randomly chosen bipartite graph. <p> A precise statement of this will be provided later in Section 1.4. We will explain the overall construction of the codes which is related to codes introduced in <ref> [145] </ref> for error-correction. <p> Although the idea of using sparse bipartite graphs for constructing codes is not new <ref> [45, 145] </ref>, the construction of the graphs in each of the layers is novel. We obtained the construction by analyzing a simple loss 39 1.8. Conclusions and Open Problems recovery algorithm. The analysis used results asserting the sharp concentration of parameters in a discrete random process around their means.
Reference: [146] <author> H. Stichtenoth. </author> <title> A note on Hermitian codes over GF (q 2 ). IEEE Trans. </title> <journal> Inform. Theory, </journal> <volume> 34 </volume> <pages> 1345-1348, </pages> <year> 1988. </year>
Reference-contexts: In all of these cases the crucial assertion is that S is polynomial in n. To prove this, we will explicitly construct the functions ' i . The basis computation for elliptic function fields is trivial. The basis computation for Hermitian function fields is well known: e.g., refer to <ref> [132, 146] </ref>. However, our basis computation for the case of F 3 seems to be novel. Throughout this section we assume familiarity with the theory of algebraic function fields as presented in [147]. 62 Chapter 2.
Reference: [147] <author> H. Stichtenoth. </author> <title> Algebraic Function Fields and Codes. </title> <publisher> Universitext. Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Section 2.11 also includes a novel basis computation for the Garcia Stichtenoth function field F 3 . Finally, Section 2.12 gives conclusions and poses open problems. 2.2 AG-Codes Throughout this chapter we will use the terminology of algebraic function fields, for which we refer the reader to <ref> [147] </ref>. Let K=F q be an algebraic function field of one variable with field of constants F q , genus g, and distinct prime divisors of degree one Q; P 1 ; : : : ; P n . Let ff be a non-negative integer less than n. <p> The quantity d fl := nff is called the designed distance of C. For further information on AG-codes, we refer the reader to <ref> [53, 54, 133, 147, 153] </ref>. The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [56, 57]. <p> The basis computation for Hermitian function fields is well known: e.g., refer to [132, 146]. However, our basis computation for the case of F 3 seems to be novel. Throughout this section we assume familiarity with the theory of algebraic function fields as presented in <ref> [147] </ref>. 62 Chapter 2. Decoding Algebraic Geometric Codes 2.11.1 Elliptic Codes For simplicity we will assume in this subsection that the characteristic of F q is different from 2 or 3.
Reference: [148] <author> R. Storn. </author> <title> Algorithmen und Architekturen der diskreten Fourier Transformation zur schnellen Faltung reeller Signale. </title> <type> PhD thesis, </type> <institution> Universitat Stuttgart, </institution> <year> 1990. </year>
Reference-contexts: Precise and Fast Fourier Transforms the calculation will require O (L log (L)) arithmetic operations, and one expects to lose `=2 bits in each component due to computational noise <ref> [104, 148] </ref>. Fix an integer n 3 as in Theorem (4.2), and let m = 2 n2 .
Reference: [149] <author> M. Sudan. </author> <title> Maximum likelihood decoding of Reed-Solomon codes. </title> <booktitle> In Proc. 37th FOCS, </booktitle> <pages> pages 164-172, </pages> <year> 1996. </year> <note> 168 BIBLIOGRAPHY </note>
Reference-contexts: The decoding task associated with an [n; k; e; b] q -code requires methods quite different from those customarily employed for error-correction. This task was first considered by Sudan <ref> [149, 150] </ref>, who investigated alternative decoding algorithms for Reed-Solomon codes. He derived the surprising result that an [n; k] q Reed-Solomon code is an [n; k; e; b] q -code such that e is approximately n p is approximately p 2n=k.
Reference: [150] <author> M. Sudan. </author> <title> Decoding of Reed-Solomon codes beyond the error-correction bound. </title> <journal> J. Compl., </journal> <volume> 13 </volume> <pages> 180-193, </pages> <year> 1997. </year>
Reference-contexts: This means that these algorithms fail if more than e errors have occurred during the transmission. In this chapter, we will discuss algorithms that surpass this difficulty. Generalizing Sudan's results <ref> [150] </ref> on Reed-Solomon codes we design algorithms to decode AG-codes above the error correction bound! Furthermore, we show that, under some mild conditions, these algorithms run in time polynomial in the block length of the code. Our general decoding algorithm requires factorization of polynomials over algebraic function fields. <p> The decoding task associated with an [n; k; e; b] q -code requires methods quite different from those customarily employed for error-correction. This task was first considered by Sudan <ref> [149, 150] </ref>, who investigated alternative decoding algorithms for Reed-Solomon codes. He derived the surprising result that an [n; k] q Reed-Solomon code is an [n; k; e; b] q -code such that e is approximately n p is approximately p 2n=k. <p> Suppose that y = (y 1 ; : : : ; y n ) 2 F n q is such that x and y agree in at least fi + 1 coordinate places. We will prove that the following algorithm (a generalization of Sudan's <ref> [150] </ref>) computes a list of at most p codewords one of which must be x: (1) (Interpolation Step) Let s := b (fi g + 1)=ffc. <p> Decoding Algebraic Geometric Codes It is now straightforward to check that L (nQ) has a basis as specified in Theorem (2.28)(2) whose size is polynomial in n. 2.12 Conclusions and Open Problems We have generalized Sudan's Reed-Solomon results <ref> [150] </ref> to algebraic-geometric codes. We have introduced the class of [n; k; e; b] q -codes, and have demonstrated that there exist [n; k; e; b] q -AG-codes for which e is surprisingly close to n while k=n is bounded away from zero and b is small.
Reference: [151] <author> J.W. Tanner and S.S. Wagstaff. </author> <title> New congruences for Bernoulli numbers. </title> <journal> Math. Comp., </journal> <volume> 48 </volume> <pages> 341-350, </pages> <year> 1987. </year>
Reference-contexts: The irregular pairs were computed for primes less than 125000 by [159] and then to 150000 by <ref> [151] </ref>. <p> In this section we will report on two such applications, which, up to now have always accompanied the computations of the irregular pairs, see <ref> [19, 40, 41, 151, 159] </ref>. For n 1 let K n denote the cyclotomic field Q ( p n+1 ), and let h n and A n be the class number and p-class group of K n , respectively.
Reference: [152] <author> H. Toyama. </author> <title> A note on the different of the composed field. </title> <journal> Kodai Math. Sem. Report, </journal> <volume> 7 </volume> <pages> 43-44, </pages> <year> 1955. </year>
Reference-contexts: M) m d (K) [ ^ M:Q] j disc (h) mn! disc (g) n! : (We use the well-known fact that d (N 1 N 2 ) divides d (N 1 ) [N 2 :Q] d (N 2 ) [N 1 :Q] , which follows from a theorem of Toyama <ref> [152] </ref>.) Hence, x ff 2 (ln (jd (L)j)) ff 1 and, as in the proof of the previous corollary, we can apply Lemma (5.3) to obtain the assertion. 2 (5.6) Remark. The constants given in the last theorem are far from optimal.
Reference: [153] <author> M.A. Tsfasman and S.G. Vladut. </author> <title> Algebraic-Geometric Codes. Mathematics and Its Applications. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Dordrecht, </address> <year> 1991. </year>
Reference-contexts: The quantity d fl := nff is called the designed distance of C. For further information on AG-codes, we refer the reader to <ref> [53, 54, 133, 147, 153] </ref>. The encoding algorithm for an AG-code requires us to know a specific basis of L (ffQ). Such bases can be constructed in polynomial time in some cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [56, 57].
Reference: [154] <author> M.A. Tsfasman, S.G. Vladut, and Th. Zink. </author> <title> Modular curves, Shimura curves, and Goppa codes better than the Varshamov-Gilbert bound. </title> <journal> Math. Nachrichten, </journal> <volume> 109 </volume> <pages> 21-28, </pages> <year> 1982. </year>
Reference-contexts: Manin [88] has proved the continuity of ff q . This motivates us to ask: (6) Are fi b q , and fi R q continuous? We have proved lower bounds analogous to the Tsfasman-Vladut-Zink bound <ref> [154] </ref> for fi b q , and fi R q . However, these lower bounds do not appear to be tight. In particular, it would be of pragmatic interest to find lower bounds which are nontrivial when the field size q is small or the rate R is high.
Reference: [155] <author> G. van der Geer, R. Schoof, and M. van der Vlugt. </author> <title> Weight formulas for ternary Melas codes. </title> <journal> Math. Comp., </journal> <volume> 58 </volume> <pages> 781-792, </pages> <year> 1992. </year>
Reference-contexts: It is more than a mere coincidence that these numbers have already been determined by Davenport-Hasse in the 1930's [33]: they are essentially the above Gaussian sums! This gives a more substantial insight into the deep connection between cyclic codes and cyclotomic fields. (See the papers <ref> [155, 67, 166] </ref> for a discussion of these and related results.) Inspired by these results the author took in [136] a different approach to study possible other relationships between cyclic codes and Gaussian sums. The main topic of that paper was the study of reductions of Stickelberger ideals modulo primes.
Reference: [156] <author> A. Vardy. </author> <title> The intractability of computing the minimum distance of a code. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 43, </volume> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Codes for which equality holds in (1.2) are called maximum distance separable codes, or MDS-codes for short. From an algorithmic point of view, erasure recovery and decoding are completely different in nature. The decoding problem for general linear codes is NP-complete <ref> [10, 156] </ref>. However, erasure recovery can be performed efficiently for any linear code, as is shown by the next result. (See also [39].) (1.3) Proposition.
Reference: [157] <author> E. Vetter. </author> <title> Private communication. </title> <year> 1995. </year>
Reference-contexts: Vetter <ref> [157] </ref>. The RMP passed the prime to the first machine available which had the amount of RAM necessary to compute the irregular pairs. Furthermore, the RMP also allowed the use of specific time windows for computations on different machines (usually during the night and at weekends).
Reference: [158] <author> S.G. Vladut. </author> <title> On the decoding of algebraic-geometric codes over F q for q 16. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 36 </volume> <pages> 1461-1463, </pages> <year> 1990. </year>
Reference-contexts: Skorbogatov and Vladut [144] generalized the ideas to arbitrary algebraic curves. Based on their results, Pellikaan [109] gave a polynomial time algorithm for decoding up to (d fl 1)=2 errors for codes constructed on maximal curves. This result was extended by Vladut <ref> [158] </ref> to any AG-code. Later, Justesen et al. [62] improved on their original procedure by designing an algorithm which could correct up to (d fl g=2 1)=2 errors using O (n 7=3 ) arithmetic operations. This result was generalized by Dahl [32] to arbitrary AG-codes.
Reference: [159] <author> S.S. Wagstaff. </author> <title> The irregular primes to 125000. </title> <journal> Math. Comp., </journal> <volume> 32 </volume> <pages> 583-591, </pages> <year> 1978. </year>
Reference-contexts: The number of irregular pairs for p is called the index of irregularity of p, and is denoted by i (p); p is called regular if i (p) = 0, and is called irregular otherwise. The irregular pairs were computed for primes less than 125000 by <ref> [159] </ref> and then to 150000 by [151]. <p> Associated to each irregular prime p there are the so-called cyclotomic invariants which describe the class groups of the cyclotomic fields with p-power conductor. These invariants are known up to four million as well, thanks to the work in <ref> [159, 40, 41, 19] </ref>. In addition, the computations of irregular pairs are the starting point for a verification of the Vandiver conjecture, see Section 3.7.2. Meanwhile we have extended these computation of irregular pairs to all primes below eight million [17, 135]. <p> In this section we will report on two such applications, which, up to now have always accompanied the computations of the irregular pairs, see <ref> [19, 40, 41, 151, 159] </ref>. For n 1 let K n denote the cyclotomic field Q ( p n+1 ), and let h n and A n be the class number and p-class group of K n , respectively.
Reference: [160] <author> L.C. </author> <title> Washington. Introduction to cyclotomic fields, volume 83 of Graduate Texts in Mathematics. </title> <publisher> Springer Verlag, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1996. </year>
Reference-contexts: Hence, B 1;! i 2 O for i 6= 1. If i = 1, the same kind of reasoning gives ord p (B 1;! 1 ) = 1. Summarizing we obtain the following. (See also <ref> [160] </ref>.) 69 3.2. Preliminaries on Cyclotomic Fields (3.1) Proposition. Let q be a prime ideal of Q ( p1 ) above the prime q, and let O be the localization of the ring of integers of Q ( p1 ) at q. <p> The quotient h (K) := h (K)=h (K) + is called the relative class number of K. Comparing the values for h (K) and h (K) + obtained by the analytic class number formula, one obtains (see <ref> [160, Theorem 4.17, Corollary 4.13] </ref>) h (K) = Qw 2 where runs over all odd characters of the Galois group of K=Q, w is the index of roots of unity in K, and Q is defined as follows: Q = [E: W E + ], where E and E + are <p> [G] is defined by = p c=1 The Stickelberger ideal S p of Z [G] is defined by S p := Z [G] " Z [G]: The arithmetic significance of the Stickelberger ideal is given by the fact that it annihilates the ideal class group of Q ( p ) <ref> [160, Theorem 6.10] </ref>. One can easily compute a finite set of generators for S p . (3.4) Proposition. We have S p = c=1 Proof. <p> One can easily compute a finite set of generators for S p . (3.4) Proposition. We have S p = c=1 Proof. S p is generated by the elements (c c ), where c runs over all integers prime to p. (See <ref> [160, Lemma 6.9] </ref>.) We have (kp + b kp+b ) = kp + (b b ): The assertion follows. 2 The constant reduction Z [G] ! F q [G] maps S p onto an ideal S p (q) of F q [G]. <p> Another example is given by (p; q) = (227; 2939). Using our algorithm given in Section 3.8 or consulting the tables at the end of <ref> [160] </ref> we see that ord q (h (p)) = 3. However, applying Proposition (3.7), we find that dim S p (q) = (p + 1)=2 1 and not (p + 1)=2 3. <p> Two Computational Problems Proof. The proof is easy and uses Proposition (3.10) and the congruence B 1;! n n + 1 holding for all odd n satisfying n 6 1 mod (p 1), see <ref> [160, Corollary 5.15] </ref>. 2 The proposition says that (p; 2t) is an irregular pair if and only if w (w p2t ) = 0 in F p . Hence, for computing irregular pairs it suffices to find all values of the polynomial w over F p . <p> If q m 6 1 mod L for all t for a given p, then Vandiver's conjecture is true for p. (See <ref> [160] </ref> for details.) The next application is concerned with the problem of computing the so-called cyclotomic invariants. <p> By Iwasawa's general result and the theorem of Ferrero and Washington <ref> [160, Chapter 13] </ref> we have ord p (h n ) = p n + -p ; ord p (h p n + - for all n large enough, say n n p , where p ; -p ; p ; - p are integers ( p ; p non negative) independent <p> Namely, if the numerators of the Bernoulli numbers are uniformly distributed mod p then for each prime p there are roughly p=2 events where the probability of success is 1=p so that one expects the distribution to be Poisson with mean 1=2, see, e.g., <ref> [160, p. 63] </ref>. Several people have asked whether or not the proportions have any trend. <p> In particular, the class groups behave as expected and the -invariant is equal to the index of irregularity for all primes up to eight million. On heuristic grounds there is a small probability that the -invariant could be larger than the index of irregularity (see <ref> [160] </ref> for a thorough discussion), but so far this has not happened. In both of the Vandiver and cyclotomic invariant calculations it is interesting to assess the probability of an "exceptional event" (i.e., a counterexample to the Vandiver conjecture or a -invariant exceeding the index of irregularity). <p> Of course, one possible explanation for the lack of exceptional events is that none exist; in other words, these tempting heuristics are wrong for theoretical reasons that we don't yet understand. For a more thorough discussion of some of these questions see <ref> [160] </ref>. 3.8 Computing the Relative Class Number In the previous sections we developed an algorithm to test for a given prime p whether it divides the relative class number h of the field Q ( p ). In this section, we develop an algorithm for computing h itself. <p> We will later use the results stated here to derive our approximation algorithms in Sections 4.6 and 4.7. Proofs of the classic results not explicitly proved here can be found in, e.g., Washington's book <ref> [160] </ref>. 4.3.1 Explicit Galois Theory Let n := e 2 n , and K n := Q ( n ) be the cyclotomic field generated over Q by n . (Caveat: the notation is slightly different from that of Chapter 3.) K n has a Q-basis (1; n ; : : <p> The following important fact holds for the matrix ffi := (log j (i) (4.13) Theorem. The matrix ffi is invertible. A proof of this classic result can be found in <ref> [160, Chap. 8.1] </ref>. <p> This result suggests the following generalization of the general approximation algorithm GAA: suppose that Q (w) is a CM-field <ref> [160, pp. 38] </ref>, i.e., Q (w) = Q (ff)(i), where ff is a totally real element. Suppose further that we already know a set of units of the ring Z [w i + w i j i 0] with nonvanishing regulator, where bar means complex conjugation. <p> By Dirichlet's Unit Theorem <ref> [160] </ref> the number n equals [Q (w): Q]=2. Abelian number fields satisfy the above assumptions. Hence, our algorithm is readily extendable to all these fields. 4.10 Conclusion In this chapter we have introduced an abstract processor for high-precision FFT-computations which operates using fixed-point arithmetic. <p> Fortunately we do know the set of primes which split completely in Q ( n ): these are exactly the primes p 1 mod m (see, e.g., <ref> [160, Chapter 2] </ref>). This additional information allows us now to obtain a randomized efficient solution to the problem "K Q ( n )?" (see (5.16) Theorem. Let K be generated by a root of a polynomial g of degree m and let n be a non-negative integer. <p> How can we solve this problem with our methods? Let K be an Abelian extension of Q. By the celebrated Theorem of Kronecker and Weber <ref> [160, Chapter 14] </ref> there exists a positive integer f such that K is contained in a cyclotomic field Q ( f ). The smallest such f is called the conductor of K. <p> Furthermore, the conductor f (K) of K equals the least common multiple of the conductors f , 2 X. The conductor-discriminant formula (see <ref> [160, Th. 3.11] </ref>) relates the discriminant d (K) of K and the conductors of characters in X in the following way: jd (K)j = 2X In the sequel the conductor of a subgroup of a Galois group is meant to be the conductor of the corresponding fixed field. <p> The first case occurs if and only if ord 2 (d (K)) = n`. Proof. Let X p denote the group f p j 2 Xg. By <ref> [160, Th. 3.5] </ref>, we know that jX p j equals the ramification index e p of p in K. <p> The conductor of M equals the least common multiple of f , 2 X 2 , and is equal to the 2-part of the conductor of K. In the first case M has conductor 2 `+1 and ord 2 (d (M )) = `2 ` , see <ref> [160, Prop. 2.1] </ref>.
Reference: [161] <author> H. Wasserman. </author> <title> Reconstructing randomly sampled multivariate polynomials from highly noisy data. </title> <booktitle> Publication in progress, </booktitle> <year> 1997. </year>
Reference-contexts: Here we shall accompany our existence result with an efficient decoding algorithm. Indeed, this algorithm will have the advantage of being more efficient than our main algorithm of Section 2.4. 57 2.8. Unique Decoding for Random Noise The new algorithm (which extends a method of <ref> [161] </ref>) is suggested by the proof of Theorem (2.2). In that proof, one constructs a polynomial G such that G (P i ; y i ) = 0 for i = 1; : : : ; n.
Reference: [162] <author> P.J. Weinberger. </author> <title> Finding the number of factors of a polynomial. </title> <journal> Journal of Algorithms, </journal> <volume> 5 </volume> <pages> 180-186, </pages> <year> 1984. </year>
Reference-contexts: In some cases (as in the cyclicity test) this might be enough. Is there a way to quickly find a "good guess" for the structure of the Galois group of a normal irreducible polynomial g, if we know that the group is Abelian? (See also the paper <ref> [162] </ref>.) (6) A well-known theorem (which is a consequence of the Chebotarev Density Theorem) states that Galois number fields are uniquely determined by the set of split rational primes (see [97, Cor. 6.9]).
Reference: [163] <author> L.R. Welch and R.A. Sholtz. </author> <title> Continued fractions and Berlekamp's algorithm. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 25 </volume> <pages> 18-27, </pages> <year> 1979. </year>
Reference-contexts: Asymptotically fast software implementations are based on variants of the extended Euclidean algorithm <ref> [23, 34, 91, 163] </ref>. (See also [21, Ex. 3.9].) Their running time is O (n log 2 (n) log log (n)), where n is the block length of the code [21, Chap. 3]. The decoding algorithms of last section can be specialized to RS-codes in the following way.
Reference: [164] <author> P.D. Welch. </author> <title> A fixed-point fast Fourier transform error analysis. </title> <journal> IEEE Trans. Audio and Electroacoustics, </journal> <volume> 17 </volume> <pages> 151-157, </pages> <year> 1969. </year>
Reference-contexts: An error analysis reveals that, when performed on fixed-point arithmetic units, the usual Cooley-Tukey FFT algorithms lose roughly `=2 bits, on average, of precision for Fourier transforms of vectors of length 2 ` , see, e.g., <ref> [164] </ref>. This phenomenon, often referred to as computational noise, is caused by inaccurate computations due to limited dynamic range.
Reference: [165] <editor> S.B. Wicker and V.K. Bhargava, editors. </editor> <title> Reed-Solomon Codes and their Applications. </title> <publisher> IEEE Press, </publisher> <year> 1994. </year> <note> 169 BIBLIOGRAPHY </note>
Reference-contexts: In the decades since their discovery by Irving Reed and Gus Solomon [115], Reed-Solomon codes have enjoyed countless applications, from compact disc players to spacecrafts and satellite communication. (For an interesting account of these codes and their use the reader is referred to <ref> [165] </ref>.) Moreover, these can be used to transmit at the capacity of the erasure channel with O (n 1+* ) encoding time and quadratic decoding time. These codes have recently been customized to compensate for Internet packet loss in real-time transmission of moderate-quality video [2]. <p> decoding time of RS-codes makes them less desirable for protection of huge amounts of data (like frames in high-quality video) on networks which encorporate small packets, if the algorithms are to run in software. (This is not necessarily true for hardware applications; see, e.g., the article by Berlekamp et al. <ref> [165, Chap. 10] </ref>.) Even asymptotically fast algorithms seem not to be well-suited for this task, as the constants encorporated in these algorithms are of moderate size. Whether or not faster algorithms exist is an open problem. However, loss recovery for RS-codes amounts to polynomial interpolation, and there 9 1.3. <p> However, RS-codes are usually used for their excellent error correction capabilities, rather than as erasure codes. Typical applications of these codes include CD-players, DAT-recorders, or satellite and deep space communication. For an excellent survey on practical uses of this important class of codes, the reader is referred to <ref> [11, 168, 165] </ref>. RS-codes are very attractive for various reasons: they are MDS-codes which means that they have the largest possible minimum distance for a given block length and a given dimension; this makes them natural candidates for decoding bursts of errors [87, Ch. 10,x6].
Reference: [166] <author> J. Wolfman. </author> <title> New bounds on cyclic codes from algebraic curves, </title> <booktitle> volume 388 of Lecture Notes in Computer Science, </booktitle> <pages> pages 47-62. </pages> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: It is more than a mere coincidence that these numbers have already been determined by Davenport-Hasse in the 1930's [33]: they are essentially the above Gaussian sums! This gives a more substantial insight into the deep connection between cyclic codes and cyclotomic fields. (See the papers <ref> [155, 67, 166] </ref> for a discussion of these and related results.) Inspired by these results the author took in [136] a different approach to study possible other relationships between cyclic codes and Gaussian sums. The main topic of that paper was the study of reductions of Stickelberger ideals modulo primes.
Reference: [167] <author> N.C. Wormald. </author> <title> Differential equations for random processes and random graphs. </title> <journal> Ann. Appl. Prob., </journal> <volume> 5 </volume> <pages> 1217-1235, </pages> <year> 1995. </year>
Reference-contexts: In the fist part of this section, we will state a general sharp concentration result. Such results have been obtained by Kurtz [66] who studied Markov jump processes, and have been used previously by many researchers, see <ref> [43, 64, 94, 95, 111, 167] </ref> and the references therein. We will, however, use a version due to Wormald [167] which has the advantage of being directly applicable to our situation. Next we will set up the appropriate system of differential equations, and solve them explicitly. <p> Such results have been obtained by Kurtz [66] who studied Markov jump processes, and have been used previously by many researchers, see [43, 64, 94, 95, 111, 167] and the references therein. We will, however, use a version due to Wormald <ref> [167] </ref> which has the advantage of being directly applicable to our situation. Next we will set up the appropriate system of differential equations, and solve them explicitly. This will provide us with a concrete condition on the bipartite graph for successful decoding. <p> This is a typical example of a so-called sharp concentration result which we will derive in this subsection. We will assume that the reader is familiar with basic concepts such as (super- and sub-)martingales [96]. In the sequel we will follow <ref> [167] </ref> rather closely. The evolution of the number of nodes of different degrees on the graphs considered is a typical example of a discrete time random process. Let denote a probability space and S a measurable space. <p> For a sequence of real-valued random variables X m , we say that X m = O (f (m)) always, if supfx j Pr (X m = x) 6= 0g = O (f (m)). For the proof of our concentration result we need the following version of Azu-ma's Inequality <ref> [167, Lemma 1] </ref>. (1.7) Theorem (Azuma's Inequality). <p> Proof. We will modify the proof in <ref> [167] </ref> slightly to obtain the error bounds asserted in the theorem. First, note that by a standard result in the theory of first order differential equations, there is a unique solution in (1). 16 Chapter 1. Efficient Loss Resilient Codes As in [167] we will simplify the notation by considering d <p> Proof. We will modify the proof in <ref> [167] </ref> slightly to obtain the error bounds asserted in the theorem. First, note that by a standard result in the theory of first order differential equations, there is a unique solution in (1). 16 Chapter 1. Efficient Loss Resilient Codes As in [167] we will simplify the notation by considering d = 1 and referring to y (1;m) , z 1 , and f 1 as y, z, and f , and so on. The proof for general d is similar.
Reference: [168] <author> W.W. Wu, D. Haccoun, and R.E. Peile andY. Hirata. </author> <title> Coding for satellite communication. </title> <journal> IEEE J. Selected Areas in Comm., </journal> <volume> SAC-5:724-748, </volume> <year> 1987. </year>
Reference-contexts: However, RS-codes are usually used for their excellent error correction capabilities, rather than as erasure codes. Typical applications of these codes include CD-players, DAT-recorders, or satellite and deep space communication. For an excellent survey on practical uses of this important class of codes, the reader is referred to <ref> [11, 168, 165] </ref>. RS-codes are very attractive for various reasons: they are MDS-codes which means that they have the largest possible minimum distance for a given block length and a given dimension; this makes them natural candidates for decoding bursts of errors [87, Ch. 10,x6].
Reference: [169] <author> M. Yajnik, J. Kurose, and D. Towsley. </author> <title> Packet loss correlation in the MBone multicast network. </title> <booktitle> In IEEE Global Internet Conference, </booktitle> <address> London, </address> <year> 1996. </year> <month> 170 </month>
Reference-contexts: Such a scheme can be used as the basic building block for the more robust and general protection scheme described in [2]. To demonstrate the benefits of forward error-correction in a simplified setting, consider the Internet loss measurements performed by <ref> [169] </ref> involving a multicast by one sender to a number of geographically distributed receivers. In one typical transmission to eleven receivers for a period of an hour, the average packet loss rate per receiver was 9.3%, yet 46.5% of the packets were lost by at least one of the receivers.
References-found: 169

