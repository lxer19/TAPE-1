URL: http://www.cs.utah.edu/~cs686/Previous/a97/compcon-97-cachejava.ps
Refering-URL: http://www.cs.utah.edu/~cs686/Previous/a97/
Root-URL: 
Email: ada,mconte,tjohnson,gyllen,hwu@crhc.uiuc.edu  
Title: A Study of the Cache and Branch Performance Issues with Running Java on Current Hardware Platforms  
Author: Cheng-Hsueh A. Hsieh Marie T. Conte Teresa L. Johnson John C. Gyllenhaal Wen-mei W. Hwu 
Address: IL 61801  
Affiliation: Center for Reliable and High-Performance Computing University of Illinois Urbana-Champaign,  
Abstract: The Java bytecode language is emerging as a software distribution standard. With major vendors committed to porting the Java run-time environment to their platforms, Java bytecode programs are expected to run without modification on multiple platforms. These first generation run-time environments rely on an interpreter to bridge the gap between the bytecode instructions and the native hardware. However, Java interpreters cause performance problems with microarchitec-tural features such as the caches and the Branch Target Buffer. Some of these problems can be solved by translating Java bytecode to native code. In this paper we compare the performance of code run through the SUN Java interpreter to code compiled through Caffeine, a bytecode to native code translator, as well as to compiled C/C++ versions of the code, using large applications and common benchmarks. We discuss the reasons for several performance problems incurred by both approaches to running Java code, and examine possible solutions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Arnold and J. Gosling. </author> <title> The Java Programming Lan guage. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: One of the objectives of our work is to run our translated code at nearly the full performance of native code directly generated from a source representation such as the C/C++ programming language. Our translated code still implements the Java language features and semantics [4] <ref> [1] </ref>. We use our translated code to isolate the interpreter behavior from the bytecode being executed and use this, as well as C/C++ versions of the programs, to study the performance hits experienced in both ap proaches. 2.
Reference: [2] <author> R. A. Bringmann. </author> <title> Compiler-Controlled Speculation. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Univer sity of Illinois, Urbana, IL, </institution> <year> 1995. </year>
Reference-contexts: How ever, since we are translating to static native code, some of these additional branch instructions could be eliminated by utilizing analysis tools <ref> [2] </ref>. Table 3 shows that there are large numbers of ad ditional mispredictions for cmp, even after translation. These are a result of the two calls to the getc routine in the inner loop of cmp.
Reference: [3] <author> P. P. Chang, S. A. Mahlke, W. Y. Chen, N. J. Warter, and W. W. Hwu. </author> <title> IMPACT: An architectural framework for multiple-instruction-issue processors. </title> <booktitle> In Proceedings of the 18th International Symposium on Computer Ar chitecture, </booktitle> <pages> pages 266-275, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The IMPACT NET Compiler, Caffeine Ver sion 1.0, is used to generate x86 code running under Linux. The C code was optimized and scheduled for an Pentium Pro style implementation of the x86 in struction set using the IMPACT compiler <ref> [3] </ref>. We used the IMPACT simulation environment, which performs a detailed cycle-by-cycle execution-driven simulation, to generate results. Our simulation model is also based on a Pentium Pro style microarchitecture. It consists of a 32K first-level Icache with 64 byte blocks and 2 way associativity.
Reference: [4] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: One of the objectives of our work is to run our translated code at nearly the full performance of native code directly generated from a source representation such as the C/C++ programming language. Our translated code still implements the Java language features and semantics <ref> [4] </ref> [1]. We use our translated code to isolate the interpreter behavior from the bytecode being executed and use this, as well as C/C++ versions of the programs, to study the performance hits experienced in both ap proaches. 2.

Reference: [6] <author> C.-H. A. Hsieh, J. C. Gyllenhaal, and W. W. Hwu. </author> <title> Java bytecode to native code translation: the caffeine proto type and preliminary results. </title> <booktitle> In Proceedings of the 29th International Symposium on Microarchitecture, Decem ber 1996. </booktitle>
Reference-contexts: One way to avoid the performance penalty experienced when executing Java is to eliminate the interpreter by translating the Java bytecode to efficient native code. We have developed an initial prototype of a NET compiler called Caffeine <ref> [6] </ref>. One of the objectives of our work is to run our translated code at nearly the full performance of native code directly generated from a source representation such as the C/C++ programming language. Our translated code still implements the Java language features and semantics [4] [1].

References-found: 5

