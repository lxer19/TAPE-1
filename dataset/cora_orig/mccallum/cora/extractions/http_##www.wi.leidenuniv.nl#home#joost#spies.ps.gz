URL: http://www.wi.leidenuniv.nl/home/joost/spies.ps.gz
Refering-URL: http://www.wi.leidenuniv.nl/home/joost/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: The RPC-Memory Specification Problem: UNITY Refinement Calculus  
Author: Rob T. Udink Joost N. Kok 
Address: P.O. Box 9512, 2300 RA Leiden, The Netherlands.  
Affiliation: Department of Computer Science, Leiden University,  
Abstract: We use the ImpUNITY framework to solve the "RPC-Memory Specification problem" of the Dagstuhl Workshop on reactive systems. ImpUNITY supports the development of parallel and distributed programs from specification to implementation in a stepwise manner. It is an extension of UNITY, as introduced by Chandy and Misra, with features of the Action System formalism of Back and Kurki-Suonio. Due to this extension, the ImpUNITY framework is also suitable for the implementation phase of the development process. It supports local variables and (remote) procedure calls and it has a UNITY like temporal logic.
Abstract-found: 1
Intro-found: 1
Reference: [Bac90] <author> R.J.R. </author> <title> Back. Refinement calculus, part II: Parallel and reactive programs. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </title> <booktitle> volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 42-66. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: However, these approaches do not support refinement of components of programs and the UNITY programming language does not does not support local variables and procedure calls. The Action System framework <ref> [BKS83, Bac90] </ref> is a framework for refinement of parallel and distributed programs. It is based on Back's Refinement Calculus [Bac93], which was originally built for preservation of total correctness, i.e., ? The work of Rob Udink was carried out at the Department of Computer Science, Utrecht University. <p> Rob Udink is currently working at Philips Research Laboratories, Eindhoven. all pre- and postcondition pairs of programs. By modeling reactive systems as sequential programs and by using data refinement, the Refinement Calculus can also be used for the refinement of reactive systems <ref> [Bac90] </ref>. The programming language supports local variables and nondeterminism. Remote procedures can be added to split programs into modules [BS94]. Refinement corresponds to the reduction of possible behaviors (sequences of states) of a program and preserves all temporal properties. However, the framework does not support temporal reasoning about programs.
Reference: [Bac93] <author> R.J.R. </author> <title> Back. Refinement calculus, lattices and higher order logic. </title> <editor> In M. Broy, editor, </editor> <booktitle> Program Design Calculi, volume 118 of Nato ASI Series, Series F, </booktitle> <pages> pages 53-72. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: However, these approaches do not support refinement of components of programs and the UNITY programming language does not does not support local variables and procedure calls. The Action System framework [BKS83, Bac90] is a framework for refinement of parallel and distributed programs. It is based on Back's Refinement Calculus <ref> [Bac93] </ref>, which was originally built for preservation of total correctness, i.e., ? The work of Rob Udink was carried out at the Department of Computer Science, Utrecht University. It has been supported by the Foundation for Computer Science in the Netherlands SION under project 612-317-107. <p> If this number is exceeded (no slot is free at the moment call is called) then the calls are not answered. Statements of ImpUNITY programs are interpreted as (weakest precondition) predicate transformers, and we use the Refinement Calculus of Back <ref> [Bac93] </ref> to reason about them. Unlike UNITY, we allow statements that are nondeterministic, but the nondeterminism can only be demonic. To denote statements we use the command language of the refinement calculus. In this paper we will (almost) only use the assign statement and the if -statement.
Reference: [BKS83] <author> R.-J.R. Back and R. Kurki-Suonio. </author> <title> Decentralization of process nets with centralized control. </title> <booktitle> In 2nd ACM SIGACT-SIGOPS Symp. on Distributed Computing, </booktitle> <pages> pages 131-142. </pages> <publisher> ACM, </publisher> <year> 1983. </year>
Reference-contexts: However, these approaches do not support refinement of components of programs and the UNITY programming language does not does not support local variables and procedure calls. The Action System framework <ref> [BKS83, Bac90] </ref> is a framework for refinement of parallel and distributed programs. It is based on Back's Refinement Calculus [Bac93], which was originally built for preservation of total correctness, i.e., ? The work of Rob Udink was carried out at the Department of Computer Science, Utrecht University.
Reference: [BS94] <author> R.J.R. Back and K. Sere. </author> <title> Action systems with synchronous communication. </title> <editor> In E.-R. Olderog, editor, </editor> <title> Programming Concepts, Methods and Calculi, </title> <journal> volume A-56 of IFIP Transactions, </journal> <pages> pages 107-126. </pages> <publisher> IFIP, Elsevier Science Publishers B.V. (North Holland), </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: By modeling reactive systems as sequential programs and by using data refinement, the Refinement Calculus can also be used for the refinement of reactive systems [Bac90]. The programming language supports local variables and nondeterminism. Remote procedures can be added to split programs into modules <ref> [BS94] </ref>. Refinement corresponds to the reduction of possible behaviors (sequences of states) of a program and preserves all temporal properties. However, the framework does not support temporal reasoning about programs.
Reference: [CM88] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design A Foundation. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction The UNITY framework, as introduced by Chandy and Misra <ref> [CM88] </ref>, supports the idea of stepwise refinement of specifications. The framework consists of a programming language and a programming logic. The logic is based on a small set of temporal properties for describing specifications. <p> The logic is based on a small set of temporal properties for describing specifications. The UNITY approach is to refine specifications towards a specific architecture until a program can be derived easily. Case studies show that the method is useful for deriving parallel and distributed algorithms <ref> [CM88] </ref>. However, it is not always easy to deal with low-level implementation details at the level of specifications. In this stage of the development process, program refinement seems to be preferable to refinement of specifications. Program refinement consists of program transformations that preserve semantic properties of the programs. <p> procedures that are called but not declared in the union, and the initially-section of the union is the conjunction of the initially-sections of its components. 3 The ImpUNITY logic For reasoning about UNITY programs and for the formulation of specifications, Chandy and Misra give a nice and simple (temporal) logic <ref> [CM88] </ref> based on three temporal properties: unless, ensures and leadsto (7!). A modification of this logic for reasoning about closed systems was given by Sanders [San90]. We lift both logics to ImpUNITY programs.
Reference: [Pac92] <author> Jan Pachl. </author> <title> A simple proof of a completeness result for leads-to in the UNITY logic. </title> <journal> Information Processing Letters, </journal> <volume> 41 </volume> <pages> 35-38, </pages> <year> 1992. </year>
Reference-contexts: : (r ^ p) ensures CM q in F i; p 7! S q in F = h9r : invariant CM r in F : (r ^ p) 7! CM q in F i: Properties in this logic can be interpreted in terms of (stutter-free) execution sequences of a program <ref> [Pac92] </ref>: 1. p unless S q in F holds if and only if for every state in every execution sequence of F , if p ^ :q hold, then p _ q holds in the next state. 2. p 7! S q in F holds if and only if whenever p
Reference: [San90] <author> Beverly A. Sanders. </author> <title> Stepwise refinement of mixed specifications of concurrent programs. </title> <editor> In M. Broy and Jones C.B., editors, </editor> <booktitle> Proceedings of the IFIP Working Conference on Programming and Methods, </booktitle> <pages> pages 1-25. </pages> <publisher> Elsevier Science Publishers B.V. (North Holland), </publisher> <month> May </month> <year> 1990. </year>
Reference-contexts: In this stage of the development process, program refinement seems to be preferable to refinement of specifications. Program refinement consists of program transformations that preserve semantic properties of the programs. The standard UNITY framework does not support program refinement, but several proposals have been put forward <ref> [San90, Sin93] </ref> where refinement is defined as preservation of (specific) properties. However, these approaches do not support refinement of components of programs and the UNITY programming language does not does not support local variables and procedure calls. <p> A modification of this logic for reasoning about closed systems was given by Sanders <ref> [San90] </ref>. We lift both logics to ImpUNITY programs. UNITY properties are attached to an entire program and are defined in terms of the assign-section of the program. In contrast to UNITY, ImpUNITY program may contain procedure calls, and bodies of procedures calls can be unknown.
Reference: [San91] <author> Beverly A. Sanders. </author> <title> Eliminating the substitution axiom from UNITY logic. </title> <journal> Formal Aspects of Computing, </journal> <volume> 3(2) </volume> <pages> 189-205, </pages> <year> 1991. </year>
Reference-contexts: The ImpUNITY logic is a generalization of the UNITY logic to support the extra features of ImpUNITY programs. It is an extension of the compositional logic presented in [UHK94] which, as a generalization of the logic of Sanders <ref> [San91] </ref>, takes invariants of programs in a context into account. In this way, the union theorem of UNITY (giving a way to derive properties of a composed program from properties of its components) is still valid. <p> Sanders <ref> [San91] </ref> gave a modification of the UNITY logic for reasoning about programs as closed systems. For closed systems, some states are not reachable by the program, and this can be coded into the properties by taking the invariants of the program into account.
Reference: [Sin93] <author> Ambuj K. Singh. </author> <title> Program refinement in fair transition systems. </title> <journal> Acta Infor-matica, </journal> <volume> 30(6) </volume> <pages> 503-535, </pages> <year> 1993. </year>
Reference-contexts: In this stage of the development process, program refinement seems to be preferable to refinement of specifications. Program refinement consists of program transformations that preserve semantic properties of the programs. The standard UNITY framework does not support program refinement, but several proposals have been put forward <ref> [San90, Sin93] </ref> where refinement is defined as preservation of (specific) properties. However, these approaches do not support refinement of components of programs and the UNITY programming language does not does not support local variables and procedure calls. <p> UNITY does not support refinement of programs, but a natural notion of program refinement is preservation of properties <ref> [Sin93, UK93, UHK94] </ref>. We adopt this notion with the modification that we take locality of variables into account and that we define a compositional notion of refinement. This results in the following notion of program refinement: Definition 4.
Reference: [Udi95] <author> Rob Udink. </author> <title> Program Refinement in UNITY-like Environments. </title> <type> PhD thesis, </type> <institution> Utrecht University, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: However, the framework does not support temporal reasoning about programs. The ImpUNITY framework combines UNITY and Action Systems in such a way that it supports a modular way of program design <ref> [UK95, Udi95] </ref>. Like the UNITY framework it consists of a programming language and a programming logic. ImpUNITY programs are similar to Action Systems: a program can have local variables, statements in a program may be nondeterministic and may contain (remote) procedure calls.
Reference: [UHK94] <author> R.T. Udink, T. Herman, and J.N. Kok. </author> <title> Progress for local variables in UNITY. </title> <editor> In E.-R. Olderog, editor, </editor> <title> Programming Concepts, Methods and Calculi, </title> <journal> volume A-56 of IFIP Transactions, </journal> <pages> pages 127-146. </pages> <publisher> IFIP, Elseviers Science Publishers B.V. (North Holland), </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: The notion of fairness of a program execution is taken from UNITY. The ImpUNITY logic is a generalization of the UNITY logic to support the extra features of ImpUNITY programs. It is an extension of the compositional logic presented in <ref> [UHK94] </ref> which, as a generalization of the logic of Sanders [San91], takes invariants of programs in a context into account. In this way, the union theorem of UNITY (giving a way to derive properties of a composed program from properties of its components) is still valid. <p> To reason about ImpUNITY programs in a compositional way, ImpUNITY supports a logic that is a generalisation of the logics above <ref> [UHK94] </ref>. Here we only define the unless fl and ensures fl property in this logic. These properties, which are subscripted by fl, take local invariants into account. Local invariants are invariants that cannot be disturbed by an environment. We use these properties in the formulation of program transformation rules. <p> UNITY does not support refinement of programs, but a natural notion of program refinement is preservation of properties <ref> [Sin93, UK93, UHK94] </ref>. We adopt this notion with the modification that we take locality of variables into account and that we define a compositional notion of refinement. This results in the following notion of program refinement: Definition 4.
Reference: [UK93] <author> R.T. Udink and J.N. Kok. </author> <title> Two fully abstract models for UNITY. In Eike Best, </title> <editor> editor, CONCUR'93, </editor> <booktitle> Proceedings of the 4th International Conference on Concurrency Theory, volume 715 of Lecture Notes in Computer Science, </booktitle> <pages> pages 339-352. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1993. </year>
Reference-contexts: UNITY does not support refinement of programs, but a natural notion of program refinement is preservation of properties <ref> [Sin93, UK93, UHK94] </ref>. We adopt this notion with the modification that we take locality of variables into account and that we define a compositional notion of refinement. This results in the following notion of program refinement: Definition 4.
Reference: [UK95] <author> R.T. Udink and J.N. Kok. ImpUNITY: </author> <title> UNITY with procedures and local variables. </title> <editor> In Bernhard Moller, editor, </editor> <booktitle> Mathematics of Program Construction, volume 947 of Lecture Notes in Computer Science, </booktitle> <pages> pages 452-472. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: However, the framework does not support temporal reasoning about programs. The ImpUNITY framework combines UNITY and Action Systems in such a way that it supports a modular way of program design <ref> [UK95, Udi95] </ref>. Like the UNITY framework it consists of a programming language and a programming logic. ImpUNITY programs are similar to Action Systems: a program can have local variables, statements in a program may be nondeterministic and may contain (remote) procedure calls.
References-found: 13

