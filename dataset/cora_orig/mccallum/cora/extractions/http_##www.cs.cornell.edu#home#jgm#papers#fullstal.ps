URL: http://www.cs.cornell.edu/home/jgm/papers/fullstal.ps
Refering-URL: http://www.cs.cornell.edu/home/jgm/papers.html
Root-URL: 
Title: Stack-Based Typed Assembly Language  
Author: Greg Morrisett, Karl Crary, Neal Glew, and David Walker 
Affiliation: Cornell University  
Abstract: In previous work, we presented a Typed Assembly Language (TAL). TAL is sufficiently expressive to serve as a target language for compilers of high-level languages such as ML. This work assumed such a compiler would perform a continuation-passing style transform and eliminate the control stack by heap-allocating activation records. However, most compilers are based on stack allocation. This paper presents STAL, an extension of TAL with stack constructs and stack types to support the stack allocation style. We show that STAL is sufficiently expressive to support languages such as Java, Pascal, and ML; constructs such as exceptions and displays; and optimizations such as tail call elimination and callee-saves registers. This paper also formalizes the typing connection between CPS-based compilation and stack-based compilation and illustrates how STAL can formally model calling conventions by specifying them as formal translations of source function types to STAL types.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Andrew Appel and Zhong Shao. </author> <title> Callee-saves registers in continuation-passing style. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 5 </volume> <pages> 189-219, </pages> <year> 1992. </year>
Reference-contexts: The general framework makes it easy to transfer transformations developed for one style to the other. For instance, we can easily explain the callee-saves registers of SML/NJ <ref> [5, 3, 1] </ref> and the callee-saves registers of a stack-based compiler as instances of a more general CPS transformation that is independent of the continuation representation. 2 Overview of TAL and CPS-Based Compilation In this section, we briefly review our original proposal for typed assembly language (TAL) and sketch how a <p> 8 [; ff]:fr1:hi; r2:int; r3:ff; ra:8 []fsp:; r1:int; r3:ffg; sp:g Translating this type back in to a boxed, heap allocated closure, we obtain: 8 [ff]:fr1:hi; r2 : int; r3:ff; ra:9fi:h8 []fr1:fi; r2:int; r3:ffg 1 ; fi 1 ig This is the type of the callee-saves approach of Appel and Shao <ref> [1] </ref>. Thus we see how our correspondence enables transformations developed for heap-based compilers to be used in traditional stack-based compilers and vice versa. The generalization to multiple callee-saves registers and other calling conventions should be clear.
Reference: 2. <author> Andrew Appel and Zhong Shao. </author> <title> An empirical and analytic study of stack vs. heap cost for languages with clsoures. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1), </volume> <month> January </month> <year> 1993. </year>
Reference-contexts: Allocating continuation closures on the heap has many advantages over a conventional stack-based implementation. First, it is straightforward to implement control primitives such as exceptions, first-class continuations, or user-level lightweight coroutine threads [3, 31, 34]. Second, Appel and Shao <ref> [2] </ref> have shown that heap allocation of closures can have better space properties, primarily because it is easier to share environments. Third, there is a unified memory management mechanism (namely the garbage collector) for allocating and collecting all kinds of objects, including activation frames. Finally, Appel and Shao [2] have argued <p> and Shao <ref> [2] </ref> have shown that heap allocation of closures can have better space properties, primarily because it is easier to share environments. Third, there is a unified memory management mechanism (namely the garbage collector) for allocating and collecting all kinds of objects, including activation frames. Finally, Appel and Shao [2] have argued that, at least for SML/NJ, the locality lost by heap-allocating activation frames is negligible. Nevertheless, there are also compelling reasons for providing support for stacks. <p> caller might unpack the continuations: 8 [ff 1 ; ff 2 ]:fr1:int; ra:8 [ ]:fr1:ff 1 ; r2:hig; ra 0 :ff 1 ; re:8 [ ]:fr1:ff 2 ; r2:exng; re 0 :ff 2 g Then the caller might (erroneously) attempt to place the continuation environments on stacks, as before: 8 <ref> [ 1 ; 2 ] </ref>:fr1:int; ra:8 [ ]:fsp: 1 ; r1:hig; sp: 1 ; re:8 [ ]:fsp: 2 ; r1:exng; sp 0 : 2 g Unfortunately, this calling convention uses two stack pointers, and STAL has only one stack. 3 Observe, though, that the exception continuation's stack is necessarily a tail <p> This observation leads to the following calling convention for exceptions with stacks: 8 <ref> [ 1 ; 2 ] </ref>:f sp: 1 ffi 2 ; r1:int; ra:8 [ ]:fsp: 1 ffi 2 ; r1:hig; re 0 :ptr ( 2 ); re:8 [ ]:fsp: 2 ; r1:exngg 3 Some language implementations use a separate exception stack; with some minor modifications, this calling convention would be satisfactory for <p> In the above example the load will be rejected because r1's type t :: is not a tail of sp 0 s type, ns::. 4.3 Using Compound Stacks Recall the type for a function in the presence of exceptions: 8 <ref> [ 1 ; 2 ] </ref>:f sp: 1 ffi 2 ; r1:int; ra:8 [ ]:fsp: 1 ffi 2 ; r1:hig; re 0 :ptr ( 2 ); re:8 [ ]:fsp: 2 ; r1:exngg An exception may be raised within the body of such a function by restoring the handler's stack from re 0 <p> This last convention illustrates a use for compound stacks that goes beyond implementing exceptions. We have a general tool for locating data of type t amidst the stack by using the calling convention: 8 <ref> [ 1 ; 2 ] </ref>:fsp: 1 ffi (t :: 2 ); r1:ptr (t :: 2 ); : : :g One application of this tool would be for implementing Pascal with displays.
Reference: 3. <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: However, the compiler we presented was critically based on a continuation-passing style (CPS) transform, which eliminated the need for a control stack. In particular, activation records were represented by heap-allocated closures as in the SML of New Jersey compiler (SML/NJ) <ref> [5, 3] </ref>. For example, Figure 1 shows the TAL code our heap-based compiler would produce for the recursive factorial computation. Each function takes an additional argument which represents the control stack as a continuation closure. <p> Allocating continuation closures on the heap has many advantages over a conventional stack-based implementation. First, it is straightforward to implement control primitives such as exceptions, first-class continuations, or user-level lightweight coroutine threads <ref> [3, 31, 34] </ref>. Second, Appel and Shao [2] have shown that heap allocation of closures can have better space properties, primarily because it is easier to share environments. <p> The general framework makes it easy to transfer transformations developed for one style to the other. For instance, we can easily explain the callee-saves registers of SML/NJ <ref> [5, 3, 1] </ref> and the callee-saves registers of a stack-based compiler as instances of a more general CPS transformation that is independent of the continuation representation. 2 Overview of TAL and CPS-Based Compilation In this section, we briefly review our original proposal for typed assembly language (TAL) and sketch how a
Reference: 4. <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <address> Austin, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: Modern type-directed compilers [19, 25, 7, 32, 20, 28, 12] exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. These compilers use types to direct sophisticated transformations such as closure conversion <ref> [18, 31, 17, 4, 21] </ref>, region inference [8], subsumption elimination [9, 11], and unboxing [19, 24, 29]. Without types these transformations are, in many cases, less effective or impossible.
Reference: 5. <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In Martin Wirsing, editor, </editor> <booktitle> Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <title> Springer-Verlag. </title> <booktitle> Volume 528 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: However, the compiler we presented was critically based on a continuation-passing style (CPS) transform, which eliminated the need for a control stack. In particular, activation records were represented by heap-allocated closures as in the SML of New Jersey compiler (SML/NJ) <ref> [5, 3] </ref>. For example, Figure 1 shows the TAL code our heap-based compiler would produce for the recursive factorial computation. Each function takes an additional argument which represents the control stack as a continuation closure. <p> The general framework makes it easy to transfer transformations developed for one style to the other. For instance, we can easily explain the callee-saves registers of SML/NJ <ref> [5, 3, 1] </ref> and the callee-saves registers of a stack-based compiler as instances of a more general CPS transformation that is independent of the continuation representation. 2 Overview of TAL and CPS-Based Compilation In this section, we briefly review our original proposal for typed assembly language (TAL) and sketch how a
Reference: 6. <author> Mark Bailey and Jack Davidson. </author> <title> A formal model of procedure calling conven tions. </title> <booktitle> In Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 298-310, </pages> <address> San Francisco, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: In contrast, STAL only allows allocation at the top of the stack and assumes a garbage collector for heap-allocated values. However, the type system for STAL is considerably simpler than the type system of Tofte et al., as it requires no effect information in types. Bailey and Davidson <ref> [6] </ref> also describe a specification language for modeling procedure calling conventions and checking that implementations respect these conventions. They are able to specify features such as a variable number of arguments that our formalism does not address.
Reference: 7. <author> Lars Birkedal, Nick Rothwell, Mads Tofte, and David N. Turner. </author> <title> The ML Kit (version 1). </title> <type> Technical Report 93/14, </type> <institution> Department of Computer Science, University of Copenhagen, </institution> <year> 1993. </year>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages.
Reference: 8. <author> Lars Birkedal, Mads Tofte, and Magnus Vejlstrup. </author> <title> From region inference to von Neumann machines via region representation inference. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 171-183, </pages> <address> St. Peters-burg, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: These compilers use types to direct sophisticated transformations such as closure conversion [18, 31, 17, 4, 21], region inference <ref> [8] </ref>, subsumption elimination [9, 11], and unboxing [19, 24, 29]. Without types these transformations are, in many cases, less effective or impossible. Furthermore, the type translation partially specifies the corresponding term translation and often captures the critical concerns in an elegant and succinct fashion. <p> Consequently, procedure call must be a primitive construct (which it is in JVML). In contrast, our treatment supports polymorphic stack recursion, and hence procedure calls can be encoded with existing assembly-language primitives. Tofte and others <ref> [8, 33] </ref> have developed an allocation strategy involving regions. Regions are lexically scoped containers that have a LIFO ordering on their lifetimes, much like the values on a stack. As in our approach, polymorphic recursion on abstracted region variables plays a critical role.
Reference: 9. <author> Val Breazu-Tannen, Thierry Coquand, Carl A. Gunter, and Andre Scedrov. </author> <title> In heritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 172-221, </pages> <year> 1991. </year>
Reference-contexts: These compilers use types to direct sophisticated transformations such as closure conversion [18, 31, 17, 4, 21], region inference [8], subsumption elimination <ref> [9, 11] </ref>, and unboxing [19, 24, 29]. Without types these transformations are, in many cases, less effective or impossible. Furthermore, the type translation partially specifies the corresponding term translation and often captures the critical concerns in an elegant and succinct fashion.
Reference: 10. <author> Karl Crary. </author> <title> KML Reference Manual. </title> <institution> Department of Computer Science, Cornell University, </institution> <year> 1996. </year>
Reference-contexts: However, we claim that the framework presented here is a practical approach to compilation. To substantiate this claim, we are constructing a compiler called TALC that maps the KML language <ref> [10] </ref> to a variant of STAL described here, suitably adapted for the Intel IA32 architecture. We have found it straightforward to enrich the target language type system to include support for other type constructors, such as references, higher-order constructors, and recursive types.
Reference: 11. <author> Karl Crary. </author> <title> Foundations for the implementation of higher-order subtyping. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 125-135, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: These compilers use types to direct sophisticated transformations such as closure conversion [18, 31, 17, 4, 21], region inference [8], subsumption elimination <ref> [9, 11] </ref>, and unboxing [19, 24, 29]. Without types these transformations are, in many cases, less effective or impossible. Furthermore, the type translation partially specifies the corresponding term translation and often captures the critical concerns in an elegant and succinct fashion.
Reference: 12. <author> Allyn Dimock, Robert Muller, Franklyn Turbak, and J. B. Wells. </author> <title> Strongly typed flow-directed reprsentation transformations. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 11-24, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages.
Reference: 13. <author> Amer Diwan, David Tarditi, and Eliot Moss. </author> <title> Memory subsystem performance of programs using copying garbage collection. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Nevertheless, there are also compelling reasons for providing support for stacks. First, Appel and Shao's work did not consider imperative languages, such as Java, where the ability to share environments is greatly reduced, nor did it consider languages that do not require garbage collection. Second, Tarditi and Diwan <ref> [14, 13] </ref> have shown that with some cache architectures, heap allocation of continuations (as in SML/NJ) can have substantial overhead due to a loss of locality. Third, stack-based activation records can have a smaller memory footprint than heap-based activation records.
Reference: 14. <author> Amer Diwan, David Tarditi, and Eliot Moss. </author> <title> Memory system performance of programs with intensive heap allocation. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 13(3) </volume> <pages> 244-273, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Nevertheless, there are also compelling reasons for providing support for stacks. First, Appel and Shao's work did not consider imperative languages, such as Java, where the ability to share environments is greatly reduced, nor did it consider languages that do not require garbage collection. Second, Tarditi and Diwan <ref> [14, 13] </ref> have shown that with some cache architectures, heap allocation of continuations (as in SML/NJ) can have substantial overhead due to a loss of locality. Third, stack-based activation records can have a smaller memory footprint than heap-based activation records.
Reference: 15. <author> Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 66-77, </pages> <month> June </month> <year> 1990. </year> <note> Published as SIGPLAN Notices, 25(6). </note>
Reference-contexts: Second, threads and advanced mechanisms for implementing first-class continuations such as the work by Hieb et al. <ref> [15] </ref> cannot be modeled in this system without adding new primitives. However, we claim that the framework presented here is a practical approach to compilation.
Reference: 16. <author> Intel Corporation. </author> <title> Intel Architecture Optimization Manual. </title> <publisher> Intel Corporation, </publisher> <address> P.O. Box 7641, Mt. Prospect, IL, 60056-7641, </address> <year> 1997. </year>
Reference-contexts: Finally, many machine architectures have hardware mechanisms that expect programs to behave in a stack-like fashion. For example, the Pentium Pro processor has an internal stack that it uses to predict return addresses for procedures so that instruction pre-fetching will not be stalled <ref> [16] </ref>. The internal stack is guided by the use of call/return primitives which use the standard control stack. Clearly, compiler writers must weigh a complex set of factors before choosing stack allocation, heap allocation, or both. The target language must not constrain these design decisions.
Reference: 17. <author> David Kranz, R. Kelsey, J. Rees, P. R. Hudak, J. Philbin, and N. Adams. </author> <title> ORBIT: An optimizing compiler for Scheme. </title> <booktitle> In Proceedings of the ACM SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 219-233, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Modern type-directed compilers [19, 25, 7, 32, 20, 28, 12] exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. These compilers use types to direct sophisticated transformations such as closure conversion <ref> [18, 31, 17, 4, 21] </ref>, region inference [8], subsumption elimination [9, 11], and unboxing [19, 24, 29]. Without types these transformations are, in many cases, less effective or impossible.
Reference: 18. <author> P. J. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer J., </journal> <volume> 6(4) </volume> <pages> 308-20, </pages> <year> 1964. </year>
Reference-contexts: Modern type-directed compilers [19, 25, 7, 32, 20, 28, 12] exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. These compilers use types to direct sophisticated transformations such as closure conversion <ref> [18, 31, 17, 4, 21] </ref>, region inference [8], subsumption elimination [9, 11], and unboxing [19, 24, 29]. Without types these transformations are, in many cases, less effective or impossible.
Reference: 19. <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 177-188, </pages> <address> Albuquerque, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. <p> These compilers use types to direct sophisticated transformations such as closure conversion [18, 31, 17, 4, 21], region inference [8], subsumption elimination [9, 11], and unboxing <ref> [19, 24, 29] </ref>. Without types these transformations are, in many cases, less effective or impossible. Furthermore, the type translation partially specifies the corresponding term translation and often captures the critical concerns in an elegant and succinct fashion. Strong type systems not only describe but also enforce many important invariants.
Reference: 20. <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. <p> More specifically, the typing discipline supports stack allocation of temporary variables and values that do not escape, stack allocation of procedure activation frames, exception handlers, and displays, as well as optimizations such as callee-saves registers. Unlike the JVM architecture <ref> [20] </ref>, our system does not constrain the stack to have the same size at each control-flow point, nor does it require new high-level primitives for procedure call/return. Instead, our assembly language continues to have low-level RISC-like primitives such as loads, stores, and jumps.
Reference: 21. <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Twenty Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 271-283, </pages> <address> St. Petersburg, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Modern type-directed compilers [19, 25, 7, 32, 20, 28, 12] exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. These compilers use types to direct sophisticated transformations such as closure conversion <ref> [18, 31, 17, 4, 21] </ref>, region inference [8], subsumption elimination [9, 11], and unboxing [19, 24, 29]. Without types these transformations are, in many cases, less effective or impossible. <p> At the TAL level, we represent closures as a pair consisting of a code block label and a pointer to an environment data structure. The type of the environment must be held abstract in order to avoid typing difficulties <ref> [21] </ref>, and thus we pack the type of the environment and the pair to form an existential type. All functions, including continuation functions introduced during CPS conversion, are thus represented as existentials.
Reference: 22. <author> G. Morrisett, D. Tarditi, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> The TIL/ML compiler: Performance and safety through types. </title> <booktitle> In Workshop on Compiler Support for Systems Software, </booktitle> <address> Tucson, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: Although type-checkers for decidable type systems will not catch all compiler errors, they have proven themselves valuable debugging tools in practice <ref> [22] </ref>. ? This material is based on work supported in part by the AFOSR grant F49620-97 1-0013, ARPA/RADC grant F30602-96-1-0317, ARPA/AF grant F30602-95-1-0047, and AASERT grant N00014-95-1-0985.
Reference: 23. <author> Greg Morrisett, David Walker, Karl Crary, and Neal Glew. </author> <title> From System F to typed assembly language. </title> <booktitle> In Twenty-Fifth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <month> January </month> <year> 1998. </year> <note> Extended version published as Cornell University technical report TR97-1651, </note> <month> November </month> <year> 1997. </year>
Reference-contexts: Many of the complex tasks of code generation including register allocation and instruction scheduling are left unchecked; types are not used to specify or explain these low-level code transformations. These observations motivated our exploration of very low-level type systems and corresponding compiler technology. In Morrisett et al. <ref> [23] </ref>, we presented a typed assembly language (TAL) and proved that its type system was sound with respect to an operational semantics. We demonstrated the expressiveness of this type system by sketching a type-preserving compiler from an ML-like language to TAL. <p> On an untyped machine, this is implemented by an ordinary move. The other non-standard instruction is malloc, which is explained below. Evaluation is specified as a deterministic rewriting system that takes programs to programs (see Morrisett et al. <ref> [23] </ref> for details). The types for TAL consist of type variables, integers, tuple types, existential types, and polymorphic code types. Tuple types contain initialization flags (ei-ther 0 or 1) that indicate whether or not components have been initialized.
Reference: 24. <author> Gregory Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1995. </year> <note> Published as CMU Technical Report CMU-CS-95-226. </note>
Reference-contexts: These compilers use types to direct sophisticated transformations such as closure conversion [18, 31, 17, 4, 21], region inference [8], subsumption elimination [9, 11], and unboxing <ref> [19, 24, 29] </ref>. Without types these transformations are, in many cases, less effective or impossible. Furthermore, the type translation partially specifies the corresponding term translation and often captures the critical concerns in an elegant and succinct fashion. Strong type systems not only describe but also enforce many important invariants.
Reference: 25. <author> Simon L. Peyton Jones, Cordelia V. Hall, Kevin Hammond, Will Partain, and Philip Wadler. </author> <title> The Glasgow Haskell compiler: a technical overview. </title> <booktitle> In Proc. UK Joint Framework for Information Technology (JFIT) Technical Conference, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages.
Reference: 26. <author> John Reynolds. </author> <title> Using functor categories to generate intermediate code. </title> <booktitle> In Twenty Second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 25-36, </pages> <address> San Francisco, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: It appears that this limitation could be removed by introducing a limited form of intersection type, but we have not yet explored the ramifications of this enhancement. 5 Related and Future Work Our work is partially inspired by Reynolds <ref> [26] </ref>, which uses functor categories to "replace continuations by instruction sequences and store shapes by descriptions of the structure of the run-time stack." However, Reynolds was primarily concerned with using functors to express an intermediate language of a semantics-based compiler for Algol, whereas we are primarily concerned with type structure for
Reference: 27. <author> John C. Reynolds. </author> <title> Types, abstraction and parametric polymorphism. </title> <booktitle> In Informa tion Processing '83, </booktitle> <pages> pages 513-523. </pages> <publisher> North-Holland, </publisher> <year> 1983. </year> <booktitle> Proceedings of the IFIP 9th World Computer Congress. </booktitle>
Reference-contexts: stack, only this space may be accessed by the function, and the space must be freed before returning to the caller. 2 The second problem is solved because the stack type variable may be instantiated 2 Some intuition on this topic may be obtained from Reynolds' theorem on parametric polymorphism <ref> [27] </ref> but a formal proof is difficult. in different ways. Hence multiple call sites with different stack states, including recursive calls, may now invoke the function.
Reference: 28. <author> Z. Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In Workshop on Types in Com pilation, </booktitle> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year> <institution> ACM SIGPLAN. Published as Boston College Computer Science Dept. </institution> <note> Technical Report BCCS-97-03. </note>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages.
Reference: 29. <author> Zhong Shao. </author> <title> Flexible representation analysis. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 85-98, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: These compilers use types to direct sophisticated transformations such as closure conversion [18, 31, 17, 4, 21], region inference [8], subsumption elimination [9, 11], and unboxing <ref> [19, 24, 29] </ref>. Without types these transformations are, in many cases, less effective or impossible. Furthermore, the type translation partially specifies the corresponding term translation and often captures the critical concerns in an elegant and succinct fashion. Strong type systems not only describe but also enforce many important invariants.
Reference: 30. <author> Raymie Stata and Martn Abadi. </author> <title> A type system for java bytecode subroutines. </title> <booktitle> In Twenty-Fifth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <month> January </month> <year> 1998. </year>
Reference-contexts: Stata and Abadi <ref> [30] </ref> formalize the Java bytecode verifier's treatment of subroutines by giving a type system for a subset of the Java Virtual Machine language.
Reference: 31. <author> Guy L. Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <year> 1978. </year>
Reference-contexts: Modern type-directed compilers [19, 25, 7, 32, 20, 28, 12] exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages. These compilers use types to direct sophisticated transformations such as closure conversion <ref> [18, 31, 17, 4, 21] </ref>, region inference [8], subsumption elimination [9, 11], and unboxing [19, 24, 29]. Without types these transformations are, in many cases, less effective or impossible. <p> Allocating continuation closures on the heap has many advantages over a conventional stack-based implementation. First, it is straightforward to implement control primitives such as exceptions, first-class continuations, or user-level lightweight coroutine threads <ref> [3, 31, 34] </ref>. Second, Appel and Shao [2] have shown that heap allocation of closures can have better space properties, primarily because it is easier to share environments.
Reference: 32. <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 181-192, </pages> <address> Philadelphia, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: 1 Introduction and Motivation Statically typed source languages have efficiency and software engineering advantages over their dynamically typed counterparts. Modern type-directed compilers <ref> [19, 25, 7, 32, 20, 28, 12] </ref> exploit the properties of typed languages more extensively than their predecessors by preserving type information computed in the front end through a series of typed intermediate languages.
Reference: 33. <author> Mads Tofte and Jean-Pierre Talpin. </author> <title> Implementation of the typed call-by-value calculus using a stack of regions. </title> <booktitle> In Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 188-201, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Consequently, procedure call must be a primitive construct (which it is in JVML). In contrast, our treatment supports polymorphic stack recursion, and hence procedure calls can be encoded with existing assembly-language primitives. Tofte and others <ref> [8, 33] </ref> have developed an allocation strategy involving regions. Regions are lexically scoped containers that have a LIFO ordering on their lifetimes, much like the values on a stack. As in our approach, polymorphic recursion on abstracted region variables plays a critical role.
Reference: 34. <author> Mitchell Wand. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Proceedings of the 1980 LISP Conference, </booktitle> <pages> pages 19-28, </pages> <month> August </month> <year> 1980. </year>
Reference-contexts: Allocating continuation closures on the heap has many advantages over a conventional stack-based implementation. First, it is straightforward to implement control primitives such as exceptions, first-class continuations, or user-level lightweight coroutine threads <ref> [3, 31, 34] </ref>. Second, Appel and Shao [2] have shown that heap allocation of closures can have better space properties, primarily because it is easier to share environments.
References-found: 34

