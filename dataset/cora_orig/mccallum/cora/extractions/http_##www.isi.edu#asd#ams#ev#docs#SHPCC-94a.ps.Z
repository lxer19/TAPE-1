URL: http://www.isi.edu/asd/ams/ev/docs/SHPCC-94a.ps.Z
Refering-URL: http://www.isi.edu/asd/ams/papers/papers.html
Root-URL: http://www.isi.edu
Title: Abstract The ISI Embeddable Variant is a 16-node, physically-compact, modular multicomputer designed for applications in
Author: W.C. Athas J.G. Koller 
Keyword: Figure 1. EV System Configuration Host  
Address: Marina del Rey, California 90292  
Affiliation: Exploratory Design Group University of Southern California Information Sciences Institute  
Note: were not located on the MCM but were mounted on  Computer  Submitted to SHPCC-94 This document was created with FrameMaker 4.0.4  
Abstract: through special ribbon cables. Memory chip technology then became the driving factor in the design of the node architecture. The important requirements of the memory technology were die availability, data path width, density, and speed. Memory speed was important for two reasons. First, for a high-performance design it is important to introduce as few wait states as possible between the microprocessor and its external memory. Second, for multicomputers the memory bandwidth must often be shared between the microprocessor and hardware such as a Direct 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W.C. Athas, </author> <title> Packet Handler Design Specification Document EVHW-001-12, </title> <month> March </month> <year> 1993. </year>
Reference-contexts: These performance levels are not achieved at the cost of generality or compatibility. By configuring EV and the Intel Paragon multicomputer [3] to both run the Mach microkernel <ref> [1] </ref> and by adhering to the EV Software Guidelines [5] it is possible to develop application programs on the Paragon which will run on the EV module without need for modification. 2: Architecture The node architecture of EV was driven by a number of packaging and compatibility constraints.
Reference: [2] <author> J.T. Draper, </author> <title> Analysis of Ping Execution on EV , ISI Docu ment EVSW-200-00, </title> <month> October </month> <year> 1993. </year>
Reference-contexts: The goals of NK were small size, maximum performance, a clean interface to a larger OS such as Mach, and exible protocol options such as NX or MPI <ref> [2] </ref>. As a nanokernel, NK does no scheduling or address space management, and does not enforce any particular programming model. The guiding philosophy was that in a tightly-coupled multicomputer such as EV, the message-passing layer should be below any workstation-class operating system, rather than part of it. <p> A second conclusion was that it is surprisingly difficult to reduce the total number of clock cycles of overhead required to process messages <ref> [2] </ref>, particularly for a high-performance memory system. Even though the number of operations may be small, many cycles can be consumed performing inefficient single word transfers to follow pointers, set ags, etc.
Reference: [3] <author> Intel Corp., </author> <title> Paragon XP/S Product Overview , Beaver ton, </title> <type> Ore., </type> <year> 1991. </year>
Reference-contexts: These performance levels are not achieved at the cost of generality or compatibility. By configuring EV and the Intel Paragon multicomputer <ref> [3] </ref> to both run the Mach microkernel [1] and by adhering to the EV Software Guidelines [5] it is possible to develop application programs on the Paragon which will run on the EV module without need for modification. 2: Architecture The node architecture of EV was driven by a number of
Reference: [4] <author> Intel Corp., </author> <title> Paragon OSF/1 C System Calls Reference Manual, </title> <type> Beaverton, Ore., </type> <year> 1992. </year>
Reference-contexts: The approach taken for achieving the software goals was to document a set of guidelines, called the EV Software Guidelines [5], that defined the subset of the Paragon OS which would be supported on EV. The subset includes the Intel NX message-passing primitives <ref> [4] </ref>. Initially, it was considered imperative to run Mach 3.0 on EV, since this is the heart of Paragon OS. The software guidelines therefore supported all of the Mach 3.0 microker-nel primitives.
Reference: [5] <author> J.G. </author> <title> Koller EV Software Guidelines for iPSC/860 Users ISI Document EVSW-003-10, </title> <month> June </month> <year> 1992. </year>
Reference-contexts: These performance levels are not achieved at the cost of generality or compatibility. By configuring EV and the Intel Paragon multicomputer [3] to both run the Mach microkernel [1] and by adhering to the EV Software Guidelines <ref> [5] </ref> it is possible to develop application programs on the Paragon which will run on the EV module without need for modification. 2: Architecture The node architecture of EV was driven by a number of packaging and compatibility constraints. <p> However, it was important to provide efficient message passing for the most common operations. The approach taken for achieving the software goals was to document a set of guidelines, called the EV Software Guidelines <ref> [5] </ref>, that defined the subset of the Paragon OS which would be supported on EV. The subset includes the Intel NX message-passing primitives [4]. Initially, it was considered imperative to run Mach 3.0 on EV, since this is the heart of Paragon OS.
Reference: [6] <author> J.G. Koller, </author> <title> The MOOS II Operating System and Dynamic Load Balancing , Proceedings of the Fourth Con ference on Hypercubes, Concurrent Computers, </title> <editor> and Appli cations, </editor> <address> Monterey, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: The design was evaluated for the efficiency with which the operating system could process message data after it had been processed by the Packet Handler. The operating system principles that were evaluated against were drawn from Mach and MOOS II <ref> [6] </ref>. After evaluating the first trial design, two conclusions were reached. First, that message sending was conceptually simpler than receiving. Second, that the cause of the added difficulty in receiving was that it required a synchronization step.
Reference: [7] <author> J.G. Koller, </author> <title> Packet Handler Programming Notes Document EVSW-001-12, </title> <month> September </month> <year> 1993. </year>
Reference: [8] <author> K. Loepere, </author> <note> Mach 3 Kernel Principles , Open Software Foundation and Carnegie Mellon University, </note> <month> Mar. </month> <year> 1992. </year>
Reference: [9] <author> Message Passing Interface Forum, </author> <title> Draft Document for a Standard Message-Passing Interface , University of Tennes see, </title> <month> November </month> <year> 1993. </year>
Reference: [10] <editor> C.L. Seitz, et. al, </editor> <booktitle> The Architecture and Programming of the Ametek Series 2010 Multicomputer , Proceedings of the 1988 Hypercube Conference. </booktitle> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: gigabytes per second Module power 500 Watts (19 Watts/in Node memory bandwidth (peak) 400 megabytes per second Node user microprocessor Intel 50MHz i860 XP Node message protocol engine ISI Packet Handler Node operating system Mach microkernel, version 3.0 Mach internode RPC time 90 microseconds the Symult Systems s2010 Message Interface <ref> [10] </ref>. The design was evaluated for the efficiency with which the operating system could process message data after it had been processed by the Packet Handler. The operating system principles that were evaluated against were drawn from Mach and MOOS II [6].
References-found: 10

