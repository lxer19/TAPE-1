URL: http://www.cs.umd.edu/users/franklin/papers/vldbgc.ps.gz
Refering-URL: http://www.cs.umd.edu/projects/dimsum/papers/
Root-URL: 
Email: Laurent.Amsaleg@inria.fr franklin@cs.umd.edu Olivier.Gruber@inria.fr  
Title: Efficient Incremental Garbage Collection for Client-Server Object Database Systems  
Author: Laurent Amsaleg Michael Franklin Olivier Gruber 
Address: Rocquencourt  
Affiliation: INRIA Rocquencourt University of Maryland INRIA  
Abstract: A shorter version of this paper will appear in the 21st VLDB Conf., Zurich, September 1995. Abstract We describe an efficient server-based algorithm for garbage collecting object-oriented databases in a client/server environment. The algorithm is incremental and runs concurrently with client transactions, however, unlike previous algorithms, it does not hold any locks on data and does not require callbacks to clients. It is fault tolerant, but performs very little logging. The algorithm has been designed to be integrated into existing OODB systems, and therefore it works with standard implementation techniques such as two-phase locking and write-ahead-logging. In addition, it supports client-server performance optimizations such as client caching and flexible management of client buffers. We describe an implementation of the algorithm in the EXODUS storage manager and present results from an initial performance study of the implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [Bak78] <author> H. Baker. </author> <title> List Processing in Real Time on a Serial Computer. Com. </title> <journal> of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <month> April </month> <year> 1978. </year>
Reference-contexts: Tracing collectors can be divided into Mark & Sweep algorithms [McC60], which first mark all reachable objects and then reclaim the unmarked ones, and copy-based algorithms (e.g., <ref> [Bak78, Ung84] </ref>) which copy live objects to new locations before reclaiming an entire storage area. <p> At the end of the sweeping phase, garbage collection is complete. Our algorithm is an incremental Mark & Sweep algorithm that has been extended to enforce the preservation of three invariants. These invariants are similar in spirit to invariants that have been proposed for traditional incremental garbage collectors <ref> [DLM + 78, Bak78] </ref>. In contrast to that earlier work, however, these invariants reflect the transactional nature of database accesses. <p> Surveys of this work include [Coh81] and [Wil92]. The invariants that an incremental collector must respect were first proposed by <ref> [DLM + 78, Bak78] </ref>. Our work addresses the efficient implementation of similar invariants in a (transactional) client-server DBMS context. The earliest study of garbage collection for object-oriented databases was done by Butler [But87].
Reference: [BD90] <author> V. Benzaken and C. Delobel. </author> <title> Enhancing Performance in a Persistent Object Store: </title> <booktitle> Clustering Strategies in O 2 . In 4th Int. Workshop on Persistent Object Systems, </booktitle> <pages> pages 403-412, </pages> <address> Martha-Vineyard, Mass., </address> <month> September </month> <year> 1990. </year>
Reference-contexts: * Although copying can reduce fragmentation, slotted pages, which are used in many database systems, allow objects to be moved within a page, thus mitigating the potential fragmentation problems of sweeping. * The clustering produced by a copying-based collector may be in conflict with database requirements or user-specified hints (e.g, <ref> [BD90, GA92] </ref>). For example, generation scaveng ing [Ung84], tends to cluster objects by their age. * Copying causes objects to move between pages, which can require locks and can complicate recovery [KLW89, MRV91, YNY94].
Reference: [BDK91] <author> F. Bancilhon, C. Delobel, and P. Kannellakis. </author> <title> Building an object-oriented database : the O 2 story. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: Objects that are not reachable from a root or from the transient program state of an on-going transaction are garbage; such objects are inaccessible and thus, the space that they occupy can be safely reclaimed. Reachability-based persistence is used in some database systems, such as GemStone [BOS91] and O2 <ref> [BDK91] </ref>, and garbage collection is required in the Smalltalk binding for the ODMG object database standard [Cat94]. In general, however, most existing systems still require programmers to explicitly deallocate objects.
Reference: [BOS91] <author> P. Butterworth, A. Otis, and J. Stein. </author> <title> The GemStone Object Database Management System. Com. </title> <journal> of the ACM, </journal> <volume> 34(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: Objects that are not reachable from a root or from the transient program state of an on-going transaction are garbage; such objects are inaccessible and thus, the space that they occupy can be safely reclaimed. Reachability-based persistence is used in some database systems, such as GemStone <ref> [BOS91] </ref> and O2 [BDK91], and garbage collection is required in the Smalltalk binding for the ODMG object database standard [Cat94]. In general, however, most existing systems still require programmers to explicitly deallocate objects.
Reference: [But87] <author> M. Butler. </author> <title> Storage Reclamation in Object Oriented Database Systems. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <pages> pages 410-425, </pages> <address> San Francisco, CA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: The work described here is aimed at addressing this need. 1.1 OODBMS Garbage Collection Issues In recent years, there has been increasing research activity in OODBMS garbage collection <ref> [But87, FCW89, KLW89, ONG93, ML94, YNY94] </ref>. OODBMS have several features that can impact the correctness and/or performance of traditional garbage collection approaches, including: Concurrency: OODBMS support concurrent transactions. A garbage collector must co-exist with these transactions, and must not adversely impact their ability to execute. <p> The invariants that an incremental collector must respect were first proposed by [DLM + 78, Bak78]. Our work addresses the efficient implementation of similar invariants in a (transactional) client-server DBMS context. The earliest study of garbage collection for object-oriented databases was done by Butler <ref> [But87] </ref>. This work simulated the behavior of several kinds of collectors running against a centralized OODBMS, but did not consider interactions with concurrency control, recovery, and caching mechanisms.
Reference: [Cat94] <author> R. Cattell. </author> <title> The ODMG Object Database Standard, </title> <address> Rel 1.1. Morgan-Kaufman, San Mateo, CA, </address> <year> 1994. </year>
Reference-contexts: Reachability-based persistence is used in some database systems, such as GemStone [BOS91] and O2 [BDK91], and garbage collection is required in the Smalltalk binding for the ODMG object database standard <ref> [Cat94] </ref>. In general, however, most existing systems still require programmers to explicitly deallocate objects. Such systems therefore, typically provide off-line utilities which must be run periodically in order to reclaim lost storage and/or detect dangling references.
Reference: [CDN93] <author> M. Carey, D. Dewitt, and J. Naughton. </author> <title> The OO7 Benchmark. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf, </booktitle> <address> Washington D.C., </address> <month> May 93. </month>
Reference-contexts: EXODUS is a client-server, multi-user system which runs on many Unix platforms. It has been shown to have performance that is competitive with existing commercial OODBMS <ref> [CDN93] </ref>. EXODUS supports the transactional management of untyped objects of variable length, and has full support for indexing, concurrency control, recovery, multiple clients and multiple servers. Data is locked using a strict two-phase locking protocol at the page or coarser granularity.
Reference: [CDRS86] <author> M. Carey, D. DeWitt, J. Richarson, and E. Shekita. </author> <title> Object and File Management in the EXODUS Extensible Database System. </title> <booktitle> In Proc. of the 12th VLDB Int. Conf., </booktitle> <address> Kyoto, Japan, </address> <year> 1986. </year>
Reference-contexts: The server supports asynchronous I/O (using multiple I/O processes) so some threads can run while other threads are waiting for I/O. EXODUS extends a traditional slotted page structure to support objects of arbitrary length <ref> [CDRS86] </ref>. "Small" data items (those that are smaller than a page) and the headers of larger ones are stored on slotted pages.
Reference: [CFLS91] <author> M. Carey, M. Franklin, M. Livny, and E. Shekita. </author> <title> Data Caching Tradeoffs in Client-Server DBMS Architectures. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> Denver, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: At commit time, copies of any remaining dirty pages are sent to the server. The client retains the contents of its cache across transaction boundaries, but no locks are held on those pages. Cache consistency is maintained using a check-on-access policy (based on "Caching 2PL" <ref> [CFLS91] </ref>). For recovery purposes all pages are tagged with a Log Sequence Number (LSN) which serves as a timestamp for the page. The server keeps a small list of the current LSNs for pages that have been recently requested by clients.
Reference: [CFZ94] <author> M. Carey, M. Franklin, and M. Zaharioudakis. </author> <title> Fine-Grained Sharing in a Page Server OODBMS. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> Minneapolis, MN, </address> <month> May 94. </month>
Reference-contexts: Data-shipping systems can be structured as page servers, which send physical units 3 of data between servers and clients, and object servers, in which clients and servers interact using logical units of data <ref> [DFMV90, CFZ94] </ref>. For concreteness, in this paper and in the implementation, we focus on page servers. Each Client DBMS process is responsible for translating local application data requests into requests for specific database pages and for bringing those pages into memory at the client.
Reference: [Coh81] <author> J. Cohen. </author> <title> Garbage Collection of Linked Data Structures. </title> <journal> Computing Surveys, </journal> <volume> 13(3) </volume> <pages> 341-367, </pages> <month> September </month> <year> 1981. </year> <month> 24 </month>
Reference-contexts: Manual detection and reclamation of garbage increases code complexity and is highly error-prone, raising the risk of memory leaks and dangling pointers. For these reasons automated garbage collection has long been an active area of investigation in the programming languages community <ref> [Coh81, Wil92] </ref>. The shared and persistent nature of databases provides further motivation for automated garbage collection. Because a database is shared, the knowledge of data interconnection may be distributed among many programs and/or users, making it difficult for programmers to determine when to explicitly reclaim storage. <p> Such overhead would be incurred by any tracing-based garbage collector, and can be adjusted due to the incremental nature of the collector. 7 Related Work As stated in the introduction, garbage collection has been intensively studied in the context of traditional programming languages. Surveys of this work include <ref> [Coh81] </ref> and [Wil92]. The invariants that an incremental collector must respect were first proposed by [DLM + 78, Bak78]. Our work addresses the efficient implementation of similar invariants in a (transactional) client-server DBMS context. The earliest study of garbage collection for object-oriented databases was done by Butler [But87].
Reference: [Col60] <author> G. Collins. </author> <title> A method for overlapping and erasure of lists. Com. </title> <journal> of the ACM, </journal> <volume> 2(12) </volume> <pages> 655-657, </pages> <month> December </month> <year> 1960. </year>
Reference-contexts: Reference counting <ref> [Col60, McB63] </ref> was disregarded because of its inability to collect cycles (i.e., mutually-referential garbage objects) and the overhead of maintaining reference counts in a fault tolerant manner; thus, a tracing approach was required. In a tracing garbage collector, live objects are identified by traversing the object graph.
Reference: [CWZ94] <author> J. Cook, A. Wolf, and B. Zorn. </author> <title> Partition Selection Policies in Object Database Garbage Collection. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <pages> pages 371-382, </pages> <address> Mineapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: It can co-exist with performance enhancements such as inter-transaction caching at clients and flexible "steal" buffer management between clients and servers. * It has been implemented and measured in the client-server EXODUS storage manager. Similar to other recent work on DBMS garbage collection <ref> [CWZ94, YNY94, ML94] </ref> we have adopted a partitioned approach in order to avoid having to scan the entire database before reclaiming any space. In contrast to the other work, which advocated copying or reference counting approaches, we have adopted a non-copying Mark & Sweep algorithm. <p> In a tracing garbage collector, live objects are identified by traversing the object graph. The potential for large object graphs in an OODBMS dictates a approach in which the database is partitioned into separate units that can be garbage collected independently <ref> [YNY94, CWZ94] </ref>. Tracing collectors can be divided into Mark & Sweep algorithms [McC60], which first mark all reachable objects and then reclaim the unmarked ones, and copy-based algorithms (e.g., [Bak78, Ung84]) which copy live objects to new locations before reclaiming an entire storage area. <p> This work addresses fault tolerance but does not consider dynamic page replication and caching as arises in a client-server environment. Heuristics for selecting which partition is the most cost-effective for a partition-based algorithm to collect have been studied in <ref> [CWZ94] </ref>. This work, however, did not address the details of collection algorithm itself. A reference counting collection scheme for MIT's Thor system is described in [ML94]. Thor is a distributed OODBMS which uses optimistic concurrency control to regulate accesses to objects.
Reference: [DFMV90] <author> D. DeWitt, P. Futtersack, D. Maier, and F. Velez. </author> <title> A Study of Three Alternative Workstation-Server Architectures for Object-Oriented Database Systems. </title> <booktitle> In Proc. of the 16th VLDB Int. Conf., </booktitle> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Data-shipping systems can be structured as page servers, which send physical units 3 of data between servers and clients, and object servers, in which clients and servers interact using logical units of data <ref> [DFMV90, CFZ94] </ref>. For concreteness, in this paper and in the implementation, we focus on page servers. Each Client DBMS process is responsible for translating local application data requests into requests for specific database pages and for bringing those pages into memory at the client.
Reference: [DLM + 78] <author> E. Dijkstra, L. Lamport, A. Martin, C. Scholten, and E. Steffens. </author> <title> On-the-Fly Garbage Collection: An Exercise in Cooperation. Com. </title> <journal> of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: At the end of the sweeping phase, garbage collection is complete. Our algorithm is an incremental Mark & Sweep algorithm that has been extended to enforce the preservation of three invariants. These invariants are similar in spirit to invariants that have been proposed for traditional incremental garbage collectors <ref> [DLM + 78, Bak78] </ref>. In contrast to that earlier work, however, these invariants reflect the transactional nature of database accesses. <p> Surveys of this work include [Coh81] and [Wil92]. The invariants that an incremental collector must respect were first proposed by <ref> [DLM + 78, Bak78] </ref>. Our work addresses the efficient implementation of similar invariants in a (transactional) client-server DBMS context. The earliest study of garbage collection for object-oriented databases was done by Butler [But87].
Reference: [EXO93] <author> EXODUS Project Group. </author> <title> EXODUS Storage Manager Architectural Overview, </title> <year> 1993. </year>
Reference-contexts: In order to assess the algorithm in light of these requirements, we have implemented it in the client-server version of the EXODUS storage manager <ref> [FZT + 92, EXO93] </ref>. In this section we describe the implementation of the single-partition collector. The extensions for fully supporting inter-partition references discussed in Section 4.6 are currently being added. 5.1 The EXODUS Storage Manager Our initial implementation is based on the EXODUS storage manager v3.1 [EXO93]. <p> In this section we describe the implementation of the single-partition collector. The extensions for fully supporting inter-partition references discussed in Section 4.6 are currently being added. 5.1 The EXODUS Storage Manager Our initial implementation is based on the EXODUS storage manager v3.1 <ref> [EXO93] </ref>. EXODUS is a client-server, multi-user system which runs on many Unix platforms. It has been shown to have performance that is competitive with existing commercial OODBMS [CDN93].
Reference: [FCL93] <author> M. Franklin, M. Carey, and M. Livny. </author> <title> Local Disk Caching in Client-Server Database Systems. </title> <booktitle> In Proc. of the 19th VLDB Int. Conf, </booktitle> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: A3 must be supported by any client-server DBMS that implements WAL-based recovery at servers (e.g., EXODUS [FZT + 92], and ARIES/CSA [MN94]). A4 simplifies recovery and avoids the need for client checkpoints in such systems. The tradeoffs involved in relaxing A4 are discussed in [FZT + 92], <ref> [FCL93] </ref>, and [MN94].
Reference: [FCW89] <author> M. Franklin, G. Copeland, and G. Weikum. </author> <title> What's Different About Garbage Collection For Persistent Programming Languages? Technical Report ACA-ST-062-89, </title> <institution> MCC, Austin, Texas, </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: The work described here is aimed at addressing this need. 1.1 OODBMS Garbage Collection Issues In recent years, there has been increasing research activity in OODBMS garbage collection <ref> [But87, FCW89, KLW89, ONG93, ML94, YNY94] </ref>. OODBMS have several features that can impact the correctness and/or performance of traditional garbage collection approaches, including: Concurrency: OODBMS support concurrent transactions. A garbage collector must co-exist with these transactions, and must not adversely impact their ability to execute.
Reference: [FZT + 92] <author> M. Franklin, M. Zwilling, C. Tan, M. Carey, and D. DeWitt. </author> <title> Crash Recovery in Client-Server EXODUS. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> San Diego, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Assumptions A1 and A2 are fundamental to the algorithm's correctness; A3 and A4 are important details on which the implementation of the algorithm is based. A3 must be supported by any client-server DBMS that implements WAL-based recovery at servers (e.g., EXODUS <ref> [FZT + 92] </ref>, and ARIES/CSA [MN94]). A4 simplifies recovery and avoids the need for client checkpoints in such systems. The tradeoffs involved in relaxing A4 are discussed in [FZT + 92], [FCL93], and [MN94]. <p> A3 must be supported by any client-server DBMS that implements WAL-based recovery at servers (e.g., EXODUS <ref> [FZT + 92] </ref>, and ARIES/CSA [MN94]). A4 simplifies recovery and avoids the need for client checkpoints in such systems. The tradeoffs involved in relaxing A4 are discussed in [FZT + 92], [FCL93], and [MN94]. <p> In order to assess the algorithm in light of these requirements, we have implemented it in the client-server version of the EXODUS storage manager <ref> [FZT + 92, EXO93] </ref>. In this section we describe the implementation of the single-partition collector. The extensions for fully supporting inter-partition references discussed in Section 4.6 are currently being added. 5.1 The EXODUS Storage Manager Our initial implementation is based on the EXODUS storage manager v3.1 [EXO93]. <p> Data is locked using a strict two-phase locking protocol at the page or coarser granularity. Recovery is provided by an ARIES-based [MHL + 92] WAL protocol <ref> [FZT + 92] </ref>. The EXODUS server is multi-threaded | every user request is assigned a thread when it arrives at the server; the server also has its own threads for log management, etc.
Reference: [GA92] <author> O. Gruber and L. Amsaleg. </author> <title> Object Grouping in Eos. </title> <booktitle> In Proc. of the Int. Workshop on Distributed Object Management, </booktitle> <pages> pages 117-131, </pages> <address> Edmonton, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: * Although copying can reduce fragmentation, slotted pages, which are used in many database systems, allow objects to be moved within a page, thus mitigating the potential fragmentation problems of sweeping. * The clustering produced by a copying-based collector may be in conflict with database requirements or user-specified hints (e.g, <ref> [BD90, GA92] </ref>). For example, generation scaveng ing [Ung84], tends to cluster objects by their age. * Copying causes objects to move between pages, which can require locks and can complicate recovery [KLW89, MRV91, YNY94].
Reference: [GR93] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <address> Morgan-Kaufman, San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: The collector has the following characteristics: * It is server-based, but requires no callbacks to clients and performs only minimal synchro nization with client processes. 2 * It works in the context of ACID transactions <ref> [GR93] </ref> with standard implementation techniques such as two-phase locking and write-ahead-logging; it requires no special hardware. * It is incremental and non-disruptive; it holds no locks on data and introduces very little additional logging. <p> performance, also raises potential problems for garbage collection algorithms. 2.2 Assumptions Our solution depends upon several assumptions about the OODBMS architecture: Assumption A1: All user operations that access or modify object pointers are done using two phase locks that are held until the end of transaction (i.e., degree 3 consistency <ref> [GR93] </ref>). 1 Assumption A2: The validity of object identifiers (OIDs) is maintained only for those OIDs that reside in the database or in the transient state (e.g., program variables, stacks, etc.) of active transactions. <p> Recall that invariant I3 requires the effects of a page sweep to be reflected on stable storage before the space freed on the page is re-used. In a sense, it requires that the sweep of a page be treated as if it were a "nested top-level transaction" <ref> [GR93] </ref>. Therefore, REDO can ensure that if an operation that re-used space freed by the sweeper needs to be redone, the freeing of that space will be redone prior to the redo of the operation.
Reference: [Hug85] <author> J. Hughes. </author> <title> A Distributed Garbage Collection Algorithm. </title> <booktitle> In Functional Languages and Computer Architectures, number 201 in Lecture Notes in Computer Science, </booktitle> <pages> pages 256-272, </pages> <address> Nancy (France), </address> <month> September </month> <year> 1985. </year> <note> Springer-Verlag. </note>
Reference-contexts: Thus, IRLs must be maintained in database pages (rather than with in-memory structures), and updates to them must be logged. Secondly, as is well known, this type of approach can not collect cycles of garbage that are distributed across multiple partitions. Separate algorithms such as Hughes' distributed collector <ref> [Hug85] </ref> can be used to collect such cycles periodically.
Reference: [KLW89] <author> E. Kolodner, B. Liskov, and W. Weihl. </author> <title> Atomic Garbage collection: Managing a Stable Heap. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <pages> pages 15-25, </pages> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: The work described here is aimed at addressing this need. 1.1 OODBMS Garbage Collection Issues In recent years, there has been increasing research activity in OODBMS garbage collection <ref> [But87, FCW89, KLW89, ONG93, ML94, YNY94] </ref>. OODBMS have several features that can impact the correctness and/or performance of traditional garbage collection approaches, including: Concurrency: OODBMS support concurrent transactions. A garbage collector must co-exist with these transactions, and must not adversely impact their ability to execute. <p> For example, generation scaveng ing [Ung84], tends to cluster objects by their age. * Copying causes objects to move between pages, which can require locks and can complicate recovery <ref> [KLW89, MRV91, YNY94] </ref>. Despite these arguments, there are several problems that can arise when attempting to implement an efficient Mark & Sweep algorithm for an OODBMS. <p> This work simulated the behavior of several kinds of collectors running against a centralized OODBMS, but did not consider interactions with concurrency control, recovery, and caching mechanisms. More recent work has investigated fault-tolerant garbage collection techniques for transactional persistent systems in centralized <ref> [KLW89, KW93, ONG93] </ref> and distributed [MRV91, MS91] architectures. This work addresses fault tolerance but does not consider dynamic page replication and caching as arises in a client-server environment. Heuristics for selecting which partition is the most cost-effective for a partition-based algorithm to collect have been studied in [CWZ94].
Reference: [KW93] <author> E. Kolodner and W. Weihl. </author> <title> Atomic incremental garbage collection and recovery for large stable heap. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> Washington D.C., </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Note that unlike previous work that exploits logs (e.g., <ref> [KW93, ONG93] </ref>), this algorithm processes log records as they arrive at the server | prior to their reaching stable storage. When a transaction terminates (commits or aborts), its entries in the PRT are flagged. <p> This work simulated the behavior of several kinds of collectors running against a centralized OODBMS, but did not consider interactions with concurrency control, recovery, and caching mechanisms. More recent work has investigated fault-tolerant garbage collection techniques for transactional persistent systems in centralized <ref> [KLW89, KW93, ONG93] </ref> and distributed [MRV91, MS91] architectures. This work addresses fault tolerance but does not consider dynamic page replication and caching as arises in a client-server environment. Heuristics for selecting which partition is the most cost-effective for a partition-based algorithm to collect have been studied in [CWZ94].
Reference: [McB63] <author> J. McBeth. </author> <title> On the Reference Counter Method. Com. </title> <booktitle> of the ACM, </booktitle> <address> 6(9):575, </address> <month> September </month> <year> 1963. </year>
Reference-contexts: Reference counting <ref> [Col60, McB63] </ref> was disregarded because of its inability to collect cycles (i.e., mutually-referential garbage objects) and the overhead of maintaining reference counts in a fault tolerant manner; thus, a tracing approach was required. In a tracing garbage collector, live objects are identified by traversing the object graph.
Reference: [McC60] <author> J. McCarthy. </author> <title> Recursive Functions of Symbolic Expressions and their Computation by Machine. Com. </title> <journal> of the ACM, </journal> <volume> 3(4) </volume> <pages> 184-195, </pages> <month> April </month> <year> 1960. </year>
Reference-contexts: The potential for large object graphs in an OODBMS dictates a approach in which the database is partitioned into separate units that can be garbage collected independently [YNY94, CWZ94]. Tracing collectors can be divided into Mark & Sweep algorithms <ref> [McC60] </ref>, which first mark all reachable objects and then reclaim the unmarked ones, and copy-based algorithms (e.g., [Bak78, Ung84]) which copy live objects to new locations before reclaiming an entire storage area. <p> The algorithm is initially presented in the context of a monolithic (i.e., non-partitioned) database, and then extended to allow for independent collection of database partitions. First, however, we discuss the intuition behind the algorithm. 8 4.1 Enforcing Correctness A traditional Mark&Sweep <ref> [McC60] </ref> algorithm associates a "color" with each object in the object space. An object can have one of two colors: live or garbage. The colors for objects are stored in special color maps that are not part of the persistent object space.
Reference: [MHL + 92] <author> C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh, and P. Schwarz. </author> <title> ARIES: A Transaction Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(1), </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: EXODUS supports the transactional management of untyped objects of variable length, and has full support for indexing, concurrency control, recovery, multiple clients and multiple servers. Data is locked using a strict two-phase locking protocol at the page or coarser granularity. Recovery is provided by an ARIES-based <ref> [MHL + 92] </ref> WAL protocol [FZT + 92]. The EXODUS server is multi-threaded | every user request is assigned a thread when it arrives at the server; the server also has its own threads for log management, etc.
Reference: [ML94] <author> U. Maheshwari and B. Liskov. </author> <title> Fault-Tolerant Distributed Garbage Collection in a Client-Server Object-Oriented Database. </title> <booktitle> In Proc. of the 3rd PDIS Int. Conf., </booktitle> <address> Austin, TX, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: The work described here is aimed at addressing this need. 1.1 OODBMS Garbage Collection Issues In recent years, there has been increasing research activity in OODBMS garbage collection <ref> [But87, FCW89, KLW89, ONG93, ML94, YNY94] </ref>. OODBMS have several features that can impact the correctness and/or performance of traditional garbage collection approaches, including: Concurrency: OODBMS support concurrent transactions. A garbage collector must co-exist with these transactions, and must not adversely impact their ability to execute. <p> It can co-exist with performance enhancements such as inter-transaction caching at clients and flexible "steal" buffer management between clients and servers. * It has been implemented and measured in the client-server EXODUS storage manager. Similar to other recent work on DBMS garbage collection <ref> [CWZ94, YNY94, ML94] </ref> we have adopted a partitioned approach in order to avoid having to scan the entire database before reclaiming any space. In contrast to the other work, which advocated copying or reference counting approaches, we have adopted a non-copying Mark & Sweep algorithm. <p> Figure 5 shows an example of two partitions containing objects with cross-partition references. Note that the objects themselves point directly to each other and do not involve the inter-partition reference list. Similar schemes are often used by distributed garbage collection algorithms to handle inter-node references (e.g., <ref> [SGP90, ML94] </ref>). The IRL mechanism is transparent to programmers, and therefore, updates that may require IRL modifications must be trapped. This is handled in the same manner as the PRT and COT: the server examines incoming log records. <p> Heuristics for selecting which partition is the most cost-effective for a partition-based algorithm to collect have been studied in [CWZ94]. This work, however, did not address the details of collection algorithm itself. A reference counting collection scheme for MIT's Thor system is described in <ref> [ML94] </ref>. Thor is a distributed OODBMS which uses optimistic concurrency control to regulate accesses to objects. This paper focuses on distributed collection across servers in a client-server environment rather than on collection that is local to a server. <p> The algorithm uses a "no-steal" policy so that modified objects are not sent to the servers prior to commit. This policy avoids the problems due to partial flushes of updates (Section 3.2) at the expense of reduced flexibility in client cache management. <ref> [ML94] </ref> describes the algorithm but does not discuss an implementation and provides no performance analysis. The work that is most relevant to our algorithm is [YNY94]. This paper investigates the perfor 22 mance tradeoffs of several reclamation algorithms for client-server persistent object stores.
Reference: [MN94] <author> C. Mohan and I. Narang. ARIES/CSA: </author> <title> A method for Database Recovery in Client-Server Architectures. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Assumptions A1 and A2 are fundamental to the algorithm's correctness; A3 and A4 are important details on which the implementation of the algorithm is based. A3 must be supported by any client-server DBMS that implements WAL-based recovery at servers (e.g., EXODUS [FZT + 92], and ARIES/CSA <ref> [MN94] </ref>). A4 simplifies recovery and avoids the need for client checkpoints in such systems. The tradeoffs involved in relaxing A4 are discussed in [FZT + 92], [FCL93], and [MN94]. <p> A3 must be supported by any client-server DBMS that implements WAL-based recovery at servers (e.g., EXODUS [FZT + 92], and ARIES/CSA <ref> [MN94] </ref>). A4 simplifies recovery and avoids the need for client checkpoints in such systems. The tradeoffs involved in relaxing A4 are discussed in [FZT + 92], [FCL93], and [MN94].
Reference: [MRV91] <author> L. Mancini, V. Rotella, and S. Venosa. </author> <title> Copying Garbage Collection for Distributed Object Stores. </title> <booktitle> In 10th Symposium on Reliable Distributed Systems, </booktitle> <address> Pisa, Italy, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: For example, generation scaveng ing [Ung84], tends to cluster objects by their age. * Copying causes objects to move between pages, which can require locks and can complicate recovery <ref> [KLW89, MRV91, YNY94] </ref>. Despite these arguments, there are several problems that can arise when attempting to implement an efficient Mark & Sweep algorithm for an OODBMS. <p> This work simulated the behavior of several kinds of collectors running against a centralized OODBMS, but did not consider interactions with concurrency control, recovery, and caching mechanisms. More recent work has investigated fault-tolerant garbage collection techniques for transactional persistent systems in centralized [KLW89, KW93, ONG93] and distributed <ref> [MRV91, MS91] </ref> architectures. This work addresses fault tolerance but does not consider dynamic page replication and caching as arises in a client-server environment. Heuristics for selecting which partition is the most cost-effective for a partition-based algorithm to collect have been studied in [CWZ94].
Reference: [MS91] <author> L. Mancini and S. Shrinivastava. </author> <title> Fault-tolerant Reference Counting for Garbage Colection in Distributed Systems. </title> <journal> Computer Journal, </journal> <volume> 34(6) </volume> <pages> 503-513, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: This work simulated the behavior of several kinds of collectors running against a centralized OODBMS, but did not consider interactions with concurrency control, recovery, and caching mechanisms. More recent work has investigated fault-tolerant garbage collection techniques for transactional persistent systems in centralized [KLW89, KW93, ONG93] and distributed <ref> [MRV91, MS91] </ref> architectures. This work addresses fault tolerance but does not consider dynamic page replication and caching as arises in a client-server environment. Heuristics for selecting which partition is the most cost-effective for a partition-based algorithm to collect have been studied in [CWZ94].
Reference: [ONG93] <author> J. O'Toole, S. Nettles, and D. Gifford. </author> <title> Concurrent Compacting Garbage Collection of a Persistent Heap. </title> <booktitle> In Proc. of the 14th SOSP, </booktitle> <pages> pages 161-174, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year> <note> ACM Press. </note>
Reference-contexts: The work described here is aimed at addressing this need. 1.1 OODBMS Garbage Collection Issues In recent years, there has been increasing research activity in OODBMS garbage collection <ref> [But87, FCW89, KLW89, ONG93, ML94, YNY94] </ref>. OODBMS have several features that can impact the correctness and/or performance of traditional garbage collection approaches, including: Concurrency: OODBMS support concurrent transactions. A garbage collector must co-exist with these transactions, and must not adversely impact their ability to execute. <p> Note that unlike previous work that exploits logs (e.g., <ref> [KW93, ONG93] </ref>), this algorithm processes log records as they arrive at the server | prior to their reaching stable storage. When a transaction terminates (commits or aborts), its entries in the PRT are flagged. <p> This work simulated the behavior of several kinds of collectors running against a centralized OODBMS, but did not consider interactions with concurrency control, recovery, and caching mechanisms. More recent work has investigated fault-tolerant garbage collection techniques for transactional persistent systems in centralized <ref> [KLW89, KW93, ONG93] </ref> and distributed [MRV91, MS91] architectures. This work addresses fault tolerance but does not consider dynamic page replication and caching as arises in a client-server environment. Heuristics for selecting which partition is the most cost-effective for a partition-based algorithm to collect have been studied in [CWZ94].
Reference: [SGP90] <author> M. Shapiro, O. Gruber, and D. Plainfosse. </author> <title> A Garbage Detection Protocol for a Realistic Distributed Object-support System. </title> <type> Technical Report INRIA-1320, </type> <institution> INRIA, Rocquencourt, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: Figure 5 shows an example of two partitions containing objects with cross-partition references. Note that the objects themselves point directly to each other and do not involve the inter-partition reference list. Similar schemes are often used by distributed garbage collection algorithms to handle inter-node references (e.g., <ref> [SGP90, ML94] </ref>). The IRL mechanism is transparent to programmers, and therefore, updates that may require IRL modifications must be trapped. This is handled in the same manner as the PRT and COT: the server examines incoming log records.
Reference: [Ung84] <author> D. Ungar. </author> <title> Generation scavenging: A non-disruptive high-performance storage reclamation algorithm. </title> <booktitle> In ACM SIGSOFT/SIGPLAN Symposium on Practical Software Development Environments, </booktitle> <pages> pages 157-167. </pages> <publisher> ACM Press, </publisher> <month> April </month> <year> 1984. </year> <month> 25 </month>
Reference-contexts: Tracing collectors can be divided into Mark & Sweep algorithms [McC60], which first mark all reachable objects and then reclaim the unmarked ones, and copy-based algorithms (e.g., <ref> [Bak78, Ung84] </ref>) which copy live objects to new locations before reclaiming an entire storage area. <p> For example, generation scaveng ing <ref> [Ung84] </ref>, tends to cluster objects by their age. * Copying causes objects to move between pages, which can require locks and can complicate recovery [KLW89, MRV91, YNY94]. Despite these arguments, there are several problems that can arise when attempting to implement an efficient Mark & Sweep algorithm for an OODBMS.
Reference: [Wil92] <author> P. Wilson. </author> <title> Uniprocessor Garbage Collection Techniques. </title> <booktitle> In Int. Workshop on Memory Manage--ment, </booktitle> <volume> volume 637, </volume> <pages> pages 1-43, </pages> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference-contexts: Manual detection and reclamation of garbage increases code complexity and is highly error-prone, raising the risk of memory leaks and dangling pointers. For these reasons automated garbage collection has long been an active area of investigation in the programming languages community <ref> [Coh81, Wil92] </ref>. The shared and persistent nature of databases provides further motivation for automated garbage collection. Because a database is shared, the knowledge of data interconnection may be distributed among many programs and/or users, making it difficult for programmers to determine when to explicitly reclaim storage. <p> Therefore, a single PRT entry transitively protects all of the objects that are reachable from the protected object. In order to make the necessary entries in the PRT, all updates to pointer fields in objects must be trapped. Traps of this form are typically implemented using a write barrier <ref> [Wil92, YNY94] </ref>. A write barrier detects when an assignment operation occurs and performs any bookkeeping that is required by the garbage collector. Recall that the garbage collector (and hence, the PRT) reside at the server while updates are performed on cached data copies at clients. <p> Surveys of this work include [Coh81] and <ref> [Wil92] </ref>. The invariants that an incremental collector must respect were first proposed by [DLM + 78, Bak78]. Our work addresses the efficient implementation of similar invariants in a (transactional) client-server DBMS context. The earliest study of garbage collection for object-oriented databases was done by Butler [But87].
Reference: [YNY94] <author> V. Yong, J. Naughton, and J. Yu. </author> <title> Storage Reclamation and Reorganization in Client-Server Persistent Object Stores. </title> <booktitle> In Proc. of the Data Engineering Int. Conf., </booktitle> <pages> pages 120-133, </pages> <address> Houston, TX, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: The work described here is aimed at addressing this need. 1.1 OODBMS Garbage Collection Issues In recent years, there has been increasing research activity in OODBMS garbage collection <ref> [But87, FCW89, KLW89, ONG93, ML94, YNY94] </ref>. OODBMS have several features that can impact the correctness and/or performance of traditional garbage collection approaches, including: Concurrency: OODBMS support concurrent transactions. A garbage collector must co-exist with these transactions, and must not adversely impact their ability to execute. <p> It can co-exist with performance enhancements such as inter-transaction caching at clients and flexible "steal" buffer management between clients and servers. * It has been implemented and measured in the client-server EXODUS storage manager. Similar to other recent work on DBMS garbage collection <ref> [CWZ94, YNY94, ML94] </ref> we have adopted a partitioned approach in order to avoid having to scan the entire database before reclaiming any space. In contrast to the other work, which advocated copying or reference counting approaches, we have adopted a non-copying Mark & Sweep algorithm. <p> In a tracing garbage collector, live objects are identified by traversing the object graph. The potential for large object graphs in an OODBMS dictates a approach in which the database is partitioned into separate units that can be garbage collected independently <ref> [YNY94, CWZ94] </ref>. Tracing collectors can be divided into Mark & Sweep algorithms [McC60], which first mark all reachable objects and then reclaim the unmarked ones, and copy-based algorithms (e.g., [Bak78, Ung84]) which copy live objects to new locations before reclaiming an entire storage area. <p> For example, generation scaveng ing [Ung84], tends to cluster objects by their age. * Copying causes objects to move between pages, which can require locks and can complicate recovery <ref> [KLW89, MRV91, YNY94] </ref>. Despite these arguments, there are several problems that can arise when attempting to implement an efficient Mark & Sweep algorithm for an OODBMS. <p> Therefore, a single PRT entry transitively protects all of the objects that are reachable from the protected object. In order to make the necessary entries in the PRT, all updates to pointer fields in objects must be trapped. Traps of this form are typically implemented using a write barrier <ref> [Wil92, YNY94] </ref>. A write barrier detects when an assignment operation occurs and performs any bookkeeping that is required by the garbage collector. Recall that the garbage collector (and hence, the PRT) reside at the server while updates are performed on cached data copies at clients. <p> This policy avoids the problems due to partial flushes of updates (Section 3.2) at the expense of reduced flexibility in client cache management. [ML94] describes the algorithm but does not discuss an implementation and provides no performance analysis. The work that is most relevant to our algorithm is <ref> [YNY94] </ref>. This paper investigates the perfor 22 mance tradeoffs of several reclamation algorithms for client-server persistent object stores. Some of the results are obtained from an implementation of an incremental partitioned Mark & Sweep algorithm, although very few details of this algorithm or its implementation are given. <p> Measurements of the implementation showed that the write barrier has only minimal impact on client performance; our measurements support this result. Several other algorithms are examined in <ref> [YNY94] </ref>, including a partitioned copy-based collection algorithm. This algorithm obtains non-two-phase exclusive transactional locks for moving objects and uses callbacks, it also requires the use of logical OIDs.
Reference: [ZM90] <author> S. Zdonik and D. Maier. </author> <title> Readings in Object-Oriented Database Systems. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year> <month> 26 </month>
Reference-contexts: Reachability provides a simple, implicit way to express persistence that is orthogonal fl Much of this author's work was performed as a Visiting Researcher at INRIA Rocquencourt and was partially supported by NSF Grant IRI-9409575, and the University of Maryland General Research Board. 1 to object type <ref> [ZM90] </ref>. The database is an object graph in which some objects are designated as persistent roots. Objects that can be reached by traversing a path from a root can persist beyond the execution of the transaction that created them.
References-found: 37

