URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/rec.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Email: ma@pa.dec.com  mf@dcs.ed.ac.uk  
Title: Syntactic Considerations on Recursive Types  
Author: Martin Abadi Marcelo P. Fiore 
Affiliation: Systems Research Center Digital Equipment Corporation  LFCS University of Edinburgh  
Abstract: We study recursive types from a syntactic perspective. In particular, we compare the formulations of recursive types that are used in programming languages and formal systems. Our main tool is a new syntactic explanation of type expressions as functors. We also introduce a simple logic for programs with recursive types in which we carry out our proofs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martin Abadi and Gordon Plotkin. </author> <title> A per model of polymorphism and recursive types. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 355-365, </pages> <year> 1990. </year>
Reference-contexts: Given a category C there are various approaches to constructing an involutory category I (C). In the context of order-enriched categories one can exploit the duality embedding/projection [21]. There are also canonical choices, namely C = C op fi C [11] or its subcategory C D <ref> [1, 10] </ref> consisting of all those objects on the diagonal. In any case type constructors with n free type variables are viewed as symmetric functors I (C) n ! I (C), induced by functors I (C) n ! C. In our definitions, we are constrained by syntax. <p> Equal types can be used interchangeably: when- ever A = B, x = A y oe x = B y We believe that the extended logic is sound for a per model, a call-by-value version of existing ones <ref> [2, 1] </ref>.
Reference: [2] <author> Roberto M. Amadio. </author> <title> Recursion over realizab-ility structures. </title> <journal> Information and Computation, </journal> <volume> 91(1) </volume> <pages> 55-85, </pages> <year> 1991. </year>
Reference-contexts: Equal types can be used interchangeably: when- ever A = B, x = A y oe x = B y We believe that the extended logic is sound for a per model, a call-by-value version of existing ones <ref> [2, 1] </ref>.
Reference: [3] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyp-ing recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: We examine the formulations of recursive types as they appear in programming languages and in formal systems; there are two main approaches: * The first approach relies on a notion of type equality (e.g., see <ref> [16, 3] </ref>). A recursive type is equal to fl Research supported by EPSRC project Frameworks for Programming Language Semantics and Logic (grant RR29300) and by HCM project Typed Lambda-Calculus (grant ERBCHRXCT 92-0046). its expansions, and if a term has a type then it has all equal types. <p> Our work draws on many previous developments in semantics and in logics of programs. It also has affinities with previous syntactic work, particularly that of Amadio and Cardelli <ref> [3] </ref>. Amadio and Cardelli have shown how to replace subtypings with coercion functions in the presence of recursive types (see also [6]).
Reference: [4] <author> M. Beeson. </author> <title> Formalizing constructive mathematics: why and how? In Constructive Mathematics, </title> <booktitle> volume 873 of Lecture Notes in Mathematics, </booktitle> <pages> pages 146-190. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Our explanation of type expressions as functors, although based on semantic ideas, is purely syntactic. It is perhaps more elementary and compelling than its semantic counterparts. We also introduce a simple logic for the first-order -calculus with recursive types. It is a logic of partial terms <ref> [4, 18] </ref>; because of partiality, we avoid the inconsistencies connected with recursive types. Alternatively, we could have reasoned in the models of the logic, possibly doing without the logic altogether. We have preferred to use the logic because of the syntactic character of our enterprise. <p> The logic is suggested by a call-by-value interpretation of FPC. It is a logic of definedness in the sense of Feferman [7] (or a logic of partial terms <ref> [4, 5] </ref>); it enables us to reason about terms which may or may not have a value. The use of a logic of definedness is important for two reasons: 1. In FPC, one can write terms that do not normal ize. 2.
Reference: [5] <author> M. Beeson. </author> <title> Foundations of Constructive Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The logic is suggested by a call-by-value interpretation of FPC. It is a logic of definedness in the sense of Feferman [7] (or a logic of partial terms <ref> [4, 5] </ref>); it enables us to reason about terms which may or may not have a value. The use of a logic of definedness is important for two reasons: 1. In FPC, one can write terms that do not normal ize. 2.
Reference: [6] <author> Val Breazu-Tannen, Thierry Coquand, Carl A. Gunter, and Andre Scedrov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 172-222, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Our work draws on many previous developments in semantics and in logics of programs. It also has affinities with previous syntactic work, particularly that of Amadio and Cardelli [3]. Amadio and Cardelli have shown how to replace subtypings with coercion functions in the presence of recursive types (see also <ref> [6] </ref>). Our work is complementary to theirs; roughly, their coercion interpretation reduces a calculus with subtyping to one with type equality, and our coercion interpretation reduces one with type equality to one with iso-morphism.
Reference: [7] <author> S. Feferman. Definedness. </author> <title> Manuscript (Lecture for mini-conference on Partial Functions and Programming: Foundational Questions), </title> <month> May </month> <year> 1995. </year>
Reference-contexts: The logic is suggested by a call-by-value interpretation of FPC. It is a logic of definedness in the sense of Feferman <ref> [7] </ref> (or a logic of partial terms [4, 5]); it enables us to reason about terms which may or may not have a value. The use of a logic of definedness is important for two reasons: 1. In FPC, one can write terms that do not normal ize. 2. <p> Three minor differences are worth noting. First, Plotkin works with a logic of existence <ref> [7] </ref> (or a logic of partial elements [20, 9]), where free variables are thought of as ranging over a domain of possibly non-existing elements. Second, he axiomatises approximation (v, &lt; ) rather than equality.
Reference: [8] <author> M.P. Fiore. </author> <title> Axiomatic Domain Theory in Categories of Partial Maps. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1994. </year> <note> To be published by Cam-bridge University Press in the Distinguished Dissertations Series. </note>
Reference-contexts: Those ideas are the origin of the definition of types as functors that we have given. The treatment of type constructors as functors is difficult because of contravariance. A solution is to take the category of types to be involutory (i.e., isomorphic to its dual via an involution) <ref> [8] </ref>. Given a category C there are various approaches to constructing an involutory category I (C). In the context of order-enriched categories one can exploit the duality embedding/projection [21].
Reference: [9] <author> M.P. Fourman. </author> <title> The logic of topoi. </title> <editor> In J. Bar-wise, editor, </editor> <booktitle> Handbook of Mathematical Logic, volume 90 of Studies in Logic. </booktitle> <publisher> North Holland, </publisher> <year> 1977. </year>
Reference-contexts: Three minor differences are worth noting. First, Plotkin works with a logic of existence [7] (or a logic of partial elements <ref> [20, 9] </ref>), where free variables are thought of as ranging over a domain of possibly non-existing elements. Second, he axiomatises approximation (v, &lt; ) rather than equality.
Reference: [10] <author> P.J. Freyd. </author> <title> Recursive types reduced to inductive types. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 498-507, </pages> <year> 1990. </year>
Reference-contexts: In semantics, it is by now common to view functions on types as functors; the substantial difficulties that arise for con-travariant types can be surmounted with a variety of techniques (categories of embeddings, involutory categories, etc.) <ref> [21, 10, 11] </ref>. Our explanation of type expressions as functors, although based on semantic ideas, is purely syntactic. It is perhaps more elementary and compelling than its semantic counterparts. We also introduce a simple logic for the first-order -calculus with recursive types. <p> Given a category C there are various approaches to constructing an involutory category I (C). In the context of order-enriched categories one can exploit the duality embedding/projection [21]. There are also canonical choices, namely C = C op fi C [11] or its subcategory C D <ref> [1, 10] </ref> consisting of all those objects on the diagonal. In any case type constructors with n free type variables are viewed as symmetric functors I (C) n ! I (C), induced by functors I (C) n ! C. In our definitions, we are constrained by syntax.
Reference: [11] <author> P.J. Freyd. </author> <title> Algebraically complete categories. </title> <editor> In A. Carboni, M.C. Pedicchio, and G. Rosolini, editors, </editor> <booktitle> Category Theory, volume 1488 of Lecture Notes in Mathematics, </booktitle> <pages> pages 131-156. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In semantics, it is by now common to view functions on types as functors; the substantial difficulties that arise for con-travariant types can be surmounted with a variety of techniques (categories of embeddings, involutory categories, etc.) <ref> [21, 10, 11] </ref>. Our explanation of type expressions as functors, although based on semantic ideas, is purely syntactic. It is perhaps more elementary and compelling than its semantic counterparts. We also introduce a simple logic for the first-order -calculus with recursive types. <p> Given a category C there are various approaches to constructing an involutory category I (C). In the context of order-enriched categories one can exploit the duality embedding/projection [21]. There are also canonical choices, namely C = C op fi C <ref> [11] </ref> or its subcategory C D [1, 10] consisting of all those objects on the diagonal. In any case type constructors with n free type variables are viewed as symmetric functors I (C) n ! I (C), induced by functors I (C) n ! C. <p> The use of a logic of definedness is important for two reasons: 1. In FPC, one can write terms that do not normal ize. 2. Our main means for reasoning about recursion is Freyd's Principle of Versality (or PV) <ref> [11] </ref>. This principle is compatible with the theory of the typed partial -calculus [15] formalisable within a logic of definedness, but is inconsistent with the equational theory of the simply-typed -calculus.
Reference: [12] <author> M.H. Gordon, R.M. Milner, and C. Wadsworth. </author> <title> Edinburgh LCF, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: type D equal to D ! D, and hence equal also to (D ! D) ! (D ! D); any term that has one of these types has all the other types. * The second approach relies on an explicit iso-morphism between a recursive type and its expansions (e.g., see <ref> [12, 13] </ref>). For example, one may introduce a type D isomorphic to D ! D; the iso-morphism between these types is represented explicitly by two terms, one of type D ! (D ! D) and the other of type (D ! D) ! D.
Reference: [13] <author> Carl Gunter. </author> <title> Semantics of Programming Lan--guages: Structures and Techniques. </title> <booktitle> Foundations of Computing Series. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: type D equal to D ! D, and hence equal also to (D ! D) ! (D ! D); any term that has one of these types has all the other types. * The second approach relies on an explicit iso-morphism between a recursive type and its expansions (e.g., see <ref> [12, 13] </ref>). For example, one may introduce a type D isomorphic to D ! D; the iso-morphism between these types is represented explicitly by two terms, one of type D ! (D ! D) and the other of type (D ! D) ! D. <p> In section 5 we describe our logic of programs, and in section 6 we show some of its applications. 2 Formulations of recursive types In this section we review the main formulations of recursive types in the context of a first-order -calculus. The resulting systems are versions of FPC <ref> [13] </ref>. 2.1 Core FPC We start by briefly describing the part common to all systems; it is rather standard, so we list its rules in the appendix. A type context is a list of distinct type variables. We write O ` to indicate that O is a well-formed type context.
Reference: [14] <author> E. Moggi. </author> <title> Categories of partial morphisms and the partial lambda-calculus. </title> <booktitle> In Proceedings Workshop on Category Theory and Computer Programming, Guildford 1985, volume 240 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: For products, we have: (s; t) # oe s # ^ t # snd (e) # oe e # snd (x; y) = y VI. For exponentials, the axioms are those of the typed partial -calculus <ref> [18, 14, 15] </ref>: (x: e) # x: e [x] = y: e [y] x: f x = f x: s [x] = x: t [x] x not free in assumptions above s [x] ' t [x] Since the substitutivity axiom applies only to terms that are known to exist, the law
Reference: [15] <author> E. Moggi. </author> <title> The Partial Lambda-Calculus. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference-contexts: In FPC, one can write terms that do not normal ize. 2. Our main means for reasoning about recursion is Freyd's Principle of Versality (or PV) [11]. This principle is compatible with the theory of the typed partial -calculus <ref> [15] </ref> formalisable within a logic of definedness, but is inconsistent with the equational theory of the simply-typed -calculus. This inconsistency arises because X:X becomes a zero object (i.e., both initial and terminal), and then is isomorphic to every type. <p> For products, we have: (s; t) # oe s # ^ t # snd (e) # oe e # snd (x; y) = y VI. For exponentials, the axioms are those of the typed partial -calculus <ref> [18, 14, 15] </ref>: (x: e) # x: e [x] = y: e [y] x: f x = f x: s [x] = x: t [x] x not free in assumptions above s [x] ' t [x] Since the substitutivity axiom applies only to terms that are known to exist, the law
Reference: [16] <author> Greg Nelson, </author> <title> editor. Systems Programming in Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: We examine the formulations of recursive types as they appear in programming languages and in formal systems; there are two main approaches: * The first approach relies on a notion of type equality (e.g., see <ref> [16, 3] </ref>). A recursive type is equal to fl Research supported by EPSRC project Frameworks for Programming Language Semantics and Logic (grant RR29300) and by HCM project Typed Lambda-Calculus (grant ERBCHRXCT 92-0046). its expansions, and if a term has a type then it has all equal types. <p> FPC with iso-morphism has a somewhat simpler proof theory and semantics; it can also be argued that it is clearer. On the other hand, the notion of type equality can be appealing for programming, particularly in the presence of a subtyping relation (e.g., as in Modula-3 <ref> [16] </ref>); hence we may prefer FPC = or FPC =+ . Of these, FPC = is easier to formulate and to understand, while FPC =+ is more liberal. We know advocates of at least two variants of FPC.
Reference: [17] <author> A.M. Pitts. </author> <title> Relational properties of recursively defined domains. </title> <booktitle> In Proceedings of the Eighth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 86-97, </pages> <year> 1993. </year> <note> An expanded version will appear in Information and Computation. </note>
Reference-contexts: Much further work is possible. For example, it should be simple to extend our results to type systems with polymorphism. In a more logical direction, it may be interesting to revisit Pitts' relational approach to reasoning with recursive types, and in particular his treatment of nested recursion <ref> [17] </ref>. Acknowledgments We thank Roberto Amadio, Luca Cardelli, John Mitchell, Andy Pitts, and Gordon Plotkin for discussions on the subject of this work.
Reference: [18] <author> G.D. Plotkin. </author> <title> Denotational semantics with partial functions. </title> <booktitle> Lecture at C.S.L.I. Summer School, </booktitle> <year> 1985. </year>
Reference-contexts: Our explanation of type expressions as functors, although based on semantic ideas, is purely syntactic. It is perhaps more elementary and compelling than its semantic counterparts. We also introduce a simple logic for the first-order -calculus with recursive types. It is a logic of partial terms <ref> [4, 18] </ref>; because of partiality, we avoid the inconsistencies connected with recursive types. Alternatively, we could have reasoned in the models of the logic, possibly doing without the logic altogether. We have preferred to use the logic because of the syntactic character of our enterprise. <p> For products, we have: (s; t) # oe s # ^ t # snd (e) # oe e # snd (x; y) = y VI. For exponentials, the axioms are those of the typed partial -calculus <ref> [18, 14, 15] </ref>: (x: e) # x: e [x] = y: e [y] x: f x = f x: s [x] = x: t [x] x not free in assumptions above s [x] ' t [x] Since the substitutivity axiom applies only to terms that are known to exist, the law <p> X:F ) = id X:F PV: for f : F [A] ! X:F [X] : u, (u = f ffi F X:F;A (v; u) ffi ud) oe v = coit (g; f ) ^ u = it (g; f ) This logic is essentially an extension of that of Plotkin <ref> [18] </ref> with new axioms for recursion. Three minor differences are worth noting. First, Plotkin works with a logic of existence [7] (or a logic of partial elements [20, 9]), where free variables are thought of as ranging over a domain of possibly non-existing elements. <p> The standard model of FPC, pCpo (the category of cpos and partial continuous functions), gives rise to a model of the logic; equality and existence have their usual meanings (see <ref> [18] </ref>). 6 Applications of the logic In this section we develop several applications of our logic.
Reference: [19] <author> G.D. Plotkin. </author> <title> Type theory and recursion (extended abstract). </title> <booktitle> In Proceedings of the Eighth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> page 374, </pages> <year> 1993. </year>
Reference-contexts: Our work is complementary to theirs; roughly, their coercion interpretation reduces a calculus with subtyping to one with type equality, and our coercion interpretation reduces one with type equality to one with iso-morphism. Another relevant syntactic investigation is that of Plotkin <ref> [19] </ref>, who developed a second-order intu-itionistic linear type theory with a fixed-point operator at the level of terms, showed how to encode recursive types, and derived some reasoning principles for them.
Reference: [20] <author> D.S. Scott. </author> <title> Identity and existence in intuitionistic logic. In M.P. </title> <editor> Fourman, C.J. Mulvey, and D.S. Scott, editors, </editor> <booktitle> Applications of Sheaves, volume 753 of Lecture Notes in Mathematics. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Three minor differences are worth noting. First, Plotkin works with a logic of existence [7] (or a logic of partial elements <ref> [20, 9] </ref>), where free variables are thought of as ranging over a domain of possibly non-existing elements. Second, he axiomatises approximation (v, &lt; ) rather than equality.
Reference: [21] <author> M.B. Smyth and G.D. Plotkin. </author> <title> The category-theoretic solution of recursive domain equations. </title> <journal> SIAM Journal of Computing, </journal> <volume> 11(4) </volume> <pages> 761-783, </pages> <year> 1982. </year>
Reference-contexts: In semantics, it is by now common to view functions on types as functors; the substantial difficulties that arise for con-travariant types can be surmounted with a variety of techniques (categories of embeddings, involutory categories, etc.) <ref> [21, 10, 11] </ref>. Our explanation of type expressions as functors, although based on semantic ideas, is purely syntactic. It is perhaps more elementary and compelling than its semantic counterparts. We also introduce a simple logic for the first-order -calculus with recursive types. <p> A solution is to take the category of types to be involutory (i.e., isomorphic to its dual via an involution) [8]. Given a category C there are various approaches to constructing an involutory category I (C). In the context of order-enriched categories one can exploit the duality embedding/projection <ref> [21] </ref>. There are also canonical choices, namely C = C op fi C [11] or its subcategory C D [1, 10] consisting of all those objects on the diagonal.
Reference: [22] <author> P. Urzyczyn. </author> <title> Positive recursive type assignment. </title> <booktitle> In Mathematical Foundations of Computer Science, volume 969 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: While it would be interesting to build on Plotkin's theory, we have preferred to avoid type quantification and linear types. Finally, Urzyczyn has studied typability in several systems with covariant recursive types <ref> [22] </ref>; some of our results are similar to his. The next section is mostly a review of the formulations of recursive types; we compare them formally in sections 4 and 6.5. In section 3, we define the func-torial interpretation of type expressions.
References-found: 22

