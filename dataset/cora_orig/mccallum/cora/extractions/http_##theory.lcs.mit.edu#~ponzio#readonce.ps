URL: http://theory.lcs.mit.edu/~ponzio/readonce.ps
Refering-URL: http://theory.lcs.mit.edu/~ponzio/readonce.html
Root-URL: 
Title: A lower bound for integer multiplication with read-once branching programs  
Author: Stephen Ponzio 
Date: August 8, 1995  
Affiliation: MIT Laboratory for Computer Science  
Abstract: Recent developments in the field of digital design and hardware verification have found great use for restricted forms of branching programs. In particular, oblivious read-once branching programs (also called "OBDD's") are central to a very common technique for verifying circuits. These programs are useful because they are easily manipulated and compared for equivalence. However, their practical utility is limited because they cannot compute in polynomial size several simple functions|most notably, integer multiplication. This limitation has prompted the consideration of alternative models, usually restricted classes of branching programs, in the hope of finding one with greater computational power but also easily manipulated and tested for equivalence. Read-once (non-oblivious) branching programs can to some degree be manipulated and tested for equivalence, but it has been an open question whether they can compute integer multiplication in polynomial size. This paper proves that they cannot| multiplication requires size 2 ( p n) . This is the first lower bound for multiplication on non-oblivious branching programs. By defining the appropriate kind of problem reduction, which we call read-once reductions, we are able to show that our result implies the same asymptotic lower bound for other arithmetic functions. 
Abstract-found: 1
Intro-found: 1
Reference: [AM88] <author> N. Alon and W. Maass. </author> <title> Meanders and their applications in lower bounds arguments. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 37, </volume> <year> 1988, </year> <pages> pp. 118-129. </pages>
Reference-contexts: In <ref> [AM88] </ref>, lower bounds are proved for any oblivious programs of linear length, regardless of the order in which variables are read. Recently proposed alternative models include "graph-driven BDD's" [SW95] and "binary moment diagrams" [BC94]. <p> From the proof of Bryant's lower bound for OBDD's [Br91], it follows by a simple communication complexity argument that MULT cannot be computed in polynomial-size by k-OBDD's [Kr91, BSSW93] or the various non-deterministic OBDD's [Ge94]. Incorporating results from <ref> [AM88] </ref>, a similar lower bound is shown for arbitrary linear-length oblivious programs [Ge94]. Indeed, all of these oblivious models have proven too weak to compute MULT in polynomial size.
Reference: [AGD91] <author> P. Ashar, A. Ghosh, and S. Devadas. </author> <title> Boolean satisfiability and equivalence checking using general binary decision diagrams. </title> <booktitle> Proc. Int'l. Conference on Computer Design, </booktitle> <year> 1991, </year> <pages> pp. 259-264. </pages>
Reference: [BHST87] <author> L. Babai, A. Hajnal, E. Szemeredi, and G. Turan. </author> <title> A lower bound for read-once branching programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> No. 37 (1988), </volume> <pages> pp. 153-162. </pages>
Reference-contexts: 1 Introduction and background It is well known that many functions, some of them very simple, cannot be computed by read-once branching programs of polynomial size <ref> [We88, Za84, Du85, We87, BHST87, Ju88, Kr88] </ref>. Interest in whether integer multiplication can be so computed has been created by recent developments in the field of digital design and hardware verification. The central problem of verification is to check whether a combinational hardware circuit has been correctly designed. <p> was proved in [Za84] (see also [We87]) that determines whether a graph on n nodes is an n=2-clique (with no further edges) requires size 2 (n) . (For comparison, there is a simple read-twice program of size O (n 3 ).) The only asymptotically optimal lower bound is due to <ref> [BHST87] </ref>, which proves a bound of 2 (n 2 ) for computing the parity of the number of triangles in a graph on n nodes. Exponential lower bounds for explicit functions have also been proved for nondeterministic read-once branching programs [Ju89, KMW91, BRS93]. <p> It is curious that many of the lower bounds for read-once programs achieve only 2 ( p n) if n is the number of input bits|only the lower bound of <ref> [BHST87] </ref> achieves a fully exponential lower bound of 2 (n) . This limitation is most likely an artifact of the proofs, but it is not well understood.
Reference: [BCW80] <author> M. Blum, A. Chandra, and M. Wegman. </author> <title> Equivalence of free boolean graphs can be decided probabilistically in polynomial time. </title> <journal> Information Processing Letters, </journal> <volume> Vol. 10, No. 2, </volume> <month> March </month> <year> 1980, </year> <pages> pp. 80-82. </pages>
Reference-contexts: Also, testing equivalence is reasonably tractable: although it is not known how to do so in deterministic polynomial time, there is a randomized polynomial-time algorithm with one-sided error due to Blum, Chandra, and Wegman <ref> [BCW80] </ref>. (There is also a deterministic algorithm to test the equivalence of an OBDD and a read-once program [FHS78].) The synthesis operations, however, are provably not tractable: there exist functions f and g that each have polynomial-size read-once programs but whose conjunction f ^ g requires exponential-size read-once programs. 5 For
Reference: [BSSW93] <author> B. Bollig, M. Sauerhoff, D. Sieling, and I. Wegener. </author> <title> Read-k-times ordered binary decision diagrams|efficient algorithms in the presence of null chains. </title> <type> Technical Report 474, </type> <institution> Univ. Dortmund, </institution> <year> 1993. </year>
Reference-contexts: For example, the various extensions to OBDD's that have been considered include 4 * "k-OBDD's", where each path reads the variables in the same order k times consecu- tively <ref> [BSSW93, BHR95, Kr91] </ref>; * "k-IBDD's", which are the same as k-OBDD's except that the k variable orderings may be different [JABFA92, BSSW95]; * OBDD's with various kinds of non-deterministic branching nodes (_-nodes, ^-nodes, -nodes) [Me89, SDG94, Ge94, and others]. <p> The latter are not branching programs, and do not compute a function, but they do allow polynomial-size representation of multiplication. From the proof of Bryant's lower bound for OBDD's [Br91], it follows by a simple communication complexity argument that MULT cannot be computed in polynomial-size by k-OBDD's <ref> [Kr91, BSSW93] </ref> or the various non-deterministic OBDD's [Ge94]. Incorporating results from [AM88], a similar lower bound is shown for arbitrary linear-length oblivious programs [Ge94]. Indeed, all of these oblivious models have proven too weak to compute MULT in polynomial size.
Reference: [BSSW95] <author> B. Bollig, M. Sauerhoff, D. Sieling, and I. Wegener. </author> <title> On the power of different types of restricted branching programs. </title> <note> Submitted to Theoretical Computer Science. Also published in the Electronic Colloquium on Computational Complexity, Report No. TR94-026 (1994), available via http://www.eccc.uni-trier.de/eccc/. </note>
Reference-contexts: For example, the various extensions to OBDD's that have been considered include 4 * "k-OBDD's", where each path reads the variables in the same order k times consecu- tively [BSSW93, BHR95, Kr91]; * "k-IBDD's", which are the same as k-OBDD's except that the k variable orderings may be different <ref> [JABFA92, BSSW95] </ref>; * OBDD's with various kinds of non-deterministic branching nodes (_-nodes, ^-nodes, -nodes) [Me89, SDG94, Ge94, and others]. In [AM88], lower bounds are proved for any oblivious programs of linear length, regardless of the order in which variables are read.
Reference: [BRS93] <author> A. Borodin, A. Razborov, and R. Smolensky. </author> <title> On lower bounds for read-k-times branching programs. Computational Complexity 3, </title> <booktitle> 1993, </booktitle> <pages> pp. 1-18. 26 </pages>
Reference-contexts: Exponential lower bounds for explicit functions have also been proved for nondeterministic read-once branching programs <ref> [Ju89, KMW91, BRS93] </ref>. <p> Exponential lower bounds for explicit functions have also been proved for nondeterministic read-once branching programs [Ju89, KMW91, BRS93]. Lower bounds for read-k-times programs (where each variable appears at most k times on each path) are proved in <ref> [Ok91, BRS93, Ju92] </ref>. 1.4 The decision problem DMULT|the graph of multiplication Although it is not directly related to the issue of verification, another Boolean function that has been considered is the decision problem DMULT of recognizing the graph of multiplication. <p> Since we can test the satisfiability of a read-once program in polynomial time, the entire procedure can be executed in polynomial time. Jukna [Ju94] proves a lower bound of 2 n 1=4 =k 2k for DMULT on non-deterministic read-k-times branching programs. His lower bound follows the framework of <ref> [BRS93] </ref>, and gives a simple reduction of DMULT to the problem of recognizing codewords of a linear code, for which a lower bound of 2 p is proved in [Ju92]. 1.5 Our results In this paper, we prove that MULT requires read-once branching programs of size 2 ( p This is <p> This limitation is most likely an artifact of the proofs, but it is not well understood. In addition to improving the bound, it may also be possible to extend the argument using the framework of <ref> [BRS93] </ref> to show that a similar bound holds for nondeterministic read-once programs or for read-k-times programs. <p> We believe that higher dimensional versions of this latter problem should separate 25 the read-k-times hierarchy. A possible strategy along these lines, using the framework of <ref> [BRS93] </ref>, is given in [P95] for separating read-3-times programs from read-2-times programs. Acknowledgments Thanks to Mikael Goldmann for pointing out the reductions in [We93], to Mauricio Karchmer and Ravi Sundaram for discussions, and to Allan Borodin for bringing this problem to my attention.
Reference: [BHR95] <author> Y. Breitbart, H. B. Hunt III and D. Rosenkrantz. </author> <title> On the size of binary decision diagrams representing Boolean functions. </title> <booktitle> Theoretical Computer Science, 145 (1995), </booktitle> <pages> pp. 45-69. </pages>
Reference-contexts: For example, the various extensions to OBDD's that have been considered include 4 * "k-OBDD's", where each path reads the variables in the same order k times consecu- tively <ref> [BSSW93, BHR95, Kr91] </ref>; * "k-IBDD's", which are the same as k-OBDD's except that the k variable orderings may be different [JABFA92, BSSW95]; * OBDD's with various kinds of non-deterministic branching nodes (_-nodes, ^-nodes, -nodes) [Me89, SDG94, Ge94, and others].
Reference: [BF85] <author> F. Brglez and H. Fujiwara. </author> <title> A neutral netlist of 10 combinational circuits. </title> <booktitle> Proc. 1985 IEEE Int'l. Symposium on Circuits and Systems. </booktitle>
Reference: [Br91] <author> R. Bryant. </author> <title> On the complexity of VLSI implementations and graph representations of boolean functions with applications to integer multiplication. </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 40, No. 2, </volume> <month> February </month> <year> 1991. </year> <pages> pp. 205-213. </pages>
Reference-contexts: The answer is yes, for the most part|OBDD's can compute in polynomial size such functions as integer addition, symmetric Boolean functions, and many of the benchmark functions used by the verification community [BF85]|but with a very important exception: exponential size is required to compute integer multiplication <ref> [Br91] </ref>. This is an serious setback to the viability of OBDD's, since the hardware to be tested typically contains circuits that perform multiplication. <p> Recently proposed alternative models include "graph-driven BDD's" [SW95] and "binary moment diagrams" [BC94]. The latter are not branching programs, and do not compute a function, but they do allow polynomial-size representation of multiplication. From the proof of Bryant's lower bound for OBDD's <ref> [Br91] </ref>, it follows by a simple communication complexity argument that MULT cannot be computed in polynomial-size by k-OBDD's [Kr91, BSSW93] or the various non-deterministic OBDD's [Ge94]. Incorporating results from [AM88], a similar lower bound is shown for arbitrary linear-length oblivious programs [Ge94].
Reference: [Br92] <author> R. Bryant. </author> <title> Symbolic boolean manipulation with ordered binary decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 24, No. 3, </volume> <month> September </month> <year> 1992. </year> <pages> pp. 293-318. </pages>
Reference-contexts: The use of restricted branching programs as the intermediate representation has made this approach feasible and very popular|several software packages are available for implementing this very strategy <ref> [Kr94, Br92] </ref>. Definition 1 A branching program is a directed acyclic graph with a distinguished root node and two sink nodes.
Reference: [BC94] <author> R. Bryant and Y. Chen. </author> <title> Verification of arithmetic functions with binary moment diagrams. </title> <type> Technical Report CMU-CS-94-160, </type> <institution> Carnegie Mellon University, </institution> <month> May 31, </month> <year> 1994. </year>
Reference-contexts: In [AM88], lower bounds are proved for any oblivious programs of linear length, regardless of the order in which variables are read. Recently proposed alternative models include "graph-driven BDD's" [SW95] and "binary moment diagrams" <ref> [BC94] </ref>. The latter are not branching programs, and do not compute a function, but they do allow polynomial-size representation of multiplication.
Reference: [Bu92] <author> S. Buss. </author> <title> The graph of multiplication is equivalent to counting. </title> <journal> Information Processing Letters, </journal> <month> 41 (18 March </month> <year> 1992), </year> <pages> pp. 199-201. </pages>
Reference-contexts: Note that it is not readily apparent which problem is "harder", MULT or DMULT. On the one hand, DMULT seems to require practically computing all the bits of xy; however, an algorithm for DMULT has the advantage of inspecting all the bits of z, the putative product. Buss <ref> [Bu92] </ref> proves that DMULT 62 AC 0 by reducing it to counting the number of 1's in the input (and therefore to MULT and to PARITY by results of [CSV84]); for comparison, [FSS84] gives an easy reduction of MULT to PARITY to show MULT 62 AC 0 .
Reference: [CSV84] <author> A. Chandra, L. Stockmeyer, and U. Vishkin. </author> <title> Constant depth reducibility. </title> <journal> SIAM Journal of Computing, </journal> <volume> 13 (1984), </volume> <pages> pp. 423-439. </pages>
Reference-contexts: Buss [Bu92] proves that DMULT 62 AC 0 by reducing it to counting the number of 1's in the input (and therefore to MULT and to PARITY by results of <ref> [CSV84] </ref>); for comparison, [FSS84] gives an easy reduction of MULT to PARITY to show MULT 62 AC 0 . A simple argument [We94] shows that computing DMULT with read-once programs is as hard as factoring. <p> In order to preserve read-once complexity, we will consider a very restrictive type of problem reduction. We begin with the notion of projection reductions [SV81], as defined in <ref> [CSV84] </ref>: Definition 6 A function f = ff n g n2N is projection reducible to a function g = fg n g n2N , written f proj g, if there is a mapping : fy 1 ; : : : ; y p (n) g ! f0; 1; x 1 ; <p> These reductions were used by Chandra, Stockmeyer, and Vishkin <ref> [CSV84] </ref> in their study of constant-depth reducibility| clearly, given that f proj g, if g 2 AC 0 then f 2 AC 0 . We would like a reduction 0 that allows us to deduce that if f 0 g and g 2 READ-1 then f 2 READ-1.
Reference: [Du85] <author> P. E. Dunne. </author> <title> Lower bounds on the complexity of 1-time only branching programs. </title> <booktitle> Proceedings of the FCT, </booktitle> <publisher> Springer-Verlag LNCS No. </publisher> <month> 199 </month> <year> (1985), </year> <pages> pp. 90-99. </pages>
Reference-contexts: 1 Introduction and background It is well known that many functions, some of them very simple, cannot be computed by read-once branching programs of polynomial size <ref> [We88, Za84, Du85, We87, BHST87, Ju88, Kr88] </ref>. Interest in whether integer multiplication can be so computed has been created by recent developments in the field of digital design and hardware verification. The central problem of verification is to check whether a combinational hardware circuit has been correctly designed. <p> Until now, however, very little was known about the complexity of multiplication with any non-oblivious programs. there has been great success in proving lower bounds on the size of read-once programs, even for some very simple functions <ref> [Ma76, Du85, Za84, We87, SS93] </ref>.
Reference: [FHS78] <author> S. Fortune, J. Hopcroft, and E. M. Schmidt. </author> <title> The complexity of equivalence and containment for free single variable program schemes. </title> <publisher> Springer-Verlag LNCS No. </publisher> <address> 62, </address> <year> 1978, </year> <pages> pp. 227-240. </pages>
Reference-contexts: equivalence is reasonably tractable: although it is not known how to do so in deterministic polynomial time, there is a randomized polynomial-time algorithm with one-sided error due to Blum, Chandra, and Wegman [BCW80]. (There is also a deterministic algorithm to test the equivalence of an OBDD and a read-once program <ref> [FHS78] </ref>.) The synthesis operations, however, are provably not tractable: there exist functions f and g that each have polynomial-size read-once programs but whose conjunction f ^ g requires exponential-size read-once programs. 5 For example, determining whether a 0; 1-matrix is a permutation matrix requires exponen-tial-size read-once programs [Kr91, KMW91] whereas the
Reference: [FSS84] <author> M. Furst, J. B. Saxe, and M. Sipser. </author> <title> Parity, circuits, and the polynomial-time hierarchy. </title> <journal> Mathematical Systems Theory, </journal> <volume> 17 (1984), </volume> <pages> pp. 13-27. </pages>
Reference-contexts: Buss [Bu92] proves that DMULT 62 AC 0 by reducing it to counting the number of 1's in the input (and therefore to MULT and to PARITY by results of [CSV84]); for comparison, <ref> [FSS84] </ref> gives an easy reduction of MULT to PARITY to show MULT 62 AC 0 . A simple argument [We94] shows that computing DMULT with read-once programs is as hard as factoring. <p> It was originally proved in [HMPST93] that INNER-PRODUCT-MODULO-2 cannot be computed in polynomial-size by threshold circuits of depth 2. It was also noted there that the projection reduction to multiplication (first given in <ref> [FSS84] </ref>, from PARITY to MULT) shows that MULT obeys the same lower bound. Wegener [We93] gives projection reductions from MULT to squaring and inversion in order to show that these functions also require depth 3 polynomial-size threshold circuits.
Reference: [Ge94] <author> J. Gergov. </author> <title> Time-space tradeoffs for integer multiplication on various types of input-oblivious sequential machines. </title> <journal> Information Processing Letters, </journal> <volume> 51 (1994), </volume> <pages> pp. 265-269. </pages>
Reference-contexts: * "k-OBDD's", where each path reads the variables in the same order k times consecu- tively [BSSW93, BHR95, Kr91]; * "k-IBDD's", which are the same as k-OBDD's except that the k variable orderings may be different [JABFA92, BSSW95]; * OBDD's with various kinds of non-deterministic branching nodes (_-nodes, ^-nodes, -nodes) <ref> [Me89, SDG94, Ge94, and others] </ref>. In [AM88], lower bounds are proved for any oblivious programs of linear length, regardless of the order in which variables are read. Recently proposed alternative models include "graph-driven BDD's" [SW95] and "binary moment diagrams" [BC94]. <p> From the proof of Bryant's lower bound for OBDD's [Br91], it follows by a simple communication complexity argument that MULT cannot be computed in polynomial-size by k-OBDD's [Kr91, BSSW93] or the various non-deterministic OBDD's <ref> [Ge94] </ref>. Incorporating results from [AM88], a similar lower bound is shown for arbitrary linear-length oblivious programs [Ge94]. Indeed, all of these oblivious models have proven too weak to compute MULT in polynomial size. <p> From the proof of Bryant's lower bound for OBDD's [Br91], it follows by a simple communication complexity argument that MULT cannot be computed in polynomial-size by k-OBDD's [Kr91, BSSW93] or the various non-deterministic OBDD's <ref> [Ge94] </ref>. Incorporating results from [AM88], a similar lower bound is shown for arbitrary linear-length oblivious programs [Ge94]. Indeed, all of these oblivious models have proven too weak to compute MULT in polynomial size. It is therefore natural to consider non-oblivious programs, the simplest of these being read-once programs. 1.3 Non-oblivious programs Unfortunately, (non-oblivious) read-once programs do not enjoy quite the same degree of manipulability as OBDD's.
Reference: [GM94] <author> J. Gergov and C. Meinel. </author> <title> Efficient boolean manipulations with OBDD's can be extended to FBDD's. </title> <journal> IEEE Transactions on Computers, </journal> <month> 43 (10) (October </month> <year> 1994), </year> <pages> pp. 1197-1209. </pages>
Reference-contexts: Despite their relative recalcitrance, read-once programs have been considered by some researchers for possible use in hardware verification <ref> [GM94] </ref>. Until now, however, very little was known about the complexity of multiplication with any non-oblivious programs. there has been great success in proving lower bounds on the size of read-once programs, even for some very simple functions [Ma76, Du85, Za84, We87, SS93].
Reference: [HMPST93] <author> A. Hajnal, W. Maass, P. Pudlak, M. Szegedy, and G. Turan. </author> <title> Threshold circuits of bounded depth. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 46(2) 1993, </volume> <pages> pp. 129-154. </pages>
Reference-contexts: It was originally proved in <ref> [HMPST93] </ref> that INNER-PRODUCT-MODULO-2 cannot be computed in polynomial-size by threshold circuits of depth 2. It was also noted there that the projection reduction to multiplication (first given in [FSS84], from PARITY to MULT) shows that MULT obeys the same lower bound.
Reference: [JABFA92] <author> J. Jain, M. Abadir, J. Bitner, D. Fussell, and J. Abraham. IBDD's: </author> <title> An efficient functional representation for digital circuits. </title> <booktitle> European Design Automation Conference (1992), </booktitle> <pages> pp. 440-446. </pages>
Reference-contexts: For example, the various extensions to OBDD's that have been considered include 4 * "k-OBDD's", where each path reads the variables in the same order k times consecu- tively [BSSW93, BHR95, Kr91]; * "k-IBDD's", which are the same as k-OBDD's except that the k variable orderings may be different <ref> [JABFA92, BSSW95] </ref>; * OBDD's with various kinds of non-deterministic branching nodes (_-nodes, ^-nodes, -nodes) [Me89, SDG94, Ge94, and others]. In [AM88], lower bounds are proved for any oblivious programs of linear length, regardless of the order in which variables are read.
Reference: [Ju88] <author> S. Jukna. </author> <title> Entropy of contact circuits and lower bounds on their complexity. </title> <booktitle> Theoretical Computer Science, 47:2 (1988), </booktitle> <pages> pp. 113-129. </pages>
Reference-contexts: 1 Introduction and background It is well known that many functions, some of them very simple, cannot be computed by read-once branching programs of polynomial size <ref> [We88, Za84, Du85, We87, BHST87, Ju88, Kr88] </ref>. Interest in whether integer multiplication can be so computed has been created by recent developments in the field of digital design and hardware verification. The central problem of verification is to check whether a combinational hardware circuit has been correctly designed.
Reference: [Ju89] <author> S. Jukna. </author> <title> The effect of null-chains on the complexity of contact schemes. </title> <booktitle> Proceedings of the FCT (1989), </booktitle> <publisher> Springer-Verlag LNCS No. </publisher> <pages> 380, pp. 246-256. </pages>
Reference-contexts: Exponential lower bounds for explicit functions have also been proved for nondeterministic read-once branching programs <ref> [Ju89, KMW91, BRS93] </ref>.
Reference: [Ju92] <author> S. Jukna. </author> <title> A note on read-k-times branching programs. </title> <type> Technical report 448, </type> <institution> Universitat Dortmund, </institution> <year> 1992. </year> <note> RAIRO Theoretical Computer Science, to appear. Also published in the Electronic Colloquium on Computational Complexity, Report No. TR94-027 (1994), available via http://www.eccc.uni-trier.de/eccc/. </note>
Reference-contexts: Exponential lower bounds for explicit functions have also been proved for nondeterministic read-once branching programs [Ju89, KMW91, BRS93]. Lower bounds for read-k-times programs (where each variable appears at most k times on each path) are proved in <ref> [Ok91, BRS93, Ju92] </ref>. 1.4 The decision problem DMULT|the graph of multiplication Although it is not directly related to the issue of verification, another Boolean function that has been considered is the decision problem DMULT of recognizing the graph of multiplication. <p> His lower bound follows the framework of [BRS93], and gives a simple reduction of DMULT to the problem of recognizing codewords of a linear code, for which a lower bound of 2 p is proved in <ref> [Ju92] </ref>. 1.5 Our results In this paper, we prove that MULT requires read-once branching programs of size 2 ( p This is the first superpolynomial lower bound for multiplication on non-oblivious branching programs.
Reference: [Ju94] <author> S. Jukna. </author> <title> The graph of multiplication is hard for read-k-times networks. </title> <type> Manuscript, </type> <month> April </month> <year> 1994. </year>
Reference-contexts: If the only successful instantiations for x are 1 and z, then z is prime; otherwise, a nontrivial factor is determined. Since we can test the satisfiability of a read-once program in polynomial time, the entire procedure can be executed in polynomial time. Jukna <ref> [Ju94] </ref> proves a lower bound of 2 n 1=4 =k 2k for DMULT on non-deterministic read-k-times branching programs.
Reference: [Kr88] <author> M. Krause. </author> <title> Exponential lower bounds on the complexity of real time and local branching programs. </title> <journal> Journal of Information Processing and Cybernetics (EIK), </journal> <month> 24:3 </month> <year> (1988), </year> <pages> pp. 99-110. </pages>
Reference-contexts: 1 Introduction and background It is well known that many functions, some of them very simple, cannot be computed by read-once branching programs of polynomial size <ref> [We88, Za84, Du85, We87, BHST87, Ju88, Kr88] </ref>. Interest in whether integer multiplication can be so computed has been created by recent developments in the field of digital design and hardware verification. The central problem of verification is to check whether a combinational hardware circuit has been correctly designed.
Reference: [Kr91] <author> M. Krause. </author> <title> Lower bounds for depth-restricted branching programs. </title> <journal> Information and Computation, </journal> <volume> Vol. 91, </volume> <year> 1991. </year> <pages> pp. 1-14. </pages>
Reference-contexts: For example, the various extensions to OBDD's that have been considered include 4 * "k-OBDD's", where each path reads the variables in the same order k times consecu- tively <ref> [BSSW93, BHR95, Kr91] </ref>; * "k-IBDD's", which are the same as k-OBDD's except that the k variable orderings may be different [JABFA92, BSSW95]; * OBDD's with various kinds of non-deterministic branching nodes (_-nodes, ^-nodes, -nodes) [Me89, SDG94, Ge94, and others]. <p> The latter are not branching programs, and do not compute a function, but they do allow polynomial-size representation of multiplication. From the proof of Bryant's lower bound for OBDD's [Br91], it follows by a simple communication complexity argument that MULT cannot be computed in polynomial-size by k-OBDD's <ref> [Kr91, BSSW93] </ref> or the various non-deterministic OBDD's [Ge94]. Incorporating results from [AM88], a similar lower bound is shown for arbitrary linear-length oblivious programs [Ge94]. Indeed, all of these oblivious models have proven too weak to compute MULT in polynomial size. <p> a read-once program [FHS78].) The synthesis operations, however, are provably not tractable: there exist functions f and g that each have polynomial-size read-once programs but whose conjunction f ^ g requires exponential-size read-once programs. 5 For example, determining whether a 0; 1-matrix is a permutation matrix requires exponen-tial-size read-once programs <ref> [Kr91, KMW91] </ref> whereas the (necessary and together sufficient) row-wise and column-wise criteria (that each have one 1) are each computable with small OBDD's. Despite their relative recalcitrance, read-once programs have been considered by some researchers for possible use in hardware verification [GM94].
Reference: [KMW91] <author> M. Krause, C. Meinel, and S. Waack. </author> <title> Separating the eraser Turing machine classes L e , N L e , co-NL e , and P e . Theoretical Computer Science, </title> <booktitle> 86 (1991), </booktitle> <pages> pp. 267-275. </pages>
Reference-contexts: a read-once program [FHS78].) The synthesis operations, however, are provably not tractable: there exist functions f and g that each have polynomial-size read-once programs but whose conjunction f ^ g requires exponential-size read-once programs. 5 For example, determining whether a 0; 1-matrix is a permutation matrix requires exponen-tial-size read-once programs <ref> [Kr91, KMW91] </ref> whereas the (necessary and together sufficient) row-wise and column-wise criteria (that each have one 1) are each computable with small OBDD's. Despite their relative recalcitrance, read-once programs have been considered by some researchers for possible use in hardware verification [GM94]. <p> Exponential lower bounds for explicit functions have also been proved for nondeterministic read-once branching programs <ref> [Ju89, KMW91, BRS93] </ref>.
Reference: [KW91] <author> M. Krause and S. Waack. </author> <title> On oblivious branching programs of linear length. </title> <booktitle> Information and Computation, 94:2 (1991), </booktitle> <pages> pp. 232-249. </pages>
Reference: [Kr94] <author> S. Krischer. </author> <note> FANCY|new version (1.1). Theorynet-A announcement from krischer@ ti.uni-trier.de, </note> <editor> U. </editor> <address> Trier, Germany, Nov. 17, </address> <year> 1994. </year>
Reference-contexts: The use of restricted branching programs as the intermediate representation has made this approach feasible and very popular|several software packages are available for implementing this very strategy <ref> [Kr94, Br92] </ref>. Definition 1 A branching program is a directed acyclic graph with a distinguished root node and two sink nodes.
Reference: [Ma76] <author> W. Masek. </author> <title> A Fast Algorithm for the String-Editing Problem and Decision Graph Complexity. </title> <type> SM Thesis, </type> <institution> MIT, </institution> <year> 1976. </year>
Reference-contexts: Until now, however, very little was known about the complexity of multiplication with any non-oblivious programs. there has been great success in proving lower bounds on the size of read-once programs, even for some very simple functions <ref> [Ma76, Du85, Za84, We87, SS93] </ref>.
Reference: [Me89] <author> C. Meinel. </author> <title> Modified Branching Programs and Their Computational Power. </title> <publisher> Springer-Ver-lag LNCS No. </publisher> <address> 370, </address> <year> 1989. </year>
Reference-contexts: * "k-OBDD's", where each path reads the variables in the same order k times consecu- tively [BSSW93, BHR95, Kr91]; * "k-IBDD's", which are the same as k-OBDD's except that the k variable orderings may be different [JABFA92, BSSW95]; * OBDD's with various kinds of non-deterministic branching nodes (_-nodes, ^-nodes, -nodes) <ref> [Me89, SDG94, Ge94, and others] </ref>. In [AM88], lower bounds are proved for any oblivious programs of linear length, regardless of the order in which variables are read. Recently proposed alternative models include "graph-driven BDD's" [SW95] and "binary moment diagrams" [BC94].
Reference: [Ne66] <author> E. I. Neciporuk. </author> <title> A boolean function. </title> <journal> Soviet Mathematis Doklady, </journal> <month> 7:4 </month> <year> (1966), </year> <pages> pp. 999-1000. </pages>
Reference: [Ok91] <author> E. A. Okolnishnikova. </author> <title> Lower bounds for branching programs computing characteristic functions of binary codes. </title> <journal> Metody discretnogo analiza, </journal> <volume> 51 (1991), </volume> <pages> pp. 61-83. </pages> <note> In Russian. </note>
Reference-contexts: Exponential lower bounds for explicit functions have also been proved for nondeterministic read-once branching programs [Ju89, KMW91, BRS93]. Lower bounds for read-k-times programs (where each variable appears at most k times on each path) are proved in <ref> [Ok91, BRS93, Ju92] </ref>. 1.4 The decision problem DMULT|the graph of multiplication Although it is not directly related to the issue of verification, another Boolean function that has been considered is the decision problem DMULT of recognizing the graph of multiplication.
Reference: [P95] <author> S. Ponzio. </author> <title> Restricted branching programs and hardware verification. </title> <type> Ph.D. thesis, </type> <institution> Mas-sachusetts Institute of Technology, </institution> <month> August </month> <year> 1995. </year> <note> Available as LCS Technical Report MIT/LCS/TR-663, </note> <month> September </month> <year> 1995. </year> <month> 28 </month>
Reference-contexts: We believe that higher dimensional versions of this latter problem should separate 25 the read-k-times hierarchy. A possible strategy along these lines, using the framework of [BRS93], is given in <ref> [P95] </ref> for separating read-3-times programs from read-2-times programs. Acknowledgments Thanks to Mikael Goldmann for pointing out the reductions in [We93], to Mauricio Karchmer and Ravi Sundaram for discussions, and to Allan Borodin for bringing this problem to my attention.
Reference: [SDG94] <author> A. Shen, S. Devadas, and A. Ghosh. </author> <title> Probabilistic manipulation of boolean functions using free boolean diagrams. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> Volume 14, Number 1 (January 1995), </volume> <pages> pp. 87-95. </pages>
Reference-contexts: size s (n), then any other bit can be computed with size at most s (2n). 1.2 Other oblivious models: extensions to OBDD's Thus, despite the success of this approach, there has also been great effort expended to find another model that is likewise manipulated, but with greater computational power <ref> [SDG94, SW95, e.g.] </ref>. <p> * "k-OBDD's", where each path reads the variables in the same order k times consecu- tively [BSSW93, BHR95, Kr91]; * "k-IBDD's", which are the same as k-OBDD's except that the k variable orderings may be different [JABFA92, BSSW95]; * OBDD's with various kinds of non-deterministic branching nodes (_-nodes, ^-nodes, -nodes) <ref> [Me89, SDG94, Ge94, and others] </ref>. In [AM88], lower bounds are proved for any oblivious programs of linear length, regardless of the order in which variables are read. Recently proposed alternative models include "graph-driven BDD's" [SW95] and "binary moment diagrams" [BC94].
Reference: [SW95] <author> D. Sieling and I. Wegener. </author> <title> Graph driven BDD's|a new data structure for boolean functions. </title> <booktitle> Theoretical Computer Science 141 (1995), </booktitle> <pages> pp. 283-310. </pages>
Reference-contexts: size s (n), then any other bit can be computed with size at most s (2n). 1.2 Other oblivious models: extensions to OBDD's Thus, despite the success of this approach, there has also been great effort expended to find another model that is likewise manipulated, but with greater computational power <ref> [SDG94, SW95, e.g.] </ref>. <p> In [AM88], lower bounds are proved for any oblivious programs of linear length, regardless of the order in which variables are read. Recently proposed alternative models include "graph-driven BDD's" <ref> [SW95] </ref> and "binary moment diagrams" [BC94]. The latter are not branching programs, and do not compute a function, but they do allow polynomial-size representation of multiplication.
Reference: [SS93] <author> J. Simon and M. Szegedy. </author> <title> A new lower bound theorem for read-only-once branching programs and its applications. Advances in Computational Complexity Theory (J. Cai, editor), </title> <journal> DIMACS Series, </journal> <volume> Vol. 13, </volume> <pages> AMS (1993) pp. 183-193. </pages>
Reference-contexts: Until now, however, very little was known about the complexity of multiplication with any non-oblivious programs. there has been great success in proving lower bounds on the size of read-once programs, even for some very simple functions <ref> [Ma76, Du85, Za84, We87, SS93] </ref>. <p> By setting the values of B = X n B, we naturally induce a function on B. The lemma is stated below in the form we will need it; it appears in <ref> [SS93] </ref> in slightly more generalized form. Lemma 1 (Simon and Szegedy) If for any B in the boundary of F , at most 2 jBj =L settings to B induce the same subfunction on B, then any read-once branching program computing f has size at least L. <p> intractability of the synthesis operations, which make read-once programs less attractive as an alternative to OBDD's in hardware verification. (2) Is the read-k-times hierarchy strict? That is, for some k &gt; 2, is there a function computable by polynomial-size read-k-times programs but not computable by polynomial-size read-(k 1)-times programs? In <ref> [SS93] </ref>, it is conjectured that such a function is the problem of determining whether a k-dimensional hypergraph on n nodes is r-regular for, say, r = n=2. (In [SS93], it is proved that this problem on ordinary graphs (k = 2), while easily computed by read-2-times programs, requires read-once programs of <p> some k &gt; 2, is there a function computable by polynomial-size read-k-times programs but not computable by polynomial-size read-(k 1)-times programs? In <ref> [SS93] </ref>, it is conjectured that such a function is the problem of determining whether a k-dimensional hypergraph on n nodes is r-regular for, say, r = n=2. (In [SS93], it is proved that this problem on ordinary graphs (k = 2), while easily computed by read-2-times programs, requires read-once programs of size 2 (n) .) Note that the problem of determining whether an n fi n (0; 1)-matrix is a permutation matrix may be regarded as a special case
Reference: [SV81] <author> S. Skyum and L. Valiant. </author> <title> A complexity theory based on Boolean algebra. </title> <booktitle> Proceedings of the 22nd Annual Symposium on Foundations of Computer Science, (1981) pp. </booktitle> <pages> 244-253, </pages>
Reference-contexts: In order to preserve read-once complexity, we will consider a very restrictive type of problem reduction. We begin with the notion of projection reductions <ref> [SV81] </ref>, as defined in [CSV84]: Definition 6 A function f = ff n g n2N is projection reducible to a function g = fg n g n2N , written f proj g, if there is a mapping : fy 1 ; : : : ; y p (n) g ! f0;
Reference: [We87] <author> I. Wegener. </author> <title> The Complexity of Boolean Functions. </title> <booktitle> Wiley-Teubner Series in Computer Science. </booktitle> <address> New York/Stuggart, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction and background It is well known that many functions, some of them very simple, cannot be computed by read-once branching programs of polynomial size <ref> [We88, Za84, Du85, We87, BHST87, Ju88, Kr88] </ref>. Interest in whether integer multiplication can be so computed has been created by recent developments in the field of digital design and hardware verification. The central problem of verification is to check whether a combinational hardware circuit has been correctly designed. <p> Until now, however, very little was known about the complexity of multiplication with any non-oblivious programs. there has been great success in proving lower bounds on the size of read-once programs, even for some very simple functions <ref> [Ma76, Du85, Za84, We87, SS93] </ref>. <p> For example, it was proved in [Za84] (see also <ref> [We87] </ref>) that determines whether a graph on n nodes is an n=2-clique (with no further edges) requires size 2 (n) . (For comparison, there is a simple read-twice program of size O (n 3 ).) The only asymptotically optimal lower bound is due to [BHST87], which proves a bound of 2
Reference: [We88] <author> I. Wegener. </author> <title> On the complexity of branching programs and decision trees for clique functions. </title> <journal> Journal of the ACM, </journal> <volume> 35(2) (1988), </volume> <pages> pp. 461-471. </pages>
Reference-contexts: 1 Introduction and background It is well known that many functions, some of them very simple, cannot be computed by read-once branching programs of polynomial size <ref> [We88, Za84, Du85, We87, BHST87, Ju88, Kr88] </ref>. Interest in whether integer multiplication can be so computed has been created by recent developments in the field of digital design and hardware verification. The central problem of verification is to check whether a combinational hardware circuit has been correctly designed.
Reference: [We93] <author> I. Wegener. </author> <title> Optimal lower bounds on the depth of polynomial-size threshold circuits for some arithmetic functions. </title> <journal> Information Processing Letters, </journal> <volume> 46 (2), </volume> <pages> pp. 85-87, </pages> <month> May 17, </month> <year> 1993. </year>
Reference-contexts: It was originally proved in [HMPST93] that INNER-PRODUCT-MODULO-2 cannot be computed in polynomial-size by threshold circuits of depth 2. It was also noted there that the projection reduction to multiplication (first given in [FSS84], from PARITY to MULT) shows that MULT obeys the same lower bound. Wegener <ref> [We93] </ref> gives projection reductions from MULT to squaring and inversion in order to show that these functions also require depth 3 polynomial-size threshold circuits. The lower bound for the middle bit of multiplication implies a lower bound for the appropriate bit of these two functions. We phrase the reductions in [We93] <p> <ref> [We93] </ref> gives projection reductions from MULT to squaring and inversion in order to show that these functions also require depth 3 polynomial-size threshold circuits. The lower bound for the middle bit of multiplication implies a lower bound for the appropriate bit of these two functions. We phrase the reductions in [We93] in terms of the following Boolean functions: * SQUARING : f0; 1g n ! f0; 1g; computes "the" middle bit (here, bit n rather than bit n 1 which we chose for MULT) in the square of an n-bit integer: SQUARING (z) = (z 2 ) n : * INVERSION <p> This gives the following corollaries to Theorem 2: 23 Corollary 1 Any read-once branching program for computing the function SQUARING has size at least 2 ( p Proof: We verify that the reduction in <ref> [We93] </ref> shows MULT r-o SQUARING with a polynomial p (n) = 3n + 2. In addition to verifying p (n), we must also check that the reduction is indeed between these two Boolean functions and also that the mapping is injective. <p> &gt; &lt; y i if 0 i &lt; n; x i2 (n+1) if 2 (n + 1) i &lt; 2 (n + 1) + n: Corollary 2 Any read-once branching program for computing the function INVERSION has size at least 2 ( p Proof: We verify that the reduction in <ref> [We93] </ref> shows SQUARING r-o INVERSION with polynomial p (n) = 17n + 1. <p> The proof in <ref> [We93] </ref> shows that the product m 2 lies in bit positions 6n1 through 8n in 1=(1x), its middle bit being in position 7n. By instead computing the inverse of 2 7n (1 x), a 17n-bit number, we find the middle bit of m 2 in position 0. <p> We believe that higher dimensional versions of this latter problem should separate 25 the read-k-times hierarchy. A possible strategy along these lines, using the framework of [BRS93], is given in [P95] for separating read-3-times programs from read-2-times programs. Acknowledgments Thanks to Mikael Goldmann for pointing out the reductions in <ref> [We93] </ref>, to Mauricio Karchmer and Ravi Sundaram for discussions, and to Allan Borodin for bringing this problem to my attention.
Reference: [We94] <author> I. Wegener. </author> <title> Efficient data structures for boolean functions. </title> <journal> Discrete Mathematics, </journal> <volume> 136, </volume> <year> (1994), </year> <pages> pp. 347-372. </pages>
Reference-contexts: One approach to verification often employed today is to independently convert both the circuit description and the function specification to a common intermediate representation and then test whether the two representations are equivalent (e.g., <ref> [We94] </ref>). The use of restricted branching programs as the intermediate representation has made this approach feasible and very popular|several software packages are available for implementing this very strategy [Kr94, Br92]. Definition 1 A branching program is a directed acyclic graph with a distinguished root node and two sink nodes. <p> A simple argument <ref> [We94] </ref> shows that computing DMULT with read-once programs is as hard as factoring. Given a polynomial-size read-once program for DMULT and any integer n, the following procedure will either factor n or determine that it is prime.
Reference: [Za84] <author> S. Zak. </author> <title> An exponential lower bound for one-time-only branching programs. </title> <booktitle> Proceedings of the 11th MFCT, </booktitle> <publisher> Springer-Verlag LNCS No. </publisher> <month> 176 </month> <year> (1984), </year> <pages> pp. 562-566. 29 </pages>
Reference-contexts: 1 Introduction and background It is well known that many functions, some of them very simple, cannot be computed by read-once branching programs of polynomial size <ref> [We88, Za84, Du85, We87, BHST87, Ju88, Kr88] </ref>. Interest in whether integer multiplication can be so computed has been created by recent developments in the field of digital design and hardware verification. The central problem of verification is to check whether a combinational hardware circuit has been correctly designed. <p> Until now, however, very little was known about the complexity of multiplication with any non-oblivious programs. there has been great success in proving lower bounds on the size of read-once programs, even for some very simple functions <ref> [Ma76, Du85, Za84, We87, SS93] </ref>. <p> Until now, however, very little was known about the complexity of multiplication with any non-oblivious programs. there has been great success in proving lower bounds on the size of read-once programs, even for some very simple functions [Ma76, Du85, Za84, We87, SS93]. For example, it was proved in <ref> [Za84] </ref> (see also [We87]) that determines whether a graph on n nodes is an n=2-clique (with no further edges) requires size 2 (n) . (For comparison, there is a simple read-twice program of size O (n 3 ).) The only asymptotically optimal lower bound is due to [BHST87], which proves a
References-found: 44

