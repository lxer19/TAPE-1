URL: http://www.cs.iastate.edu/tech-reports/TR94-12.ps
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: 
Title: Local Variable Allocation For Accurate Garbage Collection of C++  
Author: Ravichandran Ganesan 
Address: 226 Atanasoff Ames, IA 50011  
Affiliation: Iowa State University of Science and Technology Department of Computer Science  
Date: November 8, 1994  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> H. Boehm and M. Weiser, </author> <title> Garbage Collection in an Uncooperative Environment, </title> <journal> SoftwarePractice & Experience 18, </journal> <month> 9 (Sep </month> <year> 1988), </year> <pages> 807-820. </pages>
Reference-contexts: It treats as a pointer any register or memory cell containing a value that is a valid heap memory address <ref> [1] </ref>. Conservative garbage collection has been shown to provide good time and space performance on a wide variety of real-world applications [13]. The alternative available garbage collection technique for C++ is accurate garbage collection, as described in references 8 and 7.
Reference: 2. <author> H. Boehm and D. Chase, </author> <title> A Proposal for Garbage-Collector-Safe C Compilation, </title> <journal> Journal of C Lan guage Translation 4, </journal> <month> 2 (Dec </month> <year> 1992), </year> <pages> 126-141. </pages> <month> -23- </month>
Reference-contexts: Other efforts are focusing on the identification of descriptors and terminals in the global data area, the machine registers, and the parameter passing area within each activation frame. Additionally, we are modifying the code optimizer so that it will avoid garbage-collection unsafe transformations <ref> [2, 3] </ref>. And we are investigating several different garbage collection techniques, both for stock hardware and for custom hardware. We hav e not yet been able to evaluate the performance of an integrated system because parameter passing has not yet been implemented.
Reference: 3. <author> A. Diwan, E. Moss and R. Hudson, </author> <title> Compiler Support for Garbage Collection in a Statically Typed Language, </title> <booktitle> ACM SIGPLAN Notices Conference on Programming Language Design and Implementa tion, </booktitle> <month> June </month> <year> 1992, </year> <pages> 273-282. </pages>
Reference-contexts: Other efforts are focusing on the identification of descriptors and terminals in the global data area, the machine registers, and the parameter passing area within each activation frame. Additionally, we are modifying the code optimizer so that it will avoid garbage-collection unsafe transformations <ref> [2, 3] </ref>. And we are investigating several different garbage collection techniques, both for stock hardware and for custom hardware. We hav e not yet been able to evaluate the performance of an integrated system because parameter passing has not yet been implemented.
Reference: 4. <author> H. Gao and K. Nilsen, </author> <title> Reliable General Purpose Dynamic Memory Management for Real-Time Sys tems, </title> <institution> Iowa State Univ. </institution> <type> Tech. Rep. </type> <pages> 94-09, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: These programs were proposed by Zorn as standard benchmarks for evaluation of applications that make extensive use of dynamic memory [12]. Gao converted these programs, originally written in C, to C++ so that they could be analyzed by C++ compilers <ref> [4] </ref>. We instrumented the GNU C++ compiler to report the number of scalar pointers and the number of scalar non-pointers found in the activation frames of each function in the four experimental workloads. These distributions are illustrated in figures 2.1 through 2.4, shown below.
Reference: 5. <author> S. K. Guggilla, </author> <title> Generational Garbage Collection for C++ Targeted to Sparc Architectures, </title> <type> Master's Degree. </type>
Reference-contexts: Therefore, the garbage collector (rather than the compiler) takes responsibility for computing base pointers from derived pointers. Special circuitry provides the functionality in the hardware-assisted real-time garbage collection system [6]. In the stock-hardware garbage collection system, this functionality is implemented in software <ref> [5] </ref>. Thus, Schmidt's compiler did not need to preserve base pointers, nor did it need to find ways to compute base addresses of objects from derived pointers. <p> This is illustrated in Fig. 4.4. Consider the local variables declared within function foo. t1, t2, and d1 are allocated slots on the activation frame stack. arr and a are allocated positions within the aggregate area. -13- int t1,t2; int arr <ref> [5] </ref>; int *i; a; function body - When the compiler encounters a local aggregate, it begins construction of the corresponding aggregate area, and creates a local variable (usually represented by a register) which points to the base of the aggregate area. Call this variable the aggregate area pointer.
Reference: 6. <author> K. Nilsen and W. J. Schmidt, </author> <title> Cost-Effective Object-Space Management for Hardware-Assisted Real Time Garbage Collection, </title> <journal> ACM Letters on Pro g. Lang. and Systems 1, </journal> <month> 4 (Dec. </month> <year> 1992), </year> <pages> 338-354. </pages>
Reference-contexts: In C++, derived pointers may be assigned to programmer-defined variables and passed as arguments to other functions. Therefore, the garbage collector (rather than the compiler) takes responsibility for computing base pointers from derived pointers. Special circuitry provides the functionality in the hardware-assisted real-time garbage collection system <ref> [6] </ref>. In the stock-hardware garbage collection system, this functionality is implemented in software [5]. Thus, Schmidt's compiler did not need to preserve base pointers, nor did it need to find ways to compute base addresses of objects from derived pointers.
Reference: 7. <author> K. Nilsen, </author> <title> Reliable Real-Time Garbage Collection of C++, </title> <booktitle> Computing Systems 7, </booktitle> <month> 4 (Fall </month> <year> 1994), </year> . 
Reference-contexts: The SPARC instruction encoding reserves five bits to address registers. Register numbers are mapped according to the following table: Windowed Register Name Absolute Register Names global [0] - global <ref> [7] </ref> r0 - r7 out [0] - out [7] r8 - r15 local [0] - local [7] r16 - r23 in [0] - in [7] r24 - r31 Thus, at a given time, an instruction may access any of the the 8 global registers, any of the 16 registers in the <p> The SPARC instruction encoding reserves five bits to address registers. Register numbers are mapped according to the following table: Windowed Register Name Absolute Register Names global [0] - global <ref> [7] </ref> r0 - r7 out [0] - out [7] r8 - r15 local [0] - local [7] r16 - r23 in [0] - in [7] r24 - r31 Thus, at a given time, an instruction may access any of the the 8 global registers, any of the 16 registers in the register set dedicated to the current function, and <p> The SPARC instruction encoding reserves five bits to address registers. Register numbers are mapped according to the following table: Windowed Register Name Absolute Register Names global [0] - global <ref> [7] </ref> r0 - r7 out [0] - out [7] r8 - r15 local [0] - local [7] r16 - r23 in [0] - in [7] r24 - r31 Thus, at a given time, an instruction may access any of the the 8 global registers, any of the 16 registers in the register set dedicated to the current function, and any of the 8 in registers of the <p> Register numbers are mapped according to the following table: Windowed Register Name Absolute Register Names global [0] - global <ref> [7] </ref> r0 - r7 out [0] - out [7] r8 - r15 local [0] - local [7] r16 - r23 in [0] - in [7] r24 - r31 Thus, at a given time, an instruction may access any of the the 8 global registers, any of the 16 registers in the register set dedicated to the current function, and any of the 8 in registers of the next register set.
Reference: 8. <author> K. D. Nilsen and W. J. Schmidt, </author> <title> A High-Performance Hardware-Assisted Real-Time Garbage Col lection System, </title> <journal> Journal of Programming Languages, </journal> <note> To appear. </note>
Reference-contexts: The first two techniques exhibited measurably better performance than the last two. See reference 9 for a more detailed analysis. In response to these observations, Nilsen and Schmidt designed a more efficient activation frame protocol for C++ programs <ref> [8, 9] </ref>. In this revised design, all activation frames are heap allocated as in the fourth alternative described above. H owev er, rather than discarding activation frames in order for the garbage collector to reclaim them, the new design recycles activation frames for each function independently. <p> Previous work by Schmidt and Nilsen differs from Diwan's work in that the target language is lower level than Modula-3 <ref> [8, 9] </ref>. Since the target language is C++, there is no hope of tracking base pointers for all heap-allocated objects. In C++, derived pointers may be assigned to programmer-defined variables and passed as arguments to other functions.
Reference: 9. <author> W. J. Schmidt, </author> <title> Issues in the Design and Implementation of a Real-Time Garbage Collection Archi tecture, </title> <type> Ph.D. Dissertation, </type> <institution> Iowa State Univ. </institution> <type> Tech. Rep. </type> <pages> 92-25, </pages> <year> 1992. </year>
Reference-contexts: Schmidt and Nilsen have identified the management of stack activation frames to be the primary source of run-time overhead in an existing hardware-assisted accurate garbage collection system for C++ <ref> [9, 11] </ref>. The challenge lies in properly identifying precisely which words within every activation frame contain pointers. Schmidt studied several alternative strategies: 1. <p> The first two techniques exhibited measurably better performance than the last two. See reference 9 for a more detailed analysis. In response to these observations, Nilsen and Schmidt designed a more efficient activation frame protocol for C++ programs <ref> [8, 9] </ref>. In this revised design, all activation frames are heap allocated as in the fourth alternative described above. H owev er, rather than discarding activation frames in order for the garbage collector to reclaim them, the new design recycles activation frames for each function independently. <p> Measurements of this ratio on two real programs found activation frame hit rates of 0.9995 and 0.9998 <ref> [9, 10] </ref>. This is the activation frame allocation scheme that was measured to incur overheads of up to 30% on program execution times. <p> Previous work by Schmidt and Nilsen differs from Diwan's work in that the target language is lower level than Modula-3 <ref> [8, 9] </ref>. Since the target language is C++, there is no hope of tracking base pointers for all heap-allocated objects. In C++, derived pointers may be assigned to programmer-defined variables and passed as arguments to other functions. <p> Design of the Activation-Frame It is important for the garbage collector to identify which words in the stack frame are descriptors and which are terminals. So we need a mechanism to give this information to the garbage collector. Schmidt's implementation <ref> [9] </ref> uses a technique called Pointer Location Descriptions (PLD for short) to identify the descriptors and terminals in a run-time stack. In Schmidt's system, each activation frame is accompanied by a PLD, which specifies which words in the activation frame are descriptors and which are not. <p> Though we have not yet measured the performance of the revised system on real workloads, we expect to see activation frame reuse rates that are similar to those reported by Schmidt <ref> [9] </ref>. The main benefit, how-ev er, in comparison with Schmidt's technique is that over 90% of function invocations do not even hav e to bother with the management of aggregate areas, since they hav e no local aggregate variables. 5. Implementation 5.1.
Reference: 10. <author> W. J. Schmidt and K. D. Nilsen, </author> <title> Experimental Measurements of a Real-Time Garbage Collection Architecture, </title> <institution> Iowa State Univ. </institution> <type> Tech. Rep. </type> <pages> 92-26, </pages> <year> 1992. </year>
Reference-contexts: Measurements of this ratio on two real programs found activation frame hit rates of 0.9995 and 0.9998 <ref> [9, 10] </ref>. This is the activation frame allocation scheme that was measured to incur overheads of up to 30% on program execution times. <p> The signature of an aggregate data object is the catenation of the signatures of its constituent data types. For example, the variable ab, declared below: str uct a - int *j; ab; has the signature 011, and int a <ref> [10] </ref>; has the signature 0000000000. Therefore, the variable baz in the following declaration str uct b - int x [10]; has the signature 0000000000011, obtained by catenating the signatures of the individual structure elements. <p> For example, the variable ab, declared below: str uct a - int *j; ab; has the signature 011, and int a <ref> [10] </ref>; has the signature 0000000000. Therefore, the variable baz in the following declaration str uct b - int x [10]; has the signature 0000000000011, obtained by catenating the signatures of the individual structure elements.
Reference: 11. <author> W. J. Schmidt and K. D. Nilsen, </author> <title> Performance of a Hardware-Assisted Real-Time Garbage Collector, </title> <booktitle> Sixth International Conference on Architectural Support for Programming Languages and Operating Systems, To appear. </booktitle>
Reference-contexts: But previous implementations of accurate C++ garbage collectors require special hardware and incur a run-time overhead of up to 30%, even with the aid of the special hardware support <ref> [11] </ref>. Schmidt and Nilsen have identified the management of stack activation frames to be the primary source of run-time overhead in an existing hardware-assisted accurate garbage collection system for C++ [9, 11]. The challenge lies in properly identifying precisely which words within every activation frame contain pointers. <p> Schmidt and Nilsen have identified the management of stack activation frames to be the primary source of run-time overhead in an existing hardware-assisted accurate garbage collection system for C++ <ref> [9, 11] </ref>. The challenge lies in properly identifying precisely which words within every activation frame contain pointers. Schmidt studied several alternative strategies: 1.
Reference: 12. <author> B. Zorn and D. Grunwald, </author> <title> Empirical Measurements of Six Allocation-intensive C Programs, </title> <journal> SIG PLAN Notices 27, </journal> <month> 12 (Dec </month> <year> 1992), </year> . 
Reference-contexts: These programs were proposed by Zorn as standard benchmarks for evaluation of applications that make extensive use of dynamic memory <ref> [12] </ref>. Gao converted these programs, originally written in C, to C++ so that they could be analyzed by C++ compilers [4].
Reference: 13. <author> B. Zorn, </author> <title> The Measured Cost of Conservative Garbage Collection, </title> <journal> SoftwarePractice & Experience 23, </journal> <month> 7 (Jul </month> <year> 1993), </year> <pages> 773-756. </pages>
Reference-contexts: It treats as a pointer any register or memory cell containing a value that is a valid heap memory address [1]. Conservative garbage collection has been shown to provide good time and space performance on a wide variety of real-world applications <ref> [13] </ref>. The alternative available garbage collection technique for C++ is accurate garbage collection, as described in references 8 and 7. Accurate garbage collection requires cooperation from the compiler's code generator in order to distinguish pointers from non-pointers within memory and registers.
References-found: 13

