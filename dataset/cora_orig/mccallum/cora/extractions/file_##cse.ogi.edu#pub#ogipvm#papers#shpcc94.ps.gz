URL: file://cse.ogi.edu/pub/ogipvm/papers/shpcc94.ps.gz
Refering-URL: http://www.cse.ogi.edu/~konuru/
Root-URL: http://www.cse.ogi.edu
Email: walpoleg@cse.ogi.edu  
Title: A User-Level Process Package for PVM  
Author: Ravi Konuru, Jeremy Casas, Steve Otto, Robert Prouty, Jonathan Walpole fkonuru, casas, prouty, otto, 
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Note: Copyright 1994 IEEE 0-8186-5680-8/94 $03.00  
Abstract: This paper describes an approach to supporting efficient processor virtualization and dynamic load balancing for message-based, parallel programs. Specifically, a user-level process package (UPVM) for SPMD-style PVM applications is presented. UPVM supports light-weight virtual processors that are transparently and independently migratable. It also implements a source-code compatible PVM interface, which means that existing PVM programs only need to be recompiled and re-linked. The performance of UPVM is discussed and compared with that of standard PVM. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. E. Anderson, B. N. Bershad, E. D. Lazowska, and H. M. Levy. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Further, the reduced thread context switch costs increase the scope for overlap of remote communication with computation. To further reduce the cost of thread operations, user-level thread libraries have been proposed that obviate operating system intervention for thread creation, termination, context switch and scheduling <ref> [10, 16, 1] </ref>. Generally, user-level thread performance is an order of magnitude better than OS threads. Although both these thread-based approaches offer significant improvement over the use of OS processes, there are two main objections to thread based approaches. <p> However, there are several issues that need to be considered when implementing, porting, programming, or determining the applicability of UPVM. Some of the main issues are discussed below. 5.1 OS support for performance The problems of supporting programming abstractions at user-level are well explored in the literature <ref> [16, 1] </ref>. Operating systems manage processes or OS threads, and do not know about abstractions implemented at user-level. This "mismatch" can result in performance degradation of applications. <p> Because of such problems, care had to be taken in benchmarking the UPVM package. Copyright 1994 IEEE 0-8186-5680-8/94 $03.00 However, most of these problems have been ad-dressed in the context of user-level, thread-based systems using scheduler activations <ref> [1] </ref> and first-class user-level threads [16]. The mechanisms implemented therein provide the required OS support for user-level abstractions. Similarly, the Solaris operating system [19] implements new types of signals that can be used to achieve better integration of user-level libraries with the OS.
Reference: [2] <author> Adam Beguelin, Jack Dongarra, Al Geist, Robert Manchek, Steve Otto, and Jon Walpole. </author> <title> PVM: Experiences, current status and future direction. </title> <booktitle> In Supercomputing'93 Proceedings, </booktitle> <pages> pages 765-6, </pages> <year> 1993. </year>
Reference-contexts: There is ongoing work with the ORNL PVM group to define such an interface, called the Concurrent Processing Environment (CPE) interface, for PVM-based parallel applications <ref> [2] </ref>. 5.3 Migration Transparent ULP migration is one of the major goals of this work and is under current development. ULP migration is designed to work between workstation architectures that are binary compatible. Heterogeneity is possible, but restricted, in the ULP environment.
Reference: [3] <author> David L. Black. </author> <title> Scheduling support for concur-rency and parallelism in the Mach operating system. </title> <journal> Computer, </journal> <volume> 23(5) </volume> <pages> 35-43, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: If the source ULP is local, that Copyright 1994 IEEE 0-8186-5680-8/94 $03.00 is, within the same process, and is runnable, UPVM schedules the destination ULP regardless of its position in the run queue. This technique is called hand-off scheduling <ref> [3] </ref>. The PVM buffer management interface is implemented by giving each ULP its own local view of buffer identifiers, the current send buffer and receive buffer. These local buffer identifiers (LBIDs) are mapped into global buffer identifiers (GBIDs) by UPVM.
Reference: [4] <author> Ralph Butler and Ewing Lusk. </author> <title> User's guide to the p4 parallel programming system. </title> <type> Technical Report ANL-92/17, </type> <institution> Argonne National laboratory, </institution> <year> 1992. </year>
Reference-contexts: Processor virtualization also improves system resource utilization because it allows systems software to transparently adapt to changes in processor availability, preemption, and load imbalance. Support for dynamic reallocation is useful in large multicomputers and essential in shared workstation environments. Parallel processing packages, such as PVM [11] and P4 <ref> [4] </ref>, use operating system (OS) processes as their VPs. Consequently, system calls provided by the OS are used to implement their message-passing and task-management interfaces.
Reference: [5] <author> Jeffrey S. Chase, Franz G. Amador, Edward D. Lazowska, Henry M. Levy, and Richard J. Little-field. </author> <title> The Amber system: Parallel programming on a network of multiprocessors. </title> <booktitle> In Proceedings of the 12th Symposium on Operating System Principles, </booktitle> <pages> pages 147-158, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: In other words, the per-ULP context allows ULP emulation and migration to be independent of the execution state of other ULPs. However, these benefits are achieved at the cost of higher context switch overheads and the restriction of migration to homogeneous pools of processors. Object-based systems such as Amber <ref> [5] </ref> and COOL [15] provide a programming environment that exports a thread-based object oriented programming model to the user. The objects share a single address space per 3 except for certain small critical sections within the ULP system. application.
Reference: [6] <author> David R. Cheriton. </author> <title> The V kernel: A software base for distributed systems. </title> <journal> IEEE Software, </journal> <volume> 1(2) </volume> <pages> 19-42, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: If the overhead of VPs is low enough, this approach becomes attractive. However, OD at the granularity of OS processes leads to excessive overhead. Attempts to address the high cost of OS processes have introduced a new OS abstraction called the thread <ref> [12, 9, 6, 19] </ref>. Like processes, threads have a register context and a stack. However, unlike processes, threads do not have their own private address space. Consequently, thread switches can be cheaper than process switches because they need not involve virtual memory context switches. <p> These approaches can be broadly classified as OS-thread based, user-level-thread based, language-- based, and object-based approaches. Operating systems such as Chorus [12], Mach [9], V <ref> [6] </ref>, and Solaris [19], provide OS threads that can be used to reduce the cost of OD. Context switches between OS threads of the same process do not require the switching of the virtual memory context.
Reference: [7] <author> Eric C. Cooper and Richard P. Draves. </author> <title> C Threads. </title> <type> Technical Report CMU-CS-88-154, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: Consequently, thread switches can be cheaper than process switches because they need not involve virtual memory context switches. Similarly, local communication is reduced to accessing memory locations in the same address space. Some packages implement Copyright 1994 IEEE 0-8186-5680-8/94 $03.00 the thread abstraction above the OS at user level <ref> [7, 8] </ref>. These user-level thread packages further reduce the cost of thread operations by avoiding the need to enter the OS for thread scheduling and management. The lower cost of local communication and context switching for both user and OS-level threads means that OD can be implemented efficiently.
Reference: [8] <author> Thomas W. Doeppner. </author> <title> Threads: A System for the Support of Concurrent Programming. </title> <type> Technical Report CS-87-11, </type> <institution> Department of Computer Science Brown University, </institution> <address> Providence, RI 02912, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: Consequently, thread switches can be cheaper than process switches because they need not involve virtual memory context switches. Similarly, local communication is reduced to accessing memory locations in the same address space. Some packages implement Copyright 1994 IEEE 0-8186-5680-8/94 $03.00 the thread abstraction above the OS at user level <ref> [7, 8] </ref>. These user-level thread packages further reduce the cost of thread operations by avoiding the need to enter the OS for thread scheduling and management. The lower cost of local communication and context switching for both user and OS-level threads means that OD can be implemented efficiently.
Reference: [9] <author> Mike Accetta et al. </author> <title> Mach: A new kernel foundation for UNIX development. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 93-112, </pages> <address> Atlanta, Georgia, </address> <year> 1986. </year>
Reference-contexts: If the overhead of VPs is low enough, this approach becomes attractive. However, OD at the granularity of OS processes leads to excessive overhead. Attempts to address the high cost of OS processes have introduced a new OS abstraction called the thread <ref> [12, 9, 6, 19] </ref>. Like processes, threads have a register context and a stack. However, unlike processes, threads do not have their own private address space. Consequently, thread switches can be cheaper than process switches because they need not involve virtual memory context switches. <p> These approaches can be broadly classified as OS-thread based, user-level-thread based, language-- based, and object-based approaches. Operating systems such as Chorus [12], Mach <ref> [9] </ref>, V [6], and Solaris [19], provide OS threads that can be used to reduce the cost of OD. Context switches between OS threads of the same process do not require the switching of the virtual memory context.
Reference: [10] <author> E.W. Felten and D. McNamee. </author> <title> Improving application performance by multithreading. </title> <booktitle> In Proceeding of the Scalable High Performance Computing Conference, </booktitle> <address> Williamsburg, VA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Further, the reduced thread context switch costs increase the scope for overlap of remote communication with computation. To further reduce the cost of thread operations, user-level thread libraries have been proposed that obviate operating system intervention for thread creation, termination, context switch and scheduling <ref> [10, 16, 1] </ref>. Generally, user-level thread performance is an order of magnitude better than OS threads. Although both these thread-based approaches offer significant improvement over the use of OS processes, there are two main objections to thread based approaches.
Reference: [11] <author> G. A. Geist and V. S. Sunderam. </author> <title> Network-Base Concurrent Computing on the PVM System. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 4(4) </volume> <pages> 293-311, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Processor virtualization also improves system resource utilization because it allows systems software to transparently adapt to changes in processor availability, preemption, and load imbalance. Support for dynamic reallocation is useful in large multicomputers and essential in shared workstation environments. Parallel processing packages, such as PVM <ref> [11] </ref> and P4 [4], use operating system (OS) processes as their VPs. Consequently, system calls provided by the OS are used to implement their message-passing and task-management interfaces.
Reference: [12] <author> Michel Gien. </author> <title> Micro-kernel design. </title> <journal> UNIX REVIEW, </journal> <volume> 8(11) </volume> <pages> 58-63, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: If the overhead of VPs is low enough, this approach becomes attractive. However, OD at the granularity of OS processes leads to excessive overhead. Attempts to address the high cost of OS processes have introduced a new OS abstraction called the thread <ref> [12, 9, 6, 19] </ref>. Like processes, threads have a register context and a stack. However, unlike processes, threads do not have their own private address space. Consequently, thread switches can be cheaper than process switches because they need not involve virtual memory context switches. <p> These approaches can be broadly classified as OS-thread based, user-level-thread based, language-- based, and object-based approaches. Operating systems such as Chorus <ref> [12] </ref>, Mach [9], V [6], and Solaris [19], provide OS threads that can be used to reduce the cost of OD. Context switches between OS threads of the same process do not require the switching of the virtual memory context.
Reference: [13] <author> Philip J. Hatcher, Robert R. Jones Anthony J. Lapadula, Michael J. Quinn, and Ray J. Ander-son. </author> <title> A Production-quality C* Compiler for Hypercube Multicomputers. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles & Practice of Parallel Programming, </booktitle> <pages> pages 73-82, </pages> <address> Williamsburg VA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Existing process based applications have to be extensively modified or rewritten to take advantage of threads. In contrast, our approach supports the familiar process programming model. This implies that existing programs employing the process model can directly benefit from ULPs. The Data Parallel C (DPC) compiler and run-time environment <ref> [13] </ref> export a SIMD, shared address space model operated upon by a user-specified number of VPs. This number is usually much larger than the number of processors available. The multicomputer DPC compiler translates the SIMD DPC program source into SPMD C code.
Reference: [14] <author> Ravi Konuru, Jeremy Casas, Robert Prouty, Steve Otto, and Jonathan Walpole. </author> <title> A user-level process package for concurrent computing. </title> <type> Technical Report TR-93-016, </type> <institution> Dept of Computer Science and Engineering, Oregon Graduate Institute of Science & Technology, </institution> <year> 1993. </year>
Reference-contexts: Porting to other systems is discussed in Sec. 5.4. A more detailed description is provided in <ref> [14] </ref>. Some familiarity with the PVM interface is assumed. When the application is invoked, control is immediately transferred into the UPVM library. At this point, the number of idle processors is determined, a process is created on each allocated processor, and the ULPs are created within these processes.
Reference: [15] <author> Rodger Lea, Paulo Amaral, and Christian Jacquemot. COOL-2: </author> <title> An object oriented support platform built above the Chorus micro-kernel. </title> <booktitle> In Proceedings of the 1991 International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 68-72, </pages> <address> Palo Alto, CA, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: However, these benefits are achieved at the cost of higher context switch overheads and the restriction of migration to homogeneous pools of processors. Object-based systems such as Amber [5] and COOL <ref> [15] </ref> provide a programming environment that exports a thread-based object oriented programming model to the user. The objects share a single address space per 3 except for certain small critical sections within the ULP system. application.
Reference: [16] <author> B. D. Marsh, M. L. Scott, T. J. LeBlanc, and E. P. Markatos. </author> <title> First-class user-level threads. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 95-109, </pages> <address> Pacific Grove, CA, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Further, the reduced thread context switch costs increase the scope for overlap of remote communication with computation. To further reduce the cost of thread operations, user-level thread libraries have been proposed that obviate operating system intervention for thread creation, termination, context switch and scheduling <ref> [10, 16, 1] </ref>. Generally, user-level thread performance is an order of magnitude better than OS threads. Although both these thread-based approaches offer significant improvement over the use of OS processes, there are two main objections to thread based approaches. <p> However, there are several issues that need to be considered when implementing, porting, programming, or determining the applicability of UPVM. Some of the main issues are discussed below. 5.1 OS support for performance The problems of supporting programming abstractions at user-level are well explored in the literature <ref> [16, 1] </ref>. Operating systems manage processes or OS threads, and do not know about abstractions implemented at user-level. This "mismatch" can result in performance degradation of applications. <p> Because of such problems, care had to be taken in benchmarking the UPVM package. Copyright 1994 IEEE 0-8186-5680-8/94 $03.00 However, most of these problems have been ad-dressed in the context of user-level, thread-based systems using scheduler activations [1] and first-class user-level threads <ref> [16] </ref>. The mechanisms implemented therein provide the required OS support for user-level abstractions. Similarly, the Solaris operating system [19] implements new types of signals that can be used to achieve better integration of user-level libraries with the OS.
Reference: [17] <author> Bill Nitzberg and Virginia Lo. </author> <title> Distributed Shared Memory: A Survey of Issues and Algorithms. </title> <journal> IEEE Computer, </journal> <volume> 24(8) </volume> <pages> 52-60, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The root of many of these problems is the need to preserve the memory consistency imposed by the shared-memory programming model. Distributed shared memory (DSM) mechanisms exist that provide consistency at the granularity of the machine page size rather than the size of the actual data structure being shared <ref> [17] </ref>. Second, thread migration is complicated in the context of a shared-memory programming model because a thread's state can be implicitly changed by other threads through shared memory. Thus, accurate inter-thread, data-dependence information must be known about the application to achieve an optimal migration.
Reference: [18] <author> John K. Ousterhout. </author> <booktitle> Why aren't operating systems getting faster as fast as hardware? In Proceedings of the Summer 1990 USENIX Conference, </booktitle> <pages> pages 247-256, </pages> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Type Cost (micro-seconds) Ratio ULP switch 4.74 7.30 UNIX switch 195.00 300.46 Isolating the process context switch cost in a portable manner is extremely difficult, since there is no equivalent of a yield-to-another-process system call on UNIX. Our solution to this problem was to use Ouster-hout's context switch benchmark <ref> [18] </ref>. In this case, we calculate half the time taken by two UNIX processes to alternately read and write one byte from a pair of pipes.
Reference: [19] <author> M. L. Powell, S. R. Kleiman, S. Barton, D. Shah, D. Stein, and M. Weeks. </author> <title> SunOS multi-thread architecture. </title> <booktitle> In Proceedings of the Winter 1991 USENIX conference, </booktitle> <pages> pages 1-14, </pages> <address> Dallas, TX, </address> <month> January </month> <year> 1991. </year> <note> Copyright 1994 IEEE 0-8186-5680-8/94 $03.00 </note>
Reference-contexts: If the overhead of VPs is low enough, this approach becomes attractive. However, OD at the granularity of OS processes leads to excessive overhead. Attempts to address the high cost of OS processes have introduced a new OS abstraction called the thread <ref> [12, 9, 6, 19] </ref>. Like processes, threads have a register context and a stack. However, unlike processes, threads do not have their own private address space. Consequently, thread switches can be cheaper than process switches because they need not involve virtual memory context switches. <p> These approaches can be broadly classified as OS-thread based, user-level-thread based, language-- based, and object-based approaches. Operating systems such as Chorus [12], Mach [9], V [6], and Solaris <ref> [19] </ref>, provide OS threads that can be used to reduce the cost of OD. Context switches between OS threads of the same process do not require the switching of the virtual memory context. Consequently, thread context switch is generally an order of magnitude or so faster than process context switch. <p> Copyright 1994 IEEE 0-8186-5680-8/94 $03.00 However, most of these problems have been ad-dressed in the context of user-level, thread-based systems using scheduler activations [1] and first-class user-level threads [16]. The mechanisms implemented therein provide the required OS support for user-level abstractions. Similarly, the Solaris operating system <ref> [19] </ref> implements new types of signals that can be used to achieve better integration of user-level libraries with the OS.
References-found: 19

