URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1996/TR38.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: Dependency Sequences and Hierarchical Clocks: Efficient Alternatives to Vector Clocks for Mobile Computing Systems  
Author: Ravi Prakash Mukesh Singhal 
Address: 2015 Neil Avenue Columbus, Ohio 43210.  
Affiliation: Department of Computer and Information Science The Ohio State University  
Abstract: Vector clock has been used to capture causal dependencies between processes in distributed computing systems. It is not suitable for mobile computing systems due to (i) lack of scalability: its size is equal to the number of nodes, and (ii) its inability to cope with fluctuations in the number of nodes. This paper presents two efficient alternatives to vector clock, namely, sets of dependency sequences, and hierarchical clock. Both the alternatives are scalable, and are immune to fluctuations in the number of nodes in the system.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. R. Badrinath, A. Acharya, and T. Imielinski. </author> <title> Structuring Distributed Algorithms for Mobile Hosts. </title> <booktitle> In Proceedings of the 14 th International Conference on Distributed Computing Systems, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Several communication protocols and application software that are suitable for such distributed systems have unacceptable performance in a mobile computing system due to the low data rate. Hence, there is a need to develop efficient alternatives <ref> [1] </ref>. Applications, running on distributed systems have employed vector clocks [2, 6] to track causal dependency relations between events on different processes. The vector clock is an integer vector with as many components as the number of processes in the application. <p> Initially, the vector clocks at both the M SSs are set to [0; 0]. M H b has to send a message m 1 to M H c . So, M H b sends the message to M SS p . M SS p associates a vector timestamp of <ref> [1; 0] </ref> with the event Send (m 1 ) (as it is the first message sent or received by M SS p ), and forwards the message to M SS q . <p> When m 1 arrives at M SS q , M SS q sets its vector clock to <ref> [1; 1] </ref>, associates this timestamp with the event Recv (m 1 ), (i:e:, V (Recv (m 1 )) = [1; 1]) and forwards m 1 to M H c . <p> When m 1 arrives at M SS q , M SS q sets its vector clock to <ref> [1; 1] </ref>, associates this timestamp with the event Recv (m 1 ), (i:e:, V (Recv (m 1 )) = [1; 1]) and forwards m 1 to M H c . M H d has to send message m 2 to an arbitrary node in the network, say M H a . So, M H d sends m 2 to M SS q . <p> So, M H d sends m 2 to M SS q . M SS q receives m 2 after receiving m 1 . Hence, M SS q updates its vector clock to <ref> [1; 2] </ref> and associates this timestamp with the event Send (m 2 ), i:e:, V (Send (m 2 )) = [1; 2]. As there is no causal relationship between Recv (m 1 ) and Send (m 2 ), the two events are concurrent. <p> M SS q receives m 2 after receiving m 1 . Hence, M SS q updates its vector clock to <ref> [1; 2] </ref> and associates this timestamp with the event Send (m 2 ), i:e:, V (Send (m 2 )) = [1; 2]. As there is no causal relationship between Recv (m 1 ) and Send (m 2 ), the two events are concurrent.
Reference: [2] <author> J. Fidge. </author> <title> Timestamps in Message-Passing Systems that Preserve the Partial Ordering. </title> <booktitle> In Proceedings of the 11 th Australian Computer Science Conference, </booktitle> <pages> pages 56-66, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Several communication protocols and application software that are suitable for such distributed systems have unacceptable performance in a mobile computing system due to the low data rate. Hence, there is a need to develop efficient alternatives [1]. Applications, running on distributed systems have employed vector clocks <ref> [2, 6] </ref> to track causal dependency relations between events on different processes. The vector clock is an integer vector with as many components as the number of processes in the application. For large distributed applications, with many constituent processes, the size of the vector clock is large. <p> Let C (a) and C (b) be the scalar clock values associated with two events a and b. Then, a ! b ) C (a) &lt; C (b). However, the converse is not true. Vector clocks, proposed independently by Fidge <ref> [2] </ref> and Mattern [6], guarantee that if V (a) and V (b) are the vector timestamps (values of the vector clocks when events occur) associated with events a and b, respectively, then a ! b , V (a) &lt; V (b). <p> So, M H d sends m 2 to M SS q . M SS q receives m 2 after receiving m 1 . Hence, M SS q updates its vector clock to <ref> [1; 2] </ref> and associates this timestamp with the event Send (m 2 ), i:e:, V (Send (m 2 )) = [1; 2]. As there is no causal relationship between Recv (m 1 ) and Send (m 2 ), the two events are concurrent. <p> M SS q receives m 2 after receiving m 1 . Hence, M SS q updates its vector clock to <ref> [1; 2] </ref> and associates this timestamp with the event Send (m 2 ), i:e:, V (Send (m 2 )) = [1; 2]. As there is no causal relationship between Recv (m 1 ) and Send (m 2 ), the two events are concurrent.
Reference: [3] <author> J. Fowler and W. Zwaenepoel. </author> <title> Causal Distributed Breakpoints. </title> <booktitle> In Proceedings of the 10 th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 134-141. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: Thus, a dependency chain has to be traversed to generate the bit matrix. This is similar to the dependency generating method proposed in Fowler-Zwaenepoel <ref> [3] </ref>. 6.3 Handling Handoff When a mobile host M H a moves from cell C i to C j , the handoff process is executed.
Reference: [4] <author> T. Imielinski and B. R. Badrinath. </author> <title> Mobile Wireless Computing. </title> <journal> Communications of the ACM, </journal> <volume> 37(10) </volume> <pages> 19-28, </pages> <year> 1994. </year>
Reference-contexts: The data rate achievable on wireless channels is significantly lower than the achievable data rate on the fixed wireline network <ref> [4] </ref>. Communication bandwidth available to mobile hosts is significantly less than the bandwidth available to nodes in traditional distributed systems that use wireline networks only.
Reference: [5] <author> L. Lamport. </author> <title> Time, Clocks and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Such dependencies can be expressed using the happened before relation (!) between events, defined in <ref> [5] </ref> as: * a ! b, if a and b are events in the same process and a occurred before b. * a ! b, if a is the event of sending a message M in a process and b is the event of delivery of the same message to another <p> In such a situation a is not present in the past cone of b, and vice-versa. Lamport's happened before relation is employed to maintain a scalar clock <ref> [5] </ref> representing the partial order between events. Let C (a) and C (b) be the scalar clock values associated with two events a and b. Then, a ! b ) C (a) &lt; C (b). However, the converse is not true.
Reference: [6] <author> F. Mattern. </author> <title> Virtual Time and Global States of Distributed Systems. </title> <editor> In M.Cosnard et. al., editor, </editor> <booktitle> Proceedings of the Workshop on Parallel and Distributed Algorithm, </booktitle> <pages> pages 215-226. </pages> <publisher> Elsevier Science Publishers B.V.(North-Holland), </publisher> <year> 1989. </year>
Reference-contexts: Several communication protocols and application software that are suitable for such distributed systems have unacceptable performance in a mobile computing system due to the low data rate. Hence, there is a need to develop efficient alternatives [1]. Applications, running on distributed systems have employed vector clocks <ref> [2, 6] </ref> to track causal dependency relations between events on different processes. The vector clock is an integer vector with as many components as the number of processes in the application. For large distributed applications, with many constituent processes, the size of the vector clock is large. <p> Let C (a) and C (b) be the scalar clock values associated with two events a and b. Then, a ! b ) C (a) &lt; C (b). However, the converse is not true. Vector clocks, proposed independently by Fidge [2] and Mattern <ref> [6] </ref>, guarantee that if V (a) and V (b) are the vector timestamps (values of the vector clocks when events occur) associated with events a and b, respectively, then a ! b , V (a) &lt; V (b).
Reference: [7] <author> M. Raynal and M. Singhal. </author> <title> Logical Time: Capturing Causality in Distributed Systems. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 49-56, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: Thus, an isomorphism exists between the set of partially ordered events in a distributed computation and their timestamps <ref> [7] </ref>. If V (a) &lt; V (b), then event a is in the past cone of event b. 3 Insufficiency of n-component Vector Clocks In mobile computing systems, all communications of the M Hs take place through the M SS of the cell in which they are present.
References-found: 7

