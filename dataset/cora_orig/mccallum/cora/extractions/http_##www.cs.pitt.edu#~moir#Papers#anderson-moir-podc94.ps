URL: http://www.cs.pitt.edu/~moir/Papers/anderson-moir-podc94.ps
Refering-URL: http://www.cs.pitt.edu/~moir/papers.html
Root-URL: 
Title: Using k-Exclusion to Implement Resilient, Scalable Shared Objects (Extended Abstract)  
Author: James H. Anderson and Mark Moir 
Address: Chapel Hill, North Carolina 27599-3175, USA  
Affiliation: Department of Computer Science The University of North Carolina at Chapel Hill  
Abstract: We present a methodology for the implementation of resilient shared objects that allows the desired level of resiliency to be selected based on performance concerns. This methodology is based on the k-exclusion and renaming problems. To make this methodology practical, we present a number of fast k-exclusion algorithms that employ "local spin" techniques to minimize the impact of the processor-to-memory bottleneck. We also present a new "long-lived" renaming algorithm. Our k-exclusion algorithms are based on commonly-available synchronization primitives, are fast in the absence of contention, and have scalable performance when contention exceeds expected thresholds. By contrast, all prior k-exclusion algorithms either require unrealistic atomic operations or perform badly. Our k-exclusion algorithms are also the first algorithms based on local-spin techniques that tolerate process failures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Afek, D. Dolev, E. Gafni, M. Merritt, and N. Shavit, "First-in-First-Enabled l-Exclusion", </author> <booktitle> Proceedings of the 4th International Workshop on Distributed Algorithms, </booktitle> <year> 1990. </year>
Reference-contexts: By definition, such objects will not scale well, even at lower levels of resiliency. 1 Ref. Complexity w/ Contention Complexity w/o Contention Instructions Used [9] 1 O (1) Large Critical Sections [10] 1 O (1) Large Critical Sections [8] 1 O (N 2 ) Safe Bits <ref> [1] </ref> 1 O (N ) Atomic Read and Write Thm. 3 O (k log (N=k)) w/ coherent cache O (k) Read, Write, Fetch-and-Increment Thm. 7 O (k log (N=k)) O (k) Above and Compare-and-Swap Table 1: A comparison of k-exclusion algorithms. names from a range of size k to use within
Reference: [2] <author> T. Anderson, </author> <title> "The Performance of Spin Lock Alternatives for Shared-Memory Multiprocessors", </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> Vol. 1, No. 1, </volume> <month> January, </month> <year> 1990, </year> <pages> pp. 6-16. </pages>
Reference-contexts: An access is remote if it requires a traversal of the global interconnect between processors and shared memory, and local otherwise. We measure time complexity in terms of remote accesses because performance studies have shown that minimizing such accesses is important for scalable performance <ref> [2, 11, 12, 14] </ref>. In practice, a shared variable can be made locally-accessible by storing it in a local cache-line or in a local partition of distributed shared memory. In this paper, we present several fast k-exclusion algorithms, for cache-coherent and distributed shared-memory machines. <p> We present several other algorithms in addition to these, including algorithms that exhibit performance that degrades gracefully as contention rises. To achieve good performance in the presence of contention, our algorithms employ "local-spin" techniques to minimize remote accesses of shared memory <ref> [2, 11, 12, 14] </ref>. We show that our k-exclusion algorithms can be extended to solve k-assignment, specifically by using a new solution to the renaming problem [3, 4, 5]. This new solution is the first that is long-lived, i.e., that allows each process to repeatedly obtain and release names. <p> Ultimately, we would like to develop k-exclusion algorithms for which performance under contention is completely independent of N . We would also like for such algorithms to have performance that approaches that of the fastest spin-lock algorithms <ref> [2, 11, 12, 14] </ref> when k approaches 1. If based on universal wait-free constructions, the methodology we suggest could yield a generic approach to shared object design in which resiliency can be "tuned" according to performance demands.
Reference: [3] <author> H. Attiya, A. Bar-Noy, D. Dolev, D. Koller, D. Peleg, and R. Reischuk, </author> <title> "Achievable Cases in an Asynchronous Environment", </title> <booktitle> Proceedings of the 28th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1987, </year> <pages> pp. 337-346. </pages>
Reference-contexts: From a performance standpoint, linking resiliency to expected levels of contention may be preferable. So doing requires a methodology for implementing objects at intermediate levels of resiliency. Such a methodology can be based on solutions to the k-exclusion [9] and k-assignment <ref> [3] </ref> problems. The k-exclusion problem extends the well-known mutual exclusion problem [7] by allowing up to k processes to be in their critical sections simultaneously. k-assignment extends k-exclusion by requiring each process in its critical section to obtain a unique name taken from a fixed set of k names. <p> To achieve good performance in the presence of contention, our algorithms employ "local-spin" techniques to minimize remote accesses of shared memory [2, 11, 12, 14]. We show that our k-exclusion algorithms can be extended to solve k-assignment, specifically by using a new solution to the renaming problem <ref> [3, 4, 5] </ref>. This new solution is the first that is long-lived, i.e., that allows each process to repeatedly obtain and release names. It is based on test-and-set, requires a name-space of exactly k, and has time complexity O (k). The remainder of this paper is organized as follows. <p> Proof Sketch: This result is proved by using the algorithm shown in Figure 4, with (2k; k)-exclusion implemented as in Theorem 5 and (N k; k)-exclusion implemented using the algorithm in Figure 4. This approach is depicted in Figure 3 (b). 2 4 k-Assignment In the renaming problem <ref> [3] </ref>, each of k processes must be assigned a unique name from a fixed name space. A solution to the renaming problem can be used to extend a k-exclusion algorithm to a k-assignment algorithm.
Reference: [4] <author> A. Bar-Noy and D. Dolev, </author> <title> "Shared Memory versus Message-Passing in an Asynchronous Distributed Environment", </title> <booktitle> Proceedings of the 8th Annual ACM Symposium on Principles of Distributed Computing , ACM, </booktitle> <address> New York, </address> <month> August </month> <year> 1989, </year> <pages> pp. 307-318. </pages>
Reference-contexts: To achieve good performance in the presence of contention, our algorithms employ "local-spin" techniques to minimize remote accesses of shared memory [2, 11, 12, 14]. We show that our k-exclusion algorithms can be extended to solve k-assignment, specifically by using a new solution to the renaming problem <ref> [3, 4, 5] </ref>. This new solution is the first that is long-lived, i.e., that allows each process to repeatedly obtain and release names. It is based on test-and-set, requires a name-space of exactly k, and has time complexity O (k). The remainder of this paper is organized as follows.
Reference: [5] <author> E. Borowsky and E. Gafni, </author> <title> "Immediate Atomic Snapshots and Fast Renaming", </title> <booktitle> Proceedings of the 12th Annual ACM Symposium on Principles of Distributed Computing , ACM, </booktitle> <address> New York, </address> <month> August </month> <year> 1993, </year> <pages> pp. 41-50. </pages>
Reference-contexts: To achieve good performance in the presence of contention, our algorithms employ "local-spin" techniques to minimize remote accesses of shared memory [2, 11, 12, 14]. We show that our k-exclusion algorithms can be extended to solve k-assignment, specifically by using a new solution to the renaming problem <ref> [3, 4, 5] </ref>. This new solution is the first that is long-lived, i.e., that allows each process to repeatedly obtain and release names. It is based on test-and-set, requires a name-space of exactly k, and has time complexity O (k). The remainder of this paper is organized as follows.
Reference: [6] <author> K. Chandy and J. Misra, </author> <title> Parallel Program Design: </title>
Reference-contexts: When reasoning about programs, we define safety properties using invariant and unless assertions and progress properties using leads-to assertions <ref> [6] </ref>. A state assertion is an invariant iff it holds in each state of every history.
References-found: 6

