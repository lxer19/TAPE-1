URL: http://www.cs.ucla.edu/~stefanus/report.ps
Refering-URL: http://www.cs.ucla.edu/~stefanus/resume.html
Root-URL: http://www.cs.ucla.edu
Title: Fast Parallel Multiplication with Parallel On-The-Fly Conversion  
Author: Stefanus Mantik 
Date: December 9, 1996  
Address: Los Angeles  
Affiliation: University of California,  
Abstract: Fast multiplication can be constructed by combining the tree structure of multiplication's addition, i.e. Wallace tree, with the parallel on-the-fly conversion to have a multiplication without using any carry propagation adder at the end. This parallel on-the-fly conversion speeds up the conversion of redundant binary to conventional binary. With the delay of n 4 , we can have the conversion from redundant binary to conventional digit faster than regular Carry Propagation Adder.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M.D. Ercegovac and T. Lang, </author> <title> "Fast Multiplication Without Carry-Propagate Addition", </title> <journal> IEEE Trans. Computers Vol. </journal> <volume> 39, No. 11, </volume> <pages> pp. 1385-1390, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: As we know, using CPA in our final addition will cost us a lot in time due to its significant delay. Thus, several research have been done in order to find another way to do fast multiplication. A new method of partial product addition is proposed by <ref> [1] </ref> where the addition is now done from left-to-right instead of the conventional right-to-left. They proposed the use of On-the-fly Conversion (OTF) for converting the redundant binary digit to conventional digit one at a time. <p> Then for every new digit calculated, the next value of A and B is determined by Next digit = ( -1, A B, concat A and B with 1 0, concat A with 0 and B with 1 1, B A, concat A and B with 1 Both <ref> [1] </ref> and [2] uses one variable to store the result and then determine whether to keep the value or decrement it. They store the result in A i and wait for the value of P i+1 , where P i+1 is the next digit in redundant binary form.
Reference: [2] <author> L. Ciminiera and P. Montuschi, </author> <title> "Carry-Save Multiplication Scheme Without Final Addition", </title> <journal> IEEE Trans. Computers Vol. </journal> <volume> 45, No. 9, </volume> <pages> pp. 1050-1055, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: If we limit our precision with the input precision, after N step (where N is the number of precision), we will have the result without doing anymore addition using CPA. The extension of this scheme is proposed by <ref> [2] </ref> where the result is in full precision. Unfortunately, this scheme works only if we have at least N steps in partial product addition because the OTF works only for one digit at a time. <p> Then for every new digit calculated, the next value of A and B is determined by Next digit = ( -1, A B, concat A and B with 1 0, concat A with 0 and B with 1 1, B A, concat A and B with 1 Both [1] and <ref> [2] </ref> uses one variable to store the result and then determine whether to keep the value or decrement it. They store the result in A i and wait for the value of P i+1 , where P i+1 is the next digit in redundant binary form.
Reference: [3] <author> H. Makino, Y. Nakase, H. Suzuki, H. Morinaka, H. Shinohara, and K. Mashiko, </author> <title> "An 8.8-ns 54x54-Bit Multiplier with Hight Speed Redundant Binary Architecture", </title> <journal> IEEE Journal of Solid-State Circuit Vol. </journal> <volume> 31, No. 6, </volume> <pages> pp. 773-783, </pages> <month> June </month> <year> 1996. </year> <month> 7 </month>
Reference-contexts: There are many RBA schemes available for use but for the simplicity of the design I will use the scheme proposed by <ref> [3] </ref>. In fact, their scheme also works fast in doing 4-to-2 reduction (addition with four operands at one time). [3] proposed a new method of doing addition where instead of using straight forward addition of A + B, we can change the implementation into A + B = A (B) where <p> There are many RBA schemes available for use but for the simplicity of the design I will use the scheme proposed by <ref> [3] </ref>. In fact, their scheme also works fast in doing 4-to-2 reduction (addition with four operands at one time). [3] proposed a new method of doing addition where instead of using straight forward addition of A + B, we can change the implementation into A + B = A (B) where converting into two's complement notation we can have A + B = A B 1. <p> So the addition steps itself is reduced by half. In order to maintain the simplicity of the explanation, I will use the same notation that <ref> [3] </ref> uses where the redundant digit is represented as (a i ; b i ) a i b i and rule of addition is (a + i ) + (b + i ) ! (d + i ).
References-found: 3

