URL: ftp://ic.eecs.berkeley.edu/pub/HWSW/publications/UCB-ERL-96-12.ps.gz
Refering-URL: http://www-cad.eecs.berkeley.edu/research/hsc/publications.html
Root-URL: 
Title: Evaluation of trade-offs in the design of embedded systems via co-simulation  
Author: Claudio Passerone Massimiliano Chiodo Wilsin Gosti Luciano Lavagno Alberto Sangiovanni-Vincentelli 
Abstract: Current design methodologies for embedded systems often force the designer to evaluate early in the design process architectural choices that will heavily impact the cost and performance of the final product. Examples of these choices are hardware/software partitioning, choice of the micro-controller, and choice of a run-time scheduling method. This paper describes how to help the designer in this task, by providing a flexible co-simulation environment in which these alternatives can be interactively evaluated. Our approach is based on the Ptolemy co-simulation framework, but it uses a different modeling paradigm, well suited for control-dominated reactive systems (asynchronous extended Finite State Machines called CFSMs). We build on previous research on software synthesis and cost estimation to provide the designer with fast but reasonably accurate performance data. We demonstrate the effectiveness of the approach by showing the result of the trade-off analysis on a dashboard control system.
Abstract-found: 1
Intro-found: 1
Reference: [BCG91] <author> G. Berry, P. Couronne, and G. Gonthier. </author> <title> The synchronous approach to reactive and real-time systems. </title> <journal> IEEE Proceedings, </journal> <volume> 79, </volume> <month> September </month> <year> 1991. </year>
Reference-contexts: The design flow that is currently implemented in the POLIS system is depicted in 1. High Level Language Translation In the POLIS environment designers write their specifications in a high level language (e.g., ESTEREL <ref> [BCG91] </ref>, State-Charts [DH89], subsets of Verilog or VHDL) that can be directly translated into CFSMs. 2. Design Partitioning Design partitioning is the process of choosing a software or hardware implementation for each CFSM in the system specification.
Reference: [BHJ + 96] <author> F. Balarin, H. Hsieh, A. Jurecska, L. Lavagno, and A. Sangiovanni-Vincentelli. </author> <title> Formal verification of embedded systems based on CFSM networks. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <year> 1996. </year>
Reference: [BHLM90] <author> J. Buck, S. Ha, E.A. Lee, and D.G. Masserschmitt. Ptolemy: </author> <title> a framework for simulating and prototyping heterogeneous systems. </title> <journal> Interntional Journal of Computer Simulation, special issue on Simulation Software Development, </journal> <month> January </month> <year> 1990. </year>
Reference: [BRX93] <author> E. Barros, W. Rosenstiel, and X. Xiong. </author> <title> Hardware/software partitioning with UNITY. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: Past work in the area of performance prediction and trade-off evaluation has focused mostly on elaborate cost models to guide automated partitioning algorithms ([KAJW93], [VG92], [HEHB94], [HDMT94], <ref> [BRX93] </ref>, [KL94], : : : ), or on co-simulation methods in which a rather detailed model of the processor may be required.
Reference: [Buc93] <author> J. T. Buck. </author> <title> Scheduling Dynamic Dataflow Graphs with Bounded Memory Using the Token Flow Model. </title> <type> PhD thesis, </type> <institution> U.C. Berkeley, </institution> <year> 1993. </year> <note> UCB/ERL Memo M93/69. </note>
Reference: [CCG + 96] <author> S. Cardelli, M. Chiodo, P. Giusto, A. Jurecska, L. Lavagno, and A. Sangiovanni-Vincentelli. </author> <title> Rapid-prototyping of embedded systems via 17 reprogrammable devices. </title> <booktitle> In 7th IEEE International Workshop on Rapid System Prototyping, </booktitle> <year> 1996. </year>
Reference-contexts: The results for the dashboard simulation, using various types of architectural choices, are reported in Table 1. In this case, we used estimated execution times for a Motorola 68HC11 micro-controller (which was eventually chosen for the final implementation, reported in <ref> [CCG + 96] </ref>), with a 1 MHz clock speed, and a MIPS R3000, with a 1 MHz and a 10 MHz clock speed.
Reference: [CGH + 94] <author> M. Chiodo, P. Giusto, H. Hsieh, A. Jurecska, L. Lavagno, and A. Sangiovanni-Vincentelli. </author> <title> Hardware/software codesign of embedded systems. </title> <journal> IEEE Micro, </journal> <volume> 14(4) </volume> <pages> 26-36, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Section 6 concludes the paper and outlines opportunities for future research. 2 The POLIS co-design environment Our co-simulation and trade-off evaluation method uses an existing co-design environment for reactive embedded systems, described in <ref> [CGH + 94] </ref>, for synthesizing software and hardware, and for analyzing their performance. The POLIS system is centered around a single Finite State Machine-like representation, which is well suited to our target class of control-dominated systems.
Reference: [CGH + 95] <author> M. Chiodo, P. Giusto, H. Hsieh, A. Jurecska, L. Lavagno, and A. Sangiovanni-Vincentelli. </author> <title> Synthesis of software programs from CFSM specifications. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: The detailed design flow for the co-simulation and trade-off analysis phases is as follows: 1. The control/data flow graph of every CFSM in the system specification is built, and the corresponding C code is generated (as described in <ref> [CGH + 95] </ref>). The C code also includes run time estimations for each C code statement, based on information derived from benchmark analysis of the target processor. 2. The Ptolemy language source code for every CFSM is generated.
Reference: [DH89] <author> D. Drusinski and D. Har'el. </author> <title> Using statecharts for hardware description and synthesis. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 8(7), </volume> <month> July </month> <year> 1989. </year>
Reference-contexts: The design flow that is currently implemented in the POLIS system is depicted in 1. High Level Language Translation In the POLIS environment designers write their specifications in a high level language (e.g., ESTEREL [BCG91], State-Charts <ref> [DH89] </ref>, subsets of Verilog or VHDL) that can be directly translated into CFSMs. 2. Design Partitioning Design partitioning is the process of choosing a software or hardware implementation for each CFSM in the system specification.
Reference: [GJM92] <author> R. K. Gupta, C. N. Coelho Jr., and G. De Micheli. </author> <title> Synthesis and simulation of digital systems containing interacting hardware and software components. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: A first class of co-simulation methods, proposed for example by Gupta et al. in <ref> [GJM92] </ref>, relies on a single custom simulator for hardware and software. This simulator uses a single event queue, and a high-level, bus-cycle model of the target CPU.
Reference: [HDMT94] <author> X. Hu, J.G. D'Ambrosio, B. T. Murray, and D-L Tang. </author> <title> Codesign of architectures for powertrain modules. </title> <journal> IEEE Micro, </journal> <volume> 14(4) </volume> <pages> 48-58, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Past work in the area of performance prediction and trade-off evaluation has focused mostly on elaborate cost models to guide automated partitioning algorithms ([KAJW93], [VG92], [HEHB94], <ref> [HDMT94] </ref>, [BRX93], [KL94], : : : ), or on co-simulation methods in which a rather detailed model of the processor may be required.
Reference: [HEHB94] <author> J. Henkel, R. Ernst, U. Holtmann, and T. Benner. </author> <title> Adaptation of partitioning and high-level synthesis in hardware/software co-synthesis. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: Past work in the area of performance prediction and trade-off evaluation has focused mostly on elaborate cost models to guide automated partitioning algorithms ([KAJW93], [VG92], <ref> [HEHB94] </ref>, [HDMT94], [BRX93], [KL94], : : : ), or on co-simulation methods in which a rather detailed model of the processor may be required.
Reference: [KAJW93] <author> S. Kumar, J. H. Aylor, B. Johnson, and W. Wulf. </author> <title> Exploring hardware/software abstractions and alternatives for codesign. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> October </month> <year> 1993. </year>
Reference: [KL92] <author> A. Kalavade and E. A. Lee. </author> <title> Hardware/software co-design using Ptolemy - a case study. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: If the hardware is master, then the hardware simulator calls communication procedures which in turn call user software code. A similar approach is used by Kalavade et al. in <ref> [KL92] </ref> and by Lee et al. in [LR93]. In both cases, the simulation and design environment Ptolemy (described in Section 3) is used to provide an interfacing mechanism between different domains. In [KL92] co-simulation is done: * at the specification level by using a data flow model, * at the implementation <p> A similar approach is used by Kalavade et al. in <ref> [KL92] </ref> and by Lee et al. in [LR93]. In both cases, the simulation and design environment Ptolemy (described in Section 3) is used to provide an interfacing mechanism between different domains. In [KL92] co-simulation is done: * at the specification level by using a data flow model, * at the implementation level by using a bus-cycle model of the target Digital Signal Processor and a hardware simulator, both built within Ptolemy.
Reference: [KL93] <author> A. Kalavade and E.A. Lee. </author> <title> A hardware-software codesign methodology for DSP applications. </title> <journal> IEEE Design and Test of Computers, </journal> <volume> 10(3) </volume> <pages> 16-28, </pages> <month> September </month> <year> 1993. </year>
Reference: [KL94] <author> A. Kalavade and E.A. Lee. </author> <title> A global criticality/local phase driven algorithm for the constrained hardware/software partitioning problem. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Code-sign, </booktitle> <year> 1994. </year> <month> 18 </month>
Reference-contexts: Past work in the area of performance prediction and trade-off evaluation has focused mostly on elaborate cost models to guide automated partitioning algorithms ([KAJW93], [VG92], [HEHB94], [HDMT94], [BRX93], <ref> [KL94] </ref>, : : : ), or on co-simulation methods in which a rather detailed model of the processor may be required.
Reference: [LL73] <author> C.L. Liu and James W. Layland. </author> <title> Scheduling algorithms for multipro-gramming in a hard-real-time environment. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 20(1):46 - 61, </volume> <month> January </month> <year> 1973. </year>
Reference-contexts: An application-specific OS, consisting of a scheduler and I/O drivers, is generated for each partitioned design. Currently POLIS allows the designer to choose from a set of classical scheduling algorithms (e.g. Rate-Monotonic and Deadline-Monotonic, <ref> [LL73] </ref>). 5. Interfacing Implementation Domains Interfaces between different implementation domains (hardware-software) are automatically synthesized within POLIS. These interfaces come in the form of cooperating circuits and software procedures (I/O drivers) embedded in the synthesized implementation. 6 6.
Reference: [LR93] <author> S. Lee and J.M. Rabaey. </author> <title> A hardware-software co-simulation environment. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: If the hardware is master, then the hardware simulator calls communication procedures which in turn call user software code. A similar approach is used by Kalavade et al. in [KL92] and by Lee et al. in <ref> [LR93] </ref>. In both cases, the simulation and design environment Ptolemy (described in Section 3) is used to provide an interfacing mechanism between different domains. <p> In [KL92] co-simulation is done: * at the specification level by using a data flow model, * at the implementation level by using a bus-cycle model of the target Digital Signal Processor and a hardware simulator, both built within Ptolemy. In <ref> [LR93] </ref> the specification is simulated by using concurrent processes, communicating via queues. The same message exchanging mechanism is retained in the implementation (using a mix of micro-processor-based boards, DSPs, and ASICs), thus allowing to perform co-simulation of one part of the implementation with a simulation model of the rest.
Reference: [PS91] <author> C. Y. Park and A. C. Shaw. </author> <title> Experiments with a program timing tool based on source-level timing schema. </title> <journal> IEEE Computer, </journal> <volume> 24(5) </volume> <pages> 48-57, </pages> <year> 1991. </year>
Reference-contexts: This methodology results in better optimization and tighter control of software size and timing than with a general-purpose compiler. A timing estimator quickly analyzes the program and reports code size and speed characteristics. The algorithm is similar to that used by <ref> [PS91] </ref>, but requires no user input. It uses a formula, with parameters obtained from benchmark programs, to compute the delay of each node in the control/data flow graph for various micro-controller architectures (currently MIPS R3000 and Mo-torola 68HC11 and 68332).
Reference: [Row94] <editor> J. Rowson. Hardware/software co-simulation. </editor> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 439-440, </pages> <year> 1994. </year>
Reference-contexts: This simulator uses a single event queue, and a high-level, bus-cycle model of the target CPU. A second class, described by Wilson et al. in [Wil94], by Thomas et al. in [TAS93], and by Rowson in <ref> [Row94] </ref>, loosely links a hardware simulator with a software process. Synchronization is achieved by using the standard interprocess communication mechanisms offered by the host Operating System.
Reference: [SSL + 92] <author> E. M. Sentovich, K. J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Sal-danha, H. Savoj, P. R. Stephan, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> SIS: A system for sequential circuit synthesis. </title> <type> Technical Report UCB/ERL M92/41, </type> <institution> U.C. Berkeley, </institution> <month> May </month> <year> 1992. </year>
Reference: [TAS93] <author> D.E. Thomas, J.K. Adams, and H. </author> <title> Schmit. A model and methodology for hardware-software codesign. </title> <journal> IEEE Design and Test of Computers, </journal> <volume> 10(3) </volume> <pages> 6-15, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: This simulator uses a single event queue, and a high-level, bus-cycle model of the target CPU. A second class, described by Wilson et al. in [Wil94], by Thomas et al. in <ref> [TAS93] </ref>, and by Rowson in [Row94], loosely links a hardware simulator with a software process. Synchronization is achieved by using the standard interprocess communication mechanisms offered by the host Operating System.
Reference: [tHM93] <author> K. ten Hagen and H. Meyr. Timed and untimed hardware/software cosim-ulation: </author> <title> application and efficient implementation. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: This may impose an undue burden on the implementation, e.g. if hardware and software do not need such handshaking since the hardware part in reality runs much faster than in the simulation. A third class, described in <ref> [tHM93] </ref>, keeps track of time in software and hardware independently, using various mechanisms to synchronize them periodically. If the software is master, then it decides when to send a message, tagged with the current software clock cycle, to the hardware simulator.
Reference: [VG92] <author> F. Vahid and D. G. Gajski. </author> <title> Specifcation partitioning for system design. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Efficient synchronized execution of each domain is a key element of any co-simulation methodology aimed at evaluating potential bottlenecks associated with a given hardware/software partition. Past work in the area of performance prediction and trade-off evaluation has focused mostly on elaborate cost models to guide automated partitioning algorithms ([KAJW93], <ref> [VG92] </ref>, [HEHB94], [HDMT94], [BRX93], [KL94], : : : ), or on co-simulation methods in which a rather detailed model of the processor may be required.
Reference: [Wil94] <author> J. Wilson. </author> <title> Hardware/software selected cycle solution. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <year> 1994. </year> <month> 19 </month>
Reference-contexts: This simulator uses a single event queue, and a high-level, bus-cycle model of the target CPU. A second class, described by Wilson et al. in <ref> [Wil94] </ref>, by Thomas et al. in [TAS93], and by Rowson in [Row94], loosely links a hardware simulator with a software process. Synchronization is achieved by using the standard interprocess communication mechanisms offered by the host Operating System.
References-found: 25

