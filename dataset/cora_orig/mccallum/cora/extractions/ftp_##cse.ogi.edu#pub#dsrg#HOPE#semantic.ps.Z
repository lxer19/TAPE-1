URL: ftp://cse.ogi.edu/pub/dsrg/HOPE/semantic.ps.Z
Refering-URL: http://www.cse.ogi.edu/~crispin/
Root-URL: http://www.cse.ogi.edu
Email: crispin@cse.ogi.edu  hanan@csd.uwo.ca  
Title: Formal Semantics for Expressing Optimism: The Meaning of HOPE  
Author: Crispin Cowan Hanan Lutfiyya 
Keyword: optimism, semantics of optimism, concurrency, parallelism, distributed computing, rollback.  
Date: May 19, 1995  
Address: P.O. Box 91000 Portland, OR 97291-1000  Middlesex College  Ontario London, Ontario N6A 5B7  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute  Computer Science Department  University of Western  
Abstract: Optimism is a powerful technique for increasing concurrency. A program can increase concurrency by making an optimistic assumption about its future state, and verifying the assumption in parallel with computations based on the optimistic assumption. The use of optimism has been restricted to specialized systems due to the difficulty of writing and understanding optimistic programs. In this paper, we define optimism as any computation that uses rollback. We present a formal semantics for expressing optimism by defining operations for concurrent programs to specify which optimistic computations to roll back, while automating the dependency tracking. We prove that these semantics guarantee some intuitively desirable behaviors. Finally, we describe our programming language implementation based on the semantics. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David F. Bacon and Robert E. Strom. </author> <title> Optimistic Par-allelization of Communicating Sequential Processes. </title> <booktitle> In Third ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: S 2 takes the line number and checks to see if the line number now exceeds page size. If it does, then S 2 creates a new page; otherwise execution can immediately proceed to S 3 . Bacon and Strom <ref> [1] </ref> present an algorithm for optimistically parallelizing two such statements.
Reference: [2] <author> R.G. Bubenik. </author> <title> Optimistic Computation. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: There has been a small amount of work in systems supporting optimistic programming <ref> [2, 3, 17, 20, 23, 25] </ref>. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [8]. In [25], computation based on an optimistic assumption is limited to the scope of an if or while statement. <p> In [25], computation based on an optimistic assumption is limited to the scope of an if or while statement. Randell [23] provides a similar statically scoped construct. In <ref> [2, 3] </ref>, computation based on an optimistic assumption is limited to the scope of a previously defined encapsulation. All encapsulations must be defined ahead of this time.
Reference: [3] <author> Rick Bubenik and Willy Zwaenepoel. </author> <title> Semantics of Optimistic Computation. </title> <booktitle> In 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 20-27, </pages> <year> 1990. </year>
Reference-contexts: There has been a small amount of work in systems supporting optimistic programming <ref> [2, 3, 17, 20, 23, 25] </ref>. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [8]. In [25], computation based on an optimistic assumption is limited to the scope of an if or while statement. <p> In [25], computation based on an optimistic assumption is limited to the scope of an if or while statement. Randell [23] provides a similar statically scoped construct. In <ref> [2, 3] </ref>, computation based on an optimistic assumption is limited to the scope of a previously defined encapsulation. All encapsulations must be defined ahead of this time.
Reference: [4] <author> N. Carriero and D. Gelernter. </author> <title> Linda in Context. </title> <journal> Communications of the ACM, </journal> <volume> 31(4) </volume> <pages> 444-458, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Rather, it is programming model for optimism, embodied as a set of primi tives designed to be embedded in some other programming language, similar to Linda <ref> [4] </ref>. There are very few restrictions on the kinds of distributed systems in which HOPE can be embedded. HOPE can be embedded in any system providing concurrent processes that communicate with messages.
Reference: [5] <author> G. V. Cormack. </author> <title> A formalism for real-time distributed lock-free conference editing. </title> <type> private communication. </type>
Reference-contexts: We will also extend the application of optimism beyond its traditional domains [16, 26] into new areas such as truth maintenance systems [12], numerical computation [7] and co-operative work <ref> [5] </ref>. 8 ACKNOWLEDGMENTS HOPE was inspired by optimism studies at the IBM T.J. Watson Research Center. The initial inspiration for HOPE came from discussions with Robert E. Strom.
Reference: [6] <author> Crispin Cowan. </author> <title> Optimistic Replication in HOPE. </title> <booktitle> In Proceedings of the 1992 CAS Conference, </booktitle> <pages> pages 269-282, </pages> <address> Toronto, Ontario, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: If p i is forced to rollback, then p j must also rollback to undo the events triggered by the messages, otherwise an inconsistent state is produced. Optimism has been used in various areas to enhance performance <ref> [6, 15, 24, 26] </ref>. However, optimism is mostly embedded inside systems, and not exposed to the applications programmer. Optimism is not often used in applications because optimistic programs are difficult to write. <p> The verification criteria can also be selected at run time. Furthermore, affirmation and denial of optimistic assumptions, as well as making further optimistic assumptions, can all be performed by computations that are themselves optimistic. In previous work, we have defined the HOPE programming model and it's applicability <ref> [6, 10, 22] </ref>. We have also constructed a prototype HOPE system [7, 8, 11]. This paper presents the formal semantics of the HOPE programming model. The rest of this paper is organized as follows. Section 2 describes related work. <p> This information could be used to optimize checkpointing, broadening the applicability of HOPE to finer-grained problems. In future applied work, we will apply HOPE to the problem of optimistic concurrency control of replicated data <ref> [6] </ref>. A local cached replica of a piece of data can greatly reduce the latency of access to that data, and optimistically assuming consistency can reduce the latency of updating replicated data.
Reference: [7] <author> Crispin Cowan. </author> <title> Optimistic Programming in PVM. </title> <booktitle> In Proceedings of the 2nd PVM User's Group Meeting, </booktitle> <institution> Oak Ridge, TN, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: Furthermore, affirmation and denial of optimistic assumptions, as well as making further optimistic assumptions, can all be performed by computations that are themselves optimistic. In previous work, we have defined the HOPE programming model and it's applicability [6, 10, 22]. We have also constructed a prototype HOPE system <ref> [7, 8, 11] </ref>. This paper presents the formal semantics of the HOPE programming model. The rest of this paper is organized as follows. Section 2 describes related work. Section 3 informally describes our programming model for expressing optimism, and provides an example program. <p> We have also proven some intuitively desirable behaviors of the primitives are guaranteed by the semantics of the primitives. HOPE is not just a theory: a prototype HOPE system exists <ref> [7, 8, 9] </ref>, built on top of the PVM system [13]. HOPE processes are PVM tasks (UNIX processes for the most part), assumption identifiers are implemented as AID tasks, and the HOPE dependency tracking algorithms are implemented using PVM messages. <p> We will also extend the application of optimism beyond its traditional domains [16, 26] into new areas such as truth maintenance systems [12], numerical computation <ref> [7] </ref> and co-operative work [5]. 8 ACKNOWLEDGMENTS HOPE was inspired by optimism studies at the IBM T.J. Watson Research Center. The initial inspiration for HOPE came from discussions with Robert E. Strom.
Reference: [8] <author> Crispin Cowan. </author> <title> A Programming Model for Optimism. </title> <type> PhD thesis, </type> <institution> University of Western Ontario, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Furthermore, affirmation and denial of optimistic assumptions, as well as making further optimistic assumptions, can all be performed by computations that are themselves optimistic. In previous work, we have defined the HOPE programming model and it's applicability [6, 10, 22]. We have also constructed a prototype HOPE system <ref> [7, 8, 11] </ref>. This paper presents the formal semantics of the HOPE programming model. The rest of this paper is organized as follows. Section 2 describes related work. Section 3 informally describes our programming model for expressing optimism, and provides an example program. <p> There has been a small amount of work in systems supporting optimistic programming [2, 3, 17, 20, 23, 25]. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation <ref> [8] </ref>. In [25], computation based on an optimistic assumption is limited to the scope of an if or while statement. Randell [23] provides a similar statically scoped construct. In [2, 3], computation based on an optimistic assumption is limited to the scope of a previously defined encapsulation. <p> We have also proven some intuitively desirable behaviors of the primitives are guaranteed by the semantics of the primitives. HOPE is not just a theory: a prototype HOPE system exists <ref> [7, 8, 9] </ref>, built on top of the PVM system [13]. HOPE processes are PVM tasks (UNIX processes for the most part), assumption identifiers are implemented as AID tasks, and the HOPE dependency tracking algorithms are implemented using PVM messages.
Reference: [9] <author> Crispin Cowan. </author> <title> HOPE: Hopefully Optimistic Programming Environment. Prototype implementation, </title> <note> avial-able via FTP from ftp://ftp.csd.uwo.ca/pub/src/hope.tar.Z, </note> <month> January </month> <year> 1995. </year>
Reference-contexts: We have also proven some intuitively desirable behaviors of the primitives are guaranteed by the semantics of the primitives. HOPE is not just a theory: a prototype HOPE system exists <ref> [7, 8, 9] </ref>, built on top of the PVM system [13]. HOPE processes are PVM tasks (UNIX processes for the most part), assumption identifiers are implemented as AID tasks, and the HOPE dependency tracking algorithms are implemented using PVM messages.
Reference: [10] <author> Crispin Cowan, Hanan Lutfiyya, and Mike Bauer. </author> <title> Increasing Concurrency Through Optimism: A Reason for HOPE. </title> <booktitle> In Proceedings of the 1994 ACM Computer Science Conference, </booktitle> <pages> pages 218-225, </pages> <address> Phoenix, Arizona, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: Sometimes, it is subtle, such as the concurrency introduced between the volatile and stable-storage components of a fault-tolerant application. A program increases its concurrency by making an optimistic assumption about its future state and verifying the assumption in parallel with computations based on the optimistic assumption <ref> [10] </ref>. If a computation proceeds based on an optimistic assumption and that assumption is shown to be incorrect, then all computations predicated on that assumption must be rolled back to correct for the incorrect assumption. <p> The verification criteria can also be selected at run time. Furthermore, affirmation and denial of optimistic assumptions, as well as making further optimistic assumptions, can all be performed by computations that are themselves optimistic. In previous work, we have defined the HOPE programming model and it's applicability <ref> [6, 10, 22] </ref>. We have also constructed a prototype HOPE system [7, 8, 11]. This paper presents the formal semantics of the HOPE programming model. The rest of this paper is organized as follows. Section 2 describes related work. <p> The pessimistic program in this example specifies the meaning of the optimistic constructs being illustrated. A program increases its concurrency by making an optimistic assumption about its future state and verifying the assumption in parallel with computations based on the assumption <ref> [10] </ref>. If a computation proceeds based on an assumption and that assumption is shown to be incorrect, then all computations predicated on that assumption must be rolled back to correct for the incorrect assumption.
Reference: [11] <author> Crispin Cowan, Hanan Lutfiyya, and Mike Bauer. </author> <title> Performance Benefits of Optimistic Programming: A Measure of HOPE. </title> <booktitle> In Fourth IEEE International Symposium on High-Performance Distributed Computing (HPDC-4), </booktitle> <month> August </month> <year> 1995. </year>
Reference-contexts: Furthermore, affirmation and denial of optimistic assumptions, as well as making further optimistic assumptions, can all be performed by computations that are themselves optimistic. In previous work, we have defined the HOPE programming model and it's applicability [6, 10, 22]. We have also constructed a prototype HOPE system <ref> [7, 8, 11] </ref>. This paper presents the formal semantics of the HOPE programming model. The rest of this paper is organized as follows. Section 2 describes related work. Section 3 informally describes our programming model for expressing optimism, and provides an example program. <p> Of particular note is the fact that the implementation never forces a user process to wait for a HOPE dependency tracking message before proceeding. Preliminary performance studies show that the prototype can deliver performance gains of up to 80% using the Call Streaming protocol to avoid RPC latency <ref> [11] </ref>. To facilitate practical programming, the prototype supports a richer set of dependency tracking facilities than those presented here.
Reference: [12] <author> J. Doyle. </author> <title> A Truth Maintenance System. </title> <journal> Artificial Intelligence, </journal> <volume> 12 </volume> <pages> 231-272, </pages> <year> 1979. </year>
Reference-contexts: We will also extend the application of optimism beyond its traditional domains [16, 26] into new areas such as truth maintenance systems <ref> [12] </ref>, numerical computation [7] and co-operative work [5]. 8 ACKNOWLEDGMENTS HOPE was inspired by optimism studies at the IBM T.J. Watson Research Center. The initial inspiration for HOPE came from discussions with Robert E. Strom.
Reference: [13] <author> Al Geist, Adam Geguelin, Jack Dongarra, Wicheng Jiang, Robert Manchek, and Vaidy Sunderam. </author> <title> PVM: Parallel Virtual Machine, a Users' Guide and Tutorial for Networked Parallel Computing. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: We have also proven some intuitively desirable behaviors of the primitives are guaranteed by the semantics of the primitives. HOPE is not just a theory: a prototype HOPE system exists [7, 8, 9], built on top of the PVM system <ref> [13] </ref>. HOPE processes are PVM tasks (UNIX processes for the most part), assumption identifiers are implemented as AID tasks, and the HOPE dependency tracking algorithms are implemented using PVM messages.
Reference: [14] <author> Arthur Goldberg, Ajei Gopal, Kong Li, Rob Strom, and David F. Bacon. </author> <title> Transparent Recovery of Mach Applications. </title> <booktitle> In First USENIX Mach Workshop, </booktitle> <address> Burlington, VT, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Finally, section 7 presents our conclusions and future research. 2 RELATED WORK Use of optimism has largely been limited to embedded systems. For instance, numerous optimistic recovery protocols have been designed [24, 18, 19], and a few have even been implemented <ref> [14] </ref>. These protocols allow separate components of a distributed system to asynchronously checkpoint their state while retaining the ability to recover the whole system to a consistent state.
Reference: [15] <author> Arthur P. Goldberg. </author> <title> Optimistic Algorithms for Distributed Transparent Process Replication. </title> <type> PhD thesis, </type> <institution> University of California at Los Angeles, </institution> <year> 1991. </year> <note> (UCLA Tech. Report CSD-910050). </note>
Reference-contexts: If p i is forced to rollback, then p j must also rollback to undo the events triggered by the messages, otherwise an inconsistent state is produced. Optimism has been used in various areas to enhance performance <ref> [6, 15, 24, 26] </ref>. However, optimism is mostly embedded inside systems, and not exposed to the applications programmer. Optimism is not often used in applications because optimistic programs are difficult to write.
Reference: [16] <author> D. Jefferson. </author> <title> Virtual Time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(7) </volume> <pages> 404-425, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: A local cached replica of a piece of data can greatly reduce the latency of access to that data, and optimistically assuming consistency can reduce the latency of updating replicated data. We will also extend the application of optimism beyond its traditional domains <ref> [16, 26] </ref> into new areas such as truth maintenance systems [12], numerical computation [7] and co-operative work [5]. 8 ACKNOWLEDGMENTS HOPE was inspired by optimism studies at the IBM T.J. Watson Research Center. The initial inspiration for HOPE came from discussions with Robert E. Strom.
Reference: [17] <author> D. Jefferson and A. Motro. </author> <title> The Time Warp Mechanism for Database Concurrency Control. </title> <type> Report Technical Report TR-84-302, </type> <institution> University of Southern California, </institution> <month> January </month> <year> 1984. </year>
Reference-contexts: There has been a small amount of work in systems supporting optimistic programming <ref> [2, 3, 17, 20, 23, 25] </ref>. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [8]. In [25], computation based on an optimistic assumption is limited to the scope of an if or while statement. <p> All encapsulations must be defined ahead of this time. This means that dependency tracking is not necessary, but it also means that the range of computation based on an optimistic assumption is statically bound. In Time Warp <ref> [17] </ref>, on the other hand, the amount of computation based on a optimistic assumption is not statically bound. However, only one kind of optimistic assumption can be made, which is that messages arrive at each process in time-stamp order, reflecting a presumption of a globally synchronized clock.
Reference: [18] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Recovery in Distributed Systems using Optimistic Message Logging and Checkpointing. </title> <journal> J. Algorithms, </journal> <volume> 11(3) </volume> <pages> 462-491, </pages> <month> Septem-ber </month> <year> 1990. </year>
Reference-contexts: Finally, section 7 presents our conclusions and future research. 2 RELATED WORK Use of optimism has largely been limited to embedded systems. For instance, numerous optimistic recovery protocols have been designed <ref> [24, 18, 19] </ref>, and a few have even been implemented [14]. These protocols allow separate components of a distributed system to asynchronously checkpoint their state while retaining the ability to recover the whole system to a consistent state.
Reference: [19] <author> T.T.Y. Juang and S. Venkatesan. </author> <title> Efficient Algorithm for Crash Recovery in Distributed Systems. </title> <booktitle> In 10th Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 349-361, </pages> <year> 1990. </year>
Reference-contexts: Finally, section 7 presents our conclusions and future research. 2 RELATED WORK Use of optimism has largely been limited to embedded systems. For instance, numerous optimistic recovery protocols have been designed <ref> [24, 18, 19] </ref>, and a few have even been implemented [14]. These protocols allow separate components of a distributed system to asynchronously checkpoint their state while retaining the ability to recover the whole system to a consistent state.
Reference: [20] <author> Jonathan I. Leivent and Ronald J. Watro. </author> <title> Mathematical Foundations for Time Warp Systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(5) </volume> <pages> 771-794, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: There has been a small amount of work in systems supporting optimistic programming <ref> [2, 3, 17, 20, 23, 25] </ref>. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [8]. In [25], computation based on an optimistic assumption is limited to the scope of an if or while statement.
Reference: [21] <author> Hanan Lutfiyya and Crispin Cowan. </author> <title> Language Support for the Application-Oriented Fault Tolerance Paradigm. </title> <note> To be submitted for review, </note> <year> 1995. </year>
Reference-contexts: The use of such tagges messages ensures that HOPE programs remain globally consistent, even in the presence of rollback of some processes <ref> [21] </ref>. In future theoretical work, we are studying ways to specify the meaning of HOPE in a more denotational style. The operational semantics presented here were invaluable in the construction of the HOPE system, but are awkward for reasoning about optimistic programs.
Reference: [22] <author> Hanan Lutfiyya and Crispin Cowan. </author> <title> Optimistic Language Constructs. </title> <booktitle> In ICSE-17 Workshop on Research Issues in the Intersection of Software Engineering and Programming Languages, </booktitle> <address> Seattle, WA, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: The verification criteria can also be selected at run time. Furthermore, affirmation and denial of optimistic assumptions, as well as making further optimistic assumptions, can all be performed by computations that are themselves optimistic. In previous work, we have defined the HOPE programming model and it's applicability <ref> [6, 10, 22] </ref>. We have also constructed a prototype HOPE system [7, 8, 11]. This paper presents the formal semantics of the HOPE programming model. The rest of this paper is organized as follows. Section 2 describes related work.
Reference: [23] <author> B. Randell. </author> <title> System Structure for Software Fault Tolerance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(2) </volume> <pages> 226-232, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: There has been a small amount of work in systems supporting optimistic programming <ref> [2, 3, 17, 20, 23, 25] </ref>. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [8]. In [25], computation based on an optimistic assumption is limited to the scope of an if or while statement. <p> However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [8]. In [25], computation based on an optimistic assumption is limited to the scope of an if or while statement. Randell <ref> [23] </ref> provides a similar statically scoped construct. In [2, 3], computation based on an optimistic assumption is limited to the scope of a previously defined encapsulation. All encapsulations must be defined ahead of this time.
Reference: [24] <author> R.E. Strom and S. Yemini. </author> <title> Optimistic Recovery in Dis--tributed Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: If p i is forced to rollback, then p j must also rollback to undo the events triggered by the messages, otherwise an inconsistent state is produced. Optimism has been used in various areas to enhance performance <ref> [6, 15, 24, 26] </ref>. However, optimism is mostly embedded inside systems, and not exposed to the applications programmer. Optimism is not often used in applications because optimistic programs are difficult to write. <p> Finally, section 7 presents our conclusions and future research. 2 RELATED WORK Use of optimism has largely been limited to embedded systems. For instance, numerous optimistic recovery protocols have been designed <ref> [24, 18, 19] </ref>, and a few have even been implemented [14]. These protocols allow separate components of a distributed system to asynchronously checkpoint their state while retaining the ability to recover the whole system to a consistent state.
Reference: [25] <author> Thomas Strothotte. </author> <title> Temporal Constructs for an Algorithmic Language. </title> <type> PhD thesis, </type> <institution> McGill University, </institution> <year> 1984. </year>
Reference-contexts: There has been a small amount of work in systems supporting optimistic programming <ref> [2, 3, 17, 20, 23, 25] </ref>. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [8]. In [25], computation based on an optimistic assumption is limited to the scope of an if or while statement. <p> There has been a small amount of work in systems supporting optimistic programming [2, 3, 17, 20, 23, 25]. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [8]. In <ref> [25] </ref>, computation based on an optimistic assumption is limited to the scope of an if or while statement. Randell [23] provides a similar statically scoped construct. In [2, 3], computation based on an optimistic assumption is limited to the scope of a previously defined encapsulation.
Reference: [26] <author> P. Triantafillou and D.J. Taylor. </author> <title> A New Paradigm for High Availability and Efficiency in Replicated and Distributed Databases. </title> <booktitle> In 2nd IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 136-143, </pages> <month> Decem-ber </month> <year> 1990. </year>
Reference-contexts: If p i is forced to rollback, then p j must also rollback to undo the events triggered by the messages, otherwise an inconsistent state is produced. Optimism has been used in various areas to enhance performance <ref> [6, 15, 24, 26] </ref>. However, optimism is mostly embedded inside systems, and not exposed to the applications programmer. Optimism is not often used in applications because optimistic programs are difficult to write. <p> A local cached replica of a piece of data can greatly reduce the latency of access to that data, and optimistically assuming consistency can reduce the latency of updating replicated data. We will also extend the application of optimism beyond its traditional domains <ref> [16, 26] </ref> into new areas such as truth maintenance systems [12], numerical computation [7] and co-operative work [5]. 8 ACKNOWLEDGMENTS HOPE was inspired by optimism studies at the IBM T.J. Watson Research Center. The initial inspiration for HOPE came from discussions with Robert E. Strom.
References-found: 26

