URL: http://www.cs.jhu.edu/~kumar/thesis.ps.Z
Refering-URL: http://www.cs.jhu.edu/~kumar/
Root-URL: http://www.cs.jhu.edu
Title: Geometric Data Structures and Applications  
Author: Kumar Ramaiyer 
Degree: A dissertation submitted to The  in conformity with the requirement for the degree of Doctor of Philosophy.  
Note: Copyright c 1996 by Kumar Ramaiyer, All rights reserved.  
Date: 1996  
Affiliation: Johns Hopkins University  Baltimore, Maryland  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. Adel'son-Vel'skii and E. Landis. </author> <title> An algorithm for the organization of information. </title> <journal> Soviet Math. Dokl., </journal> <volume> 3 </volume> <pages> 1259-1262, </pages> <year> 1962. </year>
Reference-contexts: Incidentally, this is also the approach used by Chiang and Tamassia [37], albeit in a different way. Let us assume, for the time being, that the x-coordinates of the segment endpoints are integers in the range <ref> [1; n] </ref> (we will show later how to get around this restriction using the BB [ff] tree). We define our structure recursively, following the general approach of Preparata [103]. <p> In this case we divide t into two by a vertical line down the "middle" (we choose a vertical line through the vertex inside the vertical slab determined by the boundaries of t , but the vertical line x = x 0 2 <ref> [1; n] </ref> is determined globally as described later) of t , an action we refer to as a vertical cut. This creates two new trapezoids t l and t r that are ordered by the "right of" relation. <p> We stress here that the vertical cuts are global, and they form a complete balanced tree whose nodes correspond to the vertices of the subdivision, in x-sorted order with x values being integers in the range <ref> [1; n] </ref>. Hence, a trapezoid may be cut vertically at some x 0 even though it may not contain a vertex with x-coordinate at x 0 (see Fig. 2.19, where two trapezoids are cut vertically at x = f even though only one trapezoid has a vertex at that x-value). <p> Noting that w (r) is O (n log n) (see [103]) and depth (t ) is O (log n) (since our primary data 69 structure is a tree of vertical cuts that forms a complete balanced tree on integers in the range <ref> [1; n] </ref>) gives us the desired result that a point location query takes O (log n) time. We now turn to the problem of implementing our update operations. <p> We detailed the updating of the dictionaries 's for f 1 and f 2 in each of the cases. Therefore, the overall complexity of insert operation is O (log n). Thus, we show, Lemma 2.4.1: Given a convex subdivision S of n vertices with integer x-coordinates in the range <ref> [1; n] </ref>, there exists a data structure of O (n log n) space that allows point location queries in O (log n) time, and vertex/edge insertion in O (log n) time. 77 2.4.5 Edge Deletion Consider an edge deletion operation delete (t; e; f; f 1 ; f 2 ; v <p> This leads to a O (log 2 n) time algorithm for deletion. Lemma 2.4.2: Given a convex subdivision S of n vertices with integer x-coordinates in the range <ref> [1; n] </ref>, there exists a data structure of O (n log n) space that allows for vertex/edge insertion in O (log n) time, and vertex/edge deletion in O (log 2 n) time. There is a type of deletion that runs in O (log n) time, however. <p> All other cases of deletion, including the recursive calls, can be bounded within O (log n) time. 85 2.4.6 Rebalancing the Primary Structure In this section we show how to relax the constraint that the endpoints have integer x coordinates in the range <ref> [1; n] </ref>. We use a BB [ff]-tree as a tree for vertical cuts with a biased finger tree as a secondary structure in each node. We briefly review the properties of BB [ff]-tree. <p> Splay trees are self-adjusting binary trees, 126 and they form a simple and very interesting class of "balanced" binary search trees. We highlight the term balanced, because, unlike other binary search trees such as AVL trees <ref> [1] </ref> or red-black trees [66, 118], splay trees do not enforce explicit global structural constraints.
Reference: [2] <author> P. Agarwal. </author> <title> Private Communication. </title>
Reference-contexts: Kung, Luccio, and Preparata [81] showed that 3-dimensional maxima set problem can be solved in O (n log n) time. It appears that 3-dimensional layers of maxima problem can be solved for a 3-dimensional point set S in O (n log n log log n) time <ref> [2] </ref> using the dynamic fractional cascading technique of Mehlhorn and Naher [94]. We show how to solve the 3-dimensional layers-of-maxima problem in O (n log n) time, which is optimal 6 .
Reference: [3] <author> A. Aggarwal and J. Park. </author> <title> Notes on searching in multidimensional monotone arrays. </title> <booktitle> In Proc. 29th Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 497-512, </pages> <year> 1988. </year>
Reference-contexts: We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the three-dimensional layers-of-maxima problem <ref> [3, 28, 51, 81] </ref> and also give improved methods for dynamic point location in a convex subdivision [37, 103]. The space-sweeping algorithm makes use of dynamic point location in a staircase subdivision, which we deal with as a special case of point location in convex subdivision.
Reference: [4] <author> A. Aggarwal and J. Vitter. </author> <title> The input/output complexity of sorting and related problems. </title> <journal> Communications of the ACM, </journal> <volume> 31(9) </volume> <pages> 1116-1127, </pages> <year> 1988. </year>
Reference-contexts: involve any geometry, its usage (mainly as secondary structure) in applications in other areas, needs to be explored. 91 Chapter 3 Topology B-Trees and Applications 3.1 Introduction The B-tree [43, 68, 82, 87] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [4, 7, 64, 74, 99, 102, 116, 122] </ref>. Indeed, in his well-known survey paper [43], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [57], which is an elegant internal-memory method for maintaining unbalanced binary trees. 92 Before we describe our specific results, let us review the model for external memory <ref> [4, 64, 74, 99, 102, 116, 122] </ref> that we will be assuming throughout this chapter. 3.1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, to compensate for this
Reference: [5] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> Data Structures and Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: Another important variant concerns the case when each item i in the search tree is given a weight, w i . This weight is a positive integer that may be proportional to an access probability, as in an optimal binary search tree structure <ref> [5, 78] </ref>. Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [114] (that itself has many applications [41, 53, 60]) or in a point location structure built using the trapezoid method [37, 103, 108]. <p> They [14] actually introduce two kinds of biased search trees namely locally biased and globally biased search trees. 11 operations on trees (consistent with the total order). Aho, Hopcroft, and Ullman <ref> [5] </ref> refer to these as the concatenable queue operations. Table 2.1: Summary of Time Bounds for Biased Tree Operations. <p> This bias property is same as what Bent, Sleator, and Tarjan [14] define as global bias. We now review the standard rotations one performs to balance a binary search tree <ref> [5, 44, 78] </ref>. Consider the two configurations of a structure shown in Figure 2.2, where 15 A, B, and C, are arbitrary subtrees and x and y are two nodes. <p> We account for the complexity of the update operations using these credits. An update operation spends one credit to complete a single primitive operation (like a compare operation, basic arithmetic operation, moving along one edge of the tree, etc.) on our underlying computational model, i.e., the RAM model <ref> [5, 44] </ref>. We show that each update operation completes the update and rebalancing, and restores the credit invariants, using a number of credits asymptotically equal to our claimed amortized time complexity. 4 This credit notion is only used for analysis purposes.
Reference: [6] <author> N. M. Amato, M. T. Goodrich, and E. A. Ramos. </author> <title> Parallel algorithms for higher-dimensional convex hulls. </title> <booktitle> In Proc. 35th Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 683-694, </pages> <year> 1994. </year>
Reference-contexts: They further improve the space bound of our method to be linear, however, while still keeping very close to the 2dlog ne query time. Goodrich et. al. [62] use the ideas of *-cutting [70, 90], semi-net <ref> [6, 29] </ref>, and the general theory of geometric range spaces [6, 31, 61, 88] to improve the space for the point location method. <p> They further improve the space bound of our method to be linear, however, while still keeping very close to the 2dlog ne query time. Goodrich et. al. [62] use the ideas of *-cutting [70, 90], semi-net [6, 29], and the general theory of geometric range spaces <ref> [6, 31, 61, 88] </ref> to improve the space for the point location method.
Reference: [7] <author> L. Arge. </author> <title> The buffer tree: A new technique for optimal i/o algorithms. </title> <booktitle> In Proc. on Fourth Workshop on Algorithms and Data Structures, </booktitle> <year> 1995. </year>
Reference-contexts: involve any geometry, its usage (mainly as secondary structure) in applications in other areas, needs to be explored. 91 Chapter 3 Topology B-Trees and Applications 3.1 Introduction The B-tree [43, 68, 82, 87] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [4, 7, 64, 74, 99, 102, 116, 122] </ref>. Indeed, in his well-known survey paper [43], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees.
Reference: [8] <author> S. Arya and D. Mount. </author> <title> Approximate range searching. </title> <booktitle> In Proc. 11th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 172-181, </pages> <year> 1995. </year>
Reference-contexts: To represent a collection of points in d dimensions, where d is a fixed constant, and to answer queries like nearest neighbor, closest pair, range searching, several data structures like K-D tree [15], range trees [17, 86], quad trees [111, 112], and several variations <ref> [8, 10, 4 20, 26, 59] </ref> have been proposed. The segment tree [16] is a very useful data structure to represent a collection of segments and to answer questions about them, and the interval tree [49, 91] is very useful for maintaining a collection of intervals. <p> We support this query under the operations of insertion and deletion of points in S. Approximate range searching <ref> [8] </ref>: given a set S of n points in IR d , where d is fixed constant, preprocess the points the answer the queries of the following form: given a bounded range Q of diameter s and * &gt; 0, return a count of all the points lying within Q, but <p> Arya and Mount <ref> [8] </ref> first introduced this problem, and they give an internal memory solution. They preprocess the point set to construct a data structure called balanced box-decomposition tree to answer the queries. The preprocessing time is O (n log n), and the space is linear.
Reference: [9] <author> S. Arya and D. M. Mount. </author> <title> Approximate nearest neighbor queries in fixed dimensions. </title> <booktitle> In Proc. 4th ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 271-280, </pages> <year> 1993. </year>
Reference-contexts: In addition, we show that each of the operations on dynamic expression trees require O (log B N ) block i/o's 10 . Finally, using these primitives, we design optimal external-memory methods for solving the following geometric problems: Approximate nearest neighbor <ref> [9, 10] </ref>: given a set S of points in IR d , for fixed d, a query point p, a metric L t , and a parameter *, find a point q in S that is within distance at most (1 + *) times the distance of the actual nearest neighbor <p> A full history of this problem can be found in the papers by Arya et. al. <ref> [9, 10] </ref>. Here we briefly outline the previous work done on this and related problems. The exact nearest neighbor (also known as post office problem) can be solved by a simple brute-force method which compares the query point with every point in S. This takes linear time, which is prohibitive. <p> But this method requires space roughly equal to O (N dd=2e ) [39], which becomes impractical even for small dimensions. With linear space it is conjectured <ref> [9, 89] </ref> that (N 11=bd=2c ) is a lower bound for the exact nearest neighbor problem. <p> But this method requires space roughly equal to O (N dd=2e ) [39], which becomes impractical even for small dimensions. With linear space it is conjectured [9, 89] that (N 11=bd=2c ) is a lower bound for the exact nearest neighbor problem. Arya and Mount <ref> [9] </ref> first presented a (static) linear-space data structure for the approximate nearest neighbor problem that answered queries in O (log 3 N ) time, which was later improved by Arya et al. [10] to O (log N ) time and they also made the data structure dynamic.
Reference: [10] <author> S. Arya, D. M. Mount, N. S. Netanyahu, R. Silverman, and A. Wu. </author> <title> An optimal algorithm for approximate nearest neighbor searching. </title> <booktitle> In Proc. 5th ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 573-582, </pages> <year> 1994. </year>
Reference-contexts: To represent a collection of points in d dimensions, where d is a fixed constant, and to answer queries like nearest neighbor, closest pair, range searching, several data structures like K-D tree [15], range trees [17, 86], quad trees [111, 112], and several variations <ref> [8, 10, 4 20, 26, 59] </ref> have been proposed. The segment tree [16] is a very useful data structure to represent a collection of segments and to answer questions about them, and the interval tree [49, 91] is very useful for maintaining a collection of intervals. <p> In addition, we show that each of the operations on dynamic expression trees require O (log B N ) block i/o's 10 . Finally, using these primitives, we design optimal external-memory methods for solving the following geometric problems: Approximate nearest neighbor <ref> [9, 10] </ref>: given a set S of points in IR d , for fixed d, a query point p, a metric L t , and a parameter *, find a point q in S that is within distance at most (1 + *) times the distance of the actual nearest neighbor <p> A full history of this problem can be found in the papers by Arya et. al. <ref> [9, 10] </ref>. Here we briefly outline the previous work done on this and related problems. The exact nearest neighbor (also known as post office problem) can be solved by a simple brute-force method which compares the query point with every point in S. This takes linear time, which is prohibitive. <p> Arya and Mount [9] first presented a (static) linear-space data structure for the approximate nearest neighbor problem that answered queries in O (log 3 N ) time, which was later improved by Arya et al. <ref> [10] </ref> to O (log N ) time and they also made the data structure dynamic. Arya et. al. [10] show the following: Theorem 3.6.1: (Arya et. al. [10]) 1. <p> [9] first presented a (static) linear-space data structure for the approximate nearest neighbor problem that answered queries in O (log 3 N ) time, which was later improved by Arya et al. <ref> [10] </ref> to O (log N ) time and they also made the data structure dynamic. Arya et. al. [10] show the following: Theorem 3.6.1: (Arya et. al. [10]) 1. <p> the approximate nearest neighbor problem that answered queries in O (log 3 N ) time, which was later improved by Arya et al. <ref> [10] </ref> to O (log N ) time and they also made the data structure dynamic. Arya et. al. [10] show the following: Theorem 3.6.1: (Arya et. al. [10]) 1. <p> All the previous work on this problem are for the internal memory model. Using the topology B-tree data structure, we give an external-memory implementation of the method of Arya et al. <ref> [10] </ref>, constructing a data structure with which we can compute the approximate nearest neighbor for a query point using O (log B N ) i/o's. We also show how to update the data structure using O (log B N ) i/o's, under the operations of insertion and deletion of points. <p> Since the point location takes O (log N ) time, the overall time complexity of the algorithm is O (log N ). The algorithm of Arya et. al. <ref> [10] </ref> can be characterized as a method that performs a constant number of point location queries on the topology tree constructed, maintaining the closest point found so far. This observation helps us to "externalize" the algorithm.
Reference: [11] <author> M. J. Atallah, M. T. Goodrich, and K. Ramaiyer. </author> <title> Biased finger trees and three-dimensional layers of maxima. </title> <booktitle> In Proc. 10th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 150-159, </pages> <year> 1994. </year>
Reference-contexts: All of our methods assume that the planar subdivision does not change over time, but environments allowing for dynamic changes to the subdivision over time are well-motivated and well-studied, as well <ref> [11, 13, 33, 35, 60, 105, 107, 108, 117] </ref>.
Reference: [12] <author> B. G. Baumgart. </author> <title> A polyhedron representation for computer vision. </title> <booktitle> In Proc. AFIPS Natl. Comput. Conf., </booktitle> <volume> volume 44, </volume> <pages> pages 589-596, </pages> <year> 1975. </year>
Reference-contexts: These include arrangements of lines, Voronoi diagrams, Delaunay triangulations, and general triangulations. The representations for embedded planar graphs include planar straight line graphs [22, 38, 54, 58, 75], doubly connected edge list or DCEL [104], quad-edge structure [67], and winged-edge structure <ref> [12] </ref>.
Reference: [13] <author> H. Baumgarten, H. Jung, and K. Mehlhorn. </author> <title> Dynamic point location in general subdivisions. </title> <journal> J. Algorithms, </journal> <volume> 17 </volume> <pages> 342-380, </pages> <year> 1994. </year> <month> 155 </month>
Reference-contexts: N denotes the number of possible y-coordinates for edge endpoints in the subdivision. Type Queries Insert Delete General <ref> [13] </ref> O (log n log log n) O (log n log log n) O (log 2 n) Connected 7 [33] O (log 2 n) O (log n) O (log n) Connected [34] O (log n) O (log 3 n) O (log 3 n) Monotone [37] O (log n) O (log 2 <p> All of our methods assume that the planar subdivision does not change over time, but environments allowing for dynamic changes to the subdivision over time are well-motivated and well-studied, as well <ref> [11, 13, 33, 35, 60, 105, 107, 108, 117] </ref>.
Reference: [14] <author> S. Bent, D. Sleator, and R. Tarjan. </author> <title> Biased search trees. </title> <journal> SIAM Journal of Computing, </journal> <volume> 14(3) </volume> <pages> 545-568, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: The biased finger tree allows one to search and also to perform updates in the underlying set. For updates, the data structure requires fingers, which are pointers to the location where updates are performed. This data structure is a fingered version of the biased search tree data structure <ref> [14] </ref> of Bent, 5 Sleator, and Tarjan. Nevertheless, we give modifications that improve upon their results in the update times. We note that from the definition the biased finger tree can be of interest to problems other than computational geometry problems. <p> In cases with weighted items such as these one desires a search tree satisfying a bias property that forces the depth of each item i in the tree be roughly inversely proportional to log w i . Bent, Sleator, and Tarjan <ref> [14] </ref> give a method for maintaining such a structure subject to update operations, such as insertions, deletions, joins, and splits, as well as predecessor query operations. <p> Moreover, 10 we show that, while split operations will take O (log W=w i ) time (which is unavoidable), we can implement join operations in O (1) time. Our structure is topologically equivalent 1 to the globally biased search tree given by Bent, Sleator, and Tarjan <ref> [14] </ref>. In fact, if each item i has weight w i = 1, then our structure is topologically equivalent to a red-black tree [44, 66, 120]. <p> of disjoint subsets of U in binary search trees subject to the "standard" tree search queries, as well as item insertion and deletion in a tree, and join and split 1 For any given set of items, our tree and the globally biased search tree of Bent, Sleator, and Tarjan <ref> [14] </ref> are isomorphic up to rotation. They [14] actually introduce two kinds of biased search trees namely locally biased and globally biased search trees. 11 operations on trees (consistent with the total order). Aho, Hopcroft, and Ullman [5] refer to these as the concatenable queue operations. <p> search trees subject to the "standard" tree search queries, as well as item insertion and deletion in a tree, and join and split 1 For any given set of items, our tree and the globally biased search tree of Bent, Sleator, and Tarjan <ref> [14] </ref> are isomorphic up to rotation. They [14] actually introduce two kinds of biased search trees namely locally biased and globally biased search trees. 11 operations on trees (consistent with the total order). Aho, Hopcroft, and Ullman [5] refer to these as the concatenable queue operations. Table 2.1: Summary of Time Bounds for Biased Tree Operations. <p> All the complexities for update operations count only the time to perform the update, and do not include search times. Update Operation Previous Biased Trees <ref> [14] </ref> Biased Finger Trees Search (i,T) O (log W=w i ) O (log W=w i ) Insert (i; w i ; p i ; p i +; T ) O w i +w i + + log W 0 min (w i ;w i + ) j) Delete (i; T; p <p> The items i 1 and i 2 need not be siblings, but should be adjacent in the total order. As mentioned above, our structure is topologically similar to the biased search tree of Bent, Sleator, and Tarjan <ref> [14] </ref>. <p> The root also maintains the left-extreme and right-extreme pointers to the minimum and maximum (leaf ) items. Rank Property: In addition, every node x of the tree stores a non-negative integer rank r (x) that satisfies the natural extensions of red-black tree rank [120] to weighted sets <ref> [14] </ref> 3 : 1. If x is a leaf, then r (x) = blog w i c, where i is the item x stores. 2. If node x has parent y, then r (x) r (y). 3. If node x has grandparent y, then r (x) r (y) 1. nodes. <p> If node x has grandparent y, then r (x) r (y) 1. nodes. We introduce some more definitions: 3 We let the leaf has same rank as its parent which is a difference from the definition of Bent, Sleator, and Tarjan <ref> [14] </ref>. 14 1. We say a node x with parent y is minor if r (x) &lt; r (y) 1, and major otherwise i.e., if x is major then we have r (x) = r (y) 1 or r (x) = r (y). 2. <p> In addition to the above rank conditions, we also require the following structural constraint, which we call bias property on the nodes of the biased finger tree: Bias Property <ref> [14] </ref>: If a node u with parent v is minor, then the neighboring leaves of u are major leaves with rank at least r (v) 1. Also we say that the neighboring leaves support u. <p> For nodes a and c, the sibling is a major leaf, whereas for node b, the neighboring leaves are major leaf nodes of rank 8. This bias property is same as what Bent, Sleator, and Tarjan <ref> [14] </ref> define as global bias. We now review the standard rotations one performs to balance a binary search tree [5, 44, 78]. Consider the two configurations of a structure shown in Figure 2.2, where 15 A, B, and C, are arbitrary subtrees and x and y are two nodes. <p> We note that if u is a major node, then it gets zero credits, and if u is a minor node, then it gets r (v) r (u) 1 credits. Bent, Sleator, and Tarjan <ref> [14] </ref> use a similar type of credit scheme to analyze their implementation of the split and join operations. We account for the complexity of the update operations using these credits. <p> No actual credits are stored anywhere. 17 2.2.4 Special Cases of Join Operations Before we discuss the update operations, we briefly review the join algorithms of Bent, Sleator, and Tarjan <ref> [14] </ref>, and then define some special cases of join operations, which we use as subroutines in our rebalancing and update operations. Bias-consistency and Consistent-Join First we introduce a special type of bias finger tree called the bias-consistent finger tree. <p> We refer to the join operation on bias-consistent biased finger trees as a consistent join. Join Algorithm of Bent, Sleator, and Tarjan Bent, Sleator, and Tarjan <ref> [14] </ref> discuss two types of joins, one for globally biased trees and the other for locally biased trees. As we stated before, the bias property we use is the same as what they define as global bias. <p> As we stated before, the bias property we use is the same as what they define as global bias. We use their join operation on globally biased search trees as a subroutine in some of our update operations. We now summarize their results: Theorem 2.2.3: (Bent, Sleator, and Tarjan <ref> [14] </ref>) Given two globally biased trees rooted at x and y, the join (T x , T y ) algorithm requires O (log W w +w + ) time, where W is the total weight of items in the resulting tree and w and w + are the weights of the <p> We do not discuss them further in this chapter. We use the same credit invariant as in the previous section to analyze the update operations. We begin with the join operation. We describe a "bottom-up" strategy that contrasts with the "top-down" approach of Bent, Sleator and Tarjan <ref> [14] </ref>. Also this differs from the join operations discussed in the Section 2.2.4 in the sense it does not make any assumption about the two trees to be joined. Hence we refer to it as a general or oblivious join. <p> The nodes u and v can be obtained 33 using pointers stored in the root nodes x and y, respectively. Before we discuss the operation, we define the following operations as in Bent, Sleator, and Tarjan <ref> [14] </ref>. These operations make the ranks of the nodes strictly increasing along a path. tilt left (x): If both children of internal node x have the same rank as x, perform the promote operation at x, and return x. <p> Proof: Follows from the above discussions and the results presented in Section 2.2.4. Split: We perform the split operation as in Bent, Sleator, and Tarjan <ref> [14] </ref>. But we show that with the same complexity we can preserve all three types of credits in the nodes of the resulting trees. <p> We implement this step as join algorithm of Bent, Sleator, and Tarjan <ref> [14] </ref>. The credit invariants are preserved by the split and join operations. Hence the total complexity of this case is O (log (W=w i ) + log (W 0 =w i 0 )). <p> (W=w i ) + log (W 0 =w i 0 )) 56 Slice (i; T; i 1 ; i 2 ): O (log w i min (w i 1 ;w i 2 ) ) Fuse (i 1 ; i 2 ; i; T ): O (1) Bent, Sleator, and Tarjan <ref> [14] </ref> show that repeated bottom-up single-node joins on the right hand side can construct a biased search tree in O (n) worst-case time. <p> As a result, the nodes of larger weights will be at smaller depth. Our skeleton tree is therefore now a globally biased search tree <ref> [14] </ref> rather than a simple complete balanced binary tree, but we can still bound its height to be O (log n). This step takes O (n) time and space, which can be amortized by charging O (1) time to each of the 135 previous n queries. 4. <p> The step one follows from Lemma 4.2.1. The details for step two are given above and in the the previous paragraphs. The step three is straightforward. We omit the details of step four and refer the reader to the paper by Bent, Sleator, and Tarjan <ref> [14] </ref>. The details for steps five and six follow from above discussions. We now analyze the complexity of the construction of our data structure, the space requirement, and the cost of the query operations. We first state a theorem from Bent, Sleator, and Tarjan [14]. Theorem 4.2.10: [14] The globally biased <p> paper by Bent, Sleator, and Tarjan <ref> [14] </ref>. The details for steps five and six follow from above discussions. We now analyze the complexity of the construction of our data structure, the space requirement, and the cost of the query operations. We first state a theorem from Bent, Sleator, and Tarjan [14]. Theorem 4.2.10: [14] The globally biased search tree can be constructed in linear time if the items are inserted in sorted order. Analysis: Step 1 takes O (n log n) time and is performed only once. The data structure created uses O (n) space. <p> Sleator, and Tarjan <ref> [14] </ref>. The details for steps five and six follow from above discussions. We now analyze the complexity of the construction of our data structure, the space requirement, and the cost of the query operations. We first state a theorem from Bent, Sleator, and Tarjan [14]. Theorem 4.2.10: [14] The globally biased search tree can be constructed in linear time if the items are inserted in sorted order. Analysis: Step 1 takes O (n log n) time and is performed only once. The data structure created uses O (n) space.
Reference: [15] <author> J. L. Bentley. </author> <title> Multidimensional binary search trees used for associative searching. </title> <journal> Commun. ACM, </journal> <volume> 18(9) </volume> <pages> 509-517, </pages> <year> 1975. </year>
Reference-contexts: To represent a collection of points in d dimensions, where d is a fixed constant, and to answer queries like nearest neighbor, closest pair, range searching, several data structures like K-D tree <ref> [15] </ref>, range trees [17, 86], quad trees [111, 112], and several variations [8, 10, 4 20, 26, 59] have been proposed.
Reference: [16] <author> J. L. Bentley. </author> <title> Solutions to Klee's rectangle problems. </title> <institution> Report ??, Carnegie-Mellon Univ., </institution> <address> Pittsburgh, PA, </address> <year> 1977. </year>
Reference-contexts: The segment tree <ref> [16] </ref> is a very useful data structure to represent a collection of segments and to answer questions about them, and the interval tree [49, 91] is very useful for maintaining a collection of intervals.
Reference: [17] <author> J. L. Bentley. </author> <title> Decomposable searching problems. </title> <journal> Inform. Process. Lett., </journal> <volume> 8 </volume> <pages> 244-251, </pages> <year> 1979. </year>
Reference-contexts: To represent a collection of points in d dimensions, where d is a fixed constant, and to answer queries like nearest neighbor, closest pair, range searching, several data structures like K-D tree [15], range trees <ref> [17, 86] </ref>, quad trees [111, 112], and several variations [8, 10, 4 20, 26, 59] have been proposed.
Reference: [18] <author> T. Bernhardsen. </author> <title> Geographic Information Systems. VIAK IT AS./Norwegian Mapping Authority, </title> <year> 1992. </year>
Reference-contexts: We are interested in re-examining the point location problem, focusing on issues that arise in important application areas, such as geographic information systems (GIS) <ref> [19, 18, 55, 112, 121] </ref> 12 . Our re-examination of the point-location problem focuses on 12 Geographic Information Systems are powerful computing tools that manage the geometry of maps and their related geographic images and data. They are used in a variety of governmental and scientific domains.
Reference: [19] <author> J. K. Berry. </author> <title> Beyond Mapping: Concepts, Algorithms, and Issues in GIS. GIS World, </title> <address> Fort Collins, CO, </address> <year> 1993. </year>
Reference-contexts: We are interested in re-examining the point location problem, focusing on issues that arise in important application areas, such as geographic information systems (GIS) <ref> [19, 18, 55, 112, 121] </ref> 12 . Our re-examination of the point-location problem focuses on 12 Geographic Information Systems are powerful computing tools that manage the geometry of maps and their related geographic images and data. They are used in a variety of governmental and scientific domains.
Reference: [20] <author> S. N. Bespamyatnikh. </author> <title> An optimal algorithm for closest pair maintenance. </title> <booktitle> In Proc. 11th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 152-161, </pages> <year> 1995. </year>
Reference: [21] <author> N. Blum and K. Mehlhorn. </author> <title> On the average number of rebalancing operations in weight-balanced trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 11 </volume> <pages> 303-320, </pages> <year> 1980. </year>
Reference-contexts: If we implement T as a weight-balanced BB [ff]-tree data structure <ref> [21, 93, 98] </ref>, then we can maintain T so that tree-search queries take O (log n) time in the worst case (for this is the worst-case depth of T ) and insert and delete operations take O (log n) time (e.g., see Mehlhorn [93]). 2.4.2 Our Data Structure Suppose we are
Reference: [22] <author> G. R. Brightwell and E. R. Scheinerman. </author> <title> Representations of planar graphs. </title> <journal> SIAM J. Discrete Math., </journal> <volume> 6(2) </volume> <pages> 214-229, </pages> <year> 1993. </year>
Reference-contexts: There are however, several interesting special cases of embedded planar graphs, which are very useful for various applications. These include arrangements of lines, Voronoi diagrams, Delaunay triangulations, and general triangulations. The representations for embedded planar graphs include planar straight line graphs <ref> [22, 38, 54, 58, 75] </ref>, doubly connected edge list or DCEL [104], quad-edge structure [67], and winged-edge structure [12].
Reference: [23] <author> R. J. Brunner, K. Ramaiyer, A. J. C. A. Szalay, and R. H. Lupton. </author> <title> An object-oriented approach to astronomical databases. </title> <booktitle> In Astronomical Data Analysis Software and Systems IV, volume 77 of ASP Conference Series, </booktitle> <year> 1994. </year> <note> An electronic journal. URL:http://www.stsci.edu/meetings/adassIV/brunnerr.html. </note>
Reference-contexts: This offers potential challenges in terms of implementations of geometric data organization and geometric query optimization. Since the database generally involves large amounts of data, one needs to consider designing efficient spatial data structures for storage and retrieval of geometric objects. Sloan Digital Sky Survey (SDSS) project <ref> [24, 23, 110] </ref> is one such spatial database 152 application which offers several challenges for the geometry community in terms of organization of the geometry data and support for various queries. The survey aims at creating a comprehensive digital map of the northern sky.
Reference: [24] <author> R. J. Brunner, K. Ramaiyer, I. Csabai, A. Szalay, A. J. Connolly, and G. Szokoly. </author> <title> The science archive for the sloan digital sky survey. In Astronomical Data Analysis Software and Systems V, </title> <year> 1995. </year>
Reference-contexts: This offers potential challenges in terms of implementations of geometric data organization and geometric query optimization. Since the database generally involves large amounts of data, one needs to consider designing efficient spatial data structures for storage and retrieval of geometric objects. Sloan Digital Sky Survey (SDSS) project <ref> [24, 23, 110] </ref> is one such spatial database 152 application which offers several challenges for the geometry community in terms of organization of the geometry data and support for various queries. The survey aims at creating a comprehensive digital map of the northern sky.
Reference: [25] <author> P. Callahan, M. T. Goodrich, and K. Ramaiyer. </author> <title> Topology B-trees and their applications. </title> <booktitle> In Proc. 4th Workshop Algorithms Data Struct., volume 955 of Lecture Notes in Computer Science, </booktitle> <pages> pages 381-392. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: We allow for dynamic expression updates [40] and we consider a number of tree-search queries on arbitrary binary trees, which in turn can be used to solve a number of dynamic external-memory problems, including approximate nearest-neighbor searching, approximate range searching, and closest-pair maintenance <ref> [25] </ref>.
Reference: [26] <author> P. B. Callahan and S. R. Kosaraju. </author> <title> A decomposition of multi-dimensional point-sets with applications to k-nearest-neighbors and n-body potential fields. </title> <booktitle> In Proc. 24th Annu. ACM Sympos. Theory Comput., </booktitle> <pages> pages 546-556, </pages> <year> 1992. </year>
Reference-contexts: To represent a collection of points in d dimensions, where d is a fixed constant, and to answer queries like nearest neighbor, closest pair, range searching, several data structures like K-D tree [15], range trees [17, 86], quad trees [111, 112], and several variations <ref> [8, 10, 4 20, 26, 59] </ref> have been proposed. The segment tree [16] is a very useful data structure to represent a collection of segments and to answer questions about them, and the interval tree [49, 91] is very useful for maintaining a collection of intervals.
Reference: [27] <author> B. Chazelle. </author> <title> How to search in history. </title> <journal> Inform. Control, </journal> <volume> 64 </volume> <pages> 77-99, </pages> <year> 1985. </year>
Reference-contexts: We first give an overview of the method. We use a combination of ideas from the slab method [46] and the persistent methods <ref> [27, 42, 113] </ref> and modify them to achieve a fast query time. We first divide the planar regions into vertical slabs by dropping vertical lines 131 through each of the vertices of the subdivision. The resulting segments within each slab form a total order.
Reference: [28] <author> B. Chazelle. </author> <title> On the convex layers of a planar set. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT-31:509-517, </volume> <year> 1985. </year>
Reference-contexts: We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the three-dimensional layers-of-maxima problem <ref> [3, 28, 51, 81] </ref> and also give improved methods for dynamic point location in a convex subdivision [37, 103]. The space-sweeping algorithm makes use of dynamic point location in a staircase subdivision, which we deal with as a special case of point location in convex subdivision. <p> The iteration number in which a point p is removed from S is called p's layer, and we denote it by l (p). The layers-of-maxima problem is to determine the layer of each point p in S. This is related to the well-known convex layers problem <ref> [28] </ref>. Kung, Luccio, and Preparata [81] showed that 3-dimensional maxima set problem can be solved in O (n log n) time.
Reference: [29] <author> B. Chazelle. </author> <title> An optimal convex hull algorithm in any fixed dimension. </title> <journal> Discrete Comput. Geom., </journal> <volume> 10 </volume> <pages> 377-409, </pages> <year> 1993. </year> <month> 156 </month>
Reference-contexts: They further improve the space bound of our method to be linear, however, while still keeping very close to the 2dlog ne query time. Goodrich et. al. [62] use the ideas of *-cutting [70, 90], semi-net <ref> [6, 29] </ref>, and the general theory of geometric range spaces [6, 31, 61, 88] to improve the space for the point location method.
Reference: [30] <author> B. Chazelle, H. Edelsbrunner, M. Grigni, L. Guibas, J. Hershberger, M. Sharir, and J. Snoeyink. </author> <title> Ray shooting in polygons using geodesic triangulations. </title> <booktitle> In Proc. 18th Internat. Colloq. Automata Lang. Program., volume 510 of Lecture Notes in Computer Science, </booktitle> <pages> pages 661-673. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: We refer to this as the "geometric data structure solution" approach. This approach is widely used by several researchers to design very elegant data structures to solve a number of geometry problems <ref> [30, 42, 45, 46, 52, 71, 76, 83, 103, 113] </ref>.
Reference: [31] <author> B. Chazelle and J. Friedman. </author> <title> A deterministic view of random sampling and its use in geometry. </title> <journal> Combinatorica, </journal> <volume> 10(3) </volume> <pages> 229-249, </pages> <year> 1990. </year>
Reference-contexts: They further improve the space bound of our method to be linear, however, while still keeping very close to the 2dlog ne query time. Goodrich et. al. [62] use the ideas of *-cutting [70, 90], semi-net [6, 29], and the general theory of geometric range spaces <ref> [6, 31, 61, 88] </ref> to improve the space for the point location method.
Reference: [32] <author> B. Chazelle and L. J. Guibas. Fractional cascading: I. </author> <title> A data structuring technique. </title> <journal> Algorithmica, </journal> <volume> 1 </volume> <pages> 133-162, </pages> <year> 1986. </year>
Reference-contexts: describes a method based upon taking advantage of the similarity, or coherence, between consecutive slabs in the slab method; Sarnak and Tarjan describe a method based upon a plane sweep of S using persistent red-black trees [47]; and Edelsbrun-ner et al. describe a method based upon applying the fractional cascading <ref> [32] </ref> paradigm to the separating chain method. If optimized for the constant factors in their query times, the methods of Cole and Edelsbrunner et al. appear to require 3dlog ne time for point-location queries and the method of Sarnak and Tarjan appears to require 5dlog ne time 14 .
Reference: [33] <author> S. W. Cheng and R. Janardan. </author> <title> New results on dynamic planar point location. </title> <journal> SIAM J. Comput., </journal> <volume> 21 </volume> <pages> 972-999, </pages> <year> 1992. </year>
Reference-contexts: N denotes the number of possible y-coordinates for edge endpoints in the subdivision. Type Queries Insert Delete General [13] O (log n log log n) O (log n log log n) O (log 2 n) Connected 7 <ref> [33] </ref> O (log 2 n) O (log n) O (log n) Connected [34] O (log n) O (log 3 n) O (log 3 n) Monotone [37] O (log n) O (log 2 n) O (log 2 n) Monotone [60] O (log 2 n) O (log n) O (log n) Rectilinear [94] <p> All of our methods assume that the planar subdivision does not change over time, but environments allowing for dynamic changes to the subdivision over time are well-motivated and well-studied, as well <ref> [11, 13, 33, 35, 60, 105, 107, 108, 117] </ref>.
Reference: [34] <author> Y.-J. Chiang, F. P. Preparata, and R. Tamassia. </author> <title> A unified approach to dynamic point location, ray shooting, and shortest paths in planar maps. </title> <booktitle> In Proc. 4th ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 44-53, </pages> <year> 1993. </year>
Reference-contexts: N denotes the number of possible y-coordinates for edge endpoints in the subdivision. Type Queries Insert Delete General [13] O (log n log log n) O (log n log log n) O (log 2 n) Connected 7 [33] O (log 2 n) O (log n) O (log n) Connected <ref> [34] </ref> O (log n) O (log 3 n) O (log 3 n) Monotone [37] O (log n) O (log 2 n) O (log 2 n) Monotone [60] O (log 2 n) O (log n) O (log n) Rectilinear [94] O (log n log log n) O (log n log log n)
Reference: [35] <author> Y.-J. Chiang, F. P. Preparata, and R. Tamassia. </author> <title> A unified approach to dynamic point location, ray shooting, and shortest paths in planar maps. </title> <note> SIAM J. Comput., to appear. Preprint: Technical Report CS-92-07, </note> <institution> Comput. Sci. Dept., Brown Univ. </institution> <year> (1992). </year>
Reference-contexts: All of our methods assume that the planar subdivision does not change over time, but environments allowing for dynamic changes to the subdivision over time are well-motivated and well-studied, as well <ref> [11, 13, 33, 35, 60, 105, 107, 108, 117] </ref>.
Reference: [36] <author> Y.-J. Chiang and R. Tamassia. </author> <title> Dynamic algorithms in computational geometry. </title> <journal> Proc. IEEE, </journal> <volume> 80(9) </volume> <pages> 1412-1434, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: a monotone subdivision is one in which each face is monotone with respect to (say) the x-axis, a connected subdivision is one which forms a connected graph, and a general subdivision is one that may contain "holes." The interested reader is referred to the excellent survey by Chiang and Tamassia <ref> [36] </ref> for a discussion of these and other results in dynamic computational geometry. 63 In this section we give a scheme for dynamic point location in a convex subdivision that achieves O (log n) time for performing a point location query for any point p 2 IR 2 , O (log
Reference: [37] <author> Y.-J. Chiang and R. Tamassia. </author> <title> Dynamization of the trapezoid method for planar point location in monotone subdivisions. </title> <journal> Internat. J. Comput. Geom. Appl., </journal> <volume> 2(3) </volume> <pages> 311-333, </pages> <year> 1992. </year>
Reference-contexts: Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [114] (that itself has many applications [41, 53, 60]) or in a point location structure built using the trapezoid method <ref> [37, 103, 108] </ref>. In cases with weighted items such as these one desires a search tree satisfying a bias property that forces the depth of each item i in the tree be roughly inversely proportional to log w i . <p> We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the three-dimensional layers-of-maxima problem [3, 28, 51, 81] and also give improved methods for dynamic point location in a convex subdivision <ref> [37, 103] </ref>. The space-sweeping algorithm makes use of dynamic point location in a staircase subdivision, which we deal with as a special case of point location in convex subdivision. <p> Type Queries Insert Delete General [13] O (log n log log n) O (log n log log n) O (log 2 n) Connected 7 [33] O (log 2 n) O (log n) O (log n) Connected [34] O (log n) O (log 3 n) O (log 3 n) Monotone <ref> [37] </ref> O (log n) O (log 2 n) O (log 2 n) Monotone [60] O (log 2 n) O (log n) O (log n) Rectilinear [94] O (log n log log n) O (log n log log n) O (log n log log n) Convex [108] O (log n + log <p> As mentioned above, our method for maintaining S is based upon a dynamic implementation of the "trapezoid method" of Preparata [103] for static point location. Incidentally, this is also the approach used by Chiang and Tamassia <ref> [37] </ref>, albeit in a different way. Let us assume, for the time being, that the x-coordinates of the segment endpoints are integers in the range [1; n] (we will show later how to get around this restriction using the BB [ff] tree).
Reference: [38] <author> M. Chrobak and S. Nakano. </author> <title> Minimum-width grid drawings of plane graphs. </title> <editor> In R. Tamassia and I. G. Tollis, editors, </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes in Computer Science, </booktitle> <pages> pages 104-110. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: There are however, several interesting special cases of embedded planar graphs, which are very useful for various applications. These include arrangements of lines, Voronoi diagrams, Delaunay triangulations, and general triangulations. The representations for embedded planar graphs include planar straight line graphs <ref> [22, 38, 54, 58, 75] </ref>, doubly connected edge list or DCEL [104], quad-edge structure [67], and winged-edge structure [12].
Reference: [39] <author> K. L. Clarkson. </author> <title> A randomized algorithm for closest-point queries. </title> <journal> SIAM J. Comput., </journal> <volume> 17 </volume> <pages> 830-847, </pages> <year> 1988. </year>
Reference-contexts: This takes linear time, which is prohibitive. To improve the time complexity from linear to polylogarithmic, one can construct a Voronoi diagram for S, and then perform point location query in the Voronoi diagram. But this method requires space roughly equal to O (N dd=2e ) <ref> [39] </ref>, which becomes impractical even for small dimensions. With linear space it is conjectured [9, 89] that (N 11=bd=2c ) is a lower bound for the exact nearest neighbor problem.
Reference: [40] <author> R. F. Cohen and R. Tamassia. </author> <title> Dynamic expression trees and their applications. </title> <booktitle> In Proc. 2nd ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 52-61, </pages> <year> 1991. </year>
Reference-contexts: Nevertheless, there are many applications that operate on unbalanced binary trees. In this chapter we describe a data structure, which we call the topology B-tree, for maintaining unbalanced binary trees in external memory. We allow for dynamic expression updates <ref> [40] </ref> and we consider a number of tree-search queries on arbitrary binary trees, which in turn can be used to solve a number of dynamic external-memory problems, including approximate nearest-neighbor searching, approximate range searching, and closest-pair maintenance [25].
Reference: [41] <author> R. F. Cohen and R. Tamassia. </author> <title> Dynamic expression trees. </title> <journal> Algorithmica, </journal> <volume> 13 </volume> <pages> 245-265, </pages> <year> 1995. </year>
Reference-contexts: This weight is a positive integer that may be proportional to an access probability, as in an optimal binary search tree structure [5, 78]. Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [114] (that itself has many applications <ref> [41, 53, 60] </ref>) or in a point location structure built using the trapezoid method [37, 103, 108].
Reference: [42] <author> R. Cole. </author> <title> Searching and storing similar lists. </title> <journal> J. Algorithms, </journal> <volume> 7 </volume> <pages> 202-220, </pages> <year> 1986. </year>
Reference-contexts: We refer to this as the "geometric data structure solution" approach. This approach is widely used by several researchers to design very elegant data structures to solve a number of geometry problems <ref> [30, 42, 45, 46, 52, 71, 76, 83, 103, 113] </ref>. <p> The point location query takes a point as an argument and identifies the face in the underlying plane graph that contains the given point. There are several optimal solutions for this problem in static as well as in dynamic scenario <ref> [42, 46, 52, 76, 83, 103, 113] </ref>. The optimal static algorithms show that one can construct a O (n)-space data structure with O (n log n) time preprocessing which answer queries in O (log n) time. The dynamic algorithms have different performances based on the type of subdivision. <p> The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [42, 51, 52, 76, 83, 84, 103, 104, 106, 107, 113] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [42, 52, 76, 113]. <p> It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time <ref> [42, 52, 76, 113] </ref>. These optimal data structures are static, however, in that they do not allow for any changes to S to occur after the data structure is constructed. <p> This problem is very well-studied <ref> [42, 46, 52, 76, 83, 103, 113] </ref>, and there are a number of solutions that asymptotically achieve query times of O (log n) using O (n) space, which is optimal. <p> Still, based upon their benchmarking tests, they argued that the best practical method at that time was the bucketing approach, with the trapezoid method being a close competitor. Following this, Cole <ref> [42] </ref>, Sarnak and Tar-jan [113], and Edelsbrunner, Guibas, and Stolfi [52] independently showed how to improve the constant factor in the query time for point location while still achieving linear space. These three methods are described quite differently, but the resulting data structures are remarkably similar. <p> We first give an overview of the method. We use a combination of ideas from the slab method [46] and the persistent methods <ref> [27, 42, 113] </ref> and modify them to achieve a fast query time. We first divide the planar regions into vertical slabs by dropping vertical lines 131 through each of the vertices of the subdivision. The resulting segments within each slab form a total order.
Reference: [43] <author> D. Comer. </author> <title> The ubiquitous B-tree. </title> <journal> ACM Comput. Surv., </journal> <volume> 11 </volume> <pages> 121-137, </pages> <year> 1979. </year>
Reference-contexts: Since the definition of biased finger tree doesn't involve any geometry, its usage (mainly as secondary structure) in applications in other areas, needs to be explored. 91 Chapter 3 Topology B-Trees and Applications 3.1 Introduction The B-tree <ref> [43, 68, 82, 87] </ref> data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory [4, 7, 64, 74, 99, 102, 116, 122]. Indeed, in his well-known survey paper [43], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. <p> Indeed, in his well-known survey paper <ref> [43] </ref>, Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. In this chapter we describe a data structure, which we call the topology B-tree, for maintaining unbalanced binary trees in external memory.
Reference: [44] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: We present the conclusions and directions for future research in the Chapter 5. 8 Chapter 2 Biased Finger Trees and Applications 2.1 Introduction Binary search trees are one of the most useful data structures, and are ubiquitous throughout the design and analysis of efficient algorithms <ref> [44] </ref>. In some cases they serve as stand-alone structures (e.g., implementing a dictionary or a heap), while in many cases they are used in tandem with other structures, either as primary or secondary structures (or both, as in the range tree [104]). <p> Our structure is topologically equivalent 1 to the globally biased search tree given by Bent, Sleator, and Tarjan [14]. In fact, if each item i has weight w i = 1, then our structure is topologically equivalent to a red-black tree <ref> [44, 66, 120] </ref>. It is our update methods and amortized analysis that are different, and this is what allows us to achieve running times that are improvements over those obtained by Bent, Sleator, and Tarjan, even if one ignores the search times in their update procedures. <p> This bias property is same as what Bent, Sleator, and Tarjan [14] define as global bias. We now review the standard rotations one performs to balance a binary search tree <ref> [5, 44, 78] </ref>. Consider the two configurations of a structure shown in Figure 2.2, where 15 A, B, and C, are arbitrary subtrees and x and y are two nodes. <p> We account for the complexity of the update operations using these credits. An update operation spends one credit to complete a single primitive operation (like a compare operation, basic arithmetic operation, moving along one edge of the tree, etc.) on our underlying computational model, i.e., the RAM model <ref> [5, 44] </ref>. We show that each update operation completes the update and rebalancing, and restores the credit invariants, using a number of credits asymptotically equal to our claimed amortized time complexity. 4 This credit notion is only used for analysis purposes. <p> We implement step 1 as a point location in staircase subdivision, and it takes Q (n) time. We represent the staircase corresponding to each layer by a dictionary <ref> [44] </ref>, for ordering along x and yaxes (since both are same ordering). Using these data structures, we compute in O (log n) time the horizontal segment h, and the vertical segment v for a new point p. Hence step 2 takes O (log n) time. <p> Along with the tree T we also maintain a DCEL [104] (doubly connected edge list) for the subdivision. We maintain the faces of the subdivision as a dictionary D of size O (n) stored in, say, a red-black tree <ref> [44, 66, 120] </ref>. With each face f (which is a node in D), we maintain a dictionary (f ), implemented as a doubly-linked list, of size O (log n) containing pointers to the nodes in T that f covers (ordered by height).
Reference: [45] <author> M. de Berg. </author> <title> Ray Shooting, Depth Orders and Hidden Surface Removal, </title> <booktitle> volume 703 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year> <month> 157 </month>
Reference-contexts: We refer to this as the "geometric data structure solution" approach. This approach is widely used by several researchers to design very elegant data structures to solve a number of geometry problems <ref> [30, 42, 45, 46, 52, 71, 76, 83, 103, 113] </ref>.
Reference: [46] <author> D. P. Dobkin and R. J. Lipton. </author> <title> Multidimensional searching problems. </title> <journal> SIAM J. Comput., </journal> <volume> 5 </volume> <pages> 181-186, </pages> <year> 1976. </year>
Reference-contexts: We refer to this as the "geometric data structure solution" approach. This approach is widely used by several researchers to design very elegant data structures to solve a number of geometry problems <ref> [30, 42, 45, 46, 52, 71, 76, 83, 103, 113] </ref>. <p> The point location query takes a point as an argument and identifies the face in the underlying plane graph that contains the given point. There are several optimal solutions for this problem in static as well as in dynamic scenario <ref> [42, 46, 52, 76, 83, 103, 113] </ref>. The optimal static algorithms show that one can construct a O (n)-space data structure with O (n log n) time preprocessing which answer queries in O (log n) time. The dynamic algorithms have different performances based on the type of subdivision. <p> This problem is very well-studied <ref> [42, 46, 52, 76, 83, 103, 113] </ref>, and there are a number of solutions that asymptotically achieve query times of O (log n) using O (n) space, which is optimal. <p> The first non-trivial solution to this problem is a method by Dobkin and Lipton <ref> [46] </ref>, based upon a simple, elegant slab method, that answers queries using at most 2dlog ne point-line comparisons 13 . <p> We first give an overview of the method. We use a combination of ideas from the slab method <ref> [46] </ref> and the persistent methods [27, 42, 113] and modify them to achieve a fast query time. We first divide the planar regions into vertical slabs by dropping vertical lines 131 through each of the vertices of the subdivision. The resulting segments within each slab form a total order.
Reference: [47] <author> J. R. Driscoll, N. Sarnak, D. D. Sleator, and R. E. Tarjan. </author> <title> Making data structures persistent. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 38 </volume> <pages> 86-124, </pages> <year> 1989. </year>
Reference-contexts: Cole describes a method based upon taking advantage of the similarity, or coherence, between consecutive slabs in the slab method; Sarnak and Tarjan describe a method based upon a plane sweep of S using persistent red-black trees <ref> [47] </ref>; and Edelsbrun-ner et al. describe a method based upon applying the fractional cascading [32] paradigm to the separating chain method. <p> The splay heuristic that realizes the above behaviors is blind to the properties of the access sequence and to the global structure of the tree. 4.2.2 Persistence of Splay Trees In this section we discuss how to apply the persistence paradigm of Driscoll et al. <ref> [47] </ref> to the splay operations that we later use in our algorithm for adaptive point location queries. 128 Driscoll et al. discuss two kinds of persistence. <p> This allows us to perform query operations by first searching using the x-coordinate to identify the correct event and then searching using the x and y-coordinates to identify the region of the subdivision. We will again apply the persistence paradigm <ref> [47] </ref> to a left-to-right plane sweep procedure, but in order to achieve O (n) time (and space) we will apply it to a tree data structure that requires only O (1) time to update (with only O (1) structural changes needing to be stored persistently). <p> Then one can construct an O (n)-space point location data structure for S in O (n) time that achieves a query time of dlog ne + 2 fl height (T ). Proof: The constant factors in the query time follow by applying the appropriate persistence technique <ref> [47] </ref>. We first construct our point location data structure using the method outlined in the Section 4.2.3. But during the query operation we perform the destructive splay operation on the version corresponding to the slab being searched. <p> Here, the LEDA [95, 97] persistent dictionary class is used as the structure to hold the edges from the net. We call this method the e-net-leda method. 138 3. Epsilon-net method using an node-copying <ref> [47] </ref> persistence. This method is identical to the LEDA persistence method except that a persistent red-black tree built using node-copying method of persistence is used as opposed to the LEDA class. We call this method the e-net-ncp method. 4. Adaptive point location method using persistent splay tree.
Reference: [48] <author> M. Edahiro, I. Kokubo, and T. Asano. </author> <title> A new point-location algorithm and its practical efficiency: comparison with existing algorithms. </title> <journal> ACM Trans. Graph., </journal> <volume> 3 </volume> <pages> 86-109, </pages> <year> 1984. </year>
Reference-contexts: His method is based upon a beautiful hierarchical subdivision method, but the constant factor in the running time is fairly large. Because of the questions of practicality raised by this method, Edahiro, Kokubo, and Asano <ref> [48] </ref> performed a series of empirical benchmarking tests between the trapezoid and hierarchical subdivision methods, as well as a simple "bucketing" approach, 13 Most of the previous papers we review do not actually report the constant factors in the number of point-line comparisons needed to answer a query. <p> conducted on new and existing methods of planar point location and give some discussion as to the results observed. 4.3.1 Experimental Setup Epsilon net methods of planar point location (which are simple variants of *-cutting method from Lemma 4.2.2), adaptive point location methods, as well as the Edahiro et al. <ref> [48] </ref> bucket method, were implemented and experiments were conducted to compare the query times of the various methods. The epsilon net method was implemented in two different ways. <p> The adaptive point location method was implemented using a path-copying persistent splay tree structure. Thus, a total of four methods were implemented. 137 These are described below. Point Location Methods: We considered the following implementations of point location methods: 1. Bucket Method <ref> [48] </ref>. This method partitions the plane that is within the bounding box of the planar subdivision into p p n cells and associates with each cell the vertices and edges of the subdivision that either fall within or cross that cell. <p> To conduct a query, then, one finds the cell into which the query point falls and then locates the query point considering only the edges and vertices that are associated with (or cross) that cell. Edahiro et al. <ref> [48] </ref> argue that since the number of cells is roughly n and the number of vertices and edges in the subdivision is O (n) that the number of vertices and edges associated with any given cell will be O (1) for regular subdivisions.
Reference: [49] <author> H. Edelsbrunner. </author> <title> Dynamic data structures for orthogonal intersection queries. </title> <type> Report F59, </type> <institution> Inst. Informationsverarb., Tech. Univ. Graz, Graz, Austria, </institution> <year> 1980. </year>
Reference-contexts: The segment tree [16] is a very useful data structure to represent a collection of segments and to answer questions about them, and the interval tree <ref> [49, 91] </ref> is very useful for maintaining a collection of intervals. A collection of lines in two dimensions or hyperplanes in higher dimensions is represented by an arrangement, which is a planar subdivision in two dimension and spatial partition into polyhedrons in higher dimensions.
Reference: [50] <author> H. Edelsbrunner. </author> <title> A new approach to rectangle intersections, Part I. </title> <journal> Internat. J. Comput. Math., </journal> <volume> 13 </volume> <pages> 209-219, </pages> <year> 1983. </year>
Reference-contexts: Similarly, facial ordering and connectivity information of subdivisions is often needed and requires special representation. If one is given a collection of horizontal segments, one would like to represent the end points, and also the information of "aboveness" <ref> [50] </ref>. Higher dimensional geometric objects cannot be easily represented by the classical data structures, and require careful study. Problems involving geometric objects vary and are often classified as follows: Static: all the geometric objects in the problem domain are given as part of the input.
Reference: [51] <author> H. Edelsbrunner. </author> <title> Algorithms in Combinatorial Geometry, </title> <booktitle> volume 10 of EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, West Germany, </address> <year> 1987. </year>
Reference-contexts: A collection of lines in two dimensions or hyperplanes in higher dimensions is represented by an arrangement, which is a planar subdivision in two dimension and spatial partition into polyhedrons in higher dimensions. Edelsbrunner's book on combinatorial geometry <ref> [51] </ref> deals extensively with the properties, representations, and applications of arrangements of hyperplanes. 1.2 Our Thesis In this thesis we study static, dynamic, and external memory algorithms for computational geometry problems like planar point location, nearest neighbor, range searching, and three-dimensional layers of maxima. <p> We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the three-dimensional layers-of-maxima problem <ref> [3, 28, 51, 81] </ref> and also give improved methods for dynamic point location in a convex subdivision [37, 103]. The space-sweeping algorithm makes use of dynamic point location in a staircase subdivision, which we deal with as a special case of point location in convex subdivision. <p> The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [42, 51, 52, 76, 83, 84, 103, 104, 106, 107, 113] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [42, 52, 76, 113].
Reference: [52] <author> H. Edelsbrunner, L. J. Guibas, and J. Stolfi. </author> <title> Optimal point location in a monotone subdivision. </title> <journal> SIAM J. Comput., </journal> <volume> 15 </volume> <pages> 317-340, </pages> <year> 1986. </year>
Reference-contexts: We refer to this as the "geometric data structure solution" approach. This approach is widely used by several researchers to design very elegant data structures to solve a number of geometry problems <ref> [30, 42, 45, 46, 52, 71, 76, 83, 103, 113] </ref>. <p> The point location query takes a point as an argument and identifies the face in the underlying plane graph that contains the given point. There are several optimal solutions for this problem in static as well as in dynamic scenario <ref> [42, 46, 52, 76, 83, 103, 113] </ref>. The optimal static algorithms show that one can construct a O (n)-space data structure with O (n log n) time preprocessing which answer queries in O (log n) time. The dynamic algorithms have different performances based on the type of subdivision. <p> The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [42, 51, 52, 76, 83, 84, 103, 104, 106, 107, 113] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [42, 52, 76, 113]. <p> It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time <ref> [42, 52, 76, 113] </ref>. These optimal data structures are static, however, in that they do not allow for any changes to S to occur after the data structure is constructed. <p> This problem is very well-studied <ref> [42, 46, 52, 76, 83, 103, 113] </ref>, and there are a number of solutions that asymptotically achieve query times of O (log n) using O (n) space, which is optimal. <p> Still, based upon their benchmarking tests, they argued that the best practical method at that time was the bucketing approach, with the trapezoid method being a close competitor. Following this, Cole [42], Sarnak and Tar-jan [113], and Edelsbrunner, Guibas, and Stolfi <ref> [52] </ref> independently showed how to improve the constant factor in the query time for point location while still achieving linear space. These three methods are described quite differently, but the resulting data structures are remarkably similar.
Reference: [53] <author> D. Eppstein, G. F. Italiano, R. Tamassia, R. E. Tarjan, J. Westbrook, and M. Yung. </author> <title> Maintenance of a minimum spanning forest in a dynamic planar graph. </title> <journal> J. Algorithms, </journal> <volume> 13 </volume> <pages> 33-54, </pages> <year> 1992. </year>
Reference-contexts: This weight is a positive integer that may be proportional to an access probability, as in an optimal binary search tree structure [5, 78]. Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [114] (that itself has many applications <ref> [41, 53, 60] </ref>) or in a point location structure built using the trapezoid method [37, 103, 108].
Reference: [54] <author> I. Fary. </author> <title> On straight lines representation of planar graphs. </title> <journal> Acta Sci. Math. Szeged., </journal> <volume> 11 </volume> <pages> 229-233, </pages> <year> 1948. </year>
Reference-contexts: A graph is planar if it can be embedded in the plane; a plane graph has already been embedded in the plane [69]. A planar graph can always be embedded in the plane so that all its edges are straight-line segments <ref> [54] </ref> and such an embedded graph is called planar straight line graph (PSLG). The embedded planar graph in general represents a planar subdivision. There are however, several interesting special cases of embedded planar graphs, which are very useful for various applications. <p> There are however, several interesting special cases of embedded planar graphs, which are very useful for various applications. These include arrangements of lines, Voronoi diagrams, Delaunay triangulations, and general triangulations. The representations for embedded planar graphs include planar straight line graphs <ref> [22, 38, 54, 58, 75] </ref>, doubly connected edge list or DCEL [104], quad-edge structure [67], and winged-edge structure [12].
Reference: [55] <author> W. R. Franklin. </author> <title> Computer systems and low level data structures for GIS. </title> <editor> In D. Maguire, D. Rhind, and M. Goodchild, editors, GIS: </editor> <booktitle> Principles and Practice, </booktitle> <volume> volume 1, </volume> <pages> pages 215-225. </pages> <publisher> Longman Higher Education and Reference, </publisher> <address> London UK, </address> <year> 1991. </year>
Reference-contexts: We are interested in re-examining the point location problem, focusing on issues that arise in important application areas, such as geographic information systems (GIS) <ref> [19, 18, 55, 112, 121] </ref> 12 . Our re-examination of the point-location problem focuses on 12 Geographic Information Systems are powerful computing tools that manage the geometry of maps and their related geographic images and data. They are used in a variety of governmental and scientific domains.
Reference: [56] <author> G. N. Frederickson. </author> <title> Ambivalent data structures for dynamic 2-edge connectivity and k-smallest spanning trees. </title> <booktitle> In Proc. 32nd Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 632-641, </pages> <year> 1991. </year>
Reference-contexts: The topology B-tree is an external memory data structure that can be used to maintain a balanced representation of an arbitrary rooted tree. This data structure is an external memory analogue of the topology tree of Frederickson <ref> [56, 57] </ref>, and it gives a good I/O performance for traversing the different root-to-leaf paths of the underlying rooted tree. <p> Based upon these clustering rules, it is 96 fairly straightforward to show that the number of levels in a topology tree is O (log N ), where N is the number of nodes in the base tree T . Frederickson <ref> [56] </ref> proves the following (stronger) lemma, which relates the number of clusters at one level with the previous level: Lemma 3.2.1: [56] For any level l &gt; 0 in a topology tree, the number of clusters at level l is at most 5=6 of the number of clusters at level l <p> Frederickson <ref> [56] </ref> proves the following (stronger) lemma, which relates the number of clusters at one level with the previous level: Lemma 3.2.1: [56] For any level l &gt; 0 in a topology tree, the number of clusters at level l is at most 5=6 of the number of clusters at level l 1. level trees. 3.2.1 Implementation of Primitives on Topology Tree In this section, we discuss how to implement the dynamic operations
Reference: [57] <author> G. N. Frederickson. </author> <title> A data structure for dynamically maintaining rooted trees. </title> <booktitle> In Proc. 4th ACM-SIAM Symp. on Discrete Algorithms (SODA), </booktitle> <pages> pages 175-184, </pages> <year> 1993. </year>
Reference-contexts: The topology B-tree is an external memory data structure that can be used to maintain a balanced representation of an arbitrary rooted tree. This data structure is an external memory analogue of the topology tree of Frederickson <ref> [56, 57] </ref>, and it gives a good I/O performance for traversing the different root-to-leaf paths of the underlying rooted tree. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson <ref> [57] </ref>, which is an elegant internal-memory method for maintaining unbalanced binary trees. 92 Before we describe our specific results, let us review the model for external memory [4, 64, 74, 99, 102, 116, 122] that we will be assuming throughout this chapter. 3.1.1 The External-Memory Model We assume that the external-memory <p> we use the notation O (:) to describe amortized complexity. 94 Our query algorithms all use an optimal O (log B N ) external-memory i/o's. 3.2 The Topology Tree Data Structure Before we describe our data structure in detail, however, let us first review the structure of the topology tree <ref> [57] </ref>, and discuss how to implement insertion and deletion of nodes, a generalized deepest-intersection search, and the evaluation of arithmetic expressions. Given any rooted tree T = (V; E), the topology tree T is a balanced tree constructed on top of the nodes of T by repeated clustering. <p> Our methods are similar to those of Frederickson <ref> [57] </ref>, but simpler, since we consider here only a subset of the operations he considers. <p> Insert: Our method is similar to the implementation in Frederickson <ref> [57] </ref>. Consider inserting a new leaf node v in the tree T . Let T 0 = T be the level-0 tree (i.e., leaf-level tree) of the topology tree T . <p> If this search terminates at k nodes of the topology tree, then the total time for this search is O (k fl log N ). Evaluation of arithmetic expressions: Our implementation is a straightforward extension of the internal-memory procedure of Frederickson <ref> [57] </ref>. We omit the details.
Reference: [58] <author> A. Garg and R. Tamassia. </author> <title> Efficient computation of planar straight-line upward drawings. </title> <booktitle> In Graph Drawing '93 (Proc. ALCOM Workshop on Graph Drawing), </booktitle> <address> Paris, France, </address> <year> 1993. </year>
Reference-contexts: There are however, several interesting special cases of embedded planar graphs, which are very useful for various applications. These include arrangements of lines, Voronoi diagrams, Delaunay triangulations, and general triangulations. The representations for embedded planar graphs include planar straight line graphs <ref> [22, 38, 54, 58, 75] </ref>, doubly connected edge list or DCEL [104], quad-edge structure [67], and winged-edge structure [12].
Reference: [59] <author> M. Golin, R. Raman, C. Schwarz, and M. Smid. </author> <title> Randomized data structures for the dynamic closest-pair problem. </title> <booktitle> In Proc. 4th ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 301-310, </pages> <year> 1993. </year>
Reference-contexts: To represent a collection of points in d dimensions, where d is a fixed constant, and to answer queries like nearest neighbor, closest pair, range searching, several data structures like K-D tree [15], range trees [17, 86], quad trees [111, 112], and several variations <ref> [8, 10, 4 20, 26, 59] </ref> have been proposed. The segment tree [16] is a very useful data structure to represent a collection of segments and to answer questions about them, and the interval tree [49, 91] is very useful for maintaining a collection of intervals.
Reference: [60] <author> M. Goodrich and R. Tamassia. </author> <title> Dynamic trees and dynamic point location. </title> <booktitle> In Proc. 23rd Annu. ACM Sympos. Theory Comput., </booktitle> <pages> pages 523-533, </pages> <year> 1991. </year> <month> 158 </month>
Reference-contexts: This weight is a positive integer that may be proportional to an access probability, as in an optimal binary search tree structure [5, 78]. Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [114] (that itself has many applications <ref> [41, 53, 60] </ref>) or in a point location structure built using the trapezoid method [37, 103, 108]. <p> O (log n log log n) O (log 2 n) Connected 7 [33] O (log 2 n) O (log n) O (log n) Connected [34] O (log n) O (log 3 n) O (log 3 n) Monotone [37] O (log n) O (log 2 n) O (log 2 n) Monotone <ref> [60] </ref> O (log 2 n) O (log n) O (log n) Rectilinear [94] O (log n log log n) O (log n log log n) O (log n log log n) Convex [108] O (log n + log N ) O (log n log N ) O (log n log N <p> All of our methods assume that the planar subdivision does not change over time, but environments allowing for dynamic changes to the subdivision over time are well-motivated and well-studied, as well <ref> [11, 13, 33, 35, 60, 105, 107, 108, 117] </ref>.
Reference: [61] <author> M. T. Goodrich. </author> <title> Geometric partitioning made easier, even in parallel. </title> <booktitle> In Proc. 9th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 73-82, </pages> <year> 1993. </year>
Reference-contexts: They further improve the space bound of our method to be linear, however, while still keeping very close to the 2dlog ne query time. Goodrich et. al. [62] use the ideas of *-cutting [70, 90], semi-net [6, 29], and the general theory of geometric range spaces <ref> [6, 31, 61, 88] </ref> to improve the space for the point location method.
Reference: [62] <author> M. T. Goodrich, M. Orletsky, and K. Ramaiyer. </author> <title> Methods for achievint fast query times in point location data structures. </title> <type> Technical Report JHU-CS-TR-96-04, </type> <institution> Department of Computer Science, Johns Hopkins University, Baltimore, MD, </institution> <year> 1996. </year> <note> Submitted for publication to SODA'97. </note>
Reference-contexts: Goodrich et. al. <ref> [62] </ref> show the following lemma: Lemma 4.2.1: (Goodrich et. al. [62]) Given a set S of n non-intersecting line segments (except possibly at segment endpoints), one can construct a point location data structure for S in O (n log n) time and space that achieves a query time of 2dlog ne. <p> Goodrich et. al. <ref> [62] </ref> show the following lemma: Lemma 4.2.1: (Goodrich et. al. [62]) Given a set S of n non-intersecting line segments (except possibly at segment endpoints), one can construct a point location data structure for S in O (n log n) time and space that achieves a query time of 2dlog ne. <p> They further improve the space bound of our method to be linear, however, while still keeping very close to the 2dlog ne query time. Goodrich et. al. <ref> [62] </ref> use the ideas of *-cutting [70, 90], semi-net [6, 29], and the general theory of geometric range spaces [6, 31, 61, 88] to improve the space for the point location method. <p> One in which the edges comprising the epsilon net were maintained in a persistent dictionary supplied by the LEDA software library and the other in which the the edges were stored in a node-copying persistent red-black tree structure (see Orletsky [100] and Goodrich et. al. <ref> [62] </ref>). The adaptive point location method was implemented using a path-copying persistent splay tree structure. Thus, a total of four methods were implemented. 137 These are described below. Point Location Methods: We considered the following implementations of point location methods: 1. Bucket Method [48]. <p> The experimental setup allows one to replace the set of s points with a new set and also increase or decrease the working set size. 4.3.4 Experiments on Uniformly Distributed Query Data For experiments on uniformly distributed query data, we refer the reader to the Ph.D. thesis of Orletsky <ref> [62, 100] </ref>. He shows that the epsilon-net based methods with persistent search structures to locate the visible edges perform better than bucket method for different types of subdivisions. 4.3.5 Experiment 1: Spatial Coherent Query Data We implemented the adaptive point location method using persistent splay tree and conducted several experiments.
Reference: [63] <author> M. T. Goodrich and R. Tamassia. </author> <title> Dynamic ray shooting and shortest paths via balanced geodesic triangulations. </title> <booktitle> In Proc. 9th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 318-327, </pages> <year> 1993. </year>
Reference-contexts: In many dynamic computational geometry algorithms they may even be found as tertiary structures, e.g., see Goodrich and Tamassia <ref> [63] </ref>. 2.1.1 Background and Motivation When a binary search tree T is maintained dynamically as a primary structure it is appropriate to count, as a part of the update time, the time to perform a top-down search for the node (s) in T being changed.
Reference: [64] <author> M. T. Goodrich, J.-J. Tsay, D. E. Vengroff, and J. S. Vitter. </author> <title> External-memory computational geometry. </title> <booktitle> In Proc. 34th Annu. IEEE Sympos. Found. Comput. Sci. (FOCS 93), </booktitle> <pages> pages 714-723, </pages> <year> 1993. </year>
Reference-contexts: involve any geometry, its usage (mainly as secondary structure) in applications in other areas, needs to be explored. 91 Chapter 3 Topology B-Trees and Applications 3.1 Introduction The B-tree [43, 68, 82, 87] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [4, 7, 64, 74, 99, 102, 116, 122] </ref>. Indeed, in his well-known survey paper [43], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [57], which is an elegant internal-memory method for maintaining unbalanced binary trees. 92 Before we describe our specific results, let us review the model for external memory <ref> [4, 64, 74, 99, 102, 116, 122] </ref> that we will be assuming throughout this chapter. 3.1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, to compensate for this
Reference: [65] <author> L. Guibas, E. McCreight, M. Plass, and J. Roberts. </author> <title> A new representation for linear lists. </title> <booktitle> In Proc. 9th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 49-60, </pages> <year> 1977. </year>
Reference-contexts: This may not be appropriate when T is used in tandem with other structures, however, for one may be given, as part of the input to an update operation, pointers directly into the part of T being changed. Such a pointer or "finger" <ref> [65, 73, 79] </ref>, 9 could come, for example, from a query in some auxiliary data structure. <p> The static optimality theorem states that a splay tree is as efficient as an optimal binary search tree [78, 77], which is constructed to improve the search time for frequently accessed items. * The static finger theorem implies that splay trees are good and as efficient as finger search trees <ref> [65, 73, 79] </ref> when the accesses are close to the given finger. * The working set theorem implies that the splay trees are useful to achieve better access times, when there is a temporal coherence among the items in the given access sequence.
Reference: [66] <author> L. J. Guibas and R. Sedgewick. </author> <title> A dichromatic framework for balanced trees. </title> <booktitle> In Proc. 19th Annu. IEEE Sympos. Found. Comput. Sci., Lecture Notes in Computer Science, </booktitle> <pages> pages 8-21, </pages> <year> 1978. </year>
Reference-contexts: Our structure is topologically equivalent 1 to the globally biased search tree given by Bent, Sleator, and Tarjan [14]. In fact, if each item i has weight w i = 1, then our structure is topologically equivalent to a red-black tree <ref> [44, 66, 120] </ref>. It is our update methods and amortized analysis that are different, and this is what allows us to achieve running times that are improvements over those obtained by Bent, Sleator, and Tarjan, even if one ignores the search times in their update procedures. <p> Along with the tree T we also maintain a DCEL [104] (doubly connected edge list) for the subdivision. We maintain the faces of the subdivision as a dictionary D of size O (n) stored in, say, a red-black tree <ref> [44, 66, 120] </ref>. With each face f (which is a node in D), we maintain a dictionary (f ), implemented as a doubly-linked list, of size O (log n) containing pointers to the nodes in T that f covers (ordered by height). <p> Splay trees are self-adjusting binary trees, 126 and they form a simple and very interesting class of "balanced" binary search trees. We highlight the term balanced, because, unlike other binary search trees such as AVL trees [1] or red-black trees <ref> [66, 118] </ref>, splay trees do not enforce explicit global structural constraints.
Reference: [67] <author> L. J. Guibas and J. Stolfi. </author> <title> Primitives for the manipulation of general subdivisions and the computation of Voronoi diagrams. </title> <journal> ACM Trans. Graph., </journal> <volume> 4 </volume> <pages> 74-123, </pages> <year> 1985. </year>
Reference-contexts: For example, in a planar subdivision the clockwise and counter-clockwise orderings of edges around a vertex are often useful for many algorithms involving subdivisions <ref> [67, 104] </ref>. Similarly, facial ordering and connectivity information of subdivisions is often needed and requires special representation. If one is given a collection of horizontal segments, one would like to represent the end points, and also the information of "aboveness" [50]. <p> These include arrangements of lines, Voronoi diagrams, Delaunay triangulations, and general triangulations. The representations for embedded planar graphs include planar straight line graphs [22, 38, 54, 58, 75], doubly connected edge list or DCEL [104], quad-edge structure <ref> [67] </ref>, and winged-edge structure [12].
Reference: [68] <author> O. Gunther and H. Schek. </author> <title> Advances in spatial databases. </title> <booktitle> In Proc. 2nd Symposium, SSD '91, volume 525 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Since the definition of biased finger tree doesn't involve any geometry, its usage (mainly as secondary structure) in applications in other areas, needs to be explored. 91 Chapter 3 Topology B-Trees and Applications 3.1 Introduction The B-tree <ref> [43, 68, 82, 87] </ref> data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory [4, 7, 64, 74, 99, 102, 116, 122]. Indeed, in his well-known survey paper [43], Comer calls B-trees "ubiquitous," for they are found in a host of different applications.
Reference: [69] <author> F. Harary. </author> <title> Graph Theory. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1972. </year>
Reference-contexts: A graph is said to be embedded in a surface S when it is drawn on S so that no two edges intersect. A graph is planar if it can be embedded in the plane; a plane graph has already been embedded in the plane <ref> [69] </ref>. A planar graph can always be embedded in the plane so that all its edges are straight-line segments [54] and such an embedded graph is called planar straight line graph (PSLG). The embedded planar graph in general represents a planar subdivision.
Reference: [70] <author> D. Haussler and E. Welzl. </author> <title> Epsilon-nets and simplex range queries. </title> <journal> Discrete Comput. Geom., </journal> <volume> 2 </volume> <pages> 127-151, </pages> <year> 1987. </year>
Reference-contexts: They further improve the space bound of our method to be linear, however, while still keeping very close to the 2dlog ne query time. Goodrich et. al. [62] use the ideas of *-cutting <ref> [70, 90] </ref>, semi-net [6, 29], and the general theory of geometric range spaces [6, 31, 61, 88] to improve the space for the point location method.
Reference: [71] <author> J. Hershberger and S. Suri. </author> <title> O*ine maintenance of planar configurations. </title> <booktitle> In Proc. 2nd ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 32-41, </pages> <year> 1991. </year>
Reference-contexts: We refer to this as the "geometric data structure solution" approach. This approach is widely used by several researchers to design very elegant data structures to solve a number of geometry problems <ref> [30, 42, 45, 46, 52, 71, 76, 83, 103, 113] </ref>.
Reference: [72] <author> S. Huddleston and K. Mehlhorn. </author> <title> Robust balancing in b-trees. </title> <booktitle> volume 104 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Moreover, we provide an alternative proof that red-black trees support constant-time amortized finger updates (that is a fact known to folklore <ref> [72, 73, 87, 119] </ref>). We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the three-dimensional layers-of-maxima problem [3, 28, 51, 81] and also give improved methods for dynamic point location in a convex subdivision [37, 103].
Reference: [73] <author> S. Huddleston and K. Mehlhorn. </author> <title> A new data structure for representing sorted lists. </title> <journal> Acta Informatica, </journal> <volume> 17 </volume> <pages> 157-184, </pages> <year> 1982. </year>
Reference-contexts: This may not be appropriate when T is used in tandem with other structures, however, for one may be given, as part of the input to an update operation, pointers directly into the part of T being changed. Such a pointer or "finger" <ref> [65, 73, 79] </ref>, 9 could come, for example, from a query in some auxiliary data structure. <p> Such a pointer or "finger" [65, 73, 79], 9 could come, for example, from a query in some auxiliary data structure. This may, in fact, have been a prime motivating factor behind the method of Huddleston and Mehlhorn <ref> [73] </ref> for designing a dynamic search tree that has an O (1) update time performance for insertions and deletions when the search time is not counted, where we use " O () time" to refer to a worst-case time bound that is amortized over a sequence of updates. <p> Moreover, we provide an alternative proof that red-black trees support constant-time amortized finger updates (that is a fact known to folklore <ref> [72, 73, 87, 119] </ref>). We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the three-dimensional layers-of-maxima problem [3, 28, 51, 81] and also give improved methods for dynamic point location in a convex subdivision [37, 103]. <p> The static optimality theorem states that a splay tree is as efficient as an optimal binary search tree [78, 77], which is constructed to improve the search time for frequently accessed items. * The static finger theorem implies that splay trees are good and as efficient as finger search trees <ref> [65, 73, 79] </ref> when the accesses are close to the given finger. * The working set theorem implies that the splay trees are useful to achieve better access times, when there is a temporal coherence among the items in the given access sequence.
Reference: [74] <author> P. C. Kanellakis, S. Ramaswamy, D. E. Vengroff, and J. S. Vitter. </author> <title> Indexing for data models with constraints and classes. </title> <booktitle> In Proc. 12th ACM SIGACT-SIGMOD-SIGART Conf. Princ. Database Sys., </booktitle> <pages> pages 233-243, </pages> <year> 1993. </year>
Reference-contexts: involve any geometry, its usage (mainly as secondary structure) in applications in other areas, needs to be explored. 91 Chapter 3 Topology B-Trees and Applications 3.1 Introduction The B-tree [43, 68, 82, 87] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [4, 7, 64, 74, 99, 102, 116, 122] </ref>. Indeed, in his well-known survey paper [43], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [57], which is an elegant internal-memory method for maintaining unbalanced binary trees. 92 Before we describe our specific results, let us review the model for external memory <ref> [4, 64, 74, 99, 102, 116, 122] </ref> that we will be assuming throughout this chapter. 3.1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, to compensate for this
Reference: [75] <author> G. Kant. </author> <title> Drawing planar graphs using the canonical ordering. </title> <journal> Algorithmica. </journal> <note> (special issue on Graph Drawing, </note> <author> edited by G. Di Battista and R. Tamassia, </author> <note> to appear). </note>
Reference-contexts: There are however, several interesting special cases of embedded planar graphs, which are very useful for various applications. These include arrangements of lines, Voronoi diagrams, Delaunay triangulations, and general triangulations. The representations for embedded planar graphs include planar straight line graphs <ref> [22, 38, 54, 58, 75] </ref>, doubly connected edge list or DCEL [104], quad-edge structure [67], and winged-edge structure [12].
Reference: [76] <author> D. G. Kirkpatrick. </author> <title> Optimal search in planar subdivisions. </title> <journal> SIAM J. Comput., </journal> <volume> 12 </volume> <pages> 28-35, </pages> <year> 1983. </year>
Reference-contexts: We refer to this as the "geometric data structure solution" approach. This approach is widely used by several researchers to design very elegant data structures to solve a number of geometry problems <ref> [30, 42, 45, 46, 52, 71, 76, 83, 103, 113] </ref>. <p> The point location query takes a point as an argument and identifies the face in the underlying plane graph that contains the given point. There are several optimal solutions for this problem in static as well as in dynamic scenario <ref> [42, 46, 52, 76, 83, 103, 113] </ref>. The optimal static algorithms show that one can construct a O (n)-space data structure with O (n log n) time preprocessing which answer queries in O (log n) time. The dynamic algorithms have different performances based on the type of subdivision. <p> The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [42, 51, 52, 76, 83, 84, 103, 104, 106, 107, 113] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [42, 52, 76, 113]. <p> It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time <ref> [42, 52, 76, 113] </ref>. These optimal data structures are static, however, in that they do not allow for any changes to S to occur after the data structure is constructed. <p> This problem is very well-studied <ref> [42, 46, 52, 76, 83, 103, 113] </ref>, and there are a number of solutions that asymptotically achieve query times of O (log n) using O (n) space, which is optimal. <p> Their method is based upon a somewhat more-sophisticated separating chain decomposition technique. Using an interesting trapezoid technique, Preparata [103] showed that one could achieve a query time of 4dlog ne using O (n log n) space, and Kirkpatrick <ref> [76] </ref> was the first to show that one could in fact simultaneously achieve an O (log n) query time and O (n) space. His method is based upon a beautiful hierarchical subdivision method, but the constant factor in the running time is fairly large.
Reference: [77] <author> D. Knuth. </author> <title> Optimum binary search trees. </title> <journal> Acta Informatica, </journal> <volume> 1 </volume> <pages> 14-25, </pages> <year> 1971. </year> <month> 159 </month>
Reference-contexts: theorem states that if large number of accesses are performed on a splay tree (m &gt; n), then splay tree is as efficient as any other form of balanced search tree. * The static optimality theorem states that a splay tree is as efficient as an optimal binary search tree <ref> [78, 77] </ref>, which is constructed to improve the search time for frequently accessed items. * The static finger theorem implies that splay trees are good and as efficient as finger search trees [65, 73, 79] when the accesses are close to the given finger. * The working set theorem implies that
Reference: [78] <author> D. E. Knuth. </author> <title> Sorting and Searching, </title> <booktitle> volume 3 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference-contexts: Another important variant concerns the case when each item i in the search tree is given a weight, w i . This weight is a positive integer that may be proportional to an access probability, as in an optimal binary search tree structure <ref> [5, 78] </ref>. Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [114] (that itself has many applications [41, 53, 60]) or in a point location structure built using the trapezoid method [37, 103, 108]. <p> This bias property is same as what Bent, Sleator, and Tarjan [14] define as global bias. We now review the standard rotations one performs to balance a binary search tree <ref> [5, 44, 78] </ref>. Consider the two configurations of a structure shown in Figure 2.2, where 15 A, B, and C, are arbitrary subtrees and x and y are two nodes. <p> theorem states that if large number of accesses are performed on a splay tree (m &gt; n), then splay tree is as efficient as any other form of balanced search tree. * The static optimality theorem states that a splay tree is as efficient as an optimal binary search tree <ref> [78, 77] </ref>, which is constructed to improve the search time for frequently accessed items. * The static finger theorem implies that splay trees are good and as efficient as finger search trees [65, 73, 79] when the accesses are close to the given finger. * The working set theorem implies that
Reference: [79] <author> S. Kosaraju. </author> <title> Localized search in sorted lists. </title> <booktitle> In Proc. 13th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 62-69, </pages> <year> 1981. </year>
Reference-contexts: This may not be appropriate when T is used in tandem with other structures, however, for one may be given, as part of the input to an update operation, pointers directly into the part of T being changed. Such a pointer or "finger" <ref> [65, 73, 79] </ref>, 9 could come, for example, from a query in some auxiliary data structure. <p> The static optimality theorem states that a splay tree is as efficient as an optimal binary search tree [78, 77], which is constructed to improve the search time for frequently accessed items. * The static finger theorem implies that splay trees are good and as efficient as finger search trees <ref> [65, 73, 79] </ref> when the accesses are close to the given finger. * The working set theorem implies that the splay trees are useful to achieve better access times, when there is a temporal coherence among the items in the given access sequence.
Reference: [80] <author> S. Kosaraju. </author> <title> An optimal ram implementation of catenable min double-ended queues. </title> <booktitle> In Proc. 5th ACM-SIAM. on Discrete Algorithms, </booktitle> <pages> pages 195-203, </pages> <year> 1994. </year>
Reference-contexts: We assign three types of credits to nodes of a biased finger tree as follows: Twin-node credit : A node u is assigned a constant number of twin-node credits, if u and its sibling have the same rank. This type of credit was suggested by Kosaraju <ref> [80] </ref>. We use these twin-node credits to amortize the cost of rebalancing operations. Spine-node credit : A node u is assigned a constant number of spine-node credits, if u occurs along the leftmost or the rightmost root-to-leaf path of the tree containing it.
Reference: [81] <author> H. T. Kung, F. Luccio, and F. P. Preparata. </author> <title> On finding the maxima of a set of vectors. </title> <journal> J. ACM, </journal> <volume> 22 </volume> <pages> 469-476, </pages> <year> 1975. </year>
Reference-contexts: We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the three-dimensional layers-of-maxima problem <ref> [3, 28, 51, 81] </ref> and also give improved methods for dynamic point location in a convex subdivision [37, 103]. The space-sweeping algorithm makes use of dynamic point location in a staircase subdivision, which we deal with as a special case of point location in convex subdivision. <p> The layers-of-maxima problem is to determine the layer of each point p in S. This is related to the well-known convex layers problem [28]. Kung, Luccio, and Preparata <ref> [81] </ref> showed that 3-dimensional maxima set problem can be solved in O (n log n) time.
Reference: [82] <author> R. Laurini and D. Thompson. </author> <title> Fundamentals of Spatial Information Systems. </title> <publisher> Academic Press, </publisher> <address> Boston, MA, </address> <year> 1992. </year>
Reference-contexts: Since the definition of biased finger tree doesn't involve any geometry, its usage (mainly as secondary structure) in applications in other areas, needs to be explored. 91 Chapter 3 Topology B-Trees and Applications 3.1 Introduction The B-tree <ref> [43, 68, 82, 87] </ref> data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory [4, 7, 64, 74, 99, 102, 116, 122]. Indeed, in his well-known survey paper [43], Comer calls B-trees "ubiquitous," for they are found in a host of different applications.
Reference: [83] <author> D. T. Lee and F. P. Preparata. </author> <title> Location of a point in a planar subdivision and its applications. </title> <journal> SIAM J. Comput., </journal> <volume> 6 </volume> <pages> 594-606, </pages> <year> 1977. </year>
Reference-contexts: We refer to this as the "geometric data structure solution" approach. This approach is widely used by several researchers to design very elegant data structures to solve a number of geometry problems <ref> [30, 42, 45, 46, 52, 71, 76, 83, 103, 113] </ref>. <p> The point location query takes a point as an argument and identifies the face in the underlying plane graph that contains the given point. There are several optimal solutions for this problem in static as well as in dynamic scenario <ref> [42, 46, 52, 76, 83, 103, 113] </ref>. The optimal static algorithms show that one can construct a O (n)-space data structure with O (n log n) time preprocessing which answer queries in O (log n) time. The dynamic algorithms have different performances based on the type of subdivision. <p> The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [42, 51, 52, 76, 83, 84, 103, 104, 106, 107, 113] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [42, 52, 76, 113]. <p> This problem is very well-studied <ref> [42, 46, 52, 76, 83, 103, 113] </ref>, and there are a number of solutions that asymptotically achieve query times of O (log n) using O (n) space, which is optimal. <p> A location query for a point p is easily answered by performing two binary searches|one to locate the slab containing p and another to locate the cell in that slab that contains p. The quadratic space for achieving this query speed is nevertheless quite prohibitive, and Lee and Preparata <ref> [83] </ref> subsequently showed that one could achieve a linear space point location data structure, albeit at the expense of increasing the query time to dlog 2 ne. Their method is based upon a somewhat more-sophisticated separating chain decomposition technique.
Reference: [84] <author> D. T. Lee and F. P. Preparata. </author> <title> Computational geometry: a survey. </title> <journal> IEEE Trans. Comput., </journal> <volume> C-33:1072-1101, </volume> <year> 1984. </year>
Reference-contexts: The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [42, 51, 52, 76, 83, 84, 103, 104, 106, 107, 113] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [42, 52, 76, 113].
Reference: [85] <author> M. Lin and D. Manocha, </author> <title> editors. </title> <booktitle> First ACM Workshop on Applied Computational Geometry, </booktitle> <year> 1996. </year>
Reference-contexts: We also would like focus on problems in specific application areas like Geographic Information Systems and other spatial databases. Recently a lot of attention <ref> [85] </ref> is being paid in the computational geometry community to design robust algorithms for computational geometry problems and also to design theoretical frameworks for dealing with degenaracies.
Reference: [86] <author> G. S. Lueker. </author> <title> A data structure for orthogonal range queries. </title> <booktitle> In Proc. 19th Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 28-34, </pages> <year> 1978. </year>
Reference-contexts: To represent a collection of points in d dimensions, where d is a fixed constant, and to answer queries like nearest neighbor, closest pair, range searching, several data structures like K-D tree [15], range trees <ref> [17, 86] </ref>, quad trees [111, 112], and several variations [8, 10, 4 20, 26, 59] have been proposed.
Reference: [87] <author> D. Maier and S. Salveter. </author> <title> Hysterical B-trees. </title> <journal> Information Processing Letters, </journal> <volume> 12(4) </volume> <pages> 199-202, </pages> <year> 1981. </year>
Reference-contexts: Moreover, we provide an alternative proof that red-black trees support constant-time amortized finger updates (that is a fact known to folklore <ref> [72, 73, 87, 119] </ref>). We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the three-dimensional layers-of-maxima problem [3, 28, 51, 81] and also give improved methods for dynamic point location in a convex subdivision [37, 103]. <p> Since the definition of biased finger tree doesn't involve any geometry, its usage (mainly as secondary structure) in applications in other areas, needs to be explored. 91 Chapter 3 Topology B-Trees and Applications 3.1 Introduction The B-tree <ref> [43, 68, 82, 87] </ref> data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory [4, 7, 64, 74, 99, 102, 116, 122]. Indeed, in his well-known survey paper [43], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. <p> When we split (merge) blocks the pointers get added (removed) 104 to (from) the blocks in the next B-list, which may require further splitting (merging). However, we can do update operations more efficiently on hierarchical B-lists than in B-trees. We use the ideas from update operations on hysterical B-trees <ref> [87] </ref>. We briefly review the hysterical B-trees (HB-trees, from now on). <p> In ungoverned hierarchical B-lists, during update operation we perform a sequence of splits or merges, and each split and merge may require O (B) pointer changes, since we need to add new up pointers to parent blocks. But using the result of hysterical B-trees <ref> [87] </ref> that finger updates take O (1) time, we note that the number of pointer changes during an update operation is O (1).
Reference: [88] <author> J. Matousek. </author> <title> Cutting hyperplane arrangements. </title> <journal> Discrete Comput. Geom., </journal> <volume> 6 </volume> <pages> 385-406, </pages> <year> 1991. </year>
Reference-contexts: They further improve the space bound of our method to be linear, however, while still keeping very close to the 2dlog ne query time. Goodrich et. al. [62] use the ideas of *-cutting [70, 90], semi-net [6, 29], and the general theory of geometric range spaces <ref> [6, 31, 61, 88] </ref> to improve the space for the point location method.
Reference: [89] <author> J. Matousek. </author> <title> Reporting points in halfspaces. </title> <journal> Comput. Geom. Theory Appl., </journal> <volume> 2(3) </volume> <pages> 169-186, </pages> <year> 1992. </year>
Reference-contexts: But this method requires space roughly equal to O (N dd=2e ) [39], which becomes impractical even for small dimensions. With linear space it is conjectured <ref> [9, 89] </ref> that (N 11=bd=2c ) is a lower bound for the exact nearest neighbor problem.
Reference: [90] <author> J. Matousek. </author> <title> Epsilon-nets and computational geometry. </title> <editor> In J. Pach, editor, </editor> <booktitle> New Trends in Discrete and Computational Geometry, volume 10 of Algorithms and Combinatorics, </booktitle> <pages> pages 69-89. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: They further improve the space bound of our method to be linear, however, while still keeping very close to the 2dlog ne query time. Goodrich et. al. [62] use the ideas of *-cutting <ref> [70, 90] </ref>, semi-net [6, 29], and the general theory of geometric range spaces [6, 31, 61, 88] to improve the space for the point location method.
Reference: [91] <author> E. M. McCreight. </author> <title> Efficient algorithms for enumerating intersecting intervals and rectangles. </title> <type> Report CSL-80-9, </type> <institution> Xerox Palo Alto Res. Center, </institution> <address> Palo Alto, CA, </address> <year> 1980. </year>
Reference-contexts: The segment tree [16] is a very useful data structure to represent a collection of segments and to answer questions about them, and the interval tree <ref> [49, 91] </ref> is very useful for maintaining a collection of intervals. A collection of lines in two dimensions or hyperplanes in higher dimensions is represented by an arrangement, which is a planar subdivision in two dimension and spatial partition into polyhedrons in higher dimensions.
Reference: [92] <author> K. Mehlhorn. </author> <title> Multi-dimensional Searching and Computational Geometry, volume 3 of Data Structures and Algorithms. </title> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, West Germany, </address> <year> 1984. </year>
Reference-contexts: The structure of T has the property that any face covers at most O (log n) trapezoids and also each face covers at most two nodes at any level of T . These properties follow easily from arguments like those for segment trees <ref> [92] </ref>. Along with the tree T we also maintain a DCEL [104] (doubly connected edge list) for the subdivision. We maintain the faces of the subdivision as a dictionary D of size O (n) stored in, say, a red-black tree [44, 66, 120].
Reference: [93] <author> K. Mehlhorn. </author> <title> Sorting and Searching, volume 1 of Data Structures and Algorithms. </title> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, West Germany, </address> <year> 1984. </year>
Reference-contexts: If we implement T as a weight-balanced BB [ff]-tree data structure <ref> [21, 93, 98] </ref>, then we can maintain T so that tree-search queries take O (log n) time in the worst case (for this is the worst-case depth of T ) and insert and delete operations take O (log n) time (e.g., see Mehlhorn [93]). 2.4.2 Our Data Structure Suppose we are <p> as a weight-balanced BB [ff]-tree data structure [21, 93, 98], then we can maintain T so that tree-search queries take O (log n) time in the worst case (for this is the worst-case depth of T ) and insert and delete operations take O (log n) time (e.g., see Mehlhorn <ref> [93] </ref>). 2.4.2 Our Data Structure Suppose we are given a convex subdivision S that we would like to maintain dynamically subject to point location queries and edge and vertex insertions and deletions. <p> Also, assume that we perform a sequence of n update operations, each an insertion or a deletion, into an initially empty BB [ff]-tree. Now, we have the following times for rebalancing <ref> [93] </ref>: * If f (l) = O (l log c l), with c 0, then the rebalancing time for an update operation is O (log c+1 n). * If f (l) = O (l a ), with a &lt; 1, then the rebalancing time for an update operation is O (1).
Reference: [94] <author> K. Mehlhorn and S. Naher. </author> <title> Dynamic fractional cascading. </title> <journal> Algorithmica, </journal> <volume> 5 </volume> <pages> 215-241, </pages> <year> 1990. </year>
Reference-contexts: It appears that 3-dimensional layers of maxima problem can be solved for a 3-dimensional point set S in O (n log n log log n) time [2] using the dynamic fractional cascading technique of Mehlhorn and Naher <ref> [94] </ref>. We show how to solve the 3-dimensional layers-of-maxima problem in O (n log n) time, which is optimal 6 . We solve this problem using a combination of three-dimensional sweep and a dynamic method for point location in a staircase subdivision. <p> [33] O (log 2 n) O (log n) O (log n) Connected [34] O (log n) O (log 3 n) O (log 3 n) Monotone [37] O (log n) O (log 2 n) O (log 2 n) Monotone [60] O (log 2 n) O (log n) O (log n) Rectilinear <ref> [94] </ref> O (log n log log n) O (log n log log n) O (log n log log n) Convex [108] O (log n + log N ) O (log n log N ) O (log n log N ) Convex (ours) 8 O (log n) O (log n) O (log
Reference: [95] <author> K. Mehlhorn and S. Naher. Leda, </author> <title> a platform for combinatorial and geometric computing. </title> <journal> Communications of the ACM, </journal> <volume> 38(1) </volume> <pages> 96-102, </pages> <year> 1995. </year> <month> 160 </month>
Reference-contexts: A query is then answered by finding a visible edge from the net to the probe point, by using the search structure, and then traversing the subdivision itself from this edge to the face containing the probe point. Here, the LEDA <ref> [95, 97] </ref> persistent dictionary class is used as the structure to hold the edges from the net. We call this method the e-net-leda method. 138 3. Epsilon-net method using an node-copying [47] persistence. <p> The persistent splay tree is built using path-copying strategy during updates and splay operations during queries are performed in a destructive manner, i.e., the particular version being searched is restructured. All algorithms were implemented in C++ using the LEDA <ref> [95, 97] </ref> library of data structures and algorithms (v3.2.1), and they were compiled on a SUN SPARC station ELC running SUN OS Release 4.1.1 with the g++ compiler (v4.2). Three different classes of input subdivisions were used to test the performance of the above algorithms. <p> Uniform Subdivisions. The uniform subdivisions were constructed by randomly generating the desired number of vertices in the unit square and then using the LEDA <ref> [95, 97] </ref> library (v3.3.c) routine DELAUNAY TRIANG to construct a Delaunay triangulation over the point set. These subdivisions are very regular in that they have edges that are similar in length. 2. LEDA Subdivision. The LEDA subdivisions were constructed with the LEDA random planar graph routine.
Reference: [96] <author> J. Melton and A. Simon. </author> <title> Understanding the New SQL: A Complete Guide. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: Computational geometry data structures and algorithms are directly applicable in providing spatial extension to the type of data stored in a database. There are now several efforts in the ANSI standards committee to define spatial extensions to the SQL <ref> [96] </ref>, the query language used by the database community, which will allow users to store and retrieve geometric objects. The new data types being considered are two and three dimensional geometric data types, like points, lines, polygons, polytope, segments, etc.
Reference: [97] <author> S. Naher and C. Uhrig. </author> <title> The LEDA User Manual Version R 3.2. </title> <institution> Max-Planck-Institut fur Informatik. </institution>
Reference-contexts: A query is then answered by finding a visible edge from the net to the probe point, by using the search structure, and then traversing the subdivision itself from this edge to the face containing the probe point. Here, the LEDA <ref> [95, 97] </ref> persistent dictionary class is used as the structure to hold the edges from the net. We call this method the e-net-leda method. 138 3. Epsilon-net method using an node-copying [47] persistence. <p> The persistent splay tree is built using path-copying strategy during updates and splay operations during queries are performed in a destructive manner, i.e., the particular version being searched is restructured. All algorithms were implemented in C++ using the LEDA <ref> [95, 97] </ref> library of data structures and algorithms (v3.2.1), and they were compiled on a SUN SPARC station ELC running SUN OS Release 4.1.1 with the g++ compiler (v4.2). Three different classes of input subdivisions were used to test the performance of the above algorithms. <p> Uniform Subdivisions. The uniform subdivisions were constructed by randomly generating the desired number of vertices in the unit square and then using the LEDA <ref> [95, 97] </ref> library (v3.3.c) routine DELAUNAY TRIANG to construct a Delaunay triangulation over the point set. These subdivisions are very regular in that they have edges that are similar in length. 2. LEDA Subdivision. The LEDA subdivisions were constructed with the LEDA random planar graph routine.
Reference: [98] <author> J. Nievergelt and E. Reingold. </author> <title> Binary search trees of bounded balanced. </title> <journal> SIAM J. Computing, </journal> <volume> 2 </volume> <pages> 33-43, </pages> <year> 1973. </year>
Reference-contexts: If we implement T as a weight-balanced BB [ff]-tree data structure <ref> [21, 93, 98] </ref>, then we can maintain T so that tree-search queries take O (log n) time in the worst case (for this is the worst-case depth of T ) and insert and delete operations take O (log n) time (e.g., see Mehlhorn [93]). 2.4.2 Our Data Structure Suppose we are
Reference: [99] <author> M. H. Nodine, M. T. Goodrich, and J. S. Vitter. </author> <title> Blocking for external graph searching. </title> <booktitle> In Proceedings of the 12th Annual ACM Symposium on Principles of Database Systems (PODS '93), </booktitle> <pages> pages 222-232, </pages> <year> 1993. </year>
Reference-contexts: involve any geometry, its usage (mainly as secondary structure) in applications in other areas, needs to be explored. 91 Chapter 3 Topology B-Trees and Applications 3.1 Introduction The B-tree [43, 68, 82, 87] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [4, 7, 64, 74, 99, 102, 116, 122] </ref>. Indeed, in his well-known survey paper [43], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [57], which is an elegant internal-memory method for maintaining unbalanced binary trees. 92 Before we describe our specific results, let us review the model for external memory <ref> [4, 64, 74, 99, 102, 116, 122] </ref> that we will be assuming throughout this chapter. 3.1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, to compensate for this
Reference: [100] <author> M. Orletsky. </author> <title> Practical Methods for Geometric Searching Problems with Experimental Validation. </title> <type> PhD thesis, </type> <institution> The Johns Hopkins University, Computer Science Department, </institution> <year> 1996. </year>
Reference-contexts: One in which the edges comprising the epsilon net were maintained in a persistent dictionary supplied by the LEDA software library and the other in which the the edges were stored in a node-copying persistent red-black tree structure (see Orletsky <ref> [100] </ref> and Goodrich et. al. [62]). The adaptive point location method was implemented using a path-copying persistent splay tree structure. Thus, a total of four methods were implemented. 137 These are described below. Point Location Methods: We considered the following implementations of point location methods: 1. Bucket Method [48]. <p> The experimental setup allows one to replace the set of s points with a new set and also increase or decrease the working set size. 4.3.4 Experiments on Uniformly Distributed Query Data For experiments on uniformly distributed query data, we refer the reader to the Ph.D. thesis of Orletsky <ref> [62, 100] </ref>. He shows that the epsilon-net based methods with persistent search structures to locate the visible edges perform better than bucket method for different types of subdivisions. 4.3.5 Experiment 1: Spatial Coherent Query Data We implemented the adaptive point location method using persistent splay tree and conducted several experiments.
Reference: [101] <author> M. H. Overmars. </author> <title> The design of dynamic data structures, </title> <booktitle> volume 156 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference: [102] <author> M. H. Overmars, M. H. M. Smid, M. T. de Berg, and M. J. van Kreveld. </author> <title> Maintaining range trees in secondary memory, part I: partitions. </title> <journal> Acta Inform., </journal> <volume> 27 </volume> <pages> 423-452, </pages> <year> 1990. </year>
Reference-contexts: involve any geometry, its usage (mainly as secondary structure) in applications in other areas, needs to be explored. 91 Chapter 3 Topology B-Trees and Applications 3.1 Introduction The B-tree [43, 68, 82, 87] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [4, 7, 64, 74, 99, 102, 116, 122] </ref>. Indeed, in his well-known survey paper [43], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [57], which is an elegant internal-memory method for maintaining unbalanced binary trees. 92 Before we describe our specific results, let us review the model for external memory <ref> [4, 64, 74, 99, 102, 116, 122] </ref> that we will be assuming throughout this chapter. 3.1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, to compensate for this
Reference: [103] <author> F. P. Preparata. </author> <title> A new approach to planar point location. </title> <journal> SIAM J. Comput., </journal> <volume> 10 </volume> <pages> 473-482, </pages> <year> 1981. </year>
Reference-contexts: We refer to this as the "geometric data structure solution" approach. This approach is widely used by several researchers to design very elegant data structures to solve a number of geometry problems <ref> [30, 42, 45, 46, 52, 71, 76, 83, 103, 113] </ref>. <p> The point location query takes a point as an argument and identifies the face in the underlying plane graph that contains the given point. There are several optimal solutions for this problem in static as well as in dynamic scenario <ref> [42, 46, 52, 76, 83, 103, 113] </ref>. The optimal static algorithms show that one can construct a O (n)-space data structure with O (n log n) time preprocessing which answer queries in O (log n) time. The dynamic algorithms have different performances based on the type of subdivision. <p> Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [114] (that itself has many applications [41, 53, 60]) or in a point location structure built using the trapezoid method <ref> [37, 103, 108] </ref>. In cases with weighted items such as these one desires a search tree satisfying a bias property that forces the depth of each item i in the tree be roughly inversely proportional to log w i . <p> We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the three-dimensional layers-of-maxima problem [3, 28, 51, 81] and also give improved methods for dynamic point location in a convex subdivision <ref> [37, 103] </ref>. The space-sweeping algorithm makes use of dynamic point location in a staircase subdivision, which we deal with as a special case of point location in convex subdivision. <p> The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [42, 51, 52, 76, 83, 84, 103, 104, 106, 107, 113] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [42, 52, 76, 113]. <p> Thus, our method has an optimal update time of O (log n) in the on-line (also called "semi-dynamic") case. Our method is based upon a variant of the static "trapezoid" method of Preparata <ref> [103] </ref>, dynamized through the use of the biased finger tree data structure. We also extend our approach to obtain a dynamic data structure for point location in a staircase subdivision, with logarithmic query and update times, which is optimal. <p> As mentioned above, our method for maintaining S is based upon a dynamic implementation of the "trapezoid method" of Preparata <ref> [103] </ref> for static point location. Incidentally, this is also the approach used by Chiang and Tamassia [37], albeit in a different way. <p> Let us assume, for the time being, that the x-coordinates of the segment endpoints are integers in the range [1; n] (we will show later how to get around this restriction using the BB [ff] tree). We define our structure recursively, following the general approach of Preparata <ref> [103] </ref>. Our structure is a rooted tree, T , each of whose nodes is associated with a trapezoid t whose parallel boundary edges are vertical. <p> This is because the times to perform the biased tree queries down a path in T form a telescoping sum that is O (log w (r)). Noting that w (r) is O (n log n) (see <ref> [103] </ref>) and depth (t ) is O (log n) (since our primary data 69 structure is a tree of vertical cuts that forms a complete balanced tree on integers in the range [1; n]) gives us the desired result that a point location query takes O (log n) time. <p> This problem is very well-studied <ref> [42, 46, 52, 76, 83, 103, 113] </ref>, and there are a number of solutions that asymptotically achieve query times of O (log n) using O (n) space, which is optimal. <p> Their method is based upon a somewhat more-sophisticated separating chain decomposition technique. Using an interesting trapezoid technique, Preparata <ref> [103] </ref> showed that one could achieve a query time of 4dlog ne using O (n log n) space, and Kirkpatrick [76] was the first to show that one could in fact simultaneously achieve an O (log n) query time and O (n) space. <p> We note that this method achieves the same space bound as that of the trapezoid method <ref> [103] </ref> but has a worst-case query time that is twice as fast. They further improve the space bound of our method to be linear, however, while still keeping very close to the 2dlog ne query time.
Reference: [104] <author> F. P. Preparata and M. I. Shamos. </author> <title> Computational Geometry: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1985. </year>
Reference-contexts: For example, in a planar subdivision the clockwise and counter-clockwise orderings of edges around a vertex are often useful for many algorithms involving subdivisions <ref> [67, 104] </ref>. Similarly, facial ordering and connectivity information of subdivisions is often needed and requires special representation. If one is given a collection of horizontal segments, one would like to represent the end points, and also the information of "aboveness" [50]. <p> Each of these structures have unique properties that need to be reflected in its representation as any algorithm involving these structures will exploit those properties. We now briefly review some of the classical data structures in the area of computational geometry. The book by Preparata and Shamos <ref> [104] </ref> is by now a classical book in the area of computational geometry and is a good source of information for various geometry data structures and algorithms. A graph is said to be embedded in a surface S when it is drawn on S so that no two edges intersect. <p> These include arrangements of lines, Voronoi diagrams, Delaunay triangulations, and general triangulations. The representations for embedded planar graphs include planar straight line graphs [22, 38, 54, 58, 75], doubly connected edge list or DCEL <ref> [104] </ref>, quad-edge structure [67], and winged-edge structure [12]. <p> In some cases they serve as stand-alone structures (e.g., implementing a dictionary or a heap), while in many cases they are used in tandem with other structures, either as primary or secondary structures (or both, as in the range tree <ref> [104] </ref>). <p> The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [42, 51, 52, 76, 83, 84, 103, 104, 106, 107, 113] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [42, 52, 76, 113]. <p> These properties follow easily from arguments like those for segment trees [92]. Along with the tree T we also maintain a DCEL <ref> [104] </ref> (doubly connected edge list) for the subdivision. We maintain the faces of the subdivision as a dictionary D of size O (n) stored in, say, a red-black tree [44, 66, 120].
Reference: [105] <author> F. P. Preparata and R. Tamassia. </author> <title> A fully dynamic planar point location technique. </title> <type> Report UILU-ENG-87-2266, </type> <institution> Coordinated Sci. Lab., Univ. Illinois, Urbana, IL, </institution> <year> 1987. </year>
Reference-contexts: All of our methods assume that the planar subdivision does not change over time, but environments allowing for dynamic changes to the subdivision over time are well-motivated and well-studied, as well <ref> [11, 13, 33, 35, 60, 105, 107, 108, 117] </ref>.
Reference: [106] <author> F. P. Preparata and R. Tamassia. </author> <title> Efficient spatial point location. </title> <booktitle> In Proc. 1st Workshop Algorithms Data Struct., volume 382 of Lecture Notes in Computer Science, </booktitle> <pages> pages 3-11. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [42, 51, 52, 76, 83, 84, 103, 104, 106, 107, 113] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [42, 52, 76, 113].
Reference: [107] <author> F. P. Preparata and R. Tamassia. </author> <title> Fully dynamic point location in a monotone subdivision. </title> <journal> SIAM J. Comput., </journal> <volume> 18 </volume> <pages> 811-830, </pages> <year> 1989. </year>
Reference-contexts: The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [42, 51, 52, 76, 83, 84, 103, 104, 106, 107, 113] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [42, 52, 76, 113]. <p> All of our methods assume that the planar subdivision does not change over time, but environments allowing for dynamic changes to the subdivision over time are well-motivated and well-studied, as well <ref> [11, 13, 33, 35, 60, 105, 107, 108, 117] </ref>.
Reference: [108] <author> F. P. Preparata and R. Tamassia. </author> <title> Dynamic planar point location with optimal query time. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 74 </volume> <pages> 95-114, </pages> <year> 1990. </year>
Reference-contexts: Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [114] (that itself has many applications [41, 53, 60]) or in a point location structure built using the trapezoid method <ref> [37, 103, 108] </ref>. In cases with weighted items such as these one desires a search tree satisfying a bias property that forces the depth of each item i in the tree be roughly inversely proportional to log w i . <p> O (log 3 n) Monotone [37] O (log n) O (log 2 n) O (log 2 n) Monotone [60] O (log 2 n) O (log n) O (log n) Rectilinear [94] O (log n log log n) O (log n log log n) O (log n log log n) Convex <ref> [108] </ref> O (log n + log N ) O (log n log N ) O (log n log N ) Convex (ours) 8 O (log n) O (log n) O (log 2 n) Staircase (ours) O (log n) O (log n) O (log n) 7 Cheng and Janardan's update method is <p> All of our methods assume that the planar subdivision does not change over time, but environments allowing for dynamic changes to the subdivision over time are well-motivated and well-studied, as well <ref> [11, 13, 33, 35, 60, 105, 107, 108, 117] </ref>.
Reference: [109] <author> W. Pugh. </author> <title> Skip lists: A probabilistic alternative to balanced trees. </title> <journal> Communications of the ACM, </journal> <volume> 33(6) </volume> <pages> 668-676, </pages> <year> 1990. </year>
Reference-contexts: This structure is motivated by the skip list structure of Pugh <ref> [109] </ref>. The hierarchical B-list consists of a hierarchy of B-lists in which only the blocks of adjacent B-lists are connected. We assign a level to each B-list, and the level numbers increase from bottom to the top of the hierarchy.
Reference: [110] <author> K. Ramaiyer, R. J. Brunner, A. Szalay, A. J. Connolly, and R. H. Lupton. </author> <title> A prototype astronomical database. </title> <booktitle> In Proceedings of the Second ACM Workshop on Advances in Geographic Information Systems, </booktitle> <pages> pages 95-100, </pages> <year> 1994. </year>
Reference-contexts: This offers potential challenges in terms of implementations of geometric data organization and geometric query optimization. Since the database generally involves large amounts of data, one needs to consider designing efficient spatial data structures for storage and retrieval of geometric objects. Sloan Digital Sky Survey (SDSS) project <ref> [24, 23, 110] </ref> is one such spatial database 152 application which offers several challenges for the geometry community in terms of organization of the geometry data and support for various queries. The survey aims at creating a comprehensive digital map of the northern sky.
Reference: [111] <author> H. Samet. </author> <title> Applications of Spatial Data Structures. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: To represent a collection of points in d dimensions, where d is a fixed constant, and to answer queries like nearest neighbor, closest pair, range searching, several data structures like K-D tree [15], range trees [17, 86], quad trees <ref> [111, 112] </ref>, and several variations [8, 10, 4 20, 26, 59] have been proposed.
Reference: [112] <author> H. Samet. </author> <title> Applications of Spatial Data Structures: Computer Graphics, Image Processing, and GIS. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year> <month> 161 </month>
Reference-contexts: To represent a collection of points in d dimensions, where d is a fixed constant, and to answer queries like nearest neighbor, closest pair, range searching, several data structures like K-D tree [15], range trees [17, 86], quad trees <ref> [111, 112] </ref>, and several variations [8, 10, 4 20, 26, 59] have been proposed. <p> We are interested in re-examining the point location problem, focusing on issues that arise in important application areas, such as geographic information systems (GIS) <ref> [19, 18, 55, 112, 121] </ref> 12 . Our re-examination of the point-location problem focuses on 12 Geographic Information Systems are powerful computing tools that manage the geometry of maps and their related geographic images and data. They are used in a variety of governmental and scientific domains.
Reference: [113] <author> N. Sarnak and R. E. Tarjan. </author> <title> Planar point location using persistent search trees. </title> <journal> Commun. ACM, </journal> <volume> 29 </volume> <pages> 669-679, </pages> <year> 1986. </year>
Reference-contexts: We refer to this as the "geometric data structure solution" approach. This approach is widely used by several researchers to design very elegant data structures to solve a number of geometry problems <ref> [30, 42, 45, 46, 52, 71, 76, 83, 103, 113] </ref>. <p> The point location query takes a point as an argument and identifies the face in the underlying plane graph that contains the given point. There are several optimal solutions for this problem in static as well as in dynamic scenario <ref> [42, 46, 52, 76, 83, 103, 113] </ref>. The optimal static algorithms show that one can construct a O (n)-space data structure with O (n log n) time preprocessing which answer queries in O (log n) time. The dynamic algorithms have different performances based on the type of subdivision. <p> The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [42, 51, 52, 76, 83, 84, 103, 104, 106, 107, 113] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [42, 52, 76, 113]. <p> It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time <ref> [42, 52, 76, 113] </ref>. These optimal data structures are static, however, in that they do not allow for any changes to S to occur after the data structure is constructed. <p> This problem is very well-studied <ref> [42, 46, 52, 76, 83, 103, 113] </ref>, and there are a number of solutions that asymptotically achieve query times of O (log n) using O (n) space, which is optimal. <p> Still, based upon their benchmarking tests, they argued that the best practical method at that time was the bucketing approach, with the trapezoid method being a close competitor. Following this, Cole [42], Sarnak and Tar-jan <ref> [113] </ref>, and Edelsbrunner, Guibas, and Stolfi [52] independently showed how to improve the constant factor in the query time for point location while still achieving linear space. These three methods are described quite differently, but the resulting data structures are remarkably similar. <p> We first give an overview of the method. We use a combination of ideas from the slab method [46] and the persistent methods <ref> [27, 42, 113] </ref> and modify them to achieve a fast query time. We first divide the planar regions into vertical slabs by dropping vertical lines 131 through each of the vertices of the subdivision. The resulting segments within each slab form a total order.
Reference: [114] <author> D. D. Sleator and R. E. Tarjan. </author> <title> A data structure for dynamic trees. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 26(3) </volume> <pages> 362-381, </pages> <year> 1983. </year>
Reference-contexts: This weight is a positive integer that may be proportional to an access probability, as in an optimal binary search tree structure [5, 78]. Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure <ref> [114] </ref> (that itself has many applications [41, 53, 60]) or in a point location structure built using the trapezoid method [37, 103, 108].
Reference: [115] <author> D. D. Sleator and R. E. Tarjan. </author> <title> Self-adjusting binary search trees. </title> <journal> J. ACM, </journal> <volume> 32(3) </volume> <pages> 652-686, </pages> <year> 1985. </year>
Reference-contexts: We now turn our attention to adaptive point location method and develop a data structure which supports spatially and temporally coherent queries efficiently. 4.2.1 Splay Trees We achieve our results concerning adaptive point location queries by employing the splay tree data structure of Sleator and Tarjan <ref> [115] </ref>. Splay trees are self-adjusting binary trees, 126 and they form a simple and very interesting class of "balanced" binary search trees. <p> Also Sleator and Tarjan prove a vast number of useful theorems regarding a sequence of m accesses in a splay tree, which we summarize below. Lemma 4.2.3 Access Lemma <ref> [115] </ref>: The time to splay a tree with root t at a node x is at most O (log n), where n is the number of nodes in the tree. Theorem 4.2.4 Balance Theorem [115]: The total access time is O ((m + n) log n). <p> Lemma 4.2.3 Access Lemma <ref> [115] </ref>: The time to splay a tree with root t at a node x is at most O (log n), where n is the number of nodes in the tree. Theorem 4.2.4 Balance Theorem [115]: The total access time is O ((m + n) log n). Theorem 4.2.5 Static Optimality Theorem [115]: If every item is accessed at least once, then the total access time is O P n f (i) , where f (i) is the access frequency of item i in m accesses. <p> Theorem 4.2.4 Balance Theorem <ref> [115] </ref>: The total access time is O ((m + n) log n). Theorem 4.2.5 Static Optimality Theorem [115]: If every item is accessed at least once, then the total access time is O P n f (i) , where f (i) is the access frequency of item i in m accesses. <p> Let i j be the item accessed at search j, where j ranges from 1 to m. Theorem 4.2.6 Static Finger Theorem <ref> [115] </ref>: If f is any fixed item, then the total access time is O P m 127 Let t (j) denote the number of different queries before search j and since the last access of item i j or since the beginning of the sequence if j is the first access <p> Theorem 4.2.7 Working Set Theorem <ref> [115] </ref>: The total access time is O (n log n + m + j=1 To summarize, the theorems imply the following facts: * The balance theorem states that if large number of accesses are performed on a splay tree (m &gt; n), then splay tree is as efficient as any other <p> In the zig-zig case and the zig-zag case, we recursively continue the splay at x with its new parent. In the zig case, however, we terminate. Sleator and Tarjan <ref> [115] </ref> show that a sequence of O (n) splay operations on an n node splay tree requires O (n log n) time. They also that the splay can be implemented as a top-down operation.
Reference: [116] <author> M. H. M. Smid and M. H. Overmars. </author> <title> Maintaining range trees in secondary memory, part II: lower bounds. </title> <journal> Acta Inform., </journal> <volume> 27 </volume> <pages> 453-480, </pages> <year> 1990. </year>
Reference-contexts: involve any geometry, its usage (mainly as secondary structure) in applications in other areas, needs to be explored. 91 Chapter 3 Topology B-Trees and Applications 3.1 Introduction The B-tree [43, 68, 82, 87] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [4, 7, 64, 74, 99, 102, 116, 122] </ref>. Indeed, in his well-known survey paper [43], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [57], which is an elegant internal-memory method for maintaining unbalanced binary trees. 92 Before we describe our specific results, let us review the model for external memory <ref> [4, 64, 74, 99, 102, 116, 122] </ref> that we will be assuming throughout this chapter. 3.1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, to compensate for this
Reference: [117] <author> R. Tamassia. </author> <title> An incremental reconstruction method for dynamic planar point location. </title> <journal> Inform. Process. Lett., </journal> <volume> 37 </volume> <pages> 79-83, </pages> <year> 1991. </year>
Reference-contexts: All of our methods assume that the planar subdivision does not change over time, but environments allowing for dynamic changes to the subdivision over time are well-motivated and well-studied, as well <ref> [11, 13, 33, 35, 60, 105, 107, 108, 117] </ref>.
Reference: [118] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms, </title> <booktitle> volume 44 of CBMS-NSF Regional Conference Series in Applied Mathematics. Society for Industrial Applied Mathematics, </booktitle> <year> 1983. </year>
Reference-contexts: Splay trees are self-adjusting binary trees, 126 and they form a simple and very interesting class of "balanced" binary search trees. We highlight the term balanced, because, unlike other binary search trees such as AVL trees [1] or red-black trees <ref> [66, 118] </ref>, splay trees do not enforce explicit global structural constraints.
Reference: [119] <author> R. E. Tarjan. </author> <title> Amortized computational complexity. </title> <journal> SIAM J. Algebraic Discrete Methods, </journal> <volume> 6(2) </volume> <pages> 306-318, </pages> <year> 1985. </year>
Reference-contexts: Moreover, we provide an alternative proof that red-black trees support constant-time amortized finger updates (that is a fact known to folklore <ref> [72, 73, 87, 119] </ref>). We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the three-dimensional layers-of-maxima problem [3, 28, 51, 81] and also give improved methods for dynamic point location in a convex subdivision [37, 103]. <p> In the remainder of this section we provide algorithms for various update operations on biased finger trees and also analyze their amortized complexities. 16 2.2.3 Amortized Analysis and Our Credit Invariant We use the banker's view of amortization <ref> [119] </ref> to analyze the rebalancing and update operations. With each node x of a biased finger tree we associate 4 a value, C (x), of "credits", with 0 C (x).
Reference: [120] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA, </address> <year> 1987. </year>
Reference-contexts: Our structure is topologically equivalent 1 to the globally biased search tree given by Bent, Sleator, and Tarjan [14]. In fact, if each item i has weight w i = 1, then our structure is topologically equivalent to a red-black tree <ref> [44, 66, 120] </ref>. It is our update methods and amortized analysis that are different, and this is what allows us to achieve running times that are improvements over those obtained by Bent, Sleator, and Tarjan, even if one ignores the search times in their update procedures. <p> The root also maintains the left-extreme and right-extreme pointers to the minimum and maximum (leaf ) items. Rank Property: In addition, every node x of the tree stores a non-negative integer rank r (x) that satisfies the natural extensions of red-black tree rank <ref> [120] </ref> to weighted sets [14] 3 : 1. If x is a leaf, then r (x) = blog w i c, where i is the item x stores. 2. If node x has parent y, then r (x) r (y). 3. <p> Along with the tree T we also maintain a DCEL [104] (doubly connected edge list) for the subdivision. We maintain the faces of the subdivision as a dictionary D of size O (n) stored in, say, a red-black tree <ref> [44, 66, 120] </ref>. With each face f (which is a node in D), we maintain a dictionary (f ), implemented as a doubly-linked list, of size O (log n) containing pointers to the nodes in T that f covers (ordered by height).
Reference: [121] <author> D. Tomlin. </author> <title> Geographic Information Systems and Cartographic Modelling. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: We are interested in re-examining the point location problem, focusing on issues that arise in important application areas, such as geographic information systems (GIS) <ref> [19, 18, 55, 112, 121] </ref> 12 . Our re-examination of the point-location problem focuses on 12 Geographic Information Systems are powerful computing tools that manage the geometry of maps and their related geographic images and data. They are used in a variety of governmental and scientific domains.
Reference: [122] <author> J. Vitter. </author> <title> Efficient memory access in large-scale computation. </title> <booktitle> In 1991 Symposium on Theoretical Aspects of Computer Science (STACS), Lecture Notes in Computer Science,, Hamburg, 1991. </booktitle> <publisher> Springer-Verlag. </publisher> <pages> 162 </pages>
Reference-contexts: involve any geometry, its usage (mainly as secondary structure) in applications in other areas, needs to be explored. 91 Chapter 3 Topology B-Trees and Applications 3.1 Introduction The B-tree [43, 68, 82, 87] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [4, 7, 64, 74, 99, 102, 116, 122] </ref>. Indeed, in his well-known survey paper [43], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [57], which is an elegant internal-memory method for maintaining unbalanced binary trees. 92 Before we describe our specific results, let us review the model for external memory <ref> [4, 64, 74, 99, 102, 116, 122] </ref> that we will be assuming throughout this chapter. 3.1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, to compensate for this
References-found: 122

