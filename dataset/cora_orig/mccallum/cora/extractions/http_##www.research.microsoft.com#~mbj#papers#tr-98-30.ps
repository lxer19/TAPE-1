URL: http://www.research.microsoft.com/~mbj/papers/tr-98-30.ps
Refering-URL: http://www.research.microsoft.com/~mbj/papers.html
Root-URL: http://www.research.microsoft.com
Title: Vassal: Loadable Scheduler Support for Multi-Policy Scheduling  
Author: George M. Candea Michael B. Jones 
Note: Paper published in Proceedings of the Second USENIX Windows NT Symposium, Seattle, Washington,  
Address: One Microsoft Way Redmond, WA 98052  
Affiliation: Microsoft Research Microsoft Corporation  
Date: August, 1998  August 1998.  
Abstract: Technical Report MSR-TR-98-30 
Abstract-found: 1
Intro-found: 1
Reference: [Bershad et al. 95] <author> Bershad, S. Savage, P. Pardyak, E.G. Sirer, D. Becker, M. Fiuczynski, C. Chambers, and S. Eggers, </author> <title> Extensibility, Safety and Performance in the SPIN Operating System, </title> <booktitle> Proceedings of the 15 th ACM Symposium on Operating System Principles, </booktitle> <pages> pp. 267-284, </pages> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: Solaris does allow scheduling classes to be dynamically loaded into the kernel, although these classes are still subject to the restriction that they map their scheduling decisions onto a global thread priority space. A number of recent efforts are aimed at making operating systems extensible <ref> [Bershad et al. 95] </ref>, [Kaashoek et al. 97], [Seltzer & Small 97]. However these do not have the same goals as Vassal and do not provide the same facilities. The one that offers scheduling features closest to Vassal is SPIN [Bershad et al. 95]. <p> of recent efforts are aimed at making operating systems extensible <ref> [Bershad et al. 95] </ref>, [Kaashoek et al. 97], [Seltzer & Small 97]. However these do not have the same goals as Vassal and do not provide the same facilities. The one that offers scheduling features closest to Vassal is SPIN [Bershad et al. 95]. It offers applications the ability to provide their own thread package and scheduler, which can then execute in kernel space. This way applications can define their own thread semantics.
Reference: [Clark et al. 92] <author> D. D. Clark, S. Shenker, and L. Zhang, </author> <title> Supporting Real-Time Applications in an Integrated Services Packet Network: </title> <booktitle> Architecture and Mechanism Proceedings of ACM SIGCOMM 92, </booktitle> <pages> pp. 14-26, </pages> <month> Aug. </month> <year> 1992 </year>
Reference: [Corbat & Daggett 62] <author> F.J. Corbat , M. Merwin-Daggett, </author> <title> R.C. Daley, An Experimental TimeSharing System, </title> <booktitle> Proceedings of AFIPS Spring Joint Computer Conference, </booktitle> <pages> pp. 335-344, </pages> <year> 1962. </year>
Reference: [Deng & Liu 97] <author> Z. Deng and J. W.-S. Liu. </author> <title> Scheduling Real-Time Applications in an Open Environment, </title> <booktitle> Proceedings of the 18 th IEEE Real-Time Systems Symposium, </booktitle> <address> San Francisco, </address> <pages> pp. 308-319, </pages> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: In such systems, time allocated to one scheduler is sub-allocated to other dependent schedulers. [Ford & Susarla 96] describes one such system. Finally, <ref> [Deng & Liu 97] </ref> propose a new hierarchical scheduler for Windows NT that provides timing guarantees for multiple independent hard real-time applications, while continuing to run normal applications. 8. Limitations and Future Work The present Vassal implementation is definitely a prototype, and is subject to certain restrictions and limitations.
Reference: [Dusseau et al. 96] <author> A.C. Dusseau, R.H. Arpaci, D.E. Culler, </author> <title> Effective Distributed Scheduling of Parallel Workloads, </title> <booktitle> Proceedings of Sigmetrics 96 Conference on the Measurement and Modeling of Computer Systems, </booktitle> <pages> pp. 25-36, </pages> <month> May </month> <year> 1996. </year>
Reference: [Engler et al. 95] <author> D.R. Engler, M.F. Kaashoek, J. OToole Jr., Exokernel: </author> <title> an Operating System Architecture for ApplicationSpecific Resource Management, </title> <booktitle> Proceedings of 15 th ACM Symposium on Operating System Principles, </booktitle> <pages> pp. 251-266, </pages> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: We decided to find out whether we could dynamically extend systems with scheduling algorithms. While nearly all modern established operating systems can be partially extended via loadable modules (e.g., Linux, Solaris, Windows NT) and extensible systems are a very active area of research ([Bershad et al. 95], <ref> [Engler et al. 95] </ref>, [Seltzer & Small 97]), none of these systems allowed arbitrary scheduling policies to be implemented as extensions motivating our work on Vassal.
Reference: [Ford & Susarla 96] <author> B. Ford and S. Susarla, </author> <title> CPU Inheritance Scheduling, </title> <booktitle> Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pp. 91-105, </pages> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: In our model, the extensions (i.e., the drivers) are trusted and therefore we do not need to protect against them. 9 Another body of work related to ours pertains to support for hierarchical scheduling. In such systems, time allocated to one scheduler is sub-allocated to other dependent schedulers. <ref> [Ford & Susarla 96] </ref> describes one such system. Finally, [Deng & Liu 97] propose a new hierarchical scheduler for Windows NT that provides timing guarantees for multiple independent hard real-time applications, while continuing to run normal applications. 8.
Reference: [Goodheart & Cox 94] <author> B. Goodheart and J. Cox, </author> <title> The Magic Garden Explained: the Internals of UNIX System V Release 4, an Open Systems Design, </title> <address> Sydney, </address> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: But todays general purpose operating systems do not provide such specialized scheduling algorithms. Some of the more popular operating systems provide a primitive differentiation between the different scheduling classes by mapping them onto different priorities (e.g., System V Release 4 <ref> [Goodheart & Cox 94] </ref>, Windows NT [Solomon 98]) and then scheduling higher priority tasks more often or for longer periods of time. However, it is extremely 2 hard to properly map requirements such as predictability, throughput, fairness, turnaround time, waiting time, or response time onto a fixed set of priorities.
Reference: [Goyal et al. 96] <author> P. Goyal, X. Guo, H. M. Vin, </author> <title> A Hierarchical CPU Scheduler for Multimedia Operating Systems, </title> <booktitle> Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pp. 107-121, </pages> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: Examples are: Earliest Deadline First ([Liu & Layland 73]), Weighted Fair Queuing ([Clark et al. 92]), Pinwheel Scheduling ([Hsue & Lin 96]), and Proportional Share CPU allocation mechanisms ([Waldspurger 95], <ref> [Goyal et al. 96] </ref>), plus techniques such as Rate Monotonic Analysis ([Liu & Layland 73]) and Priority Inheritance ([Sha et al. 90]).
Reference: [Hsue & Lin 96] <author> C. Hsueh and K. Lin, </author> <title> Optimal Pinwheel Schedulers Using the Single-Number Reduction Technique, </title> <booktitle> Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <month> Dec. </month> <year> 1996. </year>
Reference: [Jones et al. 97] <author> Michael B. Jones, Daniela Rou, Marcel-Ctlin Rou. </author> <title> CPU Reservations and Time Constraints: Efficient, Predictable Scheduling of Independent Activities, </title> <booktitle> In Proceedings of the 16 th ACM Symposium on Operating System Principles, St-Malo, France, </booktitle> <pages> pp. 198-211, </pages> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: Priorities are, at best, a rather primitive way of describing the relative performance requirements of the threads and processes that belong to the different classes. Other systems ([Northcutt 88], <ref> [Jones et al. 97] </ref>, [Nieh & Lam 97], etc.) have tried to strike a compromise, providing some application timing and resource advice to the system, giving it imperfect, but useful information upon which to base scheduling decisions. <p> For instance, one Kernel Dispatcher Net Disk CPU Video Task 1 Task 2 Task 3 Task 4 Policy A: T1, T3, T4 Policy B: T2 5 could view this as happening in <ref> [Jones et al. 97] </ref> when a threads CPU reservations and/or time constraints do not cause it to be selected, but it is nonetheless selected by the default round-robin policy. As this is more general, we opted to allow this (while also making it possible for a scheduler to prevent it). <p> It was rather straightforward (116 lines of C code). This scheduler allows threads to request that they be scheduled at a particular time, which exercises the key operation needed to implement more interesting time-based scheduling primitives, such as time constraints <ref> [Jones et al. 97] </ref>.
Reference: [Kaashoek et al. 97] <author> D.R. Engler, M.F. Kaashoek, J. OToole Jr., </author> <title> Application Performance and Flexibility on Exokernel Systems, </title> <booktitle> Proceedings of the 16 th ACM Symposium on Operating System Principles, </booktitle> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: Solaris does allow scheduling classes to be dynamically loaded into the kernel, although these classes are still subject to the restriction that they map their scheduling decisions onto a global thread priority space. A number of recent efforts are aimed at making operating systems extensible [Bershad et al. 95], <ref> [Kaashoek et al. 97] </ref>, [Seltzer & Small 97]. However these do not have the same goals as Vassal and do not provide the same facilities. The one that offers scheduling features closest to Vassal is SPIN [Bershad et al. 95].
Reference: [Kay & Lauder 88] <author> J. Kay and P. Lauder, </author> <title> A Fair Share Scheduler, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 31, No. 1, </volume> <pages> pp. 44-55, </pages> <year> 1988. </year>
Reference: [Kleinrock 74] <author> L. Kleinrock, </author> <title> Queueing Systems. </title> <booktitle> Volume 1, </booktitle> <address> New York: </address> <publisher> John Wiley, </publisher> <year> 1974. </year>
Reference-contexts: Such large numbers of different scheduling algorithms are an indication that scheduling is, and will likely remain, an active area of research. No one algorithm will work best in all cases (despite many valiant attempts by system builders to demonstrate otherwise). In fact, <ref> [Kleinrock 74] </ref> shows that any scheduling algorithm that favors a certain class of tasks will necessarily hurt another class. A single scheduling policy will always represent a compromise and the service offered by the system will unavoidably reflect this compromise.
Reference: [Lampson 68] <author> B.W. Lampson, </author> <title> A Scheduling Philosophy for Multiprogramming Systems, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 10, </volume> <pages> pp. 613-615, </pages> <month> May </month> <year> 1968. </year>
Reference-contexts: Most general purpose systems have used algorithms which know either nothing or next-to-nothing about the actual CPU resource needs of the tasks being scheduled. Examples include First-Come, First Served used in early batch systems and Round-Robin in multitasking systems. Later algorithms such as Priority Queues ([Corbat & Daggett 62], <ref> [Lampson 68] </ref>), Fair Share Scheduling ([Kay & Lauder 88]), and typical dynamic priority boost/decay algorithms still had the property that they were essentially ignorant of the actual CPU needs of their applications. Imperfect, but nonetheless adequate, future knowledge is possible for some fixed task sets with well-characterized computation patterns.
Reference: [Liu & Layland 73] <author> C. L. Liu and James W. Layland, </author> <title> Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment, </title> <journal> Journal of the ACM, </journal> <volume> Vol. 20, No. 1, </volume> <pages> pp. 46-61, </pages> <month> Jan. </month> <year> 1973. </year>
Reference: [Nieh & Lam 97] <author> J. Nieh and M. S. Lam, </author> <title> The Design, Implementation and Evaluation of SMART: </title> <booktitle> A Scheduler for Multimedia Applications Proceedings of the 16 th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 184-197, </pages> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: Priorities are, at best, a rather primitive way of describing the relative performance requirements of the threads and processes that belong to the different classes. Other systems ([Northcutt 88], [Jones et al. 97], <ref> [Nieh & Lam 97] </ref>, etc.) have tried to strike a compromise, providing some application timing and resource advice to the system, giving it imperfect, but useful information upon which to base scheduling decisions.
Reference: [Northcutt 88] <author> J. D. Northcutt, </author> <title> The Alpha Operating System: Requirements and Rationale Archons Project Technical Report #88011, </title> <institution> Dept. of Computer Science, Carnegie-Mellon, </institution> <month> Jan. </month> <year> 1988. </year>
Reference: [Ousterhout 82] <author> J.K. Ousterhout, </author> <title> Scheduling Techniques for Concurrent Systems, </title> <booktitle> Proceedings of the 3 rd International Conference on Distributed Computer Systems, </booktitle> <pages> pp. 22-30, </pages> <month> Oct. </month> <year> 1982. </year>
Reference: [Ritchie 84] <author> Dennis M. Ritchie, </author> <title> A Stream Input-Output System, </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> Vol. 63, No. 8, </volume> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: Drivers reside in kernel space, can be layered on top of each other, and communicate among themselves using I/O Request Packets (IRPs) in a manner reminiscent of UNIX System V Streams modules <ref> [Ritchie 84] </ref>. Applications typically send and receive data to and from the drivers via the same path. 3. Loadable Scheduler Design This section describes the design of the infrastructure that allows scheduling policies to be loaded and unloaded at runtime.
Reference: [Seltzer & Small 97] <author> M.I. Seltzer, C. </author> <title> Small, Self-monitoring and Self-adapting Operating Systems, </title> <booktitle> Proceedings of the 6 th Workshop on Hot Topics in Operating Systems, </booktitle> <pages> pp. 124-129, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: While nearly all modern established operating systems can be partially extended via loadable modules (e.g., Linux, Solaris, Windows NT) and extensible systems are a very active area of research ([Bershad et al. 95], [Engler et al. 95], <ref> [Seltzer & Small 97] </ref>), none of these systems allowed arbitrary scheduling policies to be implemented as extensions motivating our work on Vassal. <p> A number of recent efforts are aimed at making operating systems extensible [Bershad et al. 95], [Kaashoek et al. 97], <ref> [Seltzer & Small 97] </ref>. However these do not have the same goals as Vassal and do not provide the same facilities. The one that offers scheduling features closest to Vassal is SPIN [Bershad et al. 95].
Reference: [Sha et al. 90] <author> L. Sha, R. Rajkumar, and J. P. Lehoczky, </author> <title> Priority Inheritance Protocols: An Approach to Real-Time Synchronization, </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 39, No. 9, </volume> <pages> pp. 1175-1185, </pages> <month> Sep. </month> <year> 1990. </year>
Reference: [Solomon 98] <author> David A. Solomon. </author> <title> Inside Windows NT, Second Edition. </title> <publisher> Microsoft Press, </publisher> <year> 1998. </year>
Reference-contexts: But todays general purpose operating systems do not provide such specialized scheduling algorithms. Some of the more popular operating systems provide a primitive differentiation between the different scheduling classes by mapping them onto different priorities (e.g., System V Release 4 [Goodheart & Cox 94], Windows NT <ref> [Solomon 98] </ref>) and then scheduling higher priority tasks more often or for longer periods of time. However, it is extremely 2 hard to properly map requirements such as predictability, throughput, fairness, turnaround time, waiting time, or response time onto a fixed set of priorities.
Reference: [Waldspurger 95] <author> C.A. Waldspurger, </author> <title> Lottery and Stride Scheduling: Flexible Proportional-Share Resource Management, </title> <type> Ph.D. dissertation, </type> <institution> Massachusetts Institute of Technology, </institution> <month> Sep. </month> <year> 1995. </year> <note> Also appears as Technical Report MIT/LCS/TR-667. </note>
References-found: 24

