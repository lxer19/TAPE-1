URL: http://www.research.microsoft.com/~ruf/files/tr9520-300.ps
Refering-URL: http://www.research.microsoft.com/~ruf/preprint.htm
Root-URL: http://www.research.microsoft.com
Email: erikruf@microsoft.com  
Title: Context-Insensitive Alias Analysis Reconsidered  
Author: Erik Ruf 
Note: This report is a preprint of the paper "Context-Insensitive Alias Analysis Reconsidered," to appear in ACM SIGPLAN '95 Conference on Programming Language Design and Implementation (PLDI'95), La Jolla, California, June 1995.  
Address: One Microsoft Way Redmond, WA 98052  
Affiliation: Microsoft Research Advanced Technology Division Microsoft Corporation  
Date: May 16, 1995  
Abstract: Technical Report MSR-TR-95-20 Copyright c fl 1995 by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Publications Dept, ACM Inc., fax + 1 (212) 869-0481, or permissions@acm.org. 
Abstract-found: 1
Intro-found: 1
Reference: [ABS94] <author> T. M. Austin, S. E. Breach, and G. S. Sohi. </author> <title> Efficient detection of all pointer and array access errors. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 290-301. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: We chose these programs from those analyzed in other alias analysis publications [LR92, LRZ93, EGH94] and in <ref> [ABS94] </ref>, which instrumented pointer-intensive programs. Under our Scheme-based implementation, analysis times for the benchmark programs range from 1 to 35 seconds. by themselves; we can learn more by considering an application, such as def/use or mod/ref analysis.
Reference: [CBC93] <author> J.-D. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Proceedings of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245. </pages> <publisher> ACM Press, </publisher> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Another approach tags each alias relationship with information that allows a procedure to propagate only appropriate relationships to each of its callers: Landi [LR92, Lan92] uses information about the alias relationships on entry to the enclosing procedure, while Cooper [Coo89] and Choi et al <ref> [CBC93] </ref> augment this with an abstraction of the call stack. All context-sensitive approaches have exponential time complexity in the size of the input program unless some effort is made to limit the number of contexts in which a procedure is analyzed. <p> We use a "points-to" model of aliasing; that is, at each program point, our analysis models the contents of storage locations (points-to relations) rather than modeling equivalence classes of location-valued expressions (alias relations). In this respect, our analysis is similar to [RM88, HPR89, CWZ90, EGH94, WL95] and different from <ref> [Coo89, LR92, CBC93, Deu94] </ref>. We chose the points-to model because it fits naturally into our intermediate representation, and because its storage requirements are likely to be smaller. <p> Thus we are willing to pay an exponential performance penalty and will not, as in <ref> [LR92, CBC93] </ref> limit our representation to avoid such a penalty. We choose to use assumption-set-based contexts (rather than call-stack-based contexts) because doing so allows us to prune contexts based on the output of the context-insensitive analysis. <p> pair hha; ci; fhs; ha; bii; hs; hb; ciigi on some output is "a points to c on this output if, on entry to this procedure, a points to b in formal s and b points to c in formal s." 6 These assumption sets are similar to those of <ref> [Coo89, LR92, CBC93] </ref>, except that (1) our assumptions concern points-to, rather than 6 Assumptions need not be restricted to store outputs; we might just as easily assume that a pointer-valued formal parameter has a particular value; e.g., hh*; ai; fhf; aigi means "this output has pointer value a if formal f <p> Many alias analysis algorithms <ref> [LR92, EGH94, CBC93] </ref> explicitly construct synthetic locations (called "invisible variables" or "representative aliases") to represent storage addresses not lexically visible to a procedure (e.g., a caller's local variable, whose address is passed to the procedure as a parameter or in a global variable), and perform mapping operations on procedure call and <p> Our analysis constructs only a single representative base-location for each invocation site of heap memory allocators (mal-loc, realloc, etc). Thus, all clients of a heap-allocated data abstraction will manipulate the same paths, irrespective of whether context-insensitive or context-sensitive analysis are used. More precise heap analyses <ref> [Har89, CWZ90, CBC93, Deu92, Deu94] </ref> allow multiple representatives per allocation site, yielding a larger pool of locations, and thus a larger set of spurious points-to relations in the context-insensitive case. 9 A similar argument applies to the handling of arrays (treating various subscript ranges independently will increase the number of distinct <p> With the exception of the mapping of invisible locations to synthetics, the arguments of Sections 5.1 and 5.2 apply equally well to other context-sensitive pointer alias analyses <ref> [LR92, CBC93, EGH94] </ref>. Thus, we believe that they, too, will realize only minor precision benefits from context-sensitivity on our benchmark suite. 6 Conclusion and Future Work We have performed what we believe to be the first empirical comparison between program-point-specific context-insensitive and context-sensitive alias analysis techniques.
Reference: [CFR + 91] <author> R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: We conclude with a brief summary and discussion of future work. 2 Framework We analyze C programs represented as value dependence graphs, or VDGs [WCES94a, WCES94b]. For purposes of this paper, VDG form can be thought of as an extended version of static single assignment (SSA) form <ref> [CFR + 91] </ref>, in which all program dependences (not merely alias-free def/use dependences) are modeled explicitly. Computation is expressed by nodes that consume input values (outputs of other nodes) and produce output values.
Reference: [Coo89] <author> B. G. Cooper. </author> <title> Ambitious data flow analysis of procedural programs. </title> <type> Master's thesis, </type> <institution> University of Min-nesota, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Another approach tags each alias relationship with information that allows a procedure to propagate only appropriate relationships to each of its callers: Landi [LR92, Lan92] uses information about the alias relationships on entry to the enclosing procedure, while Cooper <ref> [Coo89] </ref> and Choi et al [CBC93] augment this with an abstraction of the call stack. All context-sensitive approaches have exponential time complexity in the size of the input program unless some effort is made to limit the number of contexts in which a procedure is analyzed. <p> We use a "points-to" model of aliasing; that is, at each program point, our analysis models the contents of storage locations (points-to relations) rather than modeling equivalence classes of location-valued expressions (alias relations). In this respect, our analysis is similar to [RM88, HPR89, CWZ90, EGH94, WL95] and different from <ref> [Coo89, LR92, CBC93, Deu94] </ref>. We chose the points-to model because it fits naturally into our intermediate representation, and because its storage requirements are likely to be smaller. <p> In the case where the variable is of pointer type, this behavior could lead to an incorrect points-to solution if the variable's location is strongly updated by the analysis. We have experimented with two solutions to this problem. Our first scheme is essentially Cooper's <ref> [Coo89] </ref> model: each such variable variable is assigned two base-locations, one denoting the most recent instance of the variable, the other denoting all other instances on the stack. The former can be strongly updated, while the latter cannot. <p> pair hha; ci; fhs; ha; bii; hs; hb; ciigi on some output is "a points to c on this output if, on entry to this procedure, a points to b in formal s and b points to c in formal s." 6 These assumption sets are similar to those of <ref> [Coo89, LR92, CBC93] </ref>, except that (1) our assumptions concern points-to, rather than 6 Assumptions need not be restricted to store outputs; we might just as easily assume that a pointer-valued formal parameter has a particular value; e.g., hh*; ai; fhf; aigi means "this output has pointer value a if formal f
Reference: [Cou86] <author> D. S. Coutant. </author> <title> Retargetable high-level alias analysis. </title> <booktitle> In Proceedings of the Thirteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 110-118. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: Alias analysis 1 provides this approximation; its precision directly effects the quality of virtually all other dataflow analyses. Early pointer alias analyses were completely flow-insensitive; both Weihl [Wei80] and Coutant <ref> [Cou86] </ref> computed alias information on a program-wide basis, building a single, global mapping between pointers and their potential referents.
Reference: [CR82] <author> A. L. Chow and A. Rudmik. </author> <title> The design of a data flow analyzer. </title> <booktitle> In Proceedings of the SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <pages> pages 106-119. </pages> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: Such context-insensitive 2 techniques can introduce imprecision by exploring call/return paths that cannot occur in any execution of the program. The system of Chow and Rud-mik <ref> [CR82] </ref> operates in this manner; Chase et al [CWZ90] and Deutsch [Deu94] perform more sophisticated modeling intraprocedurally, but are still context-insensitive at the in-terprocedural level. Recent research in interprocedural alias analysis has focused on avoiding the spurious alias relationships generated by context-insensitive strategies.
Reference: [CWZ90] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June 20-22, </month> <year> 1990. </year>
Reference-contexts: Such context-insensitive 2 techniques can introduce imprecision by exploring call/return paths that cannot occur in any execution of the program. The system of Chow and Rud-mik [CR82] operates in this manner; Chase et al <ref> [CWZ90] </ref> and Deutsch [Deu94] perform more sophisticated modeling intraprocedurally, but are still context-insensitive at the in-terprocedural level. Recent research in interprocedural alias analysis has focused on avoiding the spurious alias relationships generated by context-insensitive strategies. <p> We use a "points-to" model of aliasing; that is, at each program point, our analysis models the contents of storage locations (points-to relations) rather than modeling equivalence classes of location-valued expressions (alias relations). In this respect, our analysis is similar to <ref> [RM88, HPR89, CWZ90, EGH94, WL95] </ref> and different from [Coo89, LR92, CBC93, Deu94]. We chose the points-to model because it fits naturally into our intermediate representation, and because its storage requirements are likely to be smaller. <p> Access paths may model single runtime locations (e.g., global variables and local variables of non-recursive procedures), while others model multiple runtime locations (array contents, heap-allocated data, and locals of recursive procedures 4 ). Paths corresponding to at most one location at runtime can be strongly updated <ref> [CWZ90] </ref> during analysis, while others cannot. <p> Our points-to pairs denote possible, rather than definite relationships; however, we follow <ref> [CWZ90] </ref> in treating any singleton set of "possibly points to" pairs as a "definitely points to" pair. This allows us to exploit strong updates without additional representational overhead. <p> Neither signal handlers, longjmp, nor casts between pointer and non-pointer types are modeled. 3 Context-Insensitive Analysis 3.1 Algorithm Our context-insensitive analysis, described in Figure 1, is essentially the "simple algorithm" of <ref> [CWZ90, Sections 3 and 4.2] </ref>, and has the same effect as the intraprocedural portion of [EGH94]. We maintain a set of points-to pairs on every node output in the program, 5 and incrementally grow these sets using a worklist strategy. <p> The choice of solution is irrelevant for the benchmarks in this paper, as they do not contain recursive procedures that pass addresses of local pointer-valued variables downward. 5 We could reduce our storage costs (at log n time cost) via the sparse storage strategy described in <ref> [CWZ90] </ref>, but we have yet to see a need for this in practice. 2 analyze program worklist := for each base-location b 2 program flow-out output (b) h*; bi while worklist not empty do take ffi = hinput; pair i from worklist flow-in input-node (input) ffi flow-out output pair if pair <p> This gives the same effect as the dual-worklist strategy of <ref> [CWZ90] </ref>. <p> Our analysis constructs only a single representative base-location for each invocation site of heap memory allocators (mal-loc, realloc, etc). Thus, all clients of a heap-allocated data abstraction will manipulate the same paths, irrespective of whether context-insensitive or context-sensitive analysis are used. More precise heap analyses <ref> [Har89, CWZ90, CBC93, Deu92, Deu94] </ref> allow multiple representatives per allocation site, yielding a larger pool of locations, and thus a larger set of spurious points-to relations in the context-insensitive case. 9 A similar argument applies to the handling of arrays (treating various subscript ranges independently will increase the number of distinct
Reference: [Deu92] <author> A. Deutsch. </author> <title> A storeless model of aliasing and its abstractions using finite representations of right-regular equivalence relations. </title> <booktitle> In International Conference on Computer Languages, </booktitle> <pages> pages 2-13. </pages> <publisher> IEEE, </publisher> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: Our analysis constructs only a single representative base-location for each invocation site of heap memory allocators (mal-loc, realloc, etc). Thus, all clients of a heap-allocated data abstraction will manipulate the same paths, irrespective of whether context-insensitive or context-sensitive analysis are used. More precise heap analyses <ref> [Har89, CWZ90, CBC93, Deu92, Deu94] </ref> allow multiple representatives per allocation site, yielding a larger pool of locations, and thus a larger set of spurious points-to relations in the context-insensitive case. 9 A similar argument applies to the handling of arrays (treating various subscript ranges independently will increase the number of distinct
Reference: [Deu94] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 230-239. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: Such context-insensitive 2 techniques can introduce imprecision by exploring call/return paths that cannot occur in any execution of the program. The system of Chow and Rud-mik [CR82] operates in this manner; Chase et al [CWZ90] and Deutsch <ref> [Deu94] </ref> perform more sophisticated modeling intraprocedurally, but are still context-insensitive at the in-terprocedural level. Recent research in interprocedural alias analysis has focused on avoiding the spurious alias relationships generated by context-insensitive strategies. <p> We use a "points-to" model of aliasing; that is, at each program point, our analysis models the contents of storage locations (points-to relations) rather than modeling equivalence classes of location-valued expressions (alias relations). In this respect, our analysis is similar to [RM88, HPR89, CWZ90, EGH94, WL95] and different from <ref> [Coo89, LR92, CBC93, Deu94] </ref>. We chose the points-to model because it fits naturally into our intermediate representation, and because its storage requirements are likely to be smaller. <p> Our analysis constructs only a single representative base-location for each invocation site of heap memory allocators (mal-loc, realloc, etc). Thus, all clients of a heap-allocated data abstraction will manipulate the same paths, irrespective of whether context-insensitive or context-sensitive analysis are used. More precise heap analyses <ref> [Har89, CWZ90, CBC93, Deu92, Deu94] </ref> allow multiple representatives per allocation site, yielding a larger pool of locations, and thus a larger set of spurious points-to relations in the context-insensitive case. 9 A similar argument applies to the handling of arrays (treating various subscript ranges independently will increase the number of distinct
Reference: [EGH94] <author> M. Emami, R. Ghiya, and L. J. Hendren. </author> <title> Context-sensitive interprocedural analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: Recent research in interprocedural alias analysis has focused on avoiding the spurious alias relationships generated by context-insensitive strategies. One approach explicitly re-analyzes each procedure under multiple contexts: Emami et al <ref> [EGH94] </ref> create a context for each each acyclic path from the root of the call graph to the current invocation, while Wilson and Lam [WL95] build one context per set of "relevant" aliases holding on entry to the procedure. <p> Context-sensitive alias analysis techniques have been quite successful, in that they run in reasonable amounts of time, and find relatively few aliases (e.g., the average indirect memory operation is found to reference/modify approximately 1.2 memory locations <ref> [LRZ93, EGH94] </ref>). However, published work in this area includes comparisons only to Weihl's program-wide analysis, so it is unclear how much of this precision derives from the program-point-specific nature of the analysis, and how much is truly due to its context-sensitivity. <p> This paper presents the results of an experiment to measure the benefits of context-sensitivity. We implemented 2 We use the terminology of <ref> [EGH94] </ref>, in which the terms context-sensitive and context-insensitive are used to distinguish analyses that propagate dataflow facts from procedure returns solely to appropriate call sites from those that propagate to all call sites. <p> We use a "points-to" model of aliasing; that is, at each program point, our analysis models the contents of storage locations (points-to relations) rather than modeling equivalence classes of location-valued expressions (alias relations). In this respect, our analysis is similar to <ref> [RM88, HPR89, CWZ90, EGH94, WL95] </ref> and different from [Coo89, LR92, CBC93, Deu94]. We chose the points-to model because it fits naturally into our intermediate representation, and because its storage requirements are likely to be smaller. <p> Neither signal handlers, longjmp, nor casts between pointer and non-pointer types are modeled. 3 Context-Insensitive Analysis 3.1 Algorithm Our context-insensitive analysis, described in Figure 1, is essentially the "simple algorithm" of [CWZ90, Sections 3 and 4.2], and has the same effect as the intraprocedural portion of <ref> [EGH94] </ref>. We maintain a set of points-to pairs on every node output in the program, 5 and incrementally grow these sets using a worklist strategy. <p> We chose these programs from those analyzed in other alias analysis publications <ref> [LR92, LRZ93, EGH94] </ref> and in [ABS94], which instrumented pointer-intensive programs. Under our Scheme-based implementation, analysis times for the benchmark programs range from 1 to 35 seconds. by themselves; we can learn more by considering an application, such as def/use or mod/ref analysis. <p> Many alias analysis algorithms <ref> [LR92, EGH94, CBC93] </ref> explicitly construct synthetic locations (called "invisible variables" or "representative aliases") to represent storage addresses not lexically visible to a procedure (e.g., a caller's local variable, whose address is passed to the procedure as a parameter or in a global variable), and perform mapping operations on procedure call and <p> With the exception of the mapping of invisible locations to synthetics, the arguments of Sections 5.1 and 5.2 apply equally well to other context-sensitive pointer alias analyses <ref> [LR92, CBC93, EGH94] </ref>. Thus, we believe that they, too, will realize only minor precision benefits from context-sensitivity on our benchmark suite. 6 Conclusion and Future Work We have performed what we believe to be the first empirical comparison between program-point-specific context-insensitive and context-sensitive alias analysis techniques.
Reference: [Har89] <author> W. L. Harrison III. </author> <title> The interprocedural analysis and automatic parallelization of Scheme programs. </title> <journal> Lisp and Symbolic Computation, </journal> 2(3/4):179-396, 1989. 
Reference-contexts: Our analysis constructs only a single representative base-location for each invocation site of heap memory allocators (mal-loc, realloc, etc). Thus, all clients of a heap-allocated data abstraction will manipulate the same paths, irrespective of whether context-insensitive or context-sensitive analysis are used. More precise heap analyses <ref> [Har89, CWZ90, CBC93, Deu92, Deu94] </ref> allow multiple representatives per allocation site, yielding a larger pool of locations, and thus a larger set of spurious points-to relations in the context-insensitive case. 9 A similar argument applies to the handling of arrays (treating various subscript ranges independently will increase the number of distinct
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the SIGPLAN'89 Symposium on Compiler Construction, </booktitle> <pages> pages 28-40, </pages> <month> June </month> <year> 1989. </year> <note> Published as SIG-PLAN Notices Vol 24, Num. 7. </note>
Reference-contexts: We use a "points-to" model of aliasing; that is, at each program point, our analysis models the contents of storage locations (points-to relations) rather than modeling equivalence classes of location-valued expressions (alias relations). In this respect, our analysis is similar to <ref> [RM88, HPR89, CWZ90, EGH94, WL95] </ref> and different from [Coo89, LR92, CBC93, Deu94]. We chose the points-to model because it fits naturally into our intermediate representation, and because its storage requirements are likely to be smaller.
Reference: [Lan92] <author> W. A. Landi. </author> <title> Interprocedural Aliasing in the Presence of Pointers. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Another approach tags each alias relationship with information that allows a procedure to propagate only appropriate relationships to each of its callers: Landi <ref> [LR92, Lan92] </ref> uses information about the alias relationships on entry to the enclosing procedure, while Cooper [Coo89] and Choi et al [CBC93] augment this with an abstraction of the call stack. <p> For each element of this product, we propagate an appropriately qualified version of the return value to the caller. alias, relations, and (2) we do not limit the size of assumption sets. Our rules for propagation of assumptions (shown in Figure 5) are similar to those in <ref> [Lan92] </ref>. Assumptions are introduced and removed at procedure calls and returns.
Reference: [LR92] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Early pointer alias analyses were completely flow-insensitive; both Weihl [Wei80] and Coutant [Cou86] computed alias information on a program-wide basis, building a single, global mapping between pointers and their potential referents. Others later found that these methods generated overly large, imprecise approximations, handicapping subsequent analyses <ref> [Ryd89, LR92] </ref>. 1 In this paper, we use the term "alias analysis" to denote a dataflow analysis for estimating the effects of indirect memory references through pointers. <p> Another approach tags each alias relationship with information that allows a procedure to propagate only appropriate relationships to each of its callers: Landi <ref> [LR92, Lan92] </ref> uses information about the alias relationships on entry to the enclosing procedure, while Cooper [Coo89] and Choi et al [CBC93] augment this with an abstraction of the call stack. <p> Other terms with similar meanings include the imprecise/precise distinction of <ref> [LR92] </ref> and the monovariant/polyvariant distinction made in partial evalu ation and abstract interpretation. 1 both context-insensitive and context-sensitive versions of a single alias analysis and evaluated the precision of the re sults. <p> We use a "points-to" model of aliasing; that is, at each program point, our analysis models the contents of storage locations (points-to relations) rather than modeling equivalence classes of location-valued expressions (alias relations). In this respect, our analysis is similar to [RM88, HPR89, CWZ90, EGH94, WL95] and different from <ref> [Coo89, LR92, CBC93, Deu94] </ref>. We chose the points-to model because it fits naturally into our intermediate representation, and because its storage requirements are likely to be smaller. <p> We chose these programs from those analyzed in other alias analysis publications <ref> [LR92, LRZ93, EGH94] </ref> and in [ABS94], which instrumented pointer-intensive programs. Under our Scheme-based implementation, analysis times for the benchmark programs range from 1 to 35 seconds. by themselves; we can learn more by considering an application, such as def/use or mod/ref analysis. <p> Thus we are willing to pay an exponential performance penalty and will not, as in <ref> [LR92, CBC93] </ref> limit our representation to avoid such a penalty. We choose to use assumption-set-based contexts (rather than call-stack-based contexts) because doing so allows us to prune contexts based on the output of the context-insensitive analysis. <p> pair hha; ci; fhs; ha; bii; hs; hb; ciigi on some output is "a points to c on this output if, on entry to this procedure, a points to b in formal s and b points to c in formal s." 6 These assumption sets are similar to those of <ref> [Coo89, LR92, CBC93] </ref>, except that (1) our assumptions concern points-to, rather than 6 Assumptions need not be restricted to store outputs; we might just as easily assume that a pointer-valued formal parameter has a particular value; e.g., hh*; ai; fhf; aigi means "this output has pointer value a if formal f <p> This performance is acceptable for our purpose (establishing an upper bound on precision), but it does limit the algorithm's practicality. Optimization techniques similar to our use of context-insensitive information might also be useful in systems such as <ref> [LR92] </ref> that maintain bounded-size assumption sets. <p> Many alias analysis algorithms <ref> [LR92, EGH94, CBC93] </ref> explicitly construct synthetic locations (called "invisible variables" or "representative aliases") to represent storage addresses not lexically visible to a procedure (e.g., a caller's local variable, whose address is passed to the procedure as a parameter or in a global variable), and perform mapping operations on procedure call and <p> With the exception of the mapping of invisible locations to synthetics, the arguments of Sections 5.1 and 5.2 apply equally well to other context-sensitive pointer alias analyses <ref> [LR92, CBC93, EGH94] </ref>. Thus, we believe that they, too, will realize only minor precision benefits from context-sensitivity on our benchmark suite. 6 Conclusion and Future Work We have performed what we believe to be the first empirical comparison between program-point-specific context-insensitive and context-sensitive alias analysis techniques.
Reference: [LRZ93] <author> W. Landi, B. G. Ryder, and S. Zhang. </author> <title> Interproce-dural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 56-67. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: Context-sensitive alias analysis techniques have been quite successful, in that they run in reasonable amounts of time, and find relatively few aliases (e.g., the average indirect memory operation is found to reference/modify approximately 1.2 memory locations <ref> [LRZ93, EGH94] </ref>). However, published work in this area includes comparisons only to Weihl's program-wide analysis, so it is unclear how much of this precision derives from the program-point-specific nature of the analysis, and how much is truly due to its context-sensitivity. <p> We chose these programs from those analyzed in other alias analysis publications <ref> [LR92, LRZ93, EGH94] </ref> and in [ABS94], which instrumented pointer-intensive programs. Under our Scheme-based implementation, analysis times for the benchmark programs range from 1 to 35 seconds. by themselves; we can learn more by considering an application, such as def/use or mod/ref analysis. <p> Figure 4 reports these statistics. We see that, on average, most indirect memory operations reference very few locations. Our statistics for memory writes are higher than those in <ref> [LRZ93] </ref> for two reasons. First, we do not construct synthetic locations to represent lexically non-visible variables, meaning that we lose some opportunities for strong updates (c.f. Section 5.1). <p> of structure or array operations into a single memory read followed by a series of aggregate update operations and a single memory write; thus, many array/structure operations are not counted as memory operations in our statistics (e.g., in our representation, assembler contains 115 indirect write operations, while in that of <ref> [LRZ93] </ref>, it contains 290). Since the majority of array/structure operations reference only one location, this increases the our "average number of locations referenced/modified" statistic. <p> We also note that the "maximum locations modified" values for allroots, assembler, compiler, lex315, loader, and simulator are identical to those produced by context-sensitive means in <ref> [LRZ93] </ref>, allowing us to conclude that the worst-case behavior at indirect memory references in these programs was not caused by context-insensitivity. <p> After the context-sensitive analysis has completed, we compute the set of ordinary points-to pairs on each node output by stripping the assumption sets from the qualified points-to pairs on that output and removing duplicates. Some context-sensitive analyses <ref> [PLR92, LRZ93] </ref> prefer to use the qualified information directly; this would be easy to accommodate. 4.2 Implementation The analysis described in the previous subsection is too inefficient to run on any but the smallest of examples. We use several techniques to improve its efficiency.
Reference: [PLR92] <author> H. D. Pande, W. Landi, and B. G. Ryder. </author> <title> Interpro-cedural reaching definitions in the presence of single level pointers. </title> <type> Technical Report lcsr-tr-193, </type> <institution> Laboratory for Computer Science Research, Rutgers University, </institution> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: After the context-sensitive analysis has completed, we compute the set of ordinary points-to pairs on each node output by stripping the assumption sets from the qualified points-to pairs on that output and removing duplicates. Some context-sensitive analyses <ref> [PLR92, LRZ93] </ref> prefer to use the qualified information directly; this would be easy to accommodate. 4.2 Implementation The analysis described in the previous subsection is too inefficient to run on any but the smallest of examples. We use several techniques to improve its efficiency.
Reference: [RM88] <author> C. Ruggieri and T. P. Murtagh. </author> <title> Lifetime analysis of dynamically allocated objects. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-293, </pages> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: We use a "points-to" model of aliasing; that is, at each program point, our analysis models the contents of storage locations (points-to relations) rather than modeling equivalence classes of location-valued expressions (alias relations). In this respect, our analysis is similar to <ref> [RM88, HPR89, CWZ90, EGH94, WL95] </ref> and different from [Coo89, LR92, CBC93, Deu94]. We chose the points-to model because it fits naturally into our intermediate representation, and because its storage requirements are likely to be smaller.
Reference: [Ruf95] <author> E. Ruf. </author> <title> Optimizing sparse representations for dataflow analysis. </title> <booktitle> In ACM SIGPLAN Workshop on Intermediate Representations (IR'95), </booktitle> <pages> pages 50-61, </pages> <month> Jan. </month> <year> 1995. </year> <note> Proceedings available as Microsoft Research technical report MSR-TR-95-01. </note>
Reference-contexts: Our analyses apply equally well to control-flow graph representations; they merely run faster on the VDG because it is more sparse <ref> [Ruf95] </ref>. We use a "points-to" model of aliasing; that is, at each program point, our analysis models the contents of storage locations (points-to relations) rather than modeling equivalence classes of location-valued expressions (alias relations). <p> Before our points-to analyses run, our compiler has already performed significant amounts of value numbering, loop invariant code motion, and dead code removal, along with an SSA-like transformation that removes non-addressed variables from the store <ref> [Ruf95, Section 3] </ref>. It may be the case that, without these optimizations, more spurious (though irrelevant) points-to pairs would be generated. * Problem formulation.
Reference: [Ryd89] <author> B. G. Ryder. </author> <title> Ismm: Incremental software maintenance manager. </title> <booktitle> In Proceedings of the IEEE Computer Society Conference on Software Maintenance, </booktitle> <pages> pages 142-164, </pages> <year> 1989. </year>
Reference-contexts: Early pointer alias analyses were completely flow-insensitive; both Weihl [Wei80] and Coutant [Cou86] computed alias information on a program-wide basis, building a single, global mapping between pointers and their potential referents. Others later found that these methods generated overly large, imprecise approximations, handicapping subsequent analyses <ref> [Ryd89, LR92] </ref>. 1 In this paper, we use the term "alias analysis" to denote a dataflow analysis for estimating the effects of indirect memory references through pointers.
Reference: [WCES94a] <author> D. Weise, R. F. Crew, M. Ernst, and B. Steensgaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <booktitle> In Proceedings 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297-310, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Section 5 discusses our results and their relevance to other alias analysis frameworks. We conclude with a brief summary and discussion of future work. 2 Framework We analyze C programs represented as value dependence graphs, or VDGs <ref> [WCES94a, WCES94b] </ref>. For purposes of this paper, VDG form can be thought of as an extended version of static single assignment (SSA) form [CFR + 91], in which all program dependences (not merely alias-free def/use dependences) are modeled explicitly.
Reference: [WCES94b] <author> D. Weise, R. F. Crew, M. Ernst, and B. Steens-gaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <type> Technical Report MSR-TR-94-03, </type> <institution> Microsoft Research, </institution> <address> Redmond, WA, </address> <month> Apr. 13, </month> <year> 1994. </year>
Reference-contexts: Section 5 discusses our results and their relevance to other alias analysis frameworks. We conclude with a brief summary and discussion of future work. 2 Framework We analyze C programs represented as value dependence graphs, or VDGs <ref> [WCES94a, WCES94b] </ref>. For purposes of this paper, VDG form can be thought of as an extended version of static single assignment (SSA) form [CFR + 91], in which all program dependences (not merely alias-free def/use dependences) are modeled explicitly.
Reference: [Wei80] <author> W. E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables, and label variables. </title> <booktitle> In Proceedings of the Seventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <month> Jan. </month> <year> 1980. </year>
Reference-contexts: Alias analysis 1 provides this approximation; its precision directly effects the quality of virtually all other dataflow analyses. Early pointer alias analyses were completely flow-insensitive; both Weihl <ref> [Wei80] </ref> and Coutant [Cou86] computed alias information on a program-wide basis, building a single, global mapping between pointers and their potential referents.
Reference: [WL95] <author> R. P. Wilson and M. S. Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation. </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1995. </year> <note> (this volume). 10 </note>
Reference-contexts: One approach explicitly re-analyzes each procedure under multiple contexts: Emami et al [EGH94] create a context for each each acyclic path from the root of the call graph to the current invocation, while Wilson and Lam <ref> [WL95] </ref> build one context per set of "relevant" aliases holding on entry to the procedure. <p> We use a "points-to" model of aliasing; that is, at each program point, our analysis models the contents of storage locations (points-to relations) rather than modeling equivalence classes of location-valued expressions (alias relations). In this respect, our analysis is similar to <ref> [RM88, HPR89, CWZ90, EGH94, WL95] </ref> and different from [Coo89, LR92, CBC93, Deu94]. We chose the points-to model because it fits naturally into our intermediate representation, and because its storage requirements are likely to be smaller.
References-found: 23

