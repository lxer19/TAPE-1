URL: http://www.cs.rochester.edu/u/singhal/456/survey.ps
Refering-URL: http://www.cs.rochester.edu/stats/oldmonths/1998.05/docs-name.html
Root-URL: 
Title: Real Time Systems A Survey  
Author: Amit Singhal 
Date: December 4, 1996  
Affiliation: Computer Science Department University of Rochester  
Abstract-found: 0
Intro-found: 0
Reference: [All87] <author> S.T. Allworth, R.N. Zobel. </author> <title> Introduction to Real Time Software Design. 2nd ed., </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: The higher levels of abstraction represent processes, channels, buffers, shared pools, synchronization events, interrupts etc. Each level of abstraction represents a virtual machine, allowing for a high degree of portability and maintainability of the system. For further details on virtual machines, please refer to <ref> [All87] </ref>. 4.2 Process Abstractions Once a system has been decomposed into subsystems and the tasks therein identified, one can use process abstractions to represent the activities that these subsystems must perform.
Reference: [Alu90] <author> R. Alur, T.A. Henzinger. </author> <title> Real Time Logics : Complexity and Expressiveness. </title> <booktitle> Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: Although certain timing constraints cannot be specified in this type of logic, it has been proven to be decidable in the finite state discrete time case <ref> [Alu90] </ref>. The MTL model is also referred to as the hidden clock model because of implicit references to the clock. MTL specifications of finite state systems are automatically verifiable because of the decidability property.
Reference: [Bak89] <author> T.P. Baker, A. Shaw. </author> <title> The Cyclic Executive Model and ADA. </title> <journal> The Journal of Real Time Systems, </journal> <volume> vol.1 , no. 1, </volume> <month> Jun </month> <year> 1989, </year> <pages> pp 7-25. </pages>
Reference-contexts: However, this does not hold true in case any of the tasks are modified or there is an unexpected occurrence during execution of the system. For further details on cyclic executive scheduling algorithms, please refer to <ref> [Bak89] </ref>. 5.3 Fixed Priority Model The fixed priority model is one of the most popular models for developing scheduling algorithms. It handles the problems of the cyclic executive model by allowing the tasks to be preemptive and assigning them fixed priorities.
Reference: [Bak91] <author> T.P. Baker, O. Pazy. </author> <title> Real Time Features for ADA 9X. </title> <booktitle> Proceedings of the IEEE 1991 Real Time Systems Symposium, </booktitle> <year> 1991, </year> <pages> pp 172-180. </pages>
Reference-contexts: It also allows for multiple processes (multiprogramming only) which synchronize through waits and signals. The language allows direct hardware access and separate compilation. However, it is not used outside of LGZ where it was developed. PEARL [Mar78] and ADA 9X <ref> [Bak91] </ref> are the most commonly used real time languages and are being continually enhanced and standardized. PEARL was developed in West Germany and has become one of the most popular languages for real time systems all across Europe.
Reference: [Ber91] <author> B. Berthomieu, M. Diaz. </author> <title> Modelling and Verification of Time Dependent Systems Using Petri Nets. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, no. 3, </volume> <month> Mar </month> <year> 1991, </year> <pages> pp 259-273. </pages>
Reference-contexts: These methods provide a structured set of system requirements. The system requirements specify what problems must be solved by the controller and how [Ost92]. The most commonly used (and by far the most popular) method for formal 7 system specification and verification is Petri Nets <ref> [Ber91, Lev87] </ref>. They are described below in further detail. 2.2.1 Petri Nets Petri Nets have long been a popular model for formally specifying any system. They have also had the most success in specifying real time systems because of the ease of inserting temporal parameters into their structure. <p> This method can be easily extended to work on timed petri nets used in specifying real time systems. For a more detailed discussion on petri nets, please refer to <ref> [Ber91] </ref>. 2.3 Process Algebras Process algebras are very similar to logic approaches for specifying and verifying real time systems but provide a more structured analysis and decomposition. They have been successfully applied to analysis of concurrent event processing and discrete event systems.
Reference: [Bet93] <author> R. Bettati. </author> <title> On Line Scheduling for Checkpointing Imprecise Computation. </title> <booktitle> Proceedings of the Fifth Euromicro Workshop on Real Time Systems, </booktitle> <year> 1993, </year> <pages> pp 238-243. </pages>
Reference-contexts: If a failure has occurred, the fault tolerance system may preempt the task at this stage to make up for lost time. Imprecise computation techniques are discussed in greater detail in <ref> [Bet93] </ref>. 7 Hardware Architecture and the Operating Sys tem These two topics are so interwoven that it is impossible to talk about them separately. The operating system is dictated by the hardware architecture and the hardware architecture needs to be able to support the operating system.
Reference: [Boo86] <author> G. Booch. </author> <title> Object Oriented Development. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-12, no. 2, </volume> <month> Feb </month> <year> 1986, </year> <pages> pp 211-221. </pages>
Reference-contexts: An abstraction is just a simple description of a subsystem, emphasizing certain aspects of it while hiding all the unnecessary details. The information hiding principle allows for the design of each subsystem to be local and independent of all other subsystems. For more detailed analysis, please see <ref> [Boo86] </ref>. 4.1.3 Virtual Machines Hierarchically layered virtual machines can be used to design complex real time systems which are not easily decomposable using one of the two strategies above.
Reference: [Bro92] <author> D.B. Brown et al. </author> <title> An Automated Oracle for Software Testing. </title> <journal> IEEE Transactions on Reliability, </journal> <volume> vol. 41, no. 2, </volume> <month> Jun </month> <year> 1992, </year> <pages> pp 272-280. </pages>
Reference-contexts: One of the biggest problems with monitor based approaches is that the monitor can introduce execution delays and affect the performance of the system because of the close coupling. For further details on monitor based approaches, please refer to <ref> [Bro92, San93] </ref>. 6.2 Supervisor Based Approaches Supervisor based approaches work very similarly to monitor based approaches except that the supervisor is separate from the real time system and runs alongside it without using any of the real time system's resources.
Reference: [Des90] <author> A.K. Deshpande. </author> <title> A Framework for Network of Processes Using Dataflow Graph Model. </title> <type> Ph.D. Thesis, </type> <institution> UT-Arlington, Arlington, TX, </institution> <year> 1990. </year>
Reference-contexts: Execution of data flow graphs is data driven (ie. once all the inputs for an actor are available, it is executed). This allows for asynchronous parallelization of computations with no dependencies. For further details on data flow graphs, please refer to <ref> [Des90, Kav90] </ref>. 15 5 Scheduling for Real Time Systems One of the biggest research areas in real time systems has been that of scheduling. Real time systems have timing constraints such as deadlines that must be met in a predictable and robust manner.
Reference: [Don92] <author> M. Donner, </author> <title> D.J. Jameson. Language and Operating Systems Features for Real Time Programming. </title> <booktitle> Computer Systems, </booktitle> <year> 1992. </year>
Reference-contexts: Below are four experimental languages, each of which is exploring a different domain of real time languages. As of today, an implementation of none of these languages has been reported in the literature. ORE <ref> [Don92] </ref> is an attempt to further exploit concurrency in real time systems by allowing processes to request their own (and their siblings) preemption and resumption. Critical code can be marked as non preemptive code. The language design borrows from the execution strips of TOMAL for performing schedulability analysis.
Reference: [Gar81] <author> J.R. Garman. </author> <title> The bug heard round the world. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <year> 1981. </year>
Reference-contexts: An example of such an incident is the delay in the first space shuttle flight due to an improbable race condition that went undetected during the multiple hand runs through the system <ref> [Gar81] </ref>.
Reference: [Ger90] <author> R. Gerber, I. Lee. </author> <title> A Proof System for Communicating Shared Resources. </title> <booktitle> Proceedings of the IEEE Real Time Systems Symposium, </booktitle> <year> 1990, </year> <pages> pp 288-299. </pages>
Reference-contexts: However, further research in the area may give us some excellent methods for formally specifying concurrent real time systems. Two of the most encouraging process algebras are Communicating Sequential Processes (CSP) [Ree91, Mol90] and Calculus of Communicating Processes (CCS) <ref> [Nic91, Ger90] </ref>. 2.4 Assertional Methods Assertional methods try and combine the characteristics of real time logics and operational semantics. They involve reasoning about events and their time of occurrence. [Hoo90] presents an assertional Hoare-style logic for reasoning about the composition of real time systems.
Reference: [Gom89] <author> H. Gomaa. </author> <title> A Software Design Method for Distributed Real Time Applications. </title> <journal> The Journal of Systems and Software, </journal> <year> 1989, </year> <pages> pp 81-94. 23 </pages>
Reference-contexts: There usually exists high cohesion between tasks in a subsystem (functionally related tasks are part of the same subsystem) and weak couplings (minimizing synchronization and increasing parallelism) across subsystems. For a more detailed analysis, please refer to <ref> [Gom89] </ref>. 4.1.2 Object Oriented Decompositions Object oriented methodologies differ from functional methodologies primarily in the manner in which the subsystems and tasks are identified. Rather than representing a set of similar functionalities, each subsystem represents a major object in the real time system.
Reference: [Gri94] <author> A.S. Grimshaw et al. </author> <title> Real Time MENTAT Programming Language and Ar--chitecture. </title> <booktitle> Proceedings of GLOBECOM'94, </booktitle> <year> 1994. </year>
Reference-contexts: This allows the language to support a rich variety of resource and timing constraints. Also, FLEX does not force all of its programs to be schedulability analyzable, only those that are critical to the real time 12 system have to meet the stringent criteria. Real Time MENTAT <ref> [Gri94] </ref> simplifies the task of programming parallel real time applications. It includes a very high level data flow language that maps to an extended version of C++. One of the major features is that processes (called actors in RTM) can maintain their state between executions.
Reference: [Hal91] <author> W. Halang, A. Stoyenko. </author> <title> Constructing Predictable Real Time Systems. </title> <publisher> Kluwer Academic Publishers, Norwell, </publisher> <address> MA, </address> <year> 1991. </year>
Reference-contexts: To be able to do that, the system must know exactly how much time each instruction takes to execute and this time must be invariant, there must be no unpredictable delays in the execution cycle, and the system must provide for fault tolerance and recovery <ref> [Hal91] </ref>. Let us examine some of the features of a real time hardware system in greater detail. In the second part of this section, we will take a look at the VIPER hardware architecture proposed in [Hal91]. 7.1 Features of Real Time Hardware/OS Since real time hardware and operating systems have <p> in the execution cycle, and the system must provide for fault tolerance and recovery <ref> [Hal91] </ref>. Let us examine some of the features of a real time hardware system in greater detail. In the second part of this section, we will take a look at the VIPER hardware architecture proposed in [Hal91]. 7.1 Features of Real Time Hardware/OS Since real time hardware and operating systems have to satisfy the requirements mentioned in the section above, they are characterized by a well defined set of features. <p> access. * no pipelining. * no caches. * no virtual memory. * limited instruction set. * peripherals and devices have timing characteristics. * high resolution real time clock. * separate processors for real time system tasks and operating system/control system tasks. 7.2 The VIPER Architecture The VIPER system proposed in <ref> [Hal91] </ref> has all of the features mentioned above. The operating system and support functions are migrated into a co-processor (specialized hardware) or firmware. This allows reliable, efficient and inconspicuous execution of support systems without interfering with the real time system.
Reference: [Hal92] <author> W. Halang. </author> <title> Real Time Systems : Another Perspective. </title> <journal> The Journal of Systems and Software, </journal> <month> Apr </month> <year> 1992, </year> <pages> pp 101-108. </pages>
Reference-contexts: It is actually quite common to view the real time system as a collection of concurrent processes [Kav92]. Real time systems must essentially be distributed and provide for parallel processing <ref> [Hal92] </ref>. This parallelism in the system may exist due to multiple sensors, each independent of the other, providing stimuli to the system and requiring response from the system within a given time frame. The presence of such parallelism in real time systems introduces some additional complexities in the system.
Reference: [Han92] <author> C.C. Han, K.J. Lin. </author> <title> Scheduling Distance Constrained Real Time Tasks. </title> <booktitle> Proceedings of the 13th IEEE Real Time Systems Symposium, </booktitle> <year> 1992, </year> <pages> pp 300-308. </pages>
Reference-contexts: For each task, this distance is not arbitrary but a multiple of the base minimum distance. Thus the NP-complete problem of generating schedules for arbitrary distance constraints is avoided. For a more detailed analysis of the distance constrained model, please refer 17 to <ref> [Han92] </ref>. 6 Fault Tolerance One of the most important requirements of a real time system is that it be robust and able to handle failures in the system without significant degradation of the system performance.
Reference: [Hoo90] <author> J.J.M. Hooman, </author> <title> W.P. deRoever. Design and Verification in Real Time Distributed Computing : An Introduction to Compositional Methods. Protocol Specification, Testing and Verification, </title> <booktitle> 1990, </booktitle> <pages> pp 37-56. </pages>
Reference-contexts: Two of the most encouraging process algebras are Communicating Sequential Processes (CSP) [Ree91, Mol90] and Calculus of Communicating Processes (CCS) [Nic91, Ger90]. 2.4 Assertional Methods Assertional methods try and combine the characteristics of real time logics and operational semantics. They involve reasoning about events and their time of occurrence. <ref> [Hoo90] </ref> presents an assertional Hoare-style logic for reasoning about the composition of real time systems.
Reference: [Hoo92] <author> B. Hoogeboom, W. Halang. </author> <title> The Concept of Time in the Specification of Real Time Systems. </title> <address> Groningen, Denmark, </address> <year> 1992. </year>
Reference-contexts: The above problem is made even more difficult in the face of concurrency issues inherently present in real time applications. The success of predicate-transformation methods in proving correctness of sequential programs has simulated interest in formal methods to incorporate time into the specification of parallel processes <ref> [Hoo92] </ref>. However, there has been little success. Many formal methods for specifying and verifying real time systems have been proposed over the years. <p> Their major advantage has been the already available base of results and methods in sequential logic methods and the proven correctness of these results. While a lot of work has been done in temporal logics, they have insufficient capability 6 to express time <ref> [Hoo92] </ref>. Only the orderings of various discrete events can be specified and verified. Real time temporal logic is an explicit clock logic that has high expressive power but has been shown to be NP-complete.
Reference: [Ish95] <author> H.T. Ishikawa. </author> <title> Object Oriented Real Time Language Design : Constructs for Timing Constraints. </title> <institution> Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <year> 1995. </year>
Reference-contexts: There is also a specification for a visual user interface to manipulate the data flow graph used for writing RTM programs. RTM also has formal language constructs for soft real time programming. Real Time C++ <ref> [Ish95] </ref> is an extension of C++ and the first attempt at programming an object oriented real time language. In addition to regular C++ objects, RTC++ defines active objects which can have more than one internal thread associated with them.
Reference: [Kav90] <author> K.M. Kavi, A.K. Deshpande. </author> <title> A Model and a Proof System for Parallel and Distributed Processes. </title> <address> HICSS-23, </address> <year> 1990, </year> <pages> pp 386-392. </pages>
Reference-contexts: Execution of data flow graphs is data driven (ie. once all the inputs for an actor are available, it is executed). This allows for asynchronous parallelization of computations with no dependencies. For further details on data flow graphs, please refer to <ref> [Des90, Kav90] </ref>. 15 5 Scheduling for Real Time Systems One of the biggest research areas in real time systems has been that of scheduling. Real time systems have timing constraints such as deadlines that must be met in a predictable and robust manner.
Reference: [Kav92] <author> K.M. Kavi. </author> <title> Real Time Systems : Abstractions, </title> <booktitle> Languages and Design Methodologies. </booktitle> <publisher> IEEE Computer Press, </publisher> <year> 1992. </year>
Reference-contexts: Once the stimuli have been received, they must be analyzed and the system must output responses to control the environment it is regulating. The real time system can be viewed as a regulating element in the feedback loop of the overall system <ref> [Kav92] </ref>. There may be various different timing constraints imposed on a system. The most common ones are deadline, period and ready time. 1.1.2 Predictability A second requirement of real time systems is that they must have predictable performance. <p> It is actually quite common to view the real time system as a collection of concurrent processes <ref> [Kav92] </ref>. Real time systems must essentially be distributed and provide for parallel processing [Hal92]. This parallelism in the system may exist due to multiple sensors, each independent of the other, providing stimuli to the system and requiring response from the system within a given time frame.
Reference: [KKY92] <author> K.M. Kavi, S. Yang. </author> <title> Real Time System Design Methodologies : An Introduction and a Survey. </title> <journal> The Journal of Systems and Software, </journal> <month> Apr </month> <year> 1992, </year> <pages> pp 85-99. </pages>
Reference: [Kie76] <author> R.B. Kieburtz, J.L. Hennessey. </author> <title> TOMAL A High Level Programming Language for Microprocessor Process Control Applications. </title> <booktitle> ACM SIGPLAN Notes, </booktitle> <year> 1976, </year> <pages> pp 127-134. </pages>
Reference-contexts: Each of them provided programming constructs to specify some orderings and even timing constraints on the tasks but none could be verified for accuracy, predictability and robustness. One of the biggest breakthroughs in real time languages came with TOMAL <ref> [Kie76] </ref>. Though an implementation of the language was never released (forever classifying it as an experimental language), it was the first language to explicitly provide for schedulability analysis.
Reference: [Koy90] <author> R. Koymans. </author> <title> Specifying Real Time Properties with Metric Temporal Logic. </title> <journal> Real Time Systems Journal, </journal> <volume> vol. 2, no. 4, </volume> <month> Nov </month> <year> 1990, </year> <pages> pp 255-299. </pages>
Reference-contexts: Real time temporal logic is an explicit clock logic that has high expressive power but has been shown to be NP-complete. Certain subsets of it have, however, been proven decidable and we will talk in some detail about two of them, Metric Temporal Logic <ref> [Koy90] </ref> and Timed Transition Model [Ost90]. 2.1.1 Metric Temporal Logic In metric temporal logic, the real time clock cannot be explicitly referenced but referred to via bounds on the temporal operators. <p> MTL specifications of finite state systems are automatically verifiable because of the decidability property. MTL can be used to specify real time systems such as communication protocols and process control systems with continuously changing variables. For a more detailed description of how to use MTL, please see <ref> [Koy90, Nar88] </ref>. 2.1.2 Timed Transition Model A timed transition model can be used to specify both hardware and software systems. They are useful in specifying real time programming languages, timed petri nets, statecharts and sequential processes.
Reference: [Lee84] <author> I. Lee. </author> <title> A Programming System for Distributed Real Time Applications. </title> <booktitle> Proceedings of the IEEE 1984 Real Time Systems Symposium, </booktitle> <year> 1984, </year> <pages> pp 18-27. </pages>
Reference: [Lee85] <author> I. Lee, V. Gehlot. </author> <title> Language Constructs for Distributed Real Time Programming. </title> <booktitle> Proceedings of the IEEE 1985 Real Time Systems Symposium, </booktitle> <year> 1985, </year> <pages> pp 57-66. </pages>
Reference-contexts: DICON-DPS satisfies every requirement listed in the previous section for real time programming languages so let us look at it in further detail. 3.3 DICON-DPS Language Model DPS (distributed programming system) and DICON (distributed configuration specification language) <ref> [Lee85] </ref> fulfill all the criteria listed for real time languages. DICON is a very high level specification language and DPS provides a supporting environment and tools package for developing and running DICON programs. 11 DICON defines distributed static processes that declare how they should be acti-vated.
Reference: [Lev87] <author> N.G. Leveson, J.L. Stolzy. </author> <title> Safety Analysis Using Petri Nets. </title> <journal> IEEE Transac--tions on Software Engineering, </journal> <volume> vol. SE-13, no. 3, </volume> <month> Mar </month> <year> 1987, </year> <pages> pp 386-397. </pages>
Reference-contexts: These methods provide a structured set of system requirements. The system requirements specify what problems must be solved by the controller and how [Ost92]. The most commonly used (and by far the most popular) method for formal 7 system specification and verification is Petri Nets <ref> [Ber91, Lev87] </ref>. They are described below in further detail. 2.2.1 Petri Nets Petri Nets have long been a popular model for formally specifying any system. They have also had the most success in specifying real time systems because of the ease of inserting temporal parameters into their structure. <p> Timing constraints in petri nets are enforced by discrete or dense lower and upper time bounds on the transitions. An enumerative analysis technique models and analyzes the properties of the system. Verification is done by building a reachability graph (bounding it by using constraints) and checking it for satisfiability. <ref> [Lev87] </ref> proposed a method of performing verification on petri nets which did not look at the entire reachability graph but only at portions of it and did some backtracking to steer the system away from high-risk states.
Reference: [Lin92] <author> K.J. Lin, S. Natarajan. </author> <title> Expressing and Maintaining Timing Constraints in FLEX. </title> <booktitle> Proceedings of the IEEE 1992 Real Time Systems Symposium, </booktitle> <year> 1992. </year>
Reference-contexts: Critical code can be marked as non preemptive code. The language design borrows from the execution strips of TOMAL for performing schedulability analysis. FLEX <ref> [Lin92] </ref> is the first real time language to formally allow for soft real time programming. Depending on time and resource availability, FLEX programs may produce a result that is more or less precise, but not disastrous. FLEX programs also do not produce unexpected results or crash.
Reference: [Lin93] <author> K.J. Lin. </author> <title> Scheduling Models for Real Time Systems. </title> <booktitle> Proceedings of the Fifth Euromicro Workshop on Real Time Systems, </booktitle> <year> 1993, </year> <pages> pp 133-134. </pages>
Reference-contexts: that it can work well in a real time environment? What models for scheduling algorithms have been developed that guarantee such performance? The following subsections attempt to answer these questions in some detail. 5.1 Requirements of a Scheduling Algorithm Any real time scheduling algorithm must satisfy the following four requirements <ref> [Lin93] </ref> : * Easy to use. The scheduling algorithm should not require extensive search operations to find a feasible schedule for assigning resources to various tasks in the system. * Easy to check performance.
Reference: [Mar78] <author> T. Martin. </author> <title> Real Time Programming Language PEARL Concept and Characteristics. </title> <booktitle> The IEEE Computer Society 2nd International Computer Software and Application Conference, </booktitle> <year> 1978, </year> <pages> pp 301-306. </pages>
Reference-contexts: It also allows for multiple processes (multiprogramming only) which synchronize through waits and signals. The language allows direct hardware access and separate compilation. However, it is not used outside of LGZ where it was developed. PEARL <ref> [Mar78] </ref> and ADA 9X [Bak91] are the most commonly used real time languages and are being continually enhanced and standardized. PEARL was developed in West Germany and has become one of the most popular languages for real time systems all across Europe.
Reference: [Mol90] <author> F. Moller, C. Tofts. </author> <title> A Temporal Calculus of Communicating Systems. </title> <address> CONCUR'90, </address> <year> 1990, </year> <pages> pp 401-415. </pages>
Reference-contexts: However, further research in the area may give us some excellent methods for formally specifying concurrent real time systems. Two of the most encouraging process algebras are Communicating Sequential Processes (CSP) <ref> [Ree91, Mol90] </ref> and Calculus of Communicating Processes (CCS) [Nic91, Ger90]. 2.4 Assertional Methods Assertional methods try and combine the characteristics of real time logics and operational semantics.
Reference: [Nag79] <author> H.H. Nageli, A.K. Gorrengourt. </author> <title> Programming in PORTAL : An Introduction. </title> <institution> LGZ Landis and Gyr Zug Corporation, Zug, Switzerland, </institution> <year> 1979. </year>
Reference-contexts: Unfortunately, the lack of discovery of a polynomial time algorithm for performing schedulability analysis has prevented most of the implemented languages from truly being real time languages. PORTAL <ref> [Nag79] </ref> was the first implemented real time language and is very similar to MODULA and PEARL. It is very well structured, has strong type checking, modules with use and define lists, monitors and device monitors. It also allows for multiple processes (multiprogramming only) which synchronize through waits and signals.
Reference: [Nar88] <author> K.T. Narayana, A.A. Aaby. </author> <title> Specification Real Time Systems in Real Time Temporal Logic. </title> <booktitle> Proceedings of the Real Time Systems Symposium, </booktitle> <month> Dec </month> <year> 1988, </year> <pages> pp 86-95. </pages>
Reference-contexts: MTL specifications of finite state systems are automatically verifiable because of the decidability property. MTL can be used to specify real time systems such as communication protocols and process control systems with continuously changing variables. For a more detailed description of how to use MTL, please see <ref> [Koy90, Nar88] </ref>. 2.1.2 Timed Transition Model A timed transition model can be used to specify both hardware and software systems. They are useful in specifying real time programming languages, timed petri nets, statecharts and sequential processes.
Reference: [Nic91] <author> X. Nicollin, J. Sifakis. </author> <title> An Overview and Synthesis on Timed Process Algebras. </title> <booktitle> Proceedings of the REX Workshop on Real Time : Theory in Practice, </booktitle> <year> 1991. </year>
Reference-contexts: However, further research in the area may give us some excellent methods for formally specifying concurrent real time systems. Two of the most encouraging process algebras are Communicating Sequential Processes (CSP) [Ree91, Mol90] and Calculus of Communicating Processes (CCS) <ref> [Nic91, Ger90] </ref>. 2.4 Assertional Methods Assertional methods try and combine the characteristics of real time logics and operational semantics. They involve reasoning about events and their time of occurrence. [Hoo90] presents an assertional Hoare-style logic for reasoning about the composition of real time systems.
Reference: [Ost90] <author> J.S. Ostroff, W.M. Wonham. </author> <title> A Framework for Real Time Discrete Event Control. </title> <journal> IEEE Transactions on Automatic Control, </journal> <volume> vol. 35, no. 4, </volume> <month> Apr </month> <year> 1990, </year> <pages> pp 386-397. </pages>
Reference-contexts: Real time temporal logic is an explicit clock logic that has high expressive power but has been shown to be NP-complete. Certain subsets of it have, however, been proven decidable and we will talk in some detail about two of them, Metric Temporal Logic [Koy90] and Timed Transition Model <ref> [Ost90] </ref>. 2.1.1 Metric Temporal Logic In metric temporal logic, the real time clock cannot be explicitly referenced but referred to via bounds on the temporal operators. <p> The TTM/RTTL framework has been proven to be decidable which allows it to be used for specifying and verifying real time systems automatically. TMM is used to represent the processes of plants and controllers and RTTL is the assertion language used for specifying plant behavior and verifying controller operations <ref> [Ost90] </ref>. Verification is performed in a manner similar to that of predicate transformation. Rather than building a state graph, the rules are logically manipulated for satisfiability. The operational semantics of TTMs represent the set of all paths the system can follow in its state space. <p> Rather than building a state graph, the rules are logically manipulated for satisfiability. The operational semantics of TTMs represent the set of all paths the system can follow in its state space. For a more detailed description of the TTM/RTTL framework, please refer to <ref> [Ost90] </ref>. 2.2 Operational Semantics Operational semantics refer to structured methods for specifying and verifying real time systems. These methods provide a structured set of system requirements. The system requirements specify what problems must be solved by the controller and how [Ost92].
Reference: [Ost92] <author> J.S. Ostroff. </author> <title> Formal Methods for the Specification and Design of Real Time Safety Critical Systems. </title> <journal> Journal of Systems and Software, </journal> <month> Apr </month> <year> 1992, </year> <pages> pp 33-60. </pages>
Reference-contexts: These methods provide a structured set of system requirements. The system requirements specify what problems must be solved by the controller and how <ref> [Ost92] </ref>. The most commonly used (and by far the most popular) method for formal 7 system specification and verification is Petri Nets [Ber91, Lev87]. They are described below in further detail. 2.2.1 Petri Nets Petri Nets have long been a popular model for formally specifying any system. <p> One of the ways to think about petri nets is as a combination of flowcharts and data flow diagrams. For further information on how to use timed petri nets for designing real time systems, please refer to <ref> [Ost92] </ref>. 4.2.4 Data Flow Graphs Data flow graphs are based on data flow languages and data flow diagrams but resemble petri nets in their structure.
Reference: [Ree91] <author> G.M. Reed, A.W. Roscoe. </author> <title> Timed CSP : Theory and Practice. </title> <booktitle> Proceedings of the REX Workshop on Real Time : Theory in Practice, </booktitle> <year> 1991. </year>
Reference-contexts: However, further research in the area may give us some excellent methods for formally specifying concurrent real time systems. Two of the most encouraging process algebras are Communicating Sequential Processes (CSP) <ref> [Ree91, Mol90] </ref> and Calculus of Communicating Processes (CCS) [Nic91, Ger90]. 2.4 Assertional Methods Assertional methods try and combine the characteristics of real time logics and operational semantics.
Reference: [Roe90] <editor> W.P. deRoever (Ed). </editor> <title> Formal Methods and Tools for the Development of Distributed and Real Time Systems. </title> <booktitle> Computing Science Notes, </booktitle> <institution> Eindhoven University of Technology, </institution> <year> 1990. </year>
Reference-contexts: Existing formalisms that are applied in the specification of real time systems may be grouped into four broad categories <ref> [Roe90] </ref>: * Temporal Logics * Operational Semantics * Process Algebras * Assertional Methods 2.1 Temporal Logics Temporal logics have been a popular way of trying to incorporate time into existing logic methods.
Reference: [San93] <author> S. Sankar. </author> <title> Concurrent Runtime Monitoring of Formally Specified Programs. </title> <journal> IEEE Computer, </journal> <volume> vol. 26, no. 3, </volume> <month> Mar </month> <year> 1993, </year> <pages> pp 32-41. 25 </pages>
Reference-contexts: One of the biggest problems with monitor based approaches is that the monitor can introduce execution delays and affect the performance of the system because of the close coupling. For further details on monitor based approaches, please refer to <ref> [Bro92, San93] </ref>. 6.2 Supervisor Based Approaches Supervisor based approaches work very similarly to monitor based approaches except that the supervisor is separate from the real time system and runs alongside it without using any of the real time system's resources.
Reference: [Sev93] <author> R.E. Seviora. </author> <title> Models for Real Time Supervision. </title> <booktitle> Proceedings of the Fifth Euromicro Workshop on Real Time Systems, </booktitle> <year> 1993, </year> <pages> pp 232-237. </pages>
Reference-contexts: For a more detailed analysis of supervisor based approaches, please refer to <ref> [Sev93] </ref>. 18 6.3 Imprecise Computation Based Approaches The most popular approach to fault tolerance is the imprecise computation principle. Succinctly put, the fault tolerance system makes a trade off between the accuracy of the computation and the execution time.
Reference: [Sha90] <author> L. Sha, J.B. Goodenough. </author> <title> Real Time Scheduling Theory and ADA. </title> <journal> IEEE Computer, </journal> <volume> vol. 23, no. 4, </volume> <month> Apr </month> <year> 1990, </year> <month> pp53-62. </month>
Reference-contexts: The very popular IRIS real time scheduler shipped with all standard SGI systems uses a fixed priority scheduling algorithm. For a more detailed description of the fixed priority model, please see <ref> [Sha90] </ref>. 5.4 Distance Constrained Model The distance constrained model provides a deterministic schedule, not by assigning each task a static schedule (based on timing constraints), but by using fixed priorities on harmonic periods.
Reference: [Sta88] <author> J. Stankovic. </author> <title> Misconceptions About Real Time Computing. </title> <booktitle> Computer, </booktitle> <month> Oct </month> <year> 1988, </year> <pages> pp 10-19. </pages>
Reference-contexts: 1 What are Real Time Systems Real time computing is a wide open research area of intellectually stimulating computer science problems with direct payoffs to current technology <ref> [Sta88] </ref>. In real time systems, not only is the logical result of the computation important, but also the time in which it was obtained. It would be necessary to distinguish real time computing from fast computing. <p> Lateness of the results only increases the cost of the system but not infinitely high. The more relaxed the timing constraints, the simpler the system required to control the operation. 1.3 Popular Misconceptions Most of the material presented in this subsection was obtained from <ref> [Sta88] </ref>. Real time systems research has traditionally lagged behind most other areas of systems research. A lot of popular misconceptions about real time systems have been responsible, at least in part, for this trend. <p> A lot of popular misconceptions about real time systems have been responsible, at least in part, for this trend. Here, I hope to dispel some of these notions and present an argument for increasing the pace of research in the area. According to <ref> [Sta88] </ref> some of the more common misconceptions harbored by researchers against real time systems are : * There is no science in real time systems. <p> An important research area in real time systems is the development of hierarchical or 5 selectable schedulers that make different resource allocations for different timing granularities. 2 Specification and Verification The fundamental challenge in the specification and verification of real time systems is how to incorporate the time metric <ref> [Sta88] </ref>. Methods, formal and informal, must be developed to incorporate these timing criteria into the specifications of a real time system. Similarly, verification methods must make sure that these timing constraints are being met and that the system is robust, predictable and accurate.
Reference: [Sto92] <author> A.D. Stoyenko. </author> <title> The Evolution and State-of-the-Art for Real Time Languages. </title> <journal> The Journal of Systems and Software, </journal> <month> Apr </month> <year> 1992, </year> <pages> pp 61-84. </pages>
Reference-contexts: Schedulability analyzable means that any program written in that language can be checked for adherence to the given timing constraints at compile time. The failure of an embedded computing system to properly control its real time processes can lead to major losses <ref> [Sto92] </ref>. Although the computation in any real time system tends to be large, the biggest demand of the system is a strict guarantee of accuracy, predictability and robustness.
Reference: [War86] <author> P.T. Ward. </author> <title> The Transformation Schema : An Extension to Data Flow Diagrams to Represent Control and Timing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <year> 1986, </year> <pages> pp 198-210. 26 </pages>
Reference-contexts: Each state represents the completion of an activity and the pathways represent conditions and events [KKM92]. 4.2.2 Extended Data Flow Diagrams Extended data flow diagrams <ref> [War86] </ref> are an extension to traditional data flow diagrams. They represent data transformations (function of the processes), control transformations (how data transformations are activated and deactivated), data flows (flow of data among transformations), control flows (signals, activations and deactivations), data stores and a state machine.
References-found: 45

