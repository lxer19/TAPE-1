URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR383.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Title: Example of Interactive Hardware Transformation  
Author: Zheng Zhu and Steven D. Johnson 
Date: May 1993  
Note: An  
Abstract: Indiana University Computer Science Department Technical Report No. 383 fl This paper was presented at the ACM/SIGDA Workshop on Formal Methods in VLSI design, Maimi, Florida, January 1991. Due to publication problems the procedings of this workshop has not yet appeared. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Camurati, P., and Prinetto, P. </author> <title> Formal verification of hardware correctness: Introduction and survey of current research. </title> <booktitle> Computer 21, </booktitle> <month> 7 </month> <year> (1988). </year>
Reference-contexts: Although these two approaches differ in several important ways, researchers have recognized the necessity of combining them. The power of verification systems is usually measured by their expressiveness. But a trade-off for expressiveness is proof complexity in those systems <ref> [1] </ref>. The following diagram gives a list of formal systems in the order of their expressive power versus the degree of proof complexity. A compromise between expressiveness and proof complexity has always been an important consideration in designing verification systems. 2.
Reference: [2] <author> Goguen, J. A., Thatcher, J. W., and Wagner, E. G. </author> <title> An initial algebra approach to the specification, correctness and implementation of abstract data types. In Current Trends in Programming Methodology, </title> <editor> R. Yeh, Ed. </editor> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J. 07632, </address> <year> 1978, </year> <journal> ch. </journal> <volume> 5, </volume> <pages> pp. 80-149. </pages>
Reference-contexts: Although equational specification and universal algebra are the bases of abstract data types specification and semantics, we 3. A Formal Framework of Hardware Specification 5 do not attempt to associate our hardware specification with any of the particular abstract data type semantics proposed in <ref> [2, 3, 4, 5, 6, 7] </ref>. Some of the definitions were inspired by [2]. More detailed discussion on the specifying hardware architecture in an algebraic framework can be found in [8, 9]. 3.1 Specifying Hardware Architecture and System Let S be a set of sorts. <p> A Formal Framework of Hardware Specification 5 do not attempt to associate our hardware specification with any of the particular abstract data type semantics proposed in [2, 3, 4, 5, 6, 7]. Some of the definitions were inspired by <ref> [2] </ref>. More detailed discussion on the specifying hardware architecture in an algebraic framework can be found in [8, 9]. 3.1 Specifying Hardware Architecture and System Let S be a set of sorts. <p> As pointed out in the literature (e.g. <ref> [2, 3] </ref> etc), equational specifications can be used as specifications for abstract data types. We now extend equational specifications to define abstract hardware architecture syntactically. Definition 1. <p> Since we have shown that an architecture can be defined in terms of -algebra, we borrow the definition of -algebras from <ref> [2] </ref>. Definition 5.. Let and be S 1 -sorted and S 2 -sorted operator domains respectively.
Reference: [3] <author> Ehrig, H., and Mahr, B. </author> <title> Fundamentals of Algebraic Specification 1; Equations and Initial Semantics, </title> <booktitle> vol. 6 of EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Although equational specification and universal algebra are the bases of abstract data types specification and semantics, we 3. A Formal Framework of Hardware Specification 5 do not attempt to associate our hardware specification with any of the particular abstract data type semantics proposed in <ref> [2, 3, 4, 5, 6, 7] </ref>. Some of the definitions were inspired by [2]. More detailed discussion on the specifying hardware architecture in an algebraic framework can be found in [8, 9]. 3.1 Specifying Hardware Architecture and System Let S be a set of sorts. <p> As pointed out in the literature (e.g. <ref> [2, 3] </ref> etc), equational specifications can be used as specifications for abstract data types. We now extend equational specifications to define abstract hardware architecture syntactically. Definition 1.
Reference: [4] <author> Meseguer, J., and Goguen, J. Initiality, </author> <title> induction, and computability. In Algebraic Methods in Semantics, </title> <editor> M. Nivat and J. C. Reynolds, Eds. </editor> <publisher> Cambridge University Press, </publisher> <year> 1985, </year> <pages> pp. 459-541. REFERENCES 16 </pages>
Reference-contexts: Although equational specification and universal algebra are the bases of abstract data types specification and semantics, we 3. A Formal Framework of Hardware Specification 5 do not attempt to associate our hardware specification with any of the particular abstract data type semantics proposed in <ref> [2, 3, 4, 5, 6, 7] </ref>. Some of the definitions were inspired by [2]. More detailed discussion on the specifying hardware architecture in an algebraic framework can be found in [8, 9]. 3.1 Specifying Hardware Architecture and System Let S be a set of sorts.
Reference: [5] <author> Wand, M. </author> <title> Final algebra semantics and data type extensions. </title> <journal> Journal of Computing System Science 19 (1979), </journal> <pages> 27-44. </pages>
Reference-contexts: Although equational specification and universal algebra are the bases of abstract data types specification and semantics, we 3. A Formal Framework of Hardware Specification 5 do not attempt to associate our hardware specification with any of the particular abstract data type semantics proposed in <ref> [2, 3, 4, 5, 6, 7] </ref>. Some of the definitions were inspired by [2]. More detailed discussion on the specifying hardware architecture in an algebraic framework can be found in [8, 9]. 3.1 Specifying Hardware Architecture and System Let S be a set of sorts.
Reference: [6] <author> Kamin, S. </author> <title> Final data types and their specification. </title> <booktitle> ACM Transaction of Programming Languages and Systems 5, </booktitle> <month> 1 (January </month> <year> 1983), </year> <pages> 97-123. </pages>
Reference-contexts: Although equational specification and universal algebra are the bases of abstract data types specification and semantics, we 3. A Formal Framework of Hardware Specification 5 do not attempt to associate our hardware specification with any of the particular abstract data type semantics proposed in <ref> [2, 3, 4, 5, 6, 7] </ref>. Some of the definitions were inspired by [2]. More detailed discussion on the specifying hardware architecture in an algebraic framework can be found in [8, 9]. 3.1 Specifying Hardware Architecture and System Let S be a set of sorts.
Reference: [7] <author> Bergstra, J. A., and Tucker, J. V. </author> <title> Initial and final algebra semanitcs for data type specification: Two characterization theorems. </title> <journal> SIAM Journal of Computing Vol 12, </journal> <volume> No. </volume> <month> 2 (May </month> <year> 1983), </year> <pages> 366-387. </pages>
Reference-contexts: Although equational specification and universal algebra are the bases of abstract data types specification and semantics, we 3. A Formal Framework of Hardware Specification 5 do not attempt to associate our hardware specification with any of the particular abstract data type semantics proposed in <ref> [2, 3, 4, 5, 6, 7] </ref>. Some of the definitions were inspired by [2]. More detailed discussion on the specifying hardware architecture in an algebraic framework can be found in [8, 9]. 3.1 Specifying Hardware Architecture and System Let S be a set of sorts.
Reference: [8] <author> Zhu, Z., and Johnson, S. D. </author> <title> An algebraic framework for data abstraction in hardware description. </title> <booktitle> In Proceedings of The Workshop of Design Correct Circuits, Oxford, England (1990), </booktitle> <editor> G. Jones, Ed., </editor> <publisher> Spring-Verlag. </publisher>
Reference-contexts: Some of the definitions were inspired by [2]. More detailed discussion on the specifying hardware architecture in an algebraic framework can be found in <ref> [8, 9] </ref>. 3.1 Specifying Hardware Architecture and System Let S be a set of sorts. An S-sorted signature is an S fl ! S-sorted family h w!s j w 2 S fl and s 2 Si. <p> The other transformations in the example are transformations concerning abstract bases of hardware systems such as implementing one architecture by another. These transformations are our major interest since they are rarely discussed in the research of digital design transformation. This section reviews the results concerning correct implementation of architecture <ref> [8] </ref> and examines the correctness of the transformations presented in the last section. 6.1 Correctness of Architectural Implementations As we stated in the last section, in order to obtain a correctness preserving hardware transformation, the correctness of the implementation of the underlying architecture must be assured when it is given. <p> Theorem 1 asserts the condition under which a given function d constitutes a derivor of an implementation (See Definition 5). <ref> [8] </ref> provides a formal proof of the theorem. Furthermore, the theorem implies that the proof of the correctness of implementation can be conducted with the help of a partially effective procedure. Definition 7. Let E 1 , E 2 and E 3 be definite sets of equations. 1.
Reference: [9] <author> Zhu, Z., and Johnson, S. D. </author> <title> An algebraic characterization of structural synthesis for hardware. </title> <booktitle> In Proceedings of The international Workshop on The Applied Formal Methods for Correct VLSI Designs (1989), </booktitle> <editor> L. Claesen, Ed., </editor> <publisher> North Holland. </publisher>
Reference-contexts: Some of the definitions were inspired by [2]. More detailed discussion on the specifying hardware architecture in an algebraic framework can be found in <ref> [8, 9] </ref>. 3.1 Specifying Hardware Architecture and System Let S be a set of sorts. An S-sorted signature is an S fl ! S-sorted family h w!s j w 2 S fl and s 2 Si. <p> This transformation, called serialization, is analogous to the problems of allocation and scheduling in high level synthesis (e.g. [16, 17]), register allocation and code generation in compiler design (e.g [20]) and microcode generation (e.g. [21]). <ref> [9] </ref> gives a formalization of the serialization problem in the current algebraic framework. Unfortunately, it is readily proved that the serialization problem is unsolvable in general [9]. Nevertheless, heuristic algorithms have been found to cope with similar problems (such as register allocation or microcode generation). <p> and scheduling in high level synthesis (e.g. [16, 17]), register allocation and code generation in compiler design (e.g [20]) and microcode generation (e.g. [21]). <ref> [9] </ref> gives a formalization of the serialization problem in the current algebraic framework. Unfortunately, it is readily proved that the serialization problem is unsolvable in general [9]. Nevertheless, heuristic algorithms have been found to cope with similar problems (such as register allocation or microcode generation).
Reference: [10] <author> Johnson, S. D. </author> <title> Synthesis of Digital Designs from Recursion Equations. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, </address> <year> 1984. </year>
Reference-contexts: Specification of Hardware Systems 7 4 Specification of Hardware Systems This section gives a simple specification of circuits. It is a simplified version of Johnson's functional notation <ref> [10] </ref> with an emphasis on the idea of separating architecture from control in circuit specifications. As we can see in this section that a control of a hardware system is a recursive structure over the underlying hardware architecture. <p> Johnson <ref> [10] </ref> shows that such an iterative recursion function characterizes a sequential control of circuit as shown in the circuit schematic below.
Reference: [11] <author> Johnson, S. D., Bose, B., and Boyer, C. D. </author> <title> A tactical framework for digital design. In VLSI Specification, Verification and Synthesis, </title> <editor> G. Birtwistle and P. Subrahmanyam, Eds. </editor> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1988, </year> <pages> pp. 349-383. </pages>
Reference-contexts: The first transformation is the abstraction or encapsulation of all the arithmetic operations into an arithmetic unit <ref> [11, 12] </ref>. <p> They are selected because they demonstrate some interesting aspects of design transformation. 6 Correctness of the Transformations The transformation from Specification 1 to Specification 2 belongs to the class of control transformations. It is called encapsulation since it encapsulates all the arithmetic operations to an arithmetic unit <ref> [11] </ref>. It has been implemented in Indiana University's digital design system DDD [12]. The other transformations in the example are transformations concerning abstract bases of hardware systems such as implementing one architecture by another.
Reference: [12] <author> Johnson, S. D., and Bose, B. </author> <title> A system for digital design derivation. </title> <type> Tech. Rep. </type> <institution> TR-289, Department of Computer Science, Indiana University, Bloomington IN 47405-4101, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: The first transformation is the abstraction or encapsulation of all the arithmetic operations into an arithmetic unit <ref> [11, 12] </ref>. <p> It is called encapsulation since it encapsulates all the arithmetic operations to an arithmetic unit [11]. It has been implemented in Indiana University's digital design system DDD <ref> [12] </ref>. The other transformations in the example are transformations concerning abstract bases of hardware systems such as implementing one architecture by another. These transformations are our major interest since they are rarely discussed in the research of digital design transformation.
Reference: [13] <author> Goguen, J. A. </author> <title> OBJ as a theorem prover with application to hardware verification. </title> <type> Tech. Rep. </type> <institution> SRI-CSl-88-4R2, SRI International, </institution> <year> 1988. </year>
Reference-contexts: The significance of this theorem is that it characterizes implementation in terms of equational rewriting mechanisms. Therefore, the correctness of implementations can be examined with a help of theorem provers such as OBJ <ref> [13] </ref> and AFFIRM [14]. In the example, the first derivor d was to transfer an architecture with stack to one with memory (From Specification 2. to Specification 3.). It is specified as follows: 1.
Reference: [14] <author> Gerhart, S. L., Musser, D. R., and Thompson, D. H. </author> <title> An overview of AFFIRM: A specification and verification system. </title> <booktitle> In Proceedings IFIP 80 (1980), </booktitle> <editor> S. H. Lavington, Ed., </editor> <publisher> North-Holland, </publisher> <pages> pp. 343-348. </pages>
Reference-contexts: The significance of this theorem is that it characterizes implementation in terms of equational rewriting mechanisms. Therefore, the correctness of implementations can be examined with a help of theorem provers such as OBJ [13] and AFFIRM <ref> [14] </ref>. In the example, the first derivor d was to transfer an architecture with stack to one with memory (From Specification 2. to Specification 3.). It is specified as follows: 1.
Reference: [15] <author> Zhu, Z., and Johnson, S. D. </author> <title> A product oriented hardware algebra. </title> <booktitle> In progress, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: It should be pointed out this mapping is actually the one for an abstract data type (stack) to another (memory/address) rather than H 1 ! H 2 . But since we can prove that the product preserves implementation relation <ref> [15] </ref>, we consider that the mapping of H 1 ! H 2 as the natural extension of that of the abstract data types. <p> Such a technique is also widely used in pipelined architectural designs and other areas of hardware designs. In order to replace combinational signals by registers, new registers need to be introduced. However, as we have discussed in <ref> [15, 19] </ref> that introducing new registers will not affect the correctness of circuit description if they are not referenced in the datapaths to those original registers. Let G a set of combinational signals an architecture can generate and H be the set of datapath of an architecture.
Reference: [16] <author> McFarland, M. C., Parker, A. C., and Camposano, R. </author> <title> Tutorial on high-level synthesis. </title> <booktitle> In Proceedings of the 25th ACM/IEEE Design Automation Conference (Anaheim, </booktitle> <address> CA, </address> <year> 1988), </year> <month> ACM/SIGDA, </month> <pages> pp. 330-336. </pages>
Reference-contexts: There are two types of resource sharing. The first one is sharing functional units such as arithmetic unit, buses etc. This type of problem has been extensively studied and successfully applied to an area of design automation. It is called scheduling and allocation in high level synthesis literature <ref> [16, 17] </ref>. The main techniques used to solve the problem are control and data flow analysis. The second kind of resource sharing is complicated components such as memory or registers. Since these components have their own internal structures, flow analysis alone is insufficient to achieve the goal. <p> This transformation, called serialization, is analogous to the problems of allocation and scheduling in high level synthesis (e.g. <ref> [16, 17] </ref>), register allocation and code generation in compiler design (e.g [20]) and microcode generation (e.g. [21]). [9] gives a formalization of the serialization problem in the current algebraic framework. Unfortunately, it is readily proved that the serialization problem is unsolvable in general [9].
Reference: [17] <author> Camposano, R. </author> <title> Behavior-preserving transformations for high-level synthesis. In VLSI Specification, Verification and Synthesis: </title> <journal> Mathematical Aspects (New York, </journal> <month> July </month> <year> 1989), </year> <editor> M. Leeser and G. Brown, Eds., </editor> <booktitle> Proceedings of Mathematical Sciences Institute Workshop, </booktitle> <institution> Cornell University, </institution> <note> Springer-Verlag. Lecture Notes in Computer Science Vol-408. </note>
Reference-contexts: There are two types of resource sharing. The first one is sharing functional units such as arithmetic unit, buses etc. This type of problem has been extensively studied and successfully applied to an area of design automation. It is called scheduling and allocation in high level synthesis literature <ref> [16, 17] </ref>. The main techniques used to solve the problem are control and data flow analysis. The second kind of resource sharing is complicated components such as memory or registers. Since these components have their own internal structures, flow analysis alone is insufficient to achieve the goal. <p> This transformation, called serialization, is analogous to the problems of allocation and scheduling in high level synthesis (e.g. <ref> [16, 17] </ref>), register allocation and code generation in compiler design (e.g [20]) and microcode generation (e.g. [21]). [9] gives a formalization of the serialization problem in the current algebraic framework. Unfortunately, it is readily proved that the serialization problem is unsolvable in general [9].
Reference: [18] <author> Gr atzer, G. </author> <title> Universal Algebra. </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: This result is a variation of Birkhoff's. The proof of original result can be found in <ref> [18] </ref>, page 120. Furthermore, it can be proven that 1 and 2 defined above automatically satisfy condition 2 and condition 3.
Reference: [19] <author> Johnson, S. D. </author> <title> Manipulating logical organization with system factorizations. In Hardware Specification, Verification and Synthesis: </title> <journal> Mathematical Aspects, Mathematical Sciences Institute Workshop (July, </journal> <year> 1989), </year> <editor> G. B. M. Leeser, Ed., </editor> <publisher> Cornell University, </publisher> <address> Ithaca, NY, USA, </address> <publisher> Springer Verlag, </publisher> <pages> pp. 260-281. </pages> <note> Lecture Notes in Computer Science Vol 408. REFERENCES 17 </note>
Reference-contexts: Such a technique is also widely used in pipelined architectural designs and other areas of hardware designs. In order to replace combinational signals by registers, new registers need to be introduced. However, as we have discussed in <ref> [15, 19] </ref> that introducing new registers will not affect the correctness of circuit description if they are not referenced in the datapaths to those original registers. Let G a set of combinational signals an architecture can generate and H be the set of datapath of an architecture.
Reference: [20] <author> Aho, A. V., Sethi, R., and Ullman, J. D. </author> <title> Compiler: Principle, Techniques and Tools. </title> <publisher> Eddison Wesley Publising Company, </publisher> <year> 1988. </year>
Reference-contexts: This transformation, called serialization, is analogous to the problems of allocation and scheduling in high level synthesis (e.g. [16, 17]), register allocation and code generation in compiler design (e.g <ref> [20] </ref>) and microcode generation (e.g. [21]). [9] gives a formalization of the serialization problem in the current algebraic framework. Unfortunately, it is readily proved that the serialization problem is unsolvable in general [9].
Reference: [21] <author> Mahmood, M., Mavaddat, F., Elmasry, M. I., and Cheng, M. H. M. </author> <title> A formal language model of local microcode synthesis. </title> <booktitle> In Proceedings of The International Workshop on The Applied Formal Method for Correct VLSI Designs (Leuven, </booktitle> <address> Belgium, </address> <year> 1989), </year> <editor> L. Claesen, Ed., </editor> <publisher> Elsevier Science Publishers B.V. </publisher>
Reference-contexts: This transformation, called serialization, is analogous to the problems of allocation and scheduling in high level synthesis (e.g. [16, 17]), register allocation and code generation in compiler design (e.g [20]) and microcode generation (e.g. <ref> [21] </ref>). [9] gives a formalization of the serialization problem in the current algebraic framework. Unfortunately, it is readily proved that the serialization problem is unsolvable in general [9]. Nevertheless, heuristic algorithms have been found to cope with similar problems (such as register allocation or microcode generation).
Reference: [22] <author> Boyer, D. C., and Zhu, Z. </author> <title> Current research of serialization problem in digital design derivation. </title> <type> Tech. rep., </type> <institution> Computer Science Department, Indiana University, </institution> <year> 1990. </year>
Reference-contexts: Unfortunately, it is readily proved that the serialization problem is unsolvable in general [9]. Nevertheless, heuristic algorithms have been found to cope with similar problems (such as register allocation or microcode generation). Although research effort has been made to solve this problem <ref> [22] </ref>, finding suitable heuristics to solve the serialization problem remains a topic in our research. 7 Conclusion This paper presents a formalized approach to hardware design derivation. The basic idea is unifying verification and derivation in a single formal framework.
References-found: 22

