URL: http://www.cs.indiana.edu/database/Exodus/arch_overview.3.0.ps
Refering-URL: http://www.cs.indiana.edu/database/Exodus/Exodus.html
Root-URL: http://www.cs.indiana.edu
Title: EXODUS Storage Manager 1 V3.0 Architecture Overview (Last revision:  
Note: April, 1993)  
Abstract-found: 0
Intro-found: 1
Reference: [Care86] <author> M. Carey, D. DeWitt, J. Richardson, and E. Shekita, </author> <title> Object and File Management in the EXODUS Extensible Database System, </title> <booktitle> Proc. of the 1986 VLDB Conf., </booktitle> <address> Kyoto, Japan, </address> <month> Aug. </month> <year> 1986. </year>
Reference: [Care89] <author> M. Carey, D. DeWitt, E. Shekita, </author> <title> Storage Management for Objects in EXODUS, Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. Lochovsky, eds., </editor> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference: [Chou85] <author> H. Chou and D. Dewitt, </author> <title> An Evaluation of Buffer Management Strategies for Relational Database Systems, </title> <booktitle> Proc. of the 1985 VLDB Conf., </booktitle> <address> Stockholm, Sweden, </address> <month> Aug. </month> <year> 1985. </year>
Reference-contexts: A buffer in the buffer pool holds a single minimum-page-size page. Several (contiguous) buffers may be required to hold a single (non-minimum-page-size) page. 2.4. Buffer Groups The buffer manager provides the concept of a buffer group as proposed in the DBMIN buffer management algorithm <ref> [Chou85] </ref>. A buffer group is a collection of buffers containing fixed and unfixed pages. Each buffer group is constrained in size and has its own replacement policy.
Reference: [Date81] <author> C. Date, </author> <title> An Introduction to Database Systems (3rd edition), </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1981 </year> <month> (pg. 173). </month>
Reference-contexts: Large objects are those that do not fit in a single slotted page. Objects are identified by an OID, which contains a volume ID, a page ID, a slot number, and a unique number. Slotted pages contain meta-data as well as objects: a page header and a slot array <ref> [Date81] </ref> at the end of the page. Each non-empty slot in the array contains the offset of the object from the beginning of the page. This mechanism allows the Storage Manager to move objects on a page without affecting the integrity of data structures that reference objects on that page.
Reference: [Fran92] <author> M. Franklin, M. Zwilling, C.K.Tan, M. Carey, and D. DeWitt, </author> <title> Crash Recovery in Client-Server EXODUS, </title> <booktitle> Proc. of the ACM SIGMOD Int'l. Conf. on Management of Data, </booktitle> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: The LRC can be considered to reflect, in some sense, the state of the page. If two copies of a given page have identical LRCs, the data in the pages are also identical. Details of the Storage Manager's logging and recovery schemes are described in <ref> [Fran92] </ref>. 3.4. Transactions The application can be in one of four transaction processing states (described in [exodSM], Section 4.3.2): INACTIVE (not running a transaction), ACTIVE (running a transaction), ABORTED (the transaction is partially aborted), and PREPARED (the transaction is prepared). <p> A table of the lock convertibility is found in the Appendices of [exodSM]. 4.5. Logging and Recovery The Storage Manager's logging and recovery subsystem is based on the ARIES recovery algorithm [Moha89]. Details on the logging and recovery subsystems can be found in <ref> [Fran92] </ref> and Section 5.2.5 of [exodSM]. Each server has a log volume, which it mounts when it starts. If the log volume is newly formatted, the server initializes the log, otherwise, the server performs recovery. The log is managed as a circular buffer of recent log pages.
Reference: [Gray78] <author> J. N. Gray, </author> <booktitle> Notes on Database Operating Systems, Lecture Notes in Computer Science 60, Advanced course on Operating Systems, </booktitle> <editor> ed. G. Seegmuller, </editor> <publisher> Springer Verlag, </publisher> <address> New York 1978. </address>
Reference-contexts: If that time expires before the lock request is granted, the request is aborted, and the server replies to the client that the lock is busy. This is a simple way to avoid global deadlocks. Access to objects involves the standard hierarchical two-phase locking (2PL) protocol (see <ref> [Gray78] </ref> or [Gray88]). The lock hierarchy contains two granularities: file-level, and page-level. The page that is locked when an object is accessed is the page containing the object header. <p> The page that is locked when an object is accessed is the page containing the object header. There are six lock modes: no lock (NL), share (S), exclusive (X), intent to share (IS), intent to exclusive (IX), share with intent to 11 exclusive (SIX) <ref> [Gray78, Gray88] </ref>. Files can be locked in any of the six modes, while pages are only locked in share and exclusive mode.
Reference: [Gray88] <author> J. Gray, R. Lorie, G. Putzolu, I. Traiger, </author> <title> Granularity of Locks and Degrees of Consistency in a Shared Data Base, Readings in Database Systems, </title> <editor> ed. M. Stonebraker, </editor> <publisher> Morgan Kauf-mann, </publisher> <address> San Mateo, Ca., </address> <year> 1988. </year>
Reference-contexts: If that time expires before the lock request is granted, the request is aborted, and the server replies to the client that the lock is busy. This is a simple way to avoid global deadlocks. Access to objects involves the standard hierarchical two-phase locking (2PL) protocol (see [Gray78] or <ref> [Gray88] </ref>). The lock hierarchy contains two granularities: file-level, and page-level. The page that is locked when an object is accessed is the page containing the object header. <p> The page that is locked when an object is accessed is the page containing the object header. There are six lock modes: no lock (NL), share (S), exclusive (X), intent to share (IS), intent to exclusive (IX), share with intent to 11 exclusive (SIX) <ref> [Gray78, Gray88] </ref>. Files can be locked in any of the six modes, while pages are only locked in share and exclusive mode.
Reference: [Moha83] <author> C. Mohan, B. Lindsay, </author> <title> Efficient Commit Protocols for the Tree of Processes Model of Distributed Transactions, </title> <booktitle> Proc. 2nd ACM SIGACT/SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <address> Montreal, Canada, </address> <month> August, </month> <year> 1983. </year>
Reference-contexts: The coordinating server takes over, and when the fate of the transaction is determined, it informs the client library of the result, and terminates the interaction with other servers. The two-phase commit protocol that is used by the servers is a variant of Presumed Abort (PA) <ref> [Moha83] </ref>. Each server is capable of being a coordinator or a subordinate, or both. The servers communicate over UDP, using the Unix (TM) Sockets interface. When a server crashes and recovers, it uses the same PA protocol to resolve transactions that were prepared under PA before the crash.
Reference: [Moha89] <author> C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh, and P. Schwarz, </author> <title> ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging, </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 17, No 1, </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: A table of the lock compatibilities is found in the Appendices of [exodSM]. A table of the lock convertibility is found in the Appendices of [exodSM]. 4.5. Logging and Recovery The Storage Manager's logging and recovery subsystem is based on the ARIES recovery algorithm <ref> [Moha89] </ref>. Details on the logging and recovery subsystems can be found in [Fran92] and Section 5.2.5 of [exodSM]. Each server has a log volume, which it mounts when it starts. If the log volume is newly formatted, the server initializes the log, otherwise, the server performs recovery. <p> All operations that involve file pages occur on the server. File pages are never sent to clients, for two reasons. First, it eliminates the need for the complex cache consistency system that would be required if multiple clients were manipulating file pages. Second, the file code uses savepoints <ref> [Moha89] </ref>, which are not available to clients, to back out of operations in the event of a failure. More discussion of Storage Manager files can be found in [Care86,89]. 5. CLIENT-SERVER INTERACTIONS 5.1.
Reference: [exodSM] <editor> Using the EXODUS Storage Manager V3.0, </editor> <title> unpublished, included in EXODUS Storage Manager software release. </title> <type> 16 </type>
Reference-contexts: 1. INTRODUCTION This document describes the architecture of Version 3.0 of the EXODUS Storage Manager. It is assumed that the reader is familiar with the Storage Manager's client application interface and server process, which are described in the <ref> [exodSM] </ref>. This document is an adjunct to [exodSM], and the authors have made an effort not to repeat here anything that is contained in [exodSM]. The Storage Manager has a client-server architecture. <p> 1. INTRODUCTION This document describes the architecture of Version 3.0 of the EXODUS Storage Manager. It is assumed that the reader is familiar with the Storage Manager's client application interface and server process, which are described in the <ref> [exodSM] </ref>. This document is an adjunct to [exodSM], and the authors have made an effort not to repeat here anything that is contained in [exodSM]. The Storage Manager has a client-server architecture. Part of the Storage Manager, called the client or the client library, is a library of functions that is linked with the application program. <p> It is assumed that the reader is familiar with the Storage Manager's client application interface and server process, which are described in the <ref> [exodSM] </ref>. This document is an adjunct to [exodSM], and the authors have made an effort not to repeat here anything that is contained in [exodSM]. The Storage Manager has a client-server architecture. Part of the Storage Manager, called the client or the client library, is a library of functions that is linked with the application program. <p> If the two differ, the OID is considered to be invalid. The generation of unique numbers is discussed in the Appendices to <ref> [exodSM] </ref>. 4 Large objects occupy slots on their home pages, and they also occupy one or more large object pages. Large object pages are dedicated to a single object. The data in large objects are stored in pages whose order and location are maintained in a B+ tree. <p> Each time the client library requests a page from a server, it also requests a lock for the page. Locks can be exclusive, or shared, depending on the use the application is making of the data. Details on the Storage Manager's lock management are found in the Appendices to <ref> [exodSM] </ref>. Lock requests are not always granted by a server. If the request would cause a deadlock, the request is denied immediately. <p> If two copies of a given page have identical LRCs, the data in the pages are also identical. Details of the Storage Manager's logging and recovery schemes are described in [Fran92]. 3.4. Transactions The application can be in one of four transaction processing states (described in <ref> [exodSM] </ref>, Section 4.3.2): INACTIVE (not running a transaction), ACTIVE (running a transaction), ABORTED (the transaction is partially aborted), and PREPARED (the transaction is prepared). The client has its notion of the application's transaction state, and each server also has its notion of the same. <p> A table is used to determining whether two lock requests are compatible (eg., when a client holds a lock on a file and another client wants to obtain a lock on it as well). A table of the lock compatibilities is found in the Appendices of <ref> [exodSM] </ref>. A table of the lock convertibility is found in the Appendices of [exodSM]. 4.5. Logging and Recovery The Storage Manager's logging and recovery subsystem is based on the ARIES recovery algorithm [Moha89]. Details on the logging and recovery subsystems can be found in [Fran92] and Section 5.2.5 of [exodSM]. <p> A table of the lock compatibilities is found in the Appendices of <ref> [exodSM] </ref>. A table of the lock convertibility is found in the Appendices of [exodSM]. 4.5. Logging and Recovery The Storage Manager's logging and recovery subsystem is based on the ARIES recovery algorithm [Moha89]. Details on the logging and recovery subsystems can be found in [Fran92] and Section 5.2.5 of [exodSM]. Each server has a log volume, which it mounts when it starts. <p> of <ref> [exodSM] </ref>. A table of the lock convertibility is found in the Appendices of [exodSM]. 4.5. Logging and Recovery The Storage Manager's logging and recovery subsystem is based on the ARIES recovery algorithm [Moha89]. Details on the logging and recovery subsystems can be found in [Fran92] and Section 5.2.5 of [exodSM]. Each server has a log volume, which it mounts when it starts. If the log volume is newly formatted, the server initializes the log, otherwise, the server performs recovery. The log is managed as a circular buffer of recent log pages. <p> The server performing recovery crashed before these transactions were resolved. These transactions are resolved (committed or aborted) by the coordinating server. Second, there are transactions that were prepared by the external two-phase commit functions (see Section 4.11.1 of <ref> [exodSM] </ref>). These transactions, after being recovered, continue to consume resources and must be resolved by a recovery application in a timely fashion. 15
References-found: 10

