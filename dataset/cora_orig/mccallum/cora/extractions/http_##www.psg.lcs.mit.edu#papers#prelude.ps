URL: http://www.psg.lcs.mit.edu/papers/prelude.ps
Refering-URL: http://www.pdos.lcs.mit.edu/~adj/papers.html
Root-URL: 
Title: PRELUDE: A System for Portable Parallel Software  
Author: by William Weihl Eric Brewer Adrian Colbrook Chrysanthos Dellarocas Wilson Hsieh Anthony Joseph Carl Waldspurger Paul Wang 
Keyword: Portability, Performance tuning, Annotations, Computation migration, Data migration.  
Address: Cambridge, Massachusetts 02139  
Affiliation: Massachusetts Institute of Technology Laboratory for Computer Science  
Note: c Massachusetts Institute of Technology  
Date: October 1991  1991  
Abstract: In this paper we describe Prelude, a programming language and accompanying system support for writing portable MIMD parallel programs. Prelude supports a methodology for designing and organizing parallel programs that makes them easier to tune for particular architectures and to port to new architectures. It builds on earlier work on Emerald, Amber, and various Fortran extensions to allow the programmer to divide programs into architecture-dependent and architecture-independent parts, and then to change the architecture-dependent parts to port the program to a new machine or to tune its performance on a single machine. The architecture-dependent parts of a program are specified by annotations that describe the mapping of a program onto a machine. Prelude provides a variety of mapping mechanisms similar to those in other systems, including remote procedure call, object migration, and data replication and partitioning. In addition, Prelude includes novel migration mechanisms for computations based on a form of continuation passing. The implementation of object migration in Prelude uses a novel approach based on fixup blocks that is more efficient than previous approaches, and amortizes the cost of each migration so that the cost per migration drops as the frequency of migrations increases. The current implementation of Prelude is built on top of Proteus, a configurable simulator that provides both fast and accurate simulations of a wide range of MIMD architectures. Proteus itself is a useful tool for developing parallel applications, since it provides powerful non-intrusive debugging and performance monitoring capabilities that are difficult or impossible to obtain on a real machine. Much of the testing, debugging, and initial testing of an application can be accomplished using Proteus, typically with less effort than would be required on a real machine. In addition, Proteus allows the programmer to test the scalability and portability of a program, including on a range of machine sizes and architectures not supported by available machines. We are using Proteus to develop our initial prototype of Prelude, and plan to port the implementation of Prelude to commercial and research multiprocessors in the near future. This work was supported by the National Science Foundation under grant CCR-8716884, by the Defense Advanced Research Projects Agency (DARPA) under Contract N00014-89-J-1988 and by an equipment grant from Digital Equipment Corporation. Individual authors were supported by an Office of Naval Research Graduate Fellowship, a Science and Engineering Research Council Postdoctoral Fellowship, National Science Foundation Graduate Fellowships, an IBM Graduate Fellowship and an AT&T Graduate Fellowship. 
Abstract-found: 1
Intro-found: 1
Reference: [Agh86] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: A Prelude object can be single-threaded or multi-threaded. A multi-threaded object can have multiple active threads performing method invocations on it; a single-threaded object can support only one such thread at a time. Some systems, particularly those based on Actors <ref> [Agh86] </ref>, support only single-threaded objects. <p> Programs written in this kind of "continuation-passing" style can be very efficient on distributed-memory machines. Indeed, many proponents of Actor-based languages advocate programming in this style, in part to reduce the amount of communication required <ref> [Agh86] </ref>. However, such programs are usually complex and hard to understand. In addition, they are less efficient on shared-memory machines than programs that use ordinary procedure calls.
Reference: [BCZ90] <author> J. Bennett, J. Carter, and W. Zwaenepoel. Munin: </author> <title> Distributed shared memory based on type-specific memory coherence. </title> <booktitle> In Proceedings of the ACM Symposium on Principles and Practice of Parallel Programming, </booktitle> <month> March </month> <year> 1990. </year>
Reference-contexts: We can also specify object-object co-location using the move to annotation. If X and Y are objects then move X to Y results in object X being moved to the same processor as object Y. We are currently exploring additional annotations, based on ideas in the Munin system <ref> [BCZ90] </ref> and on directives for data placement in Fortran D [F + 90], to provide control over replication and partitioning of data. <p> We are currently designing and implementing mechanisms and annotations for multiple- and partial-frame migration. In addition, we are studying how to add annotations for data replication and partitioning, based on ideas in Munin <ref> [BCZ90] </ref> and in Fortran D [F + 90]. The implementation of object migration in Prelude uses a novel approach based on fixup blocks. Fixup blocks eliminate the need to check at each migration point whether an object has migrated.
Reference: [BDCW91] <author> E.A. Brewer, C.N. Dellarocas, A. Colbrook, and W.E. Weihl. PROTEUS: </author> <title> A high-performance parallel-architecture simulator. </title> <type> Technical Report MIT/LCS/TR-516, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1991. </year>
Reference-contexts: To facilitate such experiments we have built a retargetable simulator, Proteus <ref> [Del91, Bre91, BDCW91] </ref>, that simulates MIMD architectures and provides support for sophisticated data collection and display. Proteus simulates MIMD multiprocessors in which independent processor nodes are connected via an interconnection medium.
Reference: [Ben87] <author> J.K. Bennett. </author> <title> The design and implementation of Distributed Smalltalk. </title> <booktitle> In Proceedings of the Object-Oriented Programming Systems Languages and Applications Conference, </booktitle> <pages> pages 318-330, </pages> <year> 1987. </year>
Reference-contexts: Annotations specify the architecture-specific implementation details that are usually necessary to achieve efficient execution. Previous projects have proposed particular mechanisms for mapping programs onto multiprocessors (e.g., <ref> [JHB88, CAL + 89, Ben87, Luc87, Li88, PM83, CA89, MG89] </ref>), each of which is appropriate for particular kinds of applications and particular kinds of machines. <p> The argument objects of a remote invocation can also be moved to the site of the invocation by specifying call-by-move parameter passing. Distributed Smalltalk <ref> [Ben87] </ref>, Sloop [Luc87], Ivy [Li88], DEMOS/MP [PM83], Par [CA89] and Comandos [MG89] have migration mechanisms similar to those in Emerald and Amber. In certain situations neither remote procedure call (commonly referred to as function-shipping ) nor object migration (commonly referred to as data-shipping) is sufficient.
Reference: [Bre91] <author> E.A. Brewer. </author> <title> Aspects of a high-performance parallel-architecture simulator. </title> <type> Master's thesis, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1991. </year>
Reference-contexts: To facilitate such experiments we have built a retargetable simulator, Proteus <ref> [Del91, Bre91, BDCW91] </ref>, that simulates MIMD architectures and provides support for sophisticated data collection and display. Proteus simulates MIMD multiprocessors in which independent processor nodes are connected via an interconnection medium.
Reference: [CA89] <author> M.D. Coffin and G.R. Andrews. </author> <title> Towards architecture-independent parallel programming. </title> <type> Technical Report 89-21a, </type> <institution> Department of Computer Science, University of Arizona, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: Annotations specify the architecture-specific implementation details that are usually necessary to achieve efficient execution. Previous projects have proposed particular mechanisms for mapping programs onto multiprocessors (e.g., <ref> [JHB88, CAL + 89, Ben87, Luc87, Li88, PM83, CA89, MG89] </ref>), each of which is appropriate for particular kinds of applications and particular kinds of machines. <p> The argument objects of a remote invocation can also be moved to the site of the invocation by specifying call-by-move parameter passing. Distributed Smalltalk [Ben87], Sloop [Luc87], Ivy [Li88], DEMOS/MP [PM83], Par <ref> [CA89] </ref> and Comandos [MG89] have migration mechanisms similar to those in Emerald and Amber. In certain situations neither remote procedure call (commonly referred to as function-shipping ) nor object migration (commonly referred to as data-shipping) is sufficient.
Reference: [CAL + 89] <author> J.S. Chase, F.G. Amador, E.D. Lazowska, H.M. Levy, and R.J. Littlefield. </author> <title> The Amber system: Parallel programming on a network of multiprocessors. </title> <type> Technical Report 89-04-01, </type> <institution> Department of Computer Science, University of Washington, </institution> <month> April </month> <year> 1989. </year>
Reference-contexts: Annotations specify the architecture-specific implementation details that are usually necessary to achieve efficient execution. Previous projects have proposed particular mechanisms for mapping programs onto multiprocessors (e.g., <ref> [JHB88, CAL + 89, Ben87, Luc87, Li88, PM83, CA89, MG89] </ref>), each of which is appropriate for particular kinds of applications and particular kinds of machines. <p> For some applications, migrating a computation is more effective than moving or replicating the data or accessing it via a series of remote procedure calls. Thus, the design of Prelude includes flexible mechanisms for migrating computations. We also include annotations for specifying scheduling constraints. Emerald [JHB88] and Amber <ref> [CAL + 89] </ref> provide mechanisms for specifying object location (locate object X at node Y), object migration (move object X to node Y) and object-object co-location (attach object X to object Z). <p> Object migration mechanisms fall into two classes: those that depend on location independence of names, and those that translate location-dependent names during migration. Location-independent naming essentially requires a global naming scheme, either through a global address space <ref> [CAL + 89, Li88] </ref> or though higher-level naming mechanisms, which use some form of indirection [PM83, MG89]. On architectures with shared memory, Prelude can exploit the global address space to avoid translation.
Reference: [Del91] <author> C.N. Dellarocas. </author> <title> A high-performance retargetable simulator for parallel architectures. </title> <type> Master's thesis, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1991. </year> <note> REFERENCES 23 </note>
Reference-contexts: To facilitate such experiments we have built a retargetable simulator, Proteus <ref> [Del91, Bre91, BDCW91] </ref>, that simulates MIMD architectures and provides support for sophisticated data collection and display. Proteus simulates MIMD multiprocessors in which independent processor nodes are connected via an interconnection medium.
Reference: [F + 90] <author> G. Fox et al. </author> <title> Fortran D language specification. </title> <type> Technical Report COMP TR90-141, </type> <institution> Rice University, Dept. of Computer Science, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: If X and Y are objects then move X to Y results in object X being moved to the same processor as object Y. We are currently exploring additional annotations, based on ideas in the Munin system [BCZ90] and on directives for data placement in Fortran D <ref> [F + 90] </ref>, to provide control over replication and partitioning of data. <p> We are currently designing and implementing mechanisms and annotations for multiple- and partial-frame migration. In addition, we are studying how to add annotations for data replication and partitioning, based on ideas in Munin [BCZ90] and in Fortran D <ref> [F + 90] </ref>. The implementation of object migration in Prelude uses a novel approach based on fixup blocks. Fixup blocks eliminate the need to check at each migration point whether an object has migrated.
Reference: [For90] <author> Parallel Computing Forum. </author> <title> PCF Fortran Proposed Standard, </title> <note> 1990. Version 3. </note>
Reference-contexts: Prelude supports the following constructs for thread creation (variants of the parfor, parbe-gin and fork constructs have been introduced by other languages including PCF Fortran <ref> [For90] </ref>, BLAZE [MvR87], Occam [Lim84] and SISAL [MSA + 85]): * The parallel parfor construct is syntactically similar to a sequential for loop.
Reference: [Gai86] <author> Jason Gait. </author> <title> A probe effect in concurrent programs. </title> <journal> Software Practice and Experience, </journal> <volume> 16(3) </volume> <pages> 225-233, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: Real multiprocessors generally provide neither of these abilities. Nonintrusive monitoring, combined with repeatability, greatly simplifies the development of concurrent programs. Real multiprocessor systems suffer from the probe effect: the addition of monitoring code may cause the monitored effect to disappear <ref> [Gai86] </ref>. This prevents programmers from collecting additional data for debugging. Proteus allows users to add arbitrary monitoring or debugging code without changing the behavior of the simulation.
Reference: [GG88] <author> David K. Gifford and Nathan Glasser. </author> <title> Remote pipes and procedures for efficient distributed communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(3) </volume> <pages> 258-283, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Previous work by Gifford and Glasser <ref> [GG88] </ref> and in the Mercury system [LBG + 88] has resulted in the design of remote invocation mechanisms for distributed systems in which a sequence of calls between a single sender and a single receiver are run in order, but asynchronously with respect to the caller.
Reference: [GR83] <author> A. Goldberg and D. Robson. Smalltalk80: </author> <title> The language and its implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: First, the migration of arguments to invocations can be controlled via annotations. In an object-oriented system the natural parameter-passing method is call-by-object-reference <ref> [LG86, GR83] </ref>. In a message-passing architecture such semantics can potentially cause additional remote invocations for parameter access. However, Prelude objects are mobile. Therefore, additional remote references can be avoided by moving argument objects to the site of the remote invocation.
Reference: [Hal85] <author> R. Halstead, Jr. </author> <title> Multilisp: A language for concurrent symbolic computation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(4) </volume> <pages> 501-538, </pages> <year> 1985. </year>
Reference-contexts: Prelude denotes unordered asynchronous calls by preceding the invocations with the fork keyword. The invocation returns a promise. The parameterized class promise [T] refers to a promise for an object of type T. Promises [LS88] are similar to futures in MultiLisp <ref> [Hal85] </ref>, except that the value of a promise must be explicitly extracted. (Promises were designed as part of extensions to Argus [LDH + 87] for incorporating asynchronous remote procedure calls, as implemented in the Mercury project [LBG + 88].) A promise is created by an asynchronous call.
Reference: [JHB88] <author> E. Jul, N. Hutchinson, and A. Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <year> 1988. </year>
Reference-contexts: Annotations specify the architecture-specific implementation details that are usually necessary to achieve efficient execution. Previous projects have proposed particular mechanisms for mapping programs onto multiprocessors (e.g., <ref> [JHB88, CAL + 89, Ben87, Luc87, Li88, PM83, CA89, MG89] </ref>), each of which is appropriate for particular kinds of applications and particular kinds of machines. <p> For some applications, migrating a computation is more effective than moving or replicating the data or accessing it via a series of remote procedure calls. Thus, the design of Prelude includes flexible mechanisms for migrating computations. We also include annotations for specifying scheduling constraints. Emerald <ref> [JHB88] </ref> and Amber [CAL + 89] provide mechanisms for specifying object location (locate object X at node Y), object migration (move object X to node Y) and object-object co-location (attach object X to object Z). <p> For example, the invocations of the read lock, read unlock, and child methods could be RPCs. Systems such as Emerald <ref> [JHB88] </ref> allow the programmer to choose between this alternative and fetching the data, i.e., moving the B-tree node object temporarily to the processor executing the B-tree operation (commonly referred to as data-shipping). Neither function-shipping nor data-shipping, however, leads to very good performance. <p> Migration mechanisms are traditionally expensive and usually reduce the performance of threads even when they do not migrate. In Prelude, we follow the philosophy used in Emerald <ref> [JHB88] </ref>: the ability to migrate should have little or no effect on the performance of threads that do not migrate. Object migration mechanisms fall into two classes: those that depend on location independence of names, and those that translate location-dependent names during migration. <p> For architectures without a global address space, Prelude must use either a high-level naming scheme or translate names during migration. We have chosen the latter, since even though translation increases the cost of migration and message-passing, it significantly improves the performance of threads that access local data <ref> [JHB88] </ref>. Translation of addresses in objects is straightforward in Prelude; the translation of addresses in thread stacks is more challenging.
Reference: [LBG + 88] <author> B. Liskov, T. Bloom, D. Gifford, R. Scheifler, and W. Weihl. </author> <title> Communication in the Mercury system. </title> <booktitle> In Proceedings of the 21st Annual Hawaii Conference on System Sciences, </booktitle> <month> January </month> <year> 1988. </year> <note> Available as MIT LCS Programming Methodology Group Memo 59. </note>
Reference-contexts: Promises [LS88] are similar to futures in MultiLisp [Hal85], except that the value of a promise must be explicitly extracted. (Promises were designed as part of extensions to Argus [LDH + 87] for incorporating asynchronous remote procedure calls, as implemented in the Mercury project <ref> [LBG + 88] </ref>.) A promise is created by an asynchronous call. For example, an asynchronous call to a procedure that normally returns a type T returns the type promise [T]. A promise, unlike a future, must be claimed explicitly. <p> Previous work by Gifford and Glasser [GG88] and in the Mercury system <ref> [LBG + 88] </ref> has resulted in the design of remote invocation mechanisms for distributed systems in which a sequence of calls between a single sender and a single receiver are run in order, but asynchronously with respect to the caller.
Reference: [LDH + 87] <author> B. Liskov, M. Day, M. Herlihy, P. Johnson, G. Leavens (editor), R. Scheifler, and W. Weihl. </author> <title> Argus reference manual. </title> <type> Technical Report MIT/LCS/TR-400, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: The invocation returns a promise. The parameterized class promise [T] refers to a promise for an object of type T. Promises [LS88] are similar to futures in MultiLisp [Hal85], except that the value of a promise must be explicitly extracted. (Promises were designed as part of extensions to Argus <ref> [LDH + 87] </ref> for incorporating asynchronous remote procedure calls, as implemented in the Mercury project [LBG + 88].) A promise is created by an asynchronous call. For example, an asynchronous call to a procedure that normally returns a type T returns the type promise [T].
Reference: [LG86] <author> B. Liskov and J. Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: First, the migration of arguments to invocations can be controlled via annotations. In an object-oriented system the natural parameter-passing method is call-by-object-reference <ref> [LG86, GR83] </ref>. In a message-passing architecture such semantics can potentially cause additional remote invocations for parameter access. However, Prelude objects are mobile. Therefore, additional remote references can be avoided by moving argument objects to the site of the remote invocation.
Reference: [Li88] <author> K. Li. Ivy: </author> <title> A shared virtual memory system for parallel computing. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <pages> pages II78-86, </pages> <year> 1988. </year>
Reference-contexts: Annotations specify the architecture-specific implementation details that are usually necessary to achieve efficient execution. Previous projects have proposed particular mechanisms for mapping programs onto multiprocessors (e.g., <ref> [JHB88, CAL + 89, Ben87, Luc87, Li88, PM83, CA89, MG89] </ref>), each of which is appropriate for particular kinds of applications and particular kinds of machines. <p> The argument objects of a remote invocation can also be moved to the site of the invocation by specifying call-by-move parameter passing. Distributed Smalltalk [Ben87], Sloop [Luc87], Ivy <ref> [Li88] </ref>, DEMOS/MP [PM83], Par [CA89] and Comandos [MG89] have migration mechanisms similar to those in Emerald and Amber. In certain situations neither remote procedure call (commonly referred to as function-shipping ) nor object migration (commonly referred to as data-shipping) is sufficient. <p> Object migration mechanisms fall into two classes: those that depend on location independence of names, and those that translate location-dependent names during migration. Location-independent naming essentially requires a global naming scheme, either through a global address space <ref> [CAL + 89, Li88] </ref> or though higher-level naming mechanisms, which use some form of indirection [PM83, MG89]. On architectures with shared memory, Prelude can exploit the global address space to avoid translation.
Reference: [Lim84] <author> INMOS Limited. </author> <title> Occam Programming Manual. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1984. </year>
Reference-contexts: Prelude supports the following constructs for thread creation (variants of the parfor, parbe-gin and fork constructs have been introduced by other languages including PCF Fortran [For90], BLAZE [MvR87], Occam <ref> [Lim84] </ref> and SISAL [MSA + 85]): * The parallel parfor construct is syntactically similar to a sequential for loop.
Reference: [Lin90] <author> M. A. Linton. </author> <title> The evolution of dbx. </title> <booktitle> In Proceedings of the 1990 USENIX Summer Conference, </booktitle> <pages> pages 211-220, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: This extends the power of advanced sequential debuggers to the parallel development arena. Furthermore, Proteus provides an internal debugging mode that allows users to examine the state of threads, processors, locks, and memory. Using a sequential debugger such as dbx <ref> [Lin90] </ref> together with Proteus results in a very effective development environment. 21 While we designed Proteus initially as a substrate for experimenting with prototype language, compiler, and runtime system mechanisms, it has become clear that a simulator such as Proteus can also be a useful tool for developing parallel applications.
Reference: [LS88] <author> B. Liskov and L. Shrira. </author> <title> Promises: Linguistic support for efficient asynchronous procedure calls in distributed systems. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 260-267, </pages> <year> 1988. </year> <note> 24 REFERENCES </note>
Reference-contexts: Prelude denotes unordered asynchronous calls by preceding the invocations with the fork keyword. The invocation returns a promise. The parameterized class promise [T] refers to a promise for an object of type T. Promises <ref> [LS88] </ref> are similar to futures in MultiLisp [Hal85], except that the value of a promise must be explicitly extracted. (Promises were designed as part of extensions to Argus [LDH + 87] for incorporating asynchronous remote procedure calls, as implemented in the Mercury project [LBG + 88].) A promise is created by
Reference: [Luc87] <author> S.E. Lucco. </author> <title> Parallel programming in a virtual object space. </title> <booktitle> In Proceedings of the Object-Oriented Programming Systems Languages and Applications Conference, </booktitle> <pages> pages 26-33, </pages> <year> 1987. </year>
Reference-contexts: Annotations specify the architecture-specific implementation details that are usually necessary to achieve efficient execution. Previous projects have proposed particular mechanisms for mapping programs onto multiprocessors (e.g., <ref> [JHB88, CAL + 89, Ben87, Luc87, Li88, PM83, CA89, MG89] </ref>), each of which is appropriate for particular kinds of applications and particular kinds of machines. <p> The argument objects of a remote invocation can also be moved to the site of the invocation by specifying call-by-move parameter passing. Distributed Smalltalk [Ben87], Sloop <ref> [Luc87] </ref>, Ivy [Li88], DEMOS/MP [PM83], Par [CA89] and Comandos [MG89] have migration mechanisms similar to those in Emerald and Amber. In certain situations neither remote procedure call (commonly referred to as function-shipping ) nor object migration (commonly referred to as data-shipping) is sufficient.
Reference: [LY81] <author> P. L. Lehman and S. B. Yao. </author> <title> Efficient locking for concurrent operations on B-trees. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(4) </volume> <pages> 650-670, </pages> <month> December </month> <year> 1981. </year>
Reference-contexts: The resulting programs can then be mapped onto machines so that the performance of the program is comparable to programs with explicit message-passing constructs. The most efficient concurrent B-tree algorithms known are based on the "link technique," which was introduced by Lehman and Yao <ref> [LY81] </ref>. The underlying data structure in the link technique is similar to a B+-tree (in which the actual data is stored only in the leaves of the tree), with the modification that each B-tree node contains a pointer to its right neighbor in the tree.
Reference: [MG89] <author> J.A. Marques and P. Guedes. </author> <title> Extending the operating system to support an object-oriented environment. </title> <booktitle> In Proceedings of the Object-Oriented Programming Systems Languages and Applications Conference, </booktitle> <pages> pages 113-122, </pages> <year> 1989. </year>
Reference-contexts: Annotations specify the architecture-specific implementation details that are usually necessary to achieve efficient execution. Previous projects have proposed particular mechanisms for mapping programs onto multiprocessors (e.g., <ref> [JHB88, CAL + 89, Ben87, Luc87, Li88, PM83, CA89, MG89] </ref>), each of which is appropriate for particular kinds of applications and particular kinds of machines. <p> The argument objects of a remote invocation can also be moved to the site of the invocation by specifying call-by-move parameter passing. Distributed Smalltalk [Ben87], Sloop [Luc87], Ivy [Li88], DEMOS/MP [PM83], Par [CA89] and Comandos <ref> [MG89] </ref> have migration mechanisms similar to those in Emerald and Amber. In certain situations neither remote procedure call (commonly referred to as function-shipping ) nor object migration (commonly referred to as data-shipping) is sufficient. We provide additional annotations for computation migration, which can be viewed as a form of continuation-passing. <p> Location-independent naming essentially requires a global naming scheme, either through a global address space [CAL + 89, Li88] or though higher-level naming mechanisms, which use some form of indirection <ref> [PM83, MG89] </ref>. On architectures with shared memory, Prelude can exploit the global address space to avoid translation. For architectures without a global address space, Prelude must use either a high-level naming scheme or translate names during migration.
Reference: [MSA + 85] <author> J. McGraw, S. Skedzielewski, S. Allan, R. Oldehoeft, J. Glauert, C. Kirkham, W. Noyce, and R. Thomas. </author> <title> SISAL language reference manual. </title> <type> Technical report, </type> <institution> Lawrence Livermore National Laboratory, </institution> <month> March </month> <year> 1985. </year>
Reference-contexts: Prelude supports the following constructs for thread creation (variants of the parfor, parbe-gin and fork constructs have been introduced by other languages including PCF Fortran [For90], BLAZE [MvR87], Occam [Lim84] and SISAL <ref> [MSA + 85] </ref>): * The parallel parfor construct is syntactically similar to a sequential for loop.
Reference: [MvR87] <author> P. Mehrotra and J. van Rosedale. </author> <title> The BLAZE language: A parallel language for scientific programming. </title> <journal> Parallel Computing, </journal> <volume> 5 </volume> <pages> 339-361, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Prelude supports the following constructs for thread creation (variants of the parfor, parbe-gin and fork constructs have been introduced by other languages including PCF Fortran [For90], BLAZE <ref> [MvR87] </ref>, Occam [Lim84] and SISAL [MSA + 85]): * The parallel parfor construct is syntactically similar to a sequential for loop.
Reference: [PM83] <author> M.L. Powell and B.P. Miller. </author> <title> Process migration in DEMOS/MP. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 110-119, </pages> <year> 1983. </year>
Reference-contexts: Annotations specify the architecture-specific implementation details that are usually necessary to achieve efficient execution. Previous projects have proposed particular mechanisms for mapping programs onto multiprocessors (e.g., <ref> [JHB88, CAL + 89, Ben87, Luc87, Li88, PM83, CA89, MG89] </ref>), each of which is appropriate for particular kinds of applications and particular kinds of machines. <p> The argument objects of a remote invocation can also be moved to the site of the invocation by specifying call-by-move parameter passing. Distributed Smalltalk [Ben87], Sloop [Luc87], Ivy [Li88], DEMOS/MP <ref> [PM83] </ref>, Par [CA89] and Comandos [MG89] have migration mechanisms similar to those in Emerald and Amber. In certain situations neither remote procedure call (commonly referred to as function-shipping ) nor object migration (commonly referred to as data-shipping) is sufficient. <p> Location-independent naming essentially requires a global naming scheme, either through a global address space [CAL + 89, Li88] or though higher-level naming mechanisms, which use some form of indirection <ref> [PM83, MG89] </ref>. On architectures with shared memory, Prelude can exploit the global address space to avoid translation. For architectures without a global address space, Prelude must use either a high-level naming scheme or translate names during migration.
Reference: [Wan91] <author> P. Wang. </author> <title> An in-depth analysis of concurrent B-tree algorithms. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: Wang has extended the Lehman-Yao algorithm so that a process propagating a merge (as well as a split) up the tree locks only one or two nodes at a time <ref> [Wan91, WW90] </ref>.
Reference: [WHH + 92] <author> C. A. Waldspurger, T. Hogg, B. A. Huberman, J. O. Kephart, and S. Stornetta. Spawn: </author> <title> A distributed computational economy. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> February </month> <year> 1992. </year> <note> to appear. </note>
Reference-contexts: Our resource management framework is based on a new abstract priority mechanism that encapsulates resource rights. This is related to earlier work with allocation mechanisms that was motivated by microeconomics <ref> [WHH + 92] </ref>. It is coupled with a stable, scalable, hierarchical propagation mechanism that efficiently disseminates information about resource usage and availability. Together, these mechanisms provide an efficient substrate that supports both load balancing and programs that adaptively vary their granularity based on application loads and machine configurations.
Reference: [WW90] <author> W.E. Weihl and P. Wang. </author> <title> Multi-version memory: Software cache management for concurrent B-trees. </title> <booktitle> In Proceedings of the 2nd IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 650-655, </pages> <year> 1990. </year>
Reference-contexts: Wang has extended the Lehman-Yao algorithm so that a process propagating a merge (as well as a split) up the tree locks only one or two nodes at a time <ref> [Wan91, WW90] </ref>.
References-found: 31

