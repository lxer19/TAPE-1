URL: ftp://ftp.cs.brown.edu/pub/techreports/96/cs96-04.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-96-04.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Abdel-Wahab, H. M., </author> <title> Scheduling with Application to Register Allocation and Deadlock Problems," </title> <institution> University of Waterloo, </institution> <type> PhD Thesis, </type> <year> 1976. </year>
Reference: [2] <author> Abdel-Wahab, H. M. & Kameda, T., </author> <title> Scheduling to Minimize Maximum Cumulative Cost Subject to Series-parallel Precedence Constraints," </title> <note> Operations Research 26 (1978), 141158. </note>
Reference-contexts: The SMMCC problem is NP-complete in general even if the node costs are restricted to 1 [1,5]. Abdel-Wahab and Kameda present an O (n 2 )-time algorithm for the special case where G is a series-parallel graph <ref> [2] </ref> (the time bound was later improved to O (n log n) [3]). As part of this solution, they give an O (n log p)- time algorithm applicable when G is a chain graph, a graph consisting of a union of p disjoint directed paths. <p> The following three sections then prove Theorem 2, Theorem 3, and Theorem 1, respectively. 2 Preliminaries 2.1 Definition and Notation Suppose G is an acyclic graph with node costs. We introduce some terminology having to do with schedules. Much of this terminology is adapted from that in <ref> [2] </ref>. A schedule of G is a sequence of G's nodes which is consistent with the precedence constraints imposed by the arcs of G. A segment of a schedule is a consecutive subsequence. Let H = v 1 v 2 v m be a sequence of nodes. <p> It follows from Lemma 1 that there is always a clustered optimal schedule of G. Two clustered schedules of the graph in Figure 5-(a) are shown in Proof of Lemma 1 The original lemma in <ref> [2] </ref> restricts G to be a chain graph. We can prove as follows that the same properties hold even without the restriction. Suppose H = v 1 v p v d , where v p is a useful peak of H. <p> The schedule in Figure 5-(e) obtained by exchanging those two clustered humps has height one less than that of the schedule in Figure 5-(d). Proof of Lemma 2 The original version of this lemma in <ref> [2] </ref> restricts A; B to be humps G. We can prove as follows that the same property holds even without these restrictions.
Reference: [3] <author> Abdel-Wahab, H. M. & Kameda, T., </author> <title> On Strictly Optimal Schedules for the Cumulative Cost-Optimal Scheduling Problem," </title> <booktitle> Computing 24 (1980), </booktitle> <pages> 6186. </pages>
Reference-contexts: The SMMCC problem is NP-complete in general even if the node costs are restricted to 1 [1,5]. Abdel-Wahab and Kameda present an O (n 2 )-time algorithm for the special case where G is a series-parallel graph [2] (the time bound was later improved to O (n log n) <ref> [3] </ref>). As part of this solution, they give an O (n log p)- time algorithm applicable when G is a chain graph, a graph consisting of a union of p disjoint directed paths.
Reference: [4] <author> Emrath, P. A., Ghosh, S. & Padua, D. A., </author> <title> Event Synchronization Analysis for Debugging Parallel Programs," </title> <booktitle> Supercomputing '89 (November 1989), </booktitle> <pages> 580588. </pages>
Reference: [5] <author> Garey, M. R. & Johnson, D. S., </author> <title> Computers and IntractabilityA Guide to the Theory of NP-Completeness, </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <year> 1979. </year>
Reference-contexts: Theorem 3 is proved. 5 NP-completeness In this section we show that determining whether v ! w for chain graphs of operations on more than one semaphore. The proof is by reduction from the NP-complete uniform-cost SMMCC problem, where the node costs are restricted to 1 <ref> [5] </ref>. The reduction has three steps. Given a SMMCC problem for a uniform-cost graph G 0 of n nodes, we construct O (log n) chain graphs with n + 2 semaphores.
Reference: [6] <author> Helmbold, D. P. & McDowell, C. E., </author> <title> A Class of Synchronization Operations that Permit Efficient Race Detection," </title> <institution> University of California at Santa Cruz Technical Report (January 1993). </institution>
Reference: [7] <author> Helmbold, D. P., McDowell, C. E. & Wang, J-Z., </author> <title> Analyzing Traces with Anonymous Synchronization," </title> <booktitle> International Conference on Parallel Processing (August 1990), </booktitle> <address> II70II77. </address>
Reference: [8] <author> Lu, H-I., Klein, P. N. & Netzer, R. H. B., </author> <title> Detecting Race Conditions in Parallel Programs that Use One Semaphore," </title> <booktitle> Workshop on Algorithms and Data Structures 3 (1993), </booktitle> <pages> 471482. </pages>
Reference-contexts: The compact representation of the relation v precedes w in some valid subschedules can be constructed in O (np log n) time and O (n) space. 1.4 Contribution The previously best race-detection algorithm for one semaphore runs in time O (n 1:5 p) <ref> [8] </ref>. The positive result of this paper improves the time complexity by a factor of W ( p n= log n). Furthermore the race conditions considered in this paper is more general than that in [8], in which the race condition is considered only for valid schedules instead of valid subsched-ules. <p> The previously best race-detection algorithm for one semaphore runs in time O (n 1:5 p) <ref> [8] </ref>. The positive result of this paper improves the time complexity by a factor of W ( p n= log n). Furthermore the race conditions considered in this paper is more general than that in [8], in which the race condition is considered only for valid schedules instead of valid subsched-ules. Specifically, in [8] v could precede w is defined to be the existence of a valid schedule (not subsched-ule) of G in which v precedes w. <p> Furthermore the race conditions considered in this paper is more general than that in <ref> [8] </ref>, in which the race condition is considered only for valid schedules instead of valid subsched-ules. Specifically, in [8] v could precede w is defined to be the existence of a valid schedule (not subsched-ule) of G in which v precedes w. Therefore some race condition defined in this paper is not regarded as a race condition in [8]. <p> Specifically, in <ref> [8] </ref> v could precede w is defined to be the existence of a valid schedule (not subsched-ule) of G in which v precedes w. Therefore some race condition defined in this paper is not regarded as a race condition in [8]. Hence the algorithms in this paper are the first polynomial-time algorithms that detect general race conditions in programs that use semaphores. The negative result of this paper shows that as long as a parallel programs uses more than one semaphore, detecting race condition, special or general, is NP-complete. <p> Thus pred (v) could be ? and succ (v) could be &gt;. For the rest of the section we describe the properties of humps in schedules which will be used later. Most of them are adapted from <ref> [8] </ref>. 2.2 Hump Decomposition As part of their scheduling algorithm for series-parallel graphs, Abdel-Wahab and Kameda show that in linear time a sequence of nodes can be decomposed into a set of humps. The algorithm DECOMP () is shown in Figure 2. <p> The last step shows that the simulating chain graph has a valid schedule if and only if v ! w, for some v and w, in the same chain graph. We will show the same proof works even if the ! is defined for schedule as in <ref> [8] </ref> 5.1 Definition and Notation Let G be a chain graph. Each node of G is an operation on a semaphore. An operation on semaphore S is either +S, incrementing the value of S by one, or S, decrementing the value of S by one. <p> Let w be the last operation of the C n+1 in G 2 . We claim that v ! w if and only if G 2 has a valid schedule. Note that if ! is considered for valid schedules, as in <ref> [8] </ref>, then the claim holds trivially, since v is always the first node in any valid (sub)schedule of G 2 . As for the general !, as defined in this paper, the if part is still straightforward for the same reason.
Reference: [9] <author> Netzer, R. H. B. & Ghosh, S., </author> <title> Efficient Race Condition Detection for Shared-Memory Programs with Post/Wait Synchronization," </title> <booktitle> International Conference on Parallel Processing (August 1992), </booktitle> <address> II242II246. </address>
Reference: [10] <author> Netzer, R. H. B. & Miller, B. P., </author> <title> On the Complexity of Event Ordering for Shared-Memory Parallel Program Executions," </title> <booktitle> International Conference on Parallel Processing (August 1990), II93II97. </booktitle> <pages> 21 </pages>
Reference-contexts: Our algorithms can be used to exactly detect race conditions in executions of such programs. Past work has shown that exactly detecting races in programs that use multiple semaphores is NP-complete <ref> [10] </ref>, and has developed exact algorithms for other cases where the problem is efficiently solvable (programs that use types of synchronization weaker than semaphores) [6,9], and heuristics for the multiple semaphore case [4,7]. The complexity for the case of constant number of semaphores has been an open question.
References-found: 10

