URL: http://www.cs.ucsd.edu/~wgg/Abstracts/starplan.ps.gz
Refering-URL: http://www.cs.ucsd.edu/~wgg/Abstracts/starplan.html
Root-URL: http://www.cs.ucsd.edu
Email: fwgg,jdmg@cs.ucsd.edu  mchen@GDEsystems.com  bowdidge@watson.ibm.com  
Title: Tool Support for Planning the Restructuring of Data Abstractions in Large Systems  
Author: William G. Griswold Morison I. Chen Robert W. Bowdidge J. David Morgenthaler 
Address: La Jolla, CA 92093-0114  16250 Technology Dr. San Diego, CA 92127-1806  P.O. Box 704, Yorktown Heights NY 10598  
Affiliation: Department of Computer Science and Engineering University of California, San Diego  GDE Systems, Inc.  IBM T. J. Watson Research Center  
Abstract: Restructuring software to improve its design can lower software maintenance costs. One problem in carrying out such a restructuring is planning the new detailed design. The star diagram manipulable visualization can help a programmer redesign a program based on abstract data types. However, our measurements revealed that the view can be too large for a programmer to effectively assimilate. Also, design plans can be expressed only by restructuring, although our studies revealed that it is beneficial to preplan a restructuring. Finally, the tool user can build a star diagram for only a single data structure, although an abstract data type might actually have several components or have multiple instantiations. Exploiting basic properties of the star diagram can mitigate these problems. First, programmer-controlled elision can remove clutter from the star diagram view. Second, elision and annotation of star diagram components can mimic restructuring, thereby supporting the planning of a restructuring. Such support also allows for the planning of a non-restructuring maintenance task. Finally, to dynamically control what data structures are visualized, the tool user can union star diagrams. We built a star diagram planning tool for C programs, measured its elision capabilities, and performed a programmer study for the encapsulation of a widely-used data structure in a 28,000 line program. We found that the amount of elision can be substantial, but is not always adequate. In the study we found that each programming team successfully planned their restructuring in rather different, unanticipated ways. 
Abstract-found: 1
Intro-found: 1
Reference: [Adams 80] <author> S. Adams. </author> <title> Pirate's adventure. </title> <journal> Byte, </journal> <volume> 5(12) </volume> <pages> 192-212, </pages> <month> December </month> <year> 1980. </year>
Reference-contexts: the size of star diagrams from large programs. 4 2 A Planning Scenario To provide a more detailed, dynamic perspective of the ideas introduced in the previous section, we present part of a session for planning the restructuring of a dungeon exploration game program written by Scott Adams called saadventure <ref> [Adams 80] </ref>. This version of saadventure is a 1,700 line C program (excluding comments and blank lines), although it was originally written in BASIC. The maintenance task. There is going to be a major enhancement to the rooms data structure, a global array of room descriptions.
Reference: [Ball & Eick 94] <author> T. Ball and S. G. Eick. </author> <title> Visualizing program slices. </title> <booktitle> In Proceedings of the IEEE Symposium on Visual Languages, </booktitle> <pages> pages 288-295, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The color of the pixels represents a value of a metric measured for that line, such as how recently the line was modified, whether a line is associated with a specific modification, or whether a given line is a member of a program slice <ref> [Weiser 84, Ball & Eick 94] </ref>. (Later enhancements to Seesoft condense the view further by displaying one or more measurements per file, rather than per line.) Such visualizations can facilitate the planning of program modifications by highlighting historical or intrinsic structure that otherwise would be invisible.
Reference: [Belady & Lehman 71] <author> L. A. Belady and M. M. Lehman. </author> <title> Programming system dynamics or the metadynamics of systems in maintenance and growth. </title> <institution> Research Report RC3546, IBM, </institution> <year> 1971. </year> <note> Reprinted in M. </note> <editor> M. Lehman, L. A. Belady, editors, </editor> <title> Program Evolution: Processes of Software Change, Ch. </title> <booktitle> 5, APIC Studies in Data Processing No. </booktitle> <volume> 27. </volume> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1985. </year>
Reference-contexts: To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. cost was $30 per line, but the maintenance cost was $4,000 per line [Boehm 75]. Much of these costs can be attributed to degraded software structure <ref> [Belady & Lehman 71] </ref>. One way to lower software maintenance costs is to restructure the system into a more modular form while preserving the original functionality [Griswold 91, Opdyke 92, Griswold & Notkin 93, Johnson & Opdyke 93].
Reference: [Boehm 75] <author> B. W. Boehm. </author> <title> The high cost of software. </title> <editor> In E. Horowitz, editor, </editor> <title> Practical Strategies for Developing Large Software Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1975. </year>
Reference-contexts: To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. cost was $30 per line, but the maintenance cost was $4,000 per line <ref> [Boehm 75] </ref>. Much of these costs can be attributed to degraded software structure [Belady & Lehman 71].
Reference: [Bowdidge & Griswold 94] <author> R. W. Bowdidge and W. G. Griswold. </author> <title> Automated support for encapsulating abstract data types. </title> <booktitle> In ACM SIGSOFT '94 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 97-110, </pages> <month> De-cember </month> <year> 1994. </year>
Reference-contexts: Even with such support, a programmer must keep careful records in order to correctly perform the data encapsulation task. 1.1 The Star Diagram To address these problems we invented the star diagram, a manipulable graphical view of a data structure <ref> [Bowdidge & Griswold 94, Bowdidge 95] </ref>. Figure 1 shows an example of the original star diagram for Scheme programs. The root, at the far left (in this case labeled *line-storage*), represents the variable to be encapsulated.
Reference: [Bowdidge 95] <author> R. W. Bowdidge. </author> <title> Supporting the Restructuring of Data Abstractions through Manipulation of a Program Visualization. </title> <type> PhD dissertation, </type> <institution> University of Califor-nia, San Diego, Department of Computer Science & Engineering, </institution> <month> November </month> <year> 1995. </year> <note> Technical Report CS95-457. </note>
Reference-contexts: Even with such support, a programmer must keep careful records in order to correctly perform the data encapsulation task. 1.1 The Star Diagram To address these problems we invented the star diagram, a manipulable graphical view of a data structure <ref> [Bowdidge & Griswold 94, Bowdidge 95] </ref>. Figure 1 shows an example of the original star diagram for Scheme programs. The root, at the far left (in this case labeled *line-storage*), represents the variable to be encapsulated. <p> been abstracted as a module operation. 1.2 Shortcomings of the Original Star Diagram The star diagram has proven to be useful in planning and carrying out small restructurings, and a detailed study of its usage showed that it can help programmers keep track of key information during the restructuring task <ref> [Bowdidge 95] </ref>. However, a number of problems inhibit its usefulness on larger systems. First, our examination of star diagrams for large C and MUMPS programs revealed that a star diagram for a widely used data structure can be unacceptably large. <p> Such a star diagram is time-consuming to assimilate for a comprehensively planned restructuring. Second, in our study of star diagram usage we found that programmers sometimes created a function and moved it into the module's interface in order to record a tentative design idea <ref> [Bowdidge 95] </ref>. The programmers were aware that the transformation sequence might have to be undone later, but it had the effect of changing the star diagram view (i.e., removing a path and giving it a name) to help recall the design idea. <p> This is readily accommodated in the existing star diagram model, because it is defined as a generic algorithm that is instantiated by supplying implementations for several functions <ref> [Bowdidge 95] </ref>. In addition to these features, the diagram includes improvements such as a navigable grep-like view of the code associated with a node stack and the addition of file nodes to the right side of the star diagram. <p> A similar effect could be achieved by a layout algorithm that allows the programmer to tune node placement to the task at hand. Additionally, programmer-controlled node-stacking criteria could increase node stacking, and hence produce more compact diagrams <ref> [Bowdidge 95, Chen 96] </ref>. 5 Related Work Like many program visualization techniques, the star diagram attempts to graphically highlight relationships of interest for some task while eliding other details.
Reference: [Brothers 89] <author> L. Brothers. </author> <title> omega [A complex, rogue-like game of dungeon exploration], </title> <note> Copyright 1989. Available from: brothers@paul.rutgers.edu. </note>
Reference-contexts: We did not provide source listings in order to force the teams to view the code on the computer screen in view of the video camera. We gave the programmers the source code to a complex, rogue-like dungeon exploration game called omega <ref> [Brothers 89] </ref>. It consists of roughly 28,000 lines of C. To complicate the task slightly, we had modified the program to introduce some parameter passing of the Objects array.
Reference: [Chen 96] <author> M. I. Chen. </author> <title> A tool for planning the restructuring of data abstractions in large systems. </title> <type> Masters Thesis, </type> <institution> University of California, San Diego, Department of Computer Science and Engineering, </institution> <month> February </month> <year> 1996. </year> <note> Technical Report CS96-472. </note>
Reference-contexts: A similar effect could be achieved by a layout algorithm that allows the programmer to tune node placement to the task at hand. Additionally, programmer-controlled node-stacking criteria could increase node stacking, and hence produce more compact diagrams <ref> [Bowdidge 95, Chen 96] </ref>. 5 Related Work Like many program visualization techniques, the star diagram attempts to graphically highlight relationships of interest for some task while eliding other details.
Reference: [Eick et al. 92] <author> S. C. Eick, J. L. Steffen, and J. E. E. Sumner. </author> <title> Seesofta tool for visualizing line-oriented software statistics. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(11) </volume> <pages> 957-68, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: However, hierarchical structure in the visualization can be used to collapse several nodes into a single node to provide more efficient use of space. The Seesoft system <ref> [Eick et al. 92] </ref> supports visualizing a property of each source line of a program (such as age) as a colored graphical line, thus allowing a programmer to identify patterns between lines in multiple files by comparing colors.
Reference: [Flor & Hutchins 91] <author> N. V. Flor and E. L. Hutchins. </author> <title> Analyzing distributed cognition in software teams: A case study of team programming during perfective software maintenance. </title> <editor> In J. Koenemann-Belliveau, T. G. Moher, and S. P. Robertson, editors, </editor> <title> Empirical Studies of Programmers: </title> <booktitle> Fourth Workshop, </booktitle> <pages> pages 36-64. </pages> <publisher> Ablex, </publisher> <address> Norwood, NJ, </address> <year> 1991. </year>
Reference-contexts: [roomNumber].dir [0], rooms [roomNumber].dir [1], rooms [roomNumber].dir [2], rooms [roomNumber].dir [3], rooms [roomNumber].dir [4], rooms [roomNumber].dir [5]); (b) Code view of the fprintf node. 8 9 3.1 Methodology Our study is modeled after Bowdidge's programmer study [Bow-didge 95], which is based on Flor's laboratory studies of organization within programmer teams <ref> [Flor & Hutchins 91, Flor 94] </ref>.
Reference: [Flor 94] <author> N. Flor. </author> <title> Dynamic Organization in Multi-Agent Distributed Cognitive Systems. </title> <type> PhD dissertation, </type> <institution> Cognitive Science Department, University of California, </institution> <address> San Diego, </address> <year> 1994. </year>
Reference-contexts: [roomNumber].dir [0], rooms [roomNumber].dir [1], rooms [roomNumber].dir [2], rooms [roomNumber].dir [3], rooms [roomNumber].dir [4], rooms [roomNumber].dir [5]); (b) Code view of the fprintf node. 8 9 3.1 Methodology Our study is modeled after Bowdidge's programmer study [Bow-didge 95], which is based on Flor's laboratory studies of organization within programmer teams <ref> [Flor & Hutchins 91, Flor 94] </ref>.
Reference: [Griswold & Notkin 93] <author> W. G. Griswold and D. Notkin. </author> <title> Automated assistance for program restructuring. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 2(3) </volume> <pages> 228-269, </pages> <month> July </month> <year> 1993. </year>
Reference: [Griswold 91] <author> W. G. Griswold. </author> <title> Program Restructuring as an Aid to Software Maintenance. </title> <type> PhD dissertation, </type> <institution> University of Washington, Dept. of Computer Science & Engineering, </institution> <month> August </month> <year> 1991. </year> <note> Technical Report No. 91-08-04. </note>
Reference: [Johnson & Opdyke 93] <author> R. E. Johnson and W. F. Opdyke. </author> <title> Refac-toring and Aggregation. </title> <booktitle> In Object Technologies for Advanced Software, volume 742 of Lecture Notes in Computer Science, </booktitle> <pages> pages 264-278. </pages> <booktitle> First JSSST International Symposium, </booktitle> <month> November </month> <year> 1993. </year>
Reference: [Lientz & Swanson 80] <author> B. Lientz and E. Swanson. </author> <title> Software Maintenance Management: A Study of the Maintenance of Computer Application Software in 487 Data Processing Organizations. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1980. </year>
Reference-contexts: 1 Introduction Lientz and Swanson found that software maintenance can account for 70% of a software system's lifetime cost <ref> [Lientz & Swanson 80] </ref>. Boehm documented an Air Force project in which the development fl This work supported in part by NSF Grants CCR-9211002 and CCR-9508745, a Hellman Faculty Fellowship, and UC MICRO grant 96-5449 with Hughes Aircraft.
Reference: [Liskov & Zilles 74] <author> B. Liskov and S. Zilles. </author> <title> Programming with abstract data types. </title> <booktitle> In ACM SIGPLAN Symposium on Very High Level Languages, </booktitle> <pages> pages 50-59, </pages> <month> March </month> <year> 1974. </year> <journal> SIGPLAN Notices 9(4). </journal>
Reference-contexts: By isolating the code pertaining to a changing design decision within a module, enhancements can be applied locally, and hence at lower cost [Parnas 72]. Restructuring in order to achieve data encapsulation <ref> [Parnas 72, Liskov & Zilles 74] </ref> is an important special case. Performing a restructuring to encapsulate a data structure can be difficult when working with only the source code.
Reference: [Miyake 86] <author> N. Miyake. </author> <title> Constructive interaction and the iterative process of understanding. </title> <journal> Cognitive Science, </journal> <volume> 10(2) </volume> <pages> 151-177, </pages> <year> 1986. </year>
Reference-contexts: Their approach of observing a pair of programmers working together, known as constructive interaction <ref> [Miyake 86, Wildman 95] </ref>, is used in our study because it provides a more natural way to induce programmers to verbalize their thoughts than single-person think-aloud methods, and it allows observing how the programmers perform problem solving by studying their dialogue.
Reference: [Muller et al. 92] <author> H. A. Muller, S. R. Tilley, M. A. Orgun, B. D. Corrie, and N. H. Madhavji. </author> <title> A reverse engineering environment based on spatial and visual software interconnection models. </title> <booktitle> In Proceedings of the SIGSOFT '92 Fifth Symposium on Software Development Environments, </booktitle> <month> December </month> <year> 1992. </year>
Reference-contexts: For example, the Rigi reverse engineering environment provides semi-automatic construction of graphical views of a system to assist broad architectural understanding <ref> [Muller et al. 92] </ref>. A view based on entities such as functions, files, classes, or modules is initially constructed by the environment and then augmented by the programmer. The additions allow the programmer to describe the system in terms of abstractions not visible in the implementation.
Reference: [Opdyke 92] <author> W. F. Opdyke. </author> <title> Refactoring: A Program Restructuring Aid in Designing Object-Oriented Applications Frameworks. </title> <type> PhD dissertation, </type> <institution> University of Illinois at Urbana-Champaign, Dept. of Computer Science, </institution> <year> 1992. </year> <note> Technical Report No. 1759. </note>
Reference: [Parnas 72] <author> D. L. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12) </volume> <pages> 1053-1058, </pages> <month> December </month> <year> 1972. </year>
Reference-contexts: By isolating the code pertaining to a changing design decision within a module, enhancements can be applied locally, and hence at lower cost <ref> [Parnas 72] </ref>. Restructuring in order to achieve data encapsulation [Parnas 72, Liskov & Zilles 74] is an important special case. Performing a restructuring to encapsulate a data structure can be difficult when working with only the source code. <p> By isolating the code pertaining to a changing design decision within a module, enhancements can be applied locally, and hence at lower cost [Parnas 72]. Restructuring in order to achieve data encapsulation <ref> [Parnas 72, Liskov & Zilles 74] </ref> is an important special case. Performing a restructuring to encapsulate a data structure can be difficult when working with only the source code.
Reference: [Stallman 93] <author> R. Stallman. </author> <title> GNU Emacs (The extensible self-documenting text editor). Free Software Foundation, </title> <address> Cambridge, MA., </address> <month> November </month> <year> 1993. </year> <note> Available by anonymous ftp at prep.ai.mit.edu/pub/gnu. </note>
Reference-contexts: Consequently, we measured the quantitative impact of elision and trimming for a few complicated data structures in omega (See the previous section) and GNU emacs version 19.28, which contains 82,000 lines of C <ref> [Stallman 93] </ref>. We measured the star diagrams at two levels of elision, each with and without the declarations trimmed. One elision prunes the diagram to a depth that we deemed appropriate for the data structure being encapsulated.
Reference: [Weick 68] <author> K. E. Weick. </author> <title> Systematic observational methods. </title> <editor> In G. Lindzey and E. Aronson, editors, </editor> <booktitle> The Handbook of Social Psychology, </booktitle> <pages> pages 357-451. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1968. </year>
Reference-contexts: However, the reversibility of these operations allows for flexible viewing strategies. 3 User Study To explore the impact of the new planning functionality on the program restructuring task, we conducted a systematic observational study <ref> [Weick 68] </ref> of three programming teams performing a modest encapsulation. 7 (a) Viewing Field:dir from the trimmed node view. fprintf (f, " North:%d South:%d East:%d West:%d Up:%d Down:%d"n", rooms [roomNumber].dir [0], rooms [roomNumber].dir [1], rooms [roomNumber].dir [2], rooms [roomNumber].dir [3], rooms [roomNumber].dir [4], rooms [roomNumber].dir [5]); (b) Code view of the
Reference: [Weiser 84] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: The color of the pixels represents a value of a metric measured for that line, such as how recently the line was modified, whether a line is associated with a specific modification, or whether a given line is a member of a program slice <ref> [Weiser 84, Ball & Eick 94] </ref>. (Later enhancements to Seesoft condense the view further by displaying one or more measurements per file, rather than per line.) Such visualizations can facilitate the planning of program modifications by highlighting historical or intrinsic structure that otherwise would be invisible.
Reference: [Wildman 95] <author> D. Wildman. </author> <title> Getting the most from paired-user testing. </title> <journal> ACM Interactions, </journal> <volume> 2(3) </volume> <pages> 21-27, </pages> <year> 1995. </year> <month> 13 </month>
Reference-contexts: Their approach of observing a pair of programmers working together, known as constructive interaction <ref> [Miyake 86, Wildman 95] </ref>, is used in our study because it provides a more natural way to induce programmers to verbalize their thoughts than single-person think-aloud methods, and it allows observing how the programmers perform problem solving by studying their dialogue.
References-found: 24

