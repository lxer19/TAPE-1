URL: http://www.cs.rice.edu/CS/PLT/Publications/tr96-266.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/packages/mrspidey/
Root-URL: 
Title: Modular and Polymorphic Set-Based Analysis: Theory and Practice  
Author: Cormac Flanagan Matthias Felleisen 
Date: November 1996  
Address: COMP TR96-266  P.O. Box 1892 Houston, TX 77251-1892  
Affiliation: Rice  Department of Computer Science Rice University  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Aho, A., J. Hopcroft and J. Ullman. </author> <title> The Design and Analysis of Computer Modular and Polymorphic Set-Based Analysis: Theory and Practice 49 Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1974. </year>
Reference-contexts: if 8ff 2 Vars (S 1 ): R S 1 ;S 2 [ff L ; ff U ; fhfl L ; fl U i j fl 2 Vars (S 2 )g; ;] alg exist, these algorithms must all be in PSPACE, because the containment problem on NFA's, which is PSPACE-complete <ref> [1] </ref>, can be polynomially reduced to the entailment problem on constraint systems. By using the entailment algorithm in both directions, we can now decide if two constraint systems are observable equivalent.
Reference: [2] <author> Aiken, A., Wimmers, E. L., and Lakshman, T. K. </author> <title> Soft typing with conditional types. </title> <booktitle> In Proceedings of the ACM Sigplan Conference on Principles of Programming Languages (1994), </booktitle> <pages> pp. 163-173. </pages>
Reference-contexts: and, in the course of this development, establish a close connection between this observable equivalence of constraint systems and the equivalence of regular tree grammars (RTGs). 1 Exploiting this connection, we develop a complete al 1 A number of researchers, including Reynolds [18], Jones and Muchnick [14], Heintze [10], Aiken <ref> [2] </ref>, and Cousot and Cousot [3] previously exploited the relationship between RTGs and the least solution of a 2 C. Flanagan, M. Felleisen gorithm for deciding the equivalence of constraint systems. Unfortunately, the problem is PSPACE-hard. Fortunately, a minimized constraint set is only optimal but not necessary for practical purposes. <p> Moreover, these reductions in size result in significant gains in the speed of the analysis. We expect that some of our theoretical and practical results as well as the techniques will carry over to other constraint-based systems, such as the conditional type system of Aiken et al. <ref> [2] </ref>, Eifrig et al.'s object-oriented type system [5], or Pottier's or Smith et al.'s subtyping simplification algorithms [17, 20]. The presentation of our results proceeds as follows. Section 2 describes an idealized source language. Section 3 describes our set-based analysis. <p> Following Aiken et al. and Palsberg and O'Keefe, we formulate this derivation as a subtype system <ref> [2, 16] </ref>. The derivation proceeds in a syntax-directed manner according to the constraint derivation rules presented in figure 2. <p> The rule (app) for applications propagates values from the argument expression into the domain of the applied function and from the range of that function into the result of the application expression. The rule (let ) produces a constraint schema = 8A: (ff; S) for polymorphic, let-bound expressions <ref> [19, 2] </ref>.
Reference: [3] <author> Cousot, P., and Cousot, R. </author> <title> Formal language, grammar, and set-constraint-based program analysis by abstract interpretation. </title> <booktitle> In Proceedings of the 1995 Conference on Functional Programming and Computer Architecture (1995), </booktitle> <pages> pp. 170-181. </pages>
Reference-contexts: this development, establish a close connection between this observable equivalence of constraint systems and the equivalence of regular tree grammars (RTGs). 1 Exploiting this connection, we develop a complete al 1 A number of researchers, including Reynolds [18], Jones and Muchnick [14], Heintze [10], Aiken [2], and Cousot and Cousot <ref> [3] </ref> previously exploited the relationship between RTGs and the least solution of a 2 C. Flanagan, M. Felleisen gorithm for deciding the equivalence of constraint systems. Unfortunately, the problem is PSPACE-hard. Fortunately, a minimized constraint set is only optimal but not necessary for practical purposes. <p> The result provides an approximate set of values for each labeled expression in the program. 3 Cousot and Cousot showed that set-based analysis can alternatively be formulated as an abstract interpretation computed by chaotic iteration <ref> [3] </ref>. 4 C. Flanagan, M.
Reference: [4] <author> Duesterwald, E., Gupta, R., and Soffa, M. L. </author> <title> Reducing the cost of data flow analysis by congruence partitioning. </title> <booktitle> In International Conference on Compiler Construction (April 1994). </booktitle>
Reference-contexts: They present three algorithms for simplifying constraint systems, two of which which are similar to the empty and *-removal algorithms, and the third is a special case of the Hopcroft algorithm. They do not present results on the cost or effectiveness of these algorithms. Duesterwald et al <ref> [4] </ref> describe algorithms for simplifying data flow equations. These algorithms are similar to the *-removal and Hopcroft algorithms. Their approach only preserves the greatest solution of the equation system and assumes that the control flow graph is already known.
Reference: [5] <author> Eifrig, J., Smith, S., and Trifonov, V. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In Conference on Object-Oriented Programming Systems, Languages, and Applications (1995). </booktitle>
Reference-contexts: We expect that some of our theoretical and practical results as well as the techniques will carry over to other constraint-based systems, such as the conditional type system of Aiken et al. [2], Eifrig et al.'s object-oriented type system <ref> [5] </ref>, or Pottier's or Smith et al.'s subtyping simplification algorithms [17, 20]. The presentation of our results proceeds as follows. Section 2 describes an idealized source language. Section 3 describes our set-based analysis. <p> Trifonov and Smith [20] describe a subtyping relation between constrained types, which are similar to our constraint systems, and they present an incomplete decision algorithm for subtyping. They do not discuss constraint simplification. Eifrig, Smith and Trifonov <ref> [5] </ref> discuss constraint simplification in the context of type inference for objects. They present three algorithms for simplifying constraint systems, two of which which are similar to the empty and *-removal algorithms, and the third is a special case of the Hopcroft algorithm.
Reference: [6] <author> F ahndrich, M., and Aiken, A. </author> <title> Making set-constraint based program analyses scale. </title> <type> Technical Report UCB/CSD-96-917, </type> <institution> University of California at Berkeley, </institution> <year> 1996. </year>
Reference-contexts: With the exception of the benchmarks browse, splay and graphs, which do not re-use many functions in a polymorphic fashion, this analysis is a factor of 2 to 4 times faster than the copy analysis, and it is also capable of analyzing larger programs. 8 Competitive Work Fahndrich and Aiken <ref> [6] </ref> examine constraint simplification for an analysis based on a more complex constraint language. They develop a number of heuristic algorithms for constraint simplification, which they test on programs of up to 6000 lines.
Reference: [7] <author> Flanagan, C., and Felleisen, M. </author> <title> Set-based analysis for full Scheme and its use in soft-typing. </title> <type> Technical Report TR95-254, </type> <institution> Rice University, </institution> <year> 1995. </year>
Reference-contexts: It is straightforward to extend the analysis to a realistic language including assignments, recursive data structures, objects and modules along the lines described in an earlier report <ref> [7] </ref>. Expressions in the language are either variables, values, function applications, let-expressions, or labeled expressions. We use labels to identify those program expressions whose values we wish to predict. Values include basic constants and functions. <p> The process iterates until the worklist is empty, at which point S is closed under fi. The complete algorithm can be found in an earlier technical report <ref> [7] </ref>. This closure process propagates all information concerning the possible constants for labeled expressions into constraints of the form c l. Hence, we can infer sba (P ) from fi (S) according to the following theorem.
Reference: [8] <author> Flanagan, C., Flatt, M., Krishnamurthi, S., Weirich, S., and Felleisen, M. </author> <title> Finding bugs in the web of program invariants. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation (1996), </booktitle> <pages> pp. 23-32. </pages>
Reference-contexts: . . 45 B Notations 47 Modular and Polymorphic Set-Based Analysis: Theory and Practice 1 1 The Effectiveness of Set-Based Analysis Rice's Scheme program development environment provides a static debugger, MrSpidey, which statically analyzes a program and, using the results of this analysis, checks the soundness of all primitive operations <ref> [8] </ref>. If an operation may fault due to a violation of its invariant, MrSpidey highlights the program operation so that the programmer can investigate the potential fault site before running the program.
Reference: [9] <author> Flatt, M. </author> <title> MzScheme Reference Manual. </title> <institution> Rice University. </institution>
Reference-contexts: The first three algorithms are linear in the number of non-empty constraints in the system, and Hopcroft is log-linear. We tested the algorithms on the constraint systems for nine program components on a 167MHz Sparc Ultra 1 with 326M of memory, using the MzScheme byte code compiler <ref> [9] </ref>. The results are described in figure 8. The second column gives the number of lines in each program component, and the third column gives the number of constraints in the original (unsimplified) constraint system after closing it under the rules fi.
Reference: [10] <author> Heintze, N. </author> <title> Set-based analysis of ML programs. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1994), </booktitle> <pages> pp. 306-317. </pages>
Reference-contexts: Using the graphical explanation facilities of MrSpidey, the programmer can determine whether this fault will really happen or whether the corresponding correctness proof is beyond the analysis's capabilities. MrSpidey's program analysis is a constraint-based system similar to Heintze's set-based analysis of ML programs <ref> [10] </ref>. The analysis consists of two co-mingled phases: a specification phase, during which MrSpidey derives constraints describing the data flow relationships, and a solution phase, during which MrSpidey solves the constraints. The solution conservatively approximates the set of values that may result from each program expression. <p> observable behavior and, in the course of this development, establish a close connection between this observable equivalence of constraint systems and the equivalence of regular tree grammars (RTGs). 1 Exploiting this connection, we develop a complete al 1 A number of researchers, including Reynolds [18], Jones and Muchnick [14], Heintze <ref> [10] </ref>, Aiken [2], and Cousot and Cousot [3] previously exploited the relationship between RTGs and the least solution of a 2 C. Flanagan, M. Felleisen gorithm for deciding the equivalence of constraint systems. Unfortunately, the problem is PSPACE-hard. <p> Flanagan, M. Felleisen Under the ordering v s , a constraint system has both a maximal solution ( &gt; above) and a minimal solution. The minimal solution exists because the greatest lower bound u s with respect to v s of two solutions is also a solution <ref> [10] </ref>. Lemma 3.3 (Least Solution of Constraint Systems) Every constraint system has a solution that is least with respect to v s . Proof: See Appendix A.2. <p> For its first step, it eliminates all those constraints that have only local relevance, thus producing a small combined constraint system for the entire program. As a result, the analysis tool can solve the combined system more quickly and using less space than traditional set-based analysis <ref> [10] </ref>. Finally, it recreates as much precision as traditional set-based analysis as needed on a per-component basis. The new analysis performs extremely in an interactive setting because it exploits the saved constraint files where possible and thus avoids re-processing many program components unnecessarily. We implemented four variants of this analysis.
Reference: [11] <author> Hindley, R. J., and Seldin, J. P. </author> <title> Introduction to Combinators and -Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference: [12] <author> Hopcroft, J. E. </author> <title> An n log n algorithm for minimizing the states of a finite automaton. </title> <booktitle> The Theory of Machines and Computations (1971), </booktitle> <pages> 189-196. </pages>
Reference-contexts: To this end, we define a valid unifier for S to be an equivalence relation ~ on the set variables of S such that we can merge the set variables Modular and Polymorphic Set-Based Analysis: Theory and Practice 19 1. Use a variant of Hopcroft's algorithm <ref> [12] </ref> to compute an equivalence relation ~ on the set variables of S that satisfies the following conditions: (a) Each set variable in E is in an equivalence class by itself. (b) If [ff fi] 2 S then 8ff ~ ff 0 9fi ~ fi 0 such that [ff 0 fi <p> To produce an equivalence relation satisfying these conditions, we use a variant of Hopcroft's O (n lg n) time algorithm <ref> [12] </ref> for computing an equivalence relation on states in a DFA and then merge set variables according to their equivalence class. 8 5.5 Simplification Benchmarks To test the effectiveness of the simplification algorithms, we extended MrSpidey with the four algorithms that we have just described: empty, unreachable, *-removal , and Hopcroft.
Reference: [13] <author> Jagannathan, S., and Wright, A. K. </author> <title> Effective flow analysis for avoiding run-time checks. </title> <booktitle> In Proc. 2nd International Static Analysis Symposium, LNCS 983 (September 1995), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 207-224. </pages>
Reference-contexts: We tested the analyses using a standard set of benchmarks <ref> [13] </ref>. The results of the test runs are documented in figure 10.
Reference: [14] <author> Jones, N., and Muchnick, S. </author> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages (January 1982), </booktitle> <pages> pp. 66-74. </pages>
Reference-contexts: characterization of observable behavior and, in the course of this development, establish a close connection between this observable equivalence of constraint systems and the equivalence of regular tree grammars (RTGs). 1 Exploiting this connection, we develop a complete al 1 A number of researchers, including Reynolds [18], Jones and Muchnick <ref> [14] </ref>, Heintze [10], Aiken [2], and Cousot and Cousot [3] previously exploited the relationship between RTGs and the least solution of a 2 C. Flanagan, M. Felleisen gorithm for deciding the equivalence of constraint systems. Unfortunately, the problem is PSPACE-hard.
Reference: [15] <author> Palsberg, J. </author> <title> Closure analysis in constraint form. </title> <journal> Transactions on Programming Languages and Systems 17, </journal> <volume> 1 (1995), </volume> <pages> 47-62. </pages> <address> 50 C. </address> <note> Flanagan, M. Felleisen </note>
Reference-contexts: We prove this property using a subject reduction proof, following Wright and Felleisen [21] 7 and Palsberg <ref> [15] </ref>. Main Lemma 3.2 (Soundness) If ; ` P : ff; S and j= S and P 7! fl E [ V l ] then V in const ((l)).
Reference: [16] <author> Palsberg, J., and O'Keefe, P. </author> <title> A type system equivalent to flow analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Principles of Programming Languages (1995), </booktitle> <pages> pp. 367-378. </pages>
Reference-contexts: This set can be formally defined as the set of total functions f : fdom; rngg fl ! P (Const), and the rest of the development can be adapted mutandis mutatis <ref> [16] </ref>. For clarity, we present our results using the more intuitive notation instead. Modular and Polymorphic Set-Based Analysis: Theory and Practice 5 We use the functions const : D ! P (Const) and dom, rng : D ! D to extract the respective components of an element of D. <p> Following Aiken et al. and Palsberg and O'Keefe, we formulate this derivation as a subtype system <ref> [2, 16] </ref>. The derivation proceeds in a syntax-directed manner according to the constraint derivation rules presented in figure 2.
Reference: [17] <author> Pottier, F. </author> <title> Simplifying subtyping constraints. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN International Conference on Functional Programming (1996), </booktitle> <pages> pp. 122-133. </pages>
Reference-contexts: We expect that some of our theoretical and practical results as well as the techniques will carry over to other constraint-based systems, such as the conditional type system of Aiken et al. [2], Eifrig et al.'s object-oriented type system [5], or Pottier's or Smith et al.'s subtyping simplification algorithms <ref> [17, 20] </ref>. The presentation of our results proceeds as follows. Section 2 describes an idealized source language. Section 3 describes our set-based analysis. Section 4 characterizes the relationship between constraint systems and RTGs, and section 5 exploits this connection to derive a number of practical constraint simplification algorithms. <p> Flanagan, M. Felleisen yields a factor of 3 saving in both time and space, but is slow in absolute times compared to other program analyses. Pottier <ref> [17] </ref> studies an ML-style language with subtyping. Performing type inference on this language produces subtype constraints that are similar to our constraints. Pot-tier defines an entailment relation on constraints, and presents an incomplete algorithm for deciding entailment. In addition, he proposes some ad hoc algorithms for simplifying constraints.
Reference: [18] <author> Reynolds, J. </author> <title> Automatic computation of data set defintions. </title> <booktitle> Information Processing'68 (1969), </booktitle> <pages> 456-461. </pages>
Reference-contexts: we provide a complete characterization of observable behavior and, in the course of this development, establish a close connection between this observable equivalence of constraint systems and the equivalence of regular tree grammars (RTGs). 1 Exploiting this connection, we develop a complete al 1 A number of researchers, including Reynolds <ref> [18] </ref>, Jones and Muchnick [14], Heintze [10], Aiken [2], and Cousot and Cousot [3] previously exploited the relationship between RTGs and the least solution of a 2 C. Flanagan, M. Felleisen gorithm for deciding the equivalence of constraint systems. Unfortunately, the problem is PSPACE-hard.
Reference: [19] <author> Tofte, M. </author> <title> Type inference for polymorphic references. </title> <booktitle> Information and Computation 89, </booktitle> <month> 1 (November </month> <year> 1990), </year> <pages> 1-34. </pages>
Reference-contexts: The rule (app) for applications propagates values from the argument expression into the domain of the applied function and from the range of that function into the result of the application expression. The rule (let ) produces a constraint schema = 8A: (ff; S) for polymorphic, let-bound expressions <ref> [19, 2] </ref>.
Reference: [20] <author> Trifonov, V., and Smith, S. </author> <title> Subtyping constrained types. </title> <booktitle> In Third International Static Analysis Symposium (LNCS 1145) (1996), </booktitle> <pages> pp. 349-365. </pages>
Reference-contexts: We expect that some of our theoretical and practical results as well as the techniques will carry over to other constraint-based systems, such as the conditional type system of Aiken et al. [2], Eifrig et al.'s object-oriented type system [5], or Pottier's or Smith et al.'s subtyping simplification algorithms <ref> [17, 20] </ref>. The presentation of our results proceeds as follows. Section 2 describes an idealized source language. Section 3 describes our set-based analysis. Section 4 characterizes the relationship between constraint systems and RTGs, and section 5 exploits this connection to derive a number of practical constraint simplification algorithms. <p> Pot-tier defines an entailment relation on constraints, and presents an incomplete algorithm for deciding entailment. In addition, he proposes some ad hoc algorithms for simplifying constraints. He does not report any results on the cost or effectiveness of these algorithms. Trifonov and Smith <ref> [20] </ref> describe a subtyping relation between constrained types, which are similar to our constraint systems, and they present an incomplete decision algorithm for subtyping. They do not discuss constraint simplification. Eifrig, Smith and Trifonov [5] discuss constraint simplification in the context of type inference for objects.
Reference: [21] <author> Wright, A., and Felleisen, M. </author> <title> A syntactic approach to type soundness. </title> <booktitle> Information and Computation 115, 1 (1994), </booktitle> <pages> 38-94. </pages>
Reference-contexts: We prove this property using a subject reduction proof, following Wright and Felleisen <ref> [21] </ref> 7 and Palsberg [15]. Main Lemma 3.2 (Soundness) If ; ` P : ff; S and j= S and P 7! fl E [ V l ] then V in const ((l)).
Reference: [22] <author> Wright, A. K. </author> <title> Simple imperative polymorphism. </title> <booktitle> Lisp and Symbolic Computation 8, </booktitle> <month> 4 (Dec. </month> <year> 1995), </year> <pages> 343-356. </pages>
Reference-contexts: Values include basic constants and functions. Functions have identifying tags so that MrSpidey can reconstruct a call-graph from the results of the analysis. We use let-expressions to introduce polymorphic bindings, and hence restrict these bindings to syntactic values <ref> [22] </ref>. We work with the usual conventions and terminology of the v -calculus when discussing syntactic issues. In particular, the substitution operation M [x V ] replaces all free occurrences of x within M by V , and fl 0 denotes the set of closed terms, also called programs.
References-found: 22

