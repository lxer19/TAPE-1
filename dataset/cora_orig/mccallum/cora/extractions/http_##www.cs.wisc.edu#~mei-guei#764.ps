URL: http://www.cs.wisc.edu/~mei-guei/764.ps
Refering-URL: http://www.cs.wisc.edu/~mei-guei/menu.html
Root-URL: http://www.cs.wisc.edu
Date: May 12, 1998  
Note: Mei-Guei Shie  
Abstract: Query Optimization in Object Relational Database-A Survey Report 
Abstract-found: 1
Intro-found: 1
Reference: [aGMK93] <author> M. Steinbrunn amd G. Moerkotte and A. Kemper. </author> <title> Optimizing join orders. </title> <type> Technical report, </type> <institution> Universitat Passau Germany, </institution> <year> 1993. </year>
Reference-contexts: Lastly, its solution space is limited to left-deep tree only, which might be unable to find an optimal plan for some cost models. As suggested in <ref> [aGMK93] </ref>, quality ratio of a cost distribution in a plan determines if a left-deep tree is sufficient to search any good results. <p> Several optimal join order algorithms were discussed in <ref> [aGMK93] </ref>. Two major kinds of these approaches are mostly used : one is applying some heuristics step by step based on the criteria of optimal properties, the other is performing a random method to search the best solution with the lowest cost within the limited solution space.
Reference: [CGK89] <author> D. Chimenti, R. Gamboa, and R. Krishnamurthy. </author> <title> Towards an open architecture for ldl. </title> <booktitle> In Proceedings of International VLDB Conference, </booktitle> <pages> pages 195-203, </pages> <year> 1989. </year>
Reference-contexts: Also the "path expressions" used in object base usually are very long and would result in large joins. In order to develop a good cost-based optimization used in ORDB, several studies have been proposed for dealing with those new features in queries. They are: (1) LDL approach <ref> [CGK89] </ref>: it views the expensive predicate as equivalent relations and optimizes by System R technique.
Reference: [CKMP97] <author> J. Claussen, A. Kemper, G. Moerkotte, and K. Peithner. </author> <title> Optimizing queries with universal quantification object-oriented and object-relational databases. </title> <booktitle> In Proceedings of International VLDB Conference, </booktitle> <year> 1997. </year>
Reference-contexts: In object-relational database, these rules would will limit the applicability for optimizing user defined functions whose the underlying property is hard to be formulized into SELECT box. Claussen et. al <ref> [CKMP97] </ref> proposed optimization in queries with universal quantification in Object-Oriented and Object-Relational database. Universal quantifier in a query implies that evaluation needs to iterate over a collection of data that is supported in OO/ORDB as set-valued attribute type.
Reference: [CS96] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Optimization of queries with user-defined predicates. </title> <booktitle> In Proceedings of International VLDB Conference, </booktitle> <year> 1996. </year>
Reference-contexts: This algorithm is easy to build on the conventional System R optimizers and not limited to the left-deep tree. However, the main drawback is that the unpruneable plans might cause exhaustive search space although it claims the complexity is polynomial in general. (5) Dynamic programming with effective pruning <ref> [CS96] </ref>: based on the conventional System R algorithm, this algorithm also presents several pruning rules to produce an optimal plan for expensive predicates. Assumption includes that all user defined expensive predicates are selections and they are commutative with joins.
Reference: [CTY + 92] <author> Hanxiong Chen, Xu Tu, Kazunori Yamaguchi, Hiroyuki Kita-gawa, Nobuo Ohbo, and Yuzuru Fujiwara. </author> <title> Decomposition-an approach for optimizing queries in the presence of foreign functions. </title> <journal> Information Processing Letters, </journal> <volume> 43(6) </volume> <pages> 327-333, </pages> <year> 1992. </year>
Reference-contexts: In this section, some theoretical work would be presented and compared, and the practical implementation in object-relational database is discussed. 4.1 Heuristics of Rearranging Predicates 4.1.1 ADT predicates An earlier study about decomposing expensive predicates in queries mainly focused on the ADT was proposed in <ref> [CTY + 92] </ref>. They defined that ADT selection (F ) is a selection with an ADT predicate f.
Reference: [Hel] <author> Joseph Hellerstein. </author> <title> Optimization techniques for queries with expensive methods. </title> <note> Work funded by NSF and an preliminary release of article accepted by ACM. </note>
Reference-contexts: Searching algorithms is a major concern. (3) Optimal order of evaluating expensive predicates: Place the expensive predicate into the join sequence. That is, the predicate can be freely interleaved whenever they are evaluable. It produces "unconstrained linear join tree" <ref> [Hel94, Hel] </ref> and searches all unpruneable plans in the end. But the optimality depends on the careful estimate of ranks. <p> This is based on rank-ordering stragt-egy [KBZ86]. Although this strategy is quite simple and effective, yet the selection pull-up cannot cross a group of joins to achieve the final optimal result. Thus it is an optimal scheme only for queries with one join and multiple selections. (4) Predicate migration <ref> [Hel94, Hel] </ref>: considers the combination of pull rank scheme and optimization for ill-ordered join nodes. The main procedure is similar to the algorithm in [KBZ86], with the addition ordering for selection ranks besides joins. In each stream of optimization, it has to re-order and merge adjacent ill-ordered groups.
Reference: [Hel94] <author> Joseph Hellerstein. </author> <title> Practical predicate placement. </title> <booktitle> In Proceedings of the ACM-SIGMOD Conference on the Management of Data, </booktitle> <pages> pages 325-335, </pages> <year> 1994. </year> <month> 17 </month>
Reference-contexts: Searching algorithms is a major concern. (3) Optimal order of evaluating expensive predicates: Place the expensive predicate into the join sequence. That is, the predicate can be freely interleaved whenever they are evaluable. It produces "unconstrained linear join tree" <ref> [Hel94, Hel] </ref> and searches all unpruneable plans in the end. But the optimality depends on the careful estimate of ranks. <p> This is based on rank-ordering stragt-egy [KBZ86]. Although this strategy is quite simple and effective, yet the selection pull-up cannot cross a group of joins to achieve the final optimal result. Thus it is an optimal scheme only for queries with one join and multiple selections. (4) Predicate migration <ref> [Hel94, Hel] </ref>: considers the combination of pull rank scheme and optimization for ill-ordered join nodes. The main procedure is similar to the algorithm in [KBZ86], with the addition ordering for selection ranks besides joins. In each stream of optimization, it has to re-order and merge adjacent ill-ordered groups.
Reference: [KBZ86] <author> R. Krishnamurthy, H. Boral, and C. Zanialo. </author> <title> Optimization of nonrecursive queries. </title> <booktitle> In Proceedings of International VLDB Conference, </booktitle> <pages> pages 128-137, </pages> <year> 1986. </year>
Reference-contexts: All of the algorithms above consider linear processing tree only. Here I shortly discuss how the "rank-ordering" promises to yield an optimal solution in the join order problem. Research <ref> [KBZ86] </ref> used "Adjacent Sequence Interchange Property" (ASI) for the cost functions that can be expressed as C (R i ./ R j ) = jR i j g (jR j j). <p> Similarly higher-ranked selection is pulled up from the join's outer stream. This is based on rank-ordering stragt-egy <ref> [KBZ86] </ref>. Although this strategy is quite simple and effective, yet the selection pull-up cannot cross a group of joins to achieve the final optimal result. <p> Thus it is an optimal scheme only for queries with one join and multiple selections. (4) Predicate migration [Hel94, Hel]: considers the combination of pull rank scheme and optimization for ill-ordered join nodes. The main procedure is similar to the algorithm in <ref> [KBZ86] </ref>, with the addition ordering for selection ranks besides joins. In each stream of optimization, it has to re-order and merge adjacent ill-ordered groups. This algorithm is easy to build on the conventional System R optimizers and not limited to the left-deep tree.
Reference: [KMPS94] <author> A. Kemper, G. Moerkotte, K. Peithner, and M. Steinbrunn. </author> <title> Optimizing disjunctive queries with expensive predicates. </title> <booktitle> In Proceedings of the ACM-SIGMOD Conference on the Management of Data, </booktitle> <pages> pages 336-347, </pages> <year> 1994. </year>
Reference-contexts: However, it may result large amounts of sub-plans and fail to evaluate the expensive predicates on both operands of a join prior to taking the join. (2) Changing the optimizer architecture <ref> [KMPS94] </ref>: to facilitate flexibility in object bases, such as blackboard architecture. Searching algorithms is a major concern. (3) Optimal order of evaluating expensive predicates: Place the expensive predicate into the join sequence. That is, the predicate can be freely interleaved whenever they are evaluable. <p> More research then continues to follow the approach of optimizing Boolean expressions while to avoid the weakness found in CNF and DNF methods for disjunctive queries. One of the algorithms is called "bypass processing" <ref> [KMPS94] </ref>. It is a technique for optimizing selection predicates that contain terms whose evaluation costs vary tremendously. Idea is to avoid the evaluation of such expensive terms whenever the outcome of the entire selection predicate can already be "induced" by testing other, less expensive terms.
Reference: [KMS92] <author> A. Kemper, G. Moerkotte, and M. Steinbrunn. </author> <title> Optimizing boolean expressions in object bases. </title> <booktitle> In Proceedings of International VLDB Conference, </booktitle> <year> 1992. </year>
Reference-contexts: DNF approach suffers from non-disjoint streams for duplicate elimination and has the similar problem as (b) in CNF. A evaluation technique for optimizing Boolean expressions <ref> [KMS92] </ref> is developed on the basis of atomic conditions (not restricted to Boolean factors or conjunction terms, which can't distribute conditions across various factors or terms). Using a heuristic for optimizing a sequence of Boolean expressions based on selectivity and cost estimates in the terms of expressions.
Reference: [LMS94] <author> A. Y. Levy, I. S. Mumick, and Y. Sagiv. </author> <title> Query optimization by predicate move-around. </title> <booktitle> In Proceedings of International VLDB Conference, </booktitle> <pages> pages 96-107, </pages> <year> 1994. </year>
Reference-contexts: Efficient if the query is defined in terms of multiple views and sub-queries <ref> [LMS94] </ref>. In this survey, I shall summarize several algorithms used for ORDB optimization. The principle of optimizers in relational systems and its applicability on ORDB will be described in Section 2. Then, the major extension in optimization, namely, placing expensive predicates in optimal order is discussed in Section 3. <p> Second, specification of the ADT predicate given by Database implementers is crucial to determine the efficiency of the algorithm thus the tool to achieve the certain specification is needed. 4.1.2 Moving Query Blocks This algorithm <ref> [LMS94] </ref> developed the idea from "Magic View" methods dealing with complex nested queries, which transforms queries by pushing join predicates across various relations and introducing auxiliary magic relations. <p> The technique is useful for the set-valued attributes introduced in object-relational systems since they would be expressed into the nested queries or sub-queries in SQL. Although some work did not prove the optimality for all cases, as pointed in <ref> [LMS94] </ref>, queries with aggregation cannot be guaranteed to be optimal by rewriting and more constraints need to be included into rules. More significance of rewriting is in application for object database which involves "path expressions" (volume of data is large and logic is more complex).
Reference: [PHH92] <author> H. Pirahesh, J. M. Hellerstein, and Waqar Hasan. </author> <title> Extensible/rule based query optimization in starburst. </title> <booktitle> In Proceedings of the ACM-SIGMOD Conference on the Management of Data, </booktitle> <pages> pages 39-48, </pages> <year> 1992. </year>
Reference-contexts: Depending on the characteristics of queries, opti-mizers refer rules to rewrite queries into optimal expressions. The goal of query rewrite is to produce as declarative queries as possible and to prevent the poorly written SQL from making sub-optimal plan, to perform natural heuristics (such as predicate pushdown). Research in <ref> [PHH92] </ref> extends the above heuristic into the real extensible database system (Starburst). The authors introduced "query graph model" that supports arbitrary table operations, where the inputs and outputs are both tables. Operations include: SELECT, GROUP BY, UNION, INTERSECT, EXCEPT in SQL. <p> The philosophy of rewriting is, whenever possible, query should be converted to a single SELECT operator (SELECT Merge in their terminology). After that we can chose a high-performance algorithms for executing such (single SELECT) queries which have been well understood. Rules presented in <ref> [PHH92] </ref> can be divided into two groups. One group (rule 1-6) is to guarantee that SELECT boxes get merged whenever 14 the only quantifiers over the lower box are F (i.e.
Reference: [SAC + 79] <author> P. G. Selinger, M. Astrahan, D. Chamberlin, R. Lorie, and T. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proceedings of the ACM-SIGMOD Conference on the Management of Data, </booktitle> <pages> pages 22-34, </pages> <year> 1979. </year>
Reference-contexts: Rewriting techniques and implementation are examined in Section 4. Section 5 concludes this survey with summary. 2 Optimization in Relational Databases and Applicability for ORDB Traditional optimization in the relational database was first proposed by the System R algorithm <ref> [SAC + 79] </ref>. Using the access cost formula and selectivities for relations in queries, this algorithm attempts to find an optimal evaluation plan with the minimum cost. Further cost-based algorithms follow the similar scheme for optimizing queries.
Reference: [SI92] <author> A. Swami and B. Iyer. </author> <title> A polynomial time algorithm for optimzing join queries. </title> <type> Technical report, </type> <institution> IBM Almaden Research Center, </institution> <year> 1992. </year>
Reference-contexts: There is also another research done by <ref> [SI92] </ref>, called "AB algorithm", to enhance the requirement used in the rank-ordering algorithm. Additional tests include finding a minimum spanning tree first, changing the order (for a possibly interesting order) and the join method as the rank ordering is being carried out.
Reference: [SKMP95] <author> M. Steinbrunn, A. Kemper, G. Moerkotte, and K. Peithner. </author> <title> By-pasing joins in disjunctive queries. </title> <booktitle> In Proceedings of International VLDB Conference, </booktitle> <year> 1995. </year>
Reference-contexts: Although the quality assessment under a quite large number of queries shows Boolean Difference Calculus Heuristic performs better and steady, yet it cannot handle joins. Work in <ref> [SKMP95] </ref>, further developed the bypass scheme for joins in the query. The algorithm tried to avoid to use an exhaustive search by using partial exploration strategies in the search space of bypass plan and only consideration of semi-join join complement.
Reference: [YKY + 91] <author> K. Yajima, H. Kitagawa, K. Yamaguchi, N. Ohbo, and Y. Fuji-wara. </author> <title> Optimization of queries including adt functions. </title> <booktitle> In Proceeding of International Symposium on Database Systems for Advanced Applications, </booktitle> <pages> pages 336-373, </pages> <year> 1991. </year> <month> 18 </month>
Reference-contexts: Before doing that, cost estimate and selectivity for joins and selections are required to compute the total cost for each predicate. It has a better performance for queries with extremely cheap or expensive predicate, but it might suffer the problem of over-eager pull up overall. (3) Pull rank <ref> [YKY + 91] </ref>: pull up selection only with a higher rank than the join's inner-single stream. Similarly higher-ranked selection is pulled up from the join's outer stream. This is based on rank-ordering stragt-egy [KBZ86].
References-found: 16

