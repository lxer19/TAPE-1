URL: http://wwwcsif.cs.ucdavis.edu/~pandey/ipps.ps
Refering-URL: http://www.cs.ucdavis.edu/~pandey/cyes.html
Root-URL: http://www.cs.ucdavis.edu
Title: Support for Extensibility and Reusability in a Concurrent Object-Oriented Programming Language  
Author: Raju Pandey J.C. Browne 
Address: Davis, CA 95616 Austin, TX 78712  
Affiliation: Computer Science Department Department of Computer Sciences University of California The University of Texas at Austin  
Abstract: In many concurrent programming languages programs are difficult to extend and modify. This is because changes in a concurrent program (either through modification or extension) require re-implementation of some or all components. This paper presents the design of a concurrent object-oriented programming language based upon separate specifications of computations and interactions of programs. Separate specification of computations and interactions allows each to be separately modified and extended. We show that separation also facilitates extension of other language composition mechanisms such as class, inheritance, and template in order to define concurrent program abstractions. The resulting language supports extensibility and modifiability of concurrent programs as well as reusability of specifications of computations and interactions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Gul A Agha. </author> <title> ACTORS: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: For instance, the concept is used in i) rendezvous-based languages such as ADA [7]; ii) approaches based on message passing such as CSP [10]; iii) approaches based on abstract data types (ADT) such as Monitors [9], ADT with path expressions [3]; and iv) actor-based approaches <ref> [1] </ref>. Further, many object-oriented concurrent programming languages have used C++ as the basis for including concurrency and synchronization. Examples of such languages are: CC++ [5], Mentat [8], Charm++ [13],COOL [4], C++ [2], and ACT++ [11].
Reference: [2] <author> Peter A. Buhr and Richard A. Strossbosscher. </author> <title> C++ Annotated Reference Manual. </title> <type> Technical Report Version 3.7, </type> <institution> University of Waterloo, Waterloo, </institution> <address> Ontario, Canada, N2L 3G1, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Further, many object-oriented concurrent programming languages have used C++ as the basis for including concurrency and synchronization. Examples of such languages are: CC++ [5], Mentat [8], Charm++ [13],COOL [4], C++ <ref> [2] </ref>, and ACT++ [11]. <p> Examples of such languages are: CC++ [5], Mentat [8], Charm++ [13],COOL [4], C++ [2], and ACT++ [11]. The different approaches to interaction specification in these languages can be categorized into three: i) languages that use traditional synchronization primitives such as locks and semaphores <ref> [4, 2] </ref>, write-once-read-many variables [5], and data flow based data dependencies [8] for specifying interaction among methods. ii) Languages such as enable-based approaches [17, 22], disable based approaches [6], and behavior abstraction based approaches [12, 23, 14] that use boolean conditions to determine if a method should be executed or delayed.
Reference: [3] <author> R. H. Campbell and A. N. Habermann. </author> <title> The Specification of Process Synchronization by Path Expressions. </title> <booktitle> In Lecture Notes on Computer Sciences, </booktitle> <volume> volume 16, </volume> <pages> pages 89102. </pages> <publisher> Springer Verlag, </publisher> <year> 1974. </year>
Reference-contexts: For instance, the concept is used in i) rendezvous-based languages such as ADA [7]; ii) approaches based on message passing such as CSP [10]; iii) approaches based on abstract data types (ADT) such as Monitors [9], ADT with path expressions <ref> [3] </ref>; and iv) actor-based approaches [1]. Further, many object-oriented concurrent programming languages have used C++ as the basis for including concurrency and synchronization. Examples of such languages are: CC++ [5], Mentat [8], Charm++ [13],COOL [4], C++ [2], and ACT++ [11]. <p> flow based data dependencies [8] for specifying interaction among methods. ii) Languages such as enable-based approaches [17, 22], disable based approaches [6], and behavior abstraction based approaches [12, 23, 14] that use boolean conditions to determine if a method should be executed or delayed. iii) Approaches that use regular expression <ref> [3] </ref> and temporal logic expressions for specifying interaction. Many of the interaction specification mechanisms do not allow one to define abstractions of interaction behaviors that can be reused. Also, event ordering constraint expressions support composition operators for modular development of interactions.
Reference: [4] <author> R. Chandra, A. Gupta, and J. L. Hennessy. </author> <title> COOL: A Language for Parallel Programming. </title> <booktitle> In Languages and Compilers for Parallel Computing Conference, </booktitle> <pages> pages 126147. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Further, many object-oriented concurrent programming languages have used C++ as the basis for including concurrency and synchronization. Examples of such languages are: CC++ [5], Mentat [8], Charm++ [13],COOL <ref> [4] </ref>, C++ [2], and ACT++ [11]. <p> Examples of such languages are: CC++ [5], Mentat [8], Charm++ [13],COOL [4], C++ [2], and ACT++ [11]. The different approaches to interaction specification in these languages can be categorized into three: i) languages that use traditional synchronization primitives such as locks and semaphores <ref> [4, 2] </ref>, write-once-read-many variables [5], and data flow based data dependencies [8] for specifying interaction among methods. ii) Languages such as enable-based approaches [17, 22], disable based approaches [6], and behavior abstraction based approaches [12, 23, 14] that use boolean conditions to determine if a method should be executed or delayed.
Reference: [5] <author> K. Mani Chandy and Carl Kesselman. </author> <title> Compositional C++: Compositional Parallel Programming. </title> <type> Technical Report Caltech-CS-TR-92-13, Cal Tech, </type> <year> 1992. </year>
Reference-contexts: They can be instantiated with user classes to associate the computational and interaction behaviors with user defined abstractions. Such classes support reusability of both computational and interaction behavior specifications. We present an example of a generic concurrent class below: Example 5.1. (Generic sync class). CC++ <ref> [5] </ref> supports the notion of sync synchronization variables. A sync variable is a write-once-read-many variable. All reads to the variable are delayed until the first write has taken place. <p> Further, many object-oriented concurrent programming languages have used C++ as the basis for including concurrency and synchronization. Examples of such languages are: CC++ <ref> [5] </ref>, Mentat [8], Charm++ [13],COOL [4], C++ [2], and ACT++ [11]. The different approaches to interaction specification in these languages can be categorized into three: i) languages that use traditional synchronization primitives such as locks and semaphores [4, 2], write-once-read-many variables [5], and data flow based data dependencies [8] for specifying <p> Examples of such languages are: CC++ <ref> [5] </ref>, Mentat [8], Charm++ [13],COOL [4], C++ [2], and ACT++ [11]. The different approaches to interaction specification in these languages can be categorized into three: i) languages that use traditional synchronization primitives such as locks and semaphores [4, 2], write-once-read-many variables [5], and data flow based data dependencies [8] for specifying interaction among methods. ii) Languages such as enable-based approaches [17, 22], disable based approaches [6], and behavior abstraction based approaches [12, 23, 14] that use boolean conditions to determine if a method should be executed or delayed. iii) Approaches that use
Reference: [6] <author> Svend Frolund. </author> <title> Inheritance of Synchronization Constraints in Concurrent ObjectOriented Programming Languages. </title> <booktitle> In ECOOP '92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 185 196. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: interaction specification in these languages can be categorized into three: i) languages that use traditional synchronization primitives such as locks and semaphores [4, 2], write-once-read-many variables [5], and data flow based data dependencies [8] for specifying interaction among methods. ii) Languages such as enable-based approaches [17, 22], disable based approaches <ref> [6] </ref>, and behavior abstraction based approaches [12, 23, 14] that use boolean conditions to determine if a method should be executed or delayed. iii) Approaches that use regular expression [3] and temporal logic expressions for specifying interaction.
Reference: [7] <author> Narain H. Gehani. </author> <title> Ada: Concurrent Programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1984. </year>
Reference-contexts: For instance, the concept is used in i) rendezvous-based languages such as ADA <ref> [7] </ref>; ii) approaches based on message passing such as CSP [10]; iii) approaches based on abstract data types (ADT) such as Monitors [9], ADT with path expressions [3]; and iv) actor-based approaches [1]. Further, many object-oriented concurrent programming languages have used C++ as the basis for including concurrency and synchronization.
Reference: [8] <author> Andrew S. Grimshaw. </author> <title> Easy-to-Use Object-Oriented Parallel Processing with Mentat. </title> <journal> IEEE Computer, </journal> <volume> 26(6):3951, </volume> <year> 1993. </year>
Reference-contexts: Further, many object-oriented concurrent programming languages have used C++ as the basis for including concurrency and synchronization. Examples of such languages are: CC++ [5], Mentat <ref> [8] </ref>, Charm++ [13],COOL [4], C++ [2], and ACT++ [11]. The different approaches to interaction specification in these languages can be categorized into three: i) languages that use traditional synchronization primitives such as locks and semaphores [4, 2], write-once-read-many variables [5], and data flow based data dependencies [8] for specifying interaction among <p> are: CC++ [5], Mentat <ref> [8] </ref>, Charm++ [13],COOL [4], C++ [2], and ACT++ [11]. The different approaches to interaction specification in these languages can be categorized into three: i) languages that use traditional synchronization primitives such as locks and semaphores [4, 2], write-once-read-many variables [5], and data flow based data dependencies [8] for specifying interaction among methods. ii) Languages such as enable-based approaches [17, 22], disable based approaches [6], and behavior abstraction based approaches [12, 23, 14] that use boolean conditions to determine if a method should be executed or delayed. iii) Approaches that use regular expression [3] and temporal logic expressions
Reference: [9] <author> C. A. R. Hoare. </author> <title> Monitor: An Operating System Structuring Concept. </title> <journal> Communication of the ACM, </journal> <volume> 17(10):549557, </volume> <year> 1974. </year>
Reference-contexts: For instance, the concept is used in i) rendezvous-based languages such as ADA [7]; ii) approaches based on message passing such as CSP [10]; iii) approaches based on abstract data types (ADT) such as Monitors <ref> [9] </ref>, ADT with path expressions [3]; and iv) actor-based approaches [1]. Further, many object-oriented concurrent programming languages have used C++ as the basis for including concurrency and synchronization. Examples of such languages are: CC++ [5], Mentat [8], Charm++ [13],COOL [4], C++ [2], and ACT++ [11].
Reference: [10] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <journal> CACM, </journal> <volume> 21(8):666677, </volume> <year> 1978. </year>
Reference-contexts: For instance, the concept is used in i) rendezvous-based languages such as ADA [7]; ii) approaches based on message passing such as CSP <ref> [10] </ref>; iii) approaches based on abstract data types (ADT) such as Monitors [9], ADT with path expressions [3]; and iv) actor-based approaches [1]. Further, many object-oriented concurrent programming languages have used C++ as the basis for including concurrency and synchronization.
Reference: [11] <author> D. G. Kafura and G. Lavender. </author> <title> Recent Progress in Combining Actor-Based Concurrency with Object-Oriented Programming. </title> <booktitle> In ACM OOPS Messenger, Proceedings OOPSLA/ECOOP 90 workshop on Object-Based Concurrent Systems, </booktitle> <volume> volume 2, </volume> <pages> pages 5558, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Further, many object-oriented concurrent programming languages have used C++ as the basis for including concurrency and synchronization. Examples of such languages are: CC++ [5], Mentat [8], Charm++ [13],COOL [4], C++ [2], and ACT++ <ref> [11] </ref>.
Reference: [12] <author> Dennis Kafura and Keung Lee. </author> <title> Inheritance in Actor based Concurrent Object-Oriented Languages. </title> <booktitle> In Proceedings ECOOP'89, </booktitle> <pages> pages 131145. </pages> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: The second is the ability to make changes in the interaction behaviors of methods. The inheritance anomaly has been studied in great detail and many solutions <ref> [12, 23, 17, 22, 16] </ref> have been proposed. Most of these solutions are based on the separation of synchronization constraints from method implementations.. Changes in interaction behavior of a method is achieved by changing the relevant synchronization constraints. <p> In addition, CYES-C++ supports many mechanisms to allow changes in the interaction behavior of methods. We give an example that illustrates the way in which the state partitioning anomaly can be resolved. The state partitioning anomaly occurs in the behavioral abstraction-based languages <ref> [12, 23, 14] </ref> when additions or modifications of methods in a subclass partition the states of objects of a superclass. <p> be categorized into three: i) languages that use traditional synchronization primitives such as locks and semaphores [4, 2], write-once-read-many variables [5], and data flow based data dependencies [8] for specifying interaction among methods. ii) Languages such as enable-based approaches [17, 22], disable based approaches [6], and behavior abstraction based approaches <ref> [12, 23, 14] </ref> that use boolean conditions to determine if a method should be executed or delayed. iii) Approaches that use regular expression [3] and temporal logic expressions for specifying interaction.
Reference: [13] <author> L.V. Kale and Sanjeev Krishnan. CHARM++: </author> <title> A Portable Concurrent Object-Oriented System Based on C++. </title> <booktitle> In OOPSLA '93, </booktitle> <pages> pages 91108. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference: [14] <author> Satoshi Matsuoka. </author> <title> Language Features for Re-use and Extensibility in Concurrent Object-Oriented Programming. </title> <type> PhD thesis, </type> <institution> The University of Tokyo, </institution> <address> Japan, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: In addition, CYES-C++ supports many mechanisms to allow changes in the interaction behavior of methods. We give an example that illustrates the way in which the state partitioning anomaly can be resolved. The state partitioning anomaly occurs in the behavioral abstraction-based languages <ref> [12, 23, 14] </ref> when additions or modifications of methods in a subclass partition the states of objects of a superclass. <p> be categorized into three: i) languages that use traditional synchronization primitives such as locks and semaphores [4, 2], write-once-read-many variables [5], and data flow based data dependencies [8] for specifying interaction among methods. ii) Languages such as enable-based approaches [17, 22], disable based approaches [6], and behavior abstraction based approaches <ref> [12, 23, 14] </ref> that use boolean conditions to determine if a method should be executed or delayed. iii) Approaches that use regular expression [3] and temporal logic expressions for specifying interaction.
Reference: [15] <author> Satoshi Matsuoka and Akinori Yonezawa. </author> <title> Analysis of Inheritance Anomaly in Object-Oriented Concurrent Programming Languages. </title> <booktitle> In Research Directions in Object-Based Concurrency. </booktitle> <publisher> MIT Press, </publisher> <address> Cam-bridge, </address> <year> 1993. </year>
Reference-contexts: We note that the modifiability and extensibility problems are present in many concurrent object-oriented programming languages as well. For instance, there is a problem with the inheritance of method implementations in concurrent object-oriented programming languages. This problem, termed the inheritance anomaly <ref> [15] </ref>, occurs when implementations of methods of a class cannot be inherited in a subclass due to the differences in synchronization constraints of the class and the subclass. Concurrent classes therefore cannot be extended easily. Similarly, interaction specifications cannot be reused easily. <p> This problem, termed the inheritance anomaly <ref> [15] </ref>, arises due to the differences in synchronization requirements of a class and its subclasses. We illustrate the problem through the following example: Example 4.1. (Inheritance anomaly). Let a concurrent class C define two methods m 1 and m 2 .
Reference: [16] <author> Jose Meseguer. </author> <title> Solving the Inheritance Anomaly in Concurrent Object-Oriented Programming. </title> <booktitle> In Proc. 7th ECOOP'93. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The second is the ability to make changes in the interaction behaviors of methods. The inheritance anomaly has been studied in great detail and many solutions <ref> [12, 23, 17, 22, 16] </ref> have been proposed. Most of these solutions are based on the separation of synchronization constraints from method implementations.. Changes in interaction behavior of a method is achieved by changing the relevant synchronization constraints.
Reference: [17] <author> Christian Neusius. </author> <title> Synchronizing Actions. </title> <booktitle> In ECOOP '91, </booktitle> <pages> pages 118132. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The second is the ability to make changes in the interaction behaviors of methods. The inheritance anomaly has been studied in great detail and many solutions <ref> [12, 23, 17, 22, 16] </ref> have been proposed. Most of these solutions are based on the separation of synchronization constraints from method implementations.. Changes in interaction behavior of a method is achieved by changing the relevant synchronization constraints. <p> The different approaches to interaction specification in these languages can be categorized into three: i) languages that use traditional synchronization primitives such as locks and semaphores [4, 2], write-once-read-many variables [5], and data flow based data dependencies [8] for specifying interaction among methods. ii) Languages such as enable-based approaches <ref> [17, 22] </ref>, disable based approaches [6], and behavior abstraction based approaches [12, 23, 14] that use boolean conditions to determine if a method should be executed or delayed. iii) Approaches that use regular expression [3] and temporal logic expressions for specifying interaction.
Reference: [18] <author> Raju Pandey. </author> <title> A Compositional Approach to Concurrent Programming. </title> <type> PhD thesis, </type> <institution> The University of Texas at Austin, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: We add events of gettwo to the following sets: QEmpty = queue::QEmpty + gettwo:empty () RemQ = queue::RemQ + gettwo The event ordering constraint expressions of queue apply to invocations of gettwo as well. ffi In <ref> [18] </ref>, we show many other instances of inheritance anomalies, and how they are resolved in CYES-C++. 5 Genericity C++ provides the template mechanism for specifying generic classes which capture essential elements of objects or functions. <p> We have done preliminary performance analysis of a number of simple applications (such as the N-Body problem and Gaussian Elimination algorithm). The results show that languages based on separation of concerns can be implemented efficiently. The details of the implementation and the performance analysis can be found in 6 <ref> [18] </ref>. Our current and future effort involves porting the cur-rent implementation to other platforms and extensive per formance analysis of many large applications.
Reference: [19] <author> Raju Pandey and James C. Browne. </author> <title> Event-based Composition of Concurrent Programs. </title> <booktitle> In Workshop on Languages and Compilers for Parallel Computation, Lecture Notes in Computer Science 768. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Changes in either aspect (due to addition or modification of components) may require that the components be re-implemented. Concurrent programs can be modified easily if specifications of computations and interaction are completely separated . We call this approach separation of concerns. <ref> [19] </ref> In this paper, we present the design of an object-oriented concurrent programming, called CYES-C++. CYES-C++ is a concurrent extension of the C++ [21] programming language. The basis for the design of CYES-C++ is derived from the concept of separation of specifications of computation and interaction.
Reference: [20] <author> Raju Pandey and James C. Browne. </author> <title> A Compositional Approach to Concurrent Object-Oriented Programming. </title> <booktitle> In IEEE International Conference on Computer Languages. </booktitle> <publisher> IEEE Press, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: The implementations of m 1 and m 2 , thus, are not inherited in S. ffi The inheritance anomaly arises because specifications of methods contain specifications of both computational and 4 interaction behaviors <ref> [20] </ref>. Since specifications of meth-ods include specifications of both computational and interaction behaviors, any changes in the interaction behavior may, therefore, require changes in the implementation as well.
Reference: [21] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison Wesley, </publisher> <address> Second Edition edition, </address> <year> 1991. </year>
Reference-contexts: Concurrent programs can be modified easily if specifications of computations and interaction are completely separated . We call this approach separation of concerns. [19] In this paper, we present the design of an object-oriented concurrent programming, called CYES-C++. CYES-C++ is a concurrent extension of the C++ <ref> [21] </ref> programming language. The basis for the design of CYES-C++ is derived from the concept of separation of specifications of computation and interaction. The language supports mechanisms for specifying computations and interactions separately.
Reference: [22] <author> Laurent Thomas. </author> <title> Extensibility and Reuse of Object-Oriented Synchronization Components. </title> <booktitle> In Parallel Architecture and Languages Europe, </booktitle> <volume> LNCS 605, </volume> <pages> pages 261275. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The second is the ability to make changes in the interaction behaviors of methods. The inheritance anomaly has been studied in great detail and many solutions <ref> [12, 23, 17, 22, 16] </ref> have been proposed. Most of these solutions are based on the separation of synchronization constraints from method implementations.. Changes in interaction behavior of a method is achieved by changing the relevant synchronization constraints. <p> The different approaches to interaction specification in these languages can be categorized into three: i) languages that use traditional synchronization primitives such as locks and semaphores [4, 2], write-once-read-many variables [5], and data flow based data dependencies [8] for specifying interaction among methods. ii) Languages such as enable-based approaches <ref> [17, 22] </ref>, disable based approaches [6], and behavior abstraction based approaches [12, 23, 14] that use boolean conditions to determine if a method should be executed or delayed. iii) Approaches that use regular expression [3] and temporal logic expressions for specifying interaction.
Reference: [23] <author> Chris Tomlinson and Vineet Singh. </author> <title> Inheritance and Synchronization with Enabled Sets. </title> <booktitle> In OOPSLA '89 Conference on Object-Oriented Programming, </booktitle> <pages> pages 103112. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year> <month> 7 </month>
Reference-contexts: The second is the ability to make changes in the interaction behaviors of methods. The inheritance anomaly has been studied in great detail and many solutions <ref> [12, 23, 17, 22, 16] </ref> have been proposed. Most of these solutions are based on the separation of synchronization constraints from method implementations.. Changes in interaction behavior of a method is achieved by changing the relevant synchronization constraints. <p> In addition, CYES-C++ supports many mechanisms to allow changes in the interaction behavior of methods. We give an example that illustrates the way in which the state partitioning anomaly can be resolved. The state partitioning anomaly occurs in the behavioral abstraction-based languages <ref> [12, 23, 14] </ref> when additions or modifications of methods in a subclass partition the states of objects of a superclass. <p> be categorized into three: i) languages that use traditional synchronization primitives such as locks and semaphores [4, 2], write-once-read-many variables [5], and data flow based data dependencies [8] for specifying interaction among methods. ii) Languages such as enable-based approaches [17, 22], disable based approaches [6], and behavior abstraction based approaches <ref> [12, 23, 14] </ref> that use boolean conditions to determine if a method should be executed or delayed. iii) Approaches that use regular expression [3] and temporal logic expressions for specifying interaction.
References-found: 23

