URL: http://www.eecs.umich.edu/~weeteck/papers/rioPC.ps
Refering-URL: http://www.eecs.umich.edu/~weeteck/pub.html
Root-URL: http://www.eecs.umich.edu
Email: -weeteck,pmchen-@eecs.umich.edu  
Title: The Systematic Improvement of Fault Tolerance in the Rio File Cache 1 The Systematic Improvement
Author: Wee Teck Ng and Peter M. Chen 
Web: http://www.eecs.umich.edu/Rio  
Address: Michigan  
Affiliation: Computer Science and Engineering Division Department of Electrical Engineering and Computer Science University of  
Abstract: Fault injection is typically used to characterize failures and to validate and compare fault-tolerant mechanisms. However, fault injection is rarely used for all these purposes to guide the design and implementation of a fault-tolerant system. We present a systematic and quantitative approach for using software-implemented fault injection to guide the design and implementation of a fault-tolerant system. Our system design goal is to build a write-back file cache on Intel PCs that is as reliable as a write-through file cache. We follow an iterative approach to improve robustness in the presence of operating system errors. In each iteration, we measure the reliability of the system, analyze the fault symptoms that lead to data corruption, and apply fault-tolerant mechanisms that address the fault symptoms. Our initial system is 13 times less reliable than a write-through file cache. The result of several iterations is a design that is both more reliable (1.9% vs. 3.1% corruption rate) and 5-9 times as fast as a write-through file cache. 
Abstract-found: 1
Intro-found: 1
Reference: [Arlat90] <author> Jean Arlat, Martine Aguera, Louis Amat, Yves Crouzet, Jean-Charles Fabre, Jean-Claude Laprie, Eliane Martins, and David Powell. </author> <title> Fault Injection for Dependability Validation: A Methodology and Some Applications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(2):166182, </volume> <month> February </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Software-implemented fault injection (SWIFI) is a common technique in the fault-tolerant community [Iyer95]. Software fault injection can be used for many purposes, such as comparing the robustness of different systems [Siewiorek93, Tsai96, Kropp98], understanding how systems behave during a fault [Chillarege89, Barton90, Kao93], and validating fault-tolerant mechanisms <ref> [Arlat90, Hudak93, Clark95, Rela96, Silva96, Carreira98] </ref>. However, there are very few case studies that use fault injection for all three of these purposes to guide the design and implementation of a fault-tolerant system.
Reference: [Barton90] <author> James H. Barton, Edward W. Czeck, Zary Z. Segall, and Daniel P. Siewiorek. </author> <title> Fault injection experiments using FIAT. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(4):575 582, </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Software-implemented fault injection (SWIFI) is a common technique in the fault-tolerant community [Iyer95]. Software fault injection can be used for many purposes, such as comparing the robustness of different systems [Siewiorek93, Tsai96, Kropp98], understanding how systems behave during a fault <ref> [Chillarege89, Barton90, Kao93] </ref>, and validating fault-tolerant mechanisms [Arlat90, Hudak93, Clark95, Rela96, Silva96, Carreira98]. However, there are very few case studies that use fault injection for all three of these purposes to guide the design and implementation of a fault-tolerant system. <p> Our primary goal in designing these faults is to generate a wide variety of operating system crashes. Our models are derived from studies of commercial operating systems and databases [Sullivan92, Sullivan91, Lee93] and from prior models used in fault-injection studies <ref> [Barton90, Kao93, Kanawati95, Chen96] </ref>. The faults we inject range from low-level hardware faults such as ipping bits in memory to high-level software faults such as memory allocation errors. We concentrate on software faults as studies have shown that software has become the dominant cause of system outages [Gray90]. <p> Note that faults that leave the system running will corrupt data on disk for both write-back and write through file caches, so these runs do not change the relative reliability between file caches. The first category of faults ips random bits in the kernels address space <ref> [Barton90, Kanawati95] </ref>. We target three areas of the kernels address space: the text, heap, and stack. These faults are easy to inject, and they cause a variety of different crashes. They are the least realistic of our bugs, however.
Reference: [Bensoussan72] <author> A. </author> <title> Bensoussan, C.T. Clingen, and R.C. Daley. The Multics Virtual Memory: Concepts and Design. </title> <journal> Communications of the ACM, </journal> <volume> 15(5):308318, </volume> <month> May </month> <year> 1972. </year>
Reference-contexts: Second, FreeBSD normally limits the amount of dirty file cache data to 10% of available system memory. We increase this limit by allowing dirty file data to migrate from the file cache to the virtual memory system, as is done in memory-mapped file systems <ref> [Bensoussan72] </ref>. 4.1 Design Iteration 1: Default FreeBSD Sync 4.1.1 Design We start the design process with the default sync used in FreeBSD. Sync refers to the routine that writes dirty file-cache data to disk during a crash.
Reference: [Carreira98] <author> Joao Carreira, Henrique Madeira, and Joao Gabriel Silva. Xception: </author> <title> A Technique for the Experimental Evaluation of Dependability in Modern Computers. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 24(2):125136, </volume> <month> February </month> <year> 1998. </year>
Reference-contexts: 1 Introduction Software-implemented fault injection (SWIFI) is a common technique in the fault-tolerant community [Iyer95]. Software fault injection can be used for many purposes, such as comparing the robustness of different systems [Siewiorek93, Tsai96, Kropp98], understanding how systems behave during a fault [Chillarege89, Barton90, Kao93], and validating fault-tolerant mechanisms <ref> [Arlat90, Hudak93, Clark95, Rela96, Silva96, Carreira98] </ref>. However, there are very few case studies that use fault injection for all three of these purposes to guide the design and implementation of a fault-tolerant system.
Reference: [Chen96] <author> Peter M. Chen, Wee Teck Ng, Subhachandra Chandra, Christopher M. Aycock, Gu-rushankar Rajamani, and David Lowell. </author> <title> The Rio File Cache: Surviving Operating System Crashes. </title> <booktitle> In Proceedings of the 1996 International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 7483, </pages> <month> October </month> <year> 1996. </year> <title> The Systematic Improvement of Fault Tolerance in the Rio File Cache 17 </title>
Reference-contexts: We call this the Rio file cache (Rio stands for RAM I/O). An earlier study showed how to implement a write-back file cache on Digital Alpha workstations that is as robust against software errors as a write-through file cache <ref> [Chen96] </ref>. The earlier study uses warm reboot, which writes file cache data to disk during reboot. Unfortunately, warm reboot relies on several Alpha-specific hardware features, such as a reset button that does not erase memory. <p> Our primary goal in designing these faults is to generate a wide variety of operating system crashes. Our models are derived from studies of commercial operating systems and databases [Sullivan92, Sullivan91, Lee93] and from prior models used in fault-injection studies <ref> [Barton90, Kao93, Kanawati95, Chen96] </ref>. The faults we inject range from low-level hardware faults such as ipping bits in memory to high-level software faults such as memory allocation errors. We concentrate on software faults as studies have shown that software has become the dominant cause of system outages [Gray90]. <p> Our goal is to make Rio (our write-back file cache) as reliable as a write-through file cache. Write-through file caches are considered very reliable against software crashes because they propagate data immediately to disk, and disks are not easily corrupted by operating system crashes <ref> [Silberschatz94, Tanenbaum95, Chen96] </ref>. We configure FreeBSD to use a write-through file cache, then measure the corruption rate to be 3.1% using the method described in Section 2. <p> Second, safe sync disables interrupts to reduce the likelihood of double faults while writing to disk. In addition to adding the registry and using a new sync routine, we also use the virtual memory system to protect file cache data from wild stores <ref> [Chen96] </ref>. We turn off the write-permission bits in the page table for file cache pages, causing the system to generate protection violations for unauthorized stores. <p> BIOS safe sync may be able to be improved further by adding a hardware reset key and modifying the PC firmware and motherboard to not initialize memory on reset/reboot. This would allow the system to do a complete reset, then to perform a warm reboot as was done in <ref> [Chen96] </ref>. Doing so should fix the remaining hangs before sync and device timeouts, but it would incur significant system cost. 5 Performance Table 7 compares the performance of our reliable write-back file cache (Rio) with different Unix file systems (UFS), each providing different guarantees on when data is made permanent. <p> Portability: We demonstrated our design methodology on FreeBSD running on Intel PCs. We have also tried this approach on a limited scale when implementing a reliable write-back file cache on Digital Alpha workstations <ref> [Chen96] </ref> and the Postgres database [Ng97]. We are confi dent that our approach is portable to other systems. Cost: Our design took four iterations, requiring 8 machine-months of testing. We tackle the dominant fault symptoms in the first iteration, with diminishing returns on successive iterations.
Reference: [Chillarege89] <author> R. Chillarege and N. S. Bowen. </author> <title> Understanding Large System FailureA Fault Injection Experiment. </title> <booktitle> In Proceedings of the 1989 International Symposium on Fault-Tolerant Computing (FTCS), </booktitle> <pages> pages 356363, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Software-implemented fault injection (SWIFI) is a common technique in the fault-tolerant community [Iyer95]. Software fault injection can be used for many purposes, such as comparing the robustness of different systems [Siewiorek93, Tsai96, Kropp98], understanding how systems behave during a fault <ref> [Chillarege89, Barton90, Kao93] </ref>, and validating fault-tolerant mechanisms [Arlat90, Hudak93, Clark95, Rela96, Silva96, Carreira98]. However, there are very few case studies that use fault injection for all three of these purposes to guide the design and implementation of a fault-tolerant system.
Reference: [Clark95] <author> Jeffrey A. Clark and Dhiraj K. Pradhan. </author> <title> Fault Injection: A Method for Validating Computer System Dependability. </title> <journal> IEEE Computer, </journal> <volume> 28(6):4756, </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Software-implemented fault injection (SWIFI) is a common technique in the fault-tolerant community [Iyer95]. Software fault injection can be used for many purposes, such as comparing the robustness of different systems [Siewiorek93, Tsai96, Kropp98], understanding how systems behave during a fault [Chillarege89, Barton90, Kao93], and validating fault-tolerant mechanisms <ref> [Arlat90, Hudak93, Clark95, Rela96, Silva96, Carreira98] </ref>. However, there are very few case studies that use fault injection for all three of these purposes to guide the design and implementation of a fault-tolerant system.
Reference: [Ganger94] <author> Gregory R. Ganger and Yale N. Patt. </author> <title> Metadata Update Performance in File Systems. </title> <booktitle> 1994 Operating Systems Design and Implementation (OSDI), </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: It writes data asynchronously to disk when 64 KB of data has been collected, when the user writes non-sequentially, or when the update daemon ushes dirty file data (once every 30 seconds). UFS writes metadata synchronously to disk to enforce ordering constraints <ref> [Ganger94] </ref>. The write-through file cache writes data and metadata synchronously to disk. The last row shows the performance of the Rio write-back file cache. We run two workloads, cp+rm and Andrew. cp+rm recursively copies then recursively removes the FreeBSD source tree (23 MB). Andrew models a software development workload [Howard88].
Reference: [Gilluwe97] <author> Frank Van Gilluwe. </author> <title> The Undocumented PC: A Programmers Guide to I/O, CPUs, and Fixed Memory Areas. </title> <publisher> Addison-Wesley Developer Press, </publisher> <year> 1997. </year>
Reference-contexts: We remove dependencies on the virtual memory system by switching the processor to use physical addresses [Int97c]. We remove dependencies on the kernel device drivers by using the BIOS interface to the disk <ref> [Gilluwe97] </ref>. BIOS stands for Basic Input/Output Service, and is implemented in the firmware of the I/O controller. Both physical addressing and BIOS routines have limited features and are used normally to load the operating system from disk during system boot. <p> The jump brings the processor to real-mode operation. Part 3: Real-mode setup: BIOS safe sync begins by initializing the remaining segment registers, setting the interrupt controllers to real-mode operation [Int97a], and initializing the video console and disk controller using the BIOS interface <ref> [Gilluwe97] </ref>. The rest of BIOS safe sync is fairly straightforward and is generated from the C version of enhanced safe sync.
Reference: [Gray90] <author> Jim Gray. </author> <title> A Census of Tandem System Availability between 1985 and 1990. </title> <journal> IEEE Transactions on Reliability, </journal> <volume> 39(4), </volume> <month> October </month> <year> 1990. </year>
Reference-contexts: The faults we inject range from low-level hardware faults such as ipping bits in memory to high-level software faults such as memory allocation errors. We concentrate on software faults as studies have shown that software has become the dominant cause of system outages <ref> [Gray90] </ref>. We classify injected faults into three categories: bit ips, low-level software faults, and high-level software faults. Unless otherwise stated, we inject 10 faults for each run to increase the chances that a fault will be triggered. Most crashes occurred within 10 seconds from the time the fault was injected.
Reference: [Howard88] <author> John H. Howard, Michael L. Kazar, Sherri G. Menees, David A. Nichols, M. Satyanarayanan, Robert N. Sidebotham, and Michael J. West. </author> <title> Scale and Performance in a Distributed File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1):5181, </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: The write-through file cache writes data and metadata synchronously to disk. The last row shows the performance of the Rio write-back file cache. We run two workloads, cp+rm and Andrew. cp+rm recursively copies then recursively removes the FreeBSD source tree (23 MB). Andrew models a software development workload <ref> [Howard88] </ref>. All results represent an average of at least 20 runs. Table 7 shows that our Rio file cache prototype is 5-9 times as fast as a write-through file cache. It is also approximately 1.5-2.7 times as fast as the standard Unix file system.
Reference: [Hudak93] <author> John Hudak, Byung-Hoon Suh, Dan Siewiorek, and Zary Segall. </author> <title> Evaluation and Comparison of Fault-Tolerant Software Techniques. </title> <journal> IEEE Transactions on Reliability, </journal> <volume> 42(2), </volume> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Software-implemented fault injection (SWIFI) is a common technique in the fault-tolerant community [Iyer95]. Software fault injection can be used for many purposes, such as comparing the robustness of different systems [Siewiorek93, Tsai96, Kropp98], understanding how systems behave during a fault [Chillarege89, Barton90, Kao93], and validating fault-tolerant mechanisms <ref> [Arlat90, Hudak93, Clark95, Rela96, Silva96, Carreira98] </ref>. However, there are very few case studies that use fault injection for all three of these purposes to guide the design and implementation of a fault-tolerant system.
Reference: [Int97a] <institution> Intel 82371AB PCI ISA IDE Xcelerator (PIIX4) Datasheet. Intel Corporation, </institution> <year> 1997. </year>
Reference-contexts: The jump brings the processor to real-mode operation. Part 3: Real-mode setup: BIOS safe sync begins by initializing the remaining segment registers, setting the interrupt controllers to real-mode operation <ref> [Int97a] </ref>, and initializing the video console and disk controller using the BIOS interface [Gilluwe97]. The rest of BIOS safe sync is fairly straightforward and is generated from the C version of enhanced safe sync.
Reference: [Int97b] <author> Intel Architecture Software Developers Manual: </author> <title> Volume 2: Instruction Set Reference. </title> <publisher> Intel Corporation, </publisher> <year> 1997. </year>
Reference-contexts: We either ip a bit within the addressing-form specifier byte (ModR/M) or the scale, index or base (SIB) byte following the instruction opcode <ref> [Int97b] </ref>. We do not corrupt the stack pointer registers (i.e. esp and ebp registers) as these are used to access local variables instead of as a pointer variable. <p> The rest of BIOS safe sync is fairly straightforward and is generated from the C version of enhanced safe sync. We modify the resulting assembly code by adding address/data overrides <ref> [Int97b] </ref> and using a large data segment (i.e. big real-mode [Shanley96]) to access data beyond the first 1 MB of memory. During sync, we copy the file cache data into the lower 1MB of memory because the BIOS disk interface uses 16-bit segment addressing.
Reference: [Int97c] <author> Intel Architecture Software Developers Manual: </author> <title> Volume 3: System Programming Guide. </title> <publisher> Intel Corporation, </publisher> <year> 1997. </year>
Reference-contexts: It does not write to disk any file cache blocks that are locked, so data in these blocks are lost. Double fault: The Pentium processor calls a double-fault handler if it detects an exception while servicing a prior exception <ref> [Int97c] </ref>. The processor will reset and abandon sync if another exception occurs when the double fault handler is being serviced. File system errors: Our tool may inject faults into any part of the kernel. Faults that are injected into file system routines often cause data corruption. <p> Enhanced safe sync is nearly as reliable as a write-through file cache. Table 5 breaks down the fault symptoms of our current design. There are two basic dependencies remaining in our system. First, all kernel code, including safe sync, runs in virtual-addressing mode with paging enabled <ref> [Int97c] </ref>, which uses virtual addresses to access code and data. Because safe sync accesses virtual addresses, it depends on the FreeBSD virtual memory code and data (such as the doubly linked address map entries [Rashid88]). <p> We remove dependencies on the virtual memory system by switching the processor to use physical addresses <ref> [Int97c] </ref>. We remove dependencies on the kernel device drivers by using the BIOS interface to the disk [Gilluwe97]. BIOS stands for Basic Input/Output Service, and is implemented in the firmware of the I/O controller. <p> Our final design replaces the safe sync code used in design iteration 3. The new safe sync procedure is summarized below (the full source code will be made available at our web site): Part 1: Initial setup: we followed the instructions outlined in Section 8.8.1 of <ref> [Int97c] </ref>, which includes setting up a linearly mapped segments for data and code, setting the global (code/data) and interrupt descriptor table registers for real-mode operation, and making a long jump to the real-mode switch code.
Reference: [Iyer95] <author> Ravishankar K. Iyer. </author> <title> Experimental Evaluation. </title> <booktitle> In Proceedings of the 1995 International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 115132, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Software-implemented fault injection (SWIFI) is a common technique in the fault-tolerant community <ref> [Iyer95] </ref>. Software fault injection can be used for many purposes, such as comparing the robustness of different systems [Siewiorek93, Tsai96, Kropp98], understanding how systems behave during a fault [Chillarege89, Barton90, Kao93], and validating fault-tolerant mechanisms [Arlat90, Hudak93, Clark95, Rela96, Silva96, Carreira98].
Reference: [Johnson89] <author> Barry W. Johnson. </author> <title> Design and Analysis of Fault-Tolerant Digital Systems. </title> <publisher> Addi-son-Wesley Publishing Co., </publisher> <year> 1989. </year>
Reference-contexts: Sync fails if any of the routines or data structures are corrupted. To make sync more robust, we must minimize the scope of the system that it depends on. To minimize data dependencies, we implement informational redundancy <ref> [Johnson89] </ref> by creating a new data structure called the registry. The registry contains all information needed to find, identify, and write all file cache blocks. For each block in the file cache, the registry contains the physical memory address, file ID (device number and inode number), file offset, and size. <p> The dominant reason is that FreeBSD sometimes masks keyboard interrupts. If the system hangs while keyboard interrupts are masked, the reset key will not transfer control to safe sync. To fix this, we add a watchdog timer to the system timer interrupt handler <ref> [Johnson89] </ref>. The system timer interrupt handler watches for pending keyboard interrupts and calls safe sync if the keyboard interrupt does not get serviced for a long time.
Reference: [Kanawati95] <author> Ghani A. Kanawati, Nasser A. Kanawati, and Jacob A. Abraham. FERRARI: </author> <title> A Flexible Software-Based Fault and Error Injection System. IEEE Transactions on The Systematic Improvement of Fault Tolerance in the Rio File Cache 18 Computers, </title> <address> 44(2):248260, </address> <month> February </month> <year> 1995. </year>
Reference-contexts: Our primary goal in designing these faults is to generate a wide variety of operating system crashes. Our models are derived from studies of commercial operating systems and databases [Sullivan92, Sullivan91, Lee93] and from prior models used in fault-injection studies <ref> [Barton90, Kao93, Kanawati95, Chen96] </ref>. The faults we inject range from low-level hardware faults such as ipping bits in memory to high-level software faults such as memory allocation errors. We concentrate on software faults as studies have shown that software has become the dominant cause of system outages [Gray90]. <p> Note that faults that leave the system running will corrupt data on disk for both write-back and write through file caches, so these runs do not change the relative reliability between file caches. The first category of faults ips random bits in the kernels address space <ref> [Barton90, Kanawati95] </ref>. We target three areas of the kernels address space: the text, heap, and stack. These faults are easy to inject, and they cause a variety of different crashes. They are the least realistic of our bugs, however.
Reference: [Kao93] <author> Wei-Lun Kao, Ravishankar K. Iyer, and Dong Tang. </author> <title> FINE: A Fault Injection and Monitoring Environment for Tracing the UNIX System Behavior under Faults. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(11):11051118, </volume> <month> November </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Software-implemented fault injection (SWIFI) is a common technique in the fault-tolerant community [Iyer95]. Software fault injection can be used for many purposes, such as comparing the robustness of different systems [Siewiorek93, Tsai96, Kropp98], understanding how systems behave during a fault <ref> [Chillarege89, Barton90, Kao93] </ref>, and validating fault-tolerant mechanisms [Arlat90, Hudak93, Clark95, Rela96, Silva96, Carreira98]. However, there are very few case studies that use fault injection for all three of these purposes to guide the design and implementation of a fault-tolerant system. <p> Our primary goal in designing these faults is to generate a wide variety of operating system crashes. Our models are derived from studies of commercial operating systems and databases [Sullivan92, Sullivan91, Lee93] and from prior models used in fault-injection studies <ref> [Barton90, Kao93, Kanawati95, Chen96] </ref>. The faults we inject range from low-level hardware faults such as ipping bits in memory to high-level software faults such as memory allocation errors. We concentrate on software faults as studies have shown that software has become the dominant cause of system outages [Gray90]. <p> The second category of fault changes individual instructions in the kernel text segment. These faults are intended to approximate the assembly-level manifestation of real C-level programming errors <ref> [Kao93] </ref>. We corrupt assignment statements by changing the source or destination register. We corrupt conditional constructs by deleting branches. We also delete random instructions (both branch and non-branch). The last and most extensive category of faults imitate specific programming errors in the operating system [Sullivan91]. <p> The last and most extensive category of faults imitate specific programming errors in the operating system [Sullivan91]. These are targeted more at specific programming errors than the previous fault category. We inject an initialization fault by deleting instructions responsible for initializing a variable at the start of a procedure <ref> [Kao93, Lee93] </ref>. We inject pointer corruption by corrupting the addressing bytes of instructions which access operands in memory [Sullivan91, The Systematic Improvement of Fault Tolerance in the Rio File Cache 4 Lee93].
Reference: [Kropp98] <author> Nathan P. Kropp, Philip J. Koopman, and Daniel P. Siewiorek. </author> <title> Automated Robustness Testing of Off-the_shelf Software Components. </title> <booktitle> In Proceedings of the 1998 Symposium on Fault-Tolerant Computing (FTCS), </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: 1 Introduction Software-implemented fault injection (SWIFI) is a common technique in the fault-tolerant community [Iyer95]. Software fault injection can be used for many purposes, such as comparing the robustness of different systems <ref> [Siewiorek93, Tsai96, Kropp98] </ref>, understanding how systems behave during a fault [Chillarege89, Barton90, Kao93], and validating fault-tolerant mechanisms [Arlat90, Hudak93, Clark95, Rela96, Silva96, Carreira98]. However, there are very few case studies that use fault injection for all three of these purposes to guide the design and implementation of a fault-tolerant system.
Reference: [Lee93] <author> Inhwan Lee and Ravishankar K. Iyer. </author> <title> Faults, Symptoms, and Software Fault Tolerance in the Tandem GUARDIAN Operating System. </title> <booktitle> In Proceedings of the 1993 International Symposium on Fault-Tolerant Computing (FTCS), pages 2029, </booktitle> <year> 1993. </year>
Reference-contexts: Our primary goal in designing these faults is to generate a wide variety of operating system crashes. Our models are derived from studies of commercial operating systems and databases <ref> [Sullivan92, Sullivan91, Lee93] </ref> and from prior models used in fault-injection studies [Barton90, Kao93, Kanawati95, Chen96]. The faults we inject range from low-level hardware faults such as ipping bits in memory to high-level software faults such as memory allocation errors. <p> The last and most extensive category of faults imitate specific programming errors in the operating system [Sullivan91]. These are targeted more at specific programming errors than the previous fault category. We inject an initialization fault by deleting instructions responsible for initializing a variable at the start of a procedure <ref> [Kao93, Lee93] </ref>. We inject pointer corruption by corrupting the addressing bytes of instructions which access operands in memory [Sullivan91, The Systematic Improvement of Fault Tolerance in the Rio File Cache 4 Lee93].
Reference: [McKusick96] <author> Marshall Kirk McKusick, Keith Bostic, Michael J. Karels, and John S. Quarterman. </author> <title> The Design and Implementation of the 4.4BSD Operating System. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1996. </year>
Reference-contexts: We find that several design iterations are needed to reach our reliability goal, because the first itera tion may introduce new bugs, or may leave secondary vulnerabilities hidden. 2 Experimental Environment and Mechanisms Our experiments are performed on PCs running the FreeBSD 2.2.7 operating system <ref> [McKusick96] </ref>. Each PC has an Intel Pentium processor, 128 MB of memory, a 2 GB IDE hard drive, and the Phoenix 4.0 BIOS.
Reference: [Ng97] <author> Wee Teck Ng and Peter M. Chen. </author> <title> Integrating Reliable Memory in Databases. </title> <booktitle> In Proceedings of the 1997 International Conference on Very Large Data Bases (VLDB), </booktitle> <pages> pages 7685, </pages> <month> August </month> <year> 1997. </year>
Reference-contexts: Portability: We demonstrated our design methodology on FreeBSD running on Intel PCs. We have also tried this approach on a limited scale when implementing a reliable write-back file cache on Digital Alpha workstations [Chen96] and the Postgres database <ref> [Ng97] </ref>. We are confi dent that our approach is portable to other systems. Cost: Our design took four iterations, requiring 8 machine-months of testing. We tackle the dominant fault symptoms in the first iteration, with diminishing returns on successive iterations.
Reference: [Rashid88] <author> Richard F. Rashid, Jr. Avadis Tevanian, Michael Young, David Golub, Robert Baron, David Black, Jr. William J. Bolosky, and Jonathan Chew. </author> <title> Machine-Independent Virtual Memory Management for Paged Uniprocessor and Multiprocessor Architectures. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(8):896908, </volume> <month> August </month> <year> 1988. </year>
Reference-contexts: First, all kernel code, including safe sync, runs in virtual-addressing mode with paging enabled [Int97c], which uses virtual addresses to access code and data. Because safe sync accesses virtual addresses, it depends on the FreeBSD virtual memory code and data (such as the doubly linked address map entries <ref> [Rashid88] </ref>). To fix this dependency, we must configure the processor to use physical addresses during safe sync. Second, safe sync uses the low-level kernel device drivers to write data to disk.
Reference: [Rela96] <author> Mario Zenha Rela, Henrique Madeira, and Joao G. Silva. </author> <title> Experimental Evaluation of the Fail-Silent Behavior in Programs with Consistency Checks. </title> <booktitle> In Proceedings of the 1996 Symposium on Fault-Tolerant Computing (FTCS), </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Software-implemented fault injection (SWIFI) is a common technique in the fault-tolerant community [Iyer95]. Software fault injection can be used for many purposes, such as comparing the robustness of different systems [Siewiorek93, Tsai96, Kropp98], understanding how systems behave during a fault [Chillarege89, Barton90, Kao93], and validating fault-tolerant mechanisms <ref> [Arlat90, Hudak93, Clark95, Rela96, Silva96, Carreira98] </ref>. However, there are very few case studies that use fault injection for all three of these purposes to guide the design and implementation of a fault-tolerant system.
Reference: [Shanley96] <author> Tom Shanley. </author> <title> Protected Mode Software Architecture. </title> <publisher> Addison-Wesley Developer Press, </publisher> <year> 1996. </year>
Reference-contexts: The rest of BIOS safe sync is fairly straightforward and is generated from the C version of enhanced safe sync. We modify the resulting assembly code by adding address/data overrides [Int97b] and using a large data segment (i.e. big real-mode <ref> [Shanley96] </ref>) to access data beyond the first 1 MB of memory. During sync, we copy the file cache data into the lower 1MB of memory because the BIOS disk interface uses 16-bit segment addressing.
Reference: [Siewiorek93] <author> Daniel P. Siewiorek, John J. Hudak, Byung-Hoon Suh, and Zary Segal. </author> <title> Development of a Benchmark to Measure System Robustness. </title> <booktitle> In Proceedings of the 1993 International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 8897, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Software-implemented fault injection (SWIFI) is a common technique in the fault-tolerant community [Iyer95]. Software fault injection can be used for many purposes, such as comparing the robustness of different systems <ref> [Siewiorek93, Tsai96, Kropp98] </ref>, understanding how systems behave during a fault [Chillarege89, Barton90, Kao93], and validating fault-tolerant mechanisms [Arlat90, Hudak93, Clark95, Rela96, Silva96, Carreira98]. However, there are very few case studies that use fault injection for all three of these purposes to guide the design and implementation of a fault-tolerant system.
Reference: [Silberschatz94] <author> Abraham Silberschatz and Peter B. Galvin. </author> <title> Operating System Concepts. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year> <title> The Systematic Improvement of Fault Tolerance in the Rio File Cache 19 </title>
Reference-contexts: Our goal is to make Rio (our write-back file cache) as reliable as a write-through file cache. Write-through file caches are considered very reliable against software crashes because they propagate data immediately to disk, and disks are not easily corrupted by operating system crashes <ref> [Silberschatz94, Tanenbaum95, Chen96] </ref>. We configure FreeBSD to use a write-through file cache, then measure the corruption rate to be 3.1% using the method described in Section 2.
Reference: [Silva96] <author> Joao G. Silva, Joao Carreira, Henrique Madeira, Diamantino Costa, and Francisco Moreira. </author> <title> Experimental Assessment of Parallel Systems. </title> <booktitle> In Proceedings of the 1996 Symposium on Fault-Tolerant Computing (FTCS), </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Software-implemented fault injection (SWIFI) is a common technique in the fault-tolerant community [Iyer95]. Software fault injection can be used for many purposes, such as comparing the robustness of different systems [Siewiorek93, Tsai96, Kropp98], understanding how systems behave during a fault [Chillarege89, Barton90, Kao93], and validating fault-tolerant mechanisms <ref> [Arlat90, Hudak93, Clark95, Rela96, Silva96, Carreira98] </ref>. However, there are very few case studies that use fault injection for all three of these purposes to guide the design and implementation of a fault-tolerant system.
Reference: [Sullivan91] <author> Mark Sullivan and R. Chillarege. </author> <title> Software Defects and Their Impact on System AvailabilityA Study of Field Failures in Operating Systems. </title> <booktitle> In Proceedings of the 1991 International Symposium on Fault-Tolerant Computing, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Our primary goal in designing these faults is to generate a wide variety of operating system crashes. Our models are derived from studies of commercial operating systems and databases <ref> [Sullivan92, Sullivan91, Lee93] </ref> and from prior models used in fault-injection studies [Barton90, Kao93, Kanawati95, Chen96]. The faults we inject range from low-level hardware faults such as ipping bits in memory to high-level software faults such as memory allocation errors. <p> We corrupt assignment statements by changing the source or destination register. We corrupt conditional constructs by deleting branches. We also delete random instructions (both branch and non-branch). The last and most extensive category of faults imitate specific programming errors in the operating system <ref> [Sullivan91] </ref>. These are targeted more at specific programming errors than the previous fault category. We inject an initialization fault by deleting instructions responsible for initializing a variable at the start of a procedure [Kao93, Lee93]. <p> The length of the overrun was distributed as follows: 50% corrupt one byte; 44% corrupt 2-1024 bytes; 6% corrupt 2-4 KB. This distribution was chosen by starting with the data gathered in <ref> [Sullivan91] </ref> and modifying it somewhat according to our specific platform and experience. bcopy is set to inject this error every 1000-4000 times it is called; this fault occurs approximately every 5 seconds on our system.
Reference: [Sullivan92] <author> Mark Sullivan and Ram Chillarege. </author> <title> A Comparison of Software Defects in Database Management Systems and Operating Systems. </title> <booktitle> In Proceedings of the 1992 International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 475484, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Our primary goal in designing these faults is to generate a wide variety of operating system crashes. Our models are derived from studies of commercial operating systems and databases <ref> [Sullivan92, Sullivan91, Lee93] </ref> and from prior models used in fault-injection studies [Barton90, Kao93, Kanawati95, Chen96]. The faults we inject range from low-level hardware faults such as ipping bits in memory to high-level software faults such as memory allocation errors.
Reference: [Tanenbaum95] <author> Andrew S. Tanenbaum. </author> <title> Distributed Operating Systems. </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference-contexts: Our goal is to make Rio (our write-back file cache) as reliable as a write-through file cache. Write-through file caches are considered very reliable against software crashes because they propagate data immediately to disk, and disks are not easily corrupted by operating system crashes <ref> [Silberschatz94, Tanenbaum95, Chen96] </ref>. We configure FreeBSD to use a write-through file cache, then measure the corruption rate to be 3.1% using the method described in Section 2.
Reference: [Tsai96] <author> Timothy K. Tsai, Ravishankar K. Iyer, and Doug Jewett. </author> <title> An Approach towards Benchmarking of Fault-Tolerant Commercial Systems. </title> <booktitle> In Proceedings of the 1996 Symposium on Fault-Tolerant Computing (FTCS), </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Software-implemented fault injection (SWIFI) is a common technique in the fault-tolerant community [Iyer95]. Software fault injection can be used for many purposes, such as comparing the robustness of different systems <ref> [Siewiorek93, Tsai96, Kropp98] </ref>, understanding how systems behave during a fault [Chillarege89, Barton90, Kao93], and validating fault-tolerant mechanisms [Arlat90, Hudak93, Clark95, Rela96, Silva96, Carreira98]. However, there are very few case studies that use fault injection for all three of these purposes to guide the design and implementation of a fault-tolerant system.
References-found: 33

