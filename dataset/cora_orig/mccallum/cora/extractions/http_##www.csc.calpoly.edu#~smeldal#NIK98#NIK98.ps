URL: http://www.csc.calpoly.edu/~smeldal/NIK98/NIK98.ps
Refering-URL: http://www.csc.calpoly.edu/~smeldal/tidbits.html
Root-URL: http://www.csc.calpoly.edu
Title: Specification and prototyping of network protocols in rewriting logic  
Author: Peter Csaba Olveczky and Sigurd Meldal 
Address: Menlo Park, U.S.A.  Norway  Poly, San Luis Obispo, U.S.A.  
Affiliation: Computer Science Laboratory, SRI International,  Department of Informatics, University of Bergen,  Computer Science Department, Cal  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. C. M. Baeten and W. P. Weijland. </author> <title> Process Algebra. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: Concurrency and communication are introduced into these models by adding constructs that model particular kinds of communication as lan-guage primitives. Labeled transition systems are often studied in the context of process algebras such as CCS [29], ACP <ref> [1] </ref>, and CSP [14]. Petri nets [31] extend this state/transition setting by allowing states to be distributed across different locations.
Reference: [2] <author> B. W. Boehm. </author> <title> Software Engineering Economics. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Not only are defects most likely to be introduced in the early stage of software development, defects introduced at that stage are also the most expensive to correct. Boehm <ref> [2] </ref> estimates that specification defects are about 100 times more expensive to correct than are implementation errors.
Reference: [3] <author> T. Bolognesi and E. Brinksma. </author> <title> Introduction to the ISO specification language LOTOS. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 14, </volume> <year> 1987. </year>
Reference-contexts: Petri nets [31] extend this state/transition setting by allowing states to be distributed across different locations. These formalisms must be extended with facilities for specifying data types in specification languages such as e. g., LOTOS <ref> [16, 3] </ref>, OCCAM [15], and colored and algebraic Petri nets [17, 32] to allow more complex data structures in the systems. Executable specifications of reactive systems may be interpreted (and thus executed) in various ways, e.g., following all possible execution traces, simulating one run, etc.
Reference: [4] <author> M. G. Clavel. </author> <title> Reflection in General Logics, Rewriting Logic, and Maude. </title> <type> PhD thesis, </type> <institution> University of Navarre, </institution> <year> 1998. </year>
Reference-contexts: Instead of providing the user with extra-logical control commands to define the control strategy, Maude uses the fact that rewriting logic is reflective to allow the user to define his own strategies within rewriting logic itself 3 <ref> [4, 6, 7] </ref>.
Reference: [5] <author> M. G. Clavel, S. Eker, P. Lincoln, and J. Meseguer. </author> <title> Principles of Maude. </title> <editor> In J. Meseguer, editor, </editor> <booktitle> Proc. 1st Intl. Workshop on Rewriting Logic and its Applications, volume 4 of Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <year> 1996. </year>
Reference-contexts: UNITY, can be expressed in a natural way in rewriting logic [24, 26]. As a matter of fact, rewriting logic is employed to state the semantics for Actors [39]. The language Maude <ref> [5, 25] </ref> is based on rewriting logic and membership equational logic (an extension of order-sorted algebra) [27]. The current Maude implementation at SRI International can reach up to 590.000 rewrites per second on applications running on a 200MHz Pentium Pro.
Reference: [6] <author> M. G. Clavel and J. Meseguer. </author> <title> Axiomatizing reflective logics and languages. </title> <editor> In G. Kiczales, editor, </editor> <booktitle> Proc. </booktitle> <address> Reflection'96. </address> <note> Xerox Parc, </note> <year> 1996. </year>
Reference-contexts: Instead of providing the user with extra-logical control commands to define the control strategy, Maude uses the fact that rewriting logic is reflective to allow the user to define his own strategies within rewriting logic itself 3 <ref> [4, 6, 7] </ref>.
Reference: [7] <author> M. G. Clavel and J. Meseguer. </author> <title> Reflection and strategies in rewriting logic. </title> <editor> In J. Meseguer, editor, </editor> <booktitle> Proc. 1st Intl. Workshop on Rewriting Logic and its Applications, volume 4 of Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <year> 1996. </year>
Reference-contexts: Instead of providing the user with extra-logical control commands to define the control strategy, Maude uses the fact that rewriting logic is reflective to allow the user to define his own strategies within rewriting logic itself 3 <ref> [4, 6, 7] </ref>.
Reference: [8] <author> R. Cleaveland and S. A. Smolka et al. </author> <title> Strategic directions in concurrency research. </title> <journal> ACM Computing Surveys, </journal> <year> 1996. </year>
Reference-contexts: Instead, it is better to take into account the fact that systems interact with other systems and hence may exhibit patterns of stimulus/response relationships that vary over time <ref> [8] </ref>. There are a number of operational models of concurrency, such as various extensions of labeled transition systems, where transitions are labeled with actions representing interaction with the environment.
Reference: [9] <author> G. Denker. </author> <title> From rewrite theories to temporal logic theories: A distributed temporal logic extension of rewriting logic. </title> <type> Manuscript, </type> <institution> SRI International, </institution> <year> 1998. </year>
Reference-contexts: Work exploring these topics includes Lechner's adaption of -calculus [19] and Denker's version of the object-oriented Distributed Temporal Logic (DTL+) <ref> [9] </ref>. 5 Summary We have illustrated how one may use rewriting logic and Maude to formally specify communication protocols. The specification was tested by executing it on chosen test states using Maude's default interpreter, and was analyzed by finding all non-rewritable reachable states from these initial test configurations.
Reference: [10] <author> G. Denker, J. Meseguer, and C. Talcott. </author> <title> Protocol Specification and Analysis in Maude. </title> <editor> In N. Heintze and J. Wing, editors, </editor> <booktitle> Proc. Workshop on Formal Methods and Security Protocols, </booktitle> <address> 25 June 1998, Indianapolis, Indiana, </address> <year> 1998. </year>
Reference-contexts: Rewriting logic seems particularly suitable for specifying security and communication protocols (e.g., see <ref> [10, 18] </ref>). Such protocols are complex enough to warrant prototyping and their operational nature fits very well with rewriting logic. In this article we explore the utility of rewriting logic through the specification of a new protocol for reliable broadcasting in dynamic networks.
Reference: [11] <author> J. J. Garcia-Luna. </author> <title> Reliable broadcasting in computer networks, 1998. </title> <type> Manuscript, </type> <institution> UC Santa Cruz. </institution>
Reference-contexts: In this article we explore the utility of rewriting logic through the specification of a new protocol for reliable broadcasting in dynamic networks. The specification of the protocol originated as an informal specification suggested by Jose Garcia-Luna <ref> [11] </ref>. The goal of the protocol is to improve on existing protocols for efficient and reliable broadcasting of messages in dynamic networks. The desire is to arrive at a readable and understandable formal specification, to validate the protocol by executing the specification, and to prove that it satisfies certain properties. <p> Most broadcast protocols are based on the PI and PIF protocols [37, 36], and all the broadcasting protocols for dynamic topologies extending these are based on the routing protocol by Merlin and Segall [23] which incurs too much communication to be attractive for, say, a wireless network <ref> [11] </ref>. It is the long term goal of our work to define a more general approach (in terms of mobility of nodes) and more efficient protocols for reliable broadcasting in dynamic networks. The starting point of our work was an informal draft specification of the protocol given by Jose Garcia-Luna [11], <p> <ref> [11] </ref>. It is the long term goal of our work to define a more general approach (in terms of mobility of nodes) and more efficient protocols for reliable broadcasting in dynamic networks. The starting point of our work was an informal draft specification of the protocol given by Jose Garcia-Luna [11], and a group consisting of Garcia-Luna, Grit Denker, Jose Meseguer, Brad Smith, Carolyn Talcott, and the first author are currently working on specifying the protocol. An important subcase of the general, dynamic network topology is the static setting.
Reference: [12] <author> V. Hamilton. </author> <title> The use of Z within a safety-critical software system, </title> <booktitle> 1995. In [13]. </booktitle>
Reference-contexts: However: "Software errors are ultimately caused by human errors: typing errors, errors of understanding, errors of thought. It is just as likely for the engineer writing the formal specification to make a mistake as it is for a programmer to do so." <ref> [12] </ref>. In fact, it seems that errors in specifications occur at least as frequently as errors in program code, when measured in terms of defects per line of code/specification.
Reference: [13] <editor> M. G. Hinchey and J. P. Bowen (eds). </editor> <title> Applications of Formal Methods. </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference-contexts: Formal specifications are also likely to give specifications at a reasonable level of abstraction. Though formal methods have not quite lived up to the full potential envisioned by early proponents, their usefulness, in particular for developing safety-critical systems applications, is gradually being realized in industry (see e.g . <ref> [13] </ref>). For instance, SRI's PVS system could have detected the "Pentium bug" during routine formal verification [33]. Moreover, it is unlikely that standard testing methods would have identified the defect [30]. <p> Other industrial formal verification projects using PVS discovered subtle defects in Rockwell's AAAMP5 microprocessor [38] and the possibility of firing a failed jet in a space shuttle [34]. Some U.S. government agencies now require the use of formal methods for validation and specification of safety-critical system components <ref> [13] </ref>. The focus for formal methods has traditionally been the use of proofs to verify the correctness of specifications and conformance of purported implementations.
Reference: [14] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: Concurrency and communication are introduced into these models by adding constructs that model particular kinds of communication as lan-guage primitives. Labeled transition systems are often studied in the context of process algebras such as CCS [29], ACP [1], and CSP <ref> [14] </ref>. Petri nets [31] extend this state/transition setting by allowing states to be distributed across different locations.
Reference: [15] <author> Inmos International. </author> <title> OCCAM-2 Reference Manual. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Petri nets [31] extend this state/transition setting by allowing states to be distributed across different locations. These formalisms must be extended with facilities for specifying data types in specification languages such as e. g., LOTOS [16, 3], OCCAM <ref> [15] </ref>, and colored and algebraic Petri nets [17, 32] to allow more complex data structures in the systems. Executable specifications of reactive systems may be interpreted (and thus executed) in various ways, e.g., following all possible execution traces, simulating one run, etc.
Reference: [16] <institution> Information systems processing open systems interconnection - LOTOS. </institution> <type> Tech. rep. </type> <institution> International Standards Organization DIS 8807, </institution> <year> 1987. </year>
Reference-contexts: Petri nets [31] extend this state/transition setting by allowing states to be distributed across different locations. These formalisms must be extended with facilities for specifying data types in specification languages such as e. g., LOTOS <ref> [16, 3] </ref>, OCCAM [15], and colored and algebraic Petri nets [17, 32] to allow more complex data structures in the systems. Executable specifications of reactive systems may be interpreted (and thus executed) in various ways, e.g., following all possible execution traces, simulating one run, etc.
Reference: [17] <author> K. Jensen. </author> <title> Coloured Petri Nets, Basic Concepts, Analysis Methods and Prac--tical Use, </title> <booktitle> volume 1 of EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Petri nets [31] extend this state/transition setting by allowing states to be distributed across different locations. These formalisms must be extended with facilities for specifying data types in specification languages such as e. g., LOTOS [16, 3], OCCAM [15], and colored and algebraic Petri nets <ref> [17, 32] </ref> to allow more complex data structures in the systems. Executable specifications of reactive systems may be interpreted (and thus executed) in various ways, e.g., following all possible execution traces, simulating one run, etc.
Reference: [18] <author> S. Krogdahl and O. Lysne. </author> <title> Verifying a distributed list system: A case history. </title> <journal> Formal Aspects of Computing, </journal> <volume> 3, </volume> <year> 1997. </year>
Reference-contexts: Rewriting logic seems particularly suitable for specifying security and communication protocols (e.g., see <ref> [10, 18] </ref>). Such protocols are complex enough to warrant prototyping and their operational nature fits very well with rewriting logic. In this article we explore the utility of rewriting logic through the specification of a new protocol for reliable broadcasting in dynamic networks.
Reference: [19] <author> U. Lechner. </author> <title> Object-Oriented Specification of Distributed Systems. </title> <type> PhD thesis, </type> <institution> University of Passau, </institution> <year> 1997. </year> <note> Available at: www.mcm.unisg.ch/~ulechner. </note>
Reference-contexts: Finding the most suitable temporal logics for expressing global properties about (object-oriented) rewrite specifications and giving proof techniques for proving that a rewrite theory satisfies the global requirements are interesting and open research topics. Work exploring these topics includes Lechner's adaption of -calculus <ref> [19] </ref> and Denker's version of the object-oriented Distributed Temporal Logic (DTL+) [9]. 5 Summary We have illustrated how one may use rewriting logic and Maude to formally specify communication protocols.
Reference: [20] <author> D. C. Luckham and F. W. von Henke. </author> <title> An overview of Anna, a specification language for Ada. </title> <journal> IEEE Software, </journal> <volume> 2(2) </volume> <pages> 9-23, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: The focus for formal methods has traditionally been the use of proofs to verify the correctness of specifications and conformance of purported implementations. Complementing this approach, a recent research trend has been to investigate other uses of formalized specifications: automatic conformance testing (dating back to the work on Anna <ref> [20] </ref>, recently developing architecture conformance testing tools [22]), semantic analysis (such as advanced type checking), and (semi-)automatic synthesis of executable prototypes.
Reference: [21] <author> R. R. Lutz. </author> <title> Analyzing software requirements errors in safety-critical embedded systems. </title> <booktitle> In IEEE International Symposium on Requirements Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: For example, of the 197 critical defects identified during integration and system testing of the Voyager and Galileo spacecraft, only 3 were due to coding errors <ref> [35, 21] </ref>. A majority of defects can usually be traced back to errors in requirements, interfaces, and intrinsic difficulties of the problem domain [35]. For the spacecraft data above, approximately 50% of the defects were traced to requirements (mainly omissions), and 25% to each of interfaces and design.
Reference: [22] <author> S. Meldal and D. C. Luckham. </author> <title> NSA's MISSI reference architecture moving from prose to precise specification. </title> <editor> In M. Broy and B. Rumpe, editors, </editor> <booktitle> Requirements Targeting Software and Systems Engineering, volume (TBD) of Lecture Notes in Computer Science, </booktitle> <pages> pages 293-329, </pages> <year> 1998. </year>
Reference-contexts: Complementing this approach, a recent research trend has been to investigate other uses of formalized specifications: automatic conformance testing (dating back to the work on Anna [20], recently developing architecture conformance testing tools <ref> [22] </ref>), semantic analysis (such as advanced type checking), and (semi-)automatic synthesis of executable prototypes. The focus of this article is the latter. 1.1 Executable specifications Algebraic specification techniques, -calculi, and logic programming languages have been used to define executable formal specifications of the functional aspects of software systems.
Reference: [23] <author> P. M. Merlin and A. Segall. </author> <title> A failsafe distributed routing protocol. </title> <journal> IEEE Trans. Commun., </journal> <volume> 27(9) </volume> <pages> 1280-1288, </pages> <year> 1979. </year>
Reference-contexts: Most broadcast protocols are based on the PI and PIF protocols [37, 36], and all the broadcasting protocols for dynamic topologies extending these are based on the routing protocol by Merlin and Segall <ref> [23] </ref> which incurs too much communication to be attractive for, say, a wireless network [11]. It is the long term goal of our work to define a more general approach (in terms of mobility of nodes) and more efficient protocols for reliable broadcasting in dynamic networks.
Reference: [24] <author> J. Meseguer. </author> <title> Conditional rewriting logic as a unified model of concurrency. </title> <journal> Theoretical Computer Science, </journal> <volume> 96, </volume> <year> 1992. </year>
Reference-contexts: Executable specifications of reactive systems may be interpreted (and thus executed) in various ways, e.g., following all possible execution traces, simulating one run, etc. The operational choice of execution model is usually either embedded in the language semantics, or defined by an extra-logical set of strategy constructors. Rewriting logic <ref> [24, 25, 26, 28] </ref> extends algebraic specification techniques to concurrent and reactive systems. <p> Section 4 touches upon verification issues, and Section 5 sums up our experience using rewriting logic for this specification effort. There are two appendices that are made available at &lt;http://www.csc.calpoly.edu/~smeldal/NIK98/NIK98App.pdf&gt;. 2 Rewriting logic Rewriting logic <ref> [24, 25, 26] </ref> extends algebraic specification techniques to handle nondeterministic, reactive, and concurrent systems. It is based on the following two observations: 1. <p> Sentences are of the form [t ] E ! [t 0 ] E the intended meaning being that a state [t ] E of a system could change to a state [t 0 ] E by repeated application of the following deduction rules 2 <ref> [24] </ref>: Reflexivity. For each [t ] 2 T ;E (X ), [t ] ! [t ] Congruence. For each f 2 n ; n 2 N , [t 1 ] ! [t 0 n ] 1 ; : : : ; t 0 Unconditional replacement. <p> It has been demonstrated that models of reactive and concurrent systems such as Petri nets, CCS, Actors, and 1 A system is confluent if, for any starting state, there is only one possible termination state 2 We give the rules for the unsorted unconditional case; for conditional rewrite rules, see <ref> [24] </ref>. UNITY, can be expressed in a natural way in rewriting logic [24, 26]. As a matter of fact, rewriting logic is employed to state the semantics for Actors [39]. The language Maude [5, 25] is based on rewriting logic and membership equational logic (an extension of order-sorted algebra) [27]. <p> UNITY, can be expressed in a natural way in rewriting logic <ref> [24, 26] </ref>. As a matter of fact, rewriting logic is employed to state the semantics for Actors [39]. The language Maude [5, 25] is based on rewriting logic and membership equational logic (an extension of order-sorted algebra) [27].
Reference: [25] <author> J. Meseguer. </author> <title> A logical theory of concurrent objects and its realization in the Maude language. </title> <editor> In Gul Agha, Peter Wegner, and Akinori Yonezawa, editors, </editor> <booktitle> Research Directions in Concurrent Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Executable specifications of reactive systems may be interpreted (and thus executed) in various ways, e.g., following all possible execution traces, simulating one run, etc. The operational choice of execution model is usually either embedded in the language semantics, or defined by an extra-logical set of strategy constructors. Rewriting logic <ref> [24, 25, 26, 28] </ref> extends algebraic specification techniques to concurrent and reactive systems. <p> Section 4 touches upon verification issues, and Section 5 sums up our experience using rewriting logic for this specification effort. There are two appendices that are made available at &lt;http://www.csc.calpoly.edu/~smeldal/NIK98/NIK98App.pdf&gt;. 2 Rewriting logic Rewriting logic <ref> [24, 25, 26] </ref> extends algebraic specification techniques to handle nondeterministic, reactive, and concurrent systems. It is based on the following two observations: 1. <p> UNITY, can be expressed in a natural way in rewriting logic [24, 26]. As a matter of fact, rewriting logic is employed to state the semantics for Actors [39]. The language Maude <ref> [5, 25] </ref> is based on rewriting logic and membership equational logic (an extension of order-sorted algebra) [27]. The current Maude implementation at SRI International can reach up to 590.000 rewrites per second on applications running on a 200MHz Pentium Pro. <p> Key features of the universal theory U are provided in the built-in Maude module META-LEVEL which can be extended in a completely user-definable way to specify strategies controlling the rewriting in a way internal to rewriting logic itself. 4 We consider the setting without inheritance. Inheritance is treated in <ref> [25] </ref>. 5 The symbol marks the place for the arguments of a "mix-fix" operator symbol. subsort Object Message &lt; Configuration . op empty : -&gt; Configuration . op _ _ : Configuration Configuration -&gt; Configuration [assoc comm id: empty] .
Reference: [26] <author> J. Meseguer. </author> <title> Rewriting logic as a semantic framework for concurrency: a progress report. </title> <booktitle> In Concur'96, volume 1119 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Executable specifications of reactive systems may be interpreted (and thus executed) in various ways, e.g., following all possible execution traces, simulating one run, etc. The operational choice of execution model is usually either embedded in the language semantics, or defined by an extra-logical set of strategy constructors. Rewriting logic <ref> [24, 25, 26, 28] </ref> extends algebraic specification techniques to concurrent and reactive systems. <p> Section 4 touches upon verification issues, and Section 5 sums up our experience using rewriting logic for this specification effort. There are two appendices that are made available at &lt;http://www.csc.calpoly.edu/~smeldal/NIK98/NIK98App.pdf&gt;. 2 Rewriting logic Rewriting logic <ref> [24, 25, 26] </ref> extends algebraic specification techniques to handle nondeterministic, reactive, and concurrent systems. It is based on the following two observations: 1. <p> UNITY, can be expressed in a natural way in rewriting logic <ref> [24, 26] </ref>. As a matter of fact, rewriting logic is employed to state the semantics for Actors [39]. The language Maude [5, 25] is based on rewriting logic and membership equational logic (an extension of order-sorted algebra) [27].
Reference: [27] <author> J. Meseguer. </author> <title> Membership algebra as a semantic framework for equational specification. </title> <editor> In F. Parisi-Presicce, editor, </editor> <booktitle> Proc. WADT'97, volume 1376 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: UNITY, can be expressed in a natural way in rewriting logic [24, 26]. As a matter of fact, rewriting logic is employed to state the semantics for Actors [39]. The language Maude [5, 25] is based on rewriting logic and membership equational logic (an extension of order-sorted algebra) <ref> [27] </ref>. The current Maude implementation at SRI International can reach up to 590.000 rewrites per second on applications running on a 200MHz Pentium Pro.
Reference: [28] <author> J. Meseguer. </author> <title> Research directions in rewriting logic. </title> <editor> In U. Berger and H. Schwichtenberg, editors, </editor> <booktitle> Computational Logic, NATO Advanced Study Institute, Marktoberdorf, </booktitle> <address> Germany, </address> <month> July 29 August 6, </month> <year> 1997. </year> <note> Springer-Verlag, 1998. To appear. </note>
Reference-contexts: Executable specifications of reactive systems may be interpreted (and thus executed) in various ways, e.g., following all possible execution traces, simulating one run, etc. The operational choice of execution model is usually either embedded in the language semantics, or defined by an extra-logical set of strategy constructors. Rewriting logic <ref> [24, 25, 26, 28] </ref> extends algebraic specification techniques to concurrent and reactive systems.
Reference: [29] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: Concurrency and communication are introduced into these models by adding constructs that model particular kinds of communication as lan-guage primitives. Labeled transition systems are often studied in the context of process algebras such as CCS <ref> [29] </ref>, ACP [1], and CSP [14]. Petri nets [31] extend this state/transition setting by allowing states to be distributed across different locations.
Reference: [30] <author> V. Pratt. </author> <title> Anatomy of the Pentium Bug. </title> <editor> In P. D. Mosses, M. Nielsen, and H. I. Schwartzbach, editors, TAPSOFT'95: </editor> <booktitle> Theory and Practice of Software Development, volume 915 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-107. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: For instance, SRI's PVS system could have detected the "Pentium bug" during routine formal verification [33]. Moreover, it is unlikely that standard testing methods would have identified the defect <ref> [30] </ref>. Other industrial formal verification projects using PVS discovered subtle defects in Rockwell's AAAMP5 microprocessor [38] and the possibility of firing a failed jet in a space shuttle [34]. Some U.S. government agencies now require the use of formal methods for validation and specification of safety-critical system components [13].
Reference: [31] <author> W. Reisig. </author> <title> Petri Nets, </title> <booktitle> volume 4 of EATCS monographs on Theoretical Com--puter Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Concurrency and communication are introduced into these models by adding constructs that model particular kinds of communication as lan-guage primitives. Labeled transition systems are often studied in the context of process algebras such as CCS [29], ACP [1], and CSP [14]. Petri nets <ref> [31] </ref> extend this state/transition setting by allowing states to be distributed across different locations.
Reference: [32] <author> W. Reisig. </author> <title> Petri nets and algebraic specifications. </title> <journal> Theoretical Computer Science, </journal> <volume> 41, </volume> <year> 1991. </year>
Reference-contexts: Petri nets [31] extend this state/transition setting by allowing states to be distributed across different locations. These formalisms must be extended with facilities for specifying data types in specification languages such as e. g., LOTOS [16, 3], OCCAM [15], and colored and algebraic Petri nets <ref> [17, 32] </ref> to allow more complex data structures in the systems. Executable specifications of reactive systems may be interpreted (and thus executed) in various ways, e.g., following all possible execution traces, simulating one run, etc.
Reference: [33] <author> H. Rue, N. Shankar, and M. K. Srivas. </author> <title> Modular verification of SRT division. </title> <editor> In Rajeev Alur and Thomas A. Henzinger, editors, </editor> <booktitle> Computer-Aided Verification, CAV '96, number 1102 in Lecture Notes in Computer Science, </booktitle> <pages> pages 123-134. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: For instance, SRI's PVS system could have detected the "Pentium bug" during routine formal verification <ref> [33] </ref>. Moreover, it is unlikely that standard testing methods would have identified the defect [30]. Other industrial formal verification projects using PVS discovered subtle defects in Rockwell's AAAMP5 microprocessor [38] and the possibility of firing a failed jet in a space shuttle [34].
Reference: [34] <author> John Rushby. </author> <title> Automated deduction and formal methods. </title> <editor> In Rajeev Alur and Thomas A. Henzinger, editors, </editor> <booktitle> Computer-Aided Verification, CAV '96, number 1102 in Lecture Notes in Computer Science, </booktitle> <pages> pages 169-183. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Moreover, it is unlikely that standard testing methods would have identified the defect [30]. Other industrial formal verification projects using PVS discovered subtle defects in Rockwell's AAAMP5 microprocessor [38] and the possibility of firing a failed jet in a space shuttle <ref> [34] </ref>. Some U.S. government agencies now require the use of formal methods for validation and specification of safety-critical system components [13]. The focus for formal methods has traditionally been the use of proofs to verify the correctness of specifications and conformance of purported implementations.
Reference: [35] <author> John Rushby. </author> <title> Mechanized formal methods: Progress and prospects. </title> <booktitle> In 16th Conference on the Foundations of Software Technology and Theoretical Computer Science, volume 1180 of Lecture Notes in Computer Science, </booktitle> <pages> pages 43-51. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1996. </year>
Reference-contexts: For example, of the 197 critical defects identified during integration and system testing of the Voyager and Galileo spacecraft, only 3 were due to coding errors <ref> [35, 21] </ref>. A majority of defects can usually be traced back to errors in requirements, interfaces, and intrinsic difficulties of the problem domain [35]. For the spacecraft data above, approximately 50% of the defects were traced to requirements (mainly omissions), and 25% to each of interfaces and design. <p> For example, of the 197 critical defects identified during integration and system testing of the Voyager and Galileo spacecraft, only 3 were due to coding errors [35, 21]. A majority of defects can usually be traced back to errors in requirements, interfaces, and intrinsic difficulties of the problem domain <ref> [35] </ref>. For the spacecraft data above, approximately 50% of the defects were traced to requirements (mainly omissions), and 25% to each of interfaces and design.
Reference: [36] <author> A. Segall. </author> <title> Distributed network protocols. </title> <journal> IEEE Trans. Info. Theory, </journal> <volume> 29(1) </volume> <pages> 25-35, </pages> <year> 1983. </year>
Reference-contexts: Most broadcast protocols are based on the PI and PIF protocols <ref> [37, 36] </ref>, and all the broadcasting protocols for dynamic topologies extending these are based on the routing protocol by Merlin and Segall [23] which incurs too much communication to be attractive for, say, a wireless network [11].
Reference: [37] <author> A. Segall and B. Awerbuch. </author> <title> A reliable broadcast protocol. </title> <journal> IEEE Trans. Com-mun., </journal> <volume> 31(7) </volume> <pages> 896-901, </pages> <year> 1983. </year>
Reference-contexts: Most broadcast protocols are based on the PI and PIF protocols <ref> [37, 36] </ref>, and all the broadcasting protocols for dynamic topologies extending these are based on the routing protocol by Merlin and Segall [23] which incurs too much communication to be attractive for, say, a wireless network [11].
Reference: [38] <author> M. K. Srivas and S. P. Miller. </author> <title> Formal verification of the aamp5 microprocessor. </title> <booktitle> In [13], </booktitle> <year> 1995. </year>
Reference-contexts: For instance, SRI's PVS system could have detected the "Pentium bug" during routine formal verification [33]. Moreover, it is unlikely that standard testing methods would have identified the defect [30]. Other industrial formal verification projects using PVS discovered subtle defects in Rockwell's AAAMP5 microprocessor <ref> [38] </ref> and the possibility of firing a failed jet in a space shuttle [34]. Some U.S. government agencies now require the use of formal methods for validation and specification of safety-critical system components [13].
Reference: [39] <author> C. L. Talcott. </author> <title> An actor rewriting theory. </title> <editor> In J. Meseguer, editor, </editor> <booktitle> Proc. 1st Intl. Workshop on Rewriting Logic and its Applications, volume 4 of Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <year> 1996. </year>
Reference-contexts: UNITY, can be expressed in a natural way in rewriting logic [24, 26]. As a matter of fact, rewriting logic is employed to state the semantics for Actors <ref> [39] </ref>. The language Maude [5, 25] is based on rewriting logic and membership equational logic (an extension of order-sorted algebra) [27]. The current Maude implementation at SRI International can reach up to 590.000 rewrites per second on applications running on a 200MHz Pentium Pro.
References-found: 39

