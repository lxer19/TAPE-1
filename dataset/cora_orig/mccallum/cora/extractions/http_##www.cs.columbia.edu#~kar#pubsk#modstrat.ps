URL: http://www.cs.columbia.edu/~kar/pubsk/modstrat.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Email: kar@cs.columbia.edu  
Title: Modular Stratification and Magic Sets for Datalog Programs with Negation  
Author: Kenneth A. Ross 
Note: Journal of the ACM, Vol. 41, No. 6, 1994, pp.1216-1266  
Affiliation: Columbia University  
Abstract: A class of "modularly stratified" logic programs is defined. Modular stratification generalizes stratification and local stratification, while allowing programs that are not expressible as stratified programs. For modularly stratified programs the well-founded semantics coincides with the stable model semantics, and makes every ground literal true or false. Modularly stratified programs are weakly stratified, but the converse is false. Unlike some weakly stratified programs, modularly stratified programs can be evaluated in a subgoal-at-a-time fashion. An extension of top-down methods with memoing that handles this broader class of programs is presented. A technique for rewriting a modularly stratified program for bottom-up evaluation is demonstrated, and extended to include magic-set techniques. The rewritten program, when evaluated bottom-up, gives correct answers according to the well-founded semantics, but much more efficiently than computing the complete well-founded model. A one to one correspondence between steps of the extended top-down method and steps during the bottom-up evaluation of the magic-rewritten program is exhibited, demonstrating that the complexity of the two methods is the same. Extensions of modular stratification to other operators such as set-grouping and aggregation, which have traditionally been Categories and Subject Descriptors: D.3.1 Programming Languages: Formal definitions and theory | semantics. F.4.1 Mathematical Logic and Formal Languages: Mathematical logic | logic programming. H.2.3 Database Management: Languages | Query languages. H.2.4 Database Management: Systems | Query processing. I.2.3 Artificial Intelligence: Deduction and theorem proving | deduction, logic programming, nonmonotonic reasoning and belief revision. General Terms: Algorithms, Languages, Theory. Additional Key Words: Deductive databases, well-founded semantics, stratification, modular stratification, magic sets, rule rewriting. fl This research was performed while the author was at Stanford University, and was supported by NSF grant IRI-87-22886, a grant from IBM corporation, and by AFOSR under contract number 88-0266. A preliminary abstract of this paper appeared at the Ninth ACM Symposium on Principles of Database Systems [28]. stratified to prevent semantic difficulties, are discussed.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Balbin, I., Meenkashi, K., and Ramamohanarao, K. </author> <title> An efficient labelling algorithm for magic set computation on stratified databases. </title> <type> Tech. Rep. 88/1, </type> <institution> Dept. of Computer Science, University of Melbourne, </institution> <year> 1988. </year> <month> 50 </month>
Reference-contexts: In the absence of negation, bottom-up computation may be made at least as efficient as a top-down method without memoing by the use of magic sets [33]. Several authors have considered the problem of extending the magic sets method to stratified programs. The approach of <ref> [1, 2] </ref> is to relabel predicates in a stratified program in such a way that the magic transformation results in a stratified program. This method does not work for all stratified programs, though.
Reference: [2] <author> Balbin, I., Port, G. S., and Ramamohanarao, K. </author> <title> Magic set computation for on stratified databases. </title> <type> Tech. Rep. 87/3, </type> <institution> Dept. of Computer Science, University of Melbourne, </institution> <year> 1987. </year>
Reference-contexts: In the absence of negation, bottom-up computation may be made at least as efficient as a top-down method without memoing by the use of magic sets [33]. Several authors have considered the problem of extending the magic sets method to stratified programs. The approach of <ref> [1, 2] </ref> is to relabel predicates in a stratified program in such a way that the magic transformation results in a stratified program. This method does not work for all stratified programs, though.
Reference: [3] <author> Balbin, I., Port, G. S., Ramamohanarao, K., and Meenkashi, K. </author> <title> Efficient bottom-up computation of queries on stratified databases. </title> <journal> Journal of Logic Programming 11 (1991), </journal> <pages> 295-344. </pages>
Reference-contexts: This method does not work for all stratified programs, though. More recently, these authors have considered a "structured" bottom-up method that uses control information in order to sequence rule execution <ref> [3] </ref>. The approach of [7] is similar in nature to this structured bottom-up method. The authors perform the magic rewriting, which may result in an unstratified program, and then impose constraints on the order of evaluation of rules, in the form of regular expressions.
Reference: [4] <author> Bancilhon, F., Maier, D., Sagiv, Y., and Ullman, J. D. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the Fifth ACM Symposium on Principles of Database Systems (1986). </booktitle>
Reference-contexts: Top-down evaluation can beat bottom-up evaluation of the original program because it can restrict the computation to only those tuples relevant 31 to the query. This problem is now well-understood for programs without negation, and several techniques have been proposed [5]. One of these is magic sets <ref> [4, 6, 25] </ref>, which rewrites the program in such a way that the binding information that would have been passed down by a top-down method is incorporated into the bottom-up evaluation.
Reference: [5] <author> Bancilhon, F., and Ramakrishnan, R. </author> <title> An amateur's introduction to recursive query processing strategies. </title> <booktitle> In 1986 ACM-SIGMOD Conf. on Management of Data (1986), </booktitle> <pages> pp. 16-52. </pages>
Reference-contexts: Top-down evaluation can beat bottom-up evaluation of the original program because it can restrict the computation to only those tuples relevant 31 to the query. This problem is now well-understood for programs without negation, and several techniques have been proposed <ref> [5] </ref>. One of these is magic sets [4, 6, 25], which rewrites the program in such a way that the binding information that would have been passed down by a top-down method is incorporated into the bottom-up evaluation.
Reference: [6] <author> Beeri, C., and Ramakrishnan, R. </author> <title> On the power of magic. </title> <note> Journal of Logic Programming 10 (1991), 255-300. Preliminary version appeared in the 6th ACM Symposium on Principles of Database Systems, </note> <year> 1987. </year>
Reference-contexts: Nevertheless, the author believes that programs that cannot be rearranged into permissible versions will be rare in practice. Passing bindings from left to right is one of many possible "sideways information passing strategies" (sips) that could be used <ref> [6] </ref>. Alternative strategies can be put into our framework by applying Definition 3.6 with a refined notion of a rule prefix. <p> Top-down evaluation can beat bottom-up evaluation of the original program because it can restrict the computation to only those tuples relevant 31 to the query. This problem is now well-understood for programs without negation, and several techniques have been proposed [5]. One of these is magic sets <ref> [4, 6, 25] </ref>, which rewrites the program in such a way that the binding information that would have been passed down by a top-down method is incorporated into the bottom-up evaluation.
Reference: [7] <author> Beeri, C., Ramakrishnan, R., Srivastava, D., and Sudarshan, S. </author> <title> Magic implementation of stratified logic programs. </title> <type> (manuscript), </type> <year> 1989. </year>
Reference-contexts: This method does not work for all stratified programs, though. More recently, these authors have considered a "structured" bottom-up method that uses control information in order to sequence rule execution [3]. The approach of <ref> [7] </ref> is similar in nature to this structured bottom-up method. The authors perform the magic rewriting, which may result in an unstratified program, and then impose constraints on the order of evaluation of rules, in the form of regular expressions.
Reference: [8] <author> Brodsky, A., and Sagiv, Y. </author> <title> Inference of monotonicity constraints in Datalog programs. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems (1989). </booktitle>
Reference-contexts: When changes to m occur, we have to check only that acyclicity is not violated. In fact, acyclicity is the typical example of a semantic constraint guaranteeing modular stratifiability. Such constraints are similar in nature to "monotonicity constraints" discussed in <ref> [8] </ref>, which were used in the context of testing the termination of Datalog programs without negation. Placing constraints on components enables a modular approach to writing programs.
Reference: [9] <author> Bry, F., </author> <month> Dec. </month> <year> 1989. </year> <type> (personal communication). </type>
Reference-contexts: Unfortunately, the section on magic sets in that paper is very brief, and at the present time, no full version is available. Only after the present paper was written did we become aware of the details of Bry's work <ref> [9] </ref>. Although the class of constructively consistent programs is incomparable with the class of modularly stratified programs, it does also generalize the class of stratified programs, and constructively consistent programs have a two-valued semantics. Bry's method handles negative dependencies by storing revised rules rather than atoms.
Reference: [10] <author> Bry, F. </author> <title> Logic programming as constructivism: A formalization and its application to databases. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems (1989). </booktitle>
Reference-contexts: Weakly stratified programs are evaluated using a nested fixpoint technique that computes the fixpoint of rules from lower strata after each application of a rule from a higher stratum. In <ref> [10] </ref>, Bry outlines a magic sets method for what he calls constructively consistent programs. Unfortunately, the section on magic sets in that paper is very brief, and at the present time, no full version is available.
Reference: [11] <author> Chan, D. </author> <title> Constructive negation based on the completed database. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming (1988). </booktitle>
Reference-contexts: By placing this predicate to the left of each floundering subgoal, one can prevent floundering without losing any expressive power. An alternative approach, which merits further research, would be to incorporate constructive negation <ref> [11, 24] </ref> into the evaluation mechanisms proposed in this paper. Nevertheless, the author believes that programs that cannot be rearranged into permissible versions will be rare in practice. Passing bindings from left to right is one of many possible "sideways information passing strategies" (sips) that could be used [6].
Reference: [12] <author> Chen, W., Kifer, M., and Warren, D. S. HiLog: </author> <title> A first order semantics for higher-order logic programming constructs. </title> <booktitle> In Proc. North American Logic Programming Conference (1989). </booktitle>
Reference-contexts: The argument of 2 will always be a ground atom. 36 Instances of the meta-predicates described above may be thought of as atoms in the logic called HiLog <ref> [12] </ref>.
Reference: [13] <author> Dietrich, S., and Warren, D. S. </author> <title> Dynamic programming strategies for the evaluation of recursive queries. </title> <type> Tech. Rep. 85/31, </type> <institution> Computer Science Department, State University of New York at Stony Brook, </institution> <year> 1985. </year>
Reference-contexts: This recursive construction must be complete in order to apply the definition. 21 4.3 Top-Down with Memoing Global SLS-resolution may get lost down an infinite positive branch and hence not terminate. Several authors <ref> [13, 36, 37] </ref> have considered this problem in the context of Horn programs, and have proposed a form of memoing in which a positive literal is not "admissible" for selection if it is an instance of one of its ancestors.
Reference: [14] <author> Gelfond, M., and Lifschitz, V. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming (1988). </booktitle>
Reference-contexts: A stratified program is one in which, effectively, there is no predicate that depends negatively on itself. Recent work [17] has shown that there are interesting logic programs that are not strat-ifiable but for which a natural, unambiguous semantics exists. The well-founded semantics [35] and the stable model semantics <ref> [14] </ref> are two (closely related) proposals for defining the semantics of logic programs, whether stratified or not. For stratified programs they both coincide with the perfect model semantics. The well-founded semantics is a three-valued semantics. Literals may be true, false or undefined. <p> Then R M (F ), as given in Example 3.3 is locally stratified, and so P is modularly stratified. Note that P itself is not locally stratified. 2 Our definition of reduction also bears some similarity to the stability transformation of Gelfond and Lifschitz <ref> [14] </ref>. If the well-founded model for a component is total, then that model is also its unique stable model.
Reference: [15] <author> Kemp, D. B., and Topor, R. W. </author> <title> Completeness of a top down query evaluation procedure for stratified databases. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming (1988). </booktitle>
Reference-contexts: Kemp and Topor, and Seki and Itoh have proposed (similar) extensions of the QSQR/SLD 2 top-down query evaluation procedure of Vieille [36, 37] from Horn programs to the class of stratified programs <ref> [15, 32] </ref>. We further generalize their methods, called QSQR/SLS-resolution in [15], to the class of modularly stratified programs. In the absence of negation, bottom-up computation may be made at least as efficient as a top-down method without memoing by the use of magic sets [33]. <p> Kemp and Topor, and Seki and Itoh have proposed (similar) extensions of the QSQR/SLD 2 top-down query evaluation procedure of Vieille [36, 37] from Horn programs to the class of stratified programs [15, 32]. We further generalize their methods, called QSQR/SLS-resolution in <ref> [15] </ref>, to the class of modularly stratified programs. In the absence of negation, bottom-up computation may be made at least as efficient as a top-down method without memoing by the use of magic sets [33]. Several authors have considered the problem of extending the magic sets method to stratified programs. <p> Several authors [13, 36, 37] have considered this problem in the context of Horn programs, and have proposed a form of memoing in which a positive literal is not "admissible" for selection if it is an instance of one of its ancestors. Kemp and Topor <ref> [15] </ref> and, independently, Seki and Itoh [32] have generalized these proposals to the class of stratified programs. Our method applies to a larger class of programs, namely those programs that have finite negation trees, and still retains soundness, completeness and termination properties. In particular, our method applies to permissible programs. <p> In particular, our method applies to permissible programs. Kemp and Topor called their method the "QSQR/SLS-procedure." We now present our extension, which we also call the QSQR/SLS-procedure. While our method is similar to <ref> [15] </ref>, there are several differences that we shall explain after giving the definitions. Our version of the QSQR/SLS procedure, given in Algorithm 4.1, is presented in such a way that the comparison with bottom-up evaluation will be clearer later on. <p> Our method is motivated my the memoing technique of Section 4.2. In the query evaluation procedure described below we will "memo" those facts that we have already derived so that we can re-use them in other parts of the computation. We memo all IDB predicates; in the terminology of <ref> [15] </ref>, the set of "r-predicates" is the set of all IDB predicates. Following [15], we shall refer to literals that have been derived at an intermediate stage of the computation as lemmas. <p> We memo all IDB predicates; in the terminology of <ref> [15] </ref>, the set of "r-predicates" is the set of all IDB predicates. Following [15], we shall refer to literals that have been derived at an intermediate stage of the computation as lemmas. <p> Thus there are no "depends negatively" facts remaining after Algorithm 4.1 is run on a program with finite negation trees. We now explain the major differences between Algorithm 4.1 and the algorithms presented in <ref> [15] </ref> and [32]. The first difference is in how the lemmas are established. In [15], "proof segments" of SLD-type trees are employed rather than derivation trees. <p> Thus there are no "depends negatively" facts remaining after Algorithm 4.1 is run on a program with finite negation trees. We now explain the major differences between Algorithm 4.1 and the algorithms presented in <ref> [15] </ref> and [32]. The first difference is in how the lemmas are established. In [15], "proof segments" of SLD-type trees are employed rather than derivation trees. In [32] they are called "sub-refutations." The definition of proof segments is complicated by the fact that subsidiary information about other subgoals is embedded in the trees. <p> Our dynamic approach has the advantage that only those subgoals that do depend negatively on lower-level subgoals are suspended, while other subgoals can be expanded during that time. Unlike <ref> [15] </ref> and [32], our method distinguishes between EDB subgoals and IDB subgoals, using simple look-ups for EDB subgoals rather than performing resolution on them. A more technical difference occurs in step 3 of our algorithm. In [15] and other similar work on top-down methods with memoing [31, 32] it is possible <p> Unlike <ref> [15] </ref> and [32], our method distinguishes between EDB subgoals and IDB subgoals, using simple look-ups for EDB subgoals rather than performing resolution on them. A more technical difference occurs in step 3 of our algorithm. In [15] and other similar work on top-down methods with memoing [31, 32] it is possible to generate a subquery at a certain point, and at a later point in the same round generate a more general subquery, in which computation is repeated.
Reference: [16] <author> Kerisit, J. M., and Pugin, J. M. </author> <title> Efficient query answering on stratified databases. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems (1988). </booktitle>
Reference-contexts: These constraints ensure that a subgoal is "fully evaluated" before a predicate depending negatively on that subgoal is considered. Kerisit and Pugin also consider extending magic sets to programs with stratified negation <ref> [16] </ref>. They define a property called weak stratification 1 and demonstrate that the magic rewriting of a stratified program must be weakly stratified.
Reference: [17] <author> Kolaitis, P. G. </author> <title> The expressive power of stratified programs. </title> <booktitle> Information and Computation 90 (1991), </booktitle> <pages> 50-66. </pages>
Reference-contexts: Unfortunately, the perfect model semantics applies only to programs that are stratified (or locally stratified). A stratified program is one in which, effectively, there is no predicate that depends negatively on itself. Recent work <ref> [17] </ref> has shown that there are interesting logic programs that are not strat-ifiable but for which a natural, unambiguous semantics exists. The well-founded semantics [35] and the stable model semantics [14] are two (closely related) proposals for defining the semantics of logic programs, whether stratified or not. <p> P is a game-playing program <ref> [17] </ref> in which a position X is "winning" [w (X)] if there is a move from X to a position Y [m (X; Y )] and Y is a losing position [:w (Y )]. P is not stratified or even locally stratified. In fact Kolaitis [17] has shown that no stratified <p> P is a game-playing program <ref> [17] </ref> in which a position X is "winning" [w (X)] if there is a move from X to a position Y [m (X; Y )] and Y is a losing position [:w (Y )]. P is not stratified or even locally stratified. In fact Kolaitis [17] has shown that no stratified function-free program can express the intended semantics of P . The intuition behind this expressiveness result is that stratified programs have a fixed number of strata through which one can recurse through negation.
Reference: [18] <author> Lloyd, J. W. </author> <booktitle> Foundations of Logic Programming, 2nd ed. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: Kerisit and Pugin define weak stratification by removing from the conditions on stratified programs the restriction that positive literals in the body have level no higher than the level of the head. 3 2 Terminology We consider normal logic programs without function symbols 2 <ref> [18] </ref>, also known as "Datalog" programs with negation. Definition 2.1: A term is either a variable or a constant symbol. If p is an n-ary predicate symbol and t 1 ; ; t n are terms then p (t 1 ; ; t n ) is an atom. <p> In fact, as shown in Example 2.1, this program is weakly stratified. Suppose we try to answer the query ? p (a) top-down using a subgoal-at-a-time method such as SLDNF-resolution <ref> [18] </ref>. We assume left to right evaluation. We expand the first rule, using the first t rule for the first subgoal, yielding :p (b) as the second subgoal. p (b) succeeds, and hence :p (b) fails, so we backtrack to the second rule for t. <p> An evaluation method is said to flounder if it selects for expansion a negative literal with one or more unbound variables. There are several semantic difficulties associated with floundering; the interested reader is referred to <ref> [18] </ref> for further discussion. Example 3.8: Consider the program t (a; a) q (X) t (X; Y ); :t (Y; Z); p (Z) which is modularly stratified from left to right. <p> If no data items are new, then nothing is lost by omitting the step since the step must have been performed on a previous iteration. 29 4.5 Comparison with SLDNF-Resolution SLDNF-resolution is a top-down resolution-based method that does not perform any mem-oing <ref> [18] </ref>. Hence it will be informative to compare our memoing method with SLDNF-resolution. In Example 4.3 we have seen how QSQR/SLS-resolution would answer the query ?p (18), i.e., "Is 18 the product of an odd number of primes?" The final derivation trees are given in computation.
Reference: [19] <author> Phipps, G. </author> <title> Glue: A deductive database programming language. </title> <type> Tech. Rep. </type> <institution> TR-CS-90-14, Kansas State University, </institution> <year> 1990. </year> <booktitle> Proceedings of the NACLP'90 Workshop on Deductive Databases. </booktitle>
Reference-contexts: However, if function symbols are recursively applied, then termination cannot be guaranteed. With a slight change of syntax, the rewritten program of Algorithm 5.1 may be interpreted as statements in the database programming language Glue <ref> [19, 20] </ref>. In fact, Algorithm 5.1 is the basis of a compiler that has been implemented by the author and others as part of the NAIL! system at Stanford University. The class of modularly stratified programs has also been adopted for use in the CORAL deductive database programming language [27].
Reference: [20] <author> Phipps, G., Derr, M., and Ross, K. A. </author> <title> Glue-Nail: A deductive database system. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data (1991). </booktitle>
Reference-contexts: However, if function symbols are recursively applied, then termination cannot be guaranteed. With a slight change of syntax, the rewritten program of Algorithm 5.1 may be interpreted as statements in the database programming language Glue <ref> [19, 20] </ref>. In fact, Algorithm 5.1 is the basis of a compiler that has been implemented by the author and others as part of the NAIL! system at Stanford University. The class of modularly stratified programs has also been adopted for use in the CORAL deductive database programming language [27].
Reference: [21] <author> Przymusinska, H., and Przymusinski, T. C. </author> <title> Weakly stratified logic programs. </title> <note> Funda-menta Informaticae 13 (1990), 51-65. Preliminary version appeared in Proc. Fifth International Conference and Symposium on Logic Programming, </note> <year> 1988. </year>
Reference-contexts: In many cases, two truth values suffice to model the situation under consideration. So we desire a condition on the program, more general than stratification, that ensures that the well-founded semantics is two-valued. Recently Przymusinska and Przymusinski <ref> [21] </ref> have isolated the class of weakly stratified programs as such a class. <p> the well-founded model is, in general, a "three-valued model." A ground atom A may appear positively, negatively or not at all in the well-founded model. 3 For a justification that it is a partial model see [35]. 5 2.2 Weak Stratification We now present the concept of weak stratification from <ref> [21] </ref>. In the definitions below, the program P is assumed to be ground. In order to apply these definitions to a program with variables, one must first take the instantiation of the program with respect to the universe U . Definition 2.5: (Dependency graph) Let P be a ground program. <p> 2.6: Let ~ P be the equivalence relation between ground atoms defined as follows: A ~ P B if and only if (A = B) _ (A &lt; P B ^ B &lt; P A) We shall refer to the equivalence classes induced by ~ P simply as "classes." (In <ref> [21] </ref> they are called components.) We say a class is trivial if it consists of one element, say A, and A 6&lt; P A. Let C 1 and C 2 be classes. <p> Define L (P ) to be the set of rules from P whose heads belong to S (P ). 2 The relation ~ P denotes either equality or mutual negative dependence. That P is a partial order is shown in <ref> [21] </ref>. Definition 2.7: Let M be a partial interpretation for P , i.e., a consistent set of literals whose atoms are in B P . The reduction of P modulo M is a new program P 0 obtained from P by performing the following operations: 1. <p> the construction stops: P is not weakly stratified. * Otherwise, the partial interpretation M ff is defined as the least model (restricted to literals whose atoms are in S (P ff )) of the "bottom layer rules" L (P ff ) of P ff and the construction continues. 2 In <ref> [21] </ref> it is shown that if a program is weakly stratified, then the model N ff given in the construction above is the 2-valued well-founded model. <p> For example, the game program from Example 3.1 above is modularly stratified if and only if m is acyclic. This property is unlike stratification, for example, where checking that a program is stratified can be done syntactically. We now show that modularly stratified programs are also weakly stratified <ref> [21] </ref>. 11 Theorem 3.1: Every modularly stratified program is weakly stratified. Proof : It is not difficult to show that a program P is weakly stratified if and only if, for every component F of P , 1. <p> There is a total well-founded model M for the union of all components F 0 F , and 2. The reduction of F modulo M is weakly stratified. Since all locally stratified programs are weakly stratified <ref> [21] </ref>, we can show by induction on the level of components that modularly stratified programs are weakly stratified. The converse of Theorem 3.1 is false, as illustrated by Example 3.2. Also, every stratified program is modularly stratified, as is every locally stratified program. <p> Also, every stratified program is modularly stratified, as is every locally stratified program. Corollary 3.2: Every modularly stratified program has a total well-founded model that is its unique stable model. Proof : Since this property holds for weakly stratified programs <ref> [21] </ref>. To see how the well-founded model of a program may be composed from those of its components, recall that a locally stratified program has a unique perfect model [22] and hence a total well-founded model that coincides with the perfect model.
Reference: [22] <author> Przymusinski, T. C. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <booktitle> In Foundations of Deductive Databases and Logic Programming (Los Altos, </booktitle> <address> CA, </address> <year> 1988), </year> <editor> J. Minker, Ed., </editor> <publisher> Morgan Kaufmann, </publisher> <pages> pp. 193-216. </pages>
Reference-contexts: 1 Introduction Much recent work has concerned defining the semantics of negation in deductive databases. The "perfect model semantics" <ref> [22] </ref> has been generally accepted as natural, and is the basis for several experimental deductive database systems. Unfortunately, the perfect model semantics applies only to programs that are stratified (or locally stratified). A stratified program is one in which, effectively, there is no predicate that depends negatively on itself. <p> Proof : Since this property holds for weakly stratified programs [21]. To see how the well-founded model of a program may be composed from those of its components, recall that a locally stratified program has a unique perfect model <ref> [22] </ref> and hence a total well-founded model that coincides with the perfect model. The "lowest" components must be locally stratified; compute their perfect model M .
Reference: [23] <author> Przymusinski, T. C. </author> <title> Every logic program has a natural stratification and an iterated fixed point model. </title> <booktitle> In ACM Symposium on Principles of Database Systems (1989). </booktitle>
Reference-contexts: Modifying the top-down and bottom-up methods, described in later sections, for arbitrary sips is beyond the scope of this paper. 4 Top-Down Evaluation 4.1 Global SLS-Resolution In this section we present a variant of the top-down method called "global SLS-resolution" from [30]. A similar method was independently proposed in <ref> [23] </ref>. The version presented here is slightly different from the one appearing in [30]. In this paper we will restrict ourselves to a left-to-right computation rule, so that the leftmost subgoal is always selected. This will allow us to compare bottom-up and top-down methods using the same order of evaluation.
Reference: [24] <author> Przymusinski, T. C. </author> <title> On constructive negation in logic programming. </title> <booktitle> In Proceedings, North American Conference on Logic Programming (1989). </booktitle>
Reference-contexts: By placing this predicate to the left of each floundering subgoal, one can prevent floundering without losing any expressive power. An alternative approach, which merits further research, would be to incorporate constructive negation <ref> [11, 24] </ref> into the evaluation mechanisms proposed in this paper. Nevertheless, the author believes that programs that cannot be rearranged into permissible versions will be rare in practice. Passing bindings from left to right is one of many possible "sideways information passing strategies" (sips) that could be used [6].
Reference: [25] <author> Ramakrishnan, R. </author> <title> Magic templates: A spellbinding approach to logic programs. </title> <journal> Journal of Logic Programming 11 (1991), </journal> <pages> 189-216. </pages>
Reference-contexts: Top-down evaluation can beat bottom-up evaluation of the original program because it can restrict the computation to only those tuples relevant 31 to the query. This problem is now well-understood for programs without negation, and several techniques have been proposed [5]. One of these is magic sets <ref> [4, 6, 25] </ref>, which rewrites the program in such a way that the binding information that would have been passed down by a top-down method is incorporated into the bottom-up evaluation. <p> In Section 5.3 we describe a magic set method for evaluating modularly stratified programs bottom-up. In particular, this method also works for stratified programs. Our method extends the magic templates method of <ref> [25] </ref> rather than the original magic sets proposals. Before we introduce the magic set transformation, we describe a transformation of the program whose bottom-up evaluation is sound and complete with respect to the well-founded semantics for nonfloundering programs with finite negation trees, and in particular, for permissible programs. <p> We shall present a magic set rewriting that significantly reduces the amount of work that needs to be done. Using magic predicates in the body restricts the tuples generated during the bottom-up computation to those that are relevant. We use a version of the magic templates method <ref> [25] </ref> that is also described in [34]. The magic set method presented in the preliminary version of this paper [28] is not quite the best possible one in the sense that the depends relations can be unnecessarily large. Also, effort can be saved by using supplementary relations. <p> As a result, there are rules (namely those for dp, dn 0 and 2P ) that never fire. If one was to delete those rules, the remaining rules constitute rules isomorphic to the standard magic templates transformed rules <ref> [25] </ref>. Thus the overhead in Algorithm 5.1 consists entirely of repeatedly attempting to join an empty relation with another relation in the body of the rules mentioned above. <p> We will thus be able to demonstrate that the two algorithms have the same complexity. Note that our claim is stronger than the more common claim that various methods infer the same sets of tuples. Some authors have considered the issue of "sip-optimality" <ref> [25, 31] </ref>. Informally, a bottom-up method is sip-optimal if it infers no more facts about any predicate from the original program that a top-down method would.
Reference: [26] <author> Ramakrishnan, R., Srivastava, D., and Sudarshan, S. </author> <title> Rule ordering in bottom-up fixpoint evaluation of logic programs. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases (1990). </booktitle>
Reference-contexts: In practice, rule order can affect the number of rounds before the iteration converges. Such issues are discussed in <ref> [26] </ref>. One may ask whether there is significant overhead involved in using the magic sets method presented here rather than standard magic sets for programs without negation. One can verify that for programs without negation, Algorithm 5.1 produces no tuples of the form magic (P; ).
Reference: [27] <author> Ramakrishnan, R., Srivastava, D., and Sudarshan, S. </author> <title> Coral: A deductive database programming language. </title> <booktitle> In Proc. 18th Int. Conf. on Very Large Databases (Vancouver, </booktitle> <address> Canada, </address> <month> Aug. </month> <year> 1992). </year>
Reference-contexts: In fact, Algorithm 5.1 is the basis of a compiler that has been implemented by the author and others as part of the NAIL! system at Stanford University. The class of modularly stratified programs has also been adopted for use in the CORAL deductive database programming language <ref> [27] </ref>. Acknowledgements I would like to thank Shuky Sagiv, Rodney Topor and Jeff Ullman for comments on earlier versions of this paper. The anonymous referees made many helpful suggestions to improve the presentation of this paper.
Reference: [28] <author> Ross, K. A. </author> <title> Modular stratification and magic sets for Datalog programs with negation. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems (1990). </booktitle>
Reference-contexts: Using magic predicates in the body restricts the tuples generated during the bottom-up computation to those that are relevant. We use a version of the magic templates method [25] that is also described in [34]. The magic set method presented in the preliminary version of this paper <ref> [28] </ref> is not quite the best possible one in the sense that the depends relations can be unnecessarily large. Also, effort can be saved by using supplementary relations. In this section we introduce a magic sets method that uses supplementary predicates.
Reference: [29] <author> Ross, K. A. </author> <title> Modular acyclicity and tail recursion in logic programs. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems (1991). </booktitle>
Reference-contexts: SLDNF-resolution is not guaranteed to terminate. In particular, it may get into an infinite loop with recursive programs. QSQR/SLS-resolution always terminates for function-free programs. There are some situations where SLDNF-resolution is more efficient than QSQR/SLS-resolution. The following example is taken from <ref> [29] </ref>. Example 4.4: Let P be p (X; Z) e (X; Y ); p (Y; Z) e (1; 2) e (n 1; n) . . . <p> By contrast, QSQR/SLS-resolution would memo all the intermediate subgoals p (i; X) for i = 2; : : : n, computing m lemmas for each. Hence QSQR/SLS-resolution computes fi (mn) tuples, and is less efficient to SLDNF-resolution on this example. 2 In <ref> [29] </ref>, improvements to the magic sets method are given that make magic-sets competitive on examples like this. As we shall see later, there is a very close relationship between QSQR/SLS-resolution and magic sets, and improvements corresponding to those suggested in [29] could be applied to QSQR/SLS-resolution. 5 Bottom-Up Evaluation It is <p> is less efficient to SLDNF-resolution on this example. 2 In <ref> [29] </ref>, improvements to the magic sets method are given that make magic-sets competitive on examples like this. As we shall see later, there is a very close relationship between QSQR/SLS-resolution and magic sets, and improvements corresponding to those suggested in [29] could be applied to QSQR/SLS-resolution. 5 Bottom-Up Evaluation It is desirable to have a bottom-up alternative to global SLS-resolution, which is top-down. Bottom-up methods have the potential to work in a relation-at-a-time fashion, using efficient methods to compute large joins.
Reference: [30] <author> Ross, K. A. </author> <title> A procedural semantics for well-founded negation in logic programs. </title> <journal> Journal of Logic Programming 13, </journal> <volume> 1 (1992), </volume> <pages> 1-22. </pages> <note> Preliminary version appeared in the Proceedings of the Eighth ACM Symposium on Principles of Database Systems, </note> <year> 1989. </year>
Reference-contexts: Weak stratifiability is such a condition, and as we shall see, all modularly stratified programs are weakly stratified. 3.1 Subgoal-at-a-Time Evaluation There is another important issue, apart from having a 2-valued semantics, namely the ordering of literals in the body of rules. As observed in <ref> [30] </ref> any top-down implementation of the well-founded semantics needs to expand negative literals in parallel so that we don't loop infinitely through negation when another subgoal fails. 9 Example 3.2: Consider the program p (X) t (X; Y; Z); :p (Y ); :p (Z) t (a; a; b) from Example 2.1 <p> Modifying the top-down and bottom-up methods, described in later sections, for arbitrary sips is beyond the scope of this paper. 4 Top-Down Evaluation 4.1 Global SLS-Resolution In this section we present a variant of the top-down method called "global SLS-resolution" from <ref> [30] </ref>. A similar method was independently proposed in [23]. The version presented here is slightly different from the one appearing in [30]. In this paper we will restrict ourselves to a left-to-right computation rule, so that the leftmost subgoal is always selected. <p> sips is beyond the scope of this paper. 4 Top-Down Evaluation 4.1 Global SLS-Resolution In this section we present a variant of the top-down method called "global SLS-resolution" from <ref> [30] </ref>. A similar method was independently proposed in [23]. The version presented here is slightly different from the one appearing in [30]. In this paper we will restrict ourselves to a left-to-right computation rule, so that the leftmost subgoal is always selected. This will allow us to compare bottom-up and top-down methods using the same order of evaluation. <p> If the ground atom A is a child of H in a negation tree, there must be some branch in T H to a node that has :A as the leftmost literal. We now define a restricted version of Global SLS-resolution from <ref> [30] </ref>. <p> A formulation of a top-down method that is guaranteed to terminate is presented in Section 4.3. 18 Theorem 4.1: Global SLS-resolution (as defined in Definition 4.3) is both sound and com-plete for non-floundering programs with finite-depth negation trees. Proof : The proof follows from the corresponding results in <ref> [30] </ref>. Since the negation tree is finite, there is no infinite recursion through negation, and so every goal is either successful or failed. To get soundness and completeness in general, one must use the more general method of [30], and avoid a purely left-to-right computation rule. <p> Proof : The proof follows from the corresponding results in <ref> [30] </ref>. Since the negation tree is finite, there is no infinite recursion through negation, and so every goal is either successful or failed. To get soundness and completeness in general, one must use the more general method of [30], and avoid a purely left-to-right computation rule. In this paper we will look for sufficient conditions for negation trees to have finite depth, so that we do not need to consider indeterminate derivations. Permissibility is one such condition, as illustrated by the following theorem.
Reference: [31] <author> Seki, H. </author> <title> On the power of alexander templates. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems (1989). </booktitle>
Reference-contexts: Unlike [15] and [32], our method distinguishes between EDB subgoals and IDB subgoals, using simple look-ups for EDB subgoals rather than performing resolution on them. A more technical difference occurs in step 3 of our algorithm. In [15] and other similar work on top-down methods with memoing <ref> [31, 32] </ref> it is possible to generate a subquery at a certain point, and at a later point in the same round generate a more general subquery, in which computation is repeated. For example, suppose we encounter the selected atom p (X; X). <p> We will thus be able to demonstrate that the two algorithms have the same complexity. Note that our claim is stronger than the more common claim that various methods infer the same sets of tuples. Some authors have considered the issue of "sip-optimality" <ref> [25, 31] </ref>. Informally, a bottom-up method is sip-optimal if it infers no more facts about any predicate from the original program that a top-down method would. <p> Proof : By Theorem 6.1 and Theorem 4.6. In particular, Corollary 6.2 holds for all permissible programs. Corollary 6.3: The semi-naive bottom-up computation of SMR (P) has the same time complexity as QSQR/SLS. Seki <ref> [31] </ref> demonstrates a similar correspondence to that of Theorem 6.1 in the context of (not necessarily range-restricted) programs without negation. Ignoring our extension to programs with negation, our procedures are slightly different from Seki's: we use regional duplicate elimination while Seki uses incremental duplicate elimination.
Reference: [32] <author> Seki, H., and Itoh, H. </author> <title> A query evaluation method for stratified programs under the extended CWA. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming (1988). </booktitle>
Reference-contexts: Kemp and Topor, and Seki and Itoh have proposed (similar) extensions of the QSQR/SLD 2 top-down query evaluation procedure of Vieille [36, 37] from Horn programs to the class of stratified programs <ref> [15, 32] </ref>. We further generalize their methods, called QSQR/SLS-resolution in [15], to the class of modularly stratified programs. In the absence of negation, bottom-up computation may be made at least as efficient as a top-down method without memoing by the use of magic sets [33]. <p> Kemp and Topor [15] and, independently, Seki and Itoh <ref> [32] </ref> have generalized these proposals to the class of stratified programs. Our method applies to a larger class of programs, namely those programs that have finite negation trees, and still retains soundness, completeness and termination properties. In particular, our method applies to permissible programs. <p> Thus there are no "depends negatively" facts remaining after Algorithm 4.1 is run on a program with finite negation trees. We now explain the major differences between Algorithm 4.1 and the algorithms presented in [15] and <ref> [32] </ref>. The first difference is in how the lemmas are established. In [15], "proof segments" of SLD-type trees are employed rather than derivation trees. In [32] they are called "sub-refutations." The definition of proof segments is complicated by the fact that subsidiary information about other subgoals is embedded in the trees. <p> We now explain the major differences between Algorithm 4.1 and the algorithms presented in [15] and <ref> [32] </ref>. The first difference is in how the lemmas are established. In [15], "proof segments" of SLD-type trees are employed rather than derivation trees. In [32] they are called "sub-refutations." The definition of proof segments is complicated by the fact that subsidiary information about other subgoals is embedded in the trees. In our case, every derivation tree contains only information relevant to the subgoal at the root of the tree. <p> Our dynamic approach has the advantage that only those subgoals that do depend negatively on lower-level subgoals are suspended, while other subgoals can be expanded during that time. Unlike [15] and <ref> [32] </ref>, our method distinguishes between EDB subgoals and IDB subgoals, using simple look-ups for EDB subgoals rather than performing resolution on them. A more technical difference occurs in step 3 of our algorithm. <p> Unlike [15] and [32], our method distinguishes between EDB subgoals and IDB subgoals, using simple look-ups for EDB subgoals rather than performing resolution on them. A more technical difference occurs in step 3 of our algorithm. In [15] and other similar work on top-down methods with memoing <ref> [31, 32] </ref> it is possible to generate a subquery at a certain point, and at a later point in the same round generate a more general subquery, in which computation is repeated. For example, suppose we encounter the selected atom p (X; X).
Reference: [33] <author> Ullman, J. D. </author> <title> Bottom-up beats top-down for datalog. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems (1989). </booktitle>
Reference-contexts: We further generalize their methods, called QSQR/SLS-resolution in [15], to the class of modularly stratified programs. In the absence of negation, bottom-up computation may be made at least as efficient as a top-down method without memoing by the use of magic sets <ref> [33] </ref>. Several authors have considered the problem of extending the magic sets method to stratified programs. The approach of [1, 2] is to relabel predicates in a stratified program in such a way that the magic transformation results in a stratified program. <p> In fact, for Datalog programs without negation, semi-naive bottom-up evaluation of the rewritten program performs at least as well as a straightforward top-down method <ref> [33] </ref>. In Section 5.3 we describe a magic set method for evaluating modularly stratified programs bottom-up. In particular, this method also works for stratified programs. Our method extends the magic templates method of [25] rather than the original magic sets proposals.
Reference: [34] <author> Ullman, J. D. </author> <title> Principles of Database and Knowledge Base Systems. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year> <title> (Two volumes). </title> <type> 52 </type>
Reference-contexts: We present a magic sets transformation for modularly stratified programs that enables efficient computation bottom-up. In fact, we demonstrate a one-to-one correspondence between steps of our extension of QSQR/SLS-resolution and our magic-sets method. See <ref> [34] </ref> for a discussion of why bottom-up methods are likely to be preferable to top-down methods. 1 This concept is different from Przymusinska and Przymusinski's definition of weak stratification, and was proposed independently. <p> Every predicate has a unique minimal complete component to which it belongs. A program may be broken up into complete components according to the equivalence classes (called strongly connected components in <ref> [34] </ref>) induced on the predicates. <p> Bottom-up methods have the potential to work in a relation-at-a-time fashion, using efficient methods to compute large joins. See <ref> [34] </ref> for further discussion on the relative merits of top-down versus bottom-up methods. 5.1 Naive and Semi-Naive Evaluation "Naive" and "semi-naive" bottom-up evaluation of rules for programs without negation are now standard concepts in deductive databases [34]. <p> See <ref> [34] </ref> for further discussion on the relative merits of top-down versus bottom-up methods. 5.1 Naive and Semi-Naive Evaluation "Naive" and "semi-naive" bottom-up evaluation of rules for programs without negation are now standard concepts in deductive databases [34]. While we shall rely on semi-naive evaluation, there is one subtlety that arises due to the presence of variables. <p> Using magic predicates in the body restricts the tuples generated during the bottom-up computation to those that are relevant. We use a version of the magic templates method [25] that is also described in <ref> [34] </ref>. The magic set method presented in the preliminary version of this paper [28] is not quite the best possible one in the sense that the depends relations can be unnecessarily large. Also, effort can be saved by using supplementary relations. <p> We now define the supplementary magic rewriting of a program. We base our presentation on <ref> [34] </ref>. Definition 5.3: (Supplementary magic rewriting) Let P be a program. The supplementary magic rewriting of P , denoted SMR (P), contains three sets of rules, denoted P 0 , P 1 and P 2 . <p> Using this data structure will allow us to avoid recomputing the implication inside the universal quantifier every time P 2 is executed. Note that P 2 converges in one step since it is not recursive. As noted in <ref> [34] </ref>, we can further optimize the rewriting in several ways. For example, since there is only one rule for each sup j:0 , and each such rule has only one subgoal, we could substitute the body of the rule directly into every place that sup j:0 is used. <p> To achieve such a program, occurrences of the same predicate should be renamed apart if they have different binding patterns; also, subgoal rectification is necessary for subgoals with repeated variables. See <ref> [34] </ref> for details of how renaming and rectification are done. With our assumption about unique binding patterns, we can specialize the magic, dp and dn meta predicates so that their arguments contain only the bound variables from the 40 original rules.
Reference: [35] <author> Van Gelder, A., Ross, K. A., and Schlipf, J. S. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <journal> JACM 38, </journal> <volume> 3 (1991), </volume> <pages> 620-650. </pages>
Reference-contexts: A stratified program is one in which, effectively, there is no predicate that depends negatively on itself. Recent work [17] has shown that there are interesting logic programs that are not strat-ifiable but for which a natural, unambiguous semantics exists. The well-founded semantics <ref> [35] </ref> and the stable model semantics [14] are two (closely related) proposals for defining the semantics of logic programs, whether stratified or not. For stratified programs they both coincide with the perfect model semantics. The well-founded semantics is a three-valued semantics. Literals may be true, false or undefined. <p> Such issues are beyond the scope of this paper, and the reader is referred to <ref> [35] </ref> and the references therein for further discussion. For range restricted programs, the choice of U does not affect what is true according to their well-founded semantics. <p> of strictly higher level, and whenever a ground atom appears positively in the body of an instantiated rule, the atom in the head has at least that level. 2.1 The Well-Founded Semantics We now give a brief presentation of the well-founded semantics; for a more complete presentation with examples see <ref> [35] </ref>. Definition 2.2: Let P be a program and let H be the set of ground instances of predicates from P with respect to U . Let I be a consistent set of ground literals whose atoms are in H. <p> call this least fixpoint the well-founded (partial) model of P . 3 Note that the well-founded model is, in general, a "three-valued model." A ground atom A may appear positively, negatively or not at all in the well-founded model. 3 For a justification that it is a partial model see <ref> [35] </ref>. 5 2.2 Weak Stratification We now present the concept of weak stratification from [21]. In the definitions below, the program P is assumed to be ground. <p> Vieille shows that top-down with memoing (with a restricted, but not necessarily left-to-right order of expansion of subgoals) is correct with respect to the least Herbrand model. For programs without negation, the least Herbrand model is the two-valued well-founded model <ref> [35] </ref>. Theorem 4.6: (Correctness) Let P be a range-restricted nonfloundering program having finite negation trees. Let L be a literal, (ground if negative), and let the query be ?-L.
Reference: [36] <author> Vieille, L. </author> <title> Recursive axioms in deductive databases: The query-subquery approach. </title> <booktitle> In Proc. First International Conference on Expert Database Systems (1986). </booktitle>
Reference-contexts: Kemp and Topor, and Seki and Itoh have proposed (similar) extensions of the QSQR/SLD 2 top-down query evaluation procedure of Vieille <ref> [36, 37] </ref> from Horn programs to the class of stratified programs [15, 32]. We further generalize their methods, called QSQR/SLS-resolution in [15], to the class of modularly stratified programs. <p> This recursive construction must be complete in order to apply the definition. 21 4.3 Top-Down with Memoing Global SLS-resolution may get lost down an infinite positive branch and hence not terminate. Several authors <ref> [13, 36, 37] </ref> have considered this problem in the context of Horn programs, and have proposed a form of memoing in which a positive literal is not "admissible" for selection if it is an instance of one of its ancestors.
Reference: [37] <author> Vieille, L. </author> <title> A database-complete proof procedure based on SLD-resolution. </title> <booktitle> In Proc. Fourth International Conference on Logic Programming (1987). </booktitle> <pages> 53 </pages>
Reference-contexts: Kemp and Topor, and Seki and Itoh have proposed (similar) extensions of the QSQR/SLD 2 top-down query evaluation procedure of Vieille <ref> [36, 37] </ref> from Horn programs to the class of stratified programs [15, 32]. We further generalize their methods, called QSQR/SLS-resolution in [15], to the class of modularly stratified programs. <p> This recursive construction must be complete in order to apply the definition. 21 4.3 Top-Down with Memoing Global SLS-resolution may get lost down an infinite positive branch and hence not terminate. Several authors <ref> [13, 36, 37] </ref> have considered this problem in the context of Horn programs, and have proposed a form of memoing in which a positive literal is not "admissible" for selection if it is an instance of one of its ancestors. <p> Lemma 4.5: For Datalog programs without negation, Algorithm 4.1 is correct with respect to the well-founded semantics. Proof : See the proof of Theorem 4.6 below. Lemma 4.5 is a special case of a result of Vieille <ref> [37] </ref>. Vieille shows that top-down with memoing (with a restricted, but not necessarily left-to-right order of expansion of subgoals) is correct with respect to the least Herbrand model. For programs without negation, the least Herbrand model is the two-valued well-founded model [35].
References-found: 37

