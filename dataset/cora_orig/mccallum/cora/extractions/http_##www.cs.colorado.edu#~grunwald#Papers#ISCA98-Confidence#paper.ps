URL: http://www.cs.colorado.edu/~grunwald/Papers/ISCA98-Confidence/paper.ps
Refering-URL: http://www.cs.colorado.edu/~klauser/publications.html
Root-URL: http://www.cs.colorado.edu
Email: fgrunwald,klauserg@cs.colorado.edu  fbobbie,arpg@cs.colorado.edu  
Title: Confidence Estimation for Speculation Control  
Author: Dirk Grunwald and Artur Klauser Srilatha Manne and Andrew Pleszkun 
Address: Campus Box 430  Boulder, CO 80309  Campus Box 425  Boulder, CO 80309  
Affiliation: Department of Computer Science  University of Colorado  Department of Electrical and Computer Engineering  University of Colorado  
Abstract: Modern processors improve instruction level parallelism by speculation. The outcome of data and control decisions is predicted, and the operations are speculatively executed and only committed if the original predictions were correct. There are a number of other ways that processor resources could be used, such as threading or eager execution. As the use of speculation increases, we believe more processors will need some form of speculation control to balance the benefits of speculation against other possible activities. Confidence estimation is one technique that can be exploited by architects for speculation control. In this paper, we introduce performance metrics to compare confidence estimation mechanisms, and argue that these metrics are appropriate for speculation control. We compare a number of confidence estimation mechanisms, focusing on mechanisms that have a small implementation cost and gain benefit by exploiting characteristics of branch predictors, such as clustering of mispredicted branches. We compare the performance of the different confidence estimation methods using detailed pipeline simulations. Using these simulations, we show how to improve some confidence estimators, providing better insight for future investigations comparing and applying confidence estimators. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Arnold Allen. </author> <title> Probability, </title> <journal> Statistics, and Queuing Theory, </journal> <pages> pages 2434. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: We close with a discussion of temporal aspects of branch predictors and how they can be exploited to improve confidence estimation. 1.1 Diagnostic Tests The following description is adapted from a paper by Gastwirth [4], as described in <ref> [1] </ref>. A diagnostic test is used to determine if an individual belongs to a class D of people that have a particular disease, or to the class of people who do not have the disease, D.
Reference: [2] <author> Doug Burger, Todd M. Austin, and Steve Bennett. </author> <title> Evaluating future microprocessors: The simplescalar tool set. </title> <type> Technical Report TR#1308, </type> <institution> University of Wisconsin, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: Later, we compare these methods when using a gshare and a McFarling branch predictor [12]. In each case, the structure of the confidence estimator may change due to the branch predictor, and we indicate those changes there. We use the SimpleScalar <ref> [2] </ref> execution-driven simulation infrastructure to compare the different confidence estimators. Our simulator is an extension of the sim-outorder simulator, with a 5-stage pipeline and an additional 3 cycle misprediction recovery penalty.
Reference: [3] <author> Jeffrey Dean, James E. Hicks, Carl A. Waldspurger, William E. Weihl, and George Chrysos. ProfileMe: </author> <title> Hardware support for instruction-level profiling on out-of-order processors. </title> <booktitle> In 30th Annual International Symposium on Microar-chitecture. IEEE, </booktitle> <month> December </month> <year> 1997. </year>
Reference-contexts: Thus, the profile technique requires a branch predictor simulation (which is much slower than a simple profile) or hardware that reports performance information for the underlying branch predictor, such as the Profile-Me mechanism <ref> [3] </ref>. 2 The Icache is equivalent to a 64 kB cache, since SimpleScalar has a 64-bit instruction encoding, but we only use 32 bits for each instruction, so half the space is wasted. Table 1: Program characteristics, differentiating between committed instructions and both committed and uncommitted instructions.
Reference: [4] <author> Joseph Gastwirth. </author> <title> The Statistical Precision of Medical Screening Procedures: Application to Polygraph and AIDS Antibodies Test Data. </title> <journal> Statistical Science, </journal> <volume> 2(3), </volume> <month> August </month> <year> 1987. </year>
Reference-contexts: We close with a discussion of temporal aspects of branch predictors and how they can be exploited to improve confidence estimation. 1.1 Diagnostic Tests The following description is adapted from a paper by Gastwirth <ref> [4] </ref>, as described in [1]. A diagnostic test is used to determine if an individual belongs to a class D of people that have a particular disease, or to the class of people who do not have the disease, D.
Reference: [5] <author> Dirk Grunwald, Artur Klauser, Srilatha Manne, and Andrew Pleszkun. </author> <title> Confidence estimation for speculation control. </title> <type> Technical Report CU-CS-854-98, </type> <institution> University of Colorado, Dept. of Computer Science, </institution> <address> Campus Box 430, Boulder, CO 80309-0430, </address> <month> Mar </month> <year> 1998. </year>
Reference-contexts: The first column of Table 2 shows the performance of the different confidence estimators when using the gshare predictor. We report the geometric mean of the sensitivity, specificity, PVP and PVN for each confidence estimator; detailed information on each application can be found in <ref> [5] </ref>. The averages are computed from the averages of the original data. In other words, when computing the average for the PVP, we take the mean for C HC and C LC and compute C HC = C HC + C LC , rather than averaging the existing PVP's.
Reference: [6] <author> Timothy Heil and James Smith. </author> <title> Selective Dual Path Execution, </title> <month> November </month> <year> 1996. </year> <institution> University of Wisconsin-Madison, </institution> <address> http://www.ece.wisc.edu/ jes/papers/sdpe.ps. </address>
Reference-contexts: The goals in the power conservation architecture are similar to those of the SMT design, and we want a confidence estimator with large PVN and SPEC. Eager Execution: Some proposed architectures evaluate instructions on both paths of a conditional branch <ref> [16, 9, 15, 6, 8] </ref>. These architectures might use a confidence estimator to determine when to diverge and evaluate both paths. <p> Our measurements confirm the observation of Heil and Smith <ref> [6] </ref> that mispredictions in a trace were clustered. However, we have found the degree of clustering is different when you look at all branches (e.g., during a pipeline-level simulation) or only at the committed branches (e.g., branches in a normal program trace). <p> We use the information from all branches because that is what is actually of interest to an architect in a real pipeline or a pipeline level simulation. Our data shows that mispredictions are tightly clustered, with few branches between mispredicted branches. Heil and Smith <ref> [6] </ref> plotted the probability distribution function of the branch mispre-diction distance. If branches are independent (and not clustered), that graph has a geometric distribution with a parameter equal to the misprediction rate.
Reference: [7] <author> Erik Jacobsen, Eric Rotenberg, and J. E. Smith. </author> <title> Assigning confidence to conditional branch predictions. </title> <booktitle> In Proceedings of the 29th Annual International Symposium on Microarchi-tecture, </booktitle> <pages> pages 142152, </pages> <address> Paris, France, </address> <month> December 24, </month> <year> 1996. </year>
Reference-contexts: Confidence estimation is a technique for assessing the quality of a particular prediction. Confidence estimation has usually been studied in the context of branch prediction. Jacobsen et al <ref> [7] </ref> described a number of uses for confidence estimation: they suggested that it may be used to improve the branch prediction rate, control resource use in a dual-path execution pipeline or control context switching in a multithreaded processor. <p> To date, only Jacobsen et al <ref> [7] </ref> have published comparisons of confidence estimators, and their paper considered only two designs. When converted to our terminology, Ja-cobsen et al defined the confidence misprediction rate as I HC + C LC =C HC +I HC +C LC +I LC . <p> A higher SPEC would mean that more opportunities for applying eager execution are found. Improving Branch Predictors: Jacobsen et al <ref> [7] </ref> suggested that a confidence estimator could be used to improve the accuracy of a branch predictor. If the PVN &gt; 50%, then the confidence estimator can improve the branch prediction accuracy by inverting the outcome of a low-confident branch. <p> Later, we examine the temporal characteristics of branch predictors and show how those properties can be used to design another inexpensive confidence estimator. JRS Estimator: The first method we implemented is one-level resetting counter mechanism proposed by Jacobsen, Rotenberg, and Smith (JRS) <ref> [7] </ref>. This predictor uses a miss distance counter (which we call an MDC) table in addition to the branch predictor. The structure of the confidence estimator is similar to that of the Gshare predictor. An index is computed using an exclusive-or of the program address and the branch history register. <p> An index is computed using an exclusive-or of the program address and the branch history register. This index is used to read a value from a table of MDCs. The width of these counters can vary in size, but we used 4-bit counters as suggested in <ref> [7] </ref>. We used a large table containing 4096 4-bit counters. Each time a branch is predicted, the value of the MDC is compared to a specific threshold. If the value is above that threshold, then the branch is considered to have high confidence, otherwise it has low confidence. <p> Table 4 shows the average performance of this technique vs. other confidence estimators, using a range of distance thresholds. We can vary the distance threshold to achieve different values of SPEC and PVN. Jacobsen et al <ref> [7] </ref> examined a related configuration, where a global MDC was used to index into a table of correct-incorrect registers. This solution still has a large MDC table, and [7] primarily investigated using the global indexing MDC as a way to improve accuracy they were not looking for inexpensive confidence estimators. <p> We can vary the distance threshold to achieve different values of SPEC and PVN. Jacobsen et al <ref> [7] </ref> examined a related configuration, where a global MDC was used to index into a table of correct-incorrect registers. This solution still has a large MDC table, and [7] primarily investigated using the global indexing MDC as a way to improve accuracy they were not looking for inexpensive confidence estimators. The variation used in [7] probably did not work well for the reasons illustrated in our earlier data unless the indexing structure of a table-based confidence estimator matches that <p> This solution still has a large MDC table, and <ref> [7] </ref> primarily investigated using the global indexing MDC as a way to improve accuracy they were not looking for inexpensive confidence estimators. The variation used in [7] probably did not work well for the reasons illustrated in our earlier data unless the indexing structure of a table-based confidence estimator matches that of the underlying branch predictor, the performance will suffer.
Reference: [8] <author> Artur Klauser, Abhijit Paithankar, and Dirk Grunwald. </author> <title> Selective eager execution on the polypath architecture. </title> <booktitle> In Proceedings 25th Annual Annual International Symposium on Computer Architecture, </booktitle> <address> Barcelona, Spain, </address> <month> June </month> <year> 1998. </year> <note> ACM. </note>
Reference-contexts: The goals in the power conservation architecture are similar to those of the SMT design, and we want a confidence estimator with large PVN and SPEC. Eager Execution: Some proposed architectures evaluate instructions on both paths of a conditional branch <ref> [16, 9, 15, 6, 8] </ref>. These architectures might use a confidence estimator to determine when to diverge and evaluate both paths. <p> Two applications are described at this conference. One application involves controlling instruction fetch and issue based on confidence estimators to reduce power demands in speculative processors [11]. The second involves controlling variants of eager execution <ref> [8] </ref>. We are also working on adaptive control of multithreaded processors to better utilize processor resources. Each of these applications emphasizes the PVN and SPEC metrics, and is very sensitive to the branch prediction ac-curacy.
Reference: [9] <author> Kelsey Lick. </author> <title> Limited Dual Path Execution. </title> <type> Master's thesis, </type> <institution> University of California, Riverside, </institution> <year> 1996. </year>
Reference-contexts: The goals in the power conservation architecture are similar to those of the SMT design, and we want a confidence estimator with large PVN and SPEC. Eager Execution: Some proposed architectures evaluate instructions on both paths of a conditional branch <ref> [16, 9, 15, 6, 8] </ref>. These architectures might use a confidence estimator to determine when to diverge and evaluate both paths. <p> We tried all different threshold levels, and show detailed results for a threshold of 15 and show the trend for other thresholds. We called this the JRS confidence estimator. Pattern History Estimator: Lick et al <ref> [9, 15] </ref> proposed a confidence estimator for dual-path execution. the confidence estimator was used to determine when dual-path execution should be used. Although neither of the available papers focused on the confidence estimator itself, the basic design is described.
Reference: [10] <author> Mikko Lipasti. </author> <title> Value Locality and Speculative Execution. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: It allows an architectural implementation to achieve higher instruction level parallelism, and thus performance, by predicting the outcome of specific events. Most processors currently implement branch prediction to permit speculative control-flow; more recent work has focused on predicting data values to reduce data dependencies <ref> [10] </ref>. Confidence estimation is a technique for assessing the quality of a particular prediction. Confidence estimation has usually been studied in the context of branch prediction.
Reference: [11] <author> Srilatha Manne, Artur Klauser, and Dirk Grunwald. </author> <title> Pipeline gating: Speculation control for energy reduction. </title> <booktitle> In Proceedings 25th Annual Annual International Symposium on Computer Architecture, </booktitle> <address> Barcelona, Spain, </address> <month> June </month> <year> 1998. </year> <note> ACM. </note>
Reference-contexts: Since this architecture would err on the side of speculatively issuing instructions, confidence estimators with a high PVN are very important, while PVP would be less important. A higher SPEC means that more opportunities for avoiding wasteful speculation are identified. Power conservation: In related work <ref> [11] </ref>, we are investigating how to use confidence estimators to reduce power usage in a processor by suppressing instruction issue following low-confidence branches. The goals in the power conservation architecture are similar to those of the SMT design, and we want a confidence estimator with large PVN and SPEC. <p> Two applications are described at this conference. One application involves controlling instruction fetch and issue based on confidence estimators to reduce power demands in speculative processors <ref> [11] </ref>. The second involves controlling variants of eager execution [8]. We are also working on adaptive control of multithreaded processors to better utilize processor resources. Each of these applications emphasizes the PVN and SPEC metrics, and is very sensitive to the branch prediction ac-curacy.
Reference: [12] <author> Scott McFarling. </author> <title> Combining branch predictors. </title> <address> TN 36, DEC-WRL, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: We mainly include this technique to indicate its potential. 1 3.1 Experimental Methodology Each of the confidence estimation techniques makes assumptions concerning the underlying branch predictor. Later, we compare these methods when using a gshare and a McFarling branch predictor <ref> [12] </ref>. In each case, the structure of the confidence estimator may change due to the branch predictor, and we indicate those changes there. We use the SimpleScalar [2] execution-driven simulation infrastructure to compare the different confidence estimators. <p> The benchmarks and important measurements from our simulations are listed in Table 1. We used three underlying branch predictors to compare the different confidence estimators: a speculative gshare predictor, a speculative McFarling combining predictor <ref> [12] </ref> and a non-speculative SAg [17] predictor. Figure 2 gives a schematic illustration of each branch predictor. The gshare branch predictor (Figure 2a) combines a global branch history with the program counter to select a two-bit counter. <p> As indicated in <ref> [12] </ref>, this configuration offers the best performance for the predictor sizes we are using in this evaluation. The JRS, static and history pattern confidence estimators were implemented as before.
Reference: [13] <author> J. E. Smith. </author> <title> A study of branch prediction strategies. </title> <booktitle> In Proceedings 8th Annual International Symposium on Computer Architecture. ACM, </booktitle> <year> 1981. </year>
Reference-contexts: Essentially, the patterns were always taken, almost always taken (once not-taken), always not-taken, almost always not-taken and alternating taken and not-taken. We called this the pattern history confidence estimator. Saturating Counters Estimator: The third method we implemented was originally proposed in an early paper by Smith <ref> [13] </ref>. Here, we use the state of the saturating counters used in many branch prediction mechanisms to determine the confidence estimate. For example, in a simple gshare predictor, branch outcomes are determined by the state of a two-bit counter. We called this the saturating counters method.
Reference: [14] <author> Dean M. Tullsen, Susan Eggers, and Henry M. Levy. </author> <title> Simultaneous multithreading: Maximizing on-chip parallelism. </title> <booktitle> In Proceedings 22th Annual International Symposium on Computer Architecture, </booktitle> <month> Jun </month> <year> 1995. </year>
Reference-contexts: By comparison, we think that confidence estimators will normally be used for speculation control. For example, if a particular branch in a Simultaneous Multithreading <ref> [14] </ref> processor is of low confidence, it may be more cost effective to switch threads than speculatively evaluate the branch. A confidence predictor attempts to corroborate or assess the prediction made by a branch predictor. Each branch is eventually determined to have been predicted correctly or incorrectly.
Reference: [15] <author> Gary Tyson, Kelsey Lick, and Matthew Farrens. </author> <title> Limited Dual Path Execution. </title> <type> CSE-TR 346-97, </type> <institution> University of Michigan, </institution> <year> 1997. </year>
Reference-contexts: The goals in the power conservation architecture are similar to those of the SMT design, and we want a confidence estimator with large PVN and SPEC. Eager Execution: Some proposed architectures evaluate instructions on both paths of a conditional branch <ref> [16, 9, 15, 6, 8] </ref>. These architectures might use a confidence estimator to determine when to diverge and evaluate both paths. <p> We tried all different threshold levels, and show detailed results for a threshold of 15 and show the trend for other thresholds. We called this the JRS confidence estimator. Pattern History Estimator: Lick et al <ref> [9, 15] </ref> proposed a confidence estimator for dual-path execution. the confidence estimator was used to determine when dual-path execution should be used. Although neither of the available papers focused on the confidence estimator itself, the basic design is described.
Reference: [16] <author> A. K. Uht, V. Sindagi, and K. Hall. </author> <title> Disjoint Eager Execution: An Optimal Form of Speculative Execution. </title> <booktitle> In 28th International Conference on Microarchitecture, </booktitle> <pages> pages 313 325, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: The goals in the power conservation architecture are similar to those of the SMT design, and we want a confidence estimator with large PVN and SPEC. Eager Execution: Some proposed architectures evaluate instructions on both paths of a conditional branch <ref> [16, 9, 15, 6, 8] </ref>. These architectures might use a confidence estimator to determine when to diverge and evaluate both paths.
Reference: [17] <author> Tse-Yu Yeh and Yale N. Patt. </author> <title> Alternative implementations of two-level adaptive branch predictions. </title> <booktitle> In Proceedings 19th Annual Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 124134, </pages> <address> Gold Coast, Australia, </address> <month> May </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: The benchmarks and important measurements from our simulations are listed in Table 1. We used three underlying branch predictors to compare the different confidence estimators: a speculative gshare predictor, a speculative McFarling combining predictor [12] and a non-speculative SAg <ref> [17] </ref> predictor. Figure 2 gives a schematic illustration of each branch predictor. The gshare branch predictor (Figure 2a) combines a global branch history with the program counter to select a two-bit counter.
References-found: 17

