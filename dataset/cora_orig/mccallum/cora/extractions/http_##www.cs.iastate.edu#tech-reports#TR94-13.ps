URL: http://www.cs.iastate.edu/tech-reports/TR94-13.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Register Allocation for Accurate Garbage Collection of C++  
Author: S. Satishkumar 
Address: Ames, IA 50011  
Affiliation: Department of Computer Science Iowa State University  
Abstract: Accurate garbage collection of C++ requires that every memory location and ev ery register be known to contain either a pointer or a non-pointer. In order to minimize the run-time overhead of tagging memory locations and registers, techniques for partitioning memory and registers into separate classes dedicated independently to the representation of pointers and non-pointers respectively have been developed. This paper describes the implementation and performance of a specially designed register allocator for the GNU g++ compiler. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> H. Boehm and M. Weiser, </author> <title> Garbage Collection in an Uncooperative Environment, </title> <journal> SoftwarePractice & Experience 18, </journal> <month> 9 (Sep </month> <year> 1988), </year> <pages> 807-820. </pages>
Reference-contexts: It treats as a pointer any register or memory cell containing a value that is a valid heap memory address <ref> [1] </ref>. 1 Portions of this paper were excerpted from Code Generation to Support Efficient Accurate Garbage Collection of C++ on Stock Hardware, a paper currently being prepared for publication by Kelvin Nilsen, Ravichandran Ganesan, Satish Guggilla, Satish Kumar, and Kannan Narasimhan. -2- Conservative garbage collection has been shown to provide good <p> If the constraints are specified as null, any operand type is permissible. For example, consider the following rtl instruction pattern: -14- (define_insn "" [(set (match_operand:SI 0 "reg_or_nonsymb_mem_operand" "=r,f,r,r,f,Q,Q") (match_operand:SI 1 "move_operand" "rI,!f,K,Q,!Q,rJ,!f"))] "register_operand (operands [0], SImode) || register_operand (operands <ref> [1] </ref>, SImode) || operands [1] == const0_rtx" This instruction has two operands; call them op0 and op1. Both have constraint strings. The constraint string for op0 is "=r,f,r,r,f,Q,Q" and the constraint string for op1 is "rI,!f,K,Q,!Q,rJ,!f". If op0 satisfies the constraint =r, then op1 must satisfy the constraint rI. <p> If the constraints are specified as null, any operand type is permissible. For example, consider the following rtl instruction pattern: -14- (define_insn "" [(set (match_operand:SI 0 "reg_or_nonsymb_mem_operand" "=r,f,r,r,f,Q,Q") (match_operand:SI 1 "move_operand" "rI,!f,K,Q,!Q,rJ,!f"))] "register_operand (operands [0], SImode) || register_operand (operands <ref> [1] </ref>, SImode) || operands [1] == const0_rtx" This instruction has two operands; call them op0 and op1. Both have constraint strings. The constraint string for op0 is "=r,f,r,r,f,Q,Q" and the constraint string for op1 is "rI,!f,K,Q,!Q,rJ,!f". If op0 satisfies the constraint =r, then op1 must satisfy the constraint rI.
Reference: 2. <author> H. Boehm and D. Chase, </author> <title> A Proposal for Garbage-Collector-Safe C Compilation, </title> <journal> Journal of C Lan guage Translation 4, </journal> <month> 2 (Dec </month> <year> 1992), </year> <pages> 126-141. </pages>
Reference: 3. <author> A. Diwan, E. Moss and R. Hudson, </author> <title> Compiler Support for Garbage Collection in a Statically Typed Language, </title> <booktitle> ACM SIGPLAN Notices Conference on Programming Language Design and Implementa tion, </booktitle> <month> June </month> <year> 1992, </year> <pages> 273-282. </pages>
Reference: 4. <author> R. Ganesan and K. Nilsen, </author> <title> The Design and Implementation of SPARC Activation Frames to Facili tate Accurate Garbage Collection of C++. </title>
Reference: 5. <author> S. K. Guggilla, </author> <title> Generational Garbage Collection for C++ Targeted to Sparc Architectures, </title> <type> Master's Degree. </type>
Reference-contexts: Therefore, the garbage collector (rather than the compiler) takes responsibility for computing base pointers from derived pointers. Special circuitry provides the functionality in the hardware-assisted real-time garbage collection system [7]. In the stock-hardware garbage collection system, this functionality is implemented in software <ref> [5] </ref>. Thus, Schmidt's compiler did not need to preserve base pointers, nor did it need to find ways to compute base addresses of objects from derived pointers. Another difference between Schmidt's compiler and the other two studies cited in this section is that Schmidt's compiler did not support optimizations. <p> This is in contrast with the pseudo-register distribution which was otherwise (see reference 4). However, the available number of registers seems to be sufficient to meet the application's requirements. It should be noted that some descriptor hard registers are reserved and cannot be used for general allocation (g <ref> [5] </ref>, g [6], and g [7] are reserved for the environment, the stack pointer, and operating system). This increases the demand for descriptor registers. -23- 5.3.
Reference: 6. <author> S. </author> <title> International, The SPARC Architecture Manual, Version 8, </title> <publisher> Prentice Hall, Inc., </publisher> <address> Menlo Park, CA, </address> <year> 1992. </year>
Reference-contexts: The caller reserves space for the structure argument within its activation frame, and passes a pointer to the structure's location as an argument to the called function. Refer to the SPARC architecture manual for a more detailed description of the SPARC architecture <ref> [6] </ref>. The genoutput program The GNU compiler's code generator is designed to be portable between a large number of target architectures. Within the GNU compiler, much of the machine-independent analysis and optimization is performed on an intermediate code called rtl. <p> The partition is only partially compatible with the SPARC ABI (Application Binary Interface) specifica tion, which reserves the following registers <ref> [6] </ref>: Register Aliased Description Name Name r0 g0 Always zero. r1 g1 A temporary value (caller saved). r5-r7 g5-g7 Undefined, reserved for future use. r8 o0 Value returned from callee. r8-r13 o0-o5 Outgoing parameters 1-6. r14 o6 Stack pointer. r15 o7 Temporary value within function body / Return address associated with <p> However, the available number of registers seems to be sufficient to meet the application's requirements. It should be noted that some descriptor hard registers are reserved and cannot be used for general allocation (g [5], g <ref> [6] </ref>, and g [7] are reserved for the environment, the stack pointer, and operating system). This increases the demand for descriptor registers. -23- 5.3.
Reference: 7. <author> K. Nilsen and W. J. Schmidt, </author> <title> Cost-Effective Object-Space Management for Hardware-Assisted Real Time Garbage Collection, </title> <journal> ACM Letters on Pro g. Lang. and Systems 1, </journal> <month> 4 (Dec. </month> <year> 1992), </year> <pages> 338-354. </pages>
Reference-contexts: In C++, derived pointers may be assigned to programmer-defined variables and passed as arguments to other functions. Therefore, the garbage collector (rather than the compiler) takes responsibility for computing base pointers from derived pointers. Special circuitry provides the functionality in the hardware-assisted real-time garbage collection system <ref> [7] </ref>. In the stock-hardware garbage collection system, this functionality is implemented in software [5]. Thus, Schmidt's compiler did not need to preserve base pointers, nor did it need to find ways to compute base addresses of objects from derived pointers. <p> Windowed Register Address Register Names global [0] - global <ref> [7] </ref> r0 - r7 out [0] - out [7] r8 - r15 local [0] - local [7] r16 - r23 in [0] - in [7] r24 - r31 By convention, parameters are passed in the out registers of the caller, which become the in registers of the callee. <p> Windowed Register Address Register Names global [0] - global <ref> [7] </ref> r0 - r7 out [0] - out [7] r8 - r15 local [0] - local [7] r16 - r23 in [0] - in [7] r24 - r31 By convention, parameters are passed in the out registers of the caller, which become the in registers of the callee. <p> Windowed Register Address Register Names global [0] - global <ref> [7] </ref> r0 - r7 out [0] - out [7] r8 - r15 local [0] - local [7] r16 - r23 in [0] - in [7] r24 - r31 By convention, parameters are passed in the out registers of the caller, which become the in registers of the callee. <p> Windowed Register Address Register Names global [0] - global <ref> [7] </ref> r0 - r7 out [0] - out [7] r8 - r15 local [0] - local [7] r16 - r23 in [0] - in [7] r24 - r31 By convention, parameters are passed in the out registers of the caller, which become the in registers of the callee. However, if t here are more parameters to be passed than fit within these registers, the extra -5- parameters are passed on the stack. <p> However, the available number of registers seems to be sufficient to meet the application's requirements. It should be noted that some descriptor hard registers are reserved and cannot be used for general allocation (g [5], g [6], and g <ref> [7] </ref> are reserved for the environment, the stack pointer, and operating system). This increases the demand for descriptor registers. -23- 5.3.
Reference: 8. <author> K. Nilsen, </author> <title> Reliable Real-Time Garbage Collection of C++, </title> <booktitle> Computing Systems 7, </booktitle> <month> 4 (Fall </month> <year> 1994), </year> . 
Reference: 9. <author> K. D. Nilsen and W. J. Schmidt, </author> <title> A High-Performance Hardware-Assisted Real-Time Garbage Col lection System, </title> <journal> Journal of Programming Languages, </journal> <note> To appear. </note>
Reference-contexts: Previous work by Schmidt and Nilsen differs from Diwan's work in that the target language is lower level than Modula-3 <ref> [9, 10] </ref>. Since the target language is C++, there is no hope of tracking base pointers for all heap-allocated objects. In C++, derived pointers may be assigned to programmer-defined variables and passed as arguments to other functions.
Reference: 10. <author> W. J. Schmidt, </author> <title> Issues in the Design and Implementation of a Real-Time Garbage Collection Archi tecture, </title> <type> Ph.D. Dissertation, </type> <institution> Iowa State Univ. </institution> <type> Tech. Rep. </type> <pages> 92-25, </pages> <year> 1992. </year>
Reference-contexts: But previous implementations of accurate C++ garbage collectors require special hardware and incur a run-time overhead of up to 30%, even with the aid of the special hardware support. Further, the only previous implementation of C++ garbage collection <ref> [10] </ref> does not make use of traditional code optimizations, including global register allocation, because of bugs in the compiler's optimizer. <p> Previous work by Schmidt and Nilsen differs from Diwan's work in that the target language is lower level than Modula-3 <ref> [9, 10] </ref>. Since the target language is C++, there is no hope of tracking base pointers for all heap-allocated objects. In C++, derived pointers may be assigned to programmer-defined variables and passed as arguments to other functions. <p> Function activation frames are comprised of as many consecutive repetitions of this pattern as are needed to represent the local variables of the function. Using this technique, function calls and returns are nearly as efficient for the garbage-collected system as they are for traditional code, unlike Schmidt's design <ref> [10] </ref> which incurred a minimum of 9 instruction of additional overhead on every function call for the garbage-collected system. In case the register windows overow, the input and local registers for the offending function will be copied into the activation frame for the function.
Reference: 11. <author> R. M. Stallman, </author> <title> Using and Porting GNU CC, Free Software Foundation, </title> <publisher> Inc., </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: The compiler's code generator compares instruction patterns against rtl expressions (rtx) in order to select efficient translations of the rtx representations of the source code that it is translating. For a more complete description of the above files and of rtl, see the GNU CC manual <ref> [11] </ref>. Registers in the SPARC Architecture SPARC describes an architecture with many possible implementations. The SPARC architecture uses register windows.
Reference: 12. <author> B. Zorn, </author> <title> The Measured Cost of Conservative Garbage Collection, </title> <journal> SoftwarePractice & Experience 23, </journal> <month> 7 (Jul </month> <year> 1993), </year> <pages> 773-756. </pages>
Reference-contexts: Support Efficient Accurate Garbage Collection of C++ on Stock Hardware, a paper currently being prepared for publication by Kelvin Nilsen, Ravichandran Ganesan, Satish Guggilla, Satish Kumar, and Kannan Narasimhan. -2- Conservative garbage collection has been shown to provide good time and space performance on a wide variety of real-world applications <ref> [12] </ref>. The alternative available garbage collection technique for C++ is accurate garbage collection, as described in references 9 and 8. Accurate garbage collection requires cooperation from the compiler's code generator in order to distinguish pointers from non-pointers within memory and registers.
References-found: 12

