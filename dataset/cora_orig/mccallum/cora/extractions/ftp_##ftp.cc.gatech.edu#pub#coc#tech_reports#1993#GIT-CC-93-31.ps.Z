URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1993/GIT-CC-93-31.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.93.html
Root-URL: 
Email: hernan@cc.gatech.edu shilling@cc.gatech.edu  
Title: Alternative Object Organizations using Prototypes, Delegation and Split Objects  
Author: Hernan Astudillo R. John J. Shilling 
Date: 2, 1993  
Note: July  
Abstract: Technical Report GIT-CS-93/31 College of Computing Georgia Institute of Technology Atlanta, Georgia 30332-0280 Abstract Object-based (i.e. classless) models are very effective for elucidating requirements from users, and they support exploratory programming and rapid prototyping. On the other hand, class-based models are preferred to perform design and implementation, providing descriptive power and some types of error checking. We consider the evolution of object-based models into class-based production systems. One of the most difficult problems of this transition is the change from explicit description of individuals to implicit description of class instances. Reorganization support aims to make the system structures and properties evident and enforceable. Structural properties are useful to organize the code regardless of its meaning, and automated support can be enlisted to identify potential structures and properties, leaving the programmer with choice of alternative workspace organizations. We analyze the organization and management of classless objects, regarding the goals of redundancy elimination and consistency maintenance, and how these goals are complicated by the existence of two mechanisms of object creation, cloning and extension (split objects). We present a classification of sharing and extension patterns in terms of the two basic mechanisms, and argue for a metrics-based approach to incremental reorganization. Finally, we propose in detail a set of abstractions with increasing descriptive power and consistency requirements: groups (untyped descriptions of structure and inheritance), families (partially typed descriptions of objects structure and inheritance, with monomorphic typing 1 and consistency maintenance), and types (fully typed descriptions of families interfaces, with polymorphic typing by subtyping and relating implementation hierarchy to typed interfaces). 1 We call "monomorphic types" to types that do not allow subtypes, such as types in C (coercion is not subtyping) 
Abstract-found: 1
Intro-found: 1
Reference: [ARS91] <author> Hernan Astudillo R. and John J. Shilling. </author> <title> Criteria and operations for reorganization of classless systems. </title> <type> Technical Report GIT-CC-91/29, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <address> Atlanta, GA 30332, USA, </address> <month> Mar </month> <year> 1991. </year>
Reference-contexts: This is the case when the two objects share inheritance. 6. Two objects are similar if they are structure-similar and inheritance-similar. 5.3 Operations on Groups We provide several operations to create and manipulate groups. These operations are explained in greater detail in <ref> [ARS91] </ref>. 1. Factorization: given a set of objects and a sharable, makes each object to inherit from the sharable and removes any "redundant" slots in each object (i.e. any method slot that is value-similar to a slot in the sharable). 2. <p> However, they only allow to identify "easy" groups (i.e. with very alike elements), so we extend the concept of similarity to handle approximate matchings. Again, further details may be found in <ref> [ARS91] </ref>. In this paper we present these relationship in informal terms: 1. If the slot set of O 1 is a subset of the slot set of O 2 , then O 1 is structure-smaller than O 2 . 2. <p> Note that this "similarity" is not symmetric. 6.5 Operations on Families and Instances We provide several operations to create and manipulate families. These operations are explained in greater detail in <ref> [ARS91] </ref>. 1. Upgrading: creates a new family around a group, i.e. the group is "upgraded" to a family. If the slots in the clonable and sharable reference objects which are instances of some families, then such families become the tags of those slots. <p> The final result of classification is a "tree" of families, each of them extending or redefining their respective superfamily slots. Other operations for membership validation and set manipulation are also provided (see <ref> [ARS91] </ref>). 6.6 Operations among Families 1. Factorization: the sharable and description of each family F i in F fl are "factorized" to family F , by making each F i to inherit from F and removing any redundant slots from their sharable. 2.
Reference: [AvdL90] <author> Pierre America and Frank van der Linden. </author> <title> A parallel object-oriented language with inheritance and subtyping. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> OOPSLA/ECOOP '90 Conference on Object-Oriented Programming: Systems, Languages, and Applications/European Conference on Object-Oriented Programming, </booktitle> <pages> pages 161-168. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <address> Ottawa, Canada, </address> <month> Oct 21-25 </month> <year> 1990. </year>
Reference-contexts: In these cases, each class implicitly defines a type, and subclassing (inheritance of implementation) implicitly defines subtyping. We believe that a cleaner separation of implementation and interface can be obtained from separating classes from types [CHC90] (like in POOL <ref> [AvdL90] </ref>). We do not take issue with implicitly defining a type for each class; on the contrary, it seems very reasonable to assume that objects brought under common management are intended to have a similar use.
Reference: [Boo90] <author> Grady Booch. </author> <title> Object-Oriented Design with Appications. </title> <booktitle> Benjamin/Cummings series in Ada and software engineering. </booktitle> <address> Benjamin/Cummings, Redwood City, CA, </address> <year> 1990. </year>
Reference-contexts: Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; [BS84, Gom83]; and provide the flexible development needed for rapid prototyping [GS81]. Other experiences have shown <ref> [MP92, WBJ90, Boo90, Mey88] </ref> that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability. Classes [GR89] turn the explicit description of individual objects into an intensional description of groups of objects; this simplifies the system description, allows code reuse, and supports change propagation.
Reference: [BS84] <author> Reinhard Budde and K. Sylla. </author> <title> From application domain modelling to target system. </title> <editor> In Reinhard Budde, K. Kuhlenkamp, L. Mathiassen, and H. Zullighoven, editors, </editor> <title> Approaches to Prototyping: </title> <booktitle> Proceedings of the Working Conference on Prototyping, </booktitle> <pages> pages 31-48, </pages> <address> Berlin & New York, Namur, Belgium, </address> <year> 1983 1984. </year> <institution> Gesellschaft fur Mathematik und Datenverarbeitung mbH, Springer-Verlag. </institution>
Reference-contexts: Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; <ref> [BS84, Gom83] </ref>; and provide the flexible development needed for rapid prototyping [GS81]. Other experiences have shown [MP92, WBJ90, Boo90, Mey88] that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability.
Reference: [CHC90] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In POPL, editor, 17th ACM Symposium on Principles of Programming Languages. ACM SIGACT and SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: In these cases, each class implicitly defines a type, and subclassing (inheritance of implementation) implicitly defines subtyping. We believe that a cleaner separation of implementation and interface can be obtained from separating classes from types <ref> [CHC90] </ref> (like in POOL [AvdL90]). We do not take issue with implicitly defining a type for each class; on the contrary, it seems very reasonable to assume that objects brought under common management are intended to have a similar use.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> Dec </month> <year> 1985. </year>
Reference-contexts: The above mentioned approaches can be used to implement this one, as in fact Self [UCCH91] uses "maps" to support sharing among clones. * Implicit: the issue of sharing is abstracted into membership in a group denoted by a common description of features. This is the case in class-based <ref> [CW85] </ref> languages like Smalltalk [GR89] and C ++ [Str86], where "classes" hold both shared members and an implicit prototype. <p> If the sharable T 1 of a family is structure-smaller than the sharable T 2 of another family, then apply factorization ( slot set (T 2 ),fT 1 g,T 2 ). 7 Types Two of the most important concepts in object-oriented programming are inheritance and polymor-phism <ref> [CW85] </ref>. Polymorphism can be achieved through a variety of means, such as overloading, genericity, subtyping, and simple lack of typing. Roughly speaking, we have polymorphism by subtyping if wherever an instance of a certain kind is expected, an instance of a subkind can be given instead.
Reference: [DMC92] <author> Christophe Dony, Jacques Malenfant, and Pierre Cointe. </author> <title> Prototype-based languages: From a new taxonomy to constructive proposals and their validation. </title> <editor> In Andreas Paepcke, editor, OOPSLA'92, </editor> <booktitle> 7th annual conference on object-oriented programming systems, languages, and applications, </booktitle> <pages> pages 201-217. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <address> Vancouver, British Columbia, Canada, </address> <month> 18-22 Oct </month> <year> 1992. </year>
Reference-contexts: Several representation options exist: * Delegation: an extended object is implemented as if having "components" [NGT92]: the new features are defined into an object, and the original object (s) become parents, remaining untouched. Dony et al: call these split objects <ref> [DMC92] </ref>.
Reference: [Gom83] <author> H. Gomaa. </author> <title> The impact of rapid prototyping on specifying user requirements. </title> <journal> Software Engineering Notes, </journal> <volume> 8(2) </volume> <pages> 17-28, </pages> <year> 1983. </year>
Reference-contexts: Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; <ref> [BS84, Gom83] </ref>; and provide the flexible development needed for rapid prototyping [GS81]. Other experiences have shown [MP92, WBJ90, Boo90, Mey88] that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability.
Reference: [GR89] <author> Adele Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language. </title> <publisher> Addison-Wesley series in computer science. Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Other experiences have shown [MP92, WBJ90, Boo90, Mey88] that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability. Classes <ref> [GR89] </ref> turn the explicit description of individual objects into an intensional description of groups of objects; this simplifies the system description, allows code reuse, and supports change propagation. <p> This is the case in class-based [CW85] languages like Smalltalk <ref> [GR89] </ref> and C ++ [Str86], where "classes" hold both shared members and an implicit prototype. <p> Types provide polymorphism via subtyping, i.e. a type tag T accepts instances of the underlying family of T or of a family underlying any subtype of T. 7.1 Types and Classes Most conventional object-oriented languages <ref> [GR89] </ref> [Str86] [Mey88] combine "classes" (a code reuse abstraction) with "types" (a polymorphism abstraction) under a single linguistic construct. In these cases, each class implicitly defines a type, and subclassing (inheritance of implementation) implicitly defines subtyping.
Reference: [GS81] <author> H. Gomaa and D. B. H. Scott. </author> <title> Prototyping as a tool in the specification of user requirements. </title> <editor> In ICSE, editor, </editor> <booktitle> 5th International Conference of Software Engineering, </booktitle> <pages> pages 333-342. </pages> <booktitle> IEEE and ACM SIGSOFT, IEEE Computer Society, </booktitle> <year> 1981. </year>
Reference-contexts: Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; [BS84, Gom83]; and provide the flexible development needed for rapid prototyping <ref> [GS81] </ref>. Other experiences have shown [MP92, WBJ90, Boo90, Mey88] that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability.
Reference: [HH82] <author> J. W. Hooper and P. Hsia. </author> <title> Scenario-based prototyping of requirements identification. </title> <journal> Software Engineering Notes, </journal> <volume> 7(5) </volume> <pages> 88-93, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction Recent research and practice have shown that object-oriented analysis (OOA) is a powerful tool for capturing system requirements in the early stages of development (for example, see [MP92, SM88, WBWW90, RBP + 91] for some assessment of several OOA techniques). Some of these techniques (e.g. <ref> [Ner92, HH82] </ref>) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements.
Reference: [Hor87] <author> C. Horn. </author> <title> Conformance, genericity, inheritance and enhancement. </title> <editor> In Jean Bezivin, editor, </editor> <booktitle> European Conference on Object-Oriented Programming, Lecture notes in 21 computer science ; 276., </booktitle> <address> Berlin & New York, Paris, France, June 15-17 1987. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Roughly speaking, we have polymorphism by subtyping if wherever an instance of a certain kind is expected, an instance of a subkind can be given instead. Subtyping should represent two things: first, it needs that the interfaces of both types meet some criteria (like the one of "conformance" <ref> [Hor87] </ref>); and second, the use of a type in place of another must be meaningful. We stress the second point because the first one is usually the most (if not the only one) considered, whereas we believe that meaningfulness is the key to successful code organization. <p> However, the declaration of subtyping also requires that the involved types be checked for consistency. To determine the validity of a subtyping declaration, we use the notion of conformance <ref> [Hor87] </ref>, which we paraphrase as: * T 1 conforms to T 2 iff the slot set of T 1 is a superset of the slot set of T 2 , and for each slot S i both in T 1 and T 2 , the type tag of S i in
Reference: [Lie86] <author> Henry Lieberman. </author> <title> Using prototypical objects to implement shared behavior in object oriented systems. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <pages> pages 214-223. </pages> <publisher> ACM, ACM Press, </publisher> <address> Portland, Oregon, USA, </address> <month> Sept 29 - Oct 2 </month> <year> 1986. </year>
Reference-contexts: Some of these techniques (e.g. [Ner92, HH82]) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements. Object-based models allow the representation of concepts without a priori classifications; <ref> [Lie86] </ref>; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; [BS84, Gom83]; and provide the flexible development needed for rapid prototyping [GS81].
Reference: [MBK86] <author> Sanjay Mittal, Daniel G. Bobrow, and Kenneth M. Kahn. </author> <title> Virtual copies: At the boundary between classes and instances. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <pages> pages 159-166. </pages> <publisher> ACM, ACM Press, </publisher> <address> Portland, Oregon, USA, </address> <month> Sept 29 - Oct 2 </month> <year> 1986. </year>
Reference-contexts: This includes the Kevo language [Tai92], which provides sharing between apparently self-sufficient objects, and the "virtual copies" proposed by Mittal et al <ref> [MBK86] </ref>. * Via delegation: the sharing is explicit and visible to the programmer, who must determine what is shared and what is individual among clones. This is the model used in the Self language [US87], where "traits" objects hold shared slots, and "prototypes" and their clones hold individual state.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Ciffs, NJ 07632, USA, </address> <year> 1988. </year>
Reference-contexts: Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; [BS84, Gom83]; and provide the flexible development needed for rapid prototyping [GS81]. Other experiences have shown <ref> [MP92, WBJ90, Boo90, Mey88] </ref> that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability. Classes [GR89] turn the explicit description of individual objects into an intensional description of groups of objects; this simplifies the system description, allows code reuse, and supports change propagation. <p> Types provide polymorphism via subtyping, i.e. a type tag T accepts instances of the underlying family of T or of a family underlying any subtype of T. 7.1 Types and Classes Most conventional object-oriented languages [GR89] [Str86] <ref> [Mey88] </ref> combine "classes" (a code reuse abstraction) with "types" (a polymorphism abstraction) under a single linguistic construct. In these cases, each class implicitly defines a type, and subclassing (inheritance of implementation) implicitly defines subtyping.
Reference: [Mey90a] <author> Bertrand Meyer. </author> <title> Introduction to the Theory of Programming Languages. </title> <publisher> Prentice Hall international series in computer science. Prentice Hall, </publisher> <address> Englewood Ciffs, NJ 07632, USA, </address> <year> 1990. </year>
Reference-contexts: Classes [GR89] turn the explicit description of individual objects into an intensional description of groups of objects; this simplifies the system description, allows code reuse, and supports change propagation. Typing 2 <ref> [Mey90a] </ref> (particularly static typing) is considered necessary for the development of large and commercial systems, since it supports reusing existing code without modifying it, allows to detect certain classes of errors by static examination, helps to document the system, and facilitates optimizations of the compiled code. <p> For simplicity, we just provide the type INT , which maps to the family INT . The validity rule implies the covariance rule <ref> [Mey90a] </ref> for methods with the same name, because the type tag of a slot referencing a method P is the type tag of the method argument.
Reference: [Mey90b] <author> Bertrand Meyer. </author> <note> Usenet article &lt;454@eiffel.uucp&gt;. </note> <month> Nov </month> <year> 1990. </year>
Reference-contexts: Without going as far as Meyer, who has argued <ref> [Mey90b] </ref> that classes and not objects should be the actual stuff of object-oriented development, we believe that formalization of structure and classification is necessary if a development effort is to result in an industrial-strength system.
Reference: [MP92] <author> David E. Monarchi and Gretchen I. Puhr. </author> <title> A research typology for object-oriented analysis and design. </title> <journal> Communications of the ACM, </journal> <volume> 35(9) </volume> <pages> 35-47, </pages> <month> Sep </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Recent research and practice have shown that object-oriented analysis (OOA) is a powerful tool for capturing system requirements in the early stages of development (for example, see <ref> [MP92, SM88, WBWW90, RBP + 91] </ref> for some assessment of several OOA techniques). Some of these techniques (e.g. [Ner92, HH82]) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements. <p> Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; [BS84, Gom83]; and provide the flexible development needed for rapid prototyping [GS81]. Other experiences have shown <ref> [MP92, WBJ90, Boo90, Mey88] </ref> that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability. Classes [GR89] turn the explicit description of individual objects into an intensional description of groups of objects; this simplifies the system description, allows code reuse, and supports change propagation.
Reference: [Ner92] <author> Jean-Marc Nerson. </author> <title> Applying object-oriented analysis and design. </title> <journal> Communications of the ACM, </journal> <volume> 35(9) </volume> <pages> 63-74, </pages> <month> Sep </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Recent research and practice have shown that object-oriented analysis (OOA) is a powerful tool for capturing system requirements in the early stages of development (for example, see [MP92, SM88, WBWW90, RBP + 91] for some assessment of several OOA techniques). Some of these techniques (e.g. <ref> [Ner92, HH82] </ref>) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements.
Reference: [NGT92] <author> Oscar Nierstrasz, Simon Gibbs, and Dennis Tsichritzis. </author> <title> Component-oriented software development. </title> <journal> Communications of the ACM, </journal> <volume> 35(9) </volume> <pages> 160-165, </pages> <month> Sep </month> <year> 1992. </year>
Reference-contexts: Several representation options exist: * Delegation: an extended object is implemented as if having "components" <ref> [NGT92] </ref>: the new features are defined into an object, and the original object (s) become parents, remaining untouched. Dony et al: call these split objects [DMC92].
Reference: [RBP + 91] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Ciffs, NJ 07632, USA, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Recent research and practice have shown that object-oriented analysis (OOA) is a powerful tool for capturing system requirements in the early stages of development (for example, see <ref> [MP92, SM88, WBWW90, RBP + 91] </ref> for some assessment of several OOA techniques). Some of these techniques (e.g. [Ner92, HH82]) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements.
Reference: [SM88] <author> S. Shlaer and S. J. Mellor. </author> <title> Object-Oriented Systems Analysis: Modeling the World in Data. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Ciffs, NJ 07632, USA, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Recent research and practice have shown that object-oriented analysis (OOA) is a powerful tool for capturing system requirements in the early stages of development (for example, see <ref> [MP92, SM88, WBWW90, RBP + 91] </ref> for some assessment of several OOA techniques). Some of these techniques (e.g. [Ner92, HH82]) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements.
Reference: [Ste87] <author> Lynn Andrea Stein. </author> <title> Delegation is inheritance. </title> <booktitle> In OOPSLA, editor, OOPSLA '87: Conference on Object Oriented Programming, Systems, Languages and Applications, </booktitle> <pages> pages 138-146. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <address> Orlando, FL, USA, </address> <month> 4-8 Oct </month> <year> 1987. </year>
Reference-contexts: Our exposition is graphically shown in Figure 4, 7 Not unlike the "cut-and-paste" paradigm. 8 In fact, Stein has shown <ref> [Ste87] </ref> that inheritance is subsumed by delegation. 6 7 immutable monolithic prototype split prototype part location (extension by concatenation) (extension by delegation) individual Figure 2 (a) Figure 2 (b) shared monolithic Figure 4 (c) Figure 4 (d) (traits) spli Figure 4 (a) Figure 4 (b) Table 1: Combining extension and factorization
Reference: [Str86] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley series in computer science. Addison-Wesley, </publisher> <address> 1st edition, </address> <year> 1986. </year>
Reference-contexts: This is the case in class-based [CW85] languages like Smalltalk [GR89] and C ++ <ref> [Str86] </ref>, where "classes" hold both shared members and an implicit prototype. <p> The propagation of changes from the originally extended traits must be done either separately (e.g. by a mechanism supporting a more abstract system on top of this), or in an ad hoc manner. The first one is the way that C ++ objects are implemented <ref> [Str86] </ref>: a large table referencing the class members, and instances with inherited members as sub-parts. The third row considers object models which allow sharing of traits and that the traits itself be a split object. These two cases provide minimal replication for all immutable features in the object workspace. <p> Types provide polymorphism via subtyping, i.e. a type tag T accepts instances of the underlying family of T or of a family underlying any subtype of T. 7.1 Types and Classes Most conventional object-oriented languages [GR89] <ref> [Str86] </ref> [Mey88] combine "classes" (a code reuse abstraction) with "types" (a polymorphism abstraction) under a single linguistic construct. In these cases, each class implicitly defines a type, and subclassing (inheritance of implementation) implicitly defines subtyping.
Reference: [Tai92] <author> Antero Taivalsaari. </author> <title> Kevo a prototype-based object-oriented language based on concatenation and module operartions. </title> <type> Technical Report DCS-197-1R, </type> <institution> University of Victoria,, Victoria, British Columbia, CANADA, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: This alternative is mostly academic, since real systems would quickly suffer the effects of indiscriminate replication of essentially identical material. * System-simulated: the problem is acknowledged, but is is considered just an implementation issue underlying a programmer's vision of objects as fully autonomous. This includes the Kevo language <ref> [Tai92] </ref>, which provides sharing between apparently self-sufficient objects, and the "virtual copies" proposed by Mittal et al [MBK86]. * Via delegation: the sharing is explicit and visible to the programmer, who must determine what is shared and what is individual among clones. <p> avoids redundancy and facilitates change propagation, In Self, objects extended this way are called data-parents of their extensions. * Concatenation: a new object is built by copying the object to be extended and then modifying it to satisfy the required extension. 7 This is the extension paradigm used in Kevo <ref> [Tai92] </ref>. This model is conceptual cleaner than delegation, since it supports self-sufficient objects by avoiding dependencies; on the other hand, it suffers of possible inconsistencies and certainly of replication. <p> The programmer is not aware of object extension, but class extension can take its place. Smalltalk and C++ provide "subclassing", by which the implicit class-held prototypes are actually extended; instances created from a sub-class are themselves monolithic, even though classes themselves are both viewed and implemented as split objects <ref> [Tai92] </ref>. Implicit object extension can also be implemented using split objects or concatenation. 8 3.3 Interaction of policies Let's consider how the interaction of mechanism for redundancy elimination and for objects extension affects object organization modes.
Reference: [UCCH91] <author> David Ungar, Craig Chambers, Bay-Wei Chang, and Urs Holzle. </author> <title> Organizing programs without classes. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4(3), </volume> <month> Jun </month> <year> 1991. </year> <month> 22 </month>
Reference-contexts: This is the model used in the Self language [US87], where "traits" objects hold shared slots, and "prototypes" and their clones hold individual state. The above mentioned approaches can be used to implement this one, as in fact Self <ref> [UCCH91] </ref> uses "maps" to support sharing among clones. * Implicit: the issue of sharing is abstracted into membership in a group denoted by a common description of features. <p> The solutions to this situation (see Figure 5) all involve making the (A) part of 9 Unless the system itself implements one of the other models beneath the programmer's interface, like Self's "maps" <ref> [UCCH91] </ref>. 8 (A + B) proto to be a copy of (A) proto , rather than (A) proto itself; consequently, the advantage of split prototypes are lost. <p> Experience in classless programming <ref> [UCCH91] </ref> has found it reasonable to organize the workspace by providing two separate objects for each group of related and similar objects. The Self World [UCCH91] uses two elements for this purpose: a traits holding the shared behavior and data, and a prototype from which new objects can be cloned. <p> Experience in classless programming <ref> [UCCH91] </ref> has found it reasonable to organize the workspace by providing two separate objects for each group of related and similar objects. The Self World [UCCH91] uses two elements for this purpose: a traits holding the shared behavior and data, and a prototype from which new objects can be cloned. Structural similarity is achieved among clones, and sharing is achieved by making all the clones to delegate on the traits. <p> In the following subsections we introduce a representation for groups, present some operations to create and maintain them, and explain how prospective groups can be identified from the workspace. 5.1 Representation of Groups Groups are similar to the representation for classes in the Self World, as described in <ref> [UCCH91] </ref>. A group is defined using two objects, which can be directly examined and manipulated. They are: * Sharable: an object which slots hold the data and methods shared by all the group instances.
Reference: [US87] <author> David Ungar and Randall B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In OOPSLA, editor, OOPSLA '87: Conference on Object Oriented Programming, Systems, Languages and Applications, </booktitle> <pages> pages 227-241. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <address> Orlando, FL, USA, </address> <month> 4-8 Oct </month> <year> 1987. </year>
Reference-contexts: This is the model used in the Self language <ref> [US87] </ref>, where "traits" objects hold shared slots, and "prototypes" and their clones hold individual state.
Reference: [WBJ90] <author> Rebecca J. Wirfs-Brock and Ralph E. Johnson. </author> <title> Surveying current research in object-oriented design. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 105-124, </pages> <month> Sep </month> <year> 1990. </year>
Reference-contexts: Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; [BS84, Gom83]; and provide the flexible development needed for rapid prototyping [GS81]. Other experiences have shown <ref> [MP92, WBJ90, Boo90, Mey88] </ref> that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability. Classes [GR89] turn the explicit description of individual objects into an intensional description of groups of objects; this simplifies the system description, allows code reuse, and supports change propagation.
Reference: [WBWW90] <author> Rebecca J. Wirfs-Brock, B. Wilkerson, and L. Wiener. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Ciffs, NJ 07632, USA, </address> <year> 1990. </year> <month> 23 </month>
Reference-contexts: 1 Introduction Recent research and practice have shown that object-oriented analysis (OOA) is a powerful tool for capturing system requirements in the early stages of development (for example, see <ref> [MP92, SM88, WBWW90, RBP + 91] </ref> for some assessment of several OOA techniques). Some of these techniques (e.g. [Ner92, HH82]) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements.
References-found: 29

