URL: ftp://wilma.cs.brown.edu/u/mfc/dbpl95.ps.Z
Refering-URL: http://www.cs.brown.edu/software/cokokola/
Root-URL: http://www.cs.brown.edu
Email: mfc@cs.brown.edu  sbz@cs.brown.edu  mhn@cs.brown.edu  
Title: To Form a More Perfect Union (Intersection, Difference)  
Author: Mitch Cherniack Stanley B. Zdonik Marian H. Nodine 
Address: Providence, RI, USA  Providence, RI, USA  Providence, RI, USA  
Affiliation: Brown University  Brown University  Brown University  
Abstract: The AQUA [16] query algebra allows user-defined equivalence relations as arguments to query operators that generalize standard set operations. These predicates determine what objects are included in the query result, and the duplicates that must be removed. While an expressive enhancement, the use of arbitrary equivalence relations to decide set membership can result in sets with counterintuitive behavior, and therefore can make queries return unreasonable results. In this paper, we show that equality predicates assume two roles with respect to sets. Distinguishers differentiate between set members and implicitly give meaning to standard set properties such as set equality. Constructors determine which object from input sets contribute to the query result. The requirements of distinguishers and constructors differ. AQUA's set operators are problematic because they use constructors where distinguishers are required. We propose alternatives to AQUA's set operators that address this limitation.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Serge Abiteboul and Jan Van den Bussche. </author> <title> Deep equality revisited. </title> <editor> In Alberto O. Mendelzon Tok Wang Ling and Laurent Vieille, editors, </editor> <booktitle> Deductive and Object-Oriented Databases, Fourth International Conference, </booktitle> <address> DOOD'95, Singapore, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: by their structure (the depth to which objects are compared) rather than their purpose. 5th International Workshop on Database Programming Languages, Gubbio, Italy, 1995 9 To Form a More Perfect Union (Intersection, Difference) Our thoughts on the requirements on distinguisher equalities resembles work done in [17], [12], [11], [4], [14], <ref> [1] </ref>. From CLU ([17]) we borrow the idea that two objects should be equal if and only if they are indistinguishable. <p> Kosky [14] addresses the issue of when two database instances are equal, but does not consider when two objects belonging to the same database instance are equal. Abiteboul and Van den Bussche <ref> [1] </ref> consider object equality but ignoring how object mutability impacts equality predicate definitions. Finally, [2] and [10] also consider nondeterminism in database query operators. Abiteboul et. al. [2] show that nondeterminism in query operators allows expression of certain polynomial-time (counting) queries as well as opportunities for optimization.
Reference: [2] <author> Serge Abiteboul, Eric Simon, and Victor Vianu. </author> <title> Non-deterministic languages to express deterministic transformations. </title> <booktitle> In Proceedings of the Ninth ACM SIGACT/SIGMOD Symposium on Principles of Database Systems, </booktitle> <pages> pages 218229, </pages> <address> Nashville, Tennesee, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: Kosky [14] addresses the issue of when two database instances are equal, but does not consider when two objects belonging to the same database instance are equal. Abiteboul and Van den Bussche [1] consider object equality but ignoring how object mutability impacts equality predicate definitions. Finally, <ref> [2] </ref> and [10] also consider nondeterminism in database query operators. Abiteboul et. al. [2] show that nondeterminism in query operators allows expression of certain polynomial-time (counting) queries as well as opportunities for optimization. <p> Abiteboul and Van den Bussche [1] consider object equality but ignoring how object mutability impacts equality predicate definitions. Finally, <ref> [2] </ref> and [10] also consider nondeterminism in database query operators. Abiteboul et. al. [2] show that nondeterminism in query operators allows expression of certain polynomial-time (counting) queries as well as opportunities for optimization.
Reference: [3] <author> M. P. Atkinson, C. Lecluse, P. Philbrow, and P. Richard. </author> <title> Design issues in a map language. </title> <editor> In Paris Kanellakis and Joachim W. Schmidt, editors, </editor> <title> Bulk Types & Persistent Data: </title> <booktitle> The Third International Workshop on Database Programming Languages, pages 2032, </booktitle> <address> Nafplion, Greece, August 1991. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: Our work was motivated by recognition of the well-definedness problems of AQUA's nondeterministic operators ([16]) that were described in Section 1. Others (<ref> [3] </ref>, [9], [20]) have considered the role of user-defined equalities in query operators. In [3] and [9], sets are considered tied to a single notion of equality (equivalent in spirit to our distinguisher equality). Constructor equalities are not differentiated. Our discussion of the duality of equality predicates most resembles observations made by Osborn in [20]. However, her perspective is inspired by querying.
Reference: [4] <author> Henry Baker. </author> <title> Equal rights for functional objects or, the more things change, the more they are the same. </title> <journal> OOPS Messenger, </journal> <volume> 4(4):126, </volume> <month> October </month> <year> 1993. </year>
Reference-contexts: Thus integer equality (which might be implemented as a bitwise comparison of bit strings) must necessarily have a different implementation than set equality (which will likely be implemented using looping). For this reason, it is generally accepted ([3], [9], [11], [12], [16], <ref> [4] </ref>) that users should be able to provide their own user-defined equality predicates specific to user-defined types. The query algebra, AQUA [16] takes this philosophy a step further. AQUA permits multiple equality predicates to be used for objects of a given type. <p> predicates but by their structure (the depth to which objects are compared) rather than their purpose. 5th International Workshop on Database Programming Languages, Gubbio, Italy, 1995 9 To Form a More Perfect Union (Intersection, Difference) Our thoughts on the requirements on distinguisher equalities resembles work done in [17], [12], [11], <ref> [4] </ref>, [14], [1]. From CLU ([17]) we borrow the idea that two objects should be equal if and only if they are indistinguishable. <p> This idea is carried further in the object-oriented setting in [12] and [11] which argue that equality definitions should vary according to the mutability of an object, and that equality for mutable objects should always depend on comparisons of identity. Baker <ref> [4] </ref> proposes that equal mutable objects should share side-effects. This differs from congruence in that the effects of mutating one of two equal objects is seen from the other. Guaranteeing shared side-effects for equality predicates is one way to prevent the fission effect.
Reference: [5] <author> Catriel Beeri and Yoram Kornatzky. </author> <title> Algebraic optimization of object-oriented query languages. </title> <editor> In S. Abiteboul and P. C. Kanellakis, editors, </editor> <booktitle> Proceedings of the Third International Conference on Database Theory, number 470 in Lecture Notes in Computer Science, </booktitle> <pages> pages 7288, </pages> <address> Paris, France, </address> <month> December </month> <year> 1990. </year> <title> EATCS, </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: For the axioms shown, we adopt the algebraic set notation used in Larch [13] that includes insert and ff as set constructors. This is in contrast to the polyadic brace notation, f : : : g, used in <ref> [5] </ref> for example. 1 The pervasiveness of distinguisher equality predicates in these definitions helps argue our point that properties held or not held by ' affect the well-behavedness of the set for which it distinguishes members. Below we describe some unreasonable set behaviors that can result from poorly defined distinguishers.
Reference: [6] <author> Mitch Cherniack. </author> <title> Form(ers) over function(s): The KOLA query algebra. </title> <type> Technical report, </type> <institution> Brown University Department of Computer Science, </institution> <month> May </month> <year> 1995. </year> <note> In preparation. </note>
Reference-contexts: The work described here is part of the development of a general-purpose query algebra that is independent of underlying data models. Our algebra, KOLA [8] is combinator-based, and includes the set operators described here as well as other operators described in <ref> [6, 8] </ref>. A Larch formal specification of KOLA, and theorem prover scripts that verify over 300 identities, including those described in Section 3, are described in [6]. <p> Our algebra, KOLA [8] is combinator-based, and includes the set operators described here as well as other operators described in [6, 8]. A Larch formal specification of KOLA, and theorem prover scripts that verify over 300 identities, including those described in Section 3, are described in <ref> [6] </ref>.
Reference: [7] <author> Mitch Cherniack and Stanley B. Zdonik. </author> <title> Applying formal methods to the design of a query optimizer. </title> <type> Technical Report CS-95-41, </type> <institution> Brown University Department of Computer Science, </institution> <month> October </month> <year> 1995. </year>
Reference: [8] <author> Mitch Cherniack and Stanley B. Zdonik. </author> <title> Rule languages and internal algebras for rule-based optimizers. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <address> Montreal, Quebec, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: The work described here is part of the development of a general-purpose query algebra that is independent of underlying data models. Our algebra, KOLA <ref> [8] </ref> is combinator-based, and includes the set operators described here as well as other operators described in [6, 8]. A Larch formal specification of KOLA, and theorem prover scripts that verify over 300 identities, including those described in Section 3, are described in [6]. <p> The work described here is part of the development of a general-purpose query algebra that is independent of underlying data models. Our algebra, KOLA [8] is combinator-based, and includes the set operators described here as well as other operators described in <ref> [6, 8] </ref>. A Larch formal specification of KOLA, and theorem prover scripts that verify over 300 identities, including those described in Section 3, are described in [6].
Reference: [9] <author> Richard Connor, Malcolm Atkinson, Sonia Berman, Quinton Cutts, Graham Kirby, and Ron Morrison. </author> <title> The joy of sets. </title> <booktitle> In Proc. 4th Int'l Workshop on Database Programming Languages, </booktitle> <pages> pages 417433, </pages> <address> New York, New York, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: Thus integer equality (which might be implemented as a bitwise comparison of bit strings) must necessarily have a different implementation than set equality (which will likely be implemented using looping). For this reason, it is generally accepted ([3], <ref> [9] </ref>, [11], [12], [16], [4]) that users should be able to provide their own user-defined equality predicates specific to user-defined types. The query algebra, AQUA [16] takes this philosophy a step further. AQUA permits multiple equality predicates to be used for objects of a given type. <p> Our contributions concern recognizing the dual roles that user-defined equality predicates play with respect to sets, and building an equivalence-parameterized and deterministic set algebra. Our work was motivated by recognition of the well-definedness problems of AQUA's nondeterministic operators ([16]) that were described in Section 1. Others ([3], <ref> [9] </ref>, [20]) have considered the role of user-defined equalities in query operators. In [3] and [9], sets are considered tied to a single notion of equality (equivalent in spirit to our distinguisher equality). Constructor equalities are not differentiated. <p> Our work was motivated by recognition of the well-definedness problems of AQUA's nondeterministic operators ([16]) that were described in Section 1. Others ([3], <ref> [9] </ref>, [20]) have considered the role of user-defined equalities in query operators. In [3] and [9], sets are considered tied to a single notion of equality (equivalent in spirit to our distinguisher equality). Constructor equalities are not differentiated. Our discussion of the duality of equality predicates most resembles observations made by Osborn in [20]. However, her perspective is inspired by querying.
Reference: [10] <author> Jan Van den Bussche and Dirk Van Gucht. </author> <title> Semi-determinism (extended abstract). </title> <booktitle> In Proceedings of the Eleventh ACM SIGACT/SIGMOD Symposium on Principles of Database Systems, </booktitle> <year> 1992. </year>
Reference-contexts: Kosky [14] addresses the issue of when two database instances are equal, but does not consider when two objects belonging to the same database instance are equal. Abiteboul and Van den Bussche [1] consider object equality but ignoring how object mutability impacts equality predicate definitions. Finally, [2] and <ref> [10] </ref> also consider nondeterminism in database query operators. Abiteboul et. al. [2] show that nondeterminism in query operators allows expression of certain polynomial-time (counting) queries as well as opportunities for optimization. We borrow our notion of what makes a nondeterministic operator well-defined from [10]. 5 Conclusions and Further Work This paper <p> Finally, [2] and <ref> [10] </ref> also consider nondeterminism in database query operators. Abiteboul et. al. [2] show that nondeterminism in query operators allows expression of certain polynomial-time (counting) queries as well as opportunities for optimization. We borrow our notion of what makes a nondeterministic operator well-defined from [10]. 5 Conclusions and Further Work This paper has proposed a separation between two fundamental uses of equality: distinguishing and constructing new sets. We have shown that three undesirable behaviors of sets can arise if the distinguisher that is used to compare set members is too weak.
Reference: [11] <author> Peter Grogono and Patrice Chalin. </author> <title> Copying, sharing and aliasing. </title> <booktitle> In Colloquium on Object-Orientation in Databases and Software Engineering, </booktitle> <address> Montreal, Quebec, </address> <year> 1994. </year>
Reference-contexts: Thus integer equality (which might be implemented as a bitwise comparison of bit strings) must necessarily have a different implementation than set equality (which will likely be implemented using looping). For this reason, it is generally accepted ([3], [9], <ref> [11] </ref>, [12], [16], [4]) that users should be able to provide their own user-defined equality predicates specific to user-defined types. The query algebra, AQUA [16] takes this philosophy a step further. AQUA permits multiple equality predicates to be used for objects of a given type. <p> equality predicates but by their structure (the depth to which objects are compared) rather than their purpose. 5th International Workshop on Database Programming Languages, Gubbio, Italy, 1995 9 To Form a More Perfect Union (Intersection, Difference) Our thoughts on the requirements on distinguisher equalities resembles work done in [17], [12], <ref> [11] </ref>, [4], [14], [1]. From CLU ([17]) we borrow the idea that two objects should be equal if and only if they are indistinguishable. This idea is carried further in the object-oriented setting in [12] and [11] which argue that equality definitions should vary according to the mutability of an object, <p> Our thoughts on the requirements on distinguisher equalities resembles work done in [17], [12], <ref> [11] </ref>, [4], [14], [1]. From CLU ([17]) we borrow the idea that two objects should be equal if and only if they are indistinguishable. This idea is carried further in the object-oriented setting in [12] and [11] which argue that equality definitions should vary according to the mutability of an object, and that equality for mutable objects should always depend on comparisons of identity. Baker [4] proposes that equal mutable objects should share side-effects.
Reference: [12] <author> Peter Grogono and Philip Santas. </author> <title> Equality and assignment in object-oriented languages. </title> <booktitle> In EastEurOOPe'93, </booktitle> <pages> pages 191201, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Thus integer equality (which might be implemented as a bitwise comparison of bit strings) must necessarily have a different implementation than set equality (which will likely be implemented using looping). For this reason, it is generally accepted ([3], [9], [11], <ref> [12] </ref>, [16], [4]) that users should be able to provide their own user-defined equality predicates specific to user-defined types. The query algebra, AQUA [16] takes this philosophy a step further. AQUA permits multiple equality predicates to be used for objects of a given type. <p> compares equality predicates but by their structure (the depth to which objects are compared) rather than their purpose. 5th International Workshop on Database Programming Languages, Gubbio, Italy, 1995 9 To Form a More Perfect Union (Intersection, Difference) Our thoughts on the requirements on distinguisher equalities resembles work done in [17], <ref> [12] </ref>, [11], [4], [14], [1]. From CLU ([17]) we borrow the idea that two objects should be equal if and only if they are indistinguishable. This idea is carried further in the object-oriented setting in [12] and [11] which argue that equality definitions should vary according to the mutability of an <p> (Intersection, Difference) Our thoughts on the requirements on distinguisher equalities resembles work done in [17], <ref> [12] </ref>, [11], [4], [14], [1]. From CLU ([17]) we borrow the idea that two objects should be equal if and only if they are indistinguishable. This idea is carried further in the object-oriented setting in [12] and [11] which argue that equality definitions should vary according to the mutability of an object, and that equality for mutable objects should always depend on comparisons of identity. Baker [4] proposes that equal mutable objects should share side-effects.
Reference: [13] <author> J.V. Guttag, J.J. Hornung, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specifications. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: These properties include membership (2 ' ), equality of sets (' fg ) and cardinality (j j ' ). For the axioms shown, we adopt the algebraic set notation used in Larch <ref> [13] </ref> that includes insert and ff as set constructors. <p> We begin by formally defining this operator, and then defining our set operators, [ , " and in terms of ] . Finally, we present proofs of algebraic identities that hold of these operators. These proofs were verified with LP; the theorem prover of Larch <ref> [13] </ref>. 3.1 The Extend Operator (] ) We define the extend operator over sets in terms of a filtering operator, B A . 2 For any two sets A and B, B A consists of all elements in the set B that are equivalent to some element of A.
Reference: [14] <author> Anthony Kosky. </author> <title> Observational distinguishability of databases with object identity. </title> <booktitle> In Proc. 5th Int'l Workshop on Database Programming Languages, </booktitle> <address> Gubbio, Italy, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: but by their structure (the depth to which objects are compared) rather than their purpose. 5th International Workshop on Database Programming Languages, Gubbio, Italy, 1995 9 To Form a More Perfect Union (Intersection, Difference) Our thoughts on the requirements on distinguisher equalities resembles work done in [17], [12], [11], [4], <ref> [14] </ref>, [1]. From CLU ([17]) we borrow the idea that two objects should be equal if and only if they are indistinguishable. <p> Guaranteeing shared side-effects for equality predicates is one way to prevent the fission effect. However, since our notion of persistence also establishes that unequal objects do not become equal (i.e., no fusion), it is a tighter constraint on equality definitions. Kosky <ref> [14] </ref> addresses the issue of when two database instances are equal, but does not consider when two objects belonging to the same database instance are equal. Abiteboul and Van den Bussche [1] consider object equality but ignoring how object mutability impacts equality predicate definitions.
Reference: [15] <author> Christophe Lecluse, Philippe Richard, and Fernando Velez. </author> <title> O 2 , an object oriented data model. </title> <booktitle> In Proceedings of the Conference on the Management of Data, </booktitle> <pages> pages 424433, </pages> <month> June </month> <year> 1988. </year> <booktitle> 5th International Workshop on Database Programming Languages, </booktitle> <month> Gubbio, </month> <title> Italy, 1995 11 To Form a More Perfect Union (Intersection, Difference) </title>
Reference-contexts: Thus, we assume that the underlying system provides support for object identifiers for mutable objects. Object identifiers are assumed to be known only to the system, and are associated with objects throughout their lifetimes. (Typically, object identifiers are implemented as pointers (as in the OID's of <ref> [15] </ref>) although we impose no restrictions on their implementation here.) Two objects with the same object identifier are indistinguishable, even via mutation, and hence are referred to as identical. We assume the existence of base (system-provided) types such as integers, bools and immutable, homogeneous sets.
Reference: [16] <author> Theodore W. Leung, Gail Mitchell, Bharathi Subramanian, Bennet Vance, Scott L. Vandenberg, and Stanley B. Zdonik. </author> <title> The AQUA data model and algebra. </title> <booktitle> In Proc. 4th Int'l Workshop on Database Programming Languages, </booktitle> <address> New York, New York, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: Thus integer equality (which might be implemented as a bitwise comparison of bit strings) must necessarily have a different implementation than set equality (which will likely be implemented using looping). For this reason, it is generally accepted ([3], [9], [11], [12], <ref> [16] </ref>, [4]) that users should be able to provide their own user-defined equality predicates specific to user-defined types. The query algebra, AQUA [16] takes this philosophy a step further. AQUA permits multiple equality predicates to be used for objects of a given type. <p> For this reason, it is generally accepted ([3], [9], [11], [12], <ref> [16] </ref>, [4]) that users should be able to provide their own user-defined equality predicates specific to user-defined types. The query algebra, AQUA [16] takes this philosophy a step further. AQUA permits multiple equality predicates to be used for objects of a given type. This is motivated by the recognition that what makes two objects equal might not only be relative to their representation but also to how they are used. <p> Unlike the equality-parameterized operations of <ref> [16] </ref>, our operations are deterministic. One can get the effect of AQUA's nondeterministic operators by applying a representative choosing operation (such as AQUA's dup elim) over any set resulting from the application of one of our operators. This is because our operators have the same functionality as those of [16] except <p> of <ref> [16] </ref>, our operations are deterministic. One can get the effect of AQUA's nondeterministic operators by applying a representative choosing operation (such as AQUA's dup elim) over any set resulting from the application of one of our operators. This is because our operators have the same functionality as those of [16] except that ours incorporate entire equivalence classes into the result rather than choosing representatives. Of course, if representatives are chosen in subqueries, then the same kinds of problematic behaviors described in Section 1 can be reintroduced. But most queries should not need to choose representatives until the last step.
Reference: [17] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: 2 ' S , e 2 ' T ) Equality of sets (extensionality) j ff j ' = 0 jinsert (e; S)j ' = if e 2 ' S then jSj ' else 1 + jSj ' Cardinality 2.1.2 Symptom 1: Equal Sets that are Distinguishable by Querying In CLU <ref> [17] </ref> it is argued that equality definitions should be congruences; two objects should be equal only if they are indistinguishable. (Two objects are distinguished if they return different values for the same attribute.) This should be no different for sets: equality of sets should establish two sets to be indistinguishable by <p> [21] compares equality predicates but by their structure (the depth to which objects are compared) rather than their purpose. 5th International Workshop on Database Programming Languages, Gubbio, Italy, 1995 9 To Form a More Perfect Union (Intersection, Difference) Our thoughts on the requirements on distinguisher equalities resembles work done in <ref> [17] </ref>, [12], [11], [4], [14], [1]. From CLU ([17]) we borrow the idea that two objects should be equal if and only if they are indistinguishable.
Reference: [18] <author> Barbara Liskov, Paul Johnson, Robert Gruber, and Liuba Shrira. </author> <title> A highly available object repository for use in a heterogeneous distributed system. </title> <editor> In Alan Dearle, Gail M. Shaw, and Stanley B. Zdonik, editors, </editor> <title> Implementing Persistent Object Bases, </title> <booktitle> Principles and Practice, Proceedings of the Fourth International Workshop on Persistent Objects, </booktitle> <address> Martha's Vineyard, MA, USA, </address> <month> September </month> <year> 1990. </year> <month> Morgan-Kaufman. </month>
Reference-contexts: A Larch formal specification of KOLA, and theorem prover scripts that verify over 300 identities, including those described in Section 3, are described in [6]. We are currently concentrating our efforts on integrating KOLA within the Thor <ref> [18] </ref> object server under development at MIT and the EPOQ [19] extensible optimizer under development at Brown. 6 Acknowledgements Special thanks are due to Barbara Liskov and Andrew Myers who inspired our work with thought-provoking questions about what it means for an equality predicate to be well-behaved.
Reference: [19] <author> Marian H. Nodine, Farah B. Abbas, and Mitch Cherniack. </author> <title> The EPOQ query optimizer for object-oriented databases: Design specification, </title> <year> 1994. </year>
Reference-contexts: A Larch formal specification of KOLA, and theorem prover scripts that verify over 300 identities, including those described in Section 3, are described in [6]. We are currently concentrating our efforts on integrating KOLA within the Thor [18] object server under development at MIT and the EPOQ <ref> [19] </ref> extensible optimizer under development at Brown. 6 Acknowledgements Special thanks are due to Barbara Liskov and Andrew Myers who inspired our work with thought-provoking questions about what it means for an equality predicate to be well-behaved.
Reference: [20] <author> S. L. Osborn. </author> <title> Identity, equality and query optimization. </title> <editor> In K. R. Dittrich, editor, </editor> <booktitle> Advances in Object-Oriented Database Systems:Proceedings of the 2nd International Workshop on Object-Oriented Database Systems, number 334 in Lecture Notes in Computer Science, </booktitle> <pages> pages 346351, </pages> <address> Bad Munster am Stein-Ebenburg, FRG, Septem-ber 1988. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Our contributions concern recognizing the dual roles that user-defined equality predicates play with respect to sets, and building an equivalence-parameterized and deterministic set algebra. Our work was motivated by recognition of the well-definedness problems of AQUA's nondeterministic operators ([16]) that were described in Section 1. Others ([3], [9], <ref> [20] </ref>) have considered the role of user-defined equalities in query operators. In [3] and [9], sets are considered tied to a single notion of equality (equivalent in spirit to our distinguisher equality). Constructor equalities are not differentiated. <p> In [3] and [9], sets are considered tied to a single notion of equality (equivalent in spirit to our distinguisher equality). Constructor equalities are not differentiated. Our discussion of the duality of equality predicates most resembles observations made by Osborn in <ref> [20] </ref>. However, her perspective is inspired by querying. She writes that every object should have an identity that can be used for navigational querying as well as an equality that can be used for associative access, but fixes both predicates to be system-defined.
Reference: [21] <author> Gail M. Shaw and Stanley B. Zdonik. </author> <title> Object-oriented queries: Equivalence and optimization. </title> <editor> In Won Kim, Jean-Marie Nicolas, and Shojiro Nishioe, editors, </editor> <booktitle> Proceedings of the The First International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 264278, </pages> <address> Kyoto, Japan, </address> <month> December </month> <year> 1989. </year> <booktitle> 5th International Workshop on Database Programming Languages, </booktitle> <address> Gubbio, Italy, </address> <year> 1995 </year> <month> 12 </month>
Reference-contexts: We recognize that there may be any of a number of equivalences that are appropriate for use for associative access and that not every object should have identity (e.g., rational numbers should be differentiated by their values). <ref> [21] </ref> compares equality predicates but by their structure (the depth to which objects are compared) rather than their purpose. 5th International Workshop on Database Programming Languages, Gubbio, Italy, 1995 9 To Form a More Perfect Union (Intersection, Difference) Our thoughts on the requirements on distinguisher equalities resembles work done in [17],
References-found: 21

