URL: http://www.cs.ucsb.edu/~dsl/Kan/Papers/compos97.ps.gz
Refering-URL: http://www.cs.ucsb.edu/~dsl/Kan/Papers/
Root-URL: http://www.cs.ucsb.edu
Title: Compositional Proofs for Concurrent Objects  
Author: Jerry James and Ambuj Singh 
Address: Santa Barbara, California 93106  
Affiliation: Department of Computer Science University of California, Santa Barbara  
Abstract: Objects are a convenient representation for building compositional open systems. Many object models exist in the literature and building a new proof system for each is infeasible. Instead of constructing a new proof system from first principles, we show how proof methodologies for non-object-oriented systems can be adapted. We give a sample object model that includes inheritance, active objects, and unbounded creation of both objects and threads. We show how a proof system for this model can be built from a modular concurrent logic. We also discuss the reuse of proofs during the construction of subclasses.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-84, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: In short, we need to show that a set of lower level modules (the concrete properties) implement a set of higher level modules (the abstract properties). TLA's Decomposition Theorem is designed for just such a task. The composition of Node <ref> [1] </ref>, . . . , Node [n] has variables that do not appear in the system specification, and takes steps that do not appear there. Thus, we apply the refinement of Figure 11 to the composition. <p> Refinement: concrete to abstract Lemma 1. C (NM ) = NINIT ^ 2 [NNEXT ] hne;no i Proof. NM exhibits finite invisible nondeterminism, so the result follows from Proposition 2 of <ref> [1] </ref>, and Propositions 1 and 2 of [2]. ut Lemma 2. C (M ) = INIT ^ 2 [NEXT ] he;o i Proof. M exhibits finite invisible nondeterminism, so the result follows from Proposition 2 of [1], and Propositions 1 and 2 of [2]. ut Lemma 3. <p> NM exhibits finite invisible nondeterminism, so the result follows from Proposition 2 of <ref> [1] </ref>, and Propositions 1 and 2 of [2]. ut Lemma 2. C (M ) = INIT ^ 2 [NEXT ] he;o i Proof. M exhibits finite invisible nondeterminism, so the result follows from Proposition 2 of [1], and Propositions 1 and 2 of [2]. ut Lemma 3. C (E ) = E Proof. E exhibits finite invisible nondeterminism, so the result follows from Proposition 2 of [1]. ut Lemma 4. NM ^ NE ) Parent = n is stable, n 6= null . <p> M exhibits finite invisible nondeterminism, so the result follows from Proposition 2 of <ref> [1] </ref>, and Propositions 1 and 2 of [2]. ut Lemma 3. C (E ) = E Proof. E exhibits finite invisible nondeterminism, so the result follows from Proposition 2 of [1]. ut Lemma 4. NM ^ NE ) Parent = n is stable, n 6= null . Let: s, s 0 be states, A an action of C (NM ).
Reference: 2. <author> Martn Abadi and Leslie Lamport. </author> <title> Conjoining specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3) </volume> <pages> 507-34, </pages> <month> May </month> <year> 1995. </year> <note> Also SRC Research Report 118. </note>
Reference-contexts: We have chosen to express object properties in TLA [11] (Temporal Logic of Actions), although other concurrent logics could be used. Our proof methodology is founded on the abstract/concrete property dichotomy, and TLA's Composition Theorem <ref> [2] </ref>. We use this theorem to prove an object's abstract properties from its concrete properties, to prove properties of systems of objects, and to prove properties of a subclass while reusing proofs from the parent class where possible. The overall proof methodology is illustrated in Figure 1. <p> Methods share state of the enclosing object; objects send messages to (make method calls on) one another. Hence, either kind of logic may prove awkward for dealing with some constructs. In spite of this difficulty, we have chosen TLA (described in <ref> [2, 11] </ref> and elsewhere in this volume) as our underlying logic. This choice was somewhat arbitrary. Our example could be reworked, for example, to use UNITY [5] with the compositional techniques of Collette and Knapp [6]. Our general method is shown in Figure 1. <p> Refinement: concrete to abstract Lemma 1. C (NM ) = NINIT ^ 2 [NNEXT ] hne;no i Proof. NM exhibits finite invisible nondeterminism, so the result follows from Proposition 2 of [1], and Propositions 1 and 2 of <ref> [2] </ref>. ut Lemma 2. C (M ) = INIT ^ 2 [NEXT ] he;o i Proof. M exhibits finite invisible nondeterminism, so the result follows from Proposition 2 of [1], and Propositions 1 and 2 of [2]. ut Lemma 3. C (E ) = E Proof. <p> the result follows from Proposition 2 of [1], and Propositions 1 and 2 of <ref> [2] </ref>. ut Lemma 2. C (M ) = INIT ^ 2 [NEXT ] he;o i Proof. M exhibits finite invisible nondeterminism, so the result follows from Proposition 2 of [1], and Propositions 1 and 2 of [2]. ut Lemma 3. C (E ) = E Proof. E exhibits finite invisible nondeterminism, so the result follows from Proposition 2 of [1]. ut Lemma 4. NM ^ NE ) Parent = n is stable, n 6= null . <p> Q.E.D. Proof: h4i1, h4i2, h4i3, h4i4, and h4i5. h3i3. Q.E.D. Proof: h3i1, h3i2, and simple propositional logic. h2i3. Q.E.D. Proof: h2i1, h2i2, and the definition of NE i . h1i2. 8 i :: E ^ N j =1 NNEXT j ) NE i Proof: h1i1 and Proposition 6 of <ref> [2] </ref>. h1i3. Q.E.D. Proof: h1i2 and Lemmas 3 and 1. ut Lemma 8. C (E ) +v ^ ^ j=1 C (NM j ) ) C (M ) Proof: h1i1. N Proof: Proposition 5 of [2], with x = he i, e = o, y = hstarted ; thrd i, and <p> ^ N j =1 NNEXT j ) NE i Proof: h1i1 and Proposition 6 of <ref> [2] </ref>. h1i3. Q.E.D. Proof: h1i2 and Lemmas 3 and 1. ut Lemma 8. C (E ) +v ^ ^ j=1 C (NM j ) ) C (M ) Proof: h1i1. N Proof: Proposition 5 of [2], with x = he i, e = o, y = hstarted ; thrd i, and m = i . ^ j=1 C (NM j ) ) C (M ) ^x k = hx 1 ; : : : ; x k1 ; x k+1 ; : : : ; x <p> ACK j ; REPLY j ; NDONE j ! DONE , by the refinement. h3i5. Q.E.D. Proof: h3i1, h3i2, h3i3, and h3i4. h2i3. Q.E.D. Proof: h2i1, h2i2, and the definition of C (M ). h1i3. Q.E.D. Proof: h1i1, h1i2, and Proposition 4 of <ref> [2] </ref>. ut Lemma 9. E ^ ^ j =1 NM j ) M Proof: h1i1. E ^ N Proof: Lemma 8, since E ) C (E ) +v and NM j ) C (NM j ). h1i2. <p> Verify abstract properties of new/modified methods. Step 2 discharges our obligations for unmodified methods; the abstract property still holds. 4 Related Work Non-object-oriented compositional techniques have been pioneered by Barringer, Kuiper, and Pnueli [4], Pnueli [19], Stark [21], Pandya and Joseph [18], Misra [16], and Abadi and Lamport <ref> [2] </ref>, to name some prominent examples. Some of these techniques ([19] and [21]) are compositionally incomplete; that is, some properties of a system cannot be deduced from properties of the modules and the composition rule.
Reference: 3. <author> Henri E. Bal. </author> <title> Programming Distributed Systems. </title> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Our object model is intended to reflect trends we expect to see in real concurrent systems of the future. It is similar to other concurrent object models, such as Orca <ref> [3] </ref> and Java [13]. Initiator 1 Waiting = f2; 3g Waiting = f4; 5g 32 54 (a) Outward phase Caller 1 54 (b) Logical tree Parent Parent ParentParent Gossip Gossip Gossip Gossip Fig. 2. Segall's PIF Algorithm 2.1 Basic Concepts An object is a named, encapsulated state container.
Reference: 4. <author> Howard Barringer, Ruurd Kuiper, and Amir Pnueli. </author> <title> Now you may compose temporal logic specifications. </title> <booktitle> In STOC '84, </booktitle> <pages> pages 51-63, </pages> <address> Washington, D.C., USA, </address> <month> 30 April-2 May </month> <year> 1984. </year>
Reference-contexts: Verify concrete properties of new/modified methods; 2. Reverify environment assumptions of unmodified methods. 3. Verify abstract properties of new/modified methods. Step 2 discharges our obligations for unmodified methods; the abstract property still holds. 4 Related Work Non-object-oriented compositional techniques have been pioneered by Barringer, Kuiper, and Pnueli <ref> [4] </ref>, Pnueli [19], Stark [21], Pandya and Joseph [18], Misra [16], and Abadi and Lamport [2], to name some prominent examples. Some of these techniques ([19] and [21]) are compositionally incomplete; that is, some properties of a system cannot be deduced from properties of the modules and the composition rule.
Reference: 5. <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <year> 1988. </year> <note> Reprinted with corrections, </note> <month> May </month> <year> 1989. </year>
Reference-contexts: Our model and proof methodology are relatively independent of the underlying logic. However, various logics may be easier or harder to work with in the context of this model. State-based models such as TLA [11] and Unity <ref> [5] </ref> favor a shared variable model. Action-based models such as I/O Automata [14] favor a message-passing model. A concurrent object system, however, draws from both kinds of models. Methods share state of the enclosing object; objects send messages to (make method calls on) one another. <p> In spite of this difficulty, we have chosen TLA (described in [2, 11] and elsewhere in this volume) as our underlying logic. This choice was somewhat arbitrary. Our example could be reworked, for example, to use UNITY <ref> [5] </ref> with the compositional techniques of Collette and Knapp [6]. Our general method is shown in Figure 1. We begin with the program text, using language rules to prove that each method implements a concrete property.
Reference: 6. <author> Pierre Collette and Edgar Knapp. </author> <title> A foundation for modular reasoning about safety and progress properties of state-based concurrent programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 183(2) </volume> <pages> 253-79, </pages> <month> September </month> <year> 1997. </year>
Reference-contexts: In spite of this difficulty, we have chosen TLA (described in [2, 11] and elsewhere in this volume) as our underlying logic. This choice was somewhat arbitrary. Our example could be reworked, for example, to use UNITY [5] with the compositional techniques of Collette and Knapp <ref> [6] </ref>. Our general method is shown in Figure 1. We begin with the program text, using language rules to prove that each method implements a concrete property. In our case, this means that we give a TLA representation of each method, based on the language semantics 2 .
Reference: 7. <author> Frank S. de Boer. </author> <title> A proof system for the parallel object-oriented language POOL. </title> <editor> In M. S. Paterson, editor, </editor> <booktitle> ICALP '90, volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 572-85, </pages> <institution> Warwick University, </institution> <address> England, 16-20 July 1990. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Some of these techniques ([19] and [21]) are compositionally incomplete; that is, some properties of a system cannot be deduced from properties of the modules and the composition rule. The POOL object-oriented language is given a proof system by de Boer <ref> [7] </ref> using rely-guarantee properties. The strength of this system is that it handles a dynamic set of processes. However, the composition rule can only prove pure safety properties; there is no composition rule for progress properties. Furthermore, there is no mechanism for dealing with inheritance.
Reference: 8. <author> Wim H. Hesselink. </author> <title> A mechanical proof of Segall's PIF algorithm. </title> <journal> Formal Aspects of Computing, </journal> <volume> 9(2) </volume> <pages> 208-26, </pages> <year> 1997. </year>
Reference-contexts: We employ a single class of objects, Node, with a private method Gossip and a public method Start. Correctness of the algorithm is dependent on a number of environment assumptions, which we state explicitly. Segall's PIF algorithm has been mechanically verified <ref> [8] </ref>. In this paper, we show how our general compositional technique can be applied to its proof. 2 Object Model In this section, we describe an object-oriented programming model, for which we will construct a proof system in Section 3.
Reference: 9. <author> H.-M. Jarvinen, R. Kurki-Suonio, M. Sakkinen, and K. Systa. </author> <title> Object-oriented specification of reactive systems. </title> <booktitle> In Proc. 12th Int. Conf. on Software Eng., </booktitle> <pages> pages 63-71, </pages> <year> 1990. </year>
Reference-contexts: If all classes pass the cooperation test with respect to some invariant I , then the composition of all the rely properties guarantees I and the composition of all guarantee properties. DisCo <ref> [9] </ref> is an object-oriented specification language for reactive systems based on the joint action model of execution (see [10] for an example of its use). It has guarded multi-object actions instead of single-object methods.
Reference: 10. <author> Reino Kurki-Suonio. </author> <title> Incremental specification with joint actions: The RPC-memory specification problem. </title> <editor> In Manfred Broy, Stephan Merz, and Katharina Spies, editors, </editor> <title> Formal Systems Specification: The RPC-Memory Specification Case Study, </title> <booktitle> volume 1169 of Lecture Notes in Computer Science, </booktitle> <pages> pages 375-404. </pages> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1996. </year>
Reference-contexts: DisCo [9] is an object-oriented specification language for reactive systems based on the joint action model of execution (see <ref> [10] </ref> for an example of its use). It has guarded multi-object actions instead of single-object methods. Like our model, DisCo has a formal basis in TLA; i.e., it can be considered another example of an object model with a TLA-based proof system.
Reference: 11. <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: This leads us to distinguish between abstract and concrete properties of an object. Although this distinction is very language-dependent and perhaps somewhat arbitrary, it has been shown to be useful in structuring object class development [22]. We have chosen to express object properties in TLA <ref> [11] </ref> (Temporal Logic of Actions), although other concurrent logics could be used. Our proof methodology is founded on the abstract/concrete property dichotomy, and TLA's Composition Theorem [2]. <p> We expect that other object models can have proof systems constructed in a similar manner. Our model and proof methodology are relatively independent of the underlying logic. However, various logics may be easier or harder to work with in the context of this model. State-based models such as TLA <ref> [11] </ref> and Unity [5] favor a shared variable model. Action-based models such as I/O Automata [14] favor a message-passing model. A concurrent object system, however, draws from both kinds of models. Methods share state of the enclosing object; objects send messages to (make method calls on) one another. <p> Methods share state of the enclosing object; objects send messages to (make method calls on) one another. Hence, either kind of logic may prove awkward for dealing with some constructs. In spite of this difficulty, we have chosen TLA (described in <ref> [2, 11] </ref> and elsewhere in this volume) as our underlying logic. This choice was somewhat arbitrary. Our example could be reworked, for example, to use UNITY [5] with the compositional techniques of Collette and Knapp [6]. Our general method is shown in Figure 1. <p> thread from one wait set to another, we use the following notation: move (t (x ) ; q; s) = t (x ) = Nchoose (q) ^ q 0 = q ft (x )g ^ s 0 = s [ ft (x )g The Choose operator was used by Lamport <ref> [11] </ref> equivalently to Hilbert's * operator [12]; that is, it represents a fixed but arbitrary choice. Our Nchoose 4 Since a method call spawns a new thread, each thread executes in only a single object.
Reference: 12. <author> A. C. Leisenring. </author> <title> Mathematical Logic and Hilbert's *-Symbol. </title> <publisher> Gordon and Breach, </publisher> <address> New York, </address> <year> 1969. </year>
Reference-contexts: another, we use the following notation: move (t (x ) ; q; s) = t (x ) = Nchoose (q) ^ q 0 = q ft (x )g ^ s 0 = s [ ft (x )g The Choose operator was used by Lamport [11] equivalently to Hilbert's * operator <ref> [12] </ref>; that is, it represents a fixed but arbitrary choice. Our Nchoose 4 Since a method call spawns a new thread, each thread executes in only a single object.
Reference: 13. <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <year> 1997. </year>
Reference-contexts: Our object model is intended to reflect trends we expect to see in real concurrent systems of the future. It is similar to other concurrent object models, such as Orca [3] and Java <ref> [13] </ref>. Initiator 1 Waiting = f2; 3g Waiting = f4; 5g 32 54 (a) Outward phase Caller 1 54 (b) Logical tree Parent Parent ParentParent Gossip Gossip Gossip Gossip Fig. 2. Segall's PIF Algorithm 2.1 Basic Concepts An object is a named, encapsulated state container.
Reference: 14. <author> Nancy A. Lynch and Mark Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In PODC '87, </booktitle> <pages> pages 137-51, </pages> <address> Vancouver, British Columbia, Canada, </address> <month> 10-12 August </month> <year> 1987. </year>
Reference-contexts: Our model and proof methodology are relatively independent of the underlying logic. However, various logics may be easier or harder to work with in the context of this model. State-based models such as TLA [11] and Unity [5] favor a shared variable model. Action-based models such as I/O Automata <ref> [14] </ref> favor a message-passing model. A concurrent object system, however, draws from both kinds of models. Methods share state of the enclosing object; objects send messages to (make method calls on) one another. Hence, either kind of logic may prove awkward for dealing with some constructs.
Reference: 15. <author> Rajit Manohar and Paolo A. G. Sivilotti. </author> <title> Composing processes using modified rely-guarantee specifications. </title> <type> Technical Report CS-TR-96-22, </type> <institution> California Institute of Technology, Pasadena, </institution> <address> CA 91125, </address> <month> 12 June </month> <year> 1996. </year>
Reference-contexts: Classes which have had their abstract properties proved in this manner are then composed to prove the property of the system as a whole. Code reuse is achieved through local reasoning and composition, but global reasoning is often difficult to avoid. An example of this problem is given in <ref> [15] </ref>. The authors demonstrate that Segall's PIF algorithm [20] (which they call the "gossip" algorithm) is very hard to reason about compositionally. We use this algorithm to illustrate our ideas, and give a compositional proof of its correctness. The rest of the paper is organized as follows. <p> C (E ) +v ^ n Proof: Lemma 8. h1i3. E ^ n Proof: Lemma 9. h1i4. Q.E.D. Proof: Steps h1i1, h1i2, and h1i3 and the Composition Theorem. ut Notice how the global reasoning needed in this example (see <ref> [15] </ref>) is postponed until the final composition step. This is one of the benefits of our approach; low-level (i.e., concrete) properties can be constructed with purely local reasoning. <p> Its notion of object is somewhat different from ours, due to the use of joint actions rather than threads of control. Manohar and Sivilotti <ref> [15] </ref> provide a non-object-oriented composition rule based on modified rely-guarantee properties. These are rely-guarantee properties which can only refer to local variables (i.e., variables local to the process to which the property refers). They are able to prove both safety and progress properties with their composition rule.
Reference: 16. <author> Jayadev Misra. </author> <title> New UNITY. </title> <note> Unpublished book. </note>
Reference-contexts: Verify abstract properties of new/modified methods. Step 2 discharges our obligations for unmodified methods; the abstract property still holds. 4 Related Work Non-object-oriented compositional techniques have been pioneered by Barringer, Kuiper, and Pnueli [4], Pnueli [19], Stark [21], Pandya and Joseph [18], Misra <ref> [16] </ref>, and Abadi and Lamport [2], to name some prominent examples. Some of these techniques ([19] and [21]) are compositionally incomplete; that is, some properties of a system cannot be deduced from properties of the modules and the composition rule.
Reference: 17. <author> Susan Owicki and David Gries. </author> <title> An axiomatic proof technique for parallel programs I. </title> <journal> Acta Informatica, </journal> <volume> 6(4) </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: The guard may only reference the state of the associated object and the executing thread 1 . A trivial guard is true in all states. The guard plays much the same role as in Owicki and Gries' system <ref> [17] </ref>, ensuring that the local state meets some criterion before the following atomic step takes place. However, our construction differs from their await B then S construction in allowing method calls inside an atomic fragment. We describe method call semantics in Section 2.3.
Reference: 18. <author> Paritosh K. Pandya and Mathai Joseph. </author> <title> P-A logic|a compositional proof system for distributed programs. </title> <journal> Distributed Computing, </journal> <volume> 5(1) </volume> <pages> 37-54, </pages> <year> 1991. </year>
Reference-contexts: Reverify environment assumptions of unmodified methods. 3. Verify abstract properties of new/modified methods. Step 2 discharges our obligations for unmodified methods; the abstract property still holds. 4 Related Work Non-object-oriented compositional techniques have been pioneered by Barringer, Kuiper, and Pnueli [4], Pnueli [19], Stark [21], Pandya and Joseph <ref> [18] </ref>, Misra [16], and Abadi and Lamport [2], to name some prominent examples. Some of these techniques ([19] and [21]) are compositionally incomplete; that is, some properties of a system cannot be deduced from properties of the modules and the composition rule.
Reference: 19. <author> Amir Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <editor> In Krzysztof R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, volume 13 of NATO ASI Series F, </booktitle> <pages> pages 123-44. </pages> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1985. </year>
Reference-contexts: Verify concrete properties of new/modified methods; 2. Reverify environment assumptions of unmodified methods. 3. Verify abstract properties of new/modified methods. Step 2 discharges our obligations for unmodified methods; the abstract property still holds. 4 Related Work Non-object-oriented compositional techniques have been pioneered by Barringer, Kuiper, and Pnueli [4], Pnueli <ref> [19] </ref>, Stark [21], Pandya and Joseph [18], Misra [16], and Abadi and Lamport [2], to name some prominent examples. Some of these techniques ([19] and [21]) are compositionally incomplete; that is, some properties of a system cannot be deduced from properties of the modules and the composition rule.
Reference: 20. <author> Adrian Segall. </author> <title> Distributed network protocols. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> IT-29(2):23-35, </volume> <month> January </month> <year> 1983. </year>
Reference-contexts: Code reuse is achieved through local reasoning and composition, but global reasoning is often difficult to avoid. An example of this problem is given in [15]. The authors demonstrate that Segall's PIF algorithm <ref> [20] </ref> (which they call the "gossip" algorithm) is very hard to reason about compositionally. We use this algorithm to illustrate our ideas, and give a compositional proof of its correctness. The rest of the paper is organized as follows. We first describe Segall's PIF algorithm.
Reference: 21. <author> Eugene W. Stark. </author> <title> A proof technique for rely/guarantee properties. </title> <editor> In S. N. Maheshwari, editor, </editor> <booktitle> FST&TCS '85, volume 206 of Lecture Notes in Computer Science, </booktitle> <pages> pages 369-91, </pages> <address> New Delhi, India, </address> <month> 16-18 December </month> <year> 1985. </year> <note> Springer-Verlag. </note>
Reference-contexts: Reverify environment assumptions of unmodified methods. 3. Verify abstract properties of new/modified methods. Step 2 discharges our obligations for unmodified methods; the abstract property still holds. 4 Related Work Non-object-oriented compositional techniques have been pioneered by Barringer, Kuiper, and Pnueli [4], Pnueli [19], Stark <ref> [21] </ref>, Pandya and Joseph [18], Misra [16], and Abadi and Lamport [2], to name some prominent examples. Some of these techniques ([19] and [21]) are compositionally incomplete; that is, some properties of a system cannot be deduced from properties of the modules and the composition rule. <p> obligations for unmodified methods; the abstract property still holds. 4 Related Work Non-object-oriented compositional techniques have been pioneered by Barringer, Kuiper, and Pnueli [4], Pnueli [19], Stark <ref> [21] </ref>, Pandya and Joseph [18], Misra [16], and Abadi and Lamport [2], to name some prominent examples. Some of these techniques ([19] and [21]) are compositionally incomplete; that is, some properties of a system cannot be deduced from properties of the modules and the composition rule. The POOL object-oriented language is given a proof system by de Boer [7] using rely-guarantee properties.
Reference: 22. <author> Raymie Stata and John V. Guttag. </author> <title> Modular reasoning in the presence of subclass-ing. </title> <booktitle> In OOPSLA '95, </booktitle> <pages> pages 200-14, </pages> <address> Austin, TX, USA, </address> <month> 15-19 October </month> <year> 1995. </year>
Reference-contexts: This leads us to distinguish between abstract and concrete properties of an object. Although this distinction is very language-dependent and perhaps somewhat arbitrary, it has been shown to be useful in structuring object class development <ref> [22] </ref>. We have chosen to express object properties in TLA [11] (Temporal Logic of Actions), although other concurrent logics could be used. Our proof methodology is founded on the abstract/concrete property dichotomy, and TLA's Composition Theorem [2]. <p> However, in the second case we do want internal details. Multiple implementations are possible for any given interface, so construction of a correct subclass often depends on implementation details of the parent class. (See <ref> [22] </ref> for a formal approach to making this distinction.) We call properties of the first type abstract. They refer only to the externally visible portions of the object, respecting the encapsulation boundaries. Properties of the second type are called concrete.
Reference: 23. <author> Guy L. Steele, Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, USA, 2nd edition, </address> <year> 1990. </year>
Reference-contexts: Thus, proofs constructed for one member of a class apply to all instances of that class. For the moment, we assume that class implementations are fixed in advance, so that we may reason from the program text. This assumption does not hold for all languages. For example, Common Lisp <ref> [23] </ref> has a Meta-Object Protocol (MOP) that allows the user to construct and alter classes at runtime. Such systems introduce complexities that we do not address in this paper. 2.2 Segall's PIF Algorithm Revisited graphical form, for a class named Node that implements Segall's PIF algorithm.
Reference: 24. <author> Frits W. Vaandrager. </author> <title> Verification of a distributed summation algorithm. </title> <editor> In Insup Lee and Scott A. Smolka, editors, </editor> <booktitle> CONCUR '95, volume 962 of Lecture Notes in Computer Science, </booktitle> <pages> pages 190-203, </pages> <address> Philadelphia, PA, USA, 21-24 August 1995. </address> <publisher> Springer. </publisher>
Reference-contexts: It is used for both information scattering and gathering operations, such as a distributed summation algorithm <ref> [24] </ref>. The property provided by this algorithm is that the root knows that all nodes in the network have received the gossip, and that the feedback it receives has been collected from all nodes in the network. State Abstract Property Method 1 . . . Abstract Property . . .
References-found: 24

