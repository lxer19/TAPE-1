URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/widom-algebraic-analysis.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/
Root-URL: http://www.cs.berkeley.edu
Email: fbaralis,widomg@cs.stanford.edu  
Title: Algebraic Approach to Rule Analysis in Expert Database Systems  
Author: Elena Baralis Jennifer Widom 
Address: Stanford, CA 94305-2140  
Affiliation: Department of Computer Science Stanford University  
Note: An  
Abstract: Stanford University Computer Science Dept. Technical Report Stan-CS-94-1504, Feb. 1994 Abstract Expert database systems extend the functionality of conventional database systems by providing a facility for creating and automatically executing Condition-Action rules. While Condition-Action rules in database systems are very powerful, they also can be very difficult to program, due to the unstructured and unpredictable nature of rule processing. We provide methods for static analysis of Condition-Action rules; our methods determine whether a given rule set is guaranteed to terminate, and whether rule execution is confluent (has a guaranteed unique final state). Our methods are based on previous methods for analyzing rules in active database systems. We improve considerably on the previous methods by providing analysis criteria that are much less conservative: our methods often determine that a rule set will terminate or is confluent when previous methods could not. Our improved analysis is based on a "propagation" algorithm, which uses a formal approach based on an extended relational algebra to accurately determine when the action of one rule can affect the condition of another. Our algebraic approach yields methods that are applicable to a broad class of expert database rule languages.
Abstract-found: 1
Intro-found: 1
Reference: [AWH92] <author> A. Aiken, J. Widom, and J.M. Hellerstein. </author> <title> Behavior of database production rules: Termination, confluence, and observable determinism. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 59-68, </pages> <address> San Diego, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: It is highly beneficial if the rule programmer can predict in advance some aspects of rule behavior. This can be achieved by providing a facility that statically analyzes a set of rules, before installing the rules in the database <ref> [AWH92] </ref>. Static rule analysis can form the basis of a design methodology and programming environment for expert database systems. As has been observed in the past [AWH92,KU94,vdVS93], two important and desirable properties of rule behavior are termination and confluence. <p> In addition, the methods in [HH91, ZH90] have been shown to be weaker than the methods in <ref> [AWH92] </ref>, which in turn are weaker than the methods we present here. The methods in [AWH92] are developed in the context of the Starburst Rule System, which uses an Event-Condition-Action (active database) rule model. <p> In addition, the methods in [HH91, ZH90] have been shown to be weaker than the methods in <ref> [AWH92] </ref>, which in turn are weaker than the methods we present here. The methods in [AWH92] are developed in the context of the Starburst Rule System, which uses an Event-Condition-Action (active database) rule model. Their technique for analyzing rule interaction relies on a shallow comparison of the actions performed by one rule and the events and conditions of another rule. <p> We present two examples where we apply our analysis techniques to determine that a pair of rules does not produce a cycle in the Activation Graph, i.e. the rules cannot activate each other indefinitely. In both of these examples, the technique in <ref> [AWH92] </ref> is unable to determine that these rules terminate. Example 4.1: Consider rule bad-account (Example 2.1) and rule raise-rate (Example 2.2) that here will be called r 1 and r 2 respectively. Both rule conditions reference attribute rate, and both rule actions update rate. <p> Example 4.1: Consider rule bad-account (Example 2.1) and rule raise-rate (Example 2.2) that here will be called r 1 and r 2 respectively. Both rule conditions reference attribute rate, and both rule actions update rate. Hence, intuitively (and according to the method in <ref> [AWH92] </ref>), the two rules might activate each other indefinitely. <p> Here again, intuitively (and according to the method in <ref> [AWH92] </ref>), the two rules might activate each other indefinitely. We use the Propagation Algorithm to determine if r 1 may activate r 2 . <p> The remainder of this section describes our technique for determining commutativity of rule pairs. Since commutativity itself is a "subroutine" to proving confluence, our commutativity analysis technique also can be applied in other contexts, e.g. <ref> [AWH92] </ref>. Needless to say, we use our Propagation Algorithm to analyze commutativity, exploiting the algebraic description of rule conditions and actions to yield a much more accurate analysis technique than, e.g., [AWH92]. <p> itself is a "subroutine" to proving confluence, our commutativity analysis technique also can be applied in other contexts, e.g. <ref> [AWH92] </ref>. Needless to say, we use our Propagation Algorithm to analyze commutativity, exploiting the algebraic description of rule conditions and actions to yield a much more accurate analysis technique than, e.g., [AWH92]. To guarantee commutativity of two rules r i and r j , we must verify conditions (1), (2), and (3) in Definition 5.4. For (1), we determine that r i cannot activate r j exactly as we have done for termination; recall Section 4. <p> We present two examples where we apply our analysis techniques to determine that a pair of rules are commutative (and hence the set of these two rules is confluent). In both of these examples, the technique in <ref> [AWH92] </ref> is unable to determine that these rules commute. Example 5.1: Consider rule bad-account (Example 2.1) and rule SF-bonus (Example 2.3), that here will be called r 1 and r 2 respectively. Both rules reference attribute rate and both update this attribute. Hence, intuitively (and according to the method in [AWH92]), <p> <ref> [AWH92] </ref> is unable to determine that these rules commute. Example 5.1: Consider rule bad-account (Example 2.1) and rule SF-bonus (Example 2.3), that here will be called r 1 and r 2 respectively. Both rules reference attribute rate and both update this attribute. Hence, intuitively (and according to the method in [AWH92]), the two rules may not commute. We first analyze the effect of r 1 's action on r 2 . Since r 2 's condition does not reference the relation updated by r 1 , r 1 's action trivially cannot affect r 2 's condition. <p> Note that the methods we describe also are applicable to rule languages that "pass data" from the condition to the action (e.g. [GP91, Han92]), since our algorithm detects the actual modifications to rule conditions (inserts, deletes, and updates), not simply the transition between true and false. As in <ref> [AWH92] </ref>, our analysis techniques identify the responsible rules when termination or confluence is not guaranteed; hence, our techniques can be used as the kernel of an interactive development tool that helps rule definers develop sets of rules that are guaranteed to have the desired properties. <p> Priorities restrict the possible execution sequences of rules, making analysis more complex but perhaps more precise. Coupling our accurate analysis of rule interactions with the priority-based methods in <ref> [AWH92] </ref> should immediately produce a quite powerful analysis method for prioritized rules. 22 * Different semantics for rule condition evaluation. In some database rule languages, rule conditions may be evaluated over the entire database, as opposed to considering only "new" data as we have done here.
Reference: [Bar94] <author> E. Baralis. </author> <title> An Algebraic Approach to the Analysis and Optimization of Active Database Rules. </title> <type> PhD thesis, </type> <institution> Politecnico di Torino, Torino, Italy, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Our methods easily extend to multiple actions, usually simply by applying the method once for each action <ref> [Bar94] </ref>. 7 of OPS5 [GP91]; it also is similar to the way many Event-Condition-Action rules appear to be programmed in practice [CW90]. The action E act is a normal data modification operation executed on the current database state. <p> The leaves of the tree are relations, and one of these leaves corresponds to the relation R that is modified by A. (We assume there is only one reference to R in condition C; our method can easily be extended to handle multiple references <ref> [Bar94] </ref>.) Action A is propagated from the affected relation up the query tree, and it may be transformed into one or more different actions (modification operations) during the propagation process. To describe the propagation, we give formal rules specifying how arbitrary actions are propagated through arbitrary nodes of the tree. <p> The proof proceeds step-by-step for each propagation rule given in Tables 3-6, and the proof technique is analogous for all rules. Hence, due to space constraints, we outline the proof procedure for only one propagation rule; see <ref> [Bar94] </ref> for a complete proof. 15 Theorem 3.1: Let Q be the query tree corresponding to a relational expression C and let A be an action performed on a relation in Q.
Reference: [BCW93] <author> E. Baralis, S. Ceri, and J. Widom. </author> <title> Better termination analysis for active databases. </title> <booktitle> In Proceedings of the First International Workshop on Rules in Database Systems, </booktitle> <address> Edinburgh, Scotland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: We improve on this approach significantly by using a formal algebraic model that allows us to accurately analyze the interaction between rules using the semantics of rule conditions and actions. In an initial report we applied our approach to termination only <ref> [BCW93] </ref>; here we refine the techniques in [BCW93] and propose a general framework for analysis of both termination and confluence. In other related work, [vdVS93] analyzes rule behavior in the context of object-oriented active database systems. <p> We improve on this approach significantly by using a formal algebraic model that allows us to accurately analyze the interaction between rules using the semantics of rule conditions and actions. In an initial report we applied our approach to termination only <ref> [BCW93] </ref>; here we refine the techniques in [BCW93] and propose a general framework for analysis of both termination and confluence. In other related work, [vdVS93] analyzes rule behavior in the context of object-oriented active database systems.
Reference: [BFKM85] <author> L. Brownston, R. Farrell, E. Kant, and N. Martin. </author> <title> Programming Expert Systems in OPS5: An Introduction to Rule-Based Programming. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1985. </year>
Reference-contexts: An expert database system is a conventional database system extended with a facility for creating and automatically executing Condition-Action rules. Expert database systems originated by coupling a rule processor for a production rule language such as OPS5 <ref> [BFKM85] </ref> to a conventional DBMS; this approach is taken in, e.g., [Tzv88]. More recently the prevalent approach has been to build rule processing directly into the database system. Examples of recent or ongoing projects in expert database systems are [BM93,DE89,DOS + 92,GP91,SLR88]. <p> In addition, since we take a general approach based on relational algebra, our method is applicable to most expert database systems that use the relational model. 1.1 Previous Related Work In traditional expert systems, i.e. production rule systems such as OPS5 <ref> [BFKM85] </ref>, predicting properties such as termination and confluence is of far less importance than in the database environment; consequently, there has been little (or no) work on rule analysis in traditional expert systems.
Reference: [BM93] <author> D.A. </author> <title> Brant and D.P. Miranker. Index support for rule activation. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 42-48, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference: [BW93] <author> E. Baralis and J. Widom. </author> <title> Using delta relations to optimize condition evaluation in active databases. </title> <type> Technical Report Stan-CS-93-1495, </type> <institution> Computer Science Department, Stanford University, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Furthermore, while the algorithm presented in [LS93] applies to more general queries than we consider here (e.g. recursive queries), their model for database updates is considerably simpler than ours. 3 Finally, our Propagation Algorithm is somewhat related to incremental evaluation, as in <ref> [BW93, QW91, RCBB89] </ref>: both problems address the effect of a database modification on a relational expression.
Reference: [CCRL + 90] <author> S. Ceri, S. Crespi-Reghizzi, L. Lamperti, L. Lavazza, and R. Zicari. Algres: </author> <title> An advanced database for complex applications. </title> <journal> IEEE Software, </journal> <month> June </month> <year> 1990. </year>
Reference-contexts: For details of similar operators see <ref> [CCRL + 90] </ref>; examples are given in later sections. 5 Operation Algebraic expression New database state insert E ins R [ E ins delete E del R . &lt; 69 E del update E upd (R . &lt; 69 E upd ) [ ff A 0 u ;A u ( A
Reference: [CG85] <author> S. Ceri and G. Gottlob. </author> <title> Translating SQL into relational algebra: Optimization, semantics, and equivalence of SQL queries. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(4) </volume> <pages> 324-345, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: The attributes B are optional: when B is omitted, no grouping is performed, and the aggregate function a is applied to the entire result of E, yielding one value; that value is entered into the new attribute X for each tuple of E. For details see <ref> [CG85] </ref>. 2.1.3 Modification Operations We represent data modification operations in relational algebra by characterizing the operations in terms of the database state they produce.
Reference: [CGT90] <author> S. Ceri, G. Gottlob, and L. Tanca. </author> <title> Logic Programming and Databases. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference: [CW90] <author> S. Ceri and J. Widom. </author> <title> Deriving production rules for constraint maintenance. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 566-577, </pages> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: [X = a (A); B] attribute extension and aggregate function evaluation Table 1: Additional algebraic operators 2.1.1 Not-Exists Semijoin The not-exists semijoin operator, . &lt; 69p , is introduced to concisely express negative subqueries as they are expressed in SQL (e.g. not exists); negative subqueries appear frequently in rule definitions <ref> [CW90] </ref>. <p> Our methods easily extend to multiple actions, usually simply by applying the method once for each action [Bar94]. 7 of OPS5 [GP91]; it also is similar to the way many Event-Condition-Action rules appear to be programmed in practice <ref> [CW90] </ref>. The action E act is a normal data modification operation executed on the current database state. In some expert database systems, e.g. [GP91,Han92], a rule's action implicitly operates only on the data "selected" by the condition, rather than on the entire database. <p> We can handle Event-Condition-Action rules that have a semantics similar to our Condition-Action rules, e.g. the event-based rules of Ariel [Han92], with minor modifications to our techniques. (In fact, it is our feeling that event-based rules often are programmed this way in practice, e.g. <ref> [CW90] </ref>.) However, general Event-Condition-Action rules, especially those in which the condition is evaluated over the entire database, will require a redefinition of rule activation (as discussed in the previous point), along with corresponding modifications to our method.
Reference: [DE89] <author> L.M.L. Delcambre and J.N. Etheredge. </author> <title> The Relational Production Language: A production language for relational databases. </title> <editor> In L. Kerschberg, editor, </editor> <booktitle> Expert Database Systems|Proceedings from the Second International Conference, </booktitle> <pages> pages 333-351. </pages> <address> Benjamin/Cummings, Redwood City, California, </address> <year> 1989. </year>
Reference-contexts: If the rule has not previously been evaluated, then E old cond = ;. That is, informally, the condition is true whenever the query produces "new" tuples. This is identical to the interpretation of conditions in the Condition-Action rules of, e.g., Ariel [Han92], RPL <ref> [DE89] </ref>, and set-oriented adaptations 1 For simplicity, we consider rules with a single action here, although many expert database systems allow rules with a sequence of actions.
Reference: [DOS + 92] <author> H.M. Dewan, D. Ohsie, S.J. Stolfo, O. Wolfson, and S. Da Silva. </author> <title> Incremental database rule processing in PARADISER. </title> <journal> Journal of Intelligent Information Systems, </journal> <year> 1992. </year>
Reference: [Elk90] <author> C. Elkan. </author> <title> Independence of logic database queries and updates. </title> <booktitle> In Proceedings of the Ninth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 154-160, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: However, in the future we plan to explore the relationship between these different approaches. Our Propagation Algorithm is closely related to the problem of independence of queries and updates, addressed in, e.g., [Elk90,LS93]. [LS93], which subsumes <ref> [Elk90] </ref>, gives an algorithm for detecting if the outcome of a query, expressed as a Datalog program, can be affected by a given insertion or deletion.
Reference: [GP91] <author> D.N. Gordin and A.J. Pasik. </author> <title> Set-oriented constructs: From Rete rule bases to database systems. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 60-67, </pages> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Our methods easily extend to multiple actions, usually simply by applying the method once for each action [Bar94]. 7 of OPS5 <ref> [GP91] </ref>; it also is similar to the way many Event-Condition-Action rules appear to be programmed in practice [CW90]. The action E act is a normal data modification operation executed on the current database state. <p> Our technique improves considerably upon previous methods, because our formal approach allows us to exploit the semantics of conditions and actions to analyze the interaction between rules. Note that the methods we describe also are applicable to rule languages that "pass data" from the condition to the action (e.g. <ref> [GP91, Han92] </ref>), since our algorithm detects the actual modifications to rule conditions (inserts, deletes, and updates), not simply the transition between true and false.
Reference: [Han92] <author> E.N. Hanson. </author> <title> Rule condition testing and action execution in Ariel. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 49-58, </pages> <address> San Diego, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Corporation and IBM Corporation. y Permanent address: Dipartimento di Automatica e Informatica, Politecnico di Torino, Corso Duca degli Abruzzi, 24-10129 Torino, Italy. 1 actually use the Condition-Action rule paradigm, and hence fall into the class of expert database systems as we use the term here; examples of such systems are <ref> [Han92, SKdM92] </ref>. Since expert database systems evolved from production rule systems such as OPS5 and are closely related to active and deductive database systems, the techniques presented in this paper certainly can be adapted for other database rule paradigms. <p> If the rule has not previously been evaluated, then E old cond = ;. That is, informally, the condition is true whenever the query produces "new" tuples. This is identical to the interpretation of conditions in the Condition-Action rules of, e.g., Ariel <ref> [Han92] </ref>, RPL [DE89], and set-oriented adaptations 1 For simplicity, we consider rules with a single action here, although many expert database systems allow rules with a sequence of actions. <p> Our technique improves considerably upon previous methods, because our formal approach allows us to exploit the semantics of conditions and actions to analyze the interaction between rules. Note that the methods we describe also are applicable to rule languages that "pass data" from the condition to the action (e.g. <ref> [GP91, Han92] </ref>), since our algorithm detects the actual modifications to rule conditions (inserts, deletes, and updates), not simply the transition between true and false. <p> This interpretation yields a different notion of rule activation, since a rule condition remains true unless execution of some rule action renders it false. * Events. We can handle Event-Condition-Action rules that have a semantics similar to our Condition-Action rules, e.g. the event-based rules of Ariel <ref> [Han92] </ref>, with minor modifications to our techniques. (In fact, it is our feeling that event-based rules often are programmed this way in practice, e.g. [CW90].) However, general Event-Condition-Action rules, especially those in which the condition is evaluated over the entire database, will require a redefinition of rule activation (as discussed in
Reference: [HH91] <author> J.M. Hellerstein and M. Hsu. </author> <title> Determinism in partially ordered production systems. </title> <institution> IBM Research Report RJ 8009, IBM Almaden Research Center, </institution> <address> San Jose, California, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: However, the goal of their work is to impose restrictions on rule sets so that confluence (a "unique fixed point" in their model) is guaranteed; we instead provide techniques for analyzing the behavior of arbitrary rule sets. In addition, the methods in <ref> [HH91, ZH90] </ref> have been shown to be weaker than the methods in [AWH92], which in turn are weaker than the methods we present here. The methods in [AWH92] are developed in the context of the Starburst Rule System, which uses an Event-Condition-Action (active database) rule model.
Reference: [HW93] <author> E.N. Hanson and J. Widom. </author> <title> An overview of production rules in database systems. </title> <journal> The Knowledge Engineering Review, </journal> <volume> 8(2) </volume> <pages> 121-143, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction In the past decade there has been a surge of interest in adding rule processing to database systems. Deductive database systems use logic rules to provide an expressive query facility [CGT90,Ull89]. Active database systems use Event-Condition-Action rules to provide reactive behavior <ref> [HW93] </ref>. In this paper we focus on what we refer to as expert database systems. An expert database system is a conventional database system extended with a facility for creating and automatically executing Condition-Action rules. <p> The basic algorithm for rule processing is: repeat until no rule has a true condition: select a rule r with a true condition; execute r's action In this paper, we do not consider the effect of a conflict resolution policy for selecting among multiple rules with true conditions <ref> [HW93] </ref>. However, as an extension to our framework we plan to incorporate conflict resolution using rule priorities; see Section 6. Note also that the "granularity" of rule processing invocation with respect to database modifications [HW93] is irrelevant here in the context of rule analysis. 2.3 Examples In this section we give <p> consider the effect of a conflict resolution policy for selecting among multiple rules with true conditions <ref> [HW93] </ref>. However, as an extension to our framework we plan to incorporate conflict resolution using rule priorities; see Section 6. Note also that the "granularity" of rule processing invocation with respect to database modifications [HW93] is irrelevant here in the context of rule analysis. 2.3 Examples In this section we give the algebraic representation of five rules. These rules will be used as examples throughout the paper.
Reference: [Klu82] <author> A. Klug. </author> <title> Equivalence of relational algebra and relational calculus query languages having aggregate functions. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 699-727, </pages> <year> 1982. </year>
Reference: [KU94] <editor> A.P. Karadimce and S.D. Urban. </editor> <title> Conditional term rewriting as a formal basis for analysis of active database rules. </title> <booktitle> In Fourth International Workshop on Research Issues in Data Engineering (RIDE-ADS '94), </booktitle> <address> Houston, Texas, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: This approach is clearly infeasible in practical applications, so lower complexity algorithms are proposed, but the details and applicability of these algorithms are not clarified. A rather different approach to rule analysis is taken in a recent paper <ref> [KU94] </ref>, where Event-Condition-Action rules are reduced to term rewriting systems, and known analysis techniques for termination and confluence of term rewriting systems are applied.
Reference: [LS93] <author> A. Levy and Y. Sagiv. </author> <title> Queries independent of updates. </title> <booktitle> In Proceedings of the Ninetenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 171-181, </pages> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: However, in the future we plan to explore the relationship between these different approaches. Our Propagation Algorithm is closely related to the problem of independence of queries and updates, addressed in, e.g., [Elk90,LS93]. <ref> [LS93] </ref>, which subsumes [Elk90], gives an algorithm for detecting if the outcome of a query, expressed as a Datalog program, can be affected by a given insertion or deletion. <p> For analyzing expert database rules, we need a somewhat stronger technique: when a query and update are not independent, we need to know whether the update adds to, removes from, or modifies the result of the query. Furthermore, while the algorithm presented in <ref> [LS93] </ref> applies to more general queries than we consider here (e.g. recursive queries), their model for database updates is considerably simpler than ours. 3 Finally, our Propagation Algorithm is somewhat related to incremental evaluation, as in [BW93, QW91, RCBB89]: both problems address the effect of a database modification on a relational
Reference: [QW91] <author> X. Qian and G. Wiederhold. </author> <title> Incremental recomputation of active relational expressions. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 3(3) </volume> <pages> 337-341, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Furthermore, while the algorithm presented in [LS93] applies to more general queries than we consider here (e.g. recursive queries), their model for database updates is considerably simpler than ours. 3 Finally, our Propagation Algorithm is somewhat related to incremental evaluation, as in <ref> [BW93, QW91, RCBB89] </ref>: both problems address the effect of a database modification on a relational expression.
Reference: [RCBB89] <author> A. Rosenthal, S. Chakravarthy, B. Blaustein, and J. Blakeley. </author> <title> Situation monitoring for active databases. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 455-464, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: Furthermore, while the algorithm presented in [LS93] applies to more general queries than we consider here (e.g. recursive queries), their model for database updates is considerably simpler than ours. 3 Finally, our Propagation Algorithm is somewhat related to incremental evaluation, as in <ref> [BW93, QW91, RCBB89] </ref>: both problems address the effect of a database modification on a relational expression.
Reference: [SKdM92] <author> E. Simon, J. Kiernan, and C. de Maindreville. </author> <title> Implementing high level active rules on top of a relational DBMS. </title> <booktitle> In Proceedings of the Eighteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 315-326, </pages> <address> Vancouver, British Columbia, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Corporation and IBM Corporation. y Permanent address: Dipartimento di Automatica e Informatica, Politecnico di Torino, Corso Duca degli Abruzzi, 24-10129 Torino, Italy. 1 actually use the Condition-Action rule paradigm, and hence fall into the class of expert database systems as we use the term here; examples of such systems are <ref> [Han92, SKdM92] </ref>. Since expert database systems evolved from production rule systems such as OPS5 and are closely related to active and deductive database systems, the techniques presented in this paper certainly can be adapted for other database rule paradigms.
Reference: [SLR88] <author> T. Sellis, C.-C. Lin, and L. Raschid. </author> <title> Implementing large production systems in a DBMS environment: </title> <booktitle> Concepts and algorithms. In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 404-412, </pages> <address> Chicago, Illinois, </address> <month> June </month> <year> 1988. </year>
Reference: [Tzv88] <author> A. Tzvieli. </author> <title> On the coupling of a production system shell and a DBMS. </title> <booktitle> In Proceedings of the Third International Conference on Data and Knowledge Bases, </booktitle> <pages> pages 291-309, </pages> <address> Jerusalem, Israel, </address> <month> June </month> <year> 1988. </year> <month> 24 </month>
Reference-contexts: An expert database system is a conventional database system extended with a facility for creating and automatically executing Condition-Action rules. Expert database systems originated by coupling a rule processor for a production rule language such as OPS5 [BFKM85] to a conventional DBMS; this approach is taken in, e.g., <ref> [Tzv88] </ref>. More recently the prevalent approach has been to build rule processing directly into the database system. Examples of recent or ongoing projects in expert database systems are [BM93,DE89,DOS + 92,GP91,SLR88].
Reference: [Ull89] <author> J.D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, Volumes I and II. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, Maryland, </address> <year> 1989. </year>
Reference-contexts: Our extended relational algebra includes the basic relational algebra operators select (), project (), cross-product (fi), natural join (1), union ([), and difference (), which we do not elaborate on here; see <ref> [Ull89] </ref>. The first two lines of Table 1 present useful operators derived from the basic operators, while the next three lines present additional operators that we use. <p> However, for most expressions that arise in practice, either we can see trivially whether the expression is satisfiable (as in examples below), or we can verify satisfiability using the tableau method in <ref> [Ull89] </ref>. 2 2 Note that a "conservative" test for satisfiability is not really a limitation here, since our entire approach is based on syntactic analysis and hence is conservative: when an expression is satisfied we determine only that the condition may be affected, not that the condition necessarily will be affected.
Reference: [vdVS93] <author> L. van der Voort and A. Siebes. </author> <title> Termination and confluence of rule execution. </title> <booktitle> In Proceedings of the Second International Conference on Information and Knowledge Management, </booktitle> <address> Washington, DC, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: In an initial report we applied our approach to termination only [BCW93]; here we refine the techniques in [BCW93] and propose a general framework for analysis of both termination and confluence. In other related work, <ref> [vdVS93] </ref> analyzes rule behavior in the context of object-oriented active database systems. Their work focuses on differences between instance-oriented and set-oriented rules (we consider only set-oriented rules in this paper) and on decidability properties for rule analysis.
Reference: [ZH90] <author> Y. Zhou and M. Hsu. </author> <title> A theory for rule triggering systems. </title> <booktitle> In Advances in Database Technology| EDBT '90, Lecture Notes in Computer Science 416, </booktitle> <pages> pages 407-421. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> March </month> <year> 1990. </year> <month> 25 </month>
Reference-contexts: However, the goal of their work is to impose restrictions on rule sets so that confluence (a "unique fixed point" in their model) is guaranteed; we instead provide techniques for analyzing the behavior of arbitrary rule sets. In addition, the methods in <ref> [HH91, ZH90] </ref> have been shown to be weaker than the methods in [AWH92], which in turn are weaker than the methods we present here. The methods in [AWH92] are developed in the context of the Starburst Rule System, which uses an Event-Condition-Action (active database) rule model.
References-found: 28

