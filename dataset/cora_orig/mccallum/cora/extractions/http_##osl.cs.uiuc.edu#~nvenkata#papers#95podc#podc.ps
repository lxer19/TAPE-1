URL: http://osl.cs.uiuc.edu/~nvenkata/papers/95podc/podc.ps
Refering-URL: http://osl.cs.uiuc.edu/~nvenkata/
Root-URL: http://www.cs.uiuc.edu
Email: nalini@sail.stanford.edu  clt@sail.stanford.edu  
Title: Reasoning about Meta Level Activities in Open Distributed Systems  
Author: Nalini Venkatasubramanian Carolyn Talcott 
Address: 1501 Page Mill Road Palo Alto, CA 94304  Stanford, CA 94305-2140  
Affiliation: Hewlett-Packard Laboratories  Department of Computer Science Stanford University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport. </author> <title> Conjoining specifications. </title> <type> Technical Report 118, </type> <institution> DEC Systems Research Center, </institution> <year> 1994. </year>
Reference-contexts: Thus, standard safety and liveness properties are not adequate to specify components of ODS. Non-interference properties must also be specified and checked. Similar observations have been made for traditional one level systems. For example, in <ref> [1] </ref> Abadi and Lam-port give a method for describing open components of concurrent systems using assumption/guarantee assertions [15]. Assumptions are requirements on the components environment.
Reference: [2] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: The acquaintances that an actor can be given at creation time are among the acquaintances of its creator. An actor can also forget acquaintances. Thus the topology can change dynamically. (See <ref> [14, 2, 3] </ref> for more discussion of the actor model, and for many examples of programming with actors.) Axioms expressing the essential features of actor computation such as the acquaintance relation and ordering of events are given in [7]. <p> Will Clinger [12] developed a powerdomain semantics of actor systems, showing the consistency of these axioms. An interleaving transition system semantics for an actor language is given in [6, 5]. This work builds on the formulation in <ref> [2] </ref> and develops methods for reasoning about equivalence of actor programs. 1.2 The Two Level Approach Open distributed systems should provide strong support for customization and adaptation. Non-reflective systems which support customization do so only on a static basis.
Reference: [3] <author> G. Agha, S. Frtlund, W. Kim, R. Panwar, A. Pat-terson, and D. Sturman. </author> <title> Abstraction and Modularity Mechanisms for Concurrent Computing. </title> <journal> IEEE Parallel and Distributed Technology: Systems and Applications, </journal> <volume> 1(2) </volume> <pages> 3-14, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The acquaintances that an actor can be given at creation time are among the acquaintances of its creator. An actor can also forget acquaintances. Thus the topology can change dynamically. (See <ref> [14, 2, 3] </ref> for more discussion of the actor model, and for many examples of programming with actors.) Axioms expressing the essential features of actor computation such as the acquaintance relation and ordering of events are given in [7]. <p> Reflection also underlies recent work in language and system design that supports customization and separation of design concerns [17, 32]. Representation of dependability protocols as meta-level programs is presented in [4]. Some of the more recent research on actors has focused on coordination structures and meta-architectures <ref> [3] </ref>. None of these languages and systems have a clearly defined semantics. The TLAM (Two Level Actor Machine) model is a first step towards providing a formal semantics for such languages, and a basis for specifying and reasoning about properties of and interactions between components of such systems.
Reference: [4] <author> G. Agha, S. Frtlund, R. Panwar, and D. Sturman. </author> <title> A linguistic framework for dynamic composition of dependability protocols. </title> <booktitle> In Proceedings of the 3rd IFIP Working Conference on Dependable Computing for Critical Applications, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: Reflection has been used in the Muse Operating System [30] for dynamically modifying the system behavior. Reflection also underlies recent work in language and system design that supports customization and separation of design concerns [17, 32]. Representation of dependability protocols as meta-level programs is presented in <ref> [4] </ref>. Some of the more recent research on actors has focused on coordination structures and meta-architectures [3]. None of these languages and systems have a clearly defined semantics.
Reference: [5] <author> G. Agha, I. A. Mason, S. F. Smith, and C. L. Talcott. </author> <title> A foundation for actor computation, </title> <note> 199? to appear. </note>
Reference-contexts: Will Clinger [12] developed a powerdomain semantics of actor systems, showing the consistency of these axioms. An interleaving transition system semantics for an actor language is given in <ref> [6, 5] </ref>. This work builds on the formulation in [2] and develops methods for reasoning about equivalence of actor programs. 1.2 The Two Level Approach Open distributed systems should provide strong support for customization and adaptation. Non-reflective systems which support customization do so only on a static basis.
Reference: [6] <author> G. Agha, I. A. Mason, S. F. Smith, and C. L. Tal-cott. </author> <title> Towards a theory of actor computation. </title> <booktitle> In The Third International Conference on Concurrency Theory (CONCUR '92), volume 630 of Lecture Notes in Computer Science, </booktitle> <pages> pages 565-579. </pages> <publisher> Springer Verlag, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: Will Clinger [12] developed a powerdomain semantics of actor systems, showing the consistency of these axioms. An interleaving transition system semantics for an actor language is given in <ref> [6, 5] </ref>. This work builds on the formulation in [2] and develops methods for reasoning about equivalence of actor programs. 1.2 The Two Level Approach Open distributed systems should provide strong support for customization and adaptation. Non-reflective systems which support customization do so only on a static basis. <p> Base level actors carry out application level computation, while meta-actors are part of the runtime system which manages system resources and controls the runtime behavior of the base level. The application level of the model refines the model of <ref> [6] </ref>, explicitly representing more of the runtime structures and resources. It also abstracts from the choice of a specific programming language, providing a framework for reasoning about heterogeneous systems.
Reference: [7] <author> Henry G. Baker and Carl Hewitt. </author> <title> Laws for communicating parallel processes. </title> <booktitle> In IFIP Congress, </booktitle> <pages> pages 987-992. </pages> <publisher> IFIP, </publisher> <month> August </month> <year> 1977. </year>
Reference-contexts: Thus the topology can change dynamically. (See [14, 2, 3] for more discussion of the actor model, and for many examples of programming with actors.) Axioms expressing the essential features of actor computation such as the acquaintance relation and ordering of events are given in <ref> [7] </ref>. Will Clinger [12] developed a powerdomain semantics of actor systems, showing the consistency of these axioms. An interleaving transition system semantics for an actor language is given in [6, 5].
Reference: [8] <author> Roy Campbell, Nayeem Islam, David Raila, and Peter Madany. </author> <title> Designing and implementing choices: An object-oriented system in c++. </title> <journal> Communications of the ACM, </journal> <pages> pages 117-126, </pages> <year> 1993. </year>
Reference-contexts: Non-reflective systems which support customization do so only on a static basis. In an object-oriented system such as Choices <ref> [8] </ref>, or Spring [13], frameworks may be customized for a particular application. However, once customized, the characteristics may not change dynamically. Traditional reflective systems aim at providing a customizable and adaptable execution of concurrent systems.
Reference: [9] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: determining global states of a distributed system. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <year> 1985. </year>
Reference-contexts: Thus the reachability snapshot service can be used as the basis for design, implementation, and verification of a distributed garbage collection service (cf. [25, 26]). The reachability snapshot specializes the notion of global snapshot of a distributed computation which is an important tool for distributed programming (cf. <ref> [9, 10] </ref>). Reachability allows us to illustrate some of the issues that arise in reasoning about object based systems where object identity is a fundamental concept.
Reference: [10] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Thus the reachability snapshot service can be used as the basis for design, implementation, and verification of a distributed garbage collection service (cf. [25, 26]). The reachability snapshot specializes the notion of global snapshot of a distributed computation which is an important tool for distributed programming (cf. <ref> [9, 10] </ref>). Reachability allows us to illustrate some of the issues that arise in reasoning about object based systems where object identity is a fundamental concept. <p> They have been used to specify and verify a variety of protocols. One difficulty with existing formalisms is that components are not represented as objects of the formalisms, rather as instances signatures and formulae. Thus they do not directly support reasoning about equivalence and transformations. The Unity language <ref> [10] </ref> is a notation for describing systems, the focus of this work has been methods for program specification and development of proof rules that support reasoning about these specifications and their relations. The underlying semantic model is a state transition system.
Reference: [11] <author> K. Mani Chandy. </author> <title> Properties of concurrent programs. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6(6) </volume> <pages> 607-619, </pages> <year> 1994. </year>
Reference-contexts: The basic idea follows principles of program development based on use of high level abstractions that hide much of the implementation complexity. Recent work applying these ideas to distributed computing includes <ref> [11] </ref> where programming tools each with associated proof rules for reasoning about them are proposed. What is new in our work is the application of these ideas to two level systems.
Reference: [12] <author> W. D. Clinger. </author> <title> Foundations of actor semantics. </title> <institution> AI-TR-633, MIT Artificial Intelligence Laboratory, </institution> <month> May </month> <year> 1981. </year>
Reference-contexts: Thus the topology can change dynamically. (See [14, 2, 3] for more discussion of the actor model, and for many examples of programming with actors.) Axioms expressing the essential features of actor computation such as the acquaintance relation and ordering of events are given in [7]. Will Clinger <ref> [12] </ref> developed a powerdomain semantics of actor systems, showing the consistency of these axioms. An interleaving transition system semantics for an actor language is given in [6, 5].
Reference: [13] <author> Graham Hamilton, Michael Powell, and James Mitchell. Subcontract: </author> <title> A flexible base for distributed programming. </title> <booktitle> In ACM Symposium on Operating System Principles, </booktitle> <pages> pages 69-79, </pages> <year> 1993. </year>
Reference-contexts: Non-reflective systems which support customization do so only on a static basis. In an object-oriented system such as Choices [8], or Spring <ref> [13] </ref>, frameworks may be customized for a particular application. However, once customized, the characteristics may not change dynamically. Traditional reflective systems aim at providing a customizable and adaptable execution of concurrent systems.
Reference: [14] <author> C. Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Journal of Artificial Intelligence, </journal> <volume> 8(3) </volume> <pages> 323-364, </pages> <year> 1977. </year>
Reference-contexts: The acquaintances that an actor can be given at creation time are among the acquaintances of its creator. An actor can also forget acquaintances. Thus the topology can change dynamically. (See <ref> [14, 2, 3] </ref> for more discussion of the actor model, and for many examples of programming with actors.) Axioms expressing the essential features of actor computation such as the acquaintance relation and ordering of events are given in [7].
Reference: [15] <author> C. B. Jones. </author> <title> Specification and design of parallel programs. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of the IFIP 9th World Congress, </booktitle> <pages> pages 321-332, </pages> <year> 1983. </year>
Reference-contexts: Non-interference properties must also be specified and checked. Similar observations have been made for traditional one level systems. For example, in [1] Abadi and Lam-port give a method for describing open components of concurrent systems using assumption/guarantee assertions <ref> [15] </ref>. Assumptions are requirements on the components environment. Here we consider object based systems and have the additional important problem of ensuring that meta-level activities do not have unintended effects on the base level semantics.
Reference: [16] <author> D. Kafura, D. Washabaugh, and J. Nelson. </author> <title> Garbage collection of actors. </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> Proceedings 1990 ECOOP/OOPSLA, </booktitle> <pages> pages 126-134. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: It characterizes the potential for communication of one actor with another. It is also the basis for memory management and other resource management activities. We use a reach-ability operator based on <ref> [16] </ref>. ReachO (A; B ; R) is the set of actors potentially reachable from a root set R, assuming acquaintance relation A, and busy status predicate B . An actor is considered busy if it is enabled for execution, or has an undelivered message.
Reference: [17] <author> Gregor Kiczales, Jim des Riviers, and DanielG. Bo-brow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: A reflective implementation of object migration is reported in [29]. Reflection has been used in the Muse Operating System [30] for dynamically modifying the system behavior. Reflection also underlies recent work in language and system design that supports customization and separation of design concerns <ref> [17, 32] </ref>. Representation of dependability protocols as meta-level programs is presented in [4]. Some of the more recent research on actors has focused on coordination structures and meta-architectures [3]. None of these languages and systems have a clearly defined semantics.
Reference: [18] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference-contexts: These include formalisms based on temporal logic <ref> [21, 18, 19] </ref>, behavior histories [22], and I/O automata [20]. These formalisms provide a general framework for specifying safety and liveness properties and a means of organizing proofs. They have been used to specify and verify a variety of protocols.
Reference: [19] <author> L. Lamport. </author> <title> The temporal logic of actions. </title> <type> Technical Report 79, </type> <institution> DEC Systems Research Center, </institution> <year> 1991. </year> <note> To appear in ACM TOPLAS. </note>
Reference-contexts: These include formalisms based on temporal logic <ref> [21, 18, 19] </ref>, behavior histories [22], and I/O automata [20]. These formalisms provide a general framework for specifying safety and liveness properties and a means of organizing proofs. They have been used to specify and verify a variety of protocols.
Reference: [20] <author> N. A. Lynch and M. R. Tuttle. </author> <title> An introduction to input/output automata. </title> <type> Technical Report MIT/LCS/TM-373, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1988. </year>
Reference-contexts: These include formalisms based on temporal logic [21, 18, 19], behavior histories [22], and I/O automata <ref> [20] </ref>. These formalisms provide a general framework for specifying safety and liveness properties and a means of organizing proofs. They have been used to specify and verify a variety of protocols.
Reference: [21] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Programs. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: These include formalisms based on temporal logic <ref> [21, 18, 19] </ref>, behavior histories [22], and I/O automata [20]. These formalisms provide a general framework for specifying safety and liveness properties and a means of organizing proofs. They have been used to specify and verify a variety of protocols.
Reference: [22] <author> V. Nguyen, D. Demers, A.and Gries, and S. Owicki. </author> <title> A model and temporal proof system for networks of processes. </title> <journal> Distributed Computing, </journal> <volume> 1 </volume> <pages> 7-25, </pages> <year> 1986. </year>
Reference-contexts: These include formalisms based on temporal logic [21, 18, 19], behavior histories <ref> [22] </ref>, and I/O automata [20]. These formalisms provide a general framework for specifying safety and liveness properties and a means of organizing proofs. They have been used to specify and verify a variety of protocols.
Reference: [23] <author> H. Okamura, Y. Ishikawa, and M. Tokoro. Al-1/d: </author> <title> A distributed programming system with multi-model reflection framework. </title> <editor> In A. Yonezawa and B. C. Smith, editors, </editor> <booktitle> Reflection and Meta-Level Architetures, </booktitle> <pages> pages 36-47. </pages> <booktitle> ACM SIGPLAN, </booktitle> <year> 1992. </year>
Reference-contexts: Meta-actors communicate with each other via message passing as do base level actors, but they may also examine and modify the state of the base actors located on the same node. The multi-model reflective framework for distributed object computation (MMRF) <ref> [23] </ref> has many of the same motivations and objectives as the TLAM framework. We briefly compare the two approaches. In MMRF an object is represented by multiple models allowing behavior to be described at different levels of abstraction.
Reference: [24] <author> M. van Sinderen, L. F. Pires, and C. A. Vissers. </author> <title> Design concepts for open distributed systems. </title> <editor> In J. de Meer, B. Mahr, and S. Storp, editors, </editor> <booktitle> Proceedings of Open Distributed Computing II, </booktitle> <pages> pages 369-371. </pages> <publisher> North-Holland, </publisher> <year> 1993. </year> <title> IFIP Transactions - C, </title> <publisher> IFIP TC6/WG6.1 ODP. </publisher>
Reference-contexts: Our various levels of abstraction include levels similar in spirit to the three abstraction levels identified in the OSI reference model and proposed to strengthen the enterprise level of the ODP Reference Model in <ref> [24] </ref>. These levels are: the combined behavior of a system and its environment (service); the role of the system in this combined behavior (service provider); and the decomposition of this role (protocol).
Reference: [25] <author> N. Venkatasubramanian. </author> <title> Hierarchical garbage collection in scalable distributed systems. </title> <type> Master's thesis, </type> <institution> University of Illinois, Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: The TLAM model can be used to show that a reachability snapshot is a safe criterion to be used for garbage collection. Thus the reachability snapshot service can be used as the basis for design, implementation, and verification of a distributed garbage collection service (cf. <ref> [25, 26] </ref>). The reachability snapshot specializes the notion of global snapshot of a distributed computation which is an important tool for distributed programming (cf. [9, 10]). Reachability allows us to illustrate some of the issues that arise in reasoning about object based systems where object identity is a fundamental concept. <p> Snapshot Behavior is specified relative to a meta actor snapServer, and a map snapM assigning to each node a worker snapshot meta actor. We give only a very brief indication of this behavior here. The specification is based on a 3 phase algorithm described in more detail in <ref> [25, 26] </ref>. The intuition is that in a stable situation each worker is simply maintaining the existing recording (phase U).
Reference: [26] <author> N. Venkatasubramanian, G. Agha, and C. L. Talcott. </author> <title> Scalable distributed garbage collection for systems of active objects. </title> <booktitle> In International Workshop on Memory Management, </booktitle> <address> IWMM92, Saint-Malo, </address> <publisher> LNCS, </publisher> <year> 1992. </year>
Reference-contexts: The TLAM model can be used to show that a reachability snapshot is a safe criterion to be used for garbage collection. Thus the reachability snapshot service can be used as the basis for design, implementation, and verification of a distributed garbage collection service (cf. <ref> [25, 26] </ref>). The reachability snapshot specializes the notion of global snapshot of a distributed computation which is an important tool for distributed programming (cf. [9, 10]). Reachability allows us to illustrate some of the issues that arise in reasoning about object based systems where object identity is a fundamental concept. <p> Snapshot Behavior is specified relative to a meta actor snapServer, and a map snapM assigning to each node a worker snapshot meta actor. We give only a very brief indication of this behavior here. The specification is based on a 3 phase algorithm described in more detail in <ref> [25, 26] </ref>. The intuition is that in a stable situation each worker is simply maintaining the existing recording (phase U).
Reference: [27] <author> N. Venkatasubramanian and C. L. Talcott. </author> <title> A metaar-chitecture for distributed resource management. </title> <booktitle> In Hawaii International Conference on System Sciences, </booktitle> <address> HICSS-26, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: The TLAM (Two Level Actor Machine) model is a first step towards providing a formal semantics for such languages, and a basis for specifying and reasoning about properties of and interactions between components of such systems. A preliminary version of this model was presented in <ref> [27] </ref>. In the TLAM, a system is composed of two kinds of actors, base actors and meta actors, distributed over a network of processing nodes.
Reference: [28] <author> N. Venkatasubramanian and C. L. Talcott. </author> <title> Integration of resource management activities in distributed systems. </title> <type> Technical Report Forthcoming, </type> <institution> Stanford University Computer Science Department, </institution> <year> 1995. </year>
Reference-contexts: Section 4 contains conclusions and discusses further research directions. In this paper we only give informal definitions of the structures and concepts introduced. Proofs are omitted except for occasional discussion of key ideas or assumptions. In <ref> [28] </ref> more detailed mathematical definitions are provided, additional properties are discussed, and proofs of properties are given in more detail. 2 The TLAM Model A Summary A two-level actor machine (TLAM) consists of a two level actor system (TLAS) distributed over a network of processor nodes and communication links.
Reference: [29] <author> T. Watanabe and A. Yonezawa. </author> <title> An actor-based met-alevel architecture for group-wide reflection. </title> <booktitle> In Foundations of Object Oriented Languages, </booktitle> <pages> pages 405-425. </pages> <year> 1990. </year>
Reference-contexts: Traditional reflective systems aim at providing a customizable and adaptable execution of concurrent systems. For example, the scheduling problem of the Time Warp algorithm for parallel discrete event simulation is modeled by means of reflection in [31]. A reflective implementation of object migration is reported in <ref> [29] </ref>. Reflection has been used in the Muse Operating System [30] for dynamically modifying the system behavior. Reflection also underlies recent work in language and system design that supports customization and separation of design concerns [17, 32]. Representation of dependability protocols as meta-level programs is presented in [4].
Reference: [30] <author> Y. Yokote, A. Mitsuzawa, N. Fujinami, and M. Tokoro. </author> <title> The muse object architecture: A new operating system structuring concept. </title> <type> Technical report, </type> <institution> Sony Computer Science Laboratory, </institution> <year> 1991. </year>
Reference-contexts: For example, the scheduling problem of the Time Warp algorithm for parallel discrete event simulation is modeled by means of reflection in [31]. A reflective implementation of object migration is reported in [29]. Reflection has been used in the Muse Operating System <ref> [30] </ref> for dynamically modifying the system behavior. Reflection also underlies recent work in language and system design that supports customization and separation of design concerns [17, 32]. Representation of dependability protocols as meta-level programs is presented in [4].
Reference: [31] <author> A. Yonezawa. </author> <title> Reflection in an object-oriented concurrent language. In ABCL: </title> <booktitle> A Object Oriented Concurrent System, </booktitle> <pages> pages 45-70. </pages> <year> 1990. </year>
Reference-contexts: However, once customized, the characteristics may not change dynamically. Traditional reflective systems aim at providing a customizable and adaptable execution of concurrent systems. For example, the scheduling problem of the Time Warp algorithm for parallel discrete event simulation is modeled by means of reflection in <ref> [31] </ref>. A reflective implementation of object migration is reported in [29]. Reflection has been used in the Muse Operating System [30] for dynamically modifying the system behavior. Reflection also underlies recent work in language and system design that supports customization and separation of design concerns [17, 32].
Reference: [32] <author> A. Yonezawa and B. C. Smith, </author> <title> editors. Reflection and Meta-Level Architecture. </title> <booktitle> ACM SIGPLAN, </booktitle> <year> 1992. </year>
Reference-contexts: A reflective implementation of object migration is reported in [29]. Reflection has been used in the Muse Operating System [30] for dynamically modifying the system behavior. Reflection also underlies recent work in language and system design that supports customization and separation of design concerns <ref> [17, 32] </ref>. Representation of dependability protocols as meta-level programs is presented in [4]. Some of the more recent research on actors has focused on coordination structures and meta-architectures [3]. None of these languages and systems have a clearly defined semantics.
References-found: 32

