URL: http://www.cs.colorado.edu/~klauser/papers/coll-rate.ps.gz
Refering-URL: http://www.cs.colorado.edu/~klauser/publications.html
Root-URL: http://www.cs.colorado.edu
Title: Effectively Controlling Garbage Collection Rates in Object Databases  
Author: Jonathan E. Cook, Artur W. Klauser, Alexander L. Wolf, and Benjamin G. Zorn and 
Date: October 1994  
Address: Campus Box 430  Boulder, CO 80309-0430 USA  Klosterwiesgasse 32/I 8010 Graz, Austria  Boulder  
Affiliation: Department of Computer Science  University of Colorado  Institute for Applied Information Processing Graz University of Technology  ffi University of Colorado at  
Pubnum: CU-CS-XXX-94  
Abstract: Technical Report CU-CS-XXX-94 Department of Computer Science Campus Box 430 University of Colorado Boulder, Colorado 80309 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anders Bjornerstedt. </author> <title> Secondary Storage Garbage Collection for Decentralized Object-Based Systems. </title> <type> PhD thesis, </type> <institution> Stockholm University, Dept. of Comp. Sys. Sciences, Royal Inst. of Tech. and Stockholm Univ., Kista, Sweden, </institution> <year> 1993. </year> <note> Also appears as Systems Dev. </note> <institution> and AI Lab. </institution> <note> Report No. 77. </note>
Reference-contexts: low overhead in counting the number of pointer stores performed in an object database, counting the stores in a programming language algorithm would incur significant overhead. 2.2 Object Database Garbage Collection There has been a significant amount of research in object database garbage collection, much of which is quite recent <ref> [1, 2, 3, 9, 16, 13, 14, 20] </ref>. Here, we discuss the research that most closely relates to our current work. Both Butler [2] and Yong et al [20] show that existing programming language garbage collection algorithms have inadequate performance when used in database systems.
Reference: [2] <author> Margaret H. Butler. </author> <title> Storage reclamation in object-oriented database systems. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 410-423, </pages> <address> San Francisco, CA, </address> <year> 1987. </year>
Reference-contexts: low overhead in counting the number of pointer stores performed in an object database, counting the stores in a programming language algorithm would incur significant overhead. 2.2 Object Database Garbage Collection There has been a significant amount of research in object database garbage collection, much of which is quite recent <ref> [1, 2, 3, 9, 16, 13, 14, 20] </ref>. Here, we discuss the research that most closely relates to our current work. Both Butler [2] and Yong et al [20] show that existing programming language garbage collection algorithms have inadequate performance when used in database systems. <p> Here, we discuss the research that most closely relates to our current work. Both Butler <ref> [2] </ref> and Yong et al [20] show that existing programming language garbage collection algorithms have inadequate performance when used in database systems.
Reference: [3] <author> Jack Campin and Malcolm Atkinson. </author> <title> A persistent store garbage collector with statistical facilities. Persistent Programming Reserarch Report 29, </title> <institution> Department of Computing Science, University of Glasgow, </institution> <address> Glasgow, Scotland, </address> <year> 1986. </year>
Reference-contexts: low overhead in counting the number of pointer stores performed in an object database, counting the stores in a programming language algorithm would incur significant overhead. 2.2 Object Database Garbage Collection There has been a significant amount of research in object database garbage collection, much of which is quite recent <ref> [1, 2, 3, 9, 16, 13, 14, 20] </ref>. Here, we discuss the research that most closely relates to our current work. Both Butler [2] and Yong et al [20] show that existing programming language garbage collection algorithms have inadequate performance when used in database systems.
Reference: [4] <author> Michael J. Carey, David J. DeWitt, and Jeffrey F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 12-21, </pages> <address> Washington, DC, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Figures 1 and 2 show the effect of varying the collection rate on the I/O performance and on the total garbage collected in a test database. (Specific details of the test database, an instance of the OO7 benchmark <ref> [4] </ref>, are discussed in Section 4.3.) The figures highlight the time/space tradeoff 1 2 of collection rate policies. <p> We present a performance evaluation of our two new collection rate policies based on trace-driven simulations of two, very different database applications. One is the application developed by Yong, Naughton, and Yu [20] for the OO7 benchmark <ref> [4] </ref> and the other is based on the our own augmented binary tree application [9]. Our results show that our semi-automatic collection rate policies give excellent performance in all cases and often provide performance close to that of the best fixed-rate policy. <p> In this work, we build on the results of our previous work by using the most effective partition selection policy previously discovered. We also extend the domain of our simulations in this work by including results from the OO7 benchmark <ref> [4] </ref>. In this paper we again assume that a partitioned garbage collection algorithm is used. For a detailed discussion of the implementation issues related to partitioned garbage collection, we refer readers to our previous paper. <p> Traces of database application events (e.g., object creations, accesses, modifications) are used to drive the simulations; details appear in [8]. For the work described here, we use traces derived from two sources: our own synthetic database, ABT, which we have used in previous work, and the OO7 benchmark database <ref> [4] </ref>. Details of the test databases are provided below. 14 One advantage of using trace-driven simulation is that we are able to evaluate and compare the performance of impractical-to-implement heuristics like the SAGA GarbageOracle policy. <p> The figure was generated automatically from that trace and drawn using DOT [12]. The second test database is the OO7 benchmark, which was also used by Yong, Naughton, and Yu in their work on garbage collection [20]. OO7 has been extensively described elsewhere <ref> [4] </ref>. For our purposes, it is important to note that OO7 has a much higher connectivity than ABT and that OO7 applications, unlike ABT applications, operate in distinct phases of long object traversals intersperses with significant database reorganizations. <p> These policies are self-adaptive in that they dynamically respond to changes in the application behavior over time. We evaluated our proposed policies in the context of two very different object databases: ABT, an augmented binary tree database [9], and OO7, a more highly-connected benchmark object database <ref> [4] </ref>. Both of these databases have been used in previous object database garbage collection studies [9, 20]. Our results show that our SAIO policy is very effective at achieving the user-specified GC I/O percentage.
Reference: [5] <author> R.G.G. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: A number of recent research papers have considered some of the important aspects of the correctness and performance of ODBMS garbage collection [9, 13, 14, 20]. A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS <ref> [5] </ref>. Commercial ODBMSs are even beginning to provide implementations of garbage collection (e.g., [10]). In a previous paper [9] we presented a framework for investigating the issues surrounding partitioned garbage collection of ODBMSs.
Reference: [6] <author> C. J. </author> <title> Cheney. A nonrecursive list compacting algorithm. </title> <journal> Comm. of the ACM, </journal> <volume> 13(11) </volume> <pages> 677-678, </pages> <month> November </month> <year> 1970. </year>
Reference-contexts: Here we give just a brief review of the important aspects of that algorithm. We use a copying garbage collector <ref> [6] </ref> in which objects are relocated as a result of collection. This allows garbage collection to not only reclaim the space occupied by garbage but also to compact the collected partition's live objects for improved reference locality. Copying is done in a breadth-first traversal from the partition's roots.
Reference: [7] <author> Jacques Cohen. </author> <title> Garbage collection of linked data structures. </title> <journal> ACM Computing Surveys, </journal> <volume> 13(3) </volume> <pages> 341-367, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: Usually such policies include heuristics for growing the heap if not enough storage is reclaimed by a collection <ref> [7, 19] </ref>. 4 Another common approach to determining when to collect is to collect after a fixed amount of storage has been allocated. For example, in some systems, collections will occur after every megabyte of storage is allocated. These schemes avoid the potential thrashing behavior associated with the "collect-as-needed" policies.
Reference: [8] <author> Jonathan Cook, Alexander Wolf, and Benjamin Zorn. </author> <title> The design of a simulation system for persistent object storage management. </title> <type> Technical Report CU-CS-647-93, </type> <institution> Department of Computer Science, University of Colorado, Boulder, CO, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Traces of database application events (e.g., object creations, accesses, modifications) are used to drive the simulations; details appear in <ref> [8] </ref>. For the work described here, we use traces derived from two sources: our own synthetic database, ABT, which we have used in previous work, and the OO7 benchmark database [4].
Reference: [9] <author> Jonathan Cook, Alexander Wolf, and Benjamin Zorn. </author> <title> Partition selection policies in object database garbage collection. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <publisher> page unknown, </publisher> <address> Minneapolis, MN, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Automatic storage reclamation, or garbage collection (GC), is becoming recognized as an important new feature for object database management systems (ODBMSs). A number of recent research papers have considered some of the important aspects of the correctness and performance of ODBMS garbage collection <ref> [9, 13, 14, 20] </ref>. A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS [5]. Commercial ODBMSs are even beginning to provide implementations of garbage collection (e.g., [10]). <p> A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS [5]. Commercial ODBMSs are even beginning to provide implementations of garbage collection (e.g., [10]). In a previous paper <ref> [9] </ref> we presented a framework for investigating the issues surrounding partitioned garbage collection of ODBMSs. Partitioned collection is an incremental technique based on manipulating disjoint portions of a database [20] and is akin to generational collection in programming language systems [19]. <p> One is the application developed by Yong, Naughton, and Yu [20] for the OO7 benchmark [4] and the other is based on the our own augmented binary tree application <ref> [9] </ref>. Our results show that our semi-automatic collection rate policies give excellent performance in all cases and often provide performance close to that of the best fixed-rate policy. By "best", we mean the fixed rate that corresponds exactly to the user-specified constraint. <p> low overhead in counting the number of pointer stores performed in an object database, counting the stores in a programming language algorithm would incur significant overhead. 2.2 Object Database Garbage Collection There has been a significant amount of research in object database garbage collection, much of which is quite recent <ref> [1, 2, 3, 9, 16, 13, 14, 20] </ref>. Here, we discuss the research that most closely relates to our current work. Both Butler [2] and Yong et al [20] show that existing programming language garbage collection algorithms have inadequate performance when used in database systems. <p> is triggered either when free-space becomes unavailable or after a fixed amount of storage is allocated; these techniques are both taken directly from programming language GC algorithms. 5 In previous work, we investigated the impact of the partition selection policy on the performance of partitioned garbage collection in object databases <ref> [9] </ref>. In that work, we assumed that the collection rate was set at a fixed value. This paper compliments our previous work by investigating another, orthogonal garbage collection policy, that of determining the collection rate. <p> CurrGarbage can be easily determined by noting how much free space is available in the partition before and after it is collected. The Global heuristic estimates garbage by relating the amount of garbage reclaimed to the number of overwritten pointers into a partition. Recall that in previous work <ref> [9] </ref>, we showed that 12 using the number of overwritten pointers into a partition was an excellent heuristic for identifying the partition with the most garbage. We extend that notion with this heuristic in the following way. <p> The partitioned collection algorithm used in our experiments is the same as the one described in our previous paper <ref> [9] </ref>, so we refer the reader to that paper for details. Here we give just a brief review of the important aspects of that algorithm. We use a copying garbage collector [6] in which objects are relocated as a result of collection. <p> In terms of selecting a partition from which to reclaim garbage, all the test databases use the UpdatedPointer policy, which we previously showed to be superior to other existing policies <ref> [9] </ref>. 4.2 Simulation Environment Our simulation system mimics the physical and logical structure of the database implementation being measured. Traces of database application events (e.g., object creations, accesses, modifications) are used to drive the simulations; details appear in [8]. <p> All, part, or none of the subtree that the overwritten tree edge pointed to may become garbage, however, because of the presence of the non-tree edges. Further details of ABT, its applications, and justifications for its usefulness are given elsewhere <ref> [9] </ref>. the execution of an example trace. The figure was generated automatically from that trace and drawn using DOT [12]. The second test database is the OO7 benchmark, which was also used by Yong, Naughton, and Yu in their work on garbage collection [20]. <p> These policies are self-adaptive in that they dynamically respond to changes in the application behavior over time. We evaluated our proposed policies in the context of two very different object databases: ABT, an augmented binary tree database <ref> [9] </ref>, and OO7, a more highly-connected benchmark object database [4]. Both of these databases have been used in previous object database garbage collection studies [9, 20]. Our results show that our SAIO policy is very effective at achieving the user-specified GC I/O percentage. <p> We evaluated our proposed policies in the context of two very different object databases: ABT, an augmented binary tree database [9], and OO7, a more highly-connected benchmark object database [4]. Both of these databases have been used in previous object database garbage collection studies <ref> [9, 20] </ref>. Our results show that our SAIO policy is very effective at achieving the user-specified GC I/O percentage. Furthermore, the SAIO policy shows overall performance comparable to a fixed-rate policy, where the rate is chosen by an oracle.
Reference: [10] <author> Servio Corporation. </author> <title> Announcing GemStone version 4.0. Product literature, </title> <year> 1994. </year>
Reference-contexts: A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS [5]. Commercial ODBMSs are even beginning to provide implementations of garbage collection (e.g., <ref> [10] </ref>). In a previous paper [9] we presented a framework for investigating the issues surrounding partitioned garbage collection of ODBMSs. Partitioned collection is an incremental technique based on manipulating disjoint portions of a database [20] and is akin to generational collection in programming language systems [19].
Reference: [11] <author> Franz Incorporated. </author> <title> Allegro Common Lisp User Guide, Release 3.0 (beta) edition, </title> <month> April </month> <year> 1988. </year>
Reference-contexts: Some collector implementations allow the user to specify the fixed amount of allocation (i.e., specify collection after every two megabytes of allocation) to tune the collection rate to the behavior of the program <ref> [11] </ref>. There are many differences between programming language and object database garbage collection with respect to collection rate. One important objective of programming language collection is to collect frequently enough that the program and its data fits well in the primary memory.
Reference: [12] <author> E.R. Gansner, E. Koutsofios, S.C. North, and K.-P. Vo. </author> <title> A Technique for Drawing Directed Graphs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(3) </volume> <pages> 214-230, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Further details of ABT, its applications, and justifications for its usefulness are given elsewhere [9]. the execution of an example trace. The figure was generated automatically from that trace and drawn using DOT <ref> [12] </ref>. The second test database is the OO7 benchmark, which was also used by Yong, Naughton, and Yu in their work on garbage collection [20]. OO7 has been extensively described elsewhere [4].
Reference: [13] <author> Elliot Kolodner, Barbara Liskov, and William Weihl. </author> <title> Atomic garbage collection: Managing a stable heap. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 15-25, </pages> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Automatic storage reclamation, or garbage collection (GC), is becoming recognized as an important new feature for object database management systems (ODBMSs). A number of recent research papers have considered some of the important aspects of the correctness and performance of ODBMS garbage collection <ref> [9, 13, 14, 20] </ref>. A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS [5]. Commercial ODBMSs are even beginning to provide implementations of garbage collection (e.g., [10]). <p> low overhead in counting the number of pointer stores performed in an object database, counting the stores in a programming language algorithm would incur significant overhead. 2.2 Object Database Garbage Collection There has been a significant amount of research in object database garbage collection, much of which is quite recent <ref> [1, 2, 3, 9, 16, 13, 14, 20] </ref>. Here, we discuss the research that most closely relates to our current work. Both Butler [2] and Yong et al [20] show that existing programming language garbage collection algorithms have inadequate performance when used in database systems.
Reference: [14] <author> Elliot Kolodner and William Weihl. </author> <title> Atomic incremental garbage collection and recovery for a large stable heap. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 177-186, </pages> <address> Washington, DC, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Automatic storage reclamation, or garbage collection (GC), is becoming recognized as an important new feature for object database management systems (ODBMSs). A number of recent research papers have considered some of the important aspects of the correctness and performance of ODBMS garbage collection <ref> [9, 13, 14, 20] </ref>. A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS [5]. Commercial ODBMSs are even beginning to provide implementations of garbage collection (e.g., [10]). <p> low overhead in counting the number of pointer stores performed in an object database, counting the stores in a programming language algorithm would incur significant overhead. 2.2 Object Database Garbage Collection There has been a significant amount of research in object database garbage collection, much of which is quite recent <ref> [1, 2, 3, 9, 16, 13, 14, 20] </ref>. Here, we discuss the research that most closely relates to our current work. Both Butler [2] and Yong et al [20] show that existing programming language garbage collection algorithms have inadequate performance when used in database systems.
Reference: [15] <author> Henry Lieberman and Carl Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Comm. of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: Yong et al. [20] propose a technique called "partitioned garbage collection" for object databases that represents a generalization of the programming language garbage collection technique called generation garbage collection <ref> [15] </ref>. With partitioned garbage collection, a subset of the entire database is collected incrementally and independently of the rest.
Reference: [16] <author> David C. J. Matthews. </author> <title> Poly manual. </title> <journal> SIGPLAN Notices, </journal> <volume> 20(9), </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: low overhead in counting the number of pointer stores performed in an object database, counting the stores in a programming language algorithm would incur significant overhead. 2.2 Object Database Garbage Collection There has been a significant amount of research in object database garbage collection, much of which is quite recent <ref> [1, 2, 3, 9, 16, 13, 14, 20] </ref>. Here, we discuss the research that most closely relates to our current work. Both Butler [2] and Yong et al [20] show that existing programming language garbage collection algorithms have inadequate performance when used in database systems.
Reference: [17] <author> Robert A. Shaw. </author> <title> Empirical Analysis of a Lisp System. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, </institution> <address> CA, </address> <month> February </month> <year> 1988. </year> <note> Also appears as tech report CSL-TR-88-351. </note>
Reference-contexts: For example, in some systems, collections will occur after every megabyte of storage is allocated. These schemes avoid the potential thrashing behavior associated with the "collect-as-needed" policies. Furthermore, they are motivated by the empirical observation that most allocated programming language objects become garbage very soon after they are allocated <ref> [17, 21] </ref>. Some collector implementations allow the user to specify the fixed amount of allocation (i.e., specify collection after every two megabytes of allocation) to tune the collection rate to the behavior of the program [11].
Reference: [18] <author> Jr. William J. McIver and Roger King. </author> <title> Self-adaptive, on-line reclustering of complex object data. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 407-418, </pages> <address> Minneapolis, MN, </address> <month> March </month> <year> 1994. </year> <month> 30 </month>
Reference-contexts: Similarly, they both incur additional execution overhead that must be balanced against the performance benefits they provide. Thus, controlling the rate of both on-line reclustering and garbage collection is very important. In recent work, McIver and King investigate the performance of on-line reclustering in object databases <ref> [18] </ref>. In their work, reclustering is triggered when a measure of reference locality (the "external tension"), normalized to the number of disk accesses, exceeds a certain threshold and when an cluster analysis module determines that reclustering should improve performance.
Reference: [19] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <booktitle> In Proceedings of the International Work--shop on Memory Management, </booktitle> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: In a previous paper [9] we presented a framework for investigating the issues surrounding partitioned garbage collection of ODBMSs. Partitioned collection is an incremental technique based on manipulating disjoint portions of a database [20] and is akin to generational collection in programming language systems <ref> [19] </ref>. We categorized the issues into a number of policy areas that together contribute to a complete garbage collection algorithm. We described our results in investigating one policy area, partition selection, which is the selection of which partition of a database to collect during a given garbage collection. <p> Usually such policies include heuristics for growing the heap if not enough storage is reclaimed by a collection <ref> [7, 19] </ref>. 4 Another common approach to determining when to collect is to collect after a fixed amount of storage has been allocated. For example, in some systems, collections will occur after every megabyte of storage is allocated. These schemes avoid the potential thrashing behavior associated with the "collect-as-needed" policies.
Reference: [20] <author> Voon-Fee Yong, Jeffrey Naughton, and Jie-Bing Yu. </author> <title> Storage reclamation and reorganization in client-server persistent object stores. </title> <booktitle> In Proc. of the 10th International Conference on Data Engineering, </booktitle> <pages> pages 120-131, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Automatic storage reclamation, or garbage collection (GC), is becoming recognized as an important new feature for object database management systems (ODBMSs). A number of recent research papers have considered some of the important aspects of the correctness and performance of ODBMS garbage collection <ref> [9, 13, 14, 20] </ref>. A recently proposed standard suggests using garbage collection for at least some of the programmatic interfaces to an ODBMS [5]. Commercial ODBMSs are even beginning to provide implementations of garbage collection (e.g., [10]). <p> Commercial ODBMSs are even beginning to provide implementations of garbage collection (e.g., [10]). In a previous paper [9] we presented a framework for investigating the issues surrounding partitioned garbage collection of ODBMSs. Partitioned collection is an incremental technique based on manipulating disjoint portions of a database <ref> [20] </ref> and is akin to generational collection in programming language systems [19]. We categorized the issues into a number of policy areas that together contribute to a complete garbage collection algorithm. <p> As the mix of I/O operations changes, the collection rate adjusts to maintain the target percentage. We present a performance evaluation of our two new collection rate policies based on trace-driven simulations of two, very different database applications. One is the application developed by Yong, Naughton, and Yu <ref> [20] </ref> for the OO7 benchmark [4] and the other is based on the our own augmented binary tree application [9]. Our results show that our semi-automatic collection rate policies give excellent performance in all cases and often provide performance close to that of the best fixed-rate policy. <p> low overhead in counting the number of pointer stores performed in an object database, counting the stores in a programming language algorithm would incur significant overhead. 2.2 Object Database Garbage Collection There has been a significant amount of research in object database garbage collection, much of which is quite recent <ref> [1, 2, 3, 9, 16, 13, 14, 20] </ref>. Here, we discuss the research that most closely relates to our current work. Both Butler [2] and Yong et al [20] show that existing programming language garbage collection algorithms have inadequate performance when used in database systems. <p> Here, we discuss the research that most closely relates to our current work. Both Butler [2] and Yong et al <ref> [20] </ref> show that existing programming language garbage collection algorithms have inadequate performance when used in database systems. Yong et al. [20] propose a technique called "partitioned garbage collection" for object databases that represents a generalization of the programming language garbage collection technique called generation garbage collection [15]. <p> Here, we discuss the research that most closely relates to our current work. Both Butler [2] and Yong et al <ref> [20] </ref> show that existing programming language garbage collection algorithms have inadequate performance when used in database systems. Yong et al. [20] propose a technique called "partitioned garbage collection" for object databases that represents a generalization of the programming language garbage collection technique called generation garbage collection [15]. With partitioned garbage collection, a subset of the entire database is collected incrementally and independently of the rest. <p> The figure was generated automatically from that trace and drawn using DOT [12]. The second test database is the OO7 benchmark, which was also used by Yong, Naughton, and Yu in their work on garbage collection <ref> [20] </ref>. OO7 has been extensively described elsewhere [4]. For our purposes, it is important to note that OO7 has a much higher connectivity than ABT and that OO7 applications, unlike ABT applications, operate in distinct phases of long object traversals intersperses with significant database reorganizations. <p> We evaluated our proposed policies in the context of two very different object databases: ABT, an augmented binary tree database [9], and OO7, a more highly-connected benchmark object database [4]. Both of these databases have been used in previous object database garbage collection studies <ref> [9, 20] </ref>. Our results show that our SAIO policy is very effective at achieving the user-specified GC I/O percentage. Furthermore, the SAIO policy shows overall performance comparable to a fixed-rate policy, where the rate is chosen by an oracle.
Reference: [21] <author> Benjamin Zorn. </author> <title> Comparative Performance Evaluation of Garbage Collection Algorithms. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, Berkeley, </institution> <address> CA, </address> <month> November </month> <year> 1989. </year> <note> Also appears as tech report UCB/CSD 89/544. 31 </note>
Reference-contexts: For example, in some systems, collections will occur after every megabyte of storage is allocated. These schemes avoid the potential thrashing behavior associated with the "collect-as-needed" policies. Furthermore, they are motivated by the empirical observation that most allocated programming language objects become garbage very soon after they are allocated <ref> [17, 21] </ref>. Some collector implementations allow the user to specify the fixed amount of allocation (i.e., specify collection after every two megabytes of allocation) to tune the collection rate to the behavior of the program [11].
References-found: 21

