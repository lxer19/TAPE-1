URL: http://ftp.cs.indiana.edu/pub/stoller/AAS97.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/stoller.html
Root-URL: http://www.cs.indiana.edu
Email: stoller@cs.indiana.edu  fbs@cs.cornell.edu  
Title: Automated Analysis of Fault-Tolerance in Distributed Systems  
Author: Scott D. Stoller Fred B. Schneider 
Web: http://www.cs.indiana.edu/  http://www.cs.cornell.edu/  
Address: Bloomington, IN 47405  Ithaca, NY 14850  
Affiliation: Dept. of Computer Science Indiana University  Dept. of Computer Science Cornell University  
Abstract-found: 0
Intro-found: 1
Reference: [AH87] <editor> Samson Abramsky and Chris Hankin. </editor> <title> An introduction to abstract interpretation. </title> <editor> In Samson Abramsky and Chris Hankin, editors, </editor> <title> Abstract Interpretation of Declarative Languages, chapter 1. </title> <publisher> Ellis-Horwood, </publisher> <year> 1987. </year>
Reference-contexts: This paper explores a specialized approach to analysis of distributed systems, focusing on fault-tolerance properties. Our approach is not based on exhaustive state-space exploration. Instead, it is a novel hybrid of ideas from stream-processing (or data-flow) semantics of networks of processes [Kah74, Bro87, Bro90] and abstract interpretation of programs <ref> [AH87] </ref>. In stream-processing models, each component is represented by an I/O function describing its input/output behavior. The behavior of a system can be determined by a fixed-point calculation; this provides a clean algorithmic basis for the analysis.
Reference: [BD92] <author> Manfred Broy and Claus Dendorfer. </author> <title> Modelling operating system structures by timed stream processing functions. </title> <journal> Journal of Functional Programming, </journal> <volume> 2 </volume> <pages> 1-21, </pages> <year> 1992. </year>
Reference-contexts: The Signed Messages algorithm is more efficient but requires digital signatures, which can be modeled in our framework [Sto97]. Both algorithms assume synchronous communication. Although our framework embodies asynchronous communication, synchronous communication can be encoded by sending special values to represent passage of time <ref> [Bro90, BD92] </ref>. 4.2 Reliable Broadcast The power of symbolic multiplicities to track relationships between multiplicities is useful in analysis of atomicity properties, which are typically of the form: "All non-faulty components do action, or none of them do." Thus, atomicity properties correlate the multiplicities of actions at different sites.
Reference: [BKRS96] <author> J. F. Buss, P.C. Kanellakis, P. L. Ragde, and A. Shvartsman. </author> <title> Parallel algorithms with processor failures and delays. </title> <journal> Journal of Algorithms, </journal> <year> 1996. </year>
Reference-contexts: We have implemented the analysis in a prototype tool, CRAFT. We plan to test the approach and tool by applying them to more problems, e.g., efficient Byzantine agreement algorithms, algorithms for the certified write-all problem <ref> [KMS95, BKRS96] </ref>, secure protocols for group membership and reliable broadcast [Rei96, MR96], and cryptographic protocols for fault-tolerant moving agents [MvRSS96].
Reference: [Bro87] <author> Manfred Broy. </author> <title> Semantics of finite and infinite networks of concurrent communicating agents. </title> <journal> Distributed Computing, </journal> <volume> 2(1) </volume> <pages> 13-31, </pages> <year> 1987. </year>
Reference-contexts: This paper explores a specialized approach to analysis of distributed systems, focusing on fault-tolerance properties. Our approach is not based on exhaustive state-space exploration. Instead, it is a novel hybrid of ideas from stream-processing (or data-flow) semantics of networks of processes <ref> [Kah74, Bro87, Bro90] </ref> and abstract interpretation of programs [AH87]. In stream-processing models, each component is represented by an I/O function describing its input/output behavior. The behavior of a system can be determined by a fixed-point calculation; this provides a clean algorithmic basis for the analysis. <p> The restriction to determinate processes can be eliminated. A relatively straightforward approach, proposed by Broy <ref> [Bro87, Bro90] </ref>, is (roughly) to represent a (possibly non-determinate) process as a set of determinate processes, each corresponding to one of the process's possible behaviors. <p> We have given semantics for the abstract models with and without explicit perturbations by relating them to variants of Broy's concrete model <ref> [Bro87, Bro90] </ref>. Example. Consider again the system of Figure 1. The fault-tolerance requirement is that the change to the actuator's original inputs is the identity, and that the actuator has no new inputs.
Reference: [Bro90] <author> Manfred Broy. </author> <title> Functional specification of time sensitive communicating systems. </title> <booktitle> In Proceedings of the REX Workshop on Stepwise Refinement of Distributed Systems, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 153-179. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: This paper explores a specialized approach to analysis of distributed systems, focusing on fault-tolerance properties. Our approach is not based on exhaustive state-space exploration. Instead, it is a novel hybrid of ideas from stream-processing (or data-flow) semantics of networks of processes <ref> [Kah74, Bro87, Bro90] </ref> and abstract interpretation of programs [AH87]. In stream-processing models, each component is represented by an I/O function describing its input/output behavior. The behavior of a system can be determined by a fixed-point calculation; this provides a clean algorithmic basis for the analysis. <p> The restriction to determinate processes can be eliminated. A relatively straightforward approach, proposed by Broy <ref> [Bro87, Bro90] </ref>, is (roughly) to represent a (possibly non-determinate) process as a set of determinate processes, each corresponding to one of the process's possible behaviors. <p> We have given semantics for the abstract models with and without explicit perturbations by relating them to variants of Broy's concrete model <ref> [Bro87, Bro90] </ref>. Example. Consider again the system of Figure 1. The fault-tolerance requirement is that the change to the actuator's original inputs is the identity, and that the actuator has no new inputs. <p> The Signed Messages algorithm is more efficient but requires digital signatures, which can be modeled in our framework [Sto97]. Both algorithms assume synchronous communication. Although our framework embodies asynchronous communication, synchronous communication can be encoded by sending special values to represent passage of time <ref> [Bro90, BD92] </ref>. 4.2 Reliable Broadcast The power of symbolic multiplicities to track relationships between multiplicities is useful in analysis of atomicity properties, which are typically of the form: "All non-faulty components do action, or none of them do." Thus, atomicity properties correlate the multiplicities of actions at different sites.
Reference: [BVH94] <author> Ricky W. Butler, Ben L. Di Vito, and C. Michael Holloway. </author> <title> Formal design and verification of a reliable computing platform for real-time control (phase 3 results). </title> <type> NASA Technical Memorandum 109140, </type> <institution> NASA Langley Research Center, </institution> <year> 1994. </year>
Reference-contexts: Second, these fault-tolerance requirements must be rigorously verified. One approach is to apply general-purpose proof-based verification techniques, typically with the support of a theorem-proving system <ref> [DB92, BVH94, ORSvH95] </ref>. This approach offers an attractive conceptual economy. However, people who design and validate fault-tolerant systems are generally not experts in mathematical logic or formal verification, so methods that require construction of large proofs (even with support from a theorem-proving system) have had a limited audience.
Reference: [CdR93] <author> Antonio Cau and Willem-Paul de Roever. </author> <title> Using relative refinement for fault tolerance. </title> <editor> In J.C.P. Woodcock and P.G. Larsen, editors, FME'93: </editor> <title> Industrial-Strength Formal Methods. </title> <booktitle> First International Symposium of Formal Methods Europe, </booktitle> <pages> pages 19-41, </pages> <year> 1993. </year>
Reference-contexts: However, people who design and validate fault-tolerant systems are generally not experts in mathematical logic or formal verification, so methods that require construction of large proofs (even with support from a theorem-proving system) have had a limited audience. Proof techniques designed specifically for verification of fault-tolerance (e.g., <ref> [CdR93, PJ94] </ref>) facilitate these proofs but still require considerable logical expertise of the user. Automated verification is receiving increasing attention, largely due to advances in temporal-logic model-checking [CGL94] and automata-and process-based verification techniques [Hol91, Kur94, CS96]. These techniques are largely based on exhaustive exploration of finite state spaces.
Reference: [CGL94] <author> Edmund M. Clarke, Orna Grumberg, and David E. </author> <title> Long. Model checking and abstraction. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1512-1542, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Proof techniques designed specifically for verification of fault-tolerance (e.g., [CdR93, PJ94]) facilitate these proofs but still require considerable logical expertise of the user. Automated verification is receiving increasing attention, largely due to advances in temporal-logic model-checking <ref> [CGL94] </ref> and automata-and process-based verification techniques [Hol91, Kur94, CS96]. These techniques are largely based on exhaustive exploration of finite state spaces. They are particularly well-suited to hardware verification and have been applied predominantly thereto. <p> The notation is the same as in Figure 2. 5 Discussion and Related Work Abstractions. Abstractions (i.e., approximations) play an important role in our work. Clarke and Long studied the use of the abstractions in conjunction with temporal-logic model-checking <ref> [CGL94] </ref>. Their notion of abstraction corresponds roughly to abstract interpretation and to our abstract values, though in their state-based approach, multiplicities are not explicit, so abstractions are used only for (data) values. They also propose so-called symbolic abstractions, which are just abbreviations for finite families of (non-symbolic) abstractions. <p> The protocol can be verified more rigorously using a standard approach (see, for example, the analysis of the arithmetic pipeline in <ref> [CGL94] </ref>, or the analysis of the queue in [Kur94, Appendix D]). The problem of dealing with infinite runs also arises in verification of control systems. An approach to verification of aircraft control systems is described in [DBC91, Rus93].
Reference: [CS96] <author> Rance Cleaveland and Steve Sims. </author> <title> The ncsu concurrency workbench. </title> <editor> In Rajeev Alur and Tom Henzinger, editors, </editor> <booktitle> Computer-Aided Verification (CAV '96), volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 394-397. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Proof techniques designed specifically for verification of fault-tolerance (e.g., [CdR93, PJ94]) facilitate these proofs but still require considerable logical expertise of the user. Automated verification is receiving increasing attention, largely due to advances in temporal-logic model-checking [CGL94] and automata-and process-based verification techniques <ref> [Hol91, Kur94, CS96] </ref>. These techniques are largely based on exhaustive exploration of finite state spaces. They are particularly well-suited to hardware verification and have been applied predominantly thereto.
Reference: [DB92] <author> Ben L. Di Vito and Ricky W. Butler. </author> <title> Provable transient recovery for frame-based, fault-tolerant computing systems. </title> <booktitle> In Proc. 13th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 275-278. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Second, these fault-tolerance requirements must be rigorously verified. One approach is to apply general-purpose proof-based verification techniques, typically with the support of a theorem-proving system <ref> [DB92, BVH94, ORSvH95] </ref>. This approach offers an attractive conceptual economy. However, people who design and validate fault-tolerant systems are generally not experts in mathematical logic or formal verification, so methods that require construction of large proofs (even with support from a theorem-proving system) have had a limited audience.
Reference: [DBC91] <author> Ben L. Di Vito, Ricky W. Butler, and James L. Caldwell. </author> <title> High level design proof of a reliable computing platform. </title> <editor> In J. F. Meyer and R. D. Schlichting, editors, </editor> <title> Dependable Computing for Critical Applications 2, </title> <booktitle> volume 6 of Dependable Computing and Fault-Tolerant Systems, </booktitle> <pages> pages 279-306. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The problem of dealing with infinite runs also arises in verification of control systems. An approach to verification of aircraft control systems is described in <ref> [DBC91, Rus93] </ref>. Although the work described there uses a theorem-prover, the same ideas can be used in our framework to automatically check whether a given control system tolerates a specified rate of failures. Future Work.
Reference: [FM93] <author> P. Fenelon and J. A. McDermid. </author> <title> An integrated toolset for software safety analysis. </title> <journal> Journal of Systems and Software, </journal> <volume> 21(3) </volume> <pages> 279-290, </pages> <year> 1993. </year>
Reference-contexts: McDermid et al.'s work on validation of fault-tolerance shares with our work the idea of characterizing each component by how it generates and propagates failures <ref> [FM93, FMNP94, MNPF95] </ref>. Their work emphasizes simplicity over generality by incorporating a somewhat restricted representation of changes.
Reference: [FMNP94] <author> P. Fenelon, J. A. McDermid, M. Nicholson, and D. J. Pumfrey. </author> <title> Towards integrated safety analysis and design. </title> <journal> ACM Computing Reviews, </journal> <volume> 2(1) </volume> <pages> 21-32, </pages> <year> 1994. </year>
Reference-contexts: McDermid et al.'s work on validation of fault-tolerance shares with our work the idea of characterizing each component by how it generates and propagates failures <ref> [FM93, FMNP94, MNPF95] </ref>. Their work emphasizes simplicity over generality by incorporating a somewhat restricted representation of changes.
Reference: [Gun92] <author> Carl A. Gunter. </author> <title> Semantics of Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Informally, step (np)(cr ) represents the outcome of each component processing its inputs in the possibly-incomplete run cr and producing possibly-extended outputs. By a standard theorem <ref> [Gun92, chapter 4] </ref>, this fixed-point exists and can be computed by starting with the empty run ? CRun = (x : Name: (y : Name: ")), where " is the empty sequence, and repeatedly applying step (np) until a fixed-point is reached. The restriction to determinate processes can be eliminated.
Reference: [Hol91] <author> Gerard J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Proof techniques designed specifically for verification of fault-tolerance (e.g., [CdR93, PJ94]) facilitate these proofs but still require considerable logical expertise of the user. Automated verification is receiving increasing attention, largely due to advances in temporal-logic model-checking [CGL94] and automata-and process-based verification techniques <ref> [Hol91, Kur94, CS96] </ref>. These techniques are largely based on exhaustive exploration of finite state spaces. They are particularly well-suited to hardware verification and have been applied predominantly thereto.
Reference: [HT94] <author> Vassos Hadzilacos and Sam Toueg. </author> <title> A modular approach to fault-tolerant broadcasts and related problems. </title> <type> Technical Report TR 94-1425, </type> <institution> Cornell University, Department of Computer Science, </institution> <year> 1994. </year>
Reference-contexts: The run in Figure 4 represents the failure free behavior of this system. Now consider the effects of failures. For brevity, we consider here only the requirement of agreement: if a client of a non-faulty server delivers a message m, then all clients of non-faulty servers eventually deliver m <ref> [HT94, section 3] </ref>. One way to analyze systems subject to crash failures is to analyze separately the behavior resulting from crashes that occur at different times during the execution; in our framework, this could be done by representing crashes at different logical times with different elements of Fail .
Reference: [Kah74] <author> Gilles Kahn. </author> <title> The semantics of a simple language for parallel programming. </title> <editor> In J. L. Rosenfeld, editor, </editor> <booktitle> Information Processing 74: Proceedings of the IFIP Congress 74, </booktitle> <pages> pages 471-475. </pages> <publisher> North-Holland, </publisher> <year> 1974. </year>
Reference-contexts: This paper explores a specialized approach to analysis of distributed systems, focusing on fault-tolerance properties. Our approach is not based on exhaustive state-space exploration. Instead, it is a novel hybrid of ideas from stream-processing (or data-flow) semantics of networks of processes <ref> [Kah74, Bro87, Bro90] </ref> and abstract interpretation of programs [AH87]. In stream-processing models, each component is represented by an I/O function describing its input/output behavior. The behavior of a system can be determined by a fixed-point calculation; this provides a clean algorithmic basis for the analysis. <p> Following Kahn <ref> [Kah74] </ref>, we consider first only determinate processes, i.e., processes that are (1) internally deterministic and (2) strict (i.e., at each instant, the process is willing to receive a message from at most one sender). Determinacy ensures that the input history of a process uniquely determines its output history.
Reference: [KMS95] <author> P.C. Kanellakis, D. Michailidis, and A. Shvartsman. </author> <title> Controlling memory access in efficient fault-tolerant parallel algorithms. </title> <journal> Nordic Journal of Computing, </journal> <year> 1995. </year>
Reference-contexts: We have implemented the analysis in a prototype tool, CRAFT. We plan to test the approach and tool by applying them to more problems, e.g., efficient Byzantine agreement algorithms, algorithms for the certified write-all problem <ref> [KMS95, BKRS96] </ref>, secure protocols for group membership and reliable broadcast [Rei96, MR96], and cryptographic protocols for fault-tolerant moving agents [MvRSS96].
Reference: [Kur89] <author> R. P. Kurshan. </author> <title> Analysis of discrete event coordination. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proc. of the REX Workshop on Stepwise Refinement of Distributed Systems, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 414-453. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Our symbolic values are closer to the technique they sketch in the last paragraph of their paper for dealing with infinite-state systems. In Kurshan's automata-based verification methodology, approximations are embodied in reductions between verifications <ref> [Kur89, Kur94] </ref>. Relationships between concrete values can be captured using parameterized families of reductions, reminiscent of Clarke and Long's "symbolic abstractions".
Reference: [Kur94] <author> Robert P. Kurshan. </author> <title> Computer-aided verification of coordinating processes: the automata-theoretic approach. </title> <publisher> Princeton Univesity Press, </publisher> <year> 1994. </year>
Reference-contexts: Proof techniques designed specifically for verification of fault-tolerance (e.g., [CdR93, PJ94]) facilitate these proofs but still require considerable logical expertise of the user. Automated verification is receiving increasing attention, largely due to advances in temporal-logic model-checking [CGL94] and automata-and process-based verification techniques <ref> [Hol91, Kur94, CS96] </ref>. These techniques are largely based on exhaustive exploration of finite state spaces. They are particularly well-suited to hardware verification and have been applied predominantly thereto. <p> Our symbolic values are closer to the technique they sketch in the last paragraph of their paper for dealing with infinite-state systems. In Kurshan's automata-based verification methodology, approximations are embodied in reductions between verifications <ref> [Kur89, Kur94] </ref>. Relationships between concrete values can be captured using parameterized families of reductions, reminiscent of Clarke and Long's "symbolic abstractions". <p> For example, a bounded-length queue can be proven not to drop items using a family of reductions that collapse a set of (concrete) data values to 2 "abstract" data values: the one being focused on, specified as a parameter, and "everything else" <ref> [Kur94, Appendix D] </ref> (the parameterization is not explicit in Kurshan's presentation). For problems involving related values (e.g., X and F (X)), the reductions must introduce an "abstract" data value representing each such value. <p> The protocol can be verified more rigorously using a standard approach (see, for example, the analysis of the arithmetic pipeline in [CGL94], or the analysis of the queue in <ref> [Kur94, Appendix D] </ref>). The problem of dealing with infinite runs also arises in verification of control systems. An approach to verification of aircraft control systems is described in [DBC91, Rus93].
Reference: [Liu96] <author> Yanhong A. Liu. </author> <title> Incremental Compu--tation: A Semantics-Based Systematic Transformational Approach. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Their work emphasizes simplicity over generality by incorporating a somewhat restricted representation of changes. Our explicit perturbations are related to error analysis for numerical computations and to incremental computation <ref> [RR93, Liu96] </ref>, which studies how changes to the input of a computation are propagated to its output, so that new outputs can be computed efficiently by updating the old output.
Reference: [LSP82] <author> Leslie Lamport, Robert Shostak, and Marshall Pease. </author> <title> The byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Thus, the analysis shows that the system satisfies its fault-tolerance require ment in this failure scenario. 4 Examples 4.1 Byzantine Agreement A seminal paper by Lamport, Shostak, and Pease defines the problem of Byzantine Agreement and presents two solutions <ref> [LSP82] </ref>. Both can be analyzed in our framework. The Oral Messages algorithm is essentially a recursive application of majority voting, so the analysis is similar in style to the simple example in Section 3.
Reference: [MNPF95] <author> J. A. McDermid, M. Nicholson, D. J. Pumfrey, and P. Fenelon. </author> <title> Experience with the application of HAZOP to computer-based systems. </title> <booktitle> In Proc. 10th Annual Conference on Computer Assurance, </booktitle> <pages> pages 37-48, </pages> <year> 1995. </year>
Reference-contexts: McDermid et al.'s work on validation of fault-tolerance shares with our work the idea of characterizing each component by how it generates and propagates failures <ref> [FM93, FMNP94, MNPF95] </ref>. Their work emphasizes simplicity over generality by incorporating a somewhat restricted representation of changes.
Reference: [MR96] <author> Dalia Malki and Michael Reiter. </author> <title> A high-throughput secure reliable multi-cast protocol. </title> <booktitle> In Proc. of the 9th IEEE Computer Security Foundations Workshop, </booktitle> <pages> page 9=17. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year>
Reference-contexts: We have implemented the analysis in a prototype tool, CRAFT. We plan to test the approach and tool by applying them to more problems, e.g., efficient Byzantine agreement algorithms, algorithms for the certified write-all problem [KMS95, BKRS96], secure protocols for group membership and reliable broadcast <ref> [Rei96, MR96] </ref>, and cryptographic protocols for fault-tolerant moving agents [MvRSS96].
Reference: [MvRSS96] <author> Yaron Minsky, Robbert van Re-nesse, Fred B. Schneider, and Scott Stoller. </author> <title> Cryptographic support for fault-tolerant distributed computing. </title> <booktitle> In Proc. Seventh ACM SIGOPS Euro-pean Workshop, </booktitle> <pages> pages 109-114. </pages> <publisher> ACM Press, </publisher> <month> September </month> <year> 1996. </year>
Reference-contexts: We plan to test the approach and tool by applying them to more problems, e.g., efficient Byzantine agreement algorithms, algorithms for the certified write-all problem [KMS95, BKRS96], secure protocols for group membership and reliable broadcast [Rei96, MR96], and cryptographic protocols for fault-tolerant moving agents <ref> [MvRSS96] </ref>.
Reference: [ORSvH95] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of pvs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Second, these fault-tolerance requirements must be rigorously verified. One approach is to apply general-purpose proof-based verification techniques, typically with the support of a theorem-proving system <ref> [DB92, BVH94, ORSvH95] </ref>. This approach offers an attractive conceptual economy. However, people who design and validate fault-tolerant systems are generally not experts in mathematical logic or formal verification, so methods that require construction of large proofs (even with support from a theorem-proving system) have had a limited audience.
Reference: [PJ94] <author> Doron Peled and Mathai Joseph. </author> <title> A compositional framework for fault-tolerance by specification transformation. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 128(1-2):99-125, </address> <year> 1994. </year>
Reference-contexts: However, people who design and validate fault-tolerant systems are generally not experts in mathematical logic or formal verification, so methods that require construction of large proofs (even with support from a theorem-proving system) have had a limited audience. Proof techniques designed specifically for verification of fault-tolerance (e.g., <ref> [CdR93, PJ94] </ref>) facilitate these proofs but still require considerable logical expertise of the user. Automated verification is receiving increasing attention, largely due to advances in temporal-logic model-checking [CGL94] and automata-and process-based verification techniques [Hol91, Kur94, CS96]. These techniques are largely based on exhaustive exploration of finite state spaces.
Reference: [Rei96] <author> Michael K. Reiter. </author> <title> A secure group membership protocol. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(1) </volume> <pages> 31-42, </pages> <year> 1996. </year>
Reference-contexts: We have implemented the analysis in a prototype tool, CRAFT. We plan to test the approach and tool by applying them to more problems, e.g., efficient Byzantine agreement algorithms, algorithms for the certified write-all problem [KMS95, BKRS96], secure protocols for group membership and reliable broadcast <ref> [Rei96, MR96] </ref>, and cryptographic protocols for fault-tolerant moving agents [MvRSS96].
Reference: [RR93] <author> G. Ramalingam and Thomas Reps. </author> <title> A categorized bibliography on incremental computation. </title> <booktitle> In Conference Record of the 20th Annual ACM Symposium on POPL, </booktitle> <pages> pages 502-510, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Their work emphasizes simplicity over generality by incorporating a somewhat restricted representation of changes. Our explicit perturbations are related to error analysis for numerical computations and to incremental computation <ref> [RR93, Liu96] </ref>, which studies how changes to the input of a computation are propagated to its output, so that new outputs can be computed efficiently by updating the old output.
Reference: [Rus93] <author> John Rushby. </author> <title> A fault-masking and transient-recovery model for digital flight-control systems. </title> <editor> In Jan Vy-topil, editor, </editor> <booktitle> Formal techniques in real-time and fault-tolerant systems, </booktitle> <pages> pages 109-136. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year> <note> Also appeared in SRI International Computer Science Laboratory Technical Report SRI-CSL-93-04. </note>
Reference-contexts: The problem of dealing with infinite runs also arises in verification of control systems. An approach to verification of aircraft control systems is described in <ref> [DBC91, Rus93] </ref>. Although the work described there uses a theorem-prover, the same ideas can be used in our framework to automatically check whether a given control system tolerates a specified rate of failures. Future Work.
Reference: [Sto97] <author> Scott D. Stoller. </author> <title> Tools for Evaluating Fault-Tolerance in Systems. </title> <type> PhD thesis, </type> <institution> Cornell University, Department of Computer Science, </institution> <note> forthcoming in 1997. </note>
Reference-contexts: This allows independent proofs that each I/O function represents the behavior of the corresponding process. 2 Roughly, the reason is that runs do not have canonical forms <ref> [Sto97] </ref>. For convenience, we include in SVal a special wildcard symbol " ", which can always represent any value. <p> The Oral Messages algorithm is essentially a recursive application of majority voting, so the analysis is similar in style to the simple example in Section 3. The Signed Messages algorithm is more efficient but requires digital signatures, which can be modeled in our framework <ref> [Sto97] </ref>. Both algorithms assume synchronous communication.
Reference: [WG93] <author> Pierre Wolper and Patrice Godefroid. </author> <title> Partial-order methods for temporal verification. </title> <booktitle> In CONCUR '93: 4th International Conference on Concur-rency Theory, </booktitle> <pages> pages 233-246, </pages> <year> 1993. </year>
Reference-contexts: Our use of partial orders to represent message ordering supports similar benefits to partial-order methods in model-checking <ref> [WG93] </ref>. We are exploring extensions to the framework to reflect orderings between messages sent by different components. 3 Analyzing Systems with Failures Since each component's behavior depends on what failures it suffers, we parameterize each compo nent (i.e., each I/O function) by its possible failures.
References-found: 32

