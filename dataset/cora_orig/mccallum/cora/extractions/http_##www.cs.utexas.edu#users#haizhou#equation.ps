URL: http://www.cs.utexas.edu/users/haizhou/equation.ps
Refering-URL: http://www.cs.utexas.edu/users/haizhou/publications.html
Root-URL: 
Title: BDD Based Procedures for a Theory of Equality with Uninterpreted Functions  
Author: Anuj Goel Khurram Sajid Hai Zhou Adnan Aziz and Vigyan Singhal 
Affiliation: 1 The University of Texas at Austin 2 Intel Corporation 3 Cadence Berkeley Labs  
Abstract: The logic of equality with uninterpreted functions has been proposed for verifying abstract hardware designs. The ability to perform fast satisfiability checking over this logic is imperative for this verification paradigm to be successful. We present symbolic methods for satisfiability checking for this logic. The first procedure is based on restricting analysis to finite instantiations of the design. The second procedure directly reasons about equality by introducing Boolean-valued indicator variables for equality. Theoretical and experimental evidence shows the superiority of the second approach.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Wilhelm Ackermann. </author> <title> Solvable Cases of the Decision Problem. </title> <booktitle> Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1954. </year>
Reference-contexts: In this context, the primary verification problem we solve is design equivalence; this includes such applications as verifying equivalence of pipelined and nonpipelined processors. This can be posed as a problem in satisfiability checking for quantifier--free formulas involving both equality and UIFs. As shown by Ackermann <ref> [1] </ref>, this problem can be reduced to satisfiability checking of quantifier-free formulas involving only equality through a suitable generalization of the following: given a formula containing terms f (x 1 ) and f (x 2 ), replace f (x 1 ) and f (x 2 ) and by fresh variables y <p> As is the case for Shostak's procedure [13], the soundness and completeness of this construction follows from <ref> [1] </ref>. 3 IE Netlist Satisfiability Checking IE Netlist Satisfiability Checking consists of taking an IE-netlist and determining if an input assignment exists for which a specified Boolean-valued output can take the value 1.
Reference: 2. <author> C. Barrett, D. Dill, and Jeremy Levitt. </author> <title> Validity Checking for Combinations of Theories with Equality. </title> <booktitle> In Proc. of the Formal Methods in CAD Conf., </booktitle> <month> November </month> <year> 1996. </year>
Reference-contexts: In this way, formula satisfiability (and, by duality, validity) can be checked. Extensions to the basic algorithm of Shostak have been made in many recent papers on processor verification <ref> [3, 10, 2] </ref>. Essentially, their approach is a variant of the Davis-Putnam procedure for validity checking over propositional logic, with suitable extensions for handling the properties of equality. One source of their efficiency is the ability to split on subformulas; they also use heuristic rewrite rules for formula simplification. <p> One difference of our work with the work of <ref> [2] </ref> is that while they use formulas to encode the designs, we use BDDs which also incorporate the constraints that are required of the UIFs. If these BDDs can be built and manipulated, the validity checking problem is considerably simplified, and should work more robustly than a rewrite-based approach.
Reference: 3. <author> J. Burch and D. Dill. </author> <title> Automatic Verification of Microprocessor Control. </title> <booktitle> In Proc. of the Computer Aided Verification Conf., </booktitle> <month> July </month> <year> 1994. </year>
Reference-contexts: In this way, formula satisfiability (and, by duality, validity) can be checked. Extensions to the basic algorithm of Shostak have been made in many recent papers on processor verification <ref> [3, 10, 2] </ref>. Essentially, their approach is a variant of the Davis-Putnam procedure for validity checking over propositional logic, with suitable extensions for handling the properties of equality. One source of their efficiency is the ability to split on subformulas; they also use heuristic rewrite rules for formula simplification. <p> Their notion of correctness is based on the equivalence of the machine state of the nonpipelined machine after processing an instruction and the state resulting in the pipelined machine after executing the same instruction and flushing it out. (This is the standard "commutative diagram" approach to verification <ref> [3] </ref>.) Equivalence is formulated as in terms of the validity of a quantifier free formula involving both equality and UIFs. <p> Our examples are derived from the comparison of the pipelined and non-pipelined version of the 3-stage pipelined ALU used in <ref> [3] </ref>; this design has uninterpreted functions which correspond to the ALU and Reads/Writes to the register file. <p> The results clearly are in favor of the e ij encoding; hence, we propose it as the method of choice for BDD-based satisfiability checking. The runtimes are higher than those reported in <ref> [3] </ref>; this is not surprising given the large overheads associated with initialization of the data structures we use for design representation. The results demonstrate that BDD methods are feasible, contradicting prevailing beliefs.
Reference: 4. <author> W. Chan, R. Anderson, P. Deame, and D. Notkin. </author> <title> Combining Constraint Solving and Symbolic Model Checking for a Class of Systems with Non-linear Constraints. </title> <booktitle> In Proc. of the Computer Aided Verification Conf., </booktitle> <month> July </month> <year> 1997. </year>
Reference-contexts: When iteratively generating cubes, we prune the search by finding early contradictions; this is the source of a major speedup. This is similar to the procedure of Chan et al <ref> [4] </ref> for pruning BDDs over variables corresponding to complex arithmetical constraints. One source of relative efficiency for us is that because we are dealing purely with equality, we can incrementally check inconsistency as we explore the BDD.
Reference: 5. <author> T. H. Cormen, C. E. Leiserson, and R. H. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: The proof is constructive, and yields an algorithm for checking cube satisfiability; efficient querying and updating of the partition can be performed by a variant of the union-find algorithm <ref> [5] </ref>. Thus, a procedure for finding a consistent minterm in a BDD is to iterate over a set of cubes (a "cover") which contains all the minterms in the BDD.
Reference: 6. <author> R. K. Brayton et al. </author> <title> VIS: A system for Verification and Synthesis. </title> <booktitle> In Proc. of the Computer Aided Verification Conf., </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: the search is to identify nodes appearing in the BDD for which the corresponding subfunction rooted at that node has no satisfying assignments; we have not experimented with this. 4 Experiments We implemented the procedure for constructing the e ij -encoded functions from an IE netlist on top of VIS <ref> [6] </ref>, which is a popular gate-level BDD-based verification tool. (For the finite instantiation approach, there was no code to write, since VIS has the capability of building BDDs for binary netlists.) In order to perform a comparison of the two symbolic methods for IE netlist satisfiability checking we first created a
Reference: 7. <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability. </title> <editor> W. H. </editor> <publisher> Freeman and Co., </publisher> <year> 1979. </year>
Reference-contexts: This tells us the simple fact that BDD SAT is in NP. We now show BDD ConSAT to be NP-hard by transforming the problem of PATH WITH FORBIDDEN PAIRS <ref> [7] </ref> to it. INSTANCE: Directed graph G = (V; A), specified vertices s; t 2 V , collec tion C = f (a 1 ; b 1 ); : : : ; (a n ; b n )g of pairs of vertices from V .
Reference: 8. <author> R. Hojati, A. Isles, D. Kirkpatrick, and R. Brayton. </author> <title> Verification Using Finite Instan-tiations and Uninterpreted Functions. </title> <booktitle> In Proc. of the Formal Methods in CAD Conf., </booktitle> <month> November </month> <year> 1996. </year>
Reference-contexts: However, a naive method for building these BDDs does not work; BDDs become too big. We present a novel encoding technique so that the validity checking problem can be efficiently represented using BDDs. Hojati et al <ref> [8, 9] </ref> use finite instantiations to handle UIFs (we also discuss a finite instantiation based method in Section 3.1). <p> We present a novel encoding technique so that the validity checking problem can be efficiently represented using BDDs. Hojati et al [8, 9] use finite instantiations to handle UIFs (we also discuss a finite instantiation based method in Section 3.1). In <ref> [8] </ref>, they require an explicit invocation of Shostak's method to decide equality between two terms containing UIFs; it is not described if Shostak's algorithm is used directly or another approach is used.
Reference: 9. <author> R. Hojati, A. Kuehlmann, S. German, and R. Brayton. </author> <title> Validity Checking in the Theory of Equality Using Finite Instantiations. </title> <booktitle> In Proc. Intl. Workshop on Logic Synthesis, </booktitle> <month> May </month> <year> 1997. </year>
Reference-contexts: However, a naive method for building these BDDs does not work; BDDs become too big. We present a novel encoding technique so that the validity checking problem can be efficiently represented using BDDs. Hojati et al <ref> [8, 9] </ref> use finite instantiations to handle UIFs (we also discuss a finite instantiation based method in Section 3.1).
Reference: 10. <author> Robert B. Jones, David Dill, and Jerry R. Burch. </author> <title> Efficient Validity Checking for Processor Validation. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 2-6, </pages> <year> 1995. </year>
Reference-contexts: We are interested in the verification of designs at the high-level. This necessitates reasoning about designs where a lot of complexity has been abstracted away. The use of uninterpreted functions (UIFs) has been proposed as a powerful abstraction mechanism for hardware verification <ref> [10, 14] </ref>. Essentially, UIFs allow the verification tool to avoid getting bogged down by complex details which are irrelevant to the property being proved. <p> In this way, formula satisfiability (and, by duality, validity) can be checked. Extensions to the basic algorithm of Shostak have been made in many recent papers on processor verification <ref> [3, 10, 2] </ref>. Essentially, their approach is a variant of the Davis-Putnam procedure for validity checking over propositional logic, with suitable extensions for handling the properties of equality. One source of their efficiency is the ability to split on subformulas; they also use heuristic rewrite rules for formula simplification. <p> These correspond to verifying processors using commutative diagrams <ref> [10] </ref>. Specifically, they arise in the verification of a pipelined processor; the approach taken is that of Burch and Dill, wherein a pipelined processor is flushed after executing one instruction; the resulting state is compared with the state resulting from execution of the same instruction on a nonpipelined implementation.
Reference: 11. <author> Andreas Kuehlmann and Florian Krohm. </author> <title> Equivalence Checking Using Cuts and Heaps. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Today, state-of-the-art tools for Boolean verification use BDDs and heavily exploit the structure of the design; the original tools were based on case splitting (e.g., ATPG-based methods) <ref> [11] </ref>. Currently, all approaches for verification in the theory of equality with UIFs proceed by case splitting on terms occurring in the formula; heuristic rewriting of subformulas is also performed. <p> There are many ways in which this work can be extended. Perhaps the most important is the incorporation of the "miter" concept for identifying equivalent nodes; this has been extremely successful in the Boolean verification world <ref> [11] </ref>, enabling the verification of million gate circuits. We are developing a specification language for designs with UIFs, a data structure for representing the same, and a set of routines for restructuring and verifying the design; this will be made available to the general public.
Reference: 12. <author> R. Rudell. </author> <title> Dynamic Variable Ordering for Binary Decision Diagrams. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 42-47, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: It is noteworthy that for the finite instantiation approach, the default BDD variable ordering would always result in memory overflows; dynamic variable re ordering <ref> [12] </ref> had to be enabled for the process to complete. Even so, the example Pipe5.v would exhaust available memory. For the equality based approach, variables are allocated dynamically, and added to the end of the order; no variable re-ordering was needed.
Reference: 13. <author> R. E. Shostak. </author> <title> A practical decision procedure for arithmetic with function symbols. </title> <journal> Journal of the ACM, </journal> <volume> 26(2) </volume> <pages> 351-360, </pages> <year> 1979. </year>
Reference-contexts: Moreover, memories can also be incorporated in this framework as partially interpreted functions by adding constraints which relate reads and writes <ref> [13] </ref>. In this context, the primary verification problem we solve is design equivalence; this includes such applications as verifying equivalence of pipelined and nonpipelined processors. This can be posed as a problem in satisfiability checking for quantifier--free formulas involving both equality and UIFs. <p> A number of decision procedures exist for the theory of equality with UIFs and its extensions. Pioneering work was done by Shostak <ref> [13] </ref>, who considered linear arithmetic in conjunction with UIFs. His procedure replaces terms generated from UIFs by new variables as previously described; the formula is then converted to a conjunctive normal form, and each conjunct is checked for satisfiability using Integer Linear Programming. <p> As is the case for Shostak's procedure <ref> [13] </ref>, the soundness and completeness of this construction follows from [1]. 3 IE Netlist Satisfiability Checking IE Netlist Satisfiability Checking consists of taking an IE-netlist and determining if an input assignment exists for which a specified Boolean-valued output can take the value 1.
Reference: 14. <author> Mandayam Srivas and Mark Bickford. </author> <title> Formal verification of a pipelined microprocessor. </title> <journal> IEEE Software, </journal> <volume> 7(5) </volume> <pages> 52-64, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: We are interested in the verification of designs at the high-level. This necessitates reasoning about designs where a lot of complexity has been abstracted away. The use of uninterpreted functions (UIFs) has been proposed as a powerful abstraction mechanism for hardware verification <ref> [10, 14] </ref>. Essentially, UIFs allow the verification tool to avoid getting bogged down by complex details which are irrelevant to the property being proved.
References-found: 14

