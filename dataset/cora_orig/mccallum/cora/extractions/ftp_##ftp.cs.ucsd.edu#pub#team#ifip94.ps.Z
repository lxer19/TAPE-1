URL: ftp://ftp.cs.ucsd.edu/pub/team/ifip94.ps.Z
Refering-URL: http://www.cs.ucsd.edu/users/flaviu/publications.html
Root-URL: http://www.cs.ucsd.edu
Date: 1994  
Note: Invited paper, 13th IFIP World Computer Congress, Aug 28-Sept 2, Hamburg,  
Abstract: ions for Fault-Tolerance Designing and understanding fault-tolerant distributed system architectures is notoriously difficult: one has to maintain control not only over standard (failure-free) behaviors, but also over a multitude of failure behaviors caused by component failures. The lack of clear structuring concepts and terminology can exacerbate this difficulty. This paper complements earlier attempts at introducing some order and discipline in this area [5], by discussing a number of basic concepts and services that simplify the understanding and design of fault-tolerant systems. Fault-tolerance has two different meanings. First, a system is said fault-tolerant if its behavior remains well-defined when components fail. For example, a storage service that either reads correctly a value written previously or signals an exception is fault-tolerant in the above sense: low level bit corruption do not lead to ill-defined, potentially catastrophic behaviors. Second, a system is said fault-tolerant if it masks component failures, that is, its users do not see system failures when system components fail. Fault-tolerance is achieved by incorporating redundancy into a system. Thus, before we discuss the issues which underlie fault-tolerance (or redundancy management), we need to talk about basic concepts used to structure systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Birman. </author> <title> Theprocess group approach to reliable distributed computing. </title> <journal> Communications of ACM, </journal> <month> Dec </month> <year> 1993. </year>
Reference-contexts: The area of what transport protocols are best for communication between client groups and server groups is not well understood at present; solutions such as making the clients become members of the group of servers that provide a certain service (see the client-server groups of <ref> [1] </ref>) tend to produce large mixed overlapping groups and the membership and broadcast group management protocols currently known do not scale well for such groups.
Reference: [2] <author> F. Cristian. </author> <title> Understanding fault-tolerant distributed systems. </title> <journal> Communications of ACM, </journal> <volume> 34(2) </volume> <pages> 56-78, </pages> <month> Feb </month> <year> 1991. </year>
Reference-contexts: Since the recovery actions depend on the likely failure behaviors, in a fault-tolerant system one has to extend the specification of servers to include, in addition to their standard, failure-free, semantics (i.e. set of allowable failure-free behaviors), their likely failure behaviors, or failure semantics <ref> [2] </ref>. If the specification of a server s requires that the failure behaviors likely to be observed by s users should be in class F, we say that `s has F failure semantics' (for a discussion of what is meant by `likely' see [2]). <p> their likely failure behaviors, or failure semantics <ref> [2] </ref>. If the specification of a server s requires that the failure behaviors likely to be observed by s users should be in class F, we say that `s has F failure semantics' (for a discussion of what is meant by `likely' see [2]). If a failure specification allows a service S to exhibit failure behaviors that are in the union of the failure behaviors defined by two failure classes A and B, we say that the failure semantics specified for S is A/B. <p> Operations that, for any initial input and state, either provide their standard service or signal an exception without changing state are called atomic w.r.t. exceptions <ref> [2] </ref>. <p> The issue of how to maintain the population of the various server groups that implement critical services has recently received some initial attention with the investigation of automatic availability management services <ref> [2] </ref>.
Reference: [3] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kauf-mann, </publisher> <year> 1993. </year>
Reference-contexts: Higher level persistent storage structures, such as files, databases and more general abstract objects can be made atomic w.r.t. crashes and exceptions by using logging and recovery algorithms such as the write-ahead log protocol, that themselves depend upon lower level stable storage services <ref> [3] </ref>.
Reference: [4] <author> B. Lampson. </author> <title> Atomic transactions. </title> <booktitle> In Distributed Systems|Architecture and Implementation, </booktitle> <pages> pages 246-265. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: Such error detecting codes ensure read omission failure semantics for as long as no operating system crashes occur. To ensure that write operations on persistent storage have a clean omission failure semantics despite operating system crashes a common method <ref> [4] </ref> is to use mirrored persistent storage servers (e.g. disks) and software implemented hierarchical masking to implement stable storage as follows.
Reference: [5] <author> J. C. Laprie, </author> <title> editor. Dependability: Basic Concepts and Terminology. </title> <publisher> Springer-Verlag, </publisher> <address> Vienna, </address> <year> 1992. </year>
Reference: [6] <author> D. L. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12) </volume> <pages> 1053-1058, </pages> <month> Dec </month> <year> 1972. </year>
Reference-contexts: The operations defined for a service can only be carried out by a service implementation consisting of one or more servers. A server encapsulates private state data by a set of procedures (or instructions or methods) that provide the only way for changing and accessing the server's state <ref> [6] </ref>. A server is also a unit of failure and growth: at any point in time a service implementation has a membership consisting of an integer number of servers.
References-found: 6

