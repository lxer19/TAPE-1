URL: http://www.cs.gatech.edu/reverse/repository/jase.ps
Refering-URL: http://www.cs.gatech.edu/reverse/repos.html
Root-URL: 
Email: fspencer, kurt, lindag@cc.gatech.edu  
Title: Understanding Interleaved Code  
Author: Spencer Rugaber, Kurt Stirewalt, and Linda M. Wills 
Note: With every leaf a miracle. Walt Whitman.  
Address: Atlanta, Georgia 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: Complex programs often contain multiple, interwoven strands of computation, each responsible for accomplishing a distinct goal. The individual strands responsible for each goal are typically delocalized and overlap rather than being composed in a simple linear sequence. We refer to these code fragments as being interleaved. Interleaving may be intentional-for example, in optimizing a program, a programmer might use some intermediate result for several purposes-or it may creep into a program unintentionally, due to patches, quick fixes, or other hasty maintenance practices. To understand this phenomenon, we have looked at a variety of instances of interleaving in actual programs and have distilled characteristic features. This paper presents our characterization of interleaving and the implications it has for tools that detect interleaving and extract the individual strands of computation. Our exploration of interleaving has been done in the context of a case study of a corpus of production mathematical software, written in Fortran from the Jet Propulsion Laboratory. This paper also describes our experiences in developing tools to detect interleaving in this software, driven by the application of program comprehension to improving the description of this software library's components. This in turn aids in the automated component-based synthesis of software using the library. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> V.R. Basili and H.D. Mills. </author> <title> Understanding and documenting programs. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 8(3) </volume> <pages> 270-283, </pages> <month> May </month> <year> 1982. </year>
Reference-contexts: Secondary sources of existing software which we also examined are a Cobol database report writing system from the US Army and a program for finding the roots of functions (ZEROIN), presented and analyzed in <ref> [1] </ref> and [30]. We relate our characterization of interleaving to existing concepts in the literature, such as delocalized plans [18], coupling [41], and redistribution of intermediate results [10, 11]. We then describe the context in which we are exploring and applying these ideas.
Reference: [2] <author> T. Biggerstaff, B. Mitbander, and D. Webster. </author> <title> Program understanding and the concept assignment problem. </title> <journal> Comm. of the ACM, </journal> <volume> 37(5) </volume> <pages> 72-83, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Loop fusion is viewed as redistribution of sequences of values and treated as any other redistribution optimization [40]. Most existing cliche recognition systems tend to deal with interleaving involving data and control mechanisms. Domain-based clustering, as explored by DM-TAO in the DESIRE system <ref> [2] </ref>, focuses on naming mechanisms, by keying in on the patterns of linguistic idioms used in the program, which suggest the manifestations of domain concepts. Mechanisms for dealing with specific types of interleaving have been explicitly built into existing recognition systems. <p> Only cliched plans can be recognized, since recognition implies noticing something that is familiar. 24 used technique for localizing functional components by tracing through data dependencies within the procedural scope. Cluster analysis <ref> [2, 13, 32, 33] </ref> is used to group related sections of code, based on the detection of shared uses of global data, control paths, and names. However, clustering techniques can only provide limited assistance by roughly delineating possible locations of functionally cohesive components.
Reference: [3] <author> Barry Boehm. </author> <title> Software Engineering Economics. </title> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: 1 Introduction Imagine being handed a software system you have never seen before. Perhaps you need to track down a bug, rewrite the software in another language or extend it in some way. We know that software maintenance tasks such as these consume the majority of software costs <ref> [3] </ref>, and we know that reading and understanding the code requires more effort than actually making the changes [9]. But we don't know what makes understanding the code itself so difficult. Letovsky has observed that programmers engaged in software understanding activities typically ask "how" questions and "why" questions [17].
Reference: [4] <author> R. Bowdidge and W. Griswold. </author> <title> Automated support for encapsulating abstract data types. </title> <booktitle> In Proc. 2nd ACM SIGSOFT Symp. on Foundations of Software Engineering, </booktitle> <pages> pages 97-110, </pages> <address> New Orleans, </address> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: These graphs show dependencies among global entities within a single module. Presumably, the independent services reflect separate plans in the code. Research into automating data encapsulation has recently provided mechanisms for hypothesizing possible locations of data plans at the object scope. For example, Bowdidge and Griswold <ref> [4] </ref> use an extended data flow graph representation, called a star diagram, to help human users see all the uses of a particular data structure and to detect frequently occurring computations that are candidates for abstract functions.
Reference: [5] <author> R. Brooks. </author> <title> Towards a theory of the comprehension of computer programs. </title> <journal> Int. Journal of Man-Machine Studies, </journal> <volume> 18 </volume> <pages> 543-554, </pages> <year> 1983. </year>
Reference-contexts: From the software analysis perspective, the refinement and elaboration of domain knowledge, based on what is discovered in the code, is a primary activity, driving the generation of hypotheses and informing future analyses. The process of understanding software involves two parallel knowledge acquisition activities <ref> [5, 23, 36] </ref>: 1. using domain knowledge to understand the code|knowledge about the application sets up expectations about how abstract concepts are typically manifested in concrete code implemen tations; 2. using knowledge of the code to understand the domain|what is discovered in the code is used to build up a description
Reference: [6] <author> F. Calliss and B. Cornelius. </author> <title> Potpourri module detection. </title> <booktitle> In IEEE Conf. on Software Maintenance - 1990, </booktitle> <pages> pages 46-51, </pages> <address> San Diego, CA, November 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: However, clustering techniques can only provide limited assistance by roughly delineating possible locations of functionally cohesive components. Another technique, called "potpourri module detection" <ref> [6] </ref>, detects modules that provide more than one independent service by looking for multiple proper subgraphs in an entity-to-entity interconnection graph. These graphs show dependencies among global entities within a single module. Presumably, the independent services reflect separate plans in the code.
Reference: [7] <author> G. Canfora, A. Cimitile, and M. Munro. </author> <title> A reverse engineering method for identifying reusable abstract data types. </title> <booktitle> In Proc. of the First Working Conference on Reverse Engineering, </booktitle> <pages> pages 73-82, </pages> <address> Baltimore, Maryland, May 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Techniques have also been developed within the RE 2 project <ref> [7, 8] </ref>, for identifying candidate abstract data types and their associated modules, based on the call graph and dominance relations. Further research is required to develop techniques for extracting objects from pieces of data that have not already been aggregated in programmer-defined data structures.
Reference: [8] <author> A. Cimitile, M. Tortorella, and M. Munro. </author> <title> Program comprehension through the identification of abstract data types. </title> <booktitle> In Proc. 3rd Workshop on Program Comprehension, </booktitle> <pages> pages 12-19, </pages> <address> Washington, D.C., November 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Techniques have also been developed within the RE 2 project <ref> [7, 8] </ref>, for identifying candidate abstract data types and their associated modules, based on the call graph and dominance relations. Further research is required to develop techniques for extracting objects from pieces of data that have not already been aggregated in programmer-defined data structures.
Reference: [9] <author> R. K. Fjeldstad and W. T. Hamlen. </author> <title> Application program maintenance study: </title> <note> Report to our respondents. In GUIDE 48, 4 1979. Also appears in [24]. </note>
Reference-contexts: We know that software maintenance tasks such as these consume the majority of software costs [3], and we know that reading and understanding the code requires more effort than actually making the changes <ref> [9] </ref>. But we don't know what makes understanding the code itself so difficult. Letovsky has observed that programmers engaged in software understanding activities typically ask "how" questions and "why" questions [17].
Reference: [10] <author> R. Hall. </author> <title> Program improvement by automatic redistribution of intermediate results. </title> <type> Technical Report 1251, </type> <institution> MIT Artificial Intelligence Lab., </institution> <month> February </month> <year> 1990. </year> <type> PhD. </type>
Reference-contexts: We relate our characterization of interleaving to existing concepts in the literature, such as delocalized plans [18], coupling [41], and redistribution of intermediate results <ref> [10, 11] </ref>. We then describe the context in which we are exploring and applying these ideas. Our driving program comprehension problem is to elaborate and validate existing partial specifications of the JPL library routines to facilitate the automation of specification-driven generation of programs using these routines. <p> The implementations for computing the nearest point and the shortest distance overlap in that a single structural element contributes to multiple goals. The sharing of the results of some subcomputation in the implementation of two distinct higher level operations is termed redistribution of intermediate results by Hall <ref> [10, 11] </ref>. More specifically, redistribution is a class of function sharing optimizations which are implemented simply by tapping into the dataflow from some value producer and feeding it to an additional target consumer, introducing fanout into the dataflow.
Reference: [11] <author> R. Hall. </author> <title> Program improvement by automatic redistribution of intermediate results: An overview. </title> <editor> In M. Lowry and R. McCartney, editors, </editor> <title> Automating Software Design. </title> <publisher> AAAI Press, </publisher> <address> Menlo Park, CA, </address> <year> 1991. </year>
Reference-contexts: We relate our characterization of interleaving to existing concepts in the literature, such as delocalized plans [18], coupling [41], and redistribution of intermediate results <ref> [10, 11] </ref>. We then describe the context in which we are exploring and applying these ideas. Our driving program comprehension problem is to elaborate and validate existing partial specifications of the JPL library routines to facilitate the automation of specification-driven generation of programs using these routines. <p> The implementations for computing the nearest point and the shortest distance overlap in that a single structural element contributes to multiple goals. The sharing of the results of some subcomputation in the implementation of two distinct higher level operations is termed redistribution of intermediate results by Hall <ref> [10, 11] </ref>. More specifically, redistribution is a class of function sharing optimizations which are implemented simply by tapping into the dataflow from some value producer and feeding it to an additional target consumer, introducing fanout into the dataflow.
Reference: [12] <author> J. Hartman. </author> <title> Automatic control understanding for natural programs. </title> <type> Technical Report AI 91-161, </type> <institution> University of Texas at Austin, </institution> <year> 1991. </year> <type> PhD thesis. </type>
Reference-contexts: Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. Following [28, 34], we reserve the term cliche for a plan that represents a standard, stereotypical form, which can be detected by recognition techniques, such as <ref> [12, 17, 16, 25, 29, 40] </ref>. 2 3 4 at any level of abstraction from architectural overviews to code. By extracting the error checking plan from NPEDLN, we get the much smaller and, presumably, more understandable program shown in Figure 3. <p> as the scope becomes more global in nature. 23 5 Related Work Techniques for detecting interleaving and disentangling interleaved plans are likely to build on existing program comprehension and maintenance techniques. 5.1 The Role of Recognition When what is interleaved is familiar (i.e., stereotypical, frequently used plans), cliche recognition (e.g., <ref> [12, 15, 16, 17, 25, 29, 40] </ref>) is a useful detection mechanism. 3 In fact, most recognition systems deal explicitly with the recognition of cliches that are interleaved in specific ways with unrecognizable code or other cliches.
Reference: [13] <author> D. Hutchens and V. Basili. </author> <title> System structure analysis: Clustering with data bindings. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 11(8), </volume> <month> August </month> <year> 1985. </year>
Reference-contexts: Only cliched plans can be recognized, since recognition implies noticing something that is familiar. 24 used technique for localizing functional components by tracing through data dependencies within the procedural scope. Cluster analysis <ref> [2, 13, 32, 33] </ref> is used to group related sections of code, based on the detection of shared uses of global data, control paths, and names. However, clustering techniques can only provide limited assistance by roughly delineating possible locations of functionally cohesive components.
Reference: [14] <institution> Reasoning Systems Incorporated. Software Refinery Toolkit. </institution> <address> Palo Alto, CA. </address>
Reference-contexts: In the process, we are also performing analyses to gather empirical information about how much of SPICELIB is covered by the domain theory. We are building interleaving detection mechanisms and empirical analysis tools using a collection of commercial tools, called the Software Refinery <ref> [14] </ref>. This is a comprehensive tool suite including 14 language-specific analyzers and browsers for Fortran, C, Ada, and Cobol, language extension mech-anisms for building new analyzers, and a user interface construction tool for displaying the results of analysis.
Reference: [15] <author> W. L. Johnson. </author> <title> Intention-Based Diagnosis of Novice Programming Errors. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, CA, </address> <year> 1986. </year> <month> 28 </month>
Reference-contexts: as the scope becomes more global in nature. 23 5 Related Work Techniques for detecting interleaving and disentangling interleaved plans are likely to build on existing program comprehension and maintenance techniques. 5.1 The Role of Recognition When what is interleaved is familiar (i.e., stereotypical, frequently used plans), cliche recognition (e.g., <ref> [12, 15, 16, 17, 25, 29, 40] </ref>) is a useful detection mechanism. 3 In fact, most recognition systems deal explicitly with the recognition of cliches that are interleaved in specific ways with unrecognizable code or other cliches.
Reference: [16] <author> W. Kozaczynski and J.Q. Ning. </author> <title> Automated program understanding by concept recognition. </title> <journal> Automated Software Engineering, </journal> <volume> 1(1) </volume> <pages> 61-78, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. Following [28, 34], we reserve the term cliche for a plan that represents a standard, stereotypical form, which can be detected by recognition techniques, such as <ref> [12, 17, 16, 25, 29, 40] </ref>. 2 3 4 at any level of abstraction from architectural overviews to code. By extracting the error checking plan from NPEDLN, we get the much smaller and, presumably, more understandable program shown in Figure 3. <p> as the scope becomes more global in nature. 23 5 Related Work Techniques for detecting interleaving and disentangling interleaved plans are likely to build on existing program comprehension and maintenance techniques. 5.1 The Role of Recognition When what is interleaved is familiar (i.e., stereotypical, frequently used plans), cliche recognition (e.g., <ref> [12, 15, 16, 17, 25, 29, 40] </ref>) is a useful detection mechanism. 3 In fact, most recognition systems deal explicitly with the recognition of cliches that are interleaved in specific ways with unrecognizable code or other cliches.
Reference: [17] <author> S. Letovsky. </author> <title> Plan analysis of programs. </title> <type> Research Report 662, </type> <institution> Yale University, </institution> <month> December </month> <year> 1988. </year> <type> PhD. </type>
Reference-contexts: But we don't know what makes understanding the code itself so difficult. Letovsky has observed that programmers engaged in software understanding activities typically ask "how" questions and "why" questions <ref> [17] </ref>. The former require an in-depth knowledge of the programming language and the ways in which programmers express their software designs. This includes knowledge of common algorithms and data structures and even concerns style issues such as indentation and use of comments. <p> Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. Following [28, 34], we reserve the term cliche for a plan that represents a standard, stereotypical form, which can be detected by recognition techniques, such as <ref> [12, 17, 16, 25, 29, 40] </ref>. 2 3 4 at any level of abstraction from architectural overviews to code. By extracting the error checking plan from NPEDLN, we get the much smaller and, presumably, more understandable program shown in Figure 3. <p> as the scope becomes more global in nature. 23 5 Related Work Techniques for detecting interleaving and disentangling interleaved plans are likely to build on existing program comprehension and maintenance techniques. 5.1 The Role of Recognition When what is interleaved is familiar (i.e., stereotypical, frequently used plans), cliche recognition (e.g., <ref> [12, 15, 16, 17, 25, 29, 40] </ref>) is a useful detection mechanism. 3 In fact, most recognition systems deal explicitly with the recognition of cliches that are interleaved in specific ways with unrecognizable code or other cliches.
Reference: [18] <author> S. Letovsky and E. Soloway. </author> <title> Delocalized plans and program comprehension. </title> <journal> IEEE Software, </journal> <volume> 3(3), </volume> <year> 1986. </year>
Reference-contexts: We use the term plan to denote a description or representation of a computational structure that the designers have proposed as a way of achieving some purpose or goal in a program. 1 Plans can occur 1 This definition is distilled from definitions in <ref> [18, 28, 34] </ref>. Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. <p> The delocalized nature of this "scale-unscale" plan makes it difficult to gather together all the pieces involved for consistent maintenance. It also gets in the way of understanding the rest of the code, since it provides distractions that must be filtered out. Letovsky and Soloway's cognitive study <ref> [18] </ref> shows the deleterious effects of delocalization on comprehension and maintenance. <p> We relate our characterization of interleaving to existing concepts in the literature, such as delocalized plans <ref> [18] </ref>, coupling [41], and redistribution of intermediate results [10, 11]. We then describe the context in which we are exploring and applying these ideas. <p> This allows the scaling factor to be computed once and the result reused. Realizing that a reformulation wrapper or some other delocalized plan is interleaved with a particular computation can help prevent severe comprehension failures during maintenance <ref> [18] </ref>.
Reference: [19] <author> M. Lowry, A. Philpot, T. Pressburger, and I. Underwood. Amphion: </author> <title> automatic programming for subroutine libraries. </title> <booktitle> In Proc. 9th Knowledge-Based Software Engineering Conference, </booktitle> <pages> pages 2-11, </pages> <address> Monterey, CA, </address> <year> 1994. </year>
Reference-contexts: NPEDLN comes from this library. We were introduced to SPICELIB by researchers at NASA Ames, who have developed a component-based software synthesis system, called Amphion <ref> [20, 19, 37] </ref>. Amphion automatically constructs programs that compose routines drawn from SPICELIB. It does this by making use of a domain theory that includes formal specifications of the library routines, connecting them to abstract concepts in the solar system geometry domain. <p> Amphion has been installed at JPL and used by space scientists to successfully generate over one hundred programs to solve solar system kinematics problems. The programs consist of dozens of subroutine calls and are typically synthesized in under three minutes of CPU time using a Sun Sparc 2 <ref> [20, 19] </ref>. Amphion's success depends on how accurate, consistent, and complete the domain theory is that Amphion uses.
Reference: [20] <author> M. Lowry, A. Philpot, T. Pressburger, and I. Underwood. </author> <title> A formal approach to domain-oriented software design environments. </title> <booktitle> In Proc. 9th Knowledge-Based Software Engineering Conference, </booktitle> <pages> pages 48-57, </pages> <address> Monterey, CA, </address> <year> 1994. </year>
Reference-contexts: NPEDLN comes from this library. We were introduced to SPICELIB by researchers at NASA Ames, who have developed a component-based software synthesis system, called Amphion <ref> [20, 19, 37] </ref>. Amphion automatically constructs programs that compose routines drawn from SPICELIB. It does this by making use of a domain theory that includes formal specifications of the library routines, connecting them to abstract concepts in the solar system geometry domain. <p> Amphion has been installed at JPL and used by space scientists to successfully generate over one hundred programs to solve solar system kinematics problems. The programs consist of dozens of subroutine calls and are typically synthesized in under three minutes of CPU time using a Sun Sparc 2 <ref> [20, 19] </ref>. Amphion's success depends on how accurate, consistent, and complete the domain theory is that Amphion uses.
Reference: [21] <author> G. Myers. </author> <title> Reliable Software through Composite Design. </title> <type> Petrocelli Charter, </type> <year> 1975. </year>
Reference-contexts: The use of control flags is a special form of control coupling: "any connection between two modules that communicates elements of control [41]," typically in the form of function codes, flags, or switches <ref> [21] </ref>. This sharing of control information between two modules increases the complexity of the code, complicating comprehension and maintenance. Content coupling. Another form of resource sharing occurs when the lexical structure of a module is shared among several related functional components.
Reference: [22] <author> J.Q. Ning, A. Engberts, and W. Kozaczynski. </author> <title> Automated support for legacy code understanding. </title> <journal> Comm. of the ACM, </journal> <volume> 37(5) </volume> <pages> 50-57, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: For example, slicing <ref> [39, 22] </ref> is a widely 3 Recognition as a program understanding technique deals with cliches, not plans in general. Only cliched plans can be recognized, since recognition implies noticing something that is familiar. 24 used technique for localizing functional components by tracing through data dependencies within the procedural scope.
Reference: [23] <author> S. Ornburn and S. Rugaber. </author> <title> Reverse engineering: Resolving conflicts between expected and actual software designs. </title> <booktitle> In IEEE Conf. on Software Maintenance - 1992, </booktitle> <pages> pages 32-40, </pages> <address> Orlando, Florida, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: From the software analysis perspective, the refinement and elaboration of domain knowledge, based on what is discovered in the code, is a primary activity, driving the generation of hypotheses and informing future analyses. The process of understanding software involves two parallel knowledge acquisition activities <ref> [5, 23, 36] </ref>: 1. using domain knowledge to understand the code|knowledge about the application sets up expectations about how abstract concepts are typically manifested in concrete code implemen tations; 2. using knowledge of the code to understand the domain|what is discovered in the code is used to build up a description
Reference: [24] <editor> G. Parikh and N. Zvegintozov, editors. </editor> <booktitle> Tutorial on Software Maintenance. IEEE Computer Society, </booktitle> <year> 1983. </year> <title> Order No. </title> <publisher> EM453. </publisher>
Reference: [25] <author> A. Quilici. </author> <title> A memory-based approach to recognizing programming plans. </title> <journal> Comm. of the ACM, </journal> <volume> 37(5) </volume> <pages> 84-93, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. Following [28, 34], we reserve the term cliche for a plan that represents a standard, stereotypical form, which can be detected by recognition techniques, such as <ref> [12, 17, 16, 25, 29, 40] </ref>. 2 3 4 at any level of abstraction from architectural overviews to code. By extracting the error checking plan from NPEDLN, we get the much smaller and, presumably, more understandable program shown in Figure 3. <p> as the scope becomes more global in nature. 23 5 Related Work Techniques for detecting interleaving and disentangling interleaved plans are likely to build on existing program comprehension and maintenance techniques. 5.1 The Role of Recognition When what is interleaved is familiar (i.e., stereotypical, frequently used plans), cliche recognition (e.g., <ref> [12, 15, 16, 17, 25, 29, 40] </ref>) is a useful detection mechanism. 3 In fact, most recognition systems deal explicitly with the recognition of cliches that are interleaved in specific ways with unrecognizable code or other cliches.
Reference: [26] <author> C. Rich. </author> <title> A formal representation for plans in the Programmer's Apprentice. </title> <booktitle> In Proc. 7th Int. Joint Conf. Artificial Intelligence, </booktitle> <pages> pages 1044-1052, </pages> <address> Vancouver, British Columbia, Canada, </address> <month> August </month> <year> 1981. </year>
Reference-contexts: An existing formalism that meets these criteria is Rich's Plan Calculus <ref> [26, 27, 28] </ref>. A plan in the Plan Calculus is encoded as a graphical depiction of the plan's structural parts and the constraints (e.g., data and control flow connections) between them. This diagrammatic notation is complemented with an axiomatized description of the plan that defines its formal semantics.
Reference: [27] <author> C. Rich. </author> <title> Inspection methods in programming. </title> <type> Technical Report 604, </type> <institution> MIT Artificial Intelligence Lab., </institution> <month> June </month> <year> 1981. </year> <type> PhD thesis. </type>
Reference-contexts: An existing formalism that meets these criteria is Rich's Plan Calculus <ref> [26, 27, 28] </ref>. A plan in the Plan Calculus is encoded as a graphical depiction of the plan's structural parts and the constraints (e.g., data and control flow connections) between them. This diagrammatic notation is complemented with an axiomatized description of the plan that defines its formal semantics.
Reference: [28] <author> C. Rich and R. C. Waters. </author> <title> The Programmer's Apprentice. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, </address> <publisher> MA and ACM Press, </publisher> <address> Baltimore, MD, </address> <year> 1990. </year>
Reference-contexts: We use the term plan to denote a description or representation of a computational structure that the designers have proposed as a way of achieving some purpose or goal in a program. 1 Plans can occur 1 This definition is distilled from definitions in <ref> [18, 28, 34] </ref>. Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. <p> Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. Following <ref> [28, 34] </ref>, we reserve the term cliche for a plan that represents a standard, stereotypical form, which can be detected by recognition techniques, such as [12, 17, 16, 25, 29, 40]. 2 3 4 at any level of abstraction from architectural overviews to code. <p> An existing formalism that meets these criteria is Rich's Plan Calculus <ref> [26, 27, 28] </ref>. A plan in the Plan Calculus is encoded as a graphical depiction of the plan's structural parts and the constraints (e.g., data and control flow connections) between them. This diagrammatic notation is complemented with an axiomatized description of the plan that defines its formal semantics. <p> One of the key features of GRASPR [40], for instance, is its ability to deal with delocalization and redistribution-type function sharing optimizations. KBEmacs <ref> [28, 38] </ref> uses a simple, special-purpose recognition strategy to segment loops within programs. This is based on detecting coarse patterns of data and control flow at the procedural level that are indicative of common ways of constructing, augmenting, and interleaving iterative computations.
Reference: [29] <author> C. Rich and L. M. Wills. </author> <title> Recognizing a program's design: A graph-parsing approach. </title> <journal> IEEE Software, </journal> <volume> 7(1) </volume> <pages> 82-89, </pages> <month> January </month> <year> 1990. </year> <note> Reprinted in P. </note> <editor> H. Winston, editor, </editor> <booktitle> Artificial Intelligence at MIT: Expanding Frontiers, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <publisher> In press. </publisher>
Reference-contexts: Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. Following [28, 34], we reserve the term cliche for a plan that represents a standard, stereotypical form, which can be detected by recognition techniques, such as <ref> [12, 17, 16, 25, 29, 40] </ref>. 2 3 4 at any level of abstraction from architectural overviews to code. By extracting the error checking plan from NPEDLN, we get the much smaller and, presumably, more understandable program shown in Figure 3. <p> as the scope becomes more global in nature. 23 5 Related Work Techniques for detecting interleaving and disentangling interleaved plans are likely to build on existing program comprehension and maintenance techniques. 5.1 The Role of Recognition When what is interleaved is familiar (i.e., stereotypical, frequently used plans), cliche recognition (e.g., <ref> [12, 15, 16, 17, 25, 29, 40] </ref>) is a useful detection mechanism. 3 In fact, most recognition systems deal explicitly with the recognition of cliches that are interleaved in specific ways with unrecognizable code or other cliches.
Reference: [30] <author> S. Rugaber, S. Ornburn, and R. LeBlanc. </author> <title> Recognizing design decisions in programs. </title> <journal> IEEE Software, </journal> <volume> 7(1) </volume> <pages> 46-54, </pages> <month> January </month> <year> 1990. </year> <month> 29 </month>
Reference-contexts: Secondary sources of existing software which we also examined are a Cobol database report writing system from the US Army and a program for finding the roots of functions (ZEROIN), presented and analyzed in [1] and <ref> [30] </ref>. We relate our characterization of interleaving to existing concepts in the literature, such as delocalized plans [18], coupling [41], and redistribution of intermediate results [10, 11]. We then describe the context in which we are exploring and applying these ideas.
Reference: [31] <author> S. Rugaber, K. Stirewalt, and L. Wills. </author> <title> Detecting interleaving. </title> <booktitle> In IEEE Conf. on Software Maintenance - 1995, </booktitle> <address> Nice, France, </address> <month> September </month> <year> 1995. </year> <note> IEEE Computer Society Press. To appear. </note>
Reference-contexts: We recognize application-specific exception handlers using two rules which search the AST for a call to SIGERR, followed by a RETURN statement. These rules and the Refine code that applies them are presented in detail in <ref> [31] </ref>. Detecting Guards Discovering "guards," which are IF statements that depend only upon input parameters, involves keeping track of whether or not these parameters have been modified before the check. If they have been modified before the check, then the check probably is not a precondition check on inputs. <p> We describe how to implement this test in <ref> [31] </ref>. 4 Open Issues We are convinced that interleaving seriously complicates understanding computer programs. But recognizing a problem is different from knowing how to fix it. <p> The first is called the Workbench, and it provided pre-existing analyses for traditional graphs and reports such as structure charts, dataflow diagrams, and cross reference lists. The results of the analyses can be accessed from the repository using small, Refine language programs such as those described in <ref> [31] </ref>. The Refine compiler was the other feature we used, compiling a Refine program into compiled Lisp. The approach taken by the Refine language and tool suite has many advantages for attacking problems like ours.
Reference: [32] <author> R. Schwanke. </author> <title> An intelligent tool for re-engineering software modularity. </title> <booktitle> In IEEE Conf. on Software Maintenance - 1991, </booktitle> <pages> pages 83-92, </pages> <year> 1991. </year>
Reference-contexts: Only cliched plans can be recognized, since recognition implies noticing something that is familiar. 24 used technique for localizing functional components by tracing through data dependencies within the procedural scope. Cluster analysis <ref> [2, 13, 32, 33] </ref> is used to group related sections of code, based on the detection of shared uses of global data, control paths, and names. However, clustering techniques can only provide limited assistance by roughly delineating possible locations of functionally cohesive components.
Reference: [33] <author> R. Schwanke, R. Altucher, and M. Platoff. </author> <title> Discovering, visualizing, and controlling software structure. </title> <booktitle> In Proc. 5th Int. Workshop on Software Specs. and Design, </booktitle> <pages> pages 147-150, </pages> <address> Pittsburgh, PA, </address> <year> 1989. </year>
Reference-contexts: Only cliched plans can be recognized, since recognition implies noticing something that is familiar. 24 used technique for localizing functional components by tracing through data dependencies within the procedural scope. Cluster analysis <ref> [2, 13, 32, 33] </ref> is used to group related sections of code, based on the detection of shared uses of global data, control paths, and names. However, clustering techniques can only provide limited assistance by roughly delineating possible locations of functionally cohesive components.
Reference: [34] <author> P. Selfridge, R. Waters, and E. Chikofsky. </author> <title> Challenges to the field of reverse engineering - A position paper. </title> <booktitle> In Proc. of the First Working Conference on Reverse Engineering, </booktitle> <pages> pages 144-150, </pages> <address> Baltimore, Maryland, May 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: We use the term plan to denote a description or representation of a computational structure that the designers have proposed as a way of achieving some purpose or goal in a program. 1 Plans can occur 1 This definition is distilled from definitions in <ref> [18, 28, 34] </ref>. Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. <p> Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. Following <ref> [28, 34] </ref>, we reserve the term cliche for a plan that represents a standard, stereotypical form, which can be detected by recognition techniques, such as [12, 17, 16, 25, 29, 40]. 2 3 4 at any level of abstraction from architectural overviews to code.
Reference: [35] <author> D. Smith, G. Kotik, and S. Westfold. </author> <title> Research on knowledge-based software environments at Kestrel Institute. </title> <journal> IEEE Trans. on Software Engineering, </journal> <month> November </month> <year> 1985. </year>
Reference-contexts: It maintains an object-oriented repository for holding the results of analyses, such as abstract syntax trees and symbol tables. It provides a powerful wide-spectrum language, called Refine <ref> [35] </ref>, which supports pattern matching and querying the repository. Using the Software Refinery allows us to leverage commercially available tools as well as evaluate the strengths and limitations of its approach to program analysis, which we discuss in Section 4.1.
Reference: [36] <author> E. Soloway and K. Ehrlich. </author> <title> Empirical studies of programming knowledge. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 10(5) </volume> <pages> 595-609, </pages> <month> September </month> <year> 1984. </year> <note> Reprinted in C. </note> <editor> Rich and R.C. Waters, editors, </editor> <booktitle> Readings in Artificial Intelligence and Software Engineering, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1986. </year>
Reference-contexts: From the software analysis perspective, the refinement and elaboration of domain knowledge, based on what is discovered in the code, is a primary activity, driving the generation of hypotheses and informing future analyses. The process of understanding software involves two parallel knowledge acquisition activities <ref> [5, 23, 36] </ref>: 1. using domain knowledge to understand the code|knowledge about the application sets up expectations about how abstract concepts are typically manifested in concrete code implemen tations; 2. using knowledge of the code to understand the domain|what is discovered in the code is used to build up a description
Reference: [37] <author> M. Stickel, R. Waldinger, M. Lowry, T. Pressburger, I. Underwood, and A. Bundy. </author> <title> Deductive composition of astronomical software from subroutine libraries. </title> <booktitle> In Proc. 12th International Conference on Automated Deduction, </booktitle> <pages> pages 341-55, </pages> <address> Nancy, France, </address> <year> 1994. </year>
Reference-contexts: NPEDLN comes from this library. We were introduced to SPICELIB by researchers at NASA Ames, who have developed a component-based software synthesis system, called Amphion <ref> [20, 19, 37] </ref>. Amphion automatically constructs programs that compose routines drawn from SPICELIB. It does this by making use of a domain theory that includes formal specifications of the library routines, connecting them to abstract concepts in the solar system geometry domain.
Reference: [38] <author> R. C. Waters. </author> <title> A method for analyzing loop programs. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 5(3) </volume> <pages> 237-247, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: One of the key features of GRASPR [40], for instance, is its ability to deal with delocalization and redistribution-type function sharing optimizations. KBEmacs <ref> [28, 38] </ref> uses a simple, special-purpose recognition strategy to segment loops within programs. This is based on detecting coarse patterns of data and control flow at the procedural level that are indicative of common ways of constructing, augmenting, and interleaving iterative computations.
Reference: [39] <author> Mark Weiser. </author> <title> Program slicing. </title> <booktitle> In 5th Int. Conf. on Software Engineering, </booktitle> <pages> pages 439-449, </pages> <address> San Diego, CA, </address> <month> 3 </month> <year> 1981. </year>
Reference-contexts: For example, slicing <ref> [39, 22] </ref> is a widely 3 Recognition as a program understanding technique deals with cliches, not plans in general. Only cliched plans can be recognized, since recognition implies noticing something that is familiar. 24 used technique for localizing functional components by tracing through data dependencies within the procedural scope.
Reference: [40] <author> L. Wills. </author> <title> Automated program recognition by graph parsing. </title> <type> Technical Report 1358, </type> <institution> MIT Artificial Intelligence Lab., </institution> <month> July </month> <year> 1992. </year> <type> PhD Thesis. </type>
Reference-contexts: Note that a plan is not necessarily stereotypical or used repeatedly; it may be novel or idiosyncratic. Following [28, 34], we reserve the term cliche for a plan that represents a standard, stereotypical form, which can be detected by recognition techniques, such as <ref> [12, 17, 16, 25, 29, 40] </ref>. 2 3 4 at any level of abstraction from architectural overviews to code. By extracting the error checking plan from NPEDLN, we get the much smaller and, presumably, more understandable program shown in Figure 3. <p> as the scope becomes more global in nature. 23 5 Related Work Techniques for detecting interleaving and disentangling interleaved plans are likely to build on existing program comprehension and maintenance techniques. 5.1 The Role of Recognition When what is interleaved is familiar (i.e., stereotypical, frequently used plans), cliche recognition (e.g., <ref> [12, 15, 16, 17, 25, 29, 40] </ref>) is a useful detection mechanism. 3 In fact, most recognition systems deal explicitly with the recognition of cliches that are interleaved in specific ways with unrecognizable code or other cliches. <p> One of the key features of GRASPR <ref> [40] </ref>, for instance, is its ability to deal with delocalization and redistribution-type function sharing optimizations. KBEmacs [28, 38] uses a simple, special-purpose recognition strategy to segment loops within programs. <p> The recognition and temporal abstraction of iteration cliches is similarly used in GRASPR to enable it to deal with generalized loop fusion forms of interleaving. Loop fusion is viewed as redistribution of sequences of values and treated as any other redistribution optimization <ref> [40] </ref>. Most existing cliche recognition systems tend to deal with interleaving involving data and control mechanisms.
Reference: [41] <author> E. Yourdon and L. Constantine. </author> <title> Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1979. </year> <month> 30 </month>
Reference-contexts: We relate our characterization of interleaving to existing concepts in the literature, such as delocalized plans [18], coupling <ref> [41] </ref>, and redistribution of intermediate results [10, 11]. We then describe the context in which we are exploring and applying these ideas. <p> The use of control flags is a special form of control coupling: "any connection between two modules that communicates elements of control <ref> [41] </ref>," typically in the form of function codes, flags, or switches [21]. This sharing of control information between two modules increases the complexity of the code, complicating comprehension and maintenance. Content coupling. <p> This is sometimes done in a language, such as Fortran, that does not contain an encapsulation mechanism like packages or objects. These two practices are examples of a phenomenon called content coupling in which <ref> [41] </ref> | "some or all of the contents of one module are included in the contents of another"|and which often manifests itself in the form of a multiple-entry module. Content coupling makes it difficult to independently modify or maintain the individual functions. Name Sharing.
References-found: 41

