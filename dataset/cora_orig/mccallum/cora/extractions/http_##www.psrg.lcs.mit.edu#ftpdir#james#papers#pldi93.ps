URL: http://www.psrg.lcs.mit.edu/ftpdir/james/papers/pldi93.ps
Refering-URL: http://www.psrg.lcs.mit.edu/publications.html
Root-URL: 
Title: Real-Time Replication Garbage Collection  
Author: Scott Nettles and James O'Toole 
Keyword: real-time garbage collection, copying garbage collection, incremental collection, concurrent collection, replication.  
Abstract: We have implemented the first copying garbage collector that permits continuous unimpeded mutator access to the original objects during copying. The garbage collector incrementally replicates all accessible objects and uses a mutation log to bring the replicas up-to-date with changes made by the mu-tator. An experimental implementation demonstrates that the costs of using our algorithm are small and that bounded pause times of 50 milliseconds can be readily achieved. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time Concurrent Garbage Collection on Stock Multiprocessors. </title> <booktitle> In SIG-PLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 11-20, </pages> <year> 1988. </year>
Reference-contexts: For incremental collection to be possible, the garbage collector must sometimes suspend its work and permit the mutator to run, even though the collection algorithm has not completed. Previous work on incremental collection has focused on techniques that required either special hardware or operating system support <ref> [12, 1] </ref>, or in which the extra overhead for the mutator was potentially very high [4, 16]. These algorithms are variants of Baker's algorithm [2] which uses a to-space invariant. The to-space invariant requires that the mutator use only pointers into to-space. <p> The collector only needs to replicate all the live data soon enough to terminate and reuse the memory in from-space before the application runs out of memory. In the algorithm of Appel, Ellis, and Li <ref> [1] </ref>, the application may frequently be blocked waiting for the collector to copy the objects that it must use. We believe that the flexibility of our invariant offers potentially important optimization opportunities to any replication-based implementation. For example, the collector can copy objects in essentially any desired order. <p> The work of Ellis, Li, and Appel <ref> [1] </ref> exemplifies the use of virtual memory traps and other operating system support to implement similar conditions. A method due to Brooks [4], and later implemented by North [16], requires the mutator to follow a forwarding pointer which leads to the relocated object.
Reference: [2] <author> H. G. Baker. </author> <title> List Processing in Real Time on a Serial Computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <year> 1978. </year>
Reference-contexts: Previous work on incremental collection has focused on techniques that required either special hardware or operating system support [12, 1], or in which the extra overhead for the mutator was potentially very high [4, 16]. These algorithms are variants of Baker's algorithm <ref> [2] </ref> which uses a to-space invariant. The to-space invariant requires that the mutator use only pointers into to-space. The cost of enforcing this restriction leads to the need for special hardware or operating system support. <p> (secs) 1 0.2 7556 3.6 3.9 5 0.2 5561 1.6 2.8 Sort O N G %G CG (Mb) (Mb) (Kb) (secs) 1 0.2 5561 1.6 2.8 5 0.2 1237 0.4 0.6 Table 3: Latent garbage amounts make this effect more important. 5 Related Work The real-time copying collector by Baker <ref> [2] </ref> first proposed the condition that object accesses somehow be redirected to the relocated copy of the object. The work of Ellis, Li, and Appel [1] exemplifies the use of virtual memory traps and other operating system support to implement similar conditions.
Reference: [3] <author> Hans-Juergen Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly Parallel Garbage Collection. </title> <booktitle> In SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 157-164, </pages> <year> 1991. </year>
Reference-contexts: Nilsen [15] describes a software implementation of Baker's algorithm which is designed for an environment in which strings are heavily used. The overhead of his technique seems to be prohibitive in a more general context. Recent work by Boehm, Demers and Shenker <ref> [3] </ref> on a concurrent mark-and-sweep collector promises real-time performance. As in our algorithm, a form of mutation logging is used by the collector to track changes made by the mutator. The mutation log is implemented by periodically sampling the dirty page bits maintained by the virtual memory system.
Reference: [4] <author> Rodney A. Brooks. </author> <title> Trading Data Space for Reduced Time and Code Space in Real-Time Garbage Collection. </title> <booktitle> In SIGPLAN Symposium on LISP and Functional Programming, </booktitle> <year> 1984. </year>
Reference-contexts: Previous work on incremental collection has focused on techniques that required either special hardware or operating system support [12, 1], or in which the extra overhead for the mutator was potentially very high <ref> [4, 16] </ref>. These algorithms are variants of Baker's algorithm [2] which uses a to-space invariant. The to-space invariant requires that the mutator use only pointers into to-space. The cost of enforcing this restriction leads to the need for special hardware or operating system support. <p> The work of Ellis, Li, and Appel [1] exemplifies the use of virtual memory traps and other operating system support to implement similar conditions. A method due to Brooks <ref> [4] </ref>, and later implemented by North [16], requires the mutator to follow a forwarding pointer which leads to the relocated object. Nilsen [15] describes a software implementation of Baker's algorithm which is designed for an environment in which strings are heavily used.
Reference: [5] <author> Stuart K. Card, Thomas P. Moran, and Allen Newell. </author> <title> The Psychology of Human-Computer Interaction. </title> <publisher> Lawrence Erlbaum Associates, </publisher> <address> Hillsdale, NJ, </address> <year> 1983. </year>
Reference-contexts: Government. tracking a mouse in an interactive graphics application requires pause times of 50 milliseconds or less <ref> [5] </ref>. For garbage collection to be useful in applications with real-time constraints, pause times must be bounded. We have implemented a garbage collector which provides real-time collection using a new technique. This technique is efficient and can provide such short bounded pause times. <p> The lower setting was chosen because it allowed us to achieve pause times of 50 milliseconds yet still have the collector terminate. We chose 50 milliseconds as our target pause time because this is the maximum pause time which will allow an interactive program to smoothly track a mouse <ref> [5] </ref>. When N is 0.2Mb we set L to 0.1Mb and when N is 1Mb we set L to 0.5Mb. The value of 0.1Mb was chosen because that is approximately how much data the collector can copy in 50 milliseconds, while the value of 0.5Mb was chosen somewhat arbitrarily.
Reference: [6] <author> Eric Cooper, Scott Nettles, and Indira Subramanian. </author> <title> Improving the Performance of SML Garbage Collection using Application-Specific Virtual Memory Management. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 43-52, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Each was chosen because it stressed the memory management system in a different way. All benchmarks require several minutes to execute and require many major and minor garbage collections during execution. See <ref> [6] </ref> for more details about these benchmarks. * Primes is a prime number sieve implemented in a simple lazy language which is in turn interpreted by an SML program. It allocates memory at a very high rate (approximately 10Mb/sec), but few objects survive garbage collection.
Reference: [7] <author> E. Dijkstra, L. Lamport, A. Martin, C. Scholten, and E. Stef-fens. </author> <title> On-the-fly Garbage Collection:An Exercise in Cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <month> Novem-ber </month> <year> 1978. </year>
Reference-contexts: Immutable objects are allocated in private heaps which are collected by a replication-based stop-and-copy collector. This collector copies values into a shared heap which is collected using a concurrent mark-and-sweep algorithm based on Dijkstra <ref> [7] </ref>. To avoid the issue of inconsistent mutable values all such objects are allocated in the shared heap.
Reference: [8] <author> D. Doligez and X. Leroy. </author> <title> A concurrent generational garbage collector for a multi-threaded implementation of ml. </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 113-123, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The authors observed the possibility of using a from-space invariant for a copying collector. Two recent collectors for ML are quite closely related to ours. However, both depend on the semantics of ML more closely than our work. Doligez and Leroy <ref> [8] </ref> have implemented a concurrent collector which uses a mixed strategy to provide collection for a multithreaded version of CAML. Immutable objects are allocated in private heaps which are collected by a replication-based stop-and-copy collector.
Reference: [9] <author> John R. Ellis, Kai Li, and Andrew W. Appel. </author> <title> Real-time Concurrent Garbage Collection on Stock Multiprocessors. </title> <type> Technical Report DEC-SRC-TR-25, </type> <institution> DEC Systems Research Center, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: The collector could choose to concentrate early replication effort on only immutable objects, and thereby delay the need to process the log until the last possible moment. The actual copying of an object can be delayed until the object is scanned using an optimization suggested by Ellis <ref> [9] </ref>. The collector could replicate mutable objects into a segregated portion of the to-space, and delay copying and scanning mutable objects as long as possible.
Reference: [10] <author> Antony L. Hosking, J. Eliot B. Moss, and Darko Stefanovic. </author> <title> A comparative performance evaluation of write barrier implementations. </title> <booktitle> In Proceedings of the 1992 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <year> 1992. </year>
Reference-contexts: This allows us to eliminate the read-barrier and modify the to-space invariant. However, our method requires a write-barrier because the mutator may continue to modify objects after they have been replicated. A write-barrier is much less costly to implement than a read-barrier <ref> [10] </ref>. Conceptually, the standard Copy operation can be made non-destructive by reserving an extra word in the object which is not observable by the mutator and which is used to store the forwarding pointer.
Reference: [11] <author> Lorenz Huelsbergen and James R. Larus. </author> <title> A concurrent copying garbage collector for languages that distinguish (im)mutable data. </title> <booktitle> In Proceedings of the 1993 ACM Sym-posiym on Principles and Practice of Parallel Programming, </booktitle> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: The use of replication-copying allows the original owner of these values to continue to access the copy in the private heap. Huelsbergen and Larus <ref> [11] </ref> have recently built a concurrent collector for SML/NJ which uses replication-based copying. They use a to-space invariant and a consistency protocol which requires that the mutator read and write the to-space version if it exists.
Reference: [12] <author> David A. Moon. </author> <title> Garbage Collection in a Large Lisp System. </title> <booktitle> In Proceedings of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 235-246. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1984. </year>
Reference-contexts: For incremental collection to be possible, the garbage collector must sometimes suspend its work and permit the mutator to run, even though the collection algorithm has not completed. Previous work on incremental collection has focused on techniques that required either special hardware or operating system support <ref> [12, 1] </ref>, or in which the extra overhead for the mutator was potentially very high [4, 16]. These algorithms are variants of Baker's algorithm [2] which uses a to-space invariant. The to-space invariant requires that the mutator use only pointers into to-space.
Reference: [13] <author> Scott M. Nettles, James W. O'Toole, and David K. Gifford. </author> <title> Concurrent garbage collection of persistent heaps. </title> <institution> Technical Report MIT-LCS-TR-569 and CMU-CS-93-137, Mas-sachusetts Institute of Technology and Carnegie Mellon University, </institution> <year> 1993. </year> <note> Submitted to 14th Symposium on Operating Systems Principles. </note>
Reference-contexts: Mutation logging works best when mutations are infrequent or can be recorded without mutator cooperation. Mutation logging is also attractive whenever writes are already expensive or a mutation log is required for other reasons. For example, generational collectors, persistent data, and distributed systems usually make mutation operations more expensive <ref> [13] </ref>. 2.2 The Collector Invariant The invariant maintained by the replication-based garbage collector is that the mutator can only access from-space objects, that all previously scanned objects in to-space contain only to-space pointers, and that all to-space replicas are up-to-date with respect to their original from-space objects, unless a corresponding mutation <p> In addition to the advantages concurrent collection has for such systems a further advantage is that such systems also must log all mutation to transactional data. Replication-copying is thus even more attractive. We are currently working on extending the concurrent collector implementation to support a transactional persistent heap <ref> [13] </ref>. An area which we have not yet explored is what policies are best suited for use with our collector. For example in an interactive system, our technique would allow collection to proceed while the system was waiting for input.
Reference: [14] <author> Scott M. Nettles, James W. O'Toole, David Pierce, and Nicholas Haines. </author> <title> Replication-Based Incremental Copying Collection. </title> <booktitle> In Proceedings of the SIGPLAN International Workshop on Memory Management, </booktitle> <pages> pages 357-364. </pages> <publisher> ACM, Springer-Verlag, </publisher> <month> September </month> <year> 1992. </year> <note> Also available as Carnegie Mellon University Technical Report CMU-CS-93-135. </note>
Reference-contexts: The garbage collector incrementally builds a consistent replica of the accessible objects. The modified collector invariant decouples the execution of the garbage collector from the mutator, and permits the collector great flexibility in scheduling its replication activity. An early prototype of our implementation <ref> [14] </ref> demonstrated that replication can be used for incremental collection but did not provide real-time response. It also did not allow for a careful comparison of performance with stop-and-copy collection. <p> Therefore, when L is very small, the major-incremental collection may not terminate. There is an implementation-dependent lower bound for L that will guarantee termination, but such a conservative completion strategy increases the total cost of garbage collection <ref> [14] </ref>. 3.4 The Real-Time Collector Minor collection pauses are usually short, but may not be bounded by L. Therefore, to bound these collection pauses, the real-time collector uses the incremental algorithm for minor collections as well as for major collections. <p> Huelsbergen and Larus [11] have recently built a concurrent collector for SML/NJ which uses replication-based copying. They use a to-space invariant and a consistency protocol which requires that the mutator read and write the to-space version if it exists. Our previous work <ref> [14] </ref> considers this protocol, the from-space invariant and other consistency options for replication garbage collection. In addition to maintaining a to-space invariant, their collector has a number of other differences from our own. <p> Also their implementation is more closely tied to the semantics of mutable values in SML and to the details of their processor memory consistency model. We hope to implement their technique along with others from <ref> [14] </ref> in the context of a concurrent version of the collector described here. This will allow a quantitative comparison of these options. 6 Future Work and Conclusions We are actively extending the current work in several directions. Our experimental implementation is perfectly suited for use as a concurrent collector.
Reference: [15] <author> K. Nilsen. </author> <title> Garbage Collection of Strings and Linked Data Structures in Real-time. </title> <journal> Software-Practice and Experience, </journal> <volume> 18(7) </volume> <pages> 613-640, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: A method due to Brooks [4], and later implemented by North [16], requires the mutator to follow a forwarding pointer which leads to the relocated object. Nilsen <ref> [15] </ref> describes a software implementation of Baker's algorithm which is designed for an environment in which strings are heavily used. The overhead of his technique seems to be prohibitive in a more general context. Recent work by Boehm, Demers and Shenker [3] on a concurrent mark-and-sweep collector promises real-time performance.
Reference: [16] <author> S. C. North and J.H. Reppy. </author> <title> Concurrent Garbage Collection on Stock Hardware. </title> <editor> In Gilles Kahn, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture (LNCS 274), </booktitle> <pages> pages 113-133. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Previous work on incremental collection has focused on techniques that required either special hardware or operating system support [12, 1], or in which the extra overhead for the mutator was potentially very high <ref> [4, 16] </ref>. These algorithms are variants of Baker's algorithm [2] which uses a to-space invariant. The to-space invariant requires that the mutator use only pointers into to-space. The cost of enforcing this restriction leads to the need for special hardware or operating system support. <p> The work of Ellis, Li, and Appel [1] exemplifies the use of virtual memory traps and other operating system support to implement similar conditions. A method due to Brooks [4], and later implemented by North <ref> [16] </ref>, requires the mutator to follow a forwarding pointer which leads to the relocated object. Nilsen [15] describes a software implementation of Baker's algorithm which is designed for an environment in which strings are heavily used. The overhead of his technique seems to be prohibitive in a more general context.
Reference: [17] <author> James W. O'Toole. </author> <title> Garbage Collecting an Object Cache. </title> <type> Technical Report MIT/LCS/TM-485, </type> <institution> Massachusetts Institute of Technology, </institution> <month> April </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: For example, the collector can copy objects in essentially any desired order. This freedom in copying order could be used to increase locality of reference or to change the representation of objects stored in a cache <ref> [17] </ref>. Another way that copying order freedom can be exploited is by concentrating early replication work on objects reachable from particular roots. Particular roots may be more likely to change than others, so copying them later could reduce the amount of latent garbage copied by the collector.
Reference: [18] <author> James W. O'Toole and Scott M. Nettles. </author> <title> Concurrent Replication Garbage Collection. </title> <institution> Technical Report MIT-LCS-TR-570 and CMU-CS-93-138, Massachusetts Institute of Technology and Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: Synchronization between the collector and the mutator is only required for transferring the mutation log and updating the roots. The concurrent version of this implementation is working and initial performance measurements can be found in <ref> [18] </ref>. Replication-based copying is also a promising approach for use in heap based transaction systems. In addition to the advantages concurrent collection has for such systems a further advantage is that such systems also must log all mutation to transactional data. Replication-copying is thus even more attractive.
Reference: [19] <author> James W. O'Toole and Scott M. Nettles. </author> <title> Real-Time Replication GC: An Implementation Report. </title> <institution> Technical Report MIT-LCS-TR-568 and CMU-CS-93-136, Massachusetts Institute of Technology and Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: A was chosen to be L/2. This guarantees that the collector will make progress when an incremental collection is active. We also ran our benchmarks with other values of L but those results are not particularly illuminating and have been omitted due to lack of space (see <ref> [19] </ref> for more details). In general, as L increases, pause times increase and duration of collections decrease. Any overheads that are related to collection duration decrease.
Reference: [20] <author> Paul R. Wilson. </author> <title> Uniprocessor Garbage Collection Techniques. </title> <booktitle> In Proceedings of the 1992 SIGPLAN International Workshop on Memory Management, </booktitle> <pages> pages 1-42. </pages> <publisher> ACM, Springer-Verlag, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: Finally, we discuss possible improvements to the implementation and suggest areas for further work. We assume that the reader is familiar with the basics of copying and generational garbage collection, a survey may be found in Wilson <ref> [20] </ref>. 2 Real-Time Replication Garbage Col lection Incremental collectors permit the mutator to resume execution before the collection has completed. The operations of the collector and the mutator may be interleaved. Thus the effects of the garbage collector must not be observable by the language primitives used by the mutator.
References-found: 20

