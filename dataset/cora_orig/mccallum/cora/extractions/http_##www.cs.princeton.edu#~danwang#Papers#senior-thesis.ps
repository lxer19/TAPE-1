URL: http://www.cs.princeton.edu/~danwang/Papers/senior-thesis.ps
Refering-URL: http://www.cs.princeton.edu/~danwang/
Root-URL: http://www.cs.princeton.edu
Title: A Generic Typed Virtual Machine  
Author: Daniel C. Wang 
Degree: Advisor: Peter Lee  
Date: May 11, 1996  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Hal Abelson and Gerald Jay Sussman. </author> <title> The Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: 1 Introduction 1.1 Intermediate code and Virtual Machines Research in the design and implementation of compilers and interpreters has been progressing for several decades. Techniques for efficient compilation of Algol and Lisp like languages are well understood <ref> [3, 1] </ref>. Likewise there are well-established techniques for the interpretation of these languages. A technique common to both compiler and interpreters is to translate the source language into an intermediate language thereby converting the higher level constructs into more primitive forms.
Reference: [2] <author> Ali-Reza Adl-Tabatabai, Geoff Langdale, Steven Lucco, and Robert Wahbe. </author> <title> Efficient and language-independent mobile programs. </title> <booktitle> In Proceedings of the 1996 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year> <note> ACM Press. to appear in. </note>
Reference-contexts: Current implementations of Java rely on a P-CODE like virtual machine [11]. Omniware is a recent UNCOL for modern day RISC machines <ref> [2] </ref>. Compilers are becoming more machine independent and easier to re-target with code generator generators [16, 9]. <p> experience in using the GTVM as a target for a dynamically and statically type source language and finally evaluate some of the underlying design assumptions empirically. 3.1 Comparisons with Other Designs The JavaVM and OmniVM are the underlying virtual machines that are used to implement the Java and Omniware systems <ref> [11, 2] </ref>. Since the JavaVM is modeled after a P-CODE machine and the OmniVM is basically a modern day UNCOL, the GTVM shares several features in common with both the JavaVM and OmniVM. <p> SFI allows several untrusted programs to share a single address space without the danger of one program maliciously or accidently gaining access to the memory of other programs. An SFI scheme that checks each memory write incurs approximately a 10% - 5% overhead when compared to native unsafe code <ref> [2] </ref>. However, when SFI is used to check memory reads the overhead can increase to 20% - 30% [20]. <p> Compilers for the OmniVM instruction set produce code that is as good as that produced by portable compilers like gcc. Compared to compilers targeted for a specific hardware architecture OmniVM compilers can produce code that ranges from 3% to 10% worse depending on the hardware architecture <ref> [2] </ref>. It seems clear that the best possible performance is to be achieved with an UNCOL approach to portability that GTVM and the OmniVM take. However, to achieve good performance the GTVM relies much more heavily on the techniques of optimizing compilers.
Reference: [3] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <title> Compilers. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: 1 Introduction 1.1 Intermediate code and Virtual Machines Research in the design and implementation of compilers and interpreters has been progressing for several decades. Techniques for efficient compilation of Algol and Lisp like languages are well understood <ref> [3, 1] </ref>. Likewise there are well-established techniques for the interpretation of these languages. A technique common to both compiler and interpreters is to translate the source language into an intermediate language thereby converting the higher level constructs into more primitive forms. <p> This restriction does not make it more difficult to compile various source languages for the GTVM and significantly simplifies the type system and type checking algorithm. Procedures pass arguments with value result semantics. Value result semantics prevent register aliasing ambiguities which make certain compiler optimizations difficult <ref> [3] </ref>. Except for one primitive constant instruction there are no immediate values. All arithmetic instructions work on register values alone. Tail recursion optimizations are guaranteed to be performed when tail calls are used. <p> It then must check that the entry and exit type state of each basic block is independent of any path taken in the control flow graph [11]. This algorithm is similar to a variety of conservative data flow analysis done by traditional compilers <ref> [3] </ref>. Because the GTVM uses an infinite register model it can restrict the use of each register to one unique type. This restriction makes the the type checking algorithm for the GTVM considerably simpler and most likely much more efficient in practice.
Reference: [4] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Making data representation relatively abstract allows aggressive representation optimizations to benefit a wider class of languages <ref> [4, 18] </ref>. This places a much larger burden on the implementors of a GTVM compiler or interpreter, but since GTVM is designed to be used by a large set of source languages the effort put into the data optimizations is well rewarded. <p> Since these heap allocated boolean values can also be represented as plain integers a third version of the quicksort program was generated from the GTVM generated C code by hand which makes this data representation optimization. This data representation optimization is a common one found in the SML/NJ compiler <ref> [4] </ref>. All three programs were compiled with gcc with and without optimizations. Each programs was run on the same sample input set thirty times on three different machine architectures (MIPS, SPARC, PA-RISC) and the normalized averages of all ninety runs are reported in table 3.3.
Reference: [5] <author> Brian N. Bershard, Stefan Savage, Przemyslaw Pardyak, Emin Gun Sirer, Marc E. Fi-uczynski, David Becker, Craig Chambers, and Susan J. Eggers. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 267-284, </pages> <address> Copper Mouontain Resort, CO, </address> <month> December </month> <year> 1995. </year> <note> ACM Press. </note>
Reference-contexts: These language or compiler enforced abstraction boundaries are often cheaper and more flexible than hardware techniques. With cheap abstraction boundaries the idea of highly-user configurable operating systems becomes a reality <ref> [5, 10] </ref>. If a client depends on a remote resource on a server it can be worthwhile for the client to encode the computation it wishes to cary out and have the server carry out the client's computation remotely to minimize communication.
Reference: [6] <author> Lucca Cardelli. Obliq: </author> <title> A language with distributed scope. </title> <type> Report 122, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1994. </year>
Reference-contexts: Networks connecting large groups of heterogeneous computers, have given rise to the idea of platform independent code that travels from host to host via the network, allowing one to distribute computation <ref> [6] </ref>. In an effort to achieve higher levels of performance, operating systems designers are using compiler and language level support to enforce abstraction boundaries rather than relying on traditional hardware based techniques. These language or compiler enforced abstraction boundaries are often cheaper and more flexible than hardware techniques.
Reference: [7] <author> M. E. Conway. </author> <title> Proposal for an UNCOL. </title> <journal> cacm, </journal> <volume> 1(10) </volume> <pages> 5-8, </pages> <month> October </month> <year> 1958. </year>
Reference-contexts: Ideally language implementors would like a way to portably compile to native machine code. There in fact have been several proposals to achieve this ideal. An old idea is for the creation of a universal computer oriented language (UNCOL) <ref> [7] </ref>. All compilers would compile to this language, and then a machine specific translator would convert UNCOL to native machine code. Unfortunately because any UNCOL was intended to be generic, compilers could not exploit machine specific features to get optimal performance.
Reference: [8] <author> Drew Dean, Edward W. Felton, and Dan S. Wallach. </author> <title> Java security: from HotJava to Netscape and beyond. </title> <booktitle> In 1996 IEEE Symposium on Security and Privacy, </booktitle> <address> Oakland, CA, </address> <month> May </month> <year> 1996. </year> <note> to appear in. </note>
Reference-contexts: If software components are to be trusted they must be simple. Already there is evidence that the complexity of the JavaVM type system and verification algorithm as well as the lack of a formal semantics has lead to serious security flaws <ref> [8] </ref>. Enforcing security through type systems and other methods of static verification have some theoretical limits. In particular there may exist programs that are not type correct but do not violate the security of the system.
Reference: [9] <author> H. Emmelmann, F.-W. Schroer, and L. Landwehr. BEG: </author> <title> a generation for efficient back ends. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(7) </volume> <pages> 227-237, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Current implementations of Java rely on a P-CODE like virtual machine [11]. Omniware is a recent UNCOL for modern day RISC machines [2]. Compilers are becoming more machine independent and easier to re-target with code generator generators <ref> [16, 9] </ref>. However, today there are new problems that these old ideas do not address, and many of these old ideas have not be incorporated into a useful framework that langauge implementors can use "off the shelf".
Reference: [10] <author> Dawson R. Engler, M. Frans Kaashoek, and James O'Toole Jr. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 251-266, </pages> <address> Copper Mouontain Resort, CO, </address> <month> December </month> <year> 1995. </year> <note> ACM Press. </note>
Reference-contexts: These language or compiler enforced abstraction boundaries are often cheaper and more flexible than hardware techniques. With cheap abstraction boundaries the idea of highly-user configurable operating systems becomes a reality <ref> [5, 10] </ref>. If a client depends on a remote resource on a server it can be worthwhile for the client to encode the computation it wishes to cary out and have the server carry out the client's computation remotely to minimize communication.
Reference: [11] <author> James Gosling. </author> <title> Java intermediate bytecodes. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 30(3) </volume> <pages> 111-118, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Current implementations of Java rely on a P-CODE like virtual machine <ref> [11] </ref>. Omniware is a recent UNCOL for modern day RISC machines [2]. Compilers are becoming more machine independent and easier to re-target with code generator generators [16, 9]. <p> experience in using the GTVM as a target for a dynamically and statically type source language and finally evaluate some of the underlying design assumptions empirically. 3.1 Comparisons with Other Designs The JavaVM and OmniVM are the underlying virtual machines that are used to implement the Java and Omniware systems <ref> [11, 2] </ref>. Since the JavaVM is modeled after a P-CODE machine and the OmniVM is basically a modern day UNCOL, the GTVM shares several features in common with both the JavaVM and OmniVM. <p> After computing the control flow graph a type checker for a JavaVM program must infer the "type state" of each basic block. It then must check that the entry and exit type state of each basic block is independent of any path taken in the control flow graph <ref> [11] </ref>. This algorithm is similar to a variety of conservative data flow analysis done by traditional compilers [3]. Because the GTVM uses an infinite register model it can restrict the use of each register to one unique type. <p> The unoptimized code generate from the GTVM runs about three times slower than the both the reference versions compiled with and without -O. This is at least an order of magnitude better than P-CODE approaches such as Java <ref> [11] </ref>. Making the simple data representation optimization on the code compiled without -O gives us nearly double the performance. This demonstrates the importance of data representation optimizations.
Reference: [12] <author> David Gudeman. </author> <title> Representing type information in dynamically typed languages. </title> <type> TR 93-27, </type> <institution> University of Arizona, </institution> <month> October </month> <year> 1993. </year> <month> 17 </month>
Reference-contexts: The intermediate language for a Lisp-like source language which might for example, include pairs and symbols as primitive data structures. This makes the compiler or interpreter less dependent on specific tagging <ref> [12] </ref>, alignment and other machine dependent issues. Implementations that use an intermediate language sometime conceptualize the intermediate language as the instruction set for a virtual 1 machine whose execution semantics define the semantics of the intermediate language. <p> The values of such a language would use the a union v whose tag would encode the dynamic type. For dynamically typed languages efficient machine representations for type information are very important. However, often the most efficient machine representation depends on the underlying machine architecture <ref> [12] </ref>. By leaving the specification abstract, the language puts the burden on a GTVM compiler or interpreter to find a efficient machine dependent representation.
Reference: [13] <author> Priyadarshan Kolte and Michael Wolfe. </author> <title> Elimination of redundant array subscript range checks. </title> <booktitle> In Proceedings of the 1995 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 270 - 278, </pages> <address> La Jolla, California, June 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: However, when SFI is used to check memory reads the overhead can increase to 20% - 30% [20]. SFI has the advantage that it can enforce security for a larger class of programs. 5 See <ref> [13] </ref> for compile time techniques that to reduce the cost of these runtime checks. 11 Compilers for unsafe languages such as C whose security cannot be statically verified can be run safely with SFI. The security guarantees that SFI provide however are much weaker.
Reference: [14] <author> Sun Microsystems. </author> <title> The java virutal machine specification. </title> <note> See: http://java.sun.com/java.sun.com/doc/vmspec/html/vmspec-29.html#HEADING29-0, 1995. </note>
Reference-contexts: Most of these difference arise from the fact that the JavaVM was designed as a target VM for the Java language. In fact the current JavaVM specification includes references to the Java language specification to define the semantics of certain JavaVM instructions <ref> [14] </ref>. However, important differences lie in the static type systems of the two languages. The JavaVM is modeled after P-CODE machine which uses a stack to manage temporaries. This stack model provides a more compact binary encoding when compared to the infinite register model used by the GTVM and OmniVM.
Reference: [15] <author> P. A. Nelson. </author> <title> A comparison of PASCAL intermediate languages. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 14(8) </volume> <pages> 208-213, </pages> <month> August </month> <year> 1979. </year>
Reference-contexts: The UCSD Pascal compiler compiled Pascal code to a virtual machine, implemented the virtual machine in software, and combined the virtual machine code (P-CODE) with the software virtual machine (P-machine) to produce stand alone Pascal programs that were in essence interpreted <ref> [15] </ref>. Since the work of porting a software virtual machine to a different hardware architecture is small when compared to re-targeting a native code compiler, the UCSD Pascal compiler became popular and ran on a wide variety of different hardware machines during its time 2 .
Reference: [16] <author> Todd A. Proebsting. </author> <title> BURS automata generation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3) </volume> <pages> 461-486, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Current implementations of Java rely on a P-CODE like virtual machine [11]. Omniware is a recent UNCOL for modern day RISC machines [2]. Compilers are becoming more machine independent and easier to re-target with code generator generators <ref> [16, 9] </ref>. However, today there are new problems that these old ideas do not address, and many of these old ideas have not be incorporated into a useful framework that langauge implementors can use "off the shelf".
Reference: [17] <author> David Muir Sharnoff and Steven Allen Robenalt. </author> <title> Catalog of free compilers and interpreters. Online at: </title> <address> ftp://ftp.idiom.com/pub/compilers-list/free-compilers, </address> <year> 1996. </year>
Reference-contexts: not intended to exists as physical hardware machine. 2 Especially when the virtual machine is implemented in a widely avaliable language like C. 2 interpreters for languages such as Perl, Caml Light, Emacs Lisp, and Scheme compile the source language to virtual machine code and interpret the code in software <ref> [17] </ref>. This approach in implementing an interpreter provides significant performance improvements when compared to interpreting the source language. <p> C has in fact become widely available across a number of platforms, several different implementations of compilers for advanced languages (ghc, Scheme-&gt;C, smlc, bigloo, p2c, f2c, and m2c) use C as a de facto UNCOL <ref> [17] </ref>. Using C has a number of disadvantages, since C was not designed to be a target for these high-level languages. For example tail-recursion optimizations are necessary for the efficient implementation of many of these languages. Few if any C compilers support these optimizations. <p> Some compiler writers wishing to achieve a high level of portability with minimal cost have attempted to interface a language specific front-end (DEC SRC Modula-3, Gnu-ADA, g++, Gnu-Fortran77) with the portable backend of gcc <ref> [17] </ref>. This technique provides more flexibility than compiling to C. For example, tail-recursion optimizations can be carried out 3 at this level. Unfortunately the designers of gcc did not intend it to be a universal back--end, and so retrofitting a front-end on gcc can be difficult.
Reference: [18] <author> David Tarditi, Greg Morriset, Perry Cheng, Chris Stone, Robert Harper, and Peter Lee. </author> <title> Til: A type-directed optimizing compiler for ML. </title> <booktitle> In Proceedings of the 1996 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year> <note> ACM Press. to appear in. </note>
Reference-contexts: Making data representation relatively abstract allows aggressive representation optimizations to benefit a wider class of languages <ref> [4, 18] </ref>. This places a much larger burden on the implementors of a GTVM compiler or interpreter, but since GTVM is designed to be used by a large set of source languages the effort put into the data optimizations is well rewarded.
Reference: [19] <author> Jeffrey D. Ullman. </author> <title> Elements of ML programming. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: Having recursive data structures in an otherwise low-level intermediate language is a unique contribution of this design. The choice of data structures was strongly influenced by the "datatype" construct in SML <ref> [19] </ref> and the data structures of C. The data structures of the language includes mutable tuples of heterogenous values, arrays with length determined at run-time, and immutable discriminated unions.
Reference: [20] <author> Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Grahm. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <address> Philadelphia, PA, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The OmniVM provides a much weaker but more flexible form of security though software fault isolation (SFI) <ref> [20] </ref>. SFI provides fine grain memory protection within a single address space by inserting software memory checks in machine code. SFI allows several untrusted programs to share a single address space without the danger of one program maliciously or accidently gaining access to the memory of other programs. <p> An SFI scheme that checks each memory write incurs approximately a 10% - 5% overhead when compared to native unsafe code [2]. However, when SFI is used to check memory reads the overhead can increase to 20% - 30% <ref> [20] </ref>.
Reference: [21] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <booktitle> In Lecture Notes in Computer Science no. </booktitle> <volume> 637. </volume> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: For example tail-recursion optimizations are necessary for the efficient implementation of many of these languages. Few if any C compilers support these optimizations. Also many high-level languages require automatic storage reclamation through garbage collection techniques, which requires the compiler to identify statically pointers and non-pointers <ref> [21] </ref>. Some compiler writers wishing to achieve a high level of portability with minimal cost have attempted to interface a language specific front-end (DEC SRC Modula-3, Gnu-ADA, g++, Gnu-Fortran77) with the portable backend of gcc [17]. This technique provides more flexibility than compiling to C.
Reference: [22] <author> Paul R. Wilson, Mark S. Johnstone, Michael Neely, and David Boles. </author> <title> Allocation: A survey and critical review. </title> <booktitle> In International Workshop on Memory Management, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: Data representation optimizations will almost always improve performance across a large class of programs, but the choice of an optimal garbage collection strategy or memory management policy in general is much more program specific <ref> [22] </ref>. It is not clear whether there exists one general purpose automatic storage management technique that is optimal for a large class of allocation intensive programs that may use the GTVM .
References-found: 22

