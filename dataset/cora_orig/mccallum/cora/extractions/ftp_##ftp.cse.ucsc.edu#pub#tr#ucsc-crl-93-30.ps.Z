URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-93-30.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: What is a race in a program  
Keyword: trace analysis, race detection, debugging, parallel programming, event ordering  
Address: Santa Cruz, CA 95064  
Affiliation: Board of Studies in Computer and Information Sciences University of California, Santa Cruz  
Date: August 2, 1993  
Note: UCSC-CRL-93-30  
Abstract: and when can we detect it? abstract This paper presents a taxonomy of methods for detecting race conditions in parallel programs, shows how recent results fit into the taxonomy, and presents some new results for previously unexamined points in the taxonomy. It also presents a taxonomy of "races" and suggested terminology. 
Abstract-found: 1
Intro-found: 1
Reference: [CKS90] <author> D. Callahan, K. Kennedy, and J. Subhlok. </author> <title> Analysis of event synchronization in a parallel programming tool. </title> <booktitle> In Proceedings of Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPOPP), SIGPLAN Notices, </booktitle> <pages> pages 21-30, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: in P [LKN93], * post/wait/clear is N P-hard (Thm: 3), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear <ref> [CKS90] </ref> Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 3.1: What <p> N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear <ref> [CKS90] </ref> Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 3.1: What ordering relationships hold between statement (instances)? Theorem 2: Deciding if there exists a race between two conflicting statements in an arbitrary shared memory parallel program <p> The set of programs where all paths are executable is clearly a subset of all programs and hence they have shown that with the addition of Post and Wait the problem is still N P-hard even for the smaller set of programs. Post/Wait no Clear Callahan et. al. <ref> [CKS90] </ref> have studied simple programs containing only if-then-else conditionals and Post/Wait synchronization without Clear (i.e. no loops). The Post/Wait operations are permitted to specify events within an array. <p> In an earlier paper [CS88] they prove that the problem of determining if a program is race free is CoN P-hard for even these relatively simple programs under the further assumption that all program paths are feasible. In <ref> [CKS90] </ref>, they have gone on to develop a dataflow formulation of the problem for which they can compute an approximate solution in polynomial time (the paper does not give the actual complexity). <p> As in the case of unrestricted programs, programmers must still uncover data races in their parallel programs. Therefore approaches that compute approximate answers to the problem have been studied and continue to be investigated <ref> [MC91, DS90, NR88, CKS90] </ref>. Post/Wait/Clear The CoN P-Hard result from [CS88] also applies here. In fact, with the addition of Clear, even detecting races in branch-free (i.e. no conditionals or loops) programs is N P-Hard (see Theorem 3). 4.
Reference: [CS88] <author> D. Callahan and J. Subhlok. </author> <title> Static analysis of low-level synchronization. </title> <booktitle> In Proc. Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 100-111, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: For each input, the program with branching can be viewed as a set of branch-free programs. Each legal combination of branch choices for that input leads to one branch-free program. A simplifying assumption <ref> [CS88] </ref> is that all branch combinations 3. <p> * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 3), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard <ref> [CS88] </ref> even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered <p> are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard <ref> [CS88] </ref> even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 3.1: What ordering relationships hold between statement (instances)? Theorem 2: Deciding if there exists <p> They claim that as generally used, the index expressions for these events are amenable to standard dependence analysis for computing a dependence distance (i.e. the difference between the parallel loop index and the array index used by the Post or Wait). In an earlier paper <ref> [CS88] </ref> they prove that the problem of determining if a program is race free is CoN P-hard for even these relatively simple programs under the further assumption that all program paths are feasible. <p> As in the case of unrestricted programs, programmers must still uncover data races in their parallel programs. Therefore approaches that compute approximate answers to the problem have been studied and continue to be investigated [MC91, DS90, NR88, CKS90]. Post/Wait/Clear The CoN P-Hard result from <ref> [CS88] </ref> also applies here. In fact, with the addition of Clear, even detecting races in branch-free (i.e. no conditionals or loops) programs is N P-Hard (see Theorem 3). 4.
Reference: [DKF93] <author> S. K. Damodaran-Kamal and J. M Francioni. </author> <title> Nondeterminacy: Testing and debugging in message passing parallel programs. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 118-128, </pages> <year> 1993. </year>
Reference-contexts: [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing <ref> [DKF93] </ref>, rendezvous [Tay83, LC89] Table 3.1: What ordering relationships hold between statement (instances)? Theorem 2: Deciding if there exists a race between two conflicting statements in an arbitrary shared memory parallel program (containing explicit thread creation but no loops) is N P-hard. Proof: By reduction from 3SAT.
Reference: [DS90] <author> A. Dinning and E. Schonberg. </author> <title> An empirical comparison of monitoring algorithms for access anomaly detection. </title> <booktitle> In Proceedings of Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPOPP), </booktitle> <year> 1990. </year>
Reference-contexts: However, the assumption that all combinations of branches are possible alleviates this problem. 4. Details of known results in our taxonomy of ordering event results 11 Exact Solution Approximations Branch free Mono tonic * all monotonic are in P [HM93], * fork/join is in P <ref> [MC91, DS90, NR88] </ref>, * ordered critical sections are in P (section 4.4), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 3), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is <p> mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 3), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], <p> loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 3.1: What ordering relationships hold between statement (instances)? Theorem 2: Deciding if there exists a race between two conflicting statements in <p> is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 3.1: What ordering relationships hold between statement (instances)? Theorem 2: Deciding if there exists a race between two conflicting statements in an arbitrary shared memory parallel program (containing explicit thread creation but no loops) is <p> As in the case of unrestricted programs, programmers must still uncover data races in their parallel programs. Therefore approaches that compute approximate answers to the problem have been studied and continue to be investigated <ref> [MC91, DS90, NR88, CKS90] </ref>. Post/Wait/Clear The CoN P-Hard result from [CS88] also applies here. In fact, with the addition of Clear, even detecting races in branch-free (i.e. no conditionals or loops) programs is N P-Hard (see Theorem 3). 4. <p> Fork/Join A number of methods have been developed in the context of on-the-fly race detection that could be used as polynomial time algorithms for determining event orders in branch free fork/join programs <ref> [MC91, DS90, NR88] </ref>. Some recent efforts have focused on reducing the number of events that must be traced [Net93, MC93].
Reference: [DS91] <author> A. Dinning and E. Schonberg. </author> <title> Detecting access anomalies in programs with critical sections. </title> <booktitle> In Proc. Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 79-90, </pages> <month> May </month> <year> 1991. </year> <note> References 19 </note>
Reference-contexts: For branch-free programs, this comparision can easily be done using O (L 2 ) time and O (L) space per event, where L is the maximum lock nesting depth. In practice the lock nesting depth is very small (i.e. 0 or 1) <ref> [DS91] </ref>. Post/Wait no Clear Netzer and Ghosh [NG92] have an algorithm that precisely determines the event orderings for a trace of a program that uses Post/Wait synchronization with no Clears. <p> The most significant contribution of Offset-Span labeling is that a single execution is sufficient to identify a non-empty subset of the races that could occur for a given input. 5.2 Critical Sections Dinning and Schonberg <ref> [DS91] </ref> describe an approach to detecting access anomalies in programs that contain critical sections (i.e. properly nested binary semaphores). This approach can use any existing method for determining when two blocks are ordered (e.g. Offset-Span labeling) ignoring the orderings imposed by the unlock-lock operations. As one 6.
Reference: [EP88] <author> P. A. Emrath and D. A. Padua. </author> <title> Automatic detection of nondeterminacy in parallel programs. </title> <booktitle> In Proc. Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 89-99, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: A third potentially useful attribute of a race is its severity. We currently identify two severity levels, critical and benign. A benign race has no external effect on the results of the program (Padua and Emrath <ref> [EP88] </ref> call this internal non-determinism), while the outcome of a critical race can affect the program's result. Protecting a critical section with locks (mutual exclusion) does not prevent a race, but can make races benign.
Reference: [HM91] <author> D. P. Helmbold and C. E. McDowell. </author> <title> Computing reachable states of parallel programs (extended abstract). </title> <booktitle> SIGPLAN Notices: Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <volume> 26(12) </volume> <pages> 76-84, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Nevertheless, programmers must still uncover data races in their parallel programs. Therefore approaches that compute approximate answers to the problem have been studied and continue to be investigated <ref> [Tay83, LC89, HM91] </ref>. 4.2 No Loops and Monotonically Synchronized Excluding arbitrary loops is necessary to avoid termination problems and undecidability. Loops executing a fixed number of times can be unrolled.
Reference: [HM93] <author> D. P. Helmbold and C. E. McDowell. </author> <title> A class os synchronization operations that permit efficient race detection. </title> <note> In Submitted to Supercomputing '93, </note> <year> 1993. </year>
Reference-contexts: A taxonomy of event ordering approaches 7 3.1 Type of synchronization The first axis identifies the type of synchronization. At the top level we only distinguish two types of synchronization: monotonic and non-monotonic. These terms were first applied to synchronization in <ref> [HM93] </ref>. Intuitively, a synchronization construct is monotonic if once a blocking operation becomes unblocked, it remains unblocked for the duration of the program (e.g. <p> However, the assumption that all combinations of branches are possible alleviates this problem. 4. Details of known results in our taxonomy of ordering event results 11 Exact Solution Approximations Branch free Mono tonic * all monotonic are in P <ref> [HM93] </ref>, * fork/join is in P [MC91, DS90, NR88], * ordered critical sections are in P (section 4.4), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 3), * semaphores are coN P-hard [NM90] semaphores [HMW93] No <p> Therefore the problem is also coN P-hard when branches are permitted. 4.4 No Branches and Monotonically Synchronized We proved in a previous paper <ref> [HM93] </ref> that computing the precise ordering relationships between events in branch-free monotonically synchronized programs can be done in polynomial time. For completeness we include here several previous polynomial time results for determining the precise ordering relationships between events for programs using specific sets of monotonic synchronization constructs.
Reference: [HMW91] <author> D. P. Helmbold, C. E. McDowell, and J. Z. Wang. </author> <title> Detecting data races from sequential traces. </title> <booktitle> In Proc. of Hawaii International Conference on System Sciences, </booktitle> <pages> pages 408-417, </pages> <year> 1991. </year>
Reference-contexts: Are there any races in this program? Semaphores Determining precisely the ordering relationships for even branch-free programs containing semaphore synchronization is coN P-hard [NM90]. The results in this area are therefore restricted to approximations. Helmbold et.al. <ref> [HMW91] </ref> and Netzer and Miller [NM91] have pursed two complimentary approaches.
Reference: [HMW93] <author> D. P. Helmbold, C. E. McDowell, and J. Z. Wang. </author> <title> Determining possible event orders by analyzing sequential traces. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <note> 1993. Also UCSC Tech. Rep. UCSC-CRL-91-36. </note>
Reference-contexts: P [HM93], * fork/join is in P [MC91, DS90, NR88], * ordered critical sections are in P (section 4.4), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 3), * semaphores are coN P-hard [NM90] semaphores <ref> [HMW93] </ref> No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard <p> In <ref> [HMW93] </ref> we proved that our algorithm will find at least one race from the set of possible races that can occur for a given input if any exist. 6 What shared memory addresses are accessed by a statement (instance)? Operationally, race detection systems can be divided into three groups, compile time
Reference: [LC89] <author> D. L. Long and L. A. Clarke. </author> <title> Task interaction graphs for concurrency analysis. </title> <booktitle> In Proc. 11th Int. Conf. on Software Engineering, </booktitle> <year> 1989. </year>
Reference-contexts: Nevertheless, programmers must still uncover data races in their parallel programs. Therefore approaches that compute approximate answers to the problem have been studied and continue to be investigated <ref> [Tay83, LC89, HM91] </ref>. 4.2 No Loops and Monotonically Synchronized Excluding arbitrary loops is necessary to avoid termination problems and undecidability. Loops executing a fixed number of times can be unrolled. <p> NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous <ref> [Tay83, LC89] </ref> Table 3.1: What ordering relationships hold between statement (instances)? Theorem 2: Deciding if there exists a race between two conflicting statements in an arbitrary shared memory parallel program (containing explicit thread creation but no loops) is N P-hard. Proof: By reduction from 3SAT.
Reference: [LKN93] <author> H-I. Lu, P. N. Klein, and R. H. B. Netzer. </author> <title> Detecting race conditions in parallel programs that use one semaphore. </title> <type> Technical report, </type> <institution> Brown Univ., </institution> <year> 1993. </year>
Reference-contexts: event results 11 Exact Solution Approximations Branch free Mono tonic * all monotonic are in P [HM93], * fork/join is in P [MC91, DS90, NR88], * ordered critical sections are in P (section 4.4), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P <ref> [LKN93] </ref>, * post/wait/clear is N P-hard (Thm: 3), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono <p> Single Semaphore Computing the exact ordering relationship between events for a loop-free program that synchronizes using only a single semaphore can be done in O (n 1:5 p) time <ref> [LKN93] </ref> where n is the number of events and p is the number of threads. The algorithm presented by Lu, Klein, and Netzer determines if two events are ordered by solving a kind of scheduling problem.
Reference: [MC91] <author> J. Mellor-Crummey. </author> <title> On-the-fly detection of data races for programs with nested fork-join parallelism. </title> <booktitle> In Supercomputing '91, </booktitle> <pages> pages 24-33, </pages> <month> November </month> <year> 1991. </year> <title> Albu-querque, </title> <address> NM. </address>
Reference-contexts: However, the assumption that all combinations of branches are possible alleviates this problem. 4. Details of known results in our taxonomy of ordering event results 11 Exact Solution Approximations Branch free Mono tonic * all monotonic are in P [HM93], * fork/join is in P <ref> [MC91, DS90, NR88] </ref>, * ordered critical sections are in P (section 4.4), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 3), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is <p> mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 3), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], <p> loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 3.1: What ordering relationships hold between statement (instances)? Theorem 2: Deciding if there exists a race between two conflicting statements in <p> is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 3.1: What ordering relationships hold between statement (instances)? Theorem 2: Deciding if there exists a race between two conflicting statements in an arbitrary shared memory parallel program (containing explicit thread creation but no loops) is <p> As in the case of unrestricted programs, programmers must still uncover data races in their parallel programs. Therefore approaches that compute approximate answers to the problem have been studied and continue to be investigated <ref> [MC91, DS90, NR88, CKS90] </ref>. Post/Wait/Clear The CoN P-Hard result from [CS88] also applies here. In fact, with the addition of Clear, even detecting races in branch-free (i.e. no conditionals or loops) programs is N P-Hard (see Theorem 3). 4. <p> Fork/Join A number of methods have been developed in the context of on-the-fly race detection that could be used as polynomial time algorithms for determining event orders in branch free fork/join programs <ref> [MC91, DS90, NR88] </ref>. Some recent efforts have focused on reducing the number of events that must be traced [Net93, MC93]. <p> A compromise that has been achieved in some situations is to guarantee to report a non-empty subset of the actual races. While some races may still be missed, if a program (or execution) is reported to be race free, then the report is accurate. 5.1 Fork/Join Mellor-Crummey <ref> [MC91] </ref> describes a method for analyzing programs containing only properly nested fork/join parallelism. This approach requires O (V N ) space where V is the number of shared variables and N is the maximum nesting depth of the forks. Also each monitoring operation requires O (N ) time.
Reference: [MC93] <author> John Mellor-Crummey. </author> <title> Compile-time support for efficient data race detection in shared-memory parallel programs. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 129-139, </pages> <year> 1993. </year>
Reference-contexts: Some recent efforts have focused on reducing the number of events that must be traced <ref> [Net93, MC93] </ref>. More importantly, these are on-line algorithms that require only small amounts of storage and can thus be done "on-the-fly." Critical Sections with Lock/Unlock In programs that contain only fork/join synchronization, if there is a race between two events, then it must be a general race.
Reference: [McD89] <author> C. E. McDowell. </author> <title> A practical algorithm for static analysis of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <month> June </month> <year> 1989. </year>
Reference-contexts: are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores <ref> [McD89] </ref>, message passing [DKF93], rendezvous [Tay83, LC89] Table 3.1: What ordering relationships hold between statement (instances)? Theorem 2: Deciding if there exists a race between two conflicting statements in an arbitrary shared memory parallel program (containing explicit thread creation but no loops) is N P-hard. Proof: By reduction from 3SAT.
Reference: [Net93] <author> R. H. B. Netzer. </author> <title> Optimal tracing and replay for debugging shared-memory parallel programs. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <year> 1993. </year>
Reference-contexts: Some recent efforts have focused on reducing the number of events that must be traced <ref> [Net93, MC93] </ref>. More importantly, these are on-line algorithms that require only small amounts of storage and can thus be done "on-the-fly." Critical Sections with Lock/Unlock In programs that contain only fork/join synchronization, if there is a race between two events, then it must be a general race.
Reference: [NG92] <author> R. H. B. Netzer and S. Ghosh. </author> <title> Efficient race condition detection for shared-memory programs with Post/Wait synchronization. </title> <booktitle> In Proc. International Conf. on Parallel Processing, </booktitle> <year> 1992. </year>
Reference-contexts: Details of known results in our taxonomy of ordering event results 11 Exact Solution Approximations Branch free Mono tonic * all monotonic are in P [HM93], * fork/join is in P [MC91, DS90, NR88], * ordered critical sections are in P (section 4.4), * post/wait no clear is in P <ref> [NG92] </ref>, mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 3), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <p> For branch-free programs, this comparision can easily be done using O (L 2 ) time and O (L) space per event, where L is the maximum lock nesting depth. In practice the lock nesting depth is very small (i.e. 0 or 1) [DS91]. Post/Wait no Clear Netzer and Ghosh <ref> [NG92] </ref> have an algorithm that precisely determines the event orderings for a trace of a program that uses Post/Wait synchronization with no Clears. The algorithm constructs a DAG where the nodes are the events in the trace and the edges represent the guaranteed orderings between events.
Reference: [NM90] <author> R. H. B. Netzer and B. P. Miller. </author> <title> On the complexity of event ordering for shared-memory parallel program executions. </title> <booktitle> In Proc. International Conf. on Parallel Processing, </booktitle> <volume> volume II, </volume> <pages> pages 93-97, </pages> <year> 1990. </year>
Reference-contexts: are in P [HM93], * fork/join is in P [MC91, DS90, NR88], * ordered critical sections are in P (section 4.4), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 3), * semaphores are coN P-hard <ref> [NM90] </ref> semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are <p> Details of known results in our taxonomy of ordering event results 13 Semaphores Determining precisely the ordering relationships for branch-free programs containing semaphore synchronization is coN P-hard <ref> [NM90] </ref>. Therefore the problem is also coN P-hard when branches are permitted. 4.4 No Branches and Monotonically Synchronized We proved in a previous paper [HM93] that computing the precise ordering relationships between events in branch-free monotonically synchronized programs can be done in polynomial time. <p> However, if these operations are removed then the program will have many executions which end in deadlock. 16 5. Are there any races in this program? Semaphores Determining precisely the ordering relationships for even branch-free programs containing semaphore synchronization is coN P-hard <ref> [NM90] </ref>. The results in this area are therefore restricted to approximations. Helmbold et.al. [HMW91] and Netzer and Miller [NM91] have pursed two complimentary approaches.
Reference: [NM91] <author> R. H. B. Netzer and B. P. Miller. </author> <title> Improving the accuracy of data race detection. </title> <journal> SIGPLAN Notices (Proc. PPOPP), </journal> <volume> 26(7) </volume> <pages> 133-144, </pages> <year> 1991. </year>
Reference-contexts: We have borrowed the term "artifact race" from Netzer <ref> [NM91] </ref>, these races result from other races in the program. An artifact race can never be in the group of "first" races (as defined in [NM91]). <p> We have borrowed the term "artifact race" from Netzer <ref> [NM91] </ref>, these races result from other races in the program. An artifact race can never be in the group of "first" races (as defined in [NM91]). In particular, an artifact race has the property that the result of some "earlier" race affects the flow of control, preventing an event from being executed. This suggests an orthogonal attribute of races. <p> Are there any races in this program? Semaphores Determining precisely the ordering relationships for even branch-free programs containing semaphore synchronization is coN P-hard [NM90]. The results in this area are therefore restricted to approximations. Helmbold et.al. [HMW91] and Netzer and Miller <ref> [NM91] </ref> have pursed two complimentary approaches.
Reference: [NM92] <author> Robert H.B. Netzer and Barton P. Miller. </author> <title> What are race conditions? Some issues and formalizations. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <pages> pages 74-88, </pages> <month> March </month> <year> 1992. </year> <note> 20 References </note>
Reference-contexts: Events and Races 2 Events and Races Informally, an execution of a program contains a race if the result of some computational step depends upon the scheduling of the individual threads of execution 1 . Netzer and Miller <ref> [NM92] </ref> developed a formal model of races that distinguished races that served as a starting point for our development. Their model includes two orthoganol attributes of races, with attributes general and data on one axis and feasible, apparent and actual on the other axis.
Reference: [NR88] <author> I. Nudler and L. Rudolph. </author> <title> Tools for efficient development of efficient parallel programs. </title> <booktitle> In First Israeli Conference on Computer Systems Engineering, </booktitle> <year> 1988. </year>
Reference-contexts: However, the assumption that all combinations of branches are possible alleviates this problem. 4. Details of known results in our taxonomy of ordering event results 11 Exact Solution Approximations Branch free Mono tonic * all monotonic are in P [HM93], * fork/join is in P <ref> [MC91, DS90, NR88] </ref>, * ordered critical sections are in P (section 4.4), * post/wait no clear is in P [NG92], mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 3), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is <p> mono tonic * single semaphore is in P [LKN93], * post/wait/clear is N P-hard (Thm: 3), * semaphores are coN P-hard [NM90] semaphores [HMW93] No loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], <p> loops Mono tonic * fork/join is N P-hard (Thm: 2), * post/wait no clear is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 3.1: What ordering relationships hold between statement (instances)? Theorem 2: Deciding if there exists a race between two conflicting statements in <p> is CoN P-hard [CS88] even if all paths are executable, fork/join <ref> [MC91, DS90, NR88] </ref>, post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 3.1: What ordering relationships hold between statement (instances)? Theorem 2: Deciding if there exists a race between two conflicting statements in an arbitrary shared memory parallel program (containing explicit thread creation but no loops) is <p> As in the case of unrestricted programs, programmers must still uncover data races in their parallel programs. Therefore approaches that compute approximate answers to the problem have been studied and continue to be investigated <ref> [MC91, DS90, NR88, CKS90] </ref>. Post/Wait/Clear The CoN P-Hard result from [CS88] also applies here. In fact, with the addition of Clear, even detecting races in branch-free (i.e. no conditionals or loops) programs is N P-Hard (see Theorem 3). 4. <p> Fork/Join A number of methods have been developed in the context of on-the-fly race detection that could be used as polynomial time algorithms for determining event orders in branch free fork/join programs <ref> [MC91, DS90, NR88] </ref>. Some recent efforts have focused on reducing the number of events that must be traced [Net93, MC93]. <p> This approach requires O (V N ) space where V is the number of shared variables and N is the maximum nesting depth of the forks. Also each monitoring operation requires O (N ) time. The method is called Offset-Span labeling and is similar to English-Hebrew labeling <ref> [NR88] </ref>. In particular the label for each thread that is created during the execution of the program is computed based only on the labels of its immediate predecessors (the thread executing the fork or the threads resulting in a successful join).
Reference: [Ste93] <author> N. Sterling. </author> <title> WARLOCK a static data race analysis tool. </title> <booktitle> In Proc. Winter Usenix, </booktitle> <pages> pages 97-106, </pages> <year> 1993. </year>
Reference-contexts: A taxonomy of event ordering approaches are often benign when they are caused by commutative 4 updates to a shared variable. The goal of at least one tool <ref> [Ste93] </ref> is to ignore the unordered races and report only concurrent and/or general races. Finally we note that previous work in race detection has distinguished between feasible and infeasible races. This is really a characteristic of the race detection system which results from the need for approximate solutions. <p> all paths are executable, fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections <ref> [Ste93] </ref>, semaphores [McD89], message passing [DKF93], rendezvous [Tay83, LC89] Table 3.1: What ordering relationships hold between statement (instances)? Theorem 2: Deciding if there exists a race between two conflicting statements in an arbitrary shared memory parallel program (containing explicit thread creation but no loops) is N P-hard.
Reference: [Tay83] <author> R. N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent programs. </title> <journal> CACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Nevertheless, programmers must still uncover data races in their parallel programs. Therefore approaches that compute approximate answers to the problem have been studied and continue to be investigated <ref> [Tay83, LC89, HM91] </ref>. 4.2 No Loops and Monotonically Synchronized Excluding arbitrary loops is necessary to avoid termination problems and undecidability. Loops executing a fixed number of times can be unrolled. <p> NR88], post/wait no clear [CKS90] Non mono tonic * post/wait/clear is N P-hard (Thm: 3 or [CS88]), * semaphores are N P-hard fork/join [MC91, DS90, NR88], post/wait no clear [CKS90] Unre stricted any Undecidable (Thm: 1) fork/join [MC91, DS90, NR88], ordered critical sections [Ste93], semaphores [McD89], message passing [DKF93], rendezvous <ref> [Tay83, LC89] </ref> Table 3.1: What ordering relationships hold between statement (instances)? Theorem 2: Deciding if there exists a race between two conflicting statements in an arbitrary shared memory parallel program (containing explicit thread creation but no loops) is N P-hard. Proof: By reduction from 3SAT.
References-found: 23

