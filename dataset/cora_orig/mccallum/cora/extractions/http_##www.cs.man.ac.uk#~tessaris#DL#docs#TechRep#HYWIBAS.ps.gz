URL: http://www.cs.man.ac.uk/~tessaris/DL/docs/TechRep/HYWIBAS.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~tessaris/DL/papers.html
Root-URL: http://www.cs.man.ac.uk
Title: "Hybrid Knowledge Base System"  
Author: U. Reimer, R. Marti, M. Norrie, H.-J. Schek 
Abstract: Final Report of the SPP Project 1 
Abstract-found: 1
Intro-found: 1
Reference: [Blu96] <author> Urs Blum. </author> <title> Implementation und Evaluation verschiedener Heuristiken zur Al-lokation von Tabellen auf verschiedenen Disks bei der Abbildung von COCOON Typen und Klassen. </title> <type> Diploma thesis, </type> <institution> ETH Zurich, </institution> <month> March </month> <year> 1996. </year>
Reference-contexts: The simplest method would be a round robin allocation of the tables, more sophisticated methods would take the anticipated size of the relations and their semantical relationship into account to achieve some load balancing. Our current implementation supports only disk striping, however current work investigates placement heuristics <ref> [Blu96] </ref>. 4.2 Mapping of Operations The operations over COCOON databases are expressed in the language COOL which is founded on a set-oriented, generic, orthogonal and closed algebra formally defined in [SLR + 94].
Reference: [BM95] <author> Urs Badertscher, Robert Marti. </author> <title> Integrating Terminological and Deductive Reasoning. </title> <institution> Berichte des Instituts fur Informatik Nr.229, Dept. Informatik, ETH Zurich, </institution> <year> 1995. </year>
Reference-contexts: This mapping is described both in [BMR94] and, in more detail, in <ref> [BM95] </ref>. Using the predefined predicates, all information which is stored in the terminological component can be accessed by the deduction rules and by the semantic integrity constraints of the logical (deductive) component. As shown in [BMR94] and [BM95], the mapping even allows the representation of the terminological inference rules employed by <p> This mapping is described both in [BMR94] and, in more detail, in <ref> [BM95] </ref>. Using the predefined predicates, all information which is stored in the terminological component can be accessed by the deduction rules and by the semantic integrity constraints of the logical (deductive) component. As shown in [BMR94] and [BM95], the mapping even allows the representation of the terminological inference rules employed by the terminological component entirely within logic. <p> The set of all rules, referred to in the last point, includes the rules which implement terminological inferences, i.e., classification and subsumption. These rules could be obtained by mapping the terminological inference algorithms to the above described logic representation (see <ref> [BM95] </ref> for details). However, in the interest of efficiency, a more pragmatic solution for combining terminological and deductive inferences has been implemented in the HYWIBAS system. After completion of a terminological inference the deductive component is called.
Reference: [BMR94] <author> Urs Badertscher, Robert Marti, Ulrich Reimer. </author> <title> Integrating Terminological and Deductive Reasoning. </title> <booktitle> In Proceedings of the Workshop on Logic Programming, </booktitle> <address> Zurich, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: This mapping is described both in <ref> [BMR94] </ref> and, in more detail, in [BM95]. Using the predefined predicates, all information which is stored in the terminological component can be accessed by the deduction rules and by the semantic integrity constraints of the logical (deductive) component. As shown in [BMR94] and [BM95], the mapping even allows the representation of <p> This mapping is described both in <ref> [BMR94] </ref> and, in more detail, in [BM95]. Using the predefined predicates, all information which is stored in the terminological component can be accessed by the deduction rules and by the semantic integrity constraints of the logical (deductive) component. As shown in [BMR94] and [BM95], the mapping even allows the representation of the terminological inference rules employed by the terminological component entirely within logic.
Reference: [GM95] <author> Ashish Gupta and Inderpal Singh Mumick. </author> <title> Maintenance of Materialized Views: Problems, Techniques, </title> <journal> and Applications. Bulletin of the Technical Committee on Data Engineering, Vol.18, No.2, </journal> <volume> pp.3-18, </volume> <year> 1995. </year>
Reference-contexts: This is achieved by extensive replication of data, together with the maintenance of materialised views, such that COCOON objects are represented in certain partially composed forms. We describe our mapping of COCOON objects to relation structures in Section 4.1. [SC89] discusses the benefits of replication, and <ref> [Han87, GM95] </ref> the benefits of view materialisation, when the number of retrieves is significantly greater than the number of updates. The reduction in retrieval costs resulting from our mapping, is achieved at the expense of increased complexity of update operations due to the data replication and view materialisa-tion. <p> This is done by the dependency analyser which generates a dependency graph of the L1 transactions (see Fig.4). All independent L1 transactions will of course be executed in parallel. There are different approaches to implement the reclassification <ref> [GM95] </ref>. Depending on the amount of affected tuples, the affected objects could either be reclassified by explicit insert, update and delete statements, or the whole table can be rematerialised.
Reference: [Han87] <author> Eric N. Hanson. </author> <title> A Performance Analysis of View Materialisation Strategies. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <address> pp.440-453. </address> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: This is achieved by extensive replication of data, together with the maintenance of materialised views, such that COCOON objects are represented in certain partially composed forms. We describe our mapping of COCOON objects to relation structures in Section 4.1. [SC89] discusses the benefits of replication, and <ref> [Han87, GM95] </ref> the benefits of view materialisation, when the number of retrieves is significantly greater than the number of updates. The reduction in retrieval costs resulting from our mapping, is achieved at the expense of increased complexity of update operations due to the data replication and view materialisa-tion.
Reference: [Has95] <author> Christof Hasse. </author> <title> Inter- und Intratransaktionsparallelitat in Datenbanksystemen: Entwurf, Implementierung und Evaluation eines Datenbanksystems mit Inter-und Intratransaktionsparallelitat. Diss ETH Nr. </title> <type> 11045, </type> <institution> ETH Zurich, </institution> <year> 1995. </year>
Reference-contexts: These results show that there is a benefit in parallelising update statements using multilevel transactions. Especially, if many objects have to be reclassified in a large classification structure, there is a significant benefit in the parallelisation. As has been shown in <ref> [Has95] </ref> the faster execution of the update statements also leads to a reduced conflict potential with concurrent retrieves due to shorter locks.
Reference: [Hau95] <author> Sandra E. Hauser. </author> <title> Implementierung von COOL Anderungsoperationen auf einem Parallelrechner mittels Mehrschichtentransaktionen. </title> <type> Diploma thesis, </type> <institution> ETH Zurich, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: If the function affected by the update does not influence the classification of the objects, it would be sufficient to only update the changed attributes in the class tables. In our current implementation, we always rematerialise the whole table. <ref> [Hau95] </ref> gives a more detailed 13 BOT (1) T1.2 T1.4 EOT (1) description of the implementation of the COOL update operations, while [Stu96] imple ments the update sequence iterator apply to all [LS93]. 4.3 Logging and Recovery Strategy If a COOL transaction has to be aborted, not yet committed subtransactions will
Reference: [Kup95] <author> Stefan Kupferschmid. </author> <title> Reparatur von verletzten Integritatsbedingungen in de-duktiven Datenbanken. </title> <type> Diploma thesis, </type> <institution> ETH Zurich, </institution> <year> 1995. </year>
Reference-contexts: Also, one must pay attention that corrective actions to repair one constraint do not violate other constraints. 5 The details of various correction methods proposed in the literature as well as a synthesis of these ideas together with a stand-alone Prolog implementation are reported in <ref> [Kup95] </ref>. A more specialised version of this work has been incorporated into HYWIBAS. Basically, the syntax of "auto correcting" integrity constraints is restricted in such a way that, together with a suitable heuristic, at most one candidate correction action is generated for such a constraint.
Reference: [LS93] <author> Christian Laasch and Marc H. Scholl. </author> <title> Deterministic Semantics of Set-oriented Update Sequences. </title> <booktitle> In Proceedings of the IEEE Conference on Data Engineering, </booktitle> <pages> pages 4-13, </pages> <address> Vienna, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: In our current implementation, we always rematerialise the whole table. [Hau95] gives a more detailed 13 BOT (1) T1.2 T1.4 EOT (1) description of the implementation of the COOL update operations, while [Stu96] imple ments the update sequence iterator apply to all <ref> [LS93] </ref>. 4.3 Logging and Recovery Strategy If a COOL transaction has to be aborted, not yet committed subtransactions will be aborted by the RDBMS. However, since subtransactions are committed on the RDBMS before the COOL transaction is committed, it is necessary to compensate the committed subtrans-actions.
Reference: [RJSN96] <author> Michael Rys, Hans Jorg Schek, and Moira C. Norrie. </author> <title> Intra-Transaction Parallelism in the Mapping of an Object Model to a Relational Multi-Processor System in the Context of Decision Support Systems. </title> <note> in preparation, 1996. 23 </note>
Reference-contexts: Since most of these SQL level updates can be performed independently from each other, we would like to speed up the update operation by parallelising the SQL updates. By applying multi-level transaction management [WS92], we receive a formal foundation to correctly and efficiently parallelise these update operations (see <ref> [RJSN96] </ref> for a more detailed description). 12 insert into C1 select * from T1,.... truncate table C1; truncate table C2; insert into C2 select * from T1,.... truncate table C3; insert into C3 select * from T2,.... update [...](...) update T1 set ... where ... set ... where ... update T2
Reference: [RLNR95] <author> Ulrich Reimer, Peter Lippuner, Moira Norrie, Michael Rys. </author> <title> Terminological Reasoning by Query Evaluation: A Formal Mapping of a Terminological Logic to an Object Data Model. </title> <editor> In: G. Ellis, R.A. Levinson, A. Fall, V. Dahl (eds): </editor> <booktitle> Proc. Int. KRUSE Symposium: Knowledge Retrieval, Use, and Storage for Efficiency. </booktitle> <month> August 11-13, </month> <year> 1995, </year> <institution> University of California at Santa Cruz, USA, pp.49-53. </institution> <note> (Extended version as Bericht 12, Swiss Life, Informatik-Forschungsgruppe). </note>
Reference-contexts: Only in a second step do we introduce an object class which refers to that object type and covers the remaining features of the concept description. The resulting mapping is described in detail in <ref> [RLNR95] </ref>. 3.2 Mapping Operations and Terminological Inferences Mapping FRM constructs to COCOON constructs was a necessary prerequisite to achieve our ultimate goal of implementing FRM on top of COCOON. <p> This inference can be completely deferred to COCOON which provides a corresponding inference for associating objects with object classes (according to the class type and the class predicate). A detailed discussion of mapping terminological inferences to COCOON queries can be found in <ref> [RLNR95] </ref>. 4 Implementing COCOON The COCOON object database system is implemented on top of a commercial parallel relational database system.
Reference: [RM95] <author> Ulrich Reimer, Andreas Margelisch. </author> <title> A Hybrid Knowledge Representation Approach to Reusability of Legal Knowledge Bases. </title> <booktitle> In: Proceedings Fifth International Conference on Artificial Intelligence and Law, 1995. </booktitle> <address> New York: </address> <publisher> ACM Press, </publisher> <year> 1995, </year> <month> pp.246-255. </month>
Reference-contexts: Again the logic component of HYWIBAS is chosen. The legal knowledge is represented by deduction rules (to describe regulations) and integrity constraints (to characterise invalid situations). A detailed description of EULE2 can be found in <ref> [RM95] </ref>. 7 Conclusions and Outlook The HYWIBAS project had a clear interdisciplinary character, as it brought together three research groups of similar interests but quite different background, covering the areas of knowledge-based systems, deductive databases, and object-oriented databases.
Reference: [Sch94] <institution> Thomas Schumacher. Integritat fur ein hybrides Wissensbanksystem. Diploma thesis, ETH Zurich, </institution> <year> 1994. </year>
Reference-contexts: system, the easiest way out would be to always simply roll back the entire transaction, i.e., to undo all the effects of the changes 3 To be more precise, our implementation attempts to simplify the formula :F based on the actual changes made to the knowledge base as described in <ref> [Sch94] </ref>. 4 made within a transaction. However, from the point of view of a user (or an application programmer), it should be possible to specify other, application-specific reactions to a constraint violation.
Reference: [SC89] <author> Eugene J. Shekita and Michael J. Carey. </author> <title> Performance Enhancement Through Replication in an Object-Oriented DBMS. </title> <editor> In James Clifford, Bruce Lindsay, and David Maier, editors, </editor> <booktitle> Proceedings of the ACM SIGMOD International Conference on the Management of Data, Vol.18, No.2 of ACM SIGMOD Records, </booktitle> <address> pp.325-336, </address> <year> 1989. </year>
Reference-contexts: This is achieved by extensive replication of data, together with the maintenance of materialised views, such that COCOON objects are represented in certain partially composed forms. We describe our mapping of COCOON objects to relation structures in Section 4.1. <ref> [SC89] </ref> discusses the benefits of replication, and [Han87, GM95] the benefits of view materialisation, when the number of retrieves is significantly greater than the number of updates.
Reference: [SLR + 94] <author> Marc H. Scholl, Christian Laasch, Christian Rich, Hans-Jorg Schek, and Markus Tresch. </author> <title> The COCOON Object Model. </title> <type> Departemental Report 211, </type> <institution> ETH Zurich, Departement Informatik, ETH Zentrum CH-8092 Zurich, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Thus, we have implemented a parallel object database management system based on the COCOON object data model and its associated object algebra COOL <ref> [SLR + 94] </ref>. <p> Our current implementation supports only disk striping, however current work investigates placement heuristics [Blu96]. 4.2 Mapping of Operations The operations over COCOON databases are expressed in the language COOL which is founded on a set-oriented, generic, orthogonal and closed algebra formally defined in <ref> [SLR + 94] </ref>. COOL query operations, such as select and project, work on sets of objects (i.e. classes) and have object-preserving semantics, such that their results are subsets of the existing objects in the database.
Reference: [Stu96] <author> Lars Stucki. </author> <title> Parallele Implementation des COCOON Update-Iterators apply to all mittels Mehschichtentransaktionsverwaltung. </title> <type> Diploma thesis, </type> <institution> ETH Zurich, </institution> <month> March </month> <year> 1996. </year>
Reference-contexts: In our current implementation, we always rematerialise the whole table. [Hau95] gives a more detailed 13 BOT (1) T1.2 T1.4 EOT (1) description of the implementation of the COOL update operations, while <ref> [Stu96] </ref> imple ments the update sequence iterator apply to all [LS93]. 4.3 Logging and Recovery Strategy If a COOL transaction has to be aborted, not yet committed subtransactions will be aborted by the RDBMS.
Reference: [Tre94] <author> Markus Tresch. </author> <title> Dynamische Evolution in Objekt-Datenbanken. </title> <type> Ph.d. thesis, </type> <institution> University of Ulm, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Note that all classes can be considered as materialised views, since they could also be mapped as views of their closest some class (es) (i.e. their base class (es)). A meta-schema similar to the one defined in <ref> [Tre94] </ref> contains the necessary meta information such as superclass relationships or a class' member type. In addition, the meta-schema contains for each class all the information which is necessary to materialise its extent. Another important point to consider is the placement of the objects on the disks.

References-found: 17

