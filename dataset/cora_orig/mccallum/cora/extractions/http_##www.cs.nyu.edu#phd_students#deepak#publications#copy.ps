URL: http://www.cs.nyu.edu/phd_students/deepak/publications/copy.ps
Refering-URL: http://www.cs.nyu.edu/phd_students/deepak/index.html
Root-URL: http://www.cs.nyu.edu
Email: fdeepak, paigeg@cs.nyu.edu  
Phone: Fax 212-995-4124, Tel 212 998 3156  
Title: A New Solution to the Hidden Copy Problem  
Author: Deepak Goyal and Robert Paige 
Keyword: Copy Optimization, Big Step Operational Semantics, Abstract Interpretation, Must Alias Analysis  
Address: 251 Mercer Street, NY, NY 10012  
Affiliation: New York University,  
Abstract: We consider the well-known problem of avoiding unnecessary costly copying that arises in languages with copy/value semantics and large aggregate structures such as arrays, sets, or files. The origins of many recent studies focusing on avoiding copies of flat arrays in functional languages may be traced back to SETL copy optimization [Schwartz 75]. The problem is hard, and progress is slow, but a successful solution is crucial to achieving a pointer-free style of programming envisioned by [Hoare 75]. We give a new solution to copy optimization that uses dynamic reference counts and lazy copying to implement updates efficiently in an imperative language with arbitrarily nested finite sets and maps (which can easily model arrays, records and other aggregate datatypes). Big step operational semantics and abstract interpretations are used to prove the soundness of the analysis and the correctness of the transformation. An efficient algorithm to implement the analysis is presented. The approach is supported by realistic empirical evidence. Our solution anticipates the introduction of arbitrarily nested polymorphic sets and maps into JAVA. It may also provide a new efficient strategy for implementing object cloning in Java and object assigment in C++. We illustrate how our methods might improve the recent approach of [Wand and Clinger 98] to avoid copies of flat arrays in a language of first-order recursion equations.
Abstract-found: 1
Intro-found: 1
Reference: 1. <editor> ADA UK News, </editor> <volume> Vol. 6, No. 1, </volume> <pages> pp. 14-15, </pages> <month> Jan </month> <year> 1985. </year>
Reference-contexts: Instead, SETL1 implemented a dynamic `sticky' bit that was initially unset, but was set the first time that a location was shared and subsequently never unset. This solution was completely unsatisfactory, as was demonstrated by the performance of the Ada/Ed compiler <ref> [1] </ref>. Interestingly, researchers in the functional language community have shown that the kind of may-alias analysis for value flow combined with live variable analysis similar to Schwartz's approach is tractable even in the interprocedural case when datatypes are limited to flat arrays [10, 29].
Reference: 2. <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: The placement of omega assignments is more subtle. We say that a variable v is live at a program point p if the set of live uses of v is non-empty at p <ref> [4, 2] </ref>. If a variable is not live at p, we say it is dead. In order for our transformation to be correct, we will insert omega assignments only to dead variables.
Reference: 3. <author> J. Cai and R. Paige. </author> <title> Towards increased productivity of algorithm implementation. </title> <booktitle> In Proc. ACM SIGSOFT, </booktitle> <pages> pages 71-78, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: If such a strategy is not implemented effectively, then hidden copies can potentially degrade program performance from O (f (n)) expected time to O (f (n) 2 ) actual time. Such a slowdown has been actually observed even in small-scale SETL programs <ref> [3] </ref>. Although the hidden copy problem arises in different languages and language paradigms, it is also crucial to the more general goal, expressed by Hoare [8], of programming without pointers. Without a reasonable solution to this problem, Hoare's ideal cannot be achieved in any practical way.
Reference: 4. <author> J. Cocke and J. Schwartz. </author> <booktitle> Programming Languages and Their Compilers. Lecture Notes. </booktitle> <institution> Courant Institute, </institution> <address> New York University, New York, </address> <year> 1969. </year>
Reference-contexts: The placement of omega assignments is more subtle. We say that a variable v is live at a program point p if the set of live uses of v is non-empty at p <ref> [4, 2] </ref>. If a variable is not live at p, we say it is dead. In order for our transformation to be correct, we will insert omega assignments only to dead variables.
Reference: 5. <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixed points. </title> <booktitle> In Proc. 4th ACM Symp. on Principles of Prog. Lang., </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: These three semantics are proved to be equivalent. 3. In Section 3 an abstract interpretation <ref> [5] </ref> is given to support the analysis at each program point of equivalence classes of variables that MUST share the same location.
Reference: 6. <author> A. Deutsch. </author> <title> A storeless model of aliasing and its abstractions using finite representations of right-regular equivalence relations. </title> <booktitle> In International Conference on Computer Languages, </booktitle> <pages> pages 2-13. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Our must-alias analysis is made more accurate by the use of a congruence condition on the alias relations, which is similar to the right regularity condition of Deutsch's may-alias analysis <ref> [6] </ref>. Our analysis is fine-grained enough to detect sharing of map components f (a). A safe approximation of this analysis is computed by an algorithm that runs in time O (N V 2 ), where N is the number of program points, and V is the number of variables. 4.
Reference: 7. <author> M. Draghicescu and S. Purushotham. </author> <title> A uniform treatment of order of evaluation and aggregate update. </title> <journal> Theoretical Computer Science, </journal> <volume> 118 </volume> <pages> 231-262, </pages> <year> 1993. </year>
Reference-contexts: We will describe a third strategy with the aim of facilitating more destructive (or in-place) updates than was possible before. Copy optimization in functional languages with array updates is an important problem of intense current interest <ref> [11, 10, 7, 29] </ref>. Little seems to be known, however, about Schwartz's extensive investigation of copy optimization for SETL in the 1970's [24].
Reference: 8. <author> C. A. R. Hoare. </author> <title> Data reliability. </title> <booktitle> In Proc. of the Intl. Conf. on Reliable Software, </booktitle> <pages> pages 528-533, </pages> <year> 1975. </year>
Reference-contexts: Such a slowdown has been actually observed even in small-scale SETL programs [3]. Although the hidden copy problem arises in different languages and language paradigms, it is also crucial to the more general goal, expressed by Hoare <ref> [8] </ref>, of programming without pointers. Without a reasonable solution to this problem, Hoare's ideal cannot be achieved in any practical way. Currently without such a solution, we are forced to choose between two pragmatic, but unsatisfactory, compromises.
Reference: 9. <author> J. Hopcroft. </author> <title> An n log n algorithm for minimizing states in a finite automaton. </title> <editor> In Z. Kohavi and A. Paz, editors, </editor> <booktitle> Theory of Machines and Computations, </booktitle> <pages> pages 189-196. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1971. </year> <booktitle> Proc. Intl. Symp. on Theory of Machines and Computation. </booktitle>
Reference-contexts: The analysis and transformation are proved correct using formal semantics and abstract interpretations. A new low polynomial time algorithm is given to carry out the analysis. It would be interesting to extend this work to the interprocedural case. We also want to explore partition refinement strategies found in <ref> [9] </ref> and [14] to improve the algorithm. It would be interesting to see how further optimization could cut down or eliminate dynamic reference counts.
Reference: 10. <author> P. Hudak. </author> <title> A semantic model of reference counting and its abstraction. </title> <booktitle> In Proc. 1986 ACM Symp. on Lisp and Func. Prog., </booktitle> <pages> pages 351-363. </pages> <publisher> ACM, </publisher> <year> 1986. </year>
Reference-contexts: We will describe a third strategy with the aim of facilitating more destructive (or in-place) updates than was possible before. Copy optimization in functional languages with array updates is an important problem of intense current interest <ref> [11, 10, 7, 29] </ref>. Little seems to be known, however, about Schwartz's extensive investigation of copy optimization for SETL in the 1970's [24]. <p> Interestingly, researchers in the functional language community have shown that the kind of may-alias analysis for value flow combined with live variable analysis similar to Schwartz's approach is tractable even in the interprocedural case when datatypes are limited to flat arrays <ref> [10, 29] </ref>.
Reference: 11. <author> P. Hudak and A. Bloss. </author> <title> Avoiding copying in functional and logic programming languages. </title> <booktitle> In Proc. 12th Annual ACM Symp. on Principles of Prog. Lang., </booktitle> <pages> pages 300-314. </pages> <publisher> ACM, </publisher> <year> 1985. </year>
Reference-contexts: We will describe a third strategy with the aim of facilitating more destructive (or in-place) updates than was possible before. Copy optimization in functional languages with array updates is an important problem of intense current interest <ref> [11, 10, 7, 29] </ref>. Little seems to be known, however, about Schwartz's extensive investigation of copy optimization for SETL in the 1970's [24].
Reference: 12. <author> G. Kahn. </author> <title> Natural semantics. </title> <booktitle> In Proc. </booktitle> <address> STACS'87. </address> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <pages> 247. </pages>
Reference-contexts: These datatypes can conveniently model a wide range of aggregate datatypes including multilevel arrays and records. 2. In Section 2 we give big step operational semantics <ref> [12, 16] </ref> for (1) copy/value semantics, (2) a naive lazy copy strategy, and (3) an optimized strategy in which destructive updates are performed on data whose location is unshared. These three semantics are proved to be equivalent. 3.
Reference: 13. <author> J. B. Kam and J. D. Ullman. </author> <title> Monotone data flow analysis frameworks. </title> <journal> Acta Informatica, </journal> <volume> 7 </volume> <pages> 305-317, </pages> <year> 1977. </year>
Reference-contexts: We use st (j; i) to denote the statement between program point j and its successor i. We use the results from <ref> [13] </ref> to claim that the meet-over-all-paths solution is safely approximated by the greatest fixed point solution of the following equation: F (P 0 ; : : : ; P n ) = (g 0 (P 0 ; : : : ; P n ); . . . (32) where g 0
Reference: 14. <author> J. Keller and R. Paige. </author> <title> Program derivation with verified transformations a case study. </title> <journal> CPAM, </journal> <pages> 48(9-10), </pages> <year> 1995. </year>
Reference-contexts: The next subsection states some of the properties of partitions that will be useful in our analysis. A much more detailed description of these and many other properties can be found in <ref> [14] </ref>. v 1 ; v 2 ; v 3 v 4 ; v 5 ; v 6 u v 1 ; v 2 v 3 ; v 4 ; v 5 v 6 Fig. 7. <p> Given a partition P , we can compute f fl st (P ) for any simple assignment in O (V ) time. (1) can be proven directly from <ref> [14] </ref>. (2) has a direct implementation using simple data structuring and the techniques in [14]. Proposition 4. Each iteration of Kildall's algorithm can be implemented in O (N fi V ) time. <p> Given a partition P , we can compute f fl st (P ) for any simple assignment in O (V ) time. (1) can be proven directly from <ref> [14] </ref>. (2) has a direct implementation using simple data structuring and the techniques in [14]. Proposition 4. Each iteration of Kildall's algorithm can be implemented in O (N fi V ) time. This follows directly from Proposition 3 assuming that the control flow graph has been processed so that each node has at most 2 predecessors and at most 2 successors [19]. Proposition 5. <p> A new low polynomial time algorithm is given to carry out the analysis. It would be interesting to extend this work to the interprocedural case. We also want to explore partition refinement strategies found in [9] and <ref> [14] </ref> to improve the algorithm. It would be interesting to see how further optimization could cut down or eliminate dynamic reference counts.
Reference: 15. <author> G. A. Kildall. </author> <title> A unified approach to global program optimization. </title> <booktitle> In ACM Symp. on Principles of Prog. Lang., </booktitle> <pages> pages 194-206, </pages> <year> 1973. </year>
Reference-contexts: init ; fl init i) and g i (P 0 ; : : : ; P n ) = u j2pred (i) f fl st (j;i) (P j ); 8i = 1; : : : ; n: The above greatest fixed point can be computed by Kildall's iterative algo rithm <ref> [15] </ref> (shown in Figure 10). Let V denote jVarsj and let N denote the number of nodes in the control flow graph. Proposition 3. 1. Given partitions P 1 and P 2 , we can compute P 1 u P 2 in O (V ) time. 2.
Reference: 16. <author> H. R. Nielson and F. Nielson. </author> <title> Semantics with Applications, A formal introduction. </title> <publisher> Wiley, </publisher> <year> 1992. </year>
Reference-contexts: These datatypes can conveniently model a wide range of aggregate datatypes including multilevel arrays and records. 2. In Section 2 we give big step operational semantics <ref> [12, 16] </ref> for (1) copy/value semantics, (2) a naive lazy copy strategy, and (3) an optimized strategy in which destructive updates are performed on data whose location is unshared. These three semantics are proved to be equivalent. 3.
Reference: 17. <author> R. Paige. </author> <title> Viewing a program transformation system at work. </title> <editor> In M. Hermenegildo and J. Penjam, editors, </editor> <booktitle> Programming Language Implementation and Logic, volume 844 of LNCS, </booktitle> <pages> pages 5-24. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> Sep. </month> <year> 1994. </year> <booktitle> Proc. Joint 6th Intl. Conf. on Prog. Lang. Impl. and Logic Prog. (PLILP) and 4th Intl. Conf. on Algebraic and Logic Prog. </booktitle> <publisher> (ALP). </publisher>
Reference-contexts: Toto Paxia modified the SETL2 back-end by adding an o2 option that inserts omega assignments for dead variables for some simple cases such as the indexed assignment f (a)(b) := d. We tested the results of these optimizations on APTS <ref> [17] </ref>, a 15000 line SETL2 program. APTS had originally been written in such a way as to solve a part of the hidden copy problem at source level.
Reference: 18. <author> R. Paige and Z. Yang. </author> <title> High level reading and data structure compilation. </title> <booktitle> In Proc. 24th ACM SIGPLAN-SIGACT Symp. on Principles of Prog. Lang., </booktitle> <pages> pages 456-469, </pages> <address> Paris, France, </address> <month> 15-17 Jan. </month> <year> 1997. </year>
Reference-contexts: The elements of V fl represent canonical forms which are not described here but which can be obtained easily by lexicographic sorting or multiset discrimination (see <ref> [18] </ref>). External input constants and program constants are mapped to values in (V fl ) ? by an external procedure .
Reference: 19. <author> B. K. Rosen, M. Wegman, and K. Zadeck. </author> <title> Global value numbers and redundant computations. </title> <booktitle> In ACM Symp. on Principles of Prog. Lang., </booktitle> <pages> pages 12-27, </pages> <year> 1988. </year>
Reference-contexts: Proposition 4. Each iteration of Kildall's algorithm can be implemented in O (N fi V ) time. This follows directly from Proposition 3 assuming that the control flow graph has been processed so that each node has at most 2 predecessors and at most 2 successors <ref> [19] </ref>. Proposition 5. Kildall's algorithm converges in at most N fiV iterations.
Reference: 20. <author> M. Sagiv, T. Reps, and R. Wilhelm. </author> <title> Solving shape analysis problems in languages with destructive updating. </title> <journal> ACM TOPLAS, </journal> <volume> 20(1) </volume> <pages> 1-50, </pages> <month> January </month> <year> 1998. </year>
Reference-contexts: The disjointness of A and B ensures the single-valuedness of the resulting union. 3.2 Abstract Interpretation This section describes an abstract interpretation approach based closely along the lines of <ref> [20] </ref>, for computing a sound must-alias relation at each program point. As described in the previous subsection, the alias relation is a partition of the set of variables in the program.
Reference: 21. <author> D. A. Schmidt. </author> <title> Data flow analysis is model checking of abstract interpretations. </title> <booktitle> In 25th ACM SIGPLAN-SIGACT Symp. on Principles of Prog. </booktitle> <address> Lang., </address> <year> 1998. </year>
Reference-contexts: Furthermore, each time a program point is removed from the worklist, the processing takes O (V ) time. Hence the time complexity is O (N fi V 2 ). 4 Copy Optimization Transformation The problem of live variable analysis is well understood (see <ref> [21] </ref>, for example). We have a live variable analysis that takes map variables such as f (v) into account. This analysis is also proven correct using the framework of abstract interpretation. The abstract semantics and the proof of correctness are straightforward and are omitted.
Reference: 22. <author> J. Schwartz. </author> <title> On Programming: An Interim Report on the SETL Project, Installments I and II. </title> <address> New York University, New York, </address> <year> 1974. </year>
Reference-contexts: Little seems to be known, however, about Schwartz's extensive investigation of copy optimization for SETL in the 1970's [24]. Since we believe that this early work may be relevant to current research in the area, it is worth summarizing. 1.1 Motivation SETL <ref> [22, 25] </ref> is an imperative language with copy/value semantics for assignment and parameter passing, dynamic typing, and built-in finite sets, maps, and tuples of arbitrary depth of nesting.
Reference: 23. <author> J. Schwartz. </author> <title> Automatic data structure choice in a language of very high level. </title> <journal> CACM, </journal> <volume> 18(12) </volume> <pages> 722-728, </pages> <month> Dec. </month> <year> 1975. </year>
Reference-contexts: Another approach, taken by Java, is to assume reference semantics for aggregate objects. 1.2 An unrealized analytic approach Schwartz developed an interesting but complicated intra-procedural value flow analysis <ref> [23, 24] </ref> for SETL1 [25] in order to detect when destructive updates could be performed. His analysis determined an overestimate of the set of variables that at some level, no matter how deeply embedded, may share the same location.
Reference: 24. <author> J. Schwartz. </author> <title> Optimization of very high level languages, parts I, II. </title> <editor> J. </editor> <booktitle> of Computer Languages, </booktitle> <address> 1(2-3):161-218, </address> <year> 1975. </year>
Reference-contexts: Copy optimization in functional languages with array updates is an important problem of intense current interest [11, 10, 7, 29]. Little seems to be known, however, about Schwartz's extensive investigation of copy optimization for SETL in the 1970's <ref> [24] </ref>. <p> Another approach, taken by Java, is to assume reference semantics for aggregate objects. 1.2 An unrealized analytic approach Schwartz developed an interesting but complicated intra-procedural value flow analysis <ref> [23, 24] </ref> for SETL1 [25] in order to detect when destructive updates could be performed. His analysis determined an overestimate of the set of variables that at some level, no matter how deeply embedded, may share the same location. <p> Consequently, all updates on B will result in the creation of a new copy, although, if the calls to f are from function h, then the destructive updates on the arrays would still be legal. This problem is reminiscent of the problems that made Schwartz's value flow analysis <ref> [24] </ref> ineffective for solving the copy optimization problem in Setl. fun Sum (A) = : : : ==sum the elements of array A fun f (B; i; j) = Sum (update (B; i; j)) fun g (A; i 1 ; i 2 ) = f (A; i 1 ; 0) +
Reference: 25. <author> J. Schwartz, R. Dewar, E. Dubinsky, and E. Schonberg. </author> <title> Programming with Sets: An Introduction to SETL. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: Little seems to be known, however, about Schwartz's extensive investigation of copy optimization for SETL in the 1970's [24]. Since we believe that this early work may be relevant to current research in the area, it is worth summarizing. 1.1 Motivation SETL <ref> [22, 25] </ref> is an imperative language with copy/value semantics for assignment and parameter passing, dynamic typing, and built-in finite sets, maps, and tuples of arbitrary depth of nesting. <p> Another approach, taken by Java, is to assume reference semantics for aggregate objects. 1.2 An unrealized analytic approach Schwartz developed an interesting but complicated intra-procedural value flow analysis [23, 24] for SETL1 <ref> [25] </ref> in order to detect when destructive updates could be performed. His analysis determined an overestimate of the set of variables that at some level, no matter how deeply embedded, may share the same location.
Reference: 26. <author> M. Sharir. </author> <title> A few cautionary notes on the convergence of iterative data-flow analysis algorithms. Setl Newsletter 208, </title> <address> New York University, </address> <month> April </month> <year> 1978. </year>
Reference-contexts: A destructive update to a variable v could be performed if no other variable that might share the location storing the value of v was live. His analysis aimed to be so fine-grained as to detect when destructive updates could be performed on components of aggregate structures. Sharir <ref> [26] </ref> showed that value flow analysis did not fit any of the k-bounded monotone dataflow frameworks [28], and conjectured that extensions to interpro-cedural analysis would be too approximate to be useful. Based on these negative observations, Schwartz's approach was never implemented.
Reference: 27. <author> K. Snyder. </author> <title> The SETL2 programming language. </title> <type> Technical Report 490, </type> <institution> Courant Insititute, </institution> <address> New York University, </address> <year> 1990. </year>
Reference-contexts: However, it remains to be seen whether multi-level arrays and other aggregate data structures will confound this approach as they did for SETL. 1.3 A dynamic approach that didn't work In SETL2 <ref> [27] </ref> dynamic multi-level reference counts for each location storing an aggregate value (tuple, set, or map) are maintained. Highly restricted circularity of pointers ensures that when a location has a reference count greater than 1, then that location is shared, and cannot be updated unless it is first copied.
Reference: 28. <author> R. E. Tarjan. </author> <title> A unified approach to path problems. </title> <journal> JACM, </journal> <volume> 28(3) </volume> <pages> 577-593, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: His analysis aimed to be so fine-grained as to detect when destructive updates could be performed on components of aggregate structures. Sharir [26] showed that value flow analysis did not fit any of the k-bounded monotone dataflow frameworks <ref> [28] </ref>, and conjectured that extensions to interpro-cedural analysis would be too approximate to be useful. Based on these negative observations, Schwartz's approach was never implemented.
Reference: 29. <author> M. Wand and W. D. Clinger. </author> <title> Set constraints for destructive array update optimization. </title> <booktitle> In Proc. IEEE Conf. on Computer Languages. IEEE, </booktitle> <month> May </month> <year> 1998. </year>
Reference-contexts: We will describe a third strategy with the aim of facilitating more destructive (or in-place) updates than was possible before. Copy optimization in functional languages with array updates is an important problem of intense current interest <ref> [11, 10, 7, 29] </ref>. Little seems to be known, however, about Schwartz's extensive investigation of copy optimization for SETL in the 1970's [24]. <p> Interestingly, researchers in the functional language community have shown that the kind of may-alias analysis for value flow combined with live variable analysis similar to Schwartz's approach is tractable even in the interprocedural case when datatypes are limited to flat arrays <ref> [10, 29] </ref>. <p> We are investigating improvements to this strategy in order to facilitate elimination of more copies. 5 Applications Destructive array update optimization is critical for writing scientific codes in functional languages. Recently, Wand and Clinger <ref> [29] </ref> propose a solution for a call-by-value functional language based on interprocedural flow analysis for aliasing and liveness.
Reference: 30. <author> G. Winskell. </author> <title> The Formal Semantics of Programming Languages. </title> <booktitle> Foundations of Computing. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Note that (om) = ?. The initial environment is given by = x:?. The semantics of if-then-else, while loop, and statement sequence are straightforward (see <ref> [30] </ref>), and are omitted. In rules (1)-(11), judgment h; ei e ! u stands for the evaluation of L expression e in environment to obtain value u 2 (V fl ) ? . <p> The proof by rule induction (see for example <ref> [30] </ref>) is omitted here for the sake of brevity.
References-found: 30

