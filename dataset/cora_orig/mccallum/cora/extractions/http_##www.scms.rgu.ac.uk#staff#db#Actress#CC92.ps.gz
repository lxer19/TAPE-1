URL: http://www.scms.rgu.ac.uk/staff/db/Actress/CC92.ps.gz
Refering-URL: http://www.scms.rgu.ac.uk/staff/db/
Root-URL: 
Title: ACTRESS: an Action Semantics Directed Compiler Generator  
Author: Deryck F. Brown Hermano Moura David A. Watt 
Abstract: We report progress on the development of Actress, a compiler generator based on action semantics. It consists of a number of modules, written in SML, that can be composed to construct either an action notation compiler or a simple compiler generator. We also outline current and future developments that will improve the quality of the generated compilers.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. F. Brown. </author> <title> Sort inference in action semantics. </title> <type> Research report, </type> <institution> Department of Computing Science, University of Glasgow, </institution> <address> Scotland, </address> <year> 1992. </year> <note> In preparation. </note>
Reference-contexts: For more details see Brown <ref> [1] </ref>. 5 The Action Notation Code Generator The actual translation of actions into C object code is done by the code generator. An action is translated to a C statement (-sequence); a term yielding a datum is translated to a C expression.
Reference: [2] <author> P. Lee. </author> <title> Realistic Compiler Generation. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: In any case, denotational semantics has poor pragmatic qualities as a language development tool: denotational semantic descriptions of real programming languages are notoriously hard to write, to modify, and to read. Also worth mentioning here is Lee's "high-level semantics" <ref> [2] </ref>. This is a method of constructing compilers using semantic algebras, which are not unlike action notation. Using this method Lee has constructed compilers whose object code is 13 excellent.
Reference: [3] <author> P. D. Mosses. </author> <title> SIS semantics implementation system, reference manual and user guide. </title> <type> Departmental Report DAIMI MD-30, </type> <institution> Computer Science Department, Aarhus University, Denmark, </institution> <year> 1979. </year>
Reference-contexts: However, generating a code generator from a semantic description is much more difficult, and so far this problem has eluded satisfactory solution. The key efforts have been attempts to generate compilers from denotational semantic descriptions <ref> [3, 7, 11] </ref>. The generated compiler translates the source program to a -expression, then reduces the latter as much as it can; the residual -expression is the "object program". At run-time the residual -expression is applied to the program's input, and when reduced to normal form gives the program's output.
Reference: [4] <author> P. D. Mosses. </author> <title> Action Semantics. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, England, </address> <year> 1992. </year> <note> In preparation. </note>
Reference-contexts: Similarly, he has attempted to analyse the use of environment arguments, in order to discover whether the scopes of bindings and the lifetimes of variables permit stack allocation [8]. But the analyses are complicated, and it is unlikely that they can be extended beyond toy languages. Action semantics <ref> [4, 5, 12] </ref> seems to be a more promising basis for compiler generation. An action-semantic description in effect specifies a translation from the source language to action notation. <p> Space permits only a very brief and incomplete explanation of action notation here. For a comprehensive account of action notation, together with a formal specification, see Mosses <ref> [4] </ref>; for a gentler introduction, see Watt [12]. 1 3 Overview of Actress Actress supports a well-defined subset of action notation that is rich enough to write semantic descriptions of interesting programming languages. The subset includes all the notation listed in Tables 1-3. <p> The action notation interpreter interprets an action tree and displays the action's outcome. The outcome includes the transients, bindings and storage produced by the action, if it completes, or an indication of failure otherwise. The interpreter closely follows the structure of Mosses' operational semantics of action notation <ref> [4] </ref>. 1 For historical reasons, the action notation used in Actress differs slightly from that described in the cited texts. 6 Moreover, it implements nearly all of action notation. A full description can be found in Moura [6].
Reference: [5] <author> P. D. Mosses and D. A. Watt. </author> <title> The use of action semantics. </title> <editor> In M. Wirsing, editor, </editor> <booktitle> Formal Description of Programming Concepts III, </booktitle> <pages> pages 135-163. </pages> <publisher> North Holland, </publisher> <address> Amsterdam, Netherlands, </address> <year> 1987. </year>
Reference-contexts: Similarly, he has attempted to analyse the use of environment arguments, in order to discover whether the scopes of bindings and the lifetimes of variables permit stack allocation [8]. But the analyses are complicated, and it is unlikely that they can be extended beyond toy languages. Action semantics <ref> [4, 5, 12] </ref> seems to be a more promising basis for compiler generation. An action-semantic description in effect specifies a translation from the source language to action notation.
Reference: [6] <author> H. Moura. </author> <title> An implementation of action semantics. </title> <type> Research report, </type> <institution> Department of Computing Science, University of Glasgow, </institution> <address> Scotland, </address> <year> 1992. </year> <note> In preparation. </note>
Reference-contexts: A full description can be found in Moura <ref> [6] </ref>. The action notation interpreter can be composed with the action notation parser to allow the user to perform actions directly | a valuable tool for students of action notation.
Reference: [7] <author> L. Paulson. </author> <title> A compiler generator for semantic grammars. </title> <type> PhD thesis, </type> <institution> Stanford University, California, </institution> <year> 1981. </year>
Reference-contexts: However, generating a code generator from a semantic description is much more difficult, and so far this problem has eluded satisfactory solution. The key efforts have been attempts to generate compilers from denotational semantic descriptions <ref> [3, 7, 11] </ref>. The generated compiler translates the source program to a -expression, then reduces the latter as much as it can; the residual -expression is the "object program". At run-time the residual -expression is applied to the program's input, and when reduced to normal form gives the program's output.
Reference: [8] <author> D. A. Schmidt. </author> <title> Detecting global variables in denotational specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(2) </volume> <pages> 299-310, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Similarly, he has attempted to analyse the use of environment arguments, in order to discover whether the scopes of bindings and the lifetimes of variables permit stack allocation <ref> [8] </ref>. But the analyses are complicated, and it is unlikely that they can be extended beyond toy languages. Action semantics [4, 5, 12] seems to be a more promising basis for compiler generation. An action-semantic description in effect specifies a translation from the source language to action notation.
Reference: [9] <author> D. A. Schmidt. </author> <title> Detecting stack-based environments in denotational definitions. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 11 </volume> <pages> 107-131, </pages> <year> 1988. </year> <month> 14 </month>
Reference-contexts: For example, Schmidt has formulated sufficient conditions for single-threading of the store arguments; under these conditions all store aguments can be mapped to a global store variable <ref> [9] </ref>. Similarly, he has attempted to analyse the use of environment arguments, in order to discover whether the scopes of bindings and the lifetimes of variables permit stack allocation [8]. But the analyses are complicated, and it is unlikely that they can be extended beyond toy languages.
Reference: [10] <author> D. A. Schmidt and S. </author> <title> Even. Type inference for action semantics. </title> <editor> In N. Jones, editor, </editor> <booktitle> ESOP '90, 3rd European Symposium on Programming, </booktitle> <pages> pages 118-133, </pages> <address> Copenhagen, Denmark, 1990. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany. </address> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 432. </volume>
Reference-contexts: The imperative facet (storage) is not currently analysed. The sort information is represented by record types similar to those introduced by Wand, and applied by Even and Schmidt to their own simplified version of action notation <ref> [10] </ref>. Each action is decorated by four record schemes, representing input and output transients, and input and output bindings. <p> The sorts inferred by the sort checker have been specified using a set of inference rules, somewhat analogous to the type inference rules for a programming language. Our sort inference algorithm is based on the one given in Even and Schmidt <ref> [10] </ref>. However, it has been enhanced in several ways. It represents both transients and bindings using record schemes, which leads to a more regular structure in the sort checker.
Reference: [11] <author> M. Wand. </author> <title> A semantic prototyping system. </title> <booktitle> SIGPLAN Notices (SIGPLAN '84 Symp. On Compiler Construction), </booktitle> <volume> 19(6) </volume> <pages> 213-221, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: However, generating a code generator from a semantic description is much more difficult, and so far this problem has eluded satisfactory solution. The key efforts have been attempts to generate compilers from denotational semantic descriptions <ref> [3, 7, 11] </ref>. The generated compiler translates the source program to a -expression, then reduces the latter as much as it can; the residual -expression is the "object program". At run-time the residual -expression is applied to the program's input, and when reduced to normal form gives the program's output.
Reference: [12] <author> D. A. Watt. </author> <title> Programming Language Syntax and Semantics. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <address> Hemel Hempstead, England, </address> <year> 1991. </year>
Reference-contexts: Similarly, he has attempted to analyse the use of environment arguments, in order to discover whether the scopes of bindings and the lifetimes of variables permit stack allocation [8]. But the analyses are complicated, and it is unlikely that they can be extended beyond toy languages. Action semantics <ref> [4, 5, 12] </ref> seems to be a more promising basis for compiler generation. An action-semantic description in effect specifies a translation from the source language to action notation. <p> An action may use data operations to access the data supplied to it. The most common action primitives, action combinators, and data operations are summarized in Tables 1, 2, and 3, respectively. An action semantic description of a small imperative language, mini-4 <ref> [12] </ref>, is given in Appendix A. It is structured like a denotational semantic description, with 3 Table 2: Some action combinators Combinator Informal meaning Example A 1 or A 2 Performs either A 1 or A 2 . <p> Space permits only a very brief and incomplete explanation of action notation here. For a comprehensive account of action notation, together with a formal specification, see Mosses [4]; for a gentler introduction, see Watt <ref> [12] </ref>. 1 3 Overview of Actress Actress supports a well-defined subset of action notation that is rich enough to write semantic descriptions of interesting programming languages. The subset includes all the notation listed in Tables 1-3. Actress consists of a number of modules, which may be composed in various ways. <p> We estimate that these improvements would speed up the sort-checking phase of the generated mini-4 compiler by a factor of about 10. 7 Conclusion Our work on action semantics directed compiler generation should be seen in the context of the programming language life cycle <ref> [12] </ref>. Language development proceeds in several stages: design, specification, prototyping, and compiler construction (not necessarily in that order). We see action semantics as a means of integrating all stages of language development.
References-found: 12

