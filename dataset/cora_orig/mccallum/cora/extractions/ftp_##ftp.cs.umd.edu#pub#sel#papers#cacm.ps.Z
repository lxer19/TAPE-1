URL: ftp://ftp.cs.umd.edu/pub/sel/papers/cacm.ps.Z
Refering-URL: http://www.cs.umd.edu/projects/SoftEng/ESEG/papers/cacm.html
Root-URL: 
Title: Assessing the Impact of Reuse on Quality and Productivity in ObjectOriented Systems  
Author: Victor R. Basili, Lionel C. Briand and Walclio L. Melo 
Note: To appear in the Communication of ACM, October 1996. Copyright 1996 ACM Press.  
Abstract: This paper presents the results of a study conducted at the University of Maryland in which we assessed the impact of reuse on quality and productivity in OO systems. Reuse is assumed to be a very effective strategy for the software industry to build high-quality software. However, there is currently very little empirical information about what we can expect from reuse in terms of productivity and quality gains. This also applies to OO development which is supposed to facilitate reuse. Our experiment is one step towards a better understanding of the benefits of reuse in an OO framework, considering currently available technology. Data was collected, for four months, on the development of eight mediumsize management information systems with equivalent functional requirements. All eight projects were developed using the Waterfall style Software Engineering Life Cycle Model, an ObjectOriented (OO) design method and the C++ programming language. This study indicates significant benefits from reuse in terms of reduced defect density and rework as well as increased productivity. Furthermore, these results will help software organizations assess new reuse technologies against a quantitative and objective baseline of comparison. ** Authors names appear in alphabetical order. V. Basili is with the University of Maryland, Institute for Advanced Computer Studies and Computer Science Dept., A. V. Williams Bldg., College Park, MD 20742 USA. E-mail: basili@cs.umd.edu. Briand is with Fraunhofer-Institute for Experimental Software Engineering, Technologiepark II, Sauerwiesen 6, D-67661, Kaiserslautern, Germany. Email: briand@iese.fhg.de. W. Melo is with the Centre de Recherche Informatique de Montral, 1801 McGill College Av., Montral (Qubec), H3A 2N4, Canada. E-mail: wmelo@crim.ca 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. B. Abreu and R. </author> <month> Carapua </month> <year> (1994). </year> <title> "Candidate metrics for objectoriented software within a taxonomy framework". </title> <journal> In Journal of System and Software, 26(1):8796. </journal>
Reference-contexts: Thus, we will compare the advantages and drawbacks of using these two different types of software libraries. Finally, it would be interesting to refine our comparison of the internal class characteristics across reuse categories by using more specific OO metrics <ref> [1] </ref>. We need to better characterize the impact of reuse on the system size, complexity, coupling, and cohesion. Acknowledgments We want to thank (1) Dr.
Reference: [2] <institution> Amadeus Software Research, Inc. </institution> <year> (1994). </year> <title> Getting Started with Amadeus. </title> <booktitle> Amadeus Measurement System. </booktitle>
Reference-contexts: We ran an analysis using various code metrics (e.g., cyclomatic complexity, nesting level, function calls, etc.) and were able to determine that the distributions across reuse categories were not statistically different. (These measures were extracted using the Amadeus tool <ref> [2] </ref>). Table 2 shows the paired statistical comparisons of fault densities between reuse categories. We assumed significance at the 0.05 alevel, i.e., if the p-value is greater than 0.05, then we assume there is no observable difference.
Reference: [3] <author> W. W. Agresti and F. </author> <title> McGarry (1987). The Minnowbrook workshop on software reuse: A summary report. </title> <editor> In W. Tracz, editor, </editor> <booktitle> Software Reuse: Emerging Technology. </booktitle> <publisher> IEEE Press. </publisher>
Reference-contexts: The major motivation for reusing software artifacts is to decrease software development costs and cycle time by reducing the time and human effort required to build software products. Some research <ref> [3, 11, 21] </ref> has suggested that software quality can be improved by reusing quality software artifacts.
Reference: [4] <author> V. </author> <title> Basili (1990). Viewing maintenance as reuse-oriented software development. </title> <booktitle> In IEEE Software, </booktitle> <address> 7(1):1925, </address> <month> Jan. </month>
Reference-contexts: Some work has also hypothesized that software reuse is an important factor in the reduction of maintenance costs, since when reusing quality objects, the time and effort required to maintain software products can be reduced <ref> [4, 19] </ref>. This is why the reuse of software products, software processes and other software artifacts is considered the technological key to enabling the software industry to attain the required levels of productivity and quality [5].
Reference: [5] <author> V. Basili and H. D. </author> <title> Rombach (1988). "The TAME project: Towards improvement-oriented software environments". </title> <journal> In IEEE Trans. on Software Engineering. 14(6):758773. </journal>
Reference-contexts: This is why the reuse of software products, software processes and other software artifacts is considered the technological key to enabling the software industry to attain the required levels of productivity and quality <ref> [5] </ref>. The goal of this paper is to assess the impact of product reuse on software quality and productivity in the context of ObjectOriented (OO) systems. OO approaches are assumed to make reuse more efficient from both financial and technical perspectives.
Reference: [6] <author> V. Basili and H. D. </author> <title> Rombach (1991). "Support for comprehensive reuse". </title> <journal> In IEE Software Engineering Journal. </journal> <month> Sept. </month> <pages> pp. 303-316. </pages>
Reference-contexts: Experiment Goals and Assumptions In order to define the metrics to be collected during the experiment we used the Goal/Question/Metric (GQM) paradigm <ref> [6, 7] </ref>. This study has the following goal: Analyze: Reuse in an OO Software Development Process for the purpose of: evaluation with respect to: rework effort, defect density and productivity from the viewpoint of: organization. <p> Due to a limitation of space, we will not present the complete GQM and will only present in this paper the metrics we have derived. However, it is important to note that the metrics described in the next section were derived by following the GQM methodology <ref> [6] </ref>. 2 . 4 . Independent and Dependent Variables In the following subsections, we define the independent and dependent variables used in this study, i.e., size, reuse, effort, productivity, defect density.
Reference: [7] <author> V. Basili and D. M. </author> <title> Weiss (1984). "A methodology for collecting valid software engineering data". </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 10(6). </volume> <month> November. </month>
Reference-contexts: Experiment Goals and Assumptions In order to define the metrics to be collected during the experiment we used the Goal/Question/Metric (GQM) paradigm <ref> [6, 7] </ref>. This study has the following goal: Analyze: Reuse in an OO Software Development Process for the purpose of: evaluation with respect to: rework effort, defect density and productivity from the viewpoint of: organization. <p> E in - is the set of errors in which the class C i was affected | Classes_affected (E ij ) | is the number of classes affected by the error E ij 2.5. Collecting Data In our case we used the approach proposed in <ref> [7] </ref> which proposes using forms for collecting data and gives guidelines for checking the accuracy of the information gathered. We used three different types of forms. These forms have been tailored from those used by the Software Engineering Laboratory [18]. Personnel Resource Form. Component Origination Form. Error Report Form.
Reference: [8] <author> B. W. </author> <title> Boehm (1984). </title> <journal> Software engineering economics. IEEE Trans. on Software Engineering. </journal> <volume> SE-10(1), </volume> <month> January. </month>
Reference-contexts: As productivity is often considered to be an exponential function of software size, a reduction in the amount of software to be created could provide a dramatic savings in development costs <ref> [8] </ref>.
Reference: [9] <author> B. W. Boehm and P. N. </author> <month> Papaccio </month> <year> (1988). </year> <title> Understanding and controlling software costs. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 14(10), </volume> <month> October. </month>
Reference-contexts: In conclusion, the results support the assumption that reuse in an OO software development results in lower rework effort. 4 . Software Product Reuse and Software Productivity Reuse has been advocated as a means for reducing development cost. For example, in <ref> [9] </ref>, reuse of classes is identified as one of the most attractive strategies for improving productivity. As productivity is often considered to be an exponential function of software size, a reduction in the amount of software to be created could provide a dramatic savings in development costs [8].
Reference: [10] <author> L. Briand, S. Morasca, and V. Basili: </author> <title> Property Based Software Engineering Measurement. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> SE-22(1):68-86, </volume> <month> January </month> <year> 1996. </year>
Reference-contexts: We intend to make the underlying assumptions and models clear so that a precise terminology can be used in the remainder of the paper. A thorough and formal discussion of these issues can be found in <ref> [10] </ref>. 2.4.1 Size The size of a system S is a function Size (S) that is characterized by the properties: Size cannot be negative (property Size.1), and we expect it to be null when a system does not contain any component (property Size.2). <p> More importantly, when components do not have elements in common, we expect Size to be additive (property Size.3). From these simple properties, other properties can be derived as discussed in <ref> [10] </ref>. Let us assume an operator called Components which when applied to a system S, gives the distinct components of the system S, such that: Components (S) = -C 1 , ..., C n -, such that if C i =C j then i=j, where i, j=1,..,n .
Reference: [11] <author> F. P. </author> <title> Brooks (1987). No silver bullet: essence and accidents of software engineering. </title> <booktitle> In Computer, </booktitle> <volume> 20(4), </volume> <month> April. </month>
Reference-contexts: The major motivation for reusing software artifacts is to decrease software development costs and cycle time by reducing the time and human effort required to build software products. Some research <ref> [3, 11, 21] </ref> has suggested that software quality can be improved by reusing quality software artifacts.
Reference: [12] <author> J. </author> <title> Devore (1991). Probability and Statistics for Engineering and Sciences. </title> <publisher> Brooks/Cole Publishing Company </publisher>
Reference-contexts: The data set is rather small and, consequently, we adopted a data analysis strategy following the steps below: First, we used a non-parametric test (Wilcoxon matched-pairs signed rank test or Wilcoxon T test <ref> [12] </ref>) to determine whether significant differences could be observed between reused, modified, and newly developed classes. The rationale underlying this test is straightforward. We are comparing a set of pairs of scores (in this case: defect densities). <p> Before any thorough statistical analysis, a look at the distributions seems to indicate that measures (1) and (2) are significantly different across reuse categories. Based on these results, we can run again, as for defect density analysis, a Wilcoxon signed rank test <ref> [12] </ref> on the data collected in order to answer the question formulated at the beginning of this section. In other words, instead of using defect density per reuse category as scores, we use total amount of rework per reuse category.
Reference: [13] <author> N. E. </author> <title> Fenton (1991). Software Metrics: A Rigorous Approach. </title> <publisher> Chapman&Hall. </publisher>
Reference: [14] <author> G. Ferguson and Y. </author> <title> Takane (1989), Statistical Analysis in Psychology and Education McGraw-Hill. </title>
Reference-contexts: It might be argued that the number of data points is too small to allow such an analysis. However, there is a common agreement that the number of independent observations per explanatory variable could be as low as 5 <ref> [14] </ref>. Another analysis strategy would have been to work at the class level (e.g., compare defect densities of classes across reuse categories) but this presented several problems: Some of the projects included a large percentage of all reused classes.
Reference: [15] <author> T. C. </author> <title> Jones (1986). Programming Productivity. </title> <publisher> McGraw-Hill. </publisher>
Reference-contexts: We believe that this is a strong evidence that reuse helped improve quality all across the covered reuse rate range, i.e., 0% to 64%. 3 . 2 Reuse versus Rework In <ref> [15] </ref>, rework is identified as a major cost factor in software development. Rework on the average accounts for over 50% of the effort for large projects [15]. Reuse of previously developed, reviewed, and tested classes could result in easy-to-maintain classes and consequently, reuse should decrease the rework effort. <p> evidence that reuse helped improve quality all across the covered reuse rate range, i.e., 0% to 64%. 3 . 2 Reuse versus Rework In <ref> [15] </ref>, rework is identified as a major cost factor in software development. Rework on the average accounts for over 50% of the effort for large projects [15]. Reuse of previously developed, reviewed, and tested classes could result in easy-to-maintain classes and consequently, reuse should decrease the rework effort. In this section, we first compare rework effort on reused and newly created classes.
Reference: [16] <author> C. M. Judd, E. R. Smith and L. H. </author> <month> Kidder </month> <year> (1991). </year> <title> Research, Methods in Social Relations. </title> <publisher> Harcourt Brace Jovanovich College Publishers. </publisher>
Reference-contexts: In order to control for differences in skills and experience among students, the students were randomly grouped into 8 teams of three students. Furthermore, in order to ensure the groups were comparable with respect to the ability of their members, the following procedure (i.e., known as blocking <ref> [16] </ref>) was used to assign students to groups : First, the level of experience of each student was characterized at the beginning of the study. We used questionnaires and performed interviews. <p> Validity The validity of this study can be analyzed from two different perspective: internal validity (what are the threats to the conclusions we can draw from this study), external validity (how generalizable are these results) <ref> [16] </ref>. With respect to internal validity, we can say that subjects were classified according to their ability and assigned randomly to form equivalent teams. Therefore, we are less likely to obtain biased results due to differences in ability across teams.
Reference: [17] <author> C. W. </author> <title> Krueger (1992). "Software reuse". </title> <journal> In ACM Computing Surveys. </journal> <volume> 24(2) </volume> <pages> 131-183. </pages>
Reference-contexts: 1. Introduction Software reuse can help address the software crisis by helping produce quality software more quickly. Software reuse is the process of using existing software artifacts instead of building them from scratch <ref> [17] </ref>. Broadly speaking, the reuse process involves the following steps: (1) selection of reusable artifact, (2) its adaptation to the purpose of the application, and finally (3) its integration into the software product under development.
Reference: [18] <author> G. Heller; J. Valett; M. </author> <title> Wild (1992). Data Collection Procedure for the Software Engineering Laboratory (SEL) Database. SEL Series, </title> <publisher> SEL-92-002. </publisher>
Reference-contexts: We used three different types of forms. These forms have been tailored from those used by the Software Engineering Laboratory <ref> [18] </ref>. Personnel Resource Form. Component Origination Form. Error Report Form.
Reference: [19] <author> H. D. </author> <title> Rombach (1991). Software reuse: a key to the maintenance problem. </title> <journal> In Information and Software Technology Journal, </journal> <volume> 33(1), </volume> <month> Jan/Feb. </month>
Reference-contexts: Some work has also hypothesized that software reuse is an important factor in the reduction of maintenance costs, since when reusing quality objects, the time and effort required to maintain software products can be reduced <ref> [4, 19] </ref>. This is why the reuse of software products, software processes and other software artifacts is considered the technological key to enabling the software industry to attain the required levels of productivity and quality [5].
Reference: [20] <author> J. Rumbaugh; M. Blaha; W. Premerlani; F. Eddy; W. </author> <month> Lorensen </month> <year> (1991). </year> <title> ObjectOriented Modeling and Design. </title> <publisher> Prentice-Hall. </publisher>
Reference-contexts: Acceptance testing was performed by an independent group (see Section 2.5). During the repair phase, the students were asked to correct their system based on the errors found by the independent test group. OMT, an OO Analysis/Design method, was used during the analysis and design phases <ref> [20] </ref>. The C++ programming language, the GNU software development environment, and OSF/MOTIF were used during the implementation. Sparc Sun stations were used as the implementation platform. Therefore, the development environment and technology we used are representative of what is currently used in industry and academia. <p> However, as discussed in the next sections, measuring size in the context of reuse raises difficult measurement issues related to OO mechanisms as inheritance and aggregation of classes <ref> [20] </ref>. 2.4.2. Reuse The amount of reused code in a system S is a function Reuse (S) that is also characterized by the properties Size.1 - Size.3, that is Reuse (S) is an instance of size metric.
Reference: [21] <author> W. Thomas, A. Delis, V. </author> <title> Basili (1992). An evaluation of Ada source code reuse. </title> <booktitle> In Proc. of the Ada-Europe Intl Conf., </booktitle> <address> Zandvoort, The Netherlands, </address> <month> June. </month>
Reference-contexts: The major motivation for reusing software artifacts is to decrease software development costs and cycle time by reducing the time and human effort required to build software products. Some research <ref> [3, 11, 21] </ref> has suggested that software quality can be improved by reusing quality software artifacts.
Reference: [22] <author> D. A. </author> <title> Young (1992). ObjectOriented Programming with C++ and OSF/MOTIF. </title> <publisher> Prentice-Hall. </publisher>
Reference-contexts: Our results are thus more likely to be generalizable to other development environments (external validity). The following libraries were provided to the students: a) MotifApp. This public domain library provides a set of C++ classes on top of OSF/MOTIF for manipulation of windows, dialogues, menus, etc. <ref> [22] </ref>. The MotifApp library provides a way to use the OSF/Motif widgets in an OO programming/design style. b) GNU library. This public domain library is provided in the GNU C++ programming environment. It contains functions for manipulation of string, files, lists, etc. c) C++ database library.
References-found: 22

