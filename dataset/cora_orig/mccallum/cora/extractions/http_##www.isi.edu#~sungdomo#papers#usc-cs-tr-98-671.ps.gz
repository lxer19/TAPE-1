URL: http://www.isi.edu/~sungdomo/papers/usc-cs-tr-98-671.ps.gz
Refering-URL: http://www.isi.edu/~sungdomo/publications.html
Root-URL: http://www.isi.edu
Email: E-mail: fsungdomo,saavedrag@cs.usc.edu  
Title: Hyperblocking: A Data Reorganization Method to Eliminate Cache Conflicts in Tiled Loop Nests USCCS98671  
Author: Sungdo Moon and Rafael H. Saavedra 
Address: Los Angeles, California, 90089-0781  LOS ANGELES, CALIFORNIA 900890781  
Affiliation: Computer Science Department University of Southern California  COMPUTER SCIENCE DEPARTMENT UNIVERSITY OF SOUTHERN CALIFORNIA  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Steve Carr, Kathryn S. McKinley, and Chau-Wen Tseng. </author> <title> Compiler optimization for improving data locality. </title> <booktitle> In Proceedings of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 252262, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Thus, many compiler optimization techniques have been proposed that enable a better cache utilization such as loop permutation, loop tiling, loop unrolling, etc. Tiling, or blocking <ref> [1, 5, 6, 12] </ref>, is one of the most effective optimizations for improving the locality of numerical loop nests. It reduces the size of data sets referenced during the iterations of the innermost loops by strip-mining the iteration space.
Reference: [2] <author> Stephanie Coleman and Kathryn S. McKinley. </author> <title> Tile size selection using cache organization and data layout. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 279290, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Experimental results are presented in Section 5 In Section 6, several issues of hyperblocking and future work are discussed. Section 7 concludes the paper. 2 Motivation To improve the cache behavior of tiled loop nests, several techniques such as copy optimization and tile size selection have been proposed <ref> [2, 3, 6, 10] </ref>. In this section, we briefly review these approaches. <p> Finally, when there exist multiple references to the same array and at least one of them is a write reference, coherence problems make it difficult to apply copy optimization. Since copy optimization has already been proven to be expensive due to the high overhead incurred by copying <ref> [2, 8] </ref>, we will not consider it in this paper. Another approach to deal with cache conflicts is using a proper tile size. Tile size plays an important role in making tiling profitable. Selecting the right tile size is critical for reducing not only capacity misses but also interference misses. <p> To eliminate this problem, several heuristics to tailor the tile size to the problem size have been proposed <ref> [6, 3, 2] </ref>. Lam, Rothberg and Wolf presented an algorithm (LRW) which chooses the largest square tile that does not suffer from self interference and it is based on computing the cache mapping pattern of each data block [6, 11]. <p> However, since the corresponding working set usually overflow the cache, capacity and cross interference misses tend to degrade performance. Coleman and McKinley have proposed another tile size selection algorithm (TSS) based on the data layout for given problem size, cache size and cache line size in a direct-mapped cache <ref> [2] </ref>. The algorithm chooses the rectangular tile that eliminates self interference misses and at the same time reduces cross interference misses while maximizing the size of working set. All these three heuristics focus only on one aspect of tile selection: either the working set or the shape of tile.
Reference: [3] <author> Karim Esseghir. </author> <title> Improving data locality for caches. </title> <type> Master's thesis, </type> <institution> Dept. of Computer Science, Rice University, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: Experimental results are presented in Section 5 In Section 6, several issues of hyperblocking and future work are discussed. Section 7 concludes the paper. 2 Motivation To improve the cache behavior of tiled loop nests, several techniques such as copy optimization and tile size selection have been proposed <ref> [2, 3, 6, 10] </ref>. In this section, we briefly review these approaches. <p> To eliminate this problem, several heuristics to tailor the tile size to the problem size have been proposed <ref> [6, 3, 2] </ref>. Lam, Rothberg and Wolf presented an algorithm (LRW) which chooses the largest square tile that does not suffer from self interference and it is based on computing the cache mapping pattern of each data block [6, 11]. <p> LRW, however, usually selects small tile sizes, which tend to incur loop overheads that penalize the execution time. To solve these problems, Esseghir has proposed an algorithm (ESS) that chooses a tile size that maximizes the number of complete columns that fit in the cache <ref> [3] </ref>. Due to the tile's large column size, ESS tends to minimize the loop overhead of the innermost loops. However, since the corresponding working set usually overflow the cache, capacity and cross interference misses tend to degrade performance.
Reference: [4] <author> Dennis Gannon and William Jalby. </author> <title> The influence of memory hierarchy on algorithm organization: Programming fft on a vector multiprocessor. In The Characteristics of Parallel Algorithms. </title> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: In this section, we briefly review these approaches. Using the cache model presented in Section 2.2, we also show why tile selection heuristics are not effective. 2 Technical Report USCCS98671 2.1 Related Work To cope with cache conflicts of tiled loops, copy optimization has been suggested <ref> [4, 6, 10] </ref>. In copy optimization, non-contiguous blocks of data to be reused are copied into a contiguous area in memory. With copy optimization, self interference within the data block is eliminated since each element is mapped into a different cache frame.
Reference: [5] <author> Dennis Gannon, William Jalby, and K. Gallivan. </author> <title> Strategies for cache and local memory management by global program transformation. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 5(5):587616, </volume> <month> October </month> <year> 1988. </year>
Reference-contexts: Thus, many compiler optimization techniques have been proposed that enable a better cache utilization such as loop permutation, loop tiling, loop unrolling, etc. Tiling, or blocking <ref> [1, 5, 6, 12] </ref>, is one of the most effective optimizations for improving the locality of numerical loop nests. It reduces the size of data sets referenced during the iterations of the innermost loops by strip-mining the iteration space.
Reference: [6] <author> Monica S. Lam, Edward E. Rothberg, and Michael E. Wolf. </author> <title> The cache performance and optimization of blocked algorithms. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 6374, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Thus, many compiler optimization techniques have been proposed that enable a better cache utilization such as loop permutation, loop tiling, loop unrolling, etc. Tiling, or blocking <ref> [1, 5, 6, 12] </ref>, is one of the most effective optimizations for improving the locality of numerical loop nests. It reduces the size of data sets referenced during the iterations of the innermost loops by strip-mining the iteration space. <p> Therefore, the performance of tiled algorithms is highly dependent on the layout and the size of arrays referenced in the loop <ref> [6] </ref>. Furthermore, when data prefetching is used, cache mapping conflicts increase the probability to evict prefetched data from the cache before it is used, and consequently degrade the effectiveness of prefetching. <p> Experimental results are presented in Section 5 In Section 6, several issues of hyperblocking and future work are discussed. Section 7 concludes the paper. 2 Motivation To improve the cache behavior of tiled loop nests, several techniques such as copy optimization and tile size selection have been proposed <ref> [2, 3, 6, 10] </ref>. In this section, we briefly review these approaches. <p> In this section, we briefly review these approaches. Using the cache model presented in Section 2.2, we also show why tile selection heuristics are not effective. 2 Technical Report USCCS98671 2.1 Related Work To cope with cache conflicts of tiled loops, copy optimization has been suggested <ref> [4, 6, 10] </ref>. In copy optimization, non-contiguous blocks of data to be reused are copied into a contiguous area in memory. With copy optimization, self interference within the data block is eliminated since each element is mapped into a different cache frame. <p> For a given cache size, the optimal fixed-size tile all problem sizes is usually small, which utilizes only a small fraction of the cache, and results in large variations of miss rates over the range of problem sizes <ref> [6] </ref>. To eliminate this problem, several heuristics to tailor the tile size to the problem size have been proposed [6, 3, 2]. <p> To eliminate this problem, several heuristics to tailor the tile size to the problem size have been proposed <ref> [6, 3, 2] </ref>. Lam, Rothberg and Wolf presented an algorithm (LRW) which chooses the largest square tile that does not suffer from self interference and it is based on computing the cache mapping pattern of each data block [6, 11]. <p> Lam, Rothberg and Wolf presented an algorithm (LRW) which chooses the largest square tile that does not suffer from self interference and it is based on computing the cache mapping pattern of each data block <ref> [6, 11] </ref>. LRW, however, usually selects small tile sizes, which tend to incur loop overheads that penalize the execution time. To solve these problems, Esseghir has proposed an algorithm (ESS) that chooses a tile size that maximizes the number of complete columns that fit in the cache [3].
Reference: [7] <author> Todd C. Mowry, Monica S. Lam, and Anoop Gupta. </author> <title> Design and evaluation of a compiler algorithm for prefetch-ing. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 6273, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Prefetch instructions was inserted 4 loop iteration ahead using the algorithm introduced by Mowry, Lam and Gupta <ref> [7] </ref>. For all algorithms we used, The localized iteration space is larger than the 2 innermost loops, but smaller than the volume induced by 3 innermost loop.
Reference: [8] <author> Rafael H. Saavedra, Weihua Mao, Daeyeon Park, Jacqueline Chame, and Sungdo Moon. </author> <title> The combined effectiveness of unimodular transformations, tiling, and software prefetching. </title> <booktitle> In Proceedings of the tenth International Parallel Processing Symposium, </booktitle> <pages> pages 3945, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: Furthermore, when data prefetching is used, cache mapping conflicts increase the probability to evict prefetched data from the cache before it is used, and consequently degrade the effectiveness of prefetching. With prefetching, therefore, tiled loop nests can experience more cache misses than the original loop nests in many cases <ref> [8] </ref>. In this paper, we present a new optimization technique, called hyperblocking or hypertiling, that reorganizes data arrays with the goal of eliminating most cache conflicts in tiled loop nests. <p> Finally, when there exist multiple references to the same array and at least one of them is a write reference, coherence problems make it difficult to apply copy optimization. Since copy optimization has already been proven to be expensive due to the high overhead incurred by copying <ref> [2, 8] </ref>, we will not consider it in this paper. Another approach to deal with cache conflicts is using a proper tile size. Tile size plays an important role in making tiling profitable. Selecting the right tile size is critical for reducing not only capacity misses but also interference misses.
Reference: [9] <author> Rafael H. Saavedra and Daeyeon Park. </author> <title> Improving the effectiveness of software prefetching with adaptive execution. </title> <booktitle> In Proceedings of the International Conference on Parallel Architecture and Compilation Techniques (PACT'96), </booktitle> <pages> pages 6878, </pages> <month> October </month> <year> 1996. </year> <note> 20 Technical Report USCCS98671 </note>
Reference-contexts: Due to large variance of memory latency, using a fixed prefetch distance may result in poor performance. Thus, adaptive prefetching that adjusts prefetch distance at run-time using run-time statistics have been proposed <ref> [9] </ref>.
Reference: [10] <author> Oliver Temam, Elana Granston, and William Jalby. </author> <title> To copy or not to copy: A compile-time technique for assessing when data copying should be used to eliminate cache conflicts. </title> <booktitle> In Proceedings of Supercomputing '93, </booktitle> <pages> pages 401419, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Experimental results are presented in Section 5 In Section 6, several issues of hyperblocking and future work are discussed. Section 7 concludes the paper. 2 Motivation To improve the cache behavior of tiled loop nests, several techniques such as copy optimization and tile size selection have been proposed <ref> [2, 3, 6, 10] </ref>. In this section, we briefly review these approaches. <p> In this section, we briefly review these approaches. Using the cache model presented in Section 2.2, we also show why tile selection heuristics are not effective. 2 Technical Report USCCS98671 2.1 Related Work To cope with cache conflicts of tiled loops, copy optimization has been suggested <ref> [4, 6, 10] </ref>. In copy optimization, non-contiguous blocks of data to be reused are copied into a contiguous area in memory. With copy optimization, self interference within the data block is eliminated since each element is mapped into a different cache frame. <p> With copy optimization, self interference within the data block is eliminated since each element is mapped into a different cache frame. However, the overhead of copying can be substantial and can sometimes outweigh the improvements gained by using copy optimization <ref> [10] </ref>. Cross interference between different arrays is not eliminated by copy optimization and continues to degrade performance. Furthermore, during copying, the original and the copied data can pollute the cache.
Reference: [11] <author> Michael E. Wolf. </author> <title> Improving Locality and Parallelism in Nested Loops. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Stanford University, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: Lam, Rothberg and Wolf presented an algorithm (LRW) which chooses the largest square tile that does not suffer from self interference and it is based on computing the cache mapping pattern of each data block <ref> [6, 11] </ref>. LRW, however, usually selects small tile sizes, which tend to incur loop overheads that penalize the execution time. To solve these problems, Esseghir has proposed an algorithm (ESS) that chooses a tile size that maximizes the number of complete columns that fit in the cache [3].
Reference: [12] <author> Michael E. Wolf and Monica S. Lam. </author> <title> A data locality optimizing algorithm. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 3044, </pages> <month> June </month> <year> 1991. </year> <month> 21 </month>
Reference-contexts: Thus, many compiler optimization techniques have been proposed that enable a better cache utilization such as loop permutation, loop tiling, loop unrolling, etc. Tiling, or blocking <ref> [1, 5, 6, 12] </ref>, is one of the most effective optimizations for improving the locality of numerical loop nests. It reduces the size of data sets referenced during the iterations of the innermost loops by strip-mining the iteration space.
References-found: 12

