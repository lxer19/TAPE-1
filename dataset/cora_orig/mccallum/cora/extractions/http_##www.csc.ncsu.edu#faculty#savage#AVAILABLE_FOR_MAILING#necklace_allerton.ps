URL: http://www.csc.ncsu.edu/faculty/savage/AVAILABLE_FOR_MAILING/necklace_allerton.ps
Refering-URL: http://www.csc.ncsu.edu/faculty/savage/papers.html
Root-URL: http://www.csc.ncsu.edu
Title: A New Algorithm for Generating Necklaces Extended Abstract  
Author: Terry MinYih Wang Carla D. Savage 
Note: mance appears to be as least as good as ours for k &gt; 2.  
Date: July 12, 1990  
Address: Raleigh, North Carolina 27695  
Affiliation: Department of Computer Science North Carolina State University  
Abstract: In this paper we present an algorithm for generating the lexicographically smallest representatives of all the n-bead necklaces in k-colors. The time required is O(nN n k ), where N n k is the number of necklaces with n beads of k colors. To our knowledge, this is the first algorithm for this problem which has been proved to asymptotically improve the obvious O(n fl k n ) approach of examining all k-ary n-tuples and rejecting those which are not lexicographically smallest rotations. Our algorithm has another advantage over a competitive one proposed by Fredericksen, Kessler, and Maiorana in that it can be implemented so that there is a gap of at most one non-necklace examined between any two necklaces generated, whereas the FKM algorithm can have gaps as large as b(n 1)=2c. Although no good upper bound was established for FKM, we show experimentally that its perfor 
Abstract-found: 1
Intro-found: 1
Reference: [FrKe] <author> H. Fredericksen and I. J. Kessler, </author> <title> "An algorithm for generating necklaces of beads in two colors," </title> <note> Discrete Mathematics 61 (1986) 181-188. </note>
Reference-contexts: A necklace is thus identified with its representative. A simple and elegant algorithm was proposed in [FrMa] and <ref> [FrKe] </ref> to generate for each necklace the lexicographically largest element. We will refer to this as the FKM algorithm. A disadvantage of the FKM algorithm is that there can be gaps in which as many as b (n 1)=2c non-necklaces are examined between any two necklaces generated. <p> We will refer to this as the FKM algorithm. A disadvantage of the FKM algorithm is that there can be gaps in which as many as b (n 1)=2c non-necklaces are examined between any two necklaces generated. For the case k = 2 the authors of <ref> [FrKe] </ref> prove an upper bound of b (n1)=2cN n k on the number of n-tuples generated and examined by the algorithm. The time spent generating and checking each element is O (n), giving an overall time for the algorithm of O (n 2 N n k ). <p> The indication is that (1) our algorithm is better than FKM for k = 2, (2) FKM is at least comparable to our algorithm for k &gt; 2 and (3) the upper bound on FKM from <ref> [FrKe] </ref> is almost certainly not tight. In Section 2 we describe our basic algorithm for the case k = 2, prove that it examines no more than 2N n k of the n-tuples, discuss how to implement it to minimize gaps, and compare it to FKM.
Reference: [FrMa] <author> H. Fredericksen and J. Maiorana, </author> <title> "Necklaces of beads in k colors and k-ary de Bruijn sequences," </title> <journal> Discrete Mathematics 23, </journal> <volume> No. </volume> <month> 3 </month> <year> (1978) </year> <month> 207-210. </month>
Reference-contexts: A necklace is thus identified with its representative. A simple and elegant algorithm was proposed in <ref> [FrMa] </ref> and [FrKe] to generate for each necklace the lexicographically largest element. We will refer to this as the FKM algorithm. A disadvantage of the FKM algorithm is that there can be gaps in which as many as b (n 1)=2c non-necklaces are examined between any two necklaces generated. <p> Lemma 4 If s (j) &gt; 0 for some j, then s (j + 1) = k 1. Finally, we make use of the following lemma, a variation of which appears in <ref> [FrMa] </ref>. Lemma 5 For x = 0ff 2 n , and a 2 n f0g, if o a oe (x) is not a necklace, the neither is o a1 oe (x). Putting these results together we have the following.
Reference: [Gi] <author> E. N. Gilbert, </author> <title> "Gray codes and paths on the n-cube," </title> <note> Bell Systems Technical Journal (1958) 815-826. </note>

Reference: [LiHiCa] <author> W. Liu, T. H. Hildebrandt, and R. Cavin III, </author> <title> "Hamiltonian cycles in the shu*e-exchange network," </title> <journal> IEEE Transactions on Computers, </journal> <note> to appear. </note>
Reference-contexts: Most proofs have been omitted in this extended abstract. 2 Necklaces of Beads in Two Colors Our idea for generating necklaces of two-color beads was inspired by a result in <ref> [LiHiCa] </ref> that a certain variation on the shu*e-exchange graph is Hamiltonian. When k = 2, the n-tuples are bit strings which we regard as elements of f0; 1g n .
Reference: [Lu] <author> J. Lucas, </author> <title> "The rotation graph of binary trees is Hamiltonian," </title> <note> Journal of Algorithms 8 (1987) 503-535. </note>
Reference-contexts: More important, is there a way to generate all necklaces in total time O (N n k ), ignoring the time for output? There are several combinatorial classes for which such a result is possible using Gray code like algorithms ([Gi], [Jo], <ref> [Lu] </ref>, [Ru], [Sa]). Alternatively, some clever encoding scheme, taking advantage of the structure of the tree, may allow one to reduce or eliminate the O (n) cost of necklace testing in our algorithm.
Reference: [Ru1] <author> F. Ruskey, </author> <title> "Adjacent interchange generation of combinations," </title> <note> Journal of Algorithms 9 (1988) 162-180. </note>
Reference: [Sa1] <author> C. Savage, </author> <title> "Gray code sequences of partitions," </title> <journal> Journal of Algorithms 10, </journal> <volume> No. </volume> <month> 4 </month> <year> (1989). </year>
References-found: 7

