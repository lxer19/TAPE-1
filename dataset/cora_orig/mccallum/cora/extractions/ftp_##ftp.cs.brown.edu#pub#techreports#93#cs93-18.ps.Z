URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-18.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-18.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Gul Agha, </author> <title> "Supporting Multiparadigm Programming on Actor Architectures." </title> <booktitle> Invited Lecture presented at PARLE '89 in Eindhoven, </booktitle> <address> the Netherlands, </address> <year> 1989. </year>
Reference-contexts: A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha <ref> [1] </ref>) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: <p> Other multiparadigm work includes Zave's research into composing different independent paradigms [226]; the explicitly multiparadigm languages Loops [22, 195], Daisy II [62], Leda [33], and G-2 [157]; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors as a basis for concurrent programming <ref> [1] </ref>; the CODE system for developing parallel applications [32]; the wide-spectrum languages V [188], CIP-L [17], and PLEASE [209]; and the work by Zave and Jackson on formally composing partial specifications [227]. 2.4.2 MVDEs Not Using a Canonical Representation Table 2-3 summarizes research into MVDEs that achieve integration by a mechanism
Reference: [2] <author> Alfred V. Aho, Brian W. Kernighan, and Peter J. Weinberger, </author> <title> The AWK programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: An annotation is just a (name, value) pair, where both the name and the value are case-sensitive strings. The value of an annotation may be null. Annotations are thus similar in form to Unix and DOS environment variables, resources in the X window system, associative arrays in awk <ref> [2] </ref> and Perl [216], etc.
Reference: [3] <author> Bowen Alpern, Alan Carle, Barry Rosen, Peter Sweeney, and Kenneth Zadeck, </author> <title> "Graph Attribution as a Specification Paradigm," </title> <booktitle> in Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 121-129, </pages> <publisher> ACM Press, </publisher> <month> November </month> <year> 1988. </year> <note> Published as ACM SIGSOFT Software Engineering Notes 13:5, </note> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices 24:2, </journal> <month> February </month> <year> 1989. </year>
Reference-contexts: [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications <ref> [3] </ref>] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views.
Reference: [4] <author> Bowen Alpern, Roger Hoover, Barry K. Rosen, Peter F. Sweeney, and F. Kenneth Zadeck, </author> <title> "Keeping Priorities Straight: An Investigation of Incremental Algorithms," </title> <type> Technical Report CS-88-13, </type> <institution> Brown University Department of Computer Science, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: A substantive change to an SPG need not trigger an update in all views, because some views may not depict the aspect (s) of the SPG that are affected by the change. 6.4. MISMATCHES BETWEEN SPGS AND VIEWS 135 for use in interactive development environments <ref> [204, 144, 225, 4, 180] </ref>. An ideal algorithm for updating a presentation, of course, is as predictable as a batch-mode computation and as efficient as an incremental one. Unfortunately, it may be the case that no such algorithm has been developed for a particular presentation.
Reference: [5] <author> Richard Altmann, Andrew Hawke, and Chris Marlin, </author> <title> "An Integrated Programming Environment Based on Multiple Concurrent Views," </title> <journal> Australian Computer Journal, </journal> <volume> vol. 20, no. 2, </volume> <pages> pp. 65-72, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView <ref> [5] </ref> Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence
Reference: [6] <author> James Ambras and Vicki O'Day, </author> <title> "MicroScope: A Knowledge-Based Programming Environment," </title> <journal> IEEE Software, </journal> <pages> pp. 50-58, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope <ref> [6] </ref> Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. <p> These chunks are then stored in whatever form the database supports, e.g., relations in the case of OMEGA, objects in the case of MicroScope <ref> [6] </ref>. Some database-centered environments, such as Trellis [147] and Odin [41], use larger-grained chunks, possibly as large as entire files of source and object code.
Reference: [7] <author> James Archer, Jr. and Richard Conway, </author> <title> "COPE: A Cooperative Programming Environment," </title> <type> Technical Report TR81-459, </type> <institution> Cornell University, </institution> <month> June </month> <year> 1981. </year>
Reference-contexts: VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE <ref> [7] </ref> Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. <p> Further complicating matters is that, unlike standalone compilers for programming languages in conventional (loosely integrated) programming environments, a good SPG-to-view translator should try to provide some kind of reasonable output, regardless of the SPG it is attempting to translate. In this sense, SPG-based environments tend to encourage a COPE-style <ref> [7] </ref> attitude toward unanticipated input conditions: if an unexpected SPG topology is encountered, the translator should try to recover from the "error"and continue to generate a reasonable view. This is in sharp contrast to most compilers, which emit object code only if their input is entirely well-formed.
Reference: [8] <author> Arvind and David E. Culler, </author> <booktitle> Annual Reviews in Computer Science, </booktitle> <volume> vol. 1, </volume> <booktitle> ch. "Dataflow Architectures", </booktitle> <pages> pp. 225-253. </pages> <publisher> Annual Reviews, Inc., </publisher> <year> 1986. </year> <note> Reprinted in [211, 79-101]. </note>
Reference-contexts: Nodes are eligible for execution whenever they have a token on each of their input ports, and during execution a node places tokens on its output ports. SPG execution is thus similar to execution of a variety of other graph structures, including Petri nets, flow graphs for dataflow languages <ref> [9, 8] </ref>, and the Plan Calculus. The topology of an SPG is essentially static during program execution, but the presence of conditions on destination branches means that the set of branches along which tokens may flow is determined dynamically.
Reference: [9] <author> Arvind and Rishiyur S. Nikhil, </author> <title> "Executing a Program on the MIT Tagged-Token Dataflow Architecture," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 39, no. 3, </volume> <pages> pp. 300-318, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: In particular, parallel execution of subexpressions is limited only by data dependencies, and subprogram calls are non-strict. Examples of this approach to computation include the languages Id <ref> [9] </ref>, Haskell [83], and Lucid [10, 215]. <p> In particular, I was impressed by the the Combined model of computation advanced by Treleaven and his colleagues in their work on an architecture that supports both control- and data-driven execution [212]. I also took ideas from the Tagged-Token Dataflow Architecture <ref> [9] </ref>, most notably in the area of support for non-strict subprogram calls. My approach to unexecutable information is based on concepts underlying hypermedia systems [43], and my use of hypergraphs instead of conventional graphs is a direct reflection of how my thinking was shaped by ideas from the hypermedia community. <p> Nodes are eligible for execution whenever they have a token on each of their input ports, and during execution a node places tokens on its output ports. SPG execution is thus similar to execution of a variety of other graph structures, including Petri nets, flow graphs for dataflow languages <ref> [9, 8] </ref>, and the Plan Calculus. The topology of an SPG is essentially static during program execution, but the presence of conditions on destination branches means that the set of branches along which tokens may flow is determined dynamically. <p> A subprogram instantiation completes execution when a node within the instantiation and possessing an annotation named Return (a return node) completes execution. One 10 This is an operational semantics, not an implementation directive. Techniques exist to avoid actually making a copy while still obeying the required semantics <ref> [9] </ref>. In this thesis, however, I discuss grouping instantiations as if they were always implemented by making a physical copy of an SPG subgraph. 102 CHAPTER 4.
Reference: [10] <author> E. A. Ashcroft and W. W. Wadge, </author> <title> "Lucid, a Nonprocedural Language with Iteration," </title> <journal> Communications of the ACM, </journal> <volume> vol. 20, no. 7, </volume> <pages> pp. 519-526, </pages> <month> July </month> <year> 1977. </year> <note> 268 BIBLIOGRAPHY 269 </note>
Reference-contexts: In particular, parallel execution of subexpressions is limited only by data dependencies, and subprogram calls are non-strict. Examples of this approach to computation include the languages Id [9], Haskell [83], and Lucid <ref> [10, 215] </ref>. Dataflow is also the basis of a number of high-level design methodologies, e.g., Structured Analysis [177, 178]. * The final paradigm is parallel control flow computing, which offers software developers explicit control over the creation of multiple processes and the communication between those processes as they run.
Reference: [11] <author> Robert A. Ballance, Susan L. Graham, and Michael L. Van De Vanter, </author> <title> "The Pan Language-Based Editing System for Integrated Development Environments," </title> <booktitle> in Proceedings of the Fourth ACM SIGSOFT Symposium on Software Development Environments (SIGSOFT '90) (Richard N. </booktitle> <publisher> Taylor, ed.), </publisher> <pages> pp. 77-93, </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1990. </year> <note> Published as ACM SIGSOFT Software Engineering Notes 15:6, </note> <month> December </month> <year> 1990. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan <ref> [11] </ref> PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]]
Reference: [12] <author> Robert A. Ballance, Arthur B. Maccabe, and Karl J. Ottenstein, </author> <title> "The Program Dependence Web: A Representation Supporting Control-, Data-, and Demand-Driven Interpretation of Imperative Languages," </title> <booktitle> in Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 257-271, </pages> <month> June </month> <year> 1990. </year> <note> Published as ACM SIGPLAN Notices 25:6, </note> <month> June </month> <year> 1990. </year>
Reference-contexts: In addition, PDGs so far lack efficient incremental algorithms for common operations in an interactive environment, such as adding a statement to a program under construction. There are many derivatives of PDGs, including program representation graphs [224], program dependence webs <ref> [12] </ref>, system dependence graphs for interprocedural slicing [94], and unified interprocedural graphs [82]. Research into hypermedia representations of system information has resulted in mechanisms for storing data that is similar to SPGs. For example, the Hypertext Abstract Machine (HAM) [35] used in Neptune [50] has a resemblance to SPGs.
Reference: [13] <author> Naser S. Barghouti and Gail E. Kaiser, </author> <title> "Concurrency Control in Advanced Database Applications," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 23, no. 3, </volume> <pages> pp. 269-317, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Therefore, it may be possible to adapt the research done on flexible transaction models <ref> [187, 13, 228, 143] </ref> to the particular needs of multiple-view software development environments.
Reference: [14] <author> Dilip K. Barman, "RelType: </author> <title> Relaxed Typing for Intelligent Hypermedia Representations," </title> <type> Technical Report CS-91-26, </type> <institution> Brown University Department of Computer Science, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] <ref> [Typed Hypermedia [43, 14] </ref>] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views. <p> Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia <ref> [43, 14] </ref>] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views.
Reference: [15] <author> J. G. P. Barnes, </author> <booktitle> Programming in Ada. International Computer Science Series, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1982. </year>
Reference: [16] <editor> David R. Barstow, Howard E. Shrobe, and Erik Sandewall, eds., </editor> <title> Interactive Programming Environments. </title> <publisher> McGraw-Hill, </publisher> <year> 1984. </year>
Reference: [17] <author> Friedrich Ludwig Bauer, Bernhard Moller, Helmut Partsch, and Peter Pepper, </author> <title> "Formal Program Construction by Transformations - Computer-Aided, </title> <journal> Intuition-Guided Programming," IEEE Transactions on Software Engineering, </journal> <volume> vol. 15, no. 2, </volume> <pages> pp. 165-180, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L <ref> [17] </ref> Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. <p> multiparadigm languages Loops [22, 195], Daisy II [62], Leda [33], and G-2 [157]; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors as a basis for concurrent programming [1]; the CODE system for developing parallel applications [32]; the wide-spectrum languages V [188], CIP-L <ref> [17] </ref>, and PLEASE [209]; and the work by Zave and Jackson on formally composing partial specifications [227]. 2.4.2 MVDEs Not Using a Canonical Representation Table 2-3 summarizes research into MVDEs that achieve integration by a mechanism other than a shared canonical representation.
Reference: [18] <author> Boris Beizer, </author> <title> Software Testing Techniques. </title> <publisher> Van Nostrand Reinhold, </publisher> <year> 1990. </year>
Reference-contexts: A number of approaches to software testing have been proposed, along with an even greater number of metrics for measuring the effectiveness of the different approaches <ref> [18, 175] </ref>, but in practice, most software developers who formally test their software 6 rely on relatively simple structural testing criteria, such 6 Those who do not may have good reason.
Reference: [19] <author> L. A. Belady and M. M. Lehman, </author> <title> "A Model of Large Program Development," </title> <journal> IBM Systems Journal, </journal> <volume> no. 3, </volume> <pages> pp. 225-252, </pages> <year> 1976. </year>
Reference-contexts: However, it is also in agreement with the rigorous empirical examination of system evolution undertaken by Belady and Lehman <ref> [19] </ref>. Their first two laws of Program Evolution Dynamics the law of continuing change and the law of increasing entropy neatly summarize the common informal observation that systems tend to change, and as they change, they tend to become less integrated.
Reference: [20] <author> M. Ben-Ari, </author> <title> Principles of Concurrent and Distributed Programming. </title> <publisher> Prentice Hall International Series in Computer Science, Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Views that correspond to this paradigm frequently contain all of the features of sequential control flow views, plus additional features for the expression of parallelism and interprocess communication. 4 Such views include the programming languages CSP [87], Ada, Concurrent Pascal [27], and Oc-cam <ref> [20] </ref>, as well as the more abstract languages of Statecharts [79], nondeterministic FSAs, and Petri nets. I selected these paradigms as the basis for my view model for two reasons. First, they collectively encompass a great number of views that are currently in widespread use. <p> This is an example of a situation in which the CR must provide explicit support for a language feature that is otherwise too primitive for inclusion simply because the feature is widely used. Fortunately, it is a simple matter to simulate semaphore behavior using monitors <ref> [20, p. 65-66] </ref>, so semantic support for semaphore behavior calls for no special provision in the CR. <p> For views arising from the dataflow and parallel control-flow paradigms, however, this is not necessarily the case. Consider the following two Occam commands (based on sample code in Ben-Ari's book <ref> [20, p. 108] </ref>), each of which consists of two statements to be executed in parallel: PAR PAR south ! x east ? sum east ? sum south ! x These two commands can be represented by the same SPG, because they have identical semantics. <p> Describing Ada, Ben-Ari notes that "Syntactically, an entry is exactly like a procedure declaration. This is done on purpose to allow substitution of a concurrent entry for a sequential procedure without otherwise changing a program" <ref> [20, p. 89] </ref>. 68 CHAPTER 4. <p> buffer end insert; count := count + 1; or when count &gt; 0 =&gt; accept remove (item: out Integer) do -- remove an object from the buffer and assign it to item end remove; count := count - 1; end select; end loop; end BBuffer; based on one by Ben-Ari <ref> [20, pp. 89-92] </ref>. <p> It is often convenient to specify that an edge will put a copy of a token on each of its destination branches, regardless of the number of such branches. This is, for example, the semantics of Dijkstra's parbegin/parend construct [52] and Occam's PAR directive <ref> [20] </ref>. Such edges are called NP a (all ) edges. NP a edges are more convenient for this purpose than are NP n edges (for some fixed n), because the number of destination branches emanating from an edge may change as an SPG is edited. <p> The representation of semaphores is problematic because they are at once too ubiquitous to ignore and too low-level to fit into the STask framework I employ in SPGs. Fortunately, the semantics of semaphores can be easily achieved using either monitors or Ada tasks <ref> [20] </ref>, and the mapping between these mechanisms and STasks is, as I have shown, straightforward. Providing the correct execution-time behavior for semaphores, then, is not a challenging problem. <p> One possibility would be to rely on naming conventions for entries of STasks emulating semaphores. For example, an STask with entries named "P" and "V" might be assumed to represent a semaphore. Approaches based on naming conventions are rarely reliable, however. For example, Ben-Ari <ref> [20] </ref> eschews P and V in favor of "Wait" and "Signal," while Grunwald [75] employs the terms "reserve" and "release." I therefore employ an approach in SPGs that admits of no ambiguity. <p> This code is modeled on that found in Ben-Ari's book <ref> [20] </ref>. In the interest of brevity, with and use directives have been omitted. 196 APPENDIX A. <p> This code is modeled on that found in Ben Ari's book <ref> [20] </ref>. In the interest of brevity, with and use directives have been omitted. A.2. MAPPING BETWEEN ADA TASKS AND SPGS 197 Figure A-7: A high-level SPG for the Ada producer-consumer program.
Reference: [21] <author> W. J. Black, A. G. Sutcliffe, P. Loucopoulos, and P. J. Layzell, </author> <title> "Translation Between Pragmatic Software Development Methods," </title> <booktitle> in Lecture Notes in Computer Science 289 (H. </booktitle> <editor> K. Nichols and D. Simpson, </editor> <booktitle> eds.), </booktitle> <pages> pp. 357-365, </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1987. </year> <booktitle> Proceedings of the 1st European Software Engineering Conference, held in Strasbourg, </booktitle> <address> France. </address>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus <ref> [21] </ref> CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution.
Reference: [22] <author> Daniel G. Bobrow and Mark J. Stefik, </author> <title> The Loops Manual. </title> <institution> Xerox Corporation, Palo Alto, California, </institution> <year> 1983. </year>
Reference-contexts: A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops <ref> [22, 195] </ref> PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages. <p> <ref> [22, 195] </ref> PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages. Other multiparadigm work includes Zave's research into composing different independent paradigms [226]; the explicitly multiparadigm languages Loops [22, 195], Daisy II [62], Leda [33], and G-2 [157]; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors as a basis for concurrent programming [1]; the CODE system for developing parallel applications [32]; the wide-spectrum languages V [188], CIP-L [17], and PLEASE [209];
Reference: [23] <author> Grady Booch, </author> <title> Object Oriented Design with Applications. </title> <booktitle> The Benjamin/Cummings Series in Ada and Software Engineering, </booktitle> <address> Benjamin/Cummings, </address> <year> 1991. </year> <note> 270 BIBLIOGRAPHY </note>
Reference-contexts: One need only note the plethora of more or less "standard" views to understand that multiple-view software development is already the rule in practice. Common views include source code, flowcharts, call graphs, program profiles, class hierarchies, Petri nets , statecharts, dataflow diagrams, state transition networks, object graphs <ref> [23] </ref>, module interconnection diagrams, algorithm animations, test coverage analyses, dependency graphs, debuggers, program slices, and many others. Environment support for program development has traditionally focused on textual depictions of programs | usually source code | but it's important to note the increasing interest in nonlinear programming languages. <p> The most interesting aspect of Figure 6-11 is that the classes in the hierarchy above the PM classes are abstract. That is, they may declare data and/or functions that are inherited by subclasses, but they themselves may not be instantiated <ref> [23] </ref>. The functionality present in the Graphical View class, for example, cannot stand on its own. It must be coupled with the additional functionality provided by either the GELO PM class or the statechart PM class before it can be used.
Reference: [24] <author> P. Borras, D. Clement, Th. Despeyroux, J. Incerpi, G. Kahn, B. Lang, and V. Pas-cual, </author> <title> "CENTAUR: the System," </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 14-24, </pages> <publisher> ACM Press, </publisher> <month> November </month> <year> 1988. </year> <note> Published as ACM SIGSOFT Software Engineering Notes 13:5, </note> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices 24:2, </journal> <month> February </month> <year> 1989. </year>
Reference-contexts: As noted in Section 2.2.5, the most common representation investigated has been the abstract syntax tree (AST). ASTs are at the core of many well-known programming environments, including the Cornell Program Synthesizer [168], Gandalf [78], Pecan [163], R n [89], MENTOR [53], and CENTAUR <ref> [24] </ref>. The centerpiece of these environments is a language-based editor, which usually offers incremental syntactic and semantic analysis of the program being edited, plus incremental code generation. An AST is an excellent 7 If interesting events could be automatically generated for a program, animation views would quite interesting indeed. <p> Nonetheless, the practical problem of coming up with the interesting events that drive an animation should not be underestimated. 30 CHAPTER 2. APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur <ref> [24] </ref> Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer
Reference: [25] <author> Gerard Boudier, Ferdinando Gallo, Regis Minot, and Ian Thomas, </author> <title> "An Overview of PCTE and PCTE+," </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Hen-derson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 248-257, </pages> <publisher> ACM Press, </publisher> <month> November </month> <year> 1988. </year> <note> Published as ACM SIGSOFT Software Engineering Notes 13:5, </note> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices 24:2, </journal> <month> February </month> <year> 1989. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC <ref> [25, 57] </ref>] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs
Reference: [26] <author> Gary Bray and David Pokrass, </author> <title> Understanding Ada. </title> <publisher> John Wiley & Sons, </publisher> <year> 1985. </year>
Reference: [27] <author> P. Brinch-Hansen, </author> <title> "The Programming Language Concurrent Pascal," </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pp. 199-207, </pages> <month> June </month> <year> 1975. </year> <note> Reprinted in [92, pp. 302-310]. </note>
Reference-contexts: Views that correspond to this paradigm frequently contain all of the features of sequential control flow views, plus additional features for the expression of parallelism and interprocess communication. 4 Such views include the programming languages CSP [87], Ada, Concurrent Pascal <ref> [27] </ref>, and Oc-cam [20], as well as the more abstract languages of Statecharts [79], nondeterministic FSAs, and Petri nets. I selected these paradigms as the basis for my view model for two reasons. First, they collectively encompass a great number of views that are currently in widespread use. <p> end; procedure entry remove (var item: integer); begin if count = 0 then delay (remover); remove an object from the buffer and assign it to item - count := count - 1; continue (inserter); end; begin "initial statement" count := 0; end This solution is based on one by Brinch-Hansen <ref> [27, p. 307] </ref>. saved in variables and/or passed onto output ports in the remaining two parts of the Accept node, so there is no need to delay the caller once the tokens have arrived at the Accept node.
Reference: [28] <author> Frederick P. Brooks, Jr., </author> <title> "No Silver Bullet: Essence and Accidents of Software Engineering," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 10-19, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: The several graphs may represent the flow of control, the flow of data, patterns of dependency, time sequence, name-space relationships. These graphs are usually not even planar, much less hierarchical <ref> [28, p. 12] </ref>. In recognition of this inherently multi-faceted nature of software, many researchers in the area of software development environments have argued that environments that support only a single view | usually textual source code | are inadequate [121, 113, 124]. <p> This is in all likelihood another example of a general phenomenon: sometimes things that seem hard are just plain hard . Translating between arbitrary views is almost certainly one of these fundamentally difficult tasks, and for such tasks there is, as Fred Brooks has noted, no silver bullet <ref> [28] </ref>. A final observation is that SPGs allow more ambiguity about loop termination conditions than one might prefer. Consider this Pascal loop fragment: for i := 10 to 20 do ...
Reference: [29] <author> Marc H. Brown, </author> <title> Algorithm Animation. </title> <type> Ph.D. thesis, </type> <institution> Brown University Department of Computer Science, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: Another message-based architecture that may seem to support multiple views is embraced by algorithm animation systems based on "interesting events." Some of the best known of such systems are Balsa <ref> [29, 30] </ref>, TANGO [193, 194], and Voyeur [191], but there is a fundamental difference between these kinds of systems and the MVDEs that are the subject of my work: systems based on interesting events cannot provide views of a program until the program is instrumented to produce the interesting events. <p> Modeling data structures is certainly important, and support for data structures could be added to the model I propose here, but that is an aspect of views I have chosen not to address in this thesis. This is analogous to research on systems for algorithm animation <ref> [29, 193] </ref>. Such systems focus entirely on what happens to the data in an application, completely ignoring the control structures within the application that are responsible for generating and manipulating the data.
Reference: [30] <author> Marc H. Brown, </author> <title> "Exploring Algorithms using BALSA-II," </title> <journal> IEEE Computer, </journal> <volume> vol. 21, no. 5, </volume> <pages> pp. 14-36, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: The dynamic aspects of a dynamic view may be simple and straightforward, such as highlighting the routine currently being executed in a graphical call graph, or may be arbitrarily complex, such as a hand-crafted algorithmic animation <ref> [30, 194, 191] </ref>. Some views, such as source code, may be editable. Other views, such as the output from a program profiler, may be inherently read-only. This definition of a view is consistent with that of updatable views in the database world [105]. <p> Another message-based architecture that may seem to support multiple views is embraced by algorithm animation systems based on "interesting events." Some of the best known of such systems are Balsa <ref> [29, 30] </ref>, TANGO [193, 194], and Voyeur [191], but there is a fundamental difference between these kinds of systems and the MVDEs that are the subject of my work: systems based on interesting events cannot provide views of a program until the program is instrumented to produce the interesting events.
Reference: [31] <author> Marc H. Brown, "Zeus: </author> <title> A System for Algorithm Animation and Multi-view Editing," </title> <type> Technical Report 75, </type> <institution> DEC Systems Research Center, Palo Alto, California, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: Similarly, much work has been done on translating between different views of data structures without much regard for how those structures are manipulated by the programs in which they find themselves <ref> [85, 69, 102, 126, 217, 201, 31, 222] </ref>. Thus, a model of how a program is structured and how it executes can be largely divorced from the data structures it manipulates.
Reference: [32] <author> J. C. Browne, Muhammad Azam, and Stephen Sobek, </author> <title> "CODE: A Unified Approach to Parallel Programming," </title> <journal> IEEE Software, </journal> <pages> pp. 10-18, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE <ref> [32] </ref> (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages. <p> composing different independent paradigms [226]; the explicitly multiparadigm languages Loops [22, 195], Daisy II [62], Leda [33], and G-2 [157]; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors as a basis for concurrent programming [1]; the CODE system for developing parallel applications <ref> [32] </ref>; the wide-spectrum languages V [188], CIP-L [17], and PLEASE [209]; and the work by Zave and Jackson on formally composing partial specifications [227]. 2.4.2 MVDEs Not Using a Canonical Representation Table 2-3 summarizes research into MVDEs that achieve integration by a mechanism other than a shared canonical representation.
Reference: [33] <author> Timothy A. Budd, </author> <title> "Multiparadigm Data Structures in Leda," </title> <booktitle> in Proceedings of the International Conference on Computer Languages, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda <ref> [33] </ref> Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages. <p> Other multiparadigm work includes Zave's research into composing different independent paradigms [226]; the explicitly multiparadigm languages Loops [22, 195], Daisy II [62], Leda <ref> [33] </ref>, and G-2 [157]; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors as a basis for concurrent programming [1]; the CODE system for developing parallel applications [32]; the wide-spectrum languages V [188], CIP-L [17], and PLEASE [209]; and the work by Zave and
Reference: [34] <author> M. Cagan, </author> <title> "The HP SoftBench Environment: An Architecture for a New Generation of Software Tools," </title> <journal> Hewlett-Packard Journal, </journal> <month> June </month> <year> 1990. </year>
Reference-contexts: Environments based on message passing fall into two basic camps. Environments following the FIELD model of Section 2.2.2 include, in addition to FIELD itself, the commercial implementations SOFTBENCH <ref> [34] </ref>, FUSE [51], ToolTalk [202], and CASEVision/Workshop, 6 as well as the research efforts Forest [67], ISM [176], and the work on Mediators [200]. Forest extends the FIELD model by adding support for policies, which offer flexible user-defined control over the conditions under which messages are passed. <p> APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH <ref> [34] </ref> [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution.
Reference: [35] <author> Brad Campbell and Joseph M. Goodman, </author> <title> "HAM: A General Purpose Hypertext Abstract Machine," </title> <journal> Communications of the ACM, </journal> <volume> vol. 31, no. 7, </volume> <pages> pp. 856-861, </pages> <month> July </month> <year> 1988. </year> <title> [36] "The CASE Interoperability Message Sets: Release 1.0." </title> <institution> Published by Digital Equipment Corporation, Silicon Graphics, Inc., and SunSoft (A Sun Microsystems Company), </institution> <month> October </month> <year> 1992. </year> <note> BIBLIOGRAPHY 271 </note>
Reference-contexts: Research into hypermedia representations of system information has resulted in mechanisms for storing data that is similar to SPGs. For example, the Hypertext Abstract Machine (HAM) <ref> [35] </ref> used in Neptune [50] has a resemblance to SPGs. The HAM offers graphs, contexts, nodes, links, and attributes; contexts are used to partition data in graphs, and their functionality can be realized using node/link attributes and filtering predicates.
Reference: [37] <editor> Shi-Kuo Chang, ed., </editor> <booktitle> Principles of Visual Programming Systems. </booktitle> <address> Englewood Cliffs, New Jersey: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: I am concerned with issues that affect both single-developer endeavors (programming-in-the-small) as well as projects arising from teams of developers (programming-in-the-large). 4 CHAPTER 1. INTRODUCTION by Shu [185] and Chang <ref> [37] </ref>; and the proceedings of the IEEE workshops on visual languages (held in 1984 and annually since 1986). The result of this interest is that the number and types of views available to software developers is continually increasing. Certainly, then, multiple views are natural.
Reference: [38] <author> Thomas E. Cheatham, Jr., </author> <title> "An Overview of the Harvard Program Development System," in Software Engineering Environments (H. Hunke, </title> <editor> ed.), </editor> <publisher> North-Holland, </publisher> <year> 1981. </year>
Reference-contexts: FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS <ref> [38] </ref> RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. Evolution is an important topic, but, as noted in Section 2.1, one not directly addressed by my work in this thesis.
Reference: [39] <author> Yih-Farn Chen, Michael Y. Nishimoto, and C. V. Ramamoorthy, </author> <title> "The C Information Abstraction System," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 16, no. 3, </volume> <pages> pp. 325-334, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA <ref> [39] </ref> COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. <p> For my work, a view of a system is of no interest unless it can be generated without requiring modifications to the system being worked on. 7;8 Several environments have been developed that store information about programs in a relational database, e.g., OMEGA [121], CIA and CIA++ <ref> [39, 73] </ref>, and XREFDB [118]. In each case, however, the goal of the effort has been to answer queries about static programs, not to provide communication between views of dynamically changing systems.
Reference: [40] <author> Lori A. Clarke, Debra J. Richardson, and Steven J. Zeil, </author> <title> "TEAM: A Support Environment for Testing, Evaluation, and Analysis," </title> <booktitle> in Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 153-162, </pages> <publisher> ACM Press, </publisher> <month> November </month> <year> 1988. </year> <note> Published as ACM SIGSOFT Software Engineering Notes 13:5, </note> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices 24:2, </journal> <month> February </month> <year> 1989. </year>
Reference-contexts: System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM <ref> [40] </ref> Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views. <p> In fact, none of the environments mentioned above allows programmers to define new views. Similar difficulties arise with program representations based on abstract syntax graphs, such as those used in IPSEN [139], the Maintainer's Assistant [158] and TEAM <ref> [40] </ref>. The Programmer's Apprentice project [172, 173] has employed the Plan Calculus [170] for a variety of systems. The Plan Calculus is a graph-based representation for programs that incorporates both control- and dataflow information.
Reference: [41] <author> Geoffrey Clemm and Leon Osterweil, </author> <title> "A Mechanism for Environment Integration," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 12, no. 1, </volume> <pages> pp. 1-25, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: For example, database constraints could be used to perform a function similar to the Unix make program, thus ensuring that the executable version of a system is constructed from the most recent sources. This is in fact the underlying basis for Odin's Derivative Forest <ref> [41] </ref>, which is a generalized mechanism for indicating how objects are produced from one another. <p> [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin <ref> [41] </ref> OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. <p> These chunks are then stored in whatever form the database supports, e.g., relations in the case of OMEGA, objects in the case of MicroScope [6]. Some database-centered environments, such as Trellis [147] and Odin <ref> [41] </ref>, use larger-grained chunks, possibly as large as entire files of source and object code.
Reference: [42] <author> CASE Communique, </author> <title> "Achieving Agreement." Published by Hewlett-Packard, IBM, Informix, and Control Data Corporation, </title> <month> June </month> <year> 1992. </year> <note> This document is revised on an ongoing basis. </note>
Reference-contexts: Independent of this committee, two different message standards have been published <ref> [42, 36] </ref>. The proponents of these documents are working with X3H6, but it is difficult to avoid recalling the maxim that the nice thing about standards is that there are so many to choose from. 2.2.
Reference: [43] <author> Jeff Conklin, </author> <title> "Hypertext: An Introduction and Survey," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 17-41, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia <ref> [43, 14] </ref>] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views. <p> I also took ideas from the Tagged-Token Dataflow Architecture [9], most notably in the area of support for non-strict subprogram calls. My approach to unexecutable information is based on concepts underlying hypermedia systems <ref> [43] </ref>, and my use of hypergraphs instead of conventional graphs is a direct reflection of how my thinking was shaped by ideas from the hypermedia community.
Reference: [44] <author> Richard Conway, Dan DeJohn, and Steve Worona, </author> <title> "A User's Guide to the COPE Programming Environment," </title> <type> Technical Report TR 84-599, </type> <institution> Cornell University Computer Science Department, </institution> <month> April </month> <year> 1984. </year>
Reference-contexts: The COPE environment <ref> [44] </ref>, however, was a novel experiment in that the responsibility for ensuring that a program was always grammatically valid fell on the environment , not the user. 8 CHAPTER 1. INTRODUCTION with the call graph and stack view explicitly shown. 5.
Reference: [45] <author> Doug Cooper, </author> <title> Standard Pascal. </title> <editor> W. W. </editor> <publisher> Norton & Company, </publisher> <year> 1983. </year>
Reference: [46] <author> Rene David and Hassane Alla, </author> <title> Petri Nets & Grafcet: Tools for Modelling Discrete Event Systems. </title> <publisher> Prentice Hall International, </publisher> <year> 1992. </year>
Reference-contexts: This has the advantage of differentiating between components of SPGs and Petri nets, because the former have edges, the latter, arcs. 2 There is a recognized class of Petri nets that correspond to this restriction: safe (or binary) Petri nets <ref> [46] </ref>. Such nets never contain more than one token per place. Petri net SPG Table A-1: A simple mapping from a Petri net to an SPG. 189 190 APPENDIX A.
Reference: [47] <author> Alan M. Davis, </author> <title> "A Comparison of Techniques for the Specification of External System Behavior," </title> <journal> Communications of the ACM, </journal> <volume> vol. 31, no. 9, </volume> <pages> pp. 1098-1115, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Examples of this less conventional approach to software development include structured analysis [177], Fabrik [97], statecharts, grids [149, 150], and graphical interfaces to conventional languages [55]. Further examples can be found in the surveys by Raeder [160], Myers [138], and Davis <ref> [47] </ref>; the introductory books 1 The question is still open in the field of object-oriented databases, however [184, 86]. 2 For the purposes of this thesis, the terms "programming environments," "software development environments," "software engineering environments," etc., are all synonyms.
Reference: [48] <author> Ruth E. Davis, </author> <title> "Logic Programming and Prolog: A Tutorial," </title> <journal> IEEE Software, </journal> <month> September </month> <year> 1985. </year>
Reference: [49] <author> Norman M. Delisle, David E. Menicosy, and Mayer D. Schwartz, </author> <title> "Viewing a Programming Environment as a Single Tool," </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pp. 49-56, </pages> <month> April </month> <year> 1984. </year> <note> Published as ACM SIGSOFT Software Engineering Notes 9:3, </note> <month> May </month> <year> 1984, </year> <journal> and ACM SIGPLAN Notices 19:5, </journal> <month> May </month> <year> 1984. </year> <note> 272 BIBLIOGRAPHY </note>
Reference-contexts: Nonetheless, the practical problem of coming up with the interesting events that drive an animation should not be underestimated. 30 CHAPTER 2. APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie <ref> [49] </ref> MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]]
Reference: [50] <author> Norman M. Delisle and Mayer Schwartz, "Neptune: </author> <title> A Hypertext System for CAD Applications," </title> <booktitle> in Proceedings of SIGMOD '86, the International Conference on Management of Data, </booktitle> <pages> pp. 132-139, </pages> <publisher> ACM, </publisher> <month> May </month> <year> 1986. </year>
Reference-contexts: Research into hypermedia representations of system information has resulted in mechanisms for storing data that is similar to SPGs. For example, the Hypertext Abstract Machine (HAM) [35] used in Neptune <ref> [50] </ref> has a resemblance to SPGs. The HAM offers graphs, contexts, nodes, links, and attributes; contexts are used to partition data in graphs, and their functionality can be realized using node/link attributes and filtering predicates. Significantly | and unlike SPGs | the hypergraph itself has no semantics.
Reference: [51] <institution> Digital Equipment Corporation, Maynard, Massachusetts, DEC FUSE for ULTRIX, </institution> <month> March </month> <year> 1991. </year> <title> Order number AA-PF4TA-TE. </title>
Reference-contexts: Environments based on message passing fall into two basic camps. Environments following the FIELD model of Section 2.2.2 include, in addition to FIELD itself, the commercial implementations SOFTBENCH [34], FUSE <ref> [51] </ref>, ToolTalk [202], and CASEVision/Workshop, 6 as well as the research efforts Forest [67], ISM [176], and the work on Mediators [200]. Forest extends the FIELD model by adding support for policies, which offer flexible user-defined control over the conditions under which messages are passed. <p> APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE <ref> [51] </ref> Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147]
Reference: [52] <author> E. W. Dijkstra, </author> <title> "Cooperating Sequential Processes," </title> <type> Technical Report EWD-123, </type> <institution> Technological University, Eindhoven, </institution> <address> The Netherlands, </address> <year> 1965. </year> <note> Reprinted in [68, pp. 43-112]. </note>
Reference-contexts: It is often convenient to specify that an edge will put a copy of a token on each of its destination branches, regardless of the number of such branches. This is, for example, the semantics of Dijkstra's parbegin/parend construct <ref> [52] </ref> and Occam's PAR directive [20]. Such edges are called NP a (all ) edges. NP a edges are more convenient for this purpose than are NP n edges (for some fixed n), because the number of destination branches emanating from an edge may change as an SPG is edited.
Reference: [53] <author> Veronique Donzeau-Gouge, Gerard Huet, Gilles Kahn, and Bernard Lang, </author> <title> "Programming Environments Based on Structured Editors: The MENTOR Experience," in Interactive Programming Environments (David R. </title> <editor> Barstow, Howard E. Shrobe, and Erik Sandewall, eds.), ch. </editor> <volume> 7, </volume> <pages> pp. 128-140, </pages> <publisher> McGraw-Hill, </publisher> <year> 1984. </year>
Reference-contexts: As noted in Section 2.2.5, the most common representation investigated has been the abstract syntax tree (AST). ASTs are at the core of many well-known programming environments, including the Cornell Program Synthesizer [168], Gandalf [78], Pecan [163], R n [89], MENTOR <ref> [53] </ref>, and CENTAUR [24]. The centerpiece of these environments is a language-based editor, which usually offers incremental syntactic and semantic analysis of the program being edited, plus incremental code generation. <p> Nonetheless, the practical problem of coming up with the interesting events that drive an animation should not be underestimated. 30 CHAPTER 2. APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR <ref> [53] </ref> MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112])
Reference: [54] <author> Carolyn K. Duby, Scott Meyers, and Steven P. Reiss, "CCEL: </author> <title> A Metalanguage for C++," </title> <booktitle> in USENIX C++ Conference Proceedings, </booktitle> <month> August </month> <year> 1992. </year> <note> Also available as Brown University Computer Science Department Technical Report CS-92-51, </note> <month> October </month> <year> 1992. </year>
Reference-contexts: I also began a joint effort with Carolyn K. Duby and Steven P. Reiss on the design and implementation of a metalanguage for C++ programs that allowed programmers to specify a wide range of application-specific constraints such that violations of the constraints would be automatically detected <ref> [54, 132] </ref>. The resulting metalanguage, CCEL (the C++ Constraint Expression Language), has since grown into an independent and ongoing research project in its own right. 6.8. <p> Reiss and I then collaborated on the design and implementation of a new language that would allow C++ programmers to define custom constraints on their C++ programs and have a system automatically ensure that the constraints were not violated. Our initial reports on this system were published as follows <ref> [54, 132] </ref>: * Carolyn K. Duby, Scott Meyers, and Steven P. Reiss, "CCEL: A Metalanguage for C++," in USENIX C++ Conference Proceedings, August 1992. APPENDIX C. SPG-RELATED PUBLICATIONS 267 * Scott Meyers, Carolyn K. Duby, and Steven P.
Reference: [55] <author> Mark Edel, </author> <title> "The Tinkertoy Graphical Programming Environment," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 14, no. 8, </volume> <pages> pp. 1110-1115, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Examples of this less conventional approach to software development include structured analysis [177], Fabrik [97], statecharts, grids [149, 150], and graphical interfaces to conventional languages <ref> [55] </ref>.
Reference: [56] <author> Mike Carey et. al, </author> <title> "The EXODUS Extensible DMBS Project: An Overview," in Readings in Object-Oriented Databases (Stanley B. </title> <editor> Zdonik and David Maier, eds.), </editor> <publisher> Morgan-Kaufmann, </publisher> <year> 1989. </year>
Reference-contexts: In that case, the description of the canonical representation becomes the schema for the database. Finding ways to specify such schemata and to efficiently implement them is an active area of database research, and is one of the primary motivational forces behind research into object-oriented databases <ref> [91, 56] </ref>. 24 CHAPTER 2. APPROACHES TO VIEW INTEGRATION Criterion Shared File System Message Passing Simple DB View Oriented DB Canonical Rep.
Reference: [57] <author> Standard ECMA-149: </author> <title> Portable Common Tool Environment (PCTE) Abstract Specification. </title> <booktitle> European Computer Manufacturers Association, </booktitle> <address> Geneva, Switzerland, </address> <month> De-cember </month> <year> 1990. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] <ref> [PCTE IPC [25, 57] </ref>] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table <p> APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC <ref> [25, 57] </ref>] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs
Reference: [58] <author> Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren, </author> <title> "The Program Dependence Graph and Its Use in Optimization," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 9, no. 3, </volume> <pages> pp. 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Rich and Waters, the primary architects of the Programmer's Apprentice project, suggest that the Plan Calculus would be well-suited to supporting multiple interacting views, but they have so far chosen not to pursue this avenue of research [172]. Program dependence graphs <ref> [58] </ref> were originally developed as a way to facilitate code optimization and/or parallelization, but since then they have found favor in a variety of 2.5. CONCLUSIONS 31 applications, including interactive code restructuring [74] and integration of program variants [93].
Reference: [59] <author> A. Finkelstein, D. Gabbay, A. Hunter, J. Kramer, and B. Nuseibeh, </author> <title> "Inconsistency Handling in Multi-Perspective Specifications." </title> <note> Draft paper of November 18, </note> <year> 1992. </year>
Reference-contexts: Instead, I focus my efforts on the equally compelling problems associated with integrating divergent views. 1 Not everyone agrees with this sentiment. Finkelstein and his colleagues, for example, argue that maintaining consistency during software development is sometimes neither possible nor desirable <ref> [59] </ref>. 2.2. FIVE APPROACHES TO INTEGRATION 15 2.2 Five Approaches to Integration In the sections that follow, I examine five approaches to MVDE integration. The first approach represents very loose integration and corresponds to common state-of-the-practice today.
Reference: [60] <author> A. Finkelstein, J. Kramer, B. Nuseibeh, L. Finkelstein, and M. Goedicke, </author> <title> "Viewpoints: A Framework for Integrating Multiple Perspectives in System Development," </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> vol. 2, no. 1, </volume> <pages> pp. 31-58, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] <ref> [ViewPoints [145, 60] </ref>] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. <p> APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints <ref> [145, 60] </ref>] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. <p> Message senders need not explicitly state who is to receive a message, and in fact the set of recipients is typically determined dynamically. A very different message-based architecture is predicated on sets of hardwired mappings between views. Examples of such systems include Prisma [142] and ViewPoints <ref> [145, 60] </ref>. Each of these systems supports multiple independent views, but each also relies on environment developers to write bidirectional mappings between views that are to be kept consistent.
Reference: [61] <author> C. N. Fischer, Gregory F. Johnson, Jon Mauney, Anil Pal, and Daniel L. </author> <title> Stock, "The Poe Language-Based Editor Project," </title> <booktitle> in Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <month> May </month> <year> 1984. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe <ref> [61] </ref> Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]]
Reference: [62] <author> Gene Fisher, </author> <title> "An Overview of a Graphical Multilanguage Applications Environment," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 14, no. 6, </volume> <pages> pp. 774-786, </pages> <month> June </month> <year> 1988. </year> <note> BIBLIOGRAPHY 273 </note>
Reference-contexts: A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II <ref> [62] </ref> Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages. <p> Other multiparadigm work includes Zave's research into composing different independent paradigms [226]; the explicitly multiparadigm languages Loops [22, 195], Daisy II <ref> [62] </ref>, Leda [33], and G-2 [157]; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors as a basis for concurrent programming [1]; the CODE system for developing parallel applications [32]; the wide-spectrum languages V [188], CIP-L [17], and PLEASE [209]; and the work by
Reference: [63] <author> Joan M. Francioni, Larry Albright, and Jay Alan Jackson, </author> <title> "Debugging Parallel Programs Using Sound," </title> <booktitle> in Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. 68-75, </pages> <month> May </month> <year> 1991. </year> <note> Published as ACM SIGPLAN Notices 26:12, </note> <month> December </month> <year> 1991. </year>
Reference-contexts: Presentations may manifest themselves textually (e.g., traditional source code), graphically (e.g., a traditional call graph), through unconventional media (e.g., aurally <ref> [96, 63, 125] </ref>), or, frequently, some combination of these. The relationships among an information source for a software system, a view of that system, presentations of that view, and software developers is summarized in Figure 1-1.
Reference: [64] <author> Ferdinando Gallo, Regis Minot, and Iat Thomas, </author> <title> "The Object Management System of PCTE as a Software Engineering Database Management System," </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 12-15, </pages> <month> December </month> <year> 1986. </year> <note> Published as ACM SIGPLAN Notices 22:1, </note> <month> January </month> <year> 1987. </year>
Reference-contexts: Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS <ref> [64] </ref>] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. Evolution is an important topic, but, as noted in Section 2.1, one not directly addressed by my work in this thesis.
Reference: [65] <author> David Garlan, </author> <title> "Views for Tools in Integrated Environments," </title> <booktitle> in Proceedings of the 1986 International Workshop on Advanced Programming Environments, </booktitle> <year> 1986. </year>
Reference-contexts: David Garlan studied this problem, and his solution to the impasse was to design a mechanism whereby different tools use different representations ("views") for data in the database, but data shared between views is automatically kept consistent by the DBMS <ref> [65, 66] </ref>. In Garlan's words, "a view is a virtual description of the common database, defined in such a way that objects can be shared among a collection of tools, each tool accessing objects through the views it defines. <p> [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan <ref> [65, 66] </ref>) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. Evolution is an important topic, but, as noted in Section 2.1, one not directly addressed by my work in this thesis.
Reference: [66] <author> David Garlan, </author> <title> Views for Tools in Integrated Environments. </title> <type> Ph.D. thesis, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: David Garlan studied this problem, and his solution to the impasse was to design a mechanism whereby different tools use different representations ("views") for data in the database, but data shared between views is automatically kept consistent by the DBMS <ref> [65, 66] </ref>. In Garlan's words, "a view is a virtual description of the common database, defined in such a way that objects can be shared among a collection of tools, each tool accessing objects through the views it defines. <p> [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan <ref> [65, 66] </ref>) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. Evolution is an important topic, but, as noted in Section 2.1, one not directly addressed by my work in this thesis.
Reference: [67] <author> David Garlan and Ehsan Ilias, </author> <title> "Low-Cost, Adaptable Tool Integration Policies for Integrated Environments," </title> <booktitle> in Proceedings of the Fourth ACM SIGSOFT Symposium on Software Development Environments (SIGSOFT '90) (Richard N. </booktitle> <publisher> Taylor, ed.), </publisher> <pages> pp. 1-10, </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1990. </year> <note> Published as SIGSOFT Software Engineering Notes 15:6, </note> <month> December </month> <year> 1990. </year>
Reference-contexts: Environments based on message passing fall into two basic camps. Environments following the FIELD model of Section 2.2.2 include, in addition to FIELD itself, the commercial implementations SOFTBENCH [34], FUSE [51], ToolTalk [202], and CASEVision/Workshop, 6 as well as the research efforts Forest <ref> [67] </ref>, ISM [176], and the work on Mediators [200]. Forest extends the FIELD model by adding support for policies, which offer flexible user-defined control over the conditions under which messages are passed. ISM employs a message-based approach to integration, but it has more of an AI perspective to its application. <p> APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest <ref> [67] </ref> FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81]
Reference: [68] <editor> F. Genuys, ed., </editor> <booktitle> Programming Laanguages. </booktitle> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1968. </year>
Reference: [69] <author> P. B. Gibbons, </author> <title> "A Stub Generator for Hultilanguage RPC in Heterogeneous Environments," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-13, no. 1, </volume> <pages> pp. 77-87, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Similarly, much work has been done on translating between different views of data structures without much regard for how those structures are manipulated by the programs in which they find themselves <ref> [85, 69, 102, 126, 217, 201, 31, 222] </ref>. Thus, a model of how a program is structured and how it executes can be largely divorced from the data structures it manipulates.
Reference: [70] <author> Leonard Gilman and Allen J. Rose, </author> <title> APL: An Interactive Approach. </title> <publisher> John Wiley and Sons, </publisher> <year> 1976. </year>
Reference-contexts: These parentheses are absent in a view and should be suppressed by views when generating presentations for users. For example, in most languages, the expression a*b+c is equivalent to (a*b)+c, and this is how a*b+c would be evaluated in a Multiassignment node, too. However, in APL <ref> [70] </ref>, operators are always evaluated right to left, so the APL expression afib+c is evaluated as afi (b+c). 2 To ensure that the SPGM employs the correct semantics when evaluating this expression, the view translating from APL must insert parentheses, even though no parenthesis are present in the view.
Reference: [71] <author> Eric J. Golin and Steven P. Reiss, </author> <title> "Representing Visual Programs with Object-Graphs," </title> <type> Technical Report CS-89-05, </type> <institution> Brown University Department of Computer Science, </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss <ref> [71] </ref>) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages.
Reference: [72] <author> Eric J. Golin, Robert V. Rubin, and James Walker II, </author> <title> "The Visual Programmers Workbench," </title> <booktitle> in Proceedings of IFIP Congress 89, </booktitle> <year> 1989. </year>
Reference-contexts: It is often useful to think of a view as an abstract syntax for a language describing the underlying software system, and of a presentation as a concrete syntax for the language. In 1.2. MULTIPLE VIEWS 3 fact, this is the basic approach of the Visual Programmer's Workbench <ref> [72] </ref>, which supports the creation of language-specific development environments for visual languages. In practice, researchers tend to ignore the differences between views and presentations, generally referring only to "views" unless context forces them to draw an explicit distinction.
Reference: [73] <author> Judith E. Grass and Yih-Farn Chen, </author> <title> "The C++ Information Abstractor," </title> <booktitle> in USENIX C++ Conference Proceedings, </booktitle> <pages> pp. 265-277, </pages> <year> 1990. </year>
Reference-contexts: For my work, a view of a system is of no interest unless it can be generated without requiring modifications to the system being worked on. 7;8 Several environments have been developed that store information about programs in a relational database, e.g., OMEGA [121], CIA and CIA++ <ref> [39, 73] </ref>, and XREFDB [118]. In each case, however, the goal of the effort has been to answer queries about static programs, not to provide communication between views of dynamically changing systems.
Reference: [74] <author> William G. Griswold and David Notkin, </author> <title> "Program Restructuring to Aid Software Maintenance," </title> <type> Technical Report 90-08-05, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <note> September (Revised in December) 1990. </note>
Reference-contexts: Program dependence graphs [58] were originally developed as a way to facilitate code optimization and/or parallelization, but since then they have found favor in a variety of 2.5. CONCLUSIONS 31 applications, including interactive code restructuring <ref> [74] </ref> and integration of program variants [93].
Reference: [75] <author> Dirk Grunwald, </author> <title> "A Users Guide to Awesime: An Object Oriented Parallel Programming and Simulation System," </title> <type> Technical Report CU-CS-552-91, </type> <institution> University of Colorado at Boulder Department of Computer Science, </institution> <month> November </month> <year> 1991. </year> <note> 274 BIBLIOGRAPHY </note>
Reference-contexts: Because they are so primitive, it is tempting to omit them from consideration when designing the IPC mechanisms for a CR, but unfortunately, semaphores continue to be widely used, even in languages of contemporary design <ref> [148, 100, 75] </ref>. As a result, ignoring semaphores is simply unrealistic | they are just too prevalent to pretend that they don't exist. <p> For example, an STask with entries named "P" and "V" might be assumed to represent a semaphore. Approaches based on naming conventions are rarely reliable, however. For example, Ben-Ari [20] eschews P and V in favor of "Wait" and "Signal," while Grunwald <ref> [75] </ref> employs the terms "reserve" and "release." I therefore employ an approach in SPGs that admits of no ambiguity.
Reference: [76] <author> Vincent A. Guarna, Jr., Dennis Gannon, David Jablonowski, Allen D. Malony, and Yogesh Gaur, </author> <title> "Faust: An Integrated Environment for Parallel Programming," </title> <journal> IEEE Software, </journal> <pages> pp. 20-26, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust <ref> [76] </ref> MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution.
Reference: [77] <author> A. Nico Habermann, Charles Krueger, Benjamin Pierce, Barbara Staudt, and John Wenn, </author> <title> "Programming with Views," </title> <type> Technical Report CMU-CS-87-177, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> January </month> <year> 1988. </year>
Reference-contexts: A suitably chosen representation can allow the environment to take 4 Garlan's original compatibility maps were actually somewhat more restrictive, but followup work by Habermann and his colleagues <ref> [77] </ref> has extended them to this level of generality. 2.2. FIVE APPROACHES TO INTEGRATION 23 advantage of incremental algorithms for parsing, code generation, dataflow analysis, and the like [82]. <p> 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus <ref> [77] </ref> Table 2-3: MVDEs not based on a canonical representation. evolution. Evolution is an important topic, but, as noted in Section 2.1, one not directly addressed by my work in this thesis. <p> Some database-centered environments, such as Trellis [147] and Odin [41], use larger-grained chunks, possibly as large as entire files of source and object code. With the exception of minor extensions to compatibility maps by his erstwhile colleagues <ref> [77] </ref>, Garlan's work on view-oriented databases has attracted little follow-up work by the research community. 2.4.3 MVDEs Using a Canonical Representation Table 2-4 summarizes MVDEs that achieve integration by means of a shared canonical representation.
Reference: [78] <author> A. Nico Habermann and David Notkin, </author> <title> "Gandalf: Software Development Environments," </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> December </month> <year> 1986. </year>
Reference-contexts: Experience with AST-based environments has revealed that ASTs are not a flexible enough representation to support a sufficiently wide class of tools. In fact, Garlan's work on view-oriented databases was motivated by difficulties encountered when trying to expand the AST-based Gandalf environment <ref> [78] </ref>. Similarly, Reiss' experience with PECAN [163] led him to conclude that ASTs are particularly poorly suited for nonlinear views of programs, especially graphical views. I suspect that any representation based on syntax will prove to be too limiting, including those based on abstract syntax graphs. <p> As noted in Section 2.2.5, the most common representation investigated has been the abstract syntax tree (AST). ASTs are at the core of many well-known programming environments, including the Cornell Program Synthesizer [168], Gandalf <ref> [78] </ref>, Pecan [163], R n [89], MENTOR [53], and CENTAUR [24]. The centerpiece of these environments is a language-based editor, which usually offers incremental syntactic and semantic analysis of the program being edited, plus incremental code generation. <p> Nonetheless, the practical problem of coming up with the interesting events that drive an animation should not be underestimated. 30 CHAPTER 2. APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf <ref> [78] </ref> Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design
Reference: [79] <author> David Harel, "Statecharts: </author> <title> A Visual Formalism for Complex Systems," </title> <booktitle> Science of Computer Programming, </booktitle> <volume> vol. 8, no. 3, </volume> <pages> pp. 231-274, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: to this paradigm frequently contain all of the features of sequential control flow views, plus additional features for the expression of parallelism and interprocess communication. 4 Such views include the programming languages CSP [87], Ada, Concurrent Pascal [27], and Oc-cam [20], as well as the more abstract languages of Statecharts <ref> [79] </ref>, nondeterministic FSAs, and Petri nets. I selected these paradigms as the basis for my view model for two reasons. First, they collectively encompass a great number of views that are currently in widespread use. Such views include conventional programming languages, call graphs, high-level dataflow diagrams, and Petri nets.
Reference: [80] <author> David Harel, </author> <title> "On Visual Formalisms," </title> <journal> Communications of the ACM, </journal> <volume> vol. 31, no. 5, </volume> <pages> pp. 514-530, </pages> <month> May </month> <year> 1988. </year> <note> See also followup letters in the December 1988, May 1989, and August 1989 issues of Comunications of the ACM. </note>
Reference: [81] <author> William Harrison, </author> <title> "RPDE 3 : A Framework for Integrating Tool Fragments," </title> <journal> IEEE Software, </journal> <pages> pp. 46-56, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 <ref> [81] </ref> Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. Evolution is an important topic, but, as noted in Section 2.1, one not directly addressed by my work in this thesis.
Reference: [82] <author> Mary Jean Harrold and Brian Malloy, </author> <title> "A Unified Interprocedural Program Representation for a Maintenance Environment," </title> <booktitle> in Proceedings of the Conference on Software Maintenance, </booktitle> <pages> pp. 138-147, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: FIVE APPROACHES TO INTEGRATION 23 advantage of incremental algorithms for parsing, code generation, dataflow analysis, and the like <ref> [82] </ref>. Designers of canonical representations typically choose some fundamental data structure for the "core" data, and then allow tool-specific data to be added to the structure in some manner. <p> Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph <ref> [82] </ref>] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views. <p> There are many derivatives of PDGs, including program representation graphs [224], program dependence webs [12], system dependence graphs for interprocedural slicing [94], and unified interprocedural graphs <ref> [82] </ref>. Research into hypermedia representations of system information has resulted in mechanisms for storing data that is similar to SPGs. For example, the Hypertext Abstract Machine (HAM) [35] used in Neptune [50] has a resemblance to SPGs.
Reference: [83] <editor> ACM SIGPLAN Notices, </editor> <volume> vol. 27, no. 5, </volume> <month> May </month> <year> 1992. </year> <note> Special issue on the Haskell programming language. </note>
Reference-contexts: In particular, parallel execution of subexpressions is limited only by data dependencies, and subprogram calls are non-strict. Examples of this approach to computation include the languages Id [9], Haskell <ref> [83] </ref>, and Lucid [10, 215].
Reference: [84] <author> Roger Hayes, S. W. Manweiler, and Richard D. Schlichting, </author> <title> "A Simple System for Constructing Distributed, Mixed-Language Programs," </title> <journal> Software: Practice and Experience, </journal> <volume> vol. 18, no. 7, </volume> <pages> pp. 641-660, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP <ref> [85, 84] </ref> [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus
Reference: [85] <author> Roger Hayes and Richard D. Schlichting, </author> <title> "Facilitating Mixed Language Programming in Distributed Systems," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-13, no. 12, </volume> <pages> pp. 1254-1264, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP <ref> [85, 84] </ref> [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus <p> Similarly, much work has been done on translating between different views of data structures without much regard for how those structures are manipulated by the programs in which they find themselves <ref> [85, 69, 102, 126, 217, 201, 31, 222] </ref>. Thus, a model of how a program is structured and how it executes can be largely divorced from the data structures it manipulates.
Reference: [86] <author> Sandra Heiler and Stanley Zdonik, </author> <title> "Object Views: Extending the Vision," </title> <booktitle> in Proceedings of the Sixth International Conference on Data Engineering, </booktitle> <pages> pp. 86-93, </pages> <year> 1990. </year>
Reference-contexts: Further examples can be found in the surveys by Raeder [160], Myers [138], and Davis [47]; the introductory books 1 The question is still open in the field of object-oriented databases, however <ref> [184, 86] </ref>. 2 For the purposes of this thesis, the terms "programming environments," "software development environments," "software engineering environments," etc., are all synonyms. I am concerned with issues that affect both single-developer endeavors (programming-in-the-small) as well as projects arising from teams of developers (programming-in-the-large). 4 CHAPTER 1.
Reference: [87] <author> C. A. R. Hoare, </author> <title> "Communicating Sequential Processes," </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 8, </volume> <pages> pp. 666-677, </pages> <month> August </month> <year> 1978. </year> <note> Reprinted in [92, pp. 311-322]. </note>
Reference-contexts: Views that correspond to this paradigm frequently contain all of the features of sequential control flow views, plus additional features for the expression of parallelism and interprocess communication. 4 Such views include the programming languages CSP <ref> [87] </ref>, Ada, Concurrent Pascal [27], and Oc-cam [20], as well as the more abstract languages of Statecharts [79], nondeterministic FSAs, and Petri nets. I selected these paradigms as the basis for my view model for two reasons. <p> This restriction results in no loss of generality, because arbitrary information (e.g., images, sounds, etc.) can be encoded textually. The model assigns no semantics to this auxiliary information. 6 Throughout this thesis, any mention of CSP refers to that language described by Hoare in his 1978 CACM paper <ref> [87] </ref>, not to the language described by his 1985 book of the same name [88]. 3.3. <p> Black-boxing and approximation are alternative (frequently 138 CHAPTER 6. USING SPGS BBuffer:: count, item: integer; count := 0; fl [ count &lt; 10; producer?item ! count := count + 1 [] count &gt; 0; consumer?remove () ! consumer!item; count := count - 1 ] on one by Hoare <ref> [87, p. 318] </ref>. preferable) approaches to the problem of how views can make sense of parts of SPGs that are conceptually alien. 6.4.2 Differences in Semantics for Common Features In Section 6.4.1, the fundamental stumbling block was in mapping from an SPG into a view, because the SPG had a richer
Reference: [88] <author> C. A. R. Hoare, </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall International, </publisher> <year> 1985. </year>
Reference-contexts: The model assigns no semantics to this auxiliary information. 6 Throughout this thesis, any mention of CSP refers to that language described by Hoare in his 1978 CACM paper [87], not to the language described by his 1985 book of the same name <ref> [88] </ref>. 3.3.
Reference: [89] <author> Robert T. Hood and Ken Kennedy, </author> <title> "A Programming Environment for Fortran," </title> <type> Technical Report TR84-1, </type> <institution> Rice University, </institution> <month> June </month> <year> 1984. </year>
Reference-contexts: As noted in Section 2.2.5, the most common representation investigated has been the abstract syntax tree (AST). ASTs are at the core of many well-known programming environments, including the Cornell Program Synthesizer [168], Gandalf [78], Pecan [163], R n <ref> [89] </ref>, MENTOR [53], and CENTAUR [24]. The centerpiece of these environments is a language-based editor, which usually offers incremental syntactic and semantic analysis of the program being edited, plus incremental code generation. <p> Nonetheless, the practical problem of coming up with the interesting events that drive an animation should not be underestimated. 30 CHAPTER 2. APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment <ref> [89] </ref> Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]]
Reference: [90] <author> J. R. Horgan and D. J. Moore, </author> <title> "Techniques for Improving Language-Based Editors," </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <month> May </month> <year> 1984. </year> <note> BIBLIOGRAPHY 275 </note>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned <ref> [90] </ref> Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural
Reference: [91] <author> Mark Hornick and Stanley B. Zdonik, </author> <title> "A Shared Segmented Memory System for an Object-Oriented Database," </title> <journal> Transactions on Office Information Systems, </journal> <volume> vol. 5, no. 1, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: In that case, the description of the canonical representation becomes the schema for the database. Finding ways to specify such schemata and to efficiently implement them is an active area of database research, and is one of the primary motivational forces behind research into object-oriented databases <ref> [91, 56] </ref>. 24 CHAPTER 2. APPROACHES TO VIEW INTEGRATION Criterion Shared File System Message Passing Simple DB View Oriented DB Canonical Rep.
Reference: [92] <author> Ellis Horowitz, ed., </author> <title> Programming Languages: A Grand Tour. </title> <publisher> Computer Science Press, </publisher> <editor> third ed., </editor> <year> 1987. </year>
Reference: [93] <author> Susan Horwitz, Jan Prins, and Thomas Reps, </author> <title> "Integrating Non-Interfering Versions of Programs," </title> <type> Technical Report 690, </type> <institution> University of Wisconsin-Madison Computer Science Department, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: Program dependence graphs [58] were originally developed as a way to facilitate code optimization and/or parallelization, but since then they have found favor in a variety of 2.5. CONCLUSIONS 31 applications, including interactive code restructuring [74] and integration of program variants <ref> [93] </ref>.
Reference: [94] <author> Susan Horwitz, Thomas Reps, and David Binkley, </author> <title> "Interprocedural Slicing Using Dependence Graphs," </title> <booktitle> in Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 35-46, </pages> <month> June </month> <year> 1988. </year> <note> Published as ACM SIGPLAN Notices 23:7, </note> <month> July </month> <year> 1988. </year>
Reference-contexts: In addition, PDGs so far lack efficient incremental algorithms for common operations in an interactive environment, such as adding a statement to a program under construction. There are many derivatives of PDGs, including program representation graphs [224], program dependence webs [12], system dependence graphs for interprocedural slicing <ref> [94] </ref>, and unified interprocedural graphs [82]. Research into hypermedia representations of system information has resulted in mechanisms for storing data that is similar to SPGs. For example, the Hypertext Abstract Machine (HAM) [35] used in Neptune [50] has a resemblance to SPGs.
Reference: [95] <author> Scott E. Hudson and Roger King, </author> <title> "Semantic Feedback in the Higgens UIMS," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 14, no. 8, </volume> <pages> pp. 1188-1206, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: For example, a window-based PM would need data structures to keep track of what windows are on the screen, which SPG components are displayed in various windows, etc. Such data structures may be encapsulated in a user interface management system (UIMS) <ref> [181, 95] </ref>. PMs, then, must directly or indirectly manipulate two sets of data structures: the SPG that represents the software system being presented and presentation-specific data structures that are used to implement an interface to a view.
Reference: [96] <editor> Human-Computer Interaction, </editor> <volume> vol. 4, </volume> <year> 1989. </year> <note> Special issue on nonspeech audio. </note>
Reference-contexts: Presentations may manifest themselves textually (e.g., traditional source code), graphically (e.g., a traditional call graph), through unconventional media (e.g., aurally <ref> [96, 63, 125] </ref>), or, frequently, some combination of these. The relationships among an information source for a software system, a view of that system, presentations of that view, and software developers is summarized in Figure 1-1.
Reference: [97] <author> Dan Ingalls, Scott Wallace, Yu-Ying Chow, Frank Ludolph, and Ken Doyle, "Fab-rik: </author> <title> A Visual Programming Environment," </title> <booktitle> in Proceedings of the 1988 Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '88), </booktitle> <pages> pp. 176-190, </pages> <year> 1988. </year>
Reference-contexts: Environment support for program development has traditionally focused on textual depictions of programs | usually source code | but it's important to note the increasing interest in nonlinear programming languages. Examples of this less conventional approach to software development include structured analysis [177], Fabrik <ref> [97] </ref>, statecharts, grids [149, 150], and graphical interfaces to conventional languages [55].
Reference: [98] <author> Edward A. Ipser, Jr., </author> <title> Toward a Multi-Formalism Specification Environment. </title> <type> Ph.D. thesis, </type> <institution> University of Southern California, Department of Computer Science, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: Integration across views is achieved only at runtime. The research into multiparadigm environments is summarized in Table 2-2. The Draco system [140, 141], Ipser's subsequent work on multi-formalism specification environments <ref> [98, 99] </ref>, and Wile's research into "local formalisms" [221] explicitly provides support for (textual) user-defined languages that translate into a common base language, while Garden [164] and the Visual Programmer's WorkBench [179] concentrate on the creation of 2.4. <p> A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser <ref> [98, 99] </ref>) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages.
Reference: [99] <author> Edward A. Ipser, Jr., David S. Wile, and Dean Jacobs, </author> <title> "A Multi-Formalism Specification Environment," </title> <booktitle> in Proceedings of the Fourth ACM SIGSOFT Symposium on Software Development Environments (SIGSOFT '90) (Richard N. </booktitle> <publisher> Taylor, ed.), </publisher> <pages> pp. 94-106, </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1990. </year> <note> Published as SIGSOFT Software Engineering Notes 15:6, </note> <month> December </month> <year> 1990. </year>
Reference-contexts: Integration across views is achieved only at runtime. The research into multiparadigm environments is summarized in Table 2-2. The Draco system [140, 141], Ipser's subsequent work on multi-formalism specification environments <ref> [98, 99] </ref>, and Wile's research into "local formalisms" [221] explicitly provides support for (textual) user-defined languages that translate into a common base language, while Garden [164] and the Visual Programmer's WorkBench [179] concentrate on the creation of 2.4. <p> A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser <ref> [98, 99] </ref>) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages.
Reference: [100] <author> Suresh Jagannathan and Jim Philbin, </author> <title> "A Customizable Substrate for Concurrent Languages," </title> <booktitle> in Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 55-67, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Because they are so primitive, it is tempting to omit them from consideration when designing the IPC mechanisms for a CR, but unfortunately, semaphores continue to be widely used, even in languages of contemporary design <ref> [148, 100, 75] </ref>. As a result, ignoring semaphores is simply unrealistic | they are just too prevalent to pretend that they don't exist.
Reference: [101] <author> Douglas W. Jones, </author> <title> "How (Not) to Code a Finite State Machine," </title> <journal> ACM SIGPLAN Notices, </journal> <volume> vol. 23, no. 8, </volume> <pages> pp. 19-22, </pages> <month> August </month> <year> 1988. </year> <note> See also Robert A. Lerche's letter to the editor [119] commenting on this article. </note>
Reference-contexts: The structure of the FSA program is unsurprising, but that of the Pascal program may not be. Despite decades of experience with the creation of procedural programs for implementing FSAs, the question of how to properly code an FSA can still generate controversy <ref> [101, 119] </ref>. Compiler texts tend to encourage and compiler-building tools like lex invariably employ a table-driven approach to the problem, but for the purposes of this experiment, I used a naive translation of the topology of the FSA into Pascal control structures.
Reference: [102] <author> M. B. Jones, R. F. Rashid, and M. R. Thompson, "Matchmaker: </author> <title> An Interface Specification Language for Distributed Processing," </title> <booktitle> in Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1985. </year>
Reference-contexts: Similarly, much work has been done on translating between different views of data structures without much regard for how those structures are manipulated by the programs in which they find themselves <ref> [85, 69, 102, 126, 217, 201, 31, 222] </ref>. Thus, a model of how a program is structured and how it executes can be largely divorced from the data structures it manipulates.
Reference: [103] <author> Guy L. Steele Jr., </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year> <note> 276 BIBLIOGRAPHY </note>
Reference: [104] <author> Gail E. Kaiser, Simon M. Kaplan, and Josephine Micallef, </author> <title> "Multiuser, </title> <booktitle> Distributed Languge-Based Environments," IEEE Software, </booktitle> <pages> pp. 58-67, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: This is an active area of research, but no consensus has yet emerged. Explicit support for what-if analysis ("change simulation") is provided by Mercury <ref> [104] </ref>, which implements the feature by modifying a copy of the system when a tentative change is made.
Reference: [105] <author> Arthur M. Keller, </author> <title> "The Role of Semantics in Translating View Updates," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 63-73, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: Some views, such as source code, may be editable. Other views, such as the output from a program profiler, may be inherently read-only. This definition of a view is consistent with that of updatable views in the database world <ref> [105] </ref>. Software developers interact with a view through one or more presentations of that view. A presentation is a pair of mappings, one from a view to operations on some set of output devices, and one from operations on some set of input devices to operations on a view. <p> A request to decrement the number of employees in the Toy department would require the computer to choose an employee to fire a decision best done by some person <ref> [105, p. 64-5] </ref>. Although some researchers have investigated semantics-based view updates [105], the most common way to deal with this problem is to keep it from happening in the first place. This is typically achieved by restricting the kinds of modifications that can be made through database views. <p> A request to decrement the number of employees in the Toy department would require the computer to choose an employee to fire a decision best done by some person [105, p. 64-5]. Although some researchers have investigated semantics-based view updates <ref> [105] </ref>, the most common way to deal with this problem is to keep it from happening in the first place. This is typically achieved by restricting the kinds of modifications that can be made through database views.
Reference: [106] <author> Brian W. Kernighan and John R. Mashey, </author> <title> "The UNIX Programming Environment," </title> <journal> IEEE Computer, </journal> <volume> vol. 14, no. 4, </volume> <month> April </month> <year> 1981. </year> <note> Reprinted in [16, pp. 175-197]. </note>
Reference: [107] <author> Brian W. Kernighan and Rob Pike, </author> <title> The UNIX Programming Environment. </title> <booktitle> The Prentice-Hall Software Series, </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1984. </year>
Reference: [108] <author> Brian W. Kernighan and Dennis M. Ritchie, </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <editor> first ed., </editor> <year> 1978. </year>
Reference-contexts: Such steps would include removing existing tokens from the graph, flushing pending input and output, and destroying subprogram invocations currently in progress. 4.6 A Simple Example for writing "hello, world" to the standard output <ref> [108, p. 6] </ref>: 12 main () - printf ("hello, world"n"); - It should be clear from the SPG that the program in Figure 4-43 contains a single subprogram, main, and that the start node of the program simply invokes main.
Reference: [109] <author> Brian W. Kernighan and Dennis M. Ritchie, </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <editor> second ed., </editor> <year> 1988. </year>
Reference-contexts: In many cases this may boil down to a matter of taste on the part of the view writer, especially in C-like languages, where the semantics of for loops are defined in terms of the semantics of while loops <ref> [109] </ref>. Similarly, views are responsible for translating SPG constructs into view-specific idiomatic constructs in a presentation. For example, it is entirely up to the view doing the mapping whether to display the increment of i in Figure 5-1 as "i=i+1" or as "i++".
Reference: [110] <author> Andrew Koenig and Bjarne Stroustrup, </author> <title> "Exception Handling for C++(revised)," </title> <booktitle> in USENIX C++ Conference Proceedings, </booktitle> <year> 1990. </year>
Reference-contexts: Reiss, "A System for Multiparadigm Development of Software Systems," in Proceedings of the Sixth International Workshop on Software Specification and Design, October 1991. My decision in early 1989 to develop a prototype SPG implementation in C++ turned out to be a fateful one. The language itself was evolving rapidly <ref> [196, 199, 197, 198, 110] </ref>, 265 266 APPENDIX C. SPG-RELATED PUBLICATIONS and existing development tools were proving to be unexpectedly frustrating. Steven P.
Reference: [111] <author> Timothy Koschmann and Martha Walton Evens, </author> <title> "Bridging the Gap Between Object-Oriented and Logic Programming," </title> <journal> IEEE Software, </journal> <pages> pp. 36-42, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens <ref> [111] </ref>) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages. Other multiparadigm work includes Zave's research into composing different independent paradigms [226]; the explicitly multiparadigm languages Loops [22, 195], Daisy II [62], Leda [33], and G-2 [157]; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to <p> (Koschmann and Evens <ref> [111] </ref>) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages. Other multiparadigm work includes Zave's research into composing different independent paradigms [226]; the explicitly multiparadigm languages Loops [22, 195], Daisy II [62], Leda [33], and G-2 [157]; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors as a basis for concurrent programming [1]; the CODE system for developing parallel applications [32]; the wide-spectrum languages V [188], CIP-L [17], and PLEASE [209]; and the work by Zave and Jackson on formally composing partial specifications [227]. 2.4.2 MVDEs Not Using a Canonical Representation
Reference: [112] <author> Doug Lea, </author> <title> "Steps Toward an Internal Representation System for the Semantic Analysis of C++ Programs." </title> <booktitle> Working paper for OOPSLA OOPDE Workshop., </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea <ref> [112] </ref>) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views. <p> Lubar's General Design Representation [123] is used in the ROSE-2 [124] environment, but the GDR is primarily designed to represent static design data, and has not addressed issues concerning the executability of the resulting representation. Lea has proposed an internal representation for C++ and other object-oriented languages <ref> [112] </ref>, but, much like assembly language output from compilers, his representation is not designed to support back-mapping to a "source" view once the representation is constructed. 2.5 Conclusions At the outset of this chapter, I defined five important criteria for view integration in an MVDE, and in Table 2-1 I compared
Reference: [113] <author> Peter Lee, Frank Pfenning, Gene Rollins, and William Scherlis, </author> <title> "The Ergo Support System: An Integrated Set of Tools for Prototyping Integrated Environments," </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 25-34, </pages> <publisher> ACM Press, </publisher> <month> November </month> <year> 1988. </year> <note> Published as ACM SIGSOFT Software Engineering Notes 13:5, </note> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices 24:2, </journal> <month> February </month> <year> 1989. </year>
Reference-contexts: These graphs are usually not even planar, much less hierarchical [28, p. 12]. In recognition of this inherently multi-faceted nature of software, many researchers in the area of software development environments have argued that environments that support only a single view | usually textual source code | are inadequate <ref> [121, 113, 124] </ref>. In fact, software developers already routinely employ multiple views of the systems they work on. One need only note the plethora of more or less "standard" views to understand that multiple-view software development is already the rule in practice. <p> This makes it impossible to write, for example, one function for substitution that is syntactically correct for all object-languages. . . . From this and other examples it is clear that one would like to include information about the binding properties of object-language constructs in the representation of programs. <ref> [113, p. 28] </ref>. Scopes themselves present no particular difficulties. A scope is just a region of a program and may be directly represented as such. The matter of name-binding, however, is substantially thornier.
Reference: [114] <author> M. M. Lehman, </author> <title> "Human Thought and Action as an Ingredient of System Behavior," in The Encyclopedia of Ignorance (R. </title> <editor> Duncan and M. Weston-Smith, </editor> <booktitle> eds.), </booktitle> <pages> pp. 347-354, </pages> <address> London: </address> <publisher> Pergamon Press, </publisher> <year> 1977. </year>
Reference-contexts: In fact, Lehman argues that for E-type software [115] (which encompasses development environments), this problem is inherent, a consequence of "Heisenberg-like uncertainty" that cannot be overcome <ref> [116, 114] </ref>. It is therefore essential for users to be able to define their own views if the environment is to remain satisfactory.
Reference: [115] <author> M. M. Lehman, </author> <title> "Uncertainty in Computer Application and its Control Through the Engineering of Software," </title> <journal> Journal of Software Maintenance, </journal> <volume> vol. 1, no. 1, </volume> <pages> pp. 3-27, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: The basic argument is straightforward: it is unrealistic to expect the designer of a development environment to correctly anticipate all views that developers might want, so any fixed set of views must prove too limiting for some users of the environment. In fact, Lehman argues that for E-type software <ref> [115] </ref> (which encompasses development environments), this problem is inherent, a consequence of "Heisenberg-like uncertainty" that cannot be overcome [116, 114]. It is therefore essential for users to be able to define their own views if the environment is to remain satisfactory. <p> An additional concern is an environment's robustness in the face of evolution [130]. According to Lehman, an inherent property of E-type software (which includes development environments) is that it must evolve over time if it is to maintain the satisfaction of its users <ref> [115] </ref>. Therefore, the ability of an integration mechanism to gracefully accommodate environment evolution is an important concern. Several researchers have designed systems that specifically deal with this problem [200, 189], but in this thesis I disregard this aspect of integration.
Reference: [116] <author> M. M. Lehman, </author> <title> "Uncertainty in Computer Application," </title> <journal> Communications of the ACM, </journal> <volume> vol. 33, no. 5, </volume> <pages> pp. 584-586, </pages> <month> May </month> <year> 1990. </year> <type> Technical correspondence. </type>
Reference-contexts: In fact, Lehman argues that for E-type software [115] (which encompasses development environments), this problem is inherent, a consequence of "Heisenberg-like uncertainty" that cannot be overcome <ref> [116, 114] </ref>. It is therefore essential for users to be able to define their own views if the environment is to remain satisfactory.
Reference: [117] <author> Moises Lejter, Scott Meyers, and Steven P. Reiss, </author> <title> "Adding Semantic Information To C++ Development Environments," </title> <booktitle> in Proceedings of C++ at Work - '90, </booktitle> <pages> pp. 103-108, </pages> <month> September </month> <year> 1990. </year> <note> BIBLIOGRAPHY 277 </note>
Reference-contexts: This insight spurred collaborative work with Moises Lejter and Steven P. Reiss that resulted in enhancements 152 CHAPTER 6. USING SPGS to EMACS [192] and FIELD that yielded an experimental version of EMACS that offers programmers the ability to invoke semantics-based editing commands on C++ programs <ref> [117, 118] </ref>. As a result of my implementation work on SPGs, I became interested in the problem of avoiding common but unintuitive errors in C++ programs. Moises Lejter and I identified a number of such errors, and we described how a lint-like program could automatically detect them [133]. <p> At the same time, Moises Lejter and Steven P. Reiss Reiss and I undertook an effort to enhance FIELD and Emacs [192] to specifically address the problems I had identified. Our work was described in this paper <ref> [117] </ref>: * Moises Lejter, Scott Meyers, and Steven P. Reiss, "Adding Semantic Information To C++ Development Environments," in Proceedings of C++ at Work-'90, September 1990. These last two papers were subsequently combined and updated and presented as fol lows [118]: * Moises Lejter, Scott Meyers, and Steven P.
Reference: [118] <author> Moises Lejter, Scott Meyers, and Steven P. Reiss, </author> <title> "Support for Maintaining Object-Oriented Programs," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 18, no. 12, </volume> <month> December </month> <year> 1992. </year> <note> Also available as Brown University Computer Science Department Technical Report CS-91-52, August 1991. An earlier version of this paper appeared in the Proceedings of the 1991 Conference on Software Maintenance (CSM '91), October 1991. This paper is largely drawn from two other papers [129, 117]. </note>
Reference-contexts: [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB <ref> [118] </ref> View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. Evolution is an important topic, but, as noted in Section 2.1, one not directly addressed by my work in this thesis. <p> my work, a view of a system is of no interest unless it can be generated without requiring modifications to the system being worked on. 7;8 Several environments have been developed that store information about programs in a relational database, e.g., OMEGA [121], CIA and CIA++ [39, 73], and XREFDB <ref> [118] </ref>. In each case, however, the goal of the effort has been to answer queries about static programs, not to provide communication between views of dynamically changing systems. <p> This insight spurred collaborative work with Moises Lejter and Steven P. Reiss that resulted in enhancements 152 CHAPTER 6. USING SPGS to EMACS [192] and FIELD that yielded an experimental version of EMACS that offers programmers the ability to invoke semantics-based editing commands on C++ programs <ref> [117, 118] </ref>. As a result of my implementation work on SPGs, I became interested in the problem of avoiding common but unintuitive errors in C++ programs. Moises Lejter and I identified a number of such errors, and we described how a lint-like program could automatically detect them [133]. <p> Our work was described in this paper [117]: * Moises Lejter, Scott Meyers, and Steven P. Reiss, "Adding Semantic Information To C++ Development Environments," in Proceedings of C++ at Work-'90, September 1990. These last two papers were subsequently combined and updated and presented as fol lows <ref> [118] </ref>: * Moises Lejter, Scott Meyers, and Steven P. Reiss, "Support for Maintaining Object-Oriented Programs," in Proceedings of the Conference on Software Maintenance, Oc-tober 1991. A slightly revised version was published in IEEE Transactions on Software Engineering, December 1992.
Reference: [119] <author> Robert A. Lerche. </author> <title> Letter to the Editor of ACM SIGPLAN Notices, </title> <month> December </month> <year> 1988. </year>
Reference-contexts: The structure of the FSA program is unsurprising, but that of the Pascal program may not be. Despite decades of experience with the creation of procedural programs for implementing FSAs, the question of how to properly code an FSA can still generate controversy <ref> [101, 119] </ref>. Compiler texts tend to encourage and compiler-building tools like lex invariably employ a table-driven approach to the problem, but for the purposes of this experiment, I used a naive translation of the topology of the FSA into Pascal control structures.
Reference: [120] <author> Claus Lewerentz, </author> <title> "Extended Programming in the Large in a Software Development Environment," </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 173-182, </pages> <publisher> ACM Press, </publisher> <month> November </month> <year> 1988. </year> <note> Published as ACM SIGSOFT Software Engineering Notes 13:5, </note> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices 24:2, </journal> <month> February </month> <year> 1989. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN <ref> [139, 120] </ref> Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these
Reference: [121] <author> Mark A. Linton, </author> <title> "Implementing Relational Views of Programs," </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 132-140, </pages> <month> April </month> <year> 1984. </year> <note> Published as ACM SIGSOFT Software Engineering Notes 9:3, </note> <month> May </month> <year> 1984, </year> <journal> and ACM SIGPLAN Notices 19:5, </journal> <month> May </month> <year> 1984. </year>
Reference-contexts: These graphs are usually not even planar, much less hierarchical [28, p. 12]. In recognition of this inherently multi-faceted nature of software, many researchers in the area of software development environments have argued that environments that support only a single view | usually textual source code | are inadequate <ref> [121, 113, 124] </ref>. In fact, software developers already routinely employ multiple views of the systems they work on. One need only note the plethora of more or less "standard" views to understand that multiple-view software development is already the rule in practice. <p> Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA <ref> [121] </ref> [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. <p> For my work, a view of a system is of no interest unless it can be generated without requiring modifications to the system being worked on. 7;8 Several environments have been developed that store information about programs in a relational database, e.g., OMEGA <ref> [121] </ref>, CIA and CIA++ [39, 73], and XREFDB [118]. In each case, however, the goal of the effort has been to answer queries about static programs, not to provide communication between views of dynamically changing systems.
Reference: [122] <author> Barbara Liskov and John Guttag, </author> <title> Abstraction and Specification in Program Development. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference: [123] <author> Mitchell D. Lubars, </author> <title> "A General Design Representation," </title> <type> Technical Report STP-066-89, </type> <institution> Microelectronics and Computer Technology Corporation, </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation <ref> [123] </ref>] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views. <p> For example, in discussions of source code, it refers to a single canonical textual representation (e.g., Modula-2) and the finest granularity it seems to consider is that of function definitions. A variety of other canonical representations has been proposed or implemented for software development environments. Lubar's General Design Representation <ref> [123] </ref> is used in the ROSE-2 [124] environment, but the GDR is primarily designed to represent static design data, and has not addressed issues concerning the executability of the resulting representation.
Reference: [124] <author> Mitchell D. Lubars, </author> <title> "The ROSE-2 Strategies for Supporting High-Level Software Design Reuse," </title> <type> Technical Report STP-303-90, </type> <institution> Microelectronics and Computer Technology Corporation, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: These graphs are usually not even planar, much less hierarchical [28, p. 12]. In recognition of this inherently multi-faceted nature of software, many researchers in the area of software development environments have argued that environments that support only a single view | usually textual source code | are inadequate <ref> [121, 113, 124] </ref>. In fact, software developers already routinely employ multiple views of the systems they work on. One need only note the plethora of more or less "standard" views to understand that multiple-view software development is already the rule in practice. <p> A variety of other canonical representations has been proposed or implemented for software development environments. Lubar's General Design Representation [123] is used in the ROSE-2 <ref> [124] </ref> environment, but the GDR is primarily designed to represent static design data, and has not addressed issues concerning the executability of the resulting representation.
Reference: [125] <author> Tara Maja Madhyastha, </author> <title> "A Portable System for Data Sonification," </title> <type> Technical Report UIUCDCS-R-92-1761, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> July </month> <year> 1992. </year> <editor> M. S. </editor> <booktitle> thesis. </booktitle>
Reference-contexts: Presentations may manifest themselves textually (e.g., traditional source code), graphically (e.g., a traditional call graph), through unconventional media (e.g., aurally <ref> [96, 63, 125] </ref>), or, frequently, some combination of these. The relationships among an information source for a software system, a view of that system, presentations of that view, and software developers is summarized in Figure 1-1.
Reference: [126] <author> M. Maybee and S. D. Sykes, </author> <title> "Q: Towards a Multi-Lingual Interprocess Communications Model," </title> <type> technical report, </type> <institution> University of Colorado at Boulder, </institution> <year> 1989. </year>
Reference-contexts: Similarly, much work has been done on translating between different views of data structures without much regard for how those structures are manipulated by the programs in which they find themselves <ref> [85, 69, 102, 126, 217, 201, 31, 222] </ref>. Thus, a model of how a program is structured and how it executes can be largely divorced from the data structures it manipulates.
Reference: [127] <author> Bertrand Meyer, </author> <title> "From Structured Programming to Object-Oriented Design: The Road to Eiffel," </title> <journal> Structured Programming, </journal> <volume> vol. 10, no. 1, </volume> <pages> pp. 19-39, </pages> <year> 1989. </year>
Reference-contexts: This outer scope represents the global scope of a C program. Not all languages have a global Scope; Eiffel <ref> [127, 128] </ref>, for example, does not. There is certainly no requirement that an SPG have a global scope. Because the global scope is essentially unused in this particular program, it would have been possible for the view generating the SPG to omit it.
Reference: [128] <author> Bertrand Meyer, </author> <title> Eiffel: The Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: This outer scope represents the global scope of a C program. Not all languages have a global Scope; Eiffel <ref> [127, 128] </ref>, for example, does not. There is certainly no requirement that an SPG have a global scope. Because the global scope is essentially unused in this particular program, it would have been possible for the view generating the SPG to omit it.
Reference: [129] <author> Scott Meyers, </author> <title> "Working with Object-Oriented Programs: The View from the Trenches is Not Always Pretty," </title> <booktitle> in Proceedings of the Symposium on Object-Oriented Programming Emphasizing Practical Applications (SOOPPA), </booktitle> <pages> pp. 51-65, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Further analysis of the difficulties encountered when building object-oriented software with tools for conventional languages led to the realization that object-oriented programming languages, unlike procedural languages, are poorly suited for lexically based tools like text editors and grep-style pattern-matching programs <ref> [129] </ref>. This insight spurred collaborative work with Moises Lejter and Steven P. Reiss that resulted in enhancements 152 CHAPTER 6. USING SPGS to EMACS [192] and FIELD that yielded an experimental version of EMACS that offers programmers the ability to invoke semantics-based editing commands on C++ programs [117, 118]. <p> Reiss and Scott Meyers, "FIELD Support for C++," in USENIX C++ Con ference Proceedings, April 1990. I examined why the tools that were adequate for C programming came up short when applied to C++, and I published the results of my analysis in the following paper <ref> [129] </ref>, which pointed out the impact of such features as dynamic binding and function name overloading: * Scott Meyers, "Working with Object-Oriented Programs: The View from the Trenches is Not Always Pretty," in Proceedings of the Symposium on Object-Oriented Program ming Emphasizing Practical Applications (SOOPPA), September 1990.
Reference: [130] <author> Scott Meyers, </author> <title> "Difficulties in Integrating Multiview Development Systems," </title> <journal> IEEE Software, </journal> <pages> pp. 49-57, </pages> <month> January </month> <year> 1991. </year> <note> 278 BIBLIOGRAPHY </note>
Reference-contexts: Nonetheless, the factors outlined here are of fundamental importance. Their resolution may not be sufficient conditions for successful integration, but they are certainly necessary. An additional concern is an environment's robustness in the face of evolution <ref> [130] </ref>. According to Lehman, an inherent property of E-type software (which includes development environments) is that it must evolve over time if it is to maintain the satisfaction of its users [115]. Therefore, the ability of an integration mechanism to gracefully accommodate environment evolution is an important concern. <p> In fact, a decrease in system integration is all but unavoidable during environment evolution <ref> [130] </ref>, but that cannot obviate the need for a way to evolve (primarily extend) the semantics of a system. As described in this thesis, SPGs include a fairly small number of standard annotations, i.e., annotations with predefined semantics. <p> Reiss, "An Empirical Study of Multiple-View Software Development," in Proceedings of SIGSOFT '92: Fifth Symposium on Software Devel opment Environments, December 1992. Proceeding on the assumption that multiple-view software development was in fact a desirable goal, I examined different approaches to tool integration in the following article <ref> [130] </ref>, which was an early version of the more extensive review found in Chapter 2: * Scott Meyers, "Difficulties in Integrating Multiview Development Systems," IEEE Software, January 1991. Early work on the design of SPG-based systems was reported in the first two of the following papers [134, 135].
Reference: [131] <author> Scott Meyers, </author> <title> Effective C++: 50 Specific Ways to Improve Your Programs and Designs. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: I therefore turned my attention to the identification of a large number of likely error conditions in C++ programs and to a characterization of the circumstances under which each was and was not an error. I eventually published the results of this investigation in book form <ref> [131] </ref>. I also began a joint effort with Carolyn K. Duby and Steven P. Reiss on the design and implementation of a metalanguage for C++ programs that allowed programmers to specify a wide range of application-specific constraints such that violations of the constraints would be automatically detected [54, 132]. <p> I went on to identify many more likely error conditions | some of which were not amenable to automatic detection | in the following book <ref> [131] </ref>: * Scott Meyers, Effective C++: 50 Specific Ways to Improve Your Programs and Designs. Addison-Wesley, 1992. Carolyn K. Duby and Steven P.
Reference: [132] <author> Scott Meyers, Carolyn K. Duby, and Steven P. Reiss, </author> <title> "Constraining the Structure and Style of Object-Oriented Programs," </title> <booktitle> in Proceedings of the First Workshop on Principles and Practice of Constraint Programming (PPCP93), </booktitle> <month> April </month> <year> 1993. </year> <note> Also available as Brown University Computer Science Department Technical Report CS-93-12, </note> <month> April </month> <year> 1993. </year>
Reference-contexts: I also began a joint effort with Carolyn K. Duby and Steven P. Reiss on the design and implementation of a metalanguage for C++ programs that allowed programmers to specify a wide range of application-specific constraints such that violations of the constraints would be automatically detected <ref> [54, 132] </ref>. The resulting metalanguage, CCEL (the C++ Constraint Expression Language), has since grown into an independent and ongoing research project in its own right. 6.8. <p> Reiss and I then collaborated on the design and implementation of a new language that would allow C++ programmers to define custom constraints on their C++ programs and have a system automatically ensure that the constraints were not violated. Our initial reports on this system were published as follows <ref> [54, 132] </ref>: * Carolyn K. Duby, Scott Meyers, and Steven P. Reiss, "CCEL: A Metalanguage for C++," in USENIX C++ Conference Proceedings, August 1992. APPENDIX C. SPG-RELATED PUBLICATIONS 267 * Scott Meyers, Carolyn K. Duby, and Steven P.
Reference: [133] <author> Scott Meyers and Moises Lejter, </author> <title> "Automatic Detection of C++ Programming Errors: Initial Thoughts on a lint++," </title> <booktitle> in USENIX C++ Conference Proceedings, </booktitle> <pages> pp. 29-40, </pages> <month> April </month> <year> 1991. </year> <note> Also available as Brown University Computer Science Department Technical Report CS-91-51, </note> <month> August </month> <year> 1991. </year>
Reference-contexts: As a result of my implementation work on SPGs, I became interested in the problem of avoiding common but unintuitive errors in C++ programs. Moises Lejter and I identified a number of such errors, and we described how a lint-like program could automatically detect them <ref> [133] </ref>. This approach seemed promising, but it quickly became clear that the same constructs that lead to errors in most C++ programs can be legitimately employed in some restricted application domains. <p> Finally, I developed an interest in designing tools that could identify constructs in C++ programs that were "almost always wrong," and Moises Lejter and I presented a list of such constructs and our approach to automatically identifying them in this paper <ref> [133] </ref>: * Scott Meyers and Moises Lejter, "Automatic Detection of C++ Programming Errors: Initial Thoughts on a lint++," in USENIX C++ Conference Proceedings, April 1991.
Reference: [134] <author> Scott Meyers and Steven P. Reiss, </author> <title> "A Semantic Basis for Multiple Views of Programs," </title> <booktitle> in Advance Working Papers of the Second International Workshop on Computer-Aided Software Engineering (CASE '88), </booktitle> <month> July </month> <year> 1988. </year>
Reference-contexts: Early work on the design of SPG-based systems was reported in the first two of the following papers <ref> [134, 135] </ref>. The third paper focused less on the structural aspects of SPGs and more on the kinds of views they were designed to support and on how they could be used as the core of a development environment [136]: * Scott Meyers and Steven P.
Reference: [135] <author> Scott Meyers and Steven P. Reiss, </author> <title> "Representing Programs in Multiparadigm Software Development Environments," </title> <booktitle> in Proceedings of COMPSAC-89, </booktitle> <pages> pp. 420-427, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: The matter of name-binding, however, is substantially thornier. In my early work on SPGs, I proposed that each scope have associated with it a set of name-binding rules that collectively defined how names were bound in that scope <ref> [135] </ref>. 12 This seemed like a natural and flexible approach to an ubiquitous concept, but it turned out to be untenable. There were two reasons for this: * Name-binding rules vary too much across views. Some views scope names lexically, some do not. <p> Early work on the design of SPG-based systems was reported in the first two of the following papers <ref> [134, 135] </ref>. The third paper focused less on the structural aspects of SPGs and more on the kinds of views they were designed to support and on how they could be used as the core of a development environment [136]: * Scott Meyers and Steven P.
Reference: [136] <author> Scott Meyers and Steven P. Reiss, </author> <title> "A System for Multiparadigm Development of Software Systems," </title> <booktitle> in Proceedings of the Sixth International Workshop on Software Specification and Design, </booktitle> <month> October </month> <year> 1991. </year> <note> Also available as Brown University Computer Science Department Technical Report No. CS-91-50, </note> <month> August </month> <year> 1991. </year>
Reference-contexts: The third paper focused less on the structural aspects of SPGs and more on the kinds of views they were designed to support and on how they could be used as the core of a development environment <ref> [136] </ref>: * Scott Meyers and Steven P. Reiss, "A Semantic Basis for Multiple Views of Programs," in Advance Working Papers of the Second International Workshop on Computer-Aided Software Engineering (CASE '88), July 1988. * Scott Meyers and Steven P.
Reference: [137] <author> Scott Meyers and Steven P. Reiss, </author> <title> "An Empirical Study of Multiple-View Software Development," </title> <booktitle> in Proceedings of SIGSOFT '92: Fifth Symposium on Software Development Environments, </booktitle> <month> December </month> <year> 1992. </year>
Reference-contexts: Evaluation of Multiple-View Software Development It is still unknown whether multiple-view software development offers measurable advantages over more traditional program development techniques. The results of experiments 8.2. RELATED RESEARCH AREAS 187 performed by Steven P. Reiss and me <ref> [137] </ref> suggest that increasing the number of views of a software system increases the performance of the programmers working on that system, but methodological shortcomings present in those experiments throw into question the data on which the conclusions are based. <p> Of these questions, one of the most fundamental is at the same time one of the most neglected, namely, does multiple-view software development offer any measurable advantages compared to traditional software development methodologies? My attempt to address this question was reported in the following paper <ref> [137] </ref>: * Scott Meyers and Steven P. Reiss, "An Empirical Study of Multiple-View Software Development," in Proceedings of SIGSOFT '92: Fifth Symposium on Software Devel opment Environments, December 1992.
Reference: [138] <author> Brad A. Myers, </author> <title> "The State of the Art in Visual Programming and Program Visualization," </title> <type> Technical Report CMU-CS-88-114, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: Examples of this less conventional approach to software development include structured analysis [177], Fabrik [97], statecharts, grids [149, 150], and graphical interfaces to conventional languages [55]. Further examples can be found in the surveys by Raeder [160], Myers <ref> [138] </ref>, and Davis [47]; the introductory books 1 The question is still open in the field of object-oriented databases, however [184, 86]. 2 For the purposes of this thesis, the terms "programming environments," "software development environments," "software engineering environments," etc., are all synonyms.
Reference: [139] <author> Manfred Nagl, </author> <title> "A Software Development Environment Based on Graph Technology," </title> <type> Technical Report 87-3, </type> <institution> Lehrstuhl fur Informatik III, Rheinisch-Westfalische Technis-che Hochschule Aachen, </institution> <year> 1987. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN <ref> [139, 120] </ref> Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these <p> In fact, none of the environments mentioned above allows programmers to define new views. Similar difficulties arise with program representations based on abstract syntax graphs, such as those used in IPSEN <ref> [139] </ref>, the Maintainer's Assistant [158] and TEAM [40]. The Programmer's Apprentice project [172, 173] has employed the Plan Calculus [170] for a variety of systems. The Plan Calculus is a graph-based representation for programs that incorporates both control- and dataflow information.
Reference: [140] <author> James M. Neighbors, </author> <title> Software Construction Using Components. </title> <type> Ph.D. thesis, </type> <institution> University of California at Irvine, </institution> <year> 1980. </year>
Reference-contexts: Like the architecture founded on a common base language, there is typically no way to map from one paradigm to another. Integration across views is achieved only at runtime. The research into multiparadigm environments is summarized in Table 2-2. The Draco system <ref> [140, 141] </ref>, Ipser's subsequent work on multi-formalism specification environments [98, 99], and Wile's research into "local formalisms" [221] explicitly provides support for (textual) user-defined languages that translate into a common base language, while Garden [164] and the Visual Programmer's WorkBench [179] concentrate on the creation of 2.4. <p> A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco <ref> [141, 140] </ref> G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages.
Reference: [141] <author> James M. Neighbors, </author> <title> "The Draco Approach to Constructing Software from Reusable Components," </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> September </month> <year> 1984. </year>
Reference-contexts: Like the architecture founded on a common base language, there is typically no way to map from one paradigm to another. Integration across views is achieved only at runtime. The research into multiparadigm environments is summarized in Table 2-2. The Draco system <ref> [140, 141] </ref>, Ipser's subsequent work on multi-formalism specification environments [98, 99], and Wile's research into "local formalisms" [221] explicitly provides support for (textual) user-defined languages that translate into a common base language, while Garden [164] and the Visual Programmer's WorkBench [179] concentrate on the creation of 2.4. <p> A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco <ref> [141, 140] </ref> G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages.
Reference: [142] <author> Celso Niskier, Tom Maibaum, and Daniel Schwabe, </author> <title> "A Look Through PRISMA: Towards Plurasistic Knowledge-based Environments for Software Specification Acquisition," </title> <booktitle> in Proceedings of of the 5th International Workshop on Software Specification and Design, </booktitle> <pages> pp. 128-136, </pages> <note> ACM, 1989. BIBLIOGRAPHY 279 </note>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma <ref> [142] </ref> Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on <p> Message senders need not explicitly state who is to receive a message, and in fact the set of recipients is typically determined dynamically. A very different message-based architecture is predicated on sets of hardwired mappings between views. Examples of such systems include Prisma <ref> [142] </ref> and ViewPoints [145, 60]. Each of these systems supports multiple independent views, but each also relies on environment developers to write bidirectional mappings between views that are to be kept consistent.
Reference: [143] <author> Marian H. Nodine, </author> <title> Interactions: Multidatabase Support for Planning Applications. </title> <type> Ph.D. thesis, </type> <institution> Brown University Department of Computer Science, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: Therefore, it may be possible to adapt the research done on flexible transaction models <ref> [187, 13, 228, 143] </ref> to the particular needs of multiple-view software development environments.
Reference: [144] <author> Robert L. Nord and Frank Pfenning, </author> <title> "The Ergo Attribute System," </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments (Peter Henderson, </booktitle> <publisher> ed.), </publisher> <pages> pp. 110-120, </pages> <publisher> ACM Press, </publisher> <month> November </month> <year> 1988. </year> <note> Published as ACM SIGSOFT Software Engineering Notes 13:5, </note> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices 24:2, </journal> <month> February </month> <year> 1989. </year>
Reference-contexts: A substantive change to an SPG need not trigger an update in all views, because some views may not depict the aspect (s) of the SPG that are affected by the change. 6.4. MISMATCHES BETWEEN SPGS AND VIEWS 135 for use in interactive development environments <ref> [204, 144, 225, 4, 180] </ref>. An ideal algorithm for updating a presentation, of course, is as predictable as a batch-mode computation and as efficient as an incremental one. Unfortunately, it may be the case that no such algorithm has been developed for a particular presentation.
Reference: [145] <author> Bashnar Nuseibeh and Anthony Finkelstein, </author> <title> "ViewPoints: A Vehicle for Method and Tool Integration," </title> <booktitle> in Proceedings of the International Workshop on CASE (CASE '92), </booktitle> <pages> pp. 50-60, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints <ref> [145, 60] </ref>] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. <p> Message senders need not explicitly state who is to receive a message, and in fact the set of recipients is typically determined dynamically. A very different message-based architecture is predicated on sets of hardwired mappings between views. Examples of such systems include Prisma [142] and ViewPoints <ref> [145, 60] </ref>. Each of these systems supports multiple independent views, but each also relies on environment developers to write bidirectional mappings between views that are to be kept consistent.
Reference: [146] <author> Bashar A. Nuseibeh, </author> <title> "Inter-Viewpoint checks." </title> <type> Personal communication, </type> <month> October </month> <year> 1992. </year>
Reference-contexts: Given this kind of distributed computing environment, it is not at all obvious that a monolithic CR for software systems is an appropriate foundation for an efficient, robust environment for software development <ref> [146] </ref>. However, it may be possible to employ techniques developed for distributed database systems [152, 153], whereby a CR has a logical structure that is monolithic, but a physical structure that is actually distributed.
Reference: [147] <author> Patrick D. O'Brien, Daniel C. Halbert, and Michael F. Kilian, </author> <title> "The Trellis Programming Environment," </title> <booktitle> in Proceedings of the 1987 Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '87), </booktitle> <pages> pp. 91-102, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis <ref> [147] </ref> XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution. Evolution is an important topic, but, as noted in Section 2.1, one not directly addressed by my work in this thesis. <p> These chunks are then stored in whatever form the database supports, e.g., relations in the case of OMEGA, objects in the case of MicroScope [6]. Some database-centered environments, such as Trellis <ref> [147] </ref> and Odin [41], use larger-grained chunks, possibly as large as entire files of source and object code.
Reference: [148] <author> Kazuhiro Ogata, Satoshi Kurihara, Mikio Inari, and Norihisa Doi, </author> <title> "The Design and Implementation of HoME," </title> <booktitle> in Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 44-54, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Because they are so primitive, it is tempting to omit them from consideration when designing the IPC mechanisms for a CR, but unfortunately, semaphores continue to be widely used, even in languages of contemporary design <ref> [148, 100, 75] </ref>. As a result, ignoring semaphores is simply unrealistic | they are just too prevalent to pretend that they don't exist.
Reference: [149] <author> Harold L. Ossher, </author> <title> A New Program Structuring Mechanism Based on Layered Graphs. </title> <type> Ph.D. thesis, </type> <institution> Stanford University Department of Computer Science, </institution> <month> January </month> <year> 1985. </year> <note> Available as Stanford University Computer Science Department Technical Report STAN-CS-85-1078, </note> <month> December </month> <year> 1984. </year>
Reference-contexts: Environment support for program development has traditionally focused on textual depictions of programs | usually source code | but it's important to note the increasing interest in nonlinear programming languages. Examples of this less conventional approach to software development include structured analysis [177], Fabrik [97], statecharts, grids <ref> [149, 150] </ref>, and graphical interfaces to conventional languages [55].
Reference: [150] <author> Harold L. Ossher, </author> <title> "Multi-Dimensional Organization and Browsing of Object-Oriented Systems," </title> <booktitle> in Proceedings of the IEEE 1990 International Conference on Computer Languages, </booktitle> <pages> pp. 128-135, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Environment support for program development has traditionally focused on textual depictions of programs | usually source code | but it's important to note the increasing interest in nonlinear programming languages. Examples of this less conventional approach to software development include structured analysis [177], Fabrik [97], statecharts, grids <ref> [149, 150] </ref>, and graphical interfaces to conventional languages [55].
Reference: [151] <author> Karl J. Ottenstein and Linda M. Ottenstein, </author> <title> "The Program Dependence Graph in a Software Development Environment," </title> <booktitle> in Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pp. 177-184, </pages> <year> 1984. </year> <note> Published as ACM SIGSOFT Software Engineering Notes 9:3, </note> <month> May </month> <year> 1984, </year> <journal> and ACM SIGPLAN Notices 19:5, </journal> <month> May </month> <year> 1984. </year>
Reference-contexts: [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph <ref> [151] </ref>] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views. <p> CONCLUSIONS 31 applications, including interactive code restructuring [74] and integration of program variants [93]. Ottenstein and Ottenstein have proposed that PDGs could be used as a basis for an integrated development environment <ref> [151] </ref>, but the form of a PDG is very different from the views that programmers typically use, and it would be an arduous task to write translators that would map between views and a PDG.
Reference: [152] <author> M. Tamer Ozsu and Patrick Valduriez, </author> <title> "Distributed Database Systems: Where Are We Now?," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 68-78, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Given this kind of distributed computing environment, it is not at all obvious that a monolithic CR for software systems is an appropriate foundation for an efficient, robust environment for software development [146]. However, it may be possible to employ techniques developed for distributed database systems <ref> [152, 153] </ref>, whereby a CR has a logical structure that is monolithic, but a physical structure that is actually distributed. Use of such techniques can yield databases that are more efficient and more forgiving of network failures than are their physically monolithic counterparts, but further analysis is 188 CHAPTER 8.
Reference: [153] <author> M. Tamer Ozsu and Patrick Valduriez, </author> <title> Principles of Distributed Database Systems. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Given this kind of distributed computing environment, it is not at all obvious that a monolithic CR for software systems is an appropriate foundation for an efficient, robust environment for software development [146]. However, it may be possible to employ techniques developed for distributed database systems <ref> [152, 153] </ref>, whereby a CR has a logical structure that is monolithic, but a physical structure that is actually distributed. Use of such techniques can yield databases that are more efficient and more forgiving of network failures than are their physically monolithic counterparts, but further analysis is 188 CHAPTER 8.
Reference: [154] <author> Frank G. Pagan, </author> <title> Formal Specification of Programming Languages. </title> <booktitle> Prentice-Hall Software Series, </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: MODEL 47 It may seem unnatural to place the responsibility for name-binding entirely on the views in an MVDE, but in fact this separation of name-binding concerns between the CR and the views is precisely the same as that between environments and stores in the denotational semantics of programming languages <ref> [208, 154] </ref>. That is, in terms of denotational semantics, the CR handles stores (values in memory), while views handle environments (name-binding). In fact, the Ergo project adopted an equivalent approach by deciding to rely on the simply typed -calculus as a representation language.
Reference: [155] <author> James L. Peterson, </author> <title> "Petri Nets," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 9, no. 3, </volume> <pages> pp. 223-252, </pages> <month> September </month> <year> 1977. </year> <note> 280 BIBLIOGRAPHY </note>
Reference-contexts: As usual, features present in an SPG and absent in a Petri net must be approximated, black-boxed, or omitted (see Section 6.4.1). 1 I employ Peterson's terminology <ref> [155] </ref> in this appendix when I discuss Petri nets, hence transitions and places are connected by arcs, not edges. <p> A.1. MAPPING BETWEEN PETRI NETS AND SPGS 193 Figure A-3: A sample Petri net. This is essentially identical to Figure 1 of Peterson's survey <ref> [155] </ref>. to represent either a transition or a place, then, it becomes easy to determine whether groupings near the given grouping represent places or transitions.
Reference: [156] <author> Nathan H. Petschenik, </author> <title> "Practical Priorities in System Testing," </title> <journal> IEEE Software, </journal> <pages> pp. 18-23, </pages> <month> September </month> <year> 1985. </year>
Reference-contexts: Petschenik <ref> [156] </ref> has pointed out that for the large system he works with (over 2 million source lines), as much code would be required for the formally required test cases as for the system itself. 6.6. SUITABLE VIEWS 145 as statement or branch coverage.
Reference: [157] <author> John Placer, </author> <title> "Integrating Destructive Assignment and Lazy Evaluation in the Multi-paradigm Language G-2," </title> <journal> ACM SIGPLAN Notices, </journal> <volume> vol. 27, no. 2, </volume> <pages> pp. 65-74, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 <ref> [157] </ref> Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages. <p> Other multiparadigm work includes Zave's research into composing different independent paradigms [226]; the explicitly multiparadigm languages Loops [22, 195], Daisy II [62], Leda [33], and G-2 <ref> [157] </ref>; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors as a basis for concurrent programming [1]; the CODE system for developing parallel applications [32]; the wide-spectrum languages V [188], CIP-L [17], and PLEASE [209]; and the work by Zave and Jackson on formally
Reference: [158] <author> Michael Platoff and Michael Wagner, </author> <title> "An Integrated Program Representation and Toolkit for the Maintenance of C Programs," </title> <booktitle> in Proceedings of the 1991 Conference on Software Maintenance, </booktitle> <pages> pp. 129-137, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant <ref> [158] </ref> TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views. <p> In fact, none of the environments mentioned above allows programmers to define new views. Similar difficulties arise with program representations based on abstract syntax graphs, such as those used in IPSEN [139], the Maintainer's Assistant <ref> [158] </ref> and TEAM [40]. The Programmer's Apprentice project [172, 173] has employed the Plan Calculus [170] for a variety of systems. The Plan Calculus is a graph-based representation for programs that incorporates both control- and dataflow information.
Reference: [159] <author> Terrence W. Pratt, </author> <title> Programming Languages: Design and Implementation. </title> <publisher> Prentice-Hall, </publisher> <year> 1975. </year>
Reference-contexts: Program representations that lack support for scopes suffer from important 10 The omission of by-name parameter passing is not incidental. Although such parameters can be represented as thunks in the usual manner <ref> [159] </ref> and a special annotation can be associated with them so that views can easily identify the role they play, in the general case | in particular, in conjunction with recursion in the calling routine | thunks act like continuations, and continuations are not part of my view model. 11 This <p> The result is that name-binding within the CR is trivial, and views are responsible for mapping between view-specific name binding rules and the unambiguous references used in the CR. 12 These rules were more specific than those defined by Pratt for identifier associations <ref> [159, p. 185] </ref>, but they were similar in spirit. 3.5.
Reference: [160] <author> Georg Raeder, </author> <title> "A Survey of Current Graphical Programming Techniques," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 11-25, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: Examples of this less conventional approach to software development include structured analysis [177], Fabrik [97], statecharts, grids [149, 150], and graphical interfaces to conventional languages [55]. Further examples can be found in the surveys by Raeder <ref> [160] </ref>, Myers [138], and Davis [47]; the introductory books 1 The question is still open in the field of object-oriented databases, however [184, 86]. 2 For the purposes of this thesis, the terms "programming environments," "software development environments," "software engineering environments," etc., are all synonyms.
Reference: [161] <author> Wolfgang Reisig, </author> <title> Petri Nets: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference: [162] <author> Steven P. Reiss, </author> <title> "Generation of Compiler Symbol Processing Mechanisms from Specifications," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 5, no. 2, </volume> <pages> pp. 127-163, </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: Practically speaking, it would have made it too difficult. (An example of the complexity of such a language can be found in Reiss' work on the automatic generation of symbol table routines for use in compilers <ref> [162] </ref>.) * Defining the name-binding rules for a scope created in one view and then modified in another view was problematic. Suppose a scope S is created in view V 1 . Naturally, it assumes the name-binding conventions of V 1 .
Reference: [163] <author> Steven P. Reiss, </author> <title> "PECAN: Program Development Systems that Support Multiple Views," </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pp. 276-285, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: Experience with AST-based environments has revealed that ASTs are not a flexible enough representation to support a sufficiently wide class of tools. In fact, Garlan's work on view-oriented databases was motivated by difficulties encountered when trying to expand the AST-based Gandalf environment [78]. Similarly, Reiss' experience with PECAN <ref> [163] </ref> led him to conclude that ASTs are particularly poorly suited for nonlinear views of programs, especially graphical views. I suspect that any representation based on syntax will prove to be too limiting, including those based on abstract syntax graphs. <p> As noted in Section 2.2.5, the most common representation investigated has been the abstract syntax tree (AST). ASTs are at the core of many well-known programming environments, including the Cornell Program Synthesizer [168], Gandalf [78], Pecan <ref> [163] </ref>, R n [89], MENTOR [53], and CENTAUR [24]. The centerpiece of these environments is a language-based editor, which usually offers incremental syntactic and semantic analysis of the program being edited, plus incremental code generation. <p> APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN <ref> [163] </ref> Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia
Reference: [164] <author> Steven P. Reiss, </author> <title> "Working in the Garden Environment for Conceptual Programming," </title> <journal> IEEE Software, </journal> <pages> pp. 16-27, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Yet few current development environments offer explicit support for multiple views, and almost none have as a primary concern the ability of developers to easily define custom views. (The sole exceptions are Voyeur and Garden <ref> [164] </ref>.) The research described in this thesis directly addresses these shortcomings of current programming environments. 1.3 Integrating Views It is useful to have multiple views available, but it is equally useful to work with more than one view at a time. <p> The research into multiparadigm environments is summarized in Table 2-2. The Draco system [140, 141], Ipser's subsequent work on multi-formalism specification environments [98, 99], and Wile's research into "local formalisms" [221] explicitly provides support for (textual) user-defined languages that translate into a common base language, while Garden <ref> [164] </ref> and the Visual Programmer's WorkBench [179] concentrate on the creation of 2.4. A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops <p> languages that translate into a common base language, while Garden <ref> [164] </ref> and the Visual Programmer's WorkBench [179] concentrate on the creation of 2.4. A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages.
Reference: [165] <author> Steven P. Reiss, </author> <title> "Connecting Tools using Message Passing in the FIELD Program Development Environment," </title> <journal> IEEE Software, </journal> <pages> pp. 57-67, </pages> <month> July </month> <year> 1990. </year> <note> Also available as Brown University Computer Science Department Technical Report CS-88-18, "Integration Mechanisms in the FIELD Environment," </note> <month> October </month> <year> 1988. </year>
Reference-contexts: CGE also shows which routines are currently on the stack by highlighting them in a different color, behavior that can be found in the call graph display tool of the FIELD programming environment <ref> [165] </ref>. If S exhibits parallelism, then both TE and CGE might highlight more than one thing at a time during execution of S. In this idealized environment, software development might proceed as follows: 1. <p> In short, integration based only on a shared file system allows new tools to be easily created and added, but offers little in the way of consistency, inter-tool communication, support for multiple developers, or elimination of redundant effort. 2.2.2 Message Passing The FIELD environment <ref> [165] </ref> was motivated by a desire to overcome many of the drawbacks of traditional environments while still taking advantage of the plethora of tools that already run under Unix. <p> APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD <ref> [165] </ref> Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE <p> The language itself was evolving rapidly [196, 199, 197, 198, 110], 265 266 APPENDIX C. SPG-RELATED PUBLICATIONS and existing development tools were proving to be unexpectedly frustrating. Steven P. Reiss and I set out to enhance the FIELD environment <ref> [165] </ref> to offer better support for C++ software development, and we reported our early efforts in this paper [166], which primarily described a class browser we had developed: * Steven P. Reiss and Scott Meyers, "FIELD Support for C++," in USENIX C++ Con ference Proceedings, April 1990.
Reference: [166] <author> Steven P. Reiss and Scott Meyers, </author> <title> "FIELD Support for C++," </title> <booktitle> in USENIX C++ Conference Proceedings, </booktitle> <pages> pp. 293-299, </pages> <month> April </month> <year> 1990. </year> <note> Also available as Brown University Computer Science Department Technical Report CS-93-03, </note> <month> February </month> <year> 1993. </year>
Reference-contexts: It is possible to create development environments in which a semantically neutral action in one view can cause a change in other views. For example, selecting a C++ class in the FIELD class browser <ref> [166] </ref> causes the text editor to automatically jump to the corresponding class declaration in the C++ source code. <p> It became apparent early on that programming tools designed for languages like C were unsatisfactory when applied to C++, so Steven P. Reiss and I collaborated on enhancements to FIELD to better support the specialized needs of C++ programmers <ref> [166] </ref>. <p> SPG-RELATED PUBLICATIONS and existing development tools were proving to be unexpectedly frustrating. Steven P. Reiss and I set out to enhance the FIELD environment [165] to offer better support for C++ software development, and we reported our early efforts in this paper <ref> [166] </ref>, which primarily described a class browser we had developed: * Steven P. Reiss and Scott Meyers, "FIELD Support for C++," in USENIX C++ Con ference Proceedings, April 1990.
Reference: [167] <author> Steven P. Reiss, Scott Meyers, and Carolyn Duby, </author> <title> "Using GELO to Visualize Software Systems," </title> <booktitle> in Proceedings of UIST '89, </booktitle> <month> October </month> <year> 1989. </year>
Reference-contexts: The first view was originally designed only for debugging. My goal was to simply draw a pictorial representation of an SPG. To produce an image of the graph, I took advantage of the automatic layout capabilities of the GELO library <ref> [167] </ref>, and the resulting view is known as the GELO view. Implementation of the GELO view was substantially less straightforward than a simple data-structure dump, because GELO is unable to draw pictures of hyperedges or of edges that terminate at other edges.
Reference: [168] <author> Thomas Reps and Tim Teitelbaum, </author> <title> "The Synthesizer Generator," </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <month> May </month> <year> 1984. </year>
Reference-contexts: As noted in Section 2.2.5, the most common representation investigated has been the abstract syntax tree (AST). ASTs are at the core of many well-known programming environments, including the Cornell Program Synthesizer <ref> [168] </ref>, Gandalf [78], Pecan [163], R n [89], MENTOR [53], and CENTAUR [24]. The centerpiece of these environments is a language-based editor, which usually offers incremental syntactic and semantic analysis of the program being edited, plus incremental code generation. <p> APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator <ref> [169, 168] </ref> (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table
Reference: [169] <author> Thomas W. Reps, </author> <title> Generating Language-Based Environments. </title> <type> Ph.D. thesis, </type> <institution> Cornell University, </institution> <year> 1983. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator <ref> [169, 168] </ref> (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table
Reference: [170] <author> Charles Rich, </author> <title> "A Formal Representation for Plans in the Programmer's Apprentice," </title> <booktitle> in Proceedings of the Seventh international Joint Conference on Artificial Intelligence (IJCAI-81), </booktitle> <pages> pp. 1044-1052, </pages> <month> August </month> <year> 1981. </year> <note> Reprinted in M. </note> <editor> Brodie, J. Mylopoulos, BIBLIOGRAPHY 281 and J. Schmidt, editors, </editor> <booktitle> On Conceptual Modelling, </booktitle> <pages> pages 239-270, </pages> <publisher> Springer-Verlag, </publisher> <year> 1984, </year> <editor> and in C. Rich and R. C. Waters, editors, </editor> <booktitle> Readings in Artificial Intelligence and Software Engineering, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1986. </year>
Reference-contexts: Similar difficulties arise with program representations based on abstract syntax graphs, such as those used in IPSEN [139], the Maintainer's Assistant [158] and TEAM [40]. The Programmer's Apprentice project [172, 173] has employed the Plan Calculus <ref> [170] </ref> for a variety of systems. The Plan Calculus is a graph-based representation for programs that incorporates both control- and dataflow information. <p> Semantics approximation is not the only recourse, however, and I discuss this issue further | along with its alternatives | in Chapter 6. 50 CHAPTER 3. DESIGNING A REPRESENTATION 3.7 An Evaluation of Existing Canonical Representations During their design of the Plan Calculus <ref> [170] </ref>, Rich and Waters identified "four key properties essential to a knowledge representation" for software systems. These are "canonical form, language independence, convenience of manipulation, and expressiveness" [173, p. 23].
Reference: [171] <author> Charles Rich and Richard C. Waters, </author> <title> "Automatic Programming: Myths and Prospects," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 40-51, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Such criticism is unwarranted. The measure of success of an MVDE should not be whether it can generate output that is comparable to that of a human. Not even AI-based development environments are that ambitious <ref> [171] </ref>. Rather, it should be whether the MVDE is able to automatically produce useful views.
Reference: [172] <author> Charles Rich and Richard C. Waters, </author> <title> "The Programmer's Apprentice: A Research Overview," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 10-25, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: In fact, none of the environments mentioned above allows programmers to define new views. Similar difficulties arise with program representations based on abstract syntax graphs, such as those used in IPSEN [139], the Maintainer's Assistant [158] and TEAM [40]. The Programmer's Apprentice project <ref> [172, 173] </ref> has employed the Plan Calculus [170] for a variety of systems. The Plan Calculus is a graph-based representation for programs that incorporates both control- and dataflow information. <p> Rich and Waters, the primary architects of the Programmer's Apprentice project, suggest that the Plan Calculus would be well-suited to supporting multiple interacting views, but they have so far chosen not to pursue this avenue of research <ref> [172] </ref>. Program dependence graphs [58] were originally developed as a way to facilitate code optimization and/or parallelization, but since then they have found favor in a variety of 2.5. CONCLUSIONS 31 applications, including interactive code restructuring [74] and integration of program variants [93].
Reference: [173] <author> Charles Rich and Richard C. Waters, </author> <title> The Programmer's Apprentice. </title> <publisher> ACM Press Frontier Series, ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: In fact, none of the environments mentioned above allows programmers to define new views. Similar difficulties arise with program representations based on abstract syntax graphs, such as those used in IPSEN [139], the Maintainer's Assistant [158] and TEAM [40]. The Programmer's Apprentice project <ref> [172, 173] </ref> has employed the Plan Calculus [170] for a variety of systems. The Plan Calculus is a graph-based representation for programs that incorporates both control- and dataflow information. <p> DESIGNING A REPRESENTATION 3.7 An Evaluation of Existing Canonical Representations During their design of the Plan Calculus [170], Rich and Waters identified "four key properties essential to a knowledge representation" for software systems. These are "canonical form, language independence, convenience of manipulation, and expressiveness" <ref> [173, p. 23] </ref>. Their concerns mirror my own, although their interest in convenience of manipulation, which is founded on their desire to perform sophisticated program analyses, is focused differently than mine, which concentrates on the representation's suitability as both source and target of mappings to and from views. <p> The problem of designing a canonical form is a difficult one. Work on the Plan Calculus, for example, has been in progress for over a decade, and there is still no canonical form for programs using that representation <ref> [173, p. 32-33] </ref>. That notwithstanding, it would be interesting to investigate whether some aspects of SPGs could be made to have canonical forms, because the dividends yielded by such forms are great.
Reference: [174] <author> Charles Rich and Linda M. Wills, </author> <title> "Recognizing a Program's Design: A Graph-Parsing Approach," </title> <journal> IEEE Software, </journal> <pages> pp. 82-89, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer <ref> [174] </ref> Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views. <p> The Plan Calculus is a graph-based representation for programs that incorporates both control- and dataflow information. It has been successfully incorpo rated into the KBEmacs system for partial program synthesis [219], into Satch and Cobbler for automatic program translation [220], and into the Recognizer <ref> [174] </ref>, a program that identifies design features in existing programs. Rich and Waters, the primary architects of the Programmer's Apprentice project, suggest that the Plan Calculus would be well-suited to supporting multiple interacting views, but they have so far chosen not to pursue this avenue of research [172].
Reference: [175] <author> Richard A. Demillo et al., </author> <title> Software Testing And Evaluation. </title> <publisher> Benjamin/Cummings Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: A number of approaches to software testing have been proposed, along with an even greater number of metrics for measuring the effectiveness of the different approaches <ref> [18, 175] </ref>, but in practice, most software developers who formally test their software 6 rely on relatively simple structural testing criteria, such 6 Those who do not may have good reason.
Reference: [176] <author> Thomas Rodden, Pete Sawyer, and Ian Sommerville, </author> <title> "Interacting with an Active, Integrated Environment," </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pp. 76-84, </pages> <month> November </month> <year> 1988. </year> <note> Published as ACM SIGSOFT Software Engineering Notes 13:5, </note> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices 24:2, </journal> <month> February </month> <year> 1989. </year>
Reference-contexts: Environments based on message passing fall into two basic camps. Environments following the FIELD model of Section 2.2.2 include, in addition to FIELD itself, the commercial implementations SOFTBENCH [34], FUSE [51], ToolTalk [202], and CASEVision/Workshop, 6 as well as the research efforts Forest [67], ISM <ref> [176] </ref>, and the work on Mediators [200]. Forest extends the FIELD model by adding support for policies, which offer flexible user-defined control over the conditions under which messages are passed. ISM employs a message-based approach to integration, but it has more of an AI perspective to its application. <p> APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM <ref> [176] </ref> [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database
Reference: [177] <author> Douglas T. Ross, </author> <title> "Structured Analysis (SA): A Language for Communicating Ideas," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-3, no. 1, </volume> <pages> pp. 16-34, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: Environment support for program development has traditionally focused on textual depictions of programs | usually source code | but it's important to note the increasing interest in nonlinear programming languages. Examples of this less conventional approach to software development include structured analysis <ref> [177] </ref>, Fabrik [97], statecharts, grids [149, 150], and graphical interfaces to conventional languages [55]. <p> In particular, parallel execution of subexpressions is limited only by data dependencies, and subprogram calls are non-strict. Examples of this approach to computation include the languages Id [9], Haskell [83], and Lucid [10, 215]. Dataflow is also the basis of a number of high-level design methodologies, e.g., Structured Analysis <ref> [177, 178] </ref>. * The final paradigm is parallel control flow computing, which offers software developers explicit control over the creation of multiple processes and the communication between those processes as they run.
Reference: [178] <author> Douglas T. Ross, </author> <title> "Applications and Extensions of SADT," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 25-34, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: In particular, parallel execution of subexpressions is limited only by data dependencies, and subprogram calls are non-strict. Examples of this approach to computation include the languages Id [9], Haskell [83], and Lucid [10, 215]. Dataflow is also the basis of a number of high-level design methodologies, e.g., Structured Analysis <ref> [177, 178] </ref>. * The final paradigm is parallel control flow computing, which offers software developers explicit control over the creation of multiple processes and the communication between those processes as they run.
Reference: [179] <author> Robert V. Rubin, James Walker II, and Eric J. Golin, </author> <title> "Early Experience with the Visual Programmer's WorkBench," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 16, no. 10, </volume> <pages> pp. 1107-1121, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The Draco system [140, 141], Ipser's subsequent work on multi-formalism specification environments [98, 99], and Wile's research into "local formalisms" [221] explicitly provides support for (textual) user-defined languages that translate into a common base language, while Garden [164] and the Visual Programmer's WorkBench <ref> [179] </ref> concentrate on the creation of 2.4. <p> A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench <ref> [179] </ref> (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages.
Reference: [180] <author> Barbara G. Ryder and Marvin C. Paull, </author> <title> "Incremental Data-Flow Analysis Algorithms," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 10, no. 1, </volume> <pages> pp. 1-50, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: A substantive change to an SPG need not trigger an update in all views, because some views may not depict the aspect (s) of the SPG that are affected by the change. 6.4. MISMATCHES BETWEEN SPGS AND VIEWS 135 for use in interactive development environments <ref> [204, 144, 225, 4, 180] </ref>. An ideal algorithm for updating a presentation, of course, is as predictable as a batch-mode computation and as efficient as an incremental one. Unfortunately, it may be the case that no such algorithm has been developed for a particular presentation.
Reference: [181] <author> Stuart C. Schaffner and Martha Borkan, "Segue: </author> <title> Support for Distributed Graphical Interfaces," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 42-55, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: For example, a window-based PM would need data structures to keep track of what windows are on the screen, which SPG components are displayed in various windows, etc. Such data structures may be encapsulated in a user interface management system (UIMS) <ref> [181, 95] </ref>. PMs, then, must directly or indirectly manipulate two sets of data structures: the SPG that represents the software system being presented and presentation-specific data structures that are used to implement an interface to a view.
Reference: [182] <author> Robert W. Scheifler and James Gettys, </author> <title> X Window System: The Complete Reference to Xlib, X Protocol, ICCCM, XLFD. </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference: [183] <author> J. T. Schwartz, R. B. K. Dewar, E. Dubinsky, and E. Schonberg, </author> <title> Programming With Sets: An Introduction to SETL. </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> 282 BIBLIOGRAPHY </note>
Reference-contexts: For example, the designer of a representation need not provide support for unusually high level languages like Prolog or SETL <ref> [183] </ref>, nor for unusually low level programming languages like assembler. This does not imply that a representation need not cater to high level views at all. Far from it.
Reference: [184] <author> John J. Shilling and Peter F. Sweeney, </author> <title> "Three Steps to Views: Extending the Object-Oriented Paradigm," </title> <booktitle> in Proceedings of the 1989 Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '89), </booktitle> <pages> pp. 353-361, </pages> <month> Octo-ber </month> <year> 1989. </year>
Reference-contexts: Further examples can be found in the surveys by Raeder [160], Myers [138], and Davis [47]; the introductory books 1 The question is still open in the field of object-oriented databases, however <ref> [184, 86] </ref>. 2 For the purposes of this thesis, the terms "programming environments," "software development environments," "software engineering environments," etc., are all synonyms. I am concerned with issues that affect both single-developer endeavors (programming-in-the-small) as well as projects arising from teams of developers (programming-in-the-large). 4 CHAPTER 1.
Reference: [185] <author> Nan C. Shu, </author> <title> Visual Programming. </title> <address> New York, New York: </address> <publisher> Van Nostrand Reinhold, </publisher> <year> 1988. </year>
Reference-contexts: I am concerned with issues that affect both single-developer endeavors (programming-in-the-small) as well as projects arising from teams of developers (programming-in-the-large). 4 CHAPTER 1. INTRODUCTION by Shu <ref> [185] </ref> and Chang [37]; and the proceedings of the IEEE workshops on visual languages (held in 1984 and annually since 1986). The result of this interest is that the number and types of views available to software developers is continually increasing. Certainly, then, multiple views are natural.
Reference: [186] <author> Abraham Silberschatz, James L. Peterson, and Peter B. Galvin, </author> <title> Operating System Concepts. </title> <publisher> Addison Wesley, </publisher> <editor> third ed., </editor> <year> 1991. </year>
Reference-contexts: Such languages typically offer little syntactic distinction between intraprocess subprogram calls and interprocess communication; 5 this tends to be the case where callers of both subprograms and entries are anonymous, as in Ada, Occam, and systems featuring remote procedure calls <ref> [186] </ref>. A more important advantage of my design for call sites is that SPGs explicitly reflect the widespread outlook among software developers that sequential programs are in some sense fundamentally different from parallel programs.
Reference: [187] <author> Andrea H. Skarra, Stanley B. Zdonik, and Steven P. Reiss, </author> <title> "ObServer: An Object Server for an Object-Oriented Database System," </title> <type> Technical Report CS-88-08, </type> <institution> Brown University Department of Computer Science, </institution> <month> July </month> <year> 1987. </year> <note> Revised and reprinted in K. </note> <editor> R. Dittrich, U. Dayal, and A. P. Buchmann, editors, </editor> <booktitle> On Object-Oriented Database Systems, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Therefore, it may be possible to adapt the research done on flexible transaction models <ref> [187, 13, 228, 143] </ref> to the particular needs of multiple-view software development environments.
Reference: [188] <author> Douglas R. Smith, Gordon B. Kotik, and Stephen J. Westfold, </author> <title> "Research on Knowledge-Based Software Environments at Kestrel Institute," </title> <type> Technical Report KES.U.85.7, </type> <institution> Kestrel Institute, </institution> <month> July </month> <year> 1985. </year>
Reference-contexts: A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V <ref> [188] </ref> Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages. <p> the explicitly multiparadigm languages Loops [22, 195], Daisy II [62], Leda [33], and G-2 [157]; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors as a basis for concurrent programming [1]; the CODE system for developing parallel applications [32]; the wide-spectrum languages V <ref> [188] </ref>, CIP-L [17], and PLEASE [209]; and the work by Zave and Jackson on formally composing partial specifications [227]. 2.4.2 MVDEs Not Using a Canonical Representation Table 2-3 summarizes research into MVDEs that achieve integration by a mechanism other than a shared canonical representation.
Reference: [189] <author> Richard Snodgrass and Karen Shannon, </author> <title> "Fine Grained Data Management To Achieve Evolution Resilience in a Software Development Environment," </title> <booktitle> in Proceedings of the Fourth ACM SIGSOFT Symposium on Software Development Environments (SIG-SOFT '90) (Richard N. </booktitle> <publisher> Taylor, ed.), </publisher> <pages> pp. 144-156, </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1990. </year> <note> Published as SIGSOFT Software Engineering Notes 15:6, </note> <month> December </month> <year> 1990. </year>
Reference-contexts: Therefore, the ability of an integration mechanism to gracefully accommodate environment evolution is an important concern. Several researchers have designed systems that specifically deal with this problem <ref> [200, 189] </ref>, but in this thesis I disregard this aspect of integration. Instead, I focus my efforts on the equally compelling problems associated with integrating divergent views. 1 Not everyone agrees with this sentiment.
Reference: [190] <author> Alan Snyder, </author> <title> "The Essence of Objects: Concepts and Terms," </title> <journal> IEEE Software, </journal> <pages> pp. 31-42, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: This division of an MVDE into separate entities to manage the semantics of the underlying system (the SPGM) and the presentation of those semantics to users (the PMs) has been termed a presentation-semantic split <ref> [190] </ref>.
Reference: [191] <author> David Socha, Mary L. Bailey, and David Notkin, "Voyeur: </author> <title> Graphical Views of Parallel Programs," </title> <type> technical report, </type> <institution> University of Washington Computer Science Department, </institution> <address> Seattle, Washington, </address> <year> 1988. </year> <booktitle> Presented at the ACM Workshop on Parallel and Distributed Debugging, </booktitle> <month> May </month> <year> 1988. </year>
Reference-contexts: The dynamic aspects of a dynamic view may be simple and straightforward, such as highlighting the routine currently being executed in a graphical call graph, or may be arbitrarily complex, such as a hand-crafted algorithmic animation <ref> [30, 194, 191] </ref>. Some views, such as source code, may be editable. Other views, such as the output from a program profiler, may be inherently read-only. This definition of a view is consistent with that of updatable views in the database world [105]. <p> If these costs are too great, programmers will be discouraged from constructing views appropriate for a given program. . . . Since each parallel program might require its own view or views, it must be feasible for all parallel programmers, not just specially trained experts, to construct views effectively <ref> [191, p. 1] </ref>. In sum, multiple-view software development emerges naturally from the intrinsically multi-faceted nature of software systems, is already embraced by programmers as a matter of current practice, and can be theoretically defended. <p> My research, therefore, concentrates on addressing these more fundamental 1.5. CONTRIBUTIONS OF THIS RESEARCH 9 issues, rather than on the physical act of writing views. This is in contrast to the Voyeur system <ref> [191] </ref>, for example, which presupposes the existence of a suitable information source and integration mechanism; it is primarily concerned with facilitating the physical production of views. This scenario provides a sense of what it might be like to develop software through multiple interacting views. <p> Another message-based architecture that may seem to support multiple views is embraced by algorithm animation systems based on "interesting events." Some of the best known of such systems are Balsa [29, 30], TANGO [193, 194], and Voyeur <ref> [191] </ref>, but there is a fundamental difference between these kinds of systems and the MVDEs that are the subject of my work: systems based on interesting events cannot provide views of a program until the program is instrumented to produce the interesting events.
Reference: [192] <author> Richard M. Stallman, </author> <title> "EMACS: The Extensible, Customizable, Self-Documenting Display Editor," </title> <booktitle> in Proceedings of the ACM SIGPLAN/SIGOA Symposium on text Manipulation, </booktitle> <pages> pp. 147-156, </pages> <month> June </month> <year> 1981. </year> <note> Reprinted in [16, pp. 300-325]. </note>
Reference-contexts: Some programs (e.g., GNU Emacs <ref> [192] </ref>) attempt to prevent more than one person at a time from editing a single file, but my contention is that this is a duty for the integration mechanism, not something that should be left to individual tools in the environment. 2.2. <p> This insight spurred collaborative work with Moises Lejter and Steven P. Reiss that resulted in enhancements 152 CHAPTER 6. USING SPGS to EMACS <ref> [192] </ref> and FIELD that yielded an experimental version of EMACS that offers programmers the ability to invoke semantics-based editing commands on C++ programs [117, 118]. As a result of my implementation work on SPGs, I became interested in the problem of avoiding common but unintuitive errors in C++ programs. <p> At the same time, Moises Lejter and Steven P. Reiss Reiss and I undertook an effort to enhance FIELD and Emacs <ref> [192] </ref> to specifically address the problems I had identified. Our work was described in this paper [117]: * Moises Lejter, Scott Meyers, and Steven P. Reiss, "Adding Semantic Information To C++ Development Environments," in Proceedings of C++ at Work-'90, September 1990.
Reference: [193] <author> John T. Stasko, </author> <title> TANGO: A Framework and System for Algorithm Animation. </title> <type> Ph.D. thesis, </type> <institution> Brown University Department of Computer Science, </institution> <year> 1989. </year>
Reference-contexts: Another message-based architecture that may seem to support multiple views is embraced by algorithm animation systems based on "interesting events." Some of the best known of such systems are Balsa [29, 30], TANGO <ref> [193, 194] </ref>, and Voyeur [191], but there is a fundamental difference between these kinds of systems and the MVDEs that are the subject of my work: systems based on interesting events cannot provide views of a program until the program is instrumented to produce the interesting events. <p> Modeling data structures is certainly important, and support for data structures could be added to the model I propose here, but that is an aspect of views I have chosen not to address in this thesis. This is analogous to research on systems for algorithm animation <ref> [29, 193] </ref>. Such systems focus entirely on what happens to the data in an application, completely ignoring the control structures within the application that are responsible for generating and manipulating the data.
Reference: [194] <author> John T. Stasko, </author> <title> "TANGO: A Framework and System for Algorithm Animation," </title> <journal> IEEE Computer, </journal> <volume> vol. 23, no. 9, </volume> <pages> pp. 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The dynamic aspects of a dynamic view may be simple and straightforward, such as highlighting the routine currently being executed in a graphical call graph, or may be arbitrarily complex, such as a hand-crafted algorithmic animation <ref> [30, 194, 191] </ref>. Some views, such as source code, may be editable. Other views, such as the output from a program profiler, may be inherently read-only. This definition of a view is consistent with that of updatable views in the database world [105]. <p> Another message-based architecture that may seem to support multiple views is embraced by algorithm animation systems based on "interesting events." Some of the best known of such systems are Balsa [29, 30], TANGO <ref> [193, 194] </ref>, and Voyeur [191], but there is a fundamental difference between these kinds of systems and the MVDEs that are the subject of my work: systems based on interesting events cannot provide views of a program until the program is instrumented to produce the interesting events.
Reference: [195] <author> Mark J. Stefik, Daniel G. Bobrow, and Kenneth M. Kahn, </author> <title> "Integrating Access-Oriented Programming into a Multiparadigm Environment," </title> <journal> IEEE Software, </journal> <pages> pp. 10-18, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops <ref> [22, 195] </ref> PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages. <p> <ref> [22, 195] </ref> PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages. Other multiparadigm work includes Zave's research into composing different independent paradigms [226]; the explicitly multiparadigm languages Loops [22, 195], Daisy II [62], Leda [33], and G-2 [157]; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors as a basis for concurrent programming [1]; the CODE system for developing parallel applications [32]; the wide-spectrum languages V [188], CIP-L [17], and PLEASE [209];
Reference: [196] <author> Bjarne Stroustrup, </author> <title> "Multiple Inheritance for C++," </title> <booktitle> in Proceedings EUUG Spring '87 Conference, </booktitle> <year> 1987. </year> <note> BIBLIOGRAPHY 283 </note>
Reference-contexts: Reiss, "A System for Multiparadigm Development of Software Systems," in Proceedings of the Sixth International Workshop on Software Specification and Design, October 1991. My decision in early 1989 to develop a prototype SPG implementation in C++ turned out to be a fateful one. The language itself was evolving rapidly <ref> [196, 199, 197, 198, 110] </ref>, 265 266 APPENDIX C. SPG-RELATED PUBLICATIONS and existing development tools were proving to be unexpectedly frustrating. Steven P.
Reference: [197] <author> Bjarne Stroustrup, </author> <title> "Possible Directions for C++," </title> <booktitle> in 1987 USENIX C++ Papers, </booktitle> <pages> pp. 399-416, </pages> <year> 1987. </year>
Reference-contexts: Reiss, "A System for Multiparadigm Development of Software Systems," in Proceedings of the Sixth International Workshop on Software Specification and Design, October 1991. My decision in early 1989 to develop a prototype SPG implementation in C++ turned out to be a fateful one. The language itself was evolving rapidly <ref> [196, 199, 197, 198, 110] </ref>, 265 266 APPENDIX C. SPG-RELATED PUBLICATIONS and existing development tools were proving to be unexpectedly frustrating. Steven P.
Reference: [198] <author> Bjarne Stroustrup, </author> <title> "Parameterized Types for C++," </title> <booktitle> in 1988 USENIX C++ Conference, </booktitle> <pages> pp. 1-18, </pages> <year> 1988. </year>
Reference-contexts: Reiss, "A System for Multiparadigm Development of Software Systems," in Proceedings of the Sixth International Workshop on Software Specification and Design, October 1991. My decision in early 1989 to develop a prototype SPG implementation in C++ turned out to be a fateful one. The language itself was evolving rapidly <ref> [196, 199, 197, 198, 110] </ref>, 265 266 APPENDIX C. SPG-RELATED PUBLICATIONS and existing development tools were proving to be unexpectedly frustrating. Steven P.
Reference: [199] <author> Bjarne Stroustrup, </author> <title> "Type-Safe Linkage for C++," </title> <booktitle> in 1988 USENIX C++ Conference, </booktitle> <pages> pp. 193-210, </pages> <year> 1988. </year>
Reference-contexts: Reiss, "A System for Multiparadigm Development of Software Systems," in Proceedings of the Sixth International Workshop on Software Specification and Design, October 1991. My decision in early 1989 to develop a prototype SPG implementation in C++ turned out to be a fateful one. The language itself was evolving rapidly <ref> [196, 199, 197, 198, 110] </ref>, 265 266 APPENDIX C. SPG-RELATED PUBLICATIONS and existing development tools were proving to be unexpectedly frustrating. Steven P.
Reference: [200] <author> Kevin J. Sullivan and David Notkin, </author> <title> "Reconciling Environment Integration and Component Independence," </title> <booktitle> in Proceedings of the Fourth ACM SIGSOFT Symposium on Software Development Environments (SIGSOFT '90) (Richard N. </booktitle> <publisher> Taylor, ed.), </publisher> <pages> pp. 22-33, </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1990. </year> <note> Published as SIGSOFT Software Engineering Notes 15:6, </note> <month> December </month> <year> 1990. </year>
Reference-contexts: Therefore, the ability of an integration mechanism to gracefully accommodate environment evolution is an important concern. Several researchers have designed systems that specifically deal with this problem <ref> [200, 189] </ref>, but in this thesis I disregard this aspect of integration. Instead, I focus my efforts on the equally compelling problems associated with integrating divergent views. 1 Not everyone agrees with this sentiment. <p> Environments following the FIELD model of Section 2.2.2 include, in addition to FIELD itself, the commercial implementations SOFTBENCH [34], FUSE [51], ToolTalk [202], and CASEVision/Workshop, 6 as well as the research efforts Forest [67], ISM [176], and the work on Mediators <ref> [200] </ref>. Forest extends the FIELD model by adding support for policies, which offer flexible user-defined control over the conditions under which messages are passed. ISM employs a message-based approach to integration, but it has more of an AI perspective to its application. <p> APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators <ref> [200] </ref>] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65,
Reference: [201] <author> Sun Microsystems, Inc., </author> <title> Network Programming Guide, ch. 6: "External Data Representation Standard: Protocol Specification ", pp. </title> <type> 131-146. </type> <institution> Sun Microsystems, Inc., </institution> <month> March </month> <year> 1990. </year> <title> This protocol has been designated RFC1014 by the ARPA Network Information Center. </title>
Reference-contexts: Similarly, much work has been done on translating between different views of data structures without much regard for how those structures are manipulated by the programs in which they find themselves <ref> [85, 69, 102, 126, 217, 201, 31, 222] </ref>. Thus, a model of how a program is structured and how it executes can be largely divorced from the data structures it manipulates.
Reference: [202] <institution> Sun Microsystems, Inc., Mountain View, California, ToolTalk 1.0 Programmer's Guide, </institution> <year> 1991. </year>
Reference-contexts: Environments based on message passing fall into two basic camps. Environments following the FIELD model of Section 2.2.2 include, in addition to FIELD itself, the commercial implementations SOFTBENCH [34], FUSE [51], ToolTalk <ref> [202] </ref>, and CASEVision/Workshop, 6 as well as the research efforts Forest [67], ISM [176], and the work on Mediators [200]. Forest extends the FIELD model by adding support for policies, which offer flexible user-defined control over the conditions under which messages are passed. <p> APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk <ref> [202] </ref>] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical representation. evolution.
Reference: [203] <author> Andrew S. Tanenbaum, </author> <title> "A Tutorial on Algol 68," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 8, no. 2, </volume> <pages> pp. 155-190, </pages> <month> June </month> <year> 1976. </year>
Reference-contexts: The client/server relationship subsumes mechanisms for remote procedure calls. 13 Unfortunately, these fundamental uses are often obscured by the details of the precise mechanism available in a given language, which can range from semaphores (in Algol 68 <ref> [203] </ref>) to monitors (in Concurrent Pascal) to unidirectional message passing (in CSP) to bidirectional message passing (in Ada and Occam).
Reference: [204] <author> Tim Teitelbaum and Thomas Reps, </author> <title> "The Cornell Program Synthesizer: A Syntax-Directed Programming Environment," </title> <journal> Communications of the ACM, </journal> <month> September </month> <year> 1981. </year> <note> Reprinted in [16, pp. 97-116]. </note>
Reference-contexts: Nonetheless, the practical problem of coming up with the interesting events that drive an animation should not be underestimated. 30 CHAPTER 2. APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer <ref> [204] </ref> Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous <p> A substantive change to an SPG need not trigger an update in all views, because some views may not depict the aspect (s) of the SPG that are affected by the change. 6.4. MISMATCHES BETWEEN SPGS AND VIEWS 135 for use in interactive development environments <ref> [204, 144, 225, 4, 180] </ref>. An ideal algorithm for updating a presentation, of course, is as predictable as a batch-mode computation and as efficient as an incremental one. Unfortunately, it may be the case that no such algorithm has been developed for a particular presentation.
Reference: [205] <author> Warren Teitelman, </author> <title> "A Tour through Cedar," </title> <journal> IEEE Software, </journal> <month> April </month> <year> 1984. </year>
Reference-contexts: Sullivan's and Notkin's goal in their work on Mediators is a generalization of message-based integration that is designed to better support environment 6 CASEVision/Workshop is a commercial product from Silicon Graphics, Incorporated. 28 CHAPTER 2. APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar <ref> [205] </ref> FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS <p> A more familiar example of such a tightly coupled architecture is exhibited by closed, monolithic (typically everything is in a single address space), tightly-integrated, single-language environments like Interlisp [206], Cedar <ref> [205] </ref>, and Smalltalk [210]. In these environments, seemingly independent views are not really independent, because they are inextricably dependent on the other views in the system. For 2.4.
Reference: [206] <author> Warren Teitelman and Larry Masinter, </author> <title> "The Interlisp Programming Environment," </title> <journal> IEEE Computer, </journal> <volume> vol. 14, no. 4, </volume> <pages> pp. 25-34, </pages> <month> April </month> <year> 1981. </year> <note> Reprinted in [16, pp. 83-96]. </note>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp <ref> [206] </ref> ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk [210] SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] <p> A more familiar example of such a tightly coupled architecture is exhibited by closed, monolithic (typically everything is in a single address space), tightly-integrated, single-language environments like Interlisp <ref> [206] </ref>, Cedar [205], and Smalltalk [210]. In these environments, seemingly independent views are not really independent, because they are inextricably dependent on the other views in the system. For 2.4. <p> the Interlisp File package added a capability to notice when data was changed by defining a new function, MarkAsChanged, and then inserting calls to MarkAsChanged "in all of the parts of the Interlisp system that changed objects | the editor, the DEFINE function, the facility for (re)declaring records, and DWIM" <ref> [206, p. 27] </ref>.
Reference: [207] <author> Takao Tenma, Hideaki Tsubotani, Minoru Tanaka, and Tadao Ichikawa, </author> <title> "A System for Generating Language-Oriented Editors," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 14, no. 8, </volume> <pages> pp. 1098-1109, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Canonical Representation System [Mechanism] (Researchers) Abstract Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. <ref> [207] </ref>) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a
Reference: [208] <author> R. D. Tennent, </author> <title> "The Denotational Semantics of Programming Languages," </title> <journal> Communications of the ACM, </journal> <volume> vol. 19, no. 8, </volume> <pages> pp. 437-453, </pages> <month> August </month> <year> 1976. </year>
Reference-contexts: Third, it identifies and enforces a division between view-dependent semantics and view-independent semantics in an MVDE, a natural division that corresponds to the division between stores and environments in the denotational semantics of programming languages <ref> [208] </ref>. Fourth, it allows for a more flexible block and scoping structure than is offered in traditional languages. For example, it is possible for a portion of a program to be nested inside two or more different scopes, none of which have any nesting relationship with the others. <p> MODEL 47 It may seem unnatural to place the responsibility for name-binding entirely on the views in an MVDE, but in fact this separation of name-binding concerns between the CR and the views is precisely the same as that between environments and stores in the denotational semantics of programming languages <ref> [208, 154] </ref>. That is, in terms of denotational semantics, the CR handles stores (values in memory), while views handle environments (name-binding). In fact, the Ergo project adopted an equivalent approach by deciding to rely on the simply typed -calculus as a representation language.
Reference: [209] <author> Robert B. Terwilliger and Roy H. Campbell, "ENCOMPASS: </author> <title> an Environment for the Incremental Development of Software," </title> <type> Technical Report UIUCDCS-R-1296, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> October </month> <year> 1986. </year> <type> Preprint. </type>
Reference-contexts: A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE <ref> [209] </ref> V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages. <p> [22, 195], Daisy II [62], Leda [33], and G-2 [157]; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors as a basis for concurrent programming [1]; the CODE system for developing parallel applications [32]; the wide-spectrum languages V [188], CIP-L [17], and PLEASE <ref> [209] </ref>; and the work by Zave and Jackson on formally composing partial specifications [227]. 2.4.2 MVDEs Not Using a Canonical Representation Table 2-3 summarizes research into MVDEs that achieve integration by a mechanism other than a shared canonical representation.
Reference: [210] <author> Larry Tesler, </author> <title> "The Smalltalk Environment," </title> <journal> BYTE Magazine, </journal> <volume> vol. 6, no. 8, </volume> <pages> pp. 90-147, </pages> <month> August </month> <year> 1981. </year> <note> This paper is one of 11 articles on Smalltalk in this issue. </note>
Reference-contexts: APPROACHES TO VIEW INTEGRATION Approach to Integration System [Mechanism] (Researchers) Message Passing CASEVision/Workshop Cedar [205] FIELD [165] Forest [67] FUSE [51] Interlisp [206] ISM [176] [Mediators [200]] MLP [85, 84] [PCTE IPC [25, 57]] Prisma [142] Smalltalk <ref> [210] </ref> SOFTBENCH [34] [ToolTalk [202]] [ViewPoints [145, 60]] Simple Database Amadeus [21] CIA [39] COPE [7] Faust [76] MicroScope [6] Odin [41] OMEGA [121] [PCTE OMS [64]] PDS [38] RPDE 3 [81] Trellis [147] XREFDB [118] View-Oriented Database (Garlan [65, 66]) Janus [77] Table 2-3: MVDEs not based on a canonical <p> A more familiar example of such a tightly coupled architecture is exhibited by closed, monolithic (typically everything is in a single address space), tightly-integrated, single-language environments like Interlisp [206], Cedar [205], and Smalltalk <ref> [210] </ref>. In these environments, seemingly independent views are not really independent, because they are inextricably dependent on the other views in the system. For 2.4.
Reference: [211] <author> S. S. Thakkar, ed., </author> <title> Selected Reprints on Dataflow and Reduction Architectures. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year> <note> 284 BIBLIOGRAPHY </note>
Reference-contexts: In fact, because of these similarities, research on dataflow languages and functional languages frequently overlaps (see, for example, the motivation behind Lucid [215, p. ix-xii] and the collection of papers edited by Thakkar <ref> [211] </ref>). 8 Procedural languages typically use strict calls, while dataflow languages usually employ non-strict calls.
Reference: [212] <author> Philip C. Treleaven, David R. Brownbridge, and Richard P. Hopkins, </author> <title> "Data-Driven and Demand-Driven Computer Architecture," </title> <journal> Computing Surveys, </journal> <volume> vol. 14, no. 1, </volume> <pages> pp. 93-143, </pages> <month> March </month> <year> 1982. </year> <note> Reprinted in [211, 4-54]. </note>
Reference-contexts: In designing the executable aspects of SPGs, I was influenced by existing work in graph-based program representations. In particular, I was impressed by the the Combined model of computation advanced by Treleaven and his colleagues in their work on an architecture that supports both control- and data-driven execution <ref> [212] </ref>. I also took ideas from the Tagged-Token Dataflow Architecture [9], most notably in the area of support for non-strict subprogram calls.
Reference: [213] <author> Jeffrey D. Ullman, </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> vol. 1. </volume> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: In practice, researchers tend to ignore the differences between views and presentations, generally referring only to "views" unless context forces them to draw an explicit distinction. While there is almost universal agreement among researchers in the field of relational databases that a view is equivalent to a query <ref> [213] </ref>, 1 there is no corresponding agreement for the term in the field of programming environments. 2 As a result, there is an advantage to speaking informally: most everyone agrees on roughly what a view is, even though not everyone may agree on precisely what it is.
Reference: [214] <author> Nancy L. Urbano, </author> <title> "Heroism and Achilles in the Iliad," </title> <type> Master's thesis, </type> <institution> Brown University, </institution> <year> 1987. </year>
Reference: [215] <author> William W. Wadge and Edward A. Ashcroft, </author> <title> Lucid, the Dataflow Programming Language. </title> <publisher> Academic Press, </publisher> <year> 1985. </year>
Reference-contexts: In particular, parallel execution of subexpressions is limited only by data dependencies, and subprogram calls are non-strict. Examples of this approach to computation include the languages Id [9], Haskell [83], and Lucid <ref> [10, 215] </ref>. Dataflow is also the basis of a number of high-level design methodologies, e.g., Structured Analysis [177, 178]. * The final paradigm is parallel control flow computing, which offers software developers explicit control over the creation of multiple processes and the communication between those processes as they run. <p> In fact, because of these similarities, research on dataflow languages and functional languages frequently overlaps (see, for example, the motivation behind Lucid <ref> [215, p. ix-xii] </ref> and the collection of papers edited by Thakkar [211]). 8 Procedural languages typically use strict calls, while dataflow languages usually employ non-strict calls.
Reference: [216] <author> Larry Wall and Randal L. Schwartz, </author> <title> Programming perl. </title> <address> O'Reilly & Accociates, </address> <year> 1990. </year>
Reference-contexts: The value of an annotation may be null. Annotations are thus similar in form to Unix and DOS environment variables, resources in the X window system, associative arrays in awk [2] and Perl <ref> [216] </ref>, etc.
Reference: [217] <author> William B. Warren, Jerry Kickenson, and Richard Snodgrass, </author> <title> "A Tutorial Introduction to Using IDL," </title> <journal> ACM SIGPLAN Notices, </journal> <volume> vol. 22, no. 11, </volume> <pages> pp. 18-34, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Similarly, much work has been done on translating between different views of data structures without much regard for how those structures are manipulated by the programs in which they find themselves <ref> [85, 69, 102, 126, 217, 201, 31, 222] </ref>. Thus, a model of how a program is structured and how it executes can be largely divorced from the data structures it manipulates.
Reference: [218] <author> Richard C. Waters, </author> <title> "Program Editors Should Not Abandon Text Oriented Commands," </title> <journal> ACM SIGPLAN Notices, </journal> <pages> pp. 39-46, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: changes to be made to CGE in response to changes made to S via TE. 4 Most current environments allow programs to be syntactically invalid while they are being edited, because experience with structure editors demonstrated that forcing users to maintain syntactically valid programs during editing was an unacceptable restriction <ref> [218] </ref>. The COPE environment [44], however, was a novel experiment in that the responsibility for ensuring that a program was always grammatically valid fell on the environment , not the user. 8 CHAPTER 1. INTRODUCTION with the call graph and stack view explicitly shown. 5.
Reference: [219] <author> Richard C. Waters, </author> <title> "The Programmer's Apprentice: A Session with KBEmacs," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-11, no. 11, </volume> <pages> pp. 1296-1320, </pages> <month> November </month> <year> 1985. </year>
Reference-contexts: Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler [220] KBEmacs <ref> [219] </ref> Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views. <p> The Programmer's Apprentice project [172, 173] has employed the Plan Calculus [170] for a variety of systems. The Plan Calculus is a graph-based representation for programs that incorporates both control- and dataflow information. It has been successfully incorpo rated into the KBEmacs system for partial program synthesis <ref> [219] </ref>, into Satch and Cobbler for automatic program translation [220], and into the Recognizer [174], a program that identifies design features in existing programs.
Reference: [220] <author> Richard C. Waters, </author> <title> "Program Translation via Abstraction and Reimplementation," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 14, no. 8, </volume> <pages> pp. 1207-1228, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Syntax Tree Centaur [24] Cornell Program Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler <ref> [220] </ref> KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views. <p> Synthesizer [204] Fortran Programming Environment [89] Gandalf [78] Magpie [49] MENTOR [53] MultiView [5] Pan [11] PECAN [163] Poe [61] Syned [90] Synthesizer Generator [169, 168] (Tenma et al. [207]) Abstract Syntax Graph IPSEN [139, 120] Maintainer's Assistant [158] TEAM [40] Plan Calculus Cobbler <ref> [220] </ref> KBEmacs [219] Recognizer [174] Satch [220] Miscellaneous [Attributed Graph Specifications [3]] [General Design Representation [123]] (Lea [112]) [Program Dependence Graph [151]] [Typed Hypermedia [43, 14]] [Unified Interprocedural Graph [82]] Table 2-4: MVDEs based on a canonical representation. representation for these syntax-based views. <p> The Plan Calculus is a graph-based representation for programs that incorporates both control- and dataflow information. It has been successfully incorpo rated into the KBEmacs system for partial program synthesis [219], into Satch and Cobbler for automatic program translation <ref> [220] </ref>, and into the Recognizer [174], a program that identifies design features in existing programs.
Reference: [221] <author> David S. Wile, </author> <title> "Integrating Syntaxes and their Associated Semantics." </title> <note> Submitted for publication, </note> <month> November </month> <year> 1991. </year>
Reference-contexts: Integration across views is achieved only at runtime. The research into multiparadigm environments is summarized in Table 2-2. The Draco system [140, 141], Ipser's subsequent work on multi-formalism specification environments [98, 99], and Wile's research into "local formalisms" <ref> [221] </ref> explicitly provides support for (textual) user-defined languages that translate into a common base language, while Garden [164] and the Visual Programmer's WorkBench [179] concentrate on the creation of 2.4. <p> A CATEGORIZATION OF EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile <ref> [221] </ref>) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages.
Reference: [222] <author> Jack C. Wileden, Alexander L. Wolf, William R. Rosenblatt, and Peri L. Tarr, </author> <title> "Specification-Level Interoperability," </title> <journal> Communications of the ACM, </journal> <volume> vol. 34, no. 5, </volume> <pages> pp. 72-87, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Similarly, much work has been done on translating between different views of data structures without much regard for how those structures are manipulated by the programs in which they find themselves <ref> [85, 69, 102, 126, 217, 201, 31, 222] </ref>. Thus, a model of how a program is structured and how it executes can be largely divorced from the data structures it manipulates.
Reference: [223] <author> Patrick Henry Winston and Berthold Klaus Paul Horn, </author> <title> Lisp. </title> <publisher> Addison-Wesley, </publisher> <year> 1981. </year>
Reference: [224] <author> Wuu Yang, Susan Horwitz, and Thomas Reps, </author> <title> "Detecting Program Components with Equivalent Behaviors," </title> <type> Technical Report 840, </type> <institution> University of Wisconsin-Madison Computer Sciences Department, </institution> <month> April </month> <year> 1989. </year>
Reference-contexts: In addition, PDGs so far lack efficient incremental algorithms for common operations in an interactive environment, such as adding a statement to a program under construction. There are many derivatives of PDGs, including program representation graphs <ref> [224] </ref>, program dependence webs [12], system dependence graphs for interprocedural slicing [94], and unified interprocedural graphs [82]. Research into hypermedia representations of system information has resulted in mechanisms for storing data that is similar to SPGs.
Reference: [225] <author> Frank Kenneth Zadeck, </author> <title> "Incremental Data Flow Analysis in a Structure Program Editor," </title> <booktitle> in Proceedings of the SIGPLAN'84 Symposium on Compiler Construction, </booktitle> <pages> pp. 132-143, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: A substantive change to an SPG need not trigger an update in all views, because some views may not depict the aspect (s) of the SPG that are affected by the change. 6.4. MISMATCHES BETWEEN SPGS AND VIEWS 135 for use in interactive development environments <ref> [204, 144, 225, 4, 180] </ref>. An ideal algorithm for updating a presentation, of course, is as predictable as a batch-mode computation and as efficient as an incremental one. Unfortunately, it may be the case that no such algorithm has been developed for a particular presentation.
Reference: [226] <author> Pamela Zave, </author> <title> "A Compositional Approach to Multiparadigm Programming," </title> <journal> IEEE Software, </journal> <pages> pp. 15-25, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave <ref> [226] </ref>) Table 2-2: Multiparadigm environments. multiparadigm visual languages. Other multiparadigm work includes Zave's research into composing different independent paradigms [226]; the explicitly multiparadigm languages Loops [22, 195], Daisy II [62], Leda [33], and G-2 [157]; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors <p> (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson [227]) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave <ref> [226] </ref>) Table 2-2: Multiparadigm environments. multiparadigm visual languages. Other multiparadigm work includes Zave's research into composing different independent paradigms [226]; the explicitly multiparadigm languages Loops [22, 195], Daisy II [62], Leda [33], and G-2 [157]; Koschmann's and Evens' research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors as a basis for concurrent programming [1]; the CODE system for developing parallel applications [32]; the wide-spectrum languages V
Reference: [227] <author> Pamela Zave and Michael Jackson, </author> <title> "Conjunction as Composition," </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <note> 1993. To appear. BIBLIOGRAPHY 285 </note>
Reference-contexts: EXISTING SYSTEMS 27 Approach to Integration System (Researchers) Underlying Base Language (Agha [1]) CIP-L [17] Daisy II [62] Draco [141, 140] G-2 [157] Garden [164] (Golin and Reiss [71]) (Ipser [98, 99]) Leda [33] Loops [22, 195] PLEASE [209] V [188] Visual Programmer's WorkBench [179] (Wile [221]) (Zave and Jackson <ref> [227] </ref>) Communicating Processes CODE [32] (Koschmann and Evens [111]) (Zave [226]) Table 2-2: Multiparadigm environments. multiparadigm visual languages. <p> research on mixing object-oriented and logic programming [111]; Agha's proposal to use Actors as a basis for concurrent programming [1]; the CODE system for developing parallel applications [32]; the wide-spectrum languages V [188], CIP-L [17], and PLEASE [209]; and the work by Zave and Jackson on formally composing partial specifications <ref> [227] </ref>. 2.4.2 MVDEs Not Using a Canonical Representation Table 2-3 summarizes research into MVDEs that achieve integration by a mechanism other than a shared canonical representation.
Reference: [228] <editor> Office Knowledge Engineering, Stanley B. Zdonik, ed., </editor> <volume> vol. 4, no. 1, </volume> <month> February </month> <year> 1991. </year> <title> Special issue on non-standard transaction models. </title>
Reference-contexts: Finding ways to cope with the implications of such 20 CHAPTER 2. APPROACHES TO VIEW INTEGRATION long-duration transactions is an active area of database research <ref> [228] </ref>. Some databases allow users to define triggers, i.e., events in a database that cause certain actions to take place, and this could form the basis for some communication between tools. <p> Therefore, it may be possible to adapt the research done on flexible transaction models <ref> [187, 13, 228, 143] </ref> to the particular needs of multiple-view software development environments.
References-found: 227

