URL: ftp://cse.ogi.edu/pub/pacsoft/papers/msl_rev.ps
Refering-URL: http://www.cse.ogi.edu/~walton/pub.html
Root-URL: http://www.cse.ogi.edu
Title: The Design of Message Specification Language  
Author: James Hook and Lisa Walton 
Date: June 21, 1997  
Web: http://www.cse.ogi.edu/ ~PacSoft  
Affiliation: Pacific Software Research Center Oregon Graduate Institute of Science and Technology  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Balzer, M. Feather, N. Goldman, and D. Wile. </author> <title> Domain specific notations for command and control message processing. </title> <type> Technical report, </type> <institution> USC/Information Science Institute, </institution> <address> 4676 Admiralty Way, Marina del Rey CA 90292, </address> <year> 1994. </year>
Reference-contexts: The MTV domain is well studied. The design of MSL was based in part on domain analysis incorporated in an Ada-templates based solution developed by the SEI [11], to which this system was experimentally compared [5]. An independent domain analysis and language implementation was developed by ISI <ref> [1] </ref>. fl The authors were supported in part by a contract with Air Force Materiel Command (F19628-93-C-0069). 1 3 Modeling the Domain In the context of Domain Engineering, a Domain Model is a precise description of all of the relevant entities and and relationships between entities in the domain.
Reference: [2] <author> Jeffrey Bell et al. </author> <title> Software design for reliability and reuse: A proof-of-concept demonstration. </title> <booktitle> In TRI-Ada '94 Proceedings, </booktitle> <pages> pages 396-404. </pages> <publisher> ACM, </publisher> <month> November </month> <year> 1994. </year>
Reference-contexts: The MSL language was designed as part of the Software Design for Reliability and Reuse (SDRR) project at the Pacific Software Research Center (PacSoft). MSL was initially the demonstration language used in the SDRR proof-of-concept experiment <ref> [2, 5] </ref>. It has subsequently been integrated with an Air Force prototype command and control system. PacSoft's approach to language design builds on a strong background in programming languages, semantics and functional programming. This paper outlines the key intellectual steps and design decisions in the design and implementation of MSL. <p> The problem is automating the task of building a module from a specification. The solution described here is the MSL [14, 16, 17] developed as part of the SDRR project <ref> [2] </ref>. The MTV domain is well studied. The design of MSL was based in part on domain analysis incorporated in an Ada-templates based solution developed by the SEI [11], to which this system was experimentally compared [5].
Reference: [3] <institution> Pacific Software Research Center. </institution> <note> SDRR project Phase I final scientific and technical report, Febru-ary 1995. </note>
Reference: [4] <author> Richard Kieburtz and Jeffrey R. Lewis. </author> <title> Algebraic design language. </title> <type> Technical Report 94-002, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1994. </year>
Reference-contexts: This required extension of the abstract syntax and the abstract machine. 7 The state of MSL The MSL generator has been implemented twice. In the initial proof-of-concept experiment it was implemented by translation into ADL, an experimental functional programming language developed by Kieburtz and Lewis <ref> [4] </ref>. The success criteria of this phase of the project were correctness, robustness, and usability. These criteria were met, as demonstrated in the usability, productivity and reliability experiment documented by Kieburtz, McKinney, and others [5]. We were particularly pleased with the robustness of the system in use.
Reference: [5] <author> Richard B. Kieburtz, Laura McKinney, Jeffrey Bell, James Hook, Alex Kotov, Jeffrey Lewis, Dino Oliva, Tim Sheard, Ira Smith, and Lisa Walton. </author> <title> A software engineering experiment in software component generation. </title> <booktitle> In 18th International Conference in Software Engineering, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: The MSL language was designed as part of the Software Design for Reliability and Reuse (SDRR) project at the Pacific Software Research Center (PacSoft). MSL was initially the demonstration language used in the SDRR proof-of-concept experiment <ref> [2, 5] </ref>. It has subsequently been integrated with an Air Force prototype command and control system. PacSoft's approach to language design builds on a strong background in programming languages, semantics and functional programming. This paper outlines the key intellectual steps and design decisions in the design and implementation of MSL. <p> The MTV domain is well studied. The design of MSL was based in part on domain analysis incorporated in an Ada-templates based solution developed by the SEI [11], to which this system was experimentally compared <ref> [5] </ref>. <p> The success criteria of this phase of the project were correctness, robustness, and usability. These criteria were met, as demonstrated in the usability, productivity and reliability experiment documented by Kieburtz, McKinney, and others <ref> [5] </ref>. We were particularly pleased with the robustness of the system in use. To support the experiment the prototype was installed at a foreign location and four subjects used the tool regularly for three months to complete a series of tasks specified by the Air Force.
Reference: [6] <author> John Launchbury and Amr Sabry. </author> <title> Monadic state: Axiomitization and type safety. </title> <booktitle> In Proceedings of the 1997 International Conference on Functional Programming, </booktitle> <month> June </month> <year> 1997. </year>
Reference: [7] <author> Erik Meijer, Maarten Fokkinga, and Ross Paterson. </author> <title> Functional programming with bananas, lenses, envelopes and barbed wire. </title> <editor> In John Hughes, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 124-144. </pages> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: The polymorphism allowed for the type system to enforce fine distinctions in the level of analysis and rewriting applied to the abstract syntax. 6.2 Type checking and analysis The type checking and environment phase is expressed as a catamorphism (a particular kind of simple structured recursive function definition <ref> [7] </ref> of similar expressive power to attribute grammar formalisms) over the abstract syntax. During type checking the representation of the abstract syntax is changed. Some "sugar" is eliminated while the coercion operators discussed above were introduced.
Reference: [8] <author> E. Moggi. </author> <title> Notions of computations and monads. </title> <booktitle> Information and Computations, </booktitle> <month> July </month> <year> 1991. </year>
Reference: [9] <author> Dino P. Oliva. </author> <title> Baseline performance measurements for unoptimized generated code, </title> <month> February </month> <year> 1995. </year> <note> In [3]. </note>
Reference-contexts: However, a few of the larger tasks could not be completed because of system capacity restrictions, which have subsequently been addressed. The performance of the proof-of-concept system was unacceptable for integration with the Air Force Command and Control demonstration system <ref> [9] </ref>. This was attributed to the immaturity of the tools used to compile ADL into Ada and the low level of abstraction used in the abstract machine provided by the target language.
Reference: [10] <author> Dino P. Oliva and Andrew Tolmach. </author> <title> From ML to Ada(!?!): Strongly-typed language interoperability via source translation, </title> <month> June </month> <year> 1997. </year> <note> Submited for publication. </note>
Reference-contexts: Once the abstract machine became stable, this implementation was replaced by an implementation in a hybrid of the ML-like target language and Ada. This reimplementation exploits specific mechanisms for developing such hybrid implementations in the Program Instantiator (also know as the RML compiler) <ref> [10] </ref>. 9 6.5 Subsequent hackery After some experience with the system, the naive way in which alternatives were considered was revisited. A frequent special case was a large number of alternatives being mapped onto a simple enumeration type. A safe transformation that improved performance in this case was introduced.
Reference: [11] <author> Charles Plinta, Kenneth Lee, and Michael Rissman. </author> <title> A model solution for C 3 I message translation and validation. </title> <type> Technical report, </type> <institution> Software Engineering Institute, Carnegie Mellon University, </institution> <month> December </month> <year> 1989. </year> <note> CMU/SEI-89-TR-12 ESD-89-TR-20. </note>
Reference-contexts: The solution described here is the MSL [14, 16, 17] developed as part of the SDRR project [2]. The MTV domain is well studied. The design of MSL was based in part on domain analysis incorporated in an Ada-templates based solution developed by the SEI <ref> [11] </ref>, to which this system was experimentally compared [5].
Reference: [12] <author> Andrew Tolmach. </author> <title> Elaborating the specification of Message Specification Language (MSL), </title> <month> July </month> <year> 1995. </year> <note> PacSoft internal technical note. </note>
Reference-contexts: An alternative implementation strategy involving an interpreter is explored by Tolmach <ref> [12] </ref>. His interpreter reuses the front-end and type-checker of the compiler described below. 6.1 Front-end The frontend utilizes ML versions of standard compiler tools for lexical analysis and parsing. Abstract syntax is expressed as a polymorphic ML datatype. <p> Integration at this level will free the requirement for source level integration. This change will permit the code generating back-end to be replaced by a much simpler, and more easily maintained, interpreter similar to the one developed by Tolmach <ref> [12] </ref>. 8 Conclusions Domain-specific languages are, in a sense, programming languages. As such, their design and development should reflect and build upon the principles of programming languages that have been developed over several decades of research.
Reference: [13] <author> P. Wadler. </author> <title> Comprehending monads. </title> <booktitle> Proceedings of the 1990 ACM Symposium on Lisp and Functional Programming, </booktitle> <year> 1990. </year>
Reference: [14] <author> Lisa Walton and James Hook. </author> <title> A preliminary definition of a domain specific design language for message translation and validation. </title> <type> Technical Report 94-006, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1994. </year>
Reference-contexts: The problem is automating the task of building a module from a specification. The solution described here is the MSL <ref> [14, 16, 17] </ref> developed as part of the SDRR project [2]. The MTV domain is well studied. The design of MSL was based in part on domain analysis incorporated in an Ada-templates based solution developed by the SEI [11], to which this system was experimentally compared [5].
Reference: [15] <author> Lisa Walton and James Hook. </author> <title> Creating and verifying domain-specific design languages. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> August </month> <year> 1995. </year> <note> Internal technical memo. 11 </note>
Reference: [16] <author> Lisa Walton and James Hook. </author> <title> Message specification language (MSL): A domain specific design language for message translation and validation. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: The problem is automating the task of building a module from a specification. The solution described here is the MSL <ref> [14, 16, 17] </ref> developed as part of the SDRR project [2]. The MTV domain is well studied. The design of MSL was based in part on domain analysis incorporated in an Ada-templates based solution developed by the SEI [11], to which this system was experimentally compared [5].
Reference: [17] <author> Lisa Walton and James Hook. </author> <title> Message specification language (MSL): Reference manual. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: The problem is automating the task of building a module from a specification. The solution described here is the MSL <ref> [14, 16, 17] </ref> developed as part of the SDRR project [2]. The MTV domain is well studied. The design of MSL was based in part on domain analysis incorporated in an Ada-templates based solution developed by the SEI [11], to which this system was experimentally compared [5].
Reference: [18] <author> Lisa Walton and James Hook. </author> <title> Denotational semantics for a domain-specific design language, </title> <month> March </month> <year> 1997. </year> <note> Internal technical memo. </note>
Reference-contexts: In this way a parsing semantics can be given to the abstract syntax that is independent of which representation is being parsed <ref> [18] </ref>. Similarly, an almost identical unparsing semantics can also be given.
Reference: [19] <author> Tanya Widen and James Hook. </author> <title> Software design automation: Language design in the context of domain engineering, </title> <month> June </month> <year> 1997. </year> <note> Submitted to DSL97. </note>
Reference-contexts: In this paper, we have illustrated a disciplined approach to domain-specific language definition and implementation that builds upon these principles. Details of the method employed are described in the companion paper by Widen and Hook <ref> [19] </ref>. MSL was defined by following a type-centric approach to language design that builds on foundational concepts from denotational semantics. The prototype development and imple 10 mentation of MSL exploit the expressive power and mathematical regularity of modern typed functional languages, such as Standard ML or Haskell.
References-found: 19

