URL: http://www.win.tue.nl/inf/onderzoek/csr/abs/95.05.ps
Refering-URL: http://www.win.tue.nl/inf/onderzoek/publicaties.html
Root-URL: http://www.win.tue.nl
Email: e-mail severi@win.tue.nl  
Title: Pure Type Systems without the -condition  
Author: Paula Severi 
Address: Den Dolech 2 Postbus 513 5600 MB Eindhoven The Netherlands  
Affiliation: Eindhoven University of Technology  
Abstract: In this paper we define the notion of pure type systems without the -condition. The -condition is the requirement that the type of an abstraction is typable. A pure type system without the -condition can be considered as an extension of the corresponding pure type system. We prove, besides studying the general properties of these systems, that weak normalisation is preserved by the extension. Using these systems, we define a syntax directed set of rules for singly sorted pure type systems. 
Abstract-found: 1
Intro-found: 1
Reference: [Bar92] <author> H. Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In D. M. Gabbai, S. Abramsky, and T. S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 1. </volume> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: Pseudocontexts will be denoted by ; 0 ; :::; ; 0 ; :::. Pseudoterms will be denoted by a; b; c; d; :::; A; B; C; :::. 2. The usual conventions for omitting parenthesis in abstractions, applications and products will be used (see <ref> [Bar92] </ref>). The following properties are proved in [GN91] and [Bar92]. <p> Pseudoterms will be denoted by a; b; c; d; :::; A; B; C; :::. 2. The usual conventions for omitting parenthesis in abstractions, applications and products will be used (see <ref> [Bar92] </ref>). The following properties are proved in [GN91] and [Bar92].
Reference: [Ber88] <author> S. Berardi. </author> <title> Towards a mathematical analysis of the coquand-huet calculus of constructions. </title> <year> 1988. </year>
Reference-contexts: A conversion morphism from A to B could be seen as a semantic of A in B. 3 Pure Type Systems Pure type systems provide a way to describe a large class of type systems a la Church in a uniform way. They were simultaneously introduced by Berardi <ref> [Ber88] </ref> and Terlouw [Ter89]. We will present the notion of pure type systems in a slightly different way than usual. We first define a functor from the category of specifications to the category of contextual abstract rewriting systems with typing.
Reference: [Geu93] <author> H. </author> <title> Geuvers. Logics and Type Systems. </title> <type> PhD thesis, </type> <institution> University of Nijmegen, </institution> <year> 1993. </year>
Reference-contexts: The functor : Spec ! CS is defined for morphisms in the obvious way. If f : S ! S 0 is a morphism in Spec then (f) is the extension of f from the set of sorts to the sets of pseudoterms and pseudocontexts (see <ref> [Geu93] </ref>). Definition 3.4. (Pure Type Systems) A pure type system is an element of (Spec) = f (S) j S 2 Specg. A singly sorted pure type system is an element of f (S) j S 2 Spec & S is singly sorted g.
Reference: [GN91] <author> H. Geuvers and M. J. Nederhof. </author> <title> A modular proof of strong normalization for the calculus of constructions. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(2) </volume> <pages> 155-189, </pages> <year> 1991. </year>
Reference-contexts: Pseudoterms will be denoted by a; b; c; d; :::; A; B; C; :::. 2. The usual conventions for omitting parenthesis in abstractions, applications and products will be used (see [Bar92]). The following properties are proved in <ref> [GN91] </ref> and [Bar92].
Reference: [Hue80] <author> Gerard Huet. </author> <title> Confluent reductions: Abstract properties and applications to term rewriting. </title> <journal> Journal of the ACM, </journal> <volume> 27(4) </volume> <pages> 797-821, </pages> <year> 1980. </year>
Reference-contexts: These concepts will be used to define the notion of pure type systems with and without the -condition in sections 3 and 4. 2.1 Abstract Rewriting Systems We use the basic definitions concerning abstract rewriting systems as in [vO94] (see also <ref> [Hue80] </ref> and [Klo90]). Definition 2.1. An abstract rewriting system is a structure &lt; A; !&gt; where A is a set of elements and ! is a subset of A fi A called rewrite relation. Definition 2.2.
Reference: [Klo90] <author> J.W. Klop. </author> <title> Term rewriting systems. </title> <type> Technical Report CS-R9073, </type> <institution> Centre for Mathematics and Computer Science Amsterdam, </institution> <year> 1990. </year>
Reference-contexts: These concepts will be used to define the notion of pure type systems with and without the -condition in sections 3 and 4. 2.1 Abstract Rewriting Systems We use the basic definitions concerning abstract rewriting systems as in [vO94] (see also [Hue80] and <ref> [Klo90] </ref>). Definition 2.1. An abstract rewriting system is a structure &lt; A; !&gt; where A is a set of elements and ! is a subset of A fi A called rewrite relation. Definition 2.2.
Reference: [Raa93] <editor> Femke Van Raamsdonk. Confluence and superdevelopment. In Claude Kirchner, editor, </editor> <booktitle> Rewriting Techniques and Applications, volume 690 of LNCS, </booktitle> <pages> pages 168-183. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 25 </month>
Reference-contexts: By lemma 8.3 the normal form is unique. 2 We mention that for singly sorted specifications, the illegal abstractions of a term b constitute an initial labelling for a superdevelopment (see <ref> [Raa93] </ref> and [RS95]) and hence the term b is fi - strongly normalising. The formal proof that the illegal abstractions are in fact a good labelling for a superdevelopment is rather tedious and hence we prefer to prove strong normalisation for fi in a direct way following the method of [Raa93]. <p> <ref> [Raa93] </ref> and [RS95]) and hence the term b is fi - strongly normalising. The formal proof that the illegal abstractions are in fact a good labelling for a superdevelopment is rather tedious and hence we prefer to prove strong normalisation for fi in a direct way following the method of [Raa93]. 22 Lemma 8.5. If ` C [(x:A: b)a] ! fi C [b [x := a]] then there exists 0 oe such that (x:A: b) is illegal in 0 . Lemma 8.6.
Reference: [RS95] <author> Femke Van Raamsdonk and Paula Severi. </author> <note> On normalisation. Technical Report CS--R9545 and CS-9520, </note> <author> CWI-Amsterdam and TU-Eindhoven, </author> <year> 1995. </year>
Reference-contexts: By lemma 8.3 the normal form is unique. 2 We mention that for singly sorted specifications, the illegal abstractions of a term b constitute an initial labelling for a superdevelopment (see [Raa93] and <ref> [RS95] </ref>) and hence the term b is fi - strongly normalising.
Reference: [Ter89] <author> J. Terlouw. </author> <title> Een nadere bewijstheoretische analyse van GSTT's. </title> <type> Manuscript, </type> <year> 1989. </year>
Reference-contexts: They were simultaneously introduced by Berardi [Ber88] and Terlouw <ref> [Ter89] </ref>. We will present the notion of pure type systems in a slightly different way than usual. We first define a functor from the category of specifications to the category of contextual abstract rewriting systems with typing. <p> We first define a functor from the category of specifications to the category of contextual abstract rewriting systems with typing. Then we define a pure type system as a value (S) of the functor for some specification S. Definition 3.1. ([Ber88], <ref> [Ter89] </ref>) A specification is a triple S = (S; A; R) such that 1. S is a set of symbols called sorts, 2. A S fi S called set of axioms 3. <p> S is a set of symbols called sorts, 2. A S fi S called set of axioms 3. R S fi S fi S called set of rules We denote the category whose objects are the specifications and morphisms are the obvious ones as Spec. Definition 3.2. ([Ber88], <ref> [Ter89] </ref>) Let S = (S; A; R) be a specification. <p> Definition 3.3. ([Ber88], <ref> [Ter89] </ref>) A functor : Spec ! CS is defined for S 2 Spec as follows. (S) = (T S ; C S ; (! fi ) S ; ` S ) (or (S) = (T ; C; ! fi ; `) for short) The components of this 4-tuple are defined as
Reference: [vBJMP93] <author> Bert van Benthem Jutting, James McKinna, and Randy Pollack. </author> <title> Checking algorithms for pure type systems. </title> <publisher> LNCS, </publisher> <address> 806, </address> <year> 1993. </year>
Reference-contexts: The pure systems without the -condition will be used to define a syntax directed set of rules for singly sorted pure type systems. Most of the attempts to construct algorithms for type checking and type inference (see for example <ref> [vBJMP93] </ref>) pass through the consideration of typing rules for which the type deduction is determined by the shape of the term b and of the context . <p> We define a syntax directed set of rules for singly sorted pure type systems similar to the one presented in <ref> [vBJMP93] </ref>. As in [vBJMP93], we use an auxiliar system to check for the -condition. The auxiliar system we use is the corresponding pure type system without the -condition. The convenience of this system is that it permits us to prove some properties (like subject reduction) by induction on the derivation. <p> We define a syntax directed set of rules for singly sorted pure type systems similar to the one presented in <ref> [vBJMP93] </ref>. As in [vBJMP93], we use an auxiliar system to check for the -condition. The auxiliar system we use is the corresponding pure type system without the -condition. The convenience of this system is that it permits us to prove some properties (like subject reduction) by induction on the derivation. <p> This contradicts the minimality of d. 2 9 Syntax Directed Pure Type Systems In this section we define a syntax directed set of rules for any singly sorted pure type system. This definition is similar to the one presented in <ref> [vBJMP93] </ref> in the sense that we use an auxiliar system to check for the -condition. The auxiliar system we use is the corresponding pure type system without the -condition.
Reference: [vO94] <author> Vincent van Oostrom. </author> <title> Confluence for Abstract and Higher-Order Rewriting. </title> <type> PhD thesis, </type> <institution> Vrije Universiteit, Amsterdem, </institution> <year> 1994. </year> <month> 26 </month>
Reference-contexts: These concepts will be used to define the notion of pure type systems with and without the -condition in sections 3 and 4. 2.1 Abstract Rewriting Systems We use the basic definitions concerning abstract rewriting systems as in <ref> [vO94] </ref> (see also [Hue80] and [Klo90]). Definition 2.1. An abstract rewriting system is a structure &lt; A; !&gt; where A is a set of elements and ! is a subset of A fi A called rewrite relation. Definition 2.2.
References-found: 11

