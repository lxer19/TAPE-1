URL: http://www.cs.brown.edu/people/pck/Papers/krvv.ps
Refering-URL: http://www.cs.brown.edu/people/pck/publications.html
Root-URL: http://www.cs.brown.edu/
Email: Email: pck@cs.brown.edu.  Email: dev@cs.duke.edu.  Email: jsv@cs.duke.edu.  
Title: Indexing for Data Models with Constraints and Classes  
Author: Paris Kanellakis Sridhar Ramaswamy Darren Vengroff Jeffrey Vitter 
Keyword: constraint and object-oriented databases, indexing, external dynamic k-dimensional range searching, dynamic interval management.  
Date: 8225.  
Address: Box 1910, Providence, RI 02912.  Box 90129, Durham, NC 27708-0129.  Box 90129, Durham, NC 27708-0129.  
Affiliation: Dept. of Computer Science, Brown University,  Dept. of Computer Science, Duke University,  Dept. of Computer Science, Duke University,  
Note: Address:  Research supported by ONR Contract N00014-91-J-4052, ARPA Order  Address:  Also affiliated with Brown University. Support was provided in part by National Science Foundation research grant CCR-9007851 and by Army Research Office grant DAAL03-91-G-0035. Address:  Support was provided in part by National Science Foundation research grant CCR-9007851 and by Army Research Office grant DAAL03-91-G-0035.  
Abstract: We examine I/O-efficient data structures that provide indexing support for new data models. The database languages of these models include concepts from constraint programming (e.g., relational tuples are generalized to conjunctions of constraints) and from object-oriented programming (e.g., objects are organized in class hierarchies). Let n be the size of the database, c the number of classes, B the page size on secondary storage, and t the size of the output of a query. (1) Indexing by one attribute in many constraint data models is equivalent to external dynamic interval management, which is a special case of external dynamic 2-dimensional range searching. We present a semi-dynamic data structure for this problem that has worst-case space O(n=B) pages, query I/O time O(log B n + t=B) and O(log B n + (log B n) 2 =B) amortized insert I/O time. Note that, for the static version of this problem, this is the first worst-case optimal solution. (2) Indexing by one attribute and by class name in an object-oriented model, where objects are organized as a forest hierarchy of classes, is also a special case of external dynamic 2-dimensional range searching. Based on this observation, we first identify a simple algorithm with good worst-case performance, query I/O time O(log 2 c log B n + t=B), update I/O time O(log 2 c log B n) and space O((n=B) log 2 c) pages for the class indexing problem. Using the forest structure of the class hierarchy and techniques from the constraint indexing problem, we improve its query I/O time to O(log B n + t=B + log 2 B). y Contact Author. Current address: Bell Communications Research, 445 South Street #2D332, Morristown NJ 07960. Research conducted while this author was at the Dept. of Computer Science, Brown University, Providence RI 02912, and supported by ONR Contract N00014-91-J-4052, ARPA Order 8225. Email: sridhar@bellcore.com. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Bayer and E. McCreight, </author> <title> "Organization of Large Ordered Indexes," </title> <journal> Acta Informatica 1 (1972), </journal> <pages> 173-189. </pages>
Reference: [2] <author> N. Beckmann, H. Kriegel, R. Schneider, and B. Seeger, </author> <title> "The R fl -tree: An Efficient and Robust Access Method for Points and Rectangles," </title> <booktitle> Proc. 1990 ACM-SIGMOD Conference on Management of Data (1990), </booktitle> <pages> 322-331. </pages>
Reference-contexts: That is, we would read O (t= p B) disk blocks to report t points on a straight line. Several data structures have been proposed in the literature to handle region data. These include the R-tree [16], the R fl -tree <ref> [2] </ref>, the R + -tree [33], the cell tree [15] and many others. These data structures are applicable to point data and 1-dimensional range data and hence are relevant to our problems.
Reference: [3] <author> J. L. Bentley, </author> <title> "Algorithms for Klee's Rectangle Problems," </title> <institution> Dept. of Computer Science, Car-negie Mellon Univ., </institution> <note> unpublished notes, </note> <year> 1977. </year>
Reference-contexts: Other data structures like the Interval Tree [11,12], and Segment Tree <ref> [3] </ref> can also solve 6 the interval management problem optimally in-core, with respect to the query time. Among these, the priority search tree does the best because it solves the interval management problem in optimal time and space, and provides an optimal worst-case update time as well.
Reference: [4] <author> J. L. Bentley, </author> <title> "Multidimensional Divide and Conquer," </title> <booktitle> CACM 23(6) (1980), </booktitle> <pages> 214-229. </pages>
Reference-contexts: Amortized update I/O time for the semi-dynamic problem with inserts is O (log 2 c (log B n + (log B n) 2 =B)). 1.4 Related Research A large literature exists for in-core algorithms for 2-dimensional range searching. The range tree <ref> [4] </ref> can be used to solve the problem in O (n log 2 n) space and static worst-case query time 1 Note that diagonal corner queries are a special case of 2-sided queries and 2-sided queries are a special case of 3-sided queries.
Reference: [5] <author> G. Blankenagel and R. H. Guting, </author> <title> "XP-Trees External Priority Search Trees," </title> <journal> FernUniver-sitat Hagen, Informatik-Bericht Nr. </journal> <volume> 92, </volume> <year> 1990. </year>
Reference-contexts: There have been several pieces of work done by researchers to implement these data structures in secondary memory. These works include [17], <ref> [5] </ref>, [6]. [17] contains a claimed optimal solution for implementing static priority search trees in secondary memory. Unfortunately, the [17] static solution has static query time O (log 2 n + t=B) instead of O (log B n + t=B) and the claimed optimal solution is incorrect.
Reference: [6] <author> G. Blankenagel and R. H. Guting, </author> <title> "External Segment Trees," </title> <address> FernUniversitat Hagen, Infor-matik-Bericht, </address> <year> 1990. </year>
Reference-contexts: There have been several pieces of work done by researchers to implement these data structures in secondary memory. These works include [17], [5], <ref> [6] </ref>. [17] contains a claimed optimal solution for implementing static priority search trees in secondary memory. Unfortunately, the [17] static solution has static query time O (log 2 n + t=B) instead of O (log B n + t=B) and the claimed optimal solution is incorrect.
Reference: [7] <author> B. Chazelle, </author> <title> "Lower Bounds for Orthogonal Range Searching: I. The Reporting Case," </title> <editor> J. </editor> <booktitle> ACM 37(2) (1990), </booktitle> <pages> 200-212. </pages>
Reference-contexts: We show in Section 2.2 that it is impossible to achieve optimal query time for this problem (O (log B n + t=B) disk I/O's) with only one copy of each object in secondary storage. (For lower bounds on range searching in main memory, see [13] and <ref> [7] </ref>.) In Section 4, analyzing the hierarchy using the hierarchical decomposition of [34], we reduce the problem of indexing classes to a special case of external dynamic 2-dimensional range searching called 3-sided range searching. 3-sided range queries are a special case of 2-dimensional range queries.
Reference: [8] <author> Y.-J. Chiang and R. Tamassia, </author> <title> "Dynamic Algorithms in Computational Geometry," </title> <booktitle> Proceedings of IEEE, Special Issue on Computational Geometry 80(9) (1992), </booktitle> <pages> 362-381. </pages>
Reference-contexts: By using fractional cascading, we can achieve a worst-case dynamic query time O (log 2 n log 2 log 2 n + t) and update time O (log 2 n log 2 log 2 n) using the same space. We refer the reader to <ref> [8] </ref> for a detailed survey of the topic. The ideal worst-case I/O bounds would involve making all the above logarithms have base B and compacting the output term to t=B; any other improvements would of course imply improvements to the in-core bounds. <p> This paper also does not offer any worst-case analysis for range searching. Specifically, this method will not have optimal reporting time with our standard case, i.e., the uniform grid of points. Dynamic interval management has been examined extensively in the literature (see <ref> [8] </ref>). As mentioned before, the best in-core bounds have been achieved using the priority search tree of [25], yielding O (n) space, dynamic query time O (log 2 n + t) and update time O (log 2 n), which are all optimal. <p> Based on this structure we show that indexing classes is a special case of external dynamic 2-dimensional range searching on some attribute of the objects. We then use the idea of the 2-dimensional range tree (see <ref> [8] </ref>), with classes as the primary dimension and the object attribute as a secondary dimension to devise an efficient storage and query strategy. These ideas are formalized in the proposition and theorem to follow.
Reference: [9] <author> E. F. Codd, </author> <title> "A Relational Model for Large Shared Data Banks," </title> <booktitle> CACM 13(6) (1970), </booktitle> <pages> 377-387. </pages>
Reference-contexts: 1 Introduction 1.1 Motivation The successful realization of any data model requires supporting its language features with efficient secondary storage manipulation. For example, the relational data model <ref> [9] </ref> includes declarative programming in the form of relational calculus and algebra and expresses queries of low data complexity because every fixed relational calculus query is evaluable in LOGSPACE and PTIME in the size of the input database.
Reference: [10] <author> D. Comer, </author> <title> "The Ubiquitous B-tree," </title> <booktitle> Computing Surveys 11(2) (1979), </booktitle> <pages> 121-137. </pages>
Reference: [11] <author> H. Edelsbrunner, </author> <title> "A New Approach to Rectangle Intersections, Part II," </title> <booktitle> Int. J. Computer Mathematics 13 (1983), </booktitle> <pages> 221-229. 38 </pages>
Reference: [12] <author> H. Edelsbrunner, </author> <title> "A New Approach to Rectangle Intersections, Part I," </title> <booktitle> Int. J. Computer Mathematics 13 (1983), </booktitle> <pages> 209-219. </pages>
Reference: [13] <author> M. L. Fredman, </author> <title> "A Lower Bound on the Complexity of Orthogonal Range Queries," </title> <editor> J. </editor> <booktitle> ACM 28 (1981), </booktitle> <pages> 696-705. </pages>
Reference-contexts: We show in Section 2.2 that it is impossible to achieve optimal query time for this problem (O (log B n + t=B) disk I/O's) with only one copy of each object in secondary storage. (For lower bounds on range searching in main memory, see <ref> [13] </ref> and [7].) In Section 4, analyzing the hierarchy using the hierarchical decomposition of [34], we reduce the problem of indexing classes to a special case of external dynamic 2-dimensional range searching called 3-sided range searching. 3-sided range queries are a special case of 2-dimensional range queries.
Reference: [14] <author> M. T. Goodrich, J.-J. Tsay, D. E. Vengroff, and J. S. Vitter, </author> <title> "External-Memory Computational Geometry," </title> <booktitle> Proc. 34th Annual IEEE Symposium on Foundations of Computer Science (1993), </booktitle> <pages> 714-723. </pages>
Reference-contexts: Progress has been made in many different directions after this paper. In the case where our goal is to handle a very large number of queries in a batch, <ref> [14] </ref> proves that 2-dimensional queries can be answered in O ((n=B + k=B)(log M=B (n=B)) + t=B) I/Os where k is the number of queries being processed and M is the amount of main memory available.
Reference: [15] <author> O. Gunther, </author> <title> "The Design of the Cell Tree: An Object-Oriented Index Structure for Geometric Databases," </title> <booktitle> Proc. of the Fifth Int. Conf. on Data Engineering (1989), </booktitle> <pages> 598-605. </pages>
Reference-contexts: Several data structures have been proposed in the literature to handle region data. These include the R-tree [16], the R fl -tree [2], the R + -tree [33], the cell tree <ref> [15] </ref> and many others. These data structures are applicable to point data and 1-dimensional range data and hence are relevant to our problems. All of them are based on the recursive decomposition of space using heuristics and cannot offer the worst-case guarantees in space and time that we seek. <p> For example, the R-tree [16], the k-d-B-tree [30], and the grid file [26] use rectangular tessellations and single copies, the R + -tree [33] uses a small number of copies and rectangular tessellations, the hB-tree [22], the cell tree <ref> [15] </ref> and the z-order [27] use non-rectangular decompositions of space. Experimental comparisons seem to indicate that none of these data structures is significantly better than the others for the different cases of range querying.
Reference: [16] <author> Antonin Guttman, "R-Trees: </author> <title> A Dynamic Index Structure for Spatial Searching," </title> <booktitle> Proc. 1984 ACM-SIGMOD Conference on Management of Data (1985), </booktitle> <pages> 47-57. </pages>
Reference-contexts: That is, we would read O (t= p B) disk blocks to report t points on a straight line. Several data structures have been proposed in the literature to handle region data. These include the R-tree <ref> [16] </ref>, the R fl -tree [2], the R + -tree [33], the cell tree [15] and many others. These data structures are applicable to point data and 1-dimensional range data and hence are relevant to our problems. <p> There are data structures that attempt to obtain B-tree-like performance using one or more of these ideas. For example, the R-tree <ref> [16] </ref>, the k-d-B-tree [30], and the grid file [26] use rectangular tessellations and single copies, the R + -tree [33] uses a small number of copies and rectangular tessellations, the hB-tree [22], the cell tree [15] and the z-order [27] use non-rectangular decompositions of space.
Reference: [17] <author> C. Icking, R. Klein, and T. Ottmann, </author> <title> Priority Search Trees in Secondary Memory (Extended Abstract), </title> <booktitle> Lecture Notes In Computer Science #314, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: There have been several pieces of work done by researchers to implement these data structures in secondary memory. These works include <ref> [17] </ref>, [5], [6]. [17] contains a claimed optimal solution for implementing static priority search trees in secondary memory. Unfortunately, the [17] static solution has static query time O (log 2 n + t=B) instead of O (log B n + t=B) and the claimed optimal solution is incorrect. <p> There have been several pieces of work done by researchers to implement these data structures in secondary memory. These works include <ref> [17] </ref>, [5], [6]. [17] contains a claimed optimal solution for implementing static priority search trees in secondary memory. Unfortunately, the [17] static solution has static query time O (log 2 n + t=B) instead of O (log B n + t=B) and the claimed optimal solution is incorrect. <p> There have been several pieces of work done by researchers to implement these data structures in secondary memory. These works include <ref> [17] </ref>, [5], [6]. [17] contains a claimed optimal solution for implementing static priority search trees in secondary memory. Unfortunately, the [17] static solution has static query time O (log 2 n + t=B) instead of O (log B n + t=B) and the claimed optimal solution is incorrect. <p> We give efficient solutions to the class indexing problem when the hierarchy has constant depth and when the hierarchy is degenerate. Combining these techniques, we give an efficient solution to the whole problem. Lemma 4.1 <ref> [17] </ref> There exists a data structure that can answer any 3-sided query on a set of n points on the plane in O (log 2 n + t=B) disk I/O's. This data structure occupies O (n=B) disk blocks and can be built in O ((n=B) log B n) disk I/O's. <p> This data structure occupies O (n=B) disk blocks and can be built in O ((n=B) log B n) disk I/O's. A data structure to achieve these bounds was presented in <ref> [17] </ref>. The data structure is essentially a priority search tree where each node contains B points. A simple recursive algorithm can build this tree in O ((n=B) log B n) disk I/O's. <p> Whether they can be asymptotically improved is an open question. The performance for the case of deletions is open. We should note that, using the techniques in this paper to dynamize the static structure of <ref> [17] </ref>, it is possible to achieve the following dynamic bounds: (1) indexing constraints in O (n=B) pages, dynamic query I/O time O (log 2 n + t=B) and amortized update time O (log 2 n + (log 2 2 n)=B), and (2) indexing classes in O ((log 2 c)(n=B)) pages, dynamic
Reference: [18] <author> J. Jaffar and J. L. Lassez, </author> <title> "Constraint Logic Programming," </title> <booktitle> Proc. 14th ACM POPL (1987), </booktitle> <pages> 111-119. </pages>
Reference-contexts: A general constraint programming framework for database query languages called Constraint Query Languages or CQLs was presented in [19]. This framework adapts ideas of Constraint Logic Programming, e.g., from <ref> [18] </ref>, to databases, provides a calculus and algebra, guarantees low data complexity, and is applicable to managing spatial data. It is, of course, important to index constraints and thus support these new language features with efficient secondary storage manipulation (see Section 2.1 for a detailed exposition of the problem).
Reference: [19] <author> P. C. Kanellakis, G. M. Kuper, and P. Z. Revesz, </author> <title> "Constraint Query Languages," </title> <booktitle> Proc. 9th ACM PODS (1990), </booktitle> <pages> 299-313, </pages> <note> invited to the special issue of JCSS on Principles of Database Systems (to appear). A complete version of the paper appears as Technical Report 90-31, </note> <institution> Brown University. </institution>
Reference-contexts: In this paper, we examine new I/O-efficient data structures for special cases of the general problem of k-dimensional range searching. These special cases are important for supporting new language features, such as constraint query languages <ref> [19] </ref> and class hierarchies in object-oriented databases [21,38]. <p> A general constraint programming framework for database query languages called Constraint Query Languages or CQLs was presented in <ref> [19] </ref>. This framework adapts ideas of Constraint Logic Programming, e.g., from [18], to databases, provides a calculus and algebra, guarantees low data complexity, and is applicable to managing spatial data. <p> It is, of course, important to index constraints and thus support these new language features with efficient secondary storage manipulation (see Section 2.1 for a detailed exposition of the problem). Fortunately, it is possible to do this by combining CQLs with existing 2-dimensional range searching data structures <ref> [19] </ref>. The basis of this observation is a reduction of indexing constraints, for a fairly general class of constraints, to dynamic interval management on secondary storage. Given a set of input intervals, dynamic interval management involves being able to perform the following operations efficiently: (1) Answer interval intersection queries. <p> Section 5 has the conclusions and open problems. 2 The Problems and Initial Approaches 2.1 Indexing Constraints To illustrate indexing constraints in CQLs consider the domain of rational numbers and a language whose syntax consists of the theory of rational order with constants + the relational calculus. (See <ref> [19] </ref> for details.) In this context, a generalized k-tuple is a quantifier-free conjunction of constraints on k variables, which range over the domain (rational numbers). For example, in the relational database model R (3; 4) is a tuple of arity 2. <p> The same program can be used for intersecting triangles. This simplicity of expression can be combined with efficient evaluation techniques, even if quantification is over the infinite domain of rationals. For more examples and details, please see <ref> [19] </ref>. fl The CQL model for rational order + relational calculus has low data complexity, because every fixed query is evaluable in LOGSPACE. That alone is not enough to make it a suitable model for implementation.
Reference: [20] <author> W. Kim, K. C. Kim, and A. Dale, </author> <title> "Indexing Techniques for Object-Oriented Databases," in Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. H. Lochovsky, eds., </editor> <publisher> Addison-Wesley, </publisher> <year> 1989, </year> <pages> 371-394. </pages>
Reference-contexts: Together with the different problem of indexing nested objects, as in [24], it constitutes the basis for indexing in object-oriented databases. Indexing classes has been examined in <ref> [20] </ref>, and more recently in [23], but the solutions offered there are largely heuristic with poor worst-case performance. We assume in this paper that the class-subclass relationship is static, although objects can be inserted to or deleted from classes.
Reference: [21] <editor> W. Kim and F. H. Lochovsky, eds., </editor> <title> Object-Oriented Concepts, Databases, and Applications, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference: [22] <author> D. B. Lomet and B. Salzberg, </author> <title> "The hB-Tree: A Multiattribute Indexing Method with Good Guaranteed Performance," </title> <booktitle> ACM Transactions on Database Systems 15(4) (1990), </booktitle> <pages> 625-658. </pages>
Reference-contexts: Many of them are based on a B-tree-like organization. We will consider several of them with reference to our problems. Two related data structures that have been proposed for multi-attribute indexing are the k-d-B-tree [30] and the hB-tree <ref> [22] </ref>. k-d-B-trees combine properties of balanced k-d-trees in a B-tree-like organization. In the 2-dimensional case (these ideas generalize readily to higher dimensions), the k-d-B-tree works by subdividing space into rectangular regions. Such subdivisions are stored in the interior nodes of the k-d-B-tree. <p> For example, the R-tree [16], the k-d-B-tree [30], and the grid file [26] use rectangular tessellations and single copies, the R + -tree [33] uses a small number of copies and rectangular tessellations, the hB-tree <ref> [22] </ref>, the cell tree [15] and the z-order [27] use non-rectangular decompositions of space. Experimental comparisons seem to indicate that none of these data structures is significantly better than the others for the different cases of range querying.
Reference: [23] <author> C. C. Low, B. C. Ooi, and H. Lu, "H-trees: </author> <title> A Dynamic Associative Search Index for OODB," </title> <booktitle> Proc. ACM SIGMOD (1992), </booktitle> <pages> 134-143. </pages>
Reference-contexts: Together with the different problem of indexing nested objects, as in [24], it constitutes the basis for indexing in object-oriented databases. Indexing classes has been examined in [20], and more recently in <ref> [23] </ref>, but the solutions offered there are largely heuristic with poor worst-case performance. We assume in this paper that the class-subclass relationship is static, although objects can be inserted to or deleted from classes.
Reference: [24] <author> D. Maier and J. Stein, </author> <title> "Indexing in an Object-Oriented DBMS," </title> <booktitle> IEEE Proc. International Workshop on Object-Oriented Database Systems (1986), </booktitle> <pages> 171-182. </pages>
Reference-contexts: Together with the different problem of indexing nested objects, as in <ref> [24] </ref>, it constitutes the basis for indexing in object-oriented databases. Indexing classes has been examined in [20], and more recently in [23], but the solutions offered there are largely heuristic with poor worst-case performance.
Reference: [25] <author> E. M. McCreight, </author> <title> "Priority Search Trees," </title> <journal> SIAM Journal of Computing 14(2) (1985), </journal> <pages> 257-276. </pages>
Reference-contexts: Dynamic interval management can be shown to be a special case of external dynamic 2-dimensional range searching. Dynamic interval management is interesting because it can be solved optimally in-core using the Priority Search Tree of McCreight <ref> [25] </ref> in query time O (log 2 n + t), update time O (log 2 n), and space O (n), which are all optimal. Achieving analogous I/O bounds is much harder. <p> Specifically, this method will not have optimal reporting time with our standard case, i.e., the uniform grid of points. Dynamic interval management has been examined extensively in the literature (see [8]). As mentioned before, the best in-core bounds have been achieved using the priority search tree of <ref> [25] </ref>, yielding O (n) space, dynamic query time O (log 2 n + t) and update time O (log 2 n), which are all optimal.
Reference: [26] <author> J. Nievergelt, H. Hinterberger, and K. C. Sevcik, </author> <title> "The Grid File: An Adaptable, Symmetric Multikey File Structure," </title> <booktitle> ACM Transactions on Database Systems 9(1) (1984), </booktitle> <pages> 38-71. </pages>
Reference-contexts: They work by recursively subdividing each region into four equal pieces until the number of points in each region fits into a disk block. Because they do not adapt to the input data, they can have very bad worst-case times. The grid file <ref> [26] </ref> was proposed as a data structure that treats all dimensions symmetrically, unlike many other data structures like the inverted file which distinguish between primary and secondary keys. <p> The grid file works by dividing each dimension into ranges and maintaining a grid directory that provides a mapping between regions in the search space and disk blocks. The paper <ref> [26] </ref> does not provide analysis for worst-case query times. They do mention that range queries become very efficient when queries return "many" records. <p> There are data structures that attempt to obtain B-tree-like performance using one or more of these ideas. For example, the R-tree [16], the k-d-B-tree [30], and the grid file <ref> [26] </ref> use rectangular tessellations and single copies, the R + -tree [33] uses a small number of copies and rectangular tessellations, the hB-tree [22], the cell tree [15] and the z-order [27] use non-rectangular decompositions of space.
Reference: [27] <author> J. A. Orenstein, </author> <title> "Spatial Query Processing in an Object-Oriented Database System," </title> <booktitle> Proc. ACM SIGMOD (1986), </booktitle> <pages> 326-336. 39 </pages>
Reference-contexts: All of them are based on the recursive decomposition of space using heuristics and cannot offer the worst-case guarantees in space and time that we seek. An interesting idea based on the use of space-filling curves is proposed in <ref> [27] </ref>. This paper identifies a space-filling curve to order points in k-dimensional space. This curve has the desirable property that points that are close by in the input will, with high probability, be close by in the resulting ordering. <p> For example, the R-tree [16], the k-d-B-tree [30], and the grid file [26] use rectangular tessellations and single copies, the R + -tree [33] uses a small number of copies and rectangular tessellations, the hB-tree [22], the cell tree [15] and the z-order <ref> [27] </ref> use non-rectangular decompositions of space. Experimental comparisons seem to indicate that none of these data structures is significantly better than the others for the different cases of range querying. From the previous lemma, we can infer that the problem of indexing classes, despite its structure, is nontrivial.
Reference: [28] <author> M. H. Overmars, M. H. M. Smid, M. T. de Berg, and M. J. van Kreveld, </author> <title> "Maintaining Range Trees in Secondary Memory: Part I: Partitions," </title> <journal> Acta Informatica 27 (1990), </journal> <pages> 423-452. </pages>
Reference: [29] <author> S. Ramaswamy and S. Subramanian, </author> <title> "Path Caching: A Technique for Optimal External Searching," </title> <booktitle> Proc. 13th ACM PODS (1994), </booktitle> <pages> 25-35. </pages>
Reference-contexts: A new technique called path caching was presented in <ref> [29] </ref> to convert many main-memory data structures like the priority search tree, segment tree, etc. into efficient secondary storage structures. For example, it is shown in [29] that it is possible to implement priority search trees in secondary memory so that 2-sided queries can be answered in optimal O (log B <p> A new technique called path caching was presented in <ref> [29] </ref> to convert many main-memory data structures like the priority search tree, segment tree, etc. into efficient secondary storage structures. For example, it is shown in [29] that it is possible to implement priority search trees in secondary memory so that 2-sided queries can be answered in optimal O (log B n + t=B) disk I/O's while using a storage of O ((n=B) log 2 log 2 B).
Reference: [30] <author> J. T. Robinson, </author> <title> "The K-D-B Tree: A Search Structure for Large Multidimensional Dynamic Indexes," </title> <booktitle> Proc. ACM SIGMOD (1984). </booktitle>
Reference-contexts: Many of them are based on a B-tree-like organization. We will consider several of them with reference to our problems. Two related data structures that have been proposed for multi-attribute indexing are the k-d-B-tree <ref> [30] </ref> and the hB-tree [22]. k-d-B-trees combine properties of balanced k-d-trees in a B-tree-like organization. In the 2-dimensional case (these ideas generalize readily to higher dimensions), the k-d-B-tree works by subdividing space into rectangular regions. Such subdivisions are stored in the interior nodes of the k-d-B-tree. <p> Insertion and deletion algorithms for the k-d-B-tree are also outlined in <ref> [30] </ref>. This work does not offer any worst-case analysis for range search. As mentioned before, the k-d-B-tree works by subdividing space into rectangular regions. With a uniform grid of points as input, we would read O (t= p B) disk blocks to report t points on a straight line. <p> There are data structures that attempt to obtain B-tree-like performance using one or more of these ideas. For example, the R-tree [16], the k-d-B-tree <ref> [30] </ref>, and the grid file [26] use rectangular tessellations and single copies, the R + -tree [33] uses a small number of copies and rectangular tessellations, the hB-tree [22], the cell tree [15] and the z-order [27] use non-rectangular decompositions of space.
Reference: [31] <author> H. Samet, </author> <title> Applications of Spatial Data Structures: Computer Graphics, Image Processing, </title> <publisher> and GIS , Addison-Wesley, </publisher> <year> 1989. </year>
Reference: [32] <author> H. Samet, </author> <title> The Design and Analysis of Spatial Data Structures, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference: [33] <author> T. Sellis, N. Roussopoulos, and C. Faloutsos, </author> <title> "The R + -Tree: A Dynamic Index for MultiDimensional Objects," </title> <booktitle> Proc. 1987 VLDB Conference, </booktitle> <address> Brighton, England (1987). </address>
Reference-contexts: That is, we would read O (t= p B) disk blocks to report t points on a straight line. Several data structures have been proposed in the literature to handle region data. These include the R-tree [16], the R fl -tree [2], the R + -tree <ref> [33] </ref>, the cell tree [15] and many others. These data structures are applicable to point data and 1-dimensional range data and hence are relevant to our problems. <p> There are data structures that attempt to obtain B-tree-like performance using one or more of these ideas. For example, the R-tree [16], the k-d-B-tree [30], and the grid file [26] use rectangular tessellations and single copies, the R + -tree <ref> [33] </ref> uses a small number of copies and rectangular tessellations, the hB-tree [22], the cell tree [15] and the z-order [27] use non-rectangular decompositions of space. Experimental comparisons seem to indicate that none of these data structures is significantly better than the others for the different cases of range querying.
Reference: [34] <author> D. D. Sleator and R. E. Tarjan, </author> <title> "A Data Structure for Dynamic Trees," </title> <editor> J. </editor> <booktitle> Computer and System Sciences 24 (1983), </booktitle> <pages> 362-381. </pages>
Reference-contexts: to achieve optimal query time for this problem (O (log B n + t=B) disk I/O's) with only one copy of each object in secondary storage. (For lower bounds on range searching in main memory, see [13] and [7].) In Section 4, analyzing the hierarchy using the hierarchical decomposition of <ref> [34] </ref>, we reduce the problem of indexing classes to a special case of external dynamic 2-dimensional range searching called 3-sided range searching. 3-sided range queries are a special case of 2-dimensional range queries. <p> The procedure trivially extends to forest hierarchies. Before that, we need an algorithm that enables us to decide which of the two lemmas to apply on which part of the hierarchy. The idea for the hierarchy tree labeling algorithm is from a dynamic tree algorithm of <ref> [34] </ref>. The following lemma is easily proven by induction. Lemma 4.5 Let the procedure label-edges shown in Figure 22 be applied to an arbitrary hierarchy tree of size c.
Reference: [35] <author> M. H. M. Smid and M. H. Overmars, </author> <title> "Maintaining Range Trees in Secondary Memory: Part II: Lower Bounds," </title> <journal> Acta Informatica 27 (1990), </journal> <pages> 453-480. </pages>
Reference: [36] <author> S. Subramanian and S. Ramaswamy, </author> <title> "The P-range tree: A new data structure for range searching in secondary memory," </title> <booktitle> To appear in the Proceedings of the Sixth Annual ACM-SIAM Symposium on Discrete Algorithms (1995). </booktitle>
Reference-contexts: Both inserts and deletes can be made to this data structure. The amortized cost of an update is O (log B n). Recently, a much stronger version of the lower bound in Lemma 2.7 was proved in <ref> [36] </ref>. They 37 show that any secondary storage data structure that can answer 2-dimensional range queries in O (log k B n + t=B) I/O's in the worst-case (where k is a constant), has to occupy ( n B )=(log log B n)) disk blocks.
Reference: [37] <author> J. S. Vitter, </author> <title> "Efficient Memory Access in Large-Scale Computation," </title> <booktitle> 1991 Symposium on Theoretical Aspects of Computer Science (STACS), Lecture Notes in Computer Science (1991), invited paper. </booktitle>
Reference-contexts: The I/O bounds will be expressed in terms of n; c; t and B, i.e., all constants will be independent of these four parameters. (For a survey of state of the art I/O complexity, see <ref> [37] </ref>.) We will first review B + -tree performance since we will use that as our point of reference. A B + -tree on attribute x of the n-tuple relation R uses O (n=B) pages of secondary storage.
Reference: [38] <author> S. Zdonik and D. Maier, </author> <title> Readings in Object-Oriented Database Systems, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
References-found: 38

