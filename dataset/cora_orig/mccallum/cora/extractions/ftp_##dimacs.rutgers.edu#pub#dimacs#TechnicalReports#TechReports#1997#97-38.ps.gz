URL: ftp://dimacs.rutgers.edu/pub/dimacs/TechnicalReports/TechReports/1997/97-38.ps.gz
Refering-URL: http://dimacs.rutgers.edu/TechnicalReports/1997.html
Root-URL: http://www.cs.rutgers.edu
Title: Practical Algorithm for Finding Matrix Representations for Polycyclic Groups  
Author: by Eddie H. Lo Gretchen Ostheimer 
Address: Fort Meade, MD  Medford, MA 02155  
Affiliation: National Security Agency  Dept. of Mathematics Tufts University  
Note: A  DIMACS is a cooperative project of Rutgers University, Princeton University, AT&T Bell Laboratories and Bellcore. DIMACS is an NSF Science and Technology Center, funded under contract STC-91-19999; and also receives support from the New Jersey Commission on Science and Technology.  
Abstract: DIMACS Technical Report 97-38 August 1997 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Gilbert Baumslag, Frank B. Cannonito, Derek J. S. Robinson, and Dan Segal. </author> <title> The algorithmic theory of polycyclic-by-finite groups. </title> <journal> J. Algebra, </journal> <volume> 142 </volume> <pages> 118-149, </pages> <year> 1991. </year> <month> - 24 </month> - 
Reference-contexts: Each of the three problems above is decidable for polycyclic groups; however, in the class of solvable groups (a slightly more general class), all three problems are undecidable. (For a summary of de-cidability results concerning polycyclic groups, see <ref> [1] </ref>; the decidability of the isomorphism problem is established in [15].) Polycyclic groups arise naturally in many contexts. For example, every solvable subgroup of the general linear group over the integers, GL (n; Z), is polycyclic. <p> Given a finite presentation for a polycyclic group, can we construct an isomorphic subgroup of GL (n; Z) for some n? It follows implicitly from the results in <ref> [1] </ref> that the answer to this question is "yes, in theory": the obvious algorithm that follows from their work is not practical (Section 2). The main result of this paper is a new algorithm for this problem (Section 3). <p> In Section 3.2 we will need a practical algorithm to find the torsion subgroup of a nilpotent group given by a consistent polycyclic presentation. In Theorem 3.11 of <ref> [1] </ref>, the authors describe an algorithm for finding T (G) for polycyclic G. In the case when G is actually nilpotent, their algorithm (modified slightly) appears to be practical. The modified algorithm is described as follows. <p> In this section we show that it follows implicitly from the results in <ref> [1] </ref> that there exists an algorithm to find an embedding for G. Among the results in [1] are algorithms to do the following. * Find a presentation for a polycyclic subgroup of GL (n; Z) given by a finite generating set of matrices. * Find the kernel of a homomorphism between <p> In this section we show that it follows implicitly from the results in <ref> [1] </ref> that there exists an algorithm to find an embedding for G. Among the results in [1] are algorithms to do the following. * Find a presentation for a polycyclic subgroup of GL (n; Z) given by a finite generating set of matrices. * Find the kernel of a homomorphism between two polycyclic groups given by finite presentations. <p> This question should be investigated further. Let G be a polycyclic group given by a consistent polycyclic presentation. In Section 3.3 an algorithm for deciding whether or not G is torsion-free nilpotent is described. A proof of decidability can also be found in <ref> [1] </ref> where the authors describe an algorithm for deciding whether or not G is nilpotent as well as an algorithm for finding the maximal normal finite subgroup of T of G. As discussed in Section 3.3, their algorithm for finding T appears to be practical for nilpotent G. <p> Then there exists a finite quotient of G which is not nilpotent. Nilpotence can therefore be decided by a method which the authors of <ref> [1] </ref> call the local-global method. Imagine two processes running simultaneously. The first process attempts to prove that G is nilpotent by computing the terms of the lower central series, stopping if it is discovered that fl k (G) = 1. <p> An algorithm for finding the Fitting subgroup of a polycyclic-by-finite group given by a finite presentation is described in <ref> [1] </ref>. Once again, the authors of [1] were not trying to find a practical algorithm. For example, at one point in the algorithm they find a certain finite section F=T of the group, where F / G and T / F . <p> An algorithm for finding the Fitting subgroup of a polycyclic-by-finite group given by a finite presentation is described in <ref> [1] </ref>. Once again, the authors of [1] were not trying to find a practical algorithm. For example, at one point in the algorithm they find a certain finite section F=T of the group, where F / G and T / F .
Reference: [2] <author> Fritz Grunewald and Daniel Segal. </author> <title> Some general algorithms II: Nilpotent groups. </title> <journal> Ann. of Math., </journal> <volume> 112 </volume> <pages> 585-617, </pages> <year> 1980. </year>
Reference-contexts: experiments suggest that such bounds vastly overestimate the actual size of the embedding obtained. (See Section 5 for details about these experiments.) Further experimentation is needed to understand how the size of the embedding obtained for G depends on the group structure of G. 4 Comparisons with Earlier Algorithms In <ref> [2] </ref>, the authors describe an algorithm for finding an embedding of a finitely-generated torsion-free nilpotent group H into Tr 1 (n; Z). Their embedding is the same as that described in Section 3.4. <p> We then used the Grobner basis algorithms described in Section 1.3 to find a basis for Z [H]=I (H) and thereby find a matrix representation for H. In <ref> [2] </ref> the authors describe another method for finding a basis for Z [H]=I (H). It is not clear which algorithm will be faster in practice. This question should be investigated further. Let G be a polycyclic group given by a consistent polycyclic presentation.
Reference: [3] <author> Philip Hall. </author> <title> Finiteness conditions for soluble groups. </title> <journal> Proc. London Math. Soc., </journal> <volume> 4(3) </volume> <pages> 419-436, </pages> <year> 1954. </year>
Reference-contexts: Therefore, our ideals will be described by a finite set of right ideal generators. (Recall that each right ideal in the group ring of a polycyclic-by-finite group is finitely generated as a right ideal. For two different proofs of this, see <ref> [3] </ref> and [9].) Note that if R is any ring and A and B are ideals of R generated as right ideals by sets A and B respectively, then AB is generated as a right ideal by fab j a 2 A; b 2 Bg.
Reference: [4] <author> Philip Hall. </author> <title> Nilpotent groups. In Collected Works of Philip Hall, </title> <booktitle> chapter 23, </booktitle> <pages> pages 415-462. </pages> <publisher> Clarendon Press, </publisher> <year> 1957. </year>
Reference-contexts: We finish this section by proving that our algorithm will produce a representation for F (k; c) of size 1+k +k 2 + +k c for all k and c. In <ref> [4] </ref>, the same representation is constructed by looking at actions of H on the group algebra Q [H], and the size of the representation is - 22 - Table 2: Free Nilpotent Groups Group Size of embedding F (2; 1) 3 F (2; 3) 15 calculated. <p> In [12], many of Hall's lemmas are proved in the context of the group ring of H over a ring R. Here, we will state the result in Z [H] and prove it by referring to <ref> [4] </ref> and [12]. As in Section 3.1, H denotes the augmentation ideal of Z [H]. Proposition 6.1 Let H be the free nilpotent group of rank k and class c. <p> and including the term t c , where for i = 1; 2; : : : ; c, m i is the rank of fl i (H)=fl i+1 (H) as a free abelian group (<ref> [4] </ref> p. 452). Note also that 1 = j=1 (1 t j ) m j by [4] p. 441. The proposition now follows. 7 Implementation Notes It has been mentioned that the algorithm described in Section 3.7 has not been fully implemented yet. In this section, we discuss what would be involved to make a full implementation possible.
Reference: [5] <author> Eddie H. Lo. </author> <title> Enumerating the finite index subgroups of a polycyclic group. </title> <note> In preparation. </note>
Reference-contexts: The restriction is weak in the sense that every polycyclic group has a finite index subgroup satisfying it. In this paper, we extend the results in [10] by removing the restriction. We do so by relying on algorithms in <ref> [5] </ref> and [11]. We also discuss some heuristics for improving on the algorithm in [10] based on new experimental results. <p> Coset tables for the subgroups of polycyclic groups can be found using a wreath-product ordering on the rows and from the coset tables, generators for the subgroups can be found. For details refer to <ref> [5] </ref> and [16]. The algorithm for constructing a representation of polycyclic groups is shown in Figure 1. <p> If the polycyclic group whose representation needs to be found is not (torsion-free nilpotent)-by-abelian, then it is necessary to find a finite index (torsion-free nilpotent)-by-abelian subgroup first. A program to enumerate finite index subgroups of a polycyclic group has been developed. See <ref> [5] </ref> for details. We also need to be able to determine whether a subgroup of a polycyclic group is torsion-free nilpotent. An algorithm has been sketched in Section 3.3.
Reference: [6] <author> Eddie H. Lo. </author> <title> Finding intersection and normalizer in finitely generated nilpotent groups. </title> <journal> J. Symbolic Computation. </journal> <note> To appear. </note>
Reference-contexts: In particular, the generators in a consistent polycyclic presentation form a polycyclic generating sequence for G. (See Section 9.6 of [16] for a precise definition.) Throughout this paper we rely on the following algorithms in [16] and <ref> [6] </ref> for working with a polycyclic group G given by a consistent polycyclic presentation.
Reference: [7] <author> Eddie H. Lo. </author> <title> A polycyclic quotient algorithm. </title> <journal> J. Symbolic Computation. </journal> <note> To appear. </note>
Reference-contexts: In this section we recall some basic facts about group rings. We also discuss a generalization of the Grobner basis method in commutative ring theory to the group ring of a polycyclic group. (See <ref> [7] </ref> or [9].) Throughout this paper, the term ideal will be used to refer to a two-sided ideal of a ring. However, the algorithms in [7] work with right ideals. <p> We also discuss a generalization of the Grobner basis method in commutative ring theory to the group ring of a polycyclic group. (See <ref> [7] </ref> or [9].) Throughout this paper, the term ideal will be used to refer to a two-sided ideal of a ring. However, the algorithms in [7] work with right ideals. Therefore, our ideals will be described by a finite set of right ideal generators. (Recall that each right ideal in the group ring of a polycyclic-by-finite group is finitely generated as a right ideal. <p> As we saw in Section 1.3, fa 1 1; : : : ; a k 1g generates H as a right ideal. Hence we can obtain a set of k c+1 elements of Z [H] that generates H c+1 as a right ideal. Use the algorithms in <ref> [7] </ref> to obtain a generating set fb 1 + H c+1 ; : : : ; b r + H c+1 g for the torsion subgroup of Z [H]=H c+1 (considered as an abelian group). <p> 4 a 2 = a 2 a 3 a 1 a 4 a 3 = a 3 a 4 ; a 5 a 3 = a 3 a 5 ; a 5 a 4 = a 4 a 5 i: This group is the metabelian quotient of G 5 from <ref> [7] </ref>. Applying the algorithm directly to this presentation, we obtain a representation of degree 35. Notice, however, that fa 1 ; a 3 ; a 4 ; a 5 g generates a normal free abelian subgroup of rank 4 in L 3 .
Reference: [8] <author> Eddie H. Lo. </author> <title> A Polycyclic Quotient Algorithm Package. </title> <institution> Department of Mathematics, Rutgers University, </institution> <address> New Jersey, ftp@math.rutgers.edu, </address> <year> 1996. </year>
Reference-contexts: Let G be a polycyclic group and let I be an ideal of Z [G]. Suppose we are given a consistent polycyclic presentation for G and a finite set of elements in the group ring that - 4 - generates I as a right ideal. In <ref> [8] </ref>, algorithms have been implemented to solve the following problems. * Decide whether or not a given element of the group ring is an element of I. * Decide whether or not Z [G]=I is finitely generated as an abelian group. * If so, find a finite set of elements of <p> Instead, we stepped through the algorithm by hand using as tools a Maple implementation of the algorithms for working with the enveloping algebra of a matrix group and the Grobner basis method for integral group rings of polycyclic groups as implemented in <ref> [8] </ref>. (See Section 1.3.) Along the way, methods to simplify the construction were used to reduce the amount of the computation and the size of the representation. In general, the algorithm seems to work well as stated. <p> We first used <ref> [8] </ref> to obtain presentations for these groups. We then used the techniques in Section 3.2 to construct embeddings from these presentations. The sizes of the embeddings obtained are listed in Table 2. <p> The algorithm relies on the ability to do fundamental computations in the group ring of a polycyclic group, as outlined in Section 1.3. In the experiments we performed, the tool we used is the program <ref> [8] </ref>. Originally used to compute polycyclic quotients of finitely presented groups, [8] also allows users to perform the group ring calculations needed here. Readers are referred to the examples in [8] on how this can be done. <p> The algorithm relies on the ability to do fundamental computations in the group ring of a polycyclic group, as outlined in Section 1.3. In the experiments we performed, the tool we used is the program <ref> [8] </ref>. Originally used to compute polycyclic quotients of finitely presented groups, [8] also allows users to perform the group ring calculations needed here. Readers are referred to the examples in [8] on how this can be done. For a full implementation, it is also necessary to be able to compute in the enveloping algebra of a matrix group. <p> In the experiments we performed, the tool we used is the program <ref> [8] </ref>. Originally used to compute polycyclic quotients of finitely presented groups, [8] also allows users to perform the group ring calculations needed here. Readers are referred to the examples in [8] on how this can be done. For a full implementation, it is also necessary to be able to compute in the enveloping algebra of a matrix group. This can be done easily when simple matrix multiplications and integer row Hermite normal form calculations are provided.
Reference: [9] <author> Eddie H. Lo. </author> <title> A polycyclic quotient algorithm. </title> <booktitle> In DIMACS Series in Discrete Mathematics and Computer Science, </booktitle> <pages> pages 159-168, </pages> <year> 1997. </year>
Reference-contexts: In this section we recall some basic facts about group rings. We also discuss a generalization of the Grobner basis method in commutative ring theory to the group ring of a polycyclic group. (See [7] or <ref> [9] </ref>.) Throughout this paper, the term ideal will be used to refer to a two-sided ideal of a ring. However, the algorithms in [7] work with right ideals. <p> Therefore, our ideals will be described by a finite set of right ideal generators. (Recall that each right ideal in the group ring of a polycyclic-by-finite group is finitely generated as a right ideal. For two different proofs of this, see [3] and <ref> [9] </ref>.) Note that if R is any ring and A and B are ideals of R generated as right ideals by sets A and B respectively, then AB is generated as a right ideal by fab j a 2 A; b 2 Bg.
Reference: [10] <author> Gretchen Ostheimer. </author> <title> Algorithms for Polycyclic-by-Finite Groups. </title> <type> PhD thesis, </type> <institution> Rutgers Univerisity, Math Dept., </institution> <year> 1996. </year>
Reference-contexts: For a comparison of our practical algorithm with that in [15], see Section 4. This paper is based on the second author's Ph. D. thesis <ref> [10] </ref>. In that thesis, a practical algorithm is given for embedding a polycyclic group provided that the group satisfies a certain technical restriction. The restriction is weak in the sense that every polycyclic group has a finite index subgroup satisfying it. In this paper, we extend the results in [10] by <p> thesis <ref> [10] </ref>. In that thesis, a practical algorithm is given for embedding a polycyclic group provided that the group satisfies a certain technical restriction. The restriction is weak in the sense that every polycyclic group has a finite index subgroup satisfying it. In this paper, we extend the results in [10] by removing the restriction. We do so by relying on algorithms in [5] and [11]. We also discuss some heuristics for improving on the algorithm in [10] based on new experimental results. <p> In this paper, we extend the results in <ref> [10] </ref> by removing the restriction. We do so by relying on algorithms in [5] and [11]. We also discuss some heuristics for improving on the algorithm in [10] based on new experimental results. Further experiments are needed to better understand which kinds of presentations can be represented practically using our techniques. 1.1 Notation and definitions Throughout this paper let Z denote the ring of integers, Q the field of rationals, and C the field of complex numbers.
Reference: [11] <author> Gretchen Ostheimer. </author> <title> Algorithms for polycyclic-by-finite matrix groups. </title> <booktitle> In DIMACS Series in Discrete Mathematics and Computer Science, </booktitle> <pages> pages 297-307, </pages> <year> 1997. </year>
Reference-contexts: The restriction is weak in the sense that every polycyclic group has a finite index subgroup satisfying it. In this paper, we extend the results in [10] by removing the restriction. We do so by relying on algorithms in [5] and <ref> [11] </ref>. We also discuss some heuristics for improving on the algorithm in [10] based on new experimental results. <p> Then Q [ P generates I as a right ideal of Z [K]. Now we may assume that we have constructed the homomorphism t of Lemma 3.6. In <ref> [11] </ref>, a practical algorithm is given for finding a presentation for an abelian matrix group; in this context, that algorithm finds a nonnegative integer r such that hri is the kernel of the homomorphism from Z to ht (a)i taking i to t (a) i . <p> By Lemma 3.8 it now follows that there exists a positive integer n and an embedding - : G ! GL (n; Z) such that -(G) 0 = -(G 0 ) Tr 1 (n; Z). It is shown in <ref> [11] </ref> that since -(G) 0 is unipotent, it follows that -(G) is triangularizable.
Reference: [12] <author> Inder Bir S. Passi. </author> <title> Group Rings and Their Augmentation Ideals. </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: In [4], the same representation is constructed by looking at actions of H on the group algebra Q [H], and the size of the representation is - 22 - Table 2: Free Nilpotent Groups Group Size of embedding F (2; 1) 3 F (2; 3) 15 calculated. In <ref> [12] </ref>, many of Hall's lemmas are proved in the context of the group ring of H over a ring R. Here, we will state the result in Z [H] and prove it by referring to [4] and [12]. As in Section 3.1, H denotes the augmentation ideal of Z [H]. <p> In <ref> [12] </ref>, many of Hall's lemmas are proved in the context of the group ring of H over a ring R. Here, we will state the result in Z [H] and prove it by referring to [4] and [12]. As in Section 3.1, H denotes the augmentation ideal of Z [H]. Proposition 6.1 Let H be the free nilpotent group of rank k and class c.
Reference: [13] <author> Derek J. S. Robinson. </author> <title> A Course in the Theory of Groups. </title> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: It is obvious that T (G) T . Since A is central in G, A is contained in Z (C), the center of C. Therefore jC : Z (C)j jC : Aj &lt; 1. By a theorem of Schur (Corollary 10.1.4 in <ref> [13] </ref>), it follows that C 0 is finite. Therefore, T is finite and T = T (G). 1.3 Algorithms for the group ring In order to construct a representation of a polycyclic group G, we let G act on the group ring Z [H] for various subgroups H of G.
Reference: [14] <author> Daniel Segal. </author> <title> Polycyclic Groups. </title> <publisher> Cambridge University Press, </publisher> <year> 1983. </year>
Reference-contexts: If G is a subgroup of GL (n; F ) and if G is triangularizable over some extension field E of F , then there exists a finite extension L of F over which G is triangularizable. (See p. 33 of <ref> [14] </ref>.) Therefore, a subgroup G of GL (n; Q) is triangularizable if and only if it is triangularizable over C. Let Tr 1 (n; R) denote the group of upper triangular matrices with entries in R and ones along the diagonal. Elements of Tr 1 (n; R) are called unitriangular. <p> and if R is Z or Q, then there is a basis for R n with respect to which G is unitriangular. (The case when R = Q is proved as Corollary 1.21 in [17], and the case when R = Z follows easily.) Lemma 7 of Chapter 5 of <ref> [14] </ref> gives an alternative condition which guarantees the existence of such a basis, namely, that G act nilpotently on R n : the group G acts nilpotently on R n if there exists a chain 0 V 0 V 1 V k = R n of G-invariant subgroups of R n <p> We also describe practical algorithms for deciding whether or not G falls into either of the above special cases (Sections 3.3 and 3.6). 3.1 Existence of an embedding into Tr 1 (n; Z) In Chapter 5 of <ref> [14] </ref>, Segal proves the existence of an embedding of a finitely generated torsion-free nilpotent group into a unitriangular matrix group. In Section 3.2 we describe an algorithm for constructing this embedding. In this section we summarize the results from [14] to which we will need to refer when describing our construction. <p> an embedding into Tr 1 (n; Z) In Chapter 5 of <ref> [14] </ref>, Segal proves the existence of an embedding of a finitely generated torsion-free nilpotent group into a unitriangular matrix group. In Section 3.2 we describe an algorithm for constructing this embedding. In this section we summarize the results from [14] to which we will need to refer when describing our construction. Proposition 3.1 Let G = X n H be a semidirect product. <p> found the last term in the lower central series for H, we can now compute the torsion subgroup of H (using the algorithm described in Section 1.2), and thereby decide whether or not H is torsion-free. 3.4 Existence of an embedding into a solvable matrix group In Chapter 5 of <ref> [14] </ref>, Segal proves the existence of an embedding of an abstract polycyclic group G into GL (n; Z) for some n. In Section 3.6 we describe an algorithm for constructing a similar embedding in the case when G 0 is torsion-free nilpotent. In this section, we summarize the results from [14] <p> <ref> [14] </ref>, Segal proves the existence of an embedding of an abstract polycyclic group G into GL (n; Z) for some n. In Section 3.6 we describe an algorithm for constructing a similar embedding in the case when G 0 is torsion-free nilpotent. In this section, we summarize the results from [14] to which we will need to refer when describing our construction. For the key step in the proof, Segal makes the following inductive assumption. Throughout this paper we will refer to this assumption as Hypothesis (y). <p> Proof Since a acts trivially on Z [K]=H, the ideal J + H is invariant under a. Therefore I is also invariant. Since Z [K]=J is finitely generated as an abelian group, so is Z [K]=(J + H). By Lemma 9 in Section 5.C of <ref> [14] </ref>, Z [K]=S is also finitely generated as an abelian group. Therefore Z [K]=I is finitely generated free abelian. Before finding the kernel of t , we show that (1 + I) " K = 1. Since is injective, (1 + J ) " K = 1. <p> With this key lemma in hand, it is now relatively easy to prove the existence of a matrix representation for a polycyclic-by-finite group. The following lemma is an exercise in <ref> [14] </ref> (p. 92). Lemma 3.7 Let G be a polycyclic-by-finite group. There exists a normal torsion-free subgroup G 1 with finite index in G such that G 1 =Fitt (G 1 ) is free abelian. Let G 1 /G as above. Lemma 8 of Section 5.C of [14] shows that in <p> an exercise in <ref> [14] </ref> (p. 92). Lemma 3.7 Let G be a polycyclic-by-finite group. There exists a normal torsion-free subgroup G 1 with finite index in G such that G 1 =Fitt (G 1 ) is free abelian. Let G 1 /G as above. Lemma 8 of Section 5.C of [14] shows that in order to find an embedding of G, it suffices to find an embedding for G 1 . Since we will use Segal's Lemma 8 in a somewhat different context, we give a more complete statement and proof of it here. <p> Since we will use Segal's Lemma 8 in a somewhat different context, we give a more complete statement and proof of it here. The proof given here is basically that sketched in <ref> [14] </ref>. Lemma 3.8 Let H be a subgroup of finite index d in a group G. Suppose that there exists an embedding of H into GL (n; Z). Then there exists an embedding of G into GL (nd; Z). <p> Therefore (G) 0 is torsion-free nilpotent. Since (G) 0 is solvable, it follows that (G) is solvable, and Mal'cev showed that all solvable subgroups of GL (n; Z) are polycyclic. (For a proof of this see Section 2.B in <ref> [14] </ref>.) The converse of Proposition 3.10 also holds: Proposition 3.11 If G is a polycyclic group and G 0 is torsion-free nilpotent, then there exists a positive integer n and an embedding : G ,! GL (n; Z) mapping G into a triangu-larizable group. <p> i+1 using the methods in Lemma 3.9; Construct a representation of H 0 from H 1 using the methods of Lemma 3.8; Construct a representation of G from H using the methods of Lemma 3.8; End. 3.7 Constructing an embedding into a solvable matrix group It is a well-known fact <ref> [14] </ref> that polycyclic groups are (torsion-free nilpotent)-by-abelian-by-finite. In the previous section we saw how a group whose commutator subgroup is torsion-free nilpotent can be embedded into a triangularizable matrix group. Here we will solve the embedding problem for general polycyclic groups. Let G be a polycyclic group. <p> As discussed in Section 3.3, their algorithm for finding T appears to be practical for nilpotent G. Their algorithm to decide nilpotence depends on the following theorem. (See Section 1.C in <ref> [14] </ref>.) Theorem 4.1 Let G be a polycyclic-by-finite group such that G is not nilpotent. Then there exists a finite quotient of G which is not nilpotent. Nilpotence can therefore be decided by a method which the authors of [1] call the local-global method. Imagine two processes running simultaneously. <p> Let A and B be subgroups of G (given by finite generating sets). Decide whether or not A and B are conjugate in G. The following theorem (Section 4.D in <ref> [14] </ref>) shows that the local-global method can be used to decide whether or not A and B are conjugate. Theorem 4.2 Let G be a polycyclic-by-finite group and let A and B be two subgroups of G.
Reference: [15] <author> Daniel Segal. </author> <title> Decidable properties of polycyclic groups. </title> <journal> Proc. London Math. Soc. </journal> <volume> (3), 61 </volume> <pages> 497-528, </pages> <year> 1990. </year>
Reference-contexts: Each of the three problems above is decidable for polycyclic groups; however, in the class of solvable groups (a slightly more general class), all three problems are undecidable. (For a summary of de-cidability results concerning polycyclic groups, see [1]; the decidability of the isomorphism problem is established in <ref> [15] </ref>.) Polycyclic groups arise naturally in many contexts. For example, every solvable subgroup of the general linear group over the integers, GL (n; Z), is polycyclic. Indeed, a group is polycyclic if and only if it is isomorphic to a solvable subgroup of GL (n; Z) for some n. <p> Preliminary experiments suggest that this algorithm is practical for some interesting presentations (Section 5). Among the examples considered were a collection of free nilpotent groups; our results here led us to a theoretical result concerning such groups (Section 6). Segal also developed an algorithm for embedding polycyclic groups <ref> [15] </ref>; his algorithm is impractical, but it is stronger than the algorithm presented here in the sense that his embedding satisfies certain properties that are necessary in order to solve the isomorphism problem. For a comparison of our practical algorithm with that in [15], see Section 4. <p> developed an algorithm for embedding polycyclic groups <ref> [15] </ref>; his algorithm is impractical, but it is stronger than the algorithm presented here in the sense that his embedding satisfies certain properties that are necessary in order to solve the isomorphism problem. For a comparison of our practical algorithm with that in [15], see Section 4. This paper is based on the second author's Ph. D. thesis [10]. In that thesis, a practical algorithm is given for embedding a polycyclic group provided that the group satisfies a certain technical restriction. <p> Eventually, one of these two processes stops, at which point we know whether or not G is nilpotent. This algorithm is unlikely to be practical even for very simple examples. In <ref> [15] </ref>, Segal describes an algorithm for finding an embedding of a polycyclic group G (given by a finite presentation) into GL (n; Z). The main result in [15] is an algorithm to decide whether or not two polycyclic groups are isomorphic. <p> This algorithm is unlikely to be practical even for very simple examples. In <ref> [15] </ref>, Segal describes an algorithm for finding an embedding of a polycyclic group G (given by a finite presentation) into GL (n; Z). The main result in [15] is an algorithm to decide whether or not two polycyclic groups are isomorphic. That goal places extra requirements on the embedding for G, and hence the construction of the embedding in [15] is more complicated than that described in Section 3.4 of this paper. In [15], no attempt was made <p> The main result in <ref> [15] </ref> is an algorithm to decide whether or not two polycyclic groups are isomorphic. That goal places extra requirements on the embedding for G, and hence the construction of the embedding in [15] is more complicated than that described in Section 3.4 of this paper. In [15], no attempt was made to find a practical algorithm to construct the embedding. <p> The main result in <ref> [15] </ref> is an algorithm to decide whether or not two polycyclic groups are isomorphic. That goal places extra requirements on the embedding for G, and hence the construction of the embedding in [15] is more complicated than that described in Section 3.4 of this paper. In [15], no attempt was made to find a practical algorithm to construct the embedding. <p> Moreover, the problem of finding a practical algorithm to solve the generalized conjugacy problem is generally believed to be quite difficult. Nonetheless, there may be a practical algorithm for finding the embedding described in <ref> [15] </ref>. It would be interesting to investigate this. As we remarked in Section 3.6, we did not follow the construction in Section 3.4 exactly, because to do so we would need to find the Fitting subgroup of a polycyclic group G given by a consistent polycyclic presentation. <p> In addition to comparing the efficiency of various algorithms for finding a matrix representation for a polycyclic group, we should also compare the sizes of the matrices produced by such algorithms. The embedding described in <ref> [15] </ref> is canonical in the following sense. Se-gal defines, for a given polycyclic-by-finite group G, a positive integer n G and an embedding fi G of G into GL (n G ; Z). Let G and H be isomorphic polycyclic groups, where : G ! H is an isomorphism.
Reference: [16] <author> Charles C. Sims. </author> <title> Computation with Finitely Presented Groups. </title> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference-contexts: nilpotently on R n if there exists a chain 0 V 0 V 1 V k = R n of G-invariant subgroups of R n such that the induced action of G on each factor V i =V i1 is trivial. 1.2 Basic algorithms for polycyclic groups Chapter 9 in <ref> [16] </ref> gives a good introduction to polycyclic groups. A group G is polycyclic if there is a sequence of subgroups G 1 , . . . , G k+1 for G such that G = G 1 . G 2 . . G k . <p> Intuitively, a consistent polycyclic presentation is one from which the polycyclic structure of the group is easily gleaned. In particular, the generators in a consistent polycyclic presentation form a polycyclic generating sequence for G. (See Section 9.6 of <ref> [16] </ref> for a precise definition.) Throughout this paper we rely on the following algorithms in [16] and [6] for working with a polycyclic group G given by a consistent polycyclic presentation. <p> In particular, the generators in a consistent polycyclic presentation form a polycyclic generating sequence for G. (See Section 9.6 of <ref> [16] </ref> for a precise definition.) Throughout this paper we rely on the following algorithms in [16] and [6] for working with a polycyclic group G given by a consistent polycyclic presentation. <p> See Section 9.3 in <ref> [16] </ref> for a proof. For a polycyclic group G define the torsion subgroup of G, T (G), to be hN j N / G and N finitei: It follows from the ascending chain condition that T (G) is finite. <p> Suppose H is generated by fa 1 ; : : : ; a k g. Then the image of generates fl i+1 (H)=fl i+2 (H). (See Proposition 9.2.6 of <ref> [16] </ref>.) Let g be in fg 1 ; : : : ; g m g, let a be in fa 1 ; : : : ; a k g, and let s be a positive integer greater than 1. Using a commutator identity (Proposition 9.1.6 of [16]), we see that [g <p> (See Proposition 9.2.6 of <ref> [16] </ref>.) Let g be in fg 1 ; : : : ; g m g, let a be in fa 1 ; : : : ; a k g, and let s be a positive integer greater than 1. Using a commutator identity (Proposition 9.1.6 of [16]), we see that [g s ; a]fl i+2 (H) = [g s1 ; a][g s1 ; a; g][g; a]fl i+2 (H): - 8 - Since fl i+1 (H)=fl i+2 (H) is abelian and [g s1 ; a; g] 2 fl i+2 , [g s ; a]fl i+2 (H) = [g <p> For the rest of this section, assume that G 0 is torsion-free nilpotent. We are now in a position to describe an algorithm for embedding G. Use the methods of Section 9.6 of <ref> [16] </ref> to find generators for G 0 . As we showed in Section 3.2, we can construct an embedding from G 0 into Tr 1 (m; Z). The methods of Section 9.6 of [16] can also be used to find a consistent polycyclic presentation for G=G 0 . <p> Use the methods of Section 9.6 of <ref> [16] </ref> to find generators for G 0 . As we showed in Section 3.2, we can construct an embedding from G 0 into Tr 1 (m; Z). The methods of Section 9.6 of [16] can also be used to find a consistent polycyclic presentation for G=G 0 . Find generators for subgroups H 0 ; : : : ; H r such that G = H 0 . H 1 . : : : . <p> Coset tables for the subgroups of polycyclic groups can be found using a wreath-product ordering on the rows and from the coset tables, generators for the subgroups can be found. For details refer to [5] and <ref> [16] </ref>. The algorithm for constructing a representation of polycyclic groups is shown in Figure 1. <p> In the first series of experiments, we constructed embeddings from presentations for the groups Tr 1 (n; Z). For n = 2; 3; 4; 5, we followed Example 4.1 in Chapter 9 of <ref> [16] </ref> to obtain a consistent polycyclic presentation for Tr 1 (n; Z).
Reference: [17] <author> B. A. F. Wehrfritz. </author> <title> Infinite Linear Groups. </title> <publisher> Springer-Verlag, </publisher> <year> 1973. </year>
Reference-contexts: If G is unipotent and if R is Z or Q, then there is a basis for R n with respect to which G is unitriangular. (The case when R = Q is proved as Corollary 1.21 in <ref> [17] </ref>, and the case when R = Z follows easily.) Lemma 7 of Chapter 5 of [14] gives an alternative condition which guarantees the existence of such a basis, namely, that G act nilpotently on R n : the group G acts nilpotently on R n if there exists a chain
References-found: 17

