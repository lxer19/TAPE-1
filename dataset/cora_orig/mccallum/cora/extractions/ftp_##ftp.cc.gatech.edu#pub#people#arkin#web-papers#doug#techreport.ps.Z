URL: ftp://ftp.cc.gatech.edu/pub/people/arkin/web-papers/doug/techreport.ps.Z
Refering-URL: http://www.cc.gatech.edu/aimosaic/robot-lab/mrl-online-publications.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A DESIGN METHODOLOGY FOR THE CONFIGURATION OF BEHAVIOR-BASED MOBILE ROBOTS  
Author: Douglas Christopher MacKenzie Douglas Christopher MacKenzie 
Degree: A Thesis Presented to The Academic Faculty By  In Partial Fulfillment of the Requirements for the Degree Doctor of Philosophy in Computer Science  
Note: Copyright c 1996 by  
Affiliation: Georgia Institute of Technology Tech  
Pubnum: Report #GIT-CS-97/01  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M.A. Arbib, A.J. Kfoury, and R.N. Moll. </author> <title> A Basis for Theoretical Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1981. </year>
Reference: [2] <author> R.C. Arkin. </author> <title> Towards Cosmopolitan Robots: Intelligent Navigation of a Mobile Robot in Extended Man-made Environments. </title> <type> Ph.D. dissertation, </type> <institution> University of Massachusetts, Department of Computer and Information Science, </institution> <year> 1987. </year> <type> COINS TR 87-80. </type>
Reference-contexts: A transition back to the Look for can state repeats the process. 3.4.3 Cooperation The cooperative class of coordination manages the actions of members of the society to present the appearance and utility of a single coherent agent. The vector summation in the AuRA <ref> [3, 2] </ref> architecture is such a mechanism. The AuRA gain-based cooperative cooperation operator can be represented functionally as a weighted vector summation, as shown in Equation 3.11.
Reference: [3] <author> R.C. Arkin. </author> <title> Motor schema-based mobile robot navigation. </title> <journal> The International Journal of Robotics Research, </journal> <volume> 8(4) </volume> <pages> 92-112, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: A transition back to the Look for can state repeats the process. 3.4.3 Cooperation The cooperative class of coordination manages the actions of members of the society to present the appearance and utility of a single coherent agent. The vector summation in the AuRA <ref> [3, 2] </ref> architecture is such a mechanism. The AuRA gain-based cooperative cooperation operator can be represented functionally as a weighted vector summation, as shown in Equation 3.11. <p> The binding process determines which compiler will be used to generate the final executable code as well as which libraries of behavior primitives will be available for placement within the editor. 5.1 Graphic Designer Reactive behavior-based architectures <ref> [3, 9] </ref> decompose a robot's control program into a collection of behaviors and coordination mechanisms. This decomposition allows 85 86 construction of a library of reusable behaviors and assemblages of behaviors by design-ers skilled in low-level control issues. <p> Currently, the mission language interpreter is resident on the operator console and communicates with the robots to invoke the correct assemblages during the mission. In future versions the interpreter may be moved onto the robots to better mesh with our schema-based control paradigm <ref> [3] </ref>. UNIT &lt;scouts&gt; (&lt;scouts-1&gt; ROBOT ROBOT) (&lt;scouts-2&gt; ROBOT ROBOT) COMMAND LIST: 0. UNIT scouts START AA-AA1 0 20 1. UNIT scouts OCCUPY AA-AA1 FORMATION Column 2. UNIT scouts MOVETO ATK-AP1 FORMATION Column 3. UNIT scouts OCCUPY ATK-AP1 FORMATION Diamond 4. UNIT scouts MOVETO PP-Charlie FORMATION Column 5. <p> The configuration editor encourages users to follow the behavior-based paradigm using data-flow style computation. Clearly, there are good points and bad points to every architecture and this one will be no exception. This style of structuring robot control software has proven fruitful in many other robot architectures <ref> [9, 3, 14] </ref> and it is expected the configurations created will be of acceptable quality, both in terms of resource requirements and run-time performance. However, there certainly exist some htask; environment; roboti tuples where expert roboticists could improve performance by hand-crafting solutions following differing paradigms.
Reference: [4] <author> R.C. </author> <title> Arkin and D.C. MacKenzie. Temporal coordination of perceptual algorithms for mobile robot navigation. </title> <journal> IEEE Transactions on Robotics and Automation, </journal> <volume> 10(3) </volume> <pages> 276-286, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Level c shows the various operating states present in each of the two fish to support the mating ritual. The linear chain of behaviors shown in Figure 3.1 can be represented as a Finite State Automaton (FSA) using the methods of Temporal Sequencing <ref> [4] </ref>. Temporal sequencing formalizes methods for partitioning a mission into discrete operating states and describing the transitions between states. The FSA is partitioned into the relevant male and female portions and distributed within the respective robots 34 (fish).
Reference: [5] <author> T. Balch, G. Boone, T. Collins, H. Forbes, D. MacKenzie, and J. Santamara. </author> <title> Io, Ganymede and Callisto amultiagent robot trash-collecting team. </title> <journal> AI Magazine, </journal> <volume> 16(2) </volume> <pages> 39-51, </pages> <month> Summer </month> <year> 1995. </year>
Reference-contexts: Consider specification of a configuration implementing a janitorial task for a team of robots (e.g., 1994 AAAI mobile robot competition <ref> [5] </ref>). Specifically, each robot should wander around looking for empty soda cans, pick them up, wander around looking for a recycling basket, and then place the can into the basket. Figure 3.12 is a graphical representation of an FSA for such a robotic trash collector. <p> This task is similar to the 1994 AAAI mobile robot competition <ref> [5] </ref> where the robots retrieved soda cans and placed them near wastebaskets. 54 Reconsider the trash collecting state-transition diagram Figure 3.12 from Section 3.4.2 reproduced in Figure 4.2. Let's call this the cleanup agent. <p> Configuration design tools have been developed to reduce the workload on designers following this development process. 5.1.2 Use of the Graphic Designer To demonstrate use of the graphic designer we will develop a configuration implementing a janitorial task for a team of robots (e.g., 1994 AAAI mobile robot competition <ref> [5] </ref>). Reconsider the trash collecting state-transition diagram from Chapter 3 (Figure 3.12) reproduced in Figure 5.4. Each robot wanders around looking for empty soda cans, picks them up, wanders around looking for a recycling basket, and places the can into the basket.
Reference: [6] <author> Tucker Balch and Ronald C. Arkin. </author> <title> Motor-schema based formation control for multiagent robotic teams. </title> <booktitle> In Proc. 1995 International Conference on Multiagent Systems, </booktitle> <pages> pages 10-16, </pages> <address> San Francisco, CA, </address> <year> 1995. </year>
Reference-contexts: A behavior called MoveInFormation was created which causes the robot to move to a specified map location while maintaining formation with other robots <ref> [6] </ref>. The robots each have an assigned spot in the formation and know the relative locations of the other robots. Each robot computes where it should be located relative to the other robots, and the Maintain Formation behavior tries to keep it in position as the formation moves.
Reference: [7] <author> Daniel G. Bobrow et al. </author> <title> Common LISP object system. </title> <editor> In Guy L. Steele Jr., editor, </editor> <title> Common LISP: </title> <booktitle> The Language, chapter 28, </booktitle> <pages> pages 770-864. </pages> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: There is no attempt to maintain a generic description of the mission and retargeting different hardware will require significant effort. 2.1.4 The SmartyCat Agent Language The SmartyCat Agent Language (SAL) developed at Grumman [47] is based on the Common LISP Object System <ref> [7] </ref>. SAL is similar to CDL in drawing heavily from the Robot Schemas (RS) architecture [50] and the Society of Mind theory [58]. In SAL a configuration is a data-flow graph of port automata nodes connected with communication links. The Agencies construction provides support for hierarchical specification of complex objects.
Reference: [8] <author> Mark Bradakis, Thomas C. Henderson, and Joe Zachary. </author> <title> Reactive behavior design tools. </title> <booktitle> In Proc. IEEE International Symposium on Intelligent Control, </booktitle> <pages> pages 178-183. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: This is compared to MissionLab which is targeted to the mobile robot community. ControlShell does not support explicit hardware binding or support any run-time architectures but its own. 2.3.4 GI Joe Graphical FSA Editor The GI Joe toolset <ref> [8] </ref> allows graphical construction and visualization of finite state automata. These state machines can then be exported to a format used by COSPAN for analysis. COSPAN [28] is a specification language and verification system for state-based control systems. <p> From this graphical representation the COSPAN S/R definition is generated automatically. (After <ref> [8] </ref>, Figure 2). GI Joe allows running the COSPAN verification system against the FSA's constructed using the editor to check their correctness.
Reference: [9] <author> R.A. Brooks. </author> <title> A robust layered control system for a mobile robot. </title> <journal> IEEE Journal of Robotics and Automation, </journal> <volume> 2(1) </volume> <pages> 14-23, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: In this case, the operator crafts a suitable behavioral assemblage which can be instantiated and executed to complete the desired task. These configurations commonly utilize temporally sequenced coordination to encode the operator's knowledge of appropriate performance changes based on run-time perceptual feedback. 2.2.2 Subsumption architecture The subsumption architecture <ref> [9] </ref> is probably the most widely known behavior-based mobile robot architecture. Sensations arriving on channels from sensors are processed by behaviors which transmit actions on their output channels to actuators for execution. Prioritization of behaviors is handled through gating operators on input and output data streams. <p> The process of determining this collection of active members (arbitration) can use a variety of techniques including spreading activation, assigning fixed priorities, or using relevancy metrics. Architectures using competition mechanisms include spreading activation nets [54], and the subsumption architecture <ref> [9] </ref>. The colony architecture [14] is a variant of the subsumption architecture which tends to simplify the behavioral networks (Section 2.2.2). As in the subsumption architecture, individual modules are interconnected into a hierarchy using a fixed priority arbitration network. <p> The binding process determines which compiler will be used to generate the final executable code as well as which libraries of behavior primitives will be available for placement within the editor. 5.1 Graphic Designer Reactive behavior-based architectures <ref> [3, 9] </ref> decompose a robot's control program into a collection of behaviors and coordination mechanisms. This decomposition allows 85 86 construction of a library of reusable behaviors and assemblages of behaviors by design-ers skilled in low-level control issues. <p> The configuration editor encourages users to follow the behavior-based paradigm using data-flow style computation. Clearly, there are good points and bad points to every architecture and this one will be no exception. This style of structuring robot control software has proven fruitful in many other robot architectures <ref> [9, 3, 14] </ref> and it is expected the configurations created will be of acceptable quality, both in terms of resource requirements and run-time performance. However, there certainly exist some htask; environment; roboti tuples where expert roboticists could improve performance by hand-crafting solutions following differing paradigms.
Reference: [10] <author> R.A. Brooks. </author> <title> A robot that walks: Emergent behaviors from a carefully evolved network. </title> <journal> Neural Computation, </journal> <volume> 1(2) </volume> <pages> 253-262, </pages> <year> 1989. </year> <note> Also MIT AI Memo 1091. </note>
Reference-contexts: Each layer can consist of several individual behaviors and normally embodies a single higher order skill, such as Avoid obstacles, Follow walls, or Exploration. The subsumption architecture has been used to construct complicated mobile robots <ref> [10] </ref> as well as societies of robots [55, 56]. However, the subsumption architecture remains more of a design philosophy than a formal specification. The Behavior 16 Language [11] is the LISP-based parallel programming language used to specify sub--sumption configurations.
Reference: [11] <author> R.A. Brooks. </author> <title> The behavior language: User's guide. AI Memo 1227, </title> <publisher> MIT, </publisher> <year> 1990. </year> <month> 259 </month>
Reference-contexts: Many of the target architectures which will be surveyed in Section 2.2 also include 7 their own programming language. Most of these languages have been created specif-ically for robotic applications <ref> [11, 18] </ref>, while the remainder are generally extended versions of traditional languages [15]. CDL differs from these languages in several ways. First, it is architecture- and robot-independent, which none of the others are. This allows the construction of configurations which transcend individual robot constraints. <p> The subsumption architecture has been used to construct complicated mobile robots [10] as well as societies of robots [55, 56]. However, the subsumption architecture remains more of a design philosophy than a formal specification. The Behavior 16 Language <ref> [11] </ref> is the LISP-based parallel programming language used to specify sub--sumption configurations. Subsumption is rather restrictive in that all coordination occurs via prioritized competition, precluding any cooperative interaction between behaviors.
Reference: [12] <author> Jonathan M. Cameron and Douglas C. MacKenzie. </author> <title> MissionLab User Man--ual. </title> <institution> College of Computing, Georgia Institute of Technology, </institution> <note> Available via http://www.cc.gatech.edu/ai/robot-lab/research/MissionLab/mlab manual.ps.gz, Version 1.0 edition, </note> <month> May </month> <year> 1996. </year>
Reference-contexts: Once the objective has been achieved (in Step 10), the mission is terminated with Step 11: 11. UNIT scouts STOP which instructs the robots the mission is complete and the executables are terminated. Complete definition of the command description file format can be found in the MissionLab manual <ref> [12] </ref>. 5.2 Hardware Binding CfgEdit supports automatic binding of configurations to robots. When the user clicks on the bind button, the system analyzes the configuration, matching output and input binding points to robot capabilities. <p> The solid black circles represent obstacles within the simulated environment. The command interface in the lower right of Figure 5.23 allows the operator to monitor and control execution of the mission. For more detail on the operation of MissionLab, see <ref> [12] </ref>. The overlay files are constructed using standard text editors. Figure 5.24 shows MissionLab with an overlay representing the Georgia Tech Mobile Robot Lab. The robot is shown in its starting location, in the lower left. The overlay file specifying this environment is shown in Figure 5.25. <p> The Gap specifies the door to the lab. Two passage points (PP) (shown as circles in Figure 5.24) were chosen arbitrarily to use as targets for MOVETO commands in missions. Many other types of overlay symbols are available and are described in the MissionLab manual <ref> [12] </ref>. 5.6 AuRA simulator The MissionLab toolset includes a multiagent simulation system which supports robots using the AuRA architecture. The simulator is structured in a client/server arrangement and currently executes in the same process as the operator console. <p> The shaded and solid circles of various sizes represent simulated obstacles within the arena (vegetation and rocks, respectively). The three robots are actively gathering trash and the paths they have taken are shown as trails. For more details on the MissionLab simulation system, see <ref> [12] </ref>. The simulation system currently models only the vehicle kinematics. The vehicle maximum speed and steer angle is also limited in some cases. No attempt to introduce dynamics into the simulator has been undertaken. Currently, Denning MRV-2 robots are modeled as holonomic robots.
Reference: [13] <author> John P. Chin, Virginia A. Diehl, and Kent L. Norman. </author> <title> Development of an instrument measuring user satisfaction of the human-computer interface. </title> <editor> In E. Soloway et al., editors, </editor> <booktitle> Proc. CHI'88, Human Factors in Computing Systems, </booktitle> <pages> pages 213-218. </pages> <publisher> ACM, </publisher> <year> 1988. </year>
Reference: [14] <author> J. Connell. </author> <title> A colony architecture for an artificial creature. </title> <type> AI Tech Report 1151, </type> <institution> MIT, </institution> <year> 1989. </year>
Reference-contexts: It is possible to describe subsumption-style configurations within the language we present, but they would need to be restricted to using only competitive coordination. A variant of the subsumption architecture is the colony architecture <ref> [14] </ref>. This is an important target since it has also been used to drive non-trivial robots. The colony architecture modifies subsumption in several ways: First, it removes the ability of behaviors to overwrite the inputs of other nodes and relies exclusively on inhibition at outputs using suppression nodes. <p> The process of determining this collection of active members (arbitration) can use a variety of techniques including spreading activation, assigning fixed priorities, or using relevancy metrics. Architectures using competition mechanisms include spreading activation nets [54], and the subsumption architecture [9]. The colony architecture <ref> [14] </ref> is a variant of the subsumption architecture which tends to simplify the behavioral networks (Section 2.2.2). As in the subsumption architecture, individual modules are interconnected into a hierarchy using a fixed priority arbitration network. <p> The configuration editor encourages users to follow the behavior-based paradigm using data-flow style computation. Clearly, there are good points and bad points to every architecture and this one will be no exception. This style of structuring robot control software has proven fruitful in many other robot architectures <ref> [9, 3, 14] </ref> and it is expected the configurations created will be of acceptable quality, both in terms of resource requirements and run-time performance. However, there certainly exist some htask; environment; roboti tuples where expert roboticists could improve performance by hand-crafting solutions following differing paradigms.
Reference: [15] <author> E. Coste-Maniere, B. Espiau, and E. Rutten. </author> <title> A task-level robot programming language and its reactive execution. </title> <booktitle> In Proc. IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 2751-2756, </pages> <address> Nice, France, </address> <year> 1992. </year>
Reference-contexts: Many of the target architectures which will be surveyed in Section 2.2 also include 7 their own programming language. Most of these languages have been created specif-ically for robotic applications [11, 18], while the remainder are generally extended versions of traditional languages <ref> [15] </ref>. CDL differs from these languages in several ways. First, it is architecture- and robot-independent, which none of the others are. This allows the construction of configurations which transcend individual robot constraints. Second, it incorporates recursive combination mechanisms to facilitate information hiding and construction of high-level primitives.
Reference: [16] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science. </booktitle> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, The Netherlands, </address> <year> 1989. </year>
Reference: [17] <author> J. Firby. </author> <title> Adaptive execution in complex dynamic worlds. </title> <institution> Computer Science Tech Report YALEU/CSD/RR 672, Yale, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: Based on the point of view of planning as coordination, UM-PRS is not so much a target architecture for this research as it is a possible component to be incorporated. 21 2.2.8 Reactive Action Packages (RAPs) Reactive Action Packages <ref> [17] </ref> (RAPs) are mechanisms to specify reactive programs. Each RAP encapsulates a single action or competency the reactive robot controller is capable of performing, such as Move down hall or Load into truck.
Reference: [18] <author> E. Gat. Alfa: </author> <title> A language for programming reactive robotic control systems. </title> <booktitle> In Proceedings 1991 IEEE International Conference on Robotics and Automation, </booktitle> <volume> volume 2, </volume> <pages> pages 1116-1121, </pages> <address> Sacramento, CA, </address> <year> 1991. </year>
Reference-contexts: Many of the target architectures which will be surveyed in Section 2.2 also include 7 their own programming language. Most of these languages have been created specif-ically for robotic applications <ref> [11, 18] </ref>, while the remainder are generally extended versions of traditional languages [15]. CDL differs from these languages in several ways. First, it is architecture- and robot-independent, which none of the others are. This allows the construction of configurations which transcend individual robot constraints. <p> Petri nets are also useful for describing how coordination procedures are related by providing a common representation for varied coordination algorithms. However, petri nets do not support the recursive construction of components and thus eliminate hierarchical designs. 2.1.9 A Language For Action (ALFA) ALFA <ref> [20, 18, 19] </ref> (A Language For Action), with its roots in the subsumption architecture, is used to describe behavior-based robots using a LISP-like syntax. It uses a data flow architecture consisting of named computational modules connected with a network of named communication channels.
Reference: [19] <author> E. Gat. </author> <title> Robust low-computation sensor-driven control for task-directed navigation. </title> <booktitle> In Proceedings 1991 IEEE International Conference on Robotics and Automation, </booktitle> <volume> volume 2, </volume> <pages> pages 2484-2489, </pages> <address> Sacramento, CA, </address> <year> 1991. </year>
Reference-contexts: Petri nets are also useful for describing how coordination procedures are related by providing a common representation for varied coordination algorithms. However, petri nets do not support the recursive construction of components and thus eliminate hierarchical designs. 2.1.9 A Language For Action (ALFA) ALFA <ref> [20, 18, 19] </ref> (A Language For Action), with its roots in the subsumption architecture, is used to describe behavior-based robots using a LISP-like syntax. It uses a data flow architecture consisting of named computational modules connected with a network of named communication channels.
Reference: [20] <author> E. Gat. </author> <title> Integrating planning and reacting in a heterogeneous asynchronous architecture for controlling real-world mobile robots. </title> <booktitle> In Proceedings AAAI Conference, </booktitle> <address> San Jose, CA, </address> <year> 1992. </year>
Reference-contexts: Petri nets are also useful for describing how coordination procedures are related by providing a common representation for varied coordination algorithms. However, petri nets do not support the recursive construction of components and thus eliminate hierarchical designs. 2.1.9 A Language For Action (ALFA) ALFA <ref> [20, 18, 19] </ref> (A Language For Action), with its roots in the subsumption architecture, is used to describe behavior-based robots using a LISP-like syntax. It uses a data flow architecture consisting of named computational modules connected with a network of named communication channels.
Reference: [21] <author> Michael P. Georgeff and Amy L. Lansky. </author> <title> Reactive reasoning and planning. </title> <booktitle> In Proceedings AAAI Conference, </booktitle> <pages> pages 677-682, </pages> <year> 1987. </year>
Reference: [22] <author> Matthew W. Gertz, Roy A. Maxion, and Pradeep K. Khosla. </author> <title> Visual programming and hypermedia implementation within a distributed laboratory environment. </title> <journal> Intelligent Automation and Soft Computing, </journal> <volume> 1(1) </volume> <pages> 43-62, </pages> <year> 1995. </year> <month> 260 </month>
Reference-contexts: This idea has been extended to allow the recursive specification of robot control programs in the MissionLab toolset. 2.3.2 Onika Probably the graphical programming environment most relevant to this research is the Onika system <ref> [74, 22] </ref> from CMU. Onika is optimized for rapid graphical construction of control programs for robot arms. It is tightly integrated with the Chimera real-time operating system, also from CMU.
Reference: [23] <author> J. J. Gibson. </author> <title> The Senses Considered as Perceptual Systems. </title> <publisher> George Allen and Unwin Ltd., </publisher> <address> London, </address> <year> 1968. </year>
Reference-contexts: Viewing perceptual modules as virtual sen-sors facilitates hardware-independent perception and task-oriented perceptual processing relevant to the current needs of the configuration. This generic view of a perceptual module also supports affordance-based <ref> [24, 23] </ref> implementations. In this case, the features extracted from the environment would each be affordances for the robot, allowing it to generate some response. The theory of affordances contends that perception extracts from the environment not geometric information, but information about what actions the environment affords the observer.
Reference: [24] <author> J. J. Gibson. </author> <title> Notes on affordances. </title> <editor> In E. Reed and R. Jones, editors, </editor> <title> Reasons for Realism: </title> <journal> Selected Essays of James J. </journal> <volume> Gibson, </volume> <pages> pages 401-436. </pages> <publisher> Lawrence Erlbaum Associates, </publisher> <year> 1982. </year>
Reference-contexts: Viewing perceptual modules as virtual sen-sors facilitates hardware-independent perception and task-oriented perceptual processing relevant to the current needs of the configuration. This generic view of a perceptual module also supports affordance-based <ref> [24, 23] </ref> implementations. In this case, the features extracted from the environment would each be affordances for the robot, allowing it to generate some response. The theory of affordances contends that perception extracts from the environment not geometric information, but information about what actions the environment affords the observer.
Reference: [25] <author> B. M. Gothard, R. D. Etersky, and R. E. Ewing. </author> <title> Lessons learned on a low-cost global navigation system for the surrogate semi-autonomous vehicle. </title> <booktitle> In Proceedings SPIE Conference on Mobile Robots VIII, </booktitle> <pages> pages 258-269, </pages> <address> Boston, MA., </address> <year> 1993. </year>
Reference: [26] <author> J. Gowdy. </author> <title> SAUSAGES Users Manual. </title> <journal> Robotics Institute, </journal> <note> Carnegie Mellon, version 1.0 edition, </note> <month> February 8 </month> <year> 1991. </year> <title> SAUSAGES: A Framework for Plan Specification, Execution, and Monitoring. </title>
Reference: [27] <author> J. Gowdy. SAUSAGES: </author> <title> Between planning and action. </title> <type> Technical Report Draft, </type> <institution> Robotics Institute, Carnegie Mellon, </institution> <year> 1994. </year>
Reference: [28] <author> Zvi Har'El and Robert P. Kurshan. </author> <title> Software for analytical development of communications protocols. </title> <journal> AT&T Technical Journal, </journal> <volume> 69(1), </volume> <month> January/February </month> <year> 1990. </year>
Reference-contexts: These state machines can then be exported to a format used by COSPAN for analysis. COSPAN <ref> [28] </ref> is a specification language and verification system for state-based control systems. The specification language is called S/R and the analysis tool is called COSPAN. The analysis of an FSA in COSPAN determines if the language accepted by the FSA includes the language that the user proposes for test.
Reference: [29] <author> Thomas C. Henderson. </author> <title> Logical behaviors. </title> <journal> Journal of Robotic Systems, </journal> <volume> 7(3) </volume> <pages> 309-336, </pages> <year> 1990. </year>
Reference-contexts: The same input binding point can be represented using functional notation as the function f S ( ) which generates the sensation s i at time t. Equation 3.3 presents this functional notation. s i = f S (t) (3.3) 3.2.2 Perceptual Modules Perceptual modules function as virtual sensors <ref> [30, 29] </ref> which extract semantically meaningful features from one or more sensation streams and generate as output a 38 stream of features (individual percepts). Viewing perceptual modules as virtual sen-sors facilitates hardware-independent perception and task-oriented perceptual processing relevant to the current needs of the configuration.
Reference: [30] <author> Thomas C. Henderson and Esther Shilcrat. </author> <title> Logical sensor systems. </title> <journal> Journal of Robotic Systems, </journal> <volume> 1(2) </volume> <pages> 169-193, </pages> <year> 1984. </year>
Reference-contexts: The same input binding point can be represented using functional notation as the function f S ( ) which generates the sensation s i at time t. Equation 3.3 presents this functional notation. s i = f S (t) (3.3) 3.2.2 Perceptual Modules Perceptual modules function as virtual sensors <ref> [30, 29] </ref> which extract semantically meaningful features from one or more sensation streams and generate as output a 38 stream of features (individual percepts). Viewing perceptual modules as virtual sen-sors facilitates hardware-independent perception and task-oriented perceptual processing relevant to the current needs of the configuration.
Reference: [31] <author> Deborah Hix and H. Rex Hartson. </author> <title> Developing User Interfaces. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: Therefore, it is very important to list the performance metrics which will impact acceptance of the product, and to state minimum levels for them, below which the product will not be accepted. Table 6.1 is an example technique for presenting the usability metrics from <ref> [31] </ref>. Table 6.1: An example usability criteria specification table for some indeterminate task (After [31], page 223). Notice that Usability Attributes are vague high-level concepts while the Values to be Measured are concrete performance metrics. The Current Level shows the average user performance on existing systems. <p> Table 6.1 is an example technique for presenting the usability metrics from <ref> [31] </ref>. Table 6.1: An example usability criteria specification table for some indeterminate task (After [31], page 223). Notice that Usability Attributes are vague high-level concepts while the Values to be Measured are concrete performance metrics. The Current Level shows the average user performance on existing systems.
Reference: [32] <author> Charles Antony Richard Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12 </volume> <pages> 576-581, </pages> <year> 1969. </year>
Reference-contexts: A collection of semantic domains are specified and a corresponding set of semantic equations map programs onto these domains, thereby describing their meaning. The final method used to describe the semantic meaning of programming languages is the axiomatic approach. The axiomatic method is attributed to Hoare <ref> [32] </ref> and has been used to define the semantics of PASCAL [33]. This style uses a collection of axioms which are true of any correct program and serve to define the meaning of the program.
Reference: [33] <author> Charles Antony Richard Hoare and N. Wirth. </author> <title> An axiomatic definition of the programming language PASCAL. </title> <journal> Acta Informatica, </journal> <volume> 2 </volume> <pages> 335-355, </pages> <year> 1973. </year>
Reference-contexts: The final method used to describe the semantic meaning of programming languages is the axiomatic approach. The axiomatic method is attributed to Hoare [32] and has been used to define the semantics of PASCAL <ref> [33] </ref>. This style uses a collection of axioms which are true of any correct program and serve to define the meaning of the program.
Reference: [34] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation, page 79. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The FSA ff is specified by the quadruple <ref> [34] </ref> (Q; ffi; q 0 ; F ) with 45 * Q the set of states, fq 0 ; q 1 ; : : : ; q m g where each q i is mapped to a i . * ffi the transition function mapping the current state (q i )
Reference: [35] <author> Marcus J. Huber, Jaeho Lee, Patrick Kenny, and Edmund H. Durfee. </author> <title> UM-PRS V1.0 Programmer and User Guide. </title> <institution> Artificial Intelligence Laboratory, The University of Michigan, </institution> <month> 28 October </month> <year> 1993. </year> <month> 261 </month>
Reference-contexts: The control program adds plans to STM relevant to the active goals with respect to the current environmental feedback and executes the plans in STM. The UM-PRS system <ref> [44, 35] </ref> is a newer implementation of PRS generated at the University of Michigan for use as a robot mission planning system. It was recoded in C++ to increase speed and to support deployment on mobile robots.
Reference: [36] <author> L. P. Kaelbling. </author> <title> An architecture for intelligent reactive systems. </title> <type> Technical Note 400, </type> <institution> SRI International, </institution> <month> October </month> <year> 1986. </year>
Reference-contexts: Finally, it relies on explicit hardware binding to prevent hardware issues from diffusing into the behavioral design. We now examine several of the related specification languages to more closely position them against CDL. 2.1.1 REX/Gapps The REX/Gapps architecture <ref> [36] </ref> partitions perception from action and utilizes horizontal decompositions, allowing complicated perceptual processes to be shared by multiple motor modules. REX [37] is a LISP-based language for describing situated automata. Off-line, the REX program is compiled into a synchronous digital circuit which can be executed to implement the specified system.
Reference: [37] <author> L. P. Kaelbling. </author> <title> Rex programmer's manual. </title> <type> Technical Note 381, </type> <institution> SRI International, </institution> <year> 1986. </year>
Reference-contexts: We now examine several of the related specification languages to more closely position them against CDL. 2.1.1 REX/Gapps The REX/Gapps architecture [36] partitions perception from action and utilizes horizontal decompositions, allowing complicated perceptual processes to be shared by multiple motor modules. REX <ref> [37] </ref> is a LISP-based language for describing situated automata. Off-line, the REX program is compiled into a synchronous digital circuit which can be executed to implement the specified system. Gapps [38, 39] is a declarative language used to specify the goal-oriented planning component of a mobile robot.
Reference: [38] <author> L. P. Kaelbling. </author> <title> Goals as parallel program specifications. </title> <booktitle> In Proceedings AAAI Conference, </booktitle> <volume> volume 1, </volume> <pages> pages 60-65, </pages> <address> St. Paul, MN, </address> <year> 1988. </year>
Reference-contexts: REX [37] is a LISP-based language for describing situated automata. Off-line, the REX program is compiled into a synchronous digital circuit which can be executed to implement the specified system. Gapps <ref> [38, 39] </ref> is a declarative language used to specify the goal-oriented planning component of a mobile robot. The output from the Gapps compiler is a REX program which is then compiled into a circuit for execution.
Reference: [39] <author> L. P. Kaelbling and S. J. Rosenschein. </author> <title> Action and planning in embedded agents. </title> <booktitle> Robotics and Autonomous Systems, </booktitle> <volume> 6 </volume> <pages> 35-48, </pages> <year> 1990. </year> <title> Also in Designing Autonomous Agents: Theory and Practice from Biology to Engineering and Back, </title> <editor> P. Maes Editor, </editor> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: REX [37] is a LISP-based language for describing situated automata. Off-line, the REX program is compiled into a synchronous digital circuit which can be executed to implement the specified system. Gapps <ref> [38, 39] </ref> is a declarative language used to specify the goal-oriented planning component of a mobile robot. The output from the Gapps compiler is a REX program which is then compiled into a circuit for execution.
Reference: [40] <author> P. Kahn. </author> <title> Specification & control of behavioral robot programs. </title> <booktitle> In Proceedings SPIE Conference on Sensor Fusion IV, </booktitle> <address> Boston, MA., </address> <month> November </month> <year> 1991. </year>
Reference-contexts: The APE architecture is a deliberative dynamic-world planner and does not lend itself to targeting from CDL. However, it might be possible to integrate supervenience in some form with CDL as a deliberative planner-based coordination mechanism. 2.2.10 Behavioral Architecture for Robot Tasks (BART) BART <ref> [40] </ref> (Behavioral Architecture for Robot Tasks) is an architecture and programming language for specifying and controlling behavior-based mobile robots. BART was designed to allow large, rapid changes in active behaviors.
Reference: [41] <author> D. E. Knuth. </author> <title> Semantics of context-free languages. </title> <journal> Mathematical Systems Theory, </journal> <volume> 2 </volume> <pages> 127-145, </pages> <year> 1968. </year>
Reference-contexts: However, it appeared that it would be quite complex to specify various aspects of CDL using a two-level grammar (e.g., scoping rules). Therefore, the choice was made to utilize an attribute grammar. Attribute grammars were first defined by Knuth in <ref> [41] </ref> and subsequently used in a post priori formal definition of the context-sensitive features of Pascal [80]. The syntax of CDL is defined using such an attribute grammar following the style promoted in [59].
Reference: [42] <author> J. Kosecka and R. </author> <title> Bajcsy. Cooperative behaviors discrete event systems based approach. Unknown source, </title> <year> 1993. </year>
Reference-contexts: This is a vastly more constrained domain than a mobile robot ranging over an unstructured environment. It seems impractical to extend this work to general unstructured environments because of the resulting representational explosion. A small team architecture for multiagent robotic systems <ref> [42] </ref> has been developed using DES theory. Behaviors are specified as FSA's by enumeration of their operating states and the set of events causing transitions from one state to the next.
Reference: [43] <author> B. Lee and A.R. Hurson. </author> <title> Dataflow architectures and multithreading. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 27-39, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Both will now be described. 5.3.2 The Configuration Network Language (CNL) When a configuration is bound to the AuRA architecture, the CDL compiler generates a Configuration Network Language (CNL)[51] specification of the configuration as its output. CNL is a hybrid data-flow language <ref> [43] </ref> using large grain parallelism, where the atomic units are arbitrary C++ functions. CNL adds data-flow extensions to C++ which eliminate the need for explicit communication code. A compiled extension to C++ was chosen to allow verification and meaningful error messages to assist casual C++ programmers in constructing behaviors.
Reference: [44] <author> Jaeho Lee, Marcus J. Huber, Edmund H. Durfee, and Patrick G. Kenny. UM-PRS: </author> <title> An implementation of the procedure reasoning system for multirobot applications. </title> <booktitle> In Proceedings AIAA/NASA Conference on Intelligent Robots in Field, Factory, Service, and Space (CIRFFSS '94), </booktitle> <year> 1994. </year>
Reference-contexts: The control program adds plans to STM relevant to the active goals with respect to the current environmental feedback and executes the plans in STM. The UM-PRS system <ref> [44, 35] </ref> is a newer implementation of PRS generated at the University of Michigan for use as a robot mission planning system. It was recoded in C++ to increase speed and to support deployment on mobile robots.
Reference: [45] <author> D. R. Lefebvre and G. N. Saridis. </author> <title> A computer architecture for intelligent machines. </title> <booktitle> In Proceedings 1992 IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 2745-2750, </pages> <address> Nice, France, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: The petri net functions by moving tokens from one place to another in response to input events. A three layer hierarchical architecture has been developed which uses petri nets as the middle layer <ref> [45, 77] </ref>. This "coordination" layer receives sequences of tasks to be executed from the higher layer and is responsible for coordinating the execution of the tasks by the bottom layer. <p> Figure 2.2 shows a graphical representation of a petri 13 net used to coordinate the execution of a vision algorithm to locate a particular spot in an image. (After <ref> [45] </ref>, Figure 5). The petri net is able to capture the unsynchronized movement of data in complex control structures. This ability to represent data movements between finite state automata is useful for describing coordination procedures.
Reference: [46] <author> Douglas B. Lenat and R.V. Guha. </author> <title> Building Large Knowlege-Based Systems. </title> <publisher> Addison-Wesley, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: A simulation environment was created which reads these descriptions and simulates the pursuit problem to determine a winner. This allows changing agent capabilities and then checking the impact of the modifications. The example system is a frame-based construction built on top of the Cyc <ref> [46] </ref> database.
Reference: [47] <author> Willie Lim. </author> <title> Sal a language for developing an agent-based architecture for mobile robots. </title> <booktitle> In Proceedings SPIE Conference on Mobile Robots VII, </booktitle> <pages> pages 285-296, </pages> <address> Boston, MA., </address> <year> 1992. </year>
Reference-contexts: There is no attempt to maintain a generic description of the mission and retargeting different hardware will require significant effort. 2.1.4 The SmartyCat Agent Language The SmartyCat Agent Language (SAL) developed at Grumman <ref> [47] </ref> is based on the Common LISP Object System [7]. SAL is similar to CDL in drawing heavily from the Robot Schemas (RS) architecture [50] and the Society of Mind theory [58]. In SAL a configuration is a data-flow graph of port automata nodes connected with communication links. <p> In SAL a configuration is a data-flow graph of port automata nodes connected with communication links. The Agencies construction provides support for hierarchical specification of complex objects. A graphical user interface for constructing the data-flow graphs is mentioned in <ref> [47] </ref>, although no description of its functionality was located. 10 SAL co-mingles the configuration with the specification of the primitives and buries hardware bindings within the implementations of individual primitives. Coordination is distributed within the primitives, making it difficult to understand and modify policies.
Reference: [48] <author> Michelle A. Lund. </author> <title> Evaluating the user interface: The candid camera approach. </title> <editor> In L. Borman et al., editors, </editor> <booktitle> Proc. CHI'85, Human Factors in Computing Systems, </booktitle> <pages> pages 107-113. </pages> <publisher> ACM, </publisher> <year> 1985. </year> <month> 262 </month>
Reference-contexts: This is not an easy task and requires careful planning and execution to prevent bias and noise from swamping the underlying data. Objective methods for data gathering generally involve test subjects using the system under controlled conditions <ref> [48] </ref>. Commonly, the software is instrumented to gather keystroke and timing information that will allow determining how the user performed certain tasks. The experiments are best if administered by a third party observer to remove bias and to keep the developers from interjecting knowledge not commonly available.
Reference: [49] <author> Damian M. Lyons. </author> <title> Representing and analyzing action plans as networks of con-current processes. </title> <journal> IEEE Transactions on Robotics and Automation, </journal> <volume> 9(3) </volume> <pages> 241-256, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: DES simplifies some problems with analyzing robot controllers by making the robot/world interactions discrete. Several researchers have begun using DES techniques to analyze situated behavior-based robot controllers. RS-L3 <ref> [49] </ref> is a subset of RS which has been implemented as a robot programming language. Experiments using RS-L3 have been conducted to control an intelligent robotic workcell which groups sub-assemblies into kits for traditional robots to assemble.
Reference: [50] <author> Damian M. Lyons and M. A. Arbib. </author> <title> A formal model of computation for sensory-based robotics. </title> <journal> IEEE Journal of Robotics and Automation, </journal> <volume> 5(3) </volume> <pages> 280-293, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: The have perceptual predicate tests if the robot is holding the object. because it requires a detailed environmental model, which is unreasonable to expect to exist for all but the most trivial cases. 2.1.2 RS The Robot Schemas (RS) architecture <ref> [50] </ref> is based on the port automata model of computation using synchronous communication. Primitive sensorimotor behaviors are called basic schemas, schemas without input ports represent sensors, and actuators are modeled as schemas without output ports. A group of basic schemas can be interconnected using communication links to form an assemblage. <p> A group of basic schemas can be interconnected using communication links to form an assemblage. An assemblage is a network of schemas which can be treated as a single schema in subsequent constructions. The assemblage mechanism facilitates information hiding, modularity, and incremental development. An example RS statement <ref> [50] </ref> is shown below. Jmove i;x ()(x) = [Jpos i ()(x); Jset i;x (x)(u); Jmot i (u)()] C;E : The example describes a simple position servo using the sensor Jpos, the computation schema Jset, and the actuator Jmot. <p> SAL is similar to CDL in drawing heavily from the Robot Schemas (RS) architecture <ref> [50] </ref> and the Society of Mind theory [58]. In SAL a configuration is a data-flow graph of port automata nodes connected with communication links. The Agencies construction provides support for hierarchical specification of complex objects.
Reference: [51] <author> Douglas C. MacKenzie. </author> <title> Configuration Network Language (CNL) User Manual. </title> <institution> College of Computing, Georgia Institute of Technology, </institution> <note> Available via http://www.cc.gatech.edu/ai/robot-lab/research/MissionLab/cnl manual.ps.gz, Version 1.5 edition, </note> <month> June </month> <year> 1996. </year>
Reference: [52] <author> Douglas C. MacKenzie and Ronald C. Arkin. </author> <title> Formal specification for behavior-based mobile robots. </title> <booktitle> In Proceedings SPIE Conference on Mobile Robots VIII, </booktitle> <pages> pages 94-104, </pages> <address> Boston, MA., </address> <year> 1993. </year>
Reference-contexts: The whole purpose of the coordination operator is to make it unimportant! Assemblages encapsulate a particular skill or ability which is a higher level construction than a behavior <ref> [52] </ref>. A simple skill such as Wander will include several behaviors: Noise to generate random motion, Avoid obstacles to keep the robot from bumping into things, and perhaps Follow wall to encourage exploration of the perimeter.
Reference: [53] <author> P. Maes. </author> <title> The dynamics of action selection. </title> <booktitle> In Proceedings Eleventh International Joint Conference on Artificial Intelligence, IJCAII-89, </booktitle> <volume> volume 2, </volume> <pages> pages 991-997, </pages> <year> 1989. </year>
Reference-contexts: The colony architecture also relies exclusively on priority-based competitive coordination and could similarly be targeted as a supported run-time architecture. 2.2.3 Maes' action-selection architecture Maes' use of action-selection mechanisms for behavior coordination <ref> [54, 53] </ref> employs a spreading activation mechanism to reactively control situated agents. Individual behaviors are termed competence modules after Minsky's Society of Mind theory [58] and represent simple computational agents, encapsulating a particular expertise.
Reference: [54] <author> P. Maes. </author> <title> Situated agents can have goals. </title> <booktitle> Robotics and Autonomous Systems, </booktitle> <volume> 6 </volume> <pages> 49-70, </pages> <year> 1990. </year> <title> Also in Designing Autonomous Agents: Theory and Practice from Biology to Engineering and Back, </title> <editor> P. Maes Editor, </editor> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The colony architecture also relies exclusively on priority-based competitive coordination and could similarly be targeted as a supported run-time architecture. 2.2.3 Maes' action-selection architecture Maes' use of action-selection mechanisms for behavior coordination <ref> [54, 53] </ref> employs a spreading activation mechanism to reactively control situated agents. Individual behaviors are termed competence modules after Minsky's Society of Mind theory [58] and represent simple computational agents, encapsulating a particular expertise. <p> A large problem with this architecture is how appropriate activation and inhibition links are created between agents. It is proposed in <ref> [54] </ref> that a second network be used to configure the primary one, functioning as a meta-level planner. However, this merely raises the problem up one level, leaving the issue of how the meta-layer is constructed. Spreading activation implements a distributed competitive coordination mechanism. <p> The process of determining this collection of active members (arbitration) can use a variety of techniques including spreading activation, assigning fixed priorities, or using relevancy metrics. Architectures using competition mechanisms include spreading activation nets <ref> [54] </ref>, and the subsumption architecture [9]. The colony architecture [14] is a variant of the subsumption architecture which tends to simplify the behavioral networks (Section 2.2.2). As in the subsumption architecture, individual modules are interconnected into a hierarchy using a fixed priority arbitration network.
Reference: [55] <author> M. J. Mataric. </author> <title> Designing emergent behaviors: From local interactions to collective intelligence. </title> <booktitle> In Proceedings From Animals to Animats, Second International Conference on Simulation of Adaptive Behavior (SAB92). </booktitle> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Each layer can consist of several individual behaviors and normally embodies a single higher order skill, such as Avoid obstacles, Follow walls, or Exploration. The subsumption architecture has been used to construct complicated mobile robots [10] as well as societies of robots <ref> [55, 56] </ref>. However, the subsumption architecture remains more of a design philosophy than a formal specification. The Behavior 16 Language [11] is the LISP-based parallel programming language used to specify sub--sumption configurations. Subsumption is rather restrictive in that all coordination occurs via prioritized competition, precluding any cooperative interaction between behaviors.
Reference: [56] <author> M.J. Mataric. </author> <title> Minimizing complexity in controlling a mobile robot population. </title> <booktitle> In Proceedings 1992 IEEE International Conference on Robotics and Automation, </booktitle> <address> Nice, France, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: Each layer can consist of several individual behaviors and normally embodies a single higher order skill, such as Avoid obstacles, Follow walls, or Exploration. The subsumption architecture has been used to construct complicated mobile robots [10] as well as societies of robots <ref> [55, 56] </ref>. However, the subsumption architecture remains more of a design philosophy than a formal specification. The Behavior 16 Language [11] is the LISP-based parallel programming language used to specify sub--sumption configurations. Subsumption is rather restrictive in that all coordination occurs via prioritized competition, precluding any cooperative interaction between behaviors.
Reference: [57] <author> David J. Miller and R. Charleene Lennox. </author> <title> An object-oriented environment for robot system architectures. </title> <booktitle> In Proc. IEEE International Conference on Robotics and Automation, </booktitle> <volume> volume 1, </volume> <pages> pages 352-361, </pages> <address> Cincinnati, OH, </address> <year> 1990. </year>
Reference-contexts: RS does not provide mechanisms for expressing coordination between multiple robots cooperating on a task. This research expands on the concept of recursive composition of sensorimotor behaviors apparent here in the assemblage construct. 2.1.3 The Robot Independent Programming Language The Robot Independent Programming Environment (RIPE) project at Sandia Labs <ref> [57] </ref> uses C++ classes to implement primitive operators. These classes are the task-level primitives which constitute the Robot Independent Programming Language (RIPL). To use RIPL, the designer writes a C++ program using those classes which are relevant to the project.
Reference: [58] <author> M. Minsky. </author> <title> The Society of Mind. </title> <publisher> Simon and Schuster, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: SAL is similar to CDL in drawing heavily from the Robot Schemas (RS) architecture [50] and the Society of Mind theory <ref> [58] </ref>. In SAL a configuration is a data-flow graph of port automata nodes connected with communication links. The Agencies construction provides support for hierarchical specification of complex objects. <p> Individual behaviors are termed competence modules after Minsky's Society of Mind theory <ref> [58] </ref> and represent simple computational agents, encapsulating a particular expertise. Since multiple modules are likely executable at each instant, they must compete for control of the system. The coin of the realm is a module's level of activation, and the module with the highest activation gains control.
Reference: [59] <author> Frank G. Pagan. </author> <title> Formal Specification of Programming Languages: A Panoramic Primer. </title> <publisher> Prentice-Hall, </publisher> <address> New Jersey, </address> <year> 1981. </year>
Reference-contexts: Attribute grammars were first defined by Knuth in [41] and subsequently used in a post priori formal definition of the context-sensitive features of Pascal [80]. The syntax of CDL is defined using such an attribute grammar following the style promoted in <ref> [59] </ref>. Standard Backus-Naur Form (BNF) notation is used to establish the underlying context-free portions of the grammar but, in this style of grammar these productions are augmented with attributes, evaluation rules, and conditions to capture the context-sensitive portions of the language. <p> These restrictions capture requirements within the grammar itself such as type matching in assignments and the need to define objects before referencing them. The actual pruning of the acceptance set occurs through use of the Assert conditional operator (Cond in <ref> [59] </ref>). <p> The Axiomatic technique was chosen for use in defining the semantics of CDL based on its ability to specify the semantic meaning without constraining the implementation. The style suggested in <ref> [59] </ref> has been followed as closely as possible in the following presentation.
Reference: [60] <author> Lynne E. Parker. </author> <title> Adaptive action selection for cooperative agent teams. </title> <booktitle> In Proceedings of 2nd International conference on Simulation of Adaptive Behavior, number 92 in SAB, </booktitle> <address> Honolulu, HA, </address> <year> 1992. </year> <month> 263 </month>
Reference-contexts: to support spreading activation coordination in a generic sense, but it is unclear how one would generate compatible configurations using other styles of coordination. 2.2.4 ALLIANCE: The Cooperative Robot Architecture The subsumption architecture has been used as the basis of the ALLIANCE architecture for controlling a society of heterogeneous robots <ref> [63, 60, 61, 62] </ref>. Individual agents are guided by subsumption-based control programs using both sensor readings and information received via communication with other robots.
Reference: [61] <author> Lynne E. Parker. </author> <title> Local versus global control laws for cooperative agent teams. </title> <type> Technical Report AI Memo No. 1357, </type> <institution> MIT, </institution> <year> 1992. </year>
Reference-contexts: to support spreading activation coordination in a generic sense, but it is unclear how one would generate compatible configurations using other styles of coordination. 2.2.4 ALLIANCE: The Cooperative Robot Architecture The subsumption architecture has been used as the basis of the ALLIANCE architecture for controlling a society of heterogeneous robots <ref> [63, 60, 61, 62] </ref>. Individual agents are guided by subsumption-based control programs using both sensor readings and information received via communication with other robots.
Reference: [62] <author> Lynne E. Parker. </author> <title> A performance-based architecture for heterogeneous, situated agent cooperation. </title> <booktitle> In AAAI-1992 Workshop on Cooperation Among Heterogeneous Intelligent Systems, </booktitle> <address> San Jose, CA, </address> <year> 1992. </year>
Reference-contexts: to support spreading activation coordination in a generic sense, but it is unclear how one would generate compatible configurations using other styles of coordination. 2.2.4 ALLIANCE: The Cooperative Robot Architecture The subsumption architecture has been used as the basis of the ALLIANCE architecture for controlling a society of heterogeneous robots <ref> [63, 60, 61, 62] </ref>. Individual agents are guided by subsumption-based control programs using both sensor readings and information received via communication with other robots.
Reference: [63] <author> Lynne E. Parker. </author> <title> Heterogeneous Multi-Robot Cooperation. </title> <type> Ph.D. dissertation, </type> <institution> MIT, Department of Electrical Engineering and Computer Science, </institution> <year> 1994. </year>
Reference-contexts: to support spreading activation coordination in a generic sense, but it is unclear how one would generate compatible configurations using other styles of coordination. 2.2.4 ALLIANCE: The Cooperative Robot Architecture The subsumption architecture has been used as the basis of the ALLIANCE architecture for controlling a society of heterogeneous robots <ref> [63, 60, 61, 62] </ref>. Individual agents are guided by subsumption-based control programs using both sensor readings and information received via communication with other robots.
Reference: [64] <author> P.J. Ramadge and W.M. Wonham. </author> <title> Supervisory control of a class of discrete event processes. </title> <journal> SIAM J. Control Optimization, </journal> <volume> 25(1) </volume> <pages> 206-230, </pages> <year> 1987. </year>
Reference: [65] <author> P.J. Ramadge and W.M. Wonham. </author> <title> The control of discrete event systems. </title> <booktitle> Proceedings of the IEEE, </booktitle> <address> 77-1(1):81-97, </address> <month> January </month> <year> 1989. </year>
Reference: [66] <author> J.K. Rosenblatt and D.W. Payton. </author> <title> A fine-grained alternative to the subsump-tion architecture for mobile robot control. </title> <booktitle> In IEEE INNS International Joint Conference on Neural Networks, </booktitle> <volume> volume 2, </volume> <pages> pages 317-323, </pages> <year> 1989. </year>
Reference-contexts: DAMN uses a fuzzy logic approach to cooperative coordination. Each behavior has a certain number of votes available and is able to allocate them to the available actions. The action with the most votes is undertaken. DAMN grew out of the Fine Grained Alternative to the Subsumption Architecture <ref> [66] </ref>. Limitations of the subsumption architecture are that it excludes cooperative coordination mechanisms and internalizes state. Since all coordination occurs via priority-based inhibition nodes, it is not possible for two behaviors to simultaneously contribute to the actions of the robot. <p> Also, the new level may require access to internal state information within lower level nodes to monitor its applicability. This can require rewriting the lower levels to make the required state information externally available. The fine-grained alternative <ref> [66] </ref> to the subsumption architecture addresses these problems by converting behaviors into a collection of simple transfer functions which are not allowed to contain state information. This transforms a subsumption architecture into a connectionist architecture, where a new layer is added as a cluster of nodes.
Reference: [67] <author> S.J. </author> <title> Rosenschein and L.P. Kaelbling. The synthesis of digital machines with provable epistemic properties. </title> <type> Technical Note 412, </type> <institution> SRI International, </institution> <address> Menlo Park, California, </address> <month> April </month> <year> 1987. </year>
Reference-contexts: The output from the Gapps compiler is a REX program which is then compiled into a circuit for execution. The circuit model allows semantic analysis to be performed to formally prove run-time properties <ref> [67] </ref>. By viewing the digital elements embedded within the circuit as implementations of logical predicates, it is possible to analyze the epistemic properties of the network (i.e., the knowledge embedded within the REX program).
Reference: [68] <author> A. Saffiotti, Kurt Konolige, and E Ruspini. </author> <title> A multivalued logic approach to integrating planning and control. </title> <type> Technical Report 533, </type> <institution> SRI Artificial Intelligence Center, </institution> <address> Menlo Park, California, </address> <year> 1993. </year>
Reference-contexts: However, the representational language PLTL provides formalisms which may prove useful in future efforts. 2.1.7 Multivalued Logic Integration of Planning and Control The use of multivalued logic provides a mechanism capable of supporting formal analysis of the process of combining behaviors. Techniques are presented <ref> [68] </ref> for for mally describing what happens when behaviors are combined in various fashions.
Reference: [69] <author> Robert Sandy. </author> <title> Statistics for Business and Economics. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: The horizontal axis denotes the event duration in seconds with a resolution of 1=2 second. The vertical axis denotes the number of "Add Step" events occurring in Experiment 1 with that duration. Notice the well-defined peak at 1 second duration. The data has a Mode <ref> [69] </ref> (the most common value) of 1 second and appears to have a nearly normal distribution. Based on this graph, the duration of the add mission steps action for experienced users will likely be near 1 second.
Reference: [70] <author> Stanley A. Schneider, Vincent W. Chen, and Gerardo Pardo-Castellote. </author> <title> The ControlShell component-based real-time programming system. </title> <booktitle> In Proc. IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 2381-2388, </pages> <year> 1995. </year>
Reference-contexts: The presentation style is reminiscent of electronic schematic diagrams. Onika modules are allowed multiple output connections while CDL uses a functional notation where each module has only a single output. 2.3.3 ControlShell ControlShell <ref> [70] </ref> is a commercial graphical programming toolset from Real-Time Innovations which is used to construct complex real-time systems. It is similar to the Engineering level of Onika (e.g., Figure 2.5) and presents the same electronic schematic-like look and feel.
Reference: [71] <author> K. Schwan et al. </author> <title> A C thread library for multiprocessors. </title> <type> ICS Tech Report GIT-ICS-91/02, </type> <institution> Georgia Institute of Technology, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: The predefined output parameter for the procedure is named output. threads of execution and edges indicate data-flow connections between producer nodes and consumer nodes. Each node in the configuration is an instantiation of a C++ function, forked as a lightweight thread using the C-Threads package <ref> [71] </ref> developed at Georgia Tech. UNIX processes are examples of heavyweight threads which use the operating system for scheduling. Lightweight threads are generally non-preemptive and scheduled by code linked into the user's program. All lightweight threads execute in the same address space and can share global variables.
Reference: [72] <author> M.P. Singh, M.N. Huhns, and L.M. Stephens. </author> <title> Declarative representations of multiagent systems. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(5) </volume> <pages> 721-739, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Thus, DES theory provides analysis tools for complex systems. 11 2.1.6 Prepositional Linear Temporal Logic A declarative representation for cooperating robots <ref> [72] </ref> has been developed in the distributed AI community. The authors concentrate on the pursuit problem where multiple cooperating blue agents attempt to surround and thus capture the red agent. The exercise takes place on a finite playing field delineated with a square grid.
Reference: [73] <author> L. Spector. </author> <title> Supervenience in Dynamic-World Planning. </title> <type> Ph.D. dissertation, </type> <institution> University of Maryland, Department of Computer Science, </institution> <year> 1992. </year> <note> Also Tech Report CS-TR-2899 or UMIACS-TR-92-55. 264 </note>
Reference-contexts: Each RAP coordinates itself until failure or success when the planner regains control. Further study is necessary to determine what class of configurations could be deployed on this architecture from within CDL. 2.2.9 Supervenience Supervenience <ref> [73] </ref> is a theory of abstraction defining a hierarchy where higher levels are more abstract with respect to their "distance from the world". Lower levels represent the world in greater detail and perhaps more correctly while higher levels represent the world more abstractly, possibly allowing erroneous beliefs to exist.
Reference: [74] <author> David B. Stewart and P.K. Khosla. </author> <title> Rapid development of robotic applications using component-based real-time software. </title> <booktitle> In Proc. Intelligent Robotics and Systems (IROS 95), </booktitle> <volume> volume 1, </volume> <pages> pages 465-470. </pages> <publisher> IEEE/RSJ, IEEE Press, </publisher> <year> 1995. </year>
Reference-contexts: This idea has been extended to allow the recursive specification of robot control programs in the MissionLab toolset. 2.3.2 Onika Probably the graphical programming environment most relevant to this research is the Onika system <ref> [74, 22] </ref> from CMU. Onika is optimized for rapid graphical construction of control programs for robot arms. It is tightly integrated with the Chimera real-time operating system, also from CMU.
Reference: [75] <author> N. Tinbergen. </author> <title> The Study of Instinct. </title> <publisher> Oxford University Press, </publisher> <address> London, </address> <note> second edition, </note> <year> 1969. </year>
Reference-contexts: All of this serves to abstract the group of soldiers into a "squad", a high-level agent which is as cohesive and concrete as an individual soldier. As a second example of complex agents consider the well-documented sexual behavior of the three-spined stickleback <ref> [75] </ref> shown in Figure 3.1. As the schematic shows, the sexual behavior involves a complex temporal chain of behaviors which transcends the individual male and female fish.
Reference: [76] <institution> University of New Mexico. </institution> <month> Khoros: </month> <title> Visual Programming System and Software Development Environment for Data Processing and Visualization. </title>
Reference-contexts: There are several other visual programming tools of note available and a survey here will attempt to highlight the similarities and differences between the MissionLab configuration editor and these systems. 2.3.1 Khoros The inspiration for the graphical construction of configurations in MissionLab was the Khoros <ref> [76] </ref> image processing workbench. Khoros is a powerful system for graphically constructing and running image processing tasks from a collection of primitive operators. The user selects items from a library of procedures and places them on the work area as icons (called glyphs).
Reference: [77] <author> F.Y. Wang, K.J. Kyriakopoulos, A. Tsolkas, and G.N. Saridis. </author> <title> A petri-net coordination model for an intelligent mobile robot. </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, </journal> <volume> 21(4) </volume> <pages> 777-789, </pages> <month> July/August </month> <year> 1991. </year>
Reference-contexts: The petri net functions by moving tokens from one place to another in response to input events. A three layer hierarchical architecture has been developed which uses petri nets as the middle layer <ref> [45, 77] </ref>. This "coordination" layer receives sequences of tasks to be executed from the higher layer and is responsible for coordinating the execution of the tasks by the bottom layer.
Reference: [78] <author> Allen C. Ward. </author> <title> A Theory of Quantitative Inference for Artifact Sets Applied to a Mechanical Design Compiler. </title> <type> Ph.D. dissertation, </type> <institution> MIT, Department of Mechanical Engineering, </institution> <year> 1989. </year> <type> Also Tech Report AI Tech Report 1089. </type>
Reference-contexts: Overall, GI Joe and COSPAN provide support for FSA's but little else. The MissionLab toolset goes far beyond these capabilities in providing users with an integrated development environment. 30 2.3.5 Mechanical design compiler A mechanical design compiler has been created <ref> [79, 78] </ref> which, given schematic specifications and a utility function, will generate a design for a mechanical system meeting those goals. The output is in the form of catalog numbers for the selected components which combine to create a design optimal with respect to the utility function. <p> The output is in the form of catalog numbers for the selected components which combine to create a design optimal with respect to the utility function. Tested domains include mechanical and hydraulic power transmission units. An example <ref> [78] </ref> will show the application of the compiler. The user would interactively create the schematic for a hydraulic power train, shown in Figure 2.10, using a graphical interface.
Reference: [79] <author> Allen C. Ward and Warren P. Seering. </author> <title> The performance of a mechanical design compiler. </title> <type> AI Tech Report 1084, </type> <institution> MIT, </institution> <year> 1989. </year>
Reference-contexts: Overall, GI Joe and COSPAN provide support for FSA's but little else. The MissionLab toolset goes far beyond these capabilities in providing users with an integrated development environment. 30 2.3.5 Mechanical design compiler A mechanical design compiler has been created <ref> [79, 78] </ref> which, given schematic specifications and a utility function, will generate a design for a mechanical system meeting those goals. The output is in the form of catalog numbers for the selected components which combine to create a design optimal with respect to the utility function.
Reference: [80] <author> David A. Watt. </author> <title> An extended attribute grammar for PASCAL. </title> <journal> SIGPLAN Notices, </journal> <volume> 14(2) </volume> <pages> 60-74, </pages> <month> February </month> <year> 1979. </year>
Reference-contexts: Therefore, the choice was made to utilize an attribute grammar. Attribute grammars were first defined by Knuth in [41] and subsequently used in a post priori formal definition of the context-sensitive features of Pascal <ref> [80] </ref>. The syntax of CDL is defined using such an attribute grammar following the style promoted in [59].
Reference: [81] <author> P Wegner. </author> <title> The Vienna definition language. </title> <journal> ACM Computing Surveys, </journal> <volume> 4(1) </volume> <pages> 5-63, </pages> <year> 1972. </year> <month> 266 </month>
References-found: 81

