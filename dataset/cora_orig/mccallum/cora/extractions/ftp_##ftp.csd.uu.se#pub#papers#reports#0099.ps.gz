URL: ftp://ftp.csd.uu.se/pub/papers/reports/0099.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: e-mail: bjornc@csd.uu.se  e-mail: matsc@sics.se  
Title: Compiling and Executing Disjunctions of Finite Domain Constraints  
Author: Bjorn Carlson Mats Carlsson 
Address: Box 311 751 05 Uppsala  Box 1263, S-164 28 KISTA, Sweden  
Affiliation: Computing Science Department, Uppsala University  Swedish Institute of Computer Science  
Date: 8, 1995 ISSN 1100-0686  
Note: March  
Abstract: UPMAIL Technical Report No. 99 Abstract We present two schemes for compiling disjunctions of finite domain constraints, where disjunction is treated as constructive. In the first scheme each disjunction is compiled to a set of indexicals, i.e. a set of range functions computing domain restrictions, such that the evaluation of the indexicals maintains a weak form of consistency of the disjunction. The second scheme is based on constraint lifting, i.e. constructive disjunction applied to the set of constraint stores given by executing a disjunction of goals, for which we provide an algorithm for lifting finite domain constraints. This scheme maintains stronger consistency than the first with a penalty in efficiency. We compare the two schemes with speculative disjunction, i.e. disjunction executed nondeterministically, and with disjunction via cardinality. Our conclusions are that the indexical scheme implements the most efficient pruning for many disjunctive constraints, such as resource and maximum/minimum constraints, and that the lifting scheme can be used for implementing lookahead pruning. 
Abstract-found: 1
Intro-found: 1
Reference: [CJH94] <author> B. Carlson, S. Janson, and S. Haridi. AKL(FD): </author> <title> a concurrent language for finite domain programming. </title> <booktitle> In Logic Programming: Proceedings of the 1994 International Symposium. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The first scheme is based on FD [VHSD91], a constraint language of indexicals. An indexical is a range function, indexed by the domains of variables, which computes restrictions on a domain variable. We use an extension of the original proposal of FD with conditional reasoning <ref> [CJH94] </ref> as the target language for the compilation of disjunctions of finite domain constraints. The extension is crucial for our purposes. Hence, disjunctions of finite domain constraints are transformed into sets of (conditional) indexicals which by computing unions of ranges maintain consistency locally. <p> Another advantage of this technique is that it is based on indexicals with no extra support for disjunction, e.g. there is no need for managing local states which is necessary to implement global consistency. The second scheme uses a concurrent language with deep guards, such as AKL <ref> [Jan94, CJH94] </ref>, to execute disjunctions globally. Given a disjunction of constraints, each constraint is executed in a private local store, thus generating local domain constraints by maintaining consistency. Henceforth, domain constraints common to each local store are computed (lifted) and added to the embedding store. <p> In this paper, we give an algorithm for lifting domain constraints, and briefly describe the implementation of constraint lifting in AKL. The compilation schemes presented here have been implemented in the AGENTS-system, developed at SICS <ref> [JH91, Jan94, CJH94] </ref>. Our initial performance evaluations indicate that the indexical scheme implements sufficient pruning for many disjunctive constraints, such as resource and maximum/minimum constraints, extending the pruning given by cardinality-based disjunction. <p> Consider for a moment the element (x; l; y) constraint which is true iff the xth element in l is equal to y <ref> [DSH88, CJH94] </ref>.
Reference: [DC93a] <author> D. Diaz and P. Codognet. </author> <title> Compiling constraints in clp(FD). </title> <note> Research report, INRIA, </note> <year> 1993. </year>
Reference-contexts: The scheme can be modified to provide full consistency by allowing arbitrary range arithmetics such as r + r 0 , where r and r 0 are ranges, as is done in clp (FD) for example <ref> [DC93b, DC93a] </ref>. The method is best explained by an example. Example 3.1. <p> This compilation scheme has one major drawback: the code size is quadratic in the size of the input. This property is probably unacceptable except in toy programs or for binary constraints, and can be removed by using conjunctions of library calls instead <ref> [DC93a] </ref>. 4 Disjunctions executed locally Let c be a constraint in dnf. Furthermore, let x 1 ; : : : ; x k be the variables that occur in c. Indexing c amounts to computing a set of monotone indexicals that evaluates :L (c; ) (see Section 2.1). <p> Conjoining X c with x z and y z compiled to index-icals (see Section 3) thus gives a more powerful max/3 constraint than in clp (FD) <ref> [DC93a] </ref>. 2 5 Disjunctions executed globally First we define constraint lifting, as implemented in AKL, and then we give an algorithm for lifting domain constraints in FD. 5.1 Constraint lifting Constraint lifting is constructive disjunction applied to a set of constraint stores generated by running a disjunction of goals in separate
Reference: [DC93b] <author> D. Diaz and P. Codognet. </author> <title> A Minimal Extension of the WAM for clp(FD). </title> <booktitle> In Proceedings of the International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The scheme can be modified to provide full consistency by allowing arbitrary range arithmetics such as r + r 0 , where r and r 0 are ranges, as is done in clp (FD) for example <ref> [DC93b, DC93a] </ref>. The method is best explained by an example. Example 3.1.
Reference: [DSH88] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving the car sequencing problem in constraint logic programming. </title> <booktitle> In Euro-pean Conference on Artificial Intelligence, </booktitle> <year> 1988. </year>
Reference-contexts: Consider for a moment the element (x; l; y) constraint which is true iff the xth element in l is equal to y <ref> [DSH88, CJH94] </ref>.
Reference: [HSD92] <author> P. Van Hentenryck, H. Simonis, and M. Dincbas. </author> <title> Constraint satisfaction using constraint logic programming. </title> <journal> Artificial Intelligence, </journal> <volume> 58 </volume> <pages> 113-159, </pages> <year> 1992. </year>
Reference-contexts: It was previously shown that element/3 can be defined in terms of cardinality disjunction <ref> [HSD92] </ref>, however, under the assumption that i j is determined. Thus, our approach is slightly more general since i j need not be determined. 2 Example 4.3. Let c be the constraint x = z _ y = z.
Reference: [Jan94] <author> Sverker Janson. </author> <title> AKL|a multiparadigm programming language. </title> <institution> Uppsala theses in computing science 19, Uppsala University, </institution> <month> June </month> <year> 1994. </year> <title> SICS Dissertation Series 14. </title>
Reference-contexts: Another advantage of this technique is that it is based on indexicals with no extra support for disjunction, e.g. there is no need for managing local states which is necessary to implement global consistency. The second scheme uses a concurrent language with deep guards, such as AKL <ref> [Jan94, CJH94] </ref>, to execute disjunctions globally. Given a disjunction of constraints, each constraint is executed in a private local store, thus generating local domain constraints by maintaining consistency. Henceforth, domain constraints common to each local store are computed (lifted) and added to the embedding store. <p> In this paper, we give an algorithm for lifting domain constraints, and briefly describe the implementation of constraint lifting in AKL. The compilation schemes presented here have been implemented in the AGENTS-system, developed at SICS <ref> [JH91, Jan94, CJH94] </ref>. Our initial performance evaluations indicate that the indexical scheme implements sufficient pruning for many disjunctive constraints, such as resource and maximum/minimum constraints, extending the pruning given by cardinality-based disjunction. <p> The notion is generic in choice of constraint system, and computing approximations of disjunctions generally requires domain specific knowledge. However, for some constraint systems, such as boolean equalities, where the constraint language supports disjunction, lifting becomes trivial. In AKL, a deep concurrent constraint language <ref> [Jan94] </ref>, we have introduced constraint lifting through a deep guard operator k, explained below. Any computation in AKL is done in a local constraint store. A hierarchy of stores is created by running goals in guards. <p> Thus, AKL supports directly the structures that are necessary to implement constraint lifting, since a representation is kept which gives access both to constraint stores and to the constraints visible externally in each store. 10 The operator k is defined as an adaption of the guard mechanism of AKL <ref> [Jan94] </ref>. Thus; the lifting statement in AKL G 1 k B 1 ; G n k B n is used for expressing constraint lifting.
Reference: [JH91] <author> Sverker Janson and Seif Haridi. </author> <title> Programming paradigms of the Andorra Kernel Language. </title> <booktitle> In Logic Programming: Proceedings of the 1991 International Symposium. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In this paper, we give an algorithm for lifting domain constraints, and briefly describe the implementation of constraint lifting in AKL. The compilation schemes presented here have been implemented in the AGENTS-system, developed at SICS <ref> [JH91, Jan94, CJH94] </ref>. Our initial performance evaluations indicate that the indexical scheme implements sufficient pruning for many disjunctive constraints, such as resource and maximum/minimum constraints, extending the pruning given by cardinality-based disjunction.
Reference: [JS93] <author> J. Jourdan and T. Sola. </author> <title> The versatility of handling disjunctions as constraints. </title> <booktitle> In Proceedings of the Programming Language Implementation and Logic Programming Conference, </booktitle> <publisher> LNCS 714. Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Disjunctions of finite domain constraints can be used for pruning search <ref> [VHSD91, VHSD92, JS93] </ref>. However, instead of speculatively exploiting disjunctions as search directives, they should be handled as constraints proper. The basic idea is to propagate information common to each disjunct, where the problem is to compute what is common. <p> The cardinality-operator is not speculative, but achieves insufficient propagation in many cases, typically for disjunctive scheduling problems. 2.2.3 Constructive Constructive disjunction was proposed as a way to treat a disjunction of constraints as a constraint to avoid the speculative behavior, and to utilize the inherent propagation of disjunctions <ref> [VHSD91, VHSD92, JS93] </ref>.
Reference: [Mac77] <author> A. Mackworth. </author> <title> Consistency in Networks of Relations. </title> <journal> Journal of Artifical Intelligence, </journal> <volume> 8 </volume> <pages> 99-118, </pages> <year> 1977. </year> <month> 15 </month>
Reference-contexts: These rules may be thought of as rules for maintaining arc-consistency <ref> [Mac77] </ref>. We have extended FD with a conditional range operator which is necessary to treat disjunctions properly. A domain constraint is an expression x 2 I, where I is a set of integers. The sets that are considered will always be finite unions of intervals.
Reference: [VH89] <author> Pascal Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Pro--gramming. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: For our benchmarks the overhead of the lifting scheme for such constraints does not pay off, since it gives no more pruning than the indexical scheme. On the other hand, the lifting scheme can be exploited for lookahead pruning <ref> [VH89] </ref>, which decreases the number of nondeterminate steps dramatically for highly constrained problems such as graph-coloring and n-queens problems. This technique is not applicable using the indexical scheme. The paper is structured as follows. In Section 2 we introduce indexicals and different types of disjunction. <p> As benchmarks we use two problems for scheduling and planning, the bridge-project problem <ref> [VH89] </ref> and the perfect squares problem [VHSD92], together with the n-queens problem. The bridge and squares problems are concerned with shared resources, where the disjunctions are thus resource constraints. <p> Time (ms) 30290 406 80 3790 Non-det. steps 51 243 36 34 Table 3: Bridge-project perfect squares spec card local global Time (ms) 620 310 180 3390 Non-det. steps 25 20 8 8 Table 4: Perfect squares 8 For the n-queens problem we consider the effect of applying lookahead pruning <ref> [VH89] </ref> through disjunctive reasoning on the number of nondetermi-nate steps. <p> If no answer was computed within one minute, or when the memory consumption became too large, "?" is used in the tables. We have used first-fail labeling throughout <ref> [VH89] </ref>.
Reference: [VHD91] <author> Pascal Van Hentenryck and Yves Deville. </author> <title> The cardinality operator: a new logical connective in constraint logic programming. </title> <booktitle> In International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The problem with this scheme is that choices are made prematurely and that backtracking is needed to undo the effects of choices. 2.2.2 Cardinality Cardinality-based disjunction is disjunction defined as <ref> [VHD91] </ref>, i.e. at least one of c 1 or c 2 must be true. Hence, given a store , neither c 1 nor c 2 is executed in until the other is inconsistent in .
Reference: [VHSD91] <author> Pascal Van Hentenryck, Vijay Saraswat, and Yves Deville. </author> <title> Constraint processing in cc(fd). </title> <type> Unpublished manuscript, </type> <year> 1991. </year>
Reference-contexts: 1 Introduction Disjunctions of finite domain constraints can be used for pruning search <ref> [VHSD91, VHSD92, JS93] </ref>. However, instead of speculatively exploiting disjunctions as search directives, they should be handled as constraints proper. The basic idea is to propagate information common to each disjunct, where the problem is to compute what is common. <p> We say that either the disjunction is executed locally or globally. In this paper we present two schemes for compiling disjunctions of finite domain constraints, one which generates code for maintaining local consistency, and one which maintains global consistency. The first scheme is based on FD <ref> [VHSD91] </ref>, a constraint language of indexicals. An indexical is a range function, indexed by the domains of variables, which computes restrictions on a domain variable. <p> the two schemes compared with speculative and cardinality-based disjunction. 2 Background We now briefly explain FD, the different types of disjunction we consider, and constraint lifting in AKL. 2.1 FD: a theory of finite domain indexicals The constraint system FD is based on domain constraints and functional rules called indexicals <ref> [VHSD91] </ref>. These rules may be thought of as rules for maintaining arc-consistency [Mac77]. We have extended FD with a conditional range operator which is necessary to treat disjunctions properly. A domain constraint is an expression x 2 I, where I is a set of integers. <p> The cardinality-operator is not speculative, but achieves insufficient propagation in many cases, typically for disjunctive scheduling problems. 2.2.3 Constructive Constructive disjunction was proposed as a way to treat a disjunction of constraints as a constraint to avoid the speculative behavior, and to utilize the inherent propagation of disjunctions <ref> [VHSD91, VHSD92, JS93] </ref>.
Reference: [VHSD92] <author> Pascal Van Hentenryck, Vijay Saraswat, and Yves Deville. </author> <title> Constraint Logic Programming over Finite Domains: the Design, Implementation, and Applications of cc(fd). </title> <type> Technical report, </type> <institution> Computer Science Department, Brown University, </institution> <year> 1992. </year> <month> 16 </month>
Reference-contexts: 1 Introduction Disjunctions of finite domain constraints can be used for pruning search <ref> [VHSD91, VHSD92, JS93] </ref>. However, instead of speculatively exploiting disjunctions as search directives, they should be handled as constraints proper. The basic idea is to propagate information common to each disjunct, where the problem is to compute what is common. <p> The cardinality-operator is not speculative, but achieves insufficient propagation in many cases, typically for disjunctive scheduling problems. 2.2.3 Constructive Constructive disjunction was proposed as a way to treat a disjunction of constraints as a constraint to avoid the speculative behavior, and to utilize the inherent propagation of disjunctions <ref> [VHSD91, VHSD92, JS93] </ref>. <p> A constraint over k variables is compiled into k monotone indexicals over k 1 variables, which approximate the constraint by interval arithmetic reasoning, i.e. they maintain partial arc-consistency. This is similar to the distinction made between interval and domain reasoning of constraints in cc (FD) <ref> [VHSD92] </ref>. The scheme can be modified to provide full consistency by allowing arbitrary range arithmetics such as r + r 0 , where r and r 0 are ranges, as is done in clp (FD) for example [DC93b, DC93a]. The method is best explained by an example. Example 3.1. <p> As benchmarks we use two problems for scheduling and planning, the bridge-project problem [VH89] and the perfect squares problem <ref> [VHSD92] </ref>, together with the n-queens problem. The bridge and squares problems are concerned with shared resources, where the disjunctions are thus resource constraints.
References-found: 13

