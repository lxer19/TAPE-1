URL: http://www.cs.mu.oz.au/tr_db/mu_95_16.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: (lee@cs.mu.OZ.AU, http://www.cs.mu.oz.au/~lee)  
Title: Pruning in logic programming  
Author: Lee Naish 
Address: Parkville, Victoria 3052 Australia  
Affiliation: Department of Computer Science University of Melbourne  
Pubnum: Technical Report 95/16  
Abstract: The logic programming community has a love-hate relationship with operators for pruning the search space of logic programs such as cut, commit, once, conditionals and variations on these. Pruning operators typically are not declarative, result in incompleteness and/or unsoundness, decrease readability and flexibility of code and make program analysis and transformation more difficult. Despite this, nearly all non-trivial Prolog programs contain cuts, nearly all more recent logic programming languages have similar pruning operators and many languages insist on pruning operators in every clause. In practice, logic programming is less logical than functional programming. Why it this so? Do we really need pruning operators? Can we have sufficiently powerful pruning operators which do not destroy the declarative semantics of programs? How are pruning operators related to logic, modes, functions and lazy evaluation? This paper attempts to answer some of these questions. Keywords: cut, soft cut, commit, negation, modes, functions 
Abstract-found: 1
Intro-found: 1
Reference: [Cla78] <author> Keith L. Clark. </author> <title> Negation as failure. </title> <editor> In Herve Gallaire and Jack Minker, editors, </editor> <booktitle> Logic and data bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <year> 1978. </year>
Reference-contexts: Several variations on conventional Prolog have soundly implemented negation facilities with well defined declarative semantics, implemented using pruning. Examples include (the original) IC-Prolog [CM79], MU-Prolog [Nai85], NU-Prolog [TZ86] and Mercury [SHC95]. The original work on negation as failure <ref> [Cla78] </ref> noted that all variables in a negated goal must be input. An more obvious example of pruning in these languages is the conditional construct: if C then A else B (the syntax is slightly different in some of the languages).
Reference: [CM79] <author> K.L. Clark and F.G. McCabe. </author> <title> The control facilities of IC-prolog. </title> <editor> In Donald Michie, editor, </editor> <booktitle> Expert systems in the microelectronic age, </booktitle> <pages> pages 122-149. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1979. </year>
Reference-contexts: Several variations on conventional Prolog have soundly implemented negation facilities with well defined declarative semantics, implemented using pruning. Examples include (the original) IC-Prolog <ref> [CM79] </ref>, MU-Prolog [Nai85], NU-Prolog [TZ86] and Mercury [SHC95]. The original work on negation as failure [Cla78] noted that all variables in a negated goal must be input.
Reference: [Fra91] <author> Torkel Franzen. </author> <title> Logical aspects of the Andorra Kernel Language. </title> <institution> Research report R91:12, Swedish Institute of Computer Science, Kista, Sweden, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: Calls which would violate quietness always suspend. An inconsistency in the (implicit) modes generally results in a deadlock at runtime. AKL [JH91] supports essentially the same commit operator as GHC and a variant of it has been shown to behave like a logical if-then-else construct <ref> [Fra91] </ref>. The mode constraint is checked during the execution of the "condition" (the guard) and if the constraint is not satisfied the computation suspends. Functional programming languages naturally have modes defined | functions have inputs and an output.
Reference: [Gre87] <author> Steve Gregory. </author> <title> Design, application and implementation of a parallel logic programming language. </title> <publisher> Addison-Wesley Publishers, </publisher> <address> Reading, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: This form of incompleteness can be used to implement versions of var and nonvar if certain assumptions about the computation rule and clause selection rule can be made. 5 Parlog programs have a commit operator in every clause <ref> [Gre87] </ref>. An important part of the language design is the "guard safety" requirement, which is essentially an input mode for the calls before a commit. Certain variables must not be further instantiated by the execution of these calls.
Reference: [Han94] <author> M. Hanus. </author> <title> The integration of functions into logic programming: From theory to practice. </title> <journal> Journal of Logic Programming, </journal> 19&20:583-628, 1994. 
Reference-contexts: This is one reason why functional programming systems can simply choose the first applicable equation for evaluation (essentially pruning the rest). There have been many proposals for combining the functionality of logic and functional programming languages <ref> [Han94] </ref> and some of these proposals allow functions to be defined but used in more than one mode. This can be implemented by techniques such as narrowing.
Reference: [HL94] <author> P.M. Hill and J.W. Lloyd. </author> <title> The Godel programming language. </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: Mercury performs the mode check at compile time by analysing mode declarations and possibly reordering conjuncts in the program to achieve the desired mode. If this is not possible a compile time error results. Godel <ref> [HL94] </ref> has very similar negation facilities to NU-Prolog. It also has a pruning operator called commit. Commit does not cause unsoundness because it performs no pruning when called inside a negation.
Reference: [HLS90] <author> P.M. Hill, J.W. Lloyd, and J.C. Sheperdson. </author> <title> Properties of a pruning operator. </title> <journal> Journal of logic and computation, </journal> <volume> 1(1) </volume> <pages> 99-143, </pages> <year> 1990. </year>
Reference-contexts: Commit does not cause unsoundness because it performs no pruning when called inside a negation. A form of completeness has also been proven: if a Godel program without commits computes a certain answer then the program with commits added could compute the answer for some execution strategy <ref> [HLS90] </ref>. This result is useless in practice since the execution strategy which is used may not be the "right" one. The Godel programmer is in a similar situation to the Prolog programmer, needing to know what the modes are in order to put commits in the right place.
Reference: [JH91] <author> Sverker Janson and Seif Haridi. </author> <title> Programming paradigms of the Andorra Kernel Language. </title> <booktitle> In Proceedings of the 1991 International Symposium on Logic Programming, </booktitle> <pages> pages 167-183, </pages> <address> San Diego, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: GHC has a similar commit operator to Parlog's, but guard safety (or "quietness") is ensured by the implementation [Ued86]. Calls which would violate quietness always suspend. An inconsistency in the (implicit) modes generally results in a deadlock at runtime. AKL <ref> [JH91] </ref> supports essentially the same commit operator as GHC and a variant of it has been shown to behave like a logical if-then-else construct [Fra91]. The mode constraint is checked during the execution of the "condition" (the guard) and if the constraint is not satisfied the computation suspends.
Reference: [Kow74] <author> R. Kowalski. </author> <title> Predicate logic as programming language. </title> <editor> In Jack L. Rosenfeld, editor, </editor> <booktitle> Proceedings of the Sixth IFIP Congress (Information Processing 74), </booktitle> <pages> pages 569-574, </pages> <address> Stockholm, Sweden, </address> <month> August </month> <year> 1974. </year> <month> 14 </month>
Reference-contexts: 1 Introduction The key idea behind logic programming is that a program can be seen as a formula in some logic and computation can be seen as deduction <ref> [Kow74] </ref>. The answers computed are logical consequences of the program. Model theory allows us to reason about what is computed declaratively, without any consideration of how computations are performed. By choosing a suitable subset of some logic and a proof procedure, computations can be performed very efficiently.
Reference: [Llo87] <author> John W. Lloyd. </author> <title> Foundations of logic programming (second, extended edition). Springer series in symbolic computation. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: Proof This theorem is closely related to the soundness of SLDNF resolution (see <ref> [Llo87] </ref>), which is the basis of our proof. Suppose N = 0: G finitely fails. We assume w.l.o.g. that there is a procedure g defined by the clause g G.
Reference: [Nai85] <author> Lee Naish. </author> <title> The MU-Prolog 3.2 reference manual. </title> <type> Technical Report 85/11, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <month> October </month> <year> 1985. </year>
Reference-contexts: Several variations on conventional Prolog have soundly implemented negation facilities with well defined declarative semantics, implemented using pruning. Examples include (the original) IC-Prolog [CM79], MU-Prolog <ref> [Nai85] </ref>, NU-Prolog [TZ86] and Mercury [SHC95]. The original work on negation as failure [Cla78] noted that all variables in a negated goal must be input.
Reference: [Nai86] <author> Lee Naish. </author> <title> Negation and quantifiers in NU-Prolog. </title> <booktitle> Proceedings of the Third International Conference on Logic Programming, </booktitle> <pages> pages 624-634, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: It is implemented using pruning and if a variable in Vars appears in A, and C has multiple answers, soft cut must be used to avoid incompleteness <ref> [Nai86] </ref>. 6 Once Unfortunately, the logical reconstruction of once is much more difficult than for soft cut because there are many different uses of once. The different uses correspond to different 6 underlying logic and hence are best replaced by distinct constructs, each with unambiguous logic.
Reference: [Nai88] <author> Lee Naish. </author> <title> Parallelizing NU-Prolog. </title> <booktitle> Proceedings of the Fifth International Conference/Symposium on Logic Programming, </booktitle> <pages> pages 1546-1564, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Examples like this do occur in practice [Nai89b]. 6.3 Other pruning operators So far we have not discussed committed choice languages in detail. Many uses of commit in these languages are either redundant or can be seen as an implementation of if-then-else <ref> [Nai88] </ref>. However, the cases of "don't care" nondeterminism such as merge cannot be explained by this logic. Many committed choice programs containing this style of nonde-terminism can be explained logically in terms of the exists construct.
Reference: [Nai89a] <author> Lee Naish. </author> <title> Proving properties of committed choice logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 7(1) </volume> <pages> 63-84, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: All that is required is that if a solution exists then at least one solution is found. This is referred to as semicompleteness in <ref> [Nai89a] </ref>.
Reference: [Nai89b] <author> Lee Naish. </author> <title> Pruning the search space of Prolog: cut and other primitives. </title> <booktitle> Proceedings of Australian Joint Artificial Intelligence Conference, </booktitle> <pages> pages 238-253, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: With well-defined modes, soft cut can be given declarative semantics in terms of negation <ref> [Nai89b] </ref>. This is illustrated by the code below. The first version of procedure p has a soft cut ($). <p> Pushing pruning into recursive procedures may reduce the space complexity from O (N ) to O (1). To design pruning operators which correspond to pushing pruning in the way we have illustrated, we need to understand the logic behind the process <ref> [Nai89b] </ref>. The key factors are maintaining what calls are in a single solution context, the computation rule, additional information relating solutions to different calls (for example, R and T) and modes. <p> The end result is programs which are declarative, are less cluttered with pruning operators, can be used in more than one mode and which prune the search space even sooner than would be done in Prolog. The basic syntax is a refinement of the construct proposed in <ref> [Nai89b] </ref>. It is intentionally similar to the conditional construct in Prolog (-&gt;) and logical implication (=&gt; in NU-Prolog). <p> In the worst case this may double the space usage because garbage collection of the variable I would not be possible. If Y contained a recursive call to Q the space saving using exists instead of cut could be arbitrarily large. Examples like this do occur in practice <ref> [Nai89b] </ref>. 6.3 Other pruning operators So far we have not discussed committed choice languages in detail. Many uses of commit in these languages are either redundant or can be seen as an implementation of if-then-else [Nai88]. <p> If combine always succeed the last conjunction operator can be replaced by =-&gt; exists [O] and the pruning context of p will be inherited by merge as well as combine. Furthermore, we know each recursive call to merge will succeed, which is vital for semicompleteness <ref> [Nai89b] </ref>. The definition of merge can therefore be as follows: merge ([], Bs, Bs). merge (As, [], As). merge (A.As, Bs, A.Cs) :- true =-&gt; exists [Cs] merge (As, Bs, Cs). merge (As, B.Bs, B.Cs) :- true =-&gt; exists [Cs] merge (As, Bs, Cs).
Reference: [Nai92] <author> Lee Naish. </author> <title> Declarative diagnosis of missing answers. </title> <journal> New Generation Computing, </journal> <volume> 10(3) </volume> <pages> 255-285, </pages> <year> 1992. </year>
Reference-contexts: Call Goal and if it fails diagnose missing answers in Goal using existing methods. Otherwise, if the solution found for Goal is incorrect, diagnose the wrong answer using existing methods. Otherwise, use an oracle to check if there are any other valid instances of Goal (an "incompleteness" question <ref> [Nai92] </ref>). If there are other valid instances the assertion is wrong; if not the goal executes correctly. 6.2 Exists If any one solution operator is used in a program then efficiency can often be increased if the pruning is "pushed" inside the computation which is being pruned.
Reference: [Nai93] <author> Lee Naish. </author> <title> Coroutining and the construction of terminating logic programs. </title> <journal> Aus-tralian Computer Science Communications, </journal> <volume> 15(1) </volume> <pages> 181-190, </pages> <year> 1993. </year>
Reference-contexts: In committed choice languages the computation rule is also made more flexible. A more flexible computation rule can lead to non-termination, but there are two important pitfalls most committed choice programs avoid: cyclic modes and "speculative" bindings 12 <ref> [Nai93] </ref>. The exists construct identifies where bindings would be speculative and hence it may play an important role in computation rules as well as pruning. We do not claim that the selection of pruning constructs we have discussed covers all possible reasonable uses of pruning.
Reference: [O'K85] <author> Richard O'Keefe. </author> <title> On the treatment of cuts in prolog source level tools. </title> <booktitle> In Proceedings of the Second IEEE Symposium on Logic Programming, </booktitle> <pages> pages 68-72, </pages> <address> Boston, Massachusetts, </address> <month> July </month> <year> 1985. </year>
Reference-contexts: Some pruning operators also make program transformation and meta interpretation more difficult due to their scope. Such problems are fundamentally syntactic and are best solved by initially transforming programs into a form which has more convenient pruning operators <ref> [O'K85] </ref>. 4 Modes Before considering specific pruning operators in more detail, it is worth noting the strong relationship between input/output modes and pruning. It it not possible to reasonably prune the search space without knowing certain mode information.
Reference: [O'K90] <author> Richard A. O'Keefe. </author> <title> The Craft of Prolog. Logic Programming. </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: This is one way of explaining why Prolog with cut is "non-logical". Pruning in the wrong place results in missing answers (a desired answer is pruned from the search space) or wrong answers (due to missing answers inside negation or conditionals or code which is not "steadfast" <ref> [O'K90] </ref>). Several variations on conventional Prolog have soundly implemented negation facilities with well defined declarative semantics, implemented using pruning. Examples include (the original) IC-Prolog [CM79], MU-Prolog [Nai85], NU-Prolog [TZ86] and Mercury [SHC95].
Reference: [SHC95] <author> Zoltan Somogyi, Fergus Henderson, and Thomas Conway. </author> <title> The execution algorithm of Mercury, an efficient purely declarative logic programming language. </title> <type> Technical Report 95/14, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Mel-bourne, Australia, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: Several variations on conventional Prolog have soundly implemented negation facilities with well defined declarative semantics, implemented using pruning. Examples include (the original) IC-Prolog [CM79], MU-Prolog [Nai85], NU-Prolog [TZ86] and Mercury <ref> [SHC95] </ref>. The original work on negation as failure [Cla78] noted that all variables in a negated goal must be input. An more obvious example of pruning in these languages is the conditional construct: if C then A else B (the syntax is slightly different in some of the languages).
Reference: [Smo84] <author> Gert Smolka. </author> <title> Making control and data flow in logic programs explicit. </title> <booktitle> In Conference Record of the ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 311-322, </pages> <address> Austin, Texas, </address> <month> July </month> <year> 1984. </year>
Reference-contexts: This is supported in Mercury but only for determinism which can be verified by the compiler If slowsort was declared deterministic an error would result. Declarations which are not checked by the compiler <ref> [Smo84] </ref> could be given semantics in the way we suggest below for only. In the body of a clause or goal, only Vars Goal can be viewed declaratively as being equivalent to Goal.
Reference: [TZ86] <author> NU-Prolog reference manual, </author> <title> version 1.0. </title> <type> Technical Report 86/10, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1986. </year>
Reference-contexts: Several variations on conventional Prolog have soundly implemented negation facilities with well defined declarative semantics, implemented using pruning. Examples include (the original) IC-Prolog [CM79], MU-Prolog [Nai85], NU-Prolog <ref> [TZ86] </ref> and Mercury [SHC95]. The original work on negation as failure [Cla78] noted that all variables in a negated goal must be input.
Reference: [Ued86] <author> Kazunori Ueda. </author> <title> Guarded Horn clauses. </title> <type> D.Eng. thesis, </type> <institution> University of Tokyo, </institution> <address> Tokyo, Japan, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: If the mode declarations in a program do not ensure guard safety the result can be a compile time error or unpredictable behaviour at runtime. GHC has a similar commit operator to Parlog's, but guard safety (or "quietness") is ensured by the implementation <ref> [Ued86] </ref>. Calls which would violate quietness always suspend. An inconsistency in the (implicit) modes generally results in a deadlock at runtime. AKL [JH91] supports essentially the same commit operator as GHC and a variant of it has been shown to behave like a logical if-then-else construct [Fra91].
Reference: [Vod88] <author> Paul J. Voda. </author> <title> The logical reconstruction of cuts as one solution operators. </title> <editor> In John W. Lloyd, editor, </editor> <booktitle> Proceedings of the Workshop on Meta-programming in Logic Programming, </booktitle> <pages> pages 379-384, </pages> <address> Bristol, England, </address> <month> June </month> <year> 1988. </year> <month> 15 </month>
Reference-contexts: The logic behind finding the first solution is thus much more complicated than the normal declarative semantics of a program. However, at least in some systems it is possible to precisely specify the logic. This has been done for the first solution operator of Trilogy <ref> [Vod88] </ref>. There are other uses of once which are normally thought of as cases of don't care nondeterminism. The programmer doesn't care which of several solutions are found, though the output is used. At the top level of a computation this causes no problem.
References-found: 24

