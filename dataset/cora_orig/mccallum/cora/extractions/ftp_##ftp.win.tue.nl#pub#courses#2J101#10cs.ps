URL: ftp://ftp.win.tue.nl/pub/courses/2J101/10cs.ps
Refering-URL: http://www.win.tue.nl/cs/pa/educ/2J180/
Root-URL: http://www.win.tue.nl
Email: Email: Jonathan.Bowen@comlab.ox.ac.uk  Email: Mike.Hinchey@cl.cam.ac.uk  
Title: Ten Commandments of Formal Methods  
Author: Jonathan P. Bowen Michael G. Hinchey 
Keyword: Albert Einstein  
Web: URL: http://www.comlab.ox.ac.uk/oucl/people/jonathan.bowen.html  URL: http://www.cl.cam.ac.uk/users/mgh1001  
Address: Wolfson Building, Parks Road, Oxford OX1 3QD, UK.  New Museums Site, Pembroke Street, Cambridge CB2 3QG, UK.  
Affiliation: Oxford University Computing Laboratory Programming Research Group  University of Cambridge Computer Laboratory,  
Abstract: The formal methods community is in general very good at undertaking research into the mathematical aspects of formal methods, but not so good at promulgating the use of formal methods in an engineering environment and at an industrial scale. Technology transfer is an extremely important part of the overall effort necessary in the acceptance of formal techniques. This paper explores some of the more informal aspects of applying formal methods and presents some maxims with associated discussion that may help in the application of formal methods in an industrial setting. A significant bibliography is included, providing pointers to more technical and detailed aspects. Why does this magnificent applied science which saves work and makes life easier bring us so little happiness? The simple answer runs: because we have not yet learned to make sensible use of it. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abrial, J.-R.: </author> <title> Assigning Meanings to Programs. Prentice Hall International Series in Computer Science, </title> <note> to appear. </note>
Reference-contexts: In this category we naturally include HOL [35], Larch [36] (with LP, the Larch Prover), Nqthm [18], OBJ [34] and PVS [54]. There are also a number of theorem provers and support environments that incorporate theorem provers for methods such as B <ref> [1] </ref> (e.g., the B toolkit from B-Core), CSP [43] (e.g., FDR from Formal Systems (Europe) Ltd.), RAISE [58] (from CRI), VDM [45] (e.g., the VDM Toolbox from IFAD) and Z [62] (e.g., Balzac/Zola from Imperial Software Technology, and ProofPower from ICL).
Reference: [2] <author> Austin, S. & Parkin, </author> <title> G.I.: Formal Methods: A Survey. </title> <institution> National Physical Laboratory, Queens Road, Teddington, </institution> <address> Middlesex, TW11 0LW, UK, </address> <month> March </month> <year> 1993. </year>
Reference-contexts: This is due to not insubstantial misconceptions [17] regarding the costs, difficulties and pay-offs accruing as a result of their use [13, 37]. A number of surveys of the industrial application of formal methods to `real-life' (as opposed to `toy') problems <ref> [2, 24, 25] </ref> are helping to dispel many of these misconceptions and to highlight the fact that formal methods projects can indeed come in on-time, within budget, produce correct software (and hardware), that is well-structured, maintainable, and which has involved system procurers and satisfied their requirements (see, for example, the case <p> It is important to have up-to-date information to hand when deciding which formal method to use. There are a plethora of notations and methods from which to choose, although the number which have been used in an industrial setting is considerably smaller <ref> [2] </ref>. Chosing an appropriate notation (or notations) and integrating it (them) with existing development processes, being careful to ensure that existing guidelines and procedures are retained as much as possible, is vital for the successful industrialization of formal methods, and to ensure the success of any given formal methods project.
Reference: [3] <author> Barwise, J.: </author> <title> Mathematical Proofs of Computer System Correctness. </title> <journal> Notices of the American Mathematical Society, </journal> <volume> 36(7) </volume> <pages> 844-851, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: One can never have absolute correctness, and to suggest that one can is ludicrous. Ongoing debates in Communications of the ACM [30] and other fora, have been criticized on the grounds that there is a mismatch between the mathematical model and reality <ref> [3] </ref>. This is no great deduction | no proponent of formal methods would ever make a claim of definitive correctness. In fact, one should never speak arbitrarily of correctness, but rather correctness with respect to the specification.
Reference: [4] <author> Biggerstaff, T.J. & Perlis, A.J. (eds.): </author> <title> Software Reusability Vol. 1: Concepts and Models, preface. </title> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: The remaining 85%, it was claimed, was common and generic, and theoretically could have been rewritten from reusable components. There are four major factors which conspire against software reuse, however: 1. The VLSR Problem The VLSR (Very Large Scale Reuse) Problem <ref> [4] </ref> holds that the cost of developing an architectural superstructure to support the composition of components is prohibitive when compared to the potential savings to be gained from reuse. 2.
Reference: [5] <author> Boehm, B.W.: </author> <title> Software Engineering Economics. </title> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: As yet, we must rely on models developed before formal methods became widely-used. Perhaps the most famous of these is Boehm's COCOMO model <ref> [5] </ref>, which weights various factors according to the historical results of system development within the organization. The intermediate model augments the basic model, adjusting it with 15 attributes which are seen as key contributors to cost.
Reference: [6] <author> Boehm, B.W.: </author> <title> A Spiral Model of Software Development and Maintenance. </title> <journal> IEEE Computer, </journal> <volume> 21(5) </volume> <pages> 61-72, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: However, in extreme cases, errors in the system specification may be uncovered during post-implementation execution. System development is not so simple as the model proposed by Royce [33, 50], but rather an iterative and non-linear process as exemplified by Boehm's `Spriral' model <ref> [6] </ref>. As such, the developer should not make claims to having determined all of the requirements just because a certain stage in the development process has been reached; indeed such claims should be considered dubious even post-implementation.
Reference: [7] <author> Bowen, J.P.: </author> <title> Formal Specification in Z as a Design and Documentation Tool. </title> <booktitle> In Proc. Second IEE/BCS Conference, Software Engineering 88, </booktitle> <address> Liverpool, UK, </address> <month> 11-15 July </month> <year> 1988. </year> <note> IEE Conference Publication No. 290, </note> <year> 1988, </year> <pages> pp 164-168. 14 </pages>
Reference-contexts: The latter is particularly important for conveying information on system aspects which are not formally specified for various reasons. In general it is highly recommended to produce an informal specification to explain the formal description <ref> [7] </ref>. This reinforces the reader's understanding of the formal text and connects it with the real world. If there is any discrepancy between the two, the formal specification should be taken as the final arbiter for the documentation since this is the less ambiguous of the two descriptions.
Reference: [8] <author> Bowen, J.P.: </author> <title> Formal Methods in Safety-Critical Standards. </title> <booktitle> In Proc. Software Engineer--ing Standards Symposium (SESS'93), </booktitle> <address> Brighton, UK, </address> <month> 30 August - 3 September </month> <year> 1993. </year> <institution> IEEE Computer Society Press, </institution> <year> 1993, </year> <pages> pp 168-177. </pages>
Reference-contexts: 1 Introduction Formal methods have been advocated as one of those techniques that are likely, when correctly applied, to result in systems of the highest integrity. A number of standards bodies are recommending their use in security- and safety-critical systems <ref> [8, 16] </ref>; this is a trend that is likely to continue [14]. Unfortunately, while the number of projects in which formal methods are being employed is growing rapidly, their use is still very much the exception rather than the norm [15]. <p> Often software quality standards such as the ISO9000 series have been used instead since these were the nearest relevant guidelines. Now a spate of standards in this area have been, or are about to be, issued <ref> [8, 14] </ref>. Some of these are recommending or even mandating the use of formal methods. These are not the only standards that need to be adhered to, however. There is a grave danger that developers will look on the application of formal methods as a means of developing correct software.
Reference: [9] <editor> Bowen, J.P. (ed.): </editor> <title> Towards Verified Systems. Elsevier, Real-Time Safety-Critical Systems series, </title> <year> 1994. </year>
Reference-contexts: Formal Development/Verification Full formal development is, as yet, rarely undertaken <ref> [9] </ref>.
Reference: [10] <author> Bowen, J.P., Breuer, P.T. & Lano, K.C. </author> <title> Formal Specifications in Software Maintenance: From code to Z ++ and back again. </title> <journal> Information and Software Technology, </journal> 35(11/12):679-690, November/December 1993. 
Reference-contexts: Having formal documentation could be of great benefit when the software needs to be maintained. In the future, it could be possible to maintain the formal description rather than the executable code directly, only undertaking redevelopment of the parts of the code that the modifications necessitate <ref> [10] </ref>. You should not put too much trust in any unproved conjecture, even if it has been propounded by a great authority, even if it has been propounded by yourself. <p> Techniques have been investigated for the reverse engineering of dusty-deck (mainly COBOL) programs to a formal specification and other associated documentation using an interactive tool-based approach which can then be redeveloped into a better structured more understandable program <ref> [10] </ref>. These have been successfully applied to programs of the order of tens of thousands of lines long.
Reference: [11] <editor> Bowen, J.P. & Gordon, M.J.C.: Z and HOL. </editor> <booktitle> In [12], </booktitle> <pages> pp 141-167. </pages>
Reference-contexts: Quite a lot of interest has also focused lately on tailoring theorem provers for use with specific methods. For example, theorem provers for Z have been developed in EVES [61], HOL <ref> [11] </ref>, and OBJ [48]. Each of these three levels is useful in itself. One must determine, however, whether the additional cost (in time, effort, manpower, tool support, etc.) is justified before embarking on full formal development and machine-checked proofs. <p> Sometimes it is possible to combine different formal methods together usefully and effectively. For example, HOL [35] has been used to provide tool support for Z <ref> [11] </ref>. This allows the more readable Z notation to have the benefit of mechanical proof checking by HOL, thus increasing confidence in the development. The management of a project using formal methods must be more technically aware than is perhaps normally the case.
Reference: [12] <editor> Bowen, J.P. & Hall, J.A. (eds.): </editor> <booktitle> Z User Workshop, </booktitle> <address> Cambridge 1994. </address> <publisher> Springer-Verlag, Workshops in Computing, </publisher> <year> 1994. </year>
Reference: [13] <editor> Bowen, J.P. & Hinchey, M.G.: </editor> <title> Seven More Myths of Formal Methods. </title> <type> Technical Report PRG-TR-7-94, </type> <institution> Programming Research Group, Oxford University Computing Laboratory, </institution> <month> June </month> <year> 1994. </year> <note> To appear in a shortened form in Proceedings FME'94 Symposium, Springer-Verlag LNCS, </note> <year> 1994. </year>
Reference-contexts: This is due to not insubstantial misconceptions [17] regarding the costs, difficulties and pay-offs accruing as a result of their use <ref> [13, 37] </ref>. <p> The fact that a number of formal methods projects have come in over-budget is not evidence that they are more expensive, but rather that we are, as yet, inexperienced in estimating costs <ref> [13] </ref>. A number of models have been produced for project cost and project development time estimation. <p> While his "Project Attributes" are all likely to remain valid, MODP (Modern Programming Practices) is likely to be constant, while the development of more useful tools and 5 support environments <ref> [13] </ref> should greatly increase the impact of the TOOL (Software Tools) attribute. Again, new attributes are likely to be required, such as DFOR (the percentage of the system that has been subjected to formal specification techniques and formal analysis) and PROF (the degree of rigorous and formal proof required).
Reference: [14] <editor> Bowen, J.P. & Hinchey, M.G.: </editor> <title> Formal Methods and Safety-Critical Standards. </title> <booktitle> IEEE Computer, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: A number of standards bodies are recommending their use in security- and safety-critical systems [8, 16]; this is a trend that is likely to continue <ref> [14] </ref>. Unfortunately, while the number of projects in which formal methods are being employed is growing rapidly, their use is still very much the exception rather than the norm [15]. <p> In fact, a number of bodies are advocating machine-checked proofs in their standards. The European Space Agency, for example, advocates formal proof (in advance of testing) wherever practicable, and suggests that proofs should be checked independently to reduce the possibility of human error <ref> [14] </ref>; more and more this is likely to involve machine-checking of proofs. A number of formal methods incorporate theorem provers as part of the method itself. In this category we naturally include HOL [35], Larch [36] (with LP, the Larch Prover), Nqthm [18], OBJ [34] and PVS [54]. <p> Often software quality standards such as the ISO9000 series have been used instead since these were the nearest relevant guidelines. Now a spate of standards in this area have been, or are about to be, issued <ref> [8, 14] </ref>. Some of these are recommending or even mandating the use of formal methods. These are not the only standards that need to be adhered to, however. There is a grave danger that developers will look on the application of formal methods as a means of developing correct software.
Reference: [15] <author> Bowen, J.P. & Stavridou, V.: </author> <title> The Industrial Take-up of Formal Methods in Safety-Critical and Other Areas: A Perspective. </title> <booktitle> In [67], </booktitle> <pages> pp 183-195. </pages>
Reference-contexts: Unfortunately, while the number of projects in which formal methods are being employed is growing rapidly, their use is still very much the exception rather than the norm <ref> [15] </ref>. This is due to not insubstantial misconceptions [17] regarding the costs, difficulties and pay-offs accruing as a result of their use [13, 37].
Reference: [16] <author> Bowen, J.P. & Stavridou, V.: </author> <title> Safety-Critical Systems, Formal Methods and Standards. </title> <journal> Software Engineering Journal, </journal> <volume> 8(4) </volume> <pages> 189-209, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Formal methods have been advocated as one of those techniques that are likely, when correctly applied, to result in systems of the highest integrity. A number of standards bodies are recommending their use in security- and safety-critical systems <ref> [8, 16] </ref>; this is a trend that is likely to continue [14]. Unfortunately, while the number of projects in which formal methods are being employed is growing rapidly, their use is still very much the exception rather than the norm [15].
Reference: [17] <author> Bowen, J.P. & Stavridou, V.: </author> <title> Formal Methods: </title> <journal> Epideictic or Apodeictic? Software Engineering Journal, </journal> <volume> 9(1):2, </volume> <month> January </month> <year> 1994. </year>
Reference-contexts: Unfortunately, while the number of projects in which formal methods are being employed is growing rapidly, their use is still very much the exception rather than the norm [15]. This is due to not insubstantial misconceptions <ref> [17] </ref> regarding the costs, difficulties and pay-offs accruing as a result of their use [13, 37].
Reference: [18] <author> Boyer, R.S. & Moore, J.S.: </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <year> 1988. </year>
Reference-contexts: A number of formal methods incorporate theorem provers as part of the method itself. In this category we naturally include HOL [35], Larch [36] (with LP, the Larch Prover), Nqthm <ref> [18] </ref>, OBJ [34] and PVS [54].
Reference: [19] <author> Breuer, P.T. & Bowen, J.P.: </author> <title> Towards Correct Executable Semantics for Z. </title> <booktitle> In [12], </booktitle> <pages> pp 185-209. </pages>
Reference-contexts: Many more errors are removed at this point, but early progress might not be as obvious as in a more typical project. One way to provide feedback, particularly for a customer, might be to produce a rapid prototype from the specification <ref> [19] </ref>. But two permissible and correct models of the same external objects may yet differ in respect of appropriateness. - Heinrich Hertz VI Thou shalt document sufficiently. An important part of a designed system is its documentation, particularly if subsequent changes are required. <p> Testing may be performed in a traditional fashion, using techniques such as McCabe's Complexity Measure to determine the required amount of testing. Alternatively it may employ some form of simulation, using executable specification languages, or some form of specification animation <ref> [19, 39] </ref>. Formal methods offer yet another alternative when it comes to testing, namely specification-based testing. The formal specification may be used as a guide for determining functional tests for the system.
Reference: [20] <author> Aujla, S., Bryant, A. & Semmens, L.: </author> <title> A Rigorous Review Technique: Using Formal Notations within Conventional Development Methods. </title> <booktitle> In Proc. Software Engineering Standards Symposium (SESS'93), </booktitle> <address> Brighton, UK, </address> <month> 30 August - 3 September </month> <year> 1993. </year> <institution> IEEE Computer Society Press, </institution> <year> 1993, </year> <pages> pp 247-255. </pages>
Reference-contexts: Z has been applied successfully and apparently cost-effectively using this approach <ref> [20] </ref>. The Cleanroom approach is a technique that could easily incorporate the use of existing formal notations to produce highly reliable software by means of non execution-based program development [29].
Reference: [21] <author> Cahill, A., Hinchey, M.G. & Relihan, L.: </author> <title> Documents are Programs. </title> <booktitle> In Proceedings ACM SIGDOC'93, 11th International Conference on System Documentation, </booktitle> <address> Waterloo, Canada, 5-8 October 1993, </address> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1993, </year> <pages> pp 43-55. </pages>
Reference-contexts: Such techniques have proven to be useful in developing a software architecture for a family of oscilloscopes [32], and for such diverse activities as formally specifying the algorithm employed in a single-transferable voting system [52], describing the structure of documents <ref> [21, 41] </ref> and highlighting inconsistencies in the design of the World Wide Web [59]. 2. Formal Development/Verification Full formal development is, as yet, rarely undertaken [9].
Reference: [22] <author> Capers Jones, T.: </author> <title> Reusability in Programming: A Survey of the State of the Art. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> September </month> <year> 1984, </year> <pages> pp 488-494. 15 </pages>
Reference-contexts: This applies to formal development as well as to more conventional development methods; indeed, exploiting reuse in formal development can (theoretically at least) aid in offsetting some of the set-up costs (e.g., tools, training and education) of the development. Studies quoted by Capers Jones <ref> [22] </ref> claim that in 1983 only about 15% of all new code was unique, novel and specific to the individual applications. The remaining 85%, it was claimed, was common and generic, and theoretically could have been rewritten from reusable components.
Reference: [23] <author> Carrington, D. & Stocks, P.: </author> <title> A Tale of Two Paradigms: Formal Methods and Software Testing. </title> <booktitle> In [12], </booktitle> <pages> pp 51-68. </pages>
Reference-contexts: The formal specification may be used as a guide for determining functional tests for the system. The tester may exploit the abstraction made in the specification to concentrate on the key aspects of the functionality. The approach offers a structured means of testing, which simplifies regression testing <ref> [23] </ref> and helps to pin-point errors.
Reference: [24] <author> Craigen, D., Gerhart, S. & Ralston, T.: </author> <title> An International Survey of Industrial Applications of Formal Methods. Atomic Energy Control Board of Canada, </title> <type> U.S. </type> <institution> National Institute of Standards and Technology, and U.S. Naval Research Laboratories, NIST GCR 93/626. National Technical Information Service, 5285 Port Royal Road, </institution> <address> Spring-field, VA 22161, USA, </address> <year> 1993. </year>
Reference-contexts: This is due to not insubstantial misconceptions [17] regarding the costs, difficulties and pay-offs accruing as a result of their use [13, 37]. A number of surveys of the industrial application of formal methods to `real-life' (as opposed to `toy') problems <ref> [2, 24, 25] </ref> are helping to dispel many of these misconceptions and to highlight the fact that formal methods projects can indeed come in on-time, within budget, produce correct software (and hardware), that is well-structured, maintainable, and which has involved system procurers and satisfied their requirements (see, for example, the case <p> Greater attention to technology transfer [64] and surveys of formal development <ref> [24, 25] </ref> will eventually provide us with the levels of detail we require. Elsewhere [40] we attempt to consolidate much of this information in an industrially useful way.
Reference: [25] <author> Craigen, D., Gerhart, S. & Ralston, T.: </author> <title> Applications of Formal Methods: Observations and Trends. </title> <booktitle> In [40]. </booktitle>
Reference-contexts: This is due to not insubstantial misconceptions [17] regarding the costs, difficulties and pay-offs accruing as a result of their use [13, 37]. A number of surveys of the industrial application of formal methods to `real-life' (as opposed to `toy') problems <ref> [2, 24, 25] </ref> are helping to dispel many of these misconceptions and to highlight the fact that formal methods projects can indeed come in on-time, within budget, produce correct software (and hardware), that is well-structured, maintainable, and which has involved system procurers and satisfied their requirements (see, for example, the case <p> Greater attention to technology transfer [64] and surveys of formal development <ref> [24, 25] </ref> will eventually provide us with the levels of detail we require. Elsewhere [40] we attempt to consolidate much of this information in an industrially useful way.
Reference: [26] <author> Dijkstra, </author> <title> E.W.: Why Correctness must be a Mathematical Concern. </title> <editor> In Boyer R.S. & Moore, J.S. (eds.), </editor> <booktitle> The Correctness Problem in Computer Science, </booktitle> <publisher> Academic Press, </publisher> <year> 1981. </year>
Reference-contexts: Even the use of a proof checker does not guarantee the correctness of a proof, but it does aid in highlighting unsubstantiated jumps, and avoidable errors. Errors are not in the art but in the artificers. Sir Isaac Newton IX Thou shalt test, test, and test again. Dijkstra <ref> [26] </ref> has pointed out a major limitation of testing | while it can demonstrate the presense of `bugs', it cannot demonstrate their absence. Just because a system has passed unit and system testing, it does not follow that the system will necessarily be bug-free.
Reference: [27] <author> Dix, A.: </author> <title> Formal Methods for Interactive Systems. </title> <publisher> Academic Press, Computers and People Series, </publisher> <year> 1991. </year>
Reference-contexts: Even the most fervent supporters of formal methods must admit that there are areas where formal methods are just not as good as more conventional methods. In User Interface (UI) design, for example, although there have been a number of somewhat successful applications using formal specification techniques <ref> [27] </ref>, it is generally accepted that UI design falls within the domain of informal reasoning. Applying formal methods to all aspects of a system would be both unnecessary and costly.
Reference: [28] <author> Draper, C.: </author> <title> Practical Experiences of Z and SSADM. </title> <editor> In Bowen, J.P. & Nicholls, J.E. (eds.), </editor> <booktitle> Z User Workshop, </booktitle> <address> London 1992, </address> <publisher> Springer-Verlag, Workshops in Computing, </publisher> <year> 1993, </year> <pages> pp 240-254. </pages>
Reference: [29] <author> Dyer, M.: </author> <title> The Cleanroom Approach to Quality Software Development, </title> <editor> John Wiley & Sons, </editor> <booktitle> Series in Software Engineering Practice, </booktitle> <year> 1992. </year>
Reference-contexts: Z has been applied successfully and apparently cost-effectively using this approach [20]. The Cleanroom approach is a technique that could easily incorporate the use of existing formal notations to produce highly reliable software by means of non execution-based program development <ref> [29] </ref>. This technique has been applied very successfully using rigorous software development techniques with a proven track record of reducing errors by a significant factor, in both safety-critical and non-critical applications. The programs are developed separately using informal (often just mental) proofs before they are certified (rather than tested).
Reference: [30] <author> Fetzer, J.H.: </author> <title> Program Verification: The Very Idea. </title> <journal> Communications of the ACM, </journal> <volume> 31 </volume> <pages> 1048-1063, </pages> <year> 1988. </year>
Reference-contexts: System development is a human activity, and always will be. Software engineering will be prone to human whim, indecision, the ambiguity of natural language, and simple carelessness. One can never have absolute correctness, and to suggest that one can is ludicrous. Ongoing debates in Communications of the ACM <ref> [30] </ref> and other fora, have been criticized on the grounds that there is a mismatch between the mathematical model and reality [3]. This is no great deduction | no proponent of formal methods would ever make a claim of definitive correctness.
Reference: [31] <author> Fuchs, N.E.: </author> <title> Specifications are (Preferably) Executable, </title> <journal> IEE/BCS Software Engineering Journal. </journal> <volume> 7(5) </volume> <pages> 323-334, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: There is some dispute about the benefit of so-called `executable specification languages' and we refer the reader elsewhere for a discussion on this topic <ref> [31, 38] </ref>. By relieving the mind of all unnecessary work, a good notation sets it free to concentrate on more advanced problems, and in effect increases the mental power of the race. - Alfred North Whitehead 2 I I Thou shalt formalize but not over-formalize.
Reference: [32] <author> Garlan, D. & Delisle, N.: </author> <title> Formal Development of a Software Architecture for a Family of Instrumentation Systems. </title> <booktitle> In [40]. </booktitle>
Reference-contexts: Such techniques have proven to be useful in developing a software architecture for a family of oscilloscopes <ref> [32] </ref>, and for such diverse activities as formally specifying the algorithm employed in a single-transferable voting system [52], describing the structure of documents [21, 41] and highlighting inconsistencies in the design of the World Wide Web [59]. 2. Formal Development/Verification Full formal development is, as yet, rarely undertaken [9].
Reference: [33] <author> Gladden, </author> <title> G.R.: Stop the Life Cycle I Want to Get Off. </title> <journal> ACM Software Engineering Notes, </journal> <volume> 7(2) </volume> <pages> 35-39, </pages> <year> 1982. </year>
Reference-contexts: Ideally all inconsistencies will be discovered during implementation, or at worst during post-implementation testing. However, in extreme cases, errors in the system specification may be uncovered during post-implementation execution. System development is not so simple as the model proposed by Royce <ref> [33, 50] </ref>, but rather an iterative and non-linear process as exemplified by Boehm's `Spriral' model [6].
Reference: [34] <author> Goguen, J.A. & Winkler, T.: </author> <title> Introducing OBJ3. </title> <type> Technical Report SRI-CSL-88-9, </type> <institution> SRI, </institution> <address> Menlo Park, USA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: A number of formal methods incorporate theorem provers as part of the method itself. In this category we naturally include HOL [35], Larch [36] (with LP, the Larch Prover), Nqthm [18], OBJ <ref> [34] </ref> and PVS [54].
Reference: [35] <editor> Gordon, M.J.C. & Melham, T.F. (eds.): </editor> <title> Introduction to HOL: A theorem proving environment for higher order logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: A number of formal methods incorporate theorem provers as part of the method itself. In this category we naturally include HOL <ref> [35] </ref>, Larch [36] (with LP, the Larch Prover), Nqthm [18], OBJ [34] and PVS [54]. <p> Sometimes it is possible to combine different formal methods together usefully and effectively. For example, HOL <ref> [35] </ref> has been used to provide tool support for Z [11]. This allows the more readable Z notation to have the benefit of mechanical proof checking by HOL, thus increasing confidence in the development.
Reference: [36] <author> Guttag, J.V. & Horning, J.J: </author> <title> Larch: Languages and Tools for Formal Specification. Springer-Verlag, </title> <booktitle> Texts and Monographs in Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: A number of formal methods incorporate theorem provers as part of the method itself. In this category we naturally include HOL [35], Larch <ref> [36] </ref> (with LP, the Larch Prover), Nqthm [18], OBJ [34] and PVS [54].
Reference: [37] <author> Hall, J.A.: </author> <title> Seven Myths of Formal Methods. </title> <journal> IEEE Software, </journal> <volume> 7(5) </volume> <pages> 11-19, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: This is due to not insubstantial misconceptions [17] regarding the costs, difficulties and pay-offs accruing as a result of their use <ref> [13, 37] </ref>.
Reference: [38] <author> Hayes I.J. & Jones, C.B.: </author> <title> Specifications are not (Necessarily) Executable. </title> <journal> IEE/BCS Software Engineering Journal, </journal> <volume> 4(6) </volume> <pages> 330-338, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: There is some dispute about the benefit of so-called `executable specification languages' and we refer the reader elsewhere for a discussion on this topic <ref> [31, 38] </ref>. By relieving the mind of all unnecessary work, a good notation sets it free to concentrate on more advanced problems, and in effect increases the mental power of the race. - Alfred North Whitehead 2 I I Thou shalt formalize but not over-formalize.
Reference: [39] <author> Hinchey, M.G.: </author> <title> Towards Visual Methods. </title> <note> Submitted for publication. </note>
Reference-contexts: Testing may be performed in a traditional fashion, using techniques such as McCabe's Complexity Measure to determine the required amount of testing. Alternatively it may employ some form of simulation, using executable specification languages, or some form of specification animation <ref> [19, 39] </ref>. Formal methods offer yet another alternative when it comes to testing, namely specification-based testing. The formal specification may be used as a guide for determining functional tests for the system.
Reference: [40] <editor> Hinchey, M.G. & Bowen, J.P. (eds.): </editor> <title> Applications of Formal Methods. </title> <publisher> Prentice Hall International Series in Computer Science, </publisher> <year> 1995. </year> <note> In preparation. </note>
Reference-contexts: are helping to dispel many of these misconceptions and to highlight the fact that formal methods projects can indeed come in on-time, within budget, produce correct software (and hardware), that is well-structured, maintainable, and which has involved system procurers and satisfied their requirements (see, for example, the case studies in <ref> [40] </ref>). But, what makes a formal methods project successful? This is a very subjective question, and to attempt a definitive answer would be ludicrous. We have, however, determined a number of factors which we believe can have a great influence on whether or not a formal methods project succeeds. <p> The proofs involved at this stage may be formal, or informal but rigorous. Each of the applications reported in <ref> [40] </ref> involves some level of rigorous proof. 3. Machine-checked proofs With the advent of support tools, and in particular theorem provers or theorem checkers, mechanically checking proofs for consistency and well-foundedness has become feasible. Indeed, for certain classes of system, machine checking of proofs is well worthwhile. <p> Greater attention to technology transfer [64] and surveys of formal development [24, 25] will eventually provide us with the levels of detail we require. Elsewhere <ref> [40] </ref> we attempt to consolidate much of this information in an industrially useful way. We do not claim that formal methods are cheap, but that for high integrity systems such an investment is warranted and that the returns are sufficient to justify this.
Reference: [41] <author> Hinchey, M.G. & Cahill, </author> <title> A: Towards a Canonical Specification of Document Structures. </title> <booktitle> In Proceedings ACM SIGDOC'92, 10th International Conference on System Documentation, </booktitle> <address> Ottawa, Canada, 13-16 October 1992. </address> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1992, </year> <pages> pp 297-307. </pages>
Reference-contexts: Such techniques have proven to be useful in developing a software architecture for a family of oscilloscopes [32], and for such diverse activities as formally specifying the algorithm employed in a single-transferable voting system [52], describing the structure of documents <ref> [21, 41] </ref> and highlighting inconsistencies in the design of the World Wide Web [59]. 2. Formal Development/Verification Full formal development is, as yet, rarely undertaken [9].
Reference: [42] <author> Hinchey, M.G. & Jarvis, S.A.: </author> <title> Concurrent Systems: Formal Development in CSP. </title> <booktitle> McGraw-Hill International Series in Software Engineering, </booktitle> <publisher> In press. </publisher>
Reference-contexts: Languages with small `vocabularies' on the other hand, while generally resulting in longer specifications, offer high levels of abstraction and little implementation bias. Consider Hoare's language of Communicating Sequential Processes (CSP) <ref> [42, 43] </ref>, for example. The only first-class entities are processes (or pipes and buffers, which are merely particular types 1 of process). CSP specifications can become quite lengthy as a result, but the fact that there are so few constructs with which to become familiar makes them readily understandable.
Reference: [43] <author> Hoare, </author> <title> C.A.R.: Communicating Sequential Processes. </title> <publisher> Prentice Hall International Series in Computer Science, </publisher> <year> 1985. </year>
Reference-contexts: Languages with small `vocabularies' on the other hand, while generally resulting in longer specifications, offer high levels of abstraction and little implementation bias. Consider Hoare's language of Communicating Sequential Processes (CSP) <ref> [42, 43] </ref>, for example. The only first-class entities are processes (or pipes and buffers, which are merely particular types 1 of process). CSP specifications can become quite lengthy as a result, but the fact that there are so few constructs with which to become familiar makes them readily understandable. <p> There are also a number of theorem provers and support environments that incorporate theorem provers for methods such as B [1] (e.g., the B toolkit from B-Core), CSP <ref> [43] </ref> (e.g., FDR from Formal Systems (Europe) Ltd.), RAISE [58] (from CRI), VDM [45] (e.g., the VDM Toolbox from IFAD) and Z [62] (e.g., Balzac/Zola from Imperial Software Technology, and ProofPower from ICL).
Reference: [44] <author> Houston, I.S.C. & King, S.: </author> <title> CICS Project Report: Experiences and Results from the Use of Z in IBM. </title> <editor> In Prehn S. & Toetenel, W.J. (eds.), VDM'91: </editor> <booktitle> Formal Software Development Methods, </booktitle> <publisher> Springer-Verlag, LNCS 551, </publisher> <year> 1991, </year> <pages> pp 588-596. </pages>
Reference-contexts: In the second case an estimated 9% was saved in the development costs for part of the very large IBM CICS transaction processing system by using the Z notation to respecify the software, resulting in a reduction of errors and an increase in quality of the code produced <ref> [44, 56] </ref>. The fact that a number of formal methods projects have come in over-budget is not evidence that they are more expensive, but rather that we are, as yet, inexperienced in estimating costs [13]. A number of models have been produced for project cost and project development time estimation. <p> It appears to be very difficult to learn to use formal methods successfully without such help until sufficient local expertise has been built up to make this unnecessary. Examples where this has been the case include the IBM CICS project <ref> [44] </ref> and the Inmos T800 floating point unit for the Transputer [49]. In the case of IBM, the formal methods experts spent months at a time on-site. Training courses were set up and gradually a significant number of people at IBM became fluent in the application of formal techniques.
Reference: [45] <author> Jones, C.B.: </author> <title> Systematic Software Development Using VDM. </title> <booktitle> Prentice Hall International Series in Computer Science, 2nd edition, </booktitle> <year> 1991. </year>
Reference-contexts: There are also a number of theorem provers and support environments that incorporate theorem provers for methods such as B [1] (e.g., the B toolkit from B-Core), CSP [43] (e.g., FDR from Formal Systems (Europe) Ltd.), RAISE [58] (from CRI), VDM <ref> [45] </ref> (e.g., the VDM Toolbox from IFAD) and Z [62] (e.g., Balzac/Zola from Imperial Software Technology, and ProofPower from ICL). Quite a lot of interest has also focused lately on tailoring theorem provers for use with specific methods.
Reference: [46] <author> Lamport, L.: TLZ. </author> <booktitle> In [12], </booktitle> <pages> pp 267-268. </pages>
Reference-contexts: This has resulted in much research aimed at integrating process algebras with model-based specification languages (e.g., [63, 68]) and extending model-based specification languages to handle concurrency and temporal aspects (e.g., <ref> [46] </ref>). It is important to choose a well established notation with a good user base to ensure successful application in an industrial setting. Typically the development of a formal notation for industrial use takes at least a decade from conception to real application.
Reference: [47] <author> Larsen, P.G., Plat, N. & Toetenel, H.: </author> <title> A Formal Semantics of Data Flow Diagrams, </title> <journal> Formal Aspects of Computing, </journal> <note> to appear. </note>
Reference: [48] <author> Martin, A.: </author> <title> Encoding W: A Logic for Z in 2OBJ. </title> <booktitle> In [67], </booktitle> <pages> pp 462-481. </pages>
Reference-contexts: Quite a lot of interest has also focused lately on tailoring theorem provers for use with specific methods. For example, theorem provers for Z have been developed in EVES [61], HOL [11], and OBJ <ref> [48] </ref>. Each of these three levels is useful in itself. One must determine, however, whether the additional cost (in time, effort, manpower, tool support, etc.) is justified before embarking on full formal development and machine-checked proofs.
Reference: [49] <author> May, D., Barrett, G. & Shepherd, D.: </author> <title> Designing Chips that Work. In Hoare, C.A.R. & Gordon, M.J.C., Mechanized Reasoning and Hardware Design. </title> <publisher> Prentice Hall International Series in Computer Science, </publisher> <year> 1992. </year>
Reference-contexts: Auditors checked for the financial benefits gained as part of the award process. In the first, an estimated 12 months reduction in testing time was gained in the development of the Inmos floating-point unit for the T800 Transputer by formally developing the microcode using machine-supported algebraic techniques <ref> [49] </ref>. <p> Examples where this has been the case include the IBM CICS project [44] and the Inmos T800 floating point unit for the Transputer <ref> [49] </ref>. In the case of IBM, the formal methods experts spent months at a time on-site. Training courses were set up and gradually a significant number of people at IBM became fluent in the application of formal techniques.
Reference: [50] <author> McCracken, D.D. & Jackson, M.A.: </author> <title> Life Cycle Concept Considered Harmful. </title> <journal> ACM Software Engineering Notes, </journal> <volume> 7(2) </volume> <pages> 28-32, </pages> <year> 1982. </year>
Reference-contexts: Ideally all inconsistencies will be discovered during implementation, or at worst during post-implementation testing. However, in extreme cases, errors in the system specification may be uncovered during post-implementation execution. System development is not so simple as the model proposed by Royce <ref> [33, 50] </ref>, but rather an iterative and non-linear process as exemplified by Boehm's `Spriral' model [6].
Reference: [51] <author> Milner, R.: </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall International Series in Computer Science, </publisher> <year> 1989. </year>
Reference-contexts: A process algebra such as CSP or CCS <ref> [51] </ref> is generally far more appropriate; but these suffer from the drawback of paying very little attention to state-based aspects of the system.
Reference: [52] <author> Mukherjee, P. & Wichmann, </author> <title> B.A.: Formal Specification of the STV Algorithm. </title> <booktitle> In [40]. </booktitle>
Reference-contexts: Such techniques have proven to be useful in developing a software architecture for a family of oscilloscopes [32], and for such diverse activities as formally specifying the algorithm employed in a single-transferable voting system <ref> [52] </ref>, describing the structure of documents [21, 41] and highlighting inconsistencies in the design of the World Wide Web [59]. 2. Formal Development/Verification Full formal development is, as yet, rarely undertaken [9].
Reference: [53] <editor> Normington, G.: Cleanroom and Z. In Bowen, J.P. & Nicholls, J.E. (eds.), </editor> <booktitle> Z User Workshop, </booktitle> <address> London 1992, </address> <publisher> Springer-Verlag, Workshops in Computing, </publisher> <year> 1993, </year> <pages> pp 281-293. </pages>
Reference-contexts: The pragmatic view is that real programs are too large to be formally proven correct, so 7 they must be written correctly in the first place! The possibility of combining Cleanroom techniques and formal methods has been investigated <ref> [53] </ref>. Sometimes it is possible to combine different formal methods together usefully and effectively. For example, HOL [35] has been used to provide tool support for Z [11].
Reference: [54] <author> Owre, S., Rushby, J.M. and Shankar, N.: PVS: </author> <title> A Prototype Verification System. </title> <editor> In Kapur, D. (ed.), </editor> <booktitle> Automated Deduction - CADE-11, </booktitle> <publisher> Springer-Verlag, LNAI 607, </publisher> <year> 1992, </year> <pages> pp 748-752. </pages>
Reference-contexts: A number of formal methods incorporate theorem provers as part of the method itself. In this category we naturally include HOL [35], Larch [36] (with LP, the Larch Prover), Nqthm [18], OBJ [34] and PVS <ref> [54] </ref>.
Reference: [55] <author> Parnas, D.L. & Madey, J.: </author> <title> Functional Documentation for Computer Systems Engineer--ing. </title> <type> Version 2, CRL Report No. 237, TRIO, </type> <institution> Communications Research Laboratory, Faculty of Engineering, McMaster University, Hamilton, </institution> <address> Ontario, Canada L8S 4K1, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: An important part of a designed system is its documentation, particularly if subsequent changes are required. Formalizing the documentation leads to less ambiguity and thus less likelihood of errors. In the case of safety-critical systems, timing issues become significant and methods for documenting these are especially important <ref> [55] </ref>. Formal methods provide a precise and unambiguous way of recording the expected and delivered system functionality, and can therefore be used as a powerful documentation aid.
Reference: [56] <author> Phillips, M.: </author> <title> CICS/ESA 3.1 Experiences. </title> <editor> In Nicholls, J.E. (ed.), </editor> <booktitle> Z User Workshop, </booktitle> <address> Oxford 1989, </address> <publisher> Springer-Verlag, Workshops in Computing, </publisher> <year> 1990, </year> <pages> pp 179-185. </pages>
Reference-contexts: This still resulted in 100,000s of lines of code and thousands of pages of specifications, and having saved 9% over costs using conventional methods (confirmed by independent audit) is often cited as a major application of formal methods <ref> [56] </ref>. Having determined that one really does need formal methods, and having chosen an appropriate notation and identified those components of the system that will benefit from a formal treatment, one must next consider the level to which formal methods will be employed. We identify three such levels: 1. <p> In the second case an estimated 9% was saved in the development costs for part of the very large IBM CICS transaction processing system by using the Z notation to respecify the software, resulting in a reduction of errors and an increase in quality of the code produced <ref> [44, 56] </ref>. The fact that a number of formal methods projects have come in over-budget is not evidence that they are more expensive, but rather that we are, as yet, inexperienced in estimating costs [13]. A number of models have been produced for project cost and project development time estimation.
Reference: [57] <author> Polack, F. & Mander, K.C.: </author> <title> Software Quality Assurance using the SAZ Method. </title> <booktitle> In [12], </booktitle> <pages> pp 230-249. </pages>
Reference-contexts: One way to do this is to investigate how an existing formal method can be combined effectively with an existing structured method already in use within industry. One attempt to do this is the "SAZ" method, a combination of SSADM and Z <ref> [57] </ref>. Of course structured methods and formal methods each have their strengths and weaknesses and ideally the combination of the two should make the most of the benefits of both.
Reference: [58] <author> The RAISE Language Group: </author> <title> The RAISE Specification Language. </title> <publisher> Prentice Hall, BCS Practitioner Series, </publisher> <year> 1992. </year>
Reference-contexts: There are also a number of theorem provers and support environments that incorporate theorem provers for methods such as B [1] (e.g., the B toolkit from B-Core), CSP [43] (e.g., FDR from Formal Systems (Europe) Ltd.), RAISE <ref> [58] </ref> (from CRI), VDM [45] (e.g., the VDM Toolbox from IFAD) and Z [62] (e.g., Balzac/Zola from Imperial Software Technology, and ProofPower from ICL). Quite a lot of interest has also focused lately on tailoring theorem provers for use with specific methods.
Reference: [59] <author> Relihan, L., Cahill, A., & Hinchey, M.G.: </author> <title> Untangling the (World-Wide) Web. </title> <booktitle> In Proc. </booktitle> <address> SIGDOC'94, Banff, Canada, </address> <month> October </month> <year> 1994, </year> <note> to appear. </note>
Reference-contexts: proven to be useful in developing a software architecture for a family of oscilloscopes [32], and for such diverse activities as formally specifying the algorithm employed in a single-transferable voting system [52], describing the structure of documents [21, 41] and highlighting inconsistencies in the design of the World Wide Web <ref> [59] </ref>. 2. Formal Development/Verification Full formal development is, as yet, rarely undertaken [9].
Reference: [60] <author> Royce, </author> <title> W.W.: Managing the Development of Large Software Systems. </title> <booktitle> In Proc. </booktitle> <address> WEST-CON'70, </address> <month> August </month> <year> 1970. </year> <booktitle> Reprinted in Proc. 9th International Conference on Software Engineering, </booktitle> <publisher> IEEE Press, </publisher> <year> 1987. </year>
Reference-contexts: System development is by no means a straight-forward 9 one-pass process. Royce's `Waterfall' model <ref> [60] </ref> of system development was abandoned be-cause of the simplistic view it held of system development. Every developer has experienced the need to revisit requirements and to rework the specification at various stages in the development. Ideally all inconsistencies will be discovered during implementation, or at worst during post-implementation testing.
Reference: [61] <editor> Saaltink, M.: Z and Eves. In Nicholls, J.E. (ed.), </editor> <booktitle> Z User Workshop, </booktitle> <address> York 1991, </address> <publisher> Springer-Verlag, Workshops in Computing, </publisher> <year> 1992, </year> <pages> pp 233-242. </pages>
Reference-contexts: Quite a lot of interest has also focused lately on tailoring theorem provers for use with specific methods. For example, theorem provers for Z have been developed in EVES <ref> [61] </ref>, HOL [11], and OBJ [48]. Each of these three levels is useful in itself. One must determine, however, whether the additional cost (in time, effort, manpower, tool support, etc.) is justified before embarking on full formal development and machine-checked proofs.
Reference: [62] <author> Spivey, J.M.: </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> Prentice Hall International Series in Computer Science, 2nd edition, </booktitle> <year> 1992. </year>
Reference-contexts: The vocabulary is not the only issue to consider, however. Some specification languages are just not as good as others when used with particular classes of system. Trying to specify a concurrent system in a model-based specification language such as Z <ref> [62] </ref> or VDM, for example, is rather like using a hammer to insert a screw : : : it can be done, but it is certainly not the best way to go about things. <p> There are also a number of theorem provers and support environments that incorporate theorem provers for methods such as B [1] (e.g., the B toolkit from B-Core), CSP [43] (e.g., FDR from Formal Systems (Europe) Ltd.), RAISE [58] (from CRI), VDM [45] (e.g., the VDM Toolbox from IFAD) and Z <ref> [62] </ref> (e.g., Balzac/Zola from Imperial Software Technology, and ProofPower from ICL). Quite a lot of interest has also focused lately on tailoring theorem provers for use with specific methods. For example, theorem provers for Z have been developed in EVES [61], HOL [11], and OBJ [48].
Reference: [63] <author> Toetenel, H.: </author> <title> VDM + CCS + Time = MOSCA. </title> <booktitle> In 18th IFAC/IFIP Workshop on Real-Time Programming - WRTP'92, </booktitle> <address> Bruges, Belgium, 23-26 June 1992. </address> <publisher> Pergamon Press, </publisher> <year> 1992. </year>
Reference-contexts: A process algebra such as CSP or CCS [51] is generally far more appropriate; but these suffer from the drawback of paying very little attention to state-based aspects of the system. This has resulted in much research aimed at integrating process algebras with model-based specification languages (e.g., <ref> [63, 68] </ref>) and extending model-based specification languages to handle concurrency and temporal aspects (e.g., [46]). It is important to choose a well established notation with a good user base to ensure successful application in an industrial setting.
Reference: [64] <author> Weber-Wulff, D.: </author> <title> Selling Formal Methods to Industry. </title> <booktitle> In [67], </booktitle> <pages> pp 671-678. </pages>
Reference-contexts: We have not yet applied formal methods to a sufficient number of projects to determine trends, and many formal methods projects are in very specialized domains that are unlikely to be addressed very regularly, and are hence very unrepresentative. Greater attention to technology transfer <ref> [64] </ref> and surveys of formal development [24, 25] will eventually provide us with the levels of detail we require. Elsewhere [40] we attempt to consolidate much of this information in an industrially useful way.
Reference: [65] <author> Whitty, R. </author> <title> Structural Metrics for Z Specifications. In Nicholls, J.E., Z Users Meeting, </title> <publisher> Oxford 1989, Springer-Verlag, Workshops in Computing, </publisher> <year> 1990, </year> <pages> pp 186-191. </pages>
Reference-contexts: Although there have been a number of approaches suggested for obtaining metrics from formal specifications (e.g., <ref> [65] </ref>), these have not as yet been extended to usable models for cost estimation. As yet, we must rely on models developed before formal methods became widely-used.
Reference: [66] <author> Wing, J.M: </author> <title> A Specifier's Introduction to Formal Methods. </title> <journal> IEEE Computer, </journal> <volume> 23(9) </volume> <pages> 8-24, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Many of these claims are quite valid | different specification languages do indeed excel when used with particular classes of system. There is always, necessarily, a certain degree of trade-off between the expressiveness of a specification language, and the levels of abstraction that it supports <ref> [66] </ref>. Certain languages may indeed have wider `vocabularies' and constructs to support the particular situations we wish to deal with. But, they will also force us towards particular implementations, and while they will shorten the specification, they generally make it less abstract.
Reference: [67] <editor> Woodcock, J.C.P. & Larsen, P.G. (eds.): FME'93: </editor> <title> Industrial-Strength Formal Methods. </title> <publisher> Springer-Verlag, LNCS 670, </publisher> <year> 1993. </year>
Reference: [68] <author> Woodcock, J.C.P. & Morgan, </author> <title> C.C.: Refinement of State-based Concurrent Systems. </title> <editor> In Bjorner, D., Hoare, C.A.R. & Langmaack, H. (eds.), </editor> <title> VDM and Z Formal Methods in Software Development. </title> <publisher> Springer-Verlag, LNCS 428, </publisher> <year> 1990, </year> <title> pp 340-351. 18 `Can't I just read your URL?' For readers with access to the World-Wide Web global hypermedia system on the Internet, the following WWW page may be of interest: http://www.comlab.ox.ac.uk/archive/formal-methods.html This provides hyperlinks to many on-line repositories of information relevant to formal methods, including some freely available tools, around the world. </title>
Reference-contexts: A process algebra such as CSP or CCS [51] is generally far more appropriate; but these suffer from the drawback of paying very little attention to state-based aspects of the system. This has resulted in much research aimed at integrating process algebras with model-based specification languages (e.g., <ref> [63, 68] </ref>) and extending model-based specification languages to handle concurrency and temporal aspects (e.g., [46]). It is important to choose a well established notation with a good user base to ensure successful application in an industrial setting.
References-found: 68

