URL: http://http.cs.berkeley.edu/~halw/goppa_STOC.ps
Refering-URL: http://http.cs.berkeley.edu/~halw/
Root-URL: 
Title: Decoding Algebraic-Geometric Codes Beyond the Error-Correction Bound  
Author: M. Amin Shokrollahi Hal Wasserman 
Address: 1947 Center Street Berkeley, CA 94704  Berkeley, CA 94720  
Affiliation: International Computer Science Institute  Computer Science Division University of California at Berkeley  
Abstract: Generalizing the high-noise decoding methods of [1, 19] to the class of algebraic-geometric codes, we design the first polynomial-time algorithms to decode algebraic-geometric codes significantly beyond the conventional error-correction bound. Applying our results to codes obtained from curves with many rational points, we construct arbitrarily long, constant-rate linear codes over a fixed field F q such that a codeword is efficiently, non-uniquely reconstructible after a majority of its letters have been arbitrarily corrupted. We also construct codes such that a codeword is uniquely and efficiently reconstructible after a majority of its letters have been corrupted by noise which is random in a specified sense. We summarize our results in terms of bounds on asymptotic parameters, giving a new characterization of decoding beyond the error-correction bound. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Ar, R. Lipton, R. Rubinfeld, and M. Sudan. </author> <title> Reconstructing algebraic functions from mixed data. </title> <booktitle> In Proc. 33rd FOCS, </booktitle> <pages> pages 503-512, </pages> <year> 1992. </year>
Reference-contexts: For example, any [n; k; d] q -code is an <ref> [n; k; b (d 1)=2c; 1] </ref> q -code. <p> It is well known that one can decode Reed-Solomon codes up to the error-correction bound [2, 24, 3] and indeed even slightly beyond the error-correction bound [24, 3, 5, 17]. Approaching this as a problem in high-noise polynomial reconstruction, <ref> [1, 19] </ref> have derived potentially stronger results: in particular, the surprising result of [19] that a Reed-Solomon [n; k] q -code is an [n; k; e; b] q -code such that e is approximately n p approximately p 2n=k. <p> Most of these algorithms fail if the number of errors exceeds the designed error-correction bound b (d fl 1)=2c, and all of them fail if the number of errors exceeds the true error-correction bound b (d 1)=2c. Here we generalize the high-noise decoding methods of <ref> [1, 19] </ref> to the class of AG-codes. Our main result is as follows: Theorem 1.2 Let C be an [n; k; d] q -AG-code built over an algebraic function field K of genus g. Let ff := k + g 1 and fi := 2ffn+g1 . <p> The bottleneck of our main algorithm is the factorization routine. In Section 5 we derive for small b variants of our general algorithm in which the factorization step has been eliminated. One variant corresponds to the case of decoding <ref> [n; k; e; 1] </ref> q -codes (i.e., conventional decoding). It is slightly less powerful than existing AG-decoding algorithms, as it can correct only up to b (d fl 1)=2c g errors. It may be regarded as a simplified variant of the basic algorithm for AG-decoding of [13]. <p> Moreover, we prove in Section 6 that, if a large fraction of the letters of a codeword are corrupted by noise which is random in a specified sense, it may be possible to uniquely decode. This inspires us to speak of an <ref> [n; k; e; 1] </ref> p q -code, which is defined to be an [n; k] q code such that, with probability of failure at most p, a codeword may be uniquely reconstructed after up to e of its letters have been replaced with uniform-random letters. <p> We demonstrate that there exist arbitrarily long, constant-rate <ref> [n; k; e; 1] </ref> p q -AG-codes over a fixed field F q such that e is close to n while p is very small. We also specify a corresponding decoding algorithm, which does not require polynomial factorization and hence is particularly efficient. <p> In Section 7 we investigate asymptotic properties of [n; k; e; b] q codes. We define analogues of the function ff q [15, Def. 5.1.2] for our new classes of [n; k; e; b] q -codes and <ref> [n; k; e; 1] </ref> p q -codes, and derive lower bounds for these functions by creating asymptotically good sequences of AG-codes. <p> PROOF. The proof is as for Theorem 1.2, except that we use s := b and the new value of fi. 2 3 The cases b = 1 and b = 2 of the above theorem will be of particular interest. Recall that <ref> [n; k; e; 1] </ref> q -codes are those for which a codeword may be conventionally (i.e., uniquely) reconstructed after the corruption of up to e letters. Therefore, we will refer to the case b = 1 as the unique reconstruction case. <p> We start with the unique reconstruction case. Setting b = 1 in Theorem 5.1 yields the following: Corollary 5.2 Let C be an [n; k; d] q -AG-code built over an algebraic function field of genus g, and let ff := k + g 1. Then C is an <ref> [n; k; b (n ff 1)=2c g; 1] </ref> q -code. We saw in Section 2 that C has designed distance d fl = n ff, and thus has designed error-correction bound e fl := b (d fl 1)=2c = b (n ff 1)=2c. <p> Here we will demonstrate that, if noise is assumed to be random in a specified sense, then a codeword x may be uniquely reconstructed from its highly noisy corruption y. We fix the following definition: Definition 6.1 An <ref> [n; k; e; 1] </ref> p q -code is an [n; k] q -code such that, after up to e letters of a codeword have been replaced with uniform-random letters, the codeword may be uniquely reconstructed, with probability of failure at most p. <p> Let ff := k + g 1 and fi := ffn + g 1 . Then for any ffi &gt; 0, C is an <ref> [n; k; e; 1] </ref> p q code, where e := bn ffin 2fi fin=(ffq) ff 2g 1c; (6.1) p := 2 exp (ffi n=2) + 2 exp (ffi n): (6.2) Moreover, the associated decoding task can be accomplished efficiently, and without having to carry out polynomial factorization. PROOF. <p> Theorem 6.2 then tells us that, using this field and picking n := 10 6 , k := 10 4 , ffi := 0:01, we can create an <ref> [n; k; 642790; 1] </ref> p 101 2 -code, where p is less than 10 21 . <p> We also set S ! q := b=1 S b q . We similarly define S R q to be the set of all (*; R) such that for any n 0 2 N there exist <ref> [n; k; e; 1] </ref> p q -codes for which n n 0 , (e=n; k=n) is arbitrarily close to (*; R), and p is upper-bounded by an exponentially small function of n. <p> Observe that S 1 q is precisely the set of all (*; R) such that (2*; R) 2 S q . Furthermore, we have obvious inclusions S 1 q S R and S b q for b b 0 . The function ff q : <ref> [0; 1] </ref> ! [0; 1], defined in [15, Def. 5.1.2], describes the boundary of S q . To be precise, S q is the set of all (ffi; R) such that R ff q (ffi). <p> Observe that S 1 q is precisely the set of all (*; R) such that (2*; R) 2 S q . Furthermore, we have obvious inclusions S 1 q S R and S b q for b b 0 . The function ff q : <ref> [0; 1] </ref> ! [0; 1], defined in [15, Def. 5.1.2], describes the boundary of S q . To be precise, S q is the set of all (ffi; R) such that R ff q (ffi). <p> The true values of the new fi functions are evidently far from known. Section 8 will summarize open questions relating to these functions. 8 Conclusions and Open Problems We have extended the high-noise decoding methods of <ref> [1, 19] </ref> to algebraic-geometric codes. We have introduced [n; k; e; b] q -codes, and have demonstrated that there exist [n; k; e; b] q -AG-codes for which e is close to n while k=n is bounded away from zero and b is small. <p> In particular, for applications to asymptotically good AG-codes, it would be advantageous to derive an explicit construction of basis functions for each of the Garcia-Stichtenoth function fields (Section 4). Restricting ourselves to a model of random noise, we have also introduced <ref> [n; k; e; 1] </ref> p q -codes, and have demonstrated that there exist [n; k; e; 1] p q -AG-codes for which e is close to n while k=n is bounded away from zero and p is very small. <p> Restricting ourselves to a model of random noise, we have also introduced <ref> [n; k; e; 1] </ref> p q -codes, and have demonstrated that there exist [n; k; e; 1] p q -AG-codes for which e is close to n while k=n is bounded away from zero and p is very small. <p> In Section 7 we constructed asymptotically good sequences of [n; k; e; b] q -codes and <ref> [n; k; e; 1] </ref> p q -codes. We introduced the functions fi b q , fi ! q , which are natural variants of the well-known function ff q .
Reference: [2] <author> E.R. Berlekamp. </author> <title> Algebraic Coding Theory. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1968. </year>
Reference-contexts: It is well known that one can decode Reed-Solomon codes up to the error-correction bound <ref> [2, 24, 3] </ref> and indeed even slightly beyond the error-correction bound [24, 3, 5, 17]. <p> It may be regarded as a simplified variant of the basic algorithm for AG-decoding of [13]. It is of interest because of its extreme conceptual simplicity: its implementation only requires solving an nfi (n+1) system of linear equations. Another variant corresponds to the case of decoding <ref> [n; k; e; 2] </ref> q -codes. We find that the small increase from b = 1 to b = 2 leads to a substantial result, allowing us to reconstruct after a number of errors which may approach 2n=3.
Reference: [3] <author> E.R. Berlekamp. </author> <title> Bounded distance + 1 soft decision Reed Solomon decoding. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 42 </volume> <pages> 704-720, </pages> <year> 1996. </year>
Reference-contexts: It is well known that one can decode Reed-Solomon codes up to the error-correction bound <ref> [2, 24, 3] </ref> and indeed even slightly beyond the error-correction bound [24, 3, 5, 17]. <p> It is well known that one can decode Reed-Solomon codes up to the error-correction bound [2, 24, 3] and indeed even slightly beyond the error-correction bound <ref> [24, 3, 5, 17] </ref>. <p> But then h can only be u 0 =u 1 . Thus our algorithm in this case simplifies to a conventional decoding algorithm giving a unique solution. This simplified algorithm is indeed seen to be a natural extension of a well-known interpolation method for decoding Reed-Solomon codes <ref> [24, 3] </ref>. Comparing it to other AG-decoding algorithms, we observe it to be of interest because of its extreme conceptual simplicity: its implementation only requires solving an n fi (n + 1) system of linear equations.
Reference: [4] <author> H. Cohen. </author> <title> A Course in Computational Algebraic Number The ory, volume 138 of Graduate Texts in Mathematics. </title> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference: [5] <author> I.I. Dumer. </author> <title> Two algorithms for the decoding of linear codes. Problems Inform. </title> <journal> Transmission, </journal> <volume> 25 </volume> <pages> 17-23, </pages> <year> 1989. </year>
Reference-contexts: It is well known that one can decode Reed-Solomon codes up to the error-correction bound [2, 24, 3] and indeed even slightly beyond the error-correction bound <ref> [24, 3, 5, 17] </ref>.
Reference: [6] <author> D. Ehrhard. </author> <title> Achieving the designed error capacity in decod ing algebraic-geometric codes. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 39 </volume> <pages> 743-751, </pages> <year> 1993. </year>
Reference-contexts: The encoding algorithm for an AG-code is simple once one knows the n rational points and a basis for the functions to be evaluated. However, corresponding decoding algorithms are more complicated. Several such algorithms have recently appeared (e.g., <ref> [6, 7, 13] </ref>). These algorithms generally decode up to b (d fl errors, where ` is some integer between zero and the genus of the curve.
Reference: [7] <author> G.L. Feng and T.R.N. Rao. </author> <title> Decoding algebraic-geometric codes up to the designed minimum distance. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 39 </volume> <pages> 37-45, </pages> <year> 1993. </year>
Reference-contexts: The encoding algorithm for an AG-code is simple once one knows the n rational points and a basis for the functions to be evaluated. However, corresponding decoding algorithms are more complicated. Several such algorithms have recently appeared (e.g., <ref> [6, 7, 13] </ref>). These algorithms generally decode up to b (d fl errors, where ` is some integer between zero and the genus of the curve.
Reference: [8] <author> A. Garcia and H. Stichtenoth. </author> <title> A tower of Artin-Schreier exten sions of function fields attaining the Drinfeld-Vladut bound. </title> <journal> Invent. Math., </journal> <volume> 121 </volume> <pages> 211-222, </pages> <year> 1995. </year>
Reference-contexts: In Section 4, we apply Theorem 1.2 to codes obtained from a sequence of function fields with many prime divisors of degree one, thus constructing asymptotically good sequences of [n; k; e; b] q codes. Specifically, we choose to work with the explicit sequence of Garcia-Stichtenoth function fields <ref> [8] </ref>. We thereby prove that there exist arbitrarily long [n; k; e; b] q -codes over a fixed field F q such that e is close to n while the rate k=n is bounded away from zero and b is small. <p> Furthermore, in Sections 5-6 we will develop more efficient algorithms for certain cases. 4 Asymptotically Good [n; k; e; b] q -Codes Garcia and Stichtenoth <ref> [8] </ref> give an explicit sequence of function fields F m =F q 2 having more than q m1 (q 2 1) prime divisors of degree one and genus less than q m1 (q + 1).
Reference: [9] <author> J. von zur Gathen and E. Kaltofen. </author> <title> Factorization of multivari ate polynomials over finite fields. </title> <journal> Math. Comp., </journal> <volume> 45 </volume> <pages> 251-261, </pages> <year> 1985. </year>
Reference: [10] <author> O. Goldreich, R. Rubinfeld, and M. Sudan. </author> <title> Learning poly nomials with queries: the highly noisy case. </title> <booktitle> In Proc. 36th FOCS, </booktitle> <pages> pages 294-303, </pages> <year> 1995. </year>
Reference-contexts: Refer also to Appendix B, which verifies that the required polynomial factorization may be conveniently implemented in time poly (n; S). 2 Example 4.2 Using F m =F 101 2 and setting k := b0:01nc, we can create an <ref> [n; k; b0:79nc; 10] </ref> 101 2 -AG-code. Equivalently, we have specified an infinite sequence of constant-rate codes over F 101 2 such that, for each code, at most ten candidates for a codeword may be efficiently determined after 79% of its letters have been arbitrarily corrupted. <p> thus that corrupted letters can only be replaced with uniform-random members of F q . (Moreover, extensions to the case of near-uniform-random distributions over F q should be straightforward.) The existence of a unique solution in the presence of large quantities of random noise has been considered previously, e.g., in <ref> [10, Sec. 6] </ref>. Here we shall accompany our existence result with an efficient decoding algorithm. Indeed, this algorithm will have the advantage of being more efficient than our main algorithm of Section 3, as it will not require a polynomial-factorization step.
Reference: [11] <author> V.D. Goppa. </author> <title> Codes on algebraic curves. </title> <journal> Sov. Math. Dokl., </journal> <volume> 24 </volume> <pages> 170-172, </pages> <year> 1981. </year>
Reference-contexts: This motivates our interest in algebraic-geometric codes, a broad, important class which is perhaps the best known for creating asymptotically good [n; k; d] q -codes. Algebraic-geometric codes, or AG-codes, are based on algebraic curves over finite fields, following a construction of Goppa <ref> [11] </ref>. These codes can be viewed as a generalization of Reed-Solomon codes, for an AG-codeword is formed by evaluating at specified rational points a function in the function field of a curve. <p> An application of the Riemann-Roch Theorem proves that C is an [n; ff g + 1; d] q -code such that d is at least as large as designed distance d fl := n ff. For further information on AG-codes, refer to <ref> [11, 18, 20] </ref>. The encoding algorithm for an AG-code requires us to know a basis for L (ffQ). Such bases can be constructed in polynomial time in many cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [12].
Reference: [12] <author> M. Huang and D. Ierardi. </author> <title> Efficient algorithms for the Riemann-Roch problem and for addition in the Jacobian of a curve. </title> <journal> J. Symb. Comp., </journal> <volume> 18 </volume> <pages> 519-539, </pages> <year> 1994. </year>
Reference-contexts: The encoding algorithm for an AG-code requires us to know a basis for L (ffQ). Such bases can be constructed in polynomial time in many cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities <ref> [12] </ref>. <p> If the curve defined by the algebraic function field K is a plane curve with only ordinary singularities, then it follows from the work in <ref> [12] </ref> that S is polynomial in n, [K: L], and size (f ). Furthermore, in many practical cases (e.g., for elliptic or Hermitian function fields), the parameters q, [K: L], size (f ), and S are all polynomial in n; our algorithm then takes time poly (n).
Reference: [13] <author> J. Justesen, K.J. Larsen, A. Havemose, H.E. Jensen, and T. Hholdt. </author> <title> Construction and decoding of a class of algebraic geometry codes. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 35 </volume> <pages> 811-821, </pages> <year> 1989. </year>
Reference-contexts: The encoding algorithm for an AG-code is simple once one knows the n rational points and a basis for the functions to be evaluated. However, corresponding decoding algorithms are more complicated. Several such algorithms have recently appeared (e.g., <ref> [6, 7, 13] </ref>). These algorithms generally decode up to b (d fl errors, where ` is some integer between zero and the genus of the curve. <p> It is slightly less powerful than existing AG-decoding algorithms, as it can correct only up to b (d fl 1)=2c g errors. It may be regarded as a simplified variant of the basic algorithm for AG-decoding of <ref> [13] </ref>. It is of interest because of its extreme conceptual simplicity: its implementation only requires solving an nfi (n+1) system of linear equations. Another variant corresponds to the case of decoding [n; k; e; 2] q -codes. <p> We thank Iwan Duursma for his observation that, with a slightly more sophisticated argument, our algorithm can be adapted to decode up to e fl g=2 errors. With this adaptation, the algorithm becomes essentially equivalent to the basic algorithm for AG-decoding of <ref> [13] </ref>. The binary reconstruction case is based on the following special case of Theorem 5.1 for b = 2: Corollary 5.3 Let C be an [n; k; d] q -AG-code built over an algebraic function field K of genus g. Then C is an fi fl -code.
Reference: [14] <author> S. Lang. </author> <title> Algebra. </title> <publisher> Addison-Wesley, </publisher> <address> third edition, </address> <year> 1993. </year>
Reference: [15] <author> J.H. van Lint. </author> <title> Introduction to Coding Theory, volume 86 of Graduate Texts in Mathematics. </title> <publisher> Springer Verlag, </publisher> <year> 1982. </year>
Reference-contexts: We also specify a corresponding decoding algorithm, which does not require polynomial factorization and hence is particularly efficient. In Section 7 we investigate asymptotic properties of [n; k; e; b] q codes. We define analogues of the function ff q <ref> [15, Def. 5.1.2] </ref> for our new classes of [n; k; e; b] q -codes and [n; k; e; 1] p q -codes, and derive lower bounds for these functions by creating asymptotically good sequences of AG-codes. <p> Furthermore, we have obvious inclusions S 1 q S R and S b q for b b 0 . The function ff q : [0; 1] ! [0; 1], defined in <ref> [15, Def. 5.1.2] </ref>, describes the boundary of S q . To be precise, S q is the set of all (ffi; R) such that R ff q (ffi). <p> 6.2. 2 q 2 , fi ! q 2 when q is large. in the case that q is large. (Specifically, the figure was made for q = 101.) The figure also juxtaposes a simple upper bound on fi 1 q 2 , which was derived from the Plotkin bound <ref> [15, Thm. 5.2.5] </ref> via the evident identity fi 1 q (R) = 1 2 fi q (R). Observe that, when q is large, known upper and lower bounds on fi 1 q 2 nearly match.
Reference: [16] <author> R. Motwani and P. Raghavan. </author> <title> Randomized Algorithms. </title> <publisher> Cam bridge University Press, </publisher> <year> 1995. </year>
Reference: [17] <author> V.M. Sidel'nikov. </author> <title> Decoding the Reed-Solomon code when the number of errors is greater than (d 1)=2, and zeros of polynomials in several variables. Problems Inform. </title> <journal> Transmission, </journal> <volume> 30 </volume> <pages> 44-59, </pages> <year> 1994. </year>
Reference-contexts: It is well known that one can decode Reed-Solomon codes up to the error-correction bound [2, 24, 3] and indeed even slightly beyond the error-correction bound <ref> [24, 3, 5, 17] </ref>.
Reference: [18] <author> H. Stichtenoth. </author> <title> Algebraic Function Fields and Codes. </title> <publisher> Uni versitext. Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Finally, Section 8 gives conclusions and poses open problems. 2 AG-Codes Throughout this paper we will use the terminology of algebraic function fields, for which we refer the reader to <ref> [18] </ref>. Let K=F q be an algebraic function field of one variable with field of constants F q , genus g, and distinct prime divisors of degree one Q; P 1 ; : : : ; P n . Let ff be a non-negative integer less than n. <p> An application of the Riemann-Roch Theorem proves that C is an [n; ff g + 1; d] q -code such that d is at least as large as designed distance d fl := n ff. For further information on AG-codes, refer to <ref> [11, 18, 20] </ref>. The encoding algorithm for an AG-code requires us to know a basis for L (ffQ). Such bases can be constructed in polynomial time in many cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [12].
Reference: [19] <author> M. Sudan. </author> <title> Decoding of Reed-Solomon codes beyond the error-correction bound. </title> <journal> J. Compl., </journal> <volume> 13 </volume> <pages> 180-193, </pages> <year> 1997. </year>
Reference-contexts: It is well known that one can decode Reed-Solomon codes up to the error-correction bound [2, 24, 3] and indeed even slightly beyond the error-correction bound [24, 3, 5, 17]. Approaching this as a problem in high-noise polynomial reconstruction, <ref> [1, 19] </ref> have derived potentially stronger results: in particular, the surprising result of [19] that a Reed-Solomon [n; k] q -code is an [n; k; e; b] q -code such that e is approximately n p approximately p 2n=k. <p> Approaching this as a problem in high-noise polynomial reconstruction, [1, 19] have derived potentially stronger results: in particular, the surprising result of <ref> [19] </ref> that a Reed-Solomon [n; k] q -code is an [n; k; e; b] q -code such that e is approximately n p approximately p 2n=k. Hence e can be close to n while the rate k=n of the code is bounded away from zero and b is small. <p> Most of these algorithms fail if the number of errors exceeds the designed error-correction bound b (d fl 1)=2c, and all of them fail if the number of errors exceeds the true error-correction bound b (d 1)=2c. Here we generalize the high-noise decoding methods of <ref> [1, 19] </ref> to the class of AG-codes. Our main result is as follows: Theorem 1.2 Let C be an [n; k; d] q -AG-code built over an algebraic function field K of genus g. Let ff := k + g 1 and fi := 2ffn+g1 . <p> Suppose that y = (y 1 ; : : : ; y n ) 2 F n q is such that x and y agree in at least fi + 1 coordinate places. We will prove that the following algorithm (a generalization of that in <ref> [19] </ref>) computes a list of at most p codewords one of which must be x: 1. (INTERPOLATION STEP) Let s := b (fi g + 1)=ffc. <p> The true values of the new fi functions are evidently far from known. Section 8 will summarize open questions relating to these functions. 8 Conclusions and Open Problems We have extended the high-noise decoding methods of <ref> [1, 19] </ref> to algebraic-geometric codes. We have introduced [n; k; e; b] q -codes, and have demonstrated that there exist [n; k; e; b] q -AG-codes for which e is close to n while k=n is bounded away from zero and b is small.
Reference: [20] <author> M.A. Tsfasman and S.G. Vladut. </author> <title> Algebraic-Geometric Codes. Mathematics and Its Applications. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Dordrecht, </address> <year> 1991. </year>
Reference-contexts: An application of the Riemann-Roch Theorem proves that C is an [n; ff g + 1; d] q -code such that d is at least as large as designed distance d fl := n ff. For further information on AG-codes, refer to <ref> [11, 18, 20] </ref>. The encoding algorithm for an AG-code requires us to know a basis for L (ffQ). Such bases can be constructed in polynomial time in many cases, e.g., when the code is built over a plane algebraic curve with only ordinary singularities [12].
Reference: [21] <author> M.A. Tsfasman, S.G. Vladut, and Th. Zink. </author> <title> Modular curves, Shimura curves, and Goppa codes better than the Varshamov-Gilbert bound. </title> <journal> Math. Nachrichten, </journal> <volume> 109 </volume> <pages> 21-28, </pages> <year> 1982. </year>
Reference-contexts: We introduced the functions fi b q , fi ! q , which are natural variants of the well-known function ff q . We proved lower bounds analogous to the Tsfasman-Vl adut-Zink bound <ref> [21] </ref> for fi b q 2 , fi ! q 2 . However, these bounds do not appear to be tight. In particular, it would be of pragmatic interest to find lower bounds which are non-trivial when field size q is small or rate R is high.
Reference: [22] <author> A. Vardy. </author> <title> Algorithmic complexity in coding theory and the minimum distance problem. </title> <booktitle> In Proc. 29th STOC, </booktitle> <pages> pages 92-109, </pages> <year> 1997. </year>
Reference-contexts: The problem of decoding an arbitrary linear code up to the error-correction bound is NP-complete. (Refer to <ref> [22] </ref> for further discussion.) However, for many particular classes of codes, one can efficiently decode up to the error-correction bound. We shall hereafter refer to this as conventional or unique decoding. Here we shall be concerned with high-noise decoding, in which e is set higher than the error-correction bound.
Reference: [23] <author> H. Wasserman. </author> <title> Reconstructing randomly sampled multivari ate polynomials from highly noisy data. </title> <booktitle> In Proc. 9th SODA, </booktitle> <pages> pages 59-67, </pages> <year> 1998. </year>
Reference-contexts: Here we shall accompany our existence result with an efficient decoding algorithm. Indeed, this algorithm will have the advantage of being more efficient than our main algorithm of Section 3, as it will not require a polynomial-factorization step. The new algorithm (which extends a method of <ref> [23] </ref>) is suggested by the proof of Theorem 1.2. In that proof, one constructs a polynomial G such that G (P i ; y i ) = 0 for i = 1; : : : ; n.
Reference: [24] <author> L.R. Welch and E.R. Berlekamp. </author> <title> Error correction for algebraic block codes. </title> <type> U.S. Patent 4,633,470, issued Dec. 30, </type> <year> 1986. </year> <month> 6 </month>
Reference-contexts: It is well known that one can decode Reed-Solomon codes up to the error-correction bound <ref> [2, 24, 3] </ref> and indeed even slightly beyond the error-correction bound [24, 3, 5, 17]. <p> It is well known that one can decode Reed-Solomon codes up to the error-correction bound [2, 24, 3] and indeed even slightly beyond the error-correction bound <ref> [24, 3, 5, 17] </ref>. <p> But then h can only be u 0 =u 1 . Thus our algorithm in this case simplifies to a conventional decoding algorithm giving a unique solution. This simplified algorithm is indeed seen to be a natural extension of a well-known interpolation method for decoding Reed-Solomon codes <ref> [24, 3] </ref>. Comparing it to other AG-decoding algorithms, we observe it to be of interest because of its extreme conceptual simplicity: its implementation only requires solving an n fi (n + 1) system of linear equations.
References-found: 24

