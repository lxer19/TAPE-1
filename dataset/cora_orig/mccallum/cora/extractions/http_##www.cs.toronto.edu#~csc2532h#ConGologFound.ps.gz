URL: http://www.cs.toronto.edu/~csc2532h/ConGologFound.ps.gz
Refering-URL: http://www.cs.toronto.edu/~csc2532h/
Root-URL: http://www.cs.toronto.edu
Email: degiacomo@dis.uniroma1.it  lesperan@cs.yorku.ca  hector@cs.toronto.edu  
Title: ConGolog, a concurrent programming language based on the situation calculus: foundations  
Author: Giuseppe De Giacomo Yves Lesperance Hector J. Levesque 
Address: Via Salaria 113, 00198 Roma, Italy  Toronto, ON, Canada M3J 1P3  Toronto, ON, Canada M5S 3H5  
Affiliation: Dipartimento di Informatica e Sistemistica Universita di Roma "La Sapienza"  Department of Computer Science York University  Department of Computer Science University of Toronto  
Abstract: As an alternative to planning, an approach to high-level agent control based on concurrent program execution is considered. The language includes facilities for prioritizing the concurrent execution, interrupting the execution when certain conditions become true, and dealing with exogenous actions. The language differs from other procedural formalisms for concurrency in that the initial state can be incompletely specified and the primitive actions can be user-defined by axioms in the situation calculus. In a companion paper, a formal definition in the situation calculus of such a programming language is presented and illustrated with detailed examples. In this paper, the mathematical properties of the programming language are explored. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. R. Andrews, and F. B. Schneider. </author> <title> Concepts and notations for concurrent programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 15:1, </volume> <pages> 3-43, </pages> <year> 1983. </year>
Reference-contexts: Internal synchronization primitives are easily added. 7 constructs behave in a similar way to the test-and-set atomic instructions used to build semaphores in concurrent programming <ref> [1] </ref>. 5 The construct (ffi 1 k ffi 2 ) denotes the concurrent execution of the actions ffi 1 and ffi 2 . (ffi 1 ii ffi 2 ) denotes the concurrent execution of the actions ffi 1 and ffi 2 with ffi 1 having higher priority than ffi 2 .
Reference: [2] <author> M. E. Bratman, D. J. Israel, and M. E. Pollack. </author> <title> Plans and resource-bounded practical reasoning. </title> <journal> Computational Intelligence, </journal> <volume> 4, </volume> <pages> 349-355, </pages> <year> 1988. </year>
Reference-contexts: As mentioned in the introduction, an important motivation for the development of ConGolog is the need for "reactive" intelligent agent programs. In the companion paper [5], a comparison is made between ConGolog and agent architectures with similar goals such as IRMA <ref> [2] </ref> and PRS [20], as well as related agent programming languages such as AGENT-0 [23], Concurrent MetateM [9], and 3APL [12]. A prototype implementation of ConGolog in Prolog has been developed.
Reference: [3] <author> J. De Bakker and E. De Vink. </author> <title> Control Flow Semantics. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: The paper is self-contained in terms of definitions and theorems; motivation and examples, however, are to be found in the companion paper. Of course ours is not the first formal model of concurrency. In fact, well developed approaches are available <ref> [13, 17, 3, 24] </ref> 1 and our work inherits many of the intuitions behind them. However, it is distinguished from these in at least two fundamental ways. First, it allows incomplete information about the environment surrounding the program.
Reference: [4] <author> G. De Giacomo and X. Chen. </author> <title> Reasoning about nondeterministic and concurrent actions: A process algebra approach. </title> <booktitle> In Proceedings of the 13th National Conference on Artificial Intelligence (AAAI'96), </booktitle> <pages> pages 658-663, </pages> <year> 1996. </year>
Reference-contexts: Second, it allows the primitive actions (elementary instructions) to affect the environment in a complex way, and such changes to the environment can affect the execution of the remainder of the program. In con 1 In <ref> [19, 4] </ref> a direct use of such approaches to model concurrent (complex) actions in AI is investigated. 2 trast to typical computer programs whose elementary instructions are simple predefined statements (e.g. variable assignments), the primitive actions of a ConGolog program are determined by a separate domain-dependent action theory, which specifies the
Reference: [5] <author> G. De Giacomo, Y. Lesperance, and H. J. Levesque. ConGolog, </author> <title> a concurrent programming language based on the situation calculus: </title> <booktitle> language and implementation. </booktitle> <year> 1998. </year> <note> Submitted. </note>
Reference-contexts: We argue that a new programming language called ConGolog [6] provides just such an expressive formalism for high-level control. ConGolog is an extension to the Golog programming language [15] that incorporates a rich account of concurrency, including prioritized execution, interrupts, and exogenous actions. In the companion paper <ref> [5] </ref>, we explain and motivate ConGolog informally, review how the situation calculus and the solution to the frame problem proposed by Reiter [21] can be used to characterize the behavior of the application-dependent primitive actions, specify formally the execution semantics of ConGolog programs as axioms of the situation calculus, provide some <p> So in fact, we never have more than one primitive action happening at any given time. This assumption might appear problematic when the domain involves actions with extended duration (e.g. filling a bathtub). In the companion paper <ref> [5] </ref>, we discuss this issue and argue that in fact, there is a straightforward way to handle such cases. An important concept in understanding concurrent execution is that of a process becoming blocked. <p> See the companion paper <ref> [5] </ref> for an example of its use. Finally, &lt; OE ! ffi &gt; is an interrupt. It has two parts: a trigger condition OE and a body, ffi. The idea is that the body ffi will execute some number of times. <p> See the companion paper <ref> [5] </ref> for examples. 4.5 Trans fl The possible configurations that can be reached by a program ffi starting in a situation s are those obtained by repeatedly following the transition relation denoted by Trans starting from (ffi; s), i.e. those in the reflexive transitive closure of the transition relation. <p> Standard semantic accounts do not attempt to characterize dynamic properties of the external environment in which a program is executed [8]. As mentioned in the introduction, an important motivation for the development of ConGolog is the need for "reactive" intelligent agent programs. In the companion paper <ref> [5] </ref>, a comparison is made between ConGolog and agent architectures with similar goals such as IRMA [2] and PRS [20], as well as related agent programming languages such as AGENT-0 [23], Concurrent MetateM [9], and 3APL [12]. A prototype implementation of ConGolog in Prolog has been developed. <p> This is a limitation of the implementation, not the theory. Further details on the implementation as well as on a number of ConGolog applications can be found in the companion paper <ref> [5] </ref>. &gt;From a more theoretical point of view, there remain, however, many areas for future research.
Reference: [6] <author> G. De Giacomo, Y. Lesperance, and H. J. Levesque. </author> <title> Reasoning about concurrent execution, prioritized interrupts, </title> <booktitle> and exogenous actions in the situation calculus. In Proceedings of the 15th International Joint Conference on Artificial Intelligence (IJCAI'97), </booktitle> <pages> pages 1221-1226, </pages> <year> 1997. </year>
Reference-contexts: We argue that a new programming language called ConGolog <ref> [6] </ref> provides just such an expressive formalism for high-level control. ConGolog is an extension to the Golog programming language [15] that incorporates a rich account of concurrency, including prioritized execution, interrupts, and exogenous actions.
Reference: [7] <author> G. De Giacomo and H. J. Levesque. </author> <title> An Incremental Interpreter for High-Level Programs with Sensing. </title> <booktitle> In Cognitive Robotics Papers from the 1998 AAAI Fall Symposium, </booktitle> <pages> pages 28-34, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1998, </year> <note> Technical Report FS-98-02, AAAI Press. 28 </note>
Reference-contexts: Regarding (1), in <ref> [7] </ref>, we adapt the transition semantics developed in this paper so that execution can be interleaved with program interpretation in order to accommodate sensing actions.
Reference: [8] <author> M. Dixon. </author> <title> Embedded Computation and the Semantics of Programs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Stanford University, Stanford, </institution> <address> CA, </address> <year> 1991. </year> <note> Also appeared as Xerox PARC Technical Report SSL-91-1. </note>
Reference-contexts: Standard semantic accounts do not attempt to characterize dynamic properties of the external environment in which a program is executed <ref> [8] </ref>. As mentioned in the introduction, an important motivation for the development of ConGolog is the need for "reactive" intelligent agent programs.
Reference: [9] <author> M. Fisher. </author> <title> A survey of Concurrent MetateM the language and its applications. In D.M. </title> <editor> Gabbay and H.J. Ohlbach, editors, </editor> <booktitle> Temporal Logic Proceedings of the First International Conference (LNAI Volume 827), </booktitle> <pages> pp. 480-505, </pages> <publisher> Springer-Verlag, </publisher> <month> July, </month> <year> 1994. </year>
Reference-contexts: In the companion paper [5], a comparison is made between ConGolog and agent architectures with similar goals such as IRMA [2] and PRS [20], as well as related agent programming languages such as AGENT-0 [23], Concurrent MetateM <ref> [9] </ref>, and 3APL [12]. A prototype implementation of ConGolog in Prolog has been developed.
Reference: [10] <author> C. C. Green. </author> <title> Theorem proving by resolution as a basis for question-answering systems. </title> <booktitle> In Machine Intelligence, </booktitle> <volume> vol. 4, </volume> <pages> pages 183-205. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year>
Reference-contexts: For any domain theory of this sort, we have a very clean specification of the planning task, which dates back to the work of Green <ref> [10] </ref>: Classical Planning: Given a domain theory Axioms as above, and a goal formula OE (s) with a single free-variable s; the planning task is to find a sequence of actions ~a such that: Axioms j= Legal (~a; S 0 ) ^ OE (do (~a; S 0 )) where do ([a
Reference: [11] <author> M. Hennessy. </author> <title> The Semantics of Programming Languages. </title> <publisher> John Wiley & Sons, </publisher> <year> 1990. </year>
Reference-contexts: Semantics of this form are sometimes called evaluation semantics (see <ref> [11] </ref>), since they are based on the (complete) evaluation the program. When concurrency is taken into account it is more convenient to adopt semantics of a different form: the so-called transition semantics or computation semantics (see again [11]). <p> Semantics of this form are sometimes called evaluation semantics (see <ref> [11] </ref>), since they are based on the (complete) evaluation the program. When concurrency is taken into account it is more convenient to adopt semantics of a different form: the so-called transition semantics or computation semantics (see again [11]). Transition semantics are based on defining single steps of computation in contrast to directly defining complete computations.
Reference: [12] <author> K. V. Hindriks, F. S. de Boer, W. van der Hoek, and J.-J. Ch. Meyer. </author> <title> A formal semantics for an abstract agent programming language. In M.P. </title> <editor> Singh, A. Rao, and M.J. Wooldridge, editors, </editor> <booktitle> Proceedings of ATAL'97, LNAI 1365, </booktitle> <pages> pages 215-229, </pages> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: In the companion paper [5], a comparison is made between ConGolog and agent architectures with similar goals such as IRMA [2] and PRS [20], as well as related agent programming languages such as AGENT-0 [23], Concurrent MetateM [9], and 3APL <ref> [12] </ref>. A prototype implementation of ConGolog in Prolog has been developed.
Reference: [13] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: The paper is self-contained in terms of definitions and theorems; motivation and examples, however, are to be found in the companion paper. Of course ours is not the first formal model of concurrency. In fact, well developed approaches are available <ref> [13, 17, 3, 24] </ref> 1 and our work inherits many of the intuitions behind them. However, it is distinguished from these in at least two fundamental ways. First, it allows incomplete information about the environment surrounding the program.
Reference: [14] <author> D. Leivant. </author> <title> Higher order logic. </title> <booktitle> In Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <volume> vol. 2, </volume> <pages> pages 229-321. </pages> <publisher> Clarendon Press, </publisher> <year> 1994. </year>
Reference: [15] <author> H. J. Levesque, R. Reiter, Y. Lesperance, F. Lin, and R. B. Scherl. GOLOG: </author> <title> A logic programming language for dynamic domains. </title> <journal> In Journal of Logic Programming, </journal> <volume> 31, </volume> <pages> 59-84, </pages> <year> 1997. </year>
Reference-contexts: 1 Introduction When it comes to providing high-level control for robots or other agents in dynamic and incompletely known worlds, approaches based on plan synthesis may end up being too demanding computationally in all but simple settings. An alternative approach that is showing promise is that of high-level program execution <ref> [15] </ref>. The idea, roughly, is that instead of searching for a sequence of actions that would take the agent from an 1 initial state to some prespecified goal state, the task is to find a sequence of actions that constitutes a legal execution of some prespecified non-deterministic program. <p> We argue that a new programming language called ConGolog [6] provides just such an expressive formalism for high-level control. ConGolog is an extension to the Golog programming language <ref> [15] </ref> that incorporates a rich account of concurrency, including prioritized execution, interrupts, and exogenous actions. <p> task is to find a sequence of actions that is executable (each action is executed in a context where its precondition is satisfied) and that achieves the goal (the goal formula OE holds in the final state that results from performing the actions in sequence). 2.2 Golog As presented in <ref> [15] </ref>, Golog is a logic-programming language whose primitive actions are those of a background domain theory. <p> In <ref> [15] </ref>, Do (ffi; s; s 0 ) was simply viewed as an abbreviation for a formula of the situation calculus. The following inductive definition of Do was provided: 1. <p> Some appeal to second-order logic appears necessary here because transitive closure is not first-order definable, and nondeterministic iteration appeals to this closure. We have left out the expansion for procedures, which is somewhat more complex; see <ref> [15] </ref> for the details. 6 3 ConGolog We are now ready to define ConGolog, an extended version of Golog that incorporates a rich account of concurrency. We say `rich' because it handles: * concurrent processes with possibly different priorities, * high-level interrupts, * arbitrary exogenous actions. <p> In other words, Trans denotes a transition relation between configurations. A configuration is a pair formed by a program (the part of the initial program that is left to perform) and the 5 In <ref> [15] </ref> a non-synchronized version of if-then else and while-loop is introduced by defining: if OE then ffi 1 else ffi 2 def = [(OE?; ffi 1 ) j (:OE?; ffi 2 )] and while OE do ffi def = [(OE?; ffi) fl ; :OE?]. <p> For Golog programs such a definition for Do coincides with the one given in <ref> [15] </ref>. <p> following implications: Final (ffi; s) oe D (ffi; s; s) Trans (ffi; s; ffi 00 ; s 00 ) ^ D (ffi 00 ; s 00 ; s 0 ) oe D (ffi; s; s 0 ): 16 Theorem 1: Let Do 1 be the original definition of Do in <ref> [15] </ref>, presented in Section 2, and Do 2 the new one given above. <p> Observe also that all procedures in <ref> [15] </ref> satisfy such hypothesis, except for the procedure d at page 9 whose definition is reported below (n is a natural number): proc d (n) (n = 0?) j d (n 1); goDown end 26 However, the variants proc d (n) (n = 0?) j goDown; d (n 1) end proc
Reference: [16] <author> J. McCarthy and P. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <booktitle> In Machine Intelligence, </booktitle> <volume> vol. 4, </volume> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year>
Reference-contexts: An interpreter for such programs must reason about the preconditions and effects of actions in the program to find legal executions. So we need a language to specify such domain theories. For this, we use the situation calculus <ref> [16] </ref>, a first-order language (with some second-order features) for representing dynamic domains. 2.1 The Situation Calculus We will not go over the language in details here (see [22]) except to note the following components: there is a special constant S 0 used to denote the initial situation, namely that situation in
Reference: [17] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: The paper is self-contained in terms of definitions and theorems; motivation and examples, however, are to be found in the companion paper. Of course ours is not the first formal model of concurrency. In fact, well developed approaches are available <ref> [13, 17, 3, 24] </ref> 1 and our work inherits many of the intuitions behind them. However, it is distinguished from these in at least two fundamental ways. First, it allows incomplete information about the environment surrounding the program.
Reference: [18] <author> G. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI-FN-19, </type> <institution> Computer Science Department Aarhus University Denmark, </institution> <year> 1981. </year>
Reference-contexts: Indeed, nonterminating programs do not need any special treatment within transition semantics, while they typically remain undefined in evaluation semantics. In general, both evaluation semantics and transition semantics belong to the family of structural operational semantics introduced by Plotkin in <ref> [18] </ref>. Both of these forms of semantics are operational since they do not assign a meaning directly to the programs (as denotational semantics), but instead see programs simply as specifications of computations (or better as syntactic objects that specify the control flow of the computation).
Reference: [19] <author> D. Pym, L. Pryor, D. Murphy. </author> <title> Processes for plan-execution. </title> <booktitle> In Proceedings of the 14th Workshop of the UK Planning and Scheduling Special Interest Group, </booktitle> <year> 1995 </year>
Reference-contexts: Second, it allows the primitive actions (elementary instructions) to affect the environment in a complex way, and such changes to the environment can affect the execution of the remainder of the program. In con 1 In <ref> [19, 4] </ref> a direct use of such approaches to model concurrent (complex) actions in AI is investigated. 2 trast to typical computer programs whose elementary instructions are simple predefined statements (e.g. variable assignments), the primitive actions of a ConGolog program are determined by a separate domain-dependent action theory, which specifies the
Reference: [20] <author> A. S. Rao and M. P. Georgeff. </author> <title> An abstract architecture for rational agents. </title> <booktitle> In Proceedings of the 3rd International Conference on Principles of Knowledge Representation and Reasoning (KR'92), </booktitle> <editor> B. Nebel, C. Rich, and W. Swartout, editors, </editor> <address> pages 439-449, </address> <publisher> Morgan Kaufmann Publishing, </publisher> <year> 1992. </year>
Reference-contexts: As mentioned in the introduction, an important motivation for the development of ConGolog is the need for "reactive" intelligent agent programs. In the companion paper [5], a comparison is made between ConGolog and agent architectures with similar goals such as IRMA [2] and PRS <ref> [20] </ref>, as well as related agent programming languages such as AGENT-0 [23], Concurrent MetateM [9], and 3APL [12]. A prototype implementation of ConGolog in Prolog has been developed.
Reference: [21] <author> R. Reiter. </author> <title> The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression. </title> <booktitle> In Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 359-380. </pages> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: In the companion paper [5], we explain and motivate ConGolog informally, review how the situation calculus and the solution to the frame problem proposed by Reiter <ref> [21] </ref> can be used to characterize the behavior of the application-dependent primitive actions, specify formally the execution semantics of ConGolog programs as axioms of the situation calculus, provide some examples of high-level agent controllers written in ConGolog, present a simple interpreter for ConGolog written in Prolog, and finally prove the correctness <p> One possibility is a theory of the following form <ref> [21] </ref>: * Axioms describing the initial situation, S 0 . 3 * Action precondition axioms, one for each primitive action a, characterizing Poss (a; s). * Successor state axioms, one for each fluent F , stating under what conditions F (~x; do (a; s)) holds as function of what holds in <p> characterizing Poss (a; s). * Successor state axioms, one for each fluent F , stating under what conditions F (~x; do (a; s)) holds as function of what holds in situation s: These take the place of the so-called effect axioms, but also provide a solution to the frame problem <ref> [21] </ref>. * Unique names axioms for the primitive actions. * Some foundational, domain independent axioms.
Reference: [22] <author> R. Reiter. </author> <title> Knowledge in Action: Logical Foundation for Describing and Implementing Dynamical Systems. </title> <note> In preparation. 29 </note>
Reference-contexts: So we need a language to specify such domain theories. For this, we use the situation calculus [16], a first-order language (with some second-order features) for representing dynamic domains. 2.1 The Situation Calculus We will not go over the language in details here (see <ref> [22] </ref>) except to note the following components: there is a special constant S 0 used to denote the initial situation, namely that situation in which no actions have yet occurred; there is a distinguished binary function symbol do where do (a; s) denotes the successor situation to s resulting from performing <p> in the left-hand part of the equations, i.e.: and then getting the disjunction of all right-hand sides, which are mutually exclusive since each of them deals with programs of a specific form. &gt;From such definitions, natural "induction principles" emerge (cf. the discussion on extracting induction principles from inductive definitions in <ref> [22] </ref>).
Reference: [23] <author> Y. Shoham. </author> <title> Agent-oriented programming. </title> <journal> Artificial Intelligence, </journal> <volume> 60, </volume> <pages> 51-92, </pages> <year> 1993. </year>
Reference-contexts: In the companion paper [5], a comparison is made between ConGolog and agent architectures with similar goals such as IRMA [2] and PRS [20], as well as related agent programming languages such as AGENT-0 <ref> [23] </ref>, Concurrent MetateM [9], and 3APL [12]. A prototype implementation of ConGolog in Prolog has been developed.
Reference: [24] <author> C. Stirling. </author> <title> Modal and temporal logics for processes. In Logics for Concurrency: Structure versus Automata, </title> <publisher> LNCS 1043, </publisher> <pages> pages 149-237. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The paper is self-contained in terms of definitions and theorems; motivation and examples, however, are to be found in the companion paper. Of course ours is not the first formal model of concurrency. In fact, well developed approaches are available <ref> [13, 17, 3, 24] </ref> 1 and our work inherits many of the intuitions behind them. However, it is distinguished from these in at least two fundamental ways. First, it allows incomplete information about the environment surrounding the program.
Reference: [25] <author> A. Tarski. </author> <title> A lattice-theoretical fixpoint theorem and its applications. </title> <journal> Pacific Journal of Mathematics,5, </journal> <pages> 285-309, </pages> <year> 1955. </year> <month> 30 </month>
Reference-contexts: that F inal is monotonic 13 , i.e.: 8Z 1 ; Z 2 :[8ffi; s:Z 1 (ffi; s)oeZ 2 (ffi; s)] oe [8ffi; s: F inal (Z 1 ; ffi; s)oe F inal (Z 2 ; ffi; s):] Hence the thesis is a direct consequence of the Tarski-Knaster fixpoint theorem <ref> [25] </ref>. 2 For Trans an analogous result does not hold in general.
References-found: 25

