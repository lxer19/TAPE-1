URL: http://www.cs.tamu.edu/research/robotics/Wolter/papers/thesis.ps.Z
Refering-URL: http://www.cs.tamu.edu/research/robotics/Wolter/asp/bib.html
Root-URL: http://www.cs.tamu.edu
Title: On the Automatic Generation of Plans for Mechanical Assembly  
Author: Jan Dithmar Wolter 
Degree: Ph.D. Thesis  
Date: Sept 1988  
Affiliation: University of Michigan  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. Barber, R. A. Volz, R. S. Desai, R. Rubinfeld, B. Schipper, and J. D. Wolter. </author> <title> Automatic two-fingered grip selection. </title> <journal> IEEE Transactions on Robotics and Automation, </journal> <volume> 3(4) </volume> <pages> 356-360, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Basing these ratings only on size and mass is a little simple minded, though. If a more careful analysis were desired it would be possible to run a program that analyzes the parts for possible gripping positions <ref> [1, 48] </ref>, and give high ratings to parts with a large variety of stable grips. This could then be compared to a similar rating of how easily a part is fixtured.
Reference: [2] <author> T. O. Binford. </author> <title> The AL language for intelligent robots. </title> <booktitle> In IRIA Seminar on Lang. and Meth. of Prog. Indust. Robots, </booktitle> <pages> pages 73-87, </pages> <month> June </month> <year> 1979. </year>
Reference-contexts: To do this, the interpreter must have available a model of the robot to be used. More recently, task-level languages have been proposed (e.g. AUTOPASS [31], LAMA [32, 33], and later versions of AL <ref> [2, 20] </ref>). These typically describe actions purely by their effects on the parts, such as "thread nut A onto bolt B", rather than by the motions of the manipulator.
Reference: [3] <author> A. Bourjolt. </author> <title> Contribution a une approche methodologique de l'assemblage automatise: Elaboration automatique des sequences operatiores. </title> <type> PhD thesis, </type> <institution> L'Universite de Franche-Comte, </institution> <month> November </month> <year> 1984. </year>
Reference-contexts: A more detailed discussion of this approach will be given in section 3.2. De Fazio and Whitney have described an approach to generate all possible assembly plans for an assembly [14]. This work is based on a thesis by Bourjault <ref> [3] </ref>. These systems are not designed to be fully automatic. The operator must first indicate significant pairs of parts called "liaisons," and then must answer a series of queries concerning the sequence in which liaisons can be established.
Reference: [4] <author> J. W. Boyse. </author> <title> Interference detection amoung solids and surfaces. </title> <journal> CACM, </journal> <volume> 22(1) </volume> <pages> 3-9, </pages> <month> Jan </month> <year> 1979. </year>
Reference-contexts: This is because only an unconstrained part can be inserted last. As in the trajectory proposal stage, constraints can be obtained by geometry-based methods or knowledge-based methods. The geometric problem of testing for collisions has been well studied <ref> [4, 8, 9] </ref>. The most general of these algorithms is by Canny [9], who gives an algorithm for detecting all collisions when a three dimensional polyhedron is translating and rotating among obstacles. This requires O (N 2 log N ) time when N is the total complexity of the objects.
Reference: [5] <author> R. Brooks. </author> <title> Solving the find-path problem by good representation of free space. </title> <journal> IEEE Trans. on Systems, Man and Cybernetics, </journal> <volume> SMC-13(3):190-197, </volume> <month> March/April </month> <year> 1983. </year>
Reference-contexts: Several specialized algorithms to find paths have been proposed which approximate the obstacles <ref> [5, 6, 38] </ref>. However, because of the close tolerances involved in mating parts, accurate representations of parts and obstacles are essential in this application. Therefore many of these path-planning algorithms would not be suitable.
Reference: [6] <author> R. Brooks and T. Lozano-Perez. </author> <title> A subdivision algorithm in configuration space for find-path with rotation. </title> <journal> IEEE Trans. on Systems, Man and Cybernetics, </journal> <volume> SMC-15(2):224-233, </volume> <month> March/April </month> <year> 1985. </year>
Reference-contexts: Several specialized algorithms to find paths have been proposed which approximate the obstacles <ref> [5, 6, 38] </ref>. However, because of the close tolerances involved in mating parts, accurate representations of parts and obstacles are essential in this application. Therefore many of these path-planning algorithms would not be suitable.
Reference: [7] <author> C. M. Brown. PADL-2: </author> <title> A technical summary. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 2(2) </volume> <pages> 69-84, </pages> <month> March </month> <year> 1982. </year>
Reference-contexts: This is similar to the type of data produced by standard mechanical CAD systems such as those descended from BUILD [25] or PADL <ref> [7] </ref>. In addition to purely geometric information, the CAD data base should supply whatever subsidiary data is needed to build the assembly. In the example shown, the planner should be told how much the screw is to be tightened.
Reference: [8] <author> Stephen Cameron. </author> <title> A study of clash detection problems in robotics. </title> <booktitle> In IEEE Intl. Conf. on Robotics and Automation, </booktitle> <pages> pages 488-493, </pages> <year> 1985. </year>
Reference-contexts: This is because only an unconstrained part can be inserted last. As in the trajectory proposal stage, constraints can be obtained by geometry-based methods or knowledge-based methods. The geometric problem of testing for collisions has been well studied <ref> [4, 8, 9] </ref>. The most general of these algorithms is by Canny [9], who gives an algorithm for detecting all collisions when a three dimensional polyhedron is translating and rotating among obstacles. This requires O (N 2 log N ) time when N is the total complexity of the objects.
Reference: [9] <author> J. Canny. </author> <title> Collision detection for moving polyhedra. </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence, </journal> <volume> PAMI-8(2):200-209, </volume> <month> March </month> <year> 1986. </year>
Reference-contexts: This is because only an unconstrained part can be inserted last. As in the trajectory proposal stage, constraints can be obtained by geometry-based methods or knowledge-based methods. The geometric problem of testing for collisions has been well studied <ref> [4, 8, 9] </ref>. The most general of these algorithms is by Canny [9], who gives an algorithm for detecting all collisions when a three dimensional polyhedron is translating and rotating among obstacles. This requires O (N 2 log N ) time when N is the total complexity of the objects. <p> As in the trajectory proposal stage, constraints can be obtained by geometry-based methods or knowledge-based methods. The geometric problem of testing for collisions has been well studied [4, 8, 9]. The most general of these algorithms is by Canny <ref> [9] </ref>, who gives an algorithm for detecting all collisions when a three dimensional polyhedron is translating and rotating among obstacles. This requires O (N 2 log N ) time when N is the total complexity of the objects. This would have to be run for each trajectory of each part.
Reference: [10] <author> John F. Canny. </author> <title> A new algebraic method for robot motion planning and real geometry. </title> <booktitle> In 28th Ann. IEEE Symp. on Found. of Comp. Sci., </booktitle> <pages> pages 39-48, </pages> <month> Oct </month> <year> 1987. </year>
Reference-contexts: from P to Q and P Q to tree 8: call MAKETREE (Q) 9: call MAKETREE (P Q) 10: end parts P . whose complexity is O (N r log N ) where r is the number of degrees of freedom and N is the total complexity of the objects <ref> [10] </ref>. Several specialized algorithms to find paths have been proposed which approximate the obstacles [5, 6, 38]. However, because of the close tolerances involved in mating parts, accurate representations of parts and obstacles are essential in this application. Therefore many of these path-planning algorithms would not be suitable.
Reference: [11] <author> John F. Canny and John H. Reif. </author> <title> New lower bound techniques for robot motion planning problems. </title> <booktitle> In 28th Ann. IEEE Symp. on Found. of Comp. Sci., </booktitle> <pages> pages 49-60, </pages> <month> Oct </month> <year> 1987. </year>
Reference-contexts: It would seem natural, therefore, to use a standard path-planner to look for separation trajectories. Unfortunately, path planners are generally expensive to run. The problem of finding the shortest path between two points among polyhedral obstacles is known to be NP-hard <ref> [11] </ref>, though efficient algorithms are known for the two-dimensional problem [37, 42]. In this application we do not, however, need to find the shortest path | any reasonable path will suffice.
Reference: [12] <author> B. K. Choi, M. M. Barash, and D. C. Anderson. </author> <title> Automatic recognition of machined surfaces from a 3D solid model. </title> <booktitle> Computer-Aided Design, </booktitle> <volume> 16(2) </volume> <pages> 81-86, </pages> <month> March </month> <year> 1984. </year>
Reference-contexts: Of course, before this kind of high-level knowledge can be used to propose trajectories, it must be obtained from some source. Some research has been done on algorithms to identify features, such as tabs, slots and holes, from geometric models of parts <ref> [12, 23, 29] </ref>. It seems likely that such algorithms could be improved if they worked on assemblies rather than individual parts, since most interesting features are better defined as relationships between parts.
Reference: [13] <author> R. Dawson. </author> <title> On removing a ball without disturbing the others. </title> <journal> Mathematics Magazine, </journal> <volume> 57(1) </volume> <pages> 27-30, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: Dawson has shown that any collection of star-shaped parts in &lt; k , such as the one in figure 2.3, can be separated <ref> [13] </ref>. A part P i is star-shaped if it contains a point v i such that the line segment connecting any other point in P i to v i is wholely contained in P i . <p> But after that is done, no other rod can be translated in the same direction. Dawson has shown that, in fact, it is possible to arrange a set of convex parts so that no one part can be removed by any rigid motion without disturbing the others <ref> [13] </ref>. It can be shown that a general robot planner could be used to find a solution to any arbitrary assembly planning problem. This is not, in fact, surprising, since the assembly planning problem is less constrained.
Reference: [14] <author> Thomas L. De Fazio and Daniel E. Whitney. </author> <title> Simplified generation of all mechanical assembly sequences. </title> <journal> IEEE J. of Robotics and Automation, </journal> <volume> RA-3(6):640-658, </volume> <month> December </month> <year> 1987. </year>
Reference-contexts: They have not, however, described how to generate this data structure. A more detailed discussion of this approach will be given in section 3.2. De Fazio and Whitney have described an approach to generate all possible assembly plans for an assembly <ref> [14] </ref>. This work is based on a thesis by Bourjault [3]. These systems are not designed to be fully automatic. The operator must first indicate significant pairs of parts called "liaisons," and then must answer a series of queries concerning the sequence in which liaisons can be established.
Reference: [15] <author> Y. Descotte and J.-C. Latombe. </author> <title> Making compromises among antagonist constraints in a planner. </title> <journal> Artificial Intelligence, </journal> <volume> 27(2) </volume> <pages> 183-217, </pages> <year> 1985. </year> <month> 74 </month>
Reference-contexts: These differences make it difficult to adapt the approaches used in robot planners to the assembly planning problem. A more closely related problem is that of generating process-plans for machining industrial parts. This problem was solved by Descotte and Latombe with the GARI system <ref> [15] </ref>. GARI selects and sequences machining operations to make a given part, using a large set of weighted manufacturing rules to give (perhaps contradictory) advise on how the operations should be done.
Reference: [16] <author> S. E. Fahlman. </author> <title> A planning system for robot construction tasks. </title> <journal> Artificial Intelligence, </journal> <volume> 5 </volume> <pages> 1-49, </pages> <year> 1974. </year>
Reference-contexts: None of the robot planning systems that have been implemented are completely general. Most consider only insertion trajectories from a single direction (the exception is Fahlman's BUILD <ref> [16] </ref> system which doesn't check them at all). In assembly planning, it is usually necessary to consider many more trajectories. Among existing robot planners, only BUILD ever uses subassemblies, which are often necessary in real problems.
Reference: [17] <author> R. E. Fikes and N. J. Nilsson. </author> <title> STRIPS: A new approach to the application of theorem proving to problem solving. </title> <journal> Artificial Intelligence, </journal> 2(2/3):189-208, Winter 1971. 
Reference-contexts: The first robot planning system was described by Green in 1969 [21]. Since that time robot planning has been widely used as a sample problem domain for general purpose planning systems, such as STRIPS <ref> [17] </ref>, and NOAH [39], in studies of skill acquisition, such as HACKER [44], and in natural language understanding systems, such as Winograd's system [47].
Reference: [18] <author> Raphael A. Finkel, Russell Taylor, Robert C. Bolles, Richard P. Paul, and Jerome A. Feldman. </author> <title> An overview of AL. </title> <booktitle> In 4th Int'l Joint Conf. on AI, </booktitle> <pages> pages 758-765, </pages> <year> 1975. </year>
Reference-contexts: Programs in joint-level languages can be directly executed by a robot. Most currently used robot languages are manipulator-level languages (e.g. VAL [43], AML [45], WAVE [35], and older versions of AL <ref> [18] </ref>), which describe only the motion of the end effector. Programs in manipulator-level languages must be converted into joint-level programs before being executed. As shown in figure 1.1, this requires the solution of the kinematics and, preferably, dynamics of the robot arm.
Reference: [19] <author> Michael R. Garey and David S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: The cardinality of this set would be a good optimistic estimate of the number of directions that will be used by the best plan solving the ACG. Unfortunately, generating such a minimal set is the HITTING SET problem, which is known to be NP-complete <ref> [19] </ref>. Since an estimate must be made for every node in the search tree, this approach is computationally impractical. We must settle for a less tight bound. The algorithm used by XAP/1 maintains several data structures.
Reference: [20] <author> Giuseppina Gini and Maria Gini. </author> <title> Using a task description language for assembly: The generation of world models. </title> <booktitle> In 8th Int'l Symp. on Indust. Robots, </booktitle> <pages> pages 364-372, </pages> <month> May </month> <year> 1975. </year>
Reference-contexts: To do this, the interpreter must have available a model of the robot to be used. More recently, task-level languages have been proposed (e.g. AUTOPASS [31], LAMA [32, 33], and later versions of AL <ref> [2, 20] </ref>). These typically describe actions purely by their effects on the parts, such as "thread nut A onto bolt B", rather than by the motions of the manipulator.
Reference: [21] <author> C. Green. </author> <title> Applications of theorem proving to problem solving. </title> <booktitle> In Int'l Joint Conf. on Art. Int., </booktitle> <pages> pages 219-239, </pages> <year> 1969. </year>
Reference-contexts: The assembly planning problem is in many ways similar to one of the most widely studied problems in artificial intelligence: the robot planning problem. The first robot planning system was described by Green in 1969 <ref> [21] </ref>. Since that time robot planning has been widely used as a sample problem domain for general purpose planning systems, such as STRIPS [17], and NOAH [39], in studies of skill acquisition, such as HACKER [44], and in natural language understanding systems, such as Winograd's system [47].
Reference: [22] <author> L. Guibas and F. Yao. </author> <title> On translating a set of rectangles. </title> <booktitle> In 12th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 154-160, </pages> <month> Apr </month> <year> 1980. </year>
Reference-contexts: Dawson showed that if the parts are each translated by the vector t~v i , they will be separated without intersection. Note that such plans are non-sequential. In some cases, such as the one in figure 2.3, no sequential plan exists. Guibas and Yao <ref> [22] </ref> have shown that given any two-dimensional assembly of convex parts there is at least one part that can be removed in any arbitrary direction. Such a part can be found in linear time.
Reference: [23] <author> M. R. Henderson and D. C. Anderson. </author> <title> Computer recognition and extraction of form features: A cad/cam link. </title> <booktitle> Computers in Industry, </booktitle> <volume> 5(4) </volume> <pages> 329-339, </pages> <month> Dec </month> <year> 1984. </year>
Reference-contexts: Of course, before this kind of high-level knowledge can be used to propose trajectories, it must be obtained from some source. Some research has been done on algorithms to identify features, such as tabs, slots and holes, from geometric models of parts <ref> [12, 23, 29] </ref>. It seems likely that such algorithms could be improved if they worked on assemblies rather than individual parts, since most interesting features are better defined as relationships between parts.
Reference: [24] <author> Frederick S. Hillier and Gerald J. Lieberman. </author> <title> Operations Research. </title> <publisher> Holden-Day, Inc., </publisher> <address> San Francisco, </address> <note> second edition, </note> <year> 1974. </year>
Reference-contexts: The leaves are kept in a unsorted list, L. Figure 5.3 assumes that this list is managed by a library of algorithms indicated by the "LIST:" prefix on their names. In operations research terminology, this is a "branch-and-bound" algorithm <ref> [24] </ref>. It is also essentially the same as the A* graph search algorithm, except that instead of generating all possible successors of an expanded node, we choose a way to split the set of solutions for the node into two disjoint subset.
Reference: [25] <author> R. C. Hillyard. </author> <title> The Build group of solid modelers. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 2(2) </volume> <pages> 43-52, </pages> <month> March </month> <year> 1982. </year>
Reference-contexts: This is similar to the type of data produced by standard mechanical CAD systems such as those descended from BUILD <ref> [25] </ref> or PADL [7]. In addition to purely geometric information, the CAD data base should supply whatever subsidiary data is needed to build the assembly. In the example shown, the planner should be told how much the screw is to be tightened.
Reference: [26] <author> Luiz S. Homem de Mello and Arthur C. Sanderson. </author> <title> AND/OR graph representation of assembly plans. </title> <booktitle> In 5th AAAI National Conf. on Artificial Intelligence, </booktitle> <pages> pages 1113-1119, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Homem de Mello and Sander-son have described the use of an AND/OR tree data structure in the generation of assembly plans <ref> [26, 27] </ref>. They have not, however, described how to generate this data structure. A more detailed discussion of this approach will be given in section 3.2. De Fazio and Whitney have described an approach to generate all possible assembly plans for an assembly [14]. <p> XAP/1's ability to handle non-rigid parts is also somewhat limited. However, methods that would allow a wider variety of non-rigid parts to be handled will be discussed here. 3.2 AND/OR Tree Approach Homem de Mello and Sanderson have introduced the use of AND/OR trees to represent assembly planning problems <ref> [26, 27] </ref>. Their research provides a convenient framework in which to search for a good plan, but leaves the question of how to generate AND/OR trees largely unanswered. In discussing AND/OR trees, it is convenient to speak in terms of disassembly rather than assembly.
Reference: [27] <author> Luiz S. Homem de Mello and Arthur C. Sanderson. </author> <title> Planning repair sequences using the AND/OR graph representation of assembly plans. </title> <booktitle> In IEEE Intl. Conf. on Robotics and Automation, </booktitle> <pages> pages 1861-1862, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Homem de Mello and Sander-son have described the use of an AND/OR tree data structure in the generation of assembly plans <ref> [26, 27] </ref>. They have not, however, described how to generate this data structure. A more detailed discussion of this approach will be given in section 3.2. De Fazio and Whitney have described an approach to generate all possible assembly plans for an assembly [14]. <p> XAP/1's ability to handle non-rigid parts is also somewhat limited. However, methods that would allow a wider variety of non-rigid parts to be handled will be discussed here. 3.2 AND/OR Tree Approach Homem de Mello and Sanderson have introduced the use of AND/OR trees to represent assembly planning problems <ref> [26, 27] </ref>. Their research provides a convenient framework in which to search for a good plan, but leaves the question of how to generate AND/OR trees largely unanswered. In discussing AND/OR trees, it is convenient to speak in terms of disassembly rather than assembly.
Reference: [28] <author> J. E. Hopcroft, J. T. Schwartz, and M. Sharir. </author> <title> On the complexity of motion planning for multiple independent objects: PSPACE-hardness of the `warehouseman's problem'. </title> <journal> Robotic Research, </journal> <volume> 3(4) </volume> <pages> 76-88, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: It has been shown by Hopcroft, Schwartz and Sharir that the robot planning problem is PSPACE-hard even in two dimensions <ref> [28] </ref>. The assembly they used to show this is one that cannot be disassembled, so that proof cannot be directly applied to the assembly planning problem. However it is possible to modify their proof to show that assembly planning, too, is PSPACE-hard.
Reference: [29] <author> S. Joshi and T. C. Chang. </author> <title> Graph-based heuristics for recognition of machined features from a 3D solid model. </title> <booktitle> Computer-Aided Design, </booktitle> <volume> 20(2) </volume> <pages> 58-66, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Of course, before this kind of high-level knowledge can be used to propose trajectories, it must be obtained from some source. Some research has been done on algorithms to identify features, such as tabs, slots and holes, from geometric models of parts <ref> [12, 23, 29] </ref>. It seems likely that such algorithms could be improved if they worked on assemblies rather than individual parts, since most interesting features are better defined as relationships between parts.
Reference: [30] <author> D. E. Knuth. </author> <booktitle> The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <note> second edition, </note> <year> 1973. </year>
Reference-contexts: If we define C n = T n+1 and rearrange the relation as follows: C n = 0jn1 then we arrive at the recurrence relation for the Catalan numbers. This is a well-known function <ref> [30, 36] </ref> whose solution is known to be: C n = n + 1 2n 4 n p + O (4 n n 5 Thus, the total number of plans is n! 1 n 1 = (n 1)! Thus the maximum number of monotone plans exceeds the maximum number of linear
Reference: [31] <author> L. T. Lieberman and M. A. Wesley. AUTOPASS: </author> <title> An automatic programming system for computer controlled assembly. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 21, </volume> <month> July </month> <year> 1977. </year>
Reference-contexts: As shown in figure 1.1, this requires the solution of the kinematics and, preferably, dynamics of the robot arm. To do this, the interpreter must have available a model of the robot to be used. More recently, task-level languages have been proposed (e.g. AUTOPASS <ref> [31] </ref>, LAMA [32, 33], and later versions of AL [2, 20]). These typically describe actions purely by their effects on the parts, such as "thread nut A onto bolt B", rather than by the motions of the manipulator.
Reference: [32] <author> T. Lozano-Perez. </author> <title> A language for automatic mechanical assembly. </title> <editor> In P. H. Winston and R. H. Brown, editors, </editor> <booktitle> Artificial Intelligence: an MIT Perspective, </booktitle> <volume> volume 2, </volume> <pages> pages 245-271. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1979. </year>
Reference-contexts: As shown in figure 1.1, this requires the solution of the kinematics and, preferably, dynamics of the robot arm. To do this, the interpreter must have available a model of the robot to be used. More recently, task-level languages have been proposed (e.g. AUTOPASS [31], LAMA <ref> [32, 33] </ref>, and later versions of AL [2, 20]). These typically describe actions purely by their effects on the parts, such as "thread nut A onto bolt B", rather than by the motions of the manipulator.
Reference: [33] <author> Tomas Lozano-Perez and Michael A. Wesley. LAMA: </author> <title> A language for automatic mechanical assembly. </title> <booktitle> In 5th Int'l Joint Conf. on AI, </booktitle> <pages> pages 710-716, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: As shown in figure 1.1, this requires the solution of the kinematics and, preferably, dynamics of the robot arm. To do this, the interpreter must have available a model of the robot to be used. More recently, task-level languages have been proposed (e.g. AUTOPASS [31], LAMA <ref> [32, 33] </ref>, and later versions of AL [2, 20]). These typically describe actions purely by their effects on the parts, such as "thread nut A onto bolt B", rather than by the motions of the manipulator.
Reference: [34] <author> Nils J. Nilsson. </author> <booktitle> Principles of Artificial Intelligence. </booktitle> <publisher> Tioga Publishing Company, </publisher> <address> Palo Alto, </address> <year> 1980. </year>
Reference-contexts: Nilsson has proven that the A* algorithm always terminates with an optimal result <ref> [34] </ref>, and this result applies to EXEC:SOLVE as well, so long as CRIT:RATE returns an optimistic rating and CRIT:PROP returns a valid, non-redundant assertion. In a sense the selection, in step 11, of an assertion to branch on is not critically important.
Reference: [35] <author> R. P. Paul. </author> <title> WAVE: A model based language for manipulator control. The Industrial Robot, </title> <booktitle> 4 </booktitle> <pages> 10-17, </pages> <year> 1977. </year>
Reference-contexts: The lowest level languages are joint-level languages, such as SIGLA [41], which describe the motions of the robot in terms of joint motions. Programs in joint-level languages can be directly executed by a robot. Most currently used robot languages are manipulator-level languages (e.g. VAL [43], AML [45], WAVE <ref> [35] </ref>, and older versions of AL [18]), which describe only the motion of the end effector. Programs in manipulator-level languages must be converted into joint-level programs before being executed. As shown in figure 1.1, this requires the solution of the kinematics and, preferably, dynamics of the robot arm.
Reference: [36] <author> P. W. Purdom, Jr. and C. A. Brown. </author> <title> The Analysis of Algorithms. </title> <publisher> Holt, Rinehart and Winston, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: If we define C n = T n+1 and rearrange the relation as follows: C n = 0jn1 then we arrive at the recurrence relation for the Catalan numbers. This is a well-known function <ref> [30, 36] </ref> whose solution is known to be: C n = n + 1 2n 4 n p + O (4 n n 5 Thus, the total number of plans is n! 1 n 1 = (n 1)! Thus the maximum number of monotone plans exceeds the maximum number of linear
Reference: [37] <author> J. Reif and J. Storer. </author> <title> Shortest paths in euclidean space with polyhedral obstacles. </title> <type> Technical Report CS-85-121, C.S. </type> <institution> Dept., Brandeis Univ., </institution> <year> 1985. </year>
Reference-contexts: Unfortunately, path planners are generally expensive to run. The problem of finding the shortest path between two points among polyhedral obstacles is known to be NP-hard [11], though efficient algorithms are known for the two-dimensional problem <ref> [37, 42] </ref>. In this application we do not, however, need to find the shortest path | any reasonable path will suffice.
Reference: [38] <author> Ritchey Ruff and Narendra Ahuja. </author> <title> Path planning in a three dimensional environment. </title> <booktitle> In IEEE Intl. Conf. on Pattern Recognition, </booktitle> <pages> pages 188-191, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Several specialized algorithms to find paths have been proposed which approximate the obstacles <ref> [5, 6, 38] </ref>. However, because of the close tolerances involved in mating parts, accurate representations of parts and obstacles are essential in this application. Therefore many of these path-planning algorithms would not be suitable.
Reference: [39] <author> Earl D. Sacerdoti. </author> <title> A structure for plans and behaviour. </title> <type> Technical Report 109, </type> <institution> Stanford, AI Cntr., </institution> <year> 1975. </year>
Reference-contexts: The first robot planning system was described by Green in 1969 [21]. Since that time robot planning has been widely used as a sample problem domain for general purpose planning systems, such as STRIPS [17], and NOAH <ref> [39] </ref>, in studies of skill acquisition, such as HACKER [44], and in natural language understanding systems, such as Winograd's system [47]. The inputs to a robot planning problem include not only the final configuration of the parts, but also an initial configuration and the geometry of the workspace.
Reference: [40] <author> J.-R. Sack and G. T. Toussaint. </author> <title> Separability of pairs of polygons through simple translations. </title> <journal> Robotica, </journal> <volume> 5(1) </volume> <pages> 55-63, </pages> <month> January-March </month> <year> 1987. </year>
Reference-contexts: Sack and Toussaint have shown that for two polygons of size N and M , all directions of translation separability can be found in O (N log M ) time <ref> [40] </ref> and Toussaint and El Gindy have shown that in the special case of monotone polygons, all directions of translation separability can be found in O (N + M ) time [46]. No fast 3-dimensional algorithms have yet been published.
Reference: [41] <author> M. Salmon. SIGLA: </author> <title> The Olivetti SIGMA robot programming language. </title> <booktitle> In 8th Int'l Symp. on Indust. Robots, </booktitle> <month> June </month> <year> 1978. </year>
Reference-contexts: The lowest level languages are joint-level languages, such as SIGLA <ref> [41] </ref>, which describe the motions of the robot in terms of joint motions. Programs in joint-level languages can be directly executed by a robot. Most currently used robot languages are manipulator-level languages (e.g.
Reference: [42] <author> M. Sharir and A. Schorr. </author> <title> On shortest paths in polyhderal spaces. </title> <booktitle> In 16th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 144-153, </pages> <month> Apr </month> <year> 1984. </year>
Reference-contexts: Unfortunately, path planners are generally expensive to run. The problem of finding the shortest path between two points among polyhedral obstacles is known to be NP-hard [11], though efficient algorithms are known for the two-dimensional problem <ref> [37, 42] </ref>. In this application we do not, however, need to find the shortest path | any reasonable path will suffice.
Reference: [43] <author> E. E. Shimano. VAL: </author> <title> An industrial robot programming and control system. </title> <booktitle> In 3rd Int'l Comp. Soft. Applic. Conf. (COMPSAC), </booktitle> <year> 1979. </year>
Reference-contexts: The lowest level languages are joint-level languages, such as SIGLA [41], which describe the motions of the robot in terms of joint motions. Programs in joint-level languages can be directly executed by a robot. Most currently used robot languages are manipulator-level languages (e.g. VAL <ref> [43] </ref>, AML [45], WAVE [35], and older versions of AL [18]), which describe only the motion of the end effector. Programs in manipulator-level languages must be converted into joint-level programs before being executed.
Reference: [44] <author> Gerald J. Sussman. </author> <title> A Computer Model of Skill Acquisition. </title> <publisher> American Elsevier, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: The first robot planning system was described by Green in 1969 [21]. Since that time robot planning has been widely used as a sample problem domain for general purpose planning systems, such as STRIPS [17], and NOAH [39], in studies of skill acquisition, such as HACKER <ref> [44] </ref>, and in natural language understanding systems, such as Winograd's system [47]. The inputs to a robot planning problem include not only the final configuration of the parts, but also an initial configuration and the geometry of the workspace.
Reference: [45] <author> R. H. Taylor, P. Summers, and J. M. Meyer. AML: </author> <title> A manufacturing language. </title> <journal> Robotics Research, </journal> <volume> 1(3), </volume> <month> Fall </month> <year> 1982. </year>
Reference-contexts: The lowest level languages are joint-level languages, such as SIGLA [41], which describe the motions of the robot in terms of joint motions. Programs in joint-level languages can be directly executed by a robot. Most currently used robot languages are manipulator-level languages (e.g. VAL [43], AML <ref> [45] </ref>, WAVE [35], and older versions of AL [18]), which describe only the motion of the end effector. Programs in manipulator-level languages must be converted into joint-level programs before being executed. As shown in figure 1.1, this requires the solution of the kinematics and, preferably, dynamics of the robot arm.
Reference: [46] <author> G. T. Toussaint and H. A. El Gindy. </author> <title> Separation of two monotone polygons in linear time. </title> <journal> Robotica, </journal> <volume> 2(4) </volume> <pages> 215-220, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: N and M , all directions of translation separability can be found in O (N log M ) time [40] and Toussaint and El Gindy have shown that in the special case of monotone polygons, all directions of translation separability can be found in O (N + M ) time <ref> [46] </ref>. No fast 3-dimensional algorithms have yet been published. In cases where parts interlock in very complex ways and cannot be separated by pure translation, standard path-planning algorithms, such as those mentioned in section 3.2 could be used.
Reference: [47] <author> Terry Winograd. </author> <title> Understanding Natural Language. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1972. </year>
Reference-contexts: Since that time robot planning has been widely used as a sample problem domain for general purpose planning systems, such as STRIPS [17], and NOAH [39], in studies of skill acquisition, such as HACKER [44], and in natural language understanding systems, such as Winograd's system <ref> [47] </ref>. The inputs to a robot planning problem include not only the final configuration of the parts, but also an initial configuration and the geometry of the workspace.
Reference: [48] <author> Jan D. Wolter, Richard A. Volz, and T. C. Woo. </author> <title> Automatic generations of gripping positions. </title> <journal> IEEE Transactions on Systems, Man and Cybernetics, </journal> <volume> 15(2) </volume> <pages> 204-213, </pages> <month> March/April </month> <year> 1985. </year>
Reference-contexts: Basing these ratings only on size and mass is a little simple minded, though. If a more careful analysis were desired it would be possible to run a program that analyzes the parts for possible gripping positions <ref> [1, 48] </ref>, and give high ratings to parts with a large variety of stable grips. This could then be compared to a similar rating of how easily a part is fixtured.
Reference: [49] <author> Xiaodong Xia and George A. Bekey. SROMA: </author> <title> An adaptive scheduler for robotic assembly systems. </title> <booktitle> In IEEE Intl. Conf. on Robotics and Automation, </booktitle> <pages> pages 1282-1287, </pages> <month> April </month> <year> 1988. </year> <month> 76 </month>
Reference-contexts: The complexity of this approach is very large, and the selection of the liaisons would not be easy to automate. The SROMA system described by Xia and Bekey <ref> [49] </ref> appears to be somewhat similar, in that it takes as its input a manually generated "T plan " data structure, which identifies subassemblies and other significant relationships among parts.
References-found: 49

