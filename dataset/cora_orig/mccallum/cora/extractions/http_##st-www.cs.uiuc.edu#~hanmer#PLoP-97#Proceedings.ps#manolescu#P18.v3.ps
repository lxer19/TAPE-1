URL: http://st-www.cs.uiuc.edu/~hanmer/PLoP-97/Proceedings.ps/manolescu/P18.v3.ps
Refering-URL: http://st-www.cs.uiuc.edu/~hanmer/PLoP-97/Workshops.html
Root-URL: http://www.cs.uiuc.edu
Title: A Data Flow Pattern Language  
Author: Dragos-Anton Manolescu 
Abstract-found: 0
Intro-found: 1
Reference: [Ack94] <author> Philipp Ackermann. </author> <title> Design and implementation of on object-oriented media composition framework. </title> <booktitle> In Proc. International Computer Music Conference, </booktitle> <address> Aarhus, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: It consists of sources, filters and renderers connected in a filter graph. All graph components are implemented as Component Object Model (COM) objects. Filters have pins which are connected with streams, but other communication channels for specialized communication (e.g., error notifications) are available. 6. MET++ <ref> [Ack94] </ref> is a framework for multimedia applications. It supports the development of multimedia applications by providing reusable objects for 2D graphics, user interface components, 3D graphics, video, audio, and music. The audio resources are modeled as modules of a source-filter-sink architecture. Variants 3 1.
Reference: [AEW96] <author> Philipp Ackermann, Dominik Eichelberg, and Bernhard Wagner. </author> <title> Visual programming in an object-oriented framework. </title> <booktitle> In Proc. Swiss Computer Science Conference, </booktitle> <address> Zurich, Switzerland, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Users that have knowledge only about the application domain (e.g., scientific visualization) could create new applications by simply connecting modules, without performing any other programming. As mentioned in [Foo88], this is usually done with visual programming tools <ref> [AEW96] </ref> which assist the creation of module networks. The network normally triggers recomputations whenever a filter's output value changes. While manipulated interactively, it should be possible to temporarily disable the network, such that no output is computed until a valid, stable state is reached.
Reference: [AMS] <institution> Microsoft Corporation, </institution> <address> Seattle, WA. </address> <note> ActiveMovie Software Development Kit version 1.0. http://www.microsoft.com/devonly/tech/amov1doc/. </note>
Reference-contexts: The algorithmic properties of most filter 6 modules are independent of the entities using them; their functions are not designed in ways that are intrinsically coupled to any particular source or sink. 5. One of the most recent data flow architectures is Microsoft's ActiveMovie <ref> [AMS] </ref>, which allows users to play digital movies and sound encoded in various formats. It consists of sources, filters and renderers connected in a filter graph. All graph components are implemented as Component Object Model (COM) objects. <p> The identifier and the length correspond to the descriptor component, while the contents correspond to the data component. Although ASN.1 and BER have been designed for the application-presentation interface within the OSI architecture, they have also been applied for distributed systems. 3. In ActiveMovie <ref> [AMS] </ref>, payloads are either media samples or quality control data. Media data originates at the source and is passed only downstream. Quality control data provides a means to gracefully adapt to load differences in the media stream. <p> A demand-driven computation takes a top-down approach. It begins by requesting the value of e, which triggers the evaluation of the product. This in turn triggers the addition and the subtraction. The lazy evaluation corresponds to the pull model. 3. In ActiveMovie <ref> [AMS] </ref>, the pins are responsible for providing interfaces to connect with other pins and for transporting the data. These interfaces transfer time-stamped data, negotiate data formats and maximize throughput by selecting an optimal buffer management and allocation scheme. <p> Examples 1. The terminology used in Solution was inspired by the VuSystem [Lin94], where the two partitions have different architectures and designs, and are also implemented in different programming languages. Their characteristics are summarized Table 1. 2. In ActiveMovie <ref> [AMS] </ref> the graph manager (out-of band partition) connects filters and controls the media stream. It also has the ability to search for a configuration of filters that will render a particular media type and automatically build the corresponding graph.
Reference: [AVS93] <institution> CONVEX Computer Corporation, Richardson, TX. </institution> <note> ConvexAVS Developer's Guide, first edition, </note> <month> December </month> <year> 1993. </year>
Reference-contexts: Resulting context An application structured as a set of sources, sinks, filters and communication channels can be distributed over several CPUs (computers). This change is transparent for sources, sinks and filters; the communication channels/messages need to provide marshalling/unmarshalling methods. Examples 1. The Application Visualization System (AVS) <ref> [AVS93] </ref> is a powerful visualization package that uses the data flow architecture. Different modules (file readers, data processing, etc.) are organized into a network with the aid of a visual network editor. AVS modules have the following characteristics: * Not all AVS modules are plug-compatible. <p> Small part of the application code which executes most of the running time. Tool Tcl/TclXt/TclAw C++ Table 1: Partitions within the VuSystem. The out-of-band partition also plays an important role in the context of visual programming. In such systems <ref> [AVS93, EXP93] </ref>, this partition is more elaborate and assists users in assembling, controlling and manipulating the in-band partition without requiring programming expertise. Another benefit of application partitioning is that some error handlers can be placed in the out-of-band partition. <p> An error detection and reporting protocol defines how errors are handled by filters and propagated to the graph manager. Because ActiveMovie is also a software development kit, the graph manager provides a set of COM interfaces to allow communication between the filter graph and other applications. 3. AVS <ref> [AVS93] </ref> and Iris Explorer [EXP93] are interactive visual programming tools which rely heavily on the out-of-band partition. They offer full access over the in-band partition, which can be built, configured and operated with from the user interface. Variants 1. This pattern is also present in [Wal94].
Reference: [BMR + 96] <author> Frank Buschman, Regine Meunier, Hans Rohnert, Peter Sommerlad, and Michael Stal. </author> <title> Pattern-Oriented Software ArchitectureA System of Patterns. </title> <publisher> John Wiley & Sons, </publisher> <month> July </month> <year> 1996. </year> <note> ISBN 0-47195-869-7. </note>
Reference-contexts: 1 Introduction There have been several attempts to write patterns about the data flow paradigm <ref> [Edw95, Meu95, Sha96, BMR + 96] </ref>, including variants specialized for particular domains [PLV96]. Based on the insights provided by these studies and on a different set of examples, in this paper I revisit the subject and define a pattern language. The major contributions of this approach are the following: 1. <p> A common characteristic of these two priority levels (assuming a single thread of execution) 1 In this context, module is any processing unit within the application domain. 3 is that scheduling (i.e., when the actual processing takes place) is non-deterministic. This issue is also addressed in <ref> [BMR + 96] </ref>. However, the finer granularity approach allows separation of the policy from the mechanisms used to implement itsee Section 4. <p> It is not a good choice for applications with dynamic control flow or feedback loops. For instances where the overhead of enforcing the inter-module interface is too high, a different architectural choice might be a better solution. As discussed in <ref> [BMR + 96] </ref>, signaling errors that occur inside filter modules is cumbersome and difficult. Modules do not make any assumptions about their context and communicate only with other data-processing modules. <p> Out-of-band and in-band processing describes how to organize such applications. * Applications following the Layers architectural pattern <ref> [BMR + 96] </ref> also manifest modules which exchange data between them. <p> semantics on each layerof course, the Data flow architecture could be used within individual layers. * Static composition is an instance of the Composite pattern [GHJV95], which ensures a consistent interface for primitive (e.g., statically composed filter) and container (e.g., sequence of filters) objects. * Streams [Edw95], Pipes and filters <ref> [Meu95, BMR + 96] </ref> and Pipeline [Sha96] provide similar solutions but are subsets of the pattern described here. 3 Pattern: Payloads Context Sometimes separate entities 5 need to exchange information with each other. <p> This 9 mechanism is propagated down the filter network until it reaches the sink. For example, the Basic Encoding Rules for ASN.1 [X2088b] reserve a special data value (the tag [UNIVERSAL 0]) for this purpose. This issue is also discussed in <ref> [BMR + 96] </ref>. If the two entities reside on separate machines, it is possible that they communicate over a high speed serial link (e.g., Ethernet). <p> However, data repositories require additional scheduling policies, might introduce unpredictable delays and are not viable if the payloads have large memory footprints. 13 Indirect (shared resources) This model requires the availability of a shared repository (some-times called mailbox, pipe <ref> [BMR + 96] </ref> or put/take buffer stage [Lea96]) that is accessible to both modules. Whenever the sender module is ready to pass a payload to the receiver, it writes it in the shared repository. When ready to process another input, the receiver module gets a payload from the repository. <p> Payloads ensure uniform access to this information, while maintaining a loose coupling between repositories and messages. * Adjacent layers within the Layers <ref> [BMR + 96] </ref> pattern communicate with each other. <p> An out-of-band partition has knowledge about the network topology and could handle error messages from the modules. It can also assist in the process of creation and in monitoring the network. * The Layers architectural pattern <ref> [BMR + 96] </ref> also partitions an application such that each division corresponds to a different level of abstraction. Each layer defines interfaces for the one above it and uses the services provided by the one below.
Reference: [CRJ87] <author> Roy H. Campbell, Vincent Russo, and Gary Johnston. </author> <title> Choices: The Design of a Multiprocessor Operating System. </title> <booktitle> In Proc. USENIX C++ Workshop, </booktitle> <pages> pages 109123, </pages> <address> Santa Fe, NM, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: This approach is well suited to high message rates or bursty traffic, such that the sender does not have to hold a message too long before passing it further. It has been successfully applied in operating systems which consist of several interacting components <ref> [TW97, CRJ87] </ref>. A consequence of the Payloads pattern is that adding new message types does not require changing the existing entities which are not interested in them. For example, in a Data flow architecture (Section 2), filters pass downstream the messages they do not understand, without performing any processing.
Reference: [Den80] <author> J. B. Dennis. </author> <title> Data flow supercomputers. </title> <journal> IEEE Computer, </journal> <volume> 13(11), </volume> <year> 1980. </year>
Reference-contexts: Then the pull model could be used, until the downstream module is ready to accept other messages from the receiver. Having more than one input port complicates flow control and requires additional policies. Two possible scenarios have been identified in the context of hardware data flow architectures <ref> [Den80, Pap91] </ref>. In the static model, a filter recomputes its output value each time a new payload is available at an input port. The dynamic model tags the payloads with context descriptors.
Reference: [Edw95] <author> Stephen Edwards. </author> <title> Streams: A Pattern for Pull-Driven Processing, </title> <booktitle> volume 1 of Pattern Languages of Program Design, chapter 21. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1995. </year> <editor> Edited by James O. Coplien and Douglas C. Schmidt. </editor> <address> ISBN 0-201-60734-4. </address>
Reference-contexts: 1 Introduction There have been several attempts to write patterns about the data flow paradigm <ref> [Edw95, Meu95, Sha96, BMR + 96] </ref>, including variants specialized for particular domains [PLV96]. Based on the insights provided by these studies and on a different set of examples, in this paper I revisit the subject and define a pattern language. The major contributions of this approach are the following: 1. <p> the data has different semantics on each layerof course, the Data flow architecture could be used within individual layers. * Static composition is an instance of the Composite pattern [GHJV95], which ensures a consistent interface for primitive (e.g., statically composed filter) and container (e.g., sequence of filters) objects. * Streams <ref> [Edw95] </ref>, Pipes and filters [Meu95, BMR + 96] and Pipeline [Sha96] provide similar solutions but are subsets of the pattern described here. 3 Pattern: Payloads Context Sometimes separate entities 5 need to exchange information with each other.
Reference: [EXP93] <institution> Silicon Graphics, Inc., Mountain View, CA. </institution> <note> IRIS Explorer User's Guide, </note> <year> 1993. </year>
Reference-contexts: For example, the color of a plot could be determined by a module which compares the plotted value with a reference. 2. Iris Explorer <ref> [EXP93] </ref> is a visualization program originally developed by Silicon Graphics. It allows users to visualize data and create visualization applications by connecting modules into a map. <p> Small part of the application code which executes most of the running time. Tool Tcl/TclXt/TclAw C++ Table 1: Partitions within the VuSystem. The out-of-band partition also plays an important role in the context of visual programming. In such systems <ref> [AVS93, EXP93] </ref>, this partition is more elaborate and assists users in assembling, controlling and manipulating the in-band partition without requiring programming expertise. Another benefit of application partitioning is that some error handlers can be placed in the out-of-band partition. <p> Because ActiveMovie is also a software development kit, the graph manager provides a set of COM interfaces to allow communication between the filter graph and other applications. 3. AVS [AVS93] and Iris Explorer <ref> [EXP93] </ref> are interactive visual programming tools which rely heavily on the out-of-band partition. They offer full access over the in-band partition, which can be built, configured and operated with from the user interface. Variants 1. This pattern is also present in [Wal94].
Reference: [Foo88] <author> Brian Foote. </author> <title> Designing to facilitate change with object-oriented frameworks. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1988. </year>
Reference-contexts: Users that have knowledge only about the application domain (e.g., scientific visualization) could create new applications by simply connecting modules, without performing any other programming. As mentioned in <ref> [Foo88] </ref>, this is usually done with visual programming tools [AEW96] which assist the creation of module networks. The network normally triggers recomputations whenever a filter's output value changes.
Reference: [GHJV95] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year> <note> ISBN 0-201-63361-2. </note>
Reference-contexts: However, in this case each module corresponds to a different abstraction level and the data has different semantics on each layerof course, the Data flow architecture could be used within individual layers. * Static composition is an instance of the Composite pattern <ref> [GHJV95] </ref>, which ensures a consistent interface for primitive (e.g., statically composed filter) and container (e.g., sequence of filters) objects. * Streams [Edw95], Pipes and filters [Meu95, BMR + 96] and Pipeline [Sha96] provide similar solutions but are subsets of the pattern described here. 3 Pattern: Payloads Context Sometimes separate entities 5 <p> MPI messages call the descriptor component message envelope. Related Patterns * Many applications that adopt the Data flow architecture use payloads to encapsulate the data that flows through the network. * Marshalling and unmarshalling methods require payloads to reconstruct themselves from a byte stream. A Factory method <ref> [GHJV95] </ref> could be employed at the receiver's end to reconstruct the appropriate type of payload. * The Composite message pattern [SC95] facilitates the packaging of several messages into a composite, thus improving performance by reducing the message passing overhead. 4 Pattern: Module data protocol Context Collaborating logical modules communicate by passing <p> The Module data protocol could be used to exchange data across layer boundaries. * To ensure a loose coupling between communicating modules, the notification mechanism could be implemented with the Observer <ref> [GHJV95] </ref> pattern. 5 Pattern: Out-of-band and in-band partitions Context An interactive application has a dual functionality: 16 1. On one hand, the application interfaces with the user. <p> It is realistic to assume that the in-band code is made up of several reusable software components, which are loosely coupled with other parts of the system. The out-of-band code has additional knowledge about the application and can be regarded as a Mediator <ref> [GHJV95] </ref> that coordinates various components and interprets error messages in the global context. which are fed to each partition show their different requirements. Examples 1.
Reference: [GR94] <author> Kevin L. Gong and Lawrence A. Rowe. </author> <title> Parallel MPEG1 video encoding. </title> <booktitle> In Proc. Picture Coding Symposium, </booktitle> <address> Sacramento, CA, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Variants 1. This pattern is also present in [Wal94]. Improvisor objects (out-of-band) coordinate different Composer and Transformer objects (in-band). In this case, the out-of-band partition does not handle user interfaces. 2. The Berkeley parallel MPEG1 encoder <ref> [GR94] </ref> is partitioned in a similar way.
Reference: [GT95] <author> Simon J. Gibbs and Dionysios C. Tsichritzis. </author> <title> Multimedia ProgrammingObjects, Environments and Frameworks. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year> <note> ISBN 0-201-42282-4. </note>
Reference-contexts: Although these two applications are very different (the former processes real-time video while the latter provides content-based access), both of them have been built with the same tool just by connecting existing modules. 2. The multimedia framework described in <ref> [GT95] </ref> also employs the media flow architecture. The framework uses a Component abstract class that represents media data processing modules. There are two kinds of components: Passive Passive components are characterized by state and behavior. Media processing is performed in response to messages sent to the object.
Reference: [Gur85] <author> J. R. Gurd. </author> <title> The Manchester prototype dataflow computer. </title> <journal> Communications of the ACM, </journal> <volume> 28(1), </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: Another system component is the Module Builder, which is used to create modules without doing any programming beyond that needed to implement the module's function. 3. Data flow architectures have been investigated from a hardware perspective as well <ref> [Gur85, Pap91] </ref>. The execution model offers attractive properties for parallel processingimplicit synchronization of parallel activities and self schedulability. Unlike the von Neumann model which explicitly states the sequence of instructions, in the data flow model the execution of any instruction is driven by the operand availability.
Reference: [Lea94] <author> Doug Lea. </author> <title> Design patterns for avionics control systems, </title> <month> November </month> <year> 1994. </year> <title> DSSA Adage Project ADAGE-OSW-94-01. </title>
Reference-contexts: Its success motivated much of the work on similar projects [NPA92] and contributed to spread the interest in data flow and parallel programming. 4. Avionics Control Systems (ACS) also use this pattern <ref> [Lea94] </ref>. ACS are complex systems and constructing a set of components that merge all possible combinations is not feasible. Rather, a means for combining different types of components (filters) together to serve a particular purpose is requiredthe data flow architecture.
Reference: [Lea96] <author> Doug Lea. </author> <title> Concurrent Programming in Java. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year> <note> ISBN 0-201-69581-2. 21 </note>
Reference-contexts: Applications, University of Illinois at Urbana-Champaign, 152 Computing Applications Building, 605 East Springfield Avenue, Champaign IL 618205518, email: daman@ncsa.uiuc.edu. 1 2 Pattern: Data flow architecture Context A variety of applications from different domains (scientific visualization, media processing, encoders and decoders, to name just a fewan exhaustive categorization is provided in <ref> [Lea96] </ref>) apply a series of transformations to a data stream. Their architectures emphasize data flow and consist of a set of interconnected processing modules (networks of modules) where control flow is not represented explicitly. <p> Inter-module communication is done by passing messages (sometimes called tokens) through unidirectional input and output ports, thereby replacing direct calls. Depending on the number of ports and their types, modules could be classified as follows (a comprehensive classification according to various criteria is available in <ref> [Lea96] </ref>): Sources Usually they interface with an input device and have one or several output ports. Sinks Interface with an output device and have one or several input ports. <p> However, data repositories require additional scheduling policies, might introduce unpredictable delays and are not viable if the payloads have large memory footprints. 13 Indirect (shared resources) This model requires the availability of a shared repository (some-times called mailbox, pipe [BMR + 96] or put/take buffer stage <ref> [Lea96] </ref>) that is accessible to both modules. Whenever the sender module is ready to pass a payload to the receiver, it writes it in the shared repository. When ready to process another input, the receiver module gets a payload from the repository. <p> However, the shared resource requires the additional overhead which is typically associated with synchronization problems [SPG91] (e.g., managing the critical sections). This model might not work if the mod ules that communicate are located across hardware boundaries. In the context of concurrent systems <ref> [Lea96] </ref> identifies two basic forms of flow policies (pull-based flow for demand-driven applications and push-based flow for event-driven contexts), as well as a mixed strategy (exchange). The rest of this section provides some additional details with general applicability and shows the relationships with other patterns.
Reference: [Lew95] <author> Ted Lewis, </author> <title> editor. Object-Oriented Application Frameworks. </title> <type> Manning, </type> <year> 1995. </year> <note> ISBN 1--884777-06-6. </note>
Reference-contexts: Rather, it is suitable for any instance of an application that has a dual functionality with divergent requirements. The unique requirements associated 17 with user interface code make it an excellent example for describing the pattern.) Com--monly, 50%-80% of an application is devoted to user interface aspects <ref> [Lew95] </ref> and has to cover a large number of possible actions which can not be determined in advance.
Reference: [Lin94] <author> Christopher J. Lindblad. </author> <title> A programming system for the dynamic manipulation of temporally sensitive data. </title> <type> Technical Report 637, </type> <institution> Massachutes Institute of Technology, </institution> <month> August </month> <year> 1994. </year> <institution> Laboratory for Computer Science. </institution>
Reference-contexts: It supports the development of multimedia applications by providing reusable objects for 2D graphics, user interface components, 3D graphics, video, audio, and music. The audio resources are modeled as modules of a source-filter-sink architecture. Variants 3 1. The data flow architecture is used in the VuSystem <ref> [Lin94] </ref>, with the same taxonomy as in Solution. Because the data flow in the network is continuous media and has soft real-time requirements, Chris Lindblad calls it media flow architecture. VuSystem applications 4 illustrate very well the flexibility of this architecture. <p> Payloads increase the overall flexibility and permit the addition of new functionality and/or features (e.g., priority levels, support for asynchronous events, etc.) with minimal changes. Examples 1. VuSystem's modules <ref> [Lin94] </ref> communicate by exchanging payloads. Examples of payloads are VideoFrame for single uncompressed video; AudioFragment for a sequence of audio samples; and Caption for close-captioned text. <p> The choice between the two models depends on the application's requirements. However, the associative memory required by the latter and the dynamic token matching overhead sometimes make this scenario not feasible. Examples 1. The VuSystem <ref> [Lin94] </ref> module data protocol has the following requirements: * Reduced latency, which is equivalent to no buffering. * Feed-back to upstream modules. * No multi-threading (the VuSystem runs like a single-threaded process). <p> Examples 1. The terminology used in Solution was inspired by the VuSystem <ref> [Lin94] </ref>, where the two partitions have different architectures and designs, and are also implemented in different programming languages. Their characteristics are summarized Table 1. 2. In ActiveMovie [AMS] the graph manager (out-of band partition) connects filters and controls the media stream.
Reference: [MD96] <author> Gerard Meszaros and Jim Doble. Metapatterns: </author> <title> A pattern language for pattern writing. </title> <booktitle> The 3rd Pattern Languages of Programming conference, </booktitle> <address> Monticello, Illinois, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: The presentation follows the guidelines from <ref> [MD96] </ref>. Each pattern is illustrated with a fairly large number of examples from different areas, such as avionics systems, digital video, hardware, music composition and improvisation, multimedia, operating systems, parallel computers and scientific visualization.
Reference: [Meu95] <author> Regine Meunier. </author> <title> The Pipes and Filters Architecture, </title> <booktitle> volume 1 of Pattern Languages of Program Design, chapter 22. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1995. </year> <editor> Edited by James O. Coplien and Douglas C. Schmidt. </editor> <address> ISBN 0-201-60734-4. </address>
Reference-contexts: 1 Introduction There have been several attempts to write patterns about the data flow paradigm <ref> [Edw95, Meu95, Sha96, BMR + 96] </ref>, including variants specialized for particular domains [PLV96]. Based on the insights provided by these studies and on a different set of examples, in this paper I revisit the subject and define a pattern language. The major contributions of this approach are the following: 1. <p> semantics on each layerof course, the Data flow architecture could be used within individual layers. * Static composition is an instance of the Composite pattern [GHJV95], which ensures a consistent interface for primitive (e.g., statically composed filter) and container (e.g., sequence of filters) objects. * Streams [Edw95], Pipes and filters <ref> [Meu95, BMR + 96] </ref> and Pipeline [Sha96] provide similar solutions but are subsets of the pattern described here. 3 Pattern: Payloads Context Sometimes separate entities 5 need to exchange information with each other.
Reference: [NPA92] <author> R. S. Nikhil, Gregory M. Papadopoulos, and Arvind. </author> <title> *T: A multithreaded massively parallel architecture. </title> <booktitle> In Proc. 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 156167. </pages> <publisher> ACM, </publisher> <year> 1992. </year>
Reference-contexts: This emphasizes a high degree of parallelism at the instruction level. The Monsoon Project [Pap91] developed by MIT and Motorola produced a data-flow multiprocessor targeted to large-scale scientific and symbolic computation. Its success motivated much of the work on similar projects <ref> [NPA92] </ref> and contributed to spread the interest in data flow and parallel programming. 4. Avionics Control Systems (ACS) also use this pattern [Lea94]. ACS are complex systems and constructing a set of components that merge all possible combinations is not feasible.
Reference: [Pap91] <author> Gregory M. Papadopoulos. </author> <title> Implementation of a general-purpose dataflow multiprocessor. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Another system component is the Module Builder, which is used to create modules without doing any programming beyond that needed to implement the module's function. 3. Data flow architectures have been investigated from a hardware perspective as well <ref> [Gur85, Pap91] </ref>. The execution model offers attractive properties for parallel processingimplicit synchronization of parallel activities and self schedulability. Unlike the von Neumann model which explicitly states the sequence of instructions, in the data flow model the execution of any instruction is driven by the operand availability. <p> Unlike the von Neumann model which explicitly states the sequence of instructions, in the data flow model the execution of any instruction is driven by the operand availability. This emphasizes a high degree of parallelism at the instruction level. The Monsoon Project <ref> [Pap91] </ref> developed by MIT and Motorola produced a data-flow multiprocessor targeted to large-scale scientific and symbolic computation. Its success motivated much of the work on similar projects [NPA92] and contributed to spread the interest in data flow and parallel programming. 4. Avionics Control Systems (ACS) also use this pattern [Lea94]. <p> Then the pull model could be used, until the downstream module is ready to accept other messages from the receiver. Having more than one input port complicates flow control and requires additional policies. Two possible scenarios have been identified in the context of hardware data flow architectures <ref> [Den80, Pap91] </ref>. In the static model, a filter recomputes its output value each time a new payload is available at an input port. The dynamic model tags the payloads with context descriptors.
Reference: [PLV96] <author> Edward J. Posnak, R. Greg Lavender, and Harrick M. Vin. </author> <title> Adaptive pipeline: an object structural pattern for adaptive applications. </title> <booktitle> The 3rd Pattern Languages of Programming conference, </booktitle> <address> Monticello, Illinois, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: 1 Introduction There have been several attempts to write patterns about the data flow paradigm [Edw95, Meu95, Sha96, BMR + 96], including variants specialized for particular domains <ref> [PLV96] </ref>. Based on the insights provided by these studies and on a different set of examples, in this paper I revisit the subject and define a pattern language. The major contributions of this approach are the following: 1. <p> Within a network, adjacent performance-critical modules could be regarded as a larger filter and replaced with an optimized version (using the Adaptive pipeline pattern <ref> [PLV96] </ref>) which trades flexibility for performance. Formally, this is modeled with functional composition: two adjacent filters with transfer functions f (x) and g (y) are replaced with only one filter h = g (f (x)) = gffif (x).
Reference: [Rit84] <author> Dennis M. Ritchie. </author> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8):18971910, </volume> <month> October </month> <year> 1984. </year>
Reference-contexts: In <ref> [Rit84] </ref>, Dennis Ritchie describes a variant of this pattern and how it is implemented in the UNIX stream system. Data flow is bidirectional and modules have queues for each direction. The queues are also employed for flow controlSection 4. <p> Quality control data provides a means to gracefully adapt to load differences in the media stream. It is used to send noti fication messages from a renderer either upstream, or directly to a designated location. 4. In UNIX streams <ref> [Rit84] </ref>, the objects that flow in the network are message blocks. A header specifies their type (data or control), as well as other attributes (e.g., asynchronous event). 11 5. <p> The rest of this section provides some additional details with general applicability and shows the relationships with other patterns. A push mechanism could use the data repositories for flow control <ref> [Rit84] </ref>. A high water mark limits the amount of payloads that could be stored in the repository; the sending module does not place data in the queue above this limit. When the queue exceeds its high water mark, it sets a flag and the upstream module stops sending data. <p> These interfaces transfer time-stamped data, negotiate data formats and maximize throughput by selecting an optimal buffer management and allocation scheme. Separate protocols are implemented for media samples, quality man agement, end-of-stream and flushing. 4. The UNIX stream input-output system <ref> [Rit84] </ref> uses a message queue and water marks for flow control. Related Patterns * Data flow architecture uses this pattern to transfer messages between modules. * Data repositories need various types of information about the messages they store (e.g., priority level, etc.).
Reference: [SC95] <author> Aamod Sane and Roy Campbell. </author> <title> Composite Messages: A Structural Pattern for Communication Between Processes. </title> <booktitle> In Proc. OOPSLA Workshop on Design Patterns for Concurrent, Parallel and Distributed Object-Oriented Systems, </booktitle> <month> October </month> <year> 1995. </year>
Reference-contexts: This is due to the high overhead associated with the message passing mechanism. One possible way to improve performance is to pack multiple messages into one container message such that all of them are transferred in one stepthe Composite message pattern <ref> [SC95] </ref> uses the same principle; however, rather than improving performance, its main objective is to abstract the communication 10 structure. This approach is well suited to high message rates or bursty traffic, such that the sender does not have to hold a message too long before passing it further. <p> A Factory method [GHJV95] could be employed at the receiver's end to reconstruct the appropriate type of payload. * The Composite message pattern <ref> [SC95] </ref> facilitates the packaging of several messages into a composite, thus improving performance by reducing the message passing overhead. 4 Pattern: Module data protocol Context Collaborating logical modules communicate by passing data blocks (or Payloads) between them. Depending on the application's domain, the requirements could be very different.
Reference: [Sha96] <author> Mary Shaw. </author> <title> Some Patterns for Software Architecture, </title> <booktitle> volume 2 of Pattern Languages of Program Design, chapter 16. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1996. </year> <note> Edited by John M. </note> <author> Vlissides, James O. Coplien and Norman L. Kerth. </author> <note> ISBN 0-201-89527-7. </note>
Reference-contexts: 1 Introduction There have been several attempts to write patterns about the data flow paradigm <ref> [Edw95, Meu95, Sha96, BMR + 96] </ref>, including variants specialized for particular domains [PLV96]. Based on the insights provided by these studies and on a different set of examples, in this paper I revisit the subject and define a pattern language. The major contributions of this approach are the following: 1. <p> Data flow architecture could be used within individual layers. * Static composition is an instance of the Composite pattern [GHJV95], which ensures a consistent interface for primitive (e.g., statically composed filter) and container (e.g., sequence of filters) objects. * Streams [Edw95], Pipes and filters [Meu95, BMR + 96] and Pipeline <ref> [Sha96] </ref> provide similar solutions but are subsets of the pattern described here. 3 Pattern: Payloads Context Sometimes separate entities 5 need to exchange information with each other. This could be done either by sending messages (payloads) through a communication channel which exists between them or with direct calls.
Reference: [SOHL + 96] <author> Marc Snir, Steve W. Otto, Steven Huss-Lederman, David W. Walker, and Jack Don-garra. </author> <title> MPIThe Complete Reference. </title> <publisher> The MIT Press, </publisher> <year> 1996. </year> <note> ISBN 0-262-69184-1. </note>
Reference-contexts: In UNIX streams [Rit84], the objects that flow in the network are message blocks. A header specifies their type (data or control), as well as other attributes (e.g., asynchronous event). 11 5. The Message Passing Interface (MPI) <ref> [SOHL + 96] </ref> is a standardized and portable message passing mechanism which runs on a wide variety of parallel computers. MPI messages call the descriptor component message envelope.
Reference: [SPG91] <author> Abraham Silberschatz, James L. Peterson, and Peter B. Galvin. </author> <title> Operating System Concepts. </title> <publisher> Addison-Wesley, </publisher> <address> third edition, </address> <year> 1991. </year> <note> ISBN 0-201-51379-X. </note>
Reference-contexts: The performance of this mechanism depends on the nature of the repository; for systems which use shared memory it could be quite efficient. However, the shared resource requires the additional overhead which is typically associated with synchronization problems <ref> [SPG91] </ref> (e.g., managing the critical sections). This model might not work if the mod ules that communicate are located across hardware boundaries.
Reference: [TW97] <author> Andrew S. Tanenbaum and Albert S. Woodhul. </author> <booktitle> Operating SystemsDesign and Implementation. Prentice-Hall, second edition, </booktitle> <year> 1997. </year> <note> ISBN 0-13-638677-6. </note>
Reference-contexts: This approach is well suited to high message rates or bursty traffic, such that the sender does not have to hold a message too long before passing it further. It has been successfully applied in operating systems which consist of several interacting components <ref> [TW97, CRJ87] </ref>. A consequence of the Payloads pattern is that adding new message types does not require changing the existing entities which are not interested in them. For example, in a Data flow architecture (Section 2), filters pass downstream the messages they do not understand, without performing any processing.
Reference: [Wal94] <author> William F. Walker. </author> <title> A Conversation-Based Framework For Musical Improvisation. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1994. </year>
Reference-contexts: Each component has one or two ports, which allow several types of information to flow in the network. Like AVS, two modules could be connected only if the corresponding ports are plug-compatible. Connectors are stand-alone objects which each connect 2 modules. 3. Bill Walker's Ph.D. thesis <ref> [Wal94] </ref> describes a framework that uses this pattern in the context of computer-assisted music. Unlike typical data flow architectures, his system has feed-back loops and shared state. <p> AVS [AVS93] and Iris Explorer [EXP93] are interactive visual programming tools which rely heavily on the out-of-band partition. They offer full access over the in-band partition, which can be built, configured and operated with from the user interface. Variants 1. This pattern is also present in <ref> [Wal94] </ref>. Improvisor objects (out-of-band) coordinate different Composer and Transformer objects (in-band). In this case, the out-of-band partition does not handle user interfaces. 2. The Berkeley parallel MPEG1 encoder [GR94] is partitioned in a similar way.
Reference: [X2088a] <author> CCITT Recommendation X.208: </author> <title> Specification of Abstract Syntax Notation One (ASN.1), </title> <year> 1988. </year>
Reference-contexts: The payloads also provide marshalling/unmarshalling methods which allow VuSystem mod ules to reside on different computers. 2. Abstract Syntax Notation One (ASN.1) <ref> [X2088a] </ref> is a method of specifying abstract objects in the Open Systems Interconnection (OSI) architecture. The Basic Encoding Rules [X2088b] describe how to encode values of each ASN.1 type as a string of bytes. BER encodes each part of a value as a (identifier,length,contents) tuple.
Reference: [X2088b] <author> CCITT Recommendation X.209: </author> <title> Specification of Basic Encoding Rules for Abstract Syntax Notation One (ASN.1), </title> <booktitle> 1988. </booktitle> <pages> 22 </pages>
Reference-contexts: When a source reaches the end of the input data, it signals this condition to all filters which are connected to its output (s). This 9 mechanism is propagated down the filter network until it reaches the sink. For example, the Basic Encoding Rules for ASN.1 <ref> [X2088b] </ref> reserve a special data value (the tag [UNIVERSAL 0]) for this purpose. This issue is also discussed in [BMR + 96]. If the two entities reside on separate machines, it is possible that they communicate over a high speed serial link (e.g., Ethernet). <p> The payloads also provide marshalling/unmarshalling methods which allow VuSystem mod ules to reside on different computers. 2. Abstract Syntax Notation One (ASN.1) [X2088a] is a method of specifying abstract objects in the Open Systems Interconnection (OSI) architecture. The Basic Encoding Rules <ref> [X2088b] </ref> describe how to encode values of each ASN.1 type as a string of bytes. BER encodes each part of a value as a (identifier,length,contents) tuple. The identifier and the length correspond to the descriptor component, while the contents correspond to the data component.
References-found: 32

