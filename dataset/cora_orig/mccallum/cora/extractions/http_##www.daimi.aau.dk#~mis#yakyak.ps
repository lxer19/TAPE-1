URL: http://www.daimi.aau.dk/~mis/yakyak.ps
Refering-URL: http://www.daimi.aau.dk/~mis/papers.html
Root-URL: http://www.daimi.aau.dk
Title: YakYak: Parsing with Logical Side Constraints  
Author: Niels Damgaard Nils Klarlund Michael I. Schwartzbach 
Abstract: Programming language syntax is often described by means of a context-free grammar, which is restricted by constraints programmed into the action code associated with productions. Without such code, the grammar would explode in size if it were to describe the same language. We present the tool YakYak, which extends Yacc with first-order logic for specifying constraints that are regular tree languages. Concise formulas about the parse tree replace explicit programming, and they are turned into canonical attribute grammars through tree automata calculations. YakYak is implemented as a preprocessor for Yacc, in which the transitions of the calculated tree automata are merged into the action code. We provide both practical experience and theoretical evidence that the YakYak approach results in fast and concisely specified parsers. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abdelwaheb Ayari, David Basin, and Andreas Podelski. LISA: </author> <title> A specification language based on WS2S. </title> <booktitle> In CSL '97 Proceedings, LNCS 1414, </booktitle> <year> 1998. </year>
Reference-contexts: There, we used an encoding of grammars that results in an inherent quadratic blowup, see Section 4. Similar ideas of using parse tree logic have been pursued in formal linguistics, see [11, 14] and in computer science logic <ref> [1] </ref>, but no practical applications have been demonstrated. Earlier work on the practical use of attribute grammars, like [13], tends to focus on minimizing calculations under more general circumstances. In contrast, our work deals with the generation of minimum grammars for the restricted class of synthesized attributes over finite domains. <p> implication j OE 1 ^ OE 2 conjunction j OE 1 _ OE 2 disjunction j 9ff : o .OE existential quantification j 8ff : o .OE universal quantification The constraint that a parse tree in the HTML0 grammar does not have nested anchors is expressed as: 8a : E <ref> [1] </ref>: :9b : E [1]:a &lt; b Nodes of type E [1] are anchors, and the formula simply states that no such node can appear below another of the same kind. <p> _ OE 2 disjunction j 9ff : o .OE existential quantification j 8ff : o .OE universal quantification The constraint that a parse tree in the HTML0 grammar does not have nested anchors is expressed as: 8a : E <ref> [1] </ref>: :9b : E [1]:a &lt; b Nodes of type E [1] are anchors, and the formula simply states that no such node can appear below another of the same kind.
Reference: [2] <author> M. Biehl, N. Klarlund, and T. Rauhe. </author> <title> Algorithms for guided tree automata. </title> <booktitle> In First International Workshop on Implementing Automata, WIA '96, Lecture Notes in Computer Science, </booktitle> <volume> 1260. </volume> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Generalizations of the usual tree automata algorithms, such as the subset construction and minimization, are described in <ref> [2] </ref>, where these partitioned automata are called guided tree automata. (They generalize the tree-shaped binary decision diagrams of [10], which assign different state spaces to a fixed, finite tree.) The size of a guided tree automaton is the sum of the table sizes, that is, d!(d 0 ;d 00 ) jS
Reference: [3] <author> Tim Bray, Jean Paoli, and C. M. Sperberg-McQueen. </author> <title> Extensible Markup Language (XML), </title> <note> 1997. URL: http://www.w3.org/TR/PR-xml-971208. </note>
Reference-contexts: In contrast, our work deals with the generation of minimum grammars for the restricted class of synthesized attributes over finite domains. Recently, work within the W3C promotes the use of simple side constraints on parse trees. For example, XML <ref> [3] </ref> offers a simple notation, based on regular expressions, for restrictions on the occurrence of subelements within an element. Our notation is strictly more expressive. Extensions of Yacc-like parser generators are too numerous to mention|a quick search on the web found 69 different implementations.
Reference: [4] <author> Roger F. Crew. ASTLOG: </author> <title> a language for examining abstract trees. </title> <booktitle> In Proceedings of the Conference on Domain-Specific Languages, </booktitle> <pages> pages 229-242. </pages> <publisher> USENIX, </publisher> <year> 1997. </year>
Reference-contexts: The ideas in YakYak could be incorporated into all such proposals. Several other logic notations have been proposed for parsing. Definite Clause Grammars [12] elegantly express both synthesized and inherited attributes. The backtracking nature of the semantics may result in poor runtime performance, including lack of termination. ASTLOG <ref> [4] </ref> is another Prolog inspired programming notation, where for efficiency reasons the parse tree is handled as a separate semantic object. Despite its declarative look, this language is also Turing-complete, even if it in many cases result in reasonably efficient parsers. <p> &lt; t 2 ` t 1 = t 2 ` t:i : M ` OE ` OE 1 ` OE 2 ` OE 1 ` OE 2 ` OE 1 ` OE 2 ; ff : o ` OE ; ff : o ` OE Here, nodes of type E <ref> [4] </ref> are lists, and we forbid chains of length four.
Reference: [5] <author> P Devanbu. </author> <title> GENOA: A language and front-end independent source code analyzer. </title> <journal> ACM Transactions in Software Engineering, </journal> <note> 1999. (to appear). </note>
Reference-contexts: ASTLOG [4] is another Prolog inspired programming notation, where for efficiency reasons the parse tree is handled as a separate semantic object. Despite its declarative look, this language is also Turing-complete, even if it in many cases result in reasonably efficient parsers. The GENOA system <ref> [5] </ref> provides a scripting language dedicated to the description of parse trees. A fragment of the notation expresses precisely PTIME parse tree analysis programs. The reference [5] also discusses many other similar systems. <p> Despite its declarative look, this language is also Turing-complete, even if it in many cases result in reasonably efficient parsers. The GENOA system <ref> [5] </ref> provides a scripting language dedicated to the description of parse trees. A fragment of the notation expresses precisely PTIME parse tree analysis programs. The reference [5] also discusses many other similar systems. It appears that all such systems are less declarative than ours in the sense that they explicitly model the information flow up and down the tree. Neither do they guarantee linear run time performance of the generated parser.
Reference: [6] <author> N. Klarlund. </author> <title> Mona & Fido: </title> <booktitle> the logic-automaton connection in practice. In CSL '97 Proceedings. </booktitle> <publisher> LNCS 1414, Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: First-order variables, like the ones in parse tree logic, are treated as singleton second-order variables, since singletoness can easily be encoded. The validity status of any WS2S formula can in principle be checked by an automata-theoretic decision procedure, see <ref> [6, 15] </ref>. The decision procedure works by inductively calculating a tree automaton for each subformula. <p> The class of regular tree languages (over binary trees) is the class of all L (A). The size of a tree automaton is jSj 2 . This definition is reasonable since the alphabet-part of the transition relation can often be compressed asymptotically by the BDD representation, see <ref> [6] </ref>.
Reference: [7] <author> N. Klarlund, J. Koistinen, and M. Schwartzbach. </author> <title> Formal design constraints. </title> <booktitle> In Proc. OOPSLA '96, </booktitle> <year> 1996. </year>
Reference-contexts: Parse Tree Logic We propose an alternative approach where the underlying grammar is defined in the usual way, but the constraints are specified in a concise, formal logic on parse trees. In <ref> [7] </ref>, we presented such a logic, called CDL, and demonstrated that it could be useful for capturing design constraints for object-oriented programs. We developed a prototype implementation that could transform constraints into simple attribute grammars that were intended to be included into syntax-directed editors. <p> Related Work To our knowledge, the idea of using a first-order like parse tree logic to generate attribute grammars has been presented earlier only in our previous paper <ref> [7] </ref>, which suggested how such a logic can be used to enforce design constraints or software architectures. There, we used an encoding of grammars that results in an inherent quadratic blowup, see Section 4. <p> Thus, we have the following result: Proposition 1 Under the conventional encoding, the size of a tree automaton recognizing the well-formedness predicate is quadratic in the size of the grammar. This is the encoding we used in the CDL design constraint tool <ref> [7] </ref>, and which sometimes prevented it from scaling to interesting grammars. A Shape Encoding We introduce here a representation that is by shape only.
Reference: [8] <author> Nils Klarlund and Anders Moller. </author> <title> MONA Version 1.2 User Manual. </title> <booktitle> BRICS, </booktitle> <address> ns-98-3 edition, </address> <year> 1998. </year> <pages> ISSN 0909-3206. </pages>
Reference-contexts: In particular, the specification of a constraint does not involve a laborious encoding of the flow of attribute values up and down the tree. Rather, the formulas are translated into tree automata by the Mona tool according to a decision procedure recently implemented <ref> [8] </ref>. The tree automata represent low-level attribute grammars, which detail the minimum information flow implicit in the formulas across the set of nonterminals. The use of automata is essential to good runtime performance.
Reference: [9] <author> D. Kozen. </author> <title> On the Myhill-Nerode theorem for trees. </title> <journal> EATCS Bulletin, </journal> <volume> 47, </volume> <year> 1992. </year>
Reference-contexts: the alphabet itself plus a couple of auxiliary states whereas without such labeling, the automaton would possibly have to process many possible right hand sides at the same time until the nonterminal was reached. (These arguments are standard in automata theory and can be shown through Myhill-Nerode congruence arguments; see <ref> [9] </ref>). The automaton that we have described is minimum. Thus, we have the following result: Proposition 1 Under the conventional encoding, the size of a tree automaton recognizing the well-formedness predicate is quadratic in the size of the grammar.
Reference: [10] <author> K. McMillan. </author> <title> Hierarchical representations of discrete functions, with applications to model checking. </title> <booktitle> In Proc. Computer Aided Verification, </booktitle> <publisher> LNCS 818. Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Generalizations of the usual tree automata algorithms, such as the subset construction and minimization, are described in [2], where these partitioned automata are called guided tree automata. (They generalize the tree-shaped binary decision diagrams of <ref> [10] </ref>, which assign different state spaces to a fixed, finite tree.) The size of a guided tree automaton is the sum of the table sizes, that is, d!(d 0 ;d 00 ) jS d 0 j jS d 00 j.
Reference: [11] <author> Frank Morawietz and Tom Cornell. </author> <booktitle> The logic-automaton connection in linguistics. In Proceedings of LACL 1997, </booktitle> <publisher> LNAI. </publisher> <address> Springer, </address> <note> To appear. </note>
Reference-contexts: There, we used an encoding of grammars that results in an inherent quadratic blowup, see Section 4. Similar ideas of using parse tree logic have been pursued in formal linguistics, see <ref> [11, 14] </ref> and in computer science logic [1], but no practical applications have been demonstrated. Earlier work on the practical use of attribute grammars, like [13], tends to focus on minimizing calculations under more general circumstances.
Reference: [12] <author> F. Pereira and D. Warren. </author> <title> Definite Clause Grammars for language analysis|a survey of the formalism and a comparison with augmented transition networks. </title> <journal> Journal of Artificial Intelligence, </journal> <volume> 13 </volume> <pages> 231-278, </pages> <year> 1980. </year>
Reference-contexts: They focus on supporting different target languages, handling EBNF notation, coping with larger classes of grammars, adding attribute evaluations, or automatically building syntax trees. The ideas in YakYak could be incorporated into all such proposals. Several other logic notations have been proposed for parsing. Definite Clause Grammars <ref> [12] </ref> elegantly express both synthesized and inherited attributes. The backtracking nature of the semantics may result in poor runtime performance, including lack of termination. ASTLOG [4] is another Prolog inspired programming notation, where for efficiency reasons the parse tree is handled as a separate semantic object.
Reference: [13] <author> T. Reps. </author> <title> Generating Language-Based Environments. </title> <publisher> The M.I.T. Press, </publisher> <year> 1984. </year>
Reference-contexts: Similar ideas of using parse tree logic have been pursued in formal linguistics, see [11, 14] and in computer science logic [1], but no practical applications have been demonstrated. Earlier work on the practical use of attribute grammars, like <ref> [13] </ref>, tends to focus on minimizing calculations under more general circumstances. In contrast, our work deals with the generation of minimum grammars for the restricted class of synthesized attributes over finite domains. Recently, work within the W3C promotes the use of simple side constraints on parse trees.
Reference: [14] <author> James Rogers. </author> <title> Studies in the logic of trees with applications to grammar formalisms. </title> <type> PhD thesis, </type> <institution> University of Delaware, </institution> <year> 1994. </year>
Reference-contexts: There, we used an encoding of grammars that results in an inherent quadratic blowup, see Section 4. Similar ideas of using parse tree logic have been pursued in formal linguistics, see <ref> [11, 14] </ref> and in computer science logic [1], but no practical applications have been demonstrated. Earlier work on the practical use of attribute grammars, like [13], tends to focus on minimizing calculations under more general circumstances.
Reference: [15] <author> W. Thomas. </author> <title> Automata on infinite objects. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> volume B, </volume> <pages> pages 133-191. </pages> <publisher> MIT Press/Elsevier, </publisher> <year> 1990. </year> <month> 15 </month>
Reference-contexts: First-order variables, like the ones in parse tree logic, are treated as singleton second-order variables, since singletoness can easily be encoded. The validity status of any WS2S formula can in principle be checked by an automata-theoretic decision procedure, see <ref> [6, 15] </ref>. The decision procedure works by inductively calculating a tree automaton for each subformula.
References-found: 15

