URL: http://www-cad.eecs.berkeley.edu/~orna/publications/cav96b.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~orna/pub.html
Root-URL: 
Email: Email: ok@research.att.com  Email: vardi@cs.rice.edu  
Title: Verification of Fair Transition Systems  
Author: Orna Kupferman Moshe Y. Vardi 
Date: June 28, 1996  
Address: 600 Mountain Avenue Murray Hill NJ 07974, U.S.A.  Houston TX 77251-1892, U.S.A.  
Affiliation: Bell Laboratories  Department of Computer Science Rice University  
Abstract: In program verification, we check that an implementation meets its specification. Both the specification and the implementation describe the possible behaviors of the program, though at different levels of abstraction. We distinguish between two approaches to implementation of specifications. The first approach is trace-based implementation, where we require every computation of the implementation to correlate to some computation of the specification. The second approach is tree-based implementation, where we require every computation tree embodied in the implementation to correlate to some computation tree embodied in the specification. The two approaches to implementation are strongly related to the linear-time versus branching-time dichotomy in temporal logic. In this work we examine the trace-based and the tree-based approaches from a complexity-theoretic point of view. We consider and compare the complexity of verification of fair transition systems, modeling both the implementation and the specification, in the two approaches. We consider unconditional, weak , and strong fairness. For the trace-based approach, the corresponding problem is fair containment. For the tree-based approach, the corresponding problem is fair simulation. We show that while both problems are PSPACE-complete, their complexities in terms of the size of the implementation do not coincide and the trace-based approach is easier. As the implementation is normally much bigger than the specification, we see this as an advantage of the trace-based approach. Our results are at variance with the known results for the case of transition systems with no fairness, where the tree-based approach is easier. 
Abstract-found: 1
Intro-found: 1
Reference: [AL91] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction In program verification, we check that an implementation meets its specification. Both the specification and the implementation describe the possible behaviors of the program, but the implementation is more concrete than the specification, or, equivalently, the specification is more abstract than the implementation (cf. <ref> [AL91] </ref>). This basic notion of verification suggests a top-down method for design development. Starting with a highly abstract specification, we can construct a sequence of "behavior descriptions". Each description refers to its predecessor as a specification, so it is less abstract than its predecessor. <p> Then, correct trace-based implementation is one in which every computation is also a computation of the specification, and correct tree-based implementation is one in which every embodied computation tree is also embodied in the specification. Numerous interpretations of correlation are suggested and studied in the literature <ref> [Hen85, Mil89, AL91] </ref>.
Reference: [ASB + 94] <author> A. Aziz, V. Singhal, F. Balarin, R. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> Equivalences for fair kripke structures. </title> <booktitle> In Proc. 21st Int. Colloquium on Automata, Languages and Programming, </booktitle> <address> Jerusalem, Israel, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: We consider unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) [LPS81, Eme90, MP92]. Within this framework, correct trace-based implementation corresponds to fair containment and correct tree-based implementation corresponds to fair simulation <ref> [BBLS92, ASB + 94, GL94] </ref>. Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches. We present a uniform method and a simple algorithm for solving the fair-containment problem for all the three types of fairness conditions.
Reference: [BBLS92] <author> S. Bensalem, A. Bouajjani, C. Loiseaux, and J. Sifakis. </author> <title> Property preserving simulations. </title> <booktitle> In Proc. 4th Workshop on Computer Aided Verification, volume 663 of Lecture Notes in Computer Science, </booktitle> <address> Montreal, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We consider unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) [LPS81, Eme90, MP92]. Within this framework, correct trace-based implementation corresponds to fair containment and correct tree-based implementation corresponds to fair simulation <ref> [BBLS92, ASB + 94, GL94] </ref>. Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches. We present a uniform method and a simple algorithm for solving the fair-containment problem for all the three types of fairness conditions.
Reference: [BCG88] <author> M.C. Browne, E.M. Clarke, and O. Grumberg. </author> <title> Characterizing finite Kripke structures in propositional temporal logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 115-131, </pages> <year> 1988. </year>
Reference-contexts: Intuitively, it means that the transition system S 0 has more behaviors than the transition system S. In fact, every 8CTL ? formula that is satisfied in S 0 is satisfied also in S <ref> [BCG88] </ref>. The simulation problem is, given S and S 0 , to determine whether S S 0 . We mention here also the bisimulation problem [Mil71]. Two transition systems are bisimilar iff they have exactly the same behaviour.
Reference: [BGS92] <author> J. Balcazar, J. Gabarro, and M. Santha. </author> <title> Deciding bisimilarity is P-complete. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4(6) </volume> <pages> 638-648, </pages> <year> 1992. </year>
Reference-contexts: Within this framework, correct trace-based implementation corresponds to containment and correct tree-based implementation corresponds to simulation [Mil71]. We start by reviewing and examining transition systems with no fairness condition. It is well-known that simulation can be checked in polynomial time <ref> [Mil80, BGS92] </ref>, whereas the containment problem is in PSPACE [SVW87]. We show that the latter problem is PSPACE-hard; thus the tree-based approach is easier than the trace-based approach. Yet, once we turn to consider the implementation complexity of simulation and containment, the trace-based approach is easier than the tree-based approach. <p> Yet, for every problem P , we have that P is NLOGSPACE-complete iff P is co-NLOGSPACE-complete (see [Imm88, Sze88] for NLOGSPACE=co-NLOGSPACE. The argument for the completeness is easy). 9 Proof: The upper bound is given in [Mil80]. The lower bound follows from the reduction in <ref> [BGS92] </ref> (the reduction there proves PTIME-hardness for bisimulation, but it is valid also for simulation). Theorem 3.4 The implementation complexity of the simulation problem is PTIME-complete. Proof: Membership in PTIME follows from Theorem 3.3.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Computer Aided Verification, Proc. 6th Int. Conference, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-155, </pages> <address> Stanford, June 1994. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address> <month> 24 </month>
Reference-contexts: This is reminiscent of the computational relations of branching-time model checking and linear-time model checking: while model checking is easier for the branching paradigm, the implementation complexity of model checking in the two paradigm coincide <ref> [LP85, CES86, VW86, BVW94] </ref>. Often, we want our implementations and specifications to describe behaviors that satisfy both liveness and safety properties. Then, transition systems with no fairness condition are too weak and we need the framework of fair transition systems. <p> When we turn to consider the program complexity of model checking, which is the analogue to our implementation complexity, this is no longer true. The program complexity of model checking for both LTL and 8CTL ? is 23 NLOGSPACE-complete <ref> [VW86, BVW94] </ref>. In contrast, we saw here that implementation is easier in the trace-based approach. Our results are summarized in the table below.
Reference: [CD88] <author> E.M. Clarke and I.A. Draghicescu. </author> <title> Expressibility results for linear-time and branching-time logics. In Proc. Workshop on Linear Time, Branching Time, and Partial Order in Logics and Models for Concurrency, </title> <booktitle> pages 428-437. Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The two approaches to implementation are strongly related to the linear-time versus branching-time dichotomy in temporal logic [Pnu85]. The temporal-logic analogy to the strength of the tree-based approach is the expressiveness superiority of 8CTL ? , the universal fragment of CTL ? , over LTL <ref> [CD88] </ref>. Indeed, while a correct trace-based implementation is guaranteed to satisfy all the LTL formulas satisfied in the specification, a correct tree-based implementation is guaranteed to satisfy all the 8CTL ? formulas satisfied in the specification [GL94].
Reference: [CDK93] <author> E. M. Clarke, I. A. Draghicescu, and R. P. Kurshan. </author> <title> A unified approach for showing language containment and equivalence between various types of !-automata. </title> <journal> Information Processing Letters 46, </journal> <pages> pages 301-308, </pages> <year> (1993). </year>
Reference-contexts: Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches. We present a uniform method and a simple algorithm for solving the fair-containment problem for all the three types of fairness conditions. Unlike <ref> [CDK93] </ref>, we consider the case where both the specification and the implementation are nondeterministic, as is appropriate in a hierarchical refinement framework. We prove that the problem is PSPACE-complete for all the three types.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: This is reminiscent of the computational relations of branching-time model checking and linear-time model checking: while model checking is easier for the branching paradigm, the implementation complexity of model checking in the two paradigm coincide <ref> [LP85, CES86, VW86, BVW94] </ref>. Often, we want our implementations and specifications to describe behaviors that satisfy both liveness and safety properties. Then, transition systems with no fairness condition are too weak and we need the framework of fair transition systems.
Reference: [Cho74] <author> Y. Choueka. </author> <title> Theories of automata on !-tapes: A simplified approach. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 8 </volume> <pages> 117-141, </pages> <year> 1974. </year>
Reference-contexts: The result then follows from the known bound on the size of the product of unconditionally fair transition systems <ref> [Cho74] </ref>. <p> Similarly, for all the three types of S 0 , going to S 0 U involves an at most exponential blow up. Thus, the size of the product of S U and S 0 U is exponential in the sizes of S and S 0 <ref> [Cho74] </ref>. By [VW94], the nonemptiness problem for unconditionally fair transition systems is in NLOGSPACE. Hence, as NLOGSPACE=co-NLOGSPACE, checking the product of S U and S 0 U for emptiness can be done in space polynomial in their sizes.
Reference: [EL85] <author> E.A. Emerson and C.-L. Lei. </author> <title> Temporal model checking under generalized fairness constraints. </title> <booktitle> In Proc. 18th Hawaii International Conference on System Sciences, Hawaii, </booktitle> <year> 1985. </year>
Reference-contexts: Unlike the algorithm there, we do not translate the transition system S to an unconditionally fair system. Rather, we check the nonemptiness of T (S) " T (S 0 U ). The nonemptiness problem for strongly fair transition systems can be solved in polynomial time <ref> [EL85] </ref>. Hence, by Lemma 4.6, we can check the nonemptiness of the intersection in time polynomial in the size of S. <p> Trace-based implementations are part of the linear-time paradigm and correspond to LTL model checking. Tree-based implementations are part of the branching-time paradigm and correspond to 8CTL ? model checking. All the four problems are PSPACE-complete <ref> [SC85, EL85] </ref>. The model-checking algorithm of 8CTL ? uses as a subroutine the model-checking algorithm of LTL [EL85]. In a similar manner, our fair-simulation algorithm uses as a subroutine the fair-containment algorithm. So, the implementation dichotomy and the temporal-logic dichotomy have a lot in common. <p> Tree-based implementations are part of the branching-time paradigm and correspond to 8CTL ? model checking. All the four problems are PSPACE-complete [SC85, EL85]. The model-checking algorithm of 8CTL ? uses as a subroutine the model-checking algorithm of LTL <ref> [EL85] </ref>. In a similar manner, our fair-simulation algorithm uses as a subroutine the fair-containment algorithm. So, the implementation dichotomy and the temporal-logic dichotomy have a lot in common.
Reference: [Eme90] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pages 997-1072, </pages> <year> 1990. </year>
Reference-contexts: Then, transition systems with no fairness condition are too weak and we need the framework of fair transition systems. We consider unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) <ref> [LPS81, Eme90, MP92] </ref>. Within this framework, correct trace-based implementation corresponds to fair containment and correct tree-based implementation corresponds to fair simulation [BBLS92, ASB + 94, GL94]. Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches.
Reference: [GHR95] <author> R. Greenlaw, H.J. Hoover, and W.L. Ruzzo. </author> <title> Limits of parallel computation. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Theorem 3.4 The implementation complexity of the simulation problem is PTIME-complete. Proof: Membership in PTIME follows from Theorem 3.3. We prove hardness in PTIME by reducing the NAND Circuit Value Problem (NANDCV), proved to be PTIME-complete in <ref> [Gol77, GHR95] </ref>, to the problem of determining whether a transition system S simulates a fixed transition system S 0 , both with no fairness.
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: Indeed, while a correct trace-based implementation is guaranteed to satisfy all the LTL formulas satisfied in the specification, a correct tree-based implementation is guaranteed to satisfy all the 8CTL ? formulas satisfied in the specification <ref> [GL94] </ref>. In this work we examine the traced-based and the tree-based approaches from a complexity-theoretic point of view. <p> We consider unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) [LPS81, Eme90, MP92]. Within this framework, correct trace-based implementation corresponds to fair containment and correct tree-based implementation corresponds to fair simulation <ref> [BBLS92, ASB + 94, GL94] </ref>. Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches. We present a uniform method and a simple algorithm for solving the fair-containment problem for all the three types of fairness conditions. <p> Let w and w 0 be states in W and W 0 , respectively. A relation H W fi W 0 is a fair simulation relation from hS; wi to hS 0 ; w 0 i iff the following conditions hold <ref> [GL94] </ref>. (1) H (w; w 0 ). (2) For all t and t 0 with H (t; t 0 ), we have L (t) = L (t 0 ). (3) For all t and t 0 with H (t; t 0 ), the pair ht; t 0 i is good in <p> In fact, every fair-8CTL ? formula (that is, every 8CTL ? formula with path quantification ranging over fair computations only) that is satisfied in S 0 , is satisfied also in S <ref> [GL94] </ref>. The fair-simulation problem is, given S and S 0 , to determine whether S S 0 . Note that when they relate non-fair transition systems, fair simulation and simulation coincide. We mention here also the fair-bisimulation problem [GL94]. <p> that is satisfied in S 0 , is satisfied also in S <ref> [GL94] </ref>. The fair-simulation problem is, given S and S 0 , to determine whether S S 0 . Note that when they relate non-fair transition systems, fair simulation and simulation coincide. We mention here also the fair-bisimulation problem [GL94]. Two transition systems are bisimilar iff they have exactly the same fair behaviour.
Reference: [Gol77] <author> L.M. Goldschlager. </author> <title> The monotone and planar circuit value problems are log space complete for p. </title> <journal> SIGACT News, </journal> <volume> 9(2) </volume> <pages> 25-29, </pages> <year> 1977. </year>
Reference-contexts: Theorem 3.4 The implementation complexity of the simulation problem is PTIME-complete. Proof: Membership in PTIME follows from Theorem 3.3. We prove hardness in PTIME by reducing the NAND Circuit Value Problem (NANDCV), proved to be PTIME-complete in <ref> [Gol77, GHR95] </ref>, to the problem of determining whether a transition system S simulates a fixed transition system S 0 , both with no fairness.
Reference: [Hen85] <author> M. Hennessy. </author> <title> Algebraic theory of Processes. </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1985. </year>
Reference-contexts: Then, correct trace-based implementation is one in which every computation is also a computation of the specification, and correct tree-based implementation is one in which every embodied computation tree is also embodied in the specification. Numerous interpretations of correlation are suggested and studied in the literature <ref> [Hen85, Mil89, AL91] </ref>.
Reference: [Imm88] <author> N. Immerman. </author> <title> Nondeterministic space is closed under complement. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17 </volume> <pages> 935-938, </pages> <year> 1988. </year>
Reference-contexts: Yet, for every problem P , we have that P is NLOGSPACE-complete iff P is co-NLOGSPACE-complete (see <ref> [Imm88, Sze88] </ref> for NLOGSPACE=co-NLOGSPACE. The argument for the completeness is easy). 9 Proof: The upper bound is given in [Mil80]. The lower bound follows from the reduction in [BGS92] (the reduction there proves PTIME-hardness for bisimulation, but it is valid also for simulation).
Reference: [Jon75] <author> N.D. Jones. </author> <title> Space-bounded reducibility among combinatorial problems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 11 </volume> <pages> 68-75, </pages> <year> 1975. </year>
Reference-contexts: Proof: In Theorem 4.5, we prove an NLOGSPACE upper bound for the implementation complexity of the more general fair-containment problem for unconditionally fair transition systems. The lower bound follows easily by a reduction from the non-reachability problem in a directed graph, proved to be NLOGSPACE-complete in <ref> [Jon75] </ref> 1 . <p> Since we can specify the expression in the right with a fixed non-fair transition system, we are done. 3.2 The Complexity of the Simulation Problem Theorem 3.3 The simulation problem is PTIME-complete. 1 The proof in <ref> [Jon75] </ref> is for the reachability problem. Yet, for every problem P , we have that P is NLOGSPACE-complete iff P is co-NLOGSPACE-complete (see [Imm88, Sze88] for NLOGSPACE=co-NLOGSPACE. The argument for the completeness is easy). 9 Proof: The upper bound is given in [Mil80].
Reference: [Kel76] <author> R.M. Keller. </author> <title> Formal verification of parallel programs. </title> <journal> Comm ACM, </journal> <volume> 19 </volume> <pages> 371-384, </pages> <year> 1976. </year>
Reference-contexts: Therefore, of particular interest to us is the implementation complexity of these problems; i.e., their complexity in terms of I, assuming S is fixed. We model specifications and implementations by transition systems <ref> [Kel76] </ref>. The systems are defined over the sets AP I and AP S of atomic propositions used in the implementation and specification, respectively. Thus, the alphabets of the systems are 2 AP I and 2 AP S . Recall that usually the implementation has more variables than the specification.
Reference: [Kur87] <author> R.P. Kurshan. </author> <title> Complementing deterministic Buchi automata in polynomial time. </title> <journal> Journal of Compututer and System Science, </journal> <volume> 35 </volume> <pages> 59-71, </pages> <year> 1987. </year>
Reference-contexts: Proof: The idea, as suggested in <ref> [Kur87] </ref>, is that the transition system S 0 guesses a position in each of its computations from which no state of B can be visited. For that, it maintains two copies of S. The first copy allows visits in states in B.
Reference: [Kur94] <author> R.P. Kurshan. </author> <title> Computer Aided Verification of Coordinating Processes. </title> <publisher> Princeton Univ. Press, </publisher> <year> 1994. </year>
Reference-contexts: Each description refers to its predecessor as a specification, so it is less abstract than its predecessor. The last description contains no abstractions, and constitutes the implementation. Hence the name hierarchical refinement for this methodology (cf. <ref> [LS84, LT87, Kur94] </ref>). We distinguish between two approaches to implementation of specifications. The first approach is trace-based implementation, where we require every computation of the implementation to correlate to some computation of the specification.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year> <month> 25 </month>
Reference-contexts: This is reminiscent of the computational relations of branching-time model checking and linear-time model checking: while model checking is easier for the branching paradigm, the implementation complexity of model checking in the two paradigm coincide <ref> [LP85, CES86, VW86, BVW94] </ref>. Often, we want our implementations and specifications to describe behaviors that satisfy both liveness and safety properties. Then, transition systems with no fairness condition are too weak and we need the framework of fair transition systems.
Reference: [LPS81] <author> D. Lehman, A. Pnueli, and J. Stavi. Impartiality, </author> <title> justice, and fairness the ethic of concurrent termination. </title> <booktitle> In Proc. 8th Colloq. on Automata, Programming, and Languages (ICALP), volume 115 of Lecture Notes in Computer Science, </booktitle> <pages> pages 264-277. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1981. </year>
Reference-contexts: Then, transition systems with no fairness condition are too weak and we need the framework of fair transition systems. We consider unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) <ref> [LPS81, Eme90, MP92] </ref>. Within this framework, correct trace-based implementation corresponds to fair containment and correct tree-based implementation corresponds to fair simulation [BBLS92, ASB + 94, GL94]. Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches.
Reference: [LS84] <author> S.S. Lam and A.U. Shankar. </author> <title> Protocol verification via projection. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 10 </volume> <pages> 325-342, </pages> <year> 1984. </year>
Reference-contexts: Each description refers to its predecessor as a specification, so it is less abstract than its predecessor. The last description contains no abstractions, and constitutes the implementation. Hence the name hierarchical refinement for this methodology (cf. <ref> [LS84, LT87, Kur94] </ref>). We distinguish between two approaches to implementation of specifications. The first approach is trace-based implementation, where we require every computation of the implementation to correlate to some computation of the specification.
Reference: [LT87] <author> N. A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proc. 6th ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <year> 1987. </year>
Reference-contexts: Each description refers to its predecessor as a specification, so it is less abstract than its predecessor. The last description contains no abstractions, and constitutes the implementation. Hence the name hierarchical refinement for this methodology (cf. <ref> [LS84, LT87, Kur94] </ref>). We distinguish between two approaches to implementation of specifications. The first approach is trace-based implementation, where we require every computation of the implementation to correlate to some computation of the specification.
Reference: [Mil71] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Proceedings of the 2nd International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 481-489, </pages> <month> September </month> <year> 1971. </year>
Reference-contexts: In other words, associating computations and computation trees of the implementation with these of the specification, we first project them on AP S . Within this framework, correct trace-based implementation corresponds to containment and correct tree-based implementation corresponds to simulation <ref> [Mil71] </ref>. We start by reviewing and examining transition systems with no fairness condition. It is well-known that simulation can be checked in polynomial time [Mil80, BGS92], whereas the containment problem is in PSPACE [SVW87]. <p> A relation H W fi W 0 is a simulation relation from hS; wi to hS 0 ; w 0 i iff the following conditions hold <ref> [Mil71] </ref>. (1) H (w; w 0 ). (2) For all t and t 0 with H (t; t 0 ), we have L (t) = L (t 0 ). (3) For all t and t 0 with H (t; t 0 ) and for all s 2 W such that R <p> In fact, every 8CTL ? formula that is satisfied in S 0 is satisfied also in S [BCG88]. The simulation problem is, given S and S 0 , to determine whether S S 0 . We mention here also the bisimulation problem <ref> [Mil71] </ref>. Two transition systems are bisimilar iff they have exactly the same behaviour.
Reference: [Mil80] <author> R. Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: The tree-based approach is stronger in the following sense. If I is a correct tree-based implementation of the specification S, then I is also a correct trace-based implementation of S. As shown by Milner <ref> [Mil80] </ref>, the opposite direction is not true. The two approaches to implementation are strongly related to the linear-time versus branching-time dichotomy in temporal logic [Pnu85]. <p> Within this framework, correct trace-based implementation corresponds to containment and correct tree-based implementation corresponds to simulation [Mil71]. We start by reviewing and examining transition systems with no fairness condition. It is well-known that simulation can be checked in polynomial time <ref> [Mil80, BGS92] </ref>, whereas the containment problem is in PSPACE [SVW87]. We show that the latter problem is PSPACE-hard; thus the tree-based approach is easier than the trace-based approach. Yet, once we turn to consider the implementation complexity of simulation and containment, the trace-based approach is easier than the tree-based approach. <p> Yet, for every problem P , we have that P is NLOGSPACE-complete iff P is co-NLOGSPACE-complete (see [Imm88, Sze88] for NLOGSPACE=co-NLOGSPACE. The argument for the completeness is easy). 9 Proof: The upper bound is given in <ref> [Mil80] </ref>. The lower bound follows from the reduction in [BGS92] (the reduction there proves PTIME-hardness for bisimulation, but it is valid also for simulation). Theorem 3.4 The implementation complexity of the simulation problem is PTIME-complete. Proof: Membership in PTIME follows from Theorem 3.3.
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrecny. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Clifs, </address> <year> 1989. </year>
Reference-contexts: Then, correct trace-based implementation is one in which every computation is also a computation of the specification, and correct tree-based implementation is one in which every embodied computation tree is also embodied in the specification. Numerous interpretations of correlation are suggested and studied in the literature <ref> [Hen85, Mil89, AL91] </ref>.
Reference: [Mil90] <author> R. Milner. </author> <title> Operational and algebraic semantics of concurrent processes. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pages 1201-1242, </pages> <year> 1990. </year>
Reference-contexts: Our algorithm uses the fair-containment algorithm as a subroutine. We prove that the problem is PSPACE-complete for all the three types. Like Milner's algorithm for checking simulation <ref> [Mil90] </ref>, our algorithm can be implemented as a calculation of a fixed-point expression. The running time of our algorithm is polynomial in the size of the implementation. We show that this is optimal; thus, the implementation complexity of fair simulation is PTIME-complete for all types of fairness conditions. <p> Thus, fixing S 0 , the problem of checking a candidate relation H is in PTIME. Instead of guessing a relation H and checking it, we do a fixed-point computation as follows (cf. <ref> [Mil90] </ref>). Let H 0 = fhw; w 0 i : w 2 W; w 0 2 W 0 ; and L (w) = L (w 0 )g. Thus, H 0 is the maximal relation that satisfies condition (1) of fair simulation.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Then, transition systems with no fairness condition are too weak and we need the framework of fair transition systems. We consider unconditional, weak, and strong fairness (also known as impartiality, justice, and compassion, respectively) <ref> [LPS81, Eme90, MP92] </ref>. Within this framework, correct trace-based implementation corresponds to fair containment and correct tree-based implementation corresponds to fair simulation [BBLS92, ASB + 94, GL94]. Hence, it is the complexity of these problems that should be examined when we compare the trace-based and the tree-based approaches.
Reference: [MS72] <author> A.R. Meyer and L.J. Stockmeyer. </author> <title> The equivalence problem for regular expressions with squaring requires exponential time. </title> <booktitle> In Proc. 13th IEEE Symp. on Switching and Automata Theory, </booktitle> <pages> pages 125-129, </pages> <year> 1972. </year>
Reference-contexts: We call the states in ff final states. A finite-acceptance transition system S is universal iff T (S) = fl . In <ref> [MS72] </ref>, Mayer and Stockmayer prove a PSPACE lower bound for the problem of determining whether a finite-acceptance transition system S is universal (the framework in [MS72] is of regular expressions, yet regular expressions can be linearly translated to finite-acceptance transition systems). <p> We call the states in ff final states. A finite-acceptance transition system S is universal iff T (S) = fl . In <ref> [MS72] </ref>, Mayer and Stockmayer prove a PSPACE lower bound for the problem of determining whether a finite-acceptance transition system S is universal (the framework in [MS72] is of regular expressions, yet regular expressions can be linearly translated to finite-acceptance transition systems). We reduce the universality problem for finite-acceptance transition systems to the trace-containment problem. Consider a finite-acceptance transition system S = h; W; R; W; L; ffi. <p> The universality problem is to determine whether a given transition system is universal. As we 18 have already mentioned in the proof of Theorem 3.1, Mayer and Stockmayer prove a PSPACE lower bound for the problem of determining whether a finite-acceptance transition system S is universal <ref> [MS72] </ref>. Our PSPACE lower bound for the fair-simulation problem follows the lines of their proofs and we first give here its details, easily adjusted to infinite traces. Theorem 5.2 The universality problem, L (S) = ! for S 2 fU ; W; Sg, is PSPACE-hard.
Reference: [Pla84] <author> D.A. Plaisted. </author> <title> Complete problems in the first-order predicate claculus. </title> <journal> J. on Computer and System Sciences, </journal> <volume> 29(1) </volume> <pages> 8-35, </pages> <year> 1984. </year>
Reference-contexts: Thus, a propositional anti-Horn clause is either of the form p ! q 1 _ _ q n (an empty disjunction is equivalent to false) or of the form q 1 _ _ q n . As Propositional-Horn Satisfiability is PTIME-complete <ref> [Pla84] </ref>, then clearly, so is PAHS.
Reference: [Pnu85] <author> A. Pnueli. </author> <title> Linear and branching structures in the semantics and logics of reactive systems. </title> <booktitle> In Proc. 12th Int. Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 15-32. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: If I is a correct tree-based implementation of the specification S, then I is also a correct trace-based implementation of S. As shown by Milner [Mil80], the opposite direction is not true. The two approaches to implementation are strongly related to the linear-time versus branching-time dichotomy in temporal logic <ref> [Pnu85] </ref>. The temporal-logic analogy to the strength of the tree-based approach is the expressiveness superiority of 8CTL ? , the universal fragment of CTL ? , over LTL [CD88].
Reference: [Saf88] <author> S. Safra. </author> <title> On the complexity of omega-automata. </title> <booktitle> In Proceedings of the 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: We also use a line over the transition system to denote the complementary transition system (one that accepts the complementary trace). For example, the transition system complementing a strongly fair transition system with n states and m pairs is denoted S (n; m). By <ref> [Saf88, Saf92] </ref>, every fair transition system indeed has a complementary transition system. 2.2 Trace-Based and Tree-Based implementations In this section we formalize the relations of correct trace-based and tree-based implementation between an implementation S and a specification S 0 . <p> W (n; m) ! U (nm) [Lemma 4.1]. 3. S (n; m) ! U (n2 O (m) ) [Lemma 4.3]. This is how we perform step (2) for the three possible types of S 0 . 1. U (n) ! U (2 O (n log n) ) <ref> [Saf88] </ref>. 3. S (n; m) ! S (2 O (nm log (nm)) ; nm) ! U (2 O (nm log (nm)) ) [Saf92]. For all the three types of S, going to S U involves an at most exponential blow up.
Reference: [Saf92] <author> S. Safra. </author> <title> Exponential determinization for !-automata with strong-fairness acceptance condition. </title> <booktitle> In Proceedings of the 24th ACM Symposium on Theory of Computing, </booktitle> <address> Victoria, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: We also use a line over the transition system to denote the complementary transition system (one that accepts the complementary trace). For example, the transition system complementing a strongly fair transition system with n states and m pairs is denoted S (n; m). By <ref> [Saf88, Saf92] </ref>, every fair transition system indeed has a complementary transition system. 2.2 Trace-Based and Tree-Based implementations In this section we formalize the relations of correct trace-based and tree-based implementation between an implementation S and a specification S 0 . <p> This is how we perform step (2) for the three possible types of S 0 . 1. U (n) ! U (2 O (n log n) ) [Saf88]. 3. S (n; m) ! S (2 O (nm log (nm)) ; nm) ! U (2 O (nm log (nm)) ) <ref> [Saf92] </ref>. For all the three types of S, going to S U involves an at most exponential blow up. Similarly, for all the three types of S 0 , going to S 0 U involves an at most exponential blow up.
Reference: [SC85] <author> A.P. Sistla and E.M. Clarke. </author> <title> The complexity of propositional linear temporal logic. </title> <journal> J. ACM, </journal> <volume> 32 </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: Trace-based implementations are part of the linear-time paradigm and correspond to LTL model checking. Tree-based implementations are part of the branching-time paradigm and correspond to 8CTL ? model checking. All the four problems are PSPACE-complete <ref> [SC85, EL85] </ref>. The model-checking algorithm of 8CTL ? uses as a subroutine the model-checking algorithm of LTL [EL85]. In a similar manner, our fair-simulation algorithm uses as a subroutine the fair-containment algorithm. So, the implementation dichotomy and the temporal-logic dichotomy have a lot in common.
Reference: [SVW87] <author> A.P. Sistla, M.Y. Vardi, and P. Wolper. </author> <title> The complementation problem for Buchi automata with applications to temporal logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 217-237, </pages> <year> 1987. </year>
Reference-contexts: Within this framework, correct trace-based implementation corresponds to containment and correct tree-based implementation corresponds to simulation [Mil71]. We start by reviewing and examining transition systems with no fairness condition. It is well-known that simulation can be checked in polynomial time [Mil80, BGS92], whereas the containment problem is in PSPACE <ref> [SVW87] </ref>. We show that the latter problem is PSPACE-hard; thus the tree-based approach is easier than the trace-based approach. Yet, once we turn to consider the implementation complexity of simulation and containment, the trace-based approach is easier than the tree-based approach.
Reference: [Sze88] <author> R. Szelepcsinyi. </author> <title> The method of forced enumeration for nondeterministic automata. </title> <journal> Acta Informatica, </journal> <volume> 26 </volume> <pages> 279-284, </pages> <year> 1988. </year>
Reference-contexts: Yet, for every problem P , we have that P is NLOGSPACE-complete iff P is co-NLOGSPACE-complete (see <ref> [Imm88, Sze88] </ref> for NLOGSPACE=co-NLOGSPACE. The argument for the completeness is easy). 9 Proof: The upper bound is given in [Mil80]. The lower bound follows from the reduction in [BGS92] (the reduction there proves PTIME-hardness for bisimulation, but it is valid also for simulation).
Reference: [Tho90] <author> W. Thomas. </author> <title> Automata on infinite objects. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 165-191, </pages> <year> 1990. </year>
Reference-contexts: In addition, we consider non-fair transition systems; i.e., transition systems in which all the computations are fair. It is easy to see is that fair transition systems are essentially a notational variant of automata on infinite words <ref> [Tho90] </ref>. Thus, we will be able to use freely results from the theory of such automata. In particular, the unconditional and the strong fairness conditions correspond to the Buchi and Streett acceptance conditions.
Reference: [VW86] <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verifica-tion. </title> <booktitle> In Proceedings of the First Symposium on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <address> Cambridge, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: This is reminiscent of the computational relations of branching-time model checking and linear-time model checking: while model checking is easier for the branching paradigm, the implementation complexity of model checking in the two paradigm coincide <ref> [LP85, CES86, VW86, BVW94] </ref>. Often, we want our implementations and specifications to describe behaviors that satisfy both liveness and safety properties. Then, transition systems with no fairness condition are too weak and we need the framework of fair transition systems. <p> When we turn to consider the program complexity of model checking, which is the analogue to our implementation complexity, this is no longer true. The program complexity of model checking for both LTL and 8CTL ? is 23 NLOGSPACE-complete <ref> [VW86, BVW94] </ref>. In contrast, we saw here that implementation is easier in the trace-based approach. Our results are summarized in the table below.
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <month> November </month> <year> 1994. </year> <month> 27 </month>
Reference-contexts: We show that these algorithms are optimal; the implementation complexity of fair containment is NLOGSPACE-complete for implementations that use the unconditional or weak fairness conditions <ref> [VW94] </ref> and is PTIME-complete for implementations that use the strong fairness condition. To prove the latter, we show that the nonemptiness problem for fair transition systems with a strong fairness condition is PTIME-hard. <p> Similarly, for all the three types of S 0 , going to S 0 U involves an at most exponential blow up. Thus, the size of the product of S U and S 0 U is exponential in the sizes of S and S 0 [Cho74]. By <ref> [VW94] </ref>, the nonemptiness problem for unconditionally fair transition systems is in NLOGSPACE. Hence, as NLOGSPACE=co-NLOGSPACE, checking the product of S U and S 0 U for emptiness can be done in space polynomial in their sizes. Hardness in PSPACE follows from the PSPACE lower bound for trace containment (Theorem 3.1).
References-found: 41

