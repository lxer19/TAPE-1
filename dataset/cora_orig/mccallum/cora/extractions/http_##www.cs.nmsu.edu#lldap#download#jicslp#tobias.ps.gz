URL: http://www.cs.nmsu.edu/lldap/download/jicslp/tobias.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/jicslp/tobias.html
Root-URL: http://www.cs.nmsu.edu
Email: tmueller@ps.uni-sb.de  wuertz@dfki.uni-sb.de  
Phone: 45, Postf. 15 11 50  45, Postf. 15 11 50  
Title: Interfacing Propagators with a Concurrent Constraint Language  
Author: Tobias Muller Jorg Wurtz 
Keyword: concurrent constraint language, finite domain constraints, propagator interface.  
Address: Geb.  66041 Saarbrucken  Geb.  66041 Saarbrucken  
Affiliation: Programming Systems Lab University of the Saarland  Programming Systems Lab German Research Center for AI  
Abstract: This paper deals with an interface for the concurrent constraint language Oz to implement arbitrary constraints in an efficient manner. The programmer has all the advantages of a high-level language in combination with efficiency. For the user it is transparent, whether a constraint is implemented by an Oz procedure or through the interface. The interface is completely separated from the underlying abstract machine of Oz. Moreover, it frees the user from tedious tasks like suspending and waking of constraints. As an implementation language we use C++. The overall efficiency of the resulting system is comparable to existing finite domain systems. For scheduling applications we show that algorithms from Operations Research can be incorporated, which allows to obtain results comparable to commercially available systems. 
Abstract-found: 1
Intro-found: 1
Reference: [CL94] <author> Y. Caseau and F. Laburthe. </author> <title> Improved CLP scheduling with task intervals. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 369-383, </pages> <year> 1994. </year>
Reference-contexts: 0.24 0.705 1.35 3.970 donald, naive 19.48 6.23 0.319 21.2 1.088 equation20, naive 0.43 0.18 0.418 1.10 2.558 equation10, naive 0.28 0.12 0.428 0.53 1.893 Table 1: Comparing different finite domain systems on a SPARC ELC The propagator presented in Section 4 in conjunction with a labelling strategy proposed by <ref> [CL94] </ref> was used to tackle job-problems 2 , which were supposed to be particularly hard for a long period of time. The obtained results are shown in Table 2.
Reference: [DC93] <author> D. Diaz and P. Codognet. </author> <title> A minimal extension of the WAM for clp(FD). </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 774-790, </pages> <address> Budapest, Hungary, 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: We compare our work with clp (fd) <ref> [DC93] </ref> and ECL i PS e [ECR95]. The queens problem is the usual one. The problems alpha and donald are crypto-arithmetic puzzles. Finding a solution for a set of n equations is the task of the problem equationn. The annotations indicate the labelling strategies; either first-fail or naive.
Reference: [DVS + 88] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. </author> <title> The constraint logic programming language CHIP. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems FGCS-88, </booktitle> <pages> pages 693-702, </pages> <address> Tokyo, Japan, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: Arbitrary constraints can be expressed in the language itself. 1 But finite domain systems must be efficient in order to tackle the prob-lems, which made this field so remarkable, like scheduling, placement or configuration <ref> [DVS + 88] </ref>. Hence, we decided to encapsulate several constraints into so-called propagators written in C++, i.e., constraints as procedures were replaced by constraints as C-functions.
Reference: [ECR95] <author> ECRC. </author> <title> ECL i PS e , User Manual Version 3.5, </title> <month> December </month> <year> 1995. </year>
Reference-contexts: We compare our work with clp (fd) [DC93] and ECL i PS e <ref> [ECR95] </ref>. The queens problem is the usual one. The problems alpha and donald are crypto-arithmetic puzzles. Finding a solution for a set of n equations is the task of the problem equationn. The annotations indicate the labelling strategies; either first-fail or naive.
Reference: [HW95] <author> M. Henz and J. Wurtz. </author> <title> Using oz for college timetabling. </title> <booktitle> In International Conference on the Practice and Theory of Automated Time Tabling, </booktitle> <pages> pages 283-296. </pages> <publisher> Springer Verlag,, </publisher> <month> August/September </month> <year> 1995. </year>
Reference-contexts: Moreover, search itself and the labelling strategies can be programmed in Oz itself. This paper deals with the implementation of the C++ interface to propagators for the language Oz. The resulting finite domain system is expressive (including reified constraints <ref> [HW95] </ref>, non-linear constraints and several symbolic constraints) and even more efficient than Oz 1.0 [ST95]. The viability of our approach is also exemplified by the incorporation of special-purpose propagators for scheduling. The obtained results are comparable to Ilog Solver. The plan of the paper is as following. <p> Finally, the yielded results are presented and discussed. 2 Computation with Constraints in Oz 2.1 Programming Model This paper deals with constraints on finite sets of nonnegative integers, so-called finite domains, in the constraint programming language Oz. For a more thorough treatment see <ref> [SSW94, HW95] </ref>. For a detailed presentation of the programming model see [Smo95]. A basic constraint takes the form x = n, x = y or x 2 D, where n is a nonnegative integer and D is a finite domain. The basic constraints reside in the constraint store.
Reference: [MJ] <author> T. Muller and J.Wurtz. </author> <title> A survey on finite domain programming in Oz. In Notes on the DFKI-Workshop: Constraint-Based Problem Solving, </title> <note> To appear as Technical report D-96-05. </note>
Reference-contexts: The resulting system was rather efficient (faster than ECL i PS e for standard benchmarks) and still allowed the user to invent new propagators by combining propagators with language constructs like conditionals or disjunctions <ref> [ST95, MJ] </ref>. Nevertheless, users could implement new constraints efficiently only in a cumbersome way (by compiling the whole abstract machine). Hence, we wanted to design an interface to propagators, which can easily be used by programmers.
Reference: [MSS95] <author> Michael Mehl, Ralf Scheidhauer, and Christian Schulte. </author> <title> An Abstract Machine for Oz. </title> <editor> In Manuel Hermenegildo and S. Doaitse Swierstra, editors, </editor> <booktitle> Programming Languages: Implementations, Logics and Programs, 7th International Symposium, PLILP'95, Lecture Notes in Computer Science, </booktitle> <volume> vol. 982, </volume> <pages> pages 151-168, </pages> <address> Utrecht, The Netherlands, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: Furthermore, encapsulated search in Oz heavily depends on local computation spaces. 3 creation running failed entailed sleeping runnable (1) SLEEPFAILED PROCEED 2.2 Implementation of Propagators The sketched computation model of Section 2.1 is implemented by an abstract machine <ref> [MSS95] </ref>, called the emulator . A propagator is realized as a C++ object narrowing the variables it is constraining and returning values to the emulator, which indicate the state of the propagator. At each variable is attached the list of suspending tasks (often only propagators), which are constraining this variable.
Reference: [PL95] <author> Jean-Froncois Puget and Michel Leconte. </author> <title> Beyond the glass box: Constraints as objects. </title> <editor> In John Lloyd, editor, </editor> <booktitle> Logic Programming Proceedings of the 1995 International Symposium, </booktitle> <volume> number 02142, </volume> <pages> pages 513-527. </pages> <publisher> The MIT Press, </publisher> <month> December </month> <year> 1995. </year>
Reference-contexts: That is why we opened up the system to the programmer by completely separating the emulator from the implementation of the propagators. Considering our design goals of Section 1, C++ was the language of choice for the interface. Further, C++ has proved to be suitable for this sort applications <ref> [PL95] </ref>. To prove the feasibility of our approach we implemented the whole propagator library of Oz using the constraint propagator interface. In fact this library is dynamically loaded to the emulator, when launching the system and mapped to Oz abstractions.
Reference: [Smo95] <author> G. Smolka. </author> <title> The Oz programming model. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Computer Science Today, Lecture Notes in Computer Science, </booktitle> <volume> vol. 1000, </volume> <pages> pages 324-343. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: For a more thorough treatment see [SSW94, HW95]. For a detailed presentation of the programming model see <ref> [Smo95] </ref>. A basic constraint takes the form x = n, x = y or x 2 D, where n is a nonnegative integer and D is a finite domain. The basic constraints reside in the constraint store. Oz provides efficient algorithms to decide satisfiability and implication for basic constraints. <p> A computation space consists of the constraint store and tasks connected to the store. One kind of tasks are the propagators. Because tasks itself (like disjunctions) may host computation spaces, a tree of spaces results (see <ref> [Smo95] </ref>). Furthermore, encapsulated search in Oz heavily depends on local computation spaces. 3 creation running failed entailed sleeping runnable (1) SLEEPFAILED PROCEED 2.2 Implementation of Propagators The sketched computation model of Section 2.1 is implemented by an abstract machine [MSS95], called the emulator .
Reference: [SSW94] <author> C. Schulte, G. Smolka, and J. Wurtz. </author> <title> Encapsulated search and constraint programming in Oz. </title> <editor> In A.H. Borning, editor, </editor> <booktitle> Second Workshop on Principles and Practice of Constraint Programming, Lecture Notes in Computer Science, </booktitle> <volume> vol. 874, </volume> <pages> pages 134-150, </pages> <address> Orcas Island, Washington, USA, 2-4 May 1994. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: 1 Introduction Concurrent constraint languages provide the ideal means to implement a finite domain constraint system over natural numbers. The inherent notions of a constraint store and of concurrent computation give the right metaphors needed to understand and develop constraint programs. For the language Oz, we have shown in <ref> [SSW94] </ref> that finite domain programming is enabled by adding primitives to reflect the current domain of variables and encapsulated search. <p> Finally, the yielded results are presented and discussed. 2 Computation with Constraints in Oz 2.1 Programming Model This paper deals with constraints on finite sets of nonnegative integers, so-called finite domains, in the constraint programming language Oz. For a more thorough treatment see <ref> [SSW94, HW95] </ref>. For a detailed presentation of the programming model see [Smo95]. A basic constraint takes the form x = n, x = y or x 2 D, where n is a nonnegative integer and D is a finite domain. The basic constraints reside in the constraint store.
Reference: [ST95] <author> G. Smolka and R. Treinen, </author> <title> editors. DFKI Oz Documentation Series. </title> <institution> Deutsches Forschungszentrum fur Kunstliche Intelligenz GmbH, Stuhlsatzenhausweg 3, 66123 Saarbrucken, Germany, </institution> <year> 1995. </year> <month> 12 </month>
Reference-contexts: The resulting system was rather efficient (faster than ECL i PS e for standard benchmarks) and still allowed the user to invent new propagators by combining propagators with language constructs like conditionals or disjunctions <ref> [ST95, MJ] </ref>. Nevertheless, users could implement new constraints efficiently only in a cumbersome way (by compiling the whole abstract machine). Hence, we wanted to design an interface to propagators, which can easily be used by programmers. <p> This paper deals with the implementation of the C++ interface to propagators for the language Oz. The resulting finite domain system is expressive (including reified constraints [HW95], non-linear constraints and several symbolic constraints) and even more efficient than Oz 1.0 <ref> [ST95] </ref>. The viability of our approach is also exemplified by the incorporation of special-purpose propagators for scheduling. The obtained results are comparable to Ilog Solver. The plan of the paper is as following. The next section sketches constraint computation in Oz and introduces basic notions and concepts.
References-found: 11

