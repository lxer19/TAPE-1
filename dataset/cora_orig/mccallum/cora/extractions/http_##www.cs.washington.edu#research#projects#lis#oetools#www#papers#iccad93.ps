URL: http://www.cs.washington.edu/research/projects/lis/oetools/www/papers/iccad93.ps
Refering-URL: http://www.cs.washington.edu/research/projects/lis/oetools/www/publications.html
Root-URL: 
Title: Practical Applications of an Efficient Time Separation of Events Algorithm  
Author: Henrik Hulgaard, Steven M. Burns, Tod Amon and Gaetano Borriello 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington,  
Abstract: Determining the time separation of events is a fundamental problem in the analysis, synthesis, and optimization of concurrent systems. We present results of applying an efficient algorithm to solve this problem to three different application domains. These are: analysis of instruction execution times of an asynchronous microprocessor, analysis of a high-performance mixed asynchronous/synchronous communication interface, and isochronic fork analysis in asynchronous circuit synthesis. The algorithm we use yields exact (tight) bounds on the separation time of events in an arbitrary process graph without conditional behavior. This class of graphs is quite large and includes graphs that are not strongly connected. The algorithm is based on a functional decomposition technique that permits the implicit evaluation of an infinitely unfolded process graph. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: The maximum over all ff 0 +n for all n 0 would then be R (I max S max S 2 max : : : ) T = R S fl T : (2) A matrix closure algorithm <ref> [1] </ref> can be used to compute S fl because (F ; max ; ffi; 0; 1) forms a closed semi-ring. <p> Using our implementation of the techniques described in this paper, a separation analysis can be performed in under 2 seconds on a SPARC 2. For example, if all the delays associated with rules within the blocks of Figure 3 are in the range <ref> [0; 1] </ref> (small in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: IMEM FETCH PCADD REG1 REG2 ALUEXEC REG3 ID E AC sty Ys ZAs A B graph components within each block, see <p> A similar argument holds for (8). (9) and (10) are needed to insure that the set and reset signals to the latch are not active simultaneously. If we assume that all gate delays are in the range [2; 3] and all the wire delays are in the range <ref> [0; 1] </ref> except those specified explicitly in the table, we get the results shown in Table 2. The CPU time needed to verify the four conditions is less than half a second on a SPARC 2. Arc A Arc B (7) (8) (9) (10) OK p p [0; 1] [0; 2] <p> in the range <ref> [0; 1] </ref> except those specified explicitly in the table, we get the results shown in Table 2. The CPU time needed to verify the four conditions is less than half a second on a SPARC 2. Arc A Arc B (7) (8) (9) (10) OK p p [0; 1] [0; 2] 1 1 3 2 [0; 1] [0; 3] 1 1 3 1 [0; 1] [0; 5] 1 1 3 1 Table 2: Results of the maximum separation analysis for the D-element. (i) is the maximum separation corre sponding to equation (i). 6 Conclusion The major contribution of <p> The CPU time needed to verify the four conditions is less than half a second on a SPARC 2. Arc A Arc B (7) (8) (9) (10) OK p p <ref> [0; 1] </ref> [0; 2] 1 1 3 2 [0; 1] [0; 3] 1 1 3 1 [0; 1] [0; 5] 1 1 3 1 Table 2: Results of the maximum separation analysis for the D-element. (i) is the maximum separation corre sponding to equation (i). 6 Conclusion The major contribution of this paper is the demonstration of the utility <p> The CPU time needed to verify the four conditions is less than half a second on a SPARC 2. Arc A Arc B (7) (8) (9) (10) OK p p <ref> [0; 1] </ref> [0; 2] 1 1 3 2 [0; 1] [0; 3] 1 1 3 1 [0; 1] [0; 5] 1 1 3 1 Table 2: Results of the maximum separation analysis for the D-element. (i) is the maximum separation corre sponding to equation (i). 6 Conclusion The major contribution of this paper is the demonstration of the utility of our time separation of events algorithm for
Reference: [2] <author> T. Amon, H. Hulgaard, S. M. Burns, and G. Borriello. </author> <title> An algorithm for exact bounds on the time separation of events in concurrent systems. </title> <booktitle> In IEEE International Conference on Computer Design (ICCD), </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: Finally, Section 6 summarizes the contributions. 2 The Algorithm In this section, we give an intuitive description of our time separation of events algorithm (details can be found in <ref> [2] </ref>). Our algorithm for analyzing a process graph is based on an algorithm by McMillan and Dill [8] that determines the maximum separation in an acyclic graph. <p> We can insure that the S matrices are indeed identical after a finite number of unfoldings if the process graph is strongly connected, because then the m-values eventually follow a periodic pattern <ref> [2, 3] </ref>. If the process graph is not strongly connected, we can not guarantee that the m-values become periodic with the same period. We can categorize separation analyses on non-strongly connected process graphs by whether or not the event s is in a strongly-connected component (SCC) that has no predecessors. <p> The delay through a C-element is set to <ref> [2; 3] </ref> in all cases. (i) is the maximum separation corresponding to equation (i). <p> A similar argument holds for (8). (9) and (10) are needed to insure that the set and reset signals to the latch are not active simultaneously. If we assume that all gate delays are in the range <ref> [2; 3] </ref> and all the wire delays are in the range [0; 1] except those specified explicitly in the table, we get the results shown in Table 2. The CPU time needed to verify the four conditions is less than half a second on a SPARC 2. <p> The CPU time needed to verify the four conditions is less than half a second on a SPARC 2. Arc A Arc B (7) (8) (9) (10) OK p p [0; 1] <ref> [0; 2] </ref> 1 1 3 2 [0; 1] [0; 3] 1 1 3 1 [0; 1] [0; 5] 1 1 3 1 Table 2: Results of the maximum separation analysis for the D-element. (i) is the maximum separation corre sponding to equation (i). 6 Conclusion The major contribution of this paper
Reference: [3] <author> F. Baccelli, G. Cohen, G. J. Olsder, and J.-P. Quadrat. </author> <title> Synchronization and Linearity. Wiley Series in Probability and Mathematical Statistics. </title> <publisher> John Wiley and Sons, </publisher> <year> 1992. </year>
Reference-contexts: Fig 1 Now at the Department of Computer Science, Southwest Texas State, San Marcos, TX 78666-4616 2 Also called a timed event graph <ref> [3] </ref>, a marked graph or a decision free Petri net. 3 The occurrence index offset is used to specify how much the occurrence index is incremented when the edge is executed. ure 1 shows a simple process graph with two events. [1,2] [1,6] and edges R 0 = fa [4;10];1 [1;2];0 <p> We can insure that the S matrices are indeed identical after a finite number of unfoldings if the process graph is strongly connected, because then the m-values eventually follow a periodic pattern <ref> [2, 3] </ref>. If the process graph is not strongly connected, we can not guarantee that the m-values become periodic with the same period. We can categorize separation analyses on non-strongly connected process graphs by whether or not the event s is in a strongly-connected component (SCC) that has no predecessors. <p> The CPU time to verify the four conditions is less than a second on a SPARC 2. d skew t skew r (3) (4) (5) (6) OK 6 [0; 0] [0; 0] 3 3 0 0 6 [0; 0] <ref> [0; 3] </ref> 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] [0; 5] 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 <p> The CPU time to verify the four conditions is less than a second on a SPARC 2. d skew t skew r (3) (4) (5) (6) OK 6 [0; 0] [0; 0] 3 3 0 0 6 [0; 0] <ref> [0; 3] </ref> 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] [0; 5] 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] [12; 12] 0 0 <p> (4) (5) (6) OK 6 [0; 0] [0; 0] 3 3 0 0 6 [0; 0] <ref> [0; 3] </ref> 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] [0; 5] 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] [12; 12] 0 0 5 5 8 [12; 12] [0; 0] 5 5 8 8 Table 1: Timing analysis of STARI. d is the lower bound on the clock period (the <p> 0 0 6 [0; 0] <ref> [0; 3] </ref> 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] [0; 5] 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] [12; 12] 0 0 5 5 8 [12; 12] [0; 0] 5 5 8 8 Table 1: Timing analysis of STARI. d is the lower bound on the clock period (the upper bound is irrelevant for the correctness of STARI), skew t <p> The delay through a C-element is set to <ref> [2; 3] </ref> in all cases. (i) is the maximum separation corresponding to equation (i). <p> A similar argument holds for (8). (9) and (10) are needed to insure that the set and reset signals to the latch are not active simultaneously. If we assume that all gate delays are in the range <ref> [2; 3] </ref> and all the wire delays are in the range [0; 1] except those specified explicitly in the table, we get the results shown in Table 2. The CPU time needed to verify the four conditions is less than half a second on a SPARC 2. <p> The CPU time needed to verify the four conditions is less than half a second on a SPARC 2. Arc A Arc B (7) (8) (9) (10) OK p p [0; 1] [0; 2] 1 1 3 2 [0; 1] <ref> [0; 3] </ref> 1 1 3 1 [0; 1] [0; 5] 1 1 3 1 Table 2: Results of the maximum separation analysis for the D-element. (i) is the maximum separation corre sponding to equation (i). 6 Conclusion The major contribution of this paper is the demonstration of the utility of our
Reference: [4] <author> S. M. Burns. </author> <title> Performance Analysis and Optimization of Asynchronous Circuits. </title> <type> Ph.D. thesis, </type> <institution> California Institute of Technology, </institution> <year> 1991. </year> <month> CS-TR-91-1. </month>
Reference-contexts: k ) are fi fi u k" 7! v k 2 R t (v k ) max t (u k" ) + D fi [d;D] example in Figure 1 obtained by choosing the upper bound, D, for all delays. root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] 0 10 28 48 68 a 4 process graph in Figure 1. Two startup edges have been added, specifying that both a 0 and b 0 must occur after root. <p> are fi fi u k" 7! v k 2 R t (v k ) max t (u k" ) + D fi [d;D] example in Figure 1 obtained by choosing the upper bound, D, for all delays. root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] 0 10 28 48 68 a 4 process graph in Figure 1. Two startup edges have been added, specifying that both a 0 and b 0 must occur after root. <p> fi u k" 7! v k 2 R t (v k ) max t (u k" ) + D fi [d;D] example in Figure 1 obtained by choosing the upper bound, D, for all delays. root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] 0 10 28 48 68 a 4 process graph in Figure 1. Two startup edges have been added, specifying that both a 0 and b 0 must occur after root. <p> k" 7! v k 2 R t (v k ) max t (u k" ) + D fi [d;D] example in Figure 1 obtained by choosing the upper bound, D, for all delays. root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] 0 10 28 48 68 a 4 process graph in Figure 1. Two startup edges have been added, specifying that both a 0 and b 0 must occur after root. <p> 1] (small in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: IMEM FETCH PCADD REG1 REG2 ALUEXEC REG3 ID E AC sty Ys ZAs A B graph components within each block, see <ref> [4] </ref>. Rise Fall Rise Fall ID [50,51] [30,31] X [30,31] [30,31] sty [20,21] [20,21] AC [20,21] [20,21] we obtain the minimum and maximum separations in cycle period seen at point A of 80 and 107.
Reference: [5] <author> M. R. Greenstreet. STARI: </author> <title> A Technique for High-Bandwidth Communication. </title> <type> Ph.D. thesis, </type> <institution> Princeton University, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: This information is useful when interfacing the microprocessor to an external synchronous component, especially in cases where the synchronous component is clocked using a signal produced by the microprocessor. 4 STARI STARI is a novel approach to high-bandwidth communication proposed by Greenstreet <ref> [5] </ref>. STARI combines synchronous and self-timed design techniques. The sender and receiver operate synchronously at the same clock rate, but the communication interface consists of an asynchronous FIFO queue. The overall structure is shown in Figure 4 (from [5, Figure 5]). <p> STARI combines synchronous and self-timed design techniques. The sender and receiver operate synchronously at the same clock rate, but the communication interface consists of an asynchronous FIFO queue. The overall structure is shown in Figure 4 (from <ref> [5, Figure 5] </ref>). Transmitter Receiver sync. completion encoding Global Clock FIFO sync. circuitrycircuitry The idea in STARI is to time the system such that the FIFO operates at the speed of the clock, accept ing a new data item every clock cycle. <p> If the variations becomes too large, the FIFO overflows or underflows and STARI fails. The amount of variation of the delays that can be tolerated depends on the length of the FIFO, the clock period, and the delay of the FIFO elements. Greenstreet <ref> [5] </ref> has derived sufficient timing conditions under which STARI operates correctly. The correctness proof for these conditions is quite complicated (approx. 20 pages). Here we show how the maximum separation analysis can be used for timing verification of a STARI implementation. <p> (6) OK 6 [0; 0] [0; 0] 3 3 0 0 6 [0; 0] [0; 3] 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] <ref> [0; 5] </ref> 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] [12; 12] 0 0 5 5 8 [12; 12] [0; 0] 5 5 8 8 Table 1: Timing analysis of STARI. d is the lower bound on the clock period (the upper bound <p> 3 3 0 0 6 [0; 0] [0; 3] 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] <ref> [0; 5] </ref> 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] [12; 12] 0 0 5 5 8 [12; 12] [0; 0] 5 5 8 8 Table 1: Timing analysis of STARI. d is the lower bound on the clock period (the upper bound is irrelevant for the correctness of STARI), <p> The CPU time needed to verify the four conditions is less than half a second on a SPARC 2. Arc A Arc B (7) (8) (9) (10) OK p p [0; 1] [0; 2] 1 1 3 2 [0; 1] [0; 3] 1 1 3 1 [0; 1] <ref> [0; 5] </ref> 1 1 3 1 Table 2: Results of the maximum separation analysis for the D-element. (i) is the maximum separation corre sponding to equation (i). 6 Conclusion The major contribution of this paper is the demonstration of the utility of our time separation of events algorithm for solving a
Reference: [6] <author> A. J. Martin. </author> <title> Programming in VLSI: From communicating processes to delay-insensitive circuits. In C.A.R. Hoare, editor, </title> <booktitle> UT Year of Programming Institute on Concurrent Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: conditions is less than a second on a SPARC 2. d skew t skew r (3) (4) (5) (6) OK 6 [0; 0] [0; 0] 3 3 0 0 6 [0; 0] [0; 3] 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] <ref> [6; 6] </ref> 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] [0; 5] 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] [12; 12] 0 0 5 5 8 [12; 12] [0; 0] 5 5 8 8 <p> Correct operation of STARI is indicated with a checkmark in the OK column. 5 Isochronic Forks An exact solution to the maximum separation problem can be used to determine whether or not an asynchronous circuit designed under the assumptions of the quasi-delay-insensitive model <ref> [6] </ref> will work correctly even if the isochronic fork assumption is relaxed. The isochronic fork assumption states that certain signals in the circuit that fan out to separate circuit elements arrive at their respective elements at the same time.
Reference: [7] <author> A.J. Martin, S.M. Burns, T.K. Lee, D. Borkovic, and P.J. Hazewindus. </author> <title> The design of an asynchronous microprocessor. </title> <editor> In C.L. Seitz, editor, </editor> <booktitle> Advanced Research in VLSI: Proceedings of the Decennial Caltech Conference on VLSI, </booktitle> <pages> pages 351-373, </pages> <address> Cambridge, MA, 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Secondly, even if a necessary termination condition were developed, there are examples where performing the closure is significantly faster than unfolding the process graph the required amount. 3 Asynchronous Microprocessor A subset of the Caltech Asynchronous Microprocessor <ref> [7] </ref> has been modeled and analyzed using the techniques described in this paper. A block diagram of the processor is shown in Figure 3. The process graph for this simplified model consists of 60 events and 127 edges.
Reference: [8] <author> K. McMillan and D. L. Dill. </author> <title> Algorithms for interface timing verification. </title> <booktitle> In 1992 IEEE International Conference on Computer Design: VLSI in Computers and Processors, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: Finally, Section 6 summarizes the contributions. 2 The Algorithm In this section, we give an intuitive description of our time separation of events algorithm (details can be found in [2]). Our algorithm for analyzing a process graph is based on an algorithm by McMillan and Dill <ref> [8] </ref> that determines the maximum separation in an acyclic graph. Let ff be the strongest bound for the separation problem given a particular occurrence index ff, i.e., t (t ff ) t (s fffi ) ff .
Reference: [9] <author> C. Myers and T. H.-Y. Meng. </author> <title> Synthesis of timed asynchronous circuits. </title> <booktitle> In 1992 IEEE International Conference on Computer Design: VLSI in Computers and Processors, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: Note that our algorithm is guaranteed to terminate and find the tightest possible bound. One may expect to be able to determine by repeatedly applying the McMillan and Dill algorithm on unfoldings of increasing size. While this technique is successful and efficient for some examples <ref> [9] </ref>, there are two problems with this approach. Firstly, we know of no necessary condition for determining when to stop unfolding the graph and report the result. The matrix closure in (2) implicitly performs an infinite analysis, thus producing an exact bound in finite time.
References-found: 9

