URL: http://www.cs.brandeis.edu/~mairson/Papers/JFP92.ps.gz
Refering-URL: http://www.cs.brandeis.edu/~mairson/
Root-URL: http://www.cs.brandeis.edu
Title: Quantifier elimination and parametric polymorphism in programming languages  
Author: Harry G. Mairson 
Note: Supported by NSF Grant CCR-9017125, and grants from Texas Instruments and from the Tyson Foundation.  
Date: February 5, 1996  
Address: Waltham, Massachusetts 02254  
Affiliation: Department of Computer Science Brandeis University  
Abstract: We present a simple and easy to understand explanation of ML type inference and parametric polymorphism within the framework of type monomorphism, as in the first order typed lambda calculus. We prove the equivalence of this system with the standard interpretation using type polymorphism, and extend the equivalence to include polymorphic fixpoints. The monomorphic interpretation gives a purely combinatorial understanding of the type inference problem, and is a classic instance of quantifier elimination, as well as an example of Gentzen-style cut elimination in the framework of the Curry-Howard propositions-as-types analogy. 
Abstract-found: 1
Intro-found: 1
Reference: [Bar84] <author> H. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <year> 1984. </year>
Reference-contexts: The example of typing let I = z:z in II, for instance, is reduced to typing (z:z)(z:z), so each z:z may be typed differently. The effect is the same as considering the expression to be a marked redex (I:II)(z:z) 1 in the theory of labelled reductions <ref> [Bar84] </ref>. The monomorphic realization of ML's parametric polymorphism is not new. A recent survey of type systems in programming [Mit90] attributes the observation to Albert Meyer. <p> We write FV (E) to denote the free variables of E. We allow ff-renaming and fi-reduction as in the -calculus, as well as reduction of let-expressions following the rule: let x = E in B ! let [E=x]B For more details concerning reductions in the -calculus and ML, see <ref> [Bar84, HS87, HMT90] </ref>. 2.2 Types The syntax of types is given by the grammar: T 0 : : = t j T 0 ! T 0 where t ranges over a set T V of type variables. <p> However, the proof is overly tedious and technical, and requires an understanding of minimal complete developments in the -calculus <ref> [HS87, Bar84] </ref>. But most 5 of all, it contradicts an overwhelming sentiment that the equivalence we want is something very simple which should be easy to prove.
Reference: [Car84] <author> L. Cardelli. </author> <title> Basic polymorphic type-checking. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8(2), </volume> <pages> pp. 147-172, </pages> <year> 1984. </year>
Reference-contexts: Observe the use in rule (let P ) of types with quantifiers (namely, the binding for x), requiring the rules (gen P ) and (inst P ) for quantifier introduction and elimination. For more details on type inference rules, we recommend <ref> [Car84, Han87, Mil78, Wan87] </ref>. 2.3.1 Core ML inference rules for the polytype system (var P ) [ fx: g fl x: fl E: (t) [t 62 FV ()] (inst P ) fl E: 8t:(t) (abs P ) fl x:E: t 0 ! t 1 fl M : t 0 ! t
Reference: [CF58] <author> H. B. Curry and R. Feys. </author> <title> Combinatory Logic I. </title> <publisher> North-Holland, </publisher> <year> 1958. </year>
Reference-contexts: ML-style parametric polymorphism, as long as we use the following inference rule for typing let-expressions: (let) fl let x = E in B: t 1 Any ML program without free variables that is typable in the standard Milner-Damas inference system [DM82] is also typable using the classical Curry inference system <ref> [CF58] </ref> augmented with the above rule. Hence parametric polymorphism as realized in ML may be achieved within the framework of type monomorphism. <p> We give below the inference rules for the polytype and monotype systems. The polytype system is due to [DM82], and the monotype system is essentially due to <ref> [CF58] </ref> augmented with the rule for let. Observe the use in rule (let P ) of types with quantifiers (namely, the binding for x), requiring the rules (gen P ) and (inst P ) for quantifier introduction and elimination.
Reference: [vanD79] <author> D. van Daalen. </author> <title> Logic and Structure. </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Proofs in sequent calculus, like type derivations, can be written in the form of trees, where the leaves form propositional hypotheses. The logical formalism of cancelling hypotheses via !-introduction is reflected in removing type assumptions and introducing -abstraction. (For a further detailed but elementary discussion, see <ref> [vanD79] </ref>.) The process of fi-reduction in the simply-typed -calculus can be interpreted as a transformation on proof trees: if M ` fl x:M : t 1 ! t 2 and N ` fl N : t 1 , by "modus ponens" we get MN ` fl (x:M )N : t 2
Reference: [Dam85] <author> L. Damas. </author> <title> Type assignment in programming languages. </title> <publisher> Ph. </publisher> <address> D. </address> <institution> dissertation, CST-33-85, Computer Science Department, Edinburgh University, </institution> <year> 1985. </year>
Reference-contexts: The monomorphic realization of ML's parametric polymorphism is not new. A recent survey of type systems in programming [Mit90] attributes the observation to Albert Meyer. An earlier appearance of the idea is found in the dissertation of Luis Damas <ref> [Dam85] </ref>, and in fact a question about it is found in the 1985 postgraduate examination in computing at Edinburgh University [Edi88]. 2 In this paper, we present a simple and easy to understand explanation of ML type inference in the framework of type monomorphism, where we prove its equivalence to the
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In 9-th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 207-212, </pages> <month> January </month> <year> 1982. </year> <month> 13 </month>
Reference-contexts: of the first order typed -calculus is sufficient to support ML-style parametric polymorphism, as long as we use the following inference rule for typing let-expressions: (let) fl let x = E in B: t 1 Any ML program without free variables that is typable in the standard Milner-Damas inference system <ref> [DM82] </ref> is also typable using the classical Curry inference system [CF58] augmented with the above rule. Hence parametric polymorphism as realized in ML may be achieved within the framework of type monomorphism. <p> We describe two such systems of rules: the first being the standard one given by Damas and Milner <ref> [DM82] </ref> which we call the polytype system, and the second one a variant called the monotype system. As its name suggests, the monotype system associates expressions with monotypes only. The major point of this paper is to show simply why this limitation is not truly a restriction. <p> We give below the inference rules for the polytype and monotype systems. The polytype system is due to <ref> [DM82] </ref>, and the monotype system is essentially due to [CF58] augmented with the rule for let. Observe the use in rule (let P ) of types with quantifiers (namely, the binding for x), requiring the rules (gen P ) and (inst P ) for quantifier introduction and elimination.
Reference: [Edi88] <institution> Edinburgh University. </institution> <note> Postgraduate Examination Questions in Computation Theory, 1978-1988, ed. Donald Sannella. </note> <institution> Laboratory for Foundations of Computer Science, </institution> <note> Report ECS-LFCS-88-64. </note>
Reference-contexts: A recent survey of type systems in programming [Mit90] attributes the observation to Albert Meyer. An earlier appearance of the idea is found in the dissertation of Luis Damas [Dam85], and in fact a question about it is found in the 1985 postgraduate examination in computing at Edinburgh University <ref> [Edi88] </ref>. 2 In this paper, we present a simple and easy to understand explanation of ML type inference in the framework of type monomorphism, where we prove its equivalence to the standard interpretation using type polymorphism.
Reference: [Gen69] <author> G. </author> <title> Gentzen. The Collected Papers of Gerhard Gentzen, </title> <editor> ed. E. Szabo. </editor> <publisher> North-Holland, </publisher> <year> 1969. </year>
Reference-contexts: Interpreted at the proof theory level, this transformation is an example of what is called, after Gentzen <ref> [Gen69] </ref>, cut elimination, since (x:M)N represents a proof where t 1 is proved once, a "shortcut" over [N=x]M , which may require many proofs of t 1 . The parametric polymorphism in Core ML introduced by the let construct can be viewed as a more powerful form of cut-elimination.
Reference: [Gir72] <author> J.-Y. Girard. </author> <title> Interpretation Fonctionelle et Elimination des Coupures de l'Arithmetique d'Ordre Superieur. </title> <institution> These de Doctorat d'Etat, Universite de Paris VII, </institution> <year> 1972. </year>
Reference-contexts: While type inference for this system is not computable [KTU90], we show that the inference system has nonetheless a purely monomorphic interpretation. We believe that the monomorphic interpretation is important because it gives a purely combinatorial understanding of a significant fragment of the Girard/Reynolds second-order polymorphic typed -calculus <ref> [Gir72, Rey74] </ref>. It provides as well a classic example of quantifier elimination, which in the context of the Curry-Howard propositions-as-types analogy serves as a sort of Gentzen-style cut elimination.
Reference: [Han87] <author> P. Hancock. </author> <title> Polymorphic type-checking. </title> <booktitle> In The Implementation of Functional Programming Languages, </booktitle> <publisher> by Simon Peyton-Jones. Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Observe the use in rule (let P ) of types with quantifiers (namely, the binding for x), requiring the rules (gen P ) and (inst P ) for quantifier introduction and elimination. For more details on type inference rules, we recommend <ref> [Car84, Han87, Mil78, Wan87] </ref>. 2.3.1 Core ML inference rules for the polytype system (var P ) [ fx: g fl x: fl E: (t) [t 62 FV ()] (inst P ) fl E: 8t:(t) (abs P ) fl x:E: t 0 ! t 1 fl M : t 0 ! t
Reference: [HMT90] <author> R. Harper, R. Milner, M. Tofte. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction In his influential paper, "A theory of type polymorphism in programming," Robin Milner proposed an extension to the first order typed -calculus which has become known as the core of the ML programming language <ref> [Mil78, HMT90] </ref>. The extension augmented the monomorphic type language of the first order typed -calculus with polytypes (also known as type schemes) allowing a limited form of quantification over type variables. <p> We write FV (E) to denote the free variables of E. We allow ff-renaming and fi-reduction as in the -calculus, as well as reduction of let-expressions following the rule: let x = E in B ! let [E=x]B For more details concerning reductions in the -calculus and ML, see <ref> [Bar84, HS87, HMT90] </ref>. 2.2 Types The syntax of types is given by the grammar: T 0 : : = t j T 0 ! T 0 where t ranges over a set T V of type variables.
Reference: [HM91] <author> F. Henglein and H. Mairson. </author> <title> The complexity of type inference for higher-order typed lambda calculi. </title> <booktitle> Proceedings of the 18-th ACM Symposium on the Principles of Programming Languages, </booktitle> <month> January </month> <year> 1991, </year> <pages> pp. 119-130. </pages>
Reference-contexts: interpretation, which reduces the problem of type inference to first-order unification [Rob65], has played a central role in a complete analysis of the computational complexity of ML type inference [KM89, Mai90, KMM91], as well as providing insight in the first significant lower bounds on type inference for higher-order typed -calculi <ref> [HM91] </ref>. 2 Preliminaries 2.1 Expressions We consider ML expressions defined by the grammar: E : : = x j EE j x:E j let x = E in E j fix x:E where x ranges over a set V of expression variables.
Reference: [HS87] <author> R. Hindley and J. Seldin. </author> <title> Introduction to Combinators and Lambda Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1987. </year>
Reference-contexts: We write FV (E) to denote the free variables of E. We allow ff-renaming and fi-reduction as in the -calculus, as well as reduction of let-expressions following the rule: let x = E in B ! let [E=x]B For more details concerning reductions in the -calculus and ML, see <ref> [Bar84, HS87, HMT90] </ref>. 2.2 Types The syntax of types is given by the grammar: T 0 : : = t j T 0 ! T 0 where t ranges over a set T V of type variables. <p> However, the proof is overly tedious and technical, and requires an understanding of minimal complete developments in the -calculus <ref> [HS87, Bar84] </ref>. But most 5 of all, it contradicts an overwhelming sentiment that the equivalence we want is something very simple which should be easy to prove.
Reference: [HW88] <editor> P. Hudak and P. L. Wadler, editors. </editor> <title> Report on the functional programming language Haskell. </title> <institution> Yale University Technical Report YALEU/DCS/RR656, </institution> <year> 1988. </year>
Reference-contexts: Type polymorphism has since been incorporated into a variety of functional programming languages <ref> [HW88, Tur85] </ref>.
Reference: [KM89] <author> P. C. Kanellakis and J. C. Mitchell. </author> <title> Polymorphic unification and ML typing. </title> <institution> Brown University Technical Report CS-89-40, </institution> <month> August </month> <year> 1989. </year> <booktitle> Also in Proceedings of the 16-th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pp. 105-115, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The simple combinatorics of the monomor-phic interpretation, which reduces the problem of type inference to first-order unification [Rob65], has played a central role in a complete analysis of the computational complexity of ML type inference <ref> [KM89, Mai90, KMM91] </ref>, as well as providing insight in the first significant lower bounds on type inference for higher-order typed -calculi [HM91]. 2 Preliminaries 2.1 Expressions We consider ML expressions defined by the grammar: E : : = x j EE j x:E j let x = E in E j <p> Of course, the module could instead give the code, but in practice the type is shorter. There are, however, examples where the type is much larger than the code, and these pathological examples provide the foundation for lower bounds on type inference <ref> [KM89, Mai90, KMM91] </ref>. In short: most general specifications (i.e., types) can be considerably longer than the programs implementing the specifications when the specification language is rich enough. The equivalence proofs we have given are based on a fairly straightforward structural induction.
Reference: [KMM91] <author> P. C. Kanellakis, H. G. Mairson, and J. C. Mitchell. </author> <title> Unification and ML type reconstruction. </title> <booktitle> In Computational Logic: Essays in Honor of Alan Robinson, </booktitle> <editor> ed. J.-L. Lassez and G. Plotkin. </editor> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The simple combinatorics of the monomor-phic interpretation, which reduces the problem of type inference to first-order unification [Rob65], has played a central role in a complete analysis of the computational complexity of ML type inference <ref> [KM89, Mai90, KMM91] </ref>, as well as providing insight in the first significant lower bounds on type inference for higher-order typed -calculi [HM91]. 2 Preliminaries 2.1 Expressions We consider ML expressions defined by the grammar: E : : = x j EE j x:E j let x = E in E j <p> A proof along these lines can indeed be given, where we proceed by a double induction on the structure of E and the maximum number of let-reductions needed to reduce E to let-normal form; see the Appendix of <ref> [KMM91] </ref>. However, the proof is overly tedious and technical, and requires an understanding of minimal complete developments in the -calculus [HS87, Bar84]. But most 5 of all, it contradicts an overwhelming sentiment that the equivalence we want is something very simple which should be easy to prove. <p> In the case of a closed term E with empty contexts, we have ` P ; fl E: t iff ` M ; fl E: t , as in <ref> [KMM91] </ref>. However, inspired by the example of Tait's strong normalization theorem for the first order typed -calculus [Tai67], we have facilitated the proof by strengthening the induction hypothesis of what is to be a syntax directed induction on E. <p> Of course, the module could instead give the code, but in practice the type is shorter. There are, however, examples where the type is much larger than the code, and these pathological examples provide the foundation for lower bounds on type inference <ref> [KM89, Mai90, KMM91] </ref>. In short: most general specifications (i.e., types) can be considerably longer than the programs implementing the specifications when the specification language is rich enough. The equivalence proofs we have given are based on a fairly straightforward structural induction.
Reference: [KTU90] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> Undecidability of the semi-unification problem. </title> <booktitle> Proceedings of the 22nd ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1990. </year> <note> (See also Boston University Technical Report, </note> <month> October </month> <year> 1989). </year>
Reference-contexts: In addition, we analyze an extension of the ML inference system proposed by Alan Mycroft [Myc84], allowing fixpoints where the variable appearing in a recursion equation may have a polymorphic type. While type inference for this system is not computable <ref> [KTU90] </ref>, we show that the inference system has nonetheless a purely monomorphic interpretation. We believe that the monomorphic interpretation is important because it gives a purely combinatorial understanding of a significant fragment of the Girard/Reynolds second-order polymorphic typed -calculus [Gir72, Rey74]. <p> It has recently been shown by Kfoury, Tiuryn, and Urzyczyn that type inference in the presence of such a polymorphic fixpoint is undecidable <ref> [KTU90] </ref>. In this section, we show that polymorphic fixpoint can also be described using type monomorphism only.
Reference: [Mai90] <author> H. G. Mairson. </author> <title> Deciding ML typability is complete for deterministic exponential time. </title> <booktitle> In Proceedings of the 17-th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pp. 382-401, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The simple combinatorics of the monomor-phic interpretation, which reduces the problem of type inference to first-order unification [Rob65], has played a central role in a complete analysis of the computational complexity of ML type inference <ref> [KM89, Mai90, KMM91] </ref>, as well as providing insight in the first significant lower bounds on type inference for higher-order typed -calculi [HM91]. 2 Preliminaries 2.1 Expressions We consider ML expressions defined by the grammar: E : : = x j EE j x:E j let x = E in E j <p> Of course, the module could instead give the code, but in practice the type is shorter. There are, however, examples where the type is much larger than the code, and these pathological examples provide the foundation for lower bounds on type inference <ref> [KM89, Mai90, KMM91] </ref>. In short: most general specifications (i.e., types) can be considerably longer than the programs implementing the specifications when the specification language is rich enough. The equivalence proofs we have given are based on a fairly straightforward structural induction.
Reference: [Mil78] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences 17, </journal> <pages> pp. 348-375, </pages> <year> 1978. </year>
Reference-contexts: 1 Introduction In his influential paper, "A theory of type polymorphism in programming," Robin Milner proposed an extension to the first order typed -calculus which has become known as the core of the ML programming language <ref> [Mil78, HMT90] </ref>. The extension augmented the monomorphic type language of the first order typed -calculus with polytypes (also known as type schemes) allowing a limited form of quantification over type variables. <p> Observe the use in rule (let P ) of types with quantifiers (namely, the binding for x), requiring the rules (gen P ) and (inst P ) for quantifier introduction and elimination. For more details on type inference rules, we recommend <ref> [Car84, Han87, Mil78, Wan87] </ref>. 2.3.1 Core ML inference rules for the polytype system (var P ) [ fx: g fl x: fl E: (t) [t 62 FV ()] (inst P ) fl E: 8t:(t) (abs P ) fl x:E: t 0 ! t 1 fl M : t 0 ! t <p> The propositions in P have a most general unifier, namely a proposition such that p for each p 2 P . We make the related observation that the monomorphic inference rules for Core ML show that the principal type property proved in <ref> [Mil78] </ref> is a straightforward consequence of the existence of most general unifiers in the first-order domain. Similar to fi-reduction, let-reduction can be viewed as a proof transformation.
Reference: [Mit90] <author> J. C. Mitchell. </author> <title> Type systems for programming languages. </title> <note> To appear as a chapter in the Handbook of Theoretical Computer Science, </note> <editor> van Leeuwen et al., eds. </editor> <publisher> North-Holland, </publisher> <year> 1990. </year> <month> 14 </month>
Reference-contexts: The effect is the same as considering the expression to be a marked redex (I:II)(z:z) 1 in the theory of labelled reductions [Bar84]. The monomorphic realization of ML's parametric polymorphism is not new. A recent survey of type systems in programming <ref> [Mit90] </ref> attributes the observation to Albert Meyer.
Reference: [MH88] <author> J. C. Mitchell and R. Harper. </author> <title> The essence of ML. </title> <booktitle> In Proceedings of the 15-th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 28-46, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Excluding expressions of the form fix x:E where E 2 E, the language considered is known as Core ML (see, for example, <ref> [MH88] </ref>). The syntax of Core ML is just that of the -calculus augmented with the polymorphic let construct. We write FV (E) to denote the free variables of E.
Reference: [Myc84] <author> A. Mycroft. </author> <title> Polymorphic types schemes and recursive definitions. </title> <booktitle> In Proceedings International Symposium on Programming, </booktitle> <editor> M. Paul and B. Robinet eds, </editor> <booktitle> Lecture Notes in Computer Science 167, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pages 217-228, </pages> <year> 1984. </year>
Reference-contexts: In addition, we analyze an extension of the ML inference system proposed by Alan Mycroft <ref> [Myc84] </ref>, allowing fixpoints where the variable appearing in a recursion equation may have a polymorphic type. While type inference for this system is not computable [KTU90], we show that the inference system has nonetheless a purely monomorphic interpretation. <p> As a consequence, adding monomorphic fixpoint does not make type inference particularly more complex. Alan Mycroft <ref> [Myc84] </ref> proposed a more powerful variant to the above rule, whereby fix -bound variables could occur polymorphically: (fix P ) fl fix x:E: In this rule, is a polytype.
Reference: [Rey74] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings of the Paris Colloquium on Programming, Lecture Notes in Computer Science 19, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pp. 408-425, </pages> <year> 1974. </year>
Reference-contexts: While type inference for this system is not computable [KTU90], we show that the inference system has nonetheless a purely monomorphic interpretation. We believe that the monomorphic interpretation is important because it gives a purely combinatorial understanding of a significant fragment of the Girard/Reynolds second-order polymorphic typed -calculus <ref> [Gir72, Rey74] </ref>. It provides as well a classic example of quantifier elimination, which in the context of the Curry-Howard propositions-as-types analogy serves as a sort of Gentzen-style cut elimination.
Reference: [Rob65] <author> J. A. Robinson. </author> <title> A machine oriented logic based on the resolution principle. </title> <journal> Journal of the ACM 12(1) </journal> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: It provides as well a classic example of quantifier elimination, which in the context of the Curry-Howard propositions-as-types analogy serves as a sort of Gentzen-style cut elimination. The simple combinatorics of the monomor-phic interpretation, which reduces the problem of type inference to first-order unification <ref> [Rob65] </ref>, has played a central role in a complete analysis of the computational complexity of ML type inference [KM89, Mai90, KMM91], as well as providing insight in the first significant lower bounds on type inference for higher-order typed -calculi [HM91]. 2 Preliminaries 2.1 Expressions We consider ML expressions defined by the
Reference: [Tai67] <author> W. W. Tait. </author> <title> Intensinal interpretation of functionals of finite type I. </title> <journal> J. Symbolic Logic 32, </journal> <pages> pp. 198-212, </pages> <year> 1967. </year>
Reference-contexts: In the case of a closed term E with empty contexts, we have ` P ; fl E: t iff ` M ; fl E: t , as in [KMM91]. However, inspired by the example of Tait's strong normalization theorem for the first order typed -calculus <ref> [Tai67] </ref>, we have facilitated the proof by strengthening the induction hypothesis of what is to be a syntax directed induction on E. Before continuing with the proof, we introduce a standard structural lemma allowing us to "normalize" derivations in the polytype system for use in a syntax-directed proof.
Reference: [Tur85] <author> D. A. Turner. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In IFIP International Conference on Functional Programming and Computer Architecture, Nancy, Lecture Notes in Computer Science 201, </booktitle> <pages> pp. 1-16, </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Type polymorphism has since been incorporated into a variety of functional programming languages <ref> [HW88, Tur85] </ref>.
Reference: [Wan87] <author> M. Wand. </author> <title> A simple algorithm and proof for type inference. </title> <note> Fundamenta Infor-maticae 10 (1987). 15 </note>
Reference-contexts: Observe the use in rule (let P ) of types with quantifiers (namely, the binding for x), requiring the rules (gen P ) and (inst P ) for quantifier introduction and elimination. For more details on type inference rules, we recommend <ref> [Car84, Han87, Mil78, Wan87] </ref>. 2.3.1 Core ML inference rules for the polytype system (var P ) [ fx: g fl x: fl E: (t) [t 62 FV ()] (inst P ) fl E: 8t:(t) (abs P ) fl x:E: t 0 ! t 1 fl M : t 0 ! t
References-found: 27

