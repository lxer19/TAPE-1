URL: ftp://ftp.cs.umd.edu/pub/realtime/fischer-thesis.ps.gz
Refering-URL: http://www.cs.umd.edu/projects/TimeWare/TimeWare-index-no-abs.html
Root-URL: 
Title: Compositional Verification by Model Checking for Counter-Examples  
Author: Jeffrey M. Fischer, 
Degree: Doctor of Philosophy, 1996 Dissertation directed by: Associate Professor Richard Gerber  
Affiliation: Department of Computer Science  
Note: Abstract Title of Dissertation:  
Abstract: Many concurrent systems are required to maintain certain safety and liveness properties. One emerging method of achieving confidence in such systems is to statically verify them using model checking. In this approach an abstract, finite-state model of the system is constructed; then an automatic check is made to ensure that the requirements are satisfied by the model. In practice, however, this method is limited by the state space explosion problem. We have developed a compositional method that directly addresses this problem in the context of multi-tasking programs. Our solution depends on three key space-saving ingredients: (1) checking for counter-examples, which leads to simpler search algorithms; (2) automatic extraction of interfaces, which allows a refinement of the finite model even before its communicating partners have been compiled; and (3) using propositional "strengthening assertions" for the sole purpose of reducing state space. 
Abstract-found: 1
Intro-found: 1
Reference: [A94] <author> A. Arnold. </author> <title> Finite Transition Systems Prentice Hall, </title> <year> 1994 </year>
Reference-contexts: Efficient model checking algorithms have been developed for this logic (see [EL86],[B92]). Many different formalisms have been developed for the modeling of concurrent programs (see [M89], [MP91], [O91]). The most commonly occurring formalism in model checking schemes is the finite state transition system (see 20 <ref> [A94] </ref>). There is a large number of variations on this basic scheme, e.g., petri nets, i/o automata, hybrid automata, timed transition systems, state charts, and mode charts (see [ACD90], [ACHH92], [PTY93]).
Reference: [ACD90] <author> R. Alur, C. Courcoubetis, and D. L. Dill. </author> <title> Model-checking for real-time systems. </title> <booktitle> Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> 414-425, </pages> <year> 1990. </year>
Reference-contexts: The most commonly occurring formalism in model checking schemes is the finite state transition system (see 20 [A94]). There is a large number of variations on this basic scheme, e.g., petri nets, i/o automata, hybrid automata, timed transition systems, state charts, and mode charts (see <ref> [ACD90] </ref>, [ACHH92], [PTY93]). One of the basic modeling choices in all of these variations is whether concurrent execution should be represented by a synchronous or an asynchronous structure. <p> The extension of untimed model checkers to support a discrete clock is fairly straight-forward (see [AH90]). But the addition of time, regardless of whether a discrete or a dense time model is used, makes model checking a significantly more complex problem (see <ref> [ACD90] </ref>, [AH90], [HNSY92], [BES93], [H93]). Non-Finite Systems support the verification of properties whose satisfac-tion depend upon the values of data objects. Once we add data into the picture, automating the verification of a system becomes a much more difficult problem.
Reference: [ACDHW93] <author> R. Alur, C. Courcoubetis, D. L. Dill. N. Halbwachs, and H. Wong-Toi. </author> <title> Minimization of timed transition systems. </title> <journal> CONCUR93, </journal> <volume> LNCS 630, </volume> <year> 1993. </year>
Reference-contexts: Many age-old theorems show that it is impossible to find a generally applicable, fully automated, verification method. However, for some classes of systems and properties, practical model checking approaches can be developed (see [JP89], [BBLS92], [KL93], <ref> [ACDHW93] </ref>). One approach to automating the reasoning about data values in programs is that of abstract interpretation (see [CC76], [F93]) where the statements of a program are symbolically executed to discover which values of variables can reach which statements.
Reference: [ACHH92] <author> R. Alur, C. Courcoubetis, T. A. Henzinger, and P. Ho. </author> <title> Hybrid automata: an algorithmic approach to the specification and verification of hybrid systems. </title> <booktitle> Proceedings of the Workshop on Theory of Hybrid Systems, </booktitle> <year> 1992. </year>
Reference-contexts: The most commonly occurring formalism in model checking schemes is the finite state transition system (see 20 [A94]). There is a large number of variations on this basic scheme, e.g., petri nets, i/o automata, hybrid automata, timed transition systems, state charts, and mode charts (see [ACD90], <ref> [ACHH92] </ref>, [PTY93]). One of the basic modeling choices in all of these variations is whether concurrent execution should be represented by a synchronous or an asynchronous structure.
Reference: [ADARM] <institution> Ada 95 Reference manual US DOD, </institution> <year> 1995 </year>
Reference: [AH90] <author> R. Alur and T. A. </author> <title> Henzinger Real-time logics: complexity and expressiveness. </title> <booktitle> Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <year> 1990. </year> <month> 195 </month>
Reference-contexts: The principal design choices in these extensions are whether an implicit or an explicit clock is assumed and whether time advances in discrete steps or continuously (see [O91]). The extension of untimed model checkers to support a discrete clock is fairly straight-forward (see <ref> [AH90] </ref>). But the addition of time, regardless of whether a discrete or a dense time model is used, makes model checking a significantly more complex problem (see [ACD90], [AH90], [HNSY92], [BES93], [H93]). Non-Finite Systems support the verification of properties whose satisfac-tion depend upon the values of data objects. <p> The extension of untimed model checkers to support a discrete clock is fairly straight-forward (see <ref> [AH90] </ref>). But the addition of time, regardless of whether a discrete or a dense time model is used, makes model checking a significantly more complex problem (see [ACD90], [AH90], [HNSY92], [BES93], [H93]). Non-Finite Systems support the verification of properties whose satisfac-tion depend upon the values of data objects. Once we add data into the picture, automating the verification of a system becomes a much more difficult problem.
Reference: [B86] <author> M. C. Brown. </author> <title> An improved algorithm for the automatic verification of finite state systems using temporal logic. </title> <booktitle> Proceedings of the Symposium on Logic in Computer Science, </booktitle> <year> 1986. </year>
Reference-contexts: structures (see [M83]) in our compositional approach will be explained in Chapter 3 and it will be shown that the choice of a synchronous model does not preclude the modeling of asynchronous behaviors (see [KMOS95]). 2.1.2 Decision Procedures Many different decision procedures for model checking have been proposed (see [LP84], <ref> [B86] </ref>, [CES86], [EL86], [CG87], [JJ89], [C90], [KV90], [EHS93]) and a considerable amount of research has been directed towards techniques for reducing the sizes of the structures that need to be constructed to carry out model checking. In practice, the structure size normally dictates the cost of the verification.
Reference: [B92] <author> J. Bradfield. </author> <title> Verifying Temporal Properties of Systems Birkhauser, </title> <year> 1992 </year>
Reference-contexts: Proofs of the lemmas presented in the dissertation can be found in the Appendix. 18 Chapter 2 Related Work There is a wide range in capability and accuracy of various modeling techniques as well as in the complexity of verifying properties of the models (see [M89], [MP91], [O91], <ref> [B92] </ref>, and [GL92]). The particular technique we use is model checking. 2.1 Model Checking Model checking refers to a family of techniques that are used to check that a mathematical structure satisfies a sentence in a suitable logic.
Reference: [BBLS92] <author> S. Bensalem, A. Bouajjani, C. Loiseaux, and J. Sifakis. </author> <title> Property preserving simulations. </title> <booktitle> Proceedings CAV92, </booktitle> <volume> LNCS 663, </volume> <pages> 260-273, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Many age-old theorems show that it is impossible to find a generally applicable, fully automated, verification method. However, for some classes of systems and properties, practical model checking approaches can be developed (see [JP89], <ref> [BBLS92] </ref>, [KL93], [ACDHW93]). One approach to automating the reasoning about data values in programs is that of abstract interpretation (see [CC76], [F93]) where the statements of a program are symbolically executed to discover which values of variables can reach which statements.
Reference: [BCG88] <author> M. C. Brown, E. M. Clarke, and O. Grumberg. </author> <title> Characterizing finite kripke structures in propositional temporal logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 115-131, </pages> <year> 1988. </year>
Reference-contexts: An alternative to encoding fairness in the formulae that are checked is to apply the fairness constraints operationally during the check. It has been shown that this approach can be used to extend CTL model checkers without introducing significantly higher verification costs (see [EL87], <ref> [BCG88] </ref>, [NV90]). Real-Time Systems support the verification of properties whose satisfaction is dependent upon durations measured by a clock. Many of the familiar propositional temporal logics have been extended to support timed specifications.
Reference: [BCMDH90] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. H. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> 428-439, </pages> <year> 1990. </year>
Reference-contexts: Of course, we may not need to model every state to support the analysis of a particular formula, and there may be ways to efficiently encode the states, e.g., BDD's <ref> [BCMDH90] </ref>. 3 Our research has focused on the effect of concurrency on model growth. This is commonly referred to as the state space explosion problem. See Figure 1.1. <p> Symbolic methods reduce the size of models by describing them more efficiently. Instead of using a structure that explicitly lists each state and transition of a model, a symbolic encoding, such as binary decision diagrams is employed 22 (see <ref> [BCMDH90] </ref>, [CGL92], [M93]). 2.1.3 Extensions While much research has addressed model size reductions and other practical improvements to the basic approach, other research has focused on extensions that enable a wider range of properties to be checked: Fair Systems support the verification of properties under a set of fairness assumptions.
Reference: [BES93] <author> A. Bouajjani, R. Echahed, and J. Sifakis. </author> <title> On model checking for real-time properties with durations. </title> <booktitle> Proceedings of the Eight Annual Symposium on Logic in Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: The extension of untimed model checkers to support a discrete clock is fairly straight-forward (see [AH90]). But the addition of time, regardless of whether a discrete or a dense time model is used, makes model checking a significantly more complex problem (see [ACD90], [AH90], [HNSY92], <ref> [BES93] </ref>, [H93]). Non-Finite Systems support the verification of properties whose satisfac-tion depend upon the values of data objects. Once we add data into the picture, automating the verification of a system becomes a much more difficult problem.
Reference: [BFG96] <author> T. Bultan, J. Fischer and R. Gerber. </author> <title> Compositional Verification by Model Checking for Counter-Examples Proceedings ISSTA'96. </title> <year> 1996. </year>
Reference-contexts: If the second formula can be proved compositionally, then the original formula can be inferred (see [K92]) without requiring compositions. A third approach is to decompose the formula, check each subformula on every component, and compose the check results (see [CSSB92]). Our research (see [FG94], <ref> [BFG96] </ref>) builds mainly upon this last method, but also includes elements of both of the other compositional approaches. Local methods expand the global, composite model on-the-fly during a check.
Reference: [BFHR92] <author> A. Bouajjani, J. Fernandez, N. Halbwachs, P. Raymond, and C. Ra-tel. </author> <title> Minimal state graph generation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 18 </volume> <pages> 247-269, </pages> <year> 1992. </year> <month> 196 </month>
Reference-contexts: Although it is not in itself a verification technique, model minimization is an important area of research with applicability to both model checking and reachability analysis. Methods have been developed for minimizing an already existing transition system structure (see [PT87]) as well as generating a minimal structure on-the-fly (see <ref> [BFHR92] </ref>). The key idea with minimization is that the reduced model is in some formal sense equivalent to the original with respect a specific set of properties.
Reference: [C90] <author> R. Cleaveland. </author> <title> Tableau-based model checking in the propositional mu--calculus. </title> <journal> Acta Informatica, </journal> <volume> 27 </volume> <pages> 725-747, </pages> <year> 1990. </year>
Reference-contexts: Our model checking algorithms are descendents of this family of decision procedures, but other automated techniques have been developed for the same logics, e.g., tableau based decision procedures (see [SW89], <ref> [C90] </ref>). Temporal logic enables us to reason about temporal sequences of states, by allowing formulae of the logic to have different truth values at different times. Modal logics are a generalization of this idea to sequences which are not necessarily temporal in nature. <p> compositional approach will be explained in Chapter 3 and it will be shown that the choice of a synchronous model does not preclude the modeling of asynchronous behaviors (see [KMOS95]). 2.1.2 Decision Procedures Many different decision procedures for model checking have been proposed (see [LP84], [B86], [CES86], [EL86], [CG87], [JJ89], <ref> [C90] </ref>, [KV90], [EHS93]) and a considerable amount of research has been directed towards techniques for reducing the sizes of the structures that need to be constructed to carry out model checking. In practice, the structure size normally dictates the cost of the verification.
Reference: [C96] <author> J. C. </author> <title> Corbett Evaluating deadlock detection methods for concurrent systems. </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> 22(3) </volume> <pages> 161-180, </pages> <year> 1996. </year>
Reference-contexts: There is food in front of each philosopher and to eat it a philosopher must hold two forks. The problem is to develop a fork protocol for the philosophers that is free of deadlock and starvation. The solution that we analyze is taken from <ref> [C96] </ref> where several solutions to this problem (as well as many others) were analyzed to determine the merits of various deadlock detection methods. As reported in [C96] the state space for this solution grows very rapidly as more philosophers are added: Number of Philosophers 4 5 6 7 Number of States <p> The solution that we analyze is taken from <ref> [C96] </ref> where several solutions to this problem (as well as many others) were analyzed to determine the merits of various deadlock detection methods. As reported in [C96] the state space for this solution grows very rapidly as more philosophers are added: Number of Philosophers 4 5 6 7 Number of States 601 3489 19861 109965 Instead of showing that the solution is deadlock free we will prove the stronger result the lack of starvation.
Reference: [CC76] <author> P. Cousot and R. Cousot. </author> <title> Static determination of dynamic properties of programs. </title> <booktitle> 2nd Internation Symposium on Programming, </booktitle> <year> 1976. </year>
Reference-contexts: However, for some classes of systems and properties, practical model checking approaches can be developed (see [JP89], [BBLS92], [KL93], [ACDHW93]). One approach to automating the reasoning about data values in programs is that of abstract interpretation (see <ref> [CC76] </ref>, [F93]) where the statements of a program are symbolically executed to discover which values of variables can reach which statements.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> Proceedings of the Fourth Annual Symposium on Principles of Programming Languages, </booktitle> <year> 1977. </year>
Reference: [CDHW93] <author> C. Courcoubetis, D. Dill, N. Halbwachs, and H. Wong-Toi. </author> <title> An implementation of three algorithms for timing verification based on automata emptiness. </title> <year> 1993. </year>
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Our research builds upon the 1 Computation Tree Logic a branching time temporal logic. 2 CTL model checking procedure devised by Clarke, Emerson, and Sistla <ref> [CES86] </ref>. Their procedure for determining the satisfiability of a sentence in the logic is linear in both the length of the sentence and the size of the model. Indeed, there are logics more expressive than CTL that we could employ as our specification language. <p> Several linear time model checking algorithms have been developed (e.g., [LP84]), but it has been shown that the decision procedures for CTL model checking are never less efficient than comparable linear time logics (see [EL84]). Efficient CTL model checking was first introduced in <ref> [CES86] </ref>, but the decision procedures are based upon earlier algorithms such as those in [EH82]. Our model checking algorithms are descendents of this family of decision procedures, but other automated techniques have been developed for the same logics, e.g., tableau based decision procedures (see [SW89], [C90]). <p> (see [M83]) in our compositional approach will be explained in Chapter 3 and it will be shown that the choice of a synchronous model does not preclude the modeling of asynchronous behaviors (see [KMOS95]). 2.1.2 Decision Procedures Many different decision procedures for model checking have been proposed (see [LP84], [B86], <ref> [CES86] </ref>, [EL86], [CG87], [JJ89], [C90], [KV90], [EHS93]) and a considerable amount of research has been directed towards techniques for reducing the sizes of the structures that need to be constructed to carry out model checking. In practice, the structure size normally dictates the cost of the verification. <p> These cannot be formalized in CTL, but can be in CTL*: Weak Fairness: 823 (:enabled _ executed) Strong Fairness: 8 (32 (:enabled) _ 23 (executed)) Although we must use CTL* to express these fairness properties, it was shown in <ref> [CES86] </ref> that their verification does not require the full power of a CTL* model checker. Efficient analysis of fairness properties can be handled within our CTL model checking framework. <p> These models are computed in a bottom-up order by a set of operator/atom specific, projection functions that (conservatively) decide satisfaction. This bottom-up quality of CTL model checking is readily apparent in our most basic strategy: the non-compositional check which we adapt from <ref> [CES86] </ref>. 57 p 4 = P (k i2- T i ; 92 (p 3 ))p 2 = P (k i2- T i ; in call (x; y:p)) p 5 = P (k i2- T i ; (p 2 ^ p 4 ))p 1 = P (k i2- T i ; TRUE) <p> Even so, as was shown in <ref> [CES86] </ref> and [EL87], a CTL model checker can handle these properties. This enables us to restrict the counter-examples identified by our checks to ones that lie on fair paths. We have adapted our support for fairness properties from [EL87], but have not incorporated all of the capabilities discussed there. <p> Let CT Lmc (T -; F ) be the function given by <ref> [CES86] </ref> for identifying the states of the global model that satisfy F . Note that passing the CTL model checker a set of transitions is equivalent to giving it the customary (state set, transition relation) pair since our global models are total.
Reference: [CG87] <author> E. M. Clarke and O. Grumberg. </author> <title> Avoiding the state explosion problem in temporal logic model checking algorithms. </title> <year> 1987. </year>
Reference-contexts: in our compositional approach will be explained in Chapter 3 and it will be shown that the choice of a synchronous model does not preclude the modeling of asynchronous behaviors (see [KMOS95]). 2.1.2 Decision Procedures Many different decision procedures for model checking have been proposed (see [LP84], [B86], [CES86], [EL86], <ref> [CG87] </ref>, [JJ89], [C90], [KV90], [EHS93]) and a considerable amount of research has been directed towards techniques for reducing the sizes of the structures that need to be constructed to carry out model checking. In practice, the structure size normally dictates the cost of the verification.
Reference: [CGL92] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> Proceedings of the Nineteenth Annual Symposium on Principles of Programming Languages, </booktitle> <pages> 343-354, </pages> <year> 1992. </year> <month> 197 </month>
Reference-contexts: Symbolic methods reduce the size of models by describing them more efficiently. Instead of using a structure that explicitly lists each state and transition of a model, a symbolic encoding, such as binary decision diagrams is employed 22 (see [BCMDH90], <ref> [CGL92] </ref>, [M93]). 2.1.3 Extensions While much research has addressed model size reductions and other practical improvements to the basic approach, other research has focused on extensions that enable a wider range of properties to be checked: Fair Systems support the verification of properties under a set of fairness assumptions.
Reference: [CK93] <author> S. C. Cheung and J. </author> <title> Kramer Enhancing compositional reachability analysis with context constraints. </title> <booktitle> Proceedings FSE'93, </booktitle> <year> 1993. </year>
Reference-contexts: One method builds upon the observation that not all of the behaviors in its environment will affect the behavior of a given component. This allows the creation of an abstracted version of the component's environment (see [CLM89], <ref> [CK93] </ref>). The component being analyzed is composed with its customized environment and then checked. 21 Another method addresses compositionality in the logic rather than the model. It may not be provable, in isolation, that some component satisfies a particular formula.
Reference: [CLM89] <author> E. M. Clarke, D. E. Long, and K. L. McMillan. </author> <title> Compositional model checking. </title> <booktitle> Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> 464-475, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: One method builds upon the observation that not all of the behaviors in its environment will affect the behavior of a given component. This allows the creation of an abstracted version of the component's environment (see <ref> [CLM89] </ref>, [CK93]). The component being analyzed is composed with its customized environment and then checked. 21 Another method addresses compositionality in the logic rather than the model. It may not be provable, in isolation, that some component satisfies a particular formula.
Reference: [CPS91] <author> R. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The Concurrency Workbench. Proceedings of the Workshop on Automatic Verification Methods for Finite-State Systems, </title> <publisher> LNCS 407, </publisher> <pages> 24-37, </pages> <year> 1990. </year>
Reference: [CS85] <author> E. M. Clarke and A. P. Sistla. </author> <title> The complexity of propositionbal linear temporal logics. </title> <journal> JACM, </journal> <volume> 32(3) </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: The particular technique we use is model checking. 2.1 Model Checking Model checking refers to a family of techniques that are used to check that a mathematical structure satisfies a sentence in a suitable logic. Various structures and logics have been proposed for this use (see [EL84], <ref> [CS85] </ref>, [S89], [E90], [EES90], [G90]). 2.1.1 Logics and Models Most model checkers employ a propositional temporal logic; the one we use is called CTL. The temporal logics can be divided into two categories: linear time and branching time.
Reference: [CSSB92] <author> R. K.Brayton, M. Chiodo, A. Sangiovanni-Vincentelli, and T. R. Shiple. </author> <title> Automatic reduction in CTL compositional model checking. </title> <booktitle> Proceedings CAV'92, </booktitle> <volume> LNCS 663, </volume> <pages> 234-247, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The preliminary work by <ref> [CSSB92] </ref> describes an approach where the partitioning of a compositional check is dictated by the hierarchical decomposition of a formula by its subformulae. Our approach is more flexible. In particular: 1. <p> If the second formula can be proved compositionally, then the original formula can be inferred (see [K92]) without requiring compositions. A third approach is to decompose the formula, check each subformula on every component, and compose the check results (see <ref> [CSSB92] </ref>). Our research (see [FG94], [BFG96]) builds mainly upon this last method, but also includes elements of both of the other compositional approaches. Local methods expand the global, composite model on-the-fly during a check. <p> So instead of composing the model all at once, we can build it incrementally, eliding parts that we won't need for a particular check. Our compositional strategy, breadth first check, adapted from <ref> [CSSB92] </ref>, exemplifies this approach. Figure 5.4 shows this strategy applied to the current example. Let us again consider the calculation of p 4 . As before, we must first compute p 3 , but this time we take a compositional approach. <p> The largest models that DF C checked had only 22 transitions and these were the original local models for x and y. The global model that DF C checked had only 14 transitions. 5.6 Breadth First Check The compositional approach suggested by <ref> [CSSB92] </ref>, is to progressively project and compose each nested subformula on every model. We call this a breadth first strategy and show its algorithm in Figure 5.20.
Reference: [D90] <author> L. K. Dillon. </author> <title> Using symbolic execution for verification of Ada tasking programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 643-669, </pages> <month> October </month> <year> 1990. </year>
Reference: [DS91] <author> E. Duesterwald and M. L. Soffa. </author> <title> Concurrency analysis in the presence of procedures using a data-flow framework. </title> <publisher> ACM. </publisher> <year> 1991. </year>
Reference: [E90] <author> E. A. Emerson. </author> <title> Temporal and modal logic Handbook of Theoretical Computer Science, </title> <publisher> Birkhauser, </publisher> <year> 1990 </year> <month> 198 </month>
Reference-contexts: The particular technique we use is model checking. 2.1 Model Checking Model checking refers to a family of techniques that are used to check that a mathematical structure satisfies a sentence in a suitable logic. Various structures and logics have been proposed for this use (see [EL84], [CS85], [S89], <ref> [E90] </ref>, [EES90], [G90]). 2.1.1 Logics and Models Most model checkers employ a propositional temporal logic; the one we use is called CTL. The temporal logics can be divided into two categories: linear time and branching time. The distinction is based upon whether implicit or explicit 19 path quantification is used. <p> The syntax and semantics for a basis of CTL* is summarized in Tables 4.1,4.2, which we have adapted from <ref> [E90] </ref>. The logic CTL is derived from CTL* by restricting the placement of temporal operators. In particular, every temporal operator 49 must be immediately preceeded by a quantifier. Recall that CTL* is a propositional logic quantification is only applied to path formulae. <p> Recall that CTL* is a propositional logic quantification is only applied to path formulae. CTL places the additional requirement that quantification not be applied to nested path formulae or their boolean combinations. We note that there are sound and complete deductive systems for CTL (see <ref> [E90] </ref>) that can be used independently, or as we shall see in Chapter 9, in conjunction with model checking. We formalize CTL's syntax in Table 4.3 (also adapted from [E90]). The semantics of CTL follows immediately from CTL*'s. <p> We note that there are sound and complete deductive systems for CTL (see <ref> [E90] </ref>) that can be used independently, or as we shall see in Chapter 9, in conjunction with model checking. We formalize CTL's syntax in Table 4.3 (also adapted from [E90]). The semantics of CTL follows immediately from CTL*'s.
Reference: [EES90] <author> E. A. Emerson, M. Evangelist, and J. Srinivasan. </author> <title> On the limits of temporal decidabilility. </title> <booktitle> Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: Various structures and logics have been proposed for this use (see [EL84], [CS85], [S89], [E90], <ref> [EES90] </ref>, [G90]). 2.1.1 Logics and Models Most model checkers employ a propositional temporal logic; the one we use is called CTL. The temporal logics can be divided into two categories: linear time and branching time. The distinction is based upon whether implicit or explicit 19 path quantification is used.
Reference: [EH82] <author> E. A. Emerson and J. Y. Halpern. </author> <title> Decision procedures and expressiveness in the temporal logic of branching time. </title> <booktitle> Proceedings of the Fourteenth Annual Symposium on the Theory of Computing, </booktitle> <year> 1982. </year>
Reference-contexts: Efficient CTL model checking was first introduced in [CES86], but the decision procedures are based upon earlier algorithms such as those in <ref> [EH82] </ref>. Our model checking algorithms are descendents of this family of decision procedures, but other automated techniques have been developed for the same logics, e.g., tableau based decision procedures (see [SW89], [C90]).
Reference: [EH86] <author> E. A. Emerson and J. Y. Halpern. </author> <title> 'Sometimes' and 'not never' revisited: on branching versus linear time temporal logic. </title> <journal> Journal of the ACM, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: The temporal logics can be divided into two categories: linear time and branching time. The distinction is based upon whether implicit or explicit 19 path quantification is used. The expressiveness of various branching and linear time temporal logics can be compared by representing them within a unified framework. In <ref> [EH86] </ref> a classification scheme is presented that groups temporal logics by the types of state and path formulae that they include. It is shown that an extension of the branching time logic CTL, called CTL*, is more expressive than similar linear time logics.
Reference: [EHS93] <author> E. A. Emerson, C. S. Jutla, and A. P. Sistla. </author> <title> On model-checking for fragments of -calculus. </title> <publisher> CAV93 ,LNCS 697, </publisher> <year> 1993. </year>
Reference-contexts: will be explained in Chapter 3 and it will be shown that the choice of a synchronous model does not preclude the modeling of asynchronous behaviors (see [KMOS95]). 2.1.2 Decision Procedures Many different decision procedures for model checking have been proposed (see [LP84], [B86], [CES86], [EL86], [CG87], [JJ89], [C90], [KV90], <ref> [EHS93] </ref>) and a considerable amount of research has been directed towards techniques for reducing the sizes of the structures that need to be constructed to carry out model checking. In practice, the structure size normally dictates the cost of the verification.
Reference: [EL84] <author> E. A. Emerson and C. Lei. </author> <title> Modalities for model checking: branching time strikes back. </title> <booktitle> Proceedings of the Twelth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1985. </year>
Reference-contexts: We record the interface and semantic requirements in CTL, the same specification language that we use elsewhere, allowing them to be easily understood and modified. * We have incorporated fairness and a notion of local action into a compositional framework. It was shown by <ref> [EL84] </ref> that several concepts of fairness could be efficiently supported by CTL model checking, even though the fairness properties themselves are not expressible in CTL. We have extended this approach to our compositional method. <p> The particular technique we use is model checking. 2.1 Model Checking Model checking refers to a family of techniques that are used to check that a mathematical structure satisfies a sentence in a suitable logic. Various structures and logics have been proposed for this use (see <ref> [EL84] </ref>, [CS85], [S89], [E90], [EES90], [G90]). 2.1.1 Logics and Models Most model checkers employ a propositional temporal logic; the one we use is called CTL. The temporal logics can be divided into two categories: linear time and branching time. <p> Several linear time model checking algorithms have been developed (e.g., [LP84]), but it has been shown that the decision procedures for CTL model checking are never less efficient than comparable linear time logics (see <ref> [EL84] </ref>). Efficient CTL model checking was first introduced in [CES86], but the decision procedures are based upon earlier algorithms such as those in [EH82].
Reference: [EL86] <author> E. A. Emerson and C. Lei. </author> <title> Efficient model checking in fragments of the propositional mu-calculus. </title> <booktitle> Proceedings of Symposium on Logic in Computer Science, </booktitle> <pages> 267-278, </pages> <year> 1986 </year>
Reference-contexts: [M83]) in our compositional approach will be explained in Chapter 3 and it will be shown that the choice of a synchronous model does not preclude the modeling of asynchronous behaviors (see [KMOS95]). 2.1.2 Decision Procedures Many different decision procedures for model checking have been proposed (see [LP84], [B86], [CES86], <ref> [EL86] </ref>, [CG87], [JJ89], [C90], [KV90], [EHS93]) and a considerable amount of research has been directed towards techniques for reducing the sizes of the structures that need to be constructed to carry out model checking. In practice, the structure size normally dictates the cost of the verification.
Reference: [EL87] <author> E. A. Emerson and C. Lei. </author> <title> Modalities for model checking: branching time strikes back. </title> <booktitle> Science of Computer Programming, </booktitle> (8):275-306, 1987. 
Reference-contexts: An alternative to encoding fairness in the formulae that are checked is to apply the fairness constraints operationally during the check. It has been shown that this approach can be used to extend CTL model checkers without introducing significantly higher verification costs (see <ref> [EL87] </ref>, [BCG88], [NV90]). Real-Time Systems support the verification of properties whose satisfaction is dependent upon durations measured by a clock. Many of the familiar propositional temporal logics have been extended to support timed specifications. <p> Even so, as was shown in [CES86] and <ref> [EL87] </ref>, a CTL model checker can handle these properties. This enables us to restrict the counter-examples identified by our checks to ones that lie on fair paths. We have adapted our support for fairness properties from [EL87], but have not incorporated all of the capabilities discussed there. <p> Even so, as was shown in [CES86] and <ref> [EL87] </ref>, a CTL model checker can handle these properties. This enables us to restrict the counter-examples identified by our checks to ones that lie on fair paths. We have adapted our support for fairness properties from [EL87], but have not incorporated all of the capabilities discussed there. Although we could associate fairness evaluation with each of our projection functions we have chosen 98 to evaluate fairness only during the computation of an 92 projection. <p> j ) _ 23 (p j )) 2 F if isF airComponent (T C ; p j ; q j ; (F F j )) then return TRUE end foreach end foreach return FALSE end isF airComponent But there is significant room for optimization here; the fair model checker of <ref> [EL87] </ref> only increases the complexity of CTL model checking by a quadratic factor in the length of the fairness formulae . 6.2 Semaphore Example: Part I Consider a set of n processes that share some mutually exclusive, serially reusable resource.
Reference: [F90] <author> J. Fernandez. </author> <title> An implementation of an efficient algorithm for bisim-ulation equivalence. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 13 </volume> <pages> 219-236, </pages> <year> 1990. </year>
Reference: [F93] <author> J. Fernandez. </author> <title> Abstract interpretation and verification of reactive sys-tems. </title> <year> 1993. </year>
Reference-contexts: However, for some classes of systems and properties, practical model checking approaches can be developed (see [JP89], [BBLS92], [KL93], [ACDHW93]). One approach to automating the reasoning about data values in programs is that of abstract interpretation (see [CC76], <ref> [F93] </ref>) where the statements of a program are symbolically executed to discover which values of variables can reach which statements.
Reference: [FG94] <author> J. Fischer and R. Gerber. </author> <title> Compositional Model Checking of Ada Tasking Programs Proceedings COMPASS'94. </title> <year> 1994. </year>
Reference-contexts: If the second formula can be proved compositionally, then the original formula can be inferred (see [K92]) without requiring compositions. A third approach is to decompose the formula, check each subformula on every component, and compose the check results (see [CSSB92]). Our research (see <ref> [FG94] </ref>, [BFG96]) builds mainly upon this last method, but also includes elements of both of the other compositional approaches. Local methods expand the global, composite model on-the-fly during a check.
Reference: [FKM93] <author> J. Fernandez, A. Kerbrat, and L. Mounier. </author> <title> Symbolic Equivalence Checking. </title> <journal> CAV93, </journal> <volume> LNCS 677, </volume> <year> 1993. </year>
Reference: [G90] <author> R. J. van Glabbeek. </author> <title> The linear time branching time spectrum. </title> <journal> CON-CUR90, </journal> <volume> LNCS 458, </volume> <year> 1990. </year>
Reference-contexts: Various structures and logics have been proposed for this use (see [EL84], [CS85], [S89], [E90], [EES90], <ref> [G90] </ref>). 2.1.1 Logics and Models Most model checkers employ a propositional temporal logic; the one we use is called CTL. The temporal logics can be divided into two categories: linear time and branching time. The distinction is based upon whether implicit or explicit 19 path quantification is used.
Reference: [GL92] <author> R. Gerber and I. Lee. </author> <title> A Layered Approach to Automating the Verification of Real-Time Systems. </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> 18(9) </volume> <pages> 768-784, </pages> <year> 1992. </year>
Reference-contexts: Proofs of the lemmas presented in the dissertation can be found in the Appendix. 18 Chapter 2 Related Work There is a wide range in capability and accuracy of various modeling techniques as well as in the complexity of verifying properties of the models (see [M89], [MP91], [O91], [B92], and <ref> [GL92] </ref>). The particular technique we use is model checking. 2.1 Model Checking Model checking refers to a family of techniques that are used to check that a mathematical structure satisfies a sentence in a suitable logic. <p> Another technique is reachability analysis, which restricts queries to specific properties (such as deadlock). In this approach, the analysis algorithm takes 24 a finite-state abstraction of the program, and then checks the states to deter-mine whether they conform to the property at hand (e.g., see [T83], [LC89], [MR91], <ref> [GL92] </ref>). Some of these methods are pessimistic; for example, they may report deadlock when none exists. On the other hand, they present tractable alternatives to the methods based on proof systems. A compositional application of these techniques can be found in algebraic reachability analysis ([YY91]).
Reference: [H93] <author> N. Halbwachs. </author> <title> Delay analysis in synchronous programs CAV93, </title> <publisher> LNCS 697. </publisher> <year> 1993. </year>
Reference-contexts: The extension of untimed model checkers to support a discrete clock is fairly straight-forward (see [AH90]). But the addition of time, regardless of whether a discrete or a dense time model is used, makes model checking a significantly more complex problem (see [ACD90], [AH90], [HNSY92], [BES93], <ref> [H93] </ref>). Non-Finite Systems support the verification of properties whose satisfac-tion depend upon the values of data objects. Once we add data into the picture, automating the verification of a system becomes a much more difficult problem.
Reference: [HM85] <author> M.Hennessy and R. Milner. </author> <title> Algebraic laws for nondeterminism and concurrency. </title> <journal> JACM, </journal> <volume> 32 </volume> <pages> 137-161, </pages> <year> 1985. </year>
Reference: [HNSY92] <editor> Symbolic model checking for real-time systems. </editor> <booktitle> Proceedings of the Seventh Annual Symposium on Logic in Computer Science, </booktitle> <year> 1992. </year>
Reference-contexts: The extension of untimed model checkers to support a discrete clock is fairly straight-forward (see [AH90]). But the addition of time, regardless of whether a discrete or a dense time model is used, makes model checking a significantly more complex problem (see [ACD90], [AH90], <ref> [HNSY92] </ref>, [BES93], [H93]). Non-Finite Systems support the verification of properties whose satisfac-tion depend upon the values of data objects. Once we add data into the picture, automating the verification of a system becomes a much more difficult problem.
Reference: [JJ89] <author> C. Jard and M. Jeron. </author> <title> On-line modle-checking for finite linear temporal logic specifications. Automatic Verificiation Methods for Finite State Systems, </title> <publisher> LNCS 407, </publisher> <year> 1989. </year>
Reference-contexts: our compositional approach will be explained in Chapter 3 and it will be shown that the choice of a synchronous model does not preclude the modeling of asynchronous behaviors (see [KMOS95]). 2.1.2 Decision Procedures Many different decision procedures for model checking have been proposed (see [LP84], [B86], [CES86], [EL86], [CG87], <ref> [JJ89] </ref>, [C90], [KV90], [EHS93]) and a considerable amount of research has been directed towards techniques for reducing the sizes of the structures that need to be constructed to carry out model checking. In practice, the structure size normally dictates the cost of the verification.
Reference: [JP89] <author> B. Jonsson and J. Parrow. </author> <title> Deciding bisimulation equivalences for a class of non-finite programs. </title> <journal> STACS89, </journal> <volume> LNCS 349. </volume> <year> 1989. </year> <month> 200 </month>
Reference-contexts: Many age-old theorems show that it is impossible to find a generally applicable, fully automated, verification method. However, for some classes of systems and properties, practical model checking approaches can be developed (see <ref> [JP89] </ref>, [BBLS92], [KL93], [ACDHW93]). One approach to automating the reasoning about data values in programs is that of abstract interpretation (see [CC76], [F93]) where the statements of a program are symbolically executed to discover which values of variables can reach which statements.
Reference: [K92] <author> R. Kaivola. </author> <title> Compositional model checking for linear-time temporal logic. </title> <address> CAV92. </address> <year> 1992. </year>
Reference-contexts: It may not be provable, in isolation, that some component satisfies a particular formula. However, we may be able to show that the formula is a logical implication of some second formula. If the second formula can be proved compositionally, then the original formula can be inferred (see <ref> [K92] </ref>) without requiring compositions. A third approach is to decompose the formula, check each subformula on every component, and compose the check results (see [CSSB92]). Our research (see [FG94], [BFG96]) builds mainly upon this last method, but also includes elements of both of the other compositional approaches.
Reference: [KL93] <author> I. Kang and I. Lee. </author> <title> A state minimization algorithm for communicating state machines with arbitrary data space. </title> <year> 1993. </year>
Reference-contexts: Many age-old theorems show that it is impossible to find a generally applicable, fully automated, verification method. However, for some classes of systems and properties, practical model checking approaches can be developed (see [JP89], [BBLS92], <ref> [KL93] </ref>, [ACDHW93]). One approach to automating the reasoning about data values in programs is that of abstract interpretation (see [CC76], [F93]) where the statements of a program are symbolically executed to discover which values of variables can reach which statements.
Reference: [KMMP93] <author> Y. Kesten, Z. Manna, H. McGuire, and A. Pnueli. </author> <title> A decision procedure for full propositional temporal logic. </title> <journal> CAV93, </journal> <volume> LNCS 697, </volume> <year> 1993. </year>
Reference: [KMOS95] <institution> Modelling asynchrony with a synchronous model. CAV95, </institution> <note> LNCS 939. </note> <year> 1995. </year>
Reference-contexts: The importance of synchronous structures (see [M83]) in our compositional approach will be explained in Chapter 3 and it will be shown that the choice of a synchronous model does not preclude the modeling of asynchronous behaviors (see <ref> [KMOS95] </ref>). 2.1.2 Decision Procedures Many different decision procedures for model checking have been proposed (see [LP84], [B86], [CES86], [EL86], [CG87], [JJ89], [C90], [KV90], [EHS93]) and a considerable amount of research has been directed towards techniques for reducing the sizes of the structures that need to be constructed to carry out model
Reference: [KS90] <author> P. C. Kanellakis and S. A. Smolka. </author> <title> CCS expressions, finite state processes, and three problems of equivalence. </title> <journal> Information and Computation, </journal> <volume> 86 </volume> <pages> 43-68, </pages> <year> 1990. </year>
Reference: [KV90] <author> R. Kaivola and A. </author> <title> Valmari Using truth-preserving reductions to improve the clarity of kripke-models. </title> <journal> CONCUR90, </journal> <volume> LNCS 527, </volume> <year> 1990. </year>
Reference-contexts: approach will be explained in Chapter 3 and it will be shown that the choice of a synchronous model does not preclude the modeling of asynchronous behaviors (see [KMOS95]). 2.1.2 Decision Procedures Many different decision procedures for model checking have been proposed (see [LP84], [B86], [CES86], [EL86], [CG87], [JJ89], [C90], <ref> [KV90] </ref>, [EHS93]) and a considerable amount of research has been directed towards techniques for reducing the sizes of the structures that need to be constructed to carry out model checking. In practice, the structure size normally dictates the cost of the verification.
Reference: [LC89] <author> D. L. Long and L. A. Clarke. </author> <title> Task interaction graphs for concurrency analysis. </title> <booktitle> Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> 44-52, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Another technique is reachability analysis, which restricts queries to specific properties (such as deadlock). In this approach, the analysis algorithm takes 24 a finite-state abstraction of the program, and then checks the states to deter-mine whether they conform to the property at hand (e.g., see [T83], <ref> [LC89] </ref>, [MR91], [GL92]). Some of these methods are pessimistic; for example, they may report deadlock when none exists. On the other hand, they present tractable alternatives to the methods based on proof systems. A compositional application of these techniques can be found in algebraic reachability analysis ([YY91]).
Reference: [LC91] <author> D. L. Long and L. A. Clarke. </author> <title> Data flow analysis of concurrent systems that use the rendezvous model of synchronization. </title> <year> 1991. </year>
Reference-contexts: Related techniques, for example data flow analysis, have also been used in the analysis of concurrent programs (see <ref> [LC91] </ref>, [S93]). 2.2 Related Verification Techniques Model checking provides a mechanism for verifying fairly general properties of systems that can be represented by finite models. Of course, not every system or property that we might want to explore will be analyzable via model checking.
Reference: [LP84] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specifications. </title> <year> 1984. </year>
Reference-contexts: It is shown that an extension of the branching time logic CTL, called CTL*, is more expressive than similar linear time logics. Several linear time model checking algorithms have been developed (e.g., <ref> [LP84] </ref>), but it has been shown that the decision procedures for CTL model checking are never less efficient than comparable linear time logics (see [EL84]). Efficient CTL model checking was first introduced in [CES86], but the decision procedures are based upon earlier algorithms such as those in [EH82]. <p> synchronous structures (see [M83]) in our compositional approach will be explained in Chapter 3 and it will be shown that the choice of a synchronous model does not preclude the modeling of asynchronous behaviors (see [KMOS95]). 2.1.2 Decision Procedures Many different decision procedures for model checking have been proposed (see <ref> [LP84] </ref>, [B86], [CES86], [EL86], [CG87], [JJ89], [C90], [KV90], [EHS93]) and a considerable amount of research has been directed towards techniques for reducing the sizes of the structures that need to be constructed to carry out model checking. In practice, the structure size normally dictates the cost of the verification.
Reference: [LvH85] <author> D. C. Luckham and F. W. von Henke. </author> <title> An overview of Anna, a specification language for Ada. </title> <journal> IEEE Software, </journal> <month> March </month> <year> 1985. </year> <month> 201 </month>
Reference: [LV93] <author> J. Lewi and B. </author> <title> Vergauwen A linear local model checking algorithm for CTL CONCUR93, </title> <publisher> LNCS 630, </publisher> <year> 1993. </year>
Reference-contexts: Consequently, one can build the composite model incrementally, including, and then expanding from, only those parts of models satisfying the formula being checked (see <ref> [LV93] </ref>). Partial order methods reduce the size of the global composite model by replacing globally equivalent local behaviors with representatives.
Reference: [M83] <author> R. </author> <title> Milner Calculi for synchrony and asynchrony logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <pages> 267-310, </pages> <year> 1983. </year>
Reference-contexts: One of the basic modeling choices in all of these variations is whether concurrent execution should be represented by a synchronous or an asynchronous structure. The importance of synchronous structures (see <ref> [M83] </ref>) in our compositional approach will be explained in Chapter 3 and it will be shown that the choice of a synchronous model does not preclude the modeling of asynchronous behaviors (see [KMOS95]). 2.1.2 Decision Procedures Many different decision procedures for model checking have been proposed (see [LP84], [B86], [CES86], [EL86],
Reference: [M89] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: Proofs of the lemmas presented in the dissertation can be found in the Appendix. 18 Chapter 2 Related Work There is a wide range in capability and accuracy of various modeling techniques as well as in the complexity of verifying properties of the models (see <ref> [M89] </ref>, [MP91], [O91], [B92], and [GL92]). The particular technique we use is model checking. 2.1 Model Checking Model checking refers to a family of techniques that are used to check that a mathematical structure satisfies a sentence in a suitable logic. <p> In fact, the modal mu-calculus has been called the assembly language of temporal logics. Efficient model checking algorithms have been developed for this logic (see [EL86],[B92]). Many different formalisms have been developed for the modeling of concurrent programs (see <ref> [M89] </ref>, [MP91], [O91]). The most commonly occurring formalism in model checking schemes is the finite state transition system (see 20 [A94]). <p> Some of these methods are pessimistic; for example, they may report deadlock when none exists. On the other hand, they present tractable alternatives to the methods based on proof systems. A compositional application of these techniques can be found in algebraic reachability analysis ([YY91]). Process algebras (see <ref> [M89] </ref>) provide a technique for specifying concurrent behavior and also provide alternative methods, based upon algebraic identities, for reasoning about system behaviors. Reachability analysis can make use of algebraic properties such as associativity and these properties can be recognized in the state transition models. <p> The key idea with minimization is that the reduced model is in some formal sense equivalent to the original with respect a specific set of properties. One of the most important of these equivalences is bisimularity (see <ref> [M89] </ref>); minimization techniques that preserves this equivalence have been developed ([F90]). 25 Chapter 3 Transition System Models Central to our analysis of reactive systems is their abstraction into mathematical models. The critical decision in this process is the choice of a suitable mathematical structure to serve as the modeling medium.
Reference: [MP91] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1991 </year>
Reference-contexts: Proofs of the lemmas presented in the dissertation can be found in the Appendix. 18 Chapter 2 Related Work There is a wide range in capability and accuracy of various modeling techniques as well as in the complexity of verifying properties of the models (see [M89], <ref> [MP91] </ref>, [O91], [B92], and [GL92]). The particular technique we use is model checking. 2.1 Model Checking Model checking refers to a family of techniques that are used to check that a mathematical structure satisfies a sentence in a suitable logic. <p> In fact, the modal mu-calculus has been called the assembly language of temporal logics. Efficient model checking algorithms have been developed for this logic (see [EL86],[B92]). Many different formalisms have been developed for the modeling of concurrent programs (see [M89], <ref> [MP91] </ref>, [O91]). The most commonly occurring formalism in model checking schemes is the finite state transition system (see 20 [A94]). There is a large number of variations on this basic scheme, e.g., petri nets, i/o automata, hybrid automata, timed transition systems, state charts, and mode charts (see [ACD90], [ACHH92], [PTY93]).
Reference: [M93] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic, </publisher> <year> 1993 </year>
Reference-contexts: Symbolic methods reduce the size of models by describing them more efficiently. Instead of using a structure that explicitly lists each state and transition of a model, a symbolic encoding, such as binary decision diagrams is employed 22 (see [BCMDH90], [CGL92], <ref> [M93] </ref>). 2.1.3 Extensions While much research has addressed model size reductions and other practical improvements to the basic approach, other research has focused on extensions that enable a wider range of properties to be checked: Fair Systems support the verification of properties under a set of fairness assumptions.
Reference: [MR91] <author> S. P. Masticola and B. G. Ryder. </author> <title> A model for Ada programs for static deadlock detection in polynomial time. </title> <booktitle> Proceedings of ACM Sigplan Programming Languages Design and Implementation, ACM Sigplan Notices, </booktitle> <volume> 26(12) </volume> <pages> 97-107, </pages> <year> 1991. </year>
Reference-contexts: Another technique is reachability analysis, which restricts queries to specific properties (such as deadlock). In this approach, the analysis algorithm takes 24 a finite-state abstraction of the program, and then checks the states to deter-mine whether they conform to the property at hand (e.g., see [T83], [LC89], <ref> [MR91] </ref>, [GL92]). Some of these methods are pessimistic; for example, they may report deadlock when none exists. On the other hand, they present tractable alternatives to the methods based on proof systems. A compositional application of these techniques can be found in algebraic reachability analysis ([YY91]).
Reference: [NV90] <author> R. De Nicola and F. </author> <title> Vaandrager Three logics for branching bisimula-tion. </title> <booktitle> Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> 118-129, </pages> <year> 1990. </year>
Reference-contexts: An alternative to encoding fairness in the formulae that are checked is to apply the fairness constraints operationally during the check. It has been shown that this approach can be used to extend CTL model checkers without introducing significantly higher verification costs (see [EL87], [BCG88], <ref> [NV90] </ref>). Real-Time Systems support the verification of properties whose satisfaction is dependent upon durations measured by a clock. Many of the familiar propositional temporal logics have been extended to support timed specifications.
Reference: [O91] <author> J. S. Ostroff. </author> <title> Survey of formal methods for the specification and design of real-time systems. Draft for IEEE Press book "Tutorial on Specification of Time", </title> <year> 1992. </year>
Reference-contexts: Proofs of the lemmas presented in the dissertation can be found in the Appendix. 18 Chapter 2 Related Work There is a wide range in capability and accuracy of various modeling techniques as well as in the complexity of verifying properties of the models (see [M89], [MP91], <ref> [O91] </ref>, [B92], and [GL92]). The particular technique we use is model checking. 2.1 Model Checking Model checking refers to a family of techniques that are used to check that a mathematical structure satisfies a sentence in a suitable logic. <p> In fact, the modal mu-calculus has been called the assembly language of temporal logics. Efficient model checking algorithms have been developed for this logic (see [EL86],[B92]). Many different formalisms have been developed for the modeling of concurrent programs (see [M89], [MP91], <ref> [O91] </ref>). The most commonly occurring formalism in model checking schemes is the finite state transition system (see 20 [A94]). There is a large number of variations on this basic scheme, e.g., petri nets, i/o automata, hybrid automata, timed transition systems, state charts, and mode charts (see [ACD90], [ACHH92], [PTY93]). <p> Many of the familiar propositional temporal logics have been extended to support timed specifications. The principal design choices in these extensions are whether an implicit or an explicit clock is assumed and whether time advances in discrete steps or continuously (see <ref> [O91] </ref>). The extension of untimed model checkers to support a discrete clock is fairly straight-forward (see [AH90]). But the addition of time, regardless of whether a discrete or a dense time model is used, makes model checking a significantly more complex problem (see [ACD90], [AH90], [HNSY92], [BES93], [H93]).
Reference: [P93] <author> D. Peled. </author> <title> All from one, one for all: on model checking using representatives. </title> <journal> CAV93, </journal> <volume> LNCS 697. </volume> <year> 1993. </year>
Reference-contexts: In such cases, if the formula being checked is satisfied by a composition containing one instance of the equivalent behaviors then it would be satisfied by a composition containing any of them (see <ref> [P93] </ref>, [P94]). Symbolic methods reduce the size of models by describing them more efficiently.
Reference: [P94] <author> D. Peled. </author> <title> Combining partial order reductions with on-the-fly model-checking. </title> <journal> CAV94, </journal> <volume> LNCS 818. </volume> <year> 1994. </year> <month> 202 </month>
Reference-contexts: In such cases, if the formula being checked is satisfied by a composition containing one instance of the equivalent behaviors then it would be satisfied by a composition containing any of them (see [P93], <ref> [P94] </ref>). Symbolic methods reduce the size of models by describing them more efficiently.
Reference: [PT87] <author> R. Paige and R. E. Tarjan. </author> <title> Three partition refinement algorithms. </title> <journal> SIAM J. Comput., </journal> <volume> 6 </volume> <pages> 973-989, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: Although it is not in itself a verification technique, model minimization is an important area of research with applicability to both model checking and reachability analysis. Methods have been developed for minimizing an already existing transition system structure (see <ref> [PT87] </ref>) as well as generating a minimal structure on-the-fly (see [BFHR92]). The key idea with minimization is that the reduced model is in some formal sense equivalent to the original with respect a specific set of properties.
Reference: [PTY93] <author> M. Pezze, R. N. Taylor, and M. Young. </author> <title> Graph models for reachability analysis of concurrent programs. </title> <year> 1993. </year>
Reference-contexts: The most commonly occurring formalism in model checking schemes is the finite state transition system (see 20 [A94]). There is a large number of variations on this basic scheme, e.g., petri nets, i/o automata, hybrid automata, timed transition systems, state charts, and mode charts (see [ACD90], [ACHH92], <ref> [PTY93] </ref>). One of the basic modeling choices in all of these variations is whether concurrent execution should be represented by a synchronous or an asynchronous structure.
Reference: [RL86] <author> J.H. Reif and H.R. Lewis. </author> <title> Efficient symbolic analysis of programs. </title> <journal> J. Computer and System Sciences, </journal> <volume> 32 </volume> <pages> 280-314, </pages> <year> 1986. </year>
Reference: [S89] <author> C. Stirling. </author> <title> An introduction to modal and temporal logics for CCS. </title> <booktitle> Proceedings joint UK/Japan Workshop on Concurrency, LNCS 491, </booktitle> <year> 1989. </year>
Reference-contexts: The particular technique we use is model checking. 2.1 Model Checking Model checking refers to a family of techniques that are used to check that a mathematical structure satisfies a sentence in a suitable logic. Various structures and logics have been proposed for this use (see [EL84], [CS85], <ref> [S89] </ref>, [E90], [EES90], [G90]). 2.1.1 Logics and Models Most model checkers employ a propositional temporal logic; the one we use is called CTL. The temporal logics can be divided into two categories: linear time and branching time.
Reference: [S93] <author> B. Steffen. </author> <title> Generating data flow analysis algorithms from modal specifications. </title> <booktitle> Science of Computer Programming 21 </booktitle> <pages> 115-139. </pages> <year> 1993. </year>
Reference-contexts: Related techniques, for example data flow analysis, have also been used in the analysis of concurrent programs (see [LC91], <ref> [S93] </ref>). 2.2 Related Verification Techniques Model checking provides a mechanism for verifying fairly general properties of systems that can be represented by finite models. Of course, not every system or property that we might want to explore will be analyzable via model checking.
Reference: [SW89] <author> C. Stirling and D. Walker. </author> <title> CCS, liveness, and local model checking in the linear time mu-calculus. Automatic Verificiation Methods for Finite State Systems, </title> <publisher> LNCS 407, </publisher> <year> 1989. </year>
Reference-contexts: Our model checking algorithms are descendents of this family of decision procedures, but other automated techniques have been developed for the same logics, e.g., tableau based decision procedures (see <ref> [SW89] </ref>, [C90]). Temporal logic enables us to reason about temporal sequences of states, by allowing formulae of the logic to have different truth values at different times. Modal logics are a generalization of this idea to sequences which are not necessarily temporal in nature.
Reference: [T83] <author> R. N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent programs. </title> <journal> Communications of the ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Another technique is reachability analysis, which restricts queries to specific properties (such as deadlock). In this approach, the analysis algorithm takes 24 a finite-state abstraction of the program, and then checks the states to deter-mine whether they conform to the property at hand (e.g., see <ref> [T83] </ref>, [LC89], [MR91], [GL92]). Some of these methods are pessimistic; for example, they may report deadlock when none exists. On the other hand, they present tractable alternatives to the methods based on proof systems. A compositional application of these techniques can be found in algebraic reachability analysis ([YY91]).
Reference: [YY91] <author> M. Young and W. J. Yeh. </author> <title> Compositional reachability analysis of Ada programs using process algebra. </title> <booktitle> Proceedings of Symposium on Software Testing, Analysis and Verification, </booktitle> <pages> 45-59, </pages> <year> 1991. </year> <month> 203 </month>
References-found: 76

