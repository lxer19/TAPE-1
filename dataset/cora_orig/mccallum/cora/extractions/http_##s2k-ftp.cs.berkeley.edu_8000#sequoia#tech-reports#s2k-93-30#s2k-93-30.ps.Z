URL: http://s2k-ftp.cs.berkeley.edu:8000/sequoia/tech-reports/s2k-93-30/s2k-93-30.ps.Z
Refering-URL: http://s2k-ftp.cs.berkeley.edu:8000/sequoia/tech-reports/s2k-93-30/
Root-URL: http://www.cs.berkeley.edu
Title: Large Object Support in POSTGRES  
Author: Michael Stonebraker Michael Olson 
Address: Berkeley  
Affiliation: Department of Electrical Engineering and Computer Science University of California at  
Abstract: This paper presents four implementations for support of large objects in POSTGRES. The four implementations offer varying levels of support for security, transactions, compression, and time travel. All are implemented using the POSTGRES abstract data type paradigm, support user-defined operators and functions, and allow file-oriented access to large objects in the database. The support for user-defined storage managers available in POSTGRES is also detailed. The performance of all four large object implementations on two different storage devices is presented. 
Abstract-found: 1
Intro-found: 1
Reference: [BATO86] <author> Batory, D., </author> <title> ``GENESIS: A Project to Develop an Extendible Database Management System,'' </title> <booktitle> Proc. 1986 International Workshop on Object-oriented Database Systems, Asilomar, </booktitle> <address> Ca., </address> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: Some research systems, such as Exodus [CARE86], support versioning of large objects, but previous proposals have been not supported other essential features, such as user defined functions, operators, and compression. Finally, there has been considerable discussion about extendability in relational database management systems <ref> [BATO86, HAAS90, STON90] </ref>. Proposals have addressed the inclusion of new types, new access methods, new optimizer strategies, and rule systems. In this paper, we present the implementation of large objects in POSTGRES, and describe the services provided by the database system for managing large object data.
Reference: [BILI92] <author> Biliris, A., </author> <title> ``The Performance of Three Database Storage Structures for Managing Large Objects,'' </title> <booktitle> Proc. 1992 ACM SIGMOD Conference, </booktitle> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: 1. Introduction There have been numerous implementations supporting large objects in database systems <ref> [BILI92] </ref>. Typically, these implementations concentrate on low-level issues such as space management and layout of objects on storage media. Support for higher-level services is less uniform among existing systems.
Reference: [CARE86] <author> Carey, M. et al., </author> <title> ``Object and File Management in the Exodus Extensible Database System,'' </title> <booktitle> Proc. 1986 VLDB Conference, </booktitle> <address> Kyoto, Japan, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: The Star-burst long field manager [LEHM89] supports file-oriented access using a functional interface. [HASK82] proposes extending the SQL cursor mechanism to support cursor operations on large object data. Other important services include versioning and compression. Some research systems, such as Exodus <ref> [CARE86] </ref>, support versioning of large objects, but previous proposals have been not supported other essential features, such as user defined functions, operators, and compression. Finally, there has been considerable discussion about extendability in relational database management systems [BATO86, HAAS90, STON90]. <p> WiSS decomposes large objects into pages, which are the fundamental unit of persistence. The WiSS client controls physical layout of object pages, making it easy to implement clustering strategies appropriate to particular large object applications. Indices on logical page locations make object traversal fast. The EXODUS storage manager <ref> [CARE86] </ref> provides a set of low-level abstractions for managing large data objects. It supports efficient versioning of these objects. Users can extend the system to support new object types and operations on them. <p> We are investigating this problem now, and expect to have much better performance soon. 10. Conclusions In this section we summarize the novel features of our proposal. Others have suggested large object managers, e.g. <ref> [CARE86, LEHM89] </ref>. Our contribution is to propose a range of alternatives with various performance and functionality characteristics. Moreover, two of our proposals support user defined compression, which previous proposals have not considered.
Reference: [DEUX90] <editor> Deux, O. et al., </editor> <title> ``The Story of O2,'' </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: Orion [KIM89] is an object-oriented system that supports efficient versioning of objects. A special buffering strategy for large object data allows Orion to instantiate only pages of interest, so entire objects need not be present in physical memory. #-roman "O"- sub 2# <ref> [DEUX90] </ref> uses WiSS to manage object data, and so provides page-oriented access to large object data. Both Orion and #-roman "O"- sub 2# provide good support for abstraction and encapsulation over large object data. Users may define methods and accessors on large objects and invoke them from within their programs.
Reference: [HAAS90] <author> Haas, L. et al., </author> <title> ``Starburst Midflight: As the Dust Clears,'' </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: Some research systems, such as Exodus [CARE86], support versioning of large objects, but previous proposals have been not supported other essential features, such as user defined functions, operators, and compression. Finally, there has been considerable discussion about extendability in relational database management systems <ref> [BATO86, HAAS90, STON90] </ref>. Proposals have addressed the inclusion of new types, new access methods, new optimizer strategies, and rule systems. In this paper, we present the implementation of large objects in POSTGRES, and describe the services provided by the database system for managing large object data. <p> Storage managers POSTGRES allows large object data to be stored on any of several different storage devices by supporting user-defined storage managers. This construct is supported in Starburst through the use of extensions <ref> [HAAS90] </ref>. Our approach is similar, but defines a specific abstraction that a storage manager must follow. Our abstraction is modelled after the UNIX file system switch, and any user can define a new storage manager by writing and registering a small set of interface routines.
Reference: [HASK82] <author> Haskins, R. and Lorie, R., </author> <title> ``On Extending the Function of a Relational Database System,'' </title> <booktitle> Proc. 1982 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Orlando, Fl., </address> <month> June </month> <year> 1982. </year>
Reference-contexts: Such query language and typing support would make BLOBs much more useful. An important issue in managing large objects is the interface provided to users for accessing them. The Star-burst long field manager [LEHM89] supports file-oriented access using a functional interface. <ref> [HASK82] </ref> proposes extending the SQL cursor mechanism to support cursor operations on large object data. Other important services include versioning and compression. <p> In Section 6 of this paper, we suggest a collection of proposals with increasing functionality that address these disadvantages. First, however, Sections 4 and 5 discusses the user interface that all our proposals share. 4. Interface to large objects Others (e.g. <ref> [HASK82] </ref>) have suggested that the cursor mechanism used in SQL be extended to support large objects. We believe that a better model for large object support is a file-oriented interface.
Reference: [KIM89] <author> Kim, W., et al., </author> <title> ``Features of the ORION Object-Oriented Database System,'' Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. Lochovsky, eds., </editor> <publisher> Addison-Wesley/ACM Press, </publisher> <month> May </month> <year> 1989, </year> <pages> pp. 251-282. </pages>
Reference-contexts: Users can extend the storage manager with new storage strategies, and can define new large data types. Large objects can be accessed via an ad hoc query language using a functional interface. Orion <ref> [KIM89] </ref> is an object-oriented system that supports efficient versioning of objects.
Reference: [LEHM89] <author> Lehman, T., and Lindsay, B., </author> <title> ``The Starburst Long Field Manager,'' </title> <booktitle> Proc. 1989 VLDB Conference, </booktitle> <address> Amster-dam, Netherlands, </address> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: Such query language and typing support would make BLOBs much more useful. An important issue in managing large objects is the interface provided to users for accessing them. The Star-burst long field manager <ref> [LEHM89] </ref> supports file-oriented access using a functional interface. [HASK82] proposes extending the SQL cursor mechanism to support cursor operations on large object data. Other important services include versioning and compression. <p> It supports efficient versioning of these objects. Users can extend the system to support new object types and operations on them. EXODUS is the storage management component of a DBMS toolkit, and does not provide (for example) query-language access to the data that it stores. Storage management in Starburst <ref> [LEHM89] </ref> is more closely integrated with conventional relational database management. Starburst manages large objects as files, with strategies for laying out data efficiently and creating new versions of existing objects. Users can extend the storage manager with new storage strategies, and can define new large data types. <p> We are investigating this problem now, and expect to have much better performance soon. 10. Conclusions In this section we summarize the novel features of our proposal. Others have suggested large object managers, e.g. <ref> [CARE86, LEHM89] </ref>. Our contribution is to propose a range of alternatives with various performance and functionality characteristics. Moreover, two of our proposals support user defined compression, which previous proposals have not considered.
Reference: [MOSH92] <editor> Mosher, C. (ed), </editor> <title> ``The POSTGRES Reference Manual, </title> <type> Version 4,'' </type> <institution> Electronics Research Laboratory, University of California, Berkeley, Ca., Report M92/14, </institution> <month> March </month> <year> 1992. </year>
Reference: [MULL91] <author> Muller, K. and Pasquale, J., </author> <title> ``A High-performance Multi-structured File System Design,'' </title> <booktitle> Proceedings of the 1991 ACM Symposium on Operating System Principles, Asilomar, </booktitle> <address> CA, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Large abstract data types We expect there to be several implementations of large ADTs offering a variety of services at varying performance. This same point about multiple instantiations of an interface is made in a file system context in <ref> [MULL91] </ref>. In the next four subsections, we discuss four different implementations, namely user file (u-file), POSTGRES file (p-file), records of fixed-length chunks of user data (f-chunk), and variable-length segments of user data (v-segment). 6.1. User file as an ADT The simplest way to support large ADTs is with user files.
Reference: [OLSO91] <author> Olson, M., </author> <title> ``Extending the POSTGRES Database System to Manage Tertiary Storage,'' M.Sc. </title> <type> thesis, </type> <institution> University of California, Berkeley, </institution> <address> CA, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: A single POSTGRES storage manager can manage all of the magnetic disks available to the system, but a different storage manager was written to manage an optical disk jukebox. A complete description of the device extensibility in POSTGRES appears in <ref> [OLSO91] </ref>. Version 4 of POSTGRES contains three storage managers. The first supports storage of classes on local magnetic disk, and is a thin veneer on top of the UNIX file system. The second allows relational data to be stored in nonvolatile random-access memory.
Reference: [OSBO86] <author> Osborne, S. and Heaven, T., </author> <title> ``The Design of a Relational System with Abstract Data Types as Domains,'' </title> <journal> ACM TODS, </journal> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: Indexing BLOBs can also be supported. Clearly, Abstract Data Types (ADTs) offer many advantages over BLOBs. Previous work in this areas is reported in <ref> [OSBO86, STON86, STON87] </ref>. These proposals support the definition of new types, along with appropriate operators and functions for them. It is straightforward to apply this construct to large objects, and several different storage representations can be quickly identified.
Reference: [SELT92] <author> Seltzer, M. and Olson, M., ``LIBTP: </author> <title> Portable, Modular Transactions for Unix,'' </title> <booktitle> Proc. 1992 Winter Usenix, </booktitle> <address> San Francisco, CA, </address> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: As our measurements demonstrate, the Inversion approach is within 1/3 of the performance of the native file system. This is especially attractive because time-travel, transactions and compression are automatically available. Another study determined that transaction support alone costs about 15% <ref> [SELT92] </ref>. Lastly, we suggested a clean table-driven interface to user-defined storage managers. This allows the convenient definition of new storage managers, a capability also present in Starburst. However, our proposal has the advantage that any new storage manager automatically supports Inversion files.
Reference: [STON80] <author> Stonebraker, M., </author> <title> ``Operating System Support for Database Management,'' </title> <journal> CACM, </journal> <month> April </month> <year> 1980. </year>
Reference: [STON84] <author> Stonebraker, M. and Rowe, L., </author> <title> ``Database Portals: A New Application Program Interface,'' </title> <booktitle> Proc. 1984 VLDB Conference, </booktitle> <address> Singapore, </address> <month> Sept. </month> <year> 1984. </year>
Reference: [STON85] <author> Stonebraker, M., et al., </author> <title> ``Problems in Supporting Data Base Transactions in an Operating System Transaction Manager,'' Operating System Review, </title> <month> January, </month> <year> 1985. </year>
Reference: [STON86] <author> Stonebraker, M., </author> <title> ``Inclusion of New Types in Relational Data Base Systems,'' </title> <booktitle> Proc. 1986 IEEE Data Engineering Conference, </booktitle> <address> Los Angeles, Ca., </address> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: Indexing BLOBs can also be supported. Clearly, Abstract Data Types (ADTs) offer many advantages over BLOBs. Previous work in this areas is reported in <ref> [OSBO86, STON86, STON87] </ref>. These proposals support the definition of new types, along with appropriate operators and functions for them. It is straightforward to apply this construct to large objects, and several different storage representations can be quickly identified. <p> These proposals support the definition of new types, along with appropriate operators and functions for them. It is straightforward to apply this construct to large objects, and several different storage representations can be quickly identified. However, there are three major problems with the specific ADT proposal suggested in <ref> [STON86, STON87] </ref> when it is applied to large objects. First, when small types are passed as arguments to a function, they reside completely in memory. For large objects, which may be gigabytes in size, this is clearly impractical. <p> For large objects, which may be gigabytes in size, this is clearly impractical. Functions using large objects must be able to locate them, and to request small chunks for individual operations. Second, the specification of ADTs in <ref> [STON86, STON87] </ref> allows conversion functions to be invoked when ADT values move between the database system and the client. These conversion functions transform data from an external to an internal format. Conversion routines allow the ADT mechanism to support compression. <p> The second problem arises in a client-server environment. The database server must support access from geographically remote clients over long-haul networks. Using the ADT proposal of <ref> [STON86, STON87] </ref>, data conversion routines will execute on the server, converting the data before it is sent to the client. If these routines are performing large object compression, this is the wrong place to do the conversion.
Reference: [STON87] <author> Stonebraker, M. et al., </author> <title> ``Extensibility in POSTGRES,'' </title> <journal> IEEE Database Engineering, </journal> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: Indexing BLOBs can also be supported. Clearly, Abstract Data Types (ADTs) offer many advantages over BLOBs. Previous work in this areas is reported in <ref> [OSBO86, STON86, STON87] </ref>. These proposals support the definition of new types, along with appropriate operators and functions for them. It is straightforward to apply this construct to large objects, and several different storage representations can be quickly identified. <p> These proposals support the definition of new types, along with appropriate operators and functions for them. It is straightforward to apply this construct to large objects, and several different storage representations can be quickly identified. However, there are three major problems with the specific ADT proposal suggested in <ref> [STON86, STON87] </ref> when it is applied to large objects. First, when small types are passed as arguments to a function, they reside completely in memory. For large objects, which may be gigabytes in size, this is clearly impractical. <p> For large objects, which may be gigabytes in size, this is clearly impractical. Functions using large objects must be able to locate them, and to request small chunks for individual operations. Second, the specification of ADTs in <ref> [STON86, STON87] </ref> allows conversion functions to be invoked when ADT values move between the database system and the client. These conversion functions transform data from an external to an internal format. Conversion routines allow the ADT mechanism to support compression. <p> The second problem arises in a client-server environment. The database server must support access from geographically remote clients over long-haul networks. Using the ADT proposal of <ref> [STON86, STON87] </ref>, data conversion routines will execute on the server, converting the data before it is sent to the client. If these routines are performing large object compression, this is the wrong place to do the conversion.
Reference: [STON87B] <author> Stonebraker, M., </author> <title> ``The POSTGRES Storage System,'' </title> <booktitle> Proc. 1987 VLDB Conference, </booktitle> <address> Brighton, England, </address> <month> Sept. </month> <year> 1987. </year>
Reference: [STON90] <author> Stonebraker, M. et al., </author> <title> ``The Implementation of POSTGRES,'' </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: Some research systems, such as Exodus [CARE86], support versioning of large objects, but previous proposals have been not supported other essential features, such as user defined functions, operators, and compression. Finally, there has been considerable discussion about extendability in relational database management systems <ref> [BATO86, HAAS90, STON90] </ref>. Proposals have addressed the inclusion of new types, new access methods, new optimizer strategies, and rule systems. In this paper, we present the implementation of large objects in POSTGRES, and describe the services provided by the database system for managing large object data.
Reference: [TRAI82] <author> Traiger, I., </author> <title> ``Virtual Memory Management for Data Base Systems,'' </title> <journal> Operating Systems Review, </journal> <volume> Vol 16, No 4, </volume> <month> October </month> <year> 1982. </year>
References-found: 21

