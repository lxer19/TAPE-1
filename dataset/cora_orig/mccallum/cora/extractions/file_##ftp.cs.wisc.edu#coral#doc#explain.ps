URL: file://ftp.cs.wisc.edu/coral/doc/explain.ps
Refering-URL: http://www.cs.wisc.edu/coral/coral.papers.html
Root-URL: 
Title: Explaining Program Execution in Deductive Systems  
Author: Tarun Arora Raghu Ramakrishnan William G. Roth Praveen Seshadri Divesh Srivastava 
Address: 1210 West Dayton Street, Madison, WI 53706, USA.  
Affiliation: Computer Sciences Department, University of Wisconsin-Madison,  
Abstract: Programs in deductive database and programming systems have a natural meaning that is based upon their mathematical reading as logical rules. High-level `explanations' of a program evaluation/execution can be constructed to provide added functionality: (1) To debug a program by following a chain of deductions leading to an unexpected (and possibly incorrect) conclusion; (2) To follow the derivation of certain correct conclusions to determine why and how they are reached; (3) To identify consequences of a (typically, incorrect or unexpected) fact. This functionality can be utilized either to perform post-mortem analysis of a session, or to interactively develop programs by running queries and viewing their deductions simultaneously. `Explanations' of programs are especially important in the context of deductive databases for three reasons: (1) These programs could involve recursion, and hence, the chain of inferences is often not evident. (2) When the input data set is large, it is very difficult for a user to inspect the data and determine which facts lead to which answers, and exactly how. (3) Such programs do not guarantee a fixed evaluation strategy, and this makes it difficult for a user to comprehend unexpected behavior of a program. With this motivation, we have designed and implemented an explanation facility for the CORAL deductive database system. The design is based on the representation of a program evaluation as a set of derivation trees, and the facility provides a high-level explanation of the inferences carried out during program execution. A notable feature of the implementation is the boot-strapped use of CORAL in the implementation of the explanation tool. We believe that an explanation system can provide a novel approach to interactively querying data, and is useful even for standard relational databases. 
Abstract-found: 1
Intro-found: 1
Reference: [BR87] <author> Catriel Beeri and Raghu Ramakrishnan. </author> <title> On the power of Magic. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: However, CORAL supports complex terms and functor symbols, and it also allows the use of variables inside facts. CORAL also uses various optimization strategies that include the rewriting of the original rules using transformations like magic rewriting <ref> [BR87, Ram88] </ref>. We discuss some of these issues in this section. 6.1 Program Transformations We note that since Explain records and displays actual derivations, these derivations are in terms of rules of the rewritten program, if the original program is optimized by applying some program transformation. <p> Clearly, a derivation tree in terms of the user's original program is likely to be more understandable, and it is important to try to present explanations in the context of the original program. An important transformation which is usually applied by default is the Magic Sets transformation <ref> [BR87, Ram88] </ref>. This transformation is purely syntactic, and can be used on an arbitrary program. The objective is to constrain a forward-chaining fixpoint computation to generate only those facts that are relevant to answering a given user query. <p> Essentially, the generation of the goal ?q (5) corresponds to the generation of the fact magic q (5); this fact triggers all subsequent derivations in the solution of this goal. (For details, we refer the reader to <ref> [BR87, Ram88] </ref>.) In general, a weakness of Explain is that it does not provide direct support for understanding why some facts are `missing', i.e., why some facts that a user expects to be generated are not.
Reference: [DE88] <author> M. Ducasse and A. M. Emde. </author> <title> A review of automated debugging systems. </title> <booktitle> In Proceedings of the 10th International Conference on Software Engineering, </booktitle> <pages> pages 162-171, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: A large number of facts may have to be displayed in the browser, and scrolling through them to find a desired fact may be difficult. The display of facts, which was 4 The fixed execution strategy also itself to stack-based debuggers and tracing tools <ref> [Duc92, DE88, Sta] </ref>. intended to support cooperative querying, could in this case produce a most un-cooperative system! In the future, we expect to add a feature that will allow the user to filter out all `uninteresting' facts and only view the ones of interest.
Reference: [DMP93] <author> Marcia A. Derr, Shinichi Morishita, and Geoffrey Phipps. </author> <title> Design and implementation of the glue-nail database system. </title> <booktitle> In Proceedings of ACM SIG-MOD International Conference on Management of Data, </booktitle> <year> 1993. </year>
Reference-contexts: More concretely, Table 1 gives the numbers for the a bill-of-materials program, running on a parts hierarchy of about 15,000 tuples and 100 basic parts. The computation generated about 30,000 derivation tree `fragments'. The query and data set are from the Nail-Glue benchmark <ref> [DMP93] </ref>. Our conclusion is that a practical limit to the use of Explain is likely to stem from the user's ability to comprehend large sets of derivations, rather than the system's capacity.
Reference: [Duc92] <author> M. Ducasse. </author> <title> A general trace query mechanism based on prolog. </title> <booktitle> In Proceedings of the Fourth International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: There is also a connection between Explain and Prolog debuggers (see e.g., <ref> [Sha83, Sta, Duc92] </ref>), since both are used to debug logic programs, but there are many important differences. Deductive databases provide a model-based semantics, where the meaning of a program is a model of the world that satisfies the rules of the program. <p> A large number of facts may have to be displayed in the browser, and scrolling through them to find a desired fact may be difficult. The display of facts, which was 4 The fixed execution strategy also itself to stack-based debuggers and tracing tools <ref> [Duc92, DE88, Sta] </ref>. intended to support cooperative querying, could in this case produce a most un-cooperative system! In the future, we expect to add a feature that will allow the user to filter out all `uninteresting' facts and only view the ones of interest.
Reference: [Mot86] <author> Amihai Motro. Seave: </author> <title> A mechanism for verifying user presuppositions in query systems. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 4(4) </volume> <pages> 312-330, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: There has also been some interesting work with respect to the understanding of null answers to a query, and the identification of erroneous pre-suppositions contained in the query <ref> [Mot86, Mot90] </ref>. This is closely related to the issue of `missing facts', and our research does not address this aspect of query explanation. 3 This is described only briefly in [ST90], and the debugger is not available with the LDL system we have.
Reference: [Mot90] <author> Amihai Motro. </author> <title> Flex: A tolerant and cooperative user interface to databases. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(2) </volume> <pages> 231-246, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: There has also been some interesting work with respect to the understanding of null answers to a query, and the identification of erroneous pre-suppositions contained in the query <ref> [Mot86, Mot90] </ref>. This is closely related to the issue of `missing facts', and our research does not address this aspect of query explanation. 3 This is described only briefly in [ST90], and the debugger is not available with the LDL system we have.
Reference: [Ram88] <author> Raghu Ramakrishnan. </author> <title> Magic templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: However, CORAL supports complex terms and functor symbols, and it also allows the use of variables inside facts. CORAL also uses various optimization strategies that include the rewriting of the original rules using transformations like magic rewriting <ref> [BR87, Ram88] </ref>. We discuss some of these issues in this section. 6.1 Program Transformations We note that since Explain records and displays actual derivations, these derivations are in terms of rules of the rewritten program, if the original program is optimized by applying some program transformation. <p> Clearly, a derivation tree in terms of the user's original program is likely to be more understandable, and it is important to try to present explanations in the context of the original program. An important transformation which is usually applied by default is the Magic Sets transformation <ref> [BR87, Ram88] </ref>. This transformation is purely syntactic, and can be used on an arbitrary program. The objective is to constrain a forward-chaining fixpoint computation to generate only those facts that are relevant to answering a given user query. <p> Essentially, the generation of the goal ?q (5) corresponds to the generation of the fact magic q (5); this fact triggers all subsequent derivations in the solution of this goal. (For details, we refer the reader to <ref> [BR87, Ram88] </ref>.) In general, a weakness of Explain is that it does not provide direct support for understanding why some facts are `missing', i.e., why some facts that a user expects to be generated are not.
Reference: [RSS92] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Coral control, relations and logic. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <pages> pages 238-249, </pages> <year> 1992. </year>
Reference-contexts: CORAL is a deductive database system that has been developed at the University of Wisconsin at Madison. It encourages the construction of queries as modular programs expressed in the style of (possibly recursive) logic rules <ref> [RSS92] </ref>. The evaluation of such rules is performed primarily in a bottom-up fashion, though other evaluation strategies are also supported. The system provides support for advanced features like negation and aggregation in rule bodies, and the presence of variables inside database facts. <p> The CORAL database system is used in three distinct ways in the implementation of the Explain visualization component: embedded CORAL, consulted CORAL code, and imperative CORAL. These three components are all part of the CORAL language <ref> [RSS92] </ref>. Embedded CORAL is, as the name suggests, CORAL code that is embedded in C++ source. Any collection of CORAL commands can be embedded at any point within C++ code [RSSS93b].
Reference: [RSSS93a] <author> Raghu Ramakrishnan, Praveen Seshadri, Divesh Srivastava, and S. Sudarshan. </author> <title> The CORAL User Manual. </title> <institution> University of Wisconsin,Madison, </institution> <address> 1.0 edition, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Again, Explain allows us to examine the derivation of the b o m tuple of interest, and to answer this question. 3 An Overview of Explain 3.1 The Requirements We wanted to develop a graphical tool that is able to visualize the evaluation of a CORAL <ref> [RSSS93a] </ref> query. Such a tool could be used either for post-mortem analysis of query execution, or for co-ordinated program development and debugging. In either mode, it should support two operations: 1. Trace how a fact is generated, in order to pinpoint `interesting' premises, and 2.
Reference: [RSSS93b] <author> Raghu Ramakrishnan, Divesh Srivastava, S. Sudarshan, and Praveen Se-shadri. </author> <title> Implementation of the CORAL deductive database system. </title> <booktitle> In Proceedings of ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1993. </year>
Reference-contexts: In this paper, we describe Explain, a menu-driven graphical tool for visualizing fact derivations in a logic programming/deductive database language. It is designed to operate in conjunction with the CORAL deductive database system <ref> [RSSS93b] </ref>, and deals specifically with (extended) Horn-clause rules evaluated using bottom-up techniques. It differs significantly from debugging tools available for Prolog-style languages, which are designed for a top-down, backtracking evaluation strategy. <p> These three components are all part of the CORAL language [RSS92]. Embedded CORAL is, as the name suggests, CORAL code that is embedded in C++ source. Any collection of CORAL commands can be embedded at any point within C++ code <ref> [RSSS93b] </ref>. CORAL rule programs stored in separate files are also `consulted' from within the C++ code, and these rule programs can be executed from within the C++ code with the help of a library of interface routines designed to provide an `imperative' interface to CORAL.
Reference: [Sha83] <author> Ehud Y. Shapiro. </author> <title> Algorithmic Program Debugging. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: There is also a connection between Explain and Prolog debuggers (see e.g., <ref> [Sha83, Sta, Duc92] </ref>), since both are used to debug logic programs, but there are many important differences. Deductive databases provide a model-based semantics, where the meaning of a program is a model of the world that satisfies the rules of the program.
Reference: [ST90] <author> O. Shmueli and S. Tsur. </author> <title> Logical diagnosis of LDL programs. </title> <booktitle> In Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <year> 1990. </year>
Reference-contexts: This is an important direction for future work. Shmueli and Tsur <ref> [ST90] </ref> consider "why not" queries in a broader sense | "Why is a fact missing from the least model?", instead of "Why wasn't a fact generated (in the computation of a given query)?" | and suggest that the user's expectations must be captured in some `intended model', and an explanation tool <p> To our knowledge, no other system with all of Explain's capabilities has been implemented. In this section, a discussion of related research is presented, along with possible future extensions to this work. 9.1 Related Work In <ref> [ST90] </ref>, a debugging system for the LDL deductive database is presented. One of the operations supported by the LDL debugger is to take a generated fact which the user believes to be incorrect, and return an instantiated rule with this fact as the head. <p> An interesting aspect of <ref> [ST90] </ref> is that the issue of `missing facts', namely facts that the user expects to see generated, but that are not generated, is addressed. <p> This is closely related to the issue of `missing facts', and our research does not address this aspect of query explanation. 3 This is described only briefly in <ref> [ST90] </ref>, and the debugger is not available with the LDL system we have. There is also a connection between Explain and Prolog debuggers (see e.g., [Sha83, Sta, Duc92]), since both are used to debug logic programs, but there are many important differences.
Reference: [Sta] <author> F. Staes. </author> <title> The Interactive LOCO Debugger : User Manual. </title> <institution> University of Antwerp, </institution> <month> UIA. </month> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: There is also a connection between Explain and Prolog debuggers (see e.g., <ref> [Sha83, Sta, Duc92] </ref>), since both are used to debug logic programs, but there are many important differences. Deductive databases provide a model-based semantics, where the meaning of a program is a model of the world that satisfies the rules of the program. <p> A large number of facts may have to be displayed in the browser, and scrolling through them to find a desired fact may be difficult. The display of facts, which was 4 The fixed execution strategy also itself to stack-based debuggers and tracing tools <ref> [Duc92, DE88, Sta] </ref>. intended to support cooperative querying, could in this case produce a most un-cooperative system! In the future, we expect to add a feature that will allow the user to filter out all `uninteresting' facts and only view the ones of interest.
References-found: 13

