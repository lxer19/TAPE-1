URL: http://www.cs.indiana.edu/l/www/pub/sjohnson/IUtr-323r1.ps.Z
Refering-URL: http://www.cs.indiana.edu/l/www/pub/sjohnson/
Root-URL: http://www.cs.indiana.edu
Title: A System for Mechanized Digital Design Derivation  
Author: by Steven D. Johnson Bhaskar Bose 
Address: Bloomington, Indiana 47405-4101  
Affiliation: Computer Science Department Indiana University  
Date: December 1990 Revised March 1997  
Note: DDD:  
Abstract: Technical Report No. 323 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Harold Abelson, Gerald J. Sussman, and Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> McGraw-Hill, </publisher> <year> 1985. </year>
Reference-contexts: A complete language definition can be found in [27]. It's equally important symbolic processing capability is thoroughly developed in several text books, such as [7], [30] and <ref> [1] </ref>. In the last of these a number of hardware modeling techniques are presented. In the informal language summary that follows, upper case variables refer to expressions and lower case variables refer to values; the same letter associates the two: expression E has value e.
Reference: [2] <author> Bhaskar Bose. </author> <title> DDD a transformation system for digital design derivation. </title> <type> Technical Report 331, </type> <institution> Indiana University, Computer Science Department, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The DDD transformation system <ref> [2] </ref> was developed to help us explore and demonstrate a formalization of digital design based on functional algebra. DDD stands for digital design derivation; the system is used interactively to transform higher level behavioral specifications into hierarchical boolean systems, to which logic synthesis tools are then applied.
Reference: [3] <author> C.D. Boyer and Steven D. Johnson. </author> <title> Using the digital design derivation system: Case study of a VLSI garbage collector. In Darringer and Ram 34 ming, </title> <editor> editors, </editor> <booktitle> Ninth International Symposium on Computer Hardware Description Languages, Amsterdam, 1989. IFIP WG 10.2, </booktitle> <address> Elsevier. </address> <note> Also published as Technical Report 274, </note> <institution> Computer Science Dept., Indiana University, </institution> <month> April </month> <year> 1989. </year>
Reference-contexts: It operates on a dialect of functional modeling expressions, providing a uniform and visible representation of the design. Previous articles develop the theoretical underpinnings of the formalization [14, 13, 15, 16, 33, 34, 35]; and mention DDD in the context of large examples <ref> [17, 3, 18] </ref>. However, these papers give few details about the experience of using the system. Our goal in this paper is to give a more complete picture of the derivation process. With two small examples we examine the sequence of intermediate expressions produced as an implementation is derived. <p> It is distilled from Boyer's derivation of a garbage collector <ref> [17, 3] </ref>. The device moves information from a source memory, organized as an array of two-byte words, to a target memory, organized as an array of bytes. <p> We have experimented with strategies in which the designer provides architectural constraints in the form of a predicate, which accepts substitutions that meet architectural goals <ref> [3] </ref>. More recently, Zhu has developed an algebraic approach [33, 34, 35] having much in common a the treatment of Maa-davaht, et.al, which based on DT0L languages [21].
Reference: [4] <author> Robert S. Boyer and J. Struther Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: One goal of our research is to explore interactions between synthesis and verification at higher levels of design specification. DDD manipulates the same language of first-order Lisp expressions that is used in "Boyer-Moore logic" <ref> [4] </ref>. In [18], we applied DDD directly to Hunt's mechanically verified FM8501 microprocessor descriptions [12]. The exercise demonstrated the interplay of two forms of automated reasoning; and in particular, showed that derivation (i.e. synthesis in a formal system) could obviate a significant portion of the correctness proof.
Reference: [5] <author> Geoffrey M. Brown and Miriam E. Leeser. </author> <title> Synthesizing correct sequential circuits. </title> <editor> In John A. Darringer and Franz J. Rammig, editors, </editor> <booktitle> Computer Hardware Description Languages and their Applications, </booktitle> <pages> pages 169-182. </pages> <publisher> North-Holland, </publisher> <year> 1989. </year> <booktitle> Proceedings of the IFIP WG 10.2 Ninth International Symposium on Computer Hardware Description Languages and their Applications. </booktitle>
Reference-contexts: This interpretation corresponds quite closely to the state transition systems of Brown and Leeser <ref> [5] </ref>. As we shall see in Section 6, this form may be transformed in order to satisfy scheduling constraints. The initial DDD transformations decompose the specification into a system expression, depicting a controller operating against an architecture which is abstract in several respects.
Reference: [6] <author> Raul Camposano. </author> <title> Behavior-preserving transformations for high-level synthesis. </title> <editor> In M. Leeser and G. Brown, editors, </editor> <title> Hardware Specification, Verification and Synthesis: </title> <journal> Mathematical Aspects, </journal> <pages> pages 106-128, </pages> <address> New York, </address> <year> 1989. </year> <booktitle> Proceedings of Mathematical Sciences Institute Workshop, </booktitle> <publisher> Cornell University, Springer-Verlag. </publisher>
Reference: [7] <author> Daniel Friedman and Matthias Felleisen. </author> <title> The Little LISPer. </title> <publisher> MIT Press, </publisher> <address> third edition, </address> <year> 1988. </year>
Reference-contexts: A complete language definition can be found in [27]. It's equally important symbolic processing capability is thoroughly developed in several text books, such as <ref> [7] </ref>, [30] and [1]. In the last of these a number of hardware modeling techniques are presented. In the informal language summary that follows, upper case variables refer to expressions and lower case variables refer to values; the same letter associates the two: expression E has value e.
Reference: [8] <author> J.A. Goguen. </author> <title> OBJ as a theorem prover with applications to hardware verification. </title> <editor> In G. Birtwistle and P.A. Subrahmanyam, editors, </editor> <booktitle> Current Trends in Hardware Verification and Automated Theorem Proving, </booktitle> <pages> pages 218-267. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: To say 3 that a transformation is "equivalence preserving" means that it preserves a primary interpretation of an expression as a function. The primitive vocabulary of a description, its ground type or basis, is a many sorted algebra <ref> [8] </ref>. This is a system of primitive constants, operations and tests, which in DDD always includes a boolean domain, a polymorphic selection operation, finite product formation, and a generic don't-care value, designated by `?'.
Reference: [9] <author> Ganesh C. Gopalakrishnan, Fichard M. Fujimoto, Vankatesh Akella, and Narayana S. Mani. HOP: </author> <title> A process model for synchronous hardware; semantics and experiments in process composition. Integration, </title> <journal> the VLSI journal, </journal> <volume> 8 </volume> <pages> 209-247, </pages> <year> 1989. </year>
Reference-contexts: We regard Sheeran's work and ours to be compatible treatments of distinct intervals of the design spectrum. In terms of abstract syntax, two related languages for hardware modeling are SBL, due to Gopalakrishnan, Srivas, and Smith [10], and HOP, developed later by Gopalakrishnan <ref> [9] </ref>. DDD operates on a more primitive concrete syntax of s-expressions (See Section 4), but a more important difference is the treatment of data abstraction. Data are encapsulated in SBL, and hardware modularity is strongly correlated to that encapsulation.
Reference: [10] <author> Ganesh C. Gopalakrishnan, David R. Smith, and Mandayam K. Srivas. </author> <title> An applicative specification language for verifiable VLSI designs and controller synthesis. </title> <type> Technical Report 85/4, </type> <institution> Department of Computer Science, State University of New York at Stony Brook, </institution> <month> January </month> <year> 1985. </year> <month> 35 </month>
Reference-contexts: The DDD algebra is specialized for manipulating data paths under sequential control. We regard Sheeran's work and ours to be compatible treatments of distinct intervals of the design spectrum. In terms of abstract syntax, two related languages for hardware modeling are SBL, due to Gopalakrishnan, Srivas, and Smith <ref> [10] </ref>, and HOP, developed later by Gopalakrishnan [9]. DDD operates on a more primitive concrete syntax of s-expressions (See Section 4), but a more important difference is the treatment of data abstraction. Data are encapsulated in SBL, and hardware modularity is strongly correlated to that encapsulation.
Reference: [11] <author> P. Hilfinger. </author> <title> A high-level language and silicon compiler for digital signal processing. </title> <booktitle> In Proceedings of the IEEE CICC Conference, </booktitle> <pages> pages 213-216, </pages> <year> 1985. </year>
Reference-contexts: In Section 7, we discuss future refinements and reexamine our goals for DDD in light of the examples. 2 Related Research The use and manipulation of functional expressions is common in hardware applications. A number of hardware description languages (HDLs) are functional; Silage <ref> [11] </ref> and ELLA [23] are examples. The majority of structural HDLs are essentially functional. Functional calculus is also prominent in formal-methods research, where it vies for prominence with predicate, relational and process calculi.
Reference: [12] <author> Jr. Hunt, Warren A. FM8501: </author> <title> A Verified Microprocessor. </title> <type> PhD thesis, </type> <institution> The University of Texas at Austin, </institution> <year> 1985. </year> <note> Also published as Technical Report 47 (December, </note> <year> 1985). </year>
Reference-contexts: One goal of our research is to explore interactions between synthesis and verification at higher levels of design specification. DDD manipulates the same language of first-order Lisp expressions that is used in "Boyer-Moore logic" [4]. In [18], we applied DDD directly to Hunt's mechanically verified FM8501 microprocessor descriptions <ref> [12] </ref>. The exercise demonstrated the interplay of two forms of automated reasoning; and in particular, showed that derivation (i.e. synthesis in a formal system) could obviate a significant portion of the correctness proof. Conversely, a synthesis system can maintain correctness only when given correct information to work with. <p> The example is contrived to show how applicative formulations of complex objects are manipulated during derivation. Since memories are values of the ground type, the LOOP body can be can be written as a single expression. Hunt specified a microprocessor programmer's model in much the same fashion <ref> [12] </ref>.
Reference: [13] <author> Steven D. Johnson. </author> <title> Applicative programming and digital design. </title> <booktitle> In Proc. Eleventh Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming (POPL'84), </booktitle> <pages> pages 218-227, </pages> <year> 1984. </year>
Reference-contexts: It operates on a dialect of functional modeling expressions, providing a uniform and visible representation of the design. Previous articles develop the theoretical underpinnings of the formalization <ref> [14, 13, 15, 16, 33, 34, 35] </ref>; and mention DDD in the context of large examples [17, 3, 18]. However, these papers give few details about the experience of using the system. Our goal in this paper is to give a more complete picture of the derivation process. <p> Since DDD places no special significance on operation symbols, limited used of imperative modeling techniques can coexist effectively with the derivation process. 5.1 Behavior to Structure An initial system expression is derived automatically. Figure 3 shows the resulting system-expression. Details of the construction are given in <ref> [13, 14, 15] </ref>.
Reference: [14] <author> Steven D. Johnson. </author> <title> Synthesis of Digital Designs from Recursion Equations. </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1984. </year> <note> ACM Distinguished Dissertation 1984. </note>
Reference-contexts: It operates on a dialect of functional modeling expressions, providing a uniform and visible representation of the design. Previous articles develop the theoretical underpinnings of the formalization <ref> [14, 13, 15, 16, 33, 34, 35] </ref>; and mention DDD in the context of large examples [17, 3, 18]. However, these papers give few details about the experience of using the system. Our goal in this paper is to give a more complete picture of the derivation process. <p> Since DDD places no special significance on operation symbols, limited used of imperative modeling techniques can coexist effectively with the derivation process. 5.1 Behavior to Structure An initial system expression is derived automatically. Figure 3 shows the resulting system-expression. Details of the construction are given in <ref> [13, 14, 15] </ref>.
Reference: [15] <author> Steven D. Johnson. </author> <title> Digital design in a functional calculus. </title> <editor> In Milne and Subramanyam, editors, </editor> <booktitle> Formal Aspects of VLSI Design, </booktitle> <pages> pages 153-178. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1986. </year> <booktitle> Proceedings of the 1985 Edinburgh Workshop on VLSI. </booktitle>
Reference-contexts: It operates on a dialect of functional modeling expressions, providing a uniform and visible representation of the design. Previous articles develop the theoretical underpinnings of the formalization <ref> [14, 13, 15, 16, 33, 34, 35] </ref>; and mention DDD in the context of large examples [17, 3, 18]. However, these papers give few details about the experience of using the system. Our goal in this paper is to give a more complete picture of the derivation process. <p> Since DDD places no special significance on operation symbols, limited used of imperative modeling techniques can coexist effectively with the derivation process. 5.1 Behavior to Structure An initial system expression is derived automatically. Figure 3 shows the resulting system-expression. Details of the construction are given in <ref> [13, 14, 15] </ref>.
Reference: [16] <author> Steven D. Johnson. </author> <title> Manipulating logical organization with system factorizations. </title> <editor> In Leeser and Brown, editors, </editor> <title> Hardware Specification, Verification and Synthesis: </title> <booktitle> Mathematical Aspects, volume 408 of LNCS, </booktitle> <pages> pages 260-281. </pages> <publisher> Springer, </publisher> <month> July </month> <year> 1989. </year> <booktitle> Proceedings of Mathematical Sciences Institute Workshop, </booktitle> <institution> Cornell University, </institution> <year> 1989. </year>
Reference-contexts: It operates on a dialect of functional modeling expressions, providing a uniform and visible representation of the design. Previous articles develop the theoretical underpinnings of the formalization <ref> [14, 13, 15, 16, 33, 34, 35] </ref>; and mention DDD in the context of large examples [17, 3, 18]. However, these papers give few details about the experience of using the system. Our goal in this paper is to give a more complete picture of the derivation process. <p> Recursive letrec and system expressions are manipulated in the manner of other simultaneous systems of equations. In addition to fold/unfold trans formations, these systems may be rearranged and reorganized hierarchically. A family of basic laws is presented in <ref> [16] </ref>. 6 4 Sketch of the Derivation Process The object is to find a derivation, or sequence of DDD transformations, resulting in an implementation that satisfies the intended design constraints. There may be many possible derivation paths, of course, but in practice the process has distinct phases. <p> The primary tool for this task is system factorization, which is used to impose logical organization <ref> [16] </ref>. DDD factorization encapsulates a subsystem in a combinator and, as a byproduct, generates the combinator definition. In the simplest cases, enclosure is simply the identification of a signal or abstraction of a group of terms. <p> These examples show that DDD factorization is more general than the combinational abstraction done in the Black-Jack machine. They can incorporate state and introduce control. Factorizations are specified by giving a collection of subject terms to be incorporated <ref> [16] </ref>. There are several ways to abbreviate the subject terms. For example, there is a version of factorization which isolates all occurrences of a particular set of operators (e.g. inc and dcr) or all occurrences to a particular group of signals (e.g. M1).
Reference: [17] <author> Steven D. Johnson, B. Bose, </author> <title> and C.D. Boyer. A tactical framework for digital design. </title> <editor> In Birtwistle and Subramanyam, editors, </editor> <booktitle> VLSI Specification, Verification and Synthesis, </booktitle> <pages> pages 349-383. </pages> <publisher> Kluwer, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: It operates on a dialect of functional modeling expressions, providing a uniform and visible representation of the design. Previous articles develop the theoretical underpinnings of the formalization [14, 13, 15, 16, 33, 34, 35]; and mention DDD in the context of large examples <ref> [17, 3, 18] </ref>. However, these papers give few details about the experience of using the system. Our goal in this paper is to give a more complete picture of the derivation process. With two small examples we examine the sequence of intermediate expressions produced as an implementation is derived. <p> For expediency, we model communication using imperative input-output commands; Rin, SWin, and display are procedures that perform the I/O. In a moment, we will extract these impurities from the description. Although it adds more notational overhead to the specification, the right way to represent communication is to use streams <ref> [17] </ref>. This technique conforms to later stages of specification and consequently, supports a hierarchical decomposition of specifications. Since DDD places no special significance on operation symbols, limited used of imperative modeling techniques can coexist effectively with the derivation process. 5.1 Behavior to Structure An initial system expression is derived automatically. <p> It is distilled from Boyer's derivation of a garbage collector <ref> [17, 3] </ref>. The device moves information from a source memory, organized as an array of two-byte words, to a target memory, organized as an array of bytes. <p> We might (as in this example) try to minimize the number of arithmetic devices, or alternatively, keep the memories busy in every state, (as was done in <ref> [17] </ref>). The underlying algebra involves a sequence of inverse substitutions applied to the argument list of LOOP.
Reference: [18] <author> Steven D. Johnson, R.M. Wehrmeister, and B. Bose. </author> <title> On the interplay of synthesis and verification: Experiments with the FM8501 processor description. </title> <editor> In Claesen, editor, </editor> <booktitle> Applied Formal Methods for Correct VLSI Design, </booktitle> <pages> pages 385-404. </pages> <publisher> Elsevier, </publisher> <year> 1989. </year> <month> IMEC </month> <year> 1989. </year>
Reference-contexts: It operates on a dialect of functional modeling expressions, providing a uniform and visible representation of the design. Previous articles develop the theoretical underpinnings of the formalization [14, 13, 15, 16, 33, 34, 35]; and mention DDD in the context of large examples <ref> [17, 3, 18] </ref>. However, these papers give few details about the experience of using the system. Our goal in this paper is to give a more complete picture of the derivation process. With two small examples we examine the sequence of intermediate expressions produced as an implementation is derived. <p> One goal of our research is to explore interactions between synthesis and verification at higher levels of design specification. DDD manipulates the same language of first-order Lisp expressions that is used in "Boyer-Moore logic" [4]. In <ref> [18] </ref>, we applied DDD directly to Hunt's mechanically verified FM8501 microprocessor descriptions [12]. The exercise demonstrated the interplay of two forms of automated reasoning; and in particular, showed that derivation (i.e. synthesis in a formal system) could obviate a significant portion of the correctness proof.
Reference: [19] <author> Kurt Keutzer and Wayne Wolf. </author> <title> Anatomy of a hardware compiler. </title> <booktitle> In SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 95-104. </pages> <publisher> ACM, </publisher> <year> 1988. </year> <month> 36 </month>
Reference: [20] <author> Eugene Kohlbecker. </author> <title> Syntactic Extension in the Programming Language Lisp. </title> <type> PhD thesis, </type> <institution> Indiana University, Bloomington, Indiana, </institution> <year> 1986. </year>
Reference-contexts: There is, however, one significant extension to legal Scheme syntax: nested formal parameters are allowed. We permit them because hardware description often involves multiple-valued functions. This extension is readily dealt with in an expansion package, such as Kohlbecker's <ref> [20] </ref>. Scheme is a statically scoped, applicative order dialect of Lisp, whose functional sublanguage is an implementation of a typed lambda calculus (i.e., a lambda calculus extended by primitive symbolic operations). A complete language definition can be found in [27].
Reference: [21] <author> M. Mahmood, F. Mavaddat, M.I. Elmasry, and M.H.M. Cheng. </author> <title> A formal language model of local microcode synthesis. </title> <editor> In Luc Claesen, editor, </editor> <booktitle> Proceedings of The International Workshop on The Applied Formal Method for Correct VLSI Designs, </booktitle> <address> Leuven, Belgium, 1989. </address> <publisher> Elsevier Science Publishers B.V. </publisher>
Reference-contexts: More recently, Zhu has developed an algebraic approach [33, 34, 35] having much in common a the treatment of Maa-davaht, et.al, which based on DT0L languages <ref> [21] </ref>. The idea is to provide a partial set of architectural constraints, and then to determine automatically whether the given list of terms is serializable in that configuration. The DDD serializer provides several forms of constraint specification. The simplest is 28 a list of partial register transfers.
Reference: [22] <author> Michael C. McFarland, Alice C. Parker, and Raul Camposano. </author> <title> Tutorial on high-level synthesis. </title> <booktitle> In 25th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 330-336, </pages> <year> 1988. </year>
Reference: [23] <author> J.D. Morison, N.E. Peeling, and T.L. Thorp. </author> <title> The design rationale of ELLA, a hardware design and description language. </title> <booktitle> In CHDL'85, </booktitle> <year> 1985. </year>
Reference-contexts: In Section 7, we discuss future refinements and reexamine our goals for DDD in light of the examples. 2 Related Research The use and manipulation of functional expressions is common in hardware applications. A number of hardware description languages (HDLs) are functional; Silage [11] and ELLA <ref> [23] </ref> are examples. The majority of structural HDLs are essentially functional. Functional calculus is also prominent in formal-methods research, where it vies for prominence with predicate, relational and process calculi. Our approach is closely related to that of Sheeran, who has also developed functional algebra for manipulating hardware descriptions.
Reference: [24] <author> John T. O'Donnell. HYDRA: </author> <title> Hardware description in a functional language using recursion equations and higher order combining forms. </title> <editor> In G. Milne, editor, </editor> <booktitle> The Fusion of Hardware Design and Verification, </booktitle> <pages> pages 309-328, </pages> <address> Amsterdam, </address> <month> July </month> <year> 1988. </year> <month> Horth-Holland. </month>
Reference-contexts: A potential benefit of performing synthesis on expressions of a symbolic processing language is that these expressions can also be executed to model the design. Each of the intermediate expressions generated by DDD is a valid Scheme program, used to simulate and explore the implementation. O'Donnell's HYDRA system <ref> [24] </ref> is a related study of this aspect of methodology. 3 Terminology, Syntax, and Elementary Al gebra Our approach formalizes synthesis as a translation between dialects of a single modeling language of functional expressions. We use the term derivation to emphasize the character of this translation.
Reference: [25] <author> Franklin P. Prosser and David E. </author> <title> Winkel. </title> <booktitle> The Art of Digital Design. Prentice-Hall, second edition, </booktitle> <year> 1987. </year>
Reference-contexts: The first example, in Section 5, details a derivation of the Black-Jack dealer described by Winkel and Prosser in their text book on digital design <ref> [25] </ref>. This simple example illustrates most aspects of the derivation but not its generality. In Section 6, we take a fragment of a larger specification through the early phases of derivation in order to illustrate how a more sophisticated data hierarchy is managed in DDD. <p> Working prototypes have been built in PLD, standard-cell, and PLA technologies; and we have developed a generic bit-slice module for rapid design [26]. 5 First Example A Black Jack Dealer The first example is taken from a text book on digital design by Winkel and Prosser <ref> [25] </ref>. The BJ machine simulates a dealer's actions in a black jack game: The environment presents cards one at a time; using a four-cycle handshake (Hit.me, Card.ready). The device plays until its score exceeds sixteen and looses should its score exceed twenty-one.
Reference: [26] <author> K. Rath, I. Celis, and R. M. Wehrmeister. RTBA: </author> <title> A generic bit-sliced bus architecture for datapath synthesis. </title> <type> Technical Report 321, </type> <institution> Department of Computer Science, Indiana University, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: The boolean subsystems are put into logic synthesis facilities, which perform low-level optimizations and assemble realizations. Working prototypes have been built in PLD, standard-cell, and PLA technologies; and we have developed a generic bit-slice module for rapid design <ref> [26] </ref>. 5 First Example A Black Jack Dealer The first example is taken from a text book on digital design by Winkel and Prosser [25]. <p> The standard-cell realization, upper right, does not include registers. The PLA realization, lower right includes the full design except for feedback paths. The device at the left is in mixed technology, the data path was generated by a package we have developed and includes a serial scan path <ref> [26] </ref>. The PLA at the bottom implements control, and small standard-cell layout, mid-left, implements comparison operations. <p> C3 BJADD-B3*) = (SLICE3 Cmd BJADD-O3 Cd3) (Score4 BJADD-B4*) = (SLICE4 Cmd BJADD-O4) (R Rd S B H* A) = (SLICE5 Cmd Go) (BJADD-O0 BJADD-O1 BJADD-O2 BJADD-O3 BJADD-O4) = (addto Score BJADD-B) in (list H* S B Score) 25 mixed layout realization, left, consists of a generic data path circuit <ref> [26] </ref> which is used to realize the score and C registers and the addto operation; the PLA below contains the ENCODE and NEXTSTATE functions and the remaining registers, SLICE 5; the tests gt21?, gt16? and ace? are implemented in standard-cell technology, just above the PLA on the left. 26 6 Second
Reference: [27] <author> Jonathan Rees and William Clinger. </author> <title> The revised 3 report on the algorithmic language scheme. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(12) </volume> <pages> 37-79, </pages> <year> 1986. </year>
Reference-contexts: Scheme is a statically scoped, applicative order dialect of Lisp, whose functional sublanguage is an implementation of a typed lambda calculus (i.e., a lambda calculus extended by primitive symbolic operations). A complete language definition can be found in <ref> [27] </ref>. It's equally important symbolic processing capability is thoroughly developed in several text books, such as [7], [30] and [1]. In the last of these a number of hardware modeling techniques are presented.
Reference: [28] <author> Mary Sheeran. muFP, </author> <title> an algebraic VLSI design language. </title> <booktitle> In Proceedings of the ACM Symposium on LISP and Functional Programming, </booktitle> <year> 1984. </year>
Reference-contexts: Our approach is closely related to that of Sheeran, who has also developed functional algebra for manipulating hardware descriptions. However, there are differences both in notation and in emphasis. Sheeran began with an FP variant <ref> [28] </ref> which she later refined to a relational notation called Ruby [29]. This is a fitting choice for the regular structures she is most concerned with. The DDD algebra is specialized for manipulating data paths under sequential control.
Reference: [29] <editor> Mary Sheeran. Retiming and slowdown in Ruby. In G.J. Milne, editor, </editor> <booktitle> The Fusion of Hardware Design and Verification, </booktitle> <pages> pages 289-308. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: Our approach is closely related to that of Sheeran, who has also developed functional algebra for manipulating hardware descriptions. However, there are differences both in notation and in emphasis. Sheeran began with an FP variant [28] which she later refined to a relational notation called Ruby <ref> [29] </ref>. This is a fitting choice for the regular structures she is most concerned with. The DDD algebra is specialized for manipulating data paths under sequential control. We regard Sheeran's work and ours to be compatible treatments of distinct intervals of the design spectrum.
Reference: [30] <author> George Springer and Daniel P. Friedman. </author> <title> Scheme and the Art of Programming. </title> <publisher> McGraw-Hill, </publisher> <year> 1989. </year> <month> 37 </month>
Reference-contexts: A complete language definition can be found in [27]. It's equally important symbolic processing capability is thoroughly developed in several text books, such as [7], <ref> [30] </ref> and [1]. In the last of these a number of hardware modeling techniques are presented. In the informal language summary that follows, upper case variables refer to expressions and lower case variables refer to values; the same letter associates the two: expression E has value e. <p> We have taken a bottom-up approach to implementing the algebra, making a priority of establishing a connection to real hardware. In principle, DDD integrates with software oriented program transformation methods, as developed for example in <ref> [30] </ref>, to give a much higher level of hardware specification. In other words, we think that this approach can be seemlessly extended to higher levels of system description. The first example presented in the paper, the Black-Jack machine in Section 5, shows how DDD is used to manipulate physical organization.
Reference: [31] <author> Ranganadha Rao Vemuri. </author> <title> A Transformational Approach to Register--Transfer-Level Design-Space Exploration. </title> <type> PhD thesis, </type> <institution> Case Western Reserve University, </institution> <month> January </month> <year> 1989. </year>
Reference: [32] <author> David Winkel and Franklin Prosser. </author> <title> The Art of Digital Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey 07632, </address> <year> 1980. </year>
Reference: [33] <author> Zheng Zhu and Steven D. Johnson. </author> <title> An algebraic characterization of structural synthesis for hardware. </title> <editor> In Claesen, editor, </editor> <booktitle> Proceedings of The International Workshop on The Applied Formal Methods for Correct VLSI Designs. </booktitle> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: It operates on a dialect of functional modeling expressions, providing a uniform and visible representation of the design. Previous articles develop the theoretical underpinnings of the formalization <ref> [14, 13, 15, 16, 33, 34, 35] </ref>; and mention DDD in the context of large examples [17, 3, 18]. However, these papers give few details about the experience of using the system. Our goal in this paper is to give a more complete picture of the derivation process. <p> We have experimented with strategies in which the designer provides architectural constraints in the form of a predicate, which accepts substitutions that meet architectural goals [3]. More recently, Zhu has developed an algebraic approach <ref> [33, 34, 35] </ref> having much in common a the treatment of Maa-davaht, et.al, which based on DT0L languages [21]. The idea is to provide a partial set of architectural constraints, and then to determine automatically whether the given list of terms is serializable in that configuration.
Reference: [34] <author> Zheng Zhu and Steven D. Johnson. </author> <title> An algebraic framework for data abstraction in hardware description. </title> <editor> In Jones and Sheeran, editors, </editor> <booktitle> Proceedings of The Oxford Workshop on Designing Correct Circuits. </booktitle> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: It operates on a dialect of functional modeling expressions, providing a uniform and visible representation of the design. Previous articles develop the theoretical underpinnings of the formalization <ref> [14, 13, 15, 16, 33, 34, 35] </ref>; and mention DDD in the context of large examples [17, 3, 18]. However, these papers give few details about the experience of using the system. Our goal in this paper is to give a more complete picture of the derivation process. <p> We have experimented with strategies in which the designer provides architectural constraints in the form of a predicate, which accepts substitutions that meet architectural goals [3]. More recently, Zhu has developed an algebraic approach <ref> [33, 34, 35] </ref> having much in common a the treatment of Maa-davaht, et.al, which based on DT0L languages [21]. The idea is to provide a partial set of architectural constraints, and then to determine automatically whether the given list of terms is serializable in that configuration.
Reference: [35] <author> Zheng Zhu and Steven D. Johnson. </author> <title> An example of interactive hardware transformation. </title> <editor> In Subramanyam, editor, </editor> <booktitle> Proceedings of ACM International Workshop on Formal Methods in VLSI Design, </booktitle> <month> January </month> <year> 1991. </year> <note> available as Techical Report 383, </note> <institution> Computer Science Department, Indi-ana University. </institution> <month> 38 </month>
Reference-contexts: It operates on a dialect of functional modeling expressions, providing a uniform and visible representation of the design. Previous articles develop the theoretical underpinnings of the formalization <ref> [14, 13, 15, 16, 33, 34, 35] </ref>; and mention DDD in the context of large examples [17, 3, 18]. However, these papers give few details about the experience of using the system. Our goal in this paper is to give a more complete picture of the derivation process. <p> We have experimented with strategies in which the designer provides architectural constraints in the form of a predicate, which accepts substitutions that meet architectural goals [3]. More recently, Zhu has developed an algebraic approach <ref> [33, 34, 35] </ref> having much in common a the treatment of Maa-davaht, et.al, which based on DT0L languages [21]. The idea is to provide a partial set of architectural constraints, and then to determine automatically whether the given list of terms is serializable in that configuration.
References-found: 35

