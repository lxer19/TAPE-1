URL: http://www.cs.wvu.edu/~atkinson/pubs/apsec97.ps.gz
Refering-URL: http://www.cs.wvu.edu/~atkinson/publications.html
Root-URL: http://www.cs.wvu.edu
Email: E-mail: atkis@it.uq.edu.au  
Phone: Phone: +61 7 3365 1003 Fax: +61 7 3365 1533  
Title: Cognitive Deficiencies in Software Library Design  
Author: Steven Atkinson 
Keyword: software libraries, cognitive design, software reuse  
Address: AUSTRALIA  
Affiliation: Software Verification Research Centre School of Information Technology University of Queensland QLD 4072  
Abstract: In this paper, a focused review of existing software libraries is undertaken. Shortcomings of the designs of existing software libraries and resulting cognitive deficiencies are identified. The design problems to be discussed are: the hiding of underlying library structure, the inadequacy of component interfaces, the problems of querying large collections, and the subjective nature of component organisation. Having encountered these problems with existing software libraries, some avenues for alleviating them are identified. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Atkinson. </author> <title> Formalizing the Eiffel Library Standard. </title> <booktitle> In Technology of Object-Oriented Languages and Systems: TOOLS 18, </booktitle> <pages> pages 323-335. </pages> <publisher> Prentice-Hall, </publisher> <year> 1995. </year> <note> Also available as Software Verification Research Centre Technical Report TR95-35, </note> <institution> University of Queensland, Australia. </institution> <month> 16 </month>
Reference-contexts: In this case, the focus should be on flexibility, consistency and intuitiveness within (rather than between) libraries. A standard developed for the Eiffel kernel library, called the Eiffel Library Standard [13], is formally examined in <ref> [1] </ref>. The formal rules that comprise the standard can verifiably help alleviate the effects of abstraction mismatch across Eiffel libraries from different vendors.
Reference: [2] <author> S. Atkinson. </author> <title> A Formal Model for Integrated Retrieval from Software Libraries. </title> <booktitle> In Technology of Object-Oriented Languages and Systems: TOOLS 21, </booktitle> <pages> pages 153-167. </pages> <institution> Monash University Printing Services, Caulfield, </institution> <address> Victoria, Australia, </address> <year> 1996. </year>
Reference-contexts: The quality of retrieval schemes used can alleviate both problems, by searching collections and finding components closely resembling the desired component. However, it is still difficult for an automated retrieval scheme to reach that goal <ref> [2, 14] </ref>. Problems 1 and 2 are problems which can be addressed in a relatively direct manner.
Reference: [3] <author> S. Atkinson. </author> <title> Engineering Software Library Systems. </title> <type> PhD thesis, </type> <institution> School of Information Technology, University of Queensland, </institution> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: The first cognitive deficiency of software library design is therefore to conceal the library schema. An explicit library schema encompassing models for components and their relationships is required. A formal model representing such a library schema for a library of formally-specified components is presented in <ref> [3] </ref>. A scalable notion of component is defined a component may be a variable declaration, operation, class or system. Three structural properties, common to components of any granularity, are used to define the library schema: 1. A component contains sub-components. <p> The software engineer can then take advantage of the knowledge to formulate precise queries. The formal schema also allows for storage of derived information, component extension during evolution, and component certification upon insertion <ref> [3] </ref>. 2.2 Component Interfaces Having identified the need for an explicit library schema, there are implications for the storage and presentation of single component declarations. <p> The ability to reason about local properties of components remains acutely relevant when reusing components in different environments. However, not all components exhibit exclusively locally-dependent properties, since they may act in concert with other components. One possible solution to the second deficiency is the derivation of feature graphs <ref> [3] </ref> from the formal library schema model mentioned in Section 2.1.2. A feature graph models the computational collaboration of components.
Reference: [4] <author> B. Fischer, M. Kievernagel, and W. Struckmann. VCR: </author> <title> A VDM-based software component retrieval tool. </title> <type> Technical Report 94-08, </type> <institution> Institut fur Program-miersprachen und Informationssysteme, Technische Universitat Braunschweig, </institution> <address> Gaustasse 17, D-38092 Braunschweig, Germany, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: Querying by class and method name can be performed in many development environments. 12 All the above libraries address Problem 2 by offering name-based search facilities which provide rudimentary querying capabilities. Many other search and retrieval strategies have been proposed <ref> [19, 4, 16] </ref>. Manual browsing of libraries is also a strategy addressing Problem 2. The sizes of the libraries under consideration are not so large as to render browsing infeasible. Pintado [15] suggests another strategy for large libraries, called "affinity browsing".
Reference: [5] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design patterns: Abstraction and reuse of object-oriented design. </title> <editor> In Oscar Nierstrasz, editor, </editor> <booktitle> Eu-ropean Conference on Object-Oriented Programming, </booktitle> <pages> pages 406-431, </pages> <address> Kaiser-lauten, Germany, July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: These applications serve as vehicles for idiomatic familiarisation, and often expose the library user to ways of constructing useful collaborations in ways intended by the library developer. Often such collaborative frameworks are also documented in reference material provided with the software library. Design patterns <ref> [5] </ref> can be viewed as generic extractions of common, useful collaborative structures of components. If such additional structure is provided with libraries, clearly "comment and type signature" interfaces alone are not adequate for effective use of a library.
Reference: [6] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: the language. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: In this paper, a focused review of existing software libraries is undertaken, showing the cognitive deficiencies of current software library designs. There are several existing software library systems used to highlight these deficiencies, based on the languages Eiffel [11], C++[17], Smalltalk <ref> [6] </ref>, and Java [9]. The existing libraries chosen for this review are medium-scale, object-oriented and domain-specific, thereby avoiding obscuring the deficiencies through large size or wide coverage. In particular, we will be reviewing libraries covering the domains of data structures and user interface construction.
Reference: [7] <author> I. Jacobson, M. Christerson, P. Jonsson, and G. Overgaard. </author> <title> Object-Oriented Software Engineering: A Use Case Driven Approach. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: However, in order to make use of these appliances, we learn a series of button presses to attain the goal of cooking or recording particular items. Such a series of actions, called a recipe (sometimes called a scenario or a use-case <ref> [7] </ref>), denotes the intended or conventional use of a component. Furthermore, one or more recipes may be associated with each component, since the manuals for many microwaves and VCRs often include a collection of recipes for different tasks, each recipe being documented as a series of button presses.
Reference: [8] <author> J. Jeng and B. H. C. Cheng. </author> <title> Using Formal Methods to Construct a Software Component Library. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 717 </volume> <pages> 397-417, </pages> <note> Septem-ber 1993. (Proc. of Fourth European Software Engineering Conference), longer version in Techreport MSU-CPS-92-11. </note>
Reference-contexts: The clustering of the libraries mentioned above is presumably undertaken by library designers. However, there have been attempts at automatically clustering component descriptions using lexical metrics derived from code comments [10], and using analysis of ranked order-sorted specification formulae <ref> [8] </ref>. There is no single way of clustering components which is universally useful. Many different criteria could be used in different circumstances (for example, alphabetical by class name or using the inheritance relationship). The criteria chosen depends on the needs of the library searcher.
Reference: [9] <author> L. Lemay, C.L. Perkins, and M. Morrison. </author> <title> Teach Yourself Java in 21 Days. </title> <publisher> Sams.net Publishing, </publisher> <year> 1996. </year>
Reference-contexts: In this paper, a focused review of existing software libraries is undertaken, showing the cognitive deficiencies of current software library designs. There are several existing software library systems used to highlight these deficiencies, based on the languages Eiffel [11], C++[17], Smalltalk [6], and Java <ref> [9] </ref>. The existing libraries chosen for this review are medium-scale, object-oriented and domain-specific, thereby avoiding obscuring the deficiencies through large size or wide coverage. In particular, we will be reviewing libraries covering the domains of data structures and user interface construction.
Reference: [10] <author> Y.S. Maarek, D.M. Berry, and G.E. Kaiser. </author> <title> An information retrieval approach for automatically constructing software libraries. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 17(8) </volume> <pages> 800-813, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The clustering of the libraries mentioned above is presumably undertaken by library designers. However, there have been attempts at automatically clustering component descriptions using lexical metrics derived from code comments <ref> [10] </ref>, and using analysis of ranked order-sorted specification formulae [8]. There is no single way of clustering components which is universally useful. Many different criteria could be used in different circumstances (for example, alphabetical by class name or using the inheritance relationship).
Reference: [11] <author> B. Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall Object-Oriented Series. Prentice Hall (UK) Ltd, </publisher> <address> 66 Wood Lane End, Hertforshire HP24RG, </address> <year> 1992. </year>
Reference-contexts: In this paper, a focused review of existing software libraries is undertaken, showing the cognitive deficiencies of current software library designs. There are several existing software library systems used to highlight these deficiencies, based on the languages Eiffel <ref> [11] </ref>, C++[17], Smalltalk [6], and Java [9]. The existing libraries chosen for this review are medium-scale, object-oriented and domain-specific, thereby avoiding obscuring the deficiencies through large size or wide coverage. In particular, we will be reviewing libraries covering the domains of data structures and user interface construction.
Reference: [12] <author> B. Meyer. </author> <title> Reusable Software The Base object-oriented component libraries. </title> <publisher> Prentice Hall, </publisher> <address> ISE, </address> <institution> Santa Barbara and SOL, Paris, </institution> <year> 1994. </year>
Reference: [13] <author> B. Meyer. </author> <title> The Eiffel Library Standard (Vintage 95). </title> <type> Technical Report TR-EI-48/KL, </type> <institution> Interactive Software Engineering, Inc., </institution> <address> 225 Storke Rd, Suite 7, Goleta, CA 93117 USA, </address> <month> June </month> <year> 1995. </year> <note> Version 8. Available from ftp://ftp.eiffel.com/pub/nice/library. 17 </note>
Reference-contexts: Clearly no single library's regime of classification and clustering can be agreeable to all under all circumstances. In this case, the focus should be on flexibility, consistency and intuitiveness within (rather than between) libraries. A standard developed for the Eiffel kernel library, called the Eiffel Library Standard <ref> [13] </ref>, is formally examined in [1]. The formal rules that comprise the standard can verifiably help alleviate the effects of abstraction mismatch across Eiffel libraries from different vendors.
Reference: [14] <author> H. Mili, F. Mili, and A. Mili. </author> <title> Reusing Software: Issues and Research Directions. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 21(6) </volume> <pages> 528-561, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The quality of retrieval schemes used can alleviate both problems, by searching collections and finding components closely resembling the desired component. However, it is still difficult for an automated retrieval scheme to reach that goal <ref> [2, 14] </ref>. Problems 1 and 2 are problems which can be addressed in a relatively direct manner.
Reference: [15] <author> Xavier Pintado. </author> <title> Selection and exploration in an object-oriented environment: The affinity browser. Object management, </title> <institution> Centre Universitaire d'Informatique, University of Geneva, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Many other search and retrieval strategies have been proposed [19, 4, 16]. Manual browsing of libraries is also a strategy addressing Problem 2. The sizes of the libraries under consideration are not so large as to render browsing infeasible. Pintado <ref> [15] </ref> suggests another strategy for large libraries, called "affinity browsing". Under this scheme, metrics and information derived from components are used to cluster components for browsing purposes. The libraries above address Problem 1 by segregating collections of components, using techniques of sub-libraries, categories or grouped hierarchies.
Reference: [16] <author> R. Prieto-Diaz and P. Freeman. </author> <title> Classifying Software for Reusability. </title> <journal> IEEE Software, </journal> <volume> 4(1) </volume> <pages> 6-16, </pages> <year> 1987. </year>
Reference-contexts: Querying by class and method name can be performed in many development environments. 12 All the above libraries address Problem 2 by offering name-based search facilities which provide rudimentary querying capabilities. Many other search and retrieval strategies have been proposed <ref> [19, 4, 16] </ref>. Manual browsing of libraries is also a strategy addressing Problem 2. The sizes of the libraries under consideration are not so large as to render browsing infeasible. Pintado [15] suggests another strategy for large libraries, called "affinity browsing".
Reference: [17] <author> B. Stroustrup. </author> <title> The C++ programming language. </title> <publisher> Addison-Wesley, </publisher> <address> 2 edition, </address> <year> 1991. </year>
Reference: [18] <institution> ParcPlace Systems. VisualWorks Cookbook. VisualWorks Manuals. ParcPlace Systems, Inc., </institution> <year> 1994. </year>
Reference-contexts: The VisualAge library also provides a collection of customisable application shells (e.g. an application shell linking a database with a user interface). VisualWorks Smalltalk has a collection of examples collated in a cookbook <ref> [18] </ref>. The exposure of library schemata through proprietary tools, coupled with idiomatic examples, falls short of providing a clear, explicit library schema which can be used to support software library operations, and thereby enhance the utility of libraries for software engineers.
Reference: [19] <author> A. M. Zaremski and J. M. Wing. </author> <title> Specification Matching of Software Components. </title> <booktitle> In Proc. Third Symposium on the Foundations of Software Engineering (FSE3), </booktitle> <pages> pages 6-17. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> October </month> <year> 1995. </year> <month> 18 </month>
Reference-contexts: Querying by class and method name can be performed in many development environments. 12 All the above libraries address Problem 2 by offering name-based search facilities which provide rudimentary querying capabilities. Many other search and retrieval strategies have been proposed <ref> [19, 4, 16] </ref>. Manual browsing of libraries is also a strategy addressing Problem 2. The sizes of the libraries under consideration are not so large as to render browsing infeasible. Pintado [15] suggests another strategy for large libraries, called "affinity browsing".
References-found: 19

