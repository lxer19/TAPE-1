URL: http://www.cis.ohio-state.edu/~harrold/webpapers/icse98-slicing.ps
Refering-URL: http://www.cis.ohio-state.edu/~harrold/788.12p/readings.html
Root-URL: 
Email: harrold@cis.ohio-state.edu  ci@cis.ohio-state.edu  
Phone: +1 614 292 2568  +1 614 292 1152  
Title: Reuse-Driven Interprocedural Slicing  
Author: Mary Jean Harrold Ning Ci 
Keyword: Program slicing, interprocedural analysis, data-flow analysis, demand analysis.  
Address: Columbus, OH 43210-1227 USA  Columbus, OH 43210-1227 USA  
Affiliation: Computer and Information Science The Ohio State University 395 Dreese Lab  Computer and Information Science The Ohio State University 395 Dreese Lab  
Abstract: To manage the evolution of software systems effectively, software developers must understand software systems, identify and evaluate alternative modification strategies, implement appropriate modifications, and validate the correctness of the modifications. One analysis technique that assists in many of these activities is program slicing. To facilitate the application of slicing to large software systems, we adapted a control-flow-based in-terprocedural slicing algorithm so that it accounts for interprocedural control dependencies not recognized by other slicing algorithms, and reuses slicing information for improved efficiency. Our initial studies suggest that additional slice accuracy and slicing efficiency may be achieved with our algorithm. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Agrawal. </author> <title> On slicing programs with jump statements. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 302-12, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Third, the current version of our slicer does not perform the additional analysis required to compute executable slices in the presence of unstructured transfers of control such as goto, break, or continue; we are currently implementing Agrawal's technique <ref> [1] </ref> to include such statements in the slices. For a given slicing criterion, &lt; s; v &gt;, our prototype does, however, include all statements that could effect the value of v at s. 3.2 Studies Table 1 lists the C programs we used as subjects for our studies.
Reference: [2] <author> D. C. Atkinson and W. G. Griswold. </author> <title> The design of whole-program analysis tools. </title> <booktitle> In Proc. of the 18th Int'l. Conf. on Softw. Eng., </booktitle> <pages> pages 16-27, </pages> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: The context-graph approach lets a user select the number of distinct calling contexts, and thus, control the precision of slices <ref> [2] </ref>. The efficiency of interprocedural slicing may be improved by using database techniques [13] or demand approaches [2, 4, 6, 10], or by efficient management of program representations [2]. <p> The context-graph approach lets a user select the number of distinct calling contexts, and thus, control the precision of slices [2]. The efficiency of interprocedural slicing may be improved by using database techniques [13] or demand approaches <ref> [2, 4, 6, 10] </ref>, or by efficient management of program representations [2]. Our attempts to use existing interprocedural slicing algorithms for our applications uncovered several areas for improvement in the accuracy and efficiency of existing approaches. <p> The context-graph approach lets a user select the number of distinct calling contexts, and thus, control the precision of slices <ref> [2] </ref>. The efficiency of interprocedural slicing may be improved by using database techniques [13] or demand approaches [2, 4, 6, 10], or by efficient management of program representations [2]. Our attempts to use existing interprocedural slicing algorithms for our applications uncovered several areas for improvement in the accuracy and efficiency of existing approaches. First, none of the existing interprocedural slicing algorithms accounts for interprocedural effects on control dependence. <p> Second, although existing interprocedural slicing algorithms reuse slicing information, none of them is reported to reuse the slices for subsequent slicing. This reuse may be especially important when single or multiple users perform repeated slices on the same program <ref> [2] </ref>. For example, suppose that we slice with criterion &lt; 5b; sum &gt; on program Sum, shown in Figure 1, and save the slicing information. <p> Finally, none of the existing data-flow-based interproce-dural slicing algorithms <ref> [2, 6] </ref> presents a technique for slicing into procedures that call the procedure in which the slice is initiated. For example, suppose that we wish to begin the slice in procedure B at statement 11.
Reference: [3] <author> S. Bates and S. Horwitz. </author> <title> Incremental program testing using program dependence graphs. </title> <booktitle> Conf. Record of the Twentieth ACM Symp. on Prin. of Prog. Lang., </booktitle> <pages> pages 384-396, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: To manage this evolution effectively, software developers need to understand software systems, identify and evaluate alternative modification strategies, implement appropriate modifications, and validate the correctness of the modifications. One analysis technique that assists in many of these activities is program slicing (e.g., <ref> [3, 9, 14] </ref>). A program slice is defined with respect to a slicing criterion &lt; S; V &gt; in which S is a program point and V is a subset of program variables.
Reference: [4] <author> E. Duesterwald and M. L. Soffa. </author> <title> Demand-driven computation of interprocedural data flow. </title> <booktitle> In Proceedings of 22nd ACM Symposium on Principles of Programming Lang uages, </booktitle> <pages> pages 37-48, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: The context-graph approach lets a user select the number of distinct calling contexts, and thus, control the precision of slices [2]. The efficiency of interprocedural slicing may be improved by using database techniques [13] or demand approaches <ref> [2, 4, 6, 10] </ref>, or by efficient management of program representations [2]. Our attempts to use existing interprocedural slicing algorithms for our applications uncovered several areas for improvement in the accuracy and efficiency of existing approaches.
Reference: [5] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: An ACFG also contains a unique node, Super Exit, that represents all exits from P . Finally, an ACFG has additional control flow edges that connect CFG nodes with these new nodes. When the ACFG is used to compute intraprocedural control dependencies using a control-dependence computation algorithm, such as <ref> [5] </ref>, the control dependen 4 cies, CD [N ], for all nodes N that are control dependent on returning from called procedures and thus, control dependent on predicates in other procedures, will contain a Return Predicate node.
Reference: [6] <author> R. Gupta and M. L. Soffa. </author> <title> Hybrid slicing: An approach for refining static slices using dynamic information. </title> <booktitle> In Proc. of the 3rd Intl. Symp. on the Found. of Softw. Eng., </booktitle> <pages> pages 29-40, </pages> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: The context-graph approach lets a user select the number of distinct calling contexts, and thus, control the precision of slices [2]. The efficiency of interprocedural slicing may be improved by using database techniques [13] or demand approaches <ref> [2, 4, 6, 10] </ref>, or by efficient management of program representations [2]. Our attempts to use existing interprocedural slicing algorithms for our applications uncovered several areas for improvement in the accuracy and efficiency of existing approaches. <p> Finally, none of the existing data-flow-based interproce-dural slicing algorithms <ref> [2, 6] </ref> presents a technique for slicing into procedures that call the procedure in which the slice is initiated. For example, suppose that we wish to begin the slice in procedure B at statement 11. <p> If PropagateToCallers, shown in 27-30), it uses backbind to determine CalleeV ars using SliceList [s; v]:entryV ars together with the actual parameters at C; this computation is similar to the algorithm presented in <ref> [6] </ref>. If PropagateToCallers finds that the CallStack is empty (line 31), there are two possibilities: (1) the slicing has reached the main procedure, or (2) for procedures other than main, the slicing has reached a caller of the procedure in which the slice was initiated or the procedure itself.
Reference: [7] <author> M. J. Harrold and G. Rothermel. Aristotle: </author> <title> A system for research on and development of program-analysis-based tools. </title> <type> Technical Report OSU-CISRC-3/97-TR17, </type> <institution> The Ohio State University, </institution> <month> Mar. </month> <year> 1997. </year>
Reference-contexts: This section reports on both the implementation and the studies. 3.1 Implementation We used the Aristotle analysis system <ref> [7] </ref>, which provides analysis information, such as control flow, data flow, and control dependence, to provide analysis information for our prototype slicer. To provide easier access to Aristotle's analysis information, we implemented a wrapper around the Aristotle analysis system.
Reference: [8] <author> M. J. Harrold, G. Rothermel, and S. Sinha. </author> <title> Computation of interprocedural control dependence. </title> <booktitle> In Proc. of the ACM Int'l. Symp. on Softw. Testing and Analysis, </booktitle> <month> Mar. </month> <year> 1998. </year>
Reference-contexts: The reason for this omission is that these algorithms use control-dependence information based on control-flow graphs for single procedures (intraprocedural control dependence). Recent work <ref> [8] </ref> describes several ways in which this intraprocedu-ral control-dependence computation inaccurately models the semantic dependencies that exist between program statements. <p> However, a study of a variety of non-trivial C programs showed that over 63% of the programs contained exit () statements that can affect control de pendencies, and thus, potentially the outcome of slicing <ref> [8] </ref>. 1 computed intraprocedurally in the usual way, without considering the effects of the embedded halt, statement 7, for example, will be control dependent on entering M. <p> Dashed edges show the interprocedural flow of control between procedures. ComputePSlice also uses control dependencies, CD [N ], for slice computation. Our algorithm differs from other existing interprocedural slicing algorithms in that the slice computation accounts for the effects of embedded halts <ref> [8] </ref>. Before control-dependence information is computed, our algorithm uses the CallGraph to determine whether any procedures reachable from P contain embedded halts. 5 If there are no reachable embedded halts, the control dependencies for statements in P are correctly computed using P 's control flow graph. <p> are reachable embedded halts, then 5 If there is no statically unreachable code in the program, then inspection of the call graph is sufficient to determine whether P can call procedures with embedded halts; otherwise, and an algorithm that uses the control flow graphs can be used for this identification <ref> [8] </ref>. there exist call sites in P whose return may be control dependent on conditional statement (s) (conditional statements controlling embedded halts) in other procedures. Although intraprocedural control-dependence analysis cannot identify these conditional statements, it can, using an augmented control flow graph (ACFG) [8], compute partial control-dependence information that ComputePSlice uses <p> graphs can be used for this identification <ref> [8] </ref>. there exist call sites in P whose return may be control dependent on conditional statement (s) (conditional statements controlling embedded halts) in other procedures. Although intraprocedural control-dependence analysis cannot identify these conditional statements, it can, using an augmented control flow graph (ACFG) [8], compute partial control-dependence information that ComputePSlice uses to compute correct interprocedural slices. An ACFG for a procedure P is a control flow graph that is augmented with placeholder nodes that represent interprocedural control dependencies.
Reference: [9] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: To manage this evolution effectively, software developers need to understand software systems, identify and evaluate alternative modification strategies, implement appropriate modifications, and validate the correctness of the modifications. One analysis technique that assists in many of these activities is program slicing (e.g., <ref> [3, 9, 14] </ref>). A program slice is defined with respect to a slicing criterion &lt; S; V &gt; in which S is a program point and V is a subset of program variables. <p> The imprecision of early interprocedural slicing algorithms [15] was corrected by the system-dependence-graph approach, which guarantees that slices are computed only along realizable paths in the program <ref> [9] </ref>. 1 With additional expense, more precise slices can be obtained if the computation uses a distinct calling context for each procedure at each call site. The context-graph approach lets a user select the number of distinct calling contexts, and thus, control the precision of slices [2]. <p> Future work will address this issue. * We have incorporated interprocedural control dependence information into our slicing algorithm, but the system dependence graph could be modified to provide similar information. If modified, the two-pass slicing algorithm of <ref> [9] </ref> would produce the same slices as our algorithm computes. * Our results show that, for our subject programs, reuse of slicing information could be significant. We did not measure the storage requirements or time saved because of the reuse that our approach provides.
Reference: [10] <author> S. Horwitz, T. Reps, and M. Sagiv. </author> <title> Demand interproce-dural dataflow analysis. </title> <booktitle> In Proc. of the 3rd Intl. Symp. on the Found. of Softw. Eng., </booktitle> <pages> pages 104-115, </pages> <address> OctOct. </address> <year> 1995. </year>
Reference-contexts: The context-graph approach lets a user select the number of distinct calling contexts, and thus, control the precision of slices [2]. The efficiency of interprocedural slicing may be improved by using database techniques [13] or demand approaches <ref> [2, 4, 6, 10] </ref>, or by efficient management of program representations [2]. Our attempts to use existing interprocedural slicing algorithms for our applications uncovered several areas for improvement in the accuracy and efficiency of existing approaches. <p> The explicit halt at statement 18' affects the control dependencies of statements in procedures M and B. If control dependence is 1 A path is realizable if it respects the fact that procedures always return to the site of the most recent call <ref> [10] </ref>. 2 For languages that do not support embedded halts, the embedded-halt effect is of no concern.
Reference: [11] <author> M. Hutchins, H. Foster, T. Goradia, and T. Os-trand. </author> <title> Experiments on the effectiveness of dataflow-and controlflow-based test adequacy criteria. </title> <booktitle> In Proc. of the 16th Int'l. Conf. on Softw. Eng., </booktitle> <pages> pages 191-200, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: One of the programs, calc, is a component of the Aristotle analysis system; the remaining seven programs were used for a study of control-flow and data-flow-based testing <ref> [11] </ref>. 6 Table 1: Subject programs for the studies.
Reference: [12] <author> A. Podgurski and L. Clarke. </author> <title> A formal model of program dependences and its implications for software testing, debugging, and maintenance. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 16(9) </volume> <pages> 965-79, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: On closer inspection, however, we see that statement 7 depends most immediately for its execution on statement 17, because of the explicit halt in statement 18'. Thus, according to the definition of semantic dependence <ref> [12] </ref>, statement 7 is semantically dependent on statement 17, and statement 17 should be included in any slice that includes statement 7.
Reference: [13] <author> T. Reps. </author> <title> Demand interprocedural program analysis using logic databases, </title> <address> pages 163-196. </address> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, MA. </address>
Reference-contexts: The context-graph approach lets a user select the number of distinct calling contexts, and thus, control the precision of slices [2]. The efficiency of interprocedural slicing may be improved by using database techniques <ref> [13] </ref> or demand approaches [2, 4, 6, 10], or by efficient management of program representations [2]. Our attempts to use existing interprocedural slicing algorithms for our applications uncovered several areas for improvement in the accuracy and efficiency of existing approaches.
Reference: [14] <author> G. Rothermel and M. J. Harrold. </author> <title> Selecting tests and identifying test coverage requirements for modified soft-ware_ Proc. </title> <booktitle> of the ACM Int'l. Symp. on Softw. Testing and Analysis, </booktitle> <pages> pages 169-184, </pages> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: To manage this evolution effectively, software developers need to understand software systems, identify and evaluate alternative modification strategies, implement appropriate modifications, and validate the correctness of the modifications. One analysis technique that assists in many of these activities is program slicing (e.g., <ref> [3, 9, 14] </ref>). A program slice is defined with respect to a slicing criterion &lt; S; V &gt; in which S is a program point and V is a subset of program variables.
Reference: [15] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Trans. on Softw. Eng., </journal> <volume> 10(4) </volume> <pages> 352-357, </pages> <month> July </month> <year> 1984. </year> <month> 10 </month>
Reference-contexts: A slice consists of a subset of program statements, possibly executable, that affect, or are affected by, the values of variables in V at S <ref> [15] </ref>. To be applicable to large software systems, slicing algorithms must perform the slicing across procedure boundaries (interprocedural slicing), and must be sufficiently precise and efficient. The imprecision of early interprocedural slicing algorithms [15] was corrected by the system-dependence-graph approach, which guarantees that slices are computed only along realizable paths in <p> statements, possibly executable, that affect, or are affected by, the values of variables in V at S <ref> [15] </ref>. To be applicable to large software systems, slicing algorithms must perform the slicing across procedure boundaries (interprocedural slicing), and must be sufficiently precise and efficient. The imprecision of early interprocedural slicing algorithms [15] was corrected by the system-dependence-graph approach, which guarantees that slices are computed only along realizable paths in the program [9]. 1 With additional expense, more precise slices can be obtained if the computation uses a distinct calling context for each procedure at each call site. <p> This information can be reused during computation of a particular slice or subsequent slices. In either case, repeated slicing with the same criterion is avoided. Example 2. After slicing procedure B with &lt; 15; i &gt; and &lt; 15; sum &gt;, SliceList contains cached informa tion: for <ref> [15; i] </ref>, entryV ars is fig and pslice is f14g; for [15; sum], entryV ars is fsum; jg and pslice is f11; 12g; for [19; i], [19; i], [19; sum], [19; sum], [19; j], and [19; j], both pslice and entryV ars are . <p> In either case, repeated slicing with the same criterion is avoided. Example 2. After slicing procedure B with &lt; 15; i &gt; and &lt; 15; sum &gt;, SliceList contains cached informa tion: for [15; i], entryV ars is fig and pslice is f14g; for <ref> [15; sum] </ref>, entryV ars is fsum; jg and pslice is f11; 12g; for [19; i], [19; i], [19; sum], [19; sum], [19; j], and [19; j], both pslice and entryV ars are .
References-found: 15

