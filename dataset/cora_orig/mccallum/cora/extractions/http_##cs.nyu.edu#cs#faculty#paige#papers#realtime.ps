URL: http://cs.nyu.edu/cs/faculty/paige/papers/realtime.ps
Refering-URL: http://cs.nyu.edu/cs/faculty/paige/research.html
Root-URL: http://www.cs.nyu.edu
Email: paige@cs.nyu.edu  
Title: Real-time Simulation of a Set Machine on a RAM  
Author: Robert Paige 
Note: November 10, 1994  
Address: New York, NY 10012  
Affiliation: Computer Science Department New York University/ Courant Institute  
Abstract: The analysis of set-based programs is sometimes facilitated by the computational model of a set machine; i.e., a uniform cost sequential RAM augmented with an assortment of primitives on finite sets, under the assumption that associative operations, e.g., set membership, take unit time. In this paper we give broad sufficient conditions in which to simulate a set machine on a RAM (without set primitives) in real time. Two variants of a RAM are considered. One allows for pointer and cursor access. The other permits only pointer access. Our translation method introduces a new programming methodology for data structure design and provides a new framework for investigating automatic data structure selec tion for set-based programs.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Aho, A., Hopcroft, J., and Ullman, J., </author> <title> Data Structures and Algorithms, </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: A third application is pedagogical. We believe that a significant compression would be obtained by reformulating the first seven chapters of Aho, Hopcroft, and Ullman <ref> [1] </ref> using the data structure design principles outlined here. Finally, our ideas on simulating cursor access with pointer access in real time might lead to a way in which methods to make linked data structures persistent [9] could extend to cursor based data structures.
Reference: 2. <author> Aho, A., Hopcroft, J., and Ullman, J., </author> <title> Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: In this paper we show how to overcome the shortcomings (a), (b), and (c) by simulating sets and set operations on a uniform cost sequential RAM <ref> [2, 22] </ref> in real time. That is, we define a formal set machine to be a RAM augmented with an assortment of primitive operations on finite sets. Each set machine primitive operation q is associated with a worst case asymptotic set-theoretic time and space bound O (f q ). <p> Notations involving sets and mappings are useful for a number of reasons: (a) Sets and mappings are abstract data types with a simple and intuitive axiomatization (see, e.g., [28, 31]). (b) More complex abstract data types, such as stacks and queues, are often used solely to imple ment sets efficiently <ref> [2, 8, 22, 28, 33] </ref>. (c) Non-determinism appears naturally in association with set notations. The retrieval operation - S denotes an arbitrary choice over the elements of set S. <p> Based on direct access using cursors and cursor arithmetic, tuples and arrays can be initialized in O (1) time using a stack and cursor array according to exercise 2.12 found in <ref> [2] </ref>. Likewise, the data in an array or tuple can be split into roughly equal parts (which is useful for divide-and-conquer strategies) in O (1) time. <p> That is, for each based input set S with base B, the input operation for S reads both B and the based representation for S. It is assumed (an assumption common to almost all algorithms texts; cf. <ref> [2] </ref>) that the input is preconditioned in this way and the program takes no measures to ensure that this is so. Of course, base representations could also be built by the program when data is input. <p> The domains of these maps are sets of indexes, and the ranges include the component values. Using this kind of simulation, it is easy to rewrite a whole bunch of algorithms that seem to require cursor access (e.g., Knuth, Morris, Pratt fast string matching [19] or lexicographic sorting; see, <ref> [2] </ref>) in a list processing form without any asymptotic penalties in time or space. 5. Conclusion We have outlined a new programming methodology for specifying complex data structures using a finite set theoretic language and for implementating these abstract specifications using simpler lower level storage structures.
Reference: 3. <author> Barstow, D., </author> <title> Knowledge-Based Program Construction, </title> <publisher> Elsevier North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: However, his concrete storage structures had limited dynamic capabilities, and his design principles did not incorporate formal complexity. After Earley, researchers in the programming language and artificial intelligence communities proposed or implemented a number of interesting expert systems for data structure design <ref> [3, 15, 21, 26] </ref> . These approaches sacrificed Earley's goal of a unified theory of data structure design in favor of hand crafted systems that could work well in a limited domain.
Reference: 4. <author> Boas, P. v. Emde, </author> <title> ``Preserving order in a forest in less than logarithmic time and linear space,'' </title> <journal> IPL, </journal> <volume> vol. 6, </volume> <pages> pp. 80-82, </pages> <year> 1977. </year>
Reference-contexts: ARAM is more powerful than APM, since finding the i-th element of a list, initializing all the cells of a list, or splitting a list cannot be achieved in constant time in APM. Consequently, various data structures for hashing, tries, and the O (loglogN ) priority queue <ref> [4, 5] </ref> of Van Emde Boas cannot be implemented with as good an asymptotic performance in APM as in ARAM. Whenever data can be stored within an array or tuple instead of a list, there are several other practical advantages that should be mentioned.
Reference: 5. <author> Boas, P. v. Emde, Kaas, R., and Zijlstra, E., </author> <title> ``Design and implementation of an efficient priority queue,'' </title> <journal> Math. Sys. Theory, </journal> <volume> vol. 10, </volume> <pages> pp. 99-127, </pages> <year> 1977. </year>
Reference-contexts: ARAM is more powerful than APM, since finding the i-th element of a list, initializing all the cells of a list, or splitting a list cannot be achieved in constant time in APM. Consequently, various data structures for hashing, tries, and the O (loglogN ) priority queue <ref> [4, 5] </ref> of Van Emde Boas cannot be implemented with as good an asymptotic performance in APM as in ARAM. Whenever data can be stored within an array or tuple instead of a list, there are several other practical advantages that should be mentioned.
Reference: 6. <author> Deak, E., </author> <title> ``Source to source transformation in SETL: a case study,'' </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> Jan., </month> <year> 1981. </year>
Reference-contexts: 1. Introduction In spite of its central place in mathematical discourse, set theory has had a relatively minor influence on programming language design. One conspicuous exception is SETL [28], a programming language that has demonstrated the benefits of finite set theory for software design and prototyping [20], program verification <ref> [6] </ref>, and top-down program (and algorithm) development methodology [7, 24, 25].
Reference: 7. <author> Dewar, R., Grand, A., Liu S. C., Schwartz, J. T., and Schonberg, E., </author> <title> ``Program by Refinement as Exemplified by the SETL Representation Sublanguage,'' </title> <journal> TOPLAS, </journal> <volume> vol. 1, no. 1, </volume> <pages> pp. 27-49, </pages> <month> July, </month> <year> 1979. </year>
Reference-contexts: One conspicuous exception is SETL [28], a programming language that has demonstrated the benefits of finite set theory for software design and prototyping [20], program verification [6], and top-down program (and algorithm) development methodology <ref> [7, 24, 25] </ref>.
Reference: 8. <author> Dijkstra, E. W., </author> <title> A Discipline of Programming, </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: Notations involving sets and mappings are useful for a number of reasons: (a) Sets and mappings are abstract data types with a simple and intuitive axiomatization (see, e.g., [28, 31]). (b) More complex abstract data types, such as stacks and queues, are often used solely to imple ment sets efficiently <ref> [2, 8, 22, 28, 33] </ref>. (c) Non-determinism appears naturally in association with set notations. The retrieval operation - S denotes an arbitrary choice over the elements of set S.
Reference: 9. <author> Driscoll, J., Sarnak, N., Sleator, D., and Tarjan, R., </author> <title> ``Making Data Structures Persistent,'' </title> <booktitle> in Proc. 8th ACM STOC, </booktitle> <pages> pp. 109 - 121, </pages> <publisher> ACM, </publisher> <month> May, </month> <year> 1986. </year>
Reference-contexts: It would be interesting to consider a more general simulation in which each unit time set operation is implemented in unit amortized time [35] on a RAM. Finally, some of the simulation conditions that require data to be unpinned might be relaxed if persistant data structures <ref> [9] </ref> were used. There are several areas where our methodology might be usefully applied. One of these is in automated software development. We are investigating a data structure selection transformation based on this methodology for the RAPTS system [24]. <p> Finally, our ideas on simulating cursor access with pointer access in real time might lead to a way in which methods to make linked data structures persistent <ref> [9] </ref> could extend to cursor based data structures.
Reference: 10. <author> Earley, J., </author> <title> ``Toward an Understanding of Data Structures,'' </title> <journal> CACM, </journal> <volume> vol. 14, no. 10, </volume> <pages> pp. 617-627, </pages> <month> Oct. </month> <year> 1971. </year>
Reference-contexts: The translation from abstract to concrete data structures simulates a set machine on a RAM in real-time (where only the complexity of data access is considered). Our ideas derive from several important sources mentioned below. Jay Earley <ref> [10] </ref> considered the problem of abstract data structure specification and implementation principles to support compilation of his proposed language VERS2. He used a graph theoretic access path model that handled both cursor and pointer access to data.
Reference: 11. <author> Freudenberger, S., Schwartz, J. T., and Sharir, M., </author> <title> ``Experience with the SETL Optimizer,'' </title> <journal> ACM TOPLAS, </journal> <volume> vol. 5, no. 1, </volume> <pages> pp. 26-45, </pages> <year> 1983. </year>
Reference-contexts: At the same time, a decade-long experience with SETL has underscored three shortcomings in its use <ref> [11] </ref>: (a) Standard compilation and optimization techniques fare poorly in a language with finite set theory: compiler and optimizer are complex and slow. (b) The resulting code is often more inefficient than that produced by other very high-level languages. (c) It is hard to perform accurate complexity analysis directly on set-based
Reference: 12. <author> Hecht, M. and Ullman, J. D., </author> <title> ``A simple algorithm for global data flow analysis programs,'' </title> <journal> SIAM J. Computing, </journal> <volume> vol. 4, </volume> <pages> pp. 519-532, </pages> <year> 1975. </year> - -- 
Reference-contexts: The organization of the set of instructions and the order in which the existential search should proceed is unspecified in the preceding code. A number of orderings were proposed over the years (for which see <ref> [12, 14, 16, 36] </ref> ) until Tarjan [34] found an optimal one. 3.
Reference: 13. <author> Hoare, C. A. R., </author> <title> ``Proof of Correctness of Data Representations,'' </title> <journal> Acta Informatica, </journal> <volume> vol. 1, no. 19, </volume> <pages> pp. 271-281, </pages> <year> 1972. </year>
Reference-contexts: Hoare <ref> [13] </ref> used the general notion of simulation to verify the implementation of abstract data types using concrete data types. We regard this work and other work in classical verification as revealing the inverse relationship that verification has with top down design.
Reference: 14. <author> Kam, J. B. and Ullman, J. D., </author> <title> ``Global data flow analysis and iterative algorithms,'' </title> <journal> JACM, </journal> <volume> vol. 23, no. 1, </volume> <pages> pp. 158-171, </pages> <year> 1976. </year>
Reference-contexts: The organization of the set of instructions and the order in which the existential search should proceed is unspecified in the preceding code. A number of orderings were proposed over the years (for which see <ref> [12, 14, 16, 36] </ref> ) until Tarjan [34] found an optimal one. 3.
Reference: 15. <author> Kant, E., </author> <title> Efficiency in Program Synthesis, </title> <publisher> UMI Research Press, </publisher> <year> 1981. </year>
Reference-contexts: However, his concrete storage structures had limited dynamic capabilities, and his design principles did not incorporate formal complexity. After Earley, researchers in the programming language and artificial intelligence communities proposed or implemented a number of interesting expert systems for data structure design <ref> [3, 15, 21, 26] </ref> . These approaches sacrificed Earley's goal of a unified theory of data structure design in favor of hand crafted systems that could work well in a limited domain.
Reference: 16. <author> Kennedy, K., </author> <title> ``Node Listings Applied to Data Flow Analysis,'' </title> <booktitle> in Proceedings 2nd ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan, </month> <year> 1975. </year>
Reference-contexts: The organization of the set of instructions and the order in which the existential search should proceed is unspecified in the preceding code. A number of orderings were proposed over the years (for which see <ref> [12, 14, 16, 36] </ref> ) until Tarjan [34] found an optimal one. 3.
Reference: 17. <author> Kildall, G., </author> <title> ``A Unified Approach to Global Program Optimization,'' </title> <booktitle> in Proc. First ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1973. </year>
Reference-contexts: An extreme example of such decision postponement, spanning more than a decade, is exemplified by Kildall's general schema <ref> [17] </ref> for iterative computation of monotone data flow problems: [x 1 ,...x n ] := [0, 0,... 0] ; (while $ i -1..n- | f i (x 1 ,..,x n ) &gt; x i ) x i := f i (x 1 ,..x n ) ; end loop ; where the
Reference: 18. <author> Knuth, D. E., </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol 1: </volume> <booktitle> Fundamental Algorithms, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1973. </year>
Reference-contexts: Two variants of a RAM are considered. The simplest is a pointer machine <ref> [18, 32] </ref>, which accesses data using pointers but lacks direct access into arrays and cannot perform address arithmetic. The other augments the pointer machine capabilities with cursor access into arrays and tuples. <p> In this case the address of the record can serve as the key. Whenever based sets are disjoint, they can sometimes be combined in a single field of a strongly based representation (as is done in Knuth's topological sorting algorithm <ref> [18] </ref>, which is explained in [23]). 4.2.4. Subbases In the preceding discussion we mentioned the potential space blowup when handling associative access for sets that belong to collections. We mentioned one favorable, exceptional case when the collection of nonsimple sets are pairwise disjoint.
Reference: 19. <author> Knuth, D., Morris, J., and Pratt, V., </author> <title> ``Fast Pattern Matching in Strings,'' </title> <journal> SIAM J. Computing, </journal> <volume> vol. 6, no. 2, </volume> <pages> pp. 323-350, </pages> <year> 1977. </year>
Reference-contexts: The domains of these maps are sets of indexes, and the ranges include the component values. Using this kind of simulation, it is easy to rewrite a whole bunch of algorithms that seem to require cursor access (e.g., Knuth, Morris, Pratt fast string matching <ref> [19] </ref> or lexicographic sorting; see, [2]) in a list processing form without any asymptotic penalties in time or space. 5.
Reference: 20. <author> Kruchten, K., Schonberg, E., and Schwartz, J., </author> <title> ``Software Prototyping using the SETL Programming Language,'' </title> <journal> IEEE Software, </journal> <pages> pp. 66-75, </pages> <month> Oct., </month> <year> 1984. </year>
Reference-contexts: 1. Introduction In spite of its central place in mathematical discourse, set theory has had a relatively minor influence on programming language design. One conspicuous exception is SETL [28], a programming language that has demonstrated the benefits of finite set theory for software design and prototyping <ref> [20] </ref>, program verification [6], and top-down program (and algorithm) development methodology [7, 24, 25].
Reference: 21. <author> Low, J. and Rovner, P., </author> <title> ``Techniques for the automatic selection of data structures,'' </title> <booktitle> in Third POPL, </booktitle> <pages> pp. 58 - 67, </pages> <year> 1976. </year>
Reference-contexts: However, his concrete storage structures had limited dynamic capabilities, and his design principles did not incorporate formal complexity. After Earley, researchers in the programming language and artificial intelligence communities proposed or implemented a number of interesting expert systems for data structure design <ref> [3, 15, 21, 26] </ref> . These approaches sacrificed Earley's goal of a unified theory of data structure design in favor of hand crafted systems that could work well in a limited domain.
Reference: 22. <author> Mehlhorn, K., </author> <title> Sorting and Searching, Data Structures and Algorithms, 1, </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: In this paper we show how to overcome the shortcomings (a), (b), and (c) by simulating sets and set operations on a uniform cost sequential RAM <ref> [2, 22] </ref> in real time. That is, we define a formal set machine to be a RAM augmented with an assortment of primitive operations on finite sets. Each set machine primitive operation q is associated with a worst case asymptotic set-theoretic time and space bound O (f q ). <p> Notations involving sets and mappings are useful for a number of reasons: (a) Sets and mappings are abstract data types with a simple and intuitive axiomatization (see, e.g., [28, 31]). (b) More complex abstract data types, such as stacks and queues, are often used solely to imple ment sets efficiently <ref> [2, 8, 22, 28, 33] </ref>. (c) Non-determinism appears naturally in association with set notations. The retrieval operation - S denotes an arbitrary choice over the elements of set S.
Reference: 23. <author> Paige, R., </author> <title> ``Transformational Programming -- Applications to Algorithms and Systems,'' </title> <booktitle> in Proceedings Tenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 73-87, </pages> <month> Jan, </month> <year> 1983. </year>
Reference-contexts: In this case the address of the record can serve as the key. Whenever based sets are disjoint, they can sometimes be combined in a single field of a strongly based representation (as is done in Knuth's topological sorting algorithm [18], which is explained in <ref> [23] </ref>). 4.2.4. Subbases In the preceding discussion we mentioned the potential space blowup when handling associative access for sets that belong to collections. We mentioned one favorable, exceptional case when the collection of nonsimple sets are pairwise disjoint.
Reference: 24. <author> Paige, R. and Henglein, F., </author> <title> ``Mechanical Translation of Set Theoretic Problem Specifications Into Efficient RAM Code A Case Study,'' </title> <journal> Journal of Symbolic Computation, </journal> <volume> vol. 4, no. 2, </volume> <pages> pp. 207-232, </pages> <month> Aug., </month> <year> 1987. </year>
Reference-contexts: One conspicuous exception is SETL [28], a programming language that has demonstrated the benefits of finite set theory for software design and prototyping [20], program verification [6], and top-down program (and algorithm) development methodology <ref> [7, 24, 25] </ref>. <p> It also provides an easy top-down methodology for designing data structures. Our techniques also provide a new framework with which to extend the data structure selection algorithms proposed in <ref> [24, 27] </ref> to produce structures that can be modified to a much greater degree at runtime. This paper is organized as follows: Section 2 examines the advantages of set-based programming in software development. Section 3 introduces the set-machine and RAM models of computation. <p> However, the subsequent search needed to locate this value within Q in order to delete it cannot in general be achieved in unit time. 4.2.2. Based representations Associative Access Removal In order to solve the associative access problem mentioned above, we follow the approach found in <ref> [24] </ref> where values common to both sets S and Q are stored in one place. Consequently the unit time retrieval from S locates the value within Q as well. <p> For example, in many graph algorithms, the set of all nodes of the graph often plays the role of a base set, and is either input explicitly, or implicitly as the domain of definition of the successor (edge) map. This restricted case of static bases was investigated in <ref> [24] </ref> for the final data structure selection phase of a very high level problem specification compiler. In the present paper we consider the broader context of dynamic bases that can be first constructed externally and input, and then augmented or diminished at run-time by addition, link, and deallocation operations. <p> There are several areas where our methodology might be usefully applied. One of these is in automated software development. We are investigating a data structure selection transformation based on this methodology for the RAPTS system <ref> [24] </ref>. In the area of verification, we might be able to get shorter more convincing transformational proofs by using inference rules more naturally based on our data structure design principles. A third application is pedagogical.
Reference: 25. <author> Paige, R and Tarjan, R., </author> <title> ``Three Efficient Algorithms Based on Partition Refinement,'' </title> <journal> SIAM Journal on Computing, </journal> <volume> vol. 16, no. 6, </volume> <month> Dec., </month> <year> 1987. </year>
Reference-contexts: One conspicuous exception is SETL [28], a programming language that has demonstrated the benefits of finite set theory for software design and prototyping [20], program verification [6], and top-down program (and algorithm) development methodology <ref> [7, 24, 25] </ref>.
Reference: 26. <author> Rovner, P., </author> <title> ``Automatic Representation Selection for Associative Data Structures,'' </title> <institution> TR10, Dept. of Computer Science, University of Rochester, </institution> <year> 1977. </year> <editor> Ph. D. </editor> <booktitle> Thesis, </booktitle> <publisher> Harvard University </publisher>
Reference-contexts: However, his concrete storage structures had limited dynamic capabilities, and his design principles did not incorporate formal complexity. After Earley, researchers in the programming language and artificial intelligence communities proposed or implemented a number of interesting expert systems for data structure design <ref> [3, 15, 21, 26] </ref> . These approaches sacrificed Earley's goal of a unified theory of data structure design in favor of hand crafted systems that could work well in a limited domain.
Reference: 27. <author> Schonberg, E., Schwartz, J. T., and Sharir, M., </author> <title> ``An Automatic Technique for Selection of Data Representations in in SETL Programs,'' </title> <journal> ACM TOPLAS, </journal> <volume> vol. 3, no. 2, </volume> <pages> pp. 126-143, </pages> <month> Apr, </month> <year> 1981. </year>
Reference-contexts: It also provides an easy top-down methodology for designing data structures. Our techniques also provide a new framework with which to extend the data structure selection algorithms proposed in <ref> [24, 27] </ref> to produce structures that can be modified to a much greater degree at runtime. This paper is organized as follows: Section 2 examines the advantages of set-based programming in software development. Section 3 introduces the set-machine and RAM models of computation. <p> Of course, base representations could also be built by the program when data is input. This is the technique described in <ref> [27] </ref>, where hashing is used to ensure that a base contains no repeated elements. 4.3. ASM simulation with ARAM The increased power of ARAM over APM can be exploited to provide for improved implementations when simulating ASM with ARAM. <p> These approaches sacrificed Earley's goal of a unified theory of data structure design in favor of hand crafted systems that could work well in a limited domain. Schwartz and others <ref> [27, 29, 30] </ref> modelled complex data structures in SETL and provided a language (that introduced the notion of a base and based representations) for implementing finite sets, maps, and tuples using concrete storage representations. An automatic data structure selection algorithm was also implemented within the SETL optimizer.
Reference: 28. <author> Schwartz, J., Dewar, R., Dubinsky, D., and Schonberg, E., </author> <title> Programming with Sets: An introduction to SETL, </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: 1. Introduction In spite of its central place in mathematical discourse, set theory has had a relatively minor influence on programming language design. One conspicuous exception is SETL <ref> [28] </ref>, a programming language that has demonstrated the benefits of finite set theory for software design and prototyping [20], program verification [6], and top-down program (and algorithm) development methodology [7, 24, 25]. <p> The advantages of set-theoretic notations in programming Notations involving sets and mappings are useful for a number of reasons: (a) Sets and mappings are abstract data types with a simple and intuitive axiomatization (see, e.g., <ref> [28, 31] </ref>). (b) More complex abstract data types, such as stacks and queues, are often used solely to imple ment sets efficiently [2, 8, 22, 28, 33]. (c) Non-determinism appears naturally in association with set notations. <p> Notations involving sets and mappings are useful for a number of reasons: (a) Sets and mappings are abstract data types with a simple and intuitive axiomatization (see, e.g., [28, 31]). (b) More complex abstract data types, such as stacks and queues, are often used solely to imple ment sets efficiently <ref> [2, 8, 22, 28, 33] </ref>. (c) Non-determinism appears naturally in association with set notations. The retrieval operation - S denotes an arbitrary choice over the elements of set S. <p> Thus, a map can be a single-valued function or a multi-valued binary relation. Sets and maps can be dynamically allocated, deallocated, and modified at run-time. The primitive set-theoretic operations of ASM correspond closely to finite set theory [31] and SETL <ref> [28] </ref>, and we will mainly use universally accepted mathematical notations. Several exceptions include the overloaded size operator denoted by #S, which represents the cardinality of a finite set S or the number of components in a tuple or array S.
Reference: 29. <author> Schwartz, J.T., </author> <title> ``Automatic Data Structure Choice in a Language of Very High Level,'' </title> <journal> CACM, </journal> <volume> vol. 18, no. 12, </volume> <pages> pp. 722-728, </pages> <month> Dec, </month> <year> 1975. </year>
Reference-contexts: The importance of (a), (b), and (c) in programming practice is sufficiently well-known that the shortest summary will suffice here: these advantages facilitate program correctness proofs by making programs shorter, more abstract, and free from unimportant implementation details. Furthermore, as Schwartz has argued <ref> [29] </ref>, they allow the programming task to be factored into two phases: one of algorithm design, and one of data structure selection, which is best tackled after the first is completed. Thus (a), (b), and (c) facilitate the application of decision-postponement, a widely advocated principle in contemporary software engineering. <p> These approaches sacrificed Earley's goal of a unified theory of data structure design in favor of hand crafted systems that could work well in a limited domain. Schwartz and others <ref> [27, 29, 30] </ref> modelled complex data structures in SETL and provided a language (that introduced the notion of a base and based representations) for implementing finite sets, maps, and tuples using concrete storage representations. An automatic data structure selection algorithm was also implemented within the SETL optimizer.
Reference: 30. <author> Schwartz, J. T., </author> <title> ``Optimization of Very High Level Languages, Parts I, II,'' </title> <journal> J. of Computer Languages, </journal> <volume> vol. 1, no. 2,3, </volume> <pages> pp. 161-218, </pages> <year> 1975. </year>
Reference-contexts: These approaches sacrificed Earley's goal of a unified theory of data structure design in favor of hand crafted systems that could work well in a limited domain. Schwartz and others <ref> [27, 29, 30] </ref> modelled complex data structures in SETL and provided a language (that introduced the notion of a base and based representations) for implementing finite sets, maps, and tuples using concrete storage representations. An automatic data structure selection algorithm was also implemented within the SETL optimizer.
Reference: 31. <author> Suppes, P., </author> <title> Axiomatic Set Theory, </title> <publisher> Dover, </publisher> <year> 1972. </year>
Reference-contexts: The advantages of set-theoretic notations in programming Notations involving sets and mappings are useful for a number of reasons: (a) Sets and mappings are abstract data types with a simple and intuitive axiomatization (see, e.g., <ref> [28, 31] </ref>). (b) More complex abstract data types, such as stacks and queues, are often used solely to imple ment sets efficiently [2, 8, 22, 28, 33]. (c) Non-determinism appears naturally in association with set notations. <p> Thus, a map can be a single-valued function or a multi-valued binary relation. Sets and maps can be dynamically allocated, deallocated, and modified at run-time. The primitive set-theoretic operations of ASM correspond closely to finite set theory <ref> [31] </ref> and SETL [28], and we will mainly use universally accepted mathematical notations. Several exceptions include the overloaded size operator denoted by #S, which represents the cardinality of a finite set S or the number of components in a tuple or array S.
Reference: 32. <author> Tarjan, R., </author> <title> ``A Class Of Algorithms Which Require Nonlinear Time To Maintain Disjoint Sets,'' </title> <journal> J. Comput. Sys. Sci., </journal> <volume> vol. 18, </volume> <pages> pp. 110-127, </pages> <year> 1979. </year>
Reference-contexts: Two variants of a RAM are considered. The simplest is a pointer machine <ref> [18, 32] </ref>, which accesses data using pointers but lacks direct access into arrays and cannot perform address arithmetic. The other augments the pointer machine capabilities with cursor access into arrays and tuples.
Reference: 33. <author> Tarjan, R., </author> <title> Data Structures and Network Algorithms, </title> <publisher> SIAM, </publisher> <year> 1984. </year>
Reference-contexts: Notations involving sets and mappings are useful for a number of reasons: (a) Sets and mappings are abstract data types with a simple and intuitive axiomatization (see, e.g., [28, 31]). (b) More complex abstract data types, such as stacks and queues, are often used solely to imple ment sets efficiently <ref> [2, 8, 22, 28, 33] </ref>. (c) Non-determinism appears naturally in association with set notations. The retrieval operation - S denotes an arbitrary choice over the elements of set S.
Reference: 34. <author> Tarjan, R., </author> <title> ``Iterative Algorithms for Global Flow Analysis,'' in Algorithms and Complexity, New Directions and Recent Results, </title> <editor> ed. Traub, </editor> <booktitle> J., </booktitle> <pages> pp. 91-102, </pages> <publisher> Academic Press, </publisher> <year> 1976. </year> - -- 
Reference-contexts: The organization of the set of instructions and the order in which the existential search should proceed is unspecified in the preceding code. A number of orderings were proposed over the years (for which see [12, 14, 16, 36] ) until Tarjan <ref> [34] </ref> found an optimal one. 3.
Reference: 35. <author> Tarjan, R., </author> <title> Amortized computational complexity, </title> <booktitle> 6, </booktitle> <pages> pp. 306-318, </pages> <note> SIAM J. Alg. Disc. Meth., </note> <year> 1985. </year>
Reference-contexts: Restricting data structure selection to a real-time simulation is probably too restrictive. It would be interesting to consider a more general simulation in which each unit time set operation is implemented in unit amortized time <ref> [35] </ref> on a RAM. Finally, some of the simulation conditions that require data to be unpinned might be relaxed if persistant data structures [9] were used. There are several areas where our methodology might be usefully applied. One of these is in automated software development.
Reference: 36. <author> Tenenbaum, A., </author> <title> Type Determination for Very High Level Languages, </title> <institution> New York University, Dept. of Computer Science, </institution> <month> Oct, </month> <year> 1974. </year> <note> appears in Courant Computer Science Report 3 </note>
Reference-contexts: The organization of the set of instructions and the order in which the existential search should proceed is unspecified in the preceding code. A number of orderings were proposed over the years (for which see <ref> [12, 14, 16, 36] </ref> ) until Tarjan [34] found an optimal one. 3.
Reference: 37. <author> Wiederhold, G., </author> <title> Database Design, </title> <publisher> McGraw-Hill, </publisher> <year> 1983. </year> - -- 
Reference-contexts: Observe that if each record field for strongly based sets is named, then we can always omit a field instead of storing W there. Wiederhold refers to this as a pile representation <ref> [37] </ref>. Consequently, space utilization for weakly and strongly based representations preserves the ASM space complexity. Weakly based and strongly based representations can be used for elements of set valued variables and domains of maps. Weakly based representations can also be used for elements of nonsimple sets. <p> Of particular importance, when a base set is either static or of bounded size, the set of records representing strongly based sets can be implemented in what Wiederhold calls transposed form <ref> [37] </ref>. That is, The base B is an array of, say, n values and each strongly based set S is implemented as a single array of size n.
References-found: 37

