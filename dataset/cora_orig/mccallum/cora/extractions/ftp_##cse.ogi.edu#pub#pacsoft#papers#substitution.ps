URL: ftp://cse.ogi.edu/pub/pacsoft/papers/substitution.ps
Refering-URL: http://www.cse.ogi.edu/~bellegar/fb.html
Root-URL: http://www.cse.ogi.edu
Email: fbellegar,hookg@cse.ogi.edu  
Title: Substitution: A formal methods case study using monads and transformations  
Author: Fran~coise Bellegarde and James Hook 
Date: April 7, 1994  
Address: PO Box 91000 Portland, Oregon 97291-1000 USA  
Affiliation: Pacific Software Research Center Oregon Graduate Institute of Science Technology  
Abstract: The specification and derivation of substitution for the de Bruijn representation of - terms is used to illustrate programming with a function-sequence monad. The resulting program is improved by interactive program transformation methods into an efficient implementation that uses primitive machine arithmetic. These transformations illustrate new techniques that assist the discovery of the arithmetic structure of the solution.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, P. L. Curien, and J. J. Levy. </author> <title> Explicit substitutions. </title> <journal> J. of Functional Programming, </journal> <volume> 1 </volume> <pages> 375-416, </pages> <year> 1991. </year>
Reference-contexts: In Curien, Hardin, and Levy's calculus with explicit substitutions, as well as in the other calculi proposed by Abadi, Cardelli, Curien and Levy <ref> [1] </ref> and Lescanne [14], the result of applying the substitution 0 to the term M is translated by a closure: M [mult (map 0 )]. Note that these calculi represents substitution as functions from terms to terms, hence we use the natural extension of 0 rather than 0 itself.
Reference: [2] <author> Jeffrey Bell et al. </author> <title> Software design for reliability and reuse: A proof-of-concept demonstration. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: We are de-veloping a transformation system for functional programs that is a combination of automated strategies implemented by different tools <ref> [2] </ref>.
Reference: [3] <author> Jeffrey M. Bell. </author> <title> An implementation of Reynold's defunctionalization method for a modern functional language. </title> <type> Master's thesis, </type> <institution> Oregon Graduate Institute, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: The case study presented here is a good (though not typical) example of this process. The system we are developing includes an algebraic programming notation with limited support for monads [13], transformation tools for conversion to first-order (including specialization and Reynolds' defunctionalization <ref> [3] </ref>), and automatic first-order transformation by rewriting techniques [4]. However, some important pieces that are required for automating the formal methods presented in this paper are not yet implemented.
Reference: [4] <author> Fran~coise Bellegarde. </author> <title> Program transformation and rewriting. </title> <booktitle> In Proceedings of the fourth conference on Rewriting Techniques and Applications, volume 488 of LNCS, </booktitle> <pages> pages 226-239, </pages> <address> Berlin, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The system we are developing includes an algebraic programming notation with limited support for monads [13], transformation tools for conversion to first-order (including specialization and Reynolds' defunctionalization [3]), and automatic first-order transformation by rewriting techniques <ref> [4] </ref>. However, some important pieces that are required for automating the formal methods presented in this paper are not yet implemented.
Reference: [5] <author> N. G. de Bruijn. </author> <title> Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser theorem. </title> <journal> Indagaciones Mathematische, </journal> <volume> 34 </volume> <pages> 381-392, </pages> <year> 1972. </year> <note> Also appeared in the Proceedings of the Koninklijke Nederlandse Akademie van Wetenschappen, Amsterdam, series A, 75(5). </note>
Reference: [6] <author> N. G. de Bruijn. </author> <title> Lambda calculus with namefree formulas involving symbols that represent reference transforming mappings. </title> <booktitle> In Proceedings of the Koninklijke Nederlandse Akaemie van Wetenschappen, </booktitle> <pages> pages 348-356, </pages> <address> Amsterdam, </address> <booktitle> series A, </booktitle> <volume> volume 81(3), </volume> <month> September </month> <year> 1978. </year>
Reference: [7] <author> R. M. Burstall and J. Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> Journal of the ACM, </journal> <volume> 24 </volume> <pages> 44-67, </pages> <year> 1977. </year> <month> 33 </month>
Reference-contexts: The transformation is performed according to the following scheme: (1) conversion of the program into a first-order set of constructor-based equations E (see Section 4), (2) manipulation of E by rewriting techniques to automate different strategies based on the unfold/fold method <ref> [7] </ref> (see Section 5), (3) translation of the constructor-based set of equations to an efficient functional program, e.g. introduction of conditionals and machine arithmetic. The case study presented here is a good (though not typical) example of this process.
Reference: [8] <author> Charles Consel and Olivier Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 493-501. </pages> <publisher> ACM, </publisher> <year> 1993. </year>
Reference: [9] <author> P. L. Curien, Th. Hardin, and J. J. Levy. </author> <title> Confluence properties of weak and strong calculi of explicit substitutions. </title> <type> Technical Report RR 1617, </type> <institution> INRIA, Rocquencourt, </institution> <year> 1992. </year>
Reference-contexts: We also wish to thank the referees for their constructive and insightful remarks. 28 A Correctness of the substitution algorithm This section demonstrates the equivalence of the substitution function defined in Figure 4 to the definition of substitution in the calculus of explicit substitutions of Curien, Hardin and Levy <ref> [10, 9] </ref>. In Curien, Hardin, and Levy's calculus with explicit substitutions, as well as in the other calculi proposed by Abadi, Cardelli, Curien and Levy [1] and Lescanne [14], the result of applying the substitution 0 to the term M is translated by a closure: M [mult (map 0 )].
Reference: [10] <author> Th. Hardin and J.J. Levy. </author> <title> A confluent calculus of substitutions. </title> <booktitle> In France-Japan Artificial Intelligence and Computer Science Symposium, </booktitle> <year> 1989. </year>
Reference-contexts: We also wish to thank the referees for their constructive and insightful remarks. 28 A Correctness of the substitution algorithm This section demonstrates the equivalence of the substitution function defined in Figure 4 to the definition of substitution in the calculus of explicit substitutions of Curien, Hardin and Levy <ref> [10, 9] </ref>. In Curien, Hardin, and Levy's calculus with explicit substitutions, as well as in the other calculi proposed by Abadi, Cardelli, Curien and Levy [1] and Lescanne [14], the result of applying the substitution 0 to the term M is translated by a closure: M [mult (map 0 )].
Reference: [11] <author> James Hook, Richard Kieburtz, and Tim Sheard. </author> <title> Generating programs by reflection. </title> <type> Technical Report 92-015, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> July </month> <year> 1992. </year>
Reference: [12] <author> Richard B. Kieburtz. </author> <title> A generic specification of prettyprinters. </title> <type> Technical Report CSE-91-020, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <year> 1991. </year>
Reference: [13] <author> Richard B. Kieburtz and Jeffrey Lewis. </author> <title> Algebraic design language (preliminary definition). </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: The case study presented here is a good (though not typical) example of this process. The system we are developing includes an algebraic programming notation with limited support for monads <ref> [13] </ref>, transformation tools for conversion to first-order (including specialization and Reynolds' defunctionalization [3]), and automatic first-order transformation by rewriting techniques [4]. However, some important pieces that are required for automating the formal methods presented in this paper are not yet implemented.
Reference: [14] <author> P. Lescanne. </author> <title> From to v, a journey through calculi of explicit substitutions. </title> <booktitle> In Symposium on Principles of Programming Languages, </booktitle> <year> 1994. </year>
Reference-contexts: In Curien, Hardin, and Levy's calculus with explicit substitutions, as well as in the other calculi proposed by Abadi, Cardelli, Curien and Levy [1] and Lescanne <ref> [14] </ref>, the result of applying the substitution 0 to the term M is translated by a closure: M [mult (map 0 )]. Note that these calculi represents substitution as functions from terms to terms, hence we use the natural extension of 0 rather than 0 itself.
Reference: [15] <author> Eugenio Moggi. </author> <title> Notions of computations and monads. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 55-92, </pages> <month> July </month> <year> 1991. </year>
Reference: [16] <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In ACM National Conference, </booktitle> <pages> pages 717-740. </pages> <publisher> ACM, </publisher> <year> 1972. </year> <month> 34 </month>
Reference: [17] <author> Philip Wadler. </author> <title> Theorems for free! In Proc. </title> <booktitle> of 4th ACM Conf. on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 347-359. </pages> <publisher> ACM Press, </publisher> <month> September </month> <year> 1989. </year>
Reference: [18] <author> Philip Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proc. 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 61-78, </pages> <year> 1990. </year>
Reference: [19] <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <month> January </month> <year> 1992. </year> <month> 35 </month>
References-found: 19

