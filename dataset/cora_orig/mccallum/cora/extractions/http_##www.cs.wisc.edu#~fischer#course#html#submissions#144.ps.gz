URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/144.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/
Root-URL: http://www.cs.wisc.edu
Email: boehm@parc.xerox.com  
Phone: (415) 812-4435  
Title: Simple Garbage-Collector-Safety Suggested classification: Storage management and runtime systems: garbage collection. Thorough familiarity with the
Author: Hans-J. Boehm 
Keyword: Garbage-Collector-Safety  
Address: 3333 Coyote Hill Rd. Palo Alto, CA 94304  
Affiliation: Xerox PARC  
Abstract: A conservative garbage collector can typically be used with conventionally compiled programs written in C or C++. But two safety issues must be considered. First, the source code must not hide pointers from the garbage collector. This primarily requires stricter adherence to existing restrictions in the language definition. Second, we must ensure that the compiler will not perform transformations that invalidate this requirement. We argue that the same technique can be used to address both issues. We present an algorithm for annotating source or intermediate code to either check the validity of pointer arithmetic in the source, or to guarantee that under minimal, clearly defined assumptions about the compiler, the optimizer cannot ``disguise'' pointers. We discuss an implementation based on a preprocessor for the GNU C compiler (gcc), and give some measurements of program slowdown. Automatic garbage collection can significantly simplify program development. It can also help to isolate program errors to one module by helping to ensure that no module can invalidate a data structure maintained by another. Though it is hard to quantify this benefit, most expert guesses seem to place it in the range of 30-40% of program development time for programs that manipulate complex linked data structures (cf. [Rovner85]). Furthermore, in our experience, garbage collected programs tend to be based on higher level abstractions where appropriate, and thus tend to have fewer arbitrary restrictions on functionality (e.g. input size limitations). Tracing garbage collectors identify all accessible memory by starting at program pointer variables, and traversing all pointers through the heap. Conservative garbage collectors (cf. [Bartlett88], [BoehmWeiser88], [Rovner85], [Boehm 95]) can do so even in the presence of incomplete information about pointer identity by treating any bit pattern that might represent the address of a heap object as a pointer. This may result in some extra memory retention, but this is rarely significant [Boehm93]. This approach enables garbage collectors to operate easily with conventional programming languages such as C and C++, and with minimal or no modification to existing compilers. It has been used by many language implementations that use C as an intermediate code (cf. [Bartlett89], [AtkinsonEtAl89], [Omohundro91], [RoseMuller92], [SchelterBallantyne88]) , and it facilitates interoperation between C and higher level programming languages. 
Abstract-found: 1
Intro-found: 1
Reference: [ANSI89] <author> Standard X3.159-1989, </author> <title> American National Standard for Information Systems - Programming Language - C, </title> <publisher> American National Standards Institute, Inc. </publisher>
Reference-contexts: Our approach to inserting checking code is significantly different, in that we essentially treat pointer offset calculations as pointer arithmetic. This appears to result in better checking of structure accesses. Compiler Safety Problem Statement We are interested in compiling ANSI C <ref> [ANSI89] </ref>, minimally restricted as defined above, such 5 that the object code resulting from a strictly conforming program is guaranteed to operate correctly with a conservative garbage collector, e.g. if we replace every call to the malloc, calloc and realloc functions by corresponding calls to a collecting allocator, and remove all
Reference: [AtkinsonEtAl89] <author> Atkinson, Russ, Alan Demers, Carl Hauser, Christian Jacobi, Peter Kessler, and Mark Weiser, </author> <title> ``Experiences Creating a Portable Cedar'', </title> <booktitle> Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation, SIGPLAN Notices 24, </booktitle> <month> 7 (July </month> <year> 1989), </year> <pages> pp. 322-329. </pages>
Reference: [AustinBreachSohi94] <author> Austin, Todd M., Scott E. Breach, and Gurindar S. Sohi, </author> <title> ``Efficient Detection of all Pointer and Array Access Errors'', </title> <booktitle> Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, SIGPLAN Notices 29, </booktitle> <month> 6 (June </month> <year> 1994), </year> <pages> pp. 290-301. </pages>
Reference-contexts: Hence they are not performance competitive with conservative collectors, though the expense may be unavoidable in hard real-time environments [Edelson91]. There has been a substantial amount of work on safer C implementations (cf. [HastingsJoyce92], <ref> [AustinBreachSohi94] </ref>, [JonesKelly95].) Most of these have concentrated on detecting erroneous memory accesses, not erroneous pointer or subscript arithmetic. Though the two are related, the distinction is important. <p> This fails in a garbage collected system. (It may also result in failed pointer comparisons with some pointer implementations on segmented memory machines.) Like Purify, but unlike <ref> [AustinBreachSohi94] </ref>, our checked code uses the same data structure layout as unchecked code. Hence it is possible, indeed trivial, to use checked code with third party object-code-only libraries, or with faster, unchecked modules. Our checked code is very similar in spirit to recent independent work by Jones and Kelly [JonesKelly95].
Reference: [Bartlett88] <author> Bartlett, Joel F. </author> <title> ``Compacting garbage collection with ambiguous roots'', Lisp Pointers 1, </title> <booktitle> 6 (April-June 1988), </booktitle> <pages> pp. 3-12. </pages>
Reference: [Bartlett89] <author> Bartlett, Joel F., </author> <title> Scheme --&gt; C a Portable Scheme-to-C Compiler, </title> <note> WRL Research Report 89/1, </note> <institution> Digital Equipment Corporation Western Research Laboratory, </institution> <month> January </month> <year> 1989. </year>
Reference: [Boehm93] <author> Boehm, Hans-J., </author> <title> ``Space Efficient Conservative Garbage Collection'', </title> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, SIGPLAN Notices 28, </booktitle> <month> 6 (June </month> <year> 1993), </year> <pages> pp. 197-206. </pages>
Reference-contexts: This requires asserting that the client program stores only pointers to the base of an object in the heap or in statically allocated variables. It would again be possible to insert dynamic checks to verify this. This avoids some complications with allocating large objects as discussed in <ref> [Boehm93] </ref>. However it interacts suboptimally with C++ compilers that use interior pointers as part of their multiple inheritance implementation. Acknowledgements Some of this grew out of prior work with David Chase and extensive discussion with John Ellis.
Reference: [Boehm94] <institution> The GC-safe SPARC scheduler is available from parcftp.xerox.com:pub/gc/sched.tar.Z. </institution>
Reference-contexts: In particular, otherwise safe simple instruction reorderings remain safe, except that moving a load or store instruction forward in the instruction stream may not be. We have implemented a simple instruction scheduler for older SPARC machines that optionally preserves GC-safety <ref> [Boehm94] </ref>. (It simply tries to fill delay slots and avoid load stalls.) With old versions of gcc that did not do this on their own, it generates on the order of 25% less improvement in the resulting code in the GC-safe mode.
Reference: [Boehm95] <institution> An overview of our conservative garbage collector along with the source code can be accessed from ftp://parcftp.xerox.com/pub/gc/gc.html. </institution>
Reference: [BoehmChase92] <author> Boehm, Hans-J., and David Chase, </author> <title> A Proposal for GC-Safe C Compilation, The Journal of C Language Translation 4, </title> <month> 2 (December , </month> <year> 1992), </year> <pages> pp. 126-141. </pages> <note> Also available (with the publishers permission) from parcftp.xerox.com:pub/gc/boecha.ps.Z. </note>
Reference-contexts: This could be remedied at minimal cost with the insertion of an additional check. Related Work This work is an extension to and refinement of that presented in <ref> [BoehmChase92] </ref> and [EllisDetlefs93]. Here we give a simplified presentation of an algorithm that potentially results in less overhead. We also believe that this algorithm is considerably easier to implement, at least if a minimal performance loss is tolerated. Unlike [BoehmChase92] we start with the assumption that the garbage collector recognizes all <p> work is an extension to and refinement of that presented in <ref> [BoehmChase92] </ref> and [EllisDetlefs93]. Here we give a simplified presentation of an algorithm that potentially results in less overhead. We also believe that this algorithm is considerably easier to implement, at least if a minimal performance loss is tolerated. Unlike [BoehmChase92] we start with the assumption that the garbage collector recognizes all pointers to the interior of an object, not just to the first byte of the object. Also unlike previous work, we describe a real implementation and give some performance measurements. <p> The value will continue to be explicitly available through a dereference or another KEEP_LIVE in the presence of all standard compiler optimizations. This implementation of KEEP_LIVE is, of course, terribly inefficient. More efficient implementations are suggested in <ref> [BoehmChase92] </ref>, and one is described below.
Reference: [BoehmDemersShenker91] <author> Boehm, H., A. Demers, and S. </author> <title> Shenker,``Mostly Parallel Garbage Collection'', </title> <booktitle> Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, SIGPLAN Notices 26, </booktitle> <month> 6 (June </month> <year> 1991), </year> <pages> pp. 157-164. </pages>
Reference: [BoehmWeiser88] <author> Boehm, Hans-J. and Mark Weiser, </author> <title> ``Garbage collection in an uncooperative environment'', </title> <journal> Software Practice & Experience 18, </journal> <month> 9 (Sept. </month> <year> 1988), </year> <pages> pp. 807-820. </pages>
Reference: [DiwanMossHudson92] <author> Diwan, Amer, Eliot Moss, Richard Hudson, </author> <title> ``Compiler Support for Garbage Collection in a Statically Typed Language'', </title> <booktitle> ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, SIGPLAN Notices 27, </booktitle> <month> 7 (July </month> <year> 1992), </year> <pages> pp. 273-282. </pages>
Reference-contexts: Also unlike previous work, we describe a real implementation and give some performance measurements. There has been much work on the generation and representation of object and stack layout 4 information by the compiler for the garbage collector. Recent examples include <ref> [DiwanMossHudson92] </ref> [Goldberg91], and [Fradet94]. The idea is to generate static information (either tables or traversal functions) to communicate pointer locations to the garbage collector. <p> The last point may introduce other forms of overhead in some multithreaded environments. To our knowledge, none of this work addresses the issue of run-time overhead required to keep pointers accessible, though <ref> [DiwanMossHudson92] </ref> does discuss the necessity for such overhead. There have also been many proposals for completely source-level implementation of garbage-collection using either the C++ constructor/destructor mechanism or Ada 9X ``finalization''. These typically greatly increase the number of memory references necessary for pointer assignments or pointer variable creation.
Reference: [DetlefsDosserZorn93] <author> Detlefs, David, Al Dosser, and Benjamin Zorn, </author> <title> ``Memory Allocation Costs in Large C and C++ Programs'', </title> <institution> University of Colorado, </institution> <type> Boulder Technical Report CU-CS-665-93. </type> <note> Available for ftp from cs.colorado.edu:pub/techreports/zorn/CU-CS-665-93.ps.Z. </note>
Reference-contexts: That would need additional checking code.) Performance We measured a small collection of small-to-medium-sized C programs, mostly drawn from the Zorn benchmark suite <ref> [DetlefsDosserZorn93] </ref>. The preprocessor applies only optimizations (1) and (2) from above. All of these programs are very pointer and allocation intensive. The programs measured were: 11 cordtest: 5 Iterations of the test normally distributed with our "cord" string package. This was run with our garbage collector.
Reference: [Edelson91] <author> Edelson, Daniel, </author> <title> ``A Mark-and-Sweep Collector for C++'', </title> <booktitle> Conference Record of the Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1992, </year> <pages> pp. 51-58. </pages>
Reference-contexts: These typically greatly increase the number of memory references necessary for pointer assignments or pointer variable creation. Hence they are not performance competitive with conservative collectors, though the expense may be unavoidable in hard real-time environments <ref> [Edelson91] </ref>. There has been a substantial amount of work on safer C implementations (cf. [HastingsJoyce92], [AustinBreachSohi94], [JonesKelly95].) Most of these have concentrated on detecting erroneous memory accesses, not erroneous pointer or subscript arithmetic. Though the two are related, the distinction is important.
Reference: [EllisDetlefs93] <author> Ellis, John R., and David L. Detlefs, </author> <title> "Safe Efficient Garbage Collection for C++'', </title> <note> Xerox PARC Technical Report CSL-93-4, September 1993. Also available from parcftp.xerox.com:pub/ellis/gc/gc.ps. </note>
Reference-contexts: This could be remedied at minimal cost with the insertion of an additional check. Related Work This work is an extension to and refinement of that presented in [BoehmChase92] and <ref> [EllisDetlefs93] </ref>. Here we give a simplified presentation of an algorithm that potentially results in less overhead. We also believe that this algorithm is considerably easier to implement, at least if a minimal performance loss is tolerated.
Reference: [Fradet94] <author> Fradet, </author> <title> Pascal, ``Collecting More Garbage'', </title> <booktitle> Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 24-33. </pages>
Reference-contexts: Also unlike previous work, we describe a real implementation and give some performance measurements. There has been much work on the generation and representation of object and stack layout 4 information by the compiler for the garbage collector. Recent examples include [DiwanMossHudson92] [Goldberg91], and <ref> [Fradet94] </ref>. The idea is to generate static information (either tables or traversal functions) to communicate pointer locations to the garbage collector.
Reference: [Goldberg91] <author> Goldberg, Benjamin, </author> <title> ``Tag-Free Garbage Collection for Strongly Typed Programming Languages'', </title> <booktitle> ACM SIGPLAN '91 Conference on Programming Language Design 13 and Implementation, SIGPLAN Notices 26, </booktitle> <month> 6 (June </month> <year> 1991), </year> <pages> pp. 165-176. </pages>
Reference-contexts: Also unlike previous work, we describe a real implementation and give some performance measurements. There has been much work on the generation and representation of object and stack layout 4 information by the compiler for the garbage collector. Recent examples include [DiwanMossHudson92] <ref> [Goldberg91] </ref>, and [Fradet94]. The idea is to generate static information (either tables or traversal functions) to communicate pointer locations to the garbage collector.
Reference: [HastingsJoyce92] <author> Hastings, Reed, and Bob Joyce, </author> <title> ``Fast Detection of Memory Leaks and Access Errors'', </title> <booktitle> Proceedings of the Winter '92 USENIX conference, </booktitle> <pages> pp. 125-136. </pages>
Reference-contexts: Admittedly the annotated program will incur a significant performance loss, at least without substantially more analysis than we perform. We expect such checking to be performed only during debugging, by analogy to the current use of systems like Purify <ref> [HastingsJoyce92] </ref>. Our checking is not completely accurate, since the garbage collector rounds up object sizes. But it is sufficient to ensure that on a machine with typical RISC alignment restrictions at most unused memory can be accidentally referenced through an incorrectly computed heap pointer to a primitive type. <p> Hence they are not performance competitive with conservative collectors, though the expense may be unavoidable in hard real-time environments [Edelson91]. There has been a substantial amount of work on safer C implementations (cf. <ref> [HastingsJoyce92] </ref>, [AustinBreachSohi94], [JonesKelly95].) Most of these have concentrated on detecting erroneous memory accesses, not erroneous pointer or subscript arithmetic. Though the two are related, the distinction is important.
Reference: [JonesKelly95] <author> Jones, Richard, and Paul Kelly, </author> <title> ``Bounds Checking for C'', </title> <address> http://www-ala.doc.ic.ac.uk/~phjk/BoundsChecking.html. </address>
Reference-contexts: Hence they are not performance competitive with conservative collectors, though the expense may be unavoidable in hard real-time environments [Edelson91]. There has been a substantial amount of work on safer C implementations (cf. [HastingsJoyce92], [AustinBreachSohi94], <ref> [JonesKelly95] </ref>.) Most of these have concentrated on detecting erroneous memory accesses, not erroneous pointer or subscript arithmetic. Though the two are related, the distinction is important. <p> Hence it is possible, indeed trivial, to use checked code with third party object-code-only libraries, or with faster, unchecked modules. Our checked code is very similar in spirit to recent independent work by Jones and Kelly <ref> [JonesKelly95] </ref>. The major differences are that we do not check references to statically allocated and stack memory, we use the garbage collectors data structures to determine whether two pointers reference the same object, and we take a different approach to inserting the checking code.
Reference: [Omohundro91] <author> Omohundro, Stephen M., </author> <title> The Sather Language, </title> <type> ICSI, </type> <institution> Berkeley, </institution> <year> 1991. </year>
Reference: [OTooleNettles94] <author> O'Toole, James, and Scott Nettles, </author> <title> ``Concurrent Replicating Garbage Collection'', </title> <booktitle> Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 34-42. </pages>
Reference: [RoseMuller92] <author> Rose, John R., and Hans Muller, </author> <title> ``Integrating the Scheme and C languages'', </title> <booktitle> Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 247-259. </pages>
Reference: [Rovner85] <author> Rovner, Paul, </author> <title> ``On Adding Garbage Collection and Runtime Types to a Strongly-Typed Statically Checked, Concurrent Language'', </title> <type> Technical Report CSL-84-7, </type> <institution> Xerox Palo Alto Research Center, </institution> <address> Palo Alto, CA, </address> <month> July </month> <year> 1985. </year>
Reference: [SchelterBallantyne88] <author> Schelter, W. F., and M. Ballantyne, </author> <title> ``Kyoto Common Lisp'', </title> <journal> AI Expert 3, </journal> <volume> 3 (1988), </volume> <pages> pp. 75-77. </pages>
References-found: 24

