URL: http://www.cs.brown.edu/courses/cs227/papers/b5/md-arrays.ps
Refering-URL: http://www.cs.brown.edu/courses/cs227/readinglist.html
Root-URL: http://www.cs.brown.edu/
Email: E-mail: libkin@research.att.com  E-mail: rona@saul.cis.upenn.edu  E-mail: limsoon@iss.nus.sg  
Title: A Query Language for Multidimensional Arrays: Design, Implementation, and Optimization Techniques  
Author: Leonid Libkin Rona Machlin Limsoon Wong Heng Mui Keng Terrace 
Address: 600 Mountain Avenue Murray Hill, NJ 07974  Philadelphia, PA 19104-6389, USA  0511  
Affiliation: AT&T Bell Laboratories  Dept. of Comp. and Info. Science University of Pennsylvania  Institute of Systems Science  Singapore  
Abstract: While much recent research has focused on extending databases beyond the traditional relational model, relatively little has been done to develop database tools for querying data organized in (multidimensional) arrays. Perhaps because the data models of existing DBMS's do not adequately support arrays, the scientific computing community has made little use of available database technology. Instead, multidimensional scientific data is typically stored in local files conforming to various data exchange formats and queried via specialized access libraries tied in to general purpose programming languages. To allow such data to be queried using known database techniques, we design and implement a query language for multidimensional arrays. Our main design decision is to treat arrays as functions from index sets to values rather than as collection types. This leads to both clean syntax and semantics as well as simple but powerful optimization rules. We present a calculus for arrays that extends standard calculi for complex objects. We derive a higher-level comprehension style query language based on this calculus and describe its implementation in ML, including a data driver for the NetCDF data exchange format. Next, we explore some optimization rules obtained from the equational laws of our core calculus. Finally, we study the expressiveness of our calculus and prove that it essentially corresponds to adding indices explicitly in a query language for complex objects be they based on sets, bags or lists.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Arvind, R.S. Nikhil, and K.K. Pingali. I-structures: </author> <title> Data structures for parallel computing. </title> <editor> In J. Fasel and R. M. Keller, editors, </editor> <booktitle> Proceedings of the Graph Reduction Workshop. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: There are several approaches that treat arrays as functions. These include Maier and Vance [21], who propose syntax similar to our tabulation construct. Constructs of the same flavor are used in a number 3 of functional language that provide support for arrays, see <ref> [25, 1, 14, 10] </ref>, and also in APL [15]. General techniques for reasoning about arrays were studied in [26]. The view of arrays as functions was also explored by [13] in the context of parallel computations. A number of proposals for object-oriented query languages include arrays, see [22, 9].
Reference: [2] <author> H. Barendregt. </author> <title> Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North Holland, </publisher> <year> 1984. </year>
Reference-contexts: These observations suggest that partial counterparts to the -calculus fi and reduction rules <ref> [2] </ref> might be applicable to arrays. We explore these and other normalization rules for the calculus in section 5. The only remaining construct other than index is the construct for errors. Recall that both e 1 [e 2 ] and get (e) can be undefined. <p> 2 ]][e 3 ] ; if e 3 &lt; e 2 then e 1 fi := e 3 g else ? ( p ) [[ e [i] j i &lt; len (e) ]] ; e The first two are partial versions of the lambda calculus fi and transition rules, cf. <ref> [2] </ref>. The third rule corresponds to partial function domain extraction.
Reference: [3] <author> C. Beeri and D.K.C. Chan. </author> <title> Bounded arrays: a bulk type perspective. </title> <type> Technical report, </type> <institution> Hebrew Univ., </institution> <year> 1995. </year>
Reference-contexts: By providing readers/writers for data exchange formats like NetDCF [27], we can tie our system in to "legacy" scientific data. Related work There have been several proposals for making arrays first class citizens in query languages. Most of these consider arrays as collection types. Beeri and Chan <ref> [3] </ref> propose an algebra for arrays, and Fegaras and Maier [9] include arrays into their object-oriented calculus. Both approaches allow constructs in which multiple values can be assigned to the same index. However, they solve the problem differently. <p> We choose to work within this simpler type framework in order to focus on the semantics of arrays; however, we see no obstacle to extending our model to a richer type system. What do we take multidimensional arrays to be in our model? We differ from others <ref> [3, 4, 11, 30, 31, 8] </ref> in that we do not treat arrays as collection types but rather as partial functions of finite, "rectangular" domain. As we shall see, this approach yields an elegant syntax and inspires some simple but powerful optimization rules.
Reference: [4] <author> P. Buneman. </author> <title> The fast Fourier transform as a database query. </title> <type> Technical Report MS-CIS-93-37/L&C 60, </type> <institution> University of Pennsylvania, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: However, they solve the problem differently. Beeri and Chan's approach is to introduce run-time checks, while Fegaras and Maier use predefined operations to merge different values assigned to the same index. Consequently, arrays become dependent on the choice of merge operation. Buneman <ref> [4] </ref> shows how to encode fast Fourier transform as a database query in comprehension style. His constructs allow him to avoid the problem mentioned above. However, his approach does not give us languages with adequate expressive power. For example, operations involving permutations of indices cannot be expressed. <p> We choose to work within this simpler type framework in order to focus on the semantics of arrays; however, we see no obstacle to extending our model to a richer type system. What do we take multidimensional arrays to be in our model? We differ from others <ref> [3, 4, 11, 30, 31, 8] </ref> in that we do not treat arrays as collection types but rather as partial functions of finite, "rectangular" domain. As we shall see, this approach yields an elegant syntax and inspires some simple but powerful optimization rules. <p> Using the algebras of functions, we show that they can be translated into each other, and are thus equivalent modulo the translation above. To give a more intuitive characterization of the expressive power of N RCA, we follow the idea of <ref> [4] </ref>, and replace the construct S fe 1 j x 2 e 2 g with ; x : s; i : N ` e 1 : ftg ` e 2 : fsg S that has the following semantics.
Reference: [5] <author> P. Buneman, S. Davidson, K. Hart, C. Overton, L. Wong. </author> <title> A data transformation system for biological data sources. </title> <booktitle> In VLDB'95, </booktitle> <pages> pages 158-169. </pages>
Reference-contexts: It is based on the architecture of CPL/Kleisli, an open query system implementing N RC, see <ref> [5, 33] </ref>. <p> We will discuss only the normalization phase of the optimizer. The normalization rules for sets, tuples, and conditionals come from the equational theory of N RC, described in [7, 34, 33]. They include rules for vertical and horizontal fusion of set loops, filter promotion, and column reduction <ref> [5] </ref>. The rules for summation and arithmetic come from an extension of N RC to arithmetic given in [17]. Here, we 14 describe the new rules for arrays.
Reference: [6] <author> P. Buneman, L. Libkin, D. Suciu, V. Tannen, and L. Wong. </author> <title> Comprehension syntax. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 23(1) </volume> <pages> 87-96, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Our data model combines complex objects with multidimensional arrays. Complex objects are usually taken to mean free nestings of collections, such as sets, bags, and lists, with records and variants. They also often encorporate some notion of object identity. Such types have been studied extensively elsewhere <ref> [7, 6, 8, 9, 16, 18, 31] </ref>. Here, we restrict our attention to complex objects formed via free nestings of sets and tuples, that is, to nested relations. <p> We now present the constructs of N RCA, our nested relational calculus with arrays. N RCA is an extension of the nested relational calculus N RC [7]. We chose this presentation of nested relations because it leads to an appealing comprehension syntax <ref> [6, 9] </ref> and because it comes with an equational theory that gives us useful optimizations [7, 33, 34]. We will touch on these aspects of the calculus in sections 3 and 5. The constructs of N RC and their typing rules are given in the top third of figure 1. <p> Before going on to describe our implementation, we consider two more issues: how to express complex object values in our language and whether we should add any derived operators to our language as primitives. Comprehensions. A set comprehension <ref> [6, 32] </ref> has the form fe j GF 1 ; : : : ; GF n g, where each GF i is either a generator nx &lt;- e or a filter (i.e., Boolean-valued expression) e. <p> For example, fi j [ni : nx] &lt;- A; x &gt; 90g picks out those positions in A whose values exceed 90. Pattern Matching. The slashed variables that occur in comprehension generators are examples of patterns, cf. <ref> [6] </ref>. In particular, nx is a pattern that matches anything and binds it to x.
Reference: [7] <author> P. Buneman, S. Naqvi, V. Tannen and L. Wong. </author> <title> Principles of programming with complex objects and collection types. </title> <journal> Theoretical Computer Science, </journal> <volume> 149(1) </volume> <pages> 3-48, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Our data model combines complex objects with multidimensional arrays. Complex objects are usually taken to mean free nestings of collections, such as sets, bags, and lists, with records and variants. They also often encorporate some notion of object identity. Such types have been studied extensively elsewhere <ref> [7, 6, 8, 9, 16, 18, 31] </ref>. Here, we restrict our attention to complex objects formed via free nestings of sets and tuples, that is, to nested relations. <p> The object function types are types t 1 ! t 2 , where t 1 , t 2 are object types. We now present the constructs of N RCA, our nested relational calculus with arrays. N RCA is an extension of the nested relational calculus N RC <ref> [7] </ref>. We chose this presentation of nested relations because it leads to an appealing comprehension syntax [6, 9] and because it comes with an equational theory that gives us useful optimizations [7, 33, 34]. We will touch on these aspects of the calculus in sections 3 and 5. <p> N RCA is an extension of the nested relational calculus N RC [7]. We chose this presentation of nested relations because it leads to an appealing comprehension syntax [6, 9] and because it comes with an equational theory that gives us useful optimizations <ref> [7, 33, 34] </ref>. We will touch on these aspects of the calculus in sections 3 and 5. The constructs of N RC and their typing rules are given in the top third of figure 1. Here, we briefly review their meanings. The constructs for functions are standard. <p> The rule bases, the rule application strategies, and the number of phases of this optimizer are extensible. We will discuss only the normalization phase of the optimizer. The normalization rules for sets, tuples, and conditionals come from the equational theory of N RC, described in <ref> [7, 34, 33] </ref>. They include rules for vertical and horizontal fusion of set loops, filter promotion, and column reduction [5]. The rules for summation and arithmetic come from an extension of N RC to arithmetic given in [17]. Here, we 14 describe the new rules for arrays.
Reference: [8] <author> R.G.G. Cattell, ed. </author> <title> The Object Database Standard: ODMG-93. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: The view of arrays as functions was also explored by [13] in the context of parallel computations. A number of proposals for object-oriented query languages include arrays, see [22, 9]. The ODMG proposal includes one-dimensional arrays with a limited set of supported operations <ref> [8] </ref>. Vandenberg and DeWitt propose an object-oriented algebra supporting arrays in addition to other constructs [31, 30]. They only treat one-dimensional arrays. The array operations in [31, 30] are very similar to typical list operations, but also include operations for array subscripting. Organization. <p> Our data model combines complex objects with multidimensional arrays. Complex objects are usually taken to mean free nestings of collections, such as sets, bags, and lists, with records and variants. They also often encorporate some notion of object identity. Such types have been studied extensively elsewhere <ref> [7, 6, 8, 9, 16, 18, 31] </ref>. Here, we restrict our attention to complex objects formed via free nestings of sets and tuples, that is, to nested relations. <p> We choose to work within this simpler type framework in order to focus on the semantics of arrays; however, we see no obstacle to extending our model to a richer type system. What do we take multidimensional arrays to be in our model? We differ from others <ref> [3, 4, 11, 30, 31, 8] </ref> in that we do not treat arrays as collection types but rather as partial functions of finite, "rectangular" domain. As we shall see, this approach yields an elegant syntax and inspires some simple but powerful optimization rules.
Reference: [9] <author> L. Fegaras and D. Maier. </author> <title> Towards an effective calculus for object query languages. </title> <booktitle> In Proceedings of ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 47-58, </pages> <year> 1995. </year>
Reference-contexts: Related work There have been several proposals for making arrays first class citizens in query languages. Most of these consider arrays as collection types. Beeri and Chan [3] propose an algebra for arrays, and Fegaras and Maier <ref> [9] </ref> include arrays into their object-oriented calculus. Both approaches allow constructs in which multiple values can be assigned to the same index. However, they solve the problem differently. <p> General techniques for reasoning about arrays were studied in [26]. The view of arrays as functions was also explored by [13] in the context of parallel computations. A number of proposals for object-oriented query languages include arrays, see <ref> [22, 9] </ref>. The ODMG proposal includes one-dimensional arrays with a limited set of supported operations [8]. Vandenberg and DeWitt propose an object-oriented algebra supporting arrays in addition to other constructs [31, 30]. They only treat one-dimensional arrays. <p> Our data model combines complex objects with multidimensional arrays. Complex objects are usually taken to mean free nestings of collections, such as sets, bags, and lists, with records and variants. They also often encorporate some notion of object identity. Such types have been studied extensively elsewhere <ref> [7, 6, 8, 9, 16, 18, 31] </ref>. Here, we restrict our attention to complex objects formed via free nestings of sets and tuples, that is, to nested relations. <p> We now present the constructs of N RCA, our nested relational calculus with arrays. N RCA is an extension of the nested relational calculus N RC [7]. We chose this presentation of nested relations because it leads to an appealing comprehension syntax <ref> [6, 9] </ref> and because it comes with an equational theory that gives us useful optimizations [7, 33, 34]. We will touch on these aspects of the calculus in sections 3 and 5. The constructs of N RC and their typing rules are given in the top third of figure 1. <p> for arrays: 1: [[ ]] = [[i j i &lt; 0]] 3: A@B = [[ if i &lt; len (A) then A [i] elseB [i : len (A)] j i &lt; len (A) + len (B)]] and observe that like the corresponding set operations, these operations form a monoid, cf. <ref> [9] </ref>. Then we set [[e 1 ; : : : ; e n ]] = [[e 1 ]]@ @[[e n ]].
Reference: [10] <author> J. Feo. </author> <title> Arrays in Sisal. </title> <booktitle> In Proc. Workshop on Arrays, Functional Languages and Parallel Systems, </booktitle> <editor> L. Mullin et.al. eds., </editor> <publisher> Kluwer Academic Publishers, </publisher> <year> 1990. </year>
Reference-contexts: There are several approaches that treat arrays as functions. These include Maier and Vance [21], who propose syntax similar to our tabulation construct. Constructs of the same flavor are used in a number 3 of functional language that provide support for arrays, see <ref> [25, 1, 14, 10] </ref>, and also in APL [15]. General techniques for reasoning about arrays were studied in [26]. The view of arrays as functions was also explored by [13] in the context of parallel computations. A number of proposals for object-oriented query languages include arrays, see [22, 9].
Reference: [11] <author> S. Greco, P. Palopoli and E. Spadafora. </author> <title> Datalog A : Array manipulations in a deductive database language. </title> <booktitle> In Proc. 4th Conf. on Database Systems for Advanced Applications, </booktitle> <pages> pages 180-188, </pages> <year> 1995. </year>
Reference-contexts: His constructs allow him to avoid the problem mentioned above. However, his approach does not give us languages with adequate expressive power. For example, operations involving permutations of indices cannot be expressed. Greco, Palopoli and Spadafora <ref> [11] </ref> propose to add multidimensional arrays to datalog. They give fixpoint semantics for their language and study optimizations. Extensions of datalog with sequences, which are similar to one-dimensional arrays, are studied in recent papers of Mecca and Bonner [23, 24]. <p> We choose to work within this simpler type framework in order to focus on the semantics of arrays; however, we see no obstacle to extending our model to a richer type system. What do we take multidimensional arrays to be in our model? We differ from others <ref> [3, 4, 11, 30, 31, 8] </ref> in that we do not treat arrays as collection types but rather as partial functions of finite, "rectangular" domain. As we shall see, this approach yields an elegant syntax and inspires some simple but powerful optimization rules.
Reference: [12] <author> S. Grumbach and T. Milo. </author> <title> Towards tractable algebras for bags. </title> <booktitle> In PODS'93, </booktitle> <pages> pages 49-58. </pages>
Reference-contexts: The semantics is the same as before except that the operation ] is used for bags and t for lists. The language N BC and its extensions have been studied extensively in the past few years, see <ref> [12, 18, 19] </ref>. The language N LC can be used as a starting point for designing list query languages, but by itself it does not possess enough power. For example, head and tail of a list cannot be defined in it.
Reference: [13] <author> P. Hammarlund and B. Lisper. </author> <title> On the relation between functional and data parallel programming languages. </title> <booktitle> In Proceedings of the ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 210-219, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Constructs of the same flavor are used in a number 3 of functional language that provide support for arrays, see [25, 1, 14, 10], and also in APL [15]. General techniques for reasoning about arrays were studied in [26]. The view of arrays as functions was also explored by <ref> [13] </ref> in the context of parallel computations. A number of proposals for object-oriented query languages include arrays, see [22, 9]. The ODMG proposal includes one-dimensional arrays with a limited set of supported operations [8]. Vandenberg and DeWitt propose an object-oriented algebra supporting arrays in addition to other constructs [31, 30].
Reference: [14] <author> P. Hudak and P. Wadler. </author> <title> Report on the programming language Haskell. </title> <type> Technical Report, </type> <institution> Glasgow University, </institution> <address> Glasgow G12 8QQ, Scotland, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: There are several approaches that treat arrays as functions. These include Maier and Vance [21], who propose syntax similar to our tabulation construct. Constructs of the same flavor are used in a number 3 of functional language that provide support for arrays, see <ref> [25, 1, 14, 10] </ref>, and also in APL [15]. General techniques for reasoning about arrays were studied in [26]. The view of arrays as functions was also explored by [13] in the context of parallel computations. A number of proposals for object-oriented query languages include arrays, see [22, 9].
Reference: [15] <author> K. E. Iverson. </author> <title> A Programming Language. </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1962. </year>
Reference-contexts: These include Maier and Vance [21], who propose syntax similar to our tabulation construct. Constructs of the same flavor are used in a number 3 of functional language that provide support for arrays, see [25, 1, 14, 10], and also in APL <ref> [15] </ref>. General techniques for reasoning about arrays were studied in [26]. The view of arrays as functions was also explored by [13] in the context of parallel computations. A number of proposals for object-oriented query languages include arrays, see [22, 9].
Reference: [16] <author> T. W. Leung, G. Mitchell, B. Subramaniam, B. Vance, S. Vandenberg, and S. B. Zdonik. </author> <title> The AQUA data model and algebra. </title> <booktitle> In Proc. 4th Int. Workshop on Database Programming Languages, </booktitle> <address> September 1993, </address> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Extensions of datalog with sequences, which are similar to one-dimensional arrays, are studied in recent papers of Mecca and Bonner [23, 24]. They are interested in giving restrictions on the programs that ensure finiteness of the results. Other work on sequences in query languages includes <ref> [16, 28, 29] </ref>. In [28, 29] sequences are viewed as maps from linear orders to values, which is close to our approach of viewing arrays as functions. There are several approaches that treat arrays as functions. These include Maier and Vance [21], who propose syntax similar to our tabulation construct. <p> Our data model combines complex objects with multidimensional arrays. Complex objects are usually taken to mean free nestings of collections, such as sets, bags, and lists, with records and variants. They also often encorporate some notion of object identity. Such types have been studied extensively elsewhere <ref> [7, 6, 8, 9, 16, 18, 31] </ref>. Here, we restrict our attention to complex objects formed via free nestings of sets and tuples, that is, to nested relations.
Reference: [17] <author> L. Libkin and L. Wong. </author> <title> Aggregate functions, conservative extensions, and linear orders. </title> <booktitle> In Proc. 4th Int. Workshop on Database Programming Languages, </booktitle> <address> September 1993, </address> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: They include rules for vertical and horizontal fusion of set loops, filter promotion, and column reduction [5]. The rules for summation and arithmetic come from an extension of N RC to arithmetic given in <ref> [17] </ref>. Here, we 14 describe the new rules for arrays. Since the syntax for arrays was inspired by viewing them as functions, it is not surprising that the rules for arrays are also based on this view of arrays as (partial) functions.
Reference: [18] <author> L. Libkin and L. Wong. </author> <title> Some properties of query languages for bags. </title> <booktitle> In Proc. 4th Int. Workshop on Database Programming Languages, </booktitle> <address> September 1993, </address> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Our data model combines complex objects with multidimensional arrays. Complex objects are usually taken to mean free nestings of collections, such as sets, bags, and lists, with records and variants. They also often encorporate some notion of object identity. Such types have been studied extensively elsewhere <ref> [7, 6, 8, 9, 16, 18, 31] </ref>. Here, we restrict our attention to complex objects formed via free nestings of sets and tuples, that is, to nested relations. <p> These algebras are derived from the calculi in the same manner as relational algebra is derived from relational calculus. The algebra of functions corresponding to N RC aggr has been presented in <ref> [18] </ref>. For N RCA we derive a similar algebra by adding a number of functions to handle the array operations. For example, there is a function mk arr (f ) : N ! [[t]], provided f is of type N ! t. <p> The semantics is the same as before except that the operation ] is used for bags and t for lists. The language N BC and its extensions have been studied extensively in the past few years, see <ref> [12, 18, 19] </ref>. The language N LC can be used as a starting point for designing list query languages, but by itself it does not possess enough power. For example, head and tail of a list cannot be defined in it.
Reference: [19] <author> L. Libkin and L. Wong. </author> <title> New techniques for studying set languages, bag languages and aggregate functions. </title> <booktitle> In PODS'94, </booktitle> <pages> pages 155-166. </pages>
Reference-contexts: This language can be viewed as a "theoretical reconstruction" of SQL. Indeed, it has both features that distinguish all implementations of SQL from purely relational languages, that is, groupby and aggregate functions. In fact, N RC aggr was used in <ref> [19] </ref> to study limitations of expressive power of SQL. Our first result characterizes the expressive power of N RCA as that of N RC aggr (gen) (we list extra primitives in parentheses). <p> The semantics is the same as before except that the operation ] is used for bags and t for lists. The language N BC and its extensions have been studied extensively in the past few years, see <ref> [12, 18, 19] </ref>. The language N LC can be used as a starting point for designing list query languages, but by itself it does not possess enough power. For example, head and tail of a list cannot be defined in it.
Reference: [20] <author> L. Libkin and L. Wong. </author> <title> Conservativity of nested relational calculi with internal generic functions. </title> <journal> Information Processing Letters, </journal> <volume> 49(6) </volume> <pages> 273-280, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: an array, dim k (e) for extracting the dimensions of an array, and index k (e) for converting an 3 Note that from an expressivity standpoint we need only include =; over the base types, because their liftings to all other complex object types will be definable in N RCA <ref> [20, 34] </ref>. 5 N RC constructs Functions and k-ary Products (k 2) ; x : s ` x : s ` x:e : s ! t ` e 1 (e 2 ) : t ` (e 1 ; : : : ; e k ) : t 1 fi fi t
Reference: [21] <author> D. Maier and B. Vance. </author> <title> A call to order. </title> <booktitle> In Proceedings of 12th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-16, </pages> <address> Washington, D. C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Data organized into multidimensional arrays arises naturally in a variety of scientific disciplines. Yet the array type has received little attention in most recent database research on data models and query languages. In their 1993 wake-up call to the database research community <ref> [21] </ref>, Maier and Vance argue that lack of adequate support for arrays in existing DBMS's is one of the reasons the scientific computing community has made little use of database technology. Instead, multidimensional scientific data is typically stored in local files using specialized data exchange formats. <p> Other work on sequences in query languages includes [16, 28, 29]. In [28, 29] sequences are viewed as maps from linear orders to values, which is close to our approach of viewing arrays as functions. There are several approaches that treat arrays as functions. These include Maier and Vance <ref> [21] </ref>, who propose syntax similar to our tabulation construct. Constructs of the same flavor are used in a number 3 of functional language that provide support for arrays, see [25, 1, 14, 10], and also in APL [15]. General techniques for reasoning about arrays were studied in [26].
Reference: [22] <author> D. Maier and D. Hansen. </author> <title> Bambi meets Godzilla: Object databases for scientific computing. </title> <booktitle> In Proc. 7th Working Conference on Scientific and Statistical Database Management, </booktitle> <year> 1994, </year> <pages> pages 176-184. </pages>
Reference-contexts: General techniques for reasoning about arrays were studied in [26]. The view of arrays as functions was also explored by [13] in the context of parallel computations. A number of proposals for object-oriented query languages include arrays, see <ref> [22, 9] </ref>. The ODMG proposal includes one-dimensional arrays with a limited set of supported operations [8]. Vandenberg and DeWitt propose an object-oriented algebra supporting arrays in addition to other constructs [31, 30]. They only treat one-dimensional arrays.
Reference: [23] <author> G. Mecca and A. Bonner. </author> <title> Sequences, datalog and transducers. </title> <booktitle> In PODS'95, </booktitle> <pages> pages 23-35. 19 </pages>
Reference-contexts: Greco, Palopoli and Spadafora [11] propose to add multidimensional arrays to datalog. They give fixpoint semantics for their language and study optimizations. Extensions of datalog with sequences, which are similar to one-dimensional arrays, are studied in recent papers of Mecca and Bonner <ref> [23, 24] </ref>. They are interested in giving restrictions on the programs that ensure finiteness of the results. Other work on sequences in query languages includes [16, 28, 29].
Reference: [24] <author> G. Mecca and A. Bonner. </author> <title> Finite query languages for sequence databases. </title> <note> In DBPL'95, to appear. </note>
Reference-contexts: Greco, Palopoli and Spadafora [11] propose to add multidimensional arrays to datalog. They give fixpoint semantics for their language and study optimizations. Extensions of datalog with sequences, which are similar to one-dimensional arrays, are studied in recent papers of Mecca and Bonner <ref> [23, 24] </ref>. They are interested in giving restrictions on the programs that ensure finiteness of the results. Other work on sequences in query languages includes [16, 28, 29].
Reference: [25] <author> R. Milner, M. Tofte, R. Harper. </author> <title> "The Definition of Standard ML". </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass, </address> <year> 1990. </year>
Reference-contexts: There are several approaches that treat arrays as functions. These include Maier and Vance [21], who propose syntax similar to our tabulation construct. Constructs of the same flavor are used in a number 3 of functional language that provide support for arrays, see <ref> [25, 1, 14, 10] </ref>, and also in APL [15]. General techniques for reasoning about arrays were studied in [26]. The view of arrays as functions was also explored by [13] in the context of parallel computations. A number of proposals for object-oriented query languages include arrays, see [22, 9]. <p> We even allow new data readers and writers to be added dynamically, so our language can easily be adapted to specific application domains. 4 Implementation We have developed a prototype system implementing AQL using Standard ML (SML) <ref> [25] </ref>.
Reference: [26] <author> T. </author> <title> More. Axioms and theorems for a theory of arrays. IBM J. Res. </title> <booktitle> and Development 17 (1973), </booktitle> <pages> 135-175. </pages>
Reference-contexts: Constructs of the same flavor are used in a number 3 of functional language that provide support for arrays, see [25, 1, 14, 10], and also in APL [15]. General techniques for reasoning about arrays were studied in <ref> [26] </ref>. The view of arrays as functions was also explored by [13] in the context of parallel computations. A number of proposals for object-oriented query languages include arrays, see [22, 9]. The ODMG proposal includes one-dimensional arrays with a limited set of supported operations [8].
Reference: [27] <author> R. Rew, G. Davis and S. Emmerson. </author> <title> NetCDF User's Guide, </title> <institution> Unidata Program Center, </institution> <year> 1993. </year>
Reference-contexts: For this reason, our implementation emphasizes openness that is, the capability to dynamically inject domain specific external primitives, data readers/writers, and optimization rules into our system. By providing readers/writers for data exchange formats like NetDCF <ref> [27] </ref>, we can tie our system in to "legacy" scientific data. Related work There have been several proposals for making arrays first class citizens in query languages. Most of these consider arrays as collection types.
Reference: [28] <author> P. Seshadri, M. Livny and R.Ramakrishnan. </author> <title> Sequence query processing. </title> <booktitle> In SIGMOD'94. </booktitle>
Reference-contexts: Extensions of datalog with sequences, which are similar to one-dimensional arrays, are studied in recent papers of Mecca and Bonner [23, 24]. They are interested in giving restrictions on the programs that ensure finiteness of the results. Other work on sequences in query languages includes <ref> [16, 28, 29] </ref>. In [28, 29] sequences are viewed as maps from linear orders to values, which is close to our approach of viewing arrays as functions. There are several approaches that treat arrays as functions. These include Maier and Vance [21], who propose syntax similar to our tabulation construct. <p> Extensions of datalog with sequences, which are similar to one-dimensional arrays, are studied in recent papers of Mecca and Bonner [23, 24]. They are interested in giving restrictions on the programs that ensure finiteness of the results. Other work on sequences in query languages includes [16, 28, 29]. In <ref> [28, 29] </ref> sequences are viewed as maps from linear orders to values, which is close to our approach of viewing arrays as functions. There are several approaches that treat arrays as functions. These include Maier and Vance [21], who propose syntax similar to our tabulation construct.
Reference: [29] <author> P. Seshadri, M. Livny and R.Ramakrishnan. SEQ: </author> <title> a model for sequence databases. </title> <type> Technical report, </type> <institution> Univ. of Wisconsin, </institution> <year> 1994. </year>
Reference-contexts: Extensions of datalog with sequences, which are similar to one-dimensional arrays, are studied in recent papers of Mecca and Bonner [23, 24]. They are interested in giving restrictions on the programs that ensure finiteness of the results. Other work on sequences in query languages includes <ref> [16, 28, 29] </ref>. In [28, 29] sequences are viewed as maps from linear orders to values, which is close to our approach of viewing arrays as functions. There are several approaches that treat arrays as functions. These include Maier and Vance [21], who propose syntax similar to our tabulation construct. <p> Extensions of datalog with sequences, which are similar to one-dimensional arrays, are studied in recent papers of Mecca and Bonner [23, 24]. They are interested in giving restrictions on the programs that ensure finiteness of the results. Other work on sequences in query languages includes [16, 28, 29]. In <ref> [28, 29] </ref> sequences are viewed as maps from linear orders to values, which is close to our approach of viewing arrays as functions. There are several approaches that treat arrays as functions. These include Maier and Vance [21], who propose syntax similar to our tabulation construct.
Reference: [30] <author> S. Vandenberg. </author> <title> Algebras for Object-Oriented Query Languages. </title> <type> PhD thesis, </type> <institution> Univ. of Wisconsin, </institution> <year> 1993. </year>
Reference-contexts: A number of proposals for object-oriented query languages include arrays, see [22, 9]. The ODMG proposal includes one-dimensional arrays with a limited set of supported operations [8]. Vandenberg and DeWitt propose an object-oriented algebra supporting arrays in addition to other constructs <ref> [31, 30] </ref>. They only treat one-dimensional arrays. The array operations in [31, 30] are very similar to typical list operations, but also include operations for array subscripting. Organization. In section 2 we describe the design of a nested relational calculus for arrays, N RCA. <p> The ODMG proposal includes one-dimensional arrays with a limited set of supported operations [8]. Vandenberg and DeWitt propose an object-oriented algebra supporting arrays in addition to other constructs <ref> [31, 30] </ref>. They only treat one-dimensional arrays. The array operations in [31, 30] are very similar to typical list operations, but also include operations for array subscripting. Organization. In section 2 we describe the design of a nested relational calculus for arrays, N RCA. <p> We choose to work within this simpler type framework in order to focus on the semantics of arrays; however, we see no obstacle to extending our model to a richer type system. What do we take multidimensional arrays to be in our model? We differ from others <ref> [3, 4, 11, 30, 31, 8] </ref> in that we do not treat arrays as collection types but rather as partial functions of finite, "rectangular" domain. As we shall see, this approach yields an elegant syntax and inspires some simple but powerful optimization rules.
Reference: [31] <author> S. Vandenberg and D. DeWitt. </author> <title> Algebraic support for complex objects with arrays, identity and inheritance. </title> <booktitle> In SIGMOD'91, </booktitle> <pages> pages 158-167. </pages>
Reference-contexts: A number of proposals for object-oriented query languages include arrays, see [22, 9]. The ODMG proposal includes one-dimensional arrays with a limited set of supported operations [8]. Vandenberg and DeWitt propose an object-oriented algebra supporting arrays in addition to other constructs <ref> [31, 30] </ref>. They only treat one-dimensional arrays. The array operations in [31, 30] are very similar to typical list operations, but also include operations for array subscripting. Organization. In section 2 we describe the design of a nested relational calculus for arrays, N RCA. <p> The ODMG proposal includes one-dimensional arrays with a limited set of supported operations [8]. Vandenberg and DeWitt propose an object-oriented algebra supporting arrays in addition to other constructs <ref> [31, 30] </ref>. They only treat one-dimensional arrays. The array operations in [31, 30] are very similar to typical list operations, but also include operations for array subscripting. Organization. In section 2 we describe the design of a nested relational calculus for arrays, N RCA. <p> Our data model combines complex objects with multidimensional arrays. Complex objects are usually taken to mean free nestings of collections, such as sets, bags, and lists, with records and variants. They also often encorporate some notion of object identity. Such types have been studied extensively elsewhere <ref> [7, 6, 8, 9, 16, 18, 31] </ref>. Here, we restrict our attention to complex objects formed via free nestings of sets and tuples, that is, to nested relations. <p> We choose to work within this simpler type framework in order to focus on the semantics of arrays; however, we see no obstacle to extending our model to a richer type system. What do we take multidimensional arrays to be in our model? We differ from others <ref> [3, 4, 11, 30, 31, 8] </ref> in that we do not treat arrays as collection types but rather as partial functions of finite, "rectangular" domain. As we shall see, this approach yields an elegant syntax and inspires some simple but powerful optimization rules.
Reference: [32] <author> P. Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proc. ACM Conf. on Lisp and Functional Progr., </booktitle> <address> Nice, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Before going on to describe our implementation, we consider two more issues: how to express complex object values in our language and whether we should add any derived operators to our language as primitives. Comprehensions. A set comprehension <ref> [6, 32] </ref> has the form fe j GF 1 ; : : : ; GF n g, where each GF i is either a generator nx &lt;- e or a filter (i.e., Boolean-valued expression) e.
Reference: [33] <author> L. Wong. </author> <title> Querying Nested Collections. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: N RCA is an extension of the nested relational calculus N RC [7]. We chose this presentation of nested relations because it leads to an appealing comprehension syntax [6, 9] and because it comes with an equational theory that gives us useful optimizations <ref> [7, 33, 34] </ref>. We will touch on these aspects of the calculus in sections 3 and 5. The constructs of N RC and their typing rules are given in the top third of figure 1. Here, we briefly review their meanings. The constructs for functions are standard. <p> Yet they are merely a syntactic convenience; like comprehensions, patterns can be translated away, as shown in the second table in figure 2, cf. <ref> [33] </ref>. Here nz is a fresh variable, CX is the constant or non-binding variable that occurs leftmost in P , and N ewP is P with this leftmost occurrence of CX replaced by nz. Blocks. Another syntactic convenience is the ability to define local variables. <p> It is based on the architecture of CPL/Kleisli, an open query system implementing N RC, see <ref> [5, 33] </ref>. <p> The rule bases, the rule application strategies, and the number of phases of this optimizer are extensible. We will discuss only the normalization phase of the optimizer. The normalization rules for sets, tuples, and conditionals come from the equational theory of N RC, described in <ref> [7, 34, 33] </ref>. They include rules for vertical and horizontal fusion of set loops, filter promotion, and column reduction [5]. The rules for summation and arithmetic come from an extension of N RC to arithmetic given in [17]. Here, we 14 describe the new rules for arrays.
Reference: [34] <author> L. Wong. </author> <title> Normal forms and conservative extension properties for query languages over collection types. </title> <journal> JCSS, </journal> <note> to appear. Extended abstract in PODS'93. 20 </note>
Reference-contexts: N RCA is an extension of the nested relational calculus N RC [7]. We chose this presentation of nested relations because it leads to an appealing comprehension syntax [6, 9] and because it comes with an equational theory that gives us useful optimizations <ref> [7, 33, 34] </ref>. We will touch on these aspects of the calculus in sections 3 and 5. The constructs of N RC and their typing rules are given in the top third of figure 1. Here, we briefly review their meanings. The constructs for functions are standard. <p> an array, dim k (e) for extracting the dimensions of an array, and index k (e) for converting an 3 Note that from an expressivity standpoint we need only include =; over the base types, because their liftings to all other complex object types will be definable in N RCA <ref> [20, 34] </ref>. 5 N RC constructs Functions and k-ary Products (k 2) ; x : s ` x : s ` x:e : s ! t ` e 1 (e 2 ) : t ` (e 1 ; : : : ; e k ) : t 1 fi fi t <p> The rule bases, the rule application strategies, and the number of phases of this optimizer are extensible. We will discuss only the normalization phase of the optimizer. The normalization rules for sets, tuples, and conditionals come from the equational theory of N RC, described in <ref> [7, 34, 33] </ref>. They include rules for vertical and horizontal fusion of set loops, filter promotion, and column reduction [5]. The rules for summation and arithmetic come from an extension of N RC to arithmetic given in [17]. Here, we 14 describe the new rules for arrays.
References-found: 34

