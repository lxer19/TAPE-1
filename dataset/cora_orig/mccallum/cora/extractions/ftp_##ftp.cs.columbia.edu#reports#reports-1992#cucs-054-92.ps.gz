URL: ftp://ftp.cs.columbia.edu/reports/reports-1992/cucs-054-92.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1992.html
Root-URL: http://www.cs.columbia.edu
Title: Efficient Comparison Based String Matching  
Author: Dany Breslauer Zvi Galil 
Keyword: m c symbol comparisons,  
Note: for m 2 k 1 and any integer k 1.  
Address: CUCS-054-92  
Affiliation: CWI  Columbia University and Tel-Aviv University  
Abstract: We study the exact number of symbol comparisons that are required to solve the string matching problem and present a family of efficient algorithms. Unlike previous string matching algorithms, the algorithms in this family do not "forget" results of comparisons, what makes their analysis much simpler. In particular, we give a linear-time algorithm that finds all occurrences of a pattern of length m in a text of length n in n + d 4 log m+2 m (n m)e comparisons 1 . The pattern preprocessing takes linear time and makes at most 2m comparisons. This algorithm establishes that, in general, searching for a long pattern is easier than searching for a short one. We also show that any algorithm in the family of the algorithms presented must make at least n + blog mcb nm
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho. </author> <title> Algorithms for finding pattern in strings. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 257-300. </pages> <publisher> Elsevier Science Publishers B. V., </publisher> <address> Amsterdam, the Netherlands, </address> <year> 1990. </year>
Reference-contexts: Several algorithms solve the string matching problem in linear time. For a survey on string matching algorithms see Aho's paper <ref> [1] </ref>. Most of these algorithms work in two steps: in the first step the pattern is preprocessed and some information is stored and used later in a text processing step. The Knuth-Morris-Pratt [19] algorithm makes at most 2n comparisons in its text processing step. <p> Lemma 6.3 ^ [1::m] can be computed in O (m) time without additional comparisons. Proof: The array ^ [1::m] can be computed by the following recurrence. ^ <ref> [1] </ref> = 1 ( P [1::!1] P [1::!] ^ [! 1 ] + 1 if 1 = !. Obviously ^ [1] = 1. <p> Lemma 6.3 ^ [1::m] can be computed in O (m) time without additional comparisons. Proof: The array ^ [1::m] can be computed by the following recurrence. ^ <ref> [1] </ref> = 1 ( P [1::!1] P [1::!] ^ [! 1 ] + 1 if 1 = !. Obviously ^ [1] = 1. If P [1::!] 1 &lt; !, then by the definition of a period P [!] = P [! P [1::!] and ^ [!] = ^ [! 1 ].
Reference: [2] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA., </address> <year> 1974. </year>
Reference-contexts: We are interested in the exact number of comparisons rather then in an asymptotic bound. The study of the exact number of comparisons that are required to solve a problem is not new; there is an extensive study on order statistics problems <ref> [2, 4, 12, 16, 17, 18, 20, 21, 22, 23] </ref>. Several algorithms solve the string matching problem in linear time. For a survey on string matching algorithms see Aho's paper [1]. <p> a text string of length n exactly n successful comparisons and at least k 1 = blog mc unsuccessful comparisons every m positions. 2 6 Implementation Details In this section we show that the general alphabet algorithm can be implemented in the standard random access machine model with uniform cost <ref> [2] </ref> in linear time with a linear time pattern preprocessing step that makes at most 2m comparisons. The comparisons made in the pattern preprocessing step of the Knuth-Morris-Pratt [19] algorithm are the only comparisons required for the pattern preprocessing of our algorithm.
Reference: [3] <author> A. Apostolico and R. Giancarlo. </author> <title> The Boyer-Moore-Galil string searching strategies revisited. </title> <journal> SIAM J. Comput., </journal> <volume> 15(1) </volume> <pages> 98-105, </pages> <year> 1986. </year>
Reference-contexts: The Boyer-Moore algorithm makes about 3n comparisons in the worst case as proved recently by Cole [8], but performs better in practice. A variant of that algorithm which makes 2n comparisons was designed by Apostolico and Giancarlo <ref> [3] </ref>. <p> On the other hand, an off-line algorithm has access to the whole text. Colussi [10] showed that the string matching problem can be solved using 1:5n :5 (m 1) comparisons improving the best previous bound of 2n m comparisons <ref> [3, 5, 11, 19] </ref>.
Reference: [4] <author> S. W. Bent and J. W. John. </author> <title> Finding the median requires 2n comparisons. </title> <booktitle> In Proc. 17th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 213-216, </pages> <year> 1985. </year>
Reference-contexts: We are interested in the exact number of comparisons rather then in an asymptotic bound. The study of the exact number of comparisons that are required to solve a problem is not new; there is an extensive study on order statistics problems <ref> [2, 4, 12, 16, 17, 18, 20, 21, 22, 23] </ref>. Several algorithms solve the string matching problem in linear time. For a survey on string matching algorithms see Aho's paper [1].
Reference: [5] <author> R. S. Boyer and J. S. Moore. </author> <title> A fast string searching algorithm. </title> <journal> Comm. of the ACM, </journal> <volume> 20 </volume> <pages> 762-772, </pages> <year> 1977. </year>
Reference-contexts: On the other hand, an off-line algorithm has access to the whole text. Colussi [10] showed that the string matching problem can be solved using 1:5n :5 (m 1) comparisons improving the best previous bound of 2n m comparisons <ref> [3, 5, 11, 19] </ref>.
Reference: [6] <author> D. Breslauer. </author> <title> Efficient String Algorithmics. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Columbia University, </institution> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: The differences between these algorithms and the family of algorithms which presented in this paper are described below. For a more detailed discussion see Breslauer's Thesis <ref> [6] </ref>. 1. Colussi's algorithm is very similar to the family of algorithms given in Figure 2 with the standard choice ffi = 1 that guides the comparisons. Galil and Giancarlo's improvement of Colussi's algorithm is essentially using the choice ffi = 2 in special cases. 2.
Reference: [7] <author> D. Breslauer, L. Colussi, and L. Toniolo. </author> <title> Tight Comparison Bounds for the String Prefix-Matching Problem. </title> <type> Technical Report CUCS-049-92, </type> <institution> Computer Science Dept., Columbia University, </institution> <year> 1992. </year>
Reference-contexts: What is the exact number of comparisons required to find the period of a string? All periods of a string? The periods of all prefixes of a string? In a recent work Breslauer, Colussi and Toniolo <ref> [7] </ref> give some lower bounds for the last problem. 9 Acknowledgments We thank Raffaele Giancarlo, Laura Toniolo and Uri Zwick for comments on early versions of this paper.
Reference: [8] <author> R. Cole. </author> <title> Tight bounds on the complexity of the Boyer-Moore pattern matching algorithm. </title> <booktitle> In Proc. 2nd ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 224-233, </pages> <year> 1991. </year> <month> 20 </month>
Reference-contexts: The Knuth-Morris-Pratt [19] algorithm makes at most 2n comparisons in its text processing step. The Boyer-Moore algorithm makes about 3n comparisons in the worst case as proved recently by Cole <ref> [8] </ref>, but performs better in practice. A variant of that algorithm which makes 2n comparisons was designed by Apostolico and Giancarlo [3].
Reference: [9] <author> R. Cole and R. Hariharan. </author> <title> Tighter Bounds on The Exact Complexity of String Matching. </title> <booktitle> In Proc. 33rd IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 600-609, </pages> <year> 1992. </year>
Reference-contexts: We also show that any algorithm in the family of string matching algorithms presented must make at least n + blog mcb nm m c symbol comparisons, for m = 2 k 1 and any integer k 1. We have learned recently that Cole and Hariharan <ref> [9] </ref> independently discovered an on-line algorithm that makes only n + 8 3 (m+1) (n m) symbol comparisons. Their algorithm can be implemented in linear-time but it requires a pattern preprocessing step that takes (m 2 ) time. <p> This phenomenon is demonstrated by the pattern `abaa' when the last pattern symbol is compared. 8 Open Problems The exact complexity of string matching is not determined yet and there are several open problems left. The recent work of Cole and Hariharan <ref> [9] </ref> still leaves a small gap between the lower and the upper comparison bounds for string matching. The gap is even larger if the pattern preprocessing is accounted for in the bounds. 1.
Reference: [10] <author> L. Colussi. </author> <title> Correctness and efficiency of string matching algorithms. </title> <journal> Inform. and Control, </journal> <volume> 95 </volume> <pages> 225-251, </pages> <year> 1991. </year>
Reference-contexts: All previous string matching algorithms are oblivious in the sense that they sometimes "forget" or do not use information that was obtained in previous comparisons. In fact, Colussi <ref> [10] </ref> developed his algorithm by using formal program correctness proof techniques to avoid performing comparisons which are implied from the results of previous comparisons. The algorithms which are described in this paper do not "forget" answers to comparisons, what makes their analysis much simpler. <p> This means that such an algorithm has to report if there is an occurrence at a certain text position i before examining any text position larger than or equal to i + m. On the other hand, an off-line algorithm has access to the whole text. Colussi <ref> [10] </ref> showed that the string matching problem can be solved using 1:5n :5 (m 1) comparisons improving the best previous bound of 2n m comparisons [3, 5, 11, 19]. <p> Galil and Giancarlo [13] proved lower bounds for the on-line and the off-line problems. These lower bounds match their upper bound for patterns of length 1, 2 and 3. These lower bounds were later generalized and improved by Zwick and Paterson [25]. In this paper we generalize Colussi's <ref> [10] </ref> algorithm and Galil and Giancarlo's [14] algorithm and present a family of on-line algorithms with a similar behavior. One of the algorithms in this family is shown to perform at most n + d 4 log m+2 m (n m)e symbol comparisons. <p> By using similar methods one can also implement the binary alphabet algorithm of Section 4:1. 18 7 Previous Work The exposition in this paper not only generalizes the algorithms of Colussi <ref> [10] </ref> and Galil and Giancarlo [14], but can also be used to simplify the analysis of these algorithms. The differences between these algorithms and the family of algorithms which presented in this paper are described below. For a more detailed discussion see Breslauer's Thesis [6]. 1.
Reference: [11] <author> M. Crochemore and D. Perrin. </author> <title> Two-way string-matching. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 38(3) </volume> <pages> 651-675, </pages> <year> 1991. </year>
Reference-contexts: The Boyer-Moore algorithm makes about 3n comparisons in the worst case as proved recently by Cole [8], but performs better in practice. A variant of that algorithm which makes 2n comparisons was designed by Apostolico and Giancarlo [3]. The Galil-Seiferas [15] algorithm and the Crochemore-Perrin <ref> [11] </ref> algorithm work in linear time and use only a constant additional fl Partially supported by the IBM Graduate Fellowship while studying at Columbia University and by the European Research Consortium for Informatics and Mathematics postdoctoral fellowship. y Partially supported by NSF Grants CCR-90-14605 and CISE Institutional Infrastructure Grant CDA-90-24735. 1 <p> On the other hand, an off-line algorithm has access to the whole text. Colussi [10] showed that the string matching problem can be solved using 1:5n :5 (m 1) comparisons improving the best previous bound of 2n m comparisons <ref> [3, 5, 11, 19] </ref>.
Reference: [12] <author> L. R. Ford and S. M. Johnson. </author> <title> A tournament problem. </title> <journal> American Mathematical Monthly, </journal> <volume> 66 </volume> <pages> 387-389, </pages> <year> 1959. </year>
Reference-contexts: We are interested in the exact number of comparisons rather then in an asymptotic bound. The study of the exact number of comparisons that are required to solve a problem is not new; there is an extensive study on order statistics problems <ref> [2, 4, 12, 16, 17, 18, 20, 21, 22, 23] </ref>. Several algorithms solve the string matching problem in linear time. For a survey on string matching algorithms see Aho's paper [1].
Reference: [13] <author> Z. Galil and R. Giancarlo. </author> <title> On the exact complexity of string matching: lower bounds. </title> <journal> SIAM J. Comput., </journal> <volume> 20(6) </volume> <pages> 1008-1020, </pages> <year> 1991. </year>
Reference-contexts: They also gave an improved version of Colussi's algorithm that makes n + b (n m) min (1=3; min ( 1 ;m 1 )+2 3 n 1 3 m comparisons in the worst case. Galil and Giancarlo <ref> [13] </ref> proved lower bounds for the on-line and the off-line problems. These lower bounds match their upper bound for patterns of length 1, 2 and 3. These lower bounds were later generalized and improved by Zwick and Paterson [25]. <p> What is the exact number of comparisons required for the string matching problem if the pattern preprocessing is not accounted for? If the pattern preprocessing is accounted for? Is there a single algorithm which is optimal in both cases? 2. Galil and Giancarlo <ref> [13, 14] </ref> also consider the number of comparisons required by algorithms that only test if there is an occurrence of the pattern in the text and do not find all occurrences. What are the bounds for this problem? 3. <p> What are the bounds for this problem? 3. Do algorithms that compare pairs of text symbols have an advantage over algorithms that compare only pattern symbols to text symbols? It seems easier to obtain lower bounds for algorithms that do not compare pairs of text symbols <ref> [13, 25] </ref>. Zwick [24] has recently shown that for some patterns, pairwise comparisons of text symbols can help.
Reference: [14] <author> Z. Galil and R. Giancarlo. </author> <title> The exact complexity of string matching: upper bounds. </title> <journal> SIAM J. Comput., </journal> <volume> 21(3) </volume> <pages> 407-437, </pages> <year> 1992. </year>
Reference-contexts: The algorithms which are described in this paper do not "forget" answers to comparisons, what makes their analysis much simpler. Galil and Giancarlo <ref> [14] </ref> distinguish between on-line and off-line string matching algorithms. An on-line algorithm has access to the text through a sliding window whose length is equal to the length of the pattern. <p> On the other hand, an off-line algorithm has access to the whole text. Colussi [10] showed that the string matching problem can be solved using 1:5n :5 (m 1) comparisons improving the best previous bound of 2n m comparisons [3, 5, 11, 19]. Galil and Giancarlo <ref> [14] </ref> proved that the number of comparisons performed by Colussi's algorithm is also bounded by n + b (n m) min ( 1 ;m 1 ) 2 c, where 1 is the length of the shortest period of the pattern (periods are defined in Section 3). <p> These lower bounds match their upper bound for patterns of length 1, 2 and 3. These lower bounds were later generalized and improved by Zwick and Paterson [25]. In this paper we generalize Colussi's [10] algorithm and Galil and Giancarlo's <ref> [14] </ref> algorithm and present a family of on-line algorithms with a similar behavior. One of the algorithms in this family is shown to perform at most n + d 4 log m+2 m (n m)e symbol comparisons. <p> By using similar methods one can also implement the binary alphabet algorithm of Section 4:1. 18 7 Previous Work The exposition in this paper not only generalizes the algorithms of Colussi [10] and Galil and Giancarlo <ref> [14] </ref>, but can also be used to simplify the analysis of these algorithms. The differences between these algorithms and the family of algorithms which presented in this paper are described below. For a more detailed discussion see Breslauer's Thesis [6]. 1. <p> What is the exact number of comparisons required for the string matching problem if the pattern preprocessing is not accounted for? If the pattern preprocessing is accounted for? Is there a single algorithm which is optimal in both cases? 2. Galil and Giancarlo <ref> [13, 14] </ref> also consider the number of comparisons required by algorithms that only test if there is an occurrence of the pattern in the text and do not find all occurrences. What are the bounds for this problem? 3.
Reference: [15] <author> Z. Galil and J. Seiferas. </author> <title> Time-space-optimal string matching. </title> <journal> J. Comput. System Sci., </journal> <volume> 26 </volume> <pages> 280-294, </pages> <year> 1983. </year>
Reference-contexts: The Boyer-Moore algorithm makes about 3n comparisons in the worst case as proved recently by Cole [8], but performs better in practice. A variant of that algorithm which makes 2n comparisons was designed by Apostolico and Giancarlo [3]. The Galil-Seiferas <ref> [15] </ref> algorithm and the Crochemore-Perrin [11] algorithm work in linear time and use only a constant additional fl Partially supported by the IBM Graduate Fellowship while studying at Columbia University and by the European Research Consortium for Informatics and Mathematics postdoctoral fellowship. y Partially supported by NSF Grants CCR-90-14605 and CISE
Reference: [16] <author> D. G. Kirkpatrick. </author> <title> Topics in the complexity of combinatorial algorithms. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, University of Toronto, Toronto, Canada, </institution> <year> 1974. </year>
Reference-contexts: We are interested in the exact number of comparisons rather then in an asymptotic bound. The study of the exact number of comparisons that are required to solve a problem is not new; there is an extensive study on order statistics problems <ref> [2, 4, 12, 16, 17, 18, 20, 21, 22, 23] </ref>. Several algorithms solve the string matching problem in linear time. For a survey on string matching algorithms see Aho's paper [1].
Reference: [17] <author> D. G. Kirkpatrick. </author> <title> A unified lower bound for selection and set partitioning problems. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 28 </volume> <pages> 150-165, </pages> <year> 1981. </year>
Reference-contexts: We are interested in the exact number of comparisons rather then in an asymptotic bound. The study of the exact number of comparisons that are required to solve a problem is not new; there is an extensive study on order statistics problems <ref> [2, 4, 12, 16, 17, 18, 20, 21, 22, 23] </ref>. Several algorithms solve the string matching problem in linear time. For a survey on string matching algorithms see Aho's paper [1].
Reference: [18] <author> S. S. Kislitsyn. </author> <title> On the Selection of the k th Element of an Ordered Set by Pairwise Comparison. </title> <journal> Sibirskii Mat. Zhurnal, </journal> <volume> 5 </volume> <pages> 557-564, </pages> <year> 1964. </year>
Reference-contexts: We are interested in the exact number of comparisons rather then in an asymptotic bound. The study of the exact number of comparisons that are required to solve a problem is not new; there is an extensive study on order statistics problems <ref> [2, 4, 12, 16, 17, 18, 20, 21, 22, 23] </ref>. Several algorithms solve the string matching problem in linear time. For a survey on string matching algorithms see Aho's paper [1].
Reference: [19] <author> D. E. Knuth, J. H. Morris, and V. R. Pratt. </author> <title> Fast pattern matching in strings. </title> <journal> SIAM J. Comput., </journal> <volume> 6 </volume> <pages> 322-350, </pages> <year> 1977. </year>
Reference-contexts: For a survey on string matching algorithms see Aho's paper [1]. Most of these algorithms work in two steps: in the first step the pattern is preprocessed and some information is stored and used later in a text processing step. The Knuth-Morris-Pratt <ref> [19] </ref> algorithm makes at most 2n comparisons in its text processing step. The Boyer-Moore algorithm makes about 3n comparisons in the worst case as proved recently by Cole [8], but performs better in practice. A variant of that algorithm which makes 2n comparisons was designed by Apostolico and Giancarlo [3]. <p> On the other hand, an off-line algorithm has access to the whole text. Colussi [10] showed that the string matching problem can be solved using 1:5n :5 (m 1) comparisons improving the best previous bound of 2n m comparisons <ref> [3, 5, 11, 19] </ref>. <p> The comparisons made in the pattern preprocessing step of the Knuth-Morris-Pratt <ref> [19] </ref> algorithm are the only comparisons required for the pattern preprocessing of our algorithm. Lemma 6.1 (Knuth, Morris and Pratt [19]) Given a string P [1::m], the periods P [1::~] prefixes P [1::~], 1 ~ m, can be computed in linear time and 2m comparisons. <p> The comparisons made in the pattern preprocessing step of the Knuth-Morris-Pratt <ref> [19] </ref> algorithm are the only comparisons required for the pattern preprocessing of our algorithm. Lemma 6.1 (Knuth, Morris and Pratt [19]) Given a string P [1::m], the periods P [1::~] prefixes P [1::~], 1 ~ m, can be computed in linear time and 2m comparisons.
Reference: [20] <author> I. Pohl. </author> <title> A Sorting Problem and Its Complexity. </title> <journal> Comm. of the ACM, </journal> <volume> 15 </volume> <pages> 462-464, </pages> <year> 1972. </year>
Reference-contexts: We are interested in the exact number of comparisons rather then in an asymptotic bound. The study of the exact number of comparisons that are required to solve a problem is not new; there is an extensive study on order statistics problems <ref> [2, 4, 12, 16, 17, 18, 20, 21, 22, 23] </ref>. Several algorithms solve the string matching problem in linear time. For a survey on string matching algorithms see Aho's paper [1].
Reference: [21] <author> A. Schonhage, M. Paterson, and N. Pippenger. </author> <title> Finding the median. </title> <journal> J. Comput. System Sci., </journal> <volume> 13 </volume> <pages> 184-199, </pages> <year> 1976. </year>
Reference-contexts: We are interested in the exact number of comparisons rather then in an asymptotic bound. The study of the exact number of comparisons that are required to solve a problem is not new; there is an extensive study on order statistics problems <ref> [2, 4, 12, 16, 17, 18, 20, 21, 22, 23] </ref>. Several algorithms solve the string matching problem in linear time. For a survey on string matching algorithms see Aho's paper [1].
Reference: [22] <author> J. Schreier. </author> <title> On tournament elimination systems. </title> <journal> Mathesis Polska, </journal> <volume> 7 </volume> <pages> 154-160, </pages> <year> 1932. </year>
Reference-contexts: We are interested in the exact number of comparisons rather then in an asymptotic bound. The study of the exact number of comparisons that are required to solve a problem is not new; there is an extensive study on order statistics problems <ref> [2, 4, 12, 16, 17, 18, 20, 21, 22, 23] </ref>. Several algorithms solve the string matching problem in linear time. For a survey on string matching algorithms see Aho's paper [1].
Reference: [23] <author> C. K. Yap. </author> <title> New upper bounds for selection. </title> <journal> Comm. of the ACM, </journal> <volume> 19 </volume> <pages> 501-508, </pages> <year> 1979. </year>
Reference-contexts: We are interested in the exact number of comparisons rather then in an asymptotic bound. The study of the exact number of comparisons that are required to solve a problem is not new; there is an extensive study on order statistics problems <ref> [2, 4, 12, 16, 17, 18, 20, 21, 22, 23] </ref>. Several algorithms solve the string matching problem in linear time. For a survey on string matching algorithms see Aho's paper [1].
Reference: [24] <author> U. </author> <title> Zwick. </title> <type> Personal communication, </type> <year> 1992. </year>
Reference-contexts: What are the bounds for this problem? 3. Do algorithms that compare pairs of text symbols have an advantage over algorithms that compare only pattern symbols to text symbols? It seems easier to obtain lower bounds for algorithms that do not compare pairs of text symbols [13, 25]. Zwick <ref> [24] </ref> has recently shown that for some patterns, pairwise comparisons of text symbols can help.
Reference: [25] <author> U. Zwick and M. S. Paterson. </author> <title> Lower bounds for string matching in the sequential comparison model. </title> <type> Manuscript, </type> <year> 1991. </year> <month> 21 </month>
Reference-contexts: Galil and Giancarlo [13] proved lower bounds for the on-line and the off-line problems. These lower bounds match their upper bound for patterns of length 1, 2 and 3. These lower bounds were later generalized and improved by Zwick and Paterson <ref> [25] </ref>. In this paper we generalize Colussi's [10] algorithm and Galil and Giancarlo's [14] algorithm and present a family of on-line algorithms with a similar behavior. One of the algorithms in this family is shown to perform at most n + d 4 log m+2 m (n m)e symbol comparisons. <p> What are the bounds for this problem? 3. Do algorithms that compare pairs of text symbols have an advantage over algorithms that compare only pattern symbols to text symbols? It seems easier to obtain lower bounds for algorithms that do not compare pairs of text symbols <ref> [13, 25] </ref>. Zwick [24] has recently shown that for some patterns, pairwise comparisons of text symbols can help. <p> Zwick [24] has recently shown that for some patterns, pairwise comparisons of text symbols can help. Zwick and Paterson <ref> [25] </ref> call an algorithm that has access to the text through a sliding window of length m + k a k-look-ahead algorithm (in our terminology a zero-look-ahead algorithm is on-line and infinite-look-ahead algorithm is off-line). They show that a look-ahead is useful, at least in some cases.
References-found: 25

