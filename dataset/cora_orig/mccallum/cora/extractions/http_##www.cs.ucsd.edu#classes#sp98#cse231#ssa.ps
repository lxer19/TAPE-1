URL: http://www.cs.ucsd.edu/classes/sp98/cse231/ssa.ps
Refering-URL: http://www.cs.ucsd.edu/classes/sp98/cse231/
Root-URL: http://www.cs.ucsd.edu
Title: Efficiently Computing Static Single Assignment Form and the Control Dependence Graph  
Author: Ron Cytron Barry K. Rosen Mark N. Wegman F. Kenneth Zadeck (Brown 
Date: March 7, 1991  
Affiliation: (IBM Research Division) Jeanne Ferrante (IBM Research Division)  (IBM Research Division)  (IBM Research Division)  University)  
Abstract: In optimizing compilers, data structure choices directly influence the power and efficiency of practical program optimization. A poor choice of data structure can inhibit optimization or slow compilation to the point that advanced optimization features become undesirable. Recently, static single assignment form and the control dependence graph have been proposed to represent data flow and control flow properties of programs. Each of these previously unrelated techniques lends efficiency and power to a useful class of program optimizations. Although both of these structures are attractive, the difficulty of their construction and their potential size have discouraged their use. We present new algorithms that efficiently compute these data structures for arbitrary control flow graphs. The algorithms use dominance frontiers, a new concept that may have other applications. We also give analytical and experimental evidence that all of these data structures are usually linear in the size of the original program. This paper thus presents strong evidence that these structures can be of practical use in optimization. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: and time bounds, compares our technique with other techniques, and presents some conclusions. 2 Control Flow Graphs The statements of a program are organized into (not necessarily maximal) basic blocks, where program flow enters a basic block at its first statement and leaves the basic block at its last statement <ref> [1, 36] </ref>. Basic blocks are indicated by the column of numbers in parentheses in Figure 5. A control flow graph is a directed graph whose nodes are the basic blocks of a program and two additional nodes, Entry and Exit. <p> The statement is a conditional branch and there are statements already marked live that are control dependent on this conditional branch. 9 The definition used here is broader than the usual one <ref> [1, p. 595] </ref> and similar to that of "faint" variables [25, p. 489]. 36 Several published algorithms eliminate dead code in the narrower sense that requires every conditional branch to be marked live [30, 31, 38]. 10 Our algorithm, given in Figure 17, goes one step further in eliminating dead conditional
Reference: [2] <author> F. E. Allen, M. Burke, P. Charles, R. Cytron, and J. Ferrante. </author> <title> An overview of the PTRAN analysis system for multiprocessing. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 5 </volume> <pages> 617-640, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Informally, a statement is control dependent on a branch if one edge from the branch definitely causes that statement to execute while another edge can cause the statement to be skipped. Such information is vital for detection of parallelism <ref> [2] </ref>, program optimization, and program analysis [28]. 1.3 Outline of the Rest of the Paper Section 2 reviews the representation of control flow by a directed graph. Section 3 explains SSA form and sketches how to construct it. This section also considers variants of SSA form as defined here. <p> However, x8 shows that the size of the mapping DF is usually linear in practice. We have implemented this algorithm and have observed that it is faster than the standard data flow computations in the PTRAN compiler <ref> [2] </ref>. 4.3 Relating Dominance Frontiers to Joins We start by stating more formally the nonrecursive characterization of where the -functions should be located. <p> We implemented our algorithms for constructing dominance frontiers and placing -functions in the PTRAN system, which already offered the required local data flow and control flow analysis <ref> [2] </ref>. We ran these algorithms on 61 library procedures from EISPACK [46] and 160 procedures from two "Perfect" [39] benchmarks. Some summary statistics of these procedures are shown in Figure 20.
Reference: [3] <author> J. R. Allen. </author> <title> Dependence Analysis for Subscripted Variables and its Application to Program Transformations. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Sci., Rice U., Houston, TX, </institution> <month> April </month> <year> 1983. </year> <month> 47 </month>
Reference-contexts: One reasonable response to the crudeness of the Update operator is to accept it. Address calculations and other genuine scalar calculations can still be optimized extensively. Another response is to perform dependence analysis <ref> [3, 10, 32, 51] </ref>, which can sometimes determine that no subsequent accesses of A require values produced by any other assignment to A. Such is the case for each execution of the assignment to A (i) on the left in Figure 8.
Reference: [4] <author> J. R. Allen and S. Johnson. </author> <title> Compiling C for vectorization, parallelization and inline expansion. </title> <booktitle> Proc. SIGPLAN'88 Symp. on Compiler Construction, </booktitle> <pages> pages 241-249, </pages> <month> June </month> <year> 1988. </year> <journal> Published as SIGPLAN Notices Vol. </journal> <volume> 23, No. </volume> <pages> 7. </pages>
Reference-contexts: Each of these previously unrelated techniques lends efficiency and power to a useful class of program optimizations. Although both of these structures are attractive, the difficulty of their construction and their potential size have discouraged their use <ref> [4] </ref>. We present new algorithms that efficiently compute these data structures for arbitrary control flow graphs. The algorithms use dominance frontiers, a new concept that may have other applications.
Reference: [5] <author> B. Alpern, M. N. Wegman, and F. K. Zadeck. </author> <title> Detecting equality of values in programs. </title> <booktitle> Conf. Rec. Fifteenth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 1-11, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: 1 Introduction In optimizing compilers, data structure choices directly influence the power and efficiency of practical program optimization. A poor choice of data structure can inhibit optimization or slow compilation to the point where advanced optimization features become undesirable. Recently, static single assignment (SSA) form <ref> [5, 43] </ref> and the control dependence graph [24] have been proposed to represent data flow and control flow properties of programs. Each of these previously unrelated techniques lends efficiency and power to a useful class of program optimizations. <p> Original Optimized Intermediate Code Intermediate Code A H H H A Horizontal arrows represent optimizations. Variants of SSA form have been used for detecting program equivalence <ref> [5, 52] </ref> and for increasing parallelism in imperative programs [21]. The representation of simple data flow information (def-use chains) may be more compact through SSA form. If a variable has D definitions and U uses, then there can be D fi U def-use chains. <p> Any -functions in X are executed before the ordinary statements in X. Some variants of -functions as defined here are useful for special purposes. For example, each -function can be tagged with the node X where it appears <ref> [5] </ref>. When the control flow of a language is suitably restricted, each -function can be tagged with information about conditionals or loops [5, 6, 11, 52]. The algorithms in this paper apply to such variants as well. <p> Some variants of -functions as defined here are useful for special purposes. For example, each -function can be tagged with the node X where it appears [5]. When the control flow of a language is suitably restricted, each -function can be tagged with information about conditionals or loops <ref> [5, 6, 11, 52] </ref>. The algorithms in this paper apply to such variants as well. Static single assignment form may be considered as a property of a single program or as a relation between two programs. <p> The original assignments to V are live, but the added assignment by the -function is dead. Often such dead -functions are useful, as in the equivalencing and redundancy elimination algorithms that are based on SSA form <ref> [5, 43] </ref>. One such use is shown in Figure 16. Although others have avoided placement of dead -functions in translating to SSA form [16, 52], we prefer to include the dead -functions to increase optimization opportunities. There are many different definitions of dead code in the literature. <p> 1 then do then do Y 1 1 Y 1 1 end end else do else do Y 2 X 1 Y 2 X 1 end end ... ... then Z 1 1 else Z 2 X 1 Z 3 (Z 1 ; Z 2 ) value numbering technique in <ref> [5] </ref> can determine that Y 3 and Z 3 have the same value. Thus, Z 3 and many of the computations that produce it can be eliminated.
Reference: [6] <author> R. A. Ballance, A. B. Maccabe, and K. J. Ottenstein. </author> <title> The Program Dependence Web: A representation supporting control-, data-, and demand driven interpretation of languages. </title> <booktitle> Proc. SIGPLAN'90 Symp. on Compiler Construction, </booktitle> <pages> pages 257-271, </pages> <month> June </month> <year> 1990. </year> <journal> Published as SIGPLAN Notices Vol. </journal> <volume> 25, No. </volume> <pages> 6. </pages>
Reference-contexts: For us, the semantics of are only important when assessing the correctness of intermediate steps in a sequence of program transformations beginning and ending with code that has no -functions. Others <ref> [6, 11, 52] </ref> have found it useful to give another parameter that incidentally encodes j, under various restrictions on the control flow. 10 in X. The value of (R; S; :::) is just the value of the j-th operand. <p> Some variants of -functions as defined here are useful for special purposes. For example, each -function can be tagged with the node X where it appears [5]. When the control flow of a language is suitably restricted, each -function can be tagged with information about conditionals or loops <ref> [5, 6, 11, 52] </ref>. The algorithms in this paper apply to such variants as well. Static single assignment form may be considered as a property of a single program or as a relation between two programs.
Reference: [7] <author> J. B. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> Conf. Rec. Sixth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: Such assumptions limit the extent that transfromations can be performed. Techniques are available to extract more detailed information: to determine parameter aliasing and effects of procedures on global variables, see <ref> [7, 8, 9, 19, 37, 42] </ref>; to determine pointer aliasing, see [14, 15, 27, 29, 33, 34, 44]. When a sophisticated analysis technique is applied, the usual result is that there are few side effects and the tuples (both LHS and RHS) are small. Small tuples can be represented directly.
Reference: [8] <author> J. M. Barth. </author> <title> An interprocedural data flow analysis algorithm. </title> <booktitle> Conf. Rec. Fourth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 119-131, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: Such assumptions limit the extent that transfromations can be performed. Techniques are available to extract more detailed information: to determine parameter aliasing and effects of procedures on global variables, see <ref> [7, 8, 9, 19, 37, 42] </ref>; to determine pointer aliasing, see [14, 15, 27, 29, 33, 34, 44]. When a sophisticated analysis technique is applied, the usual result is that there are few side effects and the tuples (both LHS and RHS) are small. Small tuples can be represented directly.
Reference: [9] <author> M. Burke. </author> <title> An interval-based approach to exhaustive and incremental interprocedural data flow analysis. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 341-395, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Such assumptions limit the extent that transfromations can be performed. Techniques are available to extract more detailed information: to determine parameter aliasing and effects of procedures on global variables, see <ref> [7, 8, 9, 19, 37, 42] </ref>; to determine pointer aliasing, see [14, 15, 27, 29, 33, 34, 44]. When a sophisticated analysis technique is applied, the usual result is that there are few side effects and the tuples (both LHS and RHS) are small. Small tuples can be represented directly.
Reference: [10] <author> M. Burke and R. Cytron. </author> <title> Interprocedural dependence analysis and parallelization. </title> <booktitle> Proc. SIGPLAN'86 Symp. on Compiler Construction, </booktitle> <pages> pages 162-175, </pages> <month> June </month> <year> 1986. </year> <journal> Published as SIGPLAN Notices Vol. </journal> <volume> 21, No. </volume> <pages> 7. </pages>
Reference-contexts: One reasonable response to the crudeness of the Update operator is to accept it. Address calculations and other genuine scalar calculations can still be optimized extensively. Another response is to perform dependence analysis <ref> [3, 10, 32, 51] </ref>, which can sometimes determine that no subsequent accesses of A require values produced by any other assignment to A. Such is the case for each execution of the assignment to A (i) on the left in Figure 8.
Reference: [11] <author> R. Cartwright and M. Felleisen. </author> <title> The semantics of program dependence. </title> <booktitle> Proc. SIGPLAN'89 Symp. on Compiler Construction, </booktitle> <pages> pages 13-27, </pages> <month> July </month> <year> 1989. </year> <journal> Published as SIGPLAN Notices Vol. </journal> <volume> 24, No. </volume> <pages> 7. </pages>
Reference-contexts: For us, the semantics of are only important when assessing the correctness of intermediate steps in a sequence of program transformations beginning and ending with code that has no -functions. Others <ref> [6, 11, 52] </ref> have found it useful to give another parameter that incidentally encodes j, under various restrictions on the control flow. 10 in X. The value of (R; S; :::) is just the value of the j-th operand. <p> Some variants of -functions as defined here are useful for special purposes. For example, each -function can be tagged with the node X where it appears [5]. When the control flow of a language is suitably restricted, each -function can be tagged with information about conditionals or loops <ref> [5, 6, 11, 52] </ref>. The algorithms in this paper apply to such variants as well. Static single assignment form may be considered as a property of a single program or as a relation between two programs.
Reference: [12] <author> G. J. Chaitin. </author> <title> Register allocation and spilling via graph coloring. </title> <booktitle> Proc. SIGPLAN'82 Symp. on Compiler Construction, </booktitle> <pages> pages 98-105, </pages> <month> June </month> <year> 1982. </year> <journal> Published as SIGPLAN Notices Vol. </journal> <volume> 17, No. </volume> <pages> 6. </pages>
Reference-contexts: Any graph coloring algorithm <ref> [12, 13, 17, 18, 21] </ref> can be used to reduce the number of variables needed and thereby remove most of the associated assignment statements. The choice of coloring technique should be guided by the eventual use of the output.
Reference: [13] <author> G. J. Chaitin, M. A. Auslander, A. K. Chandra, J. Cocke, M. E. Hopkins, and P. W. Markstein. </author> <title> Register allocation via coloring. </title> <journal> Computer Languages, </journal> <volume> 6 </volume> <pages> 47-57, </pages> <year> 1981. </year>
Reference-contexts: Any graph coloring algorithm <ref> [12, 13, 17, 18, 21] </ref> can be used to reduce the number of variables needed and thereby remove most of the associated assignment statements. The choice of coloring technique should be guided by the eventual use of the output.
Reference: [14] <author> D. R. Chase. </author> <title> Safety considerations for storage allocation optimizations. </title> <booktitle> Proc. SIGPLAN'88 Symp. on Compiler Construction, </booktitle> <pages> pages 1-10, </pages> <month> June </month> <year> 1988. </year> <journal> Published as SIGPLAN Notices Vol. </journal> <volume> 23, No. 7. </volume> <pages> 48 </pages>
Reference-contexts: Such assumptions limit the extent that transfromations can be performed. Techniques are available to extract more detailed information: to determine parameter aliasing and effects of procedures on global variables, see [7, 8, 9, 19, 37, 42]; to determine pointer aliasing, see <ref> [14, 15, 27, 29, 33, 34, 44] </ref>. When a sophisticated analysis technique is applied, the usual result is that there are few side effects and the tuples (both LHS and RHS) are small. Small tuples can be represented directly. Sophisticated analysis, however, is often unavailable.
Reference: [15] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> Proc. SIGPLAN'90 Symp. on Compiler Construction, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year> <journal> Published as SIGPLAN Notices Vol. </journal> <volume> 25, No. </volume> <pages> 6. </pages>
Reference-contexts: Heap storage can be conservatively modeled by representing the entire heap as a single variable that is both modified and used by any statement that may change the heap. More refined modeling is also possible <ref> [15] </ref>, but the conservative approach is already strong enough to support optimization of code that does not involve the heap but is interspersed with heap-dependent code. <p> Such assumptions limit the extent that transfromations can be performed. Techniques are available to extract more detailed information: to determine parameter aliasing and effects of procedures on global variables, see [7, 8, 9, 19, 37, 42]; to determine pointer aliasing, see <ref> [14, 15, 27, 29, 33, 34, 44] </ref>. When a sophisticated analysis technique is applied, the usual result is that there are few side effects and the tuples (both LHS and RHS) are small. Small tuples can be represented directly. Sophisticated analysis, however, is often unavailable.
Reference: [16] <author> J. Choi, R. Cytron, and J. Ferrante. </author> <title> Automatic construction of sparse data flow evaluation graphs. </title> <booktitle> Conf. Rec. Eighteenth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 55-66, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The -function could then be omitted without any risk of losing Condition 3. This has been called pruned SSA form <ref> [16] </ref>, and it is 11 sometimes preferable to our placement at all convergence points. However, as Figure 16 in x7 illustrates, our form is sometimes preferable to pruned form. When desired, pruned SSA form can be obtained by a simple adjustment of our algorithm [16, x5.1]. <p> However, as Figure 16 in x7 illustrates, our form is sometimes preferable to pruned form. When desired, pruned SSA form can be obtained by a simple adjustment of our algorithm <ref> [16, x5.1] </ref>. For any variable V , the nodes at which we should insert -functions in the original program can be defined recursively by Condition 1 in the definition of SSA form. <p> Often such dead -functions are useful, as in the equivalencing and redundancy elimination algorithms that are based on SSA form [5, 43]. One such use is shown in Figure 16. Although others have avoided placement of dead -functions in translating to SSA form <ref> [16, 52] </ref>, we prefer to include the dead -functions to increase optimization opportunities. There are many different definitions of dead code in the literature. Dead code is sometimes defined to be unreachable code and sometimes defined (as it is here) to be ineffectual code.
Reference: [17] <author> F. C. Chow. </author> <title> A portable machine-independent global optimizer design and measurements. </title> <type> Technical Report 83-254 (PhD Thesis), </type> <institution> Computer Systems Laboratory, Stanford U. Stanford, </institution> <address> CA, </address> <month> December </month> <year> 1983. </year>
Reference-contexts: Any graph coloring algorithm <ref> [12, 13, 17, 18, 21] </ref> can be used to reduce the number of variables needed and thereby remove most of the associated assignment statements. The choice of coloring technique should be guided by the eventual use of the output.
Reference: [18] <author> F. C. Chow and J. L. Hennessy. </author> <title> The priority-based coloring approach to register allocation. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 501-536, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Any graph coloring algorithm <ref> [12, 13, 17, 18, 21] </ref> can be used to reduce the number of variables needed and thereby remove most of the associated assignment statements. The choice of coloring technique should be guided by the eventual use of the output.
Reference: [19] <author> K. D. Cooper. </author> <title> Interprocedural Data Flow Analysis in a Programming Environment. </title> <type> PhD thesis, </type> <institution> Dept. of Mathematical Sciences, Rice U., Houston, TX, </institution> <year> 1983. </year>
Reference-contexts: Such assumptions limit the extent that transfromations can be performed. Techniques are available to extract more detailed information: to determine parameter aliasing and effects of procedures on global variables, see <ref> [7, 8, 9, 19, 37, 42] </ref>; to determine pointer aliasing, see [14, 15, 27, 29, 33, 34, 44]. When a sophisticated analysis technique is applied, the usual result is that there are few side effects and the tuples (both LHS and RHS) are small. Small tuples can be represented directly.
Reference: [20] <author> R. Cytron and J. Ferrante. </author> <title> An improved control dependence algorithm. </title> <type> Technical Report RC 13291, </type> <institution> IBM, </institution> <year> 1987. </year>
Reference-contexts: V by finding the dominance frontier of every node that assigns to V, then the dominance frontier of every node where a -function has already been placed, and so on. 6 The same concept of dominance frontiers used for computing SSA form can also be used to compute control dependences <ref> [20, 24] </ref>, which identify those conditions affecting statement execution. Informally, a statement is control dependent on a branch if one edge from the branch definitely causes that statement to execute while another edge can cause the statement to be skipped.
Reference: [21] <author> R. Cytron and J. Ferrante. </author> <title> What's in a name? Proc. </title> <booktitle> 1987 International Conf. on Parallel Processing, </booktitle> <pages> pages 19-27, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Original Optimized Intermediate Code Intermediate Code A H H H A Horizontal arrows represent optimizations. Variants of SSA form have been used for detecting program equivalence [5, 52] and for increasing parallelism in imperative programs <ref> [21] </ref>. The representation of simple data flow information (def-use chains) may be more compact through SSA form. If a variable has D definitions and U uses, then there can be D fi U def-use chains. <p> Any graph coloring algorithm <ref> [12, 13, 17, 18, 21] </ref> can be used to reduce the number of variables needed and thereby remove most of the associated assignment statements. The choice of coloring technique should be guided by the eventual use of the output.
Reference: [22] <author> R. Cytron, A. Lowry, and F. K. Zadeck. </author> <title> Code motion of control structures in high-level languages. </title> <booktitle> Conf. Rec. Thirteenth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 70-85, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: This paper thus presents strong evidence that SSA form and control dependences can be of practical use in optimization. into SSA form, optimized in various ways, and then translated back out of SSA form. Optimizations that can benefit from using SSA form include code motion <ref> [22] </ref> and elimination of partial redundancies [43], as well as the constant propagation discussed later in this section. Original Optimized Intermediate Code Intermediate Code A H H H A Horizontal arrows represent optimizations. <p> The pseudo-assignment nodes for V are exactly the nodes that need -functions for V . A closer precursor <ref> [22] </ref> of SSA form associated new names for V with pseudo-assignment nodes and inserted assignments from one new name to another. Without explicit -functions, however, it was difficult to manage the new names or reason about the flow of values.
Reference: [23] <author> J. B. Dennis. </author> <title> First version of a data flow procedure language. </title> <type> Technical Report Comp. </type> <note> Struc. Group Memo 93 (MAC Tech. Memo 61), </note> <institution> Massachussetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> May </month> <year> 1975. </year>
Reference-contexts: Any assignment to a component of A that is not used before entering such an 3 This notation is similar to Select and Update [24], which in turn is similar to notation for referencing aggregate structures in a data flow language <ref> [23] </ref>. 13 integer A (1:100) integer A 0 (1:100) integer A 0 (1:100) integer A 1 (1:100) integer A 1 (1:100) integer A 2 (1:100) integer A 2 (1:100) i 1 i 2 1 i 2 1 repeat repeat repeat i 2 (i 1 ; i 3 ) i 2 (i
Reference: [24] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: A poor choice of data structure can inhibit optimization or slow compilation to the point where advanced optimization features become undesirable. Recently, static single assignment (SSA) form [5, 43] and the control dependence graph <ref> [24] </ref> have been proposed to represent data flow and control flow properties of programs. Each of these previously unrelated techniques lends efficiency and power to a useful class of program optimizations. <p> V by finding the dominance frontier of every node that assigns to V, then the dominance frontier of every node where a -function has already been placed, and so on. 6 The same concept of dominance frontiers used for computing SSA form can also be used to compute control dependences <ref> [20, 24] </ref>, which identify those conditions affecting statement execution. Informally, a statement is control dependent on a branch if one edge from the branch definitely causes that statement to execute while another edge can cause the statement to be skipped. <p> Any assignment to a component of A that is not used before entering such an 3 This notation is similar to Select and Update <ref> [24] </ref>, which in turn is similar to notation for referencing aggregate structures in a data flow language [23]. 13 integer A (1:100) integer A 0 (1:100) integer A 0 (1:100) integer A 1 (1:100) integer A 1 (1:100) integer A 2 (1:100) integer A 2 (1:100) i 1 i 2 1 <p> As was explained at the end of x5.1, Figure 11 contributes O (A tot fi avrgDF ). 2 6 Construction of Control Dependences In this section we show that control dependences <ref> [24] </ref> are essentially the dominance frontiers in the reverse graph of the control flow graph. Let X and Y be nodes in CF G. <p> In a postdominator tree, the children of a node X are all immediately postdominated by X. 7 Each ordinary assignment LHS RHS contributes the length of the tuple LHS to A tot , and each -function contributes 1 to A tot . 8 The postdominance relation in <ref> [24] </ref> is irreflexive, while the definition we use here is reflexive. The two relations are identical on pairs of distinct elements. <p> We associate with this control dependence from X to Y the label on the control flow edge from X that causes Y to execute. Our definition of control dependence here can easily be shown to be equivalent to the original definition <ref> [24] </ref>. Lemma 11 Let X and Y be CF G nodes. Then Y postdominates a successor of X if and only if there is a nonnull path p : X + ! Y such that Y postdominates every node after X on p. Proof. <p> The earlier O (R 2 ) algorithms have no provision for running faster in typical cases; they appear to be intrinsically quadratic. For CF G with N nodes and E edges, previous general control dependence algorithms <ref> [24] </ref> can take quadratic time in (N + E). This analysis is based on the worst-case (N ) depth of the (post)dominator tree [24, p. 326]. Section 6 shows that (inverse) control dependences can be determined by computing dominance frontiers in the reverse graph RCF G. <p> For CF G with N nodes and E edges, previous general control dependence algorithms [24] can take quadratic time in (N + E). This analysis is based on the worst-case (N ) depth of the (post)dominator tree <ref> [24, p. 326] </ref>. Section 6 shows that (inverse) control dependences can be determined by computing dominance frontiers in the reverse graph RCF G. In general, our approach can also take quadratic time, but the only quadratic behavior is caused by the output being (N 2 ) in the worst case.
Reference: [25] <author> R. Giegerich. </author> <title> A formal framework for the derivation of machine-specific optimizers. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 478-498, </pages> <month> July </month> <year> 1983. </year> <month> 49 </month>
Reference-contexts: The statement is a conditional branch and there are statements already marked live that are control dependent on this conditional branch. 9 The definition used here is broader than the usual one [1, p. 595] and similar to that of "faint" variables <ref> [25, p. 489] </ref>. 36 Several published algorithms eliminate dead code in the narrower sense that requires every conditional branch to be marked live [30, 31, 38]. 10 Our algorithm, given in Figure 17, goes one step further in eliminating dead conditional branches. (An unpublished algorithm by R.
Reference: [26] <author> D. Harel. </author> <title> A linear time algorithm for finding dominators in flow graphs and related problems. </title> <booktitle> Proc. Seventeenth ACM Symp. on Theory of Computing, </booktitle> <pages> pages 185-194, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: The dominator tree for CF G from Figure 5 is shown in in O (Eff (E; N )) time [35] or (by a more difficult algorithm) in O (E) time <ref> [26] </ref>. For all practical purposes, ff (E; N ) is a small constant, 4 so this paper will consider the dominator tree to have been found in linear time.
Reference: [27] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> Proc. SIGPLAN'89 Symp. on Compiler Construction, </booktitle> <month> June </month> <year> 1989. </year> <journal> Published as SIGPLAN Notices Vol. </journal> <volume> 24, No. </volume> <pages> 7. </pages>
Reference-contexts: Such assumptions limit the extent that transfromations can be performed. Techniques are available to extract more detailed information: to determine parameter aliasing and effects of procedures on global variables, see [7, 8, 9, 19, 37, 42]; to determine pointer aliasing, see <ref> [14, 15, 27, 29, 33, 34, 44] </ref>. When a sophisticated analysis technique is applied, the usual result is that there are few side effects and the tuples (both LHS and RHS) are small. Small tuples can be represented directly. Sophisticated analysis, however, is often unavailable.
Reference: [28] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> Integrating non-interfering versions of programs. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 11(3) </volume> <pages> 345-387, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Informally, a statement is control dependent on a branch if one edge from the branch definitely causes that statement to execute while another edge can cause the statement to be skipped. Such information is vital for detection of parallelism [2], program optimization, and program analysis <ref> [28] </ref>. 1.3 Outline of the Rest of the Paper Section 2 reviews the representation of control flow by a directed graph. Section 3 explains SSA form and sketches how to construct it. This section also considers variants of SSA form as defined here. <p> We obtain a better time bound for such programs because our algorithm is based on dominance frontiers, whose sizes are not necessarily related to the depth of the dominator tree. For languages that offer only these constructs, control dependences can 46 also be computed from the parse tree <ref> [28] </ref> in linear time, but our algorithm is more robust.
Reference: [29] <author> N. D. Jones and S. S. Muchnick. </author> <title> Flow analysis and optimization of LISP-like structures. </title> <editor> In S. S. Muchnick and N. D. Jones, editors, </editor> <title> Program Flow Analysis, </title> <booktitle> chapter 4, </booktitle> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Such assumptions limit the extent that transfromations can be performed. Techniques are available to extract more detailed information: to determine parameter aliasing and effects of procedures on global variables, see [7, 8, 9, 19, 37, 42]; to determine pointer aliasing, see <ref> [14, 15, 27, 29, 33, 34, 44] </ref>. When a sophisticated analysis technique is applied, the usual result is that there are few side effects and the tuples (both LHS and RHS) are small. Small tuples can be represented directly. Sophisticated analysis, however, is often unavailable.
Reference: [30] <author> K. W. Kennedy. </author> <title> Global dead computation elimination. </title> <type> Technical Report SETL Newsletter No. 111, </type> <institution> Courant Institute of Mathematical Sciences, </institution> <address> New York U., New York, NY, </address> <month> August </month> <year> 1973. </year>
Reference-contexts: control dependent on this conditional branch. 9 The definition used here is broader than the usual one [1, p. 595] and similar to that of "faint" variables [25, p. 489]. 36 Several published algorithms eliminate dead code in the narrower sense that requires every conditional branch to be marked live <ref> [30, 31, 38] </ref>. 10 Our algorithm, given in Figure 17, goes one step further in eliminating dead conditional branches. (An unpublished algorithm by R. <p> Condition (3) is handled by the loop over CD 1 (Block (S)). A basic block whose termination controls a block with live statements is itself live. 10 The more readily accessible [31] contains a typographical error; the earlier technical report <ref> [30] </ref> should be consulted for the correct version. 11 A conditional branch can be deleted by transforming it to an unconditional branch to any one of its prior targets. 37 for each statement S do if S 2 P reLive then Live (S) true else Live (S) false end W orkList
Reference: [31] <author> K. W. Kennedy. </author> <title> A survey of data flow analysis techniques. </title> <editor> In S. S. Muchnick and N. D. Jones, editors, </editor> <title> Program Flow Analysis. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: control dependent on this conditional branch. 9 The definition used here is broader than the usual one [1, p. 595] and similar to that of "faint" variables [25, p. 489]. 36 Several published algorithms eliminate dead code in the narrower sense that requires every conditional branch to be marked live <ref> [30, 31, 38] </ref>. 10 Our algorithm, given in Figure 17, goes one step further in eliminating dead conditional branches. (An unpublished algorithm by R. <p> Statements that depend (transitively) on themselves are never marked live unless required by some other live statement. Condition (3) is handled by the loop over CD 1 (Block (S)). A basic block whose termination controls a block with live statements is itself live. 10 The more readily accessible <ref> [31] </ref> contains a typographical error; the earlier technical report [30] should be consulted for the correct version. 11 A conditional branch can be deleted by transforming it to an unconditional branch to any one of its prior targets. 37 for each statement S do if S 2 P reLive then Live
Reference: [32] <author> D. J. Kuck. </author> <title> The Structure of Computers and Computations. </title> <publisher> John Wiley & Sons, </publisher> <year> 1978. </year>
Reference-contexts: Transformation to SSA form proceeds as usual (on the right). As with scalars, translation of array references to SSA form removes some anti- and output-dependences <ref> [32] </ref>. In the program on the left in Figure 7, dependence analysis may prohibit reordering the use of A (i) by the first statement and the definition of A (j) by the second statement. <p> One reasonable response to the crudeness of the Update operator is to accept it. Address calculations and other genuine scalar calculations can still be optimized extensively. Another response is to perform dependence analysis <ref> [3, 10, 32, 51] </ref>, which can sometimes determine that no subsequent accesses of A require values produced by any other assignment to A. Such is the case for each execution of the assignment to A (i) on the left in Figure 8.
Reference: [33] <author> J. R. Larus. </author> <title> Restructuring symbolic programs for concurrent execution on multiprocessors. </title> <type> Technical Report UCB/CSD 89/502, </type> <institution> Computer Sci. Dept., U. of California at Berkeley, Berkeley, </institution> <address> CA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Such assumptions limit the extent that transfromations can be performed. Techniques are available to extract more detailed information: to determine parameter aliasing and effects of procedures on global variables, see [7, 8, 9, 19, 37, 42]; to determine pointer aliasing, see <ref> [14, 15, 27, 29, 33, 34, 44] </ref>. When a sophisticated analysis technique is applied, the usual result is that there are few side effects and the tuples (both LHS and RHS) are small. Small tuples can be represented directly. Sophisticated analysis, however, is often unavailable.
Reference: [34] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> Proc. SIGPLAN'88 Symp. on Compiler Construction, </booktitle> <pages> pages 21-34, </pages> <month> July </month> <year> 1988. </year> <journal> Published as SIGPLAN Notices Vol. </journal> <volume> 23, No. </volume> <pages> 7. </pages>
Reference-contexts: Such assumptions limit the extent that transfromations can be performed. Techniques are available to extract more detailed information: to determine parameter aliasing and effects of procedures on global variables, see [7, 8, 9, 19, 37, 42]; to determine pointer aliasing, see <ref> [14, 15, 27, 29, 33, 34, 44] </ref>. When a sophisticated analysis technique is applied, the usual result is that there are few side effects and the tuples (both LHS and RHS) are small. Small tuples can be represented directly. Sophisticated analysis, however, is often unavailable.
Reference: [35] <author> T. Lengauer and R. E. Tarjan. </author> <title> A fast algorithm for finding dominators in a flowgraph. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 1(1) </volume> <pages> 121-141, </pages> <month> July </month> <year> 1979. </year>
Reference-contexts: The root of a dominator tree is Entry, and any node Y other than Entry has idom (Y ) as its parent in the tree. The dominator tree for CF G from Figure 5 is shown in in O (Eff (E; N )) time <ref> [35] </ref> or (by a more difficult algorithm) in O (E) time [26]. For all practical purposes, ff (E; N ) is a small constant, 4 so this paper will consider the dominator tree to have been found in linear time. <p> Y such that X dominates a predecessor of Y but does not strictly dominate Y : DF (X) = f Y j (9 P 2 P red (Y ))( X P and X j Y ) g: 4 Under the definition of ff used in analyzing the dominator tree algorithm <ref> [35, p. 123] </ref>, N E implies that ff (E; N ) = 1 when log 2 N &lt; 16 and ff (E; N ) = 2 when 16 log 2 N &lt; 2 16 . 17 Entry ? 1 2 L L 3 Hj H 5 H H 7 fi fi <p> In RCF G, this says that Y dominates a predecessor of X but does not strictly dominate X, i.e., X 2 DF (Y ). 2 RCF G by the standard method <ref> [35] </ref> in time O (Eff (E; N )), we spend O (size (RDF )) finding dominance frontiers and then inverting them. The total time is thus O (E + size (RDF )) for all practical purposes.
Reference: [36] <editor> S. S. Muchnick and N. D. Jones, editors. </editor> <title> Program Flow Analysis. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: and time bounds, compares our technique with other techniques, and presents some conclusions. 2 Control Flow Graphs The statements of a program are organized into (not necessarily maximal) basic blocks, where program flow enters a basic block at its first statement and leaves the basic block at its last statement <ref> [1, 36] </ref>. Basic blocks are indicated by the column of numbers in parentheses in Figure 5. A control flow graph is a directed graph whose nodes are the basic blocks of a program and two additional nodes, Entry and Exit.
Reference: [37] <author> E. W. Myers. </author> <title> A precise interprocedural data flow algorithm. </title> <booktitle> Conf. Rec. Eighth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <month> January </month> <year> 1981. </year> <month> 50 </month>
Reference-contexts: Such assumptions limit the extent that transfromations can be performed. Techniques are available to extract more detailed information: to determine parameter aliasing and effects of procedures on global variables, see <ref> [7, 8, 9, 19, 37, 42] </ref>; to determine pointer aliasing, see [14, 15, 27, 29, 33, 34, 44]. When a sophisticated analysis technique is applied, the usual result is that there are few side effects and the tuples (both LHS and RHS) are small. Small tuples can be represented directly.
Reference: [38] <author> K. J. Ottenstein. </author> <title> Data-flow Graphs as an Intermediate Form. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Sci., Purdue U., W. Lafayette, IN, </institution> <month> August </month> <year> 1978. </year>
Reference-contexts: control dependent on this conditional branch. 9 The definition used here is broader than the usual one [1, p. 595] and similar to that of "faint" variables [25, p. 489]. 36 Several published algorithms eliminate dead code in the narrower sense that requires every conditional branch to be marked live <ref> [30, 31, 38] </ref>. 10 Our algorithm, given in Figure 17, goes one step further in eliminating dead conditional branches. (An unpublished algorithm by R.
Reference: [39] <author> L. </author> <title> Pointer. </title> <type> Perfect report: 1. Technical Report CSRD 896, </type> <institution> Center for Supercomputing Research and Development, University of Illinois at Urbana-Champaign, Urbana, Illinois, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: We implemented our algorithms for constructing dominance frontiers and placing -functions in the PTRAN system, which already offered the required local data flow and control flow analysis [2]. We ran these algorithms on 61 library procedures from EISPACK [46] and 160 procedures from two "Perfect" <ref> [39] </ref> benchmarks. Some summary statistics of these procedures are shown in Figure 20.
Reference: [40] <author> J. H. Reif and H. R. Lewis. </author> <title> Efficent symbolic analysis of programs. </title> <journal> J. Computer and System Sciences, </journal> <volume> 32(3) </volume> <pages> 280-313, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: If a variable has D definitions and U uses, then there can be D fi U def-use chains. When similar information is encoded in SSA form, there can be at most E def-use chains, 3 where E is the number of edges in the control flow graph <ref> [40] </ref>. Moreover, the def-use information encoded in SSA form can be updated easily when optimizations are applied. This is important for a constant propagation algorithm that deletes branches to code proven at compile time to be unexecutable [50].
Reference: [41] <author> J. H. Reif and R. E. Tarjan. </author> <title> Symbolic program analysis in almost linear time. </title> <journal> SIAM J. Computing, </journal> <volume> 11(1) </volume> <pages> 81-93, </pages> <month> February </month> <year> 1982. </year>
Reference-contexts: Without explicit -functions, however, it was difficult to manage the new names or reason about the flow of values. Suppose the control flow graph CF G has N nodes and E edges for a program with Q variables. One algorithm <ref> [41] </ref> requires O (Eff (E; N )) bit vector operations (where each vector is of length Q) to find all the pseudo-assignments. A simpler algorithm [43] for reducible programs computes SSA form in time O (E fi Q).
Reference: [42] <author> B. K. Rosen. </author> <title> Data flow analysis for procedural languages. </title> <journal> J. ACM, </journal> <volume> 26(2) </volume> <pages> 322-344, </pages> <month> April </month> <year> 1979. </year>
Reference-contexts: Such assumptions limit the extent that transfromations can be performed. Techniques are available to extract more detailed information: to determine parameter aliasing and effects of procedures on global variables, see <ref> [7, 8, 9, 19, 37, 42] </ref>; to determine pointer aliasing, see [14, 15, 27, 29, 33, 34, 44]. When a sophisticated analysis technique is applied, the usual result is that there are few side effects and the tuples (both LHS and RHS) are small. Small tuples can be represented directly.
Reference: [43] <author> B. K. Rosen, M. N. Wegman, and F. K. Zadeck. </author> <title> Global value numbers and redundant computations. </title> <booktitle> Conf. Rec. Fifteenth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 12-27, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: 1 Introduction In optimizing compilers, data structure choices directly influence the power and efficiency of practical program optimization. A poor choice of data structure can inhibit optimization or slow compilation to the point where advanced optimization features become undesirable. Recently, static single assignment (SSA) form <ref> [5, 43] </ref> and the control dependence graph [24] have been proposed to represent data flow and control flow properties of programs. Each of these previously unrelated techniques lends efficiency and power to a useful class of program optimizations. <p> Optimizations that can benefit from using SSA form include code motion [22] and elimination of partial redundancies <ref> [43] </ref>, as well as the constant propagation discussed later in this section. Original Optimized Intermediate Code Intermediate Code A H H H A Horizontal arrows represent optimizations. Variants of SSA form have been used for detecting program equivalence [5, 52] and for increasing parallelism in imperative programs [21]. <p> The original assignments to V are live, but the added assignment by the -function is dead. Often such dead -functions are useful, as in the equivalencing and redundancy elimination algorithms that are based on SSA form <ref> [5, 43] </ref>. One such use is shown in Figure 16. Although others have avoided placement of dead -functions in translating to SSA form [16, 52], we prefer to include the dead -functions to increase optimization opportunities. There are many different definitions of dead code in the literature. <p> Suppose the control flow graph CF G has N nodes and E edges for a program with Q variables. One algorithm [41] requires O (Eff (E; N )) bit vector operations (where each vector is of length Q) to find all the pseudo-assignments. A simpler algorithm <ref> [43] </ref> for reducible programs computes SSA form in time O (E fi Q). With lengths of bit vectors taken into account, both of these algorithms are essentially O (R 2 ) on programs of size R, and the simpler algorithm sometimes inserts extraneous -functions.
Reference: [44] <author> C. Ruggieri and T. P. Murtagh. </author> <title> Lifetime analysis of dynamically allocated objects. </title> <booktitle> Conf. Rec. Fifteenth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 285-293, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Such assumptions limit the extent that transfromations can be performed. Techniques are available to extract more detailed information: to determine parameter aliasing and effects of procedures on global variables, see [7, 8, 9, 19, 37, 42]; to determine pointer aliasing, see <ref> [14, 15, 27, 29, 33, 34, 44] </ref>. When a sophisticated analysis technique is applied, the usual result is that there are few side effects and the tuples (both LHS and RHS) are small. Small tuples can be represented directly. Sophisticated analysis, however, is often unavailable.
Reference: [45] <author> R. M. Shapiro and H. </author> <title> Saint. The representation of algorithms. </title> <type> Technical Report CA-7002-1432, </type> <institution> Massachusetts Computer Associates, </institution> <month> February </month> <year> 1970. </year>
Reference-contexts: The only quadratic behavior is caused by the output being (R 2 ) in the worst case. The data in x8 suggest that the control dependence calculation is effectively O (R). 9.2 Related Work Minimal SSA form is a refinement of Shapiro and Saint's <ref> [45] </ref> notion of a pseudo-assignment. The pseudo-assignment nodes for V are exactly the nodes that need -functions for V . A closer precursor [22] of SSA form associated new names for V with pseudo-assignment nodes and inserted assignments from one new name to another.
Reference: [46] <author> B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow, Y. Ikebe, V. C. Klema, and C. B. Moler. </author> <title> Matrix Eigensystem Routines - Eispack Guide. </title> <publisher> Springer-Verlag, </publisher> <address> NY, NY, </address> <year> 1976. </year>
Reference-contexts: We implemented our algorithms for constructing dominance frontiers and placing -functions in the PTRAN system, which already offered the required local data flow and control flow analysis [2]. We ran these algorithms on 61 library procedures from EISPACK <ref> [46] </ref> and 160 procedures from two "Perfect" [39] benchmarks. Some summary statistics of these procedures are shown in Figure 20.
Reference: [47] <author> R. E. Tarjan. </author> <title> Finding dominators in directed graphs. </title> <journal> SIAM J. Computing, </journal> <volume> 3(1) </volume> <pages> 62-89, </pages> <year> 1974. </year>
Reference-contexts: The variables are renamed (x5.2) by replacing each mention of an original variable V by an appropriate mention of a new variable V i . 16 4 Dominance Section 4.1 reviews the dominance relation <ref> [47] </ref> between nodes in the control flow graph and how to summarize this relation in a dominator tree.
Reference: [48] <author> B. Wegbreit. </author> <title> Property extraction in well-founded property sets. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> SE-1(3):270-285, </volume> <month> September </month> <year> 1975. </year>
Reference-contexts: If Q is the constant true, then all uses of V after the join point are really uses of the constant 4. Such possibilities can be taken into account without SSA form, but the processing is either costly <ref> [48] </ref> or difficult to understand [49]. With SSA form, the algorithm is fast and simple. Initially, the algorithm assumes that each edge is unexecutable (i.e., never followed at run time) and that each variable is constant with an as-yet unknown value (denoted &gt;).
Reference: [49] <author> M. N. Wegman and F. K. Zadeck. </author> <title> Constant propagation with conditional branches. </title> <booktitle> Conf. Rec. Twelfth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 291-299, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: If Q is the constant true, then all uses of V after the join point are really uses of the constant 4. Such possibilities can be taken into account without SSA form, but the processing is either costly [48] or difficult to understand <ref> [49] </ref>. With SSA form, the algorithm is fast and simple. Initially, the algorithm assumes that each edge is unexecutable (i.e., never followed at run time) and that each variable is constant with an as-yet unknown value (denoted &gt;). Worklists are initialized appropriately, and the assumptions are corrected until they stabilize.
Reference: [50] <author> M. N. Wegman and F. K. Zadeck. </author> <title> Constant propagation with conditional branches. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <note> 1991. To appear. 51 </note>
Reference-contexts: Moreover, the def-use information encoded in SSA form can be updated easily when optimizations are applied. This is important for a constant propagation algorithm that deletes branches to code proven at compile time to be unexecutable <ref> [50] </ref>. Specifically, the def-use information is just a list, for each variable, of the places in the program text that use that variable. Every use of V is indeed a use of the value provided by the (unique) assignment to V. <p> Indeed, there is only one assignment to V i in the entire program. This simplifies the record keeping for several optimizations. An especially clear example is constant propagation based on SSA form <ref> [50] </ref>, so the next subsection sketches this application. if P if P then V 4 then V 1 4 else V 6 else V 2 6 V 3 (V 1 ; V 2 ) /* Use V several times. */ /* Use V 3 several times. */ 4 1.1 Constant Propagation <p> V + 5 ... V 3 + 5 5 constants to V seem to "reach" all uses after the join point. They would thus decide that V is not constant at these uses. The algorithm just sketched is linear in the size of the SSA program it sees <ref> [50] </ref>, but this size might be nonlinear in the size of the original program. In particular, it would be safe but inefficient to place a -function for every variable at every join point. This paper shows how to obtain SSA form efficiently.
Reference: [51] <author> M. J. Wolfe. </author> <title> Optimizing Supercompilers for Supercomputers. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Sci., U. of Illinois at Urbana-Champaign, Urbana IL, </institution> <year> 1982. </year>
Reference-contexts: One reasonable response to the crudeness of the Update operator is to accept it. Address calculations and other genuine scalar calculations can still be optimized extensively. Another response is to perform dependence analysis <ref> [3, 10, 32, 51] </ref>, which can sometimes determine that no subsequent accesses of A require values produced by any other assignment to A. Such is the case for each execution of the assignment to A (i) on the left in Figure 8.
Reference: [52] <author> W. Yang, S. Horwitz, and T. Reps. </author> <title> Detecting program components with equivalent behaviors. </title> <type> Technical Report 840, </type> <institution> Dept. of Computer Sci., U. of Wisconsin at Madison, Madison, WI, </institution> <month> April </month> <year> 1989. </year> <month> 52 </month>
Reference-contexts: Original Optimized Intermediate Code Intermediate Code A H H H A Horizontal arrows represent optimizations. Variants of SSA form have been used for detecting program equivalence <ref> [5, 52] </ref> and for increasing parallelism in imperative programs [21]. The representation of simple data flow information (def-use chains) may be more compact through SSA form. If a variable has D definitions and U uses, then there can be D fi U def-use chains. <p> For us, the semantics of are only important when assessing the correctness of intermediate steps in a sequence of program transformations beginning and ending with code that has no -functions. Others <ref> [6, 11, 52] </ref> have found it useful to give another parameter that incidentally encodes j, under various restrictions on the control flow. 10 in X. The value of (R; S; :::) is just the value of the j-th operand. <p> Some variants of -functions as defined here are useful for special purposes. For example, each -function can be tagged with the node X where it appears [5]. When the control flow of a language is suitably restricted, each -function can be tagged with information about conditionals or loops <ref> [5, 6, 11, 52] </ref>. The algorithms in this paper apply to such variants as well. Static single assignment form may be considered as a property of a single program or as a relation between two programs. <p> However, extraneous -functions can cause information to be lost, and they always add unnecessary overhead to the optimization process itself. Thus it is important to place -functions only where they are required. One variant of SSA form <ref> [52] </ref> would sometimes forego placing a -function at a convergence point Z, so long as there are no more uses for V in or after Z. The -function could then be omitted without any risk of losing Condition 3. <p> Often such dead -functions are useful, as in the equivalencing and redundancy elimination algorithms that are based on SSA form [5, 43]. One such use is shown in Figure 16. Although others have avoided placement of dead -functions in translating to SSA form <ref> [16, 52] </ref>, we prefer to include the dead -functions to increase optimization opportunities. There are many different definitions of dead code in the literature. Dead code is sometimes defined to be unreachable code and sometimes defined (as it is here) to be ineffectual code.
References-found: 52

