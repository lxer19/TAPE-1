URL: file://ftp.di.unipi.it/pub/Papers/giacobazzi/alp92.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: fbarbuti,giacog@di.unipi.it  codish@cs.kuleuven.ac.be  mjm@watson.ibm.com  
Phone: 2  3  
Title: Oracle Semantics for Prolog  
Author: Roberto Barbuti Michael Codish Roberto Giacobazzi Michael Maher 
Address: Pisa, I-56125 Pisa  B-3001 Leuven  P.O. Box 704, Yorktown Heights, NY 10598  
Affiliation: 1 Dipartimento di Informatica Universita di  Department of Computer Science Katholieke Universiteit Leuven,  IBM T.J. Watson Research Center  
Abstract: This paper proposes to specify semantic definitions for Pro-log in terms of an oracle which provides information on which clauses are to be applied to resolve a given goal. The approach is quite general. It is applicable to pure Prolog to define both operational and declarative semantics; and can be viewed as a basis for both sequential and parallel implementations. Previous semantic definitions for Prolog typically attempt to encode the sequential depth-first search of the language into various mathematical frameworks. A clause is applied in such semantics only if it is chosen under the search strategy. We prefer instead to specify in a more declarative way the condition upon which a clause is to be applied. The decision whether or not to apply a clause may be viewed as a query to an oracle which may be specified from within the semantics or reasoned about from outside. This approach results in simple and concise semantic definitions which are more useful for arguing the correctness of program transformations and providing the basis for abstract interpretations than previous proposals.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K. R. Apt, R. N. Bol, and J.W. Klop. </author> <title> On the safe termination of PROLOG programs. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Proc. Sixth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 353-368. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: If we wish to obtain approximate semantics of Prolog, for program analysis, we can approximate each of these components independently. Thus oracle semantics provides a framework for combining work on termination <ref> [1, 2, 3, 22] </ref> with work on semantics-based analysis (e.g. abstract interpretation, type inference). Usual analyses, which are based on the semantics of sequential logic programs, can be viewed as using the trivial termination approximation: the oracle f = P :s:P .
Reference: 2. <author> K. R. Apt and D. Pedreschi. </author> <title> Studies in Pure Prolog: Termination. </title> <editor> In J. W. Lloyd, editor, </editor> <booktitle> Computational Logic, </booktitle> <pages> pages 150-176. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: If we wish to obtain approximate semantics of Prolog, for program analysis, we can approximate each of these components independently. Thus oracle semantics provides a framework for combining work on termination <ref> [1, 2, 3, 22] </ref> with work on semantics-based analysis (e.g. abstract interpretation, type inference). Usual analyses, which are based on the semantics of sequential logic programs, can be viewed as using the trivial termination approximation: the oracle f = P :s:P .
Reference: 3. <author> K. R. Apt and D. Pedreschi. </author> <title> Proving Termination of General Prolog Programs. </title> <editor> In T. Ito and A.R. Meyer, editors, </editor> <booktitle> Proc. of Int. Conf. on Theoretical Aspects of Computer Software, volume 526 of Lecture Notes in Computer Science, </booktitle> <pages> pages 265-289, </pages> <address> Sendai, Japan, </address> <year> 1991. </year>
Reference-contexts: If we wish to obtain approximate semantics of Prolog, for program analysis, we can approximate each of these components independently. Thus oracle semantics provides a framework for combining work on termination <ref> [1, 2, 3, 22] </ref> with work on semantics-based analysis (e.g. abstract interpretation, type inference). Usual analyses, which are based on the semantics of sequential logic programs, can be viewed as using the trivial termination approximation: the oracle f = P :s:P .
Reference: 4. <author> B. Arbab and D.M. Berry. </author> <title> Operational and Denotational Semantics of Prolog. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 309-330, </pages> <year> 1987. </year>
Reference-contexts: For this reason the semantics of Prolog is usually given by encoding operational semantics in frameworks such as dynamic algebra [6], deterministic transition systems [8], and denotational semantics <ref> [4, 9, 16] </ref>. In our approach, the semantics of logic programs is parameterized by a specification of the set of clauses applicable at each step in the computation. We call such a specification an oracle. Pure Prolog results from the choice of a specific oracle.
Reference: 5. <author> R. Barbuti, M. Codish, R. Giacobazzi, and G. Levi. </author> <title> Modelling Prolog Control. </title> <booktitle> In Proc. Nineteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 95-104. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: That is, we can express the Prolog oracle declaratively. We now turn to the problem of expressing the Prolog semantics in a T P -like manner. 4.2 An oracle declarative semantics for Prolog In <ref> [5] </ref> we stressed the fact that at each step in a Prolog computation, the set of clauses applicable to the left-most atom in a goal depends on the whole goal under the current substitution. <p> Switching P and I in the T P definition corresponds to switch the construction of proof trees from bottom-up to top-down. The resulting immediate consequence operator corresponds to the unfolding semantics of the program [17]. An alternative approach to solve this problem is in <ref> [5] </ref>. However that solution is rather complex and more difficult to abstract for the purposes of abstract interpretation. Definition 17. (oracle fixpoint semantics) Let P be a logic program, f an oracle for P and I a clausal interpretation. <p> A bottom-up characterization of Prolog success set requires more complex semantics objects like the ones introduced in <ref> [5] </ref>, where Prolog programs were encoded in an ask/tell constraint language by means of a transformation.
Reference: 6. <author> E. Borger. </author> <title> A logical operational semantics of full prolog. </title> <editor> In E.Borger, H. Kleine, H. Buning, and M. Richter, editors, </editor> <booktitle> CSL 89. 3rd workshop on Computer Science Logic, volume 440 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: Because in these semantics the control is explicit, they are suitable for languages, like Prolog, in which the success set for a program strongly depends on the control. For this reason the semantics of Prolog is usually given by encoding operational semantics in frameworks such as dynamic algebra <ref> [6] </ref>, deterministic transition systems [8], and denotational semantics [4, 9, 16]. In our approach, the semantics of logic programs is parameterized by a specification of the set of clauses applicable at each step in the computation. We call such a specification an oracle.
Reference: 7. <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Contributions to the Semantics of Open Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <year> 1992. </year> <note> To appear. </note>
Reference-contexts: We perform both of these tasks in section 4. In a step-by-step manner, we enhance the usual bottom-up semantics of logic programs until it is powerful enough to characterize termination. (This involves extending the notion of interpretation to a set of clauses, as in <ref> [7] </ref>.) From this we obtain our declarative characterization of the Prolog oracle. We then present a simple T P -like semantics for Prolog, using the oracle, which is obtained by interchanging the roles played by the program and interpretation in usual T P -like semantics. <p> In this paper we follow a different approach which extends more naturally to capture in addition to sequential selection also depth-first search. This is facilitated by enhancing the semantic domain to include clauses, as proposed in <ref> [7] </ref>. The use of clauses as semantic objects is considered in [13, 7] to model pro-gram compositionality. In particular [7] defines a bottom-up semantics in which interpretations consist of clauses instead of atoms. <p> In this paper we follow a different approach which extends more naturally to capture in addition to sequential selection also depth-first search. This is facilitated by enhancing the semantic domain to include clauses, as proposed in [7]. The use of clauses as semantic objects is considered in <ref> [13, 7] </ref> to model pro-gram compositionality. In particular [7] defines a bottom-up semantics in which interpretations consist of clauses instead of atoms. In this approach an interpretation for a program is a set of clauses; each clause representing a partial computation from its head to its body. <p> This is facilitated by enhancing the semantic domain to include clauses, as proposed in <ref> [7] </ref>. The use of clauses as semantic objects is considered in [13, 7] to model pro-gram compositionality. In particular [7] defines a bottom-up semantics in which interpretations consist of clauses instead of atoms. In this approach an interpretation for a program is a set of clauses; each clause representing a partial computation from its head to its body. <p> Definition 12. (clause interpretations) Let P be a logic program. A clause interpretation is a subset of Clause (; ; Var) ~ . The definition of the declarative clausal semantics is technically simplified by applying the clause interpretation denoted by = fi <ref> [7] </ref>. The role of in the following definition is to capture empty partial computations and is exemplified below. Definition 13. (clausal semantics for lp [7]) Let P be a logic program and I be a clausal interpretation. <p> The definition of the declarative clausal semantics is technically simplified by applying the clause interpretation denoted by = fi <ref> [7] </ref>. The role of in the following definition is to capture empty partial computations and is exemplified below. Definition 13. (clausal semantics for lp [7]) Let P be a logic program and I be a clausal interpretation.
Reference: 8. <author> A. de Bruin and E. de Vink. </author> <title> Continuation semantics for Prolog with cut. </title> <editor> In J. Diaz and F. Orejas, editors, </editor> <booktitle> Proc. CAAP 89, volume 351 of Lecture Notes in Computer Science, </booktitle> <pages> pages 178-192. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference-contexts: For this reason the semantics of Prolog is usually given by encoding operational semantics in frameworks such as dynamic algebra [6], deterministic transition systems <ref> [8] </ref>, and denotational semantics [4, 9, 16]. In our approach, the semantics of logic programs is parameterized by a specification of the set of clauses applicable at each step in the computation. We call such a specification an oracle. Pure Prolog results from the choice of a specific oracle.
Reference: 9. <author> S. K. Debray and P. Mishra. </author> <title> Denotational and Operational Semantics for Prolog. </title> <editor> In M. Wirsing, editor, </editor> <booktitle> Formal Description of Programming Concepts III, </booktitle> <pages> pages 245-269. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1987. </year>
Reference-contexts: For this reason the semantics of Prolog is usually given by encoding operational semantics in frameworks such as dynamic algebra [6], deterministic transition systems [8], and denotational semantics <ref> [4, 9, 16] </ref>. In our approach, the semantics of logic programs is parameterized by a specification of the set of clauses applicable at each step in the computation. We call such a specification an oracle. Pure Prolog results from the choice of a specific oracle.
Reference: 10. <author> M. Falaschi and G. Levi. </author> <title> Finite failures and partial computations in concurrent logic languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 75 </volume> <pages> 45-66, </pages> <year> 1990. </year>
Reference-contexts: Furthermore, as partial answers are dependent on the selection rule; the results of this subsection are refined below to consider left-to-right selection. It is straightforward to derive partial answers in a bottom-up semantics. The standard approach is first demonstrated in <ref> [10] </ref>.
Reference: 11. <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: The approach considered in this section is based on the observation that both top-down and bottom-up semantics of logic programs can be expressed in terms of program unfolding. In particular, the non-ground T P semantics of <ref> [11] </ref> can be viewed as deriving the facts from the unfoldings of P [17]. While the first two enhancements described below follow the usual bottom-up approach; the third is technically simpler when described by viewing unfolding as a top-down process. <p> k1 ); (h k B k ; d k ) &lt;&lt; C I [ D ; d = i=1 9 &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; ; We can show that D slp P is continuous and consistent with the semantics of <ref> [11] </ref>, namely that lfp (T P ) = fi fi ([h true] ~ ; d ) 2 lfp (D slp . We also have Theorem 16. Let P be a sequential logic program.
Reference: 12. <author> M. Gabbrielli and M. C. Meo. </author> <title> Fixpoint Semantics for Partial Computed Answer Substitutions and Call Patterns. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Proceedings of Third International Conference on Algebraic and Logic Programming, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year> <note> In this Proceedings. </note>
Reference-contexts: In this approach an interpretation for a program is a set of clauses; each clause representing a partial computation from its head to its body. We apply this approach to capture partial answers in a bottom-up semantics. Notice that a similar technique was developed independently in <ref> [12] </ref>. We will apply the results of this section to the definition of the declarative semantics of Prolog. Definition 12. (clause interpretations) Let P be a logic program. A clause interpretation is a subset of Clause (; ; Var) ~ .
Reference: 13. <author> H. Gaifman and E. Shapiro. </author> <title> Fully abstract compositional semantics for logic programs. </title> <booktitle> In Proc. Sixteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 134-142. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: In this paper we follow a different approach which extends more naturally to capture in addition to sequential selection also depth-first search. This is facilitated by enhancing the semantic domain to include clauses, as proposed in [7]. The use of clauses as semantic objects is considered in <ref> [13, 7] </ref> to model pro-gram compositionality. In particular [7] defines a bottom-up semantics in which interpretations consist of clauses instead of atoms. In this approach an interpretation for a program is a set of clauses; each clause representing a partial computation from its head to its body.
Reference: 14. <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: In this section we briefly outline how it can be applied to these extensions. The results of this paper extend very straightforwardly to constraint logic programming languages <ref> [14] </ref>, replacing substitutions by constraints and unification by constraint solving. This work applies to pure CLP (R) with depth-first search and left-to-right selection of atoms, that is, CLP (R) without meta-logical features and without delayed constraints.
Reference: 15. <author> J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(R) Language and System. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> 1991. To appear. </note>
Reference-contexts: This work applies to pure CLP (R) with depth-first search and left-to-right selection of atoms, that is, CLP (R) without meta-logical features and without delayed constraints. To handle delayed constraints and thus be applicable to what is essentially the language described in <ref> [15] </ref> some further changes must be made. States must distinguish between delayed and (the usual) awake constraints, and transitions and functions must express the (possible) awakening of constraints after an execution step. However the modifications are not difficult to make.
Reference: 16. <author> N. D. Jones and A. Mycroft. </author> <title> Stepwise Development of Operational and Deno-tational Semantics for Prolog. </title> <editor> In Sten -Ake Tarnlund, editor, </editor> <booktitle> Proc. Second Int'l Conf. on Logic Programming, </booktitle> <pages> pages 281-288, </pages> <year> 1984. </year>
Reference-contexts: For this reason the semantics of Prolog is usually given by encoding operational semantics in frameworks such as dynamic algebra [6], deterministic transition systems [8], and denotational semantics <ref> [4, 9, 16] </ref>. In our approach, the semantics of logic programs is parameterized by a specification of the set of clauses applicable at each step in the computation. We call such a specification an oracle. Pure Prolog results from the choice of a specific oracle.
Reference: 17. <author> G. Levi. </author> <title> Models, Unfolding Rules and Fixpoint Semantics. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1649-1665. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: The approach considered in this section is based on the observation that both top-down and bottom-up semantics of logic programs can be expressed in terms of program unfolding. In particular, the non-ground T P semantics of [11] can be viewed as deriving the facts from the unfoldings of P <ref> [17] </ref>. While the first two enhancements described below follow the usual bottom-up approach; the third is technically simpler when described by viewing unfolding as a top-down process. <p> This is possible because both programs and interpretations have the same structure. Switching P and I in the T P definition corresponds to switch the construction of proof trees from bottom-up to top-down. The resulting immediate consequence operator corresponds to the unfolding semantics of the program <ref> [17] </ref>. An alternative approach to solve this problem is in [5]. However that solution is rather complex and more difficult to abstract for the purposes of abstract interpretation. Definition 17. (oracle fixpoint semantics) Let P be a logic program, f an oracle for P and I a clausal interpretation.
Reference: 18. <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: We close with a short conclusion. Proofs, not included due to space limitations, are present in the full version of this paper. 2 Preliminaries In the following we assume familiarity with the standard definitions and notation for logic programs <ref> [18] </ref>. Throughout, , and Var will respectively denote a set of function symbols, a set of predicate symbols and a denumerable set of variables. The non-ground term algebra over and Var is denoted Term (; Var) or Term for short. <p> The standard notion of a computation tree for an inital goal G and a pro gram P is captured by T ( lp P ; hG; *i). Definition 6 is often refined (e.g. <ref> [18] </ref>) by introducing a selection rule. In particular, Prolog assumes a left-to-right selection rule. Logic programs with a left-to-right selection rule are termed sequential logic programs. Definition 7. (transition system, slp Let P be a logic program.
Reference: 19. <author> N.D.Jones and H.Stndergaard. </author> <title> A Semantics-based Framework for the Abstract Interpretation of Prolog. </title> <editor> In S. Abramsky and C. Hankin, editors, </editor> <booktitle> Abstract Interpretation of Declarative Languages, </booktitle> <pages> pages 123-142. </pages> <publisher> Ellis Horwood Ltd, </publisher> <year> 1987. </year>
Reference-contexts: It is straightforward to apply a similar approach to provide other types of top-down semantics for Prolog. In particular the denotational semantics for logic programs with left--to-right selection specified in <ref> [19] </ref> is easily enhanced by an oracle to a Prolog semantics. 4 Declarative Semantics The objective of this section is to provide a semantic basis for the analysis of Prolog programs which maintains the simplicity of the T P -based approach.
Reference: 20. <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: This construction abstracts away from operational aspects of the interpreter, for example search strategy. Although declarative semantics can be specified in different frameworks, they are typically defined in terms of an immediate consequence operators such as the classic T P operator <ref> [20] </ref>. The least fixpoint of the standard T P operator specifies the set of ground atoms which are consequences of the program. On the other hand, operational semantics are much more closely linked to the interpreter. Such semantics generally follow a top-down and goal-dependent approach.
Reference: 21. <author> T. Vasak and J. Potter. </author> <title> Characterization of Terminating Logic Programs. </title> <booktitle> In Proc. Third IEEE Int'l Symp. on Logic Programming, </booktitle> <pages> pages 140-147. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1986. </year>
Reference-contexts: It is straightforward to show that Prolog computation of a goal G and program P terminates iff the state hG; *i terminates universally for the sequential logic program P ; namely iff T ( slp P ; hG ; *i) is of finite height <ref> [21] </ref>. Furthermore, by Konig's Lemma, T ( slp P ; hG; *i) is of finite height iff it is finite because slp has finite branching. Hence, Definition 11. (Prolog oracle) Let P be a Prolog program and hG; i a state.
Reference: 22. <author> K. Vershaetse and D. De Shreye. </author> <title> Deriving Termination Proofs for Logic Programs, Using Abstract Procedures. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 301-315. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: If we wish to obtain approximate semantics of Prolog, for program analysis, we can approximate each of these components independently. Thus oracle semantics provides a framework for combining work on termination <ref> [1, 2, 3, 22] </ref> with work on semantics-based analysis (e.g. abstract interpretation, type inference). Usual analyses, which are based on the semantics of sequential logic programs, can be viewed as using the trivial termination approximation: the oracle f = P :s:P .
References-found: 22

