URL: http://ftp.eecs.umich.edu/people/yenmin/cse-tr-170-93.ps
Refering-URL: http://ftp.eecs.umich.edu/people/yenmin/
Root-URL: http://www.eecs.umich.edu
Email: yenmin@eecs.umich.edu ravi@eecs.umich.edu  
Title: A Universal RPC Toolkit  
Author: Yen-Min Huang and Chinya V. Ravishankar 
Keyword: Index Terms Remote Procedure Call, Universal RPC Toolkit, RPC Runtime Library.  
Address: Ann Arbor, MI. 48109  
Affiliation: Electrical Engineering and Computer Science Department The University of Michigan,  
Abstract: Many new RPC systems have been built in the past to meet different application requirements. However, much development effort has been spent on redoing significant parts of the RPC system. This paper describes a toolkit (the URPC toolkit) for prototyping new RPC systems. The URPC toolkit achieves its goal by letting programmers provide high-level implementations of RPC semantics and customize the supporting RPC services, such as stub generation and name service, to match the requirements of different RPC semantics. This approach allows the maximal flexibility in constructing new RPC systems with the minimal coding effort. In addition, with this approach, most optimization in handcrafted implementation can be preserved, and thus, the resulting RPC can be just as fast as handcrafted ones. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. H. Tay and A. L. Ananda. </author> <title> A Survey of Remote Procedure Calls. </title> <journal> Operating Systems Review, </journal> <volume> 24(3) </volume> <pages> 68-78, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: 1 Introduction A variety of RPC semantics have been designed and implemented in recent years. Examples are synchronous RPC, asynchronous RPC, fault tolerant RPC, multicast RPC, and RPC with atomic transactions <ref> [1, 2] </ref>. Despite this variety, there will be continued need for building RPCs with new semantics, because it is impossible for existing RPCs to address all the requirements of future applications. Even today's distributed applications can still benefit from new RPC implementations providing better throughput, response time, and failure resilience.
Reference: [2] <author> A. L. Ananda, B. H. Tay, and E. K. Koh. </author> <title> A Survey of Asynchronous Remote Procedure Calls. </title> <journal> Operating Systems Review, </journal> <volume> 26(2) </volume> <pages> 92-109, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: 1 Introduction A variety of RPC semantics have been designed and implemented in recent years. Examples are synchronous RPC, asynchronous RPC, fault tolerant RPC, multicast RPC, and RPC with atomic transactions <ref> [1, 2] </ref>. Despite this variety, there will be continued need for building RPCs with new semantics, because it is impossible for existing RPCs to address all the requirements of future applications. Even today's distributed applications can still benefit from new RPC implementations providing better throughput, response time, and failure resilience.
Reference: [3] <author> Y. Huang and C. V. Ravishankar. </author> <title> Designing An Agent Synthesis System for Cross RPC Communication. </title> <note> submitted to IEEE Transactions on Software Engineering, </note> <year> 1993. </year>
Reference-contexts: Even within the protocol ma-chine implementation, a large portion of the development effort is spent at managing internal data structure and implementing low-level details. According to our study <ref> [3] </ref>, entire protocol machine implementation comprises only 30% to 40% of code of an RPC system, and high-level protocol code accounts even less (about 10 to 15%). <p> An example given in [18] is an RPC protocol with callback. By giving programmers more control to the runtime, the URPC toolkit not only can facilitate construction of both traditional and non-traditional RPCs, but also can result in a more general solution to the RPC heterogeneity problem <ref> [19, 3] </ref>. TI-RPC is a transport independent RPC, which can operate on top of any available transport-layer protocols. The URPC toolkit is not only independent of transport-layer protocols, but also independent of RPC semantics.
Reference: [4] <author> Y. Huang and C. V. Ravishankar. Cicero: </author> <title> A Protocol Construction Language. </title> <type> Technical Report CSE-TR-171-93, </type> <institution> Dept. of EECS, The University of Michigan, Ann Arbor, Michigan, </institution> <year> 1993. </year>
Reference-contexts: An interesting aspect of our toolkit is the separation of mechanisms that are not dependent on RPC semantics from those that are. This separation allows a new RPC runtime to be created from a protocol description written in either C or in our protocol construction language Cicero <ref> [4] </ref>. This approach turns out to be close to optimal in terms of maximizing flexibility in constructing new RPC semantics and minimizing the coding effort. Cicero is a language veneer designed to facilitate complex RPC protocol implementation. <p> The Cicero runtime library can be linked together with the URPC library to add multi-thread support to the URPC runtime. In this section, we will only highlight the features in Cicero, and the complete description of Cicero can be found elsewhere <ref> [4] </ref>. 4 To simplify the PM implementation, only one outstanding call for the same RPC ID is allowed. 17 Syntax Description when (x): A end; executes action A when x occurs. when (x?i): A end; same as the above, with variable i = j x j when (x ; y): A <p> Also, the dataflow execution model used by Cicero exploits parallelism in protocol execution, and also allows the protocol construction be translated to other formal models to take advantage of existing protocol verification tools. A fuller discussion of these issues in the context of Cicero can be found in <ref> [4] </ref>.
Reference: [5] <author> C. V Ravishankar and R. Finkel. </author> <title> Linguistic Support for Dataflow. </title> <type> Technical Report CSE-TR-14-89, </type> <institution> Dept. of EECS, The University of Michigan, Ann Arbor, Michigan, </institution> <year> 1989. </year>
Reference-contexts: This approach turns out to be close to optimal in terms of maximizing flexibility in constructing new RPC semantics and minimizing the coding effort. Cicero is a language veneer designed to facilitate complex RPC protocol implementation. A novel feature of Cicero is the use of event patterns <ref> [5] </ref> to control synchrony, asynchrony and concurrency in protocol execution. To match the flexibility provided by the toolkit, our stub generator can be instructed to generate customized stub routines, incorporating various protocol 2 implementations. <p> Instead of directly providing multi-thread support in the toolkit, we provide multi-thread support through Cicero. This strategy is advantageous because better language support can be provided to facilitate multi-thread protocol implementation. * It uses event patterns <ref> [5] </ref> to control synchrony, asynchrony, and concurrency in protocol execution. Event patterns provide a structured way for programmers to specify relationships between events controlling the protocol execution, so that complex interactions in protocol execution can be organized. * It helps programmers exploit parallelism in protocol execution.
Reference: [6] <author> Open Software Foundation. </author> <title> AES/Distributed Computing: Remote Procedure Call. </title> <address> Cam-bridge, MA., </address> <month> September </month> <year> 1992. </year>
Reference-contexts: up special client RPC/Topology (default = urpc client call ()) version optional Version number of the application (default = 1.0) Table 2: Attributes Allowed in the Global Definitions 2.1.2 Stub Generator and IDL The design of the stub generator is focused on extending OSF's current DCE/RPC interface definition language (IDL) <ref> [6] </ref> to match the flexibility provided by the runtime library. IDL is the language used to define the interfaces of remote procedure calls. A file containing IDL definitions is called an RPC interface specification (RIS), from which the RPC communication code (stubs) can be generated. <p> IDL is the language used to define the interfaces of remote procedure calls. A file containing IDL definitions is called an RPC interface specification (RIS), from which the RPC communication code (stubs) can be generated. Although our IDL syntax is similar to OSF's DCE/RPC IDL <ref> [6] </ref>, it has several unique extensions, which will be introduced in the order they appear in a RIS file. An RIS file consists of three parts: 1.
Reference: [7] <author> L. Zahn, T. H. Dineen, P. J. Leach, E. A. Martin, N. W. Mishkin, J. N. Pato, and G. L. Wyant. </author> <title> Network Computing Architecture. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1990. </year> <month> 22 </month>
Reference-contexts: Given a server name, the lookup service returns its end-point address. The registration service is used to register a name-to-end-point mapping with the name server. Although all RPC name servers provide these two services, they use different naming conventions. For example, HP/Apollo NCA RPC <ref> [7] </ref> uses UUIDs to name applications, while SUN RPC [8] combines a program number and a version number for the purpose. In contrast to traditional name servers with fixed name spaces, the URPC name server provides additional mechanisms for programmers to construct their own name spaces.
Reference: [8] <author> Sun Microsystems. </author> <title> Remote Procedure Call Protocol Specification Version 2 (RFC 1057). Network Information Center, </title> <booktitle> SRI International, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: The registration service is used to register a name-to-end-point mapping with the name server. Although all RPC name servers provide these two services, they use different naming conventions. For example, HP/Apollo NCA RPC [7] uses UUIDs to name applications, while SUN RPC <ref> [8] </ref> combines a program number and a version number for the purpose. In contrast to traditional name servers with fixed name spaces, the URPC name server provides additional mechanisms for programmers to construct their own name spaces. We have considered two possible design for name-space construction mechanisms. <p> The similarity in performance to SUN RPC is not surprising; it simply reflects the fact that we use a protocol machine implementation similar to SUN RPC. 6 Related Work Much RPC work focuses on designing and implementing new RPC systems to provide new se mantics and better performance <ref> [10, 8, 11, 12, 13, 14, 15, 16, 17] </ref>. Although our toolkit also provides some popular RPC semantics, it is aimed at providing mechanisms for RPC developers to prototype new RPC systems rapidly.
Reference: [9] <author> K. M. Kavi, B. P. Buckles, and U. N. Bhat. </author> <title> Isomorphism Between Petri nets and Dataflow Graphs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(10) </volume> <pages> 1127-1134, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: This feature may become increasingly important as more functionalities are pushed into RPC protocols, and as multi-processor workstations become more common. * It can hook to existing protocol verification tools. The dataflow style of execution can be translated into other formal models (e.g. Petri nets <ref> [9] </ref>), making it possible to use existing protocol verification methods/tools. Our prototype implementation of Cicero includes a compiler for translating Cicero constructs into C code and a Cicero runtime library providing implementation of these constructs.
Reference: [10] <author> A. P. Birrell and B. J. Nelson. </author> <title> Implementing Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: The similarity in performance to SUN RPC is not surprising; it simply reflects the fact that we use a protocol machine implementation similar to SUN RPC. 6 Related Work Much RPC work focuses on designing and implementing new RPC systems to provide new se mantics and better performance <ref> [10, 8, 11, 12, 13, 14, 15, 16, 17] </ref>. Although our toolkit also provides some popular RPC semantics, it is aimed at providing mechanisms for RPC developers to prototype new RPC systems rapidly.
Reference: [11] <author> T. H. Dineen, P. J. Leach, N. W. Mishkin, J. N. Pato, and G. L. Wyant. </author> <title> The Network Computing Architecture and System: An Environment for Developing Distributed Applications. </title> <booktitle> In Proc. of the Summer USENIX Conference, </booktitle> <pages> pages 385-398, </pages> <address> Phoenix, Arizona, </address> <year> 1987. </year>
Reference-contexts: The similarity in performance to SUN RPC is not surprising; it simply reflects the fact that we use a protocol machine implementation similar to SUN RPC. 6 Related Work Much RPC work focuses on designing and implementing new RPC systems to provide new se mantics and better performance <ref> [10, 8, 11, 12, 13, 14, 15, 16, 17] </ref>. Although our toolkit also provides some popular RPC semantics, it is aimed at providing mechanisms for RPC developers to prototype new RPC systems rapidly.
Reference: [12] <author> B. Liskov and L. Shrira. </author> <title> Promises: Linguistic Support for Efficient Asynchronous Procedure Calls in Distributed System. </title> <booktitle> In Proc. of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 260-267, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: The similarity in performance to SUN RPC is not surprising; it simply reflects the fact that we use a protocol machine implementation similar to SUN RPC. 6 Related Work Much RPC work focuses on designing and implementing new RPC systems to provide new se mantics and better performance <ref> [10, 8, 11, 12, 13, 14, 15, 16, 17] </ref>. Although our toolkit also provides some popular RPC semantics, it is aimed at providing mechanisms for RPC developers to prototype new RPC systems rapidly.
Reference: [13] <author> E. F. Walker, R. Floyd, and P. Neves. </author> <title> Asynchronous Remote Operation Execution in Distributed Systems. </title> <booktitle> In Proc. of 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 253-259, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: The similarity in performance to SUN RPC is not surprising; it simply reflects the fact that we use a protocol machine implementation similar to SUN RPC. 6 Related Work Much RPC work focuses on designing and implementing new RPC systems to provide new se mantics and better performance <ref> [10, 8, 11, 12, 13, 14, 15, 16, 17] </ref>. Although our toolkit also provides some popular RPC semantics, it is aimed at providing mechanisms for RPC developers to prototype new RPC systems rapidly.
Reference: [14] <author> A. L. Ananda, B. H. Tay, and E. K. Koh. </author> <title> ASTRA An Asynchronous Remote Procedural Call Facility. </title> <booktitle> In Proc. of 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 172-179, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The similarity in performance to SUN RPC is not surprising; it simply reflects the fact that we use a protocol machine implementation similar to SUN RPC. 6 Related Work Much RPC work focuses on designing and implementing new RPC systems to provide new se mantics and better performance <ref> [10, 8, 11, 12, 13, 14, 15, 16, 17] </ref>. Although our toolkit also provides some popular RPC semantics, it is aimed at providing mechanisms for RPC developers to prototype new RPC systems rapidly.
Reference: [15] <author> D. K. Gifford and N. Glasser. </author> <title> Remote Pipes and Procedures for Efficient Distributed Communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(3) </volume> <pages> 258-283, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: The similarity in performance to SUN RPC is not surprising; it simply reflects the fact that we use a protocol machine implementation similar to SUN RPC. 6 Related Work Much RPC work focuses on designing and implementing new RPC systems to provide new se mantics and better performance <ref> [10, 8, 11, 12, 13, 14, 15, 16, 17] </ref>. Although our toolkit also provides some popular RPC semantics, it is aimed at providing mechanisms for RPC developers to prototype new RPC systems rapidly.
Reference: [16] <author> K. S. Yap, P. Jalote, and S. Tripathi. </author> <title> Fault Tolerant Remote Procedure Call. </title> <booktitle> In Proc. of 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 48-54, </pages> <address> San Jose, CA, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: The similarity in performance to SUN RPC is not surprising; it simply reflects the fact that we use a protocol machine implementation similar to SUN RPC. 6 Related Work Much RPC work focuses on designing and implementing new RPC systems to provide new se mantics and better performance <ref> [10, 8, 11, 12, 13, 14, 15, 16, 17] </ref>. Although our toolkit also provides some popular RPC semantics, it is aimed at providing mechanisms for RPC developers to prototype new RPC systems rapidly.
Reference: [17] <author> B. Liskov and R. Scheifler. </author> <title> Guardians and Actions: Linguistic Support for Robust, Distributed Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 381-404, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: The similarity in performance to SUN RPC is not surprising; it simply reflects the fact that we use a protocol machine implementation similar to SUN RPC. 6 Related Work Much RPC work focuses on designing and implementing new RPC systems to provide new se mantics and better performance <ref> [10, 8, 11, 12, 13, 14, 15, 16, 17] </ref>. Although our toolkit also provides some popular RPC semantics, it is aimed at providing mechanisms for RPC developers to prototype new RPC systems rapidly.
Reference: [18] <author> B. N. Bershad, D. T. Ching, E. D. Lazowska, J. Sanislo, and M. Schwartz. </author> <title> A Remote Procedure Call Facility for Interconnecting Heterogeneous Computer Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(8) </volume> <pages> 880-894, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: HCS/HRPC <ref> [18] </ref> is a well-known heterogeneous RPC system. It can support multiple RPC protocols through mixing and matching different implementation of several principle components. However, non-traditional RPC protocols may be hard to emulate with HRPC components cleanly, because its components are designed to model the common functionalities of most RPC facilities. <p> It can support multiple RPC protocols through mixing and matching different implementation of several principle components. However, non-traditional RPC protocols may be hard to emulate with HRPC components cleanly, because its components are designed to model the common functionalities of most RPC facilities. An example given in <ref> [18] </ref> is an RPC protocol with callback. By giving programmers more control to the runtime, the URPC toolkit not only can facilitate construction of both traditional and non-traditional RPCs, but also can result in a more general solution to the RPC heterogeneity problem [19, 3].
Reference: [19] <author> Y. Huang and C. V. Ravishankar. </author> <title> Accommodating RPC Heterogeneities in Large Heterogeneous Distributed Environments. </title> <booktitle> In Proc. of the 26th Hawaii International Conference on System Sciences (HICSS-26), </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: An example given in [18] is an RPC protocol with callback. By giving programmers more control to the runtime, the URPC toolkit not only can facilitate construction of both traditional and non-traditional RPCs, but also can result in a more general solution to the RPC heterogeneity problem <ref> [19, 3] </ref>. TI-RPC is a transport independent RPC, which can operate on top of any available transport-layer protocols. The URPC toolkit is not only independent of transport-layer protocols, but also independent of RPC semantics.
Reference: [20] <author> L. Peterson, N. Hutchinson, S. O'Malley, and H. Rao. </author> <title> The x-Kernel: A Platform for Accessing Internet Resources. </title> <journal> IEEE Computer, </journal> <volume> 23(5) </volume> <pages> 23-33, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: The independence from RPC semantics is achieved by using a generic send/receive model to describe behavior of protocol machines and by allowing customization in its supporting facilities. This independence makes the URPC runtime library highly resuable for constructing new RPC semantics. The x-kernel <ref> [20, 21] </ref> is known for configuring protocol stacks with object-oriented sub-protocol components to achieve good protocol implementation. The goal of URPC is different from that of the x-kernel. The URPC toolkit is not for configuring existing protocols, but for constructing new RPC semantics/systems.

References-found: 20

