URL: ftp://ftp.cs.dartmouth.edu/TR/TR98-327.ps.Z
Refering-URL: http://www.cnri.reston.va.us/home/koe/bib/mobile-abs.bib.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Agent Tcl: A flexible and secure mobile-agent system  Examining Committee:  
Author: Robert S. Gray George Cybenko (chairman) David Kotz Daniela Rus Robert Sproull Edward Berger Dean 
Degree: A Thesis Submitted to the Faculty in partial fulfillment of the requirements for the degree of Doctor of Philosophy in Computer Science by  
Date: 30 June 1997  
Address: Hanover, New Hampshire  
Affiliation: DARTMOUTH COLLEGE  of Graduate Studies  
Abstract-found: 0
Intro-found: 1
Reference: [AS94] <author> Stephen Appleby and Simon Steward. </author> <title> Mobile software agents for control in telecommunication networks. </title> <journal> British Telecom Technical Journal, </journal> <volume> 12(2), </volume> <month> April </month> <year> 1994. </year>
Reference-contexts: Once these differences are taken into account, the Tacoma and Agent Tcl times are comparable. Network management. Steward and Appleby use lightweight mobile agents to control traffic congestion in a circuit-switched telecommunications network <ref> [SA94, AS94] </ref>. There are two kind of agents: load-management agents, which find routes that have the highest spare capacity and adjust routing tables accordingly, and em parent agents, which randomly walk around the network and launch load-management agents when an overload is detected. <p> In their experiments, the mobile agents reduced maximum node utilization by between 39 and 50 percent, in addition, there were no overloaded nodes and no unused nodes <ref> [SA94, AS94] </ref>. The authors acknowledge that the same effect could be achieved with a more traditional distributed algorithm, but argue that mobile agents provide an extremely fault-tolerant solution without undue programmer effort. <p> Network management. As discussed in the performance analysis section, Steward and Appleby use lightweight mobile agents to control traffic congestion in a circuit-switched telecommunications network <ref> [SA94, AS94] </ref>. Load-management agents find the routes that have the highest spare capacity and adjust routing tables accordingly; parent agents randomly walk around the network and launch load-management agents when an overload is detected.
Reference: [AS97] <author> Anurag Acharya and Joel Saltz. </author> <title> Dynamic linking for mobile programs. </title> <editor> In J. Vitek and C. Tschudin, editors, </editor> <booktitle> Mobile Object Systems, Springer-Verlag Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: We intend to eventually eliminate the ClassList argument and have the Agent Java system determine automatically which classes are used inside the agent. One way to automatically determine the class list is the dynamic linking technique of <ref> [AS97] </ref> which, given an incoming agent and the set of libraries available at the current machine, determines if there are any unbound references before the agent starts executing. 5.5 Agent Scheme Agent Scheme is partially complete.
Reference: [ATLLW96] <author> Ali-Reza Adl-Tabatabai, Geoff Langdale, Steven Lucco, and Robert Wahbe. </author> <title> Efficient and language-independent mobile programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 127-136, </pages> <year> 1996. </year>
Reference-contexts: Obliq does not address security issues. Omniware <ref> [LSW95, ATLLW96] </ref>. Omniware code is written in C++ (or any other language for which an appropriate compiler exists), compiled for a RISC-like virtual machine, and later sent to a destination machine where it is converted into native code. <p> In addition, there are faster execution environments such as Omniware that can execute an agent only 25 percent slower than natively compiled code on average <ref> [ATLLW96] </ref>; if such an environment is incorporated into Agent Tcl, the CPU load on the server (excluding migration overhead) will be about the same regardless of whether the server provides low-level operations and accepts agents or provides high-level operations and does not accept agents. 11 7.1.2 Agent migration or a remote <p> Agent languages. Omniware programs are compiled into intermediate code for a RISC-based virtual machine and then into software-fault-isolated (SFI) native code; this code runs only 25 percent slower than natively compiled code on average <ref> [LSW95, ATLLW96] </ref>. Java programs are compiled into intermediate code for a stack-based virtual machine and then either interpreted or compiled on-the-fly into native code. When interpreted, Java programs run 10 to 20 times slower than natively compiled C or C++ [CH97]. <p> Depending on the performance of Java agents relative to native code, we will consider either "just-in-time" compilation or software-fault-isolation of native code (or more likely of code for a low-level virtual machine that is immediately compiled into native code) <ref> [ATLLW96, WLAG93, LSW95] </ref>. Alternatively, the system could accept native code only from certain trusted users, eliminating the need for software fault isolation, but limiting untrusted agents to the slower, interpreted languages.
Reference: [BC95] <author> Krishna A. Bharat and Luca Cardelli. </author> <title> Migratory applications. </title> <booktitle> In Proceedings of the Eighth Annual ACM Symposium on User Interface Software and Technology, </booktitle> <month> November </month> <year> 1995. </year>
Reference-contexts: The Messengers system does not address most security issues, but the Messengers group is working on market-based approaches for fairly allocating resources among competing messengers [Tsc97]. Obliq <ref> [Car95, BC95, BN97] </ref>. Obliq is an interpreted, lexically scoped, object-oriented language. An Obliq object is a collection of named fields that contain methods, aliases and values. An object can be created at a remote site, cloned onto a remote site, or migrated with a combination of cloning and redirection.
Reference: [BDH + 94] <author> C. Mic Bowman, Peter B. Danzig, Darren R. Hardy, Udi Manber, and Michael F. Schwartz. Harvest: </author> <title> A scalable, customizable discovery and access system. </title> <type> Technical Report CU-CS-732-94, </type> <institution> University of Colorado, Boulder, CO, </institution> <month> August </month> <year> 1994. </year> <month> 205 </month>
Reference-contexts: Work is underway to (1) develop a standardized set of fields for describing agent services and (2) make the yellow pages more efficient, robust and maintainable, using techniques from other hierarchical service indices such as those in the Harvest information retrieval system <ref> [BDH + 94] </ref>. 9.4 Network sensing and path planning Under certain network conditions, it is more efficient for an agent to remain stationary and interact with a resource from a remote location, rather than migrating to that resource.
Reference: [BFD96] <author> Lubomir F. Bic, Munehiro Fukuda, and Michael B. Dillencourt. </author> <title> Dis--tributed computing using autonomous objects. </title> <journal> IEEE Computer, </journal> <volume> 29(8) </volume> <pages> 55-61, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: Agents in the MESSENGERS 11 system are written in C, compiled into machine-independent assembly code, and then interpreted at each node; the agents construct a logical network on top of the physical network as they execute <ref> [BFD96] </ref>. Mobile Service Agents (MSA) are written in an extended version of the functional programming language Facile; an MSA agent spawns a new agent by submitting a closure containing data and one or more functions [TLKC95, Kna96]. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ <ref> [LSW95, JvRS95, PS97, BFD96] </ref>, Java [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96], and various scripting languages [JvRS95, PS97, JdT + 95, Coe94]. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. <p> Of course, using fake currency to control agent propagation does not prevent a service from charging real money at the application level. Many other agent projects plan to use electronic cash to control agent propagation, including Tacoma [JvRS95], Ara [PS97], and Messengers <ref> [BFD96] </ref>. Little implementation work has been done by any of these projects.
Reference: [BHR + 97] <author> J. Baumann, F. Hohl, N. Radouniklis, M. Straber, and K. Rothermel. </author> <title> Communication concepts for mobile-agent systems. </title> <booktitle> In Proceedings of the First International Workshop on Mobile Agents (MA '97), volume 1219 of Lecture Notes in Computer Science, </booktitle> <address> Berlin, April 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: FTP Software no longer sells CyberAgents, but a version of CyberAgents that uses the TRAC language (rather than Java) is used in some of FTP Software's network management tools [Gre97a]. Other Java-based systems include Mole <ref> [SBH96, BHR + 97] </ref>, Concordia [Mit97a, WPW + 97], Voyager [Voy97], and Wasp [Fun97]. The Mole project is focusing on security mechanisms for protecting an agent from a malicious machine, while the Wasp project is concerned with integrating mobile agents with Web servers. Voyager and Concordia are commercial systems.
Reference: [BN84] <author> A. D. Birrell and B. J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: Any mobile-agent system must allow an agent to examine current network and machine conditions and then decide whether to migrate to a remote resource or remain at the current site and access the resource using the equivalent of message passing [SS94] or remote procedure call (RPC) <ref> [BN84] </ref>. Latency. By migrating to the location of a resource, an agent can interact with the resource much faster than from across the network. Such faster interaction is one of the main motivations for Java-enabled web browsers. <p> and flexible, but requires the programmer to handle low-level details, such as keeping track of which response goes with which request, converting data between client and server formats, determining the address of the server, and handling communication and system errors [SS94]. 3.2.2 Remote procedure call (RPC) Remote procedure call (RPC) <ref> [BN84] </ref> relieves the programmer of these details. RPC allows a program on the client to invoke a procedure on the server using the standard procedure call mechanism. Most RPC implementations use stub procedures [BN84, SS94]. A client that makes a remote procedure call is actually calling a local stub. <p> RPC allows a program on the client to invoke a procedure on the server using the standard procedure call mechanism. Most RPC implementations use stub procedures <ref> [BN84, SS94] </ref>. A client that makes a remote procedure call is actually calling a local stub. This client stub puts the procedure name and parameters into a message and sends the message to the remote machine. <p> The idea is to allow agents that have simple requirements to communicate with minimal overhead, while providing a base on top of which more complex communication protocols can be implemented efficiently at the agent level. Possible protocols include whiteboards, KQML [GSS94], remote procedure call (RPC) <ref> [BN84] </ref> and remote method invocation [YD96]. Agent RPC, which Saurab Nog and Sumit Chawla 9 developed as a course project, is an RPC mechanism for Agent Tcl [NCK96]. The architecture of Agent RPC is shown in Figure 9.4. <p> To efficiently support a wider range of com-munication styles, Agent Tcl must be extended so that a message can include either a string or arbitrary binary data. Helper routines would be provided to add and extract standard RPC data types <ref> [BN84] </ref> from a binary data buffer. The ability to transmit binary data would eliminate the parsing overhead, and in particular, would be a much more efficient lower-layer for the Agent RPC system [NCK96].
Reference: [BN97] <author> Marc H. Brown and Marc A. Najork. </author> <title> Distributed active objects. </title> <journal> Dr. Dobb's Journal, </journal> (263):34-41, March 1997. 
Reference-contexts: The Messengers system does not address most security issues, but the Messengers group is working on market-based approaches for fairly allocating resources among competing messengers [Tsc97]. Obliq <ref> [Car95, BC95, BN97] </ref>. Obliq is an interpreted, lexically scoped, object-oriented language. An Obliq object is a collection of named fields that contain methods, aliases and values. An object can be created at a remote site, cloned onto a remote site, or migrated with a combination of cloning and redirection.
Reference: [BP88] <author> Andrea J. Borr and Franco Putzolu. </author> <title> High performance SQL through low-level system integration. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 342-349, </pages> <address> Chicago, Illinois, 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Some database systems allow a user to define complex SQL commands and store these commands on a server; the stored commands are executed at the server end during a user transaction <ref> [BP88] </ref>.
Reference: [Car95] <author> Luca Cardelli. </author> <title> A language with distributed scope. </title> <journal> Computing Systems, </journal> <volume> 8(1) </volume> <pages> 27-59, </pages> <month> Winter </month> <year> 1995. </year>
Reference-contexts: The Messengers system does not address most security issues, but the Messengers group is working on market-based approaches for fairly allocating resources among competing messengers [Tsc97]. Obliq <ref> [Car95, BC95, BN97] </ref>. Obliq is an interpreted, lexically scoped, object-oriented language. An Obliq object is a collection of named fields that contain methods, aliases and values. An object can be created at a remote site, cloned onto a remote site, or migrated with a combination of cloning and redirection. <p> Such languages include Java [CH97], Scheme 48 [KR95], Tcl [Ous94, OLW97], Lua [dIC96], and Python [Lut96], as well as Obliq <ref> [Car95] </ref> and Telescript [Whi94], which were specifically designed for mobile objects or agents. <p> In addition to these two migration models, many systems that use object-oriented languages allow an agent to move an individual object to a remote machine and then invoke that object's methods; the object does not have its own thread of control <ref> [LO97, Gen97, Car95, RASS97] </ref>. Which of the two migration models is best remains unclear. The jump model is more convenient for the end programmer since she does not have to explicitly check the current state and figure out what to do next at each entry point.
Reference: [Car97] <author> Wilmer Caripe. </author> <title> Applicability of the SNMP network management framework to the network-sensing module supporting the mobile-agent planning process. </title> <type> Technical report, </type> <institution> Thayer School of Engineering, Dartmouth College, </institution> <address> Hanover, New Hampshire, </address> <year> 1997. </year> <booktitle> In progress. </booktitle> <pages> 206 </pages>
Reference-contexts: not currently connected to the network [GKN + 97], (3) hierarchical yellow pages that provide a keyword-indexed directory of available services [GKN + 97], (4) several network sensing and planning modules that allow an agent to examine the cur 6 rent state of the network and construct an optimal route <ref> [GKN + 97, Car97] </ref>, and (5) a simple Mobile Agent Construct Environment (MACE) that allows a nonprogrammer to graphically construct an agent [Sha97]. These services represent the research of several other students. Although they are discussed further in Chapter 9, they are not an integral part of this thesis. <p> Wilmer Caripe, Katsuhiro Moizumi 7 and several undergraduates in the computer science department are working on various network-sensing and decision-making tech-7 Wilmer Caripe and Hiro Moizumi are both Ph.D. students in the Thayer School of Engineering. 181 niques <ref> [GKN + 97, Car97] </ref>. Both passive and active network-sensing techniques are under development. Passive techniques include piggybacking bandwidth and latency information onto existing agent traffic as well as taking round-trip timings for existing agent traffic. <p> Sumatra uses a similar system of network monitors called Komodo [RAS96]. Machines have their own characteristics, most notably CPU speed and current load. Although this information can also be handled in the network monitors, we are planning to use the Simple Network Management Protocol (SNMP) instead <ref> [Car97] </ref>. The SNMP protocol associates a simple database (or MIB) with each network device. The network device fills these fields with information about its inherent and current characteristics; applications run queries against the MIB to identify the device's current status. <p> Our current applications use machine learning, specifically the new Q-learning algorithm [CMG95]. Here each agent reports its observed performance to a Q-learning agent on each visited site; later agents query the Q-learning agents to obtain a performance prediction based on the past observations and the current network conditions <ref> [Car97] </ref>. The current prototype considers only agent size, result sizes, observed latencies, and time of day. There are several important research questions, but the question of immediate interest to us is how much extra network traffic the network monitors must generate to keep their performance estimates up-to-date. <p> that allows an agent to transparently migrate to or from a mobile computer [GKN + 97], (3) hierarchical yellow pages that provide a keyword-indexed directory of available services [GKN + 97], (4) several network sensing and planning modules that allow an agent to determine the best route through the network <ref> [GKN + 97, Car97] </ref>, and (5) a Mobile Agent Construct Environment (MACE) that allows a nonprogram 203 mer to graphically construct an agent [Sha97]. The main weaknesses of Agent Tcl are its lack of fault-recovery mechanisms and its poor performance relative to traditional client-server techniques.
Reference: [CB97] <author> David Chaum and Stefan Brands. </author> <title> "Minting" electronic cash. </title> <journal> IEEE Spectrum, </journal> <volume> 34(2) </volume> <pages> 30-34, </pages> <month> February </month> <year> 1997. </year> <journal> Special issue on Technology and Electronic Economy. </journal>
Reference-contexts: A more attractive solution is to use a market-based approach in which agents pay for their resource usage with cryptographically-protected electronic cash <ref> [CB97, SD95] </ref>. When an agent is created, it is given a finite currency supply from its owner's own finite currency supply.
Reference: [CBC96] <author> Kurt Cohen, Aditya Bhasin, and George Cybenko. </author> <title> Pattern recognition of 3D CAD objects: Towards an electronic yellow pages of mechanical parts. </title> <journal> International Journal of Intelligent Engineering Systems, </journal> <year> 1996. </year>
Reference-contexts: Although the "who" agent is not the most useful agent, it illustrates the general form of any agent that migrates sequentially through a set of machines. The exec who can be replaced with any desired processing. 8 prices [RGK96], medical records [Wu95], and three-dimensional drawings of mechan-ical parts <ref> [CBC96] </ref> (Chapter 8). <p> Agent Tcl has also been used to retrieve three-dimensional drawings of mechanical parts from distributed CAD databases <ref> [CBC96] </ref>, to track purchase orders [CGN96], and in several information-retrieval applications at external sites. 8.3 Summary None of these applications require mobile agents.
Reference: [CGH + 95] <author> David Chess, Benjamin Grosof, Colin Harrison, David Levine, Colin Parris, and Gene Tsudik. </author> <title> Itinerant agents for mobile computing. </title> <journal> IEEE Personal Communications, </journal> <volume> 2(5) </volume> <pages> 34-49, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: IBM Itinerant Agents is a proposed system that focuses on knowledge-based routing of service requests and security issues <ref> [CGH + 95] </ref>; it is not under active development and has given way to the more recent IBM Aglets system [LO97]. <p> If the network machines are under single administrative control, solutions are relatively straightforward; if the machines are not, solutions are much more complex. All of these problems have been considered in the mobile-agent literature <ref> [LO95, CGH + 95, TV96, PS97] </ref>, but only the first two have seen significant implementation work. These same two problems are addressed in the current implementation of Agent Tcl using PGP [KPS95], Safe Tcl [LO95, OLW97] and Java security managers [CH97]. <p> Unless "trusted (and tamper-resistant) hardware" is available on each agent server <ref> [CGH + 95] </ref>, something which is extremely unlikely in the near future, there is no way to prevent a malicious machine from examining or modifying any part of the agents that visit it. <p> Instead, some part of the solution will always be sociological and legal pressures <ref> [CGH + 95] </ref>. There are several partial technical solutions, however. Hopefully, by picking and choosing from these partial solutions, most agents will be able to protect themselves adequately for their current task, but still move freely 115 throughout the network. <p> Tacoma also includes rear-guard agents that restart a vanished agent. * Components. Perhaps the most powerful idea is to divide each agent into components <ref> [CGH + 95] </ref>. Components can be added to the agent as it migrates, and each component can be encrypted and signed with different keys. <p> The movement history could also be examined inside the authentication routine above. * Audit logs. Machines should keep logs of important agent events so that an aggrieved agent or owner can request an audit from an authorized third-party <ref> [CGH + 95] </ref>. The auditor would seek to identify the machine responsible for a theft or modification and penalize that machine appropriately. The exact contents of the audit logs is largely an open question. <p> looking at electronic cash schemes where each resource has an associated price; agents must spend electronic cash from their finite reserve to access the desired resources and thus cannot survive forever within the network [JvRS95, DiMMTH95]. 1 To protect an agent, we are looking at a combination of audit trails <ref> [CGH + 95] </ref>, replication and voting schemes [MvRSS96], a component model in which an agent is divided into pieces that are encrypted and signed at different times and with different keys [CGH + 95], limited forms of proof-carrying or self-authenticating code [PS97], and a tamper-proof movement history embedded inside a migrating <p> within the network [JvRS95, DiMMTH95]. 1 To protect an agent, we are looking at a combination of audit trails <ref> [CGH + 95] </ref>, replication and voting schemes [MvRSS96], a component model in which an agent is divided into pieces that are encrypted and signed at different times and with different keys [CGH + 95], limited forms of proof-carrying or self-authenticating code [PS97], and a tamper-proof movement history embedded inside a migrating agent [MvRSS96]. 1 Most electronic cash schemes involve significant network communication.
Reference: [CGN96] <author> Ting Cai, Peter A. Gloor, and Saurab Nog. DartFlow: </author> <title> A workflow management system on the web using transportable agents. </title> <type> Technical Report PCS-TR96-283, </type> <institution> Department of Computer Science, Dartmouth College, </institution> <address> Hanover, New Hampshire, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: The second advantage is particularly critical if the search is launched from a mobile computer, which typically has an unreliable, low-bandwidth connection into the network. Agent Tcl has also been used to track purchase orders in a workflow application <ref> [CGN96] </ref> and in several network management and information-retrieval applications at non-Dartmouth sites. Agent Tcl agents allow these applications to minimize their bandwidth consumption and to proceed with their task even if network links go down. <p> Existing Agent Tcl agents that fall into this category are a workflow agent that carries an electronic form from user to user <ref> [CGN96] </ref> and a medical agent that retrieves distributed medical records based on certain criteria [Wu95]. The workflow agent must migrate sequentially since the users need to fill out the sections of the form in order. <p> Agent Tcl has also been used to retrieve three-dimensional drawings of mechanical parts from distributed CAD databases [CBC96], to track purchase orders <ref> [CGN96] </ref>, and in several information-retrieval applications at external sites. 8.3 Summary None of these applications require mobile agents. Mobile agents, however, allow the applications to be implemented easily within a single, general framework, without such things as application-specify proxies and server operations, queued RPC, or automated installation facilities.
Reference: [CH97] <author> Gary Cornell and Cay S. Horstmann. </author> <title> Core Java. </title> <publisher> Sunsoft Press (Pren-tice Hall), </publisher> <year> 1997. </year>
Reference-contexts: Latency between the user (i.e., the screen, keyboard and mouse) and a web-based application is much lower if 12 part or all of the application is downloaded to the client's machine in the form of a Java applet, allowing the application to respond much more rapidly to user actions <ref> [CH97] </ref>. Mobile agents can be used for the same purpose. <p> In such an application, the agent serves the same purpose as a Java applet, which is downloaded into a Java-enabled browser so that a Web-based application can present a complex graphical interface without annoying delays <ref> [CH97] </ref>. Of course, the same effect can be achieved if the user installs special client software on their machine. <p> Such languages include Java <ref> [CH97] </ref>, Scheme 48 [KR95], Tcl [Ous94, OLW97], Lua [dIC96], and Python [Lut96], as well as Obliq [Car95] and Telescript [Whi94], which were specifically designed for mobile objects or agents. <p> science department and have spent two semesters each working on Agent Java. 70 5.4.1 Java Java is an object-oriented language that is syntactically similar to C++ except that there are no structures or unions, no functions, no multiple implementation inheritance, no operator overloading, no automatic type casts, and no pointers <ref> [GM95, Sun97b, CH97] </ref>. A sample Java program is shown in Figure 5.5. Memory in Java is garbage-collected so there is no delete operator. Java is multi-threaded and includes thread synchronization primitives at the language level. <p> These same two problems are addressed in the current implementation of Agent Tcl using PGP [KPS95], Safe Tcl [LO95, OLW97] and Java security managers <ref> [CH97] </ref>. First we present the current implementation and then potential solutions for the remaining two security problems. 6.1 Protecting the machine (and other agents) Protecting the machine involves two tasks: * Authentication. Verify the identity of an agent's owner. * Authorization and enforcement. <p> No direct access to system resources is possible, and there is no way for an agent to subvert the resource manager decisions, since the agent cannot modify the access lists in the trusted interpreter. Java. The Java enforcement module is implemented as a Java security manager <ref> [CH97] </ref>. A Java security manager is a class that provides a set of access-control methods, such as checkExec, checkRead, and checkExit. The Java system classes call these methods to see if the corresponding operation is allowed. <p> Java programs are compiled into intermediate code for a stack-based virtual machine and then either interpreted or compiled on-the-fly into native code. When interpreted, Java programs run 10 to 20 times slower than natively compiled C or C++ <ref> [CH97] </ref>. <p> Tcl traces, for example, provide a way to automatically detect and save any change in the value of a Tcl variable; Ara uses traces for just this purpose [Pei96]. Similarly, persistent objects can be implemented easily with Java's existing object serialization facilities <ref> [CH97] </ref>. Although such higher-level state capture is more convenient for the programmer, we plan to focus on the more general mechanism, and implement the language-specific mechanisms as time allows.
Reference: [Cha96] <author> Phil Inje Chang. </author> <title> Inside the Java Web Server: An overview of Java Web Server 1.0, Java Servlets, and the JavaServer architecture. Sun Microsystems White Paper, Sun Microsystems, </title> <year> 1996. </year>
Reference-contexts: Java servlets are Java programs that can be dynamically loaded into an executing Java-enabled web server, such as Sun Microsystem's Web Java Server 1.0 <ref> [Cha96] </ref>. Java servlets allow rapid introduction of new server functionality and are more efficient than CGI scripts, since there is no startup overhead on each access.
Reference: [CJK95] <author> Henry Cejtin, Suresh Jagannathan, and Richard Kelsey. </author> <title> Higher-order distributed objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(5), </volume> <month> September </month> <year> 1995. </year> <month> 207 </month>
Reference-contexts: The recent popularity of mobile code has led to an explosion in the number of mobile-agent systems. Here we describe a few representative systems in detail and mention other systems briefly. Kali Scheme <ref> [CJK95] </ref>. Kali Scheme is an extension of Scheme 48 [KR95], which is an efficient, multi-threaded Scheme implementation based around a bytecode interpreter. Kali Scheme provides a distributed set of address spaces in which the threads execute. <p> Research systems usually ignore administration, auditing and development tools, and often ignore security if security is orthogonal to the main research interest (such as the use of a high-order language in distributed computing <ref> [CJK95] </ref>). Agent Tcl is entirely a research project, but does provide sufficient security mechanisms to protect a machine from malicious agents and also includes a full-featured debugger and a simple visual programming environment. <p> Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ [LSW95, JvRS95, PS97, BFD96], Java [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96], and various scripting languages [JvRS95, PS97, JdT + 95, Coe94]. Functional languages such as Scheme are used only in a few research systems <ref> [CJK95, HBB96, TLKC95] </ref>. Java is the most popular imperative language and is used in every commercial system and several research systems. <p> Systems that use the jump migration model include Agent Tcl, Kali Scheme <ref> [CJK95] </ref>, and Telescript [Whi94]. * known entry point. The system moves the variables and methods of the agent to the new machine, and then restarts agent execution at some specified method [LO97]. <p> Third, since Scheme is a type-safe language and is lexically scoped, it already provides the initial layer of security that is needed when executing untrusted agents <ref> [CJK95] </ref>. Finally, there has already been work on moving ongoing Scheme computations from one machine to another [CJK95]. 5.5.2 State capture We selected Scheme 48 as the Scheme interpreter for Agent Tcl due to its efficiency, easy portability and its ability to interface with native C/C++ libraries. <p> Third, since Scheme is a type-safe language and is lexically scoped, it already provides the initial layer of security that is needed when executing untrusted agents <ref> [CJK95] </ref>. Finally, there has already been work on moving ongoing Scheme computations from one machine to another [CJK95]. 5.5.2 State capture We selected Scheme 48 as the Scheme interpreter for Agent Tcl due to its efficiency, easy portability and its ability to interface with native C/C++ libraries. <p> Instead of capturing the entire heap, we need to capture only the desired continuation or closure. This improved state capture requires additions to the Scheme 48 virtual machine. Fortunately, Kali Scheme <ref> [CJK95] </ref> has already made these additions. Kali Scheme is derived from Scheme 48 and allows either a closure or a executing thread (in the form of the thread's continuation) to be transferred from one machine to another. <p> In this chapter, we first describe applications of other mobile-agent systems, briefly considering whether each application can be implemented effectively in the current Agent Tcl system. Then we present the existing applications of Agent Tcl. 8.1 Other systems Kali Scheme. <ref> [CJK95] </ref> suggests several applications for Kali Scheme: load balancing, where executing threads are moved to a lightly loaded machine; incremental distributed linking, where a new procedure (such as a debugging or monitoring procedure) is dynamically inserted into a distributed computation; parameterized client 159 server applications, where a client and server o*oad
Reference: [CMB96] <author> Michael Condict, Dejan Milojicic, and Don Bolinger. </author> <title> Toward a world-wide civilization of objects. </title> <booktitle> In Proceedings of the Seventh ACM SIGOPS European Workshop, </booktitle> <pages> pages 25-32, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: The evolving Mobile Objects and Agents (MOA) system is a CORBA-based sys 41 tem in which both static and active Java objects 10 can move from one machine to another <ref> [CMB96, MBZM96] </ref>. CORBA is a distributed-object manager that already provides object naming, object location and remote invocation [YD96]. MOA builds on CORBA to provide object persistence, a hierarchical object cache, and a location-independent name service that uses URL's. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ [LSW95, JvRS95, PS97, BFD96], Java <ref> [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96] </ref>, and various scripting languages [JvRS95, PS97, JdT + 95, Coe94]. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. Java is the most popular imperative language and is used in every commercial system and several research systems.
Reference: [CMG95] <author> George Cybenko, Katsuhiro Moizumi, and Robert S. Gray. Q-Learning: </author> <title> A tutorial and extensions. </title> <booktitle> In Proceedings of the 1995 Conference on the Mathematics of Artificial Neural Networks, </booktitle> <year> 1995. </year>
Reference-contexts: Once network and machine monitors are available, the remaining task is to provide the decision-making routines. There are several broad approaches, most notably mathematical models and machine-learning techniques. Our current applications use machine learning, specifically the new Q-learning algorithm <ref> [CMG95] </ref>. Here each agent reports its observed performance to a Q-learning agent on each visited site; later agents query the Q-learning agents to obtain a performance prediction based on the past observations and the current network conditions [Car97].
Reference: [Coe94] <author> Michael H. Coen. SodaBot: </author> <title> A software agent environment and construction system. </title> <editor> In Yannis Labrou and Tim Finin, editors, </editor> <booktitle> Proceedings of the CIKM Workshop on Intelligent Information Agents, Third International Conference on Information and Knowledge Management (CIKM 94), </booktitle> <address> Gaithersburg, Maryland, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: It 15 has also been suggested that mobile agents move the programmer away from the rigid client-server model to the more flexible peer-peer model in which programs communicate as peers and act as either clients or servers depending on their current needs <ref> [Coe94] </ref>. Although this is perhaps true conceptually, it does not appear to be an inherent characteristic of mobile agents, but rather a matter of whether the programmer chooses to have her agents act as peers. <p> in a very high-level language called SodaBotl that provides threads, an interface toolkit, location-independent communication primitives, and both automatic code distribution and an explicit hop operation; SodaBot agents execute in a restricted execution environment that limits the agent's total lifetime and prevents unauthorized access to the filesystem and external programs <ref> [Coe94] </ref>. The Tube is similar to Kali Scheme in that agents are written in Scheme, execute inside multithreaded servers, and create new agents and migrate from machine to machine 11 The MESSENGERS system is not the same as the Messengers system that was described in more detail above. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ [LSW95, JvRS95, PS97, BFD96], Java [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96], and various scripting languages <ref> [JvRS95, PS97, JdT + 95, Coe94] </ref>. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. Java is the most popular imperative language and is used in every commercial system and several research systems.
Reference: [CR91] <author> William Clinger and Jonathan Rees. </author> <title> Revised(4) report on the algo-rtihmic language Scheme. </title> <booktitle> ACM Lisp Pointers IV, </booktitle> <pages> pages 1-55, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Agents can currently send and receive messages, but cannot migrate from machine to machine or establish meetings with other agents. Dartmouth undergraduates Ahsan Kabir and David Gondek have done most of the implementation work so far. 5.5.1 Scheme Scheme is a statically scoped and properly tail-recursive dialect of Lisp <ref> [Dyb87, CR91] </ref>. Although Scheme supports several programming paradigms, such as imperative and message passing, it is oriented towards and most commonly used for functional programming as illustrated in Figure 5.9.
Reference: [CW97] <author> Mary Campione and Kathy Walrath. </author> <title> The Java tutorial: Object-oriented programming for the Internet. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: laptop reconnects, it sends a code fragment to the filesystem server to reconcile its file changes with the permanent copy of the file [TTP + 95]. 3.2.4 Java applets, Java servlets, Java RMI and JavaOS Java applets are Java programs that are associated with a World Wide Web (WWW) page <ref> [CW97] </ref>. When a user views the page with a Java-enabled browser, the program is downloaded automatically and executed on the user's machine. By executing on the browser's machine, the program can present a complex, graphical interface and react rapidly to user actions, since there are no network delays. <p> Omniware could even be the only execution environment, since the interpreters for agents written in other languages could be compiled for the Omniware virtual machine and sent as needed to the destination machines [LSW95]. Sumatra [RASS97, RAS96]. Sumatra is an extension to Java <ref> [CW97] </ref> that supports both distributed objects and mobile code. One or more instances of the Sumatra execution engine run on each machine. 6 Each engine hosts one or more 6 The Sumatra execution engine is just the extended Java interpreter. 36 threads and their objects.
Reference: [dIC96] <author> Luiz Henrique de Figueiredo, Robert Ierusalimschy, and Waldemar Ce-les. Lua: </author> <title> An extensible embedded language. </title> <journal> Dr. Dobb's Journal, </journal> <volume> 21(12), </volume> <month> December </month> <year> 1996. </year>
Reference-contexts: Such languages include Java [CH97], Scheme 48 [KR95], Tcl [Ous94, OLW97], Lua <ref> [dIC96] </ref>, and Python [Lut96], as well as Obliq [Car95] and Telescript [Whi94], which were specifically designed for mobile objects or agents.
Reference: [DiMMTH95] <author> Giovanna Di Marzo, Murhimanya Muhugusa, Christian Tschudin, and Jurgen Harms. </author> <title> The Messenger paradigm and its implications on distributed systems. </title> <booktitle> In Proceedings of the ICC'95 Workshop on Intelligent Computer Communication, </booktitle> <year> 1995. </year> <month> 208 </month>
Reference-contexts: Kali Scheme's main weakness is that the implementation is Scheme specific (and, in fact, is contained entirely within the Scheme 48 virtual machine itself), preventing any straightforward extension to additional languages. 34 Messengers <ref> [TDiMMH94, DiMMTH95, Tsc94] </ref>. A messenger is a message that contains both data and code. A server on each host accepts incoming messengers and executes each messenger's code within its own thread. <p> This client-server "customization" is one of the main applications for Agent Tcl, although migrating a Java or Scheme agent is more often a performance win than migrating a Tcl agent, due to the slowness of Tcl. Messengers. Messengers are oriented towards communication protocols and distributed operating systems <ref> [DiMMTH95] </ref>. If a machine wants to communicate with a remote machine that does not understand the desired communication protocol, it dispatches a messenger that implements the protocol; this messenger lives on the remote machine and handles the communication channel on its behalf. <p> To protect a group of machines, we are looking at electronic cash schemes where each resource has an associated price; agents must spend electronic cash from their finite reserve to access the desired resources and thus cannot survive forever within the network <ref> [JvRS95, DiMMTH95] </ref>. 1 To protect an agent, we are looking at a combination of audit trails [CGH + 95], replication and voting schemes [MvRSS96], a component model in which an agent is divided into pieces that are encrypted and signed at different times and with different keys [CGH + 95], limited
Reference: [Dyb87] <author> R. Kent Dybvig. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Agents can currently send and receive messages, but cannot migrate from machine to machine or establish meetings with other agents. Dartmouth undergraduates Ahsan Kabir and David Gondek have done most of the implementation work so far. 5.5.1 Scheme Scheme is a statically scoped and properly tail-recursive dialect of Lisp <ref> [Dyb87, CR91] </ref>. Although Scheme supports several programming paradigms, such as imperative and message passing, it is oriented towards and most commonly used for functional programming as illustrated in Figure 5.9.
Reference: [EW94] <author> Oren Etzionoi and Daniel Weld. </author> <title> A softbot-based interface to the Internet. </title> <journal> Communications of the ACM, </journal> <volume> 37(7) </volume> <pages> 48-53, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: The partial results from one subsearch are used to narrow the scope of other subsearches. 1 functional, structural, causal, spatial and temporal 22 Etzioni and Weld present a softbot that accepts a request and then develops a plan that satisfies the request using available Internet resources <ref> [EW94] </ref>. Softbot stands for "software robot" and arises from the artificial intelligence definition above. In this case, the sensors are Internet resources such as archie, gopher and netfind, and the effectors are resources such as ftp, telnet and mail. The softbot encodes its knowledge of these resources as declarative logic. <p> The softbot encodes its knowledge of these resources as declarative logic. It accepts requests expressed in a subset of first-order logic and performs a standard backtracking search to develop an appropriate plan. The example softbot in <ref> [EW94] </ref> uses a combination of Internet resources to resolve underspecified e-mail addresses when sending messages. Vesser has written a succession of papers that develop a model for distributed searching. One of the more recent is [OPL94], which recasts the model in terms of agents.
Reference: [Fal87] <author> Joseph R. Falcone. </author> <title> A programmable interface language for heterogeneous systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(4) </volume> <pages> 330-351, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: To address this problem, researchers have turned to remote evaluation in which a subprogram is sent from the client to the server. The subprogram executes on the server and returns its result to the client. Falcone <ref> [Fal87] </ref> describes a system in which clients and servers program each other using a variant of Lisp called the Network Command Language (NCL). Each server provides a library of NCL functions. A client that requires a service sends an NCL expression to the appropriate server.
Reference: [FHS97] <editor> Stephanie Forrest, Steven A. Hofmeyr, and Anil Somayaji. </editor> <title> Computer immunology. </title> <journal> Communications of the ACM, </journal> <volume> 40(10) </volume> <pages> 88-96, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: models exist, such as (1) mandatory access control, in which programs, people and data are assigned classification levels, and information can not flow from higher to lower levels, (2) security automata [Sch97a], in which a program's current allowed actions depend on its past resource usage, 10 and (3) computer immunology <ref> [FHS97, Gre97b] </ref>, in which a program is considered malicious if its current pattern of resource usage does not match its normal pattern. Although none of these models are incompatible with Agent Tcl's current architecture, architectural extensions would be needed for all three.
Reference: [Fon93] <author> Leonard N. Foner. </author> <title> What's an agent anyway: A sociological case study. Agents Memo 93-01, Agents Group, </title> <publisher> MIT Media Lab, </publisher> <year> 1993. </year>
Reference-contexts: Applications are often described as "agent-based" solely to draw attention or increase sales. For example, No Hands Software once described its Magnet T M program as the "first intelligent agent for the Macintosh" even though it was essentially a file-finder <ref> [Fon93] </ref>. This inappropriate use of the term makes it more difficult to separate hype from actual research, but there appear to be five legitimate research areas in which the term "agent" is used|artificial intelligence and robotics, personal assistants, distributed information retrieval, software interoperation and mobile agents.
Reference: [FTP96] <author> FTP Software's agent technology: </author> <title> A general overview. </title> <note> FTP Software Technical Report, FTP Software, </note> <year> 1996. </year>
Reference-contexts: MOA will eventually enforce access restrictions according to the mobile object's owner, its current requirements, and possibly its past migration history. FTP Software's CyberAgents provided a visual editor, a visual agent manager, some debugging tools, OLE and HTML support, and extensive logging and report-generation facilities <ref> [FTP96] </ref>. FTP Software no longer sells CyberAgents, but a version of CyberAgents that uses the TRAC language (rather than Java) is used in some of FTP Software's network management tools [Gre97a]. Other Java-based systems include Mole [SBH96, BHR + 97], Concordia [Mit97a, WPW + 97], Voyager [Voy97], and Wasp [Fun97].
Reference: [Fun97] <author> Stefan Funfrocken. </author> <title> How to integrate mobile agents into web servers. </title> <booktitle> In Proceedings of the WETICE '97 Workshop on Collaborative Agents in Distributed Web Applications, </booktitle> <address> Boston, Massachusetts, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: FTP Software no longer sells CyberAgents, but a version of CyberAgents that uses the TRAC language (rather than Java) is used in some of FTP Software's network management tools [Gre97a]. Other Java-based systems include Mole [SBH96, BHR + 97], Concordia [Mit97a, WPW + 97], Voyager [Voy97], and Wasp <ref> [Fun97] </ref>. The Mole project is focusing on security mechanisms for protecting an agent from a malicious machine, while the Wasp project is concerned with integrating mobile agents with Web servers. Voyager and Concordia are commercial systems.
Reference: [Gai94] <author> R. Stockton Gaines. </author> <booktitle> Dixie language and intepreter issues. In Proceedings of the USENIX Symposium on Very High Level Languages (VHLL '94), </booktitle> <address> Sante Fe, New Mexico, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: The proposed Distributed Internet Execution Environment (Dixie) will combine the Prospero file system, the Tk toolkit, and interpreters for several languages into a virtual operating system that accepts and executes applications sent from other hosts <ref> [Gai94] </ref>; little implementation work had been done at the time of this writing, however. The Frankfurt Mobile Agents Infrastructure (ffMAIN) [LDD95] allows agents written in Tcl to migrate and communicate using the standard HTTP protocol; their agent server is a modified HTTP server.
Reference: [Gen97] <institution> Odyssey: </institution> <note> Beta Release 1.0, 1997. Available as part of the Odyssey package at http:// www.genmagic.com/ agents/. 209 </note>
Reference-contexts: Tacoma Too is also exploring various forms of proof-carrying code [Sch97b]. Telescript [Whi94, Whi95b, Whi95a, Whi96] and Odyssey <ref> [Gen97] </ref>. Tele-script, later marketed as part of the Tabriz web-server package, was the first commercial mobile-agent system. It was developed at General Magic, Inc., and was primarily used in the AT&T PersonaLink network. <p> Research versus commercial. Aside from Telescript [Whi94], most mobile-agent systems were strictly research projects until about two years ago. Since then, the number of commercial systems has increased dramatically and now includes Odyssey <ref> [Gen97] </ref>, IBM Aglets [LO97], Concordia [WPW + 97], Voyager [Voy97] and Omniware [LSW95]. As the reader might expect, commercial systems provide much better administration and development tools than research systems. In addition, all commercial systems provide sufficient security mechanisms to protect a machine from malicious agents. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ [LSW95, JvRS95, PS97, BFD96], Java <ref> [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96] </ref>, and various scripting languages [JvRS95, PS97, JdT + 95, Coe94]. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. Java is the most popular imperative language and is used in every commercial system and several research systems. <p> To ease the burden on the programmer, many systems allow the agent to follow a pre-established itinerary, which specifies a list of machines and the method that should be executed on each one <ref> [LO97, Gen97] </ref>. All commercial systems use the known entry point model with an itinerary, simply because all commercial systems use Java, which cannot 48 support the jump model without modifications to the standard virtual ma-chine. Every system that supports the jump model also supports the known entry point model. <p> In addition to these two migration models, many systems that use object-oriented languages allow an agent to move an individual object to a remote machine and then invoke that object's methods; the object does not have its own thread of control <ref> [LO97, Gen97, Car95, RASS97] </ref>. Which of the two migration models is best remains unclear. The jump model is more convenient for the end programmer since she does not have to explicitly check the current state and figure out what to do next at each entry point. <p> Security. Existing mobile-agent systems focus on protecting an individual machine from malicious agents (or a group of machines that are under single administrative control) <ref> [Whi94, Gen97, PS97] </ref>. <p> All commercial Java-based mobile-agent systems, such as IBM Aglets [LO97, Ven97], General Magic's Odyssey <ref> [Gen97] </ref> and Mitsubishi's Concordia [WPW + 97], rely on this object serialization facility. <p> The most immediate need is to create a version of Agent Tcl that does not provide the jump command and thus can run with the unmodified interpreters. Such a version would use migration techniques similar to those found in Aglets [Ven97], Odyssey <ref> [Gen97] </ref>, Concordia [WPW + 97] or Tacoma [JvRS95]. At the same time, we need to decide whether the convenience of the jump command outweighs the additional burden that it places on the system programmer.
Reference: [GG88] <author> D. K. Gifford and N. Glasser. </author> <title> Remote pipes and procedures for efficient distributed communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(3) </volume> <pages> 258-283, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: The original RPC implementations blocked the client until the server returned the result. Current RPC extensions either allow concurrent invocation of procedures on multiple servers or make RPC asynchronous [SS94]. These variations are more flexible but make programming more difficult. Other disadvantages of traditional RPC were described in <ref> [GG88] </ref>. It is difficult to send incremental results from the server to the client; implementations are commonly optimized for short results rather than bulk data transfer; and there is no way to pass pointers or procedure references to the server. <p> This last limitation obviates any protocol that requires the server to invoke a client-specified procedure on the 28 client machine. <ref> [GG88] </ref> addresses these problems by allowing procedure references to be passed as arguments and introducing the pipe abstraction.
Reference: [GK94] <author> Michael R. Genesereth and Steven P. Ketchpel. </author> <title> Software agents. </title> <journal> Communications of the ACM, </journal> <volume> 37(7) </volume> <pages> 48-53, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Most existing systems that use the procedural approach are based around high-level scripting languages. An application is sent a script that guides the application through the desired task. Notable examples of the script-based approach include Tcl, AppleScript, Hewlett-Packard's NewWave environment and the Autonomous Knowledge Agents (AKA) project <ref> [GK94, Joh93] </ref>. Genesereth [GK94] points out several disadvantages of the procedural approach. Writing procedures might require information about the recipient that is not available to the sender; procedures only compute in one direction; and procedures are difficult to merge. <p> An application is sent a script that guides the application through the desired task. Notable examples of the script-based approach include Tcl, AppleScript, Hewlett-Packard's NewWave environment and the Autonomous Knowledge Agents (AKA) project [GK94, Joh93]. Genesereth <ref> [GK94] </ref> points out several disadvantages of the procedural approach. Writing procedures might require information about the recipient that is not available to the sender; procedures only compute in one direction; and procedures are difficult to merge. Instead Genesereth argues for the declarative approach in which agents exchange declarative statements. <p> These declarative statements are written in the Agent Communication Language (ACL). ACL has three components| 24 a vocabulary, an inner language called the Knowledge Interchange Format (KIF), and an outer language called the Knowledge Query and Manipulation Language (KQML) <ref> [GK94] </ref>. The vocabulary is a dictionary of words specific to the application area. Each word has an English definition and a set of formal annotations written in KIF. KIF is a prefix version of first-order predicate calculus that can express data, procedures, and relationships among the data. <p> An example of directory assistance is the X.500 protocol; distributed object managers include CORBA, DSOM, OLE and OpenDoc; automatic brokers include ToolTalk and the Publish and Subscribe Service on the Macintosh <ref> [GK94] </ref>. The federated approach is distinguished by the amount of processing done in the facilitator; each facilitator performs backward inference rather than simple pattern matching. [GK94]. It is unclear whether the procedural or declarative approach is better. <p> the X.500 protocol; distributed object managers include CORBA, DSOM, OLE and OpenDoc; automatic brokers include ToolTalk and the Publish and Subscribe Service on the Macintosh <ref> [GK94] </ref>. The federated approach is distinguished by the amount of processing done in the facilitator; each facilitator performs backward inference rather than simple pattern matching. [GK94]. It is unclear whether the procedural or declarative approach is better. The procedural approach is suggested when the sender is requesting a task that the recipient does not know how to perform in its entirety. <p> Binary messages. Agent Tcl messages are currently null-terminated ASCII strings. Although strings are an appropriate transmission unit for some applications, such as those in which the agents exchange KQML messages <ref> [GK94] </ref>, strings introduce extra overhead in many other applications, such as those in which the agents exchange numeric data. The overhead comes from converting the data into a string and then 198 parsing the string to recover the data.
Reference: [GKCR97] <author> Robert Gray, David Kotz, George Cybenko, and Daniela Rus. </author> <title> Agent Tcl. </title> <editor> In William Cockayne and Michael Zyda, editors, </editor> <title> Itinerant Agents: Explanations and Examples with CD-ROM. </title> <publisher> Manning Publishing, </publisher> <address> 1997. </address> <publisher> Imprints by Manning Publishing and Prentice Hall. </publisher>
Reference-contexts: Agent Tcl <ref> [Gra97, GKCR97, Gra96, Gra95] </ref> is a mobile-agent system that is under development at Dartmouth College to address some of these research problems.
Reference: [GKN + 97] <author> Robert Gray, David Kotz, Saurab Nog, Daniela Rus, and George Cy-benko. </author> <title> Mobile agents: </title> <booktitle> The next generation in distributed computing. In Proceedings of the Second Aizu International Symposium on Parallel Algorithms/Architectures Synthesis (pAs '97), Fukushima, </booktitle> <address> Japan, </address> <month> March </month> <year> 1997. </year>
Reference-contexts: network, monitors its communication with other agents, and provides traditional debugger features such as breakpoints, watch conditions and line-at-a-time execution [HK97], (2) a docking system that allows an agent to transparently migrate to or from a mobile computer, even if the mobile computer is not currently connected to the network <ref> [GKN + 97] </ref>, (3) hierarchical yellow pages that provide a keyword-indexed directory of available services [GKN + 97], (4) several network sensing and planning modules that allow an agent to examine the cur 6 rent state of the network and construct an optimal route [GKN + 97, Car97], and (5) a <p> watch conditions and line-at-a-time execution [HK97], (2) a docking system that allows an agent to transparently migrate to or from a mobile computer, even if the mobile computer is not currently connected to the network <ref> [GKN + 97] </ref>, (3) hierarchical yellow pages that provide a keyword-indexed directory of available services [GKN + 97], (4) several network sensing and planning modules that allow an agent to examine the cur 6 rent state of the network and construct an optimal route [GKN + 97, Car97], and (5) a simple Mobile Agent Construct Environment (MACE) that allows a nonprogrammer to graphically construct an agent <p> not currently connected to the network [GKN + 97], (3) hierarchical yellow pages that provide a keyword-indexed directory of available services [GKN + 97], (4) several network sensing and planning modules that allow an agent to examine the cur 6 rent state of the network and construct an optimal route <ref> [GKN + 97, Car97] </ref>, and (5) a simple Mobile Agent Construct Environment (MACE) that allows a nonprogrammer to graphically construct an agent [Sha97]. These services represent the research of several other students. Although they are discussed further in Chapter 9, they are not an integral part of this thesis. <p> The naive solution of having the agent poll the network connection is extremely inefficient. Instead Ting Cai, Saurab Nog, Vishesh Khemani and Jun Shen 3 have developed a docking system that allows agents to simply go to sleep until the network connection is available again <ref> [GKN + 97] </ref>. This docking system is shown in Figure 9.2. Each mobile host has an associated dock, which is some permanently connected machine within the network. A stationary agent called the dockmaster runs on each dock machine. <p> To this end, Dawn Lawrie, Mark Hoagland and Joseph Edelman 5 have developed a hierarchical service index <ref> [GKN + 97] </ref>. This hierarchical index is implemented as a set of stationary yellow page agents, which maintain a set of entries that refer to specific service agents as well as other yellow page agents. Each entry contains a set of named fields. <p> Wilmer Caripe, Katsuhiro Moizumi 7 and several undergraduates in the computer science department are working on various network-sensing and decision-making tech-7 Wilmer Caripe and Hiro Moizumi are both Ph.D. students in the Thayer School of Engineering. 181 niques <ref> [GKN + 97, Car97] </ref>. Both passive and active network-sensing techniques are under development. Passive techniques include piggybacking bandwidth and latency information onto existing agent traffic as well as taking round-trip timings for existing agent traffic. <p> Mobile computing. Agent Tcl is meant to work seamlessly with both mobile computers and wireless networks. The existing docking system brings us a long ways towards this goal and will be our near-term focus <ref> [GKN + 97] </ref>. <p> provides numerous support services, most notably (1) a debugger that tracks an agent as it moves through the network and provides traditional debugger features such as breakpoints, watch conditions and line-at-a-time execution [HK97], (2) a docking system that allows an agent to transparently migrate to or from a mobile computer <ref> [GKN + 97] </ref>, (3) hierarchical yellow pages that provide a keyword-indexed directory of available services [GKN + 97], (4) several network sensing and planning modules that allow an agent to determine the best route through the network [GKN + 97, Car97], and (5) a Mobile Agent Construct Environment (MACE) that allows <p> moves through the network and provides traditional debugger features such as breakpoints, watch conditions and line-at-a-time execution [HK97], (2) a docking system that allows an agent to transparently migrate to or from a mobile computer <ref> [GKN + 97] </ref>, (3) hierarchical yellow pages that provide a keyword-indexed directory of available services [GKN + 97], (4) several network sensing and planning modules that allow an agent to determine the best route through the network [GKN + 97, Car97], and (5) a Mobile Agent Construct Environment (MACE) that allows a nonprogram 203 mer to graphically construct an agent [Sha97]. <p> that allows an agent to transparently migrate to or from a mobile computer [GKN + 97], (3) hierarchical yellow pages that provide a keyword-indexed directory of available services [GKN + 97], (4) several network sensing and planning modules that allow an agent to determine the best route through the network <ref> [GKN + 97, Car97] </ref>, and (5) a Mobile Agent Construct Environment (MACE) that allows a nonprogram 203 mer to graphically construct an agent [Sha97]. The main weaknesses of Agent Tcl are its lack of fault-recovery mechanisms and its poor performance relative to traditional client-server techniques.
Reference: [GM95] <author> James Gosling and Henry McGilton. </author> <title> The Java language environment: A white paper. Sun Microsystems White Paper, Sun Microsystems, </title> <year> 1995. </year>
Reference-contexts: science department and have spent two semesters each working on Agent Java. 70 5.4.1 Java Java is an object-oriented language that is syntactically similar to C++ except that there are no structures or unions, no functions, no multiple implementation inheritance, no operator overloading, no automatic type casts, and no pointers <ref> [GM95, Sun97b, CH97] </ref>. A sample Java program is shown in Figure 5.5. Memory in Java is garbage-collected so there is no delete operator. Java is multi-threaded and includes thread synchronization primitives at the language level.
Reference: [Gra95] <author> Robert S. Gray. </author> <title> Agent Tcl: A transportable agent system. </title> <editor> In James Mayfield and Tim Finin, editors, </editor> <booktitle> Proceedings of the CIKM Workshop on Intelligent Information Agents, Fourth International Conference on Information and Knowledge Management (CIKM 95), </booktitle> <address> Baltimore, Maryland, </address> <month> December </month> <year> 1995. </year> <month> 210 </month>
Reference-contexts: Agent Tcl <ref> [Gra97, GKCR97, Gra96, Gra95] </ref> is a mobile-agent system that is under development at Dartmouth College to address some of these research problems.
Reference: [Gra96] <author> Robert S. Gray. </author> <title> Agent Tcl: A flexible and secure mobile-agent sys-tem. </title> <editor> In Mark Diekhans and Mark Roseman, editors, </editor> <booktitle> Proceedings of the Fourth Annual Tcl/Tk Workshop (TCL '96), </booktitle> <address> Monterey, California, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: Agent Tcl <ref> [Gra97, GKCR97, Gra96, Gra95] </ref> is a mobile-agent system that is under development at Dartmouth College to address some of these research problems.
Reference: [Gra97] <author> Robert S. Gray. </author> <title> Agent Tcl: </title> <note> Release 2.0, 1997. Available at http://www.cs. dartmouth.edu/~agent/. </note>
Reference-contexts: Agent Tcl <ref> [Gra97, GKCR97, Gra96, Gra95] </ref> is a mobile-agent system that is under development at Dartmouth College to address some of these research problems.
Reference: [Gre97a] <author> Michael Greenberg. </author> <note> FTP Software, Septmber 1997. Personal correspondence. </note>
Reference-contexts: FTP Software no longer sells CyberAgents, but a version of CyberAgents that uses the TRAC language (rather than Java) is used in some of FTP Software's network management tools <ref> [Gre97a] </ref>. Other Java-based systems include Mole [SBH96, BHR + 97], Concordia [Mit97a, WPW + 97], Voyager [Voy97], and Wasp [Fun97]. The Mole project is focusing on security mechanisms for protecting an agent from a malicious machine, while the Wasp project is concerned with integrating mobile agents with Web servers.
Reference: [Gre97b] <author> Michael Greenberg. </author> <title> Non-authentication security modes for mobile agents. </title> <booktitle> In Proceedings of the 1997 Workshop on Mobile Agents and Security, </booktitle> <institution> University of Maryland, </institution> <month> October </month> <year> 1997. </year>
Reference-contexts: models exist, such as (1) mandatory access control, in which programs, people and data are assigned classification levels, and information can not flow from higher to lower levels, (2) security automata [Sch97a], in which a program's current allowed actions depend on its past resource usage, 10 and (3) computer immunology <ref> [FHS97, Gre97b] </ref>, in which a program is considered malicious if its current pattern of resource usage does not match its normal pattern. Although none of these models are incompatible with Agent Tcl's current architecture, architectural extensions would be needed for all three.
Reference: [GSS94] <author> Michael Genesereth, Narinder Singh, and Mustafa Syed. </author> <title> A distributed and anonymous knowledge sharing approach to software interopera-tion. </title> <editor> In Yannis Labrou and Tim Finin, editors, </editor> <booktitle> Proceedings of the CIKM Workshop on Intelligent Information Agents, Third International Conference on Information and Knowledge Management (CIKM 94), </booktitle> <address> Gaithersburg, Maryland, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: Agents that use KQML can communicate with each other directly, but this places the burden of interoperation squarely on the programmer. Instead Genesereth proposes a federated architecture in which facilitators handle interoperation <ref> [GSS94] </ref>. Essentially each agent is assigned a facilitator. An agent communicates only with its facilitator, but facilitators communicate with each other. Each agent posts its capabilities and application-specific facts to its facilitator. When an agent needs information, it sends a request to its facilitator. <p> Each entry contains a set of named fields. Each field contains either a keyword list or a definition of the interface that the server agent supports. Possible interface definitions include a set of KQML queries <ref> [GSS94] </ref> or a set of Agent RPC functions [NCK96]. To find a service, an agent contacts a yellow page agent and does an exact or ranked search on the contents of one or more fields. <p> The idea is to allow agents that have simple requirements to communicate with minimal overhead, while providing a base on top of which more complex communication protocols can be implemented efficiently at the agent level. Possible protocols include whiteboards, KQML <ref> [GSS94] </ref>, remote procedure call (RPC) [BN84] and remote method invocation [YD96]. Agent RPC, which Saurab Nog and Sumit Chawla 9 developed as a course project, is an RPC mechanism for Agent Tcl [NCK96]. The architecture of Agent RPC is shown in Figure 9.4.
Reference: [Haf95] <author> Katie Hafner. </author> <title> Have your agent call my agent. </title> <journal> Newsweek, </journal> <volume> 75(9), </volume> <month> Febru-ary 27 </month> <year> 1995. </year>
Reference-contexts: The popular definition of an agent is an intelligent software servant that either (1) relieves the user of a routine, burdensome task such as appointment scheduling or (2) filters the overwhelming amount of online information so that the user sees only the information that is relevant to her current needs <ref> [Haf95, Rog95] </ref>. This definition| due to its broadness and its ability to capture the imagination|has made "agent" a buzzword within both the academic and commercial worlds. Applications are often described as "agent-based" solely to draw attention or increase sales.
Reference: [Har95] <author> Kenneth E. Harker. TIAS: </author> <title> A Transportable Intelligent Agent System. </title> <type> Technical Report PCS-TR95-258, </type> <institution> Department of Computer Science, Dartmouth College, </institution> <year> 1995. </year> <month> 211 </month>
Reference-contexts: The architecture of Agent Tcl is shown in Figure 5.1. The architecture builds on the server model of Telescript [Whi94], the multiple languages of Ara [Pei96], and the transport mechanisms of two predecessor systems at Dartmouth <ref> [Har95, KK94] </ref>. The architecture has five levels. The lowest level is an API for the available transport mechanisms. The second level is a server that runs at each network site. The server performs the following tasks: * Status and administration.
Reference: [HBB96] <author> David Halls, John Bates, and Jean Bacon. </author> <title> Flexible distributed pro-gramming using mobile code. </title> <booktitle> In Proceedings of the Seventh ACM SIGOPS European Workshop, </booktitle> <pages> pages 225-231, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: portability. 44 by transferring a closure or continuation respectively; in addition, the Tube uses a safe Scheme interpreter and includes noticeboards, a user-interface toolkit, a service registry, an event system, continuous media streams, and a unique form of RPC in which the server sends the client stubs to the client <ref> [HBB96] </ref>. <p> Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ [LSW95, JvRS95, PS97, BFD96], Java [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96], and various scripting languages [JvRS95, PS97, JdT + 95, Coe94]. Functional languages such as Scheme are used only in a few research systems <ref> [CJK95, HBB96, TLKC95] </ref>. Java is the most popular imperative language and is used in every commercial system and several research systems.
Reference: [HCK95] <author> Colin G. Harrison, David M. Chess, and Aaron Kershenbaum. </author> <title> Mobile agents: Are they a good idea? IBM Research Report, </title> <institution> IBM T. J. Watson Research Center, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Summary. Although each of the advantages above is a reasonable argument for mobile agents, it is essential to realize that for any specific application, the same performance can be realized with other techniques <ref> [HCK95] </ref>. Such techniques include queued RPC [JTK97], higher-level server operations, application-specific query languages, application-specific proxies within the permanent network, automated installation facilities, and active web pages that contain Java applets.
Reference: [HCS97] <author> Leon Hurst, Padraig Cunningham, and Fergal Somers. </author> <title> Mobile agents| smart messages. </title> <booktitle> In Proceedings of the First International Workshop on Mobile Agents (MA '97), volume 1219 of Lecture Notes in Computer Science, </booktitle> <address> Berlin, April 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The Smart Messages system <ref> [HCS97] </ref> associates one or more reactive planners with each application-level message; the reactive planners are activated whenever the message is queued somewhere within the network and allow the message to control its own routing, filtering and error recovery.
Reference: [HG97] <author> Gisli Hjalmtysson and Robert S. Gray. </author> <title> Dynamic C++ classes: A lightweight mechanism to update code in a running program. </title> <type> AT&T Research Technical Report, </type> <institution> AT&T Research, </institution> <year> 1997. </year> <note> Submitted to the 1998 USENIX Technical Conference. </note>
Reference-contexts: Incremental linking is also questionable since, as with load balancing, the price of the dynamic code insertion is interpretive overhead. In fact, such dynamic code insertion can be achieved easily in natively compiled code <ref> [HG97] </ref>. Again, if mobile agents are used for other reasons, such dynamic code insertion would be a useful capability.
Reference: [HK97] <author> Melissa Hirschl and David Kotz. AGDB: </author> <title> A debugger for Agent Tcl. </title> <type> Technical Report PCS-TR97-306, </type> <institution> Department of Computer Science, Dartmouth College, </institution> <address> Hanover, New Hampshire, </address> <month> February </month> <year> 1997. </year>
Reference-contexts: Agent Tcl provides numerous support services, most notably (1) a debugger that tracks an agent as it moves through the network, monitors its communication with other agents, and provides traditional debugger features such as breakpoints, watch conditions and line-at-a-time execution <ref> [HK97] </ref>, (2) a docking system that allows an agent to transparently migrate to or from a mobile computer, even if the mobile computer is not currently connected to the network [GKN + 97], (3) hierarchical yellow pages that provide a keyword-indexed directory of available services [GKN + 97], (4) several network <p> Therefore Melissa Hirschl 2 wrote an interactive, graphical debugger for Agent Tcl <ref> [HK97] </ref>. The debugger tracks the agent as it moves from machine to machine, monitors its communication with other agents, and provides the traditional debugger features such as breakpoints, watch conditions, and line-at-a-time execution. Figure 9.1 shows the debugger interface while debugging the "who" agent from Figure 8.1. <p> Lightweight enforcement modules for each supported language enforce the man ager decisions. * Support services. Agent Tcl provides numerous support services, most notably (1) a debugger that tracks an agent as it moves through the network and provides traditional debugger features such as breakpoints, watch conditions and line-at-a-time execution <ref> [HK97] </ref>, (2) a docking system that allows an agent to transparently migrate to or from a mobile computer [GKN + 97], (3) hierarchical yellow pages that provide a keyword-indexed directory of available services [GKN + 97], (4) several network sensing and planning modules that allow an agent to determine the best
Reference: [HMPP96] <author> John Hartman, Udi Manber, Larry Peterson, and Todd Proebsting. </author> <title> Liquid software: A new paradigm for networked systems. </title> <type> Technical Report TR96-11, </type> <institution> Department of Computer Science, University of Ari-zonia, </institution> <year> 1996. </year> <month> 212 </month>
Reference-contexts: It provides authentication and access control, a globally unique namespace, whiteboards and message passing, and a simple management environment. IBM Aglets is extremely similar to the Odyssey system, and, in fact, the developer of IBM Aglets now works in the Odyssey group at General Magic. The Liquid Software project <ref> [HMPP96] </ref> has two goals: (1) use mobile agents to efficiently solve large-scale information-retrieval problems and (2) develop a "gigabit" compiler that can verify and compile an intermediate code representation as fast as it arrives over the network, producing efficient, secure native code while hiding the compilation latency. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ [LSW95, JvRS95, PS97, BFD96], Java <ref> [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96] </ref>, and various scripting languages [JvRS95, PS97, JdT + 95, Coe94]. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. Java is the most popular imperative language and is used in every commercial system and several research systems. <p> The agent is initially compiled into some intermediate code representation but then is compiled into native code on each machine that it visits, either as soon as it arrives <ref> [LSW95, HMPP96] </ref> or while it is executing [HMPP96]. <p> The agent is initially compiled into some intermediate code representation but then is compiled into native code on each machine that it visits, either as soon as it arrives [LSW95, HMPP96] or while it is executing <ref> [HMPP96] </ref>. When the entire agent is compiled upon arrival, software fault isolation (SFI) is typically used to prevent the native code from corrupting the execu-1 Agent Tcl uses Scheme 48, an implementation of Scheme based around a virtual machine [KR95]. 47 tion environment and violating security constraints [LSW95]. <p> Software-fault-isolated native code runs only 25 percent slower than natively compiled code [LSW95]; moreover "gigabit" compilers will be able to compile the agent as fast as it arrives over the network, completely hiding the compilation time <ref> [HMPP96] </ref>. Although Agent Tcl will eventually use "on-the-fly" compilation, either with Java or some other language, we have no immediate implementation plans, preferring instead to do a much more extensive round of performance analysis first. Migration. Different mobile-agent systems provide different migration mechanisms.
Reference: [Hoh97] <author> Fritz Hohl. </author> <title> Protecting mobile agents with blackbox security. </title> <booktitle> In Pro--ceedings of the 1997 Workshop on Mobile Agents and Security, </booktitle> <institution> University of Maryland, </institution> <month> October </month> <year> 1997. </year>
Reference-contexts: Thus, in some situations, the auditor can impose serious sanctions only after it has observed an apparent attack happening to multiple agents (that are following different migration trajectories). 120 * Encrypted algorithms. Recent work <ref> [San97, Hoh97] </ref> involves encrypting a pro-gram and its inputs in such a way that (1) the encrypted program is directly executable, (2) the encrypted program performs the same task as the original program, and (3) the output from the encrypted program is also encrypted and can only be decrypted by the
Reference: [JdT + 95] <author> Anthony D. Joseph, Alan F. de Lespinasse, Joshua A. Tauber, David K. Gifford, and M. Frans Kaashoek. </author> <title> Rover: A toolkit for mobile information access. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 156-171, </pages> <address> Copper Mountain, Colorado, </address> <month> December </month> <year> 1995. </year> <note> ACM Press. </note>
Reference-contexts: The Rover toolkit combines relocatable objects, 12 queued remote-procedure-calls (QRPC) and stable logging of object state to support fault recovery; although Rover is primarily used in disconnected or partially connected client-server computing, it can be used with some effort as a more general mobile-agent system <ref> [JdT + 95, JTK97, JK96] </ref>. The Smart Messages system [HCS97] associates one or more reactive planners with each application-level message; the reactive planners are activated whenever the message is queued somewhere within the network and allow the message to control its own routing, filtering and error recovery. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ [LSW95, JvRS95, PS97, BFD96], Java [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96], and various scripting languages <ref> [JvRS95, PS97, JdT + 95, Coe94] </ref>. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. Java is the most popular imperative language and is used in every commercial system and several research systems.
Reference: [JK96] <author> Anthony D. Joseph and M. Frans Kaashoek. </author> <title> Building reliable mobile-aware applications using the Rover toolkit. </title> <booktitle> In Proceedings of the Second Annual International Conference on Mobile Computing and Networking (MOBICOM '96), </booktitle> <pages> pages 117-129, </pages> <address> Rye, New York, </address> <month> November </month> <year> 1996. </year>
Reference-contexts: The Rover toolkit combines relocatable objects, 12 queued remote-procedure-calls (QRPC) and stable logging of object state to support fault recovery; although Rover is primarily used in disconnected or partially connected client-server computing, it can be used with some effort as a more general mobile-agent system <ref> [JdT + 95, JTK97, JK96] </ref>. The Smart Messages system [HCS97] associates one or more reactive planners with each application-level message; the reactive planners are activated whenever the message is queued somewhere within the network and allow the message to control its own routing, filtering and error recovery.
Reference: [Joh93] <author> Raymond W. Johnson. </author> <title> Autonomous knowledge agents: How agents use the tool command language. </title> <booktitle> In Proceedings of the 1993 Tcl Workshop, </booktitle> <year> 1993. </year>
Reference-contexts: Most existing systems that use the procedural approach are based around high-level scripting languages. An application is sent a script that guides the application through the desired task. Notable examples of the script-based approach include Tcl, AppleScript, Hewlett-Packard's NewWave environment and the Autonomous Knowledge Agents (AKA) project <ref> [GK94, Joh93] </ref>. Genesereth [GK94] points out several disadvantages of the procedural approach. Writing procedures might require information about the recipient that is not available to the sender; procedures only compute in one direction; and procedures are difficult to merge. <p> There are several schemes that can be viewed as a domain-specific form of remote evaluation. Postscript programs are often sent to remote printers and displays. Scripting systems such as Apple Script allow scripts to be sent from one application to another <ref> [Joh93] </ref>. MIME/Safe-Tcl allows Tcl scripts to be embedded in e-mail messages; the scripts are executed automatically when the message is received or viewed [LO95].
Reference: [Joh95] <author> D. B. Johnson. </author> <title> Scalable support for transparent mobile host internet-working. </title> <journal> Wireless Networks, </journal> <volume> 1 </volume> <pages> 311-321, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: With the current and last-known IP addresses included in agent communication whenever possible, the servers can maintain a cache of last-known IP addresses and direct outgoing agents and messages to the last-known address of the destination machine, making the docking system much more efficient and exactly analogous to mobile IP <ref> [Joh95] </ref>. In fact, once mobile IP is widely available, the implementation of the docking system will become much simpler. 4 9.3 Yellow pages In a real-world environment, an agent must identify, locate and use previously unknown services.
Reference: [JSvR97] <author> Dag Johansen, Nils P. Sudmann, and Robbert van Renesse. </author> <title> Performance issues in Tacoma. </title> <booktitle> In Proceedings of the 3rd Workshop on Mobile Object Systems, 11th European Conference on Object-Oriented Programming, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Reducing migration overhead and using a faster language such as Java might provide competitive performance 156 without resorting to compiled code. A second Tacoma performance study <ref> [JSvR97] </ref> found that it takes 21.7 milliseconds to start a null agent on a remote machine.
Reference: [JTK97] <author> Anthony D. Joseph, Joshua A. Tauber, and M. Frans Kaashoek. </author> <title> Mobile computing with the Rover toolkit. </title> <booktitle> 46(3) </booktitle> <pages> 337-352, </pages> <month> March </month> <year> 1997. </year> <month> 213 </month>
Reference-contexts: Although each of these advantages is a reasonable argument for mobile agents, any specific application can be implemented just as efficiently and robustly with more traditional techniques, such as queued RPC <ref> [JTK97] </ref>, higher-level server operations, 2 application-specific query languages, application-specific proxies within the perma-nent network, automated installation facilities, and active web pages that contain Java applets. Mobile agents eliminate the need for these other techniques, however, combining their strengths into a single, general, convenient framework. <p> Summary. Although each of the advantages above is a reasonable argument for mobile agents, it is essential to realize that for any specific application, the same performance can be realized with other techniques [HCK95]. Such techniques include queued RPC <ref> [JTK97] </ref>, higher-level server operations, application-specific query languages, application-specific proxies within the permanent network, automated installation facilities, and active web pages that contain Java applets. <p> The Rover toolkit combines relocatable objects, 12 queued remote-procedure-calls (QRPC) and stable logging of object state to support fault recovery; although Rover is primarily used in disconnected or partially connected client-server computing, it can be used with some effort as a more general mobile-agent system <ref> [JdT + 95, JTK97, JK96] </ref>. The Smart Messages system [HCS97] associates one or more reactive planners with each application-level message; the reactive planners are activated whenever the message is queued somewhere within the network and allow the message to control its own routing, filtering and error recovery.
Reference: [JvRS95] <author> Dag Johansen, Robbert van Renesse, and Fred B. Scheidner. </author> <title> Operating system support for mobile agents. </title> <booktitle> In Proceedings of the Fifth IEEE Workshop on Hot Topics in Operating Systems (HTOS), </booktitle> <pages> pages 42-45, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: In a future version of Agent Tcl, the server will also provide a nonvolatile store for agents so that an agent can be restarted after a machine failure. As in the Tacoma system <ref> [JvRS95] </ref>, all other services are provided by agents. Such services include resource directories, network-sensing tools, higher-level communication protocols such as RPC, and resource managers. <p> In addition, each execution environment includes a package of stub routines that the agent uses to interact with the servers and obtain the available agent services, such as migration, communication, and status queries. 4 Agent Tcl is similar to other mobile-agent systems, such as Tacoma <ref> [JvRS95] </ref>, Ara [PS97], and Telescript [Whi94], but distinguishes itself with (1) its combination of multiple languages, a simple migration mechanism, and both low- and high-level communication protocols, (2) its simple but effective security model, and (3) its extensive support services and tools. * Multiple languages (Chapter 5). <p> Sumatra does not provide any security mechanisms aside from those already present in Java. Similar to Kali Scheme, its main weakness is that the implementation is Java-specific (and in fact is contained entirely within the Java virtual machine), once again preventing any straightforward extension to additional languages. Tacoma <ref> [JvRS95, JvRS96, MvRSS96, Knu95] </ref>, Tacoma Too [Sch97a], and security automata [Sch97b] . Tacoma (Tromst and COrnell Moving Agents) is a mobile-agent system that supports numerous agent languages, including Tcl, Scheme, Perl, Python, Java and C. <p> A rear-guard agent is left behind whenever an agent migrates to a new machine; this rear guard restarts the agent if the agent "vanishes" due to a machine failure <ref> [JvRS95] </ref>. Electronic cash is used to pay for services and to prevent runaway agents. 9 In addition, agents can be digitally signed and encrypted, and the tac firewall agent can be instructed to reject agents that came from unauthorized users. Broker agents provide directory services. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ <ref> [LSW95, JvRS95, PS97, BFD96] </ref>, Java [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96], and various scripting languages [JvRS95, PS97, JdT + 95, Coe94]. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ [LSW95, JvRS95, PS97, BFD96], Java [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96], and various scripting languages <ref> [JvRS95, PS97, JdT + 95, Coe94] </ref>. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. Java is the most popular imperative language and is used in every commercial system and several research systems. <p> With an object-oriented language, the typical system automatically captures the complete state of all existing objects [LO97]; with other languages, the typical system requires the programmer to explicitly assemble a package of variables and methods <ref> [JvRS95] </ref>. To ease the burden on the programmer, many systems allow the agent to follow a pre-established itinerary, which specifies a list of machines and the method that should be executed on each one [LO97, Gen97]. <p> Agent Tcl uses modified Tcl, Scheme and Java interpreters and supports both migration models. Communication. Communication mechanisms break down in two ways: low-level versus high-level, and location-dependent versus location-independent. For example, IBM Aglets provides messages, byte streams, and remote method invocation [LO97], while Tacoma provides the single meet operation <ref> [JvRS95] </ref>. Tacoma requires a sender to know the current machine of the recipient [JvRS95], while IBM Aglets provides a globally unique namespace [LO97]. There has been wide disagreement over which communication mechanisms are best for mobile agents. <p> Communication. Communication mechanisms break down in two ways: low-level versus high-level, and location-dependent versus location-independent. For example, IBM Aglets provides messages, byte streams, and remote method invocation [LO97], while Tacoma provides the single meet operation <ref> [JvRS95] </ref>. Tacoma requires a sender to know the current machine of the recipient [JvRS95], while IBM Aglets provides a globally unique namespace [LO97]. There has been wide disagreement over which communication mechanisms are best for mobile agents. <p> group of machines that are not under single administrative control. 2 One notable exception is Tacoma which uses rear guard agents to regenerate agents that suddenly disappear, various replication and voting schemes to handle malicious machines that provide incorrect information, and electronic cash to prevent an agent from living forever <ref> [JvRS95, MvRSS96] </ref>; these mechanisms are only a fraction of a complete solution. <p> Fault tolerance. Most systems provide only a nonvolatile store so that agents can live past machine failure [Whi94]. Tacoma, however, provides rear guard agents that restart vanished agents <ref> [JvRS95] </ref>. In addition, the same voting and replication schemes that allow Tacoma to partially handle malicious machines also allow agents to continue with their task even if one or more copies of a desired service are unavailable. <p> Thus Tcl was chosen as the main language for the Agent Tcl system. The same advantages have led to the use of Tcl in other mobile-agent systems such as Tacoma <ref> [JvRS95] </ref> and Ara [Pei96]. 66 set query -mobile agents--set machines -muir tenaya tioga tuolomne-agent_begin # register with the agent system foreach machine $machines - agent_jump $machine agent_send "$machine query_engine" 0 $query set sender [agent_receive code result -blocking] - agent_jump $agent (home-server) agent_end interacts with a search engine on each machine. <p> Of course, using fake currency to control agent propagation does not prevent a service from charging real money at the application level. Many other agent projects plan to use electronic cash to control agent propagation, including Tacoma <ref> [JvRS95] </ref>, Ara [PS97], and Messengers [BFD96]. Little implementation work has been done by any of these projects. <p> Tacoma. The Tacoma system is used primarily in StormCast, a distributed weather-monitoring system in which the data volumes are so immense as to make data movement impractical <ref> [JvRS95] </ref>. Mobile agents allow new filtering and monitoring operations to be rapidly constructed and deployed to the data and sensor locations. <p> The agent jump command is not strictly necessary since we could continually resubmit a Tcl procedure that was parameterized according to the current status of the task; the procedure would use the parameters to determine what it needed to do on the current machine <ref> [JvRS95] </ref>. Such an approach, however, requires that the programmer explicitly collect the necessary state information. In the "who" agent, this state 165 is logged onto each one. <p> To protect a group of machines, we are looking at electronic cash schemes where each resource has an associated price; agents must spend electronic cash from their finite reserve to access the desired resources and thus cannot survive forever within the network <ref> [JvRS95, DiMMTH95] </ref>. 1 To protect an agent, we are looking at a combination of audit trails [CGH + 95], replication and voting schemes [MvRSS96], a component model in which an agent is divided into pieces that are encrypted and signed at different times and with different keys [CGH + 95], limited <p> Therefore the application must be able to detect a machine failure so that it can spawn a new agent to carry on with the task. One approach is illustrated in Tacoma where a migrating agent leaves behind rear guard agents <ref> [JvRS95] </ref>. A rear guard concludes that the migrating agent has disappeared if it loses contact with the agent for a suitably long period of time. Once this happens, the rear guard sends out a new copy of the agent. <p> The most immediate need is to create a version of Agent Tcl that does not provide the jump command and thus can run with the unmodified interpreters. Such a version would use migration techniques similar to those found in Aglets [Ven97], Odyssey [Gen97], Concordia [WPW + 97] or Tacoma <ref> [JvRS95] </ref>. At the same time, we need to decide whether the convenience of the jump command outweighs the additional burden that it places on the system programmer.
Reference: [JvRS96] <author> Dag Johansen, Robbert van Renesse, and Fred B. Schneider. </author> <title> Supporting broad Internet access to TACOMA. </title> <booktitle> In Proceedings of the Seventh ACM SIGOPS European Workshop, </booktitle> <pages> pages 55-58, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: Sumatra does not provide any security mechanisms aside from those already present in Java. Similar to Kali Scheme, its main weakness is that the implementation is Java-specific (and in fact is contained entirely within the Java virtual machine), once again preventing any straightforward extension to additional languages. Tacoma <ref> [JvRS95, JvRS96, MvRSS96, Knu95] </ref>, Tacoma Too [Sch97a], and security automata [Sch97b] . Tacoma (Tromst and COrnell Moving Agents) is a mobile-agent system that supports numerous agent languages, including Tcl, Scheme, Perl, Python, Java and C. <p> Tacoma is also used in active documents and to manage software installation within a networked collection 162 of machines <ref> [JvRS96] </ref>. Agent Tcl can be used effectively in both, although active documents require additional infrastructure to inject an agent embedded inside a document into the local agent system. 2 Telescript. Telescript was used primarily in active mail, network and platform management, and electronic commerce [Rei94]. <p> A user would give an agent to the applet or CGI script, which would pass the agent on to the agent server <ref> [JvRS96] </ref>. Although the first approach is more flexible, it is much more complex and is mainly a matter of porting code, making it more suited to a commercial product rather than a research project. Instead we will take the second approach. Operating system support.
Reference: [KK94] <author> Keith Kotay and David Kotz. </author> <title> Transportable agents. </title> <editor> In Yannis Labrou and Tim Finin, editors, </editor> <booktitle> Proceedings of the CIKM Workshop on Intelligent Information Agents, Third International Conference on Information and Knowledge Management (CIKM 94), </booktitle> <address> Gaithersburg, Mary-land, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: application implemented as a "wave" of extremely compact, lightweight agents that recursively spread themselves through a virtual network 13 ; although WAVE is syntactically awkward and demands a highly recursive programming style, it has been used effectively in several applications, including distributed simulation, network management, and distributed database retrieval [Sap96]. <ref> [KK94] </ref> implements a simple mobile-agent system in which the agents are written in a scripting language similar to AWK and migrate from machine to machine with a moveto instruction; this system was the forerunner to Agent Tcl here at Dartmouth. 3.3 Safe languages Finally, there are several interpreted languages where either <p> The architecture of Agent Tcl is shown in Figure 5.1. The architecture builds on the server model of Telescript [Whi94], the multiple languages of Ara [Pei96], and the transport mechanisms of two predecessor systems at Dartmouth <ref> [Har95, KK94] </ref>. The architecture has five levels. The lowest level is an API for the available transport mechanisms. The second level is a server that runs at each network site. The server performs the following tasks: * Status and administration.
Reference: [Kna96] <author> Frederick Knabe. </author> <title> An overview of mobile agent programming. </title> <booktitle> In Proceedings of the Fifth LOMAPS Workshop on Analysis and Verification of Multiple-Agent Languages, </booktitle> <address> Stockholm, Sweden, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: One example is a server that sends back a data set along with an agent that can present the data in various ways; the user can view and manipulate the data without any further contact with the server, reducing server load and allowing much faster response times to user actions <ref> [Kna96] </ref>. In such an application, the agent serves the same purpose as a Java applet, which is downloaded into a Java-enabled browser so that a Web-based application can present a complex graphical interface without annoying delays [CH97]. <p> Of course, the same effect can be achieved if the user installs special client software on their machine. The need for a separate installation step, however, makes it much more unlikely that a user will try a new Internet service or use a service that she only needs once <ref> [Kna96] </ref>. Both mobile agents and Java applets eliminate the installation step and allow a user to try a service with minimal effort. Dynamic deployment. Mobile agents allow rapid development, testing and installation of distributed applications since application components can be deployed "on-the-fly" to arbitrary network sites. <p> Such dynamic redeployment is used in [RASS97] to ensure that an Internet "chat" server is always located at the network position that minimizes the average latency between it and its current clients. Intelligent data <ref> [Kna96] </ref>. Intelligent (or active) data can be viewed as a special form of dynamic deployment. Here the messages in some arbitrary messaging system contain both data and the code that is needed to handle that data on the destination 14 machine. <p> Here the messages in some arbitrary messaging system contain both data and the code that is needed to handle that data on the destination 14 machine. Such code might be a viewer for a multimedia data type or a decompression routine to uncompress compressed data <ref> [Kna96] </ref>. Including code in the messages allows the destination machine to handle new data types without user effort and makes it trivial to introduce better viewers and decompression algorithms. <p> Mobile Service Agents (MSA) are written in an extended version of the functional programming language Facile; an MSA agent spawns a new agent by submitting a closure containing data and one or more functions <ref> [TLKC95, Kna96] </ref>. <p> implement. 3 This infrastructure is also easy to implement. 163 Other suggested applications include active e-mail, distributed information retrieval, software updates in telecommunications switches, software updates for general user applications (that are organized as a collection of cooperating agents), and automatic introduction of new components into a computer-aided manufacturing system <ref> [TLKC95, Kna96] </ref>. Except for telecommunications software, which demands code speed that existing mobile-agent systems cannot deliver, all of these applications are reasonable uses for mobile agents in general and Agent Tcl in particular. Network management.
Reference: [Knu95] <author> Paul Knudsen. </author> <title> Comparing two distributed paradigms a performance-case study. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, Institute of Mathematical and Physical Science, University of Tromst, </institution> <year> 1995. </year>
Reference-contexts: Sumatra does not provide any security mechanisms aside from those already present in Java. Similar to Kali Scheme, its main weakness is that the implementation is Java-specific (and in fact is contained entirely within the Java virtual machine), once again preventing any straightforward extension to additional languages. Tacoma <ref> [JvRS95, JvRS96, MvRSS96, Knu95] </ref>, Tacoma Too [Sch97a], and security automata [Sch97b] . Tacoma (Tromst and COrnell Moving Agents) is a mobile-agent system that supports numerous agent languages, including Tcl, Scheme, Perl, Python, Java and C. <p> Tacoma. Within the context of the StormCast weather-monitoring system, the Tacoma group compared two different ways of determining the maximum temperature within a particular range of days <ref> [Knu95] </ref>. In the first approach, the entire temperature record for the days of interest is downloaded to the client machine. In the second approach, a mobile agent is sent to the machine where the temperature record is stored; the agent then extracts and returns only the desired maximum temperature. <p> Due mainly to migration overhead and the slowness of Tcl, they found that the mobile agent had better performance only when the agent was written in compiled C, and the temperature record for the desired period took up nearly one hundred kilobytes <ref> [Knu95] </ref>. This particular task, however, is probably the worst possible use of Tcl, as we saw above when finding a minimum integer in some set of integers. Reducing migration overhead and using a faster language such as Java might provide competitive performance 156 without resorting to compiled code. <p> The performance of the Tcl agents is good enough, however, to suggest that a combination of faster languages and additional system engineering will lead to competitive performance under even the best network conditions. Other performance studies such as <ref> [Knu95] </ref> and [RASS97] bear out this contention. Two faster languages, Java and Scheme, have already been added to Agent Tcl. In addition, there are several obvious improvements that can be made in the system implementation. First, the amount of dynamic memory allocation in the messaging subsystem can be reduced significantly.
Reference: [KPS95] <author> Charlie Kaufman, Radia Perlman, and Mike Speciner. </author> <title> Network Security: Private Communication in a Public World. </title> <publisher> Prentice-Hall, </publisher> <address> New Jersey, </address> <year> 1995. </year>
Reference-contexts: All of these problems have been considered in the mobile-agent literature [LO95, CGH + 95, TV96, PS97], but only the first two have seen significant implementation work. These same two problems are addressed in the current implementation of Agent Tcl using PGP <ref> [KPS95] </ref>, Safe Tcl [LO95, OLW97] and Java security managers [CH97]. First we present the current implementation and then potential solutions for the remaining two security problems. 6.1 Protecting the machine (and other agents) Protecting the machine involves two tasks: * Authentication. <p> Agent Tcl uses Pretty Good Privacy (PGP) for its digital signatures and encryption. PGP is a standalone program that allows the secure transmission of electronic mail and is in widespread use despite controversies over patents and export restrictions <ref> [KPS95] </ref>. PGP encrypts a file or mail message using the IDEA algorithm and a randomly chosen secret key, encrypts the secret key using the RSA public-key algorithm and the recipient's public key, and then sends the encrypted key and file to the recipient. <p> the server on its home machine, the registration request is signed with the owner's private key (S) and optionally encrypted with the receiving machine's public key (E). generate a secret session key, known only to the agent and the server, and then use this session key to encrypt the requests <ref> [KPS95] </ref>. PGP does not provide direct access to its internal secret-key routines, however, making it impossible to generate and use session keys without modifying PGP.
Reference: [KR95] <author> Richard Kelsey and Jonathan Rees. </author> <title> A tractable Scheme implementation. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 7(4), </volume> <year> 1995. </year> <month> 214 </month>
Reference-contexts: The recent popularity of mobile code has led to an explosion in the number of mobile-agent systems. Here we describe a few representative systems in detail and mention other systems briefly. Kali Scheme [CJK95]. Kali Scheme is an extension of Scheme 48 <ref> [KR95] </ref>, which is an efficient, multi-threaded Scheme implementation based around a bytecode interpreter. Kali Scheme provides a distributed set of address spaces in which the threads execute. <p> Such languages include Java [CH97], Scheme 48 <ref> [KR95] </ref>, Tcl [Ous94, OLW97], Lua [dIC96], and Python [Lut96], as well as Obliq [Car95] and Telescript [Whi94], which were specifically designed for mobile objects or agents. <p> When the entire agent is compiled upon arrival, software fault isolation (SFI) is typically used to prevent the native code from corrupting the execu-1 Agent Tcl uses Scheme 48, an implementation of Scheme based around a virtual machine <ref> [KR95] </ref>. 47 tion environment and violating security constraints [LSW95]. Software-fault-isolated native code runs only 25 percent slower than natively compiled code [LSW95]; moreover "gigabit" compilers will be able to compile the agent as fast as it arrives over the network, completely hiding the compilation time [HMPP96]. <p> Second, there are several existing Scheme interpreters that support the full language, but that are still lightweight and extremely efficient, most notably Scheme 48 which is based around a virtual machine <ref> [KR95] </ref>. Third, since Scheme is a type-safe language and is lexically scoped, it already provides the initial layer of security that is needed when executing untrusted agents [CJK95]. <p> Implementation of the Java security manager is not yet complete. Since the methods follow the same logic as the corresponding Safe Tcl procedures, however, implementation will proceed rapidly. Scheme. Scheme 48 has a module system <ref> [KR95] </ref>. A module is a set of Scheme functions with some of those functions marked as exported or public; a program can load the module and invoke any of the exported functions.
Reference: [LDD95] <author> Anselm Lingnau, Oswald Drobnik, and Peter Domel. </author> <title> An HTTP-based infrastructure for mobile agents. World Wide Web Journal, </title> <type> (1), </type> <month> De-cember </month> <year> 1995. </year>
Reference-contexts: The Frankfurt Mobile Agents Infrastructure (ffMAIN) <ref> [LDD95] </ref> allows agents written in Tcl to migrate and communicate using the standard HTTP protocol; their agent server is a modified HTTP server.
Reference: [Lew95] <author> Ted G. Lewis. </author> <booktitle> Where is client/server software heading? IEEE Computer, </booktitle> <pages> pages 49-55, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Bandwidth. In the traditional client/server model <ref> [Lew95] </ref>, the server provides a fixed set of operations that a client invokes from a remote machine.
Reference: [LO95] <author> Jacob Y. Levy and John K. Ousterhout. </author> <title> Safe Tcl toolkit for electronic meeting places. </title> <booktitle> In Proceedings of the First USENIX Workshop on Electronic Commerce, </booktitle> <pages> pages 133-135, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Two existing systems with such active messages are (1) Safe-Tcl/MIME in which Tcl scripts are embedded inside MIME-enabled mail messages and executed (inside a safe execution environment) when the message is received or read <ref> [LO95] </ref> and (2) active networks in which packets contain small code fragments that are executed on each router [TSS + 97]. Convenient paradigm. Mobile agents are a convenient paradigm for distributed applications. First, application components can dynamically deploy themselves throughout the network as described above. <p> Postscript programs are often sent to remote printers and displays. Scripting systems such as Apple Script allow scripts to be sent from one application to another [Joh93]. MIME/Safe-Tcl allows Tcl scripts to be embedded in e-mail messages; the scripts are executed automatically when the message is received or viewed <ref> [LO95] </ref>. The IBM Intelligent Communications Network uses Intelligent Objects that contain both data and procedures and can be sent from one application to another; the recipient application can execute the embedded procedures [Rei94]. <p> If the network machines are under single administrative control, solutions are relatively straightforward; if the machines are not, solutions are much more complex. All of these problems have been considered in the mobile-agent literature <ref> [LO95, CGH + 95, TV96, PS97] </ref>, but only the first two have seen significant implementation work. These same two problems are addressed in the current implementation of Agent Tcl using PGP [KPS95], Safe Tcl [LO95, OLW97] and Java security managers [CH97]. <p> All of these problems have been considered in the mobile-agent literature [LO95, CGH + 95, TV96, PS97], but only the first two have seen significant implementation work. These same two problems are addressed in the current implementation of Agent Tcl using PGP [KPS95], Safe Tcl <ref> [LO95, OLW97] </ref> and Java security managers [CH97]. First we present the current implementation and then potential solutions for the remaining two security problems. 6.1 Protecting the machine (and other agents) Protecting the machine involves two tasks: * Authentication. Verify the identity of an agent's owner. * Authorization and enforcement. <p> The enforcement module is different for each language. 104 Tcl. The Tcl enforcement module is implemented with Safe Tcl. Safe Tcl is a Tcl extension that is designed to allow the safe execution of untrusted Tcl scripts <ref> [LO95, OLW97] </ref>. Safe Tcl provides two interpreters. One interpreter is a "trusted" interpreter that has access to the standard Tcl/Tk commands. The other interpreter is an "untrusted" interpreter in which all dangerous commands have been replaced with links to secure versions in the trusted interpreter. <p> Some of these subtle security risks do not actually involve damage to the machine or access to privileged information, but instead involve serious annoyance for the machine's owner. Agent Tcl uses the generalization of Safe Tcl that appears in the Tcl 7.5 core <ref> [LO95] </ref>. Agent Tcl creates a trusted and untrusted interpreter for each incoming agent. The agent executes in the untrusted interpreter. All dangerous commands have been removed from the untrusted interpreter and replaced with links to secure versions in the trusted interpreter.
Reference: [LO97] <author> Danny B. Lange and Mitsuru Oshima. </author> <note> The Aglet cookbook. 1997. In progress. Selected chapters available at http:// www.trl.ibm.co.jp/ aglets/ aglet-book/ index.html. </note>
Reference-contexts: Like Sumatra, Odyssey is intimately tied to the Java language with no clear way to integrate additional languages. General Magic is not selling Odyssey; instead they are using it as a key internal component of their new personal messaging service. Other Java-based systems. The IBM Aglets system <ref> [LO97] </ref> is one of the more complete commercial offerings. It provides authentication and access control, a globally unique namespace, whiteboards and message passing, and a simple management environment. <p> IBM Itinerant Agents is a proposed system that focuses on knowledge-based routing of service requests and security issues [CGH + 95]; it is not under active development and has given way to the more recent IBM Aglets system <ref> [LO97] </ref>. LogicWare [Log96] supports collaborative applications through an active object space; this object space can include mobile 43 agents called Mubots that move from machine to machine in response to changing network conditions and the location of the participants. <p> Research versus commercial. Aside from Telescript [Whi94], most mobile-agent systems were strictly research projects until about two years ago. Since then, the number of commercial systems has increased dramatically and now includes Odyssey [Gen97], IBM Aglets <ref> [LO97] </ref>, Concordia [WPW + 97], Voyager [Voy97] and Omniware [LSW95]. As the reader might expect, commercial systems provide much better administration and development tools than research systems. In addition, all commercial systems provide sufficient security mechanisms to protect a machine from malicious agents. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ [LSW95, JvRS95, PS97, BFD96], Java <ref> [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96] </ref>, and various scripting languages [JvRS95, PS97, JdT + 95, Coe94]. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. Java is the most popular imperative language and is used in every commercial system and several research systems. <p> Systems that use the jump migration model include Agent Tcl, Kali Scheme [CJK95], and Telescript [Whi94]. * known entry point. The system moves the variables and methods of the agent to the new machine, and then restarts agent execution at some specified method <ref> [LO97] </ref>. With an object-oriented language, the typical system automatically captures the complete state of all existing objects [LO97]; with other languages, the typical system requires the programmer to explicitly assemble a package of variables and methods [JvRS95]. <p> The system moves the variables and methods of the agent to the new machine, and then restarts agent execution at some specified method <ref> [LO97] </ref>. With an object-oriented language, the typical system automatically captures the complete state of all existing objects [LO97]; with other languages, the typical system requires the programmer to explicitly assemble a package of variables and methods [JvRS95]. <p> To ease the burden on the programmer, many systems allow the agent to follow a pre-established itinerary, which specifies a list of machines and the method that should be executed on each one <ref> [LO97, Gen97] </ref>. All commercial systems use the known entry point model with an itinerary, simply because all commercial systems use Java, which cannot 48 support the jump model without modifications to the standard virtual ma-chine. Every system that supports the jump model also supports the known entry point model. <p> In addition to these two migration models, many systems that use object-oriented languages allow an agent to move an individual object to a remote machine and then invoke that object's methods; the object does not have its own thread of control <ref> [LO97, Gen97, Car95, RASS97] </ref>. Which of the two migration models is best remains unclear. The jump model is more convenient for the end programmer since she does not have to explicitly check the current state and figure out what to do next at each entry point. <p> Agent Tcl uses modified Tcl, Scheme and Java interpreters and supports both migration models. Communication. Communication mechanisms break down in two ways: low-level versus high-level, and location-dependent versus location-independent. For example, IBM Aglets provides messages, byte streams, and remote method invocation <ref> [LO97] </ref>, while Tacoma provides the single meet operation [JvRS95]. Tacoma requires a sender to know the current machine of the recipient [JvRS95], while IBM Aglets provides a globally unique namespace [LO97]. There has been wide disagreement over which communication mechanisms are best for mobile agents. <p> For example, IBM Aglets provides messages, byte streams, and remote method invocation <ref> [LO97] </ref>, while Tacoma provides the single meet operation [JvRS95]. Tacoma requires a sender to know the current machine of the recipient [JvRS95], while IBM Aglets provides a globally unique namespace [LO97]. There has been wide disagreement over which communication mechanisms are best for mobile agents. <p> All commercial Java-based mobile-agent systems, such as IBM Aglets <ref> [LO97, Ven97] </ref>, General Magic's Odyssey [Gen97] and Mitsubishi's Concordia [WPW + 97], rely on this object serialization facility.
Reference: [Log96] <author> LogicWare technology: </author> <title> Foundation for next generation, world wide, collaborative applications. </title> <address> Crystaliz White Paper, Crystaliz, </address> <year> 1996. </year>
Reference-contexts: IBM Itinerant Agents is a proposed system that focuses on knowledge-based routing of service requests and security issues [CGH + 95]; it is not under active development and has given way to the more recent IBM Aglets system [LO97]. LogicWare <ref> [Log96] </ref> supports collaborative applications through an active object space; this object space can include mobile 43 agents called Mubots that move from machine to machine in response to changing network conditions and the location of the participants.
Reference: [LSW95] <author> Steven Lucco, Oliver Sharp, and Robert Wahbe. Omniware: </author> <title> A universal substrate for web programming. World Wide Web Journal, </title> <type> (1), </type> <month> December </month> <year> 1995. </year>
Reference-contexts: Obliq does not address security issues. Omniware <ref> [LSW95, ATLLW96] </ref>. Omniware code is written in C++ (or any other language for which an appropriate compiler exists), compiled for a RISC-like virtual machine, and later sent to a destination machine where it is converted into native code. <p> Software fault isolation, which essentially adds a range check to every memory access, prevents the native code from corrupting the execution environment [WLAG93]. With this arrangement, Omniware provides portable, secure code that is only 25 percent slower than natively compiled C/C++ on average <ref> [LSW95] </ref>. Therefore, although Omniware is not a general mobile-agent system itself, it or a similar execution environment is likely to find its way into most mobile-agent systems so that these systems can support compute-intensive applications. <p> Omniware could even be the only execution environment, since the interpreters for agents written in other languages could be compiled for the Omniware virtual machine and sent as needed to the destination machines <ref> [LSW95] </ref>. Sumatra [RASS97, RAS96]. Sumatra is an extension to Java [CW97] that supports both distributed objects and mobile code. <p> Research versus commercial. Aside from Telescript [Whi94], most mobile-agent systems were strictly research projects until about two years ago. Since then, the number of commercial systems has increased dramatically and now includes Odyssey [Gen97], IBM Aglets [LO97], Concordia [WPW + 97], Voyager [Voy97] and Omniware <ref> [LSW95] </ref>. As the reader might expect, commercial systems provide much better administration and development tools than research systems. In addition, all commercial systems provide sufficient security mechanisms to protect a machine from malicious agents. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ <ref> [LSW95, JvRS95, PS97, BFD96] </ref>, Java [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96], and various scripting languages [JvRS95, PS97, JdT + 95, Coe94]. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. <p> The agent is initially compiled into some intermediate code representation but then is compiled into native code on each machine that it visits, either as soon as it arrives <ref> [LSW95, HMPP96] </ref> or while it is executing [HMPP96]. <p> When the entire agent is compiled upon arrival, software fault isolation (SFI) is typically used to prevent the native code from corrupting the execu-1 Agent Tcl uses Scheme 48, an implementation of Scheme based around a virtual machine [KR95]. 47 tion environment and violating security constraints <ref> [LSW95] </ref>. Software-fault-isolated native code runs only 25 percent slower than natively compiled code [LSW95]; moreover "gigabit" compilers will be able to compile the agent as fast as it arrives over the network, completely hiding the compilation time [HMPP96]. <p> fault isolation (SFI) is typically used to prevent the native code from corrupting the execu-1 Agent Tcl uses Scheme 48, an implementation of Scheme based around a virtual machine [KR95]. 47 tion environment and violating security constraints <ref> [LSW95] </ref>. Software-fault-isolated native code runs only 25 percent slower than natively compiled code [LSW95]; moreover "gigabit" compilers will be able to compile the agent as fast as it arrives over the network, completely hiding the compilation time [HMPP96]. <p> The next section discusses the current status of the Agent Tcl implementation. 5 The checkpoint operation has not been fully implemented. The next section discusses the current status of the Agent Tcl implementation. 59 fault isolation to securely execute native code <ref> [LSW95] </ref>). <p> Agent languages. Omniware programs are compiled into intermediate code for a RISC-based virtual machine and then into software-fault-isolated (SFI) native code; this code runs only 25 percent slower than natively compiled code on average <ref> [LSW95, ATLLW96] </ref>. Java programs are compiled into intermediate code for a stack-based virtual machine and then either interpreted or compiled on-the-fly into native code. When interpreted, Java programs run 10 to 20 times slower than natively compiled C or C++ [CH97]. <p> The last three applications are all variations on the same theme, 1 Omniware, for example, uses on-the-fly compilation and software fault isolation to securely execute a C++ program only 25 percent slower than natively compiled code <ref> [LSW95] </ref>; similar approaches are just starting to find their way into mobile-agent systems. 160 either moving computation from client to server (e.g., a query against a database) or from server to client (e.g., a graphical front-end for a database), eliminating all intermediate network transmission and reducing either overall or per-operation latency. <p> Depending on the performance of Java agents relative to native code, we will consider either "just-in-time" compilation or software-fault-isolation of native code (or more likely of code for a low-level virtual machine that is immediately compiled into native code) <ref> [ATLLW96, WLAG93, LSW95] </ref>. Alternatively, the system could accept native code only from certain trusted users, eliminating the need for software fault isolation, but limiting untrusted agents to the slower, interpreted languages.
Reference: [Luc96] <institution> Inferno: la Commedia Interativa. </institution> <type> Lucent Technologies Technical Report, </type> <institution> Lucent Technologies, </institution> <year> 1996. </year> <note> This report is not available publically. Some information on Inferno can be found at http:// www.lucent.com/ inferno/. </note>
Reference-contexts: such as set-top boxes, telephones and network computers, which have limited storage facilities and need to download applications from the network as needed. 3.2.5 Inferno Inferno is a lightweight, networked operating system from Lucent Technologies that is also targeted towards mass-market devices such as set-top boxes, telephones and network computers <ref> [Luc96] </ref>. Inferno is Lucent's answer to Java and JavaOS. 4 An Inferno application consists of a set of modules written in a C-like language called Limbo; the modules are compiled into the bytecodes for a RISC-like virtual machine and then downloaded on demand to an Inferno platform.
Reference: [Lut96] <author> Mark Lutz. </author> <title> Programming Python. </title> <publisher> O'Reilly and Associates, </publisher> <year> 1996. </year>
Reference-contexts: Such languages include Java [CH97], Scheme 48 [KR95], Tcl [Ous94, OLW97], Lua [dIC96], and Python <ref> [Lut96] </ref>, as well as Obliq [Car95] and Telescript [Whi94], which were specifically designed for mobile objects or agents.
Reference: [Mad96] <author> Peter W. Madany. </author> <title> JavaOS: A standalone Java environment. Sun Microsystems White Paper, Sun Microsystems, </title> <booktitle> 1996. </booktitle> <pages> 215 </pages>
Reference-contexts: It also provides state serialization and unserialization facilities for transferring a Java object from one machine to another. Most Java-based distributed systems, including mobile-agent systems in which the agents are written in Java, use RMI for communication. Finally, JavaOS is a lightweight operating system that executes Java programs directly <ref> [Mad96] </ref>.
Reference: [Mae94] <editor> Pattie Maes. </editor> <title> Agents that reduce work and information overload. </title> <journal> Com--munications of the ACM, </journal> <volume> 37(7) </volume> <pages> 30-40, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: These agents are distinguished from traditional utilities by (1) their use of machine learning so that they can adapt to user habits and preferences <ref> [Mae94] </ref> or (2) their use of automated reasoning so that they can make complex inferences about the work environment [Rie94]. <p> Maes presents a series of agents that start with a minimum amount of domain knowledge and learn how to perform the task by observing and interacting with the user and other agents <ref> [Mae94] </ref>. The mail agent, for example, uses memory-based reasoning to filter electronic mail. It remembers every situation-action pair that occurs when the user filters her mail manually. When a new situation occurs, the agent predicts what action should be taken by comparing the new situation with the nearest memorized neighbors.
Reference: [MAF97] <institution> Mobile Agent Facility Specification (joint submissions). </institution> <type> Technical report, </type> <month> Crystaliz, </month> <title> General Magic, GMD FOKUS, Internal Business Machine Corporation, and The Open Group, 1997. Response to OMG's Common Facility Task Force RFP3. </title> <note> Draft 5 is available at http:// www.genmagic.com/ agents/ MAF/. </note>
Reference-contexts: CORBA is a distributed-object manager that already provides object naming, object location and remote invocation [YD96]. MOA builds on CORBA to provide object persistence, a hierarchical object cache, and a location-independent name service that uses URL's. In addition, MOA conforms to the new Mobile Agent Facility (MAF) standard <ref> [MAF97] </ref>. <p> Then, if a resource is not on an agent-enabled machine, an agent can migrate as close as possible to that machine and interact with the resource using standard cross-network calls <ref> [MAF97] </ref>. In addition, most agent commands can generate network traffic, particularly the commands that send messages and establish meetings. To prevent an agent from flooding the network, the network manager and enforcement modules must impose a maximum transmission rate. <p> The coalition has developed a Mobile Agent Facility (MAF) specification in response to the Object Management Group's Common Facility Task Force RFP3 <ref> [MAF97] </ref>. The specification "focuses on the interoperability of different agent systems" [MAF97]. The specification does not allow an agent from one system to execute inside another system; such a cross-execution mechanism is simply impossible due to the wide range 196 of programming languages that are used in different systems. <p> The coalition has developed a Mobile Agent Facility (MAF) specification in response to the Object Management Group's Common Facility Task Force RFP3 <ref> [MAF97] </ref>. The specification "focuses on the interoperability of different agent systems" [MAF97]. The specification does not allow an agent from one system to execute inside another system; such a cross-execution mechanism is simply impossible due to the wide range 196 of programming languages that are used in different systems.
Reference: [MBZM96] <author> Dejan S. Milojicic, Don Bolinger, Mary Ellen Zurko, and Murray Mazer. </author> <title> Mobile objects and agents. </title> <booktitle> The Open Group Research Institute, </booktitle> <month> November </month> <year> 1996. </year>
Reference-contexts: The evolving Mobile Objects and Agents (MOA) system is a CORBA-based sys 41 tem in which both static and active Java objects 10 can move from one machine to another <ref> [CMB96, MBZM96] </ref>. CORBA is a distributed-object manager that already provides object naming, object location and remote invocation [YD96]. MOA builds on CORBA to provide object persistence, a hierarchical object cache, and a location-independent name service that uses URL's. <p> which an application is partitioned into client-side and network-side components; these components cooperate when the network is available but continue operation even when the network is disconnected, presenting previously retrieved data to the user and finding additional data to send back to the user as soon as the network reconnects <ref> [MBZM96] </ref>. MOA will eventually enforce access restrictions according to the mobile object's owner, its current requirements, and possibly its past migration history. FTP Software's CyberAgents provided a visual editor, a visual agent manager, some debugging tools, OLE and HTML support, and extensive logging and report-generation facilities [FTP96].
Reference: [Men96] <institution> Gamelon file I/O library. Menai Corporation White Paper, Menai Corporation, </institution> <year> 1996. </year>
Reference-contexts: One such persistent store is the Gamelon File I/O library from the Menai corporation, which provides object-oriented persistent storage through a familiar file-access API <ref> [Men96] </ref>. Work is underway to integrate this library into the Agent Tcl system.
Reference: [Mit97a] <institution> Mobile agent computing. Mitsubishi Electric ITA White Paper, Mit-subishi Electric ITA, </institution> <year> 1997. </year>
Reference-contexts: FTP Software no longer sells CyberAgents, but a version of CyberAgents that uses the TRAC language (rather than Java) is used in some of FTP Software's network management tools [Gre97a]. Other Java-based systems include Mole [SBH96, BHR + 97], Concordia <ref> [Mit97a, WPW + 97] </ref>, Voyager [Voy97], and Wasp [Fun97]. The Mole project is focusing on security mechanisms for protecting an agent from a malicious machine, while the Wasp project is concerned with integrating mobile agents with Web servers. Voyager and Concordia are commercial systems.
Reference: [MIT97b] <institution> The Scheme programming language. </institution> <note> WWW page http:// www-swiss.ai.mit.edu/ scheme-home.html, </note> <year> 1997. </year>
Reference-contexts: Scheme provides first-class procedures and lambda expressions, supports both closures and continuations, evaluates both the operator and operand positions of a procedure call, and expresses iteration with procedure calls only <ref> [MIT97b] </ref>. The are four reasons to select Scheme as a mobile-agent language.
Reference: [Mul93] <author> Sape Mullender, </author> <title> editor. Distributed Systems. Addison-Wesley, second edition, </title> <booktitle> 1993. Lecture notes from the annual Advanced Course on Distributed Systems. </booktitle>
Reference-contexts: a similar viewpoint, if a stationary service agent disappears due to a machine failure, having the service remain unavailable until the machine comes back up is no more reasonable than in any distributed computing environment, demanding traditional service replication with a backup service agent taking over for an unavailable primary <ref> [Mul93] </ref>. Mobile agents do allow an interesting enhancement to traditional replication schemes, however, namely on-the-fly replication in which a new copy of the service agent can be dynamically deployed to any desired network location, either in response to machine and network failures or to changing load [RASS97]. <p> Finally, cooperating mobile agents are vulnerable to all the same communication failures as cooperating stationary processes, which means that some mobile-agent applications will need reliable group communication, transactions, voting schemes, and so on <ref> [Mul93] </ref>. 194 As with replication, there are three interesting questions: (1) which existing tech-niques are the more natural fit for a mobile-agent system, (2) how can techniques intended for stationary processes be extended to handle the fact that the communicating entities are moving from machine to machine, and (3) how much
Reference: [MvRSS96] <author> Yaron Minsky, Robbert van Renesse, Fred B. Schneider, and Scott D. Stoller. </author> <title> Cryptographic support for fault-tolerant distributed computing. </title> <booktitle> In Proceedings of the Seventh ACM SIGOPS European Workshop, </booktitle> <pages> pages 109-114, </pages> <month> September </month> <year> 1996. </year> <month> 216 </month>
Reference-contexts: Sumatra does not provide any security mechanisms aside from those already present in Java. Similar to Kali Scheme, its main weakness is that the implementation is Java-specific (and in fact is contained entirely within the Java virtual machine), once again preventing any straightforward extension to additional languages. Tacoma <ref> [JvRS95, JvRS96, MvRSS96, Knu95] </ref>, Tacoma Too [Sch97a], and security automata [Sch97b] . Tacoma (Tromst and COrnell Moving Agents) is a mobile-agent system that supports numerous agent languages, including Tcl, Scheme, Perl, Python, Java and C. <p> group of machines that are not under single administrative control. 2 One notable exception is Tacoma which uses rear guard agents to regenerate agents that suddenly disappear, various replication and voting schemes to handle malicious machines that provide incorrect information, and electronic cash to prevent an agent from living forever <ref> [JvRS95, MvRSS96] </ref>; these mechanisms are only a fraction of a complete solution. <p> Tacoma uses a replication and voting scheme to handle malicious machines that either terminate an agent outright or provide the agent with incorrect information <ref> [MvRSS96] </ref>. Here, if the task requires a single agent to visit n services in sequence, the application instead sends out several agents, each of which visits distinct but supposedly equivalent copies of the n services. The agents exchange results after each stage, each agent keeping the majority result. <p> Like the components themselves, such an authentication routine allows a machine to place greater trust in an agent that has migrated through untrusted machines. * Migration history. It is possible to embed a tamper-proof migration history inside a moving agent <ref> [MvRSS96] </ref>. This movement history allows the detection of some rerouting attacks, particularly if an agent is following a fixed itinerary, and, in combination with additional digital signatures, makes it impossible for a malicious machine to drop an entire component from the agent. <p> resource has an associated price; agents must spend electronic cash from their finite reserve to access the desired resources and thus cannot survive forever within the network [JvRS95, DiMMTH95]. 1 To protect an agent, we are looking at a combination of audit trails [CGH + 95], replication and voting schemes <ref> [MvRSS96] </ref>, a component model in which an agent is divided into pieces that are encrypted and signed at different times and with different keys [CGH + 95], limited forms of proof-carrying or self-authenticating code [PS97], and a tamper-proof movement history embedded inside a migrating agent [MvRSS96]. 1 Most electronic cash schemes <p> 95], replication and voting schemes <ref> [MvRSS96] </ref>, a component model in which an agent is divided into pieces that are encrypted and signed at different times and with different keys [CGH + 95], limited forms of proof-carrying or self-authenticating code [PS97], and a tamper-proof movement history embedded inside a migrating agent [MvRSS96]. 1 Most electronic cash schemes involve significant network communication. In a mobile-agent system, it is critical to eliminate as much communication as possible and defer the rest so that it does not lie on a critical path. 191 Fault tolerance.
Reference: [NCK96] <author> Saurab Nog, Sumit Chawla, and David Kotz. </author> <title> An RPC mechanism for transportable agents. </title> <type> Technical Report PCS-TR96-280, </type> <institution> Department of Computer Science, Dartmouth College, </institution> <month> March </month> <year> 1996. </year>
Reference-contexts: The base Agent Tcl system provides two low-level communication mechanisms, messaging passing and direct connections (for bulk data transfer), which work the same regardless of whether the communicating agents are on the same or different machines. Higher-level communication mechanisms, such as a Remote Procedure Call (RPC) mechanism <ref> [NCK96] </ref>, are implemented at the agent level on top of the two low-level services. With this approach, the agent programmer can choose from a range of communication mechanisms, but the base system remains lightweight. 5 * Security (Chapter 6). <p> The protocol works even if both agents use agent meet. The agent with the lower IP address and integer identifier selects the port and the other agent connects to that port. A flexible RPC mechanism 69 has been built on top of the direct connection mechanism <ref> [NCK96] </ref>. The server will take on more of the responsibility for establishing a direct connection as additional transport mechanisms are added. Agent Tcl also includes a (slightly) modified version of Tk 4.1 so that an agent can present a graphical interface and interact with the user of its current machine. <p> Each entry contains a set of named fields. Each field contains either a keyword list or a definition of the interface that the server agent supports. Possible interface definitions include a set of KQML queries [GSS94] or a set of Agent RPC functions <ref> [NCK96] </ref>. To find a service, an agent contacts a yellow page agent and does an exact or ranked search on the contents of one or more fields. If this search returns other yellow page agents, the agent can optionally recurse and make the same query of these other agents. <p> Possible protocols include whiteboards, KQML [GSS94], remote procedure call (RPC) [BN84] and remote method invocation [YD96]. Agent RPC, which Saurab Nog and Sumit Chawla 9 developed as a course project, is an RPC mechanism for Agent Tcl <ref> [NCK96] </ref>. The architecture of Agent RPC is shown in Figure 9.4. Agent RPC is exactly analogous to traditional RPC and allows an agent to invoke exported operations from another agent as if those operations were local procedures. <p> The client agent finds the desired server agent by querying the nameservers, either by name or by interface definition. The client agent then connects to the server agent and calls its local client stubs to invoke server operations. This figure appears in <ref> [NCK96] </ref> and was used with permission. 188 Chapter 10 Future work Performance analysis and performance improvements. <p> Helper routines would be provided to add and extract standard RPC data types [BN84] from a binary data buffer. The ability to transmit binary data would eliminate the parsing overhead, and in particular, would be a much more efficient lower-layer for the Agent RPC system <ref> [NCK96] </ref>. The messaging subsystem in Agent Tcl can already handle binary messages; we just need to implement a binary data type and the helper routines for each language. Unmodified interpreters. <p> The base Agent Tcl system provides two low-level commu-nication mechanisms, messaging passing and direct connections (for bulk data transfer), which work the same regardless of whether the communicating agents are on the same or different machines. Higher-level communication mechanisms, such as a Remote Procedure Call (RPC) mechanism <ref> [NCK96] </ref>, are implemented at the agent level on top of the two low-level services. With this approach, the agent programmer can choose from a range of communication mechanisms, but the base system remains lightweight. * Security.
Reference: [OLW97] <author> John K. Ousterhout, Jacob Y. Levy, and Brent B. Welch. </author> <title> The Safe-Tcl security model. </title> <type> Technical report, </type> <institution> Sun Microsystems Laboratories, </institution> <year> 1997. </year> <note> In progress. Draft available at http:// www.sunlabs.com/ people/ john.ousterhout/ safeTcl.html. </note>
Reference-contexts: Such languages include Java [CH97], Scheme 48 [KR95], Tcl <ref> [Ous94, OLW97] </ref>, Lua [dIC96], and Python [Lut96], as well as Obliq [Car95] and Telescript [Whi94], which were specifically designed for mobile objects or agents. <p> All of these problems have been considered in the mobile-agent literature [LO95, CGH + 95, TV96, PS97], but only the first two have seen significant implementation work. These same two problems are addressed in the current implementation of Agent Tcl using PGP [KPS95], Safe Tcl <ref> [LO95, OLW97] </ref> and Java security managers [CH97]. First we present the current implementation and then potential solutions for the remaining two security problems. 6.1 Protecting the machine (and other agents) Protecting the machine involves two tasks: * Authentication. Verify the identity of an agent's owner. * Authorization and enforcement. <p> The enforcement module is different for each language. 104 Tcl. The Tcl enforcement module is implemented with Safe Tcl. Safe Tcl is a Tcl extension that is designed to allow the safe execution of untrusted Tcl scripts <ref> [LO95, OLW97] </ref>. Safe Tcl provides two interpreters. One interpreter is a "trusted" interpreter that has access to the standard Tcl/Tk commands. The other interpreter is an "untrusted" interpreter in which all dangerous commands have been replaced with links to secure versions in the trusted interpreter.
Reference: [OPL94] <author> Tim Oates, M. V. Nagendra Prasad, and Victor Lesser. </author> <title> Networked information retrieval as distributed problem solving. </title> <editor> In Yannis Labrou and Tim Finin, editors, </editor> <booktitle> Proceedings of the CIKM Workshop on Intelligent Information Agents, Third International Conference on Information and Knowledge Management (CIKM 94), </booktitle> <address> Gaithersburg, Mary-land, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: The example softbot in [EW94] uses a combination of Internet resources to resolve underspecified e-mail addresses when sending messages. Vesser has written a succession of papers that develop a model for distributed searching. One of the more recent is <ref> [OPL94] </ref>, which recasts the model in terms of agents. In the model a search involving multiple distributed resources is performed by a collection of cooperating agents.
Reference: [Ous94] <author> John K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley Professional Computing Series. Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: Such languages include Java [CH97], Scheme 48 [KR95], Tcl <ref> [Ous94, OLW97] </ref>, Lua [dIC96], and Python [Lut96], as well as Obliq [Car95] and Telescript [Whi94], which were specifically designed for mobile objects or agents.
Reference: [Pei96] <author> Holger Peine. </author> <title> The Ara project. </title> <note> WWW page http:// www.uni-kl.edu/AG-Nehmer/Ara, Distributed Systems Group, </note> <institution> Department of Computer Science, University of Kaiserlautern, </institution> <year> 1996. </year>
Reference-contexts: C++ (which is compiled into an interpreted bytecode called MACE) and can migrate at any point during their execution; Ara allows an agent to checkpoint its state to disk and enforces limits on CPU time and memory usage, but does not yet protect resources such as the filesystem and network <ref> [PS97, Pei96] </ref>. The Ara group is currently implementing additional security mechanisms (such as digital signatures and access restrictions for all system resources) and adding support for the Java language. Tripathi and Karnik propose a mobile-agent system that uses CORBA as its lowest layer [TK93]. <p> The architecture of Agent Tcl is shown in Figure 5.1. The architecture builds on the server model of Telescript [Whi94], the multiple languages of Ara <ref> [Pei96] </ref>, and the transport mechanisms of two predecessor systems at Dartmouth [Har95, KK94]. The architecture has five levels. The lowest level is an API for the available transport mechanisms. The second level is a server that runs at each network site. <p> through the evaluation loop.) 65 The explicit stack is simpler and more flexible than the Ara solution, in which the C runtime stack must be captured in a portable way, and in which the same version of the Tcl interpreters must be present on both the source and destination machines <ref> [Pei96] </ref>. On the other hand, the explicit stack is less efficient. Our modified Tcl core runs Tcl programs approximately 10 percent slower than the standard Tcl core, whereas Ara's modified Tcl core imposes no significant overhead. <p> Thus Tcl was chosen as the main language for the Agent Tcl system. The same advantages have led to the use of Tcl in other mobile-agent systems such as Tacoma [JvRS95] and Ara <ref> [Pei96] </ref>. 66 set query -mobile agents--set machines -muir tenaya tioga tuolomne-agent_begin # register with the agent system foreach machine $machines - agent_jump $machine agent_send "$machine query_engine" 0 $query set sender [agent_receive code result -blocking] - agent_jump $agent (home-server) agent_end interacts with a search engine on each machine. <p> Third, every agent and every server request is currently executed in a separate process, which requires process creation, interprocess commu 189 nication and interprocess synchronization, all of which have high overhead. Although we do not feel that it is worthwhile to multithread the entire system as in Ara <ref> [Pei96] </ref>, the server itself should be multithreaded, eliminating most process creation and several extraneous communication steps. We will also consider limited multithreading in the interpreters themselves. <p> Tcl traces, for example, provide a way to automatically detect and save any change in the value of a Tcl variable; Ara uses traces for just this purpose <ref> [Pei96] </ref>. Similarly, persistent objects can be implemented easily with Java's existing object serialization facilities [CH97]. Although such higher-level state capture is more convenient for the programmer, we plan to focus on the more general mechanism, and implement the language-specific mechanisms as time allows.
Reference: [PS97] <author> Holger Peine and Torsten Stolpmann. </author> <title> The architecture of the Ara platform for mobile agents. </title> <booktitle> In Proceedings of the First International Workshop on Mobile Agents (MA '97), volume 1219 of Lecture Notes in Computer Science, </booktitle> <address> Berlin, April 1997. </address> <publisher> Springer-Verlag. </publisher> <pages> 217 </pages>
Reference-contexts: In addition, each execution environment includes a package of stub routines that the agent uses to interact with the servers and obtain the available agent services, such as migration, communication, and status queries. 4 Agent Tcl is similar to other mobile-agent systems, such as Tacoma [JvRS95], Ara <ref> [PS97] </ref>, and Telescript [Whi94], but distinguishes itself with (1) its combination of multiple languages, a simple migration mechanism, and both low- and high-level communication protocols, (2) its simple but effective security model, and (3) its extensive support services and tools. * Multiple languages (Chapter 5). <p> C++ (which is compiled into an interpreted bytecode called MACE) and can migrate at any point during their execution; Ara allows an agent to checkpoint its state to disk and enforces limits on CPU time and memory usage, but does not yet protect resources such as the filesystem and network <ref> [PS97, Pei96] </ref>. The Ara group is currently implementing additional security mechanisms (such as digital signatures and access restrictions for all system resources) and adding support for the Java language. Tripathi and Karnik propose a mobile-agent system that uses CORBA as its lowest layer [TK93]. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ <ref> [LSW95, JvRS95, PS97, BFD96] </ref>, Java [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96], and various scripting languages [JvRS95, PS97, JdT + 95, Coe94]. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ [LSW95, JvRS95, PS97, BFD96], Java [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96], and various scripting languages <ref> [JvRS95, PS97, JdT + 95, Coe94] </ref>. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. Java is the most popular imperative language and is used in every commercial system and several research systems. <p> Security. Existing mobile-agent systems focus on protecting an individual machine from malicious agents (or a group of machines that are under single administrative control) <ref> [Whi94, Gen97, PS97] </ref>. <p> The second, restoreState, takes the byte sequence and restores the internal state. Ara, which also supports multiple languages, additionally requires each interpreter to implement a set of scheduling operations and to allocate memory and access systems resources through functions defined in the core <ref> [PS97] </ref>. Agent Tcl does not need the scheduling operations since it executes each agent within its own process and relies on the underlying Unix system to schedule the processes. We hope to avoid these scheduling operations even when we make Agent Tcl multi-threaded. <p> If the network machines are under single administrative control, solutions are relatively straightforward; if the machines are not, solutions are much more complex. All of these problems have been considered in the mobile-agent literature <ref> [LO95, CGH + 95, TV96, PS97] </ref>, but only the first two have seen significant implementation work. These same two problems are addressed in the current implementation of Agent Tcl using PGP [KPS95], Safe Tcl [LO95, OLW97] and Java security managers [CH97]. <p> First, the current architecture requires that a new enforcement module be written for each language. This approach minimizes the changes to the standard interpreters, but is time-consuming and error-prone. Eventually we will move to the Ara model in which the core provides secure versions of all system functions <ref> [PS97] </ref>; these core functions would still contact the resource managers to determine access rights. Second, Agent Tcl uses discretionary access control, in which each resource has an associated access list that specifies the allowed actions for each agent owner. <p> Of course, using fake currency to control agent propagation does not prevent a service from charging real money at the application level. Many other agent projects plan to use electronic cash to control agent propagation, including Tacoma [JvRS95], Ara <ref> [PS97] </ref>, and Messengers [BFD96]. Little implementation work has been done by any of these projects. <p> Although it is impossible to detect all malicious modifications to this state information, it is possible to construct an authentication routine that will examine the state information for any obvious inconsistencies or impossibilities <ref> [PS97] </ref>. The authentication routine could also examine the current set of components. Such an authentication routine would be placed in its own component and digitally signed with the owner's key. <p> we are looking at a combination of audit trails [CGH + 95], replication and voting schemes [MvRSS96], a component model in which an agent is divided into pieces that are encrypted and signed at different times and with different keys [CGH + 95], limited forms of proof-carrying or self-authenticating code <ref> [PS97] </ref>, and a tamper-proof movement history embedded inside a migrating agent [MvRSS96]. 1 Most electronic cash schemes involve significant network communication.
Reference: [RAS96] <author> M. Ranganathan, Anurag Acharya, and Joel Saltz. </author> <title> Distributed re-source monitors for mobile objects. </title> <booktitle> In Proceedings of the Fifth International Workshop on Object Orientation in Operating Systems, </booktitle> <year> 1996. </year>
Reference-contexts: Omniware could even be the only execution environment, since the interpreters for agents written in other languages could be compiled for the Omniware virtual machine and sent as needed to the destination machines [LSW95]. Sumatra <ref> [RASS97, RAS96] </ref>. Sumatra is an extension to Java [CW97] that supports both distributed objects and mobile code. <p> Stationary agents also make use of the network monitors. The docking system, for example, relies on the local network monitor to tell it when the machine's network connection is back up. Sumatra uses a similar system of network monitors called Komodo <ref> [RAS96] </ref>. Machines have their own characteristics, most notably CPU speed and current load. Although this information can also be handled in the network monitors, we are planning to use the Simple Network Management Protocol (SNMP) instead [Car97]. The SNMP protocol associates a simple database (or MIB) with each network device.
Reference: [RASS97] <author> M. Ranganathan, Anurag Acharya, Shamik Sharma, and Joel Saltz. </author> <title> Network-aware mobile programs. </title> <booktitle> In Proceedings of the 1997 USENIX Technical Conference, </booktitle> <pages> pages 91-104, </pages> <year> 1997. </year>
Reference-contexts: For example, a search application can migrate to a dynamically selected proxy site and do its merging and filtering there, while a server can continually migrate to new machines to minimize the average latency between itself and its clients <ref> [RASS97] </ref>. In short, the true strength of mobile agents is that they are a uniform paradigm for distributed applications, allowing both data and code to move from machine to machine. <p> Dynamic deployment. Mobile agents allow rapid development, testing and installation of distributed applications since application components can be deployed "on-the-fly" to arbitrary network sites. In addition, even after it starts execution, the application can redeploy its components in response to changing network conditions. Such dynamic redeployment is used in <ref> [RASS97] </ref> to ensure that an Internet "chat" server is always located at the network position that minimizes the average latency between it and its current clients. Intelligent data [Kna96]. Intelligent (or active) data can be viewed as a special form of dynamic deployment. <p> Omniware could even be the only execution environment, since the interpreters for agents written in other languages could be compiled for the Omniware virtual machine and sent as needed to the destination machines [LSW95]. Sumatra <ref> [RASS97, RAS96] </ref>. Sumatra is an extension to Java [CW97] that supports both distributed objects and mobile code. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ [LSW95, JvRS95, PS97, BFD96], Java <ref> [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96] </ref>, and various scripting languages [JvRS95, PS97, JdT + 95, Coe94]. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. Java is the most popular imperative language and is used in every commercial system and several research systems. <p> In addition to these two migration models, many systems that use object-oriented languages allow an agent to move an individual object to a remote machine and then invoke that object's methods; the object does not have its own thread of control <ref> [LO97, Gen97, Car95, RASS97] </ref>. Which of the two migration models is best remains unclear. The jump model is more convenient for the end programmer since she does not have to explicitly check the current state and figure out what to do next at each entry point. <p> This method checks the current state of the objects to decide what to do next. Academic systems are not concerned with commercial acceptance and so are free to modify the Java virtual machine. The Sumatra system <ref> [RASS97] </ref> modifies release 1.0.2 of Sun's Java Development Kit so that it is possible to capture the complete state of an executing Java thread. <p> The statement is based on marketing information for the various Java virtual machines as well as informal benchmarks such as the CaffeineMarks. 155 Sumatra. One application of Sumatra is an Internet chat server that positions itself so as to minimize the maximum latency between itself and its clients <ref> [RASS97] </ref>. The chat server can migrate to any machine that is participating in the chat conversation. Resource monitors continually monitor the maximum latency between each machine and others and periodically sends the latency information to the chat server. <p> It must either provide a language that can be compiled on-the-fly into native code, or accept native code directly from certain highly trusted sources. Of course, accepting native code directly makes it much more difficult to handle a heterogeneous environment. Sumatra. <ref> [RASS97] </ref> suggests several applications for mobile programs: searching, filtering and combining "periodically generated large-volume datasets"; positioning a video or Internet chat server to minimize the average latency between the server and its clients; prefetching web pages; and more generally moving a network-intensive computation from a mobile computer to a dynamically selected <p> Initial work suggests that a sampling rate of thirty seconds to several hours generates sufficiently accurate estimates; the extra traffic at this sampling rate should be only a small fraction of the overall traffic <ref> [RASS97] </ref>. 9.5 Mobile Agent Construction Environment Although both Tcl and Java are generally regarded as easy to learn, they are still languages that fall within the realm of a capable programmer, rather than a nonprogrammer. <p> The performance of the Tcl agents is good enough, however, to suggest that a combination of faster languages and additional system engineering will lead to competitive performance under even the best network conditions. Other performance studies such as [Knu95] and <ref> [RASS97] </ref> bear out this contention. Two faster languages, Java and Scheme, have already been added to Agent Tcl. In addition, there are several obvious improvements that can be made in the system implementation. First, the amount of dynamic memory allocation in the messaging subsystem can be reduced significantly. <p> Mobile agents do allow an interesting enhancement to traditional replication schemes, however, namely on-the-fly replication in which a new copy of the service agent can be dynamically deployed to any desired network location, either in response to machine and network failures or to changing load <ref> [RASS97] </ref>.
Reference: [Rei94] <author> Andy Reinhardt. </author> <title> The network with smarts. </title> <journal> Byte, </journal> <pages> pages 51-64, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: The IBM Intelligent Communications Network uses Intelligent Objects that contain both data and procedures and can be sent from one application to another; the recipient application can execute the embedded procedures <ref> [Rei94] </ref>. The Decode-Encode language (DEL) allowed an emulator for one terminal type to be transparently downloaded into a different terminal type [Rul69]. The Wit and Wit 2 systems send interface code from a Unix server onto a palmtop device to minimize use of a poor-quality wireless link [Wat95]. <p> Agent Tcl can be used effectively in both, although active documents require additional infrastructure to inject an agent embedded inside a document into the local agent system. 2 Telescript. Telescript was used primarily in active mail, network and platform management, and electronic commerce <ref> [Rei94] </ref>. In active mail, a Telescript agent is embedded inside an e-mail message; the agent is executed when the message is received or viewed. Typically such an agent might allow the user to sign up for some service, asking the user for needed information and then contacting the service provider.
Reference: [RGK96] <author> Daniela Rus, Robert Gray, and David Kotz. </author> <title> Autonomous and adaptive agents that gather information. </title> <booktitle> In AAAI '96 International Workshop on Intelligent Adaptive Agents, </booktitle> <month> August </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: The most important thing to note about the agent is that it was extremely easy to write; it is just a traditional single-machine program with an agent jump command at two key points. Agent Tcl has been used primarily in distributed information-retrieval applications, including retrieval of technical reports <ref> [RGK96] </ref>, product descriptions and 7 is logged onto each one. Although the "who" agent is not the most useful agent, it illustrates the general form of any agent that migrates sequentially through a set of machines. The exec who can be replaced with any desired processing. 8 prices [RGK96], medical records <p> technical reports <ref> [RGK96] </ref>, product descriptions and 7 is logged onto each one. Although the "who" agent is not the most useful agent, it illustrates the general form of any agent that migrates sequentially through a set of machines. The exec who can be replaced with any desired processing. 8 prices [RGK96], medical records [Wu95], and three-dimensional drawings of mechan-ical parts [CBC96] (Chapter 8).
Reference: [Rie94] <author> Doug Riecken. M: </author> <title> An architecture of distributed agents. </title> <journal> Communications of the ACM, </journal> <volume> 37(7) </volume> <pages> 106-116, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: These agents are distinguished from traditional utilities by (1) their use of machine learning so that they can adapt to user habits and preferences [Mae94] or (2) their use of automated reasoning so that they can make complex inferences about the work environment <ref> [Rie94] </ref>. Maes presents a series of agents that start with a minimum amount of domain knowledge and learn how to perform the task by observing and interacting with the user and other agents [Mae94]. The mail agent, for example, uses memory-based reasoning to filter electronic mail. <p> Riecken has developed a more complex system called M that uses five inference engines 1 to automatically group the documents that are presented during the course of a virtual multimedia conference <ref> [Rie94] </ref>. The inference engines infer relationships among the documents based on the actions that the users apply to them. For example, if two documents are placed close together within the virtual conference room, the spatial engine might conclude that the documents deal with the same subject.
Reference: [RN95] <author> Stuart Russell and Peter Norvig. </author> <title> Artificial intelligence: A modern approach. </title> <booktitle> Prentice-Hall Series on Artificial Intelligence. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1995. </year>
Reference-contexts: kinds of agents to underscore the differences between non-mobile and mobile agents and to illustrate potential applications for mobile agents. 20 3.1 Other kinds of agents 3.1.1 Artificial intelligence and robotics Here an agent is an entity that perceives its environment with sensors and acts on its environment with effectors <ref> [RN95] </ref>. Such an agent can be either hardware with physical sensors and effectors or software with simulated sensors and effectors. This definition of an agent is used to provide a unified framework for artificial intelligence, to discuss software artifacts from a robotics viewpoint, and of course to discuss physical robots.
Reference: [Rog95] <author> Adams Rogers. </author> <title> Is there a case for viruses? Newsweek, </title> <type> 75(9), </type> <month> February 27 </month> <year> 1995. </year>
Reference-contexts: The popular definition of an agent is an intelligent software servant that either (1) relieves the user of a routine, burdensome task such as appointment scheduling or (2) filters the overwhelming amount of online information so that the user sees only the information that is relevant to her current needs <ref> [Haf95, Rog95] </ref>. This definition| due to its broadness and its ability to capture the imagination|has made "agent" a buzzword within both the academic and commercial worlds. Applications are often described as "agent-based" solely to draw attention or increase sales.
Reference: [Rul69] <author> Jeff Rulifson. </author> <title> Decode encode language (DEL). </title> <type> Technical Report RFC-0005, </type> <institution> DARPA Network Working Group, </institution> <year> 1969. </year>
Reference-contexts: The Decode-Encode language (DEL) allowed an emulator for one terminal type to be transparently downloaded into a different terminal type <ref> [Rul69] </ref>. The Wit and Wit 2 systems send interface code from a Unix server onto a palmtop device to minimize use of a poor-quality wireless link [Wat95].
Reference: [RWWB96] <author> Roger Riggs, Jim Waldo, Ann Wollrath, and Krishna Bharat. </author> <title> Pickling state in the Java system. </title> <journal> Computing Systems, </journal> <volume> 9(4) </volume> <pages> 291-312, </pages> <month> Fall </month> <year> 1996. </year> <month> 218 </month>
Reference-contexts: Like untrusted applets, untrusted servlets are executed in a secure Java interpreter so that they can 2 http://grail.cnri.reston.va.us/grail/ 3 http://www.sunscript.com/products 32 not access or destroy sensitive information. The Java Remote Method Invocation (RMI) subsystem allows Java objects on different machines to invoke each other's methods <ref> [WRW96, RWWB96] </ref>. It also provides state serialization and unserialization facilities for transferring a Java object from one machine to another. Most Java-based distributed systems, including mobile-agent systems in which the agents are written in Java, use RMI for communication. <p> Java would be used only in speed-critical applications for which Tcl is simply too slow. 5.4.2 State capture Release 1.1 of Sun's Java Development Kit (JDK) includes an object serialization or pickling facility <ref> [RWWB96, WRW96] </ref>. This facility allows a program to create a serialized representation of the state of a Java object. This bytestream can be stored on disk or transmitted to a remote machine. The bytestream can then be used to recreate an equivalent object.
Reference: [SA94] <author> Simon Steward and Steve Appleby. </author> <title> Mobile software agents for control of distributed systems based on principles of social insect behaviour. </title> <booktitle> In IEEE International Conference on Communication Systems (ICCS). </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> November </month> <year> 1994. </year>
Reference-contexts: Once these differences are taken into account, the Tacoma and Agent Tcl times are comparable. Network management. Steward and Appleby use lightweight mobile agents to control traffic congestion in a circuit-switched telecommunications network <ref> [SA94, AS94] </ref>. There are two kind of agents: load-management agents, which find routes that have the highest spare capacity and adjust routing tables accordingly, and em parent agents, which randomly walk around the network and launch load-management agents when an overload is detected. <p> In their experiments, the mobile agents reduced maximum node utilization by between 39 and 50 percent, in addition, there were no overloaded nodes and no unused nodes <ref> [SA94, AS94] </ref>. The authors acknowledge that the same effect could be achieved with a more traditional distributed algorithm, but argue that mobile agents provide an extremely fault-tolerant solution without undue programmer effort. <p> Network management. As discussed in the performance analysis section, Steward and Appleby use lightweight mobile agents to control traffic congestion in a circuit-switched telecommunications network <ref> [SA94, AS94] </ref>. Load-management agents find the routes that have the highest spare capacity and adjust routing tables accordingly; parent agents randomly walk around the network and launch load-management agents when an overload is detected.
Reference: [Sah94] <author> Adam Sah. </author> <title> TC: An efficient implementation of the Tcl language. </title> <type> Master's thesis, </type> <institution> University of California at Berkeley, </institution> <month> May </month> <year> 1994. </year> <note> Available as Technical Report UCB-CSD-94-812. </note>
Reference-contexts: A mobile Tcl agent is usually short even if it performs a complex task, and is often more than efficient enough when compared to resource and network latencies. In addition, several groups are working on structured-programming extensions to Tcl and on faster Tcl interpreters <ref> [Sah94] </ref>. Tcl is clearly not suitable for every mobile-agent application, however, such as performing search operations against large, distributed collections of numerical data. For this reason, Java was added to the system as discussed below.
Reference: [San97] <author> Thomas Sander. </author> <title> On cryptographic protection of mobile agents. </title> <booktitle> In Proceedings of the 1997 Workshop on Mobile Agents and Security, </booktitle> <institution> University of Maryland, </institution> <month> October </month> <year> 1997. </year>
Reference-contexts: Thus, in some situations, the auditor can impose serious sanctions only after it has observed an apparent attack happening to multiple agents (that are following different migration trajectories). 120 * Encrypted algorithms. Recent work <ref> [San97, Hoh97] </ref> involves encrypting a pro-gram and its inputs in such a way that (1) the encrypted program is directly executable, (2) the encrypted program performs the same task as the original program, and (3) the output from the encrypted program is also encrypted and can only be decrypted by the
Reference: [Sap96] <author> Peter Sapaty. </author> <booktitle> Mobile processing in open systems. In Proceedings of the Fith Annual High Performance Computing Conference (HPCD '96), </booktitle> <year> 1996. </year>
Reference-contexts: every application implemented as a "wave" of extremely compact, lightweight agents that recursively spread themselves through a virtual network 13 ; although WAVE is syntactically awkward and demands a highly recursive programming style, it has been used effectively in several applications, including distributed simulation, network management, and distributed database retrieval <ref> [Sap96] </ref>. [KK94] implements a simple mobile-agent system in which the agents are written in a scripting language similar to AWK and migrate from machine to machine with a moveto instruction; this system was the forerunner to Agent Tcl here at Dartmouth. 3.3 Safe languages Finally, there are several interpreted languages where
Reference: [SBH96] <author> F. Straber, J. Baumann, and F. Hohl. </author> <title> Mole a Java-based mobile-agent system. </title> <booktitle> In Proceedings of the ECOOP '96 Workshop on Mobile Object Systems, </booktitle> <year> 1996. </year>
Reference-contexts: FTP Software no longer sells CyberAgents, but a version of CyberAgents that uses the TRAC language (rather than Java) is used in some of FTP Software's network management tools [Gre97a]. Other Java-based systems include Mole <ref> [SBH96, BHR + 97] </ref>, Concordia [Mit97a, WPW + 97], Voyager [Voy97], and Wasp [Fun97]. The Mole project is focusing on security mechanisms for protecting an agent from a malicious machine, while the Wasp project is concerned with integrating mobile agents with Web servers. Voyager and Concordia are commercial systems. <p> Aside from the debugger and visual programming environment, however, there are no administration or development tools. 46 Languages. Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ [LSW95, JvRS95, PS97, BFD96], Java <ref> [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96] </ref>, and various scripting languages [JvRS95, PS97, JdT + 95, Coe94]. Functional languages such as Scheme are used only in a few research systems [CJK95, HBB96, TLKC95]. Java is the most popular imperative language and is used in every commercial system and several research systems.
Reference: [Sch97a] <author> Fred B. Schneider. </author> <title> Security in Tacoma Too. </title> <booktitle> In Proceedings of the 1997 DAGSTUHL Workshop on Mobile Agents, </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: Similar to Kali Scheme, its main weakness is that the implementation is Java-specific (and in fact is contained entirely within the Java virtual machine), once again preventing any straightforward extension to additional languages. Tacoma [JvRS95, JvRS96, MvRSS96, Knu95], Tacoma Too <ref> [Sch97a] </ref>, and security automata [Sch97b] . Tacoma (Tromst and COrnell Moving Agents) is a mobile-agent system that supports numerous agent languages, including Tcl, Scheme, Perl, Python, Java and C. <p> Broker agents provide directory services. Most of these features are not available in the public release. 9 Runaway agents are impossible since an agent cannot continue once its financial reserves are exhausted. 38 Tacoma Too is a version of Tacoma that is based around the ML language <ref> [Sch97a] </ref>. Tacoma Too has the same meet abstraction as Tacoma and is being used in a prototype active network. An offshoot of the Tacoma Too project is concerned with securely executing Java agents using software fault isolation and security automata [Sch97b]. <p> Many other security models exist, such as (1) mandatory access control, in which programs, people and data are assigned classification levels, and information can not flow from higher to lower levels, (2) security automata <ref> [Sch97a] </ref>, in which a program's current allowed actions depend on its past resource usage, 10 and (3) computer immunology [FHS97, Gre97b], in which a program is considered malicious if its current pattern of resource usage does not match its normal pattern.
Reference: [Sch97b] <author> Fred B. Schneider. </author> <title> Towards fault-tolerant and secure agentry. </title> <booktitle> In Proceedings of the 11th International Workshop on Distributed Algor-tithms, </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: Similar to Kali Scheme, its main weakness is that the implementation is Java-specific (and in fact is contained entirely within the Java virtual machine), once again preventing any straightforward extension to additional languages. Tacoma [JvRS95, JvRS96, MvRSS96, Knu95], Tacoma Too [Sch97a], and security automata <ref> [Sch97b] </ref> . Tacoma (Tromst and COrnell Moving Agents) is a mobile-agent system that supports numerous agent languages, including Tcl, Scheme, Perl, Python, Java and C. Each agent and machine has a briefcase or file 7 Sumatra was developed before Java's Remote Method Invocation (RMI) package became available. <p> Tacoma Too has the same meet abstraction as Tacoma and is being used in a prototype active network. An offshoot of the Tacoma Too project is concerned with securely executing Java agents using software fault isolation and security automata <ref> [Sch97b] </ref>. A security automata enforces a security policy and is similar to a finite-state automata. Transitions between states correspond to agent actions. A security exception is raised if an agent attempts an action for which the current state has no outgoing transition. <p> Thus, if an agent reads from the file and then attempts to communicate with the home machine, the security automata will raise a security exception, since the second state has no outgoing transition for communicating with the home machine. Tacoma Too is also exploring various forms of proof-carrying code <ref> [Sch97b] </ref>. Telescript [Whi94, Whi95b, Whi95a, Whi96] and Odyssey [Gen97]. Tele-script, later marketed as part of the Tabriz web-server package, was the first commercial mobile-agent system. It was developed at General Magic, Inc., and was primarily used in the AT&T PersonaLink network.
Reference: [SD95] <author> Marvin Sirbu and J. D.Tygar. NetBill: </author> <title> An Internet commerce system optimized for network delivered services. </title> <booktitle> In Proceedings of 40th IEEE 219 Computer Society International Conference (COMPCON 95). </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> March </month> <year> 1995. </year>
Reference-contexts: A more attractive solution is to use a market-based approach in which agents pay for their resource usage with cryptographically-protected electronic cash <ref> [CB97, SD95] </ref>. When an agent is created, it is given a finite currency supply from its owner's own finite currency supply.
Reference: [SG90] <author> J. Stamos and D. Gifford. </author> <title> Remote evaluation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 537-565, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The NCL expression can invoke multiple functions on either the client or server and thus avoid the overhead of multiple remote procedure calls. Remote evaluation (REV) is similar to NCL in that a procedure can be sent to a remote server for evaluation <ref> [SG90] </ref>. REV, however, uses client and server stubs in 29 much the same way as RPC and can be used with any language. All that is needed for a new language is stub generators and linking facilities so that the procedure can invoke the operations provided at the server. <p> Sta-mos and Gifford identify four security concerns|authentication, availability, secrecy and integrity. Authentication and availability consist of verifying the identity of the client and preventing denial of service attacks and can be addressed with standard techniques <ref> [SG90] </ref>. Secrecy and integrity consist of preventing unauthorized access to and destruction of server information and require more complex solutions. Sta-mos and Gifford present three solutions|separate address spaces for each procedure, careful interpretation in a single address space, and digital signatures with a single address space.
Reference: [Sha97] <author> Rohit Sharma. </author> <title> Mobile agent construction environment. </title> <type> Master's thesis, </type> <institution> Thayer School of Engineering, Dartmouth College, </institution> <year> 1997. </year>
Reference-contexts: + 97], (4) several network sensing and planning modules that allow an agent to examine the cur 6 rent state of the network and construct an optimal route [GKN + 97, Car97], and (5) a simple Mobile Agent Construct Environment (MACE) that allows a nonprogrammer to graphically construct an agent <ref> [Sha97] </ref>. These services represent the research of several other students. Although they are discussed further in Chapter 9, they are not an integral part of this thesis. A sample Agent Tcl agent is shown in Figure 1.2. <p> The Mobile Agent Construction Environment (MACE) is a first step towards removing this limitation and allowing end users to 183 construct their own useful agents <ref> [Sha97] </ref>. MACE, which Rohit Sharma 8 developed as part of his thesis work, is a simple visual programming environment in which a user assembles a mobile agent from a set of predefined components. The MACE environment is shown in Figure 9.3. <p> keyword-indexed directory of available services [GKN + 97], (4) several network sensing and planning modules that allow an agent to determine the best route through the network [GKN + 97, Car97], and (5) a Mobile Agent Construct Environment (MACE) that allows a nonprogram 203 mer to graphically construct an agent <ref> [Sha97] </ref>. The main weaknesses of Agent Tcl are its lack of fault-recovery mechanisms and its poor performance relative to traditional client-server techniques. The poor performance is due to to the large migration overhead and the slowness of Tcl (which was the only language considered in the performance analysis).
Reference: [SS94] <author> Mukesh Singhal and Niranjan G. Shivaratri. </author> <title> Advanced Concepts in Operating Systems: Distributed, Database and Multiprocessor Operating Systems. </title> <publisher> McGraw-Hill Series in Computer Science. McGraw-Hill, </publisher> <address> New York, </address> <year> 1994. </year>
Reference-contexts: Any mobile-agent system must allow an agent to examine current network and machine conditions and then decide whether to migrate to a remote resource or remain at the current site and access the resource using the equivalent of message passing <ref> [SS94] </ref> or remote procedure call (RPC) [BN84]. Latency. By migrating to the location of a resource, an agent can interact with the resource much faster than from across the network. Such faster interaction is one of the main motivations for Java-enabled web browsers. <p> Message passing is powerful and flexible, but requires the programmer to handle low-level details, such as keeping track of which response goes with which request, converting data between client and server formats, determining the address of the server, and handling communication and system errors <ref> [SS94] </ref>. 3.2.2 Remote procedure call (RPC) Remote procedure call (RPC) [BN84] relieves the programmer of these details. RPC allows a program on the client to invoke a procedure on the server using the standard procedure call mechanism. Most RPC implementations use stub procedures [BN84, SS94]. <p> RPC allows a program on the client to invoke a procedure on the server using the standard procedure call mechanism. Most RPC implementations use stub procedures <ref> [BN84, SS94] </ref>. A client that makes a remote procedure call is actually calling a local stub. This client stub puts the procedure name and parameters into a message and sends the message to the remote machine. <p> The client stub returns the result to the client. The original RPC implementations blocked the client until the server returned the result. Current RPC extensions either allow concurrent invocation of procedures on multiple servers or make RPC asynchronous <ref> [SS94] </ref>. These variations are more flexible but make programming more difficult. Other disadvantages of traditional RPC were described in [GG88].
Reference: [Ste94] <author> W. Richard Stevens. </author> <title> TCP/IP Illustrated, Volume 1: The Protocols. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Each message involves a new TCP/IP connection between the sending agent and remote server. Worse, most TCP/IP implementations do not acknowledge the first packet sent over a new connection immediately, and do not send the second packet until this acknowledgment is received <ref> [Ste94] </ref>. 6 Specifically, once the first packet arrives over a connection, the receiving ma-4 The time needed to establish the meeting will be considered later, when we look at the total time needed for an agent to migrate onto a remote machine, interact with a service agent, and return a result
Reference: [Sto94] <author> A. D. Stoyenko. SUPRA-RPC: </author> <title> SUbprogram PaRAmeters in Remote Procedure Calls. </title> <journal> Software-Practice and Experience, </journal> <volume> 24(1) </volume> <pages> 27-49, </pages> <month> Jan-uary </month> <year> 1994. </year>
Reference-contexts: The developers of REV and NCL were primarily concerned with moving computation to a remote machine and imposed this limitation to simplify the implementation. SUPRA-RPC (SUbprogram PaRAmeters in Remote Procedure Calls), on the other hand, seeks to allow normal procedure call semantics for both local and passed procedures <ref> [Sto94] </ref>. Essentially SUPRA-RPC extends REV with additional stubs that are invoked whenever the procedure references an out-of-scope variable or function. The server makes a callback to the client to handle the out-of-scope reference.
Reference: [Sun97a] <author> HotJava: </author> <title> The security story. Sun Microsystems White Paper, Sun Microsystems, </title> <year> 1997. </year>
Reference-contexts: Second, since the bytecodes are defined to have a statically predictable effect on the type state of the stack, it is possible to run a compiled Java program through a pre-execution verification process <ref> [Sun97a] </ref>.
Reference: [Sun97b] <institution> The Java language specification: Release 1.1. Sun Microsystems White Paper, Sun Microsystems, </institution> <year> 1997. </year>
Reference-contexts: science department and have spent two semesters each working on Agent Java. 70 5.4.1 Java Java is an object-oriented language that is syntactically similar to C++ except that there are no structures or unions, no functions, no multiple implementation inheritance, no operator overloading, no automatic type casts, and no pointers <ref> [GM95, Sun97b, CH97] </ref>. A sample Java program is shown in Figure 5.5. Memory in Java is garbage-collected so there is no delete operator. Java is multi-threaded and includes thread synchronization primitives at the language level.
Reference: [Sun97c] <institution> The Java Virtual Machine specification: Release 1.1. Sun Microsystems White Paper, Sun Microsystems, </institution> <year> 1997. </year> <month> 220 </month>
Reference-contexts: Memory in Java is garbage-collected so there is no delete operator. Java is multi-threaded and includes thread synchronization primitives at the language level. Most importantly, a Java program is typically compiled into bytecodes for a stack-based virtual machine, namely the Java Virtual Machine <ref> [Sun97c] </ref>. The program is then executed with an efficient, low-level interpreter. The use of bytecodes and an interpreter has two powerful advantages.
Reference: [TDiMMH94] <author> Christian Tschudin, Giovanna Di Marzo, Murhimanya Muhugusa, and Jurgen Harms. </author> <title> Messenger-based operating systems. </title> <institution> Cahier du Centre Universitaire d'Informatique no 90, University of Geneva, Switzerland, </institution> <year> 1994. </year>
Reference-contexts: Kali Scheme's main weakness is that the implementation is Scheme specific (and, in fact, is contained entirely within the Scheme 48 virtual machine itself), preventing any straightforward extension to additional languages. 34 Messengers <ref> [TDiMMH94, DiMMTH95, Tsc94] </ref>. A messenger is a message that contains both data and code. A server on each host accepts incoming messengers and executes each messenger's code within its own thread. <p> In the case of a distributed operating system, each machine would have a small microkernel; the rest of the operating system would be implemented as messengers that dynamically distribute themselves as needed <ref> [TDiMMH94] </ref>. Although this is an interesting use of mobile agents, no existing mobile agent system (including Messengers) seems efficient enough to be used 161 for arbitrary system-level components, which means that the native "microkernel" must be relatively large.
Reference: [TK93] <author> Anand R. Tripathi and Neeran M. Karnik. </author> <title> Systems-level issues for agent-based distributed computing. </title> <type> Technical Report TR96-049, </type> <institution> Department of Computer Science, University of Minnesota, </institution> <year> 1993. </year>
Reference-contexts: The Ara group is currently implementing additional security mechanisms (such as digital signatures and access restrictions for all system resources) and adding support for the Java language. Tripathi and Karnik propose a mobile-agent system that uses CORBA as its lowest layer <ref> [TK93] </ref>. The proposed Distributed Internet Execution Environment (Dixie) will combine the Prospero file system, the Tk toolkit, and interpreters for several languages into a virtual operating system that accepts and executes applications sent from other hosts [Gai94]; little implementation work had been done at the time of this writing, however.
Reference: [TLKC95] <author> Bent Thomsen, Lone Leth, Frederick Knabe, and Pierre-Yves Chevalier. </author> <title> Mobile agents. </title> <type> ECRC External Report, </type> <institution> European Computer-Industry Research Centre, </institution> <year> 1995. </year>
Reference-contexts: The agent will continue with its work even if the laptop disconnects and will be ready with a result when the laptop reconnects. Similarly, a service can send an agent onto a laptop to continue interacting with the user <ref> [TLKC95] </ref>. In addition to periods of disconnection, the networks involved in mobile computing (or more precisely the links at the edge of these networks) are often characterized by low bandwidth and high latency, making mobile agents even more attractive. <p> Mobile Service Agents (MSA) are written in an extended version of the functional programming language Facile; an MSA agent spawns a new agent by submitting a closure containing data and one or more functions <ref> [TLKC95, Kna96] </ref>. <p> Nearly all mobile-agent systems use imperative languages, most no-tably C/C++ [LSW95, JvRS95, PS97, BFD96], Java [Gen97, LO97, RASS97, HMPP96, CMB96, SBH96], and various scripting languages [JvRS95, PS97, JdT + 95, Coe94]. Functional languages such as Scheme are used only in a few research systems <ref> [CJK95, HBB96, TLKC95] </ref>. Java is the most popular imperative language and is used in every commercial system and several research systems. <p> The Mobile Service Agent (MSA) system is used primarily for "follow-me" computing in which an application moves to the location of the user for more efficient interaction. The main MSA demo involves a conference proceedings <ref> [TLKC95] </ref>. When a user connects his laptop to the conference's machines, an agent containing the conference proceedings, site map and local points of interest is sent to the laptop. <p> implement. 3 This infrastructure is also easy to implement. 163 Other suggested applications include active e-mail, distributed information retrieval, software updates in telecommunications switches, software updates for general user applications (that are organized as a collection of cooperating agents), and automatic introduction of new components into a computer-aided manufacturing system <ref> [TLKC95, Kna96] </ref>. Except for telecommunications software, which demands code speed that existing mobile-agent systems cannot deliver, all of these applications are reasonable uses for mobile agents in general and Agent Tcl in particular. Network management.
Reference: [Tsc94] <author> Christian Tschudin. </author> <title> An introduction to the M messenger language. </title> <institution> Cahier du Centre Universitaire d'Informatique no 86, University of Geneva, Switzerland, </institution> <year> 1994. </year>
Reference-contexts: Kali Scheme's main weakness is that the implementation is Scheme specific (and, in fact, is contained entirely within the Scheme 48 virtual machine itself), preventing any straightforward extension to additional languages. 34 Messengers <ref> [TDiMMH94, DiMMTH95, Tsc94] </ref>. A messenger is a message that contains both data and code. A server on each host accepts incoming messengers and executes each messenger's code within its own thread.
Reference: [Tsc97] <author> Christian F. Tschudin. </author> <title> Open resource allocation for mobile agents. </title> <booktitle> In Proceedings of the 1997 Workshop on Mobile Agents (MA '97), volume 1219 of Lecture Notes in Computer Science, </booktitle> <address> Berlin, April 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The Messengers system does not address most security issues, but the Messengers group is working on market-based approaches for fairly allocating resources among competing messengers <ref> [Tsc97] </ref>. Obliq [Car95, BC95, BN97]. Obliq is an interpreted, lexically scoped, object-oriented language. An Obliq object is a collection of named fields that contain methods, aliases and values.
Reference: [TSS + 97] <author> D. L. Tennenhouse, J. M. Smith, W. D. Sincoskie, D. J. Wtherall, and G. J. Minden. </author> <title> A survey of active network research. </title> <journal> IEEE Communications, </journal> <volume> 35(1) </volume> <pages> 80-86, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: systems with such active messages are (1) Safe-Tcl/MIME in which Tcl scripts are embedded inside MIME-enabled mail messages and executed (inside a safe execution environment) when the message is received or read [LO95] and (2) active networks in which packets contain small code fragments that are executed on each router <ref> [TSS + 97] </ref>. Convenient paradigm. Mobile agents are a convenient paradigm for distributed applications. First, application components can dynamically deploy themselves throughout the network as described above. Second, mobile agents hide the communication channels but not the location of the computation [Whi94].
Reference: [TTP + 95] <author> Douglas B. Terry, Marvin M. Theimer, Karin Petersen, Alan J. De-mers, Mike J. Spreitzer, and Carl H. Hauser. </author> <title> Managing update conflicts in a weakly connected replicated storage system. </title> <booktitle> In Proceedings 221 of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 172-183, </pages> <address> Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year> <note> ACM Press. </note>
Reference-contexts: The 31 Bayou filesystem allows a mobile computer to cache files and then continue access-ing these cached files while disconnected; when the laptop reconnects, it sends a code fragment to the filesystem server to reconcile its file changes with the permanent copy of the file <ref> [TTP + 95] </ref>. 3.2.4 Java applets, Java servlets, Java RMI and JavaOS Java applets are Java programs that are associated with a World Wide Web (WWW) page [CW97]. When a user views the page with a Java-enabled browser, the program is downloaded automatically and executed on the user's machine.
Reference: [TV96] <author> Joseph Tardo and Luis Valente. </author> <title> Mobile agent security and Telescript. </title> <booktitle> In Proceedings of the 41th International Conference of the IEEE Computer Society (CompCon '96), </booktitle> <month> February </month> <year> 1996. </year>
Reference-contexts: If the network machines are under single administrative control, solutions are relatively straightforward; if the machines are not, solutions are much more complex. All of these problems have been considered in the mobile-agent literature <ref> [LO95, CGH + 95, TV96, PS97] </ref>, but only the first two have seen significant implementation work. These same two problems are addressed in the current implementation of Agent Tcl using PGP [KPS95], Safe Tcl [LO95, OLW97] and Java security managers [CH97].
Reference: [Ven97] <author> Bill Venners. </author> <title> Under the hood: The architecture of aglets. </title> <address> Java-World, </address> <month> January </month> <year> 1997. </year> <note> JavaWorld is an online magazine. This article is available at http:// www.javaworld.com/ javaworld/ jw-04-1997/ jw-04-hood.html. </note>
Reference-contexts: All commercial Java-based mobile-agent systems, such as IBM Aglets <ref> [LO97, Ven97] </ref>, General Magic's Odyssey [Gen97] and Mitsubishi's Concordia [WPW + 97], rely on this object serialization facility. <p> The most immediate need is to create a version of Agent Tcl that does not provide the jump command and thus can run with the unmodified interpreters. Such a version would use migration techniques similar to those found in Aglets <ref> [Ven97] </ref>, Odyssey [Gen97], Concordia [WPW + 97] or Tacoma [JvRS95]. At the same time, we need to decide whether the convenience of the jump command outweighs the additional burden that it places on the system programmer. <p> There are two approaches. Most or all of the system can be rewritten in Java and downloaded on demand to Java-enabled web browsers, essentially turning these browsers into temporary agent servers <ref> [Ven97] </ref>. Alternatively, the system can provide a much simpler Java applet or CGI script that interfaces with 200 an agent server on the same machine as the web server.
Reference: [Voo91] <author> Ellen M. Voorhees. </author> <title> Using computerized routers to control product flow. </title> <booktitle> In Proceedings of the Twenty-Fourth Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 275-282, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Intelligent routers are written in an interpreted expression language called MPL.1 and can migrate from machine to machine with a moveto instruction; a version of the router system that runs on homogeneous machines uses ISIS to detect and recover from node failures and other faults <ref> [WVF89, Voo91] </ref>. IBM Itinerant Agents is a proposed system that focuses on knowledge-based routing of service requests and security issues [CGH + 95]; it is not under active development and has given way to the more recent IBM Aglets system [LO97].
Reference: [Voy97] <institution> Voyager technical overview. </institution> <type> ObjectSpace White Paper, ObjectSpace, </type> <year> 1997. </year>
Reference-contexts: FTP Software no longer sells CyberAgents, but a version of CyberAgents that uses the TRAC language (rather than Java) is used in some of FTP Software's network management tools [Gre97a]. Other Java-based systems include Mole [SBH96, BHR + 97], Concordia [Mit97a, WPW + 97], Voyager <ref> [Voy97] </ref>, and Wasp [Fun97]. The Mole project is focusing on security mechanisms for protecting an agent from a malicious machine, while the Wasp project is concerned with integrating mobile agents with Web servers. Voyager and Concordia are commercial systems. <p> Research versus commercial. Aside from Telescript [Whi94], most mobile-agent systems were strictly research projects until about two years ago. Since then, the number of commercial systems has increased dramatically and now includes Odyssey [Gen97], IBM Aglets [LO97], Concordia [WPW + 97], Voyager <ref> [Voy97] </ref> and Omniware [LSW95]. As the reader might expect, commercial systems provide much better administration and development tools than research systems. In addition, all commercial systems provide sufficient security mechanisms to protect a machine from malicious agents.
Reference: [Wat95] <author> Terri Watson. </author> <title> Effective wireless communication through application partitioning. </title> <booktitle> In Proceedings of the Fifth IEEE Workshop on Hot Topcs in Operating Systems (HTOS), </booktitle> <pages> pages 24-27, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: The Decode-Encode language (DEL) allowed an emulator for one terminal type to be transparently downloaded into a different terminal type [Rul69]. The Wit and Wit 2 systems send interface code from a Unix server onto a palmtop device to minimize use of a poor-quality wireless link <ref> [Wat95] </ref>. Some database systems allow a user to define complex SQL commands and store these commands on a server; the stored commands are executed at the server end during a user transaction [BP88].
Reference: [Way95] <author> Peter Wayner. </author> <title> Agents Unleashed: A public domain look at agent technology. </title> <type> AP Professional, </type> <institution> Chestnut Hill, Massachusetts, </institution> <year> 1995. </year>
Reference-contexts: This approach is much less efficient than tightly integrating PGP with the rest of the system, but is simpler and more flexible, especially since it becomes trivial to create an Agent Tcl distribution that does not include PGP or that uses different encryption software <ref> [Way95] </ref>. An agent chooses whether to use encryption and signatures when it migrates or sends a message to another agent. If the agent is not concerned with interception during migration, it turns off encryption.
Reference: [Wel95] <author> Brent B. Welch. </author> <title> Practical Programming in Tcl and Tk. </title> <publisher> Prentice-Hall, </publisher> <address> New Jersey, </address> <year> 1995. </year> <month> 222 </month>
Reference-contexts: The next chapter covers the resource managers and the other security mechanisms. Chapter 8 discusses the other service agents mentioned above. 5.3 Agent Tcl 5.3.1 Tcl Tcl is a high-level scripting language that was developed in 1987 and has enjoyed enormous popularity <ref> [Wel95] </ref>. A sample Tcl program is shown in Figure 5.2. Tcl has several advantages as a mobile-agent language. Tcl is easy to learn and use due to its elegant simplicity and an imperative style that is immediately familiar to any programmer.
Reference: [Whi94] <author> James E. White. </author> <title> Telescript technology: The foundation for the elec-tronic marketplace. General Magic White Paper, General Magic, </title> <publisher> Inc., </publisher> <year> 1994. </year>
Reference-contexts: In addition, each execution environment includes a package of stub routines that the agent uses to interact with the servers and obtain the available agent services, such as migration, communication, and status queries. 4 Agent Tcl is similar to other mobile-agent systems, such as Tacoma [JvRS95], Ara [PS97], and Telescript <ref> [Whi94] </ref>, but distinguishes itself with (1) its combination of multiple languages, a simple migration mechanism, and both low- and high-level communication protocols, (2) its simple but effective security model, and (3) its extensive support services and tools. * Multiple languages (Chapter 5). <p> Mobile agents, on the other hand, do not waste bandwidth even if the server provides only low-level operations, simply because an agent can migrate to the server where it performs any desired processing before returning just the final result to the client <ref> [Whi94] </ref>. Agents that do more work avoid more intermediate messages and conserve more bandwidth. 11 Despite this advantage, there are several tradeoffs that must be considered. First, although a mobile agent eliminates the transmission of intermediate data, the agent itself must first be sent to the server. <p> A migrating agent does not require a permanent connection with its home site and can proceed with its task even if the home site is unreachable. Thus mobile agents are ideally suited for mobile computing in which computers can be disconnected from the network for long periods of time <ref> [Whi94] </ref>. For example, a laptop or other mobile device can send an agent out into the network. The agent will continue with its work even if the laptop disconnects and will be ready with a result when the laptop reconnects. <p> Convenient paradigm. Mobile agents are a convenient paradigm for distributed applications. First, application components can dynamically deploy themselves throughout the network as described above. Second, mobile agents hide the communication channels but not the location of the computation <ref> [Whi94] </ref>. This makes mobile agents easier to use than low-level facilities in which the programmer must explicitly handle communication details, but more flexible and powerful than schemes such as process migration in which the system decides when to move a program based on a small set of fixed criteria. <p> Tacoma Too is also exploring various forms of proof-carrying code [Sch97b]. Telescript <ref> [Whi94, Whi95b, Whi95a, Whi96] </ref> and Odyssey [Gen97]. Tele-script, later marketed as part of the Tabriz web-server package, was the first commercial mobile-agent system. It was developed at General Magic, Inc., and was primarily used in the AT&T PersonaLink network. <p> One permit, for example, might specify a maximum agent lifetime or a maximum amount of disk space. Each engine and place impose their own permits on incoming agents to prevent these agents from taking malicious action. Agents that attempt to violate the conditions of their permits are terminated immediately <ref> [Whi94] </ref>. Despite the fact that until recently Telescript was one of the most secure, fault-tolerant, and efficient mobile-agent systems, is has been withdrawn from the market, mainly because it was overwhelmed by the rapid spread of Java. The AT&T PersonaLink network is also defunct. <p> Such languages include Java [CH97], Scheme 48 [KR95], Tcl [Ous94, OLW97], Lua [dIC96], and Python [Lut96], as well as Obliq [Car95] and Telescript <ref> [Whi94] </ref>, which were specifically designed for mobile objects or agents. Except for Lua, all of these languages are used in at least one mobile-agent system. 13 As in the MESSENGERS system, the virtual network is mapped onto a physical network with one or more virtual nodes per physical node. <p> This mapping makes it easy to run the same application on differing numbers of physical machines. 45 Chapter 4 Trends and distinctions Existing mobile-agent systems can be compared along several axes. Research versus commercial. Aside from Telescript <ref> [Whi94] </ref>, most mobile-agent systems were strictly research projects until about two years ago. Since then, the number of commercial systems has increased dramatically and now includes Odyssey [Gen97], IBM Aglets [LO97], Concordia [WPW + 97], Voyager [Voy97] and Omniware [LSW95]. <p> The system provides a primitive operation called jump that automatically captures the executing agent's complete state and sends this state to a new machine; the new machine restores the state and the agent continues execution from the exact point of the jump. <ref> [Whi94] </ref>. Systems that use the jump migration model include Agent Tcl, Kali Scheme [CJK95], and Telescript [Whi94]. * known entry point. The system moves the variables and methods of the agent to the new machine, and then restarts agent execution at some specified method [LO97]. <p> that automatically captures the executing agent's complete state and sends this state to a new machine; the new machine restores the state and the agent continues execution from the exact point of the jump. <ref> [Whi94] </ref>. Systems that use the jump migration model include Agent Tcl, Kali Scheme [CJK95], and Telescript [Whi94]. * known entry point. The system moves the variables and methods of the agent to the new machine, and then restarts agent execution at some specified method [LO97]. <p> Security. Existing mobile-agent systems focus on protecting an individual machine from malicious agents (or a group of machines that are under single administrative control) <ref> [Whi94, Gen97, PS97] </ref>. <p> Fault tolerance. Most systems provide only a nonvolatile store so that agents can live past machine failure <ref> [Whi94] </ref>. Tacoma, however, provides rear guard agents that restart vanished agents [JvRS95]. In addition, the same voting and replication schemes that allow Tacoma to partially handle malicious machines also allow agents to continue with their task even if one or more copies of a desired service are unavailable. <p> The architecture of Agent Tcl is shown in Figure 5.1. The architecture builds on the server model of Telescript <ref> [Whi94] </ref>, the multiple languages of Ara [Pei96], and the transport mechanisms of two predecessor systems at Dartmouth [Har95, KK94]. The architecture has five levels. The lowest level is an API for the available transport mechanisms. The second level is a server that runs at each network site.
Reference: [Whi95a] <author> James E. White. </author> <title> Telescript technology: An introduction to the language. General Magic White Paper, General Magic, </title> <year> 1995. </year>
Reference-contexts: Tacoma Too is also exploring various forms of proof-carrying code [Sch97b]. Telescript <ref> [Whi94, Whi95b, Whi95a, Whi96] </ref> and Odyssey [Gen97]. Tele-script, later marketed as part of the Tabriz web-server package, was the first commercial mobile-agent system. It was developed at General Magic, Inc., and was primarily used in the AT&T PersonaLink network.
Reference: [Whi95b] <author> James E. White. </author> <title> Telescript technology: Scenes from the electronic marketplace. General Magic White Paper, General Magic, </title> <year> 1995. </year>
Reference-contexts: Tacoma Too is also exploring various forms of proof-carrying code [Sch97b]. Telescript <ref> [Whi94, Whi95b, Whi95a, Whi96] </ref> and Odyssey [Gen97]. Tele-script, later marketed as part of the Tabriz web-server package, was the first commercial mobile-agent system. It was developed at General Magic, Inc., and was primarily used in the AT&T PersonaLink network.
Reference: [Whi96] <author> James E. White. </author> <title> Telescript technology: </title> <booktitle> Mobile agents. </booktitle> <year> 1996. </year>
Reference-contexts: Tacoma Too is also exploring various forms of proof-carrying code [Sch97b]. Telescript <ref> [Whi94, Whi95b, Whi95a, Whi96] </ref> and Odyssey [Gen97]. Tele-script, later marketed as part of the Tabriz web-server package, was the first commercial mobile-agent system. It was developed at General Magic, Inc., and was primarily used in the AT&T PersonaLink network.
Reference: [WLAG93] <author> Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <address> Ashville, NC, 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Software fault isolation, which essentially adds a range check to every memory access, prevents the native code from corrupting the execution environment <ref> [WLAG93] </ref>. With this arrangement, Omniware provides portable, secure code that is only 25 percent slower than natively compiled C/C++ on average [LSW95]. <p> Depending on the performance of Java agents relative to native code, we will consider either "just-in-time" compilation or software-fault-isolation of native code (or more likely of code for a low-level virtual machine that is immediately compiled into native code) <ref> [ATLLW96, WLAG93, LSW95] </ref>. Alternatively, the system could accept native code only from certain trusted users, eliminating the need for software fault isolation, but limiting untrusted agents to the slower, interpreted languages.
Reference: [WPW + 97] <author> D. Wong, N. Paciorek, T. Walsh, J. DiCelie, M. Young, and B. Peet. </author> <title> Concordia: An infrastructure for collaborating mobile agents. </title> <booktitle> In Proceedings of the First International Workshop on Mobile Agents (MA '97), volume 1219 of Lecture Notes in Computer Science, </booktitle> <address> Berlin, April 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: FTP Software no longer sells CyberAgents, but a version of CyberAgents that uses the TRAC language (rather than Java) is used in some of FTP Software's network management tools [Gre97a]. Other Java-based systems include Mole [SBH96, BHR + 97], Concordia <ref> [Mit97a, WPW + 97] </ref>, Voyager [Voy97], and Wasp [Fun97]. The Mole project is focusing on security mechanisms for protecting an agent from a malicious machine, while the Wasp project is concerned with integrating mobile agents with Web servers. Voyager and Concordia are commercial systems. <p> Research versus commercial. Aside from Telescript [Whi94], most mobile-agent systems were strictly research projects until about two years ago. Since then, the number of commercial systems has increased dramatically and now includes Odyssey [Gen97], IBM Aglets [LO97], Concordia <ref> [WPW + 97] </ref>, Voyager [Voy97] and Omniware [LSW95]. As the reader might expect, commercial systems provide much better administration and development tools than research systems. In addition, all commercial systems provide sufficient security mechanisms to protect a machine from malicious agents. <p> All commercial Java-based mobile-agent systems, such as IBM Aglets [LO97, Ven97], General Magic's Odyssey [Gen97] and Mitsubishi's Concordia <ref> [WPW + 97] </ref>, rely on this object serialization facility. Since the current serialization facility cannot capture the state of an executing thread, and since modifications to the Java virtual machine would severely limit acceptance of a commercial product, none of the three systems provide a jump operation. <p> The most immediate need is to create a version of Agent Tcl that does not provide the jump command and thus can run with the unmodified interpreters. Such a version would use migration techniques similar to those found in Aglets [Ven97], Odyssey [Gen97], Concordia <ref> [WPW + 97] </ref> or Tacoma [JvRS95]. At the same time, we need to decide whether the convenience of the jump command outweighs the additional burden that it places on the system programmer.
Reference: [WRW96] <author> Ann Wollrath, Roger Riggs, and Jim Waldo. </author> <title> A distributed object model for the Java system. </title> <journal> Computing Systems, </journal> <volume> 9(4) </volume> <pages> 265-290, </pages> <month> Fall </month> <year> 1996. </year>
Reference-contexts: Like untrusted applets, untrusted servlets are executed in a secure Java interpreter so that they can 2 http://grail.cnri.reston.va.us/grail/ 3 http://www.sunscript.com/products 32 not access or destroy sensitive information. The Java Remote Method Invocation (RMI) subsystem allows Java objects on different machines to invoke each other's methods <ref> [WRW96, RWWB96] </ref>. It also provides state serialization and unserialization facilities for transferring a Java object from one machine to another. Most Java-based distributed systems, including mobile-agent systems in which the agents are written in Java, use RMI for communication. <p> Java would be used only in speed-critical applications for which Tcl is simply too slow. 5.4.2 State capture Release 1.1 of Sun's Java Development Kit (JDK) includes an object serialization or pickling facility <ref> [RWWB96, WRW96] </ref>. This facility allows a program to create a serialized representation of the state of a Java object. This bytestream can be stored on disk or transmitted to a remote machine. The bytestream can then be used to recreate an equivalent object.
Reference: [Wu95] <author> Yunxin Wu. </author> <title> Advanced algorithms of information organization and retrieval. </title> <type> Master's thesis, </type> <institution> Thayer School of Engineering, Dartmouth College, </institution> <year> 1995. </year> <month> 223 </month>
Reference-contexts: Although the "who" agent is not the most useful agent, it illustrates the general form of any agent that migrates sequentially through a set of machines. The exec who can be replaced with any desired processing. 8 prices [RGK96], medical records <ref> [Wu95] </ref>, and three-dimensional drawings of mechan-ical parts [CBC96] (Chapter 8). <p> Existing Agent Tcl agents that fall into this category are a workflow agent that carries an electronic form from user to user [CGN96] and a medical agent that retrieves distributed medical records based on certain criteria <ref> [Wu95] </ref>. The workflow agent must migrate sequentially since the users need to fill out the sections of the form in order.
Reference: [WVF89] <author> C. Daniel Wolfson, Ellen M. Voorhees, and Maura M. Flatley. </author> <title> Intelli--gent routers. </title> <booktitle> In Proceedings of the Ninth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 371-376. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Intelligent routers are written in an interpreted expression language called MPL.1 and can migrate from machine to machine with a moveto instruction; a version of the router system that runs on homogeneous machines uses ISIS to detect and recover from node failures and other faults <ref> [WVF89, Voo91] </ref>. IBM Itinerant Agents is a proposed system that focuses on knowledge-based routing of service requests and security issues [CGH + 95]; it is not under active development and has given way to the more recent IBM Aglets system [LO97].
Reference: [YD96] <author> Zhonghua Yang and Keith Duddy. </author> <title> CORBA: A platform for distributed object computing. </title> <journal> ACM Operating Systems Review, </journal> <volume> 30(2) </volume> <pages> 4-31, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: The evolving Mobile Objects and Agents (MOA) system is a CORBA-based sys 41 tem in which both static and active Java objects 10 can move from one machine to another [CMB96, MBZM96]. CORBA is a distributed-object manager that already provides object naming, object location and remote invocation <ref> [YD96] </ref>. MOA builds on CORBA to provide object persistence, a hierarchical object cache, and a location-independent name service that uses URL's. In addition, MOA conforms to the new Mobile Agent Facility (MAF) standard [MAF97]. <p> Possible protocols include whiteboards, KQML [GSS94], remote procedure call (RPC) [BN84] and remote method invocation <ref> [YD96] </ref>. Agent RPC, which Saurab Nog and Sumit Chawla 9 developed as a course project, is an RPC mechanism for Agent Tcl [NCK96]. The architecture of Agent RPC is shown in Figure 9.4.
Reference: [ZPMD97] <author> Deborra J. Zukowski, Apratim Purakayastha, Ajay Mohindra, and Murthy Devarakonda. Metis: </author> <title> A thin-client application framework. </title> <booktitle> In Proceedings of the Conference on Object-oriented Technologies and Systems. USENIX Association, </booktitle> <year> 1997. </year> <month> 224 </month>
Reference-contexts: The Metis thin-client framework can be viewed as a generalization of Java applets; here an arbitrary client downloads an application front-end written in Java, which then finds and interacts with one or more network services to realize the complete application <ref> [ZPMD97] </ref>. Other systems support applets that are written in other languages. The Grail web browser 2 from CNRI, for example, executes applets written in Python, while the Tcl plugin 3 from Sun Microsystems executes applets written in Tcl/Tk.
References-found: 141

