URL: http://geyer.lcs.mit.edu/~jchapin/6853/Papers/eraser.ps
Refering-URL: http://geyer.lcs.mit.edu/~jchapin/6853/readinglist.html
Root-URL: 
Title: Eraser: A Dynamic Data Race Detector for Multi-Threaded Programs  
Author: Stefan Savage Michael Burrows Greg Nelson Patrick Sobalvarro Thomas Anderson 
Address: Seattle  Berkeley  
Affiliation: Department of Computer Science and Engineering University of Washington,  Digital Equipment Corporation Systems Research Center  Computer Science Division University of California,  
Abstract: Multi-threaded programming is difficult and error prone. It is easy to make a mistake in synchronization that produces a data race, yet it can be extremely hard to locate this mistake during debugging. This paper describes a new tool, called Eraser, for dynamically detecting data races in lock-based multi-threaded programs. Eraser uses binary rewriting techniques to monitor every shared memory reference and verify that consistent locking behavior is observed. We present several case studies, including undergraduate coursework and a multi-threaded Web search engine, that demonstrate the effectiveness of this approach. 
Abstract-found: 1
Intro-found: 1
Reference: [Bershad et al. 95] <author> Bershad, B. N., Savage, S., Pardyak, P., Sirer, E. G., Fiuczynski, M., Becker, D., Eggers, S., and Chambers, C. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 267284, </pages> <address> Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: be communicated by annotating them with EraserReadLock (lock) EraserReadUnlock (lock) EraserWriteLock (lock) EraserWriteUnlock (lock) We found that a handful of these annotations usually suffices to eliminate all false alarms. 3.4 Race detection in an OS kernel We have begun to modify Eraser to detect races in the SPIN operating system <ref> [Bershad et al. 95] </ref>. While we do not yet have results in terms of data races found, we have acquired some useful experience about implementing such a tool at the kernel level, which is different from the user level in several ways.
Reference: [Choi & Lewis 97] <author> Choi, S.-E. and Lewis, E. C. </author> <title> University of Washington CSE 552 Project. </title> <type> Personal Communication, </type> <month> March </month> <year> 1997. </year> <note> http://www.cs.washington.edu/homes/ sungeun/notes/cse552/index.html. </note>
Reference-contexts: different instances of the stack frame resulted in a false alarm. 4.4 Undergraduate coursework As a counterpoint to our experience with mature multi-threaded server programs, two of our colleagues used Eraser to examine the kinds of synchronization errors found in the homework assignments produced by their undergraduate operating systems class <ref> [Choi & Lewis 97] </ref>. We report their results here to demonstrate how Eraser functions with a less sophisticated code base. The class was required to complete four standard multi-threading assignments.
Reference: [Detlefs et al. 97] <author> Detlefs, D. L., Leino, R. M., Nelson, G., and Saxe, J. B. </author> <title> Extended Static Checking. </title> <type> Technical Report 149, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <note> to appear 1997. </note>
Reference-contexts: Some attempts have been made to create purely static (that is, compile-time) race detection systems that work in the presence of dynamically allocated shared data: for example, Sun's lock lint [SunSoft 94] and the Extended Static Checker for Modula-3 <ref> [Detlefs et al. 97, Nelson et al. 96] </ref>. But these approaches seem problematical since they require statically reasoning about the program's semantics.
Reference: [Digital Equipment 96a] <institution> Digital Equipment. </institution> <note> AltaVista Search. http://altavista.digital.com/, 1996. </note>
Reference-contexts: In the remainder of this section we report on the details of our experiences with each program. 4.1 AltaVista We examined two components of the popular AltaVista <ref> [Digital Equipment 96a] </ref> Web indexing service, mhttpd and Ni2. The mhttpd program is a lightweight HTTP server designed to support the extremely high server loads experienced by AltaVista.
Reference: [Digital Equipment 96b] <institution> Digital Equipment. Vesta Home Page. </institution> <address> http://www.research.digital.com/ SRC/vesta/, </address> <year> 1996. </year>
Reference-contexts: Inserting nine annotations in the Ni2 library, five in the ft test harness, and ten in the mhttpd server reduced the number of reported races from more than a hundred to zero. 4.2 Vesta cache server Vesta <ref> [Digital Equipment 96b] </ref> is an advanced software configuration management system. Configurations are written in a specialized functional language that describes the de-pendencies and rules used to derive the current state of the software.
Reference: [Dinning & Schonberg 90] <author> Dinning, A. and Schonberg, E. </author> <title> An Empirical Comparison of Monitoring Algorithms for Access Anomaly Detection. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 110, </pages> <address> Seattle, WA, </address> <month> March </month> <year> 1990. </year>
Reference: [Dinning & Schonberg 91] <author> Dinning, A. and Schonberg, E. </author> <title> Detected Access Anomalies in Programs with Critical Sectons. </title> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, published in ACM SIGPLAN Notices, </booktitle> <address> 26(12):8596, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: The lock covers technique of Dinning and Shonberg is an improvement to the happens-before approach for programs that make heavy use of locks <ref> [Dinning & Schonberg 91] </ref>. Indeed, one way to describe our approach would be that we extend Dinning and Shonberg's improvement and discard the underlying happens-before apparatus that they were improving. 2 The Lockset algorithm In this section we describe how the Lockset algorithm detects races.
Reference: [Hoare 74] <author> Hoare, C. </author> <title> Monitors: An Operating System Structuring Concept. </title> <journal> Communications of the ACM, </journal> <volume> 17(10), </volume> <month> October </month> <year> 1974. </year>
Reference-contexts: Although programmers occasionally deliberately allow a data race when the non-determinism seems harmless, usually a potential data race is a serious error caused by failure to synchronize properly. 1.2 Related work An early attempt to avoid data races was the pioneering concept of a monitor introduced by C.A.R. Hoare <ref> [Hoare 74] </ref>. A monitor is a group of shared variables together with the procedures that are allowed to access them, all bundled together with a single anonymous lock that is automatically acquired and released at the entry and exit of the procedures.
Reference: [Kleiman & Eykholt 95] <author> Kleiman, S. and Eykholt, J. </author> <title> Interrupts as Threads. </title> <journal> ACM Operating Systems Review, </journal> <volume> 29(2):2126, </volume> <month> April </month> <year> 1995. </year>
Reference-contexts: Because semaphores are not owned it is difficult for Eraser to infer which data they are being used to protect, leading it to issue false alarms. Systems that integrate thread and interrupt processing <ref> [Kleiman & Eykholt 95] </ref> may have less trouble with this problem. 4 Experience We calibrated Eraser on a number of simple programs that contained common synchronization errors (e.g. forgot to lock, used the wrong lock, etc.) and versions of those programs with the errors corrected.
Reference: [Lamport 78] <author> Lamport, L. </author> <title> Time, clock, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7), </volume> <month> July </month> <year> 1978. </year>
Reference-contexts: We have implemented Eraser for DIGITAL Unix and used it to detect data races in a number of programs, ranging from the AltaVista Web search engine to introductory programming exercises written by undergraduates. Previous work in dynamic race detection is based on Lam-port's happens-before relation <ref> [Lamport 78] </ref> and checks that conflicting memory accesses from different threads are separated by synchronization events. Happens-before algorithms handle many styles of synchronization, but this generality comes at a cost. We have aimed Eraser specifically at the lock-based synchronization used in modern multi-threaded programs.
Reference: [Lampson & Redell 80] <author> Lampson, B. and Redell, D. </author> <title> Experiences with Processes and Monitors in Mesa. </title> <journal> Communications of the ACM, </journal> <volume> 23(2):104117, </volume> <month> February </month> <year> 1980. </year>
Reference-contexts: Monitors are an effective way to avoid data races if all shared variables are static globals, but they don't protect against data races in programs with dynamically allocated shared variables, a limitation that early users found was significant <ref> [Lampson & Redell 80] </ref>. By substituting dynamic checking for static checking, our work aims to allow dynamically allocated shared data while retaining as much of the safety of monitors as possible.
Reference: [Lee & Thekkath 96] <author> Lee, E. K. and Thekkath, C. A. </author> <title> Petal: Distributed virtual disks. </title> <booktitle> In Proceedings of the Seventh International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-VII), </booktitle> <year> 1996. </year>
Reference-contexts: In total, ten annotations and one bug fix were enough to reduce the race reports from several hundred to zero. 4.3 Petal Petal is a distributed storage system that presents its clients with a huge virtual disk implemented by a cluster of servers and physical disks <ref> [Lee & Thekkath 96] </ref>. Petal implements a distributed consensus algorithm as well as failure detection and recovery mechanisms. The Petal server is roughly 25,000 lines of C code and we used 64 concurrent worker threads in our tests.
Reference: [Manasse & Nelson 91] <author> Manasse, M. S. and Nelson, G. </author> <title> Trestle Reference Manual. </title> <type> Technical Report Research Report 68, </type> <institution> Digital Equipment Corporation's Systems Research Center, Palo Alto, Cali-fornia, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Using an earlier version of Eraser that detected race conditions in multi-threaded Modula-3 programs, we found that the Lockset algorithm reported false alarms for Trestle programs <ref> [Manasse & Nelson 91] </ref> that protected shared locations with multiple locks, because each of two readers could access the location while holding two different locks.
Reference: [Mellor-Crummey 91] <author> Mellor-Crummey, J. </author> <title> On-the-fly Detection of Data Races for Programs with Nested Fork-Join Parallelism. </title> <booktitle> In Proceedings of the 1991 Supercomputer Debugging Workshop, </booktitle> <pages> pages 116, </pages> <month> November </month> <year> 1991. </year>
Reference: [Mellor-Crummey 93] <author> Mellor-Crummey, J. </author> <title> Compile-time Support for Efficient Data Race Detection in Shared-Memory Parallel Programs. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 129139, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Finally, we describe the experience we have had using Eraser with a number of multi-threaded programs. Eraser bears no relationship to the tool by the same name constructed by John Mellor-Crummey for detecting data races in shared-memory parallel Fortran programs as part of the ParaScope Programming Environment <ref> [Mellor-Crummey 93] </ref>. 1.1 Definitions A lock is a simple synchronization object used for mutual exclusion; it is either available, or owned by a thread. The operations on a lock mu are lock (mu) and unlock (mu).
Reference: [Nelson et al. 96] <author> Nelson, G., Leino, K. R. M., Saxe, J., and Stata, R. </author> <title> Extended Static Checking Home Page. </title> <address> http://www.research.digital.com/ SRC/esc/Esc.html, </address> <year> 1996. </year>
Reference-contexts: Some attempts have been made to create purely static (that is, compile-time) race detection systems that work in the presence of dynamically allocated shared data: for example, Sun's lock lint [SunSoft 94] and the Extended Static Checker for Modula-3 <ref> [Detlefs et al. 97, Nelson et al. 96] </ref>. But these approaches seem problematical since they require statically reasoning about the program's semantics.
Reference: [Netzer 91] <author> Netzer, R. H. B. </author> <title> Race Condition Detection for Debugging Shared-Memory Parallel Programs. </title> <type> PhD dissertation, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1991. </year>
Reference: [Ousterhout 96] <author> Ousterhout, J. K. </author> <title> Why Threads Are </title>
References-found: 18

