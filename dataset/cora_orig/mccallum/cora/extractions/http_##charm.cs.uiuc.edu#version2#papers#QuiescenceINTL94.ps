URL: http://charm.cs.uiuc.edu/version2/papers/QuiescenceINTL94.ps
Refering-URL: http://charm.cs.uiuc.edu/version2/papers/QuiescenceINTL94.html
Root-URL: http://www.cs.uiuc.edu
Email: email: fsinha,kaleg@cs.uiuc.edu  email: ramkumar@hitchcock.eng.uiowa.edu  
Title: A dynamic and adaptive quiescence detection algorithm  
Author: Amitabh B. Sinha Laxmikant V. Kale Balkrishna Ramkumar 
Address: Urbana, Illinois 61801  Iowa City, Iowa 52242  
Affiliation: Department of Computer Science University of Illinois  Department of Electrical and Computer Engineering University of Iowa  
Abstract: A large number of quiescence detection algorithms with good theoretical upper-bounds have been proposed before. However the metric used to measure the performance of these algorithms is not suitable. We propose a new metric for measuring the performance of a quiescence detection algorithm. We also present an algorithm to detect quiescence in an asynchronous and dynamic model of parallel computation. The algorithm has been implemented for a machine independent parallel programming system, Charm. Quiescence detection is provided as a feature in Charm to conduct a variety of operations like collecting statistics about user computation, initiating new phases of computation, or just terminating the user computation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. W. Dijkstra and C. S. Scholten. </author> <title> Termination detection for diffusing computations. </title> <journal> Information Processing Letters, </journal> <volume> 11, 1, </volume> <month> August </month> <year> 1980. </year>
Reference-contexts: Quiescence detection, then, is the process by which the system detects quiescence in the user computation. The problem of quiescence detection in distributed systems becomes interesting because the two conditions for quiescence must be met simultaneously. Much work has been done before on quiescence detection <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, both for synchronous and asynchronous systems. We shall briefly discuss some previous work on quiescence detection in asynchronous computational models. Lai [8] and Huang [7] present schemes which use distributed snapshots to detect quiescence in asynchronous distributed systems.
Reference: [2] <author> N. Francez. </author> <title> Distributed termination. </title> <journal> ACM TOPLAS, pages 42-55, </journal> <volume> Vol. 2, No. 1, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Quiescence detection, then, is the process by which the system detects quiescence in the user computation. The problem of quiescence detection in distributed systems becomes interesting because the two conditions for quiescence must be met simultaneously. Much work has been done before on quiescence detection <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, both for synchronous and asynchronous systems. We shall briefly discuss some previous work on quiescence detection in asynchronous computational models. Lai [8] and Huang [7] present schemes which use distributed snapshots to detect quiescence in asynchronous distributed systems.
Reference: [3] <author> J. Misra and K. M. Chandy. </author> <title> Termination detection of diffusing computations in communicating sequential processes. </title> <journal> ACM TOPLAS, pages 37-34, </journal> <volume> Vol. 4, No. 1, </volume> <month> January </month> <year> 1982. </year>
Reference-contexts: Quiescence detection, then, is the process by which the system detects quiescence in the user computation. The problem of quiescence detection in distributed systems becomes interesting because the two conditions for quiescence must be met simultaneously. Much work has been done before on quiescence detection <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, both for synchronous and asynchronous systems. We shall briefly discuss some previous work on quiescence detection in asynchronous computational models. Lai [8] and Huang [7] present schemes which use distributed snapshots to detect quiescence in asynchronous distributed systems.
Reference: [4] <author> C. Hazari and H. Zedan. </author> <title> A distributed algorithm for distributed termination. </title> <journal> Information Processing Letters, </journal> <pages> pages 293-297, 24, </pages> <year> 1987. </year>
Reference-contexts: Quiescence detection, then, is the process by which the system detects quiescence in the user computation. The problem of quiescence detection in distributed systems becomes interesting because the two conditions for quiescence must be met simultaneously. Much work has been done before on quiescence detection <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, both for synchronous and asynchronous systems. We shall briefly discuss some previous work on quiescence detection in asynchronous computational models. Lai [8] and Huang [7] present schemes which use distributed snapshots to detect quiescence in asynchronous distributed systems.
Reference: [5] <author> S. P. Rana. </author> <title> A distributed solution of the distributed termination problem. </title> <journal> Information Processing Letters, </journal> <pages> pages 43-46, 17, </pages> <month> 1 (July </month> <year> 1983). </year>
Reference-contexts: Quiescence detection, then, is the process by which the system detects quiescence in the user computation. The problem of quiescence detection in distributed systems becomes interesting because the two conditions for quiescence must be met simultaneously. Much work has been done before on quiescence detection <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, both for synchronous and asynchronous systems. We shall briefly discuss some previous work on quiescence detection in asynchronous computational models. Lai [8] and Huang [7] present schemes which use distributed snapshots to detect quiescence in asynchronous distributed systems.
Reference: [6] <author> F. Mattern. </author> <title> Global quiescence detection based on credit distribution and recovery. </title> <journal> Information Processing Letters, </journal> <pages> pages 195-200, 30, </pages> <year> 1989. </year>
Reference-contexts: Quiescence detection, then, is the process by which the system detects quiescence in the user computation. The problem of quiescence detection in distributed systems becomes interesting because the two conditions for quiescence must be met simultaneously. Much work has been done before on quiescence detection <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, both for synchronous and asynchronous systems. We shall briefly discuss some previous work on quiescence detection in asynchronous computational models. Lai [8] and Huang [7] present schemes which use distributed snapshots to detect quiescence in asynchronous distributed systems. <p> In the worst case, when all processes go idle everyone will initiate a broadcast. Lai's scheme does not suffer from this drawback, however the lack of coordination between the collection of local snapshots means that a considerable number of global snapshots may be collected. Mattern <ref> [6] </ref> presents an elegant credit based scheme to detect quiescence in dynamic, asynchronous, distributed systems. In the worst case, the number of control messages needed by Mattern's algorithm is the number of activation messages. The scheme works by distributing one unit of credit amongst active processes and activation messages.
Reference: [7] <author> S. T. Huang. </author> <title> Termination detection by using distributed snapshots. </title> <journal> Information Processing Letters, </journal> <pages> pages 113-119, 32, </pages> <year> 1989. </year>
Reference-contexts: Quiescence detection, then, is the process by which the system detects quiescence in the user computation. The problem of quiescence detection in distributed systems becomes interesting because the two conditions for quiescence must be met simultaneously. Much work has been done before on quiescence detection <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, both for synchronous and asynchronous systems. We shall briefly discuss some previous work on quiescence detection in asynchronous computational models. Lai [8] and Huang [7] present schemes which use distributed snapshots to detect quiescence in asynchronous distributed systems. <p> Much work has been done before on quiescence detection [1, 2, 3, 4, 5, 6, 7, 8], both for synchronous and asynchronous systems. We shall briefly discuss some previous work on quiescence detection in asynchronous computational models. Lai [8] and Huang <ref> [7] </ref> present schemes which use distributed snapshots to detect quiescence in asynchronous distributed systems. In Lai's approach, a predefined process combines local snapshots (taken spontaneously by processes) into a global snapshot, which it then uses to determine if quiescence has occurred.
Reference: [8] <author> T. H. Lai and T. H. Yang. </author> <title> On distrbuted snapshots. </title> <journal> Information Processing Letters, </journal> <pages> pages 153-158, </pages> <month> 25 </month> <year> (1987). </year>
Reference-contexts: Quiescence detection, then, is the process by which the system detects quiescence in the user computation. The problem of quiescence detection in distributed systems becomes interesting because the two conditions for quiescence must be met simultaneously. Much work has been done before on quiescence detection <ref> [1, 2, 3, 4, 5, 6, 7, 8] </ref>, both for synchronous and asynchronous systems. We shall briefly discuss some previous work on quiescence detection in asynchronous computational models. Lai [8] and Huang [7] present schemes which use distributed snapshots to detect quiescence in asynchronous distributed systems. <p> Much work has been done before on quiescence detection [1, 2, 3, 4, 5, 6, 7, 8], both for synchronous and asynchronous systems. We shall briefly discuss some previous work on quiescence detection in asynchronous computational models. Lai <ref> [8] </ref> and Huang [7] present schemes which use distributed snapshots to detect quiescence in asynchronous distributed systems. In Lai's approach, a predefined process combines local snapshots (taken spontaneously by processes) into a global snapshot, which it then uses to determine if quiescence has occurred.
Reference: [9] <author> K. M. Chandy and J. Misra. </author> <title> How processes learn. </title> <booktitle> Distributed Computing, </booktitle> <pages> pages 40-52, 1, 1(1986). </pages>
Reference-contexts: In addition, the monitoring process becomes a bottleneck in bigger distributed systems, since all credits are being returned to the one processor on which the monitoring process is located. Chandy and Misra <ref> [9] </ref> have proved that given any quiescence detection algorithm for an asynchronous system in the worst case the number of control messages needed cannot be less than the number of activation messages in the user computation.
Reference: [10] <author> S. Chandrasekharan and S. Venkatesan. </author> <title> A message-optimal algorithm for distributed termination detection. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <pages> pages 245-252, 8, </pages> <year> 1990. </year>
Reference-contexts: Chandy and Misra [9] have proved that given any quiescence detection algorithm for an asynchronous system in the worst case the number of control messages needed cannot be less than the number of activation messages in the user computation. Chandrasekaran and Venkatesan <ref> [10] </ref> extended this result and proved that the number of control messages needed in the worst case by any quiescence detection algorithm for asynchronous systems is also bounded below by the number of communication links. The proof, however, is incorrect.
Reference: [11] <author> L. V. Kale. </author> <title> The Chare Kernel Parallel Programming System Programming System. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: The processing of message m 1 could have generated more new activity, and therefore it is incorrect to infer from the counts matching at the end of Phase 1 that the system is quiescent. 3 Quiescence Detection in Charm We have implemented the Counting algorithm discussed above for Charm <ref> [11] </ref>. Charm is a machine independent parallel programming language.
Reference: [12] <author> K. De and B. Ramkumar and P. Banerjee. ProperSYN: </author> <title> A Portable Parallel Algorithm for Logic Synthesis. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1992. </year>
Reference-contexts: The Counting algorithm itself has been implemented as a branch office chare | a branch corresponds to a component. The quiescence detection feature in Charm has been used in the implementation of a wide variety of real-life applications including parallel algorithms for logic synthesis <ref> [12] </ref> and for test pattern generation of sequential circuits [13]. In order to measure the performance of the quiescence detection algorithm in varying program contexts, we tested its performance for the following four synthetic benchmark problems 4 on a nonshared memory machine: 1.
Reference: [13] <author> B. Ramkumar and P. Banerjee. </author> <title> Portable Parallel Test Generation for Sequential Circuits. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <month> November </month> <year> 1992. </year> <month> 11 </month>
Reference-contexts: The quiescence detection feature in Charm has been used in the implementation of a wide variety of real-life applications including parallel algorithms for logic synthesis [12] and for test pattern generation of sequential circuits <ref> [13] </ref>. In order to measure the performance of the quiescence detection algorithm in varying program contexts, we tested its performance for the following four synthetic benchmark problems 4 on a nonshared memory machine: 1. Problem A is a parallel divide and conquer application.
Reference: [14] <author> W. Shu. </author> <title> Chare Kernel and its implementation on multicomputers. </title> <type> PhD thesis, </type> <institution> Department of Com--puter Science, University of Illinois, Urbana-Champaign, </institution> <year> 1990. </year> <month> 12 </month>
Reference-contexts: Although the algorithm was presented as a two-phase one, it is possible to formulate it with just one recurring phase. The two-phase formulation was chosen for the ease of presentation. The Counting algorithm was motivated by an earlier quiescence detection algorithm <ref> [14] </ref>. In Shu's method, quiescence was reported if the system was in a state of idleness for some specified interval ffit. The choice of the time interval was critical | ffit had to be greater than the worst case delivery time of a message.
References-found: 14

