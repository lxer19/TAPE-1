URL: http://www.cs.berkeley.edu/~aiken/ftp/popl91.ps
Refering-URL: http://www.cs.berkeley.edu/~aiken/pubs.html
Root-URL: 
Email: email: aiken@ibm.com  email: brm@neon.stanford.edu  
Title: Static Type Inference in a Dynamically Typed Language  
Author: Alexander Aiken Brian R. Murphy 
Address: 650 Harry Rd. San Jose, CA 95120  Stanford, CA 94305  
Affiliation: IBM Almaden Research Center  Computer Science Department Stanford University  
Abstract: We present a type inference system for FL based on an operational, rather than a denotational, formulation of types. The essential elements of the system are a type language based on regular trees and a type inference logic that implements an abstract interpretation of the operational semantics of FL. We use a non-standard approach to type inference because our requirements|using type information in the optimization of functional programs|differ substantially from those of other type systems.
Abstract-found: 1
Intro-found: 1
Reference: [B*89] <author> J. Backus et al. </author> <title> FL Language Manual, Parts 1 and 2. </title> <type> Research Report RJ 7100, </type> <institution> IBM, </institution> <year> 1989. </year>
Reference-contexts: We, however, are interested in using type inference as a tool for the optimization of programs written in a functional language. We present a type inference system for FL <ref> [B*89] </ref>, a functional language based on FP [Bac78]. Unlike ML and Haskell, the FL language definition does not include any type constraints. In standard terminology, FL is dynamically typed, meaning that run-time type checks are required.
Reference: [Bac78] <author> J. Backus. </author> <title> Can programming be liberated from the von Neumann style? a functional style and its algebra of programs. </title> <journal> Communications of the ACM, </journal> <volume> 21:8, </volume> <year> 1978. </year>
Reference-contexts: We, however, are interested in using type inference as a tool for the optimization of programs written in a functional language. We present a type inference system for FL [B*89], a functional language based on FP <ref> [Bac78] </ref>. Unlike ML and Haskell, the FL language definition does not include any type constraints. In standard terminology, FL is dynamically typed, meaning that run-time type checks are required. However, static type information is still very useful for the compilation of FL programs and particularly for enabling program optimization.
Reference: [CC79] <author> P. Cousot and R. Cousot. </author> <title> Systematic design of program analysis frameworks. </title> <booktitle> In Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: For us, a type is a set of normal-form expressions. We give a formal language based on regular trees [GS84] to describe types. We give a logic to assign types to the subexpressions of a program. Our type inference algorithm applies this logic to carry out an abstract interpretation <ref> [CC79, Nie85] </ref> of the operational semantics of FL. The correctness of this type inference algorithm is established using the operational semantics. Our approach can be viewed as an operational (or intensional) formulation of types. <p> An alternative representation, known as regular X-grammars [GS84] or leaf-linear systems of equations [MR85], is used in our implementation. 5 Type Rewriting Our type inference algorithm is an abstract interpretation <ref> [CC79, Nie85] </ref> of an operational semantics of FL.
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principle type-schemes for functional programs. </title> <booktitle> In Proceedings of the Ninth Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <year> 1982. </year>
Reference-contexts: However, the underlying algorithm is still exponential in the worst case, since the size of the proof may be exponential in the size of the original program. A promising solution to this problem is to adapt the idea of principal types from statically typed languages <ref> [DM82] </ref>. Consider the function f from Section 6. At present, the system must derive the entire proof f: Seqof (V ) ! T Seqof (V ) every time it is needed.
Reference: [Fra81] <author> G. Frank. </author> <title> Specification of data structures for FP programs. </title> <booktitle> In Proceedings of the 1981 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 221-228, </pages> <year> 1981. </year>
Reference-contexts: In contrast, a different definition of type leads us to a more robust subset test. Other algorithms on types (such as type intersection and union) are also correspondingly weaker in their approach because of the difficulty of handling function types. Several type systems have been proposed for FP <ref> [GHW81, Fra81, Kat84] </ref>. The drawbacks of using these approaches for FL type inference are the essential first-order nature of the systems and the inability to automatically infer types for recursive data structures. Regular trees have been used before in a type language for a statically-typed, first-order functional language [MR85].
Reference: [GHW81] <author> J. Guttag, J. Horning, and J. Williams. </author> <title> FP with data abstraction and strong typing. </title> <booktitle> In Proceedings of the 1981 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 11-24, </pages> <year> 1981. </year>
Reference-contexts: In contrast, a different definition of type leads us to a more robust subset test. Other algorithms on types (such as type intersection and union) are also correspondingly weaker in their approach because of the difficulty of handling function types. Several type systems have been proposed for FP <ref> [GHW81, Fra81, Kat84] </ref>. The drawbacks of using these approaches for FL type inference are the essential first-order nature of the systems and the inability to automatically infer types for recursive data structures. Regular trees have been used before in a type language for a statically-typed, first-order functional language [MR85].
Reference: [GS84] <author> F. Gecseg and M. Steinby. </author> <title> Tree Automata. </title> <address> Academei Kaido, Budapest, </address> <year> 1984. </year>
Reference-contexts: Nevertheless, there are close parallels, 1 and for this reason we choose to use the terms type and type inference, despite the non-standard interpretation. For us, a type is a set of normal-form expressions. We give a formal language based on regular trees <ref> [GS84] </ref> to describe types. We give a logic to assign types to the subexpressions of a program. Our type inference algorithm applies this logic to carry out an abstract interpretation [CC79, Nie85] of the operational semantics of FL. <p> Let T be a type expression. An occurrence of ff in T is bound if it is in the scope of fix ff:T 0 ; otherwise ff is free. Except for the presence of free variables, type expressions are regular trees <ref> [GS84] </ref>. An environment is a function from type variables to sets of expressions. The type meaning function maps type expressions and environments to sets of expressions. Definition 4.1 Let T 1 and T 2 be type expressions. <p> Type expressions have many useful properties. From Figure 2 type expressions are closed under union, intersection, and least fixed-point operations. Type expressions with no free variables are closed under complementation. It is also decidable whether T = ; <ref> [GS84] </ref> and whether T 1 T 2 [Mur90]. We have developed a fast heuristic (based on the work of [MR85]) for the following problem: Given two types T 1 and T 2 , find a most general substitution such that (T 1 ; ) (T 2 ; ). <p> Second, while the definition of type expressions given in Figure 2 is easy to understand, it does not lead to the best algorithms. An alternative representation, known as regular X-grammars <ref> [GS84] </ref> or leaf-linear systems of equations [MR85], is used in our implementation. 5 Type Rewriting Our type inference algorithm is an abstract interpretation [CC79, Nie85] of an operational semantics of FL.
Reference: [HJ90] <author> N. Heintze and J. Jaffar. </author> <title> A finite presentation theorem for approximating logic programs. </title> <booktitle> In POPL17, </booktitle> <pages> pages 197-209, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Second, we require arbitrary type union, whereas [MR85] uses discriminated unions. Regular trees have also been used in the static analysis of logic programs <ref> [HJ90] </ref>. 4 The Type Language Let be a set of type constructors and let be a set of type variables. We use c for elements of and ff; fi; : : : for elements of . A syntax and semantics for type expressions is given in Figure 2.
Reference: [HMT89] <author> R. Harper, R. Milner, and M. Tofte. </author> <title> The Definition of Standard ML|Version 3. </title> <type> Technical Report ECFS-LFCS-89-81, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <year> 1989. </year>
Reference-contexts: Traditionally, type systems have emphasized the detection of type errors. Statically typed functional languages such as Haskell [HWA*88] and ML <ref> [HMT89] </ref> include type constraints as part of the language definition, making some type inference necessary to ensure that type constraints are satisfied (i.e., to ensure that a program has no type errors).
Reference: [HWA*88] <author> P. Hudak, P. Wadler, Arvind, B. Boutel, J. Fairbairn, J. Fasel, J. Hughes, T. Johnsson, D. Kieburtz, S. P. Jones, R. Nikhil, M. Reeve, D. Wise, and J. Young. </author> <title> Report on the Functional Programming Language Haskell. </title> <type> Technical Report DCS/RR-666, </type> <institution> Yale University, </institution> <month> December </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Compilers derive at least two benefits from static type inference: the ability to detect and report potential run-time errors at compile-time, and the use of type information in program optimization. Traditionally, type systems have emphasized the detection of type errors. Statically typed functional languages such as Haskell <ref> [HWA*88] </ref> and ML [HMT89] include type constraints as part of the language definition, making some type inference necessary to ensure that type constraints are satisfied (i.e., to ensure that a program has no type errors).
Reference: [HY88] <author> P. Hudak and J. Young. </author> <title> A collecting interpretation of expressions (without powerdomains). </title> <booktitle> In Proceedings of the 15th Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 107-118, </pages> <year> 1988. </year>
Reference-contexts: Section 6 adds new inference rules to the logic to guarantee termination and to type recursive functions precisely. Section 7 presents a solution to the full type inference problem, using a simple way of defining a collecting interpretation <ref> [Nie85, HY88] </ref> directly from the structure of a proof in the logic. Section 8 concludes with a brief discussion of the implementation and outstanding problems. This paper concentrates on the theoretical basis for the type system; detailed descriptions of some of the algorithms and the implementation appear in [Mur90]. <p> In particular, V shows that the body of f produces a modified sequence for every sequence in ff, and an append-left ("al") exception for every non-sequence in ff. The application of REC in the final step proves that no append-left exceptions can arise. 7 Type Inference A collecting interpretation <ref> [Nie85, HY88] </ref> is an abstract interpretation that gathers information about the subex-pressions of an expression. <p> Without loss of generality, we assume that the context is a normal form expression. 10 We first formalize the result of type inference. Following <ref> [HY88] </ref>, we extend FL's syntax to distinguish occur-rences of a primitive function f by labelling each with a unique label l (writing l:f). 3 For higher-order functions, it is useful to have type information for every curried argument, not just the first.
Reference: [Kat84] <author> T. Katayama. </author> <title> Type inference and type checking for functional languages: a reduced computation approach. </title> <booktitle> In Conference Record of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 263-272, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: In contrast, a different definition of type leads us to a more robust subset test. Other algorithms on types (such as type intersection and union) are also correspondingly weaker in their approach because of the difficulty of handling function types. Several type systems have been proposed for FP <ref> [GHW81, Fra81, Kat84] </ref>. The drawbacks of using these approaches for FL type inference are the essential first-order nature of the systems and the inability to automatically infer types for recursive data structures. Regular trees have been used before in a type language for a statically-typed, first-order functional language [MR85].
Reference: [Mic68] <author> D. Michie. </author> <title> `Memo' functions and machine learning. </title> <journal> Nature, </journal> (218):19-22, April 1968. 
Reference-contexts: Our implementation has convinced us that this design is a good one; this approach seems to match very well with programming styles used in practice. The main barrier to a completely practical system is performance. The current implementation tries to make the proof search fast. Memoization <ref> [Mic68] </ref> is used extensively to avoid recomputation and there is no backtracking. However, the underlying algorithm is still exponential in the worst case, since the size of the proof may be exponential in the size of the original program.
Reference: [Mil78] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> J. Comp. & Sys. Sci., </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Thatte presents a type system for Lisp designed to detect statically some type errors [Tha88]. The system extends the Hindley/Milner type system <ref> [Mil78] </ref> with one new type representing the set of all values; thus, every expression has type . This is probably the simplest extension of Hindley/Milner that is adequate for dynamically typed languages. Unfortunately, the typing algorithm Thatte presents for this minimal extension may diverge.
Reference: [MR85] <author> P. Mishra and U. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Proceedings of the Twelfth Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 7-21, </pages> <year> 1985. </year>
Reference-contexts: The drawbacks of using these approaches for FL type inference are the essential first-order nature of the systems and the inability to automatically infer types for recursive data structures. Regular trees have been used before in a type language for a statically-typed, first-order functional language <ref> [MR85] </ref>. There are two essential differences in our approach. <p> ) ^ e 2 2 (TE 2 ; )g j Null (Null; ) = fhig j (; ) = feje is a normal formg j Int (Int; ) = f: : : ; 1; 0; 1; : : :g j cond (cond; ) = fcondg mechanism for expressing types; in <ref> [MR85] </ref> a separate function-space constructor is used for function types. Second, we require arbitrary type union, whereas [MR85] uses discriminated unions. <p> ) = feje is a normal formg j Int (Int; ) = f: : : ; 1; 0; 1; : : :g j cond (cond; ) = fcondg mechanism for expressing types; in <ref> [MR85] </ref> a separate function-space constructor is used for function types. Second, we require arbitrary type union, whereas [MR85] uses discriminated unions. Regular trees have also been used in the static analysis of logic programs [HJ90]. 4 The Type Language Let be a set of type constructors and let be a set of type variables. <p> Type expressions with no free variables are closed under complementation. It is also decidable whether T = ; [GS84] and whether T 1 T 2 [Mur90]. We have developed a fast heuristic (based on the work of <ref> [MR85] </ref>) for the following problem: Given two types T 1 and T 2 , find a most general substitution such that (T 1 ; ) (T 2 ; ). A heuristic is required because finding a substitution is PSPACE-hard in general [Mur90]. <p> Second, while the definition of type expressions given in Figure 2 is easy to understand, it does not lead to the best algorithms. An alternative representation, known as regular X-grammars [GS84] or leaf-linear systems of equations <ref> [MR85] </ref>, is used in our implementation. 5 Type Rewriting Our type inference algorithm is an abstract interpretation [CC79, Nie85] of an operational semantics of FL.
Reference: [Mur90] <author> B. R. Murphy. </author> <title> A Type Inference System for FL. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <year> 1990. </year>
Reference-contexts: Section 8 concludes with a brief discussion of the implementation and outstanding problems. This paper concentrates on the theoretical basis for the type system; detailed descriptions of some of the algorithms and the implementation appear in <ref> [Mur90] </ref>. An implementation of our type inference system for the full FL language has been in use at IBM Almaden for several months. During this time, the system has been used to analyze a wide variety of small- to medium-size (500 lines of FL) programs. <p> Type expressions have many useful properties. From Figure 2 type expressions are closed under union, intersection, and least fixed-point operations. Type expressions with no free variables are closed under complementation. It is also decidable whether T = ; [GS84] and whether T 1 T 2 <ref> [Mur90] </ref>. We have developed a fast heuristic (based on the work of [MR85]) for the following problem: Given two types T 1 and T 2 , find a most general substitution such that (T 1 ; ) (T 2 ; ). <p> A heuristic is required because finding a substitution is PSPACE-hard in general <ref> [Mur90] </ref>. The heuristic works well; we have yet to find an example in practice where its use adversely affects the precision of type inference. We conclude this section with two brief comments on the implementation of types.
Reference: [Nie85] <author> F. Nielson. </author> <title> Program transformations in a denotational setting. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(3) </volume> <pages> 359-379, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: For us, a type is a set of normal-form expressions. We give a formal language based on regular trees [GS84] to describe types. We give a logic to assign types to the subexpressions of a program. Our type inference algorithm applies this logic to carry out an abstract interpretation <ref> [CC79, Nie85] </ref> of the operational semantics of FL. The correctness of this type inference algorithm is established using the operational semantics. Our approach can be viewed as an operational (or intensional) formulation of types. <p> Section 6 adds new inference rules to the logic to guarantee termination and to type recursive functions precisely. Section 7 presents a solution to the full type inference problem, using a simple way of defining a collecting interpretation <ref> [Nie85, HY88] </ref> directly from the structure of a proof in the logic. Section 8 concludes with a brief discussion of the implementation and outstanding problems. This paper concentrates on the theoretical basis for the type system; detailed descriptions of some of the algorithms and the implementation appear in [Mur90]. <p> An alternative representation, known as regular X-grammars [GS84] or leaf-linear systems of equations [MR85], is used in our implementation. 5 Type Rewriting Our type inference algorithm is an abstract interpretation <ref> [CC79, Nie85] </ref> of an operational semantics of FL. <p> In particular, V shows that the body of f produces a modified sequence for every sequence in ff, and an append-left ("al") exception for every non-sequence in ff. The application of REC in the final step proves that no append-left exceptions can arise. 7 Type Inference A collecting interpretation <ref> [Nie85, HY88] </ref> is an abstract interpretation that gathers information about the subex-pressions of an expression.
Reference: [Plo] <author> G. D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <institution> Text prepared at University of Aarhus. </institution>
Reference-contexts: Section 7 presents a full solution to the type inference problem based on the abstract rewrite relation. We begin by writing the operational rewrite rules of FL in the structural style advocated by Plotkin <ref> [Plo] </ref>. Rewrite rules in this style are presented as inference rules of a formal logic; a rule is read as asserting that if the subgoals above the line hold, then the conclusion below the line holds.
Reference: [Tha88] <author> S. Thatte. </author> <title> Type inference with partial types. </title> <booktitle> In Automata, Languages and Programming: 15th International Colloquium, </booktitle> <pages> pages 615-629, </pages> <booktitle> Springer-Verlag Lecture Notes in Computer Science, </booktitle> <volume> vol. 317, </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: Thatte presents a type system for Lisp designed to detect statically some type errors <ref> [Tha88] </ref>. The system extends the Hindley/Milner type system [Mil78] with one new type representing the set of all values; thus, every expression has type . This is probably the simplest extension of Hindley/Milner that is adequate for dynamically typed languages.
Reference: [YO88] <author> J. Young and P. O'Keefe. </author> <title> Experience with a type evaluator. </title> <editor> In D. Bjtrner, A. P. Ershov, and N. D. Jones, editors, </editor> <booktitle> Partial Evaluation and Mixed Computation, </booktitle> <pages> pages 573-581, </pages> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Furthermore, the system cannot precisely type some simple expressions; for example, the expression s1: h1; ai has type because heterogeneous sequences have type List (). At the other extreme, Young and O'Keefe present a type evaluator for a lazy dialect of Scheme <ref> [YO88] </ref>. This system is strikingly similar to our system in some respects, but types are sets of values. Scheme itself serves as the type language; thus, any function from types to types is a type. As discussed above, this presents serious problems in comparing types.
References-found: 20

