URL: http://laurel.cs.nyu.edu:8080/publications/slambda3.ps.gz
Refering-URL: http://laurel.cs.nyu.edu:8080/publications/slambda.html
Root-URL: http://www.cs.nyu.edu
Email: yung@cs.nyu.edu  
Title: Extending Typed -Calculus To Sets  
Author: Chung Yung 
Date: April 12, 1997  
Address: New York University  
Affiliation: Computer Science Department Courant Institute of Mathematical Sciences  
Abstract: This paper describes our work on extending typed - calculus to accommodate operations with typed, or homogeneous, sets. Functions play a prominent role in describing the semantics of a programming language, and -calculus, as a theory of functions, provides rules for manipulating functions in a purely syntactic manner. We extend typed -calculus with typed sets, and call the extension as Set-Enriched Typed -Calculus, or in short SET -calculus. We show the well-formedness of SET -calculus, and we include the proof of its soundness and completeness. This is part of our work on implementing functional languages with sets. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. W. Appel. </author> <title> Compiling with Continuations, </title> <publisher> Cam-bridge University Press, </publisher> <year> 1992. </year> <month> 11 </month>
Reference: [2] <author> R. B. K. Dewar, E. Schonberg, and J. T. Schwartz. </author> <title> Higher Level Programming: Introduction to the Use of the Set-Theoretic Programming Language SETL, </title> <institution> Courant Institute of Mathematical Sciences, Computer Science Department, </institution> <address> New York University, </address> <year> 1981. </year>
Reference-contexts: Then, we introduce the set-enriched typed -calculus, or in short SET -calculus. We show the well-formedness as the conclusion of this section. 2.1 Extension to Sets Since a set is an unordered list whose elements appear only once, we extend the typed -calculus to sets <ref> [2] </ref>, and [16]. Analogous to the list operations, we have a few set operations. Table 1 shows our extension to set operations. In addition, we add a new membership test operator, in or 2, whose syntax is e 1 in e 2 .
Reference: [3] <author> S. M. Freudenberger, J. T. Schwartz, and M. Sharir. </author> <title> "Experience with the SETL Optimizer," </title> <journal> ACM Transaction on Programming Languages and Systems, pp. </journal> <volume> 26-45, Vol. 5, No. 1, </volume> <month> January </month> <year> 1983. </year>
Reference: [4] <author> M. Gloger, and B. Goldberg. </author> <title> "Polymorphic Type Reconstruction for Garbage Collection without Tags,", </title> <booktitle> Proceedings of the 1992 ACM Conference on LISP and Functional Programming, </booktitle> <month> June </month> <year> 1992. </year>
Reference: [5] <author> R. Harper, and J. C. Mitchell. </author> <title> "ML and Beyond," </title> <journal> ACM SIGPLAN Notices, pp. </journal> <volume> 80-85, Vol. 32, No. 1, </volume> <month> January </month> <year> 1997. </year>
Reference-contexts: The goal of programming languages research is to develop linguistic constructs and corresponding analysis and compilation techniques that will improve software productivity. In all of these efforts, clear understanding of the underlying abstractions and their properties are critical <ref> [5] </ref>. The purpose of the SET -calculus is extending the -expression transformation to set constructs. We have been less concerned with a few properties, such as: 1. By allowing general recursion, fix, we lose the strong normalization of -calculus, like a few func tional programming languages do. 2.
Reference: [6] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: [7] <author> F. Neilson, and H. R. Neilson. </author> <title> Two-level Functional Languages, </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: One of the benefits of this programming style is the reuse of function definitions and, more importantly, the reuse of properties proved to hold for them. Usually, a property of a higher-order function carries over to an instance by verifying that the arguments satisfy some simple properties <ref> [7] </ref>. <p> Proof. See <ref> [7] </ref>. 2 Theorem 2. (soundness and completeness) The type analysis of -calculus is sound and complete. Proof. See [7]. 2 2 SET -Calculus In this section, we introduce our extension of typed - calculus to homogeneous sets, or typed sets. We first describe our extension to sets. <p> Proof. See <ref> [7] </ref>. 2 Theorem 2. (soundness and completeness) The type analysis of -calculus is sound and complete. Proof. See [7]. 2 2 SET -Calculus In this section, we introduce our extension of typed - calculus to homogeneous sets, or typed sets. We first describe our extension to sets. Then, we introduce the set-enriched typed -calculus, or in short SET -calculus. <p> Finally, we observe that if x i =2 F EV (ue 0 ) the result may be obtained in much the same manner. * The following cases follow the pattern of the above cases: (See the discussion in <ref> [7] </ref> for details.) 1. ue ::= hue 1 ; ue 2 i, 3. ue ::= snd ue 0 , 5. ue ::= x i , 7. ue ::= nil, 9. ue ::= tl ue 0 , 10. ue ::= isnil ue 0 , 11. if ue 1 then ue 2 else
Reference: [8] <author> R. S. Nikhil. </author> <title> "The Semantics of Update in a Functional Database Programming Language," </title> <booktitle> Advances in Database Programming Languages, </booktitle> <editor> eds. F. Bancilhon and P. Buneman, </editor> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: a functional language is that its clean semantics makes programs amenable to very fl This paper appeared in the Proceedings on MASPLAS'97, in cooperation with ACM SIGPLAN. y Author's address: 715 Broadway, Room 1008, New York NY 10003, and author's phone number: (212) 998-3350. powerful transforms, resulting in significant optimizations <ref> [8] </ref>. The functional programming paradigm provides an alternative notion of programming that avoids the problems of side effects. Functional languages are concerned with data objects and values instead of variables. Values are bound to identifiers, but once made, these bindings cannot change. The principal operation is function application.
Reference: [9] <author> R. Paige. </author> <title> Formal Differentiation: A Program Synthesis Technique, </title> <publisher> UMI Research Press, </publisher> <year> 1981. </year>
Reference-contexts: Among others, Paige's finite differencing of computable expressions is a high-level compiler optimization technology. It captures common yet distinctive program constructions of costly repeated calculations, and then transforms them into more efficient incremental program constructions <ref> [9] </ref>, [11], [12], and [13]. We are especially interested in applying Paige's finite differencing of computable expressions to functional programming languages. 6 Acknowledgements The author appreciates the help and advise from Professor Benjamin Goldberg, Professor Robert Paige, and Professor Ajit Kambil.
Reference: [10] <author> R. Paige. </author> <title> "Programming with Invariants," </title> <journal> IEEE Software, pp. </journal> <volume> 560-69, Vol. 3, No. 1, </volume> <month> January </month> <year> 1986. </year>
Reference: [11] <author> R. Paige. </author> <title> "Real-Time Simulation of A Set Machine on a RAM," </title> <booktitle> Proceedings on ICCI 89, </booktitle> <month> May </month> <year> 1989, </year> <note> also in Computing and Information, Vol. </note> <editor> II, eds. R. Janicki and W. </editor> <booktitle> Koczkodaj, </booktitle> <pages> pp. 69-73, </pages> <publisher> Canadian Scholars Press, </publisher> <year> 1989. </year>
Reference-contexts: Among others, Paige's finite differencing of computable expressions is a high-level compiler optimization technology. It captures common yet distinctive program constructions of costly repeated calculations, and then transforms them into more efficient incremental program constructions [9], <ref> [11] </ref>, [12], and [13]. We are especially interested in applying Paige's finite differencing of computable expressions to functional programming languages. 6 Acknowledgements The author appreciates the help and advise from Professor Benjamin Goldberg, Professor Robert Paige, and Professor Ajit Kambil. The author is grateful to Allen Leung for his precious comments.
Reference: [12] <author> R. Paige. </author> <title> "Future Direction in Program Transformations," </title> <journal> ACM SIGPLAN Notices, pp. </journal> <volume> 94-98, Vol. 32, No. 1, </volume> <month> January </month> <year> 1997. </year>
Reference-contexts: Among others, Paige's finite differencing of computable expressions is a high-level compiler optimization technology. It captures common yet distinctive program constructions of costly repeated calculations, and then transforms them into more efficient incremental program constructions [9], [11], <ref> [12] </ref>, and [13]. We are especially interested in applying Paige's finite differencing of computable expressions to functional programming languages. 6 Acknowledgements The author appreciates the help and advise from Professor Benjamin Goldberg, Professor Robert Paige, and Professor Ajit Kambil. The author is grateful to Allen Leung for his precious comments.
Reference: [13] <author> R. Paige, and S. Koenig. </author> <title> "Finite Differencing of Computable Expressions," </title> <journal> ACM Transactions on Programming Languages and Systems, pp. </journal> <volume> 402-454, Vol. 4, No. 3, </volume> <month> July </month> <year> 1982. </year>
Reference-contexts: Among others, Paige's finite differencing of computable expressions is a high-level compiler optimization technology. It captures common yet distinctive program constructions of costly repeated calculations, and then transforms them into more efficient incremental program constructions [9], [11], [12], and <ref> [13] </ref>. We are especially interested in applying Paige's finite differencing of computable expressions to functional programming languages. 6 Acknowledgements The author appreciates the help and advise from Professor Benjamin Goldberg, Professor Robert Paige, and Professor Ajit Kambil. The author is grateful to Allen Leung for his precious comments.
Reference: [14] <author> L. C. Paulson. </author> <title> ML for the Working Programmer, 2 nd Edition, </title> <publisher> Cambridge Press, </publisher> <year> 1996. </year>
Reference: [15] <author> J. A. Robinson. </author> <title> "A Machine-Oriented Logic Based on the Resolution Principle," </title> <journal> Journal of the ACM, pp. </journal> <volume> 23-41, Vol. 8, No. 12, </volume> <month> December </month> <year> 1965. </year>
Reference-contexts: Lemma 4. (Robinson) There exists an algorithm U which, when supplied with a set fpt 1 ; : : : ; pt n g of poly types, either fails or produces a substitution S <ref> [15] </ref>: * It fails if and only if there exists no substitution S such that S (pt 1 ) = : : : = S (pt n ). * If it produces a substitution S then - S unifies fpt 1 ; : : : ; pt n g, i.e.
Reference: [16] <author> J. T. Schwartz, R. B. K. Dewar, E. Dubinsky, E. Schonberg. </author> <title> Programming With Sets: An Introduction to SETL, </title> <publisher> Springer-Verlag Press, </publisher> <year> 1986. </year>
Reference-contexts: Then, we introduce the set-enriched typed -calculus, or in short SET -calculus. We show the well-formedness as the conclusion of this section. 2.1 Extension to Sets Since a set is an unordered list whose elements appear only once, we extend the typed -calculus to sets [2], and <ref> [16] </ref>. Analogous to the list operations, we have a few set operations. Table 1 shows our extension to set operations. In addition, we add a new membership test operator, in or 2, whose syntax is e 1 in e 2 .
Reference: [17] <author> R. Sethi. </author> <title> Programming languages: Concepts and Constructs, </title> <publisher> Addison-Wesley Press, </publisher> <year> 1989. </year>
Reference: [18] <author> K. Slonneger, and B. L. Kurtz. </author> <title> Formal Syntax and Semantics of Programming Languages, </title> <publisher> Addison-Wesley Press, </publisher> <year> 1995. </year>
Reference-contexts: A functional language supplies primitive functions, and programmer uses function constructors to define new functions. Program execution consists of the evaluation of an expression, and sequence control depends primarily on selection and recursion <ref> [18] </ref>. Functions play a prominent role in describing the semantics of a programming language, since the meaning of a computer program can be considered as a function from input values to output values [18]. <p> execution consists of the evaluation of an expression, and sequence control depends primarily on selection and recursion <ref> [18] </ref>. Functions play a prominent role in describing the semantics of a programming language, since the meaning of a computer program can be considered as a function from input values to output values [18]. In addition, functions play an essential role in mathematics, which means that much of the theory of functions, including the issue of computability, unfolded as part of mathematical logic before advent of computers. <p> Beyond the influence of the -calculus in the area of computation theory, it has contributed important results to the formal semantics of programming languages <ref> [18] </ref>: * Although the -calculus has the power to represent all computable functions, its uncomplicated syntax and semantics provide an excellent vehicle for studying the meaning of programming language concept. * All functional programming languages can be viewed as syntactic variations of the -calculus, so that both their semantics and implementation
Reference: [19] <author> W. K. Snyder. </author> <title> "The SETL2 Programming Language," </title> <type> Technical Report 490, </type> <institution> Computer Science Department, Courant Institute of Mathematical Sciences, </institution> <address> New York University, </address> <month> September </month> <year> 1990. </year>
Reference: [20] <author> A. K. Wright, and R. Cartwright. </author> <title> "A Practical Soft Type System for Scheme," </title> <journal> Transactions on Programming Languages and Systems, pp. </journal> <volume> 87-152, Vol. 19, No. 1, </volume> <month> January </month> <year> 1997. </year> <month> 12 </month>
References-found: 20

