URL: ftp://ftp.csd.uu.se/pub/papers/reports/0077.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: E-mail: jonas@csd.uu.se  bevemyr@csd.uu.se  
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: with Arrays and Bounded Quantifications  
Author: Jonas Barklund and Johan Bevemyr 
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Uppsala University, Computing Science Dept.  
Note: Prolog  or  
Abstract: UPMAIL Technical Report No. 77 September 30, 1993 Abstract It is proposed to add bounded quantifications to Prolog. The main reason is one of natural expression, many algorithms are expressed more elegantly in a declarative way using bounded quantifications than using existing means, i.e., recursion. In particular this is true for numerical algorithms, an area where Prolog has been virtually unsuccessful so far. Moreover, bounded quantification has been found to be at least as efficient as recursion, when applicable. We outline an implementation of some bounded quantifications through an extension of Warren's abstract Prolog machine and give performance figures relative to recursion. Finally, we have shown elsewhere that bounded quantification has a high potential for parallel implementation and we conclude in this paper that one can often run the same program efficiently on a sequential computer as well and on several kinds of parallel computers. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anderson, S. and Hudak, P., </author> <title> Compilation of Haskell Array Compre hensions for Scientific Computing, </title> <booktitle> in: Proc. SIGPLAN '90 Conf. on Programming Language Design and Implementation, </booktitle> <publisher> ACM Press, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: Meier also considers "backtracking" iteration, a subject we have not discussed here (compilation of bounded existential quantifications). It seems to us that the instruction set we use would be appropriate as a base also for Millroth's and Meier's methods. The work on array comprehensions in Haskell and their compilation <ref> [1] </ref> also seems to be relevant for our work, although their context is lazy functional programming. The Common LISP dialect (and some earlier LISP dialects) contains iteration, mapping and reduction constructs that in some cases resemble ours.
Reference: [2] <author> Arro, H., Barklund, J. and Bevemyr, J., </author> <title> Parallel Bounded Quantifica tions|Preliminary Results, </title> <type> UPMAIL Tech. Rep. 74, </type> <institution> Comp. Sci. Dept., Uppsala Univ., Uppsala, </institution> <year> 1993, </year> <note> to appear in SIGPLAN Notices. </note>
Reference-contexts: Although we propose sequential operational semantics for these constructs here, we have shown elsewhere that many Prolog programs with bounded quantifications can also be run efficiently on parallel computers. We have run programs on both SIMD computers (Connection Machine Model CM-2 by Thinking Machines Corp.) <ref> [2] </ref> and shared-memory MIMD computers (SUN 630MP and Sequent Symmetry) [3]. Much of the beauty of bounded quantifications lies in the fact that they have a clear declarative semantics, while at the same time they behave well operationally on this wide range of sequential and parallel computers.
Reference: [3] <author> Barklund, J. and Bevemyr, J., </author> <title> Executing Bounded Quantifications on Shared Memory Multiprocessors, </title> <editor> in: J. Peenjam (ed.), </editor> <booktitle> Proc. 4th Intl. Conf. on Logic Programming and Automated Reasoning, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: We have run programs on both SIMD computers (Connection Machine Model CM-2 by Thinking Machines Corp.) [2] and shared-memory MIMD computers (SUN 630MP and Sequent Symmetry) <ref> [3] </ref>. Much of the beauty of bounded quantifications lies in the fact that they have a clear declarative semantics, while at the same time they behave well operationally on this wide range of sequential and parallel computers. The rest of the paper is structured as follows.
Reference: [4] <author> Barklund, J. and Bevemyr, J., </author> <title> Prolog with Arrays and Bounded Quan tifications, </title> <editor> in: A. Voronkov (ed.), </editor> <booktitle> Proc. 4th Intl. Conf. on Logic Programming and Automated Reasoning, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Section 11 concludes the paper with some conclusions and prospects for future work. This paper is a significantly extended and slightly revised version of a paper that was presented at the Fourth International Conference on Logic Programming and Automated Reasoning and can be found in its proceedings <ref> [4] </ref>. 2 Bounded Quantification Following Tennent [22, 23] in spirit, we define a quantification to be an expression that has three parts: a quantifier, which is a symbol from a given alphabet of quantifiers, a locally scoped iteration variable, and a body, which is itself an expression.
Reference: [5] <author> Barklund, J. and Millroth, H., </author> <title> Integrating Complex Data Structures in Prolog, </title> <editor> in: S. Haridi (ed.), </editor> <booktitle> Proc. 1987 Symp. on Logic Programming, Comp. </booktitle> <publisher> Soc. Press of the IEEE, </publisher> <address> Washington, D.C., </address> <year> 1987. </year>
Reference-contexts: In our earlier research, we investigated how arrays, tables and other data structures could be incorporated into Prolog by making them obey the rules above in such a way that they were denoted by terms of a fixed arity, in the same way as lists and trees are <ref> [5] </ref>. The reason was that we wanted to be able to use recursion also for traversing and constructing arrays, tables, etc. We have abandoned that effort and propose instead to use bounded quantification for this purpose, in accordance with the discussion at the beginning of this section.
Reference: [6] <author> Barklund, J. and Millroth, H., </author> <title> Providing Concurrency and Iteration in Logic Programming through Bounded Quantifications, </title> <editor> in: H. Tanaka (ed.), </editor> <booktitle> Proc. Intl. Conf. on Fifth Generation Computer Systems 1992, </booktitle> <publisher> Ohmsha, </publisher> <address> Tokyo, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Barklund and Millroth <ref> [6] </ref> and Voronkov [25, 26] have proposed bounded quantifications as a computational device for repetition by iteration in logic programs. In this paper we argue for a useful extension of the Prolog programming language with bounded quantifications.
Reference: [7] <author> Bevemyr, J., </author> <title> The Luther WAM Emulator, </title> <type> UPMAIL Tech. Rep. 72, </type> <institution> Comp. Sci. Dept., Uppsala Univ., Uppsala, </institution> <year> 1992. </year>
Reference-contexts: the code for a body is terminated by a conditional jump back to the beginning, or some variant thereof. 5 The Luther WAM Emulator Our experiments have been conducted in an implementation of Warren's abstract Prolog machine [27] which is based on an emulator written in the C programming language <ref> [7, 8] </ref>. To better understand our code sequences below one ought to know the following. 1. There are two instructions builtin and inline that do the work of various predefined relations, known to the compiler.
Reference: [8] <author> Bevemyr, J., </author> <title> A Recursion Parallel Prolog Engine, Ph.L. </title> <type> Thesis, </type> <institution> Comp. Sci. Dept., Uppsala Univ., Uppsala, </institution> <year> 1993. </year> <month> 26 </month>
Reference-contexts: the code for a body is terminated by a conditional jump back to the beginning, or some variant thereof. 5 The Luther WAM Emulator Our experiments have been conducted in an implementation of Warren's abstract Prolog machine [27] which is based on an emulator written in the C programming language <ref> [7, 8] </ref>. To better understand our code sequences below one ought to know the following. 1. There are two instructions builtin and inline that do the work of various predefined relations, known to the compiler.
Reference: [9] <author> Bevemyr, J., Lindgren, T. and Millroth, H., </author> <title> Exploiting Recursion Parallelism in Prolog, </title> <booktitle> in: Proc. </booktitle> <address> PARLE-93, </address> <publisher> LNCS 694, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: In comparison our approach is only applicable to range-restricted formulas, but is quite efficient for that case. Two other related works are the methods by Bevemyr, Lindgren & Mill-roth <ref> [9, 19] </ref> and Meier [17] for compiling recursive programs to iterative code. Millroth's method is based on an analysis of variable binding patterns while Meier's method, as presented, seems somewhat more ad hoc.
Reference: [10] <author> Chikayama, T. and Kimura, Y., </author> <title> Multiple Reference Management in Flat GHC, </title> <editor> in: J.-L. Lassez (ed.), </editor> <booktitle> Logic Programming|Proc. Fourth Intl. Conf., </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1987. </year>
Reference-contexts: Constant-time mechanisms with a reasonable overhead for that operation have been investigated, e.g., by Eriksson & Rayner [12]; note also the work on multiple reference management by Chikayama and Kimura <ref> [10] </ref>.
Reference: [11] <author> Dovier, A., Omodeo, E. G., Pontelli, E. and Rossi, G., flogg: </author> <title> a Logic Programming Language with Finite Sets, </title> <editor> in: K. Furukawa (ed.), </editor> <booktitle> Proc. Intl. Conf. on Logic Programming 1991, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: He also mentions previous work in Russia. Some authors have studied the use of bounded quantifiers with sets, for example in SETL [21] and flogg <ref> [11] </ref>. Lloyd & Topor [16] have studied transformation methods for running more general quantifier expressions, although their method will `flounder' for some examples that can be run using this method (Lloyd, personal communication).
Reference: [12] <author> Eriksson, L.-H. and Rayner, M., </author> <title> Incorporating Mutable Arrays into Logic Programming, </title> <editor> in: S. A. Tarnlund (ed.), </editor> <booktitle> Proc. 2nd Intl. Logic Programming Conf., </booktitle> <institution> Uppsala University, </institution> <year> 1984. </year>
Reference-contexts: Constant-time mechanisms with a reasonable overhead for that operation have been investigated, e.g., by Eriksson & Rayner <ref> [12] </ref>; note also the work on multiple reference management by Chikayama and Kimura [10].
Reference: [13] <editor> Gries, D., </editor> <booktitle> The Science of Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York., </address> <year> 1981. </year>
Reference-contexts: The idea for using bounded quantification in logic programming was inspired by Tennent's proposed use of them in ALGOL-like languages [22, 23], and also by an exposition of Gries <ref> [13] </ref>. 11 Conclusions and Future Work An extension of Prolog with bounded quantifications has been proposed.
Reference: [14] <author> Hill, P. M. and Lloyd, J. W., </author> <title> The Godel Programming Language, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: a is a k-dimensional s 1 fi fi s k array, is an iterator that is equivalent to 0 &lt;_ i 1 &lt; s 1, : : :, 0 &lt;_ i k &lt; s k. * the equality theory of Prolog has been extended in a way similar to Godel <ref> [14] </ref>. <p> In particular it would be interesting to know the speed-up for an implementation that produces native code. Our hypothesis is that one could obtain a speed comparable to that of iteration in imperative languages, particularly if a compile-time type system (such as the one in Godel <ref> [14] </ref>) was employed. Even though we consider bounded quantifications justified in sequential logic programming languages, for the reasons explained above, a main motivation for studying bounded quantification is their potential for paral-lelization.
Reference: [15] <editor> Hudak, P. et al., </editor> <title> Report on the Programming Language Haskell, </title> <journal> ACM SIGPLAN Notices, </journal> <month> 5 </month> <year> (1992). </year>
Reference-contexts: set quantifiers. (Incidentally, if the requirement that the range formula must contain an iterator as a conjunct is dropped we obtain the equivalent of Prolog's bagof "predicate".) The set and list quantifications are quite similar to the set and list comprehensions that can be found in some functional programming languages <ref> [15, 24] </ref>. A count quantifier, which gives the number of elements for which the range formula is true, can be included but could also be simulated by 23 sum ([i], 1, Z).
Reference: [16] <author> Lloyd, J. W. and Topor, R. W., </author> <title> Making Prolog more Expressive, </title> <journal> J. Logic Programming, </journal> <volume> 1 </volume> <month> 225-240 </month> <year> (1984). </year>
Reference-contexts: He also mentions previous work in Russia. Some authors have studied the use of bounded quantifiers with sets, for example in SETL [21] and flogg [11]. Lloyd & Topor <ref> [16] </ref> have studied transformation methods for running more general quantifier expressions, although their method will `flounder' for some examples that can be run using this method (Lloyd, personal communication).
Reference: [17] <author> Meier, M., </author> <title> Recursion vs. Iteration in Prolog, </title> <editor> in: K. Furukawa (ed.), </editor> <booktitle> Logic Programming|Proc. Eighth Intl. Conf., </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: In comparison our approach is only applicable to range-restricted formulas, but is quite efficient for that case. Two other related works are the methods by Bevemyr, Lindgren & Mill-roth [9, 19] and Meier <ref> [17] </ref> for compiling recursive programs to iterative code. Millroth's method is based on an analysis of variable binding patterns while Meier's method, as presented, seems somewhat more ad hoc.
Reference: [18] <author> Metcalf, M. and Reid, J., </author> <title> Fortran 90 Explained, </title> <publisher> Oxford Univ. Press, Oxford, </publisher> <year> 1990. </year>
Reference-contexts: In this paper we will write a Prolog array with k elements as (/ t 0 , t 1 , : : : , t k1 /), similar to Fortran 90 <ref> [18] </ref>. If every element t i , 0 i &lt; k, is a d-dimensional array with l elements, we say that this array is d+1-dimensional, otherwise it is one-dimensional. For example, (/(/a, b, c/), (/d, e, f/)/) denotes a two-dimensional 2 fi 3-element array.
Reference: [19] <author> Millroth, H., </author> <title> Reforming Compilation of Logic Programs, </title> <type> Ph.D. Thesis, </type> <institution> Comp. Sci. Dept., Uppsala Univ., Uppsala, </institution> <year> 1990. </year>
Reference-contexts: In comparison our approach is only applicable to range-restricted formulas, but is quite efficient for that case. Two other related works are the methods by Bevemyr, Lindgren & Mill-roth <ref> [9, 19] </ref> and Meier [17] for compiling recursive programs to iterative code. Millroth's method is based on an analysis of variable binding patterns while Meier's method, as presented, seems somewhat more ad hoc.
Reference: [20] <author> Sato, T. and Tamaki, H., </author> <title> First Order Compiler: a Deterministic Logic Program Synthesis Algorithm, </title> <journal> J. Symbolic Computation, </journal> <volume> 8 </volume> <month> 605-627 </month> <year> (1989). </year>
Reference-contexts: Lloyd & Topor [16] have studied transformation methods for running more general quantifier expressions, although their method will `flounder' for some examples that can be run using this method (Lloyd, personal communication). Sato & Tamaki <ref> [20] </ref> have an interpreter that will run more general quantifier expressions although the method is currently not so efficient (Sato, personal communication). In comparison our approach is only applicable to range-restricted formulas, but is quite efficient for that case.
Reference: [21] <author> Schwartz, J., T., Devar, R. B. K., Dubinski, E. and Schonberg, E., </author> <title> Programming with Sets: an Introduction to SETL, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year> <month> 27 </month>
Reference-contexts: He also mentions previous work in Russia. Some authors have studied the use of bounded quantifiers with sets, for example in SETL <ref> [21] </ref> and flogg [11]. Lloyd & Topor [16] have studied transformation methods for running more general quantifier expressions, although their method will `flounder' for some examples that can be run using this method (Lloyd, personal communication).
Reference: [22] <author> Tennent, R. D., </author> <title> Quantification in Algol-like Languages, </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <month> 133-137 </month> <year> (1987). </year>
Reference-contexts: This paper is a significantly extended and slightly revised version of a paper that was presented at the Fourth International Conference on Logic Programming and Automated Reasoning and can be found in its proceedings [4]. 2 Bounded Quantification Following Tennent <ref> [22, 23] </ref> in spirit, we define a quantification to be an expression that has three parts: a quantifier, which is a symbol from a given alphabet of quantifiers, a locally scoped iteration variable, and a body, which is itself an expression. <p> The Common LISP dialect (and some earlier LISP dialects) contains iteration, mapping and reduction constructs that in some cases resemble ours. The idea for using bounded quantification in logic programming was inspired by Tennent's proposed use of them in ALGOL-like languages <ref> [22, 23] </ref>, and also by an exposition of Gries [13]. 11 Conclusions and Future Work An extension of Prolog with bounded quantifications has been proposed.
Reference: [23] <author> Tennent, R. D., </author> <title> Semantics of Programming Languages, </title> <booktitle> Prentice-Hall International, </booktitle> <address> Hemel Hempstead, </address> <year> 1991. </year>
Reference-contexts: This paper is a significantly extended and slightly revised version of a paper that was presented at the Fourth International Conference on Logic Programming and Automated Reasoning and can be found in its proceedings [4]. 2 Bounded Quantification Following Tennent <ref> [22, 23] </ref> in spirit, we define a quantification to be an expression that has three parts: a quantifier, which is a symbol from a given alphabet of quantifiers, a locally scoped iteration variable, and a body, which is itself an expression. <p> The Common LISP dialect (and some earlier LISP dialects) contains iteration, mapping and reduction constructs that in some cases resemble ours. The idea for using bounded quantification in logic programming was inspired by Tennent's proposed use of them in ALGOL-like languages <ref> [22, 23] </ref>, and also by an exposition of Gries [13]. 11 Conclusions and Future Work An extension of Prolog with bounded quantifications has been proposed.
Reference: [24] <author> Turner, D. A., Miranda: </author> <title> a Non-Strict Functional Language with Poly morphic Types, </title> <booktitle> in: Functional Programming Languages and Computer Architecture, </booktitle> <publisher> LNCS 201, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: set quantifiers. (Incidentally, if the requirement that the range formula must contain an iterator as a conjunct is dropped we obtain the equivalent of Prolog's bagof "predicate".) The set and list quantifications are quite similar to the set and list comprehensions that can be found in some functional programming languages <ref> [15, 24] </ref>. A count quantifier, which gives the number of elements for which the range formula is true, can be included but could also be simulated by 23 sum ([i], 1, Z).
Reference: [25] <author> Voronkov, A., </author> <title> Logic Programming with Bounded Quantifiers, </title> <editor> in: A. Voronkov (ed.), </editor> <booktitle> Logic Programming|Proc. Second Russian Conf. on Logic Programming, </booktitle> <publisher> LNCS 592, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Barklund and Millroth [6] and Voronkov <ref> [25, 26] </ref> have proposed bounded quantifications as a computational device for repetition by iteration in logic programs. In this paper we argue for a useful extension of the Prolog programming language with bounded quantifications. <p> The obvious extensions m &lt;_ i &lt;_ n, m &lt; i &lt; n and m &lt; i &lt;_ n should also be recognized as iterators and can be defined in terms of m &lt;_ i &lt; n; we will not discuss them further here. 5 As pointed out by Voronkov <ref> [25, 26] </ref>, it will often be convenient to write unbounded existential quantifications in the bodies of bounded quantifications. (In repetition expressed as a recursive program clauses this is never required. <p> The actual syntax would depend on the syntax for the corresponding concepts in the Prolog system. In a Prolog system having a type system with user-defined discrete types (enumeration types) it would make sense to have iterators corresponding to these. 10 Related Work Voronkov <ref> [25, 26] </ref> has (independently from us) studied bounded quantifiers in logic programming, although from a somewhat different perspective. He introduces a class of generalized logic programs (where program clauses may contain bounded quantifications with list head/tail iterators) and a complete variant of resolution called SLDB-resolution for running them.
Reference: [26] <author> Voronkov, A. A., </author> <title> Logic Programming with Bounded Quantifiers, </title> <type> Tech nical Report ECRC-92-29, </type> <institution> ECRC, Munich, </institution> <year> 1992. </year>
Reference-contexts: 1 Introduction Barklund and Millroth [6] and Voronkov <ref> [25, 26] </ref> have proposed bounded quantifications as a computational device for repetition by iteration in logic programs. In this paper we argue for a useful extension of the Prolog programming language with bounded quantifications. <p> The obvious extensions m &lt;_ i &lt;_ n, m &lt; i &lt; n and m &lt; i &lt;_ n should also be recognized as iterators and can be defined in terms of m &lt;_ i &lt; n; we will not discuss them further here. 5 As pointed out by Voronkov <ref> [25, 26] </ref>, it will often be convenient to write unbounded existential quantifications in the bodies of bounded quantifications. (In repetition expressed as a recursive program clauses this is never required. <p> The actual syntax would depend on the syntax for the corresponding concepts in the Prolog system. In a Prolog system having a type system with user-defined discrete types (enumeration types) it would make sense to have iterators corresponding to these. 10 Related Work Voronkov <ref> [25, 26] </ref> has (independently from us) studied bounded quantifiers in logic programming, although from a somewhat different perspective. He introduces a class of generalized logic programs (where program clauses may contain bounded quantifications with list head/tail iterators) and a complete variant of resolution called SLDB-resolution for running them.
Reference: [27] <author> Warren, D. H. D., </author> <title> An Abstract Prolog Instruction Set, </title> <type> SRI Tech. Note 309, </type> <institution> SRI Intl., Menlo Park, Calif., </institution> <year> 1983. </year> <month> 28 </month>
Reference-contexts: that we intend the machine code for bounded quantifications to form loops, where the code for a body is terminated by a conditional jump back to the beginning, or some variant thereof. 5 The Luther WAM Emulator Our experiments have been conducted in an implementation of Warren's abstract Prolog machine <ref> [27] </ref> which is based on an emulator written in the C programming language [7, 8]. To better understand our code sequences below one ought to know the following. 1. There are two instructions builtin and inline that do the work of various predefined relations, known to the compiler.
References-found: 27

