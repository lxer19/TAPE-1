URL: ftp://ftp.cs.washington.edu/tr/1993/06/UW-CSE-93-06-02.PS.Z
Refering-URL: http://www.cs.washington.edu/homes/pardo/papers.d/aic.html
Root-URL: 
Title: Managing Abstraction-Induced Complexity a slightly different view of what is "most relevant." Thus, although abstractions
Author: David Keppel 
Note: users of the implementation for exactly the same reason: each user has  
Date: June 11, 1993  
Pubnum: UWCSE TR 93-06-02  
Abstract: Abstraction reduces the apparent complexity of an implementation by hiding all but "the most relevant" details. However, no interface is suitable for all the 
Abstract-found: 1
Intro-found: 1
Reference: [ABLL91] <author> Thomas E. Anderson, Brian N. Bershad, Edward D. Lazowska, and Henry M. Levy. </author> <title> Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism. </title> <booktitle> Proceedings of the 13th ACM Symposium on Operating System Principles (SOSP-13), </booktitle> <pages> page 95, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: However, the service must ensure that system security remains intact. Once an operation has been pushed out of the kernel, any of the interface structuring techniques can be applied safely. For example, to handle paging [MA90, HC92] or scheduling <ref> [MVZ91, ABLL91] </ref>. 4 OTHER ISSUES 8 4.3 Hybrid Interfaces The interfaces presented in Section 2 can be combined in various ways to create hybrid interfaces.
Reference: [AL91] <author> Andrew W. Appel and Kai Li. </author> <title> Virtual Memory Primitives for User Programs. </title> <booktitle> Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <pages> pages 96-107, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: A related issue is that different interfaces on a given service may actually provide different services. For example, a VM implementation that signals the client on page faults can be used to implement various kinds of page-based operations such as distributed shared VM <ref> [AL91] </ref>. These operations are not always available with other VM interfaces. 4.2 Protection and Security Bound aries Operating system kernels are a particularly tricky area for open systems because the client cannot inject arbitrary code to run e.g., at full kernel privilege.
Reference: [AS93] <author> Peter M. Athanas and Harvey F. Silver-man. </author> <title> Processor Reconfiguration Through Instruction-Set Metamorphosis. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 11-18, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Even architectures can support an open interface, by allowing either user-programmable microcode or dynamically-configurable hardware <ref> [JF91, Sut91, AS93] </ref>. Branch predication can then use application state such as values in general processor registers, surrounding instructions, etc. Open systems are most successful where it is hard to infer good behavior or define a simple language for tuning.
Reference: [ASU88] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ull-man. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Programming languages often provide adaptive interfaces by allowing a programmer to use fixed abstractions for arrays and procedures, while promising that the translator can perform optimizations that yield efficient implementations. Most programming language implementations discover optimizations statically <ref> [ASU88] </ref>, but some systems collect information based on runtime use of the constructs [DB77, GW78, DS84, CW86, CU91].
Reference: [BLL88] <author> Brian N. Bershad, Edward D. Lazowska, and Henry M. Levy. </author> <title> PRESTO: A System for Object-Oriented Parallel Programming. </title> <journal> Software-Practice and Experience, </journal> <volume> 18(8) </volume> <pages> 713-732, </pages> <year> 1988. </year>
Reference-contexts: Open VM systems are rare because it is hard to safely migrate code from the user space in to the kernel; the issues are discussed further in Section 4.2. An open threads package can provide a primary in terface to create, schedule, and run threads <ref> [BLL88] </ref>, with a meta-control interface that e.g., lets the client reimplement synchronization objects in order to change the way in which threads behave when they block [BLLW88]. Even architectures can support an open interface, by allowing either user-programmable microcode or dynamically-configurable hardware [JF91, Sut91, AS93].
Reference: [BLLW88] <author> Brian N. Bershad, Edward D. Lazowska, Henry M. Levy, and David B. Wagner. </author> <title> An Open Environment for Building Parallel Programming Systems. </title> <type> Technical Report UWCSE 88-01-03, </type> <institution> University of Washington, </institution> <month> January </month> <year> 1988. </year>
Reference-contexts: An open threads package can provide a primary in terface to create, schedule, and run threads [BLL88], with a meta-control interface that e.g., lets the client reimplement synchronization objects in order to change the way in which threads behave when they block <ref> [BLLW88] </ref>. Even architectures can support an open interface, by allowing either user-programmable microcode or dynamically-configurable hardware [JF91, Sut91, AS93]. Branch predication can then use application state such as values in general processor registers, surrounding instructions, etc.
Reference: [CU91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> OOPSLA '91 Proceedings; SIGPLAN Notices, </booktitle> <volume> 26(11) </volume> <pages> 1-15, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Most programming language implementations discover optimizations statically [ASU88], but some systems collect information based on runtime use of the constructs <ref> [DB77, GW78, DS84, CW86, CU91] </ref>. Operating systems provide VM and thread abstrac tions that, at some level, promise to divide machine resources between various parts of a client in a way that reflects the current needs of the client. <p> Array indexing must generally be delayed until runtime. However, if the compiler can deduce information about array indi-cies, it can perform adaptive tuning and produce optimized code at compile time. However, if basic array behavior depends on runtime data values, basic tuning information is best collected at run-time <ref> [DB77, GW78, CW86, CU91, KEH91] </ref>. Implementation details may also affect binding times. For example, it isn't generally possible to statically tune between a client and a dynamically-linked service, since different invocations of the client may use different implementations of the service.
Reference: [CW86] <author> Thomas W. Christopher and Ralph W. Wal-lace. </author> <title> Compiling Optimized Array Operations at Run-Time. </title> <booktitle> APL 86 Conferance Proceedings, </booktitle> <pages> pages 136-141, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Most programming language implementations discover optimizations statically [ASU88], but some systems collect information based on runtime use of the constructs <ref> [DB77, GW78, DS84, CW86, CU91] </ref>. Operating systems provide VM and thread abstrac tions that, at some level, promise to divide machine resources between various parts of a client in a way that reflects the current needs of the client. <p> Array indexing must generally be delayed until runtime. However, if the compiler can deduce information about array indi-cies, it can perform adaptive tuning and produce optimized code at compile time. However, if basic array behavior depends on runtime data values, basic tuning information is best collected at run-time <ref> [DB77, GW78, CW86, CU91, KEH91] </ref>. Implementation details may also affect binding times. For example, it isn't generally possible to statically tune between a client and a dynamically-linked service, since different invocations of the client may use different implementations of the service.
Reference: [DB77] <author> Eric J. Van Dyke and Kenneth A. Van Bree. </author> <title> A Dynamic Incremental Compiler for an Interpretive Language. </title> <journal> Hewlett-Packard Journal, </journal> <pages> pages 17-24, </pages> <month> July </month> <year> 1977. </year>
Reference-contexts: Most programming language implementations discover optimizations statically [ASU88], but some systems collect information based on runtime use of the constructs <ref> [DB77, GW78, DS84, CW86, CU91] </ref>. Operating systems provide VM and thread abstrac tions that, at some level, promise to divide machine resources between various parts of a client in a way that reflects the current needs of the client. <p> Array indexing must generally be delayed until runtime. However, if the compiler can deduce information about array indi-cies, it can perform adaptive tuning and produce optimized code at compile time. However, if basic array behavior depends on runtime data values, basic tuning information is best collected at run-time <ref> [DB77, GW78, CW86, CU91, KEH91] </ref>. Implementation details may also affect binding times. For example, it isn't generally possible to statically tune between a client and a dynamically-linked service, since different invocations of the client may use different implementations of the service.
Reference: [DS84] <author> Peter Deutsch and Alan M. Schiffman. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> 11th Annual Symposium on Principles of Programming Languages (POPL-11), </booktitle> <pages> pages 297-302, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: Most programming language implementations discover optimizations statically [ASU88], but some systems collect information based on runtime use of the constructs <ref> [DB77, GW78, DS84, CW86, CU91] </ref>. Operating systems provide VM and thread abstrac tions that, at some level, promise to divide machine resources between various parts of a client in a way that reflects the current needs of the client.
Reference: [Fat85] <author> Richard Fateman. </author> <type> Personal communication, </type> <year> 1985. </year>
Reference-contexts: Although some clients use the general code only rarely, other clients surely have it as a common case, and those clients suffer for it. Likewise, since the general interface is used only rarely, it is typically poorly-tuned and unreliable <ref> [Fat85] </ref>. * Meta-Control: A third strategy uses two interfaces. Usually the client is concerned with the primary interface that performs operations for the client. Sometimes the client also makes use of a meta-control interface that leaves the primary interface unchanged but changes the way the service operations are implemented.
Reference: [GW78] <author> Leo J. Guibas and Douglas K. Wyatt. </author> <title> Compilation and Delayed Evaluation in APL. </title> <booktitle> Fifth Annual ACM Symposium on Principles of Programming Languages (POPL-5), </booktitle> <pages> pages 1-8, </pages> <year> 1978. </year>
Reference-contexts: Most programming language implementations discover optimizations statically [ASU88], but some systems collect information based on runtime use of the constructs <ref> [DB77, GW78, DS84, CW86, CU91] </ref>. Operating systems provide VM and thread abstrac tions that, at some level, promise to divide machine resources between various parts of a client in a way that reflects the current needs of the client. <p> Array indexing must generally be delayed until runtime. However, if the compiler can deduce information about array indi-cies, it can perform adaptive tuning and produce optimized code at compile time. However, if basic array behavior depends on runtime data values, basic tuning information is best collected at run-time <ref> [DB77, GW78, CW86, CU91, KEH91] </ref>. Implementation details may also affect binding times. For example, it isn't generally possible to statically tune between a client and a dynamically-linked service, since different invocations of the client may use different implementations of the service.
Reference: [HC92] <author> Kieran Harty and David R. Cheriton. </author> <title> Application-Controlled Physical Memory using External Page-Cache Management. </title> <booktitle> Proceedings of the Fifth International Symposium on Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <pages> pages 187-197, </pages> <year> 1992. </year>
Reference-contexts: However, the service must ensure that system security remains intact. Once an operation has been pushed out of the kernel, any of the interface structuring techniques can be applied safely. For example, to handle paging <ref> [MA90, HC92] </ref> or scheduling [MVZ91, ABLL91]. 4 OTHER ISSUES 8 4.3 Hybrid Interfaces The interfaces presented in Section 2 can be combined in various ways to create hybrid interfaces.
Reference: [Hop79] <author> John E. Hopcroft. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The problem is that arbitrary code could compromise security. Checking arbitrary code to ensure it is safe requires a solution to the halting problem <ref> [Hop79] </ref>, and is thus impossible for general-purpose programming languages. One solution is to provide a limited language that can be checked easily. For example, a client can pass the kernel a limited program that tells just the types of values to be moved across a communication channel [TL93].
Reference: [HP90] <author> John L. Hennesy and David A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: Architectures provide adaptive branch prediction, where the hardware keeps information about each branch instruction. When a given instruction is executed, the predictor attempts to update pipeline state in a way that reflects common use of the branch instruction <ref> [HP90, YP92] </ref>. Adaptive systems generally perform well to the extent that they can deduce the needs of the client. However, adaptive systems are only as good as the tuning information that they deduce, and they can lag behind when they rely on past behavior to predict future needs. <p> Architectures often reserve branch opcode bits that the programmer or compiler can use to tell the architecture whether or not a branch is typically taken <ref> [HP90, Sit93] </ref>. The compiler or programmer may have that information when the branch is generated because a certain branch corresponds either to a part of a test for an unusual (e.g., error) case or a part of a test for termination of a loop. <p> On a branch, the hardware updates the program counter, but the client is responsible for updating the pipeline state <ref> [HP90] </ref>. An incomplete service provides "ultimate" flexibility. It does so by providing a simple interface 3 and then both allowing and forcing the client to implement things the service doesn't do well.
Reference: [JF91] <author> Charles Johnson and David L. Fox. </author> <title> The Silicon Palimpsest A Programming Model for Electrically Reconfigurable Processors. </title> <booktitle> Proceedings of the Second and Third Annual Sig-FORTH Workshops March 1991. </booktitle>
Reference-contexts: Even architectures can support an open interface, by allowing either user-programmable microcode or dynamically-configurable hardware <ref> [JF91, Sut91, AS93] </ref>. Branch predication can then use application state such as values in general processor registers, surrounding instructions, etc. Open systems are most successful where it is hard to infer good behavior or define a simple language for tuning.
Reference: [KdRB82] <author> Gregor Kiczales, Jim des Riveres and Daniel G. Bobrow. </author> <title> The Art of the Metaob-ject Protocol. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: An open translator for a program has a default implementation for, say, dense arrays indexed by small integers. A client wanting sparse arrays uses the meta-control interface to modify the compiler to implement sparse array allocation and indexing <ref> [KdRB82, Kic92] </ref>. In a like way, the translator can be augmented with code that examines procedure calls to check for application-specific information that indicates how each procedure call should be implemented [Rod91].
Reference: [KEH91] <author> David Keppel, Susan J. Eggers, and Robert R. Henry. </author> <title> A Case for Runtime Code Generation. </title> <type> Technical Report UWCSE 91-11-04, </type> <institution> University of Washington Department of Computer Science and Engineering, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: An adaptive system that adapts poorly may perform worse than a fixed implementation. Adaptive systems can also perform poorly when the cost of adaptation is more than the overhead cost of using a simpler fixed implementation <ref> [KEH91] </ref>. 3.3 Adjustable Adjustable systems are like adaptive ones that have the tuning mechanism exposed in a meta-control interface. Where the adaptive system deduces and predicts client behavior, an adjustable system simply lets the client tell it what is going to happen. <p> Second, tuning is restricted by the client's view: the client's view may be restricted by protection and security constraints [PS83] or because some information is unavailable e.g., when the client is compiled <ref> [KEH91] </ref>. Second, the client provides code that is specific to the service's implementation, which can cause portability problems. Third, since arbitrary code can be injected in to the service, it can have arbitrary side-effects. <p> Array indexing must generally be delayed until runtime. However, if the compiler can deduce information about array indi-cies, it can perform adaptive tuning and produce optimized code at compile time. However, if basic array behavior depends on runtime data values, basic tuning information is best collected at run-time <ref> [DB77, GW78, CW86, CU91, KEH91] </ref>. Implementation details may also affect binding times. For example, it isn't generally possible to statically tune between a client and a dynamically-linked service, since different invocations of the client may use different implementations of the service.
Reference: [Kep93] <author> David Keppel. QuickThreads: </author> <title> A Threads Building Core. </title> <type> Technical Report UWCSE 93-05-06, </type> <institution> University of Washington, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: Alternatively, the application can perform memory management and I/O explicitly. An incomplete threads package implementation can provide just the basic operations to initialize threads and switch between them, leaving allocation and schedul ing to the client <ref> [Kep93] </ref>. 4 OTHER ISSUES 7 Architectures use branch delay slots to expose underlying pipeline state. On a branch, the hardware updates the program counter, but the client is responsible for updating the pipeline state [HP90]. An incomplete service provides "ultimate" flexibility.
Reference: [Kic92] <author> Gregor Kiczales. </author> <title> Towards a New Model of Abstraction in Software Engineering. </title> <booktitle> Proceedings of the International Workshop on Reflection and Meta-Level Architecture, </booktitle> <pages> pages 1-11, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: 1 INTRODUCTION 2 Since different clients have differing demands, performance problems cannot generally be solved by simple tuning: optimizations for one client are typically pessimizations for some other client. Thus, performance problems are often dealt with using one of three strategies <ref> [Kic92] </ref>: * Fixed: The service provides a good interface and an implementation that is tuned for some subset of the clients. Clients that suffer bad performance are forced to work around the performance restrictions of the service. <p> differing client demands imply drastically different implementations of the interface. * Adjustable: The abstraction includes a meta-control "tuning knob" by which the client can pass usage hints to the services. * Open: The abstraction includes a reflective [Smi84] mechanism by which the client "injects" new code in to the implementation <ref> [Kic92] </ref>. The injected code reimplements key details of the service so they are optimized for the client. * Incomplete: The meta-control and primary interfaces are merged. The service provides only a part of the implementation. The client provides both tuning and missing parts of the service. <p> Fixed implementation are also efficient when the implementation is a good match to the client's use of the service. However, fixed abstractions usually fail either by limiting the operations to those with a consistently good implementation, or by hiding important performance details <ref> [Kic92] </ref>. 3.2 Adaptive Adaptive systems choose an implementation based on the way the client uses the service. That is, differ ent clients make different kinds of requests, and the kinds of requests communicate implicit information that a service can use to perform tuning. <p> An open translator for a program has a default implementation for, say, dense arrays indexed by small integers. A client wanting sparse arrays uses the meta-control interface to modify the compiler to implement sparse array allocation and indexing <ref> [KdRB82, Kic92] </ref>. In a like way, the translator can be augmented with code that examines procedure calls to check for application-specific information that indicates how each procedure call should be implemented [Rod91]. <p> Generally, then, primary interfaces provides a service and the tuning interface maintains the same primary abstraction 3 The interface may itself be fixed, adaptive, adjustable, open, or incomplete. while providing an implementation that provides the service efficiently <ref> [Kic92] </ref>. The implementation can, in fact, be tuned to such a degree that it no longer works for arbitrary inputs. However, any client that tunes a service to that degree is making an implicit contract that it will not take advantage of the changes.
Reference: [KR88] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year> <note> REFERENCES 11 </note>
Reference-contexts: Programming languages often provide a single fixed abstraction for arrays and procedures. For example, C provides arrays that are indexed by small integer values and that are space efficient if the array is used densely <ref> [KR88] </ref>. Clients that want e.g., sparse arrays either suffer poor space efficiency or must build sparse arrays using other language constructs. Straightforward implementations of procedure call and return are simple and effective, but small procedures suffer a substantial procedure call overhead.
Reference: [Lam84] <author> Butler W. Lampson. </author> <title> Hints for Computer System Design. </title> <journal> IEEE Software, </journal> <volume> 1(1) </volume> <pages> 11-28, </pages> <month> Jan-uary </month> <year> 1984. </year>
Reference-contexts: Similarly, if each layer makes some compromises, the compromises can add up, leaving a system that is useless to the client. The tradeoff is usually one of generality vs. efficiency <ref> [Lam84] </ref>. If each layer compromises some performance, the final system has many performance compromises. If each layer compromises some generality, the final system has limited usefulness. Tunable interfaces can help, but care is needed.
Reference: [Rod91] <author> Luis H. Rodriguez, Jr. </author> <title> Coarse-Grained Parallelism using Metaobject Protocols. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1991. </year>
Reference-contexts: In a like way, the translator can be augmented with code that examines procedure calls to check for application-specific information that indicates how each procedure call should be implemented <ref> [Rod91] </ref>. Open VM systems are rare because it is hard to safely migrate code from the user space in to the kernel; the issues are discussed further in Section 4.2.
Reference: [MA90] <author> Dylan McNamee and Katherine Armstrong. </author> <title> Extending the Mach External Pager Interface to Allow User-Level Page Replacement Policies. </title> <type> Technical Report UWCSE 90-09-05, </type> <institution> University of Washington, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: However, the service must ensure that system security remains intact. Once an operation has been pushed out of the kernel, any of the interface structuring techniques can be applied safely. For example, to handle paging <ref> [MA90, HC92] </ref> or scheduling [MVZ91, ABLL91]. 4 OTHER ISSUES 8 4.3 Hybrid Interfaces The interfaces presented in Section 2 can be combined in various ways to create hybrid interfaces.
Reference: [MVZ91] <author> Cathy McCann, Raj Vaswani, and John Za-horjan. </author> <title> A Dynamic Processor Allocation Policy for Multiprogrammed Shared Memory Multiprocessors. </title> <type> Technical Report UWCSE 90-03-02, </type> <institution> University of Washington, </institution> <month> March </month> <year> 1990 </year> <month> (Revised February </month> <year> 1991). </year>
Reference-contexts: However, the service must ensure that system security remains intact. Once an operation has been pushed out of the kernel, any of the interface structuring techniques can be applied safely. For example, to handle paging [MA90, HC92] or scheduling <ref> [MVZ91, ABLL91] </ref>. 4 OTHER ISSUES 8 4.3 Hybrid Interfaces The interfaces presented in Section 2 can be combined in various ways to create hybrid interfaces.
Reference: [Par72] <author> David L. Parnas. </author> <title> On The Criteria To Be Used in Decomposing Systems Into Modules. </title> <journal> Communications of the ACM, </journal> <volume> 5(12), </volume> <month> Decem-ber </month> <year> 1972. </year>
Reference: [Par79] <author> David L. Parnas. </author> <title> Designing Software for Ease of Extension and Contraction. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(2), </volume> <month> March </month> <year> 1979. </year>
Reference: [Par91] <institution> Proceedings of the Symposium on Partial Evaluation and Semantics-Based Program Manipulation. SIGPLAN Notices, </institution> <month> 26(9), September </month> <year> 1991. </year>
Reference-contexts: Second, the paper does not discuss higher-order interfaces; for example, it may be possible to partially-evaluate <ref> [Par91] </ref> richer interfaces in various ways in order to produce each of the interfaces discussed here. Third, this paper discusses performance tuning but does not explore alternative ways of improving the service's performance, such as 3 COMMON EXAMPLES 3 using approximate or probabalistically correct algorithms. <p> In general, tuning information can be derived, communicated, and used at nearly any time. For example, adaptive systems need not wait until program runtime to take advantage of tuning information. Adaptation can take place before program run-time because code can be executed incrementally as information becomes available <ref> [Par91] </ref>. For exam ple, arrays are a service. Array indexing must generally be delayed until runtime. However, if the compiler can deduce information about array indi-cies, it can perform adaptive tuning and produce optimized code at compile time.
Reference: [PS83] <author> J. Peterson and A. Silberschatz. </author> <title> Operating System Concepts. </title> <publisher> Addison Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Most thread abstractions provided by OS kernels adapt to the thread's use of resources, e.g., boosting CPU priority if the 3 COMMON EXAMPLES 5 thread is mostly I/O bound <ref> [PS83] </ref>. Architectures provide adaptive branch prediction, where the hardware keeps information about each branch instruction. When a given instruction is executed, the predictor attempts to update pipeline state in a way that reflects common use of the branch instruction [HP90, YP92]. <p> Second, tuning is restricted by the client's view: the client's view may be restricted by protection and security constraints <ref> [PS83] </ref> or because some information is unavailable e.g., when the client is compiled [KEH91]. Second, the client provides code that is specific to the service's implementation, which can cause portability problems. Third, since arbitrary code can be injected in to the service, it can have arbitrary side-effects.
Reference: [Sit93] <author> Richard L. </author> <title> Sites. Alpha AXP Architecture. </title> <journal> Communications of the ACM (CACM), </journal> <volume> 36(2), </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: Architectures often reserve branch opcode bits that the programmer or compiler can use to tell the architecture whether or not a branch is typically taken <ref> [HP90, Sit93] </ref>. The compiler or programmer may have that information when the branch is generated because a certain branch corresponds either to a part of a test for an unusual (e.g., error) case or a part of a test for termination of a loop. <p> systems are both adaptive and adjustable: Compilers may inline functions using both internal heuristics and programmer directives [Sta89]; VM systems often respond both to dynamic system behavior and to hints provided by applications [Sun90]; architectures often perform branch prediction using both adaptive hardware and tuning bits embedded in the opcodes <ref> [Sit93] </ref>. 4.4 Level of Representation A problem with meta-control interfaces is that they communicate incomplete information. One issue is that the client deals in abstractions and presents tuning information in terms of those abstractions.
Reference: [Smi84] <author> Brian Cantwell Smith. </author> <title> Reflection and semantics in Lisp. </title> <booktitle> 11th Annual ACM Symposium on Principles of Programming Languages (POPL-11), </booktitle> <pages> page 23, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: that it will figure out how to use a "good" implementation, even if differing client demands imply drastically different implementations of the interface. * Adjustable: The abstraction includes a meta-control "tuning knob" by which the client can pass usage hints to the services. * Open: The abstraction includes a reflective <ref> [Smi84] </ref> mechanism by which the client "injects" new code in to the implementation [Kic92]. The injected code reimplements key details of the service so they are optimized for the client. * Incomplete: The meta-control and primary interfaces are merged. The service provides only a part of the implementation.
Reference: [Sta89] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <address> Cambridge, Massachusetts, </address> <month> 12 September </month> <year> 1989. </year>
Reference-contexts: Tuning is often performed using command line flags (-finline-functions), using magic comments (#pragma 1 inline), or using reserved keywords (inline) <ref> [Sta89] </ref>. Operating systems have tuning and scheduling knobs, again because the programmer may have information the OS cannot deduce. For example, the programmer may indicate one memory region is used sequentially, while another is used randomly, while yet a third is used in bursts (e.g., madvise and vadvise [Sun90]). <p> For example, many systems are both adaptive and adjustable: Compilers may inline functions using both internal heuristics and programmer directives <ref> [Sta89] </ref>; VM systems often respond both to dynamic system behavior and to hints provided by applications [Sun90]; architectures often perform branch prediction using both adaptive hardware and tuning bits embedded in the opcodes [Sit93]. 4.4 Level of Representation A problem with meta-control interfaces is that they communicate incomplete information.
Reference: [Sun90] <author> SunOS Reference Manual. </author> <title> Technical Report Part Number 800-1751-10, Sun Microsystems, </title> <type> 2550 Garcia Avenue, </type> <institution> Mountain View, Califor-nia, </institution> <year> 1990. </year>
Reference-contexts: The usual VM abstraction, for instance, promises fixed-sized pages and promises that if memory is used sparsely, only the pages that are used will count towards the client's use of memory <ref> [Sun90] </ref>. Most thread abstractions provided by OS kernels adapt to the thread's use of resources, e.g., boosting CPU priority if the 3 COMMON EXAMPLES 5 thread is mostly I/O bound [PS83]. Architectures provide adaptive branch prediction, where the hardware keeps information about each branch instruction. <p> Operating systems have tuning and scheduling knobs, again because the programmer may have information the OS cannot deduce. For example, the programmer may indicate one memory region is used sequentially, while another is used randomly, while yet a third is used in bursts (e.g., madvise and vadvise <ref> [Sun90] </ref>). Or, a programmer may know either that the client is composed of nearly-independent tasks, or that tasks cooperate closely and thus benefit from gang scheduling. 1 The word "pragma" is derived from "pragmatic". <p> For example, many systems are both adaptive and adjustable: Compilers may inline functions using both internal heuristics and programmer directives [Sta89]; VM systems often respond both to dynamic system behavior and to hints provided by applications <ref> [Sun90] </ref>; architectures often perform branch prediction using both adaptive hardware and tuning bits embedded in the opcodes [Sit93]. 4.4 Level of Representation A problem with meta-control interfaces is that they communicate incomplete information.
Reference: [Sut91] <author> Ivan Sutherland. Personal Communciation, </author> <month> March </month> <year> 1991. </year>
Reference-contexts: Even architectures can support an open interface, by allowing either user-programmable microcode or dynamically-configurable hardware <ref> [JF91, Sut91, AS93] </ref>. Branch predication can then use application state such as values in general processor registers, surrounding instructions, etc. Open systems are most successful where it is hard to infer good behavior or define a simple language for tuning.
Reference: [TL93] <author> Chandramohan A. Thekkath and Henry M. Levy. </author> <title> Limits to Low Latency Communication on High-Speed Networks. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(2), </volume> <month> May </month> <year> 1993. </year>
Reference-contexts: One solution is to provide a limited language that can be checked easily. For example, a client can pass the kernel a limited program that tells just the types of values to be moved across a communication channel <ref> [TL93] </ref>. A simpler language is easier to check but less expressive. The simplest languages are simply tuning parameters. A second solution is to cross protection boundaries each time the injected code is invoked.
Reference: [YP92] <author> Tse-Yu Yeh and Yale N. Patt. </author> <title> A Comprehensive Instruction Fetch Mechanism for a Processor Supporting Speculative Execution. </title> <booktitle> Proceedings of Micro-25 (0-8186-3175-9/92, IEEE), </booktitle> <year> 1992. </year>
Reference-contexts: Fixed abstrac tions allow clients to perform branches without worrying about implementation details of how the processor pipeline is updated. Performance is typically good if branches are rare or the pipeline is short, but performance suffers with deep pipelines and frequent branches <ref> [YP92] </ref>. Fixed abstractions are generally simple to implement and use. They also provide control over just the operations that the client wants performed. Fixed implementation are also efficient when the implementation is a good match to the client's use of the service. <p> Architectures provide adaptive branch prediction, where the hardware keeps information about each branch instruction. When a given instruction is executed, the predictor attempts to update pipeline state in a way that reflects common use of the branch instruction <ref> [HP90, YP92] </ref>. Adaptive systems generally perform well to the extent that they can deduce the needs of the client. However, adaptive systems are only as good as the tuning information that they deduce, and they can lag behind when they rely on past behavior to predict future needs.
References-found: 36

