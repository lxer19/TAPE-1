URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1994/GIT-CC-94-12.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.94.html
Root-URL: 
Email: fkristian,leomarkg@cc.gatech.edu csj@iesd.auc.dk  
Title: Efficient Differential Timeslice Computation  
Author: Kristian Torp Leo Mark Christian S. Jensen 
Keyword: Transaction-time, data models, snapshots, timeslice, indexing, incremental computation.  
Date: February 19, 1994  
Address: Georgia, GA 30332, USA Aalborg University Fredrik Bajers Vej 7E DK-9220 Aalborg DENMARK  
Affiliation: College of Computing Department of Mathematics Georgia Institute of Technology and Computer Science  
Abstract: Due to the large size of transaction-time relations, it is advantageous to utilize cheap write-once storage media for storage. This is facilitated by adopting a log-based storage structure. Timeslices, i.e., relation states or snapshots, are computed by traversing the logs, using previously computed and cached timeslices as outsets. When computing a new timeslice, the cache will contain two candidate outsets: an earlier outset and a later outset. We provide efficient means of always picking the optimal one. Specifically, we define and investigate the use of a new data structure, the B + -tree-like Insertion Tree (I-tree), for this purpose. The cost of using an I-tree for picking the optimal outset is similar to that of using a B + -tree. Being sparse, I-trees require little space overhead, and they are cheap to maintain as the underlying relations are updated. I-trees also provide a basis for precisely and efficiently estimating the costs of performing timeslices in advance. This is useful for query optimization and can be essential in real-time applications. Finally, it is demonstrated how I-trees can be used in the computation of other types of queries. 
Abstract-found: 1
Intro-found: 1
Reference: [AB 80] <author> Michel E. Adiba and Bruce G. Lindsay. </author> <title> Database Snapshots. </title> <booktitle> Proceedings of the Sixth International Conference on Very Large Databases pp. </booktitle> <pages> 86-91, </pages> <year> 1980 </year>
Reference-contexts: The timeslice R (t), of a relation R at time t now, is the snapshot state of the relation R as of time t <ref> [AB 80] </ref>. The transaction-time data model used in this paper is the backlog model [JM 92]. In this model, a backlog is generated and maintained by the system for each relation defined in the database schema.
Reference: [AS 88] <author> Ilsoo Ahn and Richard Snodgrass. </author> <title> Partitioned Storage for Temporal Databases. </title> <journal> IEEE Transaction on Information Systems, </journal> <volume> Vol. 13, No. 4, </volume> <pages> pp. 369-391, </pages> <year> 1988 </year>
Reference: [BCL 89] <author> Jose A. Blakeley, Neil Coburn, </author> <title> and Per -Ake Larson Updating Derived Relations: Detecting Irrelevant and Autonomously Computable Updates. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol 14, No 3, </volume> <pages> pp. 369-400, </pages> <year> 1989 </year>
Reference: [BLT 86] <author> Jose A. Blakeley, Per -Ake Larson, and Frank W. Tompa. </author> <title> Efficiently Updating Mate rialized Views. </title> <booktitle> Proceedings of the ACM SIGMOD '86, </booktitle> <pages> pp. 61-71, </pages> <year> 1986 </year>
Reference: [BM 93] <author> Lars Bkgaard and Leo Mark. </author> <title> Incremental Evaluation of Time-Varying Queries Us ing Predicate Caches. </title> <type> Technical report CS-TR-2912, </type> <institution> UMIACS-TR-92-64, Department of Computer Science, University of Maryland, College Park, MD 20742, </institution> <month> June </month> <year> 1992 </year>
Reference: [CSLLM 90] <author> Michael Carey, Eugene Shekita, George Lapis, Bruce Lindsay, and John McPher son. </author> <title> An Incremental Join Attachment for Starburst, </title> <institution> Computer Sciences Department, University of Wisconsin | Madison, </institution> <type> Technical report, no 937, </type> <year> 1990 </year>
Reference: [DWB 86] <author> S.M. Downs, M.G. Walker, and R.L. Blum. </author> <title> Automated Summarization of On-line Medical Records. </title> <institution> Stanford Memo, KSL-86-6 Stanford University, </institution> <year> 1986 </year>
Reference-contexts: Database systems supporting transaction time are useful in a wide range of applications, including accounting and banking, where transactions on accounts are stored, as well as in many other systems where audit trails are important [EN 89]. Applications also include the management of medical records, etc. <ref> [DWB 86] </ref>. Recent and continuing advances in hardware have made the storage of ever-growing and potentially huge transaction-time databases a practical possibility. As a result, significant effort has recently been devoted to this topic see, e.g. [RS 87, McK 86, SS 88, Soo 91].
Reference: [EN 89] <author> R. Elmasri and S. B. Navathe. </author> <title> Fundamentals of Database Systems. </title> <publisher> The Ben jamin/Cummings Publishing Company Inc. </publisher> <address> ISBN 0-8053-0145-3, </address> <year> 1989 </year>
Reference-contexts: Database systems supporting transaction time are useful in a wide range of applications, including accounting and banking, where transactions on accounts are stored, as well as in many other systems where audit trails are important <ref> [EN 89] </ref>. Applications also include the management of medical records, etc. [DWB 86]. Recent and continuing advances in hardware have made the storage of ever-growing and potentially huge transaction-time databases a practical possibility.
Reference: [EWK 93] <author> Ramez Elmasri, Gene T.J. Wuu, and Vram Kouramaijian. </author> <title> The Time Index and the Monotonic B + -tree. In Temporal Databases Theory, Design and Implementation. </title> <publisher> The Benjamin/Cummings Publishing Company Inc. ISBN 0-8053-2413-5, </publisher> <pages> pp. 433-456, </pages> <year> 1993 </year>
Reference-contexts: We then describe the structure of the I-tree and show how the tree is maintained during insertions to backlogs. 3.1 Related Work The I-tree is a degenerate B + -tree similar to and inspired by the Monotonic B + -tree (MB-tree) <ref> [EWK 93] </ref> and the Append-only tree (AP-tree) [GS 93]. The I-tree is specifically designed to index monotonically increasing values. If a regular B + -tree was used for this, the nodes would only be approximately 50% full [GS 93]. <p> This inhomogeneity is not necessary for our purposes. Second, internal nodes in the right-most subtree are allocated before they are needed, yielding a space overhead that we can avoid. Third, in the insertion algorithm extra parameters are given to be able to implement a Time Index <ref> [EWK 93] </ref>. This extra generality makes the insertion algorithm more complicated. The AP-tree has not been used for three reasons. First, all pointers between nodes in the AP-tree are double pointers. For our problem, single pointers will do. <p> In Figure 4, the right-most chain consists of the root, the boldface pointer, and the right-most leaf, termed the current node. The array is a dynamic array containing pointers to all nodes in the right-most chain <ref> [EWK 93] </ref>. These pointers are used when insertions are made to the tree. In Figure 4 Position 0 of the array points to 6 and Position 1 points to 5. The numbers 5 and 6 refer to the numbers shown above the right corner of each node.
Reference: [GS 93] <author> Himawan Gunadhi and Arie Segev. </author> <title> Efficient Indexing Methods for Temporal Rela tions. </title> <journal> IEEE Transaction On Knowledge and Data Engineering Vol.5 No. </journal> <volume> 3, </volume> <pages> pp. 496-509, </pages> <month> June </month> <year> 1993 </year>
Reference-contexts: We then describe the structure of the I-tree and show how the tree is maintained during insertions to backlogs. 3.1 Related Work The I-tree is a degenerate B + -tree similar to and inspired by the Monotonic B + -tree (MB-tree) [EWK 93] and the Append-only tree (AP-tree) <ref> [GS 93] </ref>. The I-tree is specifically designed to index monotonically increasing values. If a regular B + -tree was used for this, the nodes would only be approximately 50% full [GS 93]. <p> + -tree similar to and inspired by the Monotonic B + -tree (MB-tree) [EWK 93] and the Append-only tree (AP-tree) <ref> [GS 93] </ref>. The I-tree is specifically designed to index monotonically increasing values. If a regular B + -tree was used for this, the nodes would only be approximately 50% full [GS 93]. Several other indexes may be used to index monotonically increasing key values; for an overview, please see [T 93]. Here, we simply describe why we have defined a new index instead of adopting any of the two most closely related indices, the MB-tree and the AP-tree.
Reference: [Jen 91] <author> Christian S. Jensen. </author> <title> Towards the Realization of Transaction Time Database Systems. </title> <type> PhD dissertation, </type> <institution> Technical Report R 91-11 Aalborg University, </institution> <month> March </month> <year> 1991 </year>
Reference-contexts: Note that it is straightforward to locate these cached timeslices; for example, a B + -tree on the times of the timeslices can be used. The problem of query matching when more general queries may be cached for reuse is addressed elsewhere <ref> [Rou 91, Jen 91] </ref> . This paper addresses the problem of how to efficiently determine whether incremental computation, using the earlier timeslice, or decremental computation, using the later timeslice, is most cost-efficient. The idea of differential computation of timeslices is shown in Figure 3. <p> Generally all queries which count the total number of change requests in a transaction time interval can be converted to exact-position queries. This also applies to time-varying queries, the moving window operator [NA 93] and the -operator <ref> [JMR 91, Jen 91] </ref>. Details can be found in [TMJ 94]. 6 Summary and Future Research In this paper we have taken one step in the direction of realizing a global query optimizer for temporal queries.
Reference: [JM 92] <author> Christian S. Jensen and Leo Mark. </author> <title> Queries on Change in an Extended Relational Model. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> Vol 4, No 2, </volume> <month> April </month> <year> 1992, </year> <pages> pp. 192-200 </pages>
Reference-contexts: The timeslice R (t), of a relation R at time t now, is the snapshot state of the relation R as of time t [AB 80]. The transaction-time data model used in this paper is the backlog model <ref> [JM 92] </ref>. In this model, a backlog is generated and maintained by the system for each relation defined in the database schema. The change requests (i.e., inserts and deletes) to a relation are appended to its backlog. A relation is derived from a backlog by using the timeslice operator.
Reference: [JMR 91] <author> Christian S. Jensen, Leo Mark, and Nick Roussopoulos. </author> <title> Incremental Implementation Model of Relational Database with Transaction time. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> Vol 3, No 4, </volume> <month> December </month> <year> 1991, </year> <pages> 461-473. </pages>
Reference-contexts: Generally all queries which count the total number of change requests in a transaction time interval can be converted to exact-position queries. This also applies to time-varying queries, the moving window operator [NA 93] and the -operator <ref> [JMR 91, Jen 91] </ref>. Details can be found in [TMJ 94]. 6 Summary and Future Research In this paper we have taken one step in the direction of realizing a global query optimizer for temporal queries.
Reference: [JM 93] <author> Christian S. Jensen and Leo Mark. </author> <title> Differential Query Processing in Transaction Time Databases. In Temporal Databases Theory, Design and Implementation. </title> <publisher> The Benjamin/Cummings Publishing Company Inc. ISBN 0-8053-2413-5, </publisher> <pages> pp. </pages> <month> 457-491 , </month> <year> 1993 </year>
Reference-contexts: A formal definition of the timeslice operator is given next <ref> [JM 93] </ref>. Let R be a relation having attributes A 1 , A 2 , . . ., A n where Key, a time-invariant key, is one of these.
Reference: [LHMPW 86] <author> Bruce Lindsay, Laura Hass, C. Mohan, Hamid Pirahesh, and Paul Wilms. </author> <title> A Snap shot Differential Refresh Algorithm. </title> <booktitle> Proceedings of the ACM SIGMOD '86, </booktitle> <pages> pp 53-60, </pages> <year> 1986 </year>
Reference: [LJ 88] <author> Nikos A. Lorentzos and Roger G. Johnson. </author> <title> Extending Relational Algebra to Manipu late Temporal Data. </title> <journal> Information Systems Vol. </journal> <volume> 13, </volume> <pages> No.3 pp. </pages> <month> 289-296 </month> <year> 1988 </year>
Reference: [McK 86] <author> E. </author> <title> McKenzie Bibliography: Temporal Database. </title> <journal> SIGMOD, </journal> <volume> Vol 15, No 4, </volume> <pages> pp. 40-52, </pages> <year> 1986. </year>
Reference-contexts: Applications also include the management of medical records, etc. [DWB 86]. Recent and continuing advances in hardware have made the storage of ever-growing and potentially huge transaction-time databases a practical possibility. As a result, significant effort has recently been devoted to this topic see, e.g. <ref> [RS 87, McK 86, SS 88, Soo 91] </ref>. Research focus is moving from conceptual data modeling aspects to implementation-related aspects .
Reference: [NA 93] <author> Shamkant B. </author> <title> Navathe and Rafi Ahmed Temporal Extensions to the Relational Model and SQL. In Temporal Databases Theory, Design and Implementation. </title> <publisher> The Ben-jamin/Cummings Publishing Company Inc. ISBN 0-8053-2413-5, </publisher> <pages> pp. 92-109, </pages> <year> 1993 </year>
Reference-contexts: Generally all queries which count the total number of change requests in a transaction time interval can be converted to exact-position queries. This also applies to time-varying queries, the moving window operator <ref> [NA 93] </ref> and the -operator [JMR 91, Jen 91]. Details can be found in [TMJ 94]. 6 Summary and Future Research In this paper we have taken one step in the direction of realizing a global query optimizer for temporal queries.
Reference: [RS 87] <author> L. Rowe,and M. Stonebraker. </author> <title> The POSTGRES Papers. </title> <institution> UCB/ERL M86/85, Univer sity of California, Berkeley, </institution> <address> CA, </address> <year> 1987 </year>
Reference-contexts: Applications also include the management of medical records, etc. [DWB 86]. Recent and continuing advances in hardware have made the storage of ever-growing and potentially huge transaction-time databases a practical possibility. As a result, significant effort has recently been devoted to this topic see, e.g. <ref> [RS 87, McK 86, SS 88, Soo 91] </ref>. Research focus is moving from conceptual data modeling aspects to implementation-related aspects .
Reference: [Rou 91] <author> Nicholas Roussopoulos. </author> <title> An Incremental Access Method of ViewCache: Concept, Al gorithms, and Cost Analysis. </title> <journal> ACM Transaction on Database Systems, </journal> <volume> Vol 16 No. 3, </volume> <pages> pp. 535-563, </pages> <month> September </month> <year> 1991 </year>
Reference-contexts: The results of previously computed timeslices are saved in view pointer caches <ref> [Rou 91] </ref>. A view pointer cache is a stored data structure containing a collection of pointers to change requests needed to materialize the result of the corresponding timeslice. <p> Note that it is straightforward to locate these cached timeslices; for example, a B + -tree on the times of the timeslices can be used. The problem of query matching when more general queries may be cached for reuse is addressed elsewhere <ref> [Rou 91, Jen 91] </ref> . This paper addresses the problem of how to efficiently determine whether incremental computation, using the earlier timeslice, or decremental computation, using the later timeslice, is most cost-efficient. The idea of differential computation of timeslices is shown in Figure 3.
Reference: [Sch 77] <author> B. Schueler. </author> <title> Update Reconsidered. </title> <editor> In G. M. Nijssen (ed.) </editor> <title> Architecture and Models in Data Base Management Systems. </title> <publisher> North Holland Publishing Co, </publisher> <year> 1977. </year>
Reference-contexts: Research focus is moving from conceptual data modeling aspects to implementation-related aspects . In order to make transaction-time systems practical, the hardware advances must be combined with advances in query processing techniques. 1 An essential operator in transaction-time databases is the timeslice operator <ref> [Sch 77] </ref>. The timeslice R (t), of a relation R at time t now, is the snapshot state of the relation R as of time t [AB 80]. The transaction-time data model used in this paper is the backlog model [JM 92].
Reference: [SG 89] <editor> Arie Segev and Himawan Gunadhi Event-Join Optimization in Temporal Relational Databases. </editor> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Data Bases, </booktitle> <pages> pp. 205-215, </pages> <address> Amsterdam 1989 </address>
Reference: [SA 85] <author> R. Snodgrass and Ahn, I. </author> <title> A Taxonomy of Time in Database. </title> <booktitle> ACM SIGMOD, </booktitle> <pages> pp. 235-246, </pages> <year> 1985 </year>
Reference-contexts: 1 Introduction A transaction-time database records the time when each stored tuple is current in the database, and it thus records the history of the database <ref> [SA 85] </ref>. Database systems supporting transaction time are useful in a wide range of applications, including accounting and banking, where transactions on accounts are stored, as well as in many other systems where audit trails are important [EN 89]. Applications also include the management of medical records, etc. [DWB 86].
Reference: [Sno 92] <author> Richard T. Snodgrass. </author> <title> Temporal Databases In A.U. </title> <editor> Frank, I. Campari, and U. For mentini (Eds.) </editor> <title> Theories and Methods of Spatio-Temporal Reasoning In Geographic Space. Springer-Verlag, </title> <booktitle> Lecture Notes in Computer Science 639, </booktitle> <pages> pp. 22-64, </pages> <year> 1992 </year> <month> 14 </month>
Reference-contexts: Finally, Section 5 shows other situations where the I-tree can be used. Section 6 briefly summarizes the paper and points to directions for future research. 2 Implementation Model for Transaction-Time Databases Several data models support transaction-time; for a recent survey, please see <ref> [Sno 92] </ref>. In this paper we have chosen the backlog data model because it is a very simple first normal form data model and because the simple query language has a formal semantics based on the relational algebra [Sno 92]. 2 2.1 Backlog and Cache For each relation R defined in <p> Databases Several data models support transaction-time; for a recent survey, please see <ref> [Sno 92] </ref>. In this paper we have chosen the backlog data model because it is a very simple first normal form data model and because the simple query language has a formal semantics based on the relational algebra [Sno 92]. 2 2.1 Backlog and Cache For each relation R defined in the database schema, the database system generates and maintains a backlog B R . A backlog B R is a relation which contains the entire history of change requests to the relation R. <p> The table below shows examples of how many change request can be appended to the backlog for each I-tree I/O operation, for different realistic page sizes. It is assumed that transaction timestamps occupy 64 bits <ref> [Sno 92] </ref>, pointers (Unix) 32 bits, and change requests 128 bytes.
Reference: [Soo 91] <author> M.D. Soo. </author> <title> Bibliography on Temporal Databases. </title> <journal> SIMMOD, </journal> <volume> Vol 20, No 1, </volume> <pages> pp. 14-23, </pages> <year> 1991 </year>
Reference-contexts: Applications also include the management of medical records, etc. [DWB 86]. Recent and continuing advances in hardware have made the storage of ever-growing and potentially huge transaction-time databases a practical possibility. As a result, significant effort has recently been devoted to this topic see, e.g. <ref> [RS 87, McK 86, SS 88, Soo 91] </ref>. Research focus is moving from conceptual data modeling aspects to implementation-related aspects .
Reference: [SS 88] <author> R. Stam and R. Snodgrass. </author> <title> A Bibliography on Temporal Databases. </title> <journal> Database Engi neering, </journal> <volume> Vol 7, No 4, </volume> <pages> pp. 231-239, </pages> <year> 1988 </year>
Reference-contexts: Applications also include the management of medical records, etc. [DWB 86]. Recent and continuing advances in hardware have made the storage of ever-growing and potentially huge transaction-time databases a practical possibility. As a result, significant effort has recently been devoted to this topic see, e.g. <ref> [RS 87, McK 86, SS 88, Soo 91] </ref>. Research focus is moving from conceptual data modeling aspects to implementation-related aspects .
Reference: [Sto 87] <author> Michael Stonebaker. </author> <title> The Design of The Postgres Storage System. </title> <booktitle> In Proceedings of the 13th international conference on Very Large Data Bases, </booktitle> <pages> pp. 289-300, </pages> <year> 1987 </year>
Reference: [T 93] <author> Tansel et al. </author> <title> Temporal Database, Theory Design and Implementation. </title> <publisher> The Ben jamin/Cummings Publishing Company Inc. </publisher> <address> ISBN 0-8053-2413-5, </address> <year> 1993 </year>
Reference-contexts: The I-tree is specifically designed to index monotonically increasing values. If a regular B + -tree was used for this, the nodes would only be approximately 50% full [GS 93]. Several other indexes may be used to index monotonically increasing key values; for an overview, please see <ref> [T 93] </ref>. Here, we simply describe why we have defined a new index instead of adopting any of the two most closely related indices, the MB-tree and the AP-tree. The MB-tree has not been used for three reasons.
Reference: [TMJ 94] <author> Kristian Torp, Leo Mark, and Christian S. Jensen. </author> <title> Efficient Differential Timeslice Computation in Transaction Time Databases. </title> <type> Technical Report, </type> <institution> Georgia Tech 1994. </institution>
Reference-contexts: Similarly, to decrementally "down-date" R (t x+1 ) to R (t x ) the change requests between C and B must be traversed. Algorithms for incremental and decremental computation of timeslices may be found in <ref> [TMJ 94] </ref>. 3 I-trees In this section, we first review related work on indices and explain why a new index is needed. <p> Generally all queries which count the total number of change requests in a transaction time interval can be converted to exact-position queries. This also applies to time-varying queries, the moving window operator [NA 93] and the -operator [JMR 91, Jen 91]. Details can be found in <ref> [TMJ 94] </ref>. 6 Summary and Future Research In this paper we have taken one step in the direction of realizing a global query optimizer for temporal queries.
Reference: [TMJ 94a] <author> Kristian Torp, Leo Mark, and Christian S. Jensen. </author> <title> Temporal Indexes for Transaction Time Databases. </title> <note> In preparation. </note>
Reference-contexts: The algorithm that formed the basis for implementing the I-tree is given elsewhere <ref> [TMJ 94a] </ref>. 1. Figure 5A shows an example of the general case where the whole tree is completely full and balanced. The key value 17 must be inserted. A new leaf is created and the new value inserted.
Reference: [Ull 82] <author> Jeffery D. Ullman. </author> <title> Principles of Database Systems. </title> <journal> Volume of Computer Software Engineering Series, </journal> <note> Computer Science Press, second edition, 1982 15 </note>
References-found: 31

