URL: http://www-cad.eecs.berkeley.edu/Respep/Research/mocha/manual.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/Respep/Research/mocha/user_doc.html
Root-URL: http://www.cs.berkeley.edu
Email: alur@cis.upenn.edu  fdealfaro,tah,krishnan,fmang,shaz,sriramr,serdarg@eecs.berkeley.edu  
Title: Mocha User Manual  
Author: R. Alur L. deAlfaro T.A. Henzinger S.C. Krishnan F.Y.C. Mang S. Qadeer S.K. Rajamani S. Ta~sran 
Web: www.eecs.berkeley.edu/mocha  
Address: Philadelphia  Berkeley  
Affiliation: Computer and Information Science Department University of Pennsylvania,  Electrical Engineering and Computer Sciences Department University of California,  
Abstract-found: 0
Intro-found: 1
Reference: [AH96] <author> R. Alur and T.A. Henzinger. </author> <title> Reactive modules. </title> <booktitle> In Proceedings of the 11th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 207-218. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year>
Reference-contexts: Introduction We describe a new interactive verification environment called Mocha for the modular verification of heterogeneous systems. Mocha differs from many existing model checkers in three significant ways: * For modeling, we replace unstructured state-transition graphs with the heterogeneous modeling framework of reactive modules <ref> [AH96] </ref>. The definition of reactive modules is inspired by formalisms such as Unity [CM88], I/O automata [Lyn96], and Esterel [BG88], and allows complex forms of interaction between components within a single transition. Reactive modules provide a semantic glue that allows the formal embedding and interaction of components with different characteristics. <p> However, typically both the implementation P and the specification Q consist of the parallel composition of several modules, in which case it may be possible to reduce the problem of checking if P Q to several subproblems that involve smaller state spaces. The assume-guarantee rule for reactive modules <ref> [AH96] </ref> allows us to conclude P Q as long as each component of the specification Q is refined by the corresponding components of the implementation P within a suitable environment. The following proposition gives a slightly generalized account of the assume-guarantee rule.
Reference: [AH97] <author> R. Alur and T.A. Henzinger. </author> <title> Modularity for timed and hybrid systems. </title> <booktitle> In CONCUR 97: Proceedings of the 8th International Conference on Concurrency Theory, Lecture Notes in Computer Science 1243, </booktitle> <pages> pages 74-88. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Freeing syminfo for both specification and implementation Deleting intermediate specification and implementation Compositional refinement step successful 82 Chapter 7 Real-Time Modules 7.1 Describing Systems with Real-Time Modules Mocha supports reachability analysis and invariant checking of real-time systems that are described in the form of timed reactive modules as defined in <ref> [AH97] </ref>. In addition to the discrete-valued variables of reactive modules, a timed module makes use real-valued (IR) clock variables. The purpose of clock variables is to keep track of elapsed time. Guarded commands can assign integer values to clock variables, and guards can depend on values of clock variables. <p> This is adequate for modeling the behavior of physical systems. In [HMP92], it is proven that, with this restriction, for each trace fl of a timed module, there exists a 2 For a precise treatment of the semantics of timed modules, refer to <ref> [AH97] </ref> 84 module RealTimeGate external arrive:bool interface pc:fopen,closing,closedg private y:clock atom controls pc,y reads pc,y,arrive awaits arrive init []true -&gt; pc':=open update []pc=open&arrive' -&gt; pc':=closing; y':=0 []pc=closing&y&gt;= 1 -&gt; pc':=closed; y':=0 []pc=closed&y&gt;= 7 -&gt; pc':=open wait []pc=open&~arrive' -&gt; []pc=closing&y&lt;= 2 -&gt; y':&lt;= 2 []pc=closed&y&lt;= 7 -&gt; y':&lt;= 7 endatom endmodule trace
Reference: [AHK97] <author> R. Alur, T.A. Henzinger, and O. Kupferman. </author> <title> Alternating-time temporal logic. </title> <booktitle> In Proceedings of the 38th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 100-109. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1997. </year>
Reference-contexts: Some modules may be synchronous, others asynchronous, some may represent hardware, others software, some may be speed-independent, others time-critical. * For requirement specification, we replace the system-level specification languages of linear and branching temporal logics [Pnu77, CE81] with the module-level specification language of Alternating Temporal Logic (ATL) <ref> [AHK97] </ref>. In ATL, both cooperative and adversarial relationships between modules can be expressed. <p> This is specified by the invariant: ~((pc1 = inCS) &(pc2 = inCS)) 4.2 Alternating-time temporal logic We briefly discuss how to specify Alternating Temporal Logic (ATL) formulas in Mocha. The reader is referred to <ref> [AHK97] </ref> for an introduction to this logic. ATL is a generalization of the temporal logic CTL [CE81]. <p> The temporal logic ATL is designed to write requirements of open systems <ref> [AHK97] </ref>, and is defined by generalizing the existential and universal path quantifiers of CTL. For instance, let be a set of agents corresponding to different components of the system and 56 the external environment.
Reference: [AHR98] <author> R. Alur, T.A. Henzinger, and S.K. Rajamani. </author> <title> Symbolic exploration of transition hierarchies. </title> <editor> In B. Steffen, editor, </editor> <booktitle> TACAS 98: Tools and Algorithms for Construction and Analysis of Systems, Lecture Notes in Computer Science 1384, </booktitle> <pages> pages 330-344. </pages> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: For this purpose, reactive modules provide assume-guarantee rules [HQR98] and abstraction operators <ref> [AHR98] </ref>; Mocha provides algorithms for automatic refinement checking, and will provide a proof editor that manages the decomposition of verification tasks into subtasks. In this report, we describe the toolkit Mocha in which the proposed approach is being implemented.
Reference: [BG88] <author> G. Berry and G. Gonthier. </author> <title> The synchronous programming language esterel: Design, semantics, implementation. </title> <type> Technical Report 842, </type> <institution> INRIA, </institution> <year> 1988. </year>
Reference-contexts: Mocha differs from many existing model checkers in three significant ways: * For modeling, we replace unstructured state-transition graphs with the heterogeneous modeling framework of reactive modules [AH96]. The definition of reactive modules is inspired by formalisms such as Unity [CM88], I/O automata [Lyn96], and Esterel <ref> [BG88] </ref>, and allows complex forms of interaction between components within a single transition. Reactive modules provide a semantic glue that allows the formal embedding and interaction of components with different characteristics.
Reference: [BHSV + 96] <author> R.K. Brayton, G.D. Hachtel, A. Sangiovanni-Vincentelli, F. Somenzi, A. Aziz, S.-T. Cheng, S. Edwards, S. Khatri, Y. Kukimoto, A. Pardo, S. Qadeer, R.K. Ranjan, S. Sarwary, T.R. Shiple, G. Swamy, and T. Villa. </author> <title> VIS: A System for Verification and Synthesis. </title> <editor> In R. Alur and T.A. Henzinger, editors, </editor> <booktitle> CAV 96: Computer Aided Verification, Lecture Notes in Computer Science 1102, </booktitle> <pages> pages 428-432. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: It adopts a software architecture similar to VIS <ref> [BHSV + 96] </ref>, a symbolic model-checking tool from UC Berkeley.
Reference: [CE81] <author> E.M. Clarke and E.A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching-time temporal logic. </title> <booktitle> In Workshop on Logic of Programs, Lecture Notes in Computer Science 131, </booktitle> <pages> pages 52-71. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Some modules may be synchronous, others asynchronous, some may represent hardware, others software, some may be speed-independent, others time-critical. * For requirement specification, we replace the system-level specification languages of linear and branching temporal logics <ref> [Pnu77, CE81] </ref> with the module-level specification language of Alternating Temporal Logic (ATL) [AHK97]. In ATL, both cooperative and adversarial relationships between modules can be expressed. <p> The reader is referred to [AHK97] for an introduction to this logic. ATL is a generalization of the temporal logic CTL <ref> [CE81] </ref>. If p is predicate on the states of a module, then the CTL formula EFp means that a state satisfying p is reached along some execution of the module, while the CTL formula AFp means that a state satisfying p is reached along every execution of the module.
Reference: [CM88] <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1988. </year> <month> 88 </month>
Reference-contexts: Mocha differs from many existing model checkers in three significant ways: * For modeling, we replace unstructured state-transition graphs with the heterogeneous modeling framework of reactive modules [AH96]. The definition of reactive modules is inspired by formalisms such as Unity <ref> [CM88] </ref>, I/O automata [Lyn96], and Esterel [BG88], and allows complex forms of interaction between components within a single transition. Reactive modules provide a semantic glue that allows the formal embedding and interaction of components with different characteristics. <p> The guarded command 17 that specifies a union of actions consists simply of the union of all guarded assign-ments of the individual actions. This style of describing asynchronous programs as an unstructured collection of guarded assignments is pursued in formalisms such as Unity <ref> [CM88] </ref> and Mur' [Dil96]. Write-shared variables. The original formulation of Peterson's protocol uses a single write-shared boolean variable x, whose value always corresponds to the value of the predicate x1 = x2 in our formulation.
Reference: [Dil96] <author> D. L. Dill. </author> <title> The Mur Verification System. </title> <editor> In R. Alur and T.A. Hen--zinger, editors, </editor> <booktitle> CAV 95: Computer Aided Verification, Lecture Notes in Computer Science 1102, </booktitle> <pages> pages 390-393. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The guarded command 17 that specifies a union of actions consists simply of the union of all guarded assign-ments of the individual actions. This style of describing asynchronous programs as an unstructured collection of guarded assignments is pursued in formalisms such as Unity [CM88] and Mur' <ref> [Dil96] </ref>. Write-shared variables. The original formulation of Peterson's protocol uses a single write-shared boolean variable x, whose value always corresponds to the value of the predicate x1 = x2 in our formulation.
Reference: [Exp97] <institution> Expert Interface Technologies. Tix Home Page, </institution> <year> 1997. </year> <note> http://www.xpi.com/tix/index.html. </note>
Reference-contexts: It adopts a software architecture similar to VIS [BHSV + 96], a symbolic model-checking tool from UC Berkeley. Written in C with Tcl/Tk and Tix <ref> [Exp97] </ref>, Mocha can be easily extended in two ways: designers and application developers can customize their application or design their own graphical user interface by writing Tcl scripts; algorithm developers and researchers can develop new verification algorithms by writing C code, or assembling any verification packages through C interfaces.
Reference: [HMP92] <author> T.A. Henzinger, Z. Manna, and A. Pnueli. </author> <title> What good are digital clocks? In ICALP '92: </title> <booktitle> 19th International Colloquium on Automata, Languages, and Programming, Lecture Notes in Computer Science 623, </booktitle> <pages> pages 545-558. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This is adequate for modeling the behavior of physical systems. In <ref> [HMP92] </ref>, it is proven that, with this restriction, for each trace fl of a timed module, there exists a 2 For a precise treatment of the semantics of timed modules, refer to [AH97] 84 module RealTimeGate external arrive:bool interface pc:fopen,closing,closedg private y:clock atom controls pc,y reads pc,y,arrive awaits arrive init []true
Reference: [HQR98] <author> T.A. Henzinger, S. Qadeer, and S.K. Rajamani. You assume, </author> <title> we guarantee: Methodology and case studies. </title> <type> Technical report, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1998. </year>
Reference-contexts: For example, it is possible to specify that a module can attain a goal regardless of how the environment of the module behaves. * For the verification of complex systems, Mocha supports a range of compositional and hierarchical verification methodologies. For this purpose, reactive modules provide assume-guarantee rules <ref> [HQR98] </ref> and abstraction operators [AHR98]; Mocha provides algorithms for automatic refinement checking, and will provide a proof editor that manages the decomposition of verification tasks into subtasks. In this report, we describe the toolkit Mocha in which the proposed approach is being implemented.
Reference: [Lyn96] <author> N.A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: Mocha differs from many existing model checkers in three significant ways: * For modeling, we replace unstructured state-transition graphs with the heterogeneous modeling framework of reactive modules [AH96]. The definition of reactive modules is inspired by formalisms such as Unity [CM88], I/O automata <ref> [Lyn96] </ref>, and Esterel [BG88], and allows complex forms of interaction between components within a single transition. Reactive modules provide a semantic glue that allows the formal embedding and interaction of components with different characteristics.

References-found: 13

