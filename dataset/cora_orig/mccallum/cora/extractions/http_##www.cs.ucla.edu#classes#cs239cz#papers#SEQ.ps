URL: http://www.cs.ucla.edu/classes/cs239cz/papers/SEQ.ps
Refering-URL: http://www.cs.ucla.edu/classes/cs239cz/papers/
Root-URL: http://www.cs.ucla.edu
Email: praveen,miron,raghu@cs.wisc.edu  
Title: SEQ Design and Implementation of a Sequence Database System  
Author: Praveen Seshadri Miron Livny Raghu Ramakrishnan 
Date: 531  
Note: Paper Number  
Address: U.Wisconsin, Madison WI  
Affiliation: Computer Sciences Department  
Abstract: This paper discusses the design and implementation of SEQ, a database system with support for persistent sequence data as well as relational data. Sequence data is common in a variety of application domains, and complex queries over such data arise frequently. SEQ models a sequence as an ordered collection of records. The system supports a declarative sequence query language based on an algebra of query operators, thereby permitting algebraic query optimization and evaluation. This is a fundamental aspect of the SEQ system design and implementation, and is similar in spirit to the support for relational queries in a RDBMS. An the alternative approach implemented in some current database systems is to provide a sequence Abstract Data Type (ADT), with a collection of methods that can be composed to express queries over sequences. We show that this approach can lead to queries that are difficult to express and to optimize, and consequently inefficient to execute. There are four distinct contributions made in this paper. (1) We compare the algebraic and ADT-method approaches to sequence queries using qualitative as well as experimental comparisons. (2) We describe the specification of sequence queries using the SEQUIN query language, and their execution in the SEQ system. (3) We quantitatively demonstrate the importance of various optimization techniques by studying their effect on performance. (4) We present a novel nested design paradigm used in SEQ to combine sequence and relational data. The system design uses a complex object model to freely mix relational and sequence data, while the language design permits declarative queries over both kinds of data. Based on SEQ, we suggest a pragmatic way for existing database systems to incorporate efficient support for sequence data.
Abstract-found: 1
Intro-found: 1
Reference: [AS95] <author> Rakesh Agrawal and Ramakrishnan Srikant. </author> <title> Mining Sequential Patterns. </title> <booktitle> In Proceedings of the IEEE Conference on Data Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: Sequences are also of interest to the data mining and on-line analytical processing (OLAP) communities. There has been some work on mining sequential patterns in databases <ref> [AS95] </ref>, and finding similarity between sequences [FRM94]. In OLAP queries [CCS93], time is often an important dimension of the data, and moving window queries are common. These areas represent possible application domains to which SEQ could perhaps be adapted in the future.
Reference: [BDK92] <editor> F. Bancilhon, C. Delobel, and P. Kanellakis (eds). </editor> <title> Building an Object-Oriented Database System: The Story of O2.. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1992. </year>
Reference-contexts: Most commercial database systems will allow a sequence to be represented as a `blob' which is managed by the system, but interpreted solely by the application program. Some object-oriented systems like O2 <ref> [BDK92] </ref> provide array and list constructs that allow collections of data to be ordered. The object-relational database system Illustra [Ill94a] provides database support for time-series data along with relational data. A time-series is an ADT value implemented as a large array on disk. <p> We intend to eventually support the temporal relational functionality described in the temporal database benchmark [Jen+93]. While most object-oriented database proposals include constructors for complex types like lists and arrays <ref> [VD91, BDK92] </ref>, they can either be treated as collections, or manipulated using a primitive set of methods; no facilities for sequence queries are provided. The work described in [Ric92] is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists. <p> The issues regarding support for ADTs in database systems were explored in [Sto86]. There has been extensive work on nested data models (especially nested relational models [Hul87]), and there is even a commercial database system, UniData [Uni93], based on such a model. Object-oriented systems like O2 <ref> [BDK92] </ref> also support a nested model with composite objects. The recently proposed OQL query language [Cat94] for OO databases allows collection types to be nested, and permits nested queries over them. The entire query is expressed in OQL, and there are few special query constructs for lists.
Reference: [CCS93] <author> E.F. Codd, </author> <title> S.B. Codd, C.T. Salley. Beyond Decision Support. </title> <booktitle> In Computerworld,Vol.27, </booktitle> <address> No.30, </address> <month> 26 July </month> <year> 1993. </year>
Reference-contexts: Sequences are also of interest to the data mining and on-line analytical processing (OLAP) communities. There has been some work on mining sequential patterns in databases [AS95], and finding similarity between sequences [FRM94]. In OLAP queries <ref> [CCS93] </ref>, time is often an important dimension of the data, and moving window queries are common. These areas represent possible application domains to which SEQ could perhaps be adapted in the future. There is much research work related to the E-ADT paradigm.
Reference: [CDF+94] <author> M.J. Carey, D.J. DeWitt, M.J. Franklin, N.E. Hall, M. McAuliffe, J.F. Naughton, D.T. Schuh, M.H. Solomon, C.K. Tan, O. Tsatalos, S. White and M.J. Zwilling. </author> <title> Shoring Up Persistent Objects. </title> <booktitle> In Proceeding of the ACM SIGMOD Conference on Management of Data, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: In addition, the design and implementation of SEQ use a novel paradigm to provide support for both sequences and relations. The implementation of SEQ has been in progress for more than a year. The system uses the SHORE storage manager library <ref> [CDF+94] </ref> for low-level database functionality like buffer management, concurrency control and recovery. The higher levels provide query processing support for relations and sequences. The system is currently at approximately 35,000 lines of C++ code (excluding SHORE) and will eventually be available in the public domain. <p> The server is built on top of a layer of common database utilities that all E-ADTs can use. Code to handle arithmetic and boolean expressions, constant values and functions is part of this layer. The primary portion of the utility layer is the SHORE Storage Manager <ref> [CDF+94] </ref>. SHORE provides facilities for concurrency control, recovery and buffer management for large volumes of data. It also provides a threads package that interacts with the rest of the storage management layers; SEQ uses this package to build a multi-threaded server.
Reference: [CS93] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Query Optimization in the Presence of Foreign Functions. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <pages> pages 526-541, </pages> <year> 1993. </year>
Reference-contexts: We call this the "ADT-method" approach to sequence database support. When a query expression involves the composition of more than one of these methods, little or no inter-function optimization is performed, and each individual method is evaluated separately. We discuss some recent research <ref> [CS93] </ref> that relates to this subject in Section 6.2. We now compare this approach with SEQ, based on the performance comparisons presented in Section 4.5. <p> SEQ on the other hand can consider various alternatives implementations for algebraic operators. Let us consider how a traditional system with ADT-methods could overcome these problems. A recent research proposal suggests that rewrite rules could be specified to consider semantics associated with "foriegn functions" <ref> [CS93] </ref>. The paper proposes that queries involving relations stored outside the DBMS can be optimized using declarative rules that specify how the query can be rewritten into equivalent forms. A similar approach can perhaps be used to rewrite functional expressions into equivalent expressions.
Reference: [CS92] <author> Rakesh Chandra and Arie Segev. </author> <title> Managing Temporal Financial Data in an Extensible Database. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <pages> pages 238-249, </pages> <year> 1992. </year>
Reference-contexts: We now review some research related to this area. Research work directed at modelling time-series data <ref> [SS87, CS92] </ref> provided initial direction to our efforts. The model of a time-series in [SS87] is similar to ours, and an SQL-like language was also proposed; implementation issues were discussed in the context of how the model could be mapped to a relational data model [SS88].
Reference: [Cat94] <author> R.G.G. Cattell, </author> <title> Editor. The Object Database Standard:ODMB-93. </title> <publisher> Morgan-Kaufman Inc., </publisher> <address> Los Altos, CA, </address> <year> 1994. </year>
Reference-contexts: A similar approach can perhaps be used to rewrite functional expressions into equivalent expressions. It is not clear that such an approach would be feasible to implement, or that it would be efficient to optimize and execute. In the OQL language design <ref> [Cat94] </ref>, methods are allowed to have multiple implementations, and the system has the right to choose the best one. <p> There has been extensive work on nested data models (especially nested relational models [Hul87]), and there is even a commercial database system, UniData [Uni93], based on such a model. Object-oriented systems like O2 [BDK92] also support a nested model with composite objects. The recently proposed OQL query language <ref> [Cat94] </ref> for OO databases allows collection types to be nested, and permits nested queries over them. The entire query is expressed in OQL, and there are few special query constructs for lists.
Reference: [DKLPY94] <author> D.J. DeWitt, N. Kabra, J. Luo, J.M. Patel and J. Yu. </author> <title> Client-Server Paradise. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases (VLDB), </booktitle> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: In this section, we describe two of them: the overall data model design, and its instantiation in the system architecture. The specific design for sequence data support is presented in the next section. 3.1 Data Model Design Object-relational systems like Illustra [Ill94a], Paradise <ref> [DKLPY94] </ref>, and Postgres [SRH92] allow an attribute of a relational record to belong to an Abstract Data Type (ADT). Each ADT defines methods that may be invoked on values of that type. An ADT can itself be a structured complex type, with other ADTs nested inside it.
Reference: [MIM94] <institution> Logical Information Machines. MIM User Manual. </institution> <address> 6869 Marshall Road, Dexter, MI 48130. </address>
Reference-contexts: The Order-By clause in SQL only specifies the order in which answers are presented to the user. Much research in the temporal database community has focused on enhancing relational data models with temporal semantics [TCG+93], but there have been few publicly available implementations. Financial management products like MIM <ref> [MIM94] </ref> have created a niche market by building special purpose systems for analyzing stock market data. Main-memory based systems like S-Plus [Sta91] perform statistical analysis of sequences, but these systems are not equipped to handle large quantities of data.
Reference: [FRM94] <author> C. Faloutsos, M. Ranganathan, and Y. Manolopoulos. </author> <title> Fast Subsequence Matching in Time-Series Databases. </title> <booktitle> In Proceeding of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 419-430, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Sequences are also of interest to the data mining and on-line analytical processing (OLAP) communities. There has been some work on mining sequential patterns in databases [AS95], and finding similarity between sequences <ref> [FRM94] </ref>. In OLAP queries [CCS93], time is often an important dimension of the data, and moving window queries are common. These areas represent possible application domains to which SEQ could perhaps be adapted in the future. There is much research work related to the E-ADT paradigm.
Reference: [GJS92] <author> N.H. Gehani, H.V. Jagadish, and O. Shmueli. </author> <title> Composite Event Specification in Active Databases: Model and Implementation. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <pages> pages 327-338, </pages> <year> 1992. </year>
Reference-contexts: The work described in [Ric92] is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists. There have also been languages proposed to match regular patterns over sequence data <ref> [GW89b, GJS92] </ref>, and the proposal of [GJS92] has been implemented as an event recognition system. <p> The work described in [Ric92] is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists. There have also been languages proposed to match regular patterns over sequence data [GW89b, GJS92], and the proposal of <ref> [GJS92] </ref> has been implemented as an event recognition system.
Reference: [GS89b] <author> Himawan Gunadhi and Arie Segev. </author> <title> A framework for query optimization in temporal databases. </title> <booktitle> In Fifth International Conference on Statistical and Scientific Database Management Systems, </booktitle> <year> 1989. </year>
Reference-contexts: In terms of the Figure 1, these operators "view" the sequence mapping from the right (records) to the left (positions). These operators can be directly implemented in a relational database, and several efficient techniques have been proposed for evaluating them in the temporal relational database context <ref> [GS89b, LM90] </ref>. Of greater interest to us, is the other category of Positional operators that concentrate on the relationship between the data records due to their mapping to an ordered domain. These operators "view" the sequence mapping from the left (positions) to the right (records).
Reference: [GW89b] <author> S. Ginsburg and X. Wang. </author> <title> Pattern Matching by Rs-operations: Towards a Unified Approach to Querying Sequenced Data. </title> <booktitle> In Proceeding of the ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1992. </year> <month> 26 </month>
Reference-contexts: The work described in [Ric92] is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists. There have also been languages proposed to match regular patterns over sequence data <ref> [GW89b, GJS92] </ref>, and the proposal of [GJS92] has been implemented as an event recognition system.
Reference: [Hel95] <author> Joseph M. Hellerstein. </author> <title> Optimization and Execution Techniques for Queries With Expensive Methods Ph.D. </title> <type> Thesis, </type> <institution> University of Wisconsin, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: The evaluation of the query can involve many nested evaluations of the embedded query plan. This is similar to the usual evaluation of functions in a language like SQL, and to the nested evaluation of correlated sub-queries in SQL. There are many optimizations like function caching <ref> [Hel95] </ref> and magic decorrelation [SPL94] that have been proposed in those contexts and similar optimizations could be performed in SEQ too. The current implementation, however, uses a simple value-at-a-time nested evaluation. Another issue that arises in the nested design is the granularity at which statistics are maintained. <p> This is useful for computing decay functions over a sequence, and can also be used for recursive pattern match queries (expressing regular patterns). At the level of generic nested E-ADT queries, we believe that there are opportunities for set-oriented optimization using techniques recently proposed for relation query optimization <ref> [SPL94, Hel95] </ref>. This work also has relevance independent of sequence data, because it can be applied to query processing in all languages that support nesting, and to query processing in heterogenous databases.
Reference: [Hul87] <author> Richard Hull. </author> <title> A Survey of Theoretic Research on Typed Complex Database Objects. </title> <editor> In J.Paradeans editor, </editor> <booktitle> Databases, </booktitle> <pages> pages 193-256. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1987. </year>
Reference-contexts: There is much research work related to the E-ADT paradigm. The issues regarding support for ADTs in database systems were explored in [Sto86]. There has been extensive work on nested data models (especially nested relational models <ref> [Hul87] </ref>), and there is even a commercial database system, UniData [Uni93], based on such a model. Object-oriented systems like O2 [BDK92] also support a nested model with composite objects.
Reference: [Ill94a] <institution> Illustra Information Technologies, Inc. </institution> <note> Illustra User's Guide, June 1994. 1111 Broadway, Suite 2000, Oakland, CA 94607. </note>
Reference-contexts: Some object-oriented systems like O2 [BDK92] provide array and list constructs that allow collections of data to be ordered. The object-relational database system Illustra <ref> [Ill94a] </ref> provides database support for time-series data along with relational data. A time-series is an ADT value implemented as a large array on disk. A number of ADT methods are implemented to provide primitive query functionality on a time-series. The methods may be composed to form more complex queries. <p> In this section, we describe two of them: the overall data model design, and its instantiation in the system architecture. The specific design for sequence data support is presented in the next section. 3.1 Data Model Design Object-relational systems like Illustra <ref> [Ill94a] </ref>, Paradise [DKLPY94], and Postgres [SRH92] allow an attribute of a relational record to belong to an Abstract Data Type (ADT). Each ADT defines methods that may be invoked on values of that type. An ADT can itself be a structured complex type, with other ADTs nested inside it. <p> The results are shown in evaluation. As the cost of the common sub-expression increases (i.e., as the window size grows), this optimization becomes extremely important. 4.6 Comparison with the ADT-Method Approach Some current systems like Illustra <ref> [Ill94a] </ref> support sequences (more specifically, time-series) as ADTs with a collection of methods providing query primitives. We call this the "ADT-method" approach to sequence database support. <p> This does not require any optimization across function boundaries. The table below summarizes these points of comparison. Ideally, we would have liked to present a performance comparison with an ADT-method based system to quantitatively demonstrate the effects of the underlying design differences. We chose Illustra <ref> [Ill94a] </ref> for this comparison because it is a commercial database system that provides time-series support using the ADT-method approach, and it uses a time-series model that is similar to our sequence data model. <p> In this section: * We show a real example of how sequence queries are phrased in an existing ADT-method based system (Illustra <ref> [Ill94a] </ref>).
Reference: [Ill95] <institution> Illustra User Support. </institution> <type> Personal Communication. </type> <month> October </month> <year> 1995. </year>
Reference-contexts: FROM S // Input sequence S. WHERE S.field2 &gt; S.field1 // Condition on records. OVER $P-23 TO $P; // Moving window for average. Here is how it would need to be written using ADT methods <ref> [Ill95] </ref>: -- the Filter function gives the filtered time-series, with only those records 22 -- that satisfy the qualification, other positions will be null CREATE function Filter (TimeSeriesOf (ts)) RETURN TimeSeriesOf (one_float) as RETURN PutSet (TimeSeriesCreate (`hours'), (SELECT t, field3 FROM Transpose (ts) WHERE field2 &gt; field1)); -- compute the 24-hour
Reference: [Jen+93] <author> C.S. Jensen, et al. </author> <title> The TSQL Benchmark. </title> <booktitle> In Proceedings of the International Workshop on an Infrastructure for Temporal Databases, </booktitle> <address> Arlington, TX, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa. We intend to eventually support the temporal relational functionality described in the temporal database benchmark <ref> [Jen+93] </ref>. While most object-oriented database proposals include constructors for complex types like lists and arrays [VD91, BDK92], they can either be treated as collections, or manipulated using a primitive set of methods; no facilities for sequence queries are provided.
Reference: [LM90] <author> Cliff T.Y. Leung and Richard R. Muntz. </author> <title> Query Processing for Temporal Databases. </title> <booktitle> In Proceedings of the 6th International Conference on Data Engineering, </booktitle> <address> Los Angeles, CA, </address> <month> February </month> <year> 1990. </year>
Reference-contexts: In terms of the Figure 1, these operators "view" the sequence mapping from the right (records) to the left (positions). These operators can be directly implemented in a relational database, and several efficient techniques have been proposed for evaluating them in the temporal relational database context <ref> [GS89b, LM90] </ref>. Of greater interest to us, is the other category of Positional operators that concentrate on the relationship between the data records due to their mapping to an ordered domain. These operators "view" the sequence mapping from the left (positions) to the right (records).
Reference: [LMS94] <author> A.Y. Levy, I.S. Mumick, and Y. Sagiv. </author> <title> Query Optimization by Predicate Move-Around. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <address> Santiago, Chile, </address> <year> 1994. </year>
Reference-contexts: As the selectivity increases, all the algorithms become more expensive because there is additional work being done in the final count aggregate. 5 Note that this is an important special case of constraint propagation (e.g. [SR93]) and the predicate move-around optimization <ref> [LMS94] </ref> that have been proposed for relational query optimization. 14 The results for at end are shown in Figure 10. The performance of NO PD is the same as in the at start experiment.
Reference: [MV93] <author> D. Maier and B. Vance. </author> <title> A Call to Order. </title> <booktitle> In Proceedings of the ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: As we demonstrate quantitatively in this paper, this observation is indeed valid. As practical guidelines, we also required that our design for adding sequence functionality should allow other kinds of interesting collection types (like trees [SLVZ95] and multi-dimensional arrays <ref> [MV93] </ref>) to be similarly incorporated. Further, the approach we use to support sequence data should ideally be also applicable to other existing database systems (including commercial systems). 3 High-Level System Design We can categorize the design contributions of SEQ into three components.
Reference: [PHH92] <author> Hamid Pirahesh, Joseph Hellerstein, and Waqar Hasan. </author> <title> Extensible/Rule Based Query Rewrite Optimization in Starburst. </title> <booktitle> In Proceedings of ACM SIGMOD '92 International Conference on Management of Data, </booktitle> <address> San Diego, CA, </address> <year> 1992. </year>
Reference-contexts: Although optimizations like function caching and magic decorrelation may help (as discussed in Section 5), there is no denying that there is some truth in this concern. Some systems like Starburst <ref> [PHH92] </ref> perform a number of heuristic query transformations that modify the blocks of a query expressed entirely in SQL. However, it is a fact that even for relational queries in SQL, there is little if any cost-based optimization performed across query blocks. <p> If our future experience with SEQ indicates that important opportunities for cross-E-ADT optimization exist, we might need to augment the interaction between the different E-ADT optimizers (possibly using techniques similar to those of <ref> [PHH92] </ref>). 6 Comparison with Existing Systems An important goal of our work is to find ways to incorporate efficient sequence data support into existing database systems. In this section: * We show a real example of how sequence queries are phrased in an existing ADT-method based system (Illustra [Ill94a]).
Reference: [RS87] <author> L. Rowe and M. Stonebraker. </author> <title> The POSTGRES Data Model. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <address> Brighton, England, </address> <year> 1987. </year>
Reference: [Ric92] <author> Joel Richardson. </author> <title> Supporting Lists in a Data Model. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases(VLDB), </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: While most object-oriented database proposals include constructors for complex types like lists and arrays [VD91, BDK92], they can either be treated as collections, or manipulated using a primitive set of methods; no facilities for sequence queries are provided. The work described in <ref> [Ric92] </ref> is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists. There have also been languages proposed to match regular patterns over sequence data [GW89b, GJS92], and the proposal of [GJS92] has been implemented as an event recognition system.
Reference: [SLR95] <author> Praveen Seshadri, Miron Livny and Raghu Ramakrishnan. SEQ: </author> <title> A Model for Sequence Databases. </title> <booktitle> In Proceedings of the IEEE Conference on Data Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: In earlier work, we described a data model that could describe a wide variety of sequence data, and a query algebra that could be used to represent and optimize queries over sequences <ref> [SLR95] </ref>. In particular, we observed that the execution of queries over sequences could benefit greatly from algebraic optimizations that exploited the order information [SLR94]. In this paper, we address the issues that had to be addressed when building the SEQ sequence database system based on these ideas. <p> However, this data is sequential across days. Administrators might look for seasonality of variations of various kinds of patient visits; this example is based on a real-life application which is described in Appendix A. In <ref> [SLR95] </ref>, we proposed an algebra of query operators that can be used to specify a certain expressive class of sequence queries. Every operator is compositional; it takes sequences as inputs and produces a sequence as the output. The operators are classified into two distinct categories. <p> PROJECT * FROM MovAvgStock1 T1, Offset (MovAvgStock1, 1) T2 WHERE T1.avghigh - T2.avghigh &lt; 10. Figures 15 and 16 show two possible query graphs that can be constructed from this query. The query graphs use operators from the `Positional' sequence algebra described in <ref> [SLR95] </ref>. The meaning of each query graph is 17 obvious. The difference between the two query graphs is that one uses a common sub-expression, while the other doesnt. Common sub-expressions occur frequently in sequence queries, so this is an important issue.
Reference: [SLR94] <author> Praveen Seshadri, Miron Livny and Raghu Ramakrishnan. </author> <title> Sequence Query Processing. </title> <booktitle> In Proceeding of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 430-441, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: In particular, we observed that the execution of queries over sequences could benefit greatly from algebraic optimizations that exploited the order information <ref> [SLR94] </ref>. In this paper, we address the issues that had to be addressed when building the SEQ sequence database system based on these ideas. SEQ is a multi-threaded, client-server database system with support for sequence data as well as relational data. <p> The most basic implementation requirement was that the system should efficiently process queries over large 3 disk-based sequences. We are primarily concerned with supporting queries, though our implementation should also permit updates. Our earlier qualitative observation <ref> [SLR94] </ref> that motivated this entire research should be reiterated here: algebraic query optimization is important for efficiently processing queries over complex collections like sequences. As we demonstrate quantitatively in this paper, this observation is indeed valid. <p> The algebra implementation is extensible, and the query optimizer interacts with the operators through various abstract methods. We have described the algebra operators and the optimization techniques in <ref> [SLR94] </ref>. The query optimizer uses statistics maintained on the sequences to perform some of the optimizations; the 11 statistics include the density of the sequence and the range of valid positions. This section describes the effects of four categories of implemented optimizations. <p> However, all the experimental queries used are components of meaningful queries posed by users who are currently working with SEQ. 4.5.1 Operator Pipelining An important optimization principle in SEQ <ref> [SLR94] </ref> is to try and ensure stream access to the stored sequence data as well as intermediate data; i.e., the sequences are read in a single continuous stream. This is accomplished by associating buffers with each operator, to cache some relevant portion of the most recent data from its inputs. <p> Experiment 4 demonstrates the benefits of propagating such selections into the sequence scans. The other source is from statistics on the valid ranges of positions in each sequence. These valid ranges can be propagated through the entire query as described in <ref> [SLR94] </ref> 5 . Experiment 5 demonstrates how the valid-range can be used for optimization. Experiment 4: PROJECT count (*) // Aggregate to avoid printing answers. FROM 100K_10flds_100%dens S // Input: 10 fields,100K records,100% density WHERE S.time &gt; ``&lt;timestamp1&gt;'' // Selection on the order attribute. <p> The optimization of sequence query strings, of course, can be carried out using the techniques presented in <ref> [SLR94] </ref> and in this paper (it may well be that further improvements or variations are possible, but at the least, we believe that our results provide a sound basis for further work).
Reference: [SLVZ95] <author> Bharati Subramaniam, Theodore Leung, Scott Vandenberg and Stanley Zdonik. </author> <title> The AQUA Approach to Querying Lists and Trees in Object-Oriented Databases. </title> <booktitle> In Proceedings of the IEEE Conference on Data Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: As we demonstrate quantitatively in this paper, this observation is indeed valid. As practical guidelines, we also required that our design for adding sequence functionality should allow other kinds of interesting collection types (like trees <ref> [SLVZ95] </ref> and multi-dimensional arrays [MV93]) to be similarly incorporated. Further, the approach we use to support sequence data should ideally be also applicable to other existing database systems (including commercial systems). 3 High-Level System Design We can categorize the design contributions of SEQ into three components. <p> This work is complementary to ours, since SEQ is oriented to more traditional database queries, and currently does not have meaningful pattern-matching capabilties, though we plan to address this shortcoming soon (see Section 7.2). 24 The AQUA algebra <ref> [SLVZ95] </ref> can model a variety of "pattern-match" queries over different collection types including lists. The idea is to map any query over complex and possibly nested data into a uniform algebra. The algebraic expression can then be optimized using transformation-based techniques.
Reference: [SPL94] <author> Praveen Seshadri, Hamid Pirahesh, and T.Y.Cliff Leung. </author> <title> Decorrelating Complex Queries. </title> <booktitle> To appear in Proceedings of the Twelfth International Conference on Data Engineering, </booktitle> <address> New Orleans, Louisiana, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: This is similar to the usual evaluation of functions in a language like SQL, and to the nested evaluation of correlated sub-queries in SQL. There are many optimizations like function caching [Hel95] and magic decorrelation <ref> [SPL94] </ref> that have been proposed in those contexts and similar optimizations could be performed in SEQ too. The current implementation, however, uses a simple value-at-a-time nested evaluation. Another issue that arises in the nested design is the granularity at which statistics are maintained. <p> This is useful for computing decay functions over a sequence, and can also be used for recursive pattern match queries (expressing regular patterns). At the level of generic nested E-ADT queries, we believe that there are opportunities for set-oriented optimization using techniques recently proposed for relation query optimization <ref> [SPL94, Hel95] </ref>. This work also has relevance independent of sequence data, because it can be applied to query processing in all languages that support nesting, and to query processing in heterogenous databases.
Reference: [SR93] <author> Divesh Srivastava and Raghu Ramakrishnan. </author> <title> Pushing Constraint Selections. </title> <journal> In Journal of Logic Programming, </journal> <volume> 16(3-4):361-414, </volume> <year> 1993. </year>
Reference-contexts: As the selectivity increases, all the algorithms become more expensive because there is additional work being done in the final count aggregate. 5 Note that this is an important special case of constraint propagation (e.g. <ref> [SR93] </ref>) and the predicate move-around optimization [LMS94] that have been proposed for relational query optimization. 14 The results for at end are shown in Figure 10. The performance of NO PD is the same as in the at start experiment.
Reference: [SRH92] <author> M. Stonebraker, L.A. Rowe, and M. Hirohama. </author> <title> The implementation of POSTGRES. </title> <journal> In IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> Vol.2, </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: In this section, we describe two of them: the overall data model design, and its instantiation in the system architecture. The specific design for sequence data support is presented in the next section. 3.1 Data Model Design Object-relational systems like Illustra [Ill94a], Paradise [DKLPY94], and Postgres <ref> [SRH92] </ref> allow an attribute of a relational record to belong to an Abstract Data Type (ADT). Each ADT defines methods that may be invoked on values of that type. An ADT can itself be a structured complex type, with other ADTs nested inside it.
Reference: [SS87] <author> Arie Segev and Arie Shoshani. </author> <title> Logical Modelling of Temporal Data. </title> <booktitle> In Proceedings of ACM SIGMOD '87 International Conference on Management of Data, </booktitle> <address> San Francisco, CA, </address> <pages> pages 454-466, </pages> <year> 1987. </year>
Reference-contexts: We now review some research related to this area. Research work directed at modelling time-series data <ref> [SS87, CS92] </ref> provided initial direction to our efforts. The model of a time-series in [SS87] is similar to ours, and an SQL-like language was also proposed; implementation issues were discussed in the context of how the model could be mapped to a relational data model [SS88]. <p> We now review some research related to this area. Research work directed at modelling time-series data [SS87, CS92] provided initial direction to our efforts. The model of a time-series in <ref> [SS87] </ref> is similar to ours, and an SQL-like language was also proposed; implementation issues were discussed in the context of how the model could be mapped to a relational data model [SS88]. The dual nature of sequences (Positional versus Record-Oriented) is also recognized by the temporal query language of [WJS93].
Reference: [SS88] <author> Arie Segev and Arie Shoshani. </author> <title> The Representation of a Temporal Data Model in the Relational Environment. </title> <booktitle> In Proceedings of the 4th Conference on Statistical and Scientific Database Management, </booktitle> <pages> pages 39-61, </pages> <year> 1988. </year>
Reference-contexts: The model of a time-series in [SS87] is similar to ours, and an SQL-like language was also proposed; implementation issues were discussed in the context of how the model could be mapped to a relational data model <ref> [SS88] </ref>. The dual nature of sequences (Positional versus Record-Oriented) is also recognized by the temporal query language of [WJS93].
Reference: [Sta91] <institution> Statistical Sciences, Inc. </institution> <note> S-Plus User's Manual. </note> <institution> Statistical Sciences, Inc., </institution> <address> Seattle, WA. </address>
Reference-contexts: Financial management products like MIM [MIM94] have created a niche market by building special purpose systems for analyzing stock market data. Main-memory based systems like S-Plus <ref> [Sta91] </ref> perform statistical analysis of sequences, but these systems are not equipped to handle large quantities of data. Most commercial database systems will allow a sequence to be represented as a `blob' which is managed by the system, but interpreted solely by the application program.
Reference: [Sto86] <author> Michael Stonebraker. </author> <title> Includion of New Types in Relational Data Base Systems. </title> <booktitle> In Proceedings of the IEEE Conference on Data Engineering, </booktitle> <pages> pages 262-269, </pages> <year> 1986. </year>
Reference-contexts: These areas represent possible application domains to which SEQ could perhaps be adapted in the future. There is much research work related to the E-ADT paradigm. The issues regarding support for ADTs in database systems were explored in <ref> [Sto86] </ref>. There has been extensive work on nested data models (especially nested relational models [Hul87]), and there is even a commercial database system, UniData [Uni93], based on such a model. Object-oriented systems like O2 [BDK92] also support a nested model with composite objects.
Reference: [TCG+93] <author> A. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, R. Snodgrass (eds). </author> <title> Temporal Databases, Theory, Design and Implementation. </title> <publisher> Benjamin/Cummings Punlishing Company, </publisher> <year> 1993. </year>
Reference-contexts: While SQL-92 provides a timestamp data type, there are few constructs that can exploit sequentiality. The Order-By clause in SQL only specifies the order in which answers are presented to the user. Much research in the temporal database community has focused on enhancing relational data models with temporal semantics <ref> [TCG+93] </ref>, but there have been few publicly available implementations. Financial management products like MIM [MIM94] have created a niche market by building special purpose systems for analyzing stock market data. <p> The dual nature of sequences (Positional versus Record-Oriented) is also recognized by the temporal query language of [WJS93]. The extensive work on temporal database modelling, query languages, and query processing <ref> [TCG+93] </ref> is mostly complementary to our work, because it involves changes to relations and to SQL [TSQL94], not to the sequence E-ADT . However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa.
Reference: [TSQL94] <author> TSQL2 Language Design Committee. </author> <title> TSQL2 Language Specification. </title> <booktitle> In ACM SIGMOD Record, </booktitle> <volume> 23, No.1, </volume> <pages> pages 65-86, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: The dual nature of sequences (Positional versus Record-Oriented) is also recognized by the temporal query language of [WJS93]. The extensive work on temporal database modelling, query languages, and query processing [TCG+93] is mostly complementary to our work, because it involves changes to relations and to SQL <ref> [TSQL94] </ref>, not to the sequence E-ADT . However, it would be interesting to study how time-ordered sequences can be efficiently converted into relations with time-stamps, and vice-versa. We intend to eventually support the temporal relational functionality described in the temporal database benchmark [Jen+93].
Reference: [Uni93] <institution> UniSQL User's Guide (Release 2.1). UniData Inc., </institution> <address> Denver, </address> <year> 1993. </year>
Reference-contexts: There is much research work related to the E-ADT paradigm. The issues regarding support for ADTs in database systems were explored in [Sto86]. There has been extensive work on nested data models (especially nested relational models [Hul87]), and there is even a commercial database system, UniData <ref> [Uni93] </ref>, based on such a model. Object-oriented systems like O2 [BDK92] also support a nested model with composite objects. The recently proposed OQL query language [Cat94] for OO databases allows collection types to be nested, and permits nested queries over them.
Reference: [VD91] <author> S.L. Vandenberg and D.J. DeWitt. </author> <title> Algebraic Spport for Complex Objects with Arrays, Identity, and Inheritance. </title> <booktitle> In Proceedings of ACM SIGMOD '91 International Conference on Management of Data, </booktitle> <pages> pages 158-167, </pages> <year> 1991. </year>
Reference-contexts: We intend to eventually support the temporal relational functionality described in the temporal database benchmark [Jen+93]. While most object-oriented database proposals include constructors for complex types like lists and arrays <ref> [VD91, BDK92] </ref>, they can either be treated as collections, or manipulated using a primitive set of methods; no facilities for sequence queries are provided. The work described in [Ric92] is an exception, and proposes an algebra based on temporal logic to ask complex queries over lists.
Reference: [WJS93] <author> Sean X. Wang, Sushil Jajodia, </author> <title> and V.S. Subrahmanian. Temporal Modules: An Approach Toward Federated Temporal Databases. </title> <booktitle> In Proceedings of ACM SIGMOD '93 International Conference on Management of Data, </booktitle> <address> Washington, DC, </address> <pages> pages 227-237, </pages> <year> 1993. </year>
Reference-contexts: The dual nature of sequences (Positional versus Record-Oriented) is also recognized by the temporal query language of <ref> [WJS93] </ref>. The extensive work on temporal database modelling, query languages, and query processing [TCG+93] is mostly complementary to our work, because it involves changes to relations and to SQL [TSQL94], not to the sequence E-ADT .
References-found: 39

