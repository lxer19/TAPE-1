URL: http://www.eecs.berkeley.edu/~tah/Publications/a_determinizable_class_of_timed_automata.ps
Refering-URL: http://www.eecs.berkeley.edu/~tah/Publications/a_determinizable_class_of_timed_automata.html
Root-URL: 
Title: Event-Clock Automata: A Determinizable Class of Timed Automata  
Author: Rajeev Alur Limor Fix Thomas A. Henzinger 
Abstract: We introduce event-recording automata. An event-recording automaton is a timed automaton that contains, for every event a, a clock that records the time of the last occurrence of a. The class of event-recording automata is, on one hand, expressive enough to model (finite) timed transition systems and, on the other hand, determinizable and closed under all boolean operations. As a result, the language-inclusion problem is decidable for event-recording automata. We present a translation from timed transition systems to event-recording automata, which leads to an algorithm for checking if two timed transition systems have the same set of timed behaviors. We also consider event-predicting automata, which contain clocks that predict the time of the next occurrence of an event. The class of event-clock automata, which contain both event-recording and event-predicting clocks, is a suitable specification language for real-time properties. We provide an algorithm for checking if a timed automaton meets a specification that is given as an event-clock automaton.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, C. Courcoubetis, and D. Dill. </author> <title> Model checking in dense real time. </title> <journal> Information and Computation, </journal> <volume> 104 </volume> <pages> 2-34, </pages> <year> 1993. </year>
Reference-contexts: A timed automaton, then, accepts timed words|strings in which each symbol is paired with a real-valued time-stamp. The theory of timed automata allows the solution of certain verification problems for real-time systems with finite control <ref> [1, 3, 4, 6, 13] </ref>, and the solution of certain delay problems [2, 9]. Solutions based on this theory have been implemented in several automatic tools, including Cospan [7], Kronos [10], and UppAal [8]. However, the general verification problem (i.e., language inclusion) is undecidable for timed automata [3].
Reference: [2] <author> R. Alur, C. Courcoubetis, and T. Henzinger. </author> <title> Computing accumulated delays in real-time systems. </title> <booktitle> In Proceedings of the Fifth Annual Conference on Computer-Aided Verification, </booktitle> <volume> LNCS 697, </volume> <pages> pages 181-193. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: A timed automaton, then, accepts timed words|strings in which each symbol is paired with a real-valued time-stamp. The theory of timed automata allows the solution of certain verification problems for real-time systems with finite control [1, 3, 4, 6, 13], and the solution of certain delay problems <ref> [2, 9] </ref>. Solutions based on this theory have been implemented in several automatic tools, including Cospan [7], Kronos [10], and UppAal [8]. However, the general verification problem (i.e., language inclusion) is undecidable for timed automata [3].
Reference: [3] <author> R. Alur and D. Dill. </author> <title> A theory of timed automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 126 </volume> <pages> 183-235, </pages> <year> 1994. </year>
Reference-contexts: The decision procedure for language inclusion typically involves the complementation of the specification automaton, which in turn relies upon determinization [14, 20]. To capture the behavior of a real-time system, the model of computation needs to be augmented with a notion of time. For this purpose, timed automata <ref> [3] </ref> provide a simple, and yet powerful, way of annotating state-transition graphs with timing constraints, using finitely many real-valued variables called clocks. With each transition, a timed automaton may check the clock values, and reassign new values to some clocks. <p> A timed automaton, then, accepts timed words|strings in which each symbol is paired with a real-valued time-stamp. The theory of timed automata allows the solution of certain verification problems for real-time systems with finite control <ref> [1, 3, 4, 6, 13] </ref>, and the solution of certain delay problems [2, 9]. Solutions based on this theory have been implemented in several automatic tools, including Cospan [7], Kronos [10], and UppAal [8]. However, the general verification problem (i.e., language inclusion) is undecidable for timed automata [3]. <p> Solutions based on this theory have been implemented in several automatic tools, including Cospan [7], Kronos [10], and UppAal [8]. However, the general verification problem (i.e., language inclusion) is undecidable for timed automata <ref> [3] </ref>. This is because, unlike in the untimed case, the nondeterministic variety of timed automata is strictly more expressive than the deterministic variety. <p> Automata with clocks Timed automata are finite-state machines whose transitions are constrained with timing requirements so that they accept (or generate) timed words (and thus define timed languages); they were proposed in <ref> [3] </ref> as an abstract model for real-time systems with finite control. The finite control of a timed automaton consists of a finite set of locations and a finite set of real-valued variables called clocks. Each edge between locations specifies a set of clocks to be reset (i.e., restarted). <p> Examples such as the railroad-gate controller and timing-based mutual-exclusion algorithms that appear in the literature on real-time verification (see, for instance, <ref> [3, 6, 13] </ref>) can all be specified using event clock automata. 3 Deterministic Event-clock Automata A finite-state machine (with a single start location) is deterministic if all input symbols that label edges with the same source location are pairwise distinct. <p> For event-clock automata we consider the notion of determinism that was proposed for timed automata <ref> [3] </ref>. The event-clock automaton 6 A = (; L; L 0 ; L f ; E) is deterministic iff 1. <p> In the case of timed automata, however, the nondeterministic variety is strictly more expressive than its deterministic counterpart <ref> [3] </ref>. We now show that the event-clock automata form a subclass of timed automata for which the deterministic and nondeterministic automata are equally expressive. The determinization follows the standard subset construction. Let A = (; L; L 0 ; L f ; E) be the given event-clock automaton. <p> iff q w ! q 0 for some initial state q and some final state q 0 of the labeled transition system S A . 9 The region construction The analysis of timed automata builds on the so-called region construction, which transforms a timed automaton into an untimed finite-state machine <ref> [3] </ref>. Here we apply the region construction to event-clock automata. Consider an event-clock automaton A and the corresponding labeled transition system S A . <p> Two states (`; fl); (` 0 ; fl 0 ) 2 Q A are region-equivalent, written (`; fl) ~ = A (` 0 ; fl 0 ), iff ` = ` 0 and fl ~ = A fl 0 . Lemma 2 <ref> [3] </ref> For every event-clock automaton A with integer constants, the region-equivalence relation ~ = A is a time-abstract bisimulation of A. An equivalence class of ~ = A is called a region of A. The number of regions of A is finite. Lemma 3 [3] For every event-clock automaton A with <p> Lemma 2 <ref> [3] </ref> For every event-clock automaton A with integer constants, the region-equivalence relation ~ = A is a time-abstract bisimulation of A. An equivalence class of ~ = A is called a region of A. The number of regions of A is finite. Lemma 3 [3] For every event-clock automaton A with integer constants, the number of regions of A is n 2 O (m log cm) , where n is the number of locations of A, m is the size of the input alphabet, and c is the largest constant that appears in a clock <p> Theorem 2 (Untiming) <ref> [3] </ref> For every event-clock automaton A, the untimed language Untime (L (A)) is regular. Closure properties While the class of timed automata is not closed under complement, and the language-inclusion problem for timed automata is undecidable, the subclass of event-clock automata is well-behaved. <p> The timed language L cannot be defined by a timed automaton <ref> [3] </ref>, and hence, neither by an event-clock automaton. This fact can be used to prove nonclosure properties. <p> On the other hand, the problem of checking emptiness for event-recording (or event-predicting) automata is Pspace-hard. The proof is the same as the corresponding hardness proof for timed automata <ref> [3] </ref>. The algorithm for language inclusion can be used to verify whether a system described as a timed automaton satisfies a specification given as an event-clock automaton. 5 Relating Classes of Timed Automata Timed automata We briefly review the definition of a timed automaton [3]. <p> corresponding hardness proof for timed automata <ref> [3] </ref>. The algorithm for language inclusion can be used to verify whether a system described as a timed automaton satisfies a specification given as an event-clock automaton. 5 Relating Classes of Timed Automata Timed automata We briefly review the definition of a timed automaton [3]. <p> We write NTA for the class of timed languages that are definable by timed automata. The class NTA is closed under union and intersection, but not under complement <ref> [3] </ref>. In particular, the complement of the language L (A 6 ), which contains all timed words in which no two symbols occur with time difference 1, cannot be accepted with finitely many clocks. Checking emptiness for timed automata is Pspace-complete, while language inclusion for timed automata cannot be decided [3]. <p> <ref> [3] </ref>. In particular, the complement of the language L (A 6 ), which contains all timed words in which no two symbols occur with time difference 1, cannot be accepted with finitely many clocks. Checking emptiness for timed automata is Pspace-complete, while language inclusion for timed automata cannot be decided [3]. The definition of determinism for timed automata is the same as for event-clock automata; that is, a timed automaton is deterministic iff it has at most one start location, and two edges with the same source location and the same input symbol have mutually exclusive clock constraints. <p> We write DTA for the class of timed languages that are definable by deterministic timed automata. Since DTA is closed under all boolean operations, DTA is strictly contained in NTA <ref> [3] </ref>. From event-clock automata to timed automata Every event-clock automaton can be translated into a timed automaton that defines the same timed language. Translating event-recording clocks is easy: an event-recording clock x a is reset on an 13 edge e iff the input symbol of e is a.
Reference: [4] <author> R. Alur, T. Feder, and T. Henzinger. </author> <title> The benefits of relaxing punctuality. </title> <journal> Journal of the ACM, </journal> <volume> 43 </volume> <pages> 116-146, </pages> <year> 1996. </year>
Reference-contexts: A timed automaton, then, accepts timed words|strings in which each symbol is paired with a real-valued time-stamp. The theory of timed automata allows the solution of certain verification problems for real-time systems with finite control <ref> [1, 3, 4, 6, 13] </ref>, and the solution of certain delay problems [2, 9]. Solutions based on this theory have been implemented in several automatic tools, including Cospan [7], Kronos [10], and UppAal [8]. However, the general verification problem (i.e., language inclusion) is undecidable for timed automata [3].
Reference: [5] <author> R. Alur and T. Henzinger. </author> <title> Back to the future: towards a theory of timed regular languages. </title> <booktitle> In Proceedings of the 33rd Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 177-186. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1992. </year>
Reference-contexts: The notion of nondeterminism allowed by timed automata, therefore, seems too permissive, and we hesitate to accept timed automata as the canonical model for real-time computation with finite control <ref> [5] </ref>. In this paper, we obtain a determinizable class of timed automata by restricting the use of clocks. The clocks of an event-clock automaton have a fixed, predefined association with the symbols of the input alphabet (the alphabet symbols typically represent events). <p> The proof is similar to case (1): an event-clock automaton either accepts both (a; 0)(a; 0:5)(a; 1) and (a; 0)(a; 0:5)(a; 0:9), or it rejects both timed 15 words. In <ref> [5] </ref>, we defined another subclass of NTA that is closed under all boolean operations, namely, the class 2DTA of timed languages that are definable by deterministic two-way timed automata that can read the timed input word a bounded number of times (by moving forward and backward over the input).
Reference: [6] <author> R. Alur, A. Itai, R. Kurshan, and M. Yannakakis. </author> <title> Timing verification by successive approximation. </title> <journal> Information and Computation, </journal> <volume> 118(1) </volume> <pages> 142-157, </pages> <year> 1995. </year>
Reference-contexts: A timed automaton, then, accepts timed words|strings in which each symbol is paired with a real-valued time-stamp. The theory of timed automata allows the solution of certain verification problems for real-time systems with finite control <ref> [1, 3, 4, 6, 13] </ref>, and the solution of certain delay problems [2, 9]. Solutions based on this theory have been implemented in several automatic tools, including Cospan [7], Kronos [10], and UppAal [8]. However, the general verification problem (i.e., language inclusion) is undecidable for timed automata [3]. <p> Examples such as the railroad-gate controller and timing-based mutual-exclusion algorithms that appear in the literature on real-time verification (see, for instance, <ref> [3, 6, 13] </ref>) can all be specified using event clock automata. 3 Deterministic Event-clock Automata A finite-state machine (with a single start location) is deterministic if all input symbols that label edges with the same source location are pairwise distinct. <p> For instance, it is possible to construct the time-abstract bisimulation of A with the smallest number of regions using minimization algorithms [22], or to incorporate the clock constraints of A one by one, generating successive approximations to the region automaton Reg ~ = (A) <ref> [6] </ref>. Reachability problems for timed automata can also be solved by symbolic fixpoint computation [11, 13].
Reference: [7] <author> R. Alur and R. Kurshan. </author> <title> Timing analysis in Cospan. In Hybrid Systems III: Verification and Control, </title> <publisher> LNCS 1066, </publisher> <pages> pages 220-231. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The theory of timed automata allows the solution of certain verification problems for real-time systems with finite control [1, 3, 4, 6, 13], and the solution of certain delay problems [2, 9]. Solutions based on this theory have been implemented in several automatic tools, including Cospan <ref> [7] </ref>, Kronos [10], and UppAal [8]. However, the general verification problem (i.e., language inclusion) is undecidable for timed automata [3]. This is because, unlike in the untimed case, the nondeterministic variety of timed automata is strictly more expressive than the deterministic variety.
Reference: [8] <author> J. Bengtsson, K. Larsen, F. Larsson, P. Pettersson, and W. Yi. UppAal: </author> <title> a tool suite for automatic verification of real-time systems. In Hybrid Systems III: Verification and Control, </title> <publisher> LNCS 1066, </publisher> <pages> pages 232-243. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Solutions based on this theory have been implemented in several automatic tools, including Cospan [7], Kronos [10], and UppAal <ref> [8] </ref>. However, the general verification problem (i.e., language inclusion) is undecidable for timed automata [3]. This is because, unlike in the untimed case, the nondeterministic variety of timed automata is strictly more expressive than the deterministic variety.
Reference: [9] <author> C. Courcoubetis and M. Yannakakis. </author> <title> Minimum and maximum delay problems in real-time systems. </title> <booktitle> In Proceedings of the Third Annual Conference on Computer-Aided Verification, </booktitle> <volume> LNCS 575, </volume> <pages> pages 399-409. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: A timed automaton, then, accepts timed words|strings in which each symbol is paired with a real-valued time-stamp. The theory of timed automata allows the solution of certain verification problems for real-time systems with finite control [1, 3, 4, 6, 13], and the solution of certain delay problems <ref> [2, 9] </ref>. Solutions based on this theory have been implemented in several automatic tools, including Cospan [7], Kronos [10], and UppAal [8]. However, the general verification problem (i.e., language inclusion) is undecidable for timed automata [3].
Reference: [10] <author> C. Daws, A. Olivero, S. Tripakis, and S. Yovine. </author> <title> The tool Kronos. In Hybrid Systems III: Verification and Control, </title> <publisher> LNCS 1066, </publisher> <pages> pages 208-219. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The theory of timed automata allows the solution of certain verification problems for real-time systems with finite control [1, 3, 4, 6, 13], and the solution of certain delay problems [2, 9]. Solutions based on this theory have been implemented in several automatic tools, including Cospan [7], Kronos <ref> [10] </ref>, and UppAal [8]. However, the general verification problem (i.e., language inclusion) is undecidable for timed automata [3]. This is because, unlike in the untimed case, the nondeterministic variety of timed automata is strictly more expressive than the deterministic variety.
Reference: [11] <author> D. Dill. </author> <title> Timing assumptions and verification of finite-state concurrent systems. </title> <booktitle> In Proceedings of the First Annual Conference on Computer-Aided Verification, </booktitle> <volume> LNCS 407, </volume> <pages> pages 197-212. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Reachability problems for timed automata can also be solved by symbolic fixpoint computation <ref> [11, 13] </ref>.
Reference: [12] <author> T. Henzinger, Z. Manna, and A. Pnueli. </author> <title> Temporal proof methodologies for timed transition systems. </title> <journal> Information and Computation, </journal> <volume> 112 </volume> <pages> 273-337, </pages> <year> 1994. </year> <month> 18 </month>
Reference-contexts: In fact, we argue that automata that contain only event-recording clocks (event-recording automata) are a suitable abstract model for real-time systems by proving that event-recording automata are as powerful as another popular model for real-time computation, timed transition systems <ref> [12] </ref>. A timed transition system associates with each transition a lower bound and an upper bound on the time that the transition may be enabled without being taken (many related real-time formalisms also use lower and upper time bounds to express timing constraints [18, 19]). <p> A variety of programming systems, such as message-passing systems and shared-memory systems, can be given a transition-system semantics [17]. The model of transition systems is extended to timed transition systems so that it is possible to express real-time constraints on the transitions <ref> [12] </ref>. A timed transition system T consists of a transition system (Q; Q 0 ; T ) and two functions l and u from T to Q 0 that associate with each transition t 2 T a lower bound l (t ) and an upper bound u (t ).
Reference: [13] <author> T. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> Symbolic model checking for real-time systems. </title> <journal> Information and Computation, </journal> <volume> 111 </volume> <pages> 193-244, </pages> <year> 1994. </year>
Reference-contexts: A timed automaton, then, accepts timed words|strings in which each symbol is paired with a real-valued time-stamp. The theory of timed automata allows the solution of certain verification problems for real-time systems with finite control <ref> [1, 3, 4, 6, 13] </ref>, and the solution of certain delay problems [2, 9]. Solutions based on this theory have been implemented in several automatic tools, including Cospan [7], Kronos [10], and UppAal [8]. However, the general verification problem (i.e., language inclusion) is undecidable for timed automata [3]. <p> An event-clock automaton is a (nondeterministic) finite-state machine whose edges are annotated both with input symbols and with clock constraints over event-recording and event-predicting clocks. 2 Formally, an event-clock automaton A consists of 2 Clock constraints can be added, as invariant conditions, also to the locations of an event-clock automaton <ref> [13] </ref>, without influencing our results. 4 a c d ` 2 ` 3 * a finite input alphabet , * a finite set L of locations, * a set L 0 L of start locations, * a set L f L of accepting locations, and * a finite set E of <p> Examples such as the railroad-gate controller and timing-based mutual-exclusion algorithms that appear in the literature on real-time verification (see, for instance, <ref> [3, 6, 13] </ref>) can all be specified using event clock automata. 3 Deterministic Event-clock Automata A finite-state machine (with a single start location) is deterministic if all input symbols that label edges with the same source location are pairwise distinct. <p> Reachability problems for timed automata can also be solved by symbolic fixpoint computation <ref> [11, 13] </ref>.
Reference: [14] <author> J. Hopcroft and J. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The decision procedure for language inclusion typically involves the complementation of the specification automaton, which in turn relies upon determinization <ref> [14, 20] </ref>. To capture the behavior of a real-time system, the model of computation needs to be augmented with a notion of time. For this purpose, timed automata [3] provide a simple, and yet powerful, way of annotating state-transition graphs with timing constraints, using finitely many real-valued variables called clocks.
Reference: [15] <author> R. Kurshan. </author> <title> Computer-Aided Verification: The Automata-Theoretic Approach. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Finite automata are instrumental for the modeling and analysis of many phenomena within computer science. In particular, automata theory plays an important role in the verification of concurrent finite-state systems <ref> [15, 21] </ref>. In the trace model for concurrent computation, a system is identified with its behaviors.
Reference: [16] <author> N. Lynch and H. Attiya. </author> <title> Using mappings to prove timing properties. </title> <journal> Distributed Computing, </journal> <volume> 6 </volume> <pages> 121-139, </pages> <year> 1992. </year>
Reference-contexts: Auxiliary variables that record the times of last occurrences of events have been used extensively in real-time reasoning, for example, in the context of model-checking for timed Petri nets [23], and in assertional proof methods <ref> [16, 19] </ref>. Event-recording clocks provide timing information about events in the past. The dual notion of event-predicting clocks provides timing information about future events. For every symbol a 2 , we write y a to denote the event-predicting clock of a.
Reference: [17] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: A variety of programming systems, such as message-passing systems and shared-memory systems, can be given a transition-system semantics <ref> [17] </ref>. The model of transition systems is extended to timed transition systems so that it is possible to express real-time constraints on the transitions [12].
Reference: [18] <author> M. Merritt, F. Modugno, and M. Tuttle. </author> <title> Time-constrained automata. </title> <booktitle> In Proceedings of the Second Annual Conference on Concurrency Theory, </booktitle> <volume> LNCS 527, </volume> <pages> pages 408-423. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: A timed transition system associates with each transition a lower bound and an upper bound on the time that the transition may be enabled without being taken (many related real-time formalisms also use lower and upper time bounds to express timing constraints <ref> [18, 19] </ref>). A run of a timed transition system, then, is again a timed word|a sequence of time-stamped state changes. We construct, for a given timed transition system T with a finite set of states, an event-recording automaton that accepts precisely the runs of T .
Reference: [19] <author> F. Schneider, B. Bloom, and K. Marzullo. </author> <title> Putting time into proof outlines. In Real Time: </title> <journal> Theory in Practice, </journal> <volume> LNCS 600, </volume> <pages> pages 618-639. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: A timed transition system associates with each transition a lower bound and an upper bound on the time that the transition may be enabled without being taken (many related real-time formalisms also use lower and upper time bounds to express timing constraints <ref> [18, 19] </ref>). A run of a timed transition system, then, is again a timed word|a sequence of time-stamped state changes. We construct, for a given timed transition system T with a finite set of states, an event-recording automaton that accepts precisely the runs of T . <p> Auxiliary variables that record the times of last occurrences of events have been used extensively in real-time reasoning, for example, in the context of model-checking for timed Petri nets [23], and in assertional proof methods <ref> [16, 19] </ref>. Event-recording clocks provide timing information about events in the past. The dual notion of event-predicting clocks provides timing information about future events. For every symbol a 2 , we write y a to denote the event-predicting clock of a.
Reference: [20] <author> A. Sistla, M. Vardi, and P. Wolper. </author> <title> The complementation problem for Buchi automata with applications to temporal logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 217-237, </pages> <year> 1987. </year>
Reference-contexts: The decision procedure for language inclusion typically involves the complementation of the specification automaton, which in turn relies upon determinization <ref> [14, 20] </ref>. To capture the behavior of a real-time system, the model of computation needs to be augmented with a notion of time. For this purpose, timed automata [3] provide a simple, and yet powerful, way of annotating state-transition graphs with timing constraints, using finitely many real-valued variables called clocks.
Reference: [21] <author> P. Wolper, M. Vardi, and A. Sistla. </author> <title> Reasoning about infinite computation paths. </title> <booktitle> In Proceedings of the 24th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 185-194. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1983. </year>
Reference-contexts: 1 Introduction Finite automata are instrumental for the modeling and analysis of many phenomena within computer science. In particular, automata theory plays an important role in the verification of concurrent finite-state systems <ref> [15, 21] </ref>. In the trace model for concurrent computation, a system is identified with its behaviors.
Reference: [22] <author> M. Yannakakis and D. Lee. </author> <title> An efficient algorithm for minimizing real-time transition systems. </title> <booktitle> In Proceedings of the Fifth Annual Conference on Computer-Aided Verification, </booktitle> <volume> LNCS 697, </volume> <pages> pages 210-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Since the number of regions is exponential, various heuristics have been proposed to solve emptiness (and other reachability problems) more efficiently. For instance, it is possible to construct the time-abstract bisimulation of A with the smallest number of regions using minimization algorithms <ref> [22] </ref>, or to incorporate the clock constraints of A one by one, generating successive approximations to the region automaton Reg ~ = (A) [6]. Reachability problems for timed automata can also be solved by symbolic fixpoint computation [11, 13].
Reference: [23] <author> T. Yoneda, A. Shibayam, B. Shlingloff, and E. Clarke. </author> <title> Efficient verification of parallel real-time systems. </title> <booktitle> In Proceedings of the Fifth Annual Conference on Computer-Aided Verification, </booktitle> <volume> LNCS 697, </volume> <pages> pages 321-332. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 19 </month>
Reference-contexts: The value of x a , therefore, is determined by the input word, not by the automaton. Auxiliary variables that record the times of last occurrences of events have been used extensively in real-time reasoning, for example, in the context of model-checking for timed Petri nets <ref> [23] </ref>, and in assertional proof methods [16, 19]. Event-recording clocks provide timing information about events in the past. The dual notion of event-predicting clocks provides timing information about future events. For every symbol a 2 , we write y a to denote the event-predicting clock of a.
References-found: 23

