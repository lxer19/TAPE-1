URL: ftp://ftp.cs.arizona.edu/reports/1993/TR93-01.ps
Refering-URL: http://www.cs.arizona.edu/research/reports.html
Root-URL: http://www.cs.arizona.edu
Title: Efficient Timestamp Input and Output  
Author: Curtis E. Dyreson Richard T. Snodgrass 
Date: February 25, 1993  
Pubnum: TR 93-01  
Abstract: In this paper we provide efficient algorithms for converting between the internal form of a timestamp, and various external forms, principally character strings specifying Gregorian dates. We give several algorithms that explore a range of time and space tradeoffs. Unlike previous algorithms, those discussed here have a constant time cost over a greatly extended range of timestamp values. These algorithms are especially useful in operating systems and in database management systems. 
Abstract-found: 1
Intro-found: 1
Reference: [Allen 1981] <author> Allen, J.F. </author> <title> "An Interval-Based Representation of Temporal Knowledge," </title> <booktitle> in Proceedings of the International Joint Conference on Artificial Intelligence. </booktitle> <address> Vancouver: </address> <year> 1981, </year> <pages> pp. 221-226. </pages>
Reference-contexts: Note that precedes can be used to build the complete set of temporal predicates <ref> [Allen 1981] </ref> (e.g., equals (e 1 ; e 2 ) is equivalent to :precedes (e 1 ; e 2 ) ^ :precedes (e 2 ; e 1 )). Efficient implementation of an event abstract data type depends on efficient implementation of these six functions.
Reference: [Ariav 1986] <author> Ariav, G. </author> <title> "A Temporally Oriented Data Model." </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 11, No. 4, </volume> <month> Dec. </month> <year> 1986, </year> <pages> pp. 499-527. </pages>
Reference-contexts: In the discrete model, the continuous time-line is partitioned into line segments. Each segment is called a chronon <ref> [Ariav 1986, Clifford & Rao 1987] </ref>, which is an indivisible unit of time. We choose to use the discrete model. The meaning of each chronon in our data model is given by the time-line clock .
Reference: [Aveni 1989] <author> Aveni, A. F. </author> <title> "Empires of Time: Calendars, Clocks, </title> <booktitle> and Cultures." </booktitle> <address> New York: </address> <publisher> Basic Books, Inc., </publisher> <year> 1989. </year>
Reference-contexts: Gregorian years are 365 days long except leap years which are 366. Leap years are years that are evenly divisible by 4, but not divisible by 100, unless the year is divisible by 400 (this is the common leap year rule, although other rules have been proposed <ref> [Aveni 1989] </ref>). For example, 1900 is not a leap year while 2000 is a leap year. The output algorithm is based on the observation that the Gregorian calendar repeats itself in four hundred year periods.
Reference: [Clifford & Tansel 1985] <author> Clifford, J. and A.U. Tansel. </author> <title> "On an Algebra for Historical Relational Databases: Two Views," </title> <booktitle> in Proceedings of ACM SIGMOD International Conference on Management of Data. </booktitle> <editor> Ed. S. Navathe. </editor> <booktitle> Association for Computing Machinery. </booktitle> <address> Austin, TX: </address> <month> May </month> <year> 1985, </year> <pages> pp. 247-265. </pages>
Reference-contexts: community, two basic time models have been proposed: the continuous model , in which time is viewed as being isomorphic to the real numbers, with each real number corresponding to a "point" in time, and the discrete model , in which time is viewed as being isomorphic to the integers <ref> [Clifford & Tansel 1985] </ref>. In the discrete model, the continuous time-line is partitioned into line segments. Each segment is called a chronon [Ariav 1986, Clifford & Rao 1987], which is an indivisible unit of time. We choose to use the discrete model.
Reference: [Clifford & Rao 1987] <author> Clifford, J. and A. Rao. </author> <title> "A Simple, General Structure for Temporal Domains," </title> <booktitle> in Proceedings of the Conference on Temporal Aspects in Information Systems. AFCET. </booktitle> <address> France: </address> <month> May </month> <year> 1987, </year> <pages> pp. 23-30. </pages>
Reference-contexts: In the discrete model, the continuous time-line is partitioned into line segments. Each segment is called a chronon <ref> [Ariav 1986, Clifford & Rao 1987] </ref>, which is an indivisible unit of time. We choose to use the discrete model. The meaning of each chronon in our data model is given by the time-line clock .
Reference: [Dyreson & Snodgrass 1993] <author> Dyreson, C. E. and R. T. Snodgrass. </author> <title> "Timestamp Semantics and Representation." </title> <journal> Information Systems, </journal> <volume> 18, No. 3, </volume> <month> Sep. </month> <year> 1993. </year>
Reference-contexts: The time-line clock switches from one physical clock to the next at a synchronization point. A synchronization point correlates two, distinct physical clock measurements. Elsewhere we give the rationale behind a time-line clock composed of four physical clocks <ref> [Dyreson & Snodgrass 1993] </ref>. This clock extends from the beginning of time (specifically, the "Big Bang" [Hawking 1988], which occurred between 14 and 18 billion years ago) to 18 billion years into the future. The time-line granularity is one second. <p> In C parlance, our representation is a long long int, which occupies 64 bits. Elsewhere we show how to exploit the remaining four bits <ref> [Dyreson & Snodgrass 1993] </ref>. 3 Timestamp Operations Liskov and Guttag have proposed a taxonomy of abstract data type operations [Liskov & Gut-tag 1986]. Applying this taxonomy to timestamps suggests four general categories of timestamp operations. 1. <p> Hence, databases typically do not perform input and output as we have defined them. However, typical database-style timestamps are space-inefficient and their formats make arithmetic and comparison operations as well as input and output in non-Gregorian calendars difficult and costly <ref> [Dyreson & Snodgrass 1993] </ref>. Although timegm () performs Gregorian calendar input as we have defined it, the function also checks the input parameters and allocates a tm struct in memory.
Reference: [Fraser 1987] <author> Fraser, J. </author> <title> "Time the Familiar Stranger." </title> <address> Redmond, WA: </address> <publisher> Tempus Books, </publisher> <year> 1987. </year>
Reference-contexts: For example, the Gregorian calendar counts tropical years (the year with respect to the seasons) in terms of days while the traditional Chinese calendar counts lunar months (from new moon to new moon) and 19-year periods known in the West as Metonic cycles <ref> [Fraser 1987] </ref>, in terms of days. Since there are not (currently) an integral number of days in either a lunar month, a tropical year, or a Metonic cycle, rule-based adjustments, called intercalations, are made to keep the count accurate. <p> For instance, the Julian calendar, which adds a leap day every four years, has a fixed period of four years (365 fi 3 + 366 days) while the Chinese calendar has a 60-year cycle <ref> [Fraser 1987] </ref>. 22 8 Summary Temporal databases require timestamps with much greater range than that available in the 32-bit integer representation commonly used in operating systems. Previously we proposed using a 60-bit signed integer representation, which covers all past time.
Reference: [Hawking 1988] <author> Hawking, S. </author> <title> "A Brief History of Time." </title> <address> New York: </address> <publisher> Bantam Books, </publisher> <year> 1988. </year>
Reference-contexts: A synchronization point correlates two, distinct physical clock measurements. Elsewhere we give the rationale behind a time-line clock composed of four physical clocks [Dyreson & Snodgrass 1993]. This clock extends from the beginning of time (specifically, the "Big Bang" <ref> [Hawking 1988] </ref>, which occurred between 14 and 18 billion years ago) to 18 billion years into the future. The time-line granularity is one second. That is, every chronon in our time-line clock represents one second. We adopt a particularly simple, yet adequate, timestamp format.
Reference: [Liskov & Guttag 1986] <author> Liskov, B. and J. Guttag. </author> <title> "Abstraction and Specification in Program Development." </title> <address> New York: </address> <publisher> McGraw-Hill, </publisher> <year> 1986. </year>
Reference: [Soo & Snodgrass 1992] <author> Soo, M. and R. Snodgrass. </author> <title> "Mixed Calendar Query Language Support for Temporal Constants." </title> <type> TempIS Technical Report 29. </type> <institution> Computer Science Department, University of Arizona. </institution> <note> Revised May 1992. </note>
Reference-contexts: The programs and the test cases used to derive the results in this paper can be accessed via anonymous FTP from cs.arizona.edu in the subdirectory tsql/fastIO. 2 Timestamp Semantics and Representation There are three basic temporal data types: events, spans , and intervals <ref> [Soo & Snodgrass 1992] </ref>. An event is an isolated instant in time. A span is an unanchored duration of time, while an interval is an anchored duration, the time between two events. In this paper we consider only 1 event timestamps and operations on event timestamps. <p> Each timestamp bit pattern represents a unique chronon. This simple timestamp format facilitates efficient arithmetic and comparison operations, and is essential for output to and input from multiple calendars <ref> [Soo & Snodgrass 1992] </ref>. The algorithms we describe use Midnight January 1, 1970 A.D. as the timestamp origin, but we indicate for each algorithm how a different origin might be used. In C parlance, our representation is a long long int, which occupies 64 bits. <p> anticipate that Gregorian calendar input and output will be the most common kind of input and output and are the topics of the next two sections. 4 Gregorian Output Output converts the time stored in a timestamp to a calendar specific representation, that is, an array of pertinent calendar values <ref> [Soo & Snodgrass 1992] </ref>. The Gregorian calendar representation, for instance, has array values for the year, month, and day, whereas a business calendar representation has array values for the fiscal year, quarter, and work day. Constructing a character string from such an array is straightforward.
Reference: [Soo et al. 1992] <author> Soo, M., R. Snodgrass, C. Dyreson, C. S. Jensen and N. Kline. </author> <title> "Architectural Extensions to Support Multiple Calendars." </title> <type> TempIS Technical Report 32. </type> <institution> Computer Science Department, University of Arizona. </institution> <note> Revised May 1992. 24 </note>
Reference-contexts: An event is an isolated instant in time. A span is an unanchored duration of time, while an interval is an anchored duration, the time between two events. In this paper we consider only 1 event timestamps and operations on event timestamps. Span and interval operations are similar <ref> [Soo et al. 1992] </ref>. <p> Operations that modify timestamps, called mutators . 4. Operations that take timestamps as input and return other types, called observers. Following this classification scheme, we have identified a comprehensive set of six primitive operations on event timestamps <ref> [Soo et al. 1992] </ref>. 1. create | Create an event timestamp, the initial value of the timestamp is given as a calendar specific value, a primitive constructor. 2. first | Choose the earliest event from among a pair of events, a constructor. 3. last | Choose the latest event from among
Reference: [Tansel, A. et al. 1993] <author> Tansel, A., J. Clifford, S. Gadia, S. Jajodia, A. Segev and R. Snodgrass (eds.). </author> <title> "Temporal Databases: Theory, Design, and Implementation." Database Systems and Applications Series. </title> <address> Redwood City, CA: Benjamin/Cummings, </address> <year> 1993. </year> <month> 25 </month>
Reference-contexts: To display the resulting string on a screen at 9600 baud takes much longer, about 13 msec. The need for more efficient algorithms becomes apparent when considering temporal databases <ref> [Tansel, A. et al. 1993] </ref> that store time-varying information. Current input and output algorithms apply to restricted intervals of time (generally 1970 to 2038). If temporal databases are to be useful to astronomers, historians, archaeologists, and geologists, the time interval must be greatly lengthened.
References-found: 12

