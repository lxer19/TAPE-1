URL: http://www.pdos.lcs.mit.edu/~engler/avm.ps
Refering-URL: http://www.pdos.lcs.mit.edu/~engler/
Root-URL: 
Email: kaashoekg@lcs.mit.edu  
Title: AVM: Application-Level Virtual Memory  
Author: Dawson R. Engler Sandeep K. Gupta M. Frans Kaashoek fengler, skgupta, 
Address: 545 Technology Square Cambridge, MA 02139  
Affiliation: MIT Laboratory for Computer Science  
Abstract: Virtual memory (VM) is a notoriously complicated abstraction to implement, and is hard to change, specialize, or replace. Although a certain degree of flexibility is achieved by user-level pagers, the control they provide is limited: they leave much of the VM system fixed in the kernel, unreachable by the application. As applications become more diverse and the opportunity cost of bad memory policies grows, it is essential for applications to have more control over the VM abstraction. In this position paper, we motivate and describe a VM system that is implemented completely at the application level. To the best of our knowlege this system is the first complete example of application-level virtual memory (AVM). AVM allows applications to easily specialize, modify, or even replace the VM abstractions offered. For example, on architectures with software TLB management, applications can even select their own page-table structures. In addition, AVM simplifies the OS kernel, since the kernel only multiplexes and does not abstract physical memory. A prototype AVM system is implemented for Aegis, an experimental exokernel. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Vadim Abrossimov, Marc Rozier, and Marc Shapiro. </author> <title> Generic virtual memory management for operating system kernels. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 123-36, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Many operating systems implement this abstraction completely in the kernel. These systems are typically large, complex, and inflexible, resulting in bad performance and poor reliability. To allow some degree of customization and to simplify kernel, a number of microkernels <ref> [1, 11, 25] </ref> have put the policy decisions for page-replacement in user-level servers. Unfortunately, many policies in these systems are still hard-coded (e.g., the page-table struc ture is fixed) and the page-servers are often complex and have superuser privilege, making them hard to modify or replace.
Reference: [2] <author> A.W. Appel and K. Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Proceedings of the Fourth International Conference on ASPLOS, </booktitle> <pages> pages 96-107, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Other microkernels [12, 17, 21] have chosen to implement a very restricted virtual memory system in order to make the system fast and simple. These systems do not support VM techniques such as copy-on-write, which can improve application-performance by an order of magnitude <ref> [2, 11, 14] </ref>. In summary, current VM systems are either complicated and unwieldy, or naive and rudimentary; both approaches penalize applications. <p> Control of page-size. On machines that support variable page-size mappings [19, 20], AVM can exploit application specific knowlege to determine appropriate page sizes (e.g., many of the applications discussed in Appel et al. <ref> [2] </ref> benefit from smaller page sizes). DMA. Avoidance of the memory subsystem during bulk data transfers can improve performance by eliminating the effects of both cache and TLB misses, and pollution. This optimization can aid many operations such as networking and garbage-collection, and more common operations such as memcpy (). <p> Fine-grain control over virtual memory attributes. Giving applications access to the full complement of hardware facilities allows precise control of page information (e.g., reference bits, page-size, caching attributes). Reference bits can be used to track writes to memory pages (useful for garbage-collectors <ref> [2] </ref>). Application-controlled caching can be used to reduce cache pollution by disabling caching for memory that exhibits poor locality. For example, a log that absorbs many writes before being flushed to disk should not be cached, since it needlessly evicts cache entries. Fast exception propagation. <p> For example, a log that absorbs many writes before being flushed to disk should not be cached, since it needlessly evicts cache entries. Fast exception propagation. Fast memory protection traps aid DSM and garbage collection systems that use page-protection to detect references <ref> [2] </ref>. 2.2 Radical New Structures AVM enables many radical structures to be built. We examine a few here. Different address space sizes. With the ad-vent of 64-bit machines, this consideration becomes increasingly important. <p> This can be used to replace sandboxing or to implement a single-address space operating system at application-level. Further motivation and examples can be found in <ref> [2, 11, 14] </ref>. 3 Issues in Designing an AVM To support AVM, the OS must provide the following functionality: allocation of physical memory, bootstrapping of virtual memory machinery (i.e., TLB miss code and page-tables), efficient exception pro-pogation, secure modification of the mapping hardware (e.g., TLB) and revocation of physical memory. <p> We compare Aegis and our AVM system to Ul-trix across seven virtual memory experiments, based upon those listed in <ref> [2] </ref>. The experiments are done within the DECstation/MIPS family. All times are measured using the "wall-clock." All benchmarks were compiled using the same compiler and flags, and run in "single-user" mode. A more complete discussion of the methodology and experiments can be found in [10]. <p> measures the time required to remove read-protections on 100 pages. trap measures the time to take a page-protection trap. appel1 measures the time to access a random protected page and in the fault-handler, protect some other page and unprotect the faulting page (this benchmark is "prot1+trap+unprot" in Appel et al. <ref> [2] </ref>). appel2: Time to protect 100 pages, access each page in a random sequence and, in the fault-handler, unprotect the faulting page (this benchmark is "protN+trap+unprot" in Appel et al. [2]). dirty measures the average time to parse the page-table for a random entry. <p> in the fault-handler, protect some other page and unprotect the faulting page (this benchmark is "prot1+trap+unprot" in Appel et al. <ref> [2] </ref>). appel2: Time to protect 100 pages, access each page in a random sequence and, in the fault-handler, unprotect the faulting page (this benchmark is "protN+trap+unprot" in Appel et al. [2]). dirty measures the average time to parse the page-table for a random entry. If we compare the time required for dirty to the time required to perform (un)prot1, over half the time in (un)prot1 is due to the overhead of parsing the page-table.
Reference: [3] <author> K. Bala, M.F. Kaashoek, and W.E. Weihl. </author> <title> Software prefetching and caching for translation lookaside buffers. </title> <booktitle> In Proceedings of the First Symposium on OSDI, </booktitle> <pages> pages 243-253, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Aegis uses the latter approach: it overlays the hardware TLB with a large software TLB (STLB) to absorb capacity misses <ref> [3, 13] </ref>. On a TLB miss, Aegis first checks to see whether the required mapping is in the STLB; if so, Aegis installs it and resumes execution. Otherwise, the miss is forwarded to the application. Currently we use a unified STLB.
Reference: [4] <author> B.N. Bershad, C. Chambers, S. Eggers, C. Maeda, D. McNamee, P. Pardyak, S. Savage, and E. Sirer. </author> <title> SPIN an extensible microkernel for application-specific operating system services. </title> <type> TR 94-03-03, </type> <institution> Univ. of Washington, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: In SPIN <ref> [4] </ref>, for example, applications achieve greater control over the VM systems by downloading spindles, which are fragments of user-code written in a pointer-safe language. On events, such as a page-fault, these spindles are invoked and undertake application-specific operations.
Reference: [5] <author> Brian N. Bershad, Dennis Lee, Theodore H. Romer, and J. Bradley Chen. </author> <title> Avoiding conflict misses dynamically in large direct mapped caches. </title> <booktitle> In Proceedings of the Sixth International Conference on ASPLOS, </booktitle> <pages> pages 158-170, </pages> <year> 1994. </year>
Reference-contexts: Specific page allocation. An application's ability to request specific physical pages enables a large number of optimizations. For example, control over the physical page-numbers allows cache-conscious layout of data to be done in physically mapped caches through "page-coloring" techniques <ref> [5] </ref>. This technique is further enabled by the ability of AVM to approximate the working set using TLB snapshots [18]. Additionally, data and text that exhibit poor locality can be mapped to pages of the same color, restricting their pollution of the cache to a specific segment.
Reference: [6] <author> D. Cheriton and K. Duda. </author> <title> A caching model of operating system kernel functionality. </title> <booktitle> In Proceedings of the Sixth SIGOPS European Workshop, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: For example, the application cannot replace the existing VM abstractions; it can only specialize existing implementations. In addition, this approach makes the kernel more complicated, while AVM simplifies the kernel. Many of the ideas we discuss here could be implemented on top of the Caching Kernel <ref> [6] </ref>. However, the Caching Kernel is implemented on the Motorola 68040, which has hardware page-tables, limiting the flexibility with which page-table structures can be experimented.
Reference: [7] <author> Eric Cooper, Robert Harper, and Peter Lee. </author> <title> The Fox project: Advanced development of systems software. </title> <type> Technical Report CMU-CS-91-178, </type> <institution> Carnegie Mellon University, </institution> <address> Pittsburgh, PA 15213, </address> <year> 1991. </year>
Reference-contexts: Unfortunately, since current OS implementations do not support this optimization, garbage-collection results in a "flurry" of I/O activity, because the OS VM system does not realize that while the page has indeed been modified, it contains garbage and so does not need to be stored to disk <ref> [7] </ref>. Specific page allocation. An application's ability to request specific physical pages enables a large number of optimizations. For example, control over the physical page-numbers allows cache-conscious layout of data to be done in physically mapped caches through "page-coloring" techniques [5]. <p> However, their interface and power is very limited: they do not allow control over page-table structure, allocation of specific physical pages, or even access to many page attributes (e.g., pagesize or uncached) <ref> [7] </ref>. The Bridge project attempts to move the virtual memory decisions into the compiler [15]. This is possibly another way to implement many of the features of AVM.
Reference: [8] <author> Peter Druschel, Larry L. Peterson, and Bruce S. Davie. </author> <title> Experiences with a high-speed network adaptor: A software perspective. </title> <booktitle> In SIGCOMM`94, </booktitle> <pages> pages 2-13, </pages> <year> 1994. </year>
Reference-contexts: Applications can also use this functionality to construct contiguous regions of physical memory that are larger than the hardware page size, improving the efficiency of DMA operations <ref> [8] </ref>. It also allows simpler DMA hardware to be used, since the hardware does not have to support "scatter-gather" functionality. Control of page-size.
Reference: [9] <author> D. R. Engler, M. F. Kaashoek, and J. O'Toole. </author> <title> The exokernel approach to extensibility (abstract). </title> <booktitle> In Proceedings of the First Symposium on OSDI, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: To support AVM, kernels have to be written differently: instead of abstracting physical memory and TLBs, kernels should safely export and multiplex VM resources directly to application level. We call such a kernel an exokernel <ref> [9, 10] </ref> (to be precise, exokernels strive to export all resources, not just those necessary to support AVM). The AVM system we describe in this paper is built on top of our prototype exokernel, Aegis.
Reference: [10] <author> Dawson R. Engler. </author> <title> The design and implementation of a prototype exokernel operating system. </title> <type> Master's thesis, </type> <institution> MIT, 545 Technology Square, </institution> <address> Boston MA 02139, </address> <month> February </month> <year> 1995. </year>
Reference-contexts: To support AVM, kernels have to be written differently: instead of abstracting physical memory and TLBs, kernels should safely export and multiplex VM resources directly to application level. We call such a kernel an exokernel <ref> [9, 10] </ref> (to be precise, exokernels strive to export all resources, not just those necessary to support AVM). The AVM system we describe in this paper is built on top of our prototype exokernel, Aegis. <p> For example, the kernel must avoid deallocat-ing the pages holding the AVM system's exception and page-table code without warning and must ensure that translations involving the physical page can be updated, etc. For space reasons, we elide further discussion; a thorough exploration can be found in <ref> [10] </ref>. 4 Experiments Our AVM system is approximately 1000 lines of heavily commented code. Its two main limitations are that it does not handle swapping and that page-tables are implemented as a linear vector (address tranlations are looked up in this structure using binary search). <p> The experiments are done within the DECstation/MIPS family. All times are measured using the "wall-clock." All benchmarks were compiled using the same compiler and flags, and run in "single-user" mode. A more complete discussion of the methodology and experiments can be found in <ref> [10] </ref>. In general, the low-level nature of Aegis allows extremely efficient tuning of system primitives: for example, it performs IPC and exception forwarding 10-100 times faster than Ultrix. We perform seven experiments. dirty measures the time to query whether a page is "dirty" or not.
Reference: [11] <author> K. Harty and D.R. Cheriton. </author> <title> Application-controlled physical memory using external page-cache management. </title> <booktitle> In Proceedings of the Fifth International Conference on ASPLOS, </booktitle> <pages> pages 187-199, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Many operating systems implement this abstraction completely in the kernel. These systems are typically large, complex, and inflexible, resulting in bad performance and poor reliability. To allow some degree of customization and to simplify kernel, a number of microkernels <ref> [1, 11, 25] </ref> have put the policy decisions for page-replacement in user-level servers. Unfortunately, many policies in these systems are still hard-coded (e.g., the page-table struc ture is fixed) and the page-servers are often complex and have superuser privilege, making them hard to modify or replace. <p> Other microkernels [12, 17, 21] have chosen to implement a very restricted virtual memory system in order to make the system fast and simple. These systems do not support VM techniques such as copy-on-write, which can improve application-performance by an order of magnitude <ref> [2, 11, 14] </ref>. In summary, current VM systems are either complicated and unwieldy, or naive and rudimentary; both approaches penalize applications. <p> This can be used to replace sandboxing or to implement a single-address space operating system at application-level. Further motivation and examples can be found in <ref> [2, 11, 14] </ref>. 3 Issues in Designing an AVM To support AVM, the OS must provide the following functionality: allocation of physical memory, bootstrapping of virtual memory machinery (i.e., TLB miss code and page-tables), efficient exception pro-pogation, secure modification of the mapping hardware (e.g., TLB) and revocation of physical memory.
Reference: [12] <author> D. Hildebrand. </author> <title> An architectural overview of QNX. </title> <booktitle> In Proceedings of the Usenix Workshop on Micro-kernels and Other Kernel Architectures, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: Unfortunately, many policies in these systems are still hard-coded (e.g., the page-table struc ture is fixed) and the page-servers are often complex and have superuser privilege, making them hard to modify or replace. Other microkernels <ref> [12, 17, 21] </ref> have chosen to implement a very restricted virtual memory system in order to make the system fast and simple. These systems do not support VM techniques such as copy-on-write, which can improve application-performance by an order of magnitude [2, 11, 14].
Reference: [13] <author> J. Huck and J. Hays. </author> <title> Architectural support for translation table management in large address space machines. </title> <booktitle> In Proceedings of the 19th International Symposium on Computer Architecture, </booktitle> <year> 1992. </year>
Reference-contexts: Aegis uses the latter approach: it overlays the hardware TLB with a large software TLB (STLB) to absorb capacity misses <ref> [3, 13] </ref>. On a TLB miss, Aegis first checks to see whether the required mapping is in the STLB; if so, Aegis installs it and resumes execution. Otherwise, the miss is forwarded to the application. Currently we use a unified STLB.
Reference: [14] <author> Keith Krueger, David Loftesness, Amin Vahdat, and Thomas Anderson. </author> <title> Tools for development of application-specific virtual memory management. </title> <booktitle> In Proceedings of OOPSLA, </booktitle> <pages> pages 48-64, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Other microkernels [12, 17, 21] have chosen to implement a very restricted virtual memory system in order to make the system fast and simple. These systems do not support VM techniques such as copy-on-write, which can improve application-performance by an order of magnitude <ref> [2, 11, 14] </ref>. In summary, current VM systems are either complicated and unwieldy, or naive and rudimentary; both approaches penalize applications. <p> This can be used to replace sandboxing or to implement a single-address space operating system at application-level. Further motivation and examples can be found in <ref> [2, 11, 14] </ref>. 3 Issues in Designing an AVM To support AVM, the OS must provide the following functionality: allocation of physical memory, bootstrapping of virtual memory machinery (i.e., TLB miss code and page-tables), efficient exception pro-pogation, secure modification of the mapping hardware (e.g., TLB) and revocation of physical memory.
Reference: [15] <author> Steven Lucco. </author> <title> High-performance microkernel systems (abstract). </title> <booktitle> In Proc. of the first Symp. on OSDI, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: However, their interface and power is very limited: they do not allow control over page-table structure, allocation of specific physical pages, or even access to many page attributes (e.g., pagesize or uncached) [7]. The Bridge project attempts to move the virtual memory decisions into the compiler <ref> [15] </ref>. This is possibly another way to implement many of the features of AVM. However, not enough details have been provided to do a proper comparison of Bridge and AVM. 6 Conclusions Application-level VM is a novel virtual memory organization which offers applications complete control over the VM system.
Reference: [16] <author> Dylan McNamee and Katherine Armstrong. </author> <title> Extending the mach external pager interface to accommodate user-level page replacement policies. </title> <booktitle> In Mach Workshop Conference Proceedings, </booktitle> <pages> pages 17-30, </pages> <address> Burling-ton, VT, </address> <month> October 4-5 </month> <year> 1990. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: Finally, the Caching Kernel has an alarmist view of downloading code into the kernel, limiting the flexibility and efficiency of their approach. User-level pagers allow a rudimentary control over the VM system by allowing decisions about which pages to swap <ref> [16] </ref>. However, their interface and power is very limited: they do not allow control over page-table structure, allocation of specific physical pages, or even access to many page attributes (e.g., pagesize or uncached) [7]. The Bridge project attempts to move the virtual memory decisions into the compiler [15].
Reference: [17] <author> S.J. Mullender, G. van Rossum, A.S. Tanenbaum, R. van Renesse, and H. van Staveren. </author> <title> Amoeba: a distributed operating system for the 1990s. </title> <journal> IEEE Computer, </journal> <volume> 23(5) </volume> <pages> 44-53, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Unfortunately, many policies in these systems are still hard-coded (e.g., the page-table struc ture is fixed) and the page-servers are often complex and have superuser privilege, making them hard to modify or replace. Other microkernels <ref> [12, 17, 21] </ref> have chosen to implement a very restricted virtual memory system in order to make the system fast and simple. These systems do not support VM techniques such as copy-on-write, which can improve application-performance by an order of magnitude [2, 11, 14].
Reference: [18] <author> Theodore H. Romer, Dennis Lee, Brian N. Bershad, and J. Bradley Chen. </author> <title> Dynamic page mapping policies for cache conflict resolution on standard hardware. </title> <booktitle> In Proceedings of the First Symposium on OSDI, </booktitle> <pages> pages 255-266, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: AVM (by necessity) gives very precise information about and control over the TLB. This information can be used to derive working sets <ref> [18] </ref> or to trace address streams [22]. Accurate "in core" information. AVM systems have total control over virtual memory mappings. Their accurate knowledge of which pages are resident in memory can be useful to many types of applications. <p> For example, control over the physical page-numbers allows cache-conscious layout of data to be done in physically mapped caches through "page-coloring" techniques [5]. This technique is further enabled by the ability of AVM to approximate the working set using TLB snapshots <ref> [18] </ref>. Additionally, data and text that exhibit poor locality can be mapped to pages of the same color, restricting their pollution of the cache to a specific segment.
Reference: [19] <author> M. Talluri, S. Kong, M.D. Hill, and D.A. Patterson. </author> <title> Tradeoffs in supporting two page sizes. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 415-424, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: It also allows simpler DMA hardware to be used, since the hardware does not have to support "scatter-gather" functionality. Control of page-size. On machines that support variable page-size mappings <ref> [19, 20] </ref>, AVM can exploit application specific knowlege to determine appropriate page sizes (e.g., many of the applications discussed in Appel et al. [2] benefit from smaller page sizes). DMA.
Reference: [20] <author> Madhusudhan Talluri and Mark D. Hill. </author> <title> Surpassing the TLB performance of superpages with less operating system support. </title> <booktitle> In Proceedings of the Sixth International Conference on ASPLOS, </booktitle> <year> 1994. </year>
Reference-contexts: It also allows simpler DMA hardware to be used, since the hardware does not have to support "scatter-gather" functionality. Control of page-size. On machines that support variable page-size mappings <ref> [19, 20] </ref>, AVM can exploit application specific knowlege to determine appropriate page sizes (e.g., many of the applications discussed in Appel et al. [2] benefit from smaller page sizes). DMA.
Reference: [21] <author> A.S. Tanenbaum, R. van Renesse, H. van Staveren, G. Sharp, S.J. Mullender, A. Jansen, and G. van Rossum. </author> <title> Experiences with the Amoeba distributed operating system. </title> <journal> Communications of the ACM, </journal> <volume> 33(12) </volume> <pages> 46-63, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Unfortunately, many policies in these systems are still hard-coded (e.g., the page-table struc ture is fixed) and the page-servers are often complex and have superuser privilege, making them hard to modify or replace. Other microkernels <ref> [12, 17, 21] </ref> have chosen to implement a very restricted virtual memory system in order to make the system fast and simple. These systems do not support VM techniques such as copy-on-write, which can improve application-performance by an order of magnitude [2, 11, 14].
Reference: [22] <author> Richard Uhlig, David Nagle, Trevor Mudge, and Stu-art Schrest. </author> <title> Trap-driven simulation with tapeworm II. </title> <booktitle> In Proceedings of the Sixth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-VI), </booktitle> <pages> pages 132-144, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: AVM (by necessity) gives very precise information about and control over the TLB. This information can be used to derive working sets [18] or to trace address streams <ref> [22] </ref>. Accurate "in core" information. AVM systems have total control over virtual memory mappings. Their accurate knowledge of which pages are resident in memory can be useful to many types of applications.
Reference: [23] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <year> 1993. </year>
Reference-contexts: The obvious challenge in supporting AVM is making it fast. The primary bottleneck that must be overcome is the cost of TLB refills. Their overhead can be reduced either by downloading the AVM system's TLB refill code into the kernel (this code can be "sand-boxed" to ensure fault-isolation <ref> [23] </ref>) or by reducing the number of TLB misses that the AVM system must handle. Aegis uses the latter approach: it overlays the hardware TLB with a large software TLB (STLB) to absorb capacity misses [3, 13].
Reference: [24] <author> C. Yarvin, R. Bukowski, and T. Anderson. Anonymous RPC: </author> <title> Low-latency protection in a 64-bit address space. </title> <booktitle> In Proceedings of the Summer 1993 USENIX Conference, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Control of their address space layout allows applications to place sensitive state in arbitrary locations. This technique can be used for improved fault isolation by reducing the chance that a write or read can access this state; in a sense, the virtual address is a capability <ref> [24] </ref>. Such control can be used to allow applications to safely import untrusted code (or to guard against their own buggy algorithms). More efficient dynamic fault isolation. Since context identifiers are available to AVM systems, applications can create light-weight fault isolation domains within their address space.
Reference: [25] <author> M. Young, A. Tevenian, R. Rashid, D. Golub, J. Ep-pinger, J. Chew, W. Bolosky, D. Black, and R. Baron. </author> <title> Duality of memory and communication in the implementation of a multiprocessor. </title> <booktitle> In Proceedings of the Eleventh Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-67, </pages> <address> Austin, TX, </address> <month> Nov. </month> <year> 1987. </year>
Reference-contexts: Many operating systems implement this abstraction completely in the kernel. These systems are typically large, complex, and inflexible, resulting in bad performance and poor reliability. To allow some degree of customization and to simplify kernel, a number of microkernels <ref> [1, 11, 25] </ref> have put the policy decisions for page-replacement in user-level servers. Unfortunately, many policies in these systems are still hard-coded (e.g., the page-table struc ture is fixed) and the page-servers are often complex and have superuser privilege, making them hard to modify or replace.
References-found: 25

