URL: ftp://ftp.cs.brown.edu/pub/techreports/95/cs95-08.ps.Z
Refering-URL: http://www.cs.wustl.edu/~pmh/research.html
Root-URL: 
Abstract-found: 0
Intro-found: 1
Reference: [AB94] <author> Ronald Azuma and Gary Bishop. </author> <title> Improving Static and Dynamic Registration in an Optical See-Through HMD. </title> <booktitle> In Proceedings of SIGGRAPH '94, published as Computer Graphics Proceedings, Annual Conference Series, </booktitle> <pages> pages 197-204, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: With current technology, the only way an application can compensate for latency in a tracking device is by predicting the values it will return in the immediate future. Liang et al. [LSG91], Friedmann et al. [FSP92], Deering [Dee92] and Azuma and Bishop <ref> [AB94] </ref> argue that techniques such as linear interpolation and Kalman filtering give acceptable prediction in some situations. Getting prediction to work in all situations is still a research problem, but for this dissertation I assume that prediction works and the application uses it. <p> The task of predicting acceleration bounds might be easier if the application uses a statistical prediction technique such as a Kalman filter. As Chapter 3 describes, several researchers have used Kalman filters to predict motion for the purpose of reducing input-device latency <ref> [LSG91, FSP92, AB94] </ref>. An interesting topic for future research is determining whether similar filters can make short-term predictions of acceleration magnitude and direction. 52 Chapter 5 Sphere-Trees The previous chapter discussed how the broad phase efficiently handles the temporal aspect of collision detection.
Reference: [ARB90] <author> John M. Airey, John H. Rohlf, and Frederick P. Brooks, Jr. </author> <title> Towards Image Realism with Interactive Update Rates in Complex Virtual Building Environments. </title> <booktitle> In Proceedings of the 1990 Symposium on Interactive 3D Graphics (Snowbird, Utah), </booktitle> <pages> pages 41-50, </pages> <year> 1990. </year>
Reference-contexts: For an application producing an animation, an important element of real-time performance is maintaining a high and nearly-constant frame rate. Opinions vary on the minimum acceptable frame rate. Airey et al. <ref> [ARB90] </ref> state that a rate of six frames per second (fps) is barely tolerable for building-walkthrough applications, while Funkhouser and Sequin [FS93] suggest 10 fps; in general, Brooks [Bro88] and Fuchs and Bishop [FB92] suggest that the goal should be 20 to 30 fps.
Reference: [Bar81] <author> Alan H. Barr. </author> <title> Superquadrics and Angle-Preserving Transformations. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> volume 1, number 1, </volume> <pages> pages 11-23, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: Given certain assumptions about the sparseness of objects and the motion they can have, this approach yields high performance. Sclaroff and Pentland [SP91] describe a novel solution to the pair-processing weakness. They suggest that polyhedral models be approximated by deformed superquadric ellipsoids <ref> [Bar81] </ref> whose surfaces have been modulated by a displacement map. These approximate models, which they call generalized implicit functions, have the advantage that the algorithm to detect collisions between them runs quickly.
Reference: [Bar89] <author> David Baraff. </author> <title> Analytical Methods for Dynamic Simulation of Non-Penetrating Rigid Bodies. </title> <booktitle> In Proceedings of SIGGRAPH '89, published as Computer Graphics, </booktitle> <volume> volume 23, number 3, </volume> <pages> pages 223-232, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Both collision detection and collision response pose interesting research problems, but this dissertation focuses on collision detection. Such a focus is reasonable because the geometric issues involved in collision detection are interesting and challenging. For a thorough discussion of issues in collision response, see the work of Baraff <ref> [Bar89, Bar90, Bar91, BW92] </ref>. 1 1.1 The Problem An increasingly important class of application programs are those that produce interactive animations. In an interactive application, human users directly control the course of events and receive immediate feedback from the application. <p> More sophisticated forms of collision response, such as those Baraff advocates <ref> [Bar89, Bar90, Bar91, BW92] </ref>, unfortunately do not lend themselves to time limits. This section has not distinguished between single-processor and multiple-processor applications. Multiple processors can help an application perform its activities more quickly, but they complicate the issue of latency. Wloka [Wlo94] discusses this problem and presents some pragmatic solutions.
Reference: [Bar90] <author> David Baraff. </author> <title> Curved Surfaces and Coherence for Non-Penetrating Rigid Body Simulation. </title> <booktitle> In Proceedings of SIGGRAPH '90, published as Computer Graphics, </booktitle> <volume> volume 24, number 4, </volume> <pages> pages 19-29, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Both collision detection and collision response pose interesting research problems, but this dissertation focuses on collision detection. Such a focus is reasonable because the geometric issues involved in collision detection are interesting and challenging. For a thorough discussion of issues in collision response, see the work of Baraff <ref> [Bar89, Bar90, Bar91, BW92] </ref>. 1 1.1 The Problem An increasingly important class of application programs are those that produce interactive animations. In an interactive application, human users directly control the course of events and receive immediate feedback from the application. <p> More sophisticated forms of collision response, such as those Baraff advocates <ref> [Bar89, Bar90, Bar91, BW92] </ref>, unfortunately do not lend themselves to time limits. This section has not distinguished between single-processor and multiple-processor applications. Multiple processors can help an application perform its activities more quickly, but they complicate the issue of latency. Wloka [Wlo94] discusses this problem and presents some pragmatic solutions.
Reference: [Bar91] <author> David Baraff. </author> <title> Coping with Friction for Non-Penetrating Rigid Body Simulation. </title> <booktitle> In Proceedings of SIGGRAPH '91, published as Computer Graphics, </booktitle> <volume> volume 25, number 4, </volume> <pages> pages 31-40, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Both collision detection and collision response pose interesting research problems, but this dissertation focuses on collision detection. Such a focus is reasonable because the geometric issues involved in collision detection are interesting and challenging. For a thorough discussion of issues in collision response, see the work of Baraff <ref> [Bar89, Bar90, Bar91, BW92] </ref>. 1 1.1 The Problem An increasingly important class of application programs are those that produce interactive animations. In an interactive application, human users directly control the course of events and receive immediate feedback from the application. <p> More sophisticated forms of collision response, such as those Baraff advocates <ref> [Bar89, Bar90, Bar91, BW92] </ref>, unfortunately do not lend themselves to time limits. This section has not distinguished between single-processor and multiple-processor applications. Multiple processors can help an application perform its activities more quickly, but they complicate the issue of latency. Wloka [Wlo94] discusses this problem and presents some pragmatic solutions.
Reference: [BBO + 83] <author> Bernard R. Brooks, R. E. Bruccoleri, B. D. Olafson, D. J. States, S. Swaminathan, and M. Karplus. CHARMM: </author> <title> A Program for Macromolecular Energy, Minimization and Dynamics Calculations. </title> <journal> Journal of Computational Chemistry, </journal> <volume> volume 4, number 2, </volume> <pages> pages 187-217, </pages> <year> 1983. </year>
Reference-contexts: It is interesting to note that the class of applications that must balance speed and accuracy includes such demanding tasks as dynamic simulation of macromolecular systems, for which the popular CHARMM system <ref> [BBO + 83] </ref> supports a variety of approximations even though their effects are also cumulative. Few time-critical graphics algorithms can avoid occasional decreases in frame rate or increases in latency. The work in this dissertation is no exception.
Reference: [BFGS86] <author> Larry Bergman, Henry Fuchs, Eric Grant, and Susan Spach. </author> <title> Image Rendering by Adaptive Refinement. </title> <booktitle> In Proceedings of SIGGRAPH '86, published as Computer Graphics, </booktitle> <volume> volume 20, number 4, </volume> <pages> pages 29-37, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: By supporting several levels of refinement, the algorithm gives the application the flexibility to get as much accuracy as time allows. The general idea of an interruptible computation that improves in quality with time appears by various names in other areas of graphics and computer science. Bergman et al. <ref> [BFGS86] </ref> introduced this idea in image rendering, calling it adaptive refinement. Cohen et al. [CCWG88] called this idea progressive refinement in the context of another approach to rendering. Dean and Boddy [DB88] first applied this idea to planning problems, calling the implementation an anytime algorithm. <p> The rendering components of these systems choose the appropriate number of polygons to keep the systems running at real-time rates. The shapes used by a given simulator are generally fixed, simplifying the task of building the levels of detail. Bergman et al. <ref> [BFGS86] </ref> describe one of the first time-critical rendering algorithms used outside of flight simulators. This algorithm quickly presents a crude image while a user is changing the viewpoint, and then adaptively refines this image when the user pauses (to study some feature of the image).
Reference: [Bio92] <author> Frank Biocca. </author> <title> Will Simulation Sickness Slow Down the Diffusion of Virtual Environment Technology? Presence, </title> <journal> volume 1, </journal> <volume> number 3, </volume> <pages> pages 334-343, </pages> <month> Summer </month> <year> 1992. </year>
Reference-contexts: This feeling of discomfort, with symptoms resembling those of classical motion sickness, can plague users of vehicle simulators and virtual-reality applications. Simulator sickness is a complicated phenomenon and its causes are not fully understood, but evidence suggests that it is aggravated by low frame rates and high latency <ref> [Bio92, HR92, KLL + 92] </ref>. To alleviate the problem of simulator sickness, it is more important that an application program update frames quickly than that it detect all collisions with utmost accuracy. Even when simulator sickness is not a problem, poor performance can limit the effectiveness of interactive applications.
Reference: [Blu67] <author> Harry Blum. </author> <title> A Transformation for Extracting New Descriptors of Shape. </title> <editor> In Weiant Wathen-Dunn, editor, </editor> <booktitle> Models for the Perception of Speech and Visual Form, </booktitle> <pages> pages 362-380. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1967. </year>
Reference-contexts: One result is a simple way of detecting whether a union of shapes cover a polygon, an idea which can be extended to more general covering problems (Section 5.3.3). Another result is an improved algorithm for approximating the medial-axis surface <ref> [Blu67, NP85] </ref> of a 3D polyhedron (Chapter 6). The medial-axis surface gives a summary of the shape of an object, and has potential applications in pattern recognition and computer vision as well as computer graphics. <p> This algorithm also reuses elements of the simulated-annealing algorithm from Section 5.3, such as the method for checking whether a set of spheres conservatively cover the object. 6.1 Medial-Axis Surfaces The medial axis was introduced by Blum <ref> [Blu67] </ref> to describe the shapes of biological objects.
Reference: [BN78] <author> Harry Blum and Roger N. Nagel. </author> <title> Shape Description Using Weighted Symmetric Axis Features. </title> <journal> Pattern Recognition, </journal> <volume> volume 10, </volume> <pages> pages 167-180, </pages> <year> 1978. </year> <month> 139 </month>
Reference-contexts: Points on the medial axis are equidistant from two sides of the boundary, so they represent a symmetrical axis or "skeleton." Figure 6.1 shows an example of a medial axis. In later work, Blum and Nagel <ref> [BN78] </ref> state another definition of the medial axis, which they also call the "symmetric axis": the locus of the centers of maximal circles that fit inside the figure, with no circle containing another. They also describe how quantitative properties of a medial axis relate to properties of the figure's shape.
Reference: [BO79] <author> Jon L. Bentley and Thomas A. Ottmann. </author> <title> Algorithms for Reporting and Counting Geometric Intersections. </title> <journal> IEEE Transactions on Computers, </journal> <volume> volume C-28, number 9, </volume> <pages> pages 643-647, </pages> <month> September </month> <year> 1979. </year>
Reference-contexts: A key to this algorithm is efficiently finding intersections between 2D line segments. One solution would be to test every pair of segments for intersections, but this approach suffers from the all-pairs weakness. A better alternative is to use the algorithm of Bentley and Ottmann <ref> [BO79, PS85] </ref>. This algorithm not only gives nearly-optimal asymptotic performance, but its straightforward implementation has low overhead in practice. <p> The intersection at t = t b in Figure 4.8, for example, causes s 1 and s 2 to become adjacent in the ordering, but they have already intersected. Surprisingly, neither published description of the algorithm <ref> [BO79, PS85] </ref> describes how to handle this problem. The algorithm cannot merely ignore the "new" intersection if its t coordinate is less than the t of the current intersection, because floating-point inaccuracy can affect the computation of the t coordinate. <p> Finding this point is an example of a two-variable linear-programming problem. Preparata and Shamos [PS85] describe a solution to this problem, but I chose not to implement their algorithm. Instead, I extended my implementation of the Bentley-Ottmann algorithm <ref> [BO79, PS85] </ref> to solve this problem. The necessary extensions are quite straightforward. Whenever the Bentley-Ottmann algorithm reports that two segments have intersected, the algorithm must consider what happens to the two half-planes bounded by those segments. <p> This test seems quite efficient in practice, in part because the projection method already sorts the interval endpoints in preparation for the Bentley-Ottmann algorithm <ref> [BO79, PS85] </ref>. Even so, this test could be slow in the worst case, and an alternative test that prunes the number of space-time bounds it considers would be valuable. <p> The "faces" of such a structure would no longer be planar in four dimensions. Their projections into the ff-t plane would be quadratic curves, but a simple modification to the Bentley-Ottmann algorithm <ref> [BO79, PS85] </ref> allows it to find intersections between curves of this form. A new version of the projection method from Section 4.2.3 using this idea would do more work for each intersection, but the reduction in spurious intersections might improve the performance overall. <p> An algorithm based on the boundary lemma may not be the most efficient way to detect coverage in some situations. If the boundaries of the shapes consist of a small number of curves that have monotonically increasing y coordinates, then a variation of the Bentley-Ottmann algorithm <ref> [BO79, PS85] </ref> can find the intersections between these shapes efficiently. If, additionally, the region to be covered is a polygon, then the plane-sweep of the Bentley-Ottmann algorithm could work in conjunction with a structure like an interval tree to detect any gaps in the coverage by the shapes.
Reference: [BOT79] <author> Norman I. Badler, Joseph O'Rourke, and Hasida Toltzis. </author> <title> A Spherical Representation of a Human Body for Visualizing Movement. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> volume 67, number 10, </volume> <pages> pages 1397-1403, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: The next section of this chapter explores a related idea in more detail. The most interesting previous work is that of Badler, O'Rourke and Toltzis <ref> [BOT79, OB79] </ref>. They describe a greedy approach to making a union of spheres fill the volume inside an object. <p> These last three sections all draw heavily on the concepts of simulated annealing from Section 5.3. Section 6.3.5 concludes the discussion of building sphere-trees from medial-axis surfaces by presenting some results and comparing the approach to the related ideas of Badler, O'Rourke and Toltzis <ref> [BOT79, OB79] </ref>. 6.3.1 Merging Spheres Typically, the algorithm from Section 6.2 generates a large number of Voronoi vertices on an object's medial-axis surface. The spheres centered at these vertices approximate the shape of the object at a high level of detail. <p> The only other work on fitting spheres to 3D objects, other than simple approaches comparable to the octree approach from Section 5.2, is the work of Badler, O'Rourke and Toltzis <ref> [BOT79, OB79] </ref>. Their algorithm builds a set of spheres that fit just inside an object's surface. The spheres are anchored to points on the object's surface.
Reference: [Bow81] <author> Adrian Bowyer. </author> <title> Computing Dirichlet Tessellations. </title> <journal> The Computer Journal, </journal> <volume> volume 24, number 2, </volume> <pages> pages 162-166, </pages> <year> 1981. </year>
Reference-contexts: Bowyer <ref> [Bow81] </ref> describes a relatively straightforward algorithm for the Voronoi diagram of 3D points. This algorithm implicitly assumes infinite-precision arithmetic, however. Finite-precision arithmetic causes the algorithm to enter inconsistent states from which it cannot recover. Inagaki et al. [ISS92] discuss modifications to the algorithm that prevent inconsistencies.
Reference: [Boy79] <author> John W. Boyse. </author> <title> Interference Detection Among Solids and Surfaces. </title> <journal> Communications of the ACM, </journal> <volume> volume 22, number 1, </volume> <pages> pages 3-9, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: One of the earliest examples of this idea is the work of Boyse <ref> [Boy79] </ref>. He derives simple equations for the motion of polyhedral edges and faces over time; a root of any such equation corresponds to the time and location of a collision.
Reference: [Bro88] <author> Frederick P. Brooks, Jr. </author> <title> Grasping Reality Through Illusion|Interactive Graphics Serving Science. </title> <booktitle> In Proceedings of CHI '88, </booktitle> <pages> pages 1-11, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Opinions vary on the minimum acceptable frame rate. Airey et al. [ARB90] state that a rate of six frames per second (fps) is barely tolerable for building-walkthrough applications, while Funkhouser and Sequin [FS93] suggest 10 fps; in general, Brooks <ref> [Bro88] </ref> and Fuchs and Bishop [FB92] suggest that the goal should be 20 to 30 fps. Another important aspect of real-time performance is low latency (also called lag). Latency is the time between when a user instigates an action and when the user sees that action manifested in the application. <p> These simulators are important because they train users to operate complicated vehicles without risking injury to the users or damage to the vehicles. Since users need to learn to operate the vehicles without crashing into other objects, collision detection is important for these simulators. Another application is molecular modeling <ref> [Jan85, Bro88] </ref>. The effects of a drug molecule are determined, in part, by how it fits geometrically into a receptor site. Computer simulations that allow chemists to interactively test how molecules "dock" with each other are valuable tools in the design of new drugs.
Reference: [BV91] <author> William J. Bouma and George Vanecek, Jr. </author> <title> Collision Detection and Analysis in Physically Based Simulation. </title> <booktitle> In Proceedings of the Second Eurographics Workshop on Animation and Simulation, </booktitle> <pages> pages 191-203, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Vanecek describes an algorithm that intersects a line segment with a Brep-index, identifying the parts of the segment that are inside a polyhedron. Features of Brep-indices allow this algorithm to tolerate inaccuracy in floating-point operations. Bouma and Vanecek <ref> [BV91] </ref> use this algorithm to detect collisions between pairs of polyhedra.
Reference: [BW92] <author> David Baraff and Andrew Witkin. </author> <title> Dynamic Simulation of Non-Penetrating Flexible Bodies. </title> <booktitle> In Proceedings of SIGGRAPH '92, published as Computer Graphics, </booktitle> <volume> volume 26, number 2, </volume> <pages> pages 303-308, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Both collision detection and collision response pose interesting research problems, but this dissertation focuses on collision detection. Such a focus is reasonable because the geometric issues involved in collision detection are interesting and challenging. For a thorough discussion of issues in collision response, see the work of Baraff <ref> [Bar89, Bar90, Bar91, BW92] </ref>. 1 1.1 The Problem An increasingly important class of application programs are those that produce interactive animations. In an interactive application, human users directly control the course of events and receive immediate feedback from the application. <p> More sophisticated forms of collision response, such as those Baraff advocates <ref> [Bar89, Bar90, Bar91, BW92] </ref>, unfortunately do not lend themselves to time limits. This section has not distinguished between single-processor and multiple-processor applications. Multiple processors can help an application perform its activities more quickly, but they complicate the issue of latency. Wloka [Wlo94] discusses this problem and presents some pragmatic solutions.
Reference: [Cam89] <author> Stephen A. Cameron. </author> <title> Efficient Intersection Tests for Objects Defined Constructively. </title> <journal> International Journal of Robotics Research, </journal> <volume> volume 8, number 1, </volume> <pages> pages 3-25, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: This algorithm is a 4D extension of earlier work <ref> [Cam89] </ref>, which addresses the pair-processing weakness for CSG objects by using a technique called S-bounds. Viewing CSG models as trees of operations, S-bounds provide a way to prune nodes that do not matter for a possible collision between two trees.
Reference: [Cam90] <author> Stephen A. Cameron. </author> <title> Collision Detection by Four-Dimensional Intersection Testing. </title> <journal> IEEE Transactions on Robotics and Automation, </journal> <volume> volume 6, number 3, </volume> <pages> pages 291-302, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: For interactive applications, the main disadvantage of Canny's algorithm is the disadvantage shared by most 4D methods: the motion of all objects must be completely specified throughout simulation time. Interactive applications cannot meet this requirement, because a human user controls the motion of objects "on the fly." Cameron <ref> [Cam90] </ref> presents an algorithm that handles more complicated shapes than Canny's approach, in particular, objects specified by the constructive solid geometry (CSG) paradigm. This algorithm is a 4D extension of earlier work [Cam89], which addresses the pair-processing weakness for CSG objects by using a technique called S-bounds.
Reference: [Can86] <author> John Canny. </author> <title> Collision Detection for Moving Polyhedra. </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence, </journal> <volume> volume 8, number 2, </volume> <pages> pages 200-209, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: The assumptions of the algorithm limit its utility in practice, however. Lubachevsky [Lub91] presents a detailed description of a similar idea. His approach makes even more assumptions, though, limiting itself to spheres moving in straight lines on a plane ("pool balls"). 10 Canny <ref> [Can86] </ref> uses more elaborate analysis to process more general motion. He obtains quintic polynomials whose roots, found with iterative numerical techniques, describe the collisions between convex polyhedra. The motion this algorithm can handle is still not completely general, however; objects must have constant linear velocity and nearly-constant angular velocity.
Reference: [CCWG88] <author> Michael F. Cohen, Shengchang Eric Chen, John R. Wallace, and Donald P. </author> <title> Greenberg. </title>
Reference-contexts: The general idea of an interruptible computation that improves in quality with time appears by various names in other areas of graphics and computer science. Bergman et al. [BFGS86] introduced this idea in image rendering, calling it adaptive refinement. Cohen et al. <ref> [CCWG88] </ref> called this idea progressive refinement in the context of another approach to rendering. Dean and Boddy [DB88] first applied this idea to planning problems, calling the implementation an anytime algorithm.
References-found: 22

