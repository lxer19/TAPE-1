URL: http://www.cs.toronto.edu/~chechik/pubs/cus.ps
Refering-URL: http://www.cs.toronto.edu/~chechik/courses98/csc2108/readings.html
Root-URL: http://www.cs.toronto.edu
Email: fdimi,chechikg@cs.toronto.edu  
Title: Events in Linear-Time Properties  
Author: Dimitrie O. Paun Marsha Chechik 
Address: Toronto, ON M5S 3G4, Canada  
Affiliation: Department of Computer Science University of Toronto  
Abstract: For several decades, researchers in formal methods tried to create formalisms that permit natural specification of systems and allow mathematical reasoning about their correctness. The availability of fully-automated reasoning tools enables more non-specialists to use formal methods effectively | their responsibility reduces to just specifying the model and expressing the desired properties. Thus, it is essential that these properties be represented in a language that is easy to use and sufficiently expressive. Linear-time temporal logic [21] is a formalism that has been extensively used by researchers for specifying properties of systems. When such properties are closed under stuttering, i.e. their interpretation is not modified by idle transitions, verification tools can utilize a partial-order reduction technique [16] to reduce the size of the model and thus analyze larger systems. If LTL formulas do not contain the "next" operator, the formulas are closed under stuttering, but the resulting language is not expressive enough to capture many important properties, e.g., properties involving events. Determining if an arbitrary LTL formula is closed under stuttering is hard | it has been proven to be PSPACE-complete [26]. In this paper we relax the restriction on LTL that guarantees closure under stuttering, introduce the notion of edges in the context of LTL, and provide theorems that enable syntactic reasoning about closure under stuttering of LTL formulas. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport. </author> <title> "The Existence of Refinement Mappings". </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <year> 1991. </year>
Reference-contexts: Linear-time logic (LTL) [21] is a temporal logic that has been extensively used by researchers for specifying properties of systems. A highly desirable property of LTL formulas is that they are closed under stuttering <ref> [1] </ref>. In particular, the mechanical analysis of such formulas, such as by the model-checker SPIN [16], can utilize powerful partial-order reduction algorithms that can dramatically reduce the state-space of the model.
Reference: [2] <author> J.M. Atlee and J. Gannon. </author> <title> "State-Based Model Checking of Event-Driven System Requirements". </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 22-40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Recently, the tools for proving properties of finite-state models are becoming increasingly available and are often used for analyzing requirements, e.g. <ref> [2, 3, 10, 4] </ref>. These tools typically require the users to specify properties using temporal logics and to describe models of systems using some finite-state transition representation. The tools are based on a variety of verification techniques.
Reference: [3] <author> Ramesh Bharadwaj and Connie Heitmeyer. </author> <title> "Model Checking Complete Requirements Specifications Using Abstraction". </title> <type> Memorandum Report NRL/MR/5540-97-7999, </type> <institution> Naval Research Laboratory, </institution> <address> Washington, D.C., </address> <month> November </month> <year> 1997. </year>
Reference-contexts: Recently, the tools for proving properties of finite-state models are becoming increasingly available and are often used for analyzing requirements, e.g. <ref> [2, 3, 10, 4] </ref>. These tools typically require the users to specify properties using temporal logics and to describe models of systems using some finite-state transition representation. The tools are based on a variety of verification techniques.
Reference: [4] <author> M. Chechik. </author> <title> "SC(R) 3 : Towards Usability of Formal Methods". </title> <booktitle> In Proceedings of CASCON'98, </booktitle> <pages> pages 177-191, </pages> <month> November </month> <year> 1998. </year>
Reference-contexts: Recently, the tools for proving properties of finite-state models are becoming increasingly available and are often used for analyzing requirements, e.g. <ref> [2, 3, 10, 4] </ref>. These tools typically require the users to specify properties using temporal logics and to describe models of systems using some finite-state transition representation. The tools are based on a variety of verification techniques.
Reference: [5] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. "Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Currently, the properties can be expressed in a variety of formalisms such as LTL, computational tree logic (CTL) <ref> [5] </ref>, quantified regular expressions (QRE) [23], and other state-based and event-based formalisms. The patterns are organized in a hierarchy based on their semantics, as illustrated in Figure 3.
Reference: [6] <author> Rance Cleaveland, Joachim Parrow, and Bernhard Steffen. </author> <title> "The Concurrency Workbench: A Semantics Based Tool for the Verification of Concurrent Systems". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 36-72, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The tools are based on a variety of verification techniques. For example, SPIN [16] and SMV [22] are based on state-space exploration, also called model-checking, Concurrency Workbench <ref> [6] </ref> on bisimulation, and COSPAN [11] on language containment. Most finite-state verification techniques can be fully automated, and the responsibility of the user reduces to just specifying the model and expressing the desired properties.
Reference: [7] <author> Matthew B. Dwyer, George S. Avrunin, and James C. Corbett. </author> <title> "A System of Specification Patterns". Patterns catalog is available at http://www.cis.ksu. edu/"verb1~1dwyer/spec-patterns.html. A collection of over 500 temporal properties is available at http://www.cis.ksu.edu/"verb1~1dwyer/SPAT/ SURVEY/ALL.raw, </title> <year> 1997. </year>
Reference-contexts: We also looked at over 500 temporal formulas collected by Dwyer and his colleagues <ref> [7, 8] </ref> and found virtually no explicit usage of events or the "next" operator. This led us to conclude that the community is almost religiously avoiding the "next" state operator, replacing it with a variety of surrogates, most of which are neither elegant nor expressive.
Reference: [8] <author> Matthew B. Dwyer, George S. Avrunin, and James C. Corbett. </author> <title> "Patterns in Property Specifications for Finite-State Verification". </title> <note> (submitted to ICSE'99), </note> <month> August </month> <year> 1998. </year>
Reference-contexts: The formula can be fixed by considering the consequent in the "next" state: 2 (#hold ) ffi (:hold U sensor )) 5 Edges and Patterns A pattern-based approach to the presentation, codification and reuse of property specifications for finite-state verification was proposed by Dwyer and his colleagues in <ref> [8, 9] </ref>. They performed a large-scale study 2 Note that we can move the detection of the edge after it occurs if we replace the "next" by the "previous" operator. in which specifications containing over 500 temporal properties were collected and analyzed. <p> They noticed that over 90% of these could be classified under one of the proposed patterns <ref> [8] </ref>. We discuss two directions for integrating our work into the pattern system: extending the system to include events based on edges, and evaluating the effectiveness of our theorems in determining closure under stuttering for the newly created, edge-based formulas. <p> Property Patterns Absence Bounded Existence Response Response Universality Precedence Precedence Chain Chain Occurrence Order Existence PSfrag replacements s 0 s 2 s 4 s 6 s 8 ffiB These scopes are depicted in Figure 4. The scopes were initially defined in <ref> [8] </ref> to be closed-left, open-right intervals, although it is also possible to define other combinations, such as open-left, closed-right intervals. <p> We also looked at over 500 temporal formulas collected by Dwyer and his colleagues <ref> [7, 8] </ref> and found virtually no explicit usage of events or the "next" operator. This led us to conclude that the community is almost religiously avoiding the "next" state operator, replacing it with a variety of surrogates, most of which are neither elegant nor expressive.
Reference: [9] <author> Matthew B. Dwyer, George S. Avrunin, and James C. Corbett. </author> <title> "Property Specification Patterns for Finite-state Verification". </title> <booktitle> In Proceedings of 2nd Workshop on Formal Methods in Software Practice, </booktitle> <month> March </month> <year> 1998. </year>
Reference-contexts: Section 3 discusses closure under stuttering and introduces edges. Section 4 gives some important properties of edges and closure under stuttering. Section 5 describes an application of this work to property patterns identified by Dwyer and his colleagues in <ref> [9] </ref>. We discuss some alternative approaches in Section 6 and conclude the paper in Section 7. 2 Background We begin by briefly introducing our notation which we have adopted from [12]. A sequence (or string) is a succession of elements joined by semicolons. <p> The formula can be fixed by considering the consequent in the "next" state: 2 (#hold ) ffi (:hold U sensor )) 5 Edges and Patterns A pattern-based approach to the presentation, codification and reuse of property specifications for finite-state verification was proposed by Dwyer and his colleagues in <ref> [8, 9] </ref>. They performed a large-scale study 2 Note that we can move the detection of the edge after it occurs if we replace the "next" by the "previous" operator. in which specifications containing over 500 temporal properties were collected and analyzed. <p> In the rest of the section we briefly discuss the property pattern system (following the presentation in <ref> [9] </ref>), describe our extensions based on the usage of edges, and conclude with discussing closure under stuttering. 5.1 The Pattern System The patterns enable non-experts to read and write formal specifications for realistic systems and facilitate easy conversion of specifications between formalisms. <p> s 2 s 4 s 6 s 8 ffiB For example, an LTL formulation of the property "S precedes P between Q and R" (Precedence pattern with "between Q and R" scope) is: 2 ((Q ^ 3R) ) (:P U (S _ R))) Even though the pattern system is formalism-independent <ref> [9] </ref>, we are only interested in the way the patterns are expressed in LTL. 5.2 Events in LTL Patterns It is often natural to express properties using changes of states | edges. As the original pattern system was state-based, we tried to extend it by incorporating edge-based events. <p> P , S | states, Q, R | up edges; 2. P , S | up edges, Q, R | states; 3. P , S | up edges, Q, R | up edges. Combination 0 corresponds to the original formulation of <ref> [9] </ref>, where all of P , S, Q and R are state-based. The remaining three combinations are our extensions of the pattern system. We assume that multiple events can happen simultaneously, but only consider closed-left, open-right intervals, as in the original system. <p> Each of the scopes is associated with four formulas corresponding to the four combinations of state-based and edge-based conditions and interval bounds we have considered. We have modified several of the 0-formulas (i.e. state-based conditions and intervals) from their original formulations of <ref> [9] </ref> to remove assumptions of interleaving and make them consistent with the left-closed, right-open intervals. For brevity, this is the only pattern that we detail in this paper. We are currently working on integrating our work into the pattern system of Dwyer and his colleagues. <p> We have also provided a number of theorems that enable syntax-based analysis of a large class of formulas for closure under stuttering. These theorems can be easily added to a theorem prover for mechanized checking. In addition, we extended the patterns identified in <ref> [9] </ref> with event-based formulations, and proved that the resulting formulas are closed under stuttering using the theorems presented in this paper.
Reference: [10] <author> Steve Easterbrook, Robyn Lutz, Richard Covington, John Kelly, Yoko Ampo, and David Hamilton. </author> <title> "Experience Using Lightweight Formal Methods for Requirements Modeling". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 24(1) </volume> <pages> 4-14, </pages> <month> January </month> <year> 1998. </year>
Reference-contexts: Recently, the tools for proving properties of finite-state models are becoming increasingly available and are often used for analyzing requirements, e.g. <ref> [2, 3, 10, 4] </ref>. These tools typically require the users to specify properties using temporal logics and to describe models of systems using some finite-state transition representation. The tools are based on a variety of verification techniques.
Reference: [11] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtull-Trauring, and M. Trakhtenbrot. "STATEMATE: </author> <title> A Working Environment for the Development of Complex Reactive Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 403-414, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: The tools are based on a variety of verification techniques. For example, SPIN [16] and SMV [22] are based on state-space exploration, also called model-checking, Concurrency Workbench [6] on bisimulation, and COSPAN <ref> [11] </ref> on language containment. Most finite-state verification techniques can be fully automated, and the responsibility of the user reduces to just specifying the model and expressing the desired properties.
Reference: [12] <author> Eric C.R. Hehner. </author> <title> A Practical Theory of Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Section 5 describes an application of this work to property patterns identified by Dwyer and his colleagues in [9]. We discuss some alternative approaches in Section 6 and conclude the paper in Section 7. 2 Background We begin by briefly introducing our notation which we have adopted from <ref> [12] </ref>. A sequence (or string) is a succession of elements joined by semicolons. For example, we write the sequence composed of the first five natural numbers, in order, as 0; 1; 2; 3; 4 or, more compactly, as 0; ::5 (note the left-closed, right-open interval).
Reference: [13] <author> C. Heitmeyer, R. Jeffords, and B. Labaw. </author> <title> "Automated Consistency Checking of Requirements Specifications". </title> <journal> Transactions on Software Engineering and Methodology, </journal> <year> 1996. </year>
Reference-contexts: :A ^ ffi A | up or rising edge #A = A ^ ffi:A | down or falling edge lA = "A _ #A | any edge The edges are also called events, as they capture the same notion as the events proposed by the Software Cost Reduction (SCR) researchers <ref> [14, 13] </ref>. However, the SCR events are defined just on propositional formulas, whereas our formalism also enables reasoning about events on LTL formulas. For example, a formula "2A has a well-defined interpretation in our language. We also note here a strong analogy between our (logical) edges and signal edges.
Reference: [14] <author> K. Heninger. </author> <title> "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-12, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: :A ^ ffi A | up or rising edge #A = A ^ ffi:A | down or falling edge lA = "A _ #A | any edge The edges are also called events, as they capture the same notion as the events proposed by the Software Cost Reduction (SCR) researchers <ref> [14, 13] </ref>. However, the SCR events are defined just on propositional formulas, whereas our formalism also enables reasoning about events on LTL formulas. For example, a formula "2A has a well-defined interpretation in our language. We also note here a strong analogy between our (logical) edges and signal edges.
Reference: [15] <author> G. J. Holzmann and O. Kupferman. </author> <title> "Not Check--ing for Closure under Stuttering". </title> <booktitle> In Proceedings of SPIN'96, </booktitle> <year> 1996. </year>
Reference-contexts: Even though a complete solution is impractical, we can attempt to categorize a subset that is useful in practice. In particular, a com-putationally feasible algorithm which can identify a subclass of closed under stuttering formulas has been proposed in <ref> [15] </ref> but not yet implemented in SPIN. The algorithm is fairly sophisticated and cannot be applied by hand. Moreover, it is not clear how often the subclass of formulas identified by the algorithm is encountered in practice.
Reference: [16] <author> G.J. Holzmann. </author> <title> "The Model Checker SPIN". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 23(5) </volume> <pages> 279-295, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: These tools typically require the users to specify properties using temporal logics and to describe models of systems using some finite-state transition representation. The tools are based on a variety of verification techniques. For example, SPIN <ref> [16] </ref> and SMV [22] are based on state-space exploration, also called model-checking, Concurrency Workbench [6] on bisimulation, and COSPAN [11] on language containment. Most finite-state verification techniques can be fully automated, and the responsibility of the user reduces to just specifying the model and expressing the desired properties. <p> Linear-time logic (LTL) [21] is a temporal logic that has been extensively used by researchers for specifying properties of systems. A highly desirable property of LTL formulas is that they are closed under stuttering [1]. In particular, the mechanical analysis of such formulas, such as by the model-checker SPIN <ref> [16] </ref>, can utilize powerful partial-order reduction algorithms that can dramatically reduce the state-space of the model. <p> This means that the approximation cannot be used for checking the validity of the model. Combining conservative and optimistic approximations can void the resulting formula of any meaning. The model-checker SPIN <ref> [16] </ref> probably constitutes the largest number of LTL users 3 .
Reference: [17] <author> Moataz Kamel and Stefan Leue. </author> <title> "Validation of Remote Object Invocation and Object Migration in CORBA GIOP using Promela/Spin". </title> <booktitle> In Proceedings of SPIN'98, </booktitle> <address> Paris, France, </address> <month> November </month> <year> 1998. </year>
Reference-contexts: However, judging from the four years of proceedings of the SPIN workshop, available at [20], they seldom if ever use properties involving events because of the common misconception that no formulas containing "next" are closed under stuttering, expressed, e.g., by Kamel and Leue in <ref> [17] </ref>. This is, in our opinion, a serious problem because we believe that edges are required to express most nontrivial properties.
Reference: [18] <author> Leslie Lamport. </author> <title> "The Temporal Logic of Actions". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16 </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: In particular, the mechanical analysis of such formulas, such as by the model-checker SPIN [16], can utilize powerful partial-order reduction algorithms that can dramatically reduce the state-space of the model. Unfortunately, closure under stuttering can be guaranteed only for a subset of LTL <ref> [18] </ref>, and this subset is not expressive enough to represent even fairly simple properties, such as: The magnet of the crane may be deactivated only when the magnet is above the feed belt. <p> A restricted use of "next", similar to ours, is also advocated by Lamport in his Temporal Language of Actions (TLA) <ref> [18] </ref>, where "next" is replaced by "primed variables", e.g., a 0 indicates the value of a in the next state. However, this is not sufficient to guarantee closure under stuttering and an additional restriction is placed on the TLA formulas.
Reference: [19] <author> Claus Lewerentz and Thomas Lindner, </author> <title> editors. Formal Development of Reactive Systems. Case Study Production Cell. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year> <title> [20] "On the Fly, LTL Model-checking with SPIN". Description of the model-checker and pointers to proceedings of SPIN workshops are available at http://netlib.bell-labs.com/netlib/spin/ whatispin.html. </title>
Reference-contexts: This is, in our opinion, a serious problem because we believe that edges are required to express most nontrivial properties. For example, during our work [25] on the Production Cell <ref> [19] </ref>, edges were required in 10 out of 14 properties that we formalized, and in many of these, simulating edges by introducing extra variables was not possible.
Reference: [21] <author> Z. Manna and A. Pnueli. </author> <title> "The Anchored Version of the Temporal Framework". In W.P. </title> <editor> de Roever J.W. de Bakker and G. Rozenburg, editors, </editor> <title> Models of Concurrency: Linear, Branching and Partial Orders, </title> <publisher> LNCS. Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: In this context, it is important that properties can be represented in a language that is easy to use and sufficiently expressive, to enable even fairly novice users to use it effectively. Linear-time logic (LTL) <ref> [21] </ref> is a temporal logic that has been extensively used by researchers for specifying properties of systems. A highly desirable property of LTL formulas is that they are closed under stuttering [1].
Reference: [22] <author> K.L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic, </publisher> <year> 1993. </year>
Reference-contexts: These tools typically require the users to specify properties using temporal logics and to describe models of systems using some finite-state transition representation. The tools are based on a variety of verification techniques. For example, SPIN [16] and SMV <ref> [22] </ref> are based on state-space exploration, also called model-checking, Concurrency Workbench [6] on bisimulation, and COSPAN [11] on language containment. Most finite-state verification techniques can be fully automated, and the responsibility of the user reduces to just specifying the model and expressing the desired properties.
Reference: [23] <author> Kurt M. Olender and Leon J. Osterweil. "Cecil: </author> <title> A Sequencing Constraint Language for Automatic Static Analysis Generation". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 268-280, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Currently, the properties can be expressed in a variety of formalisms such as LTL, computational tree logic (CTL) [5], quantified regular expressions (QRE) <ref> [23] </ref>, and other state-based and event-based formalisms. The patterns are organized in a hierarchy based on their semantics, as illustrated in Figure 3.
Reference: [24] <author> Dimi Paun. </author> <title> Closure Under Stuttering in Temporal Formulas. M.Sc. </title> <type> thesis, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1999. </year> <note> (In preparation). </note>
Reference-contexts: Note that, although the property is fairly complicated, the proof is not long, is completely syntactic, and each step in it is easy. Similar proofs were found for all of the new edge-based formulas <ref> [24] </ref>. Such proofs can potentially be performed by a theorem-prover like PVS [28] with little guidance from the user.
Reference: [25] <author> Dimi Paun, Marsha Chechik, and Bernd Biechelle. </author> <title> "Production Cell Revisited". </title> <booktitle> In Proceedings of SPIN'98, </booktitle> <month> November </month> <year> 1998. </year>
Reference-contexts: This is, in our opinion, a serious problem because we believe that edges are required to express most nontrivial properties. For example, during our work <ref> [25] </ref> on the Production Cell [19], edges were required in 10 out of 14 properties that we formalized, and in many of these, simulating edges by introducing extra variables was not possible.
Reference: [26] <author> Doron Peled, Thomas Wilke, and Pierre Wolper. </author> <title> "An Algorithmic Approach for Checking Closure Properties of !-Regular Languages". </title> <booktitle> In Proceedings of CONCUR '96: 7th International Conference on Concur-rency Theory, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: Determining whether an LTL formula is closed under stuttering is hard: the problem has been shown to be PSPACE-complete <ref> [26] </ref>. Even though a complete solution is impractical, we can attempt to categorize a subset that is useful in practice. In particular, a com-putationally feasible algorithm which can identify a subclass of closed under stuttering formulas has been proposed in [15] but not yet implemented in SPIN.
Reference: [27] <author> D. Rosenblum. </author> <title> "Formal Methods and Testing: Why the State-of-the-Art is not the State-of-the-Practice?". </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 21(4), </volume> <month> July </month> <year> 1996. </year> <title> (ISSTA'96/FMSP'96 panel summary). </title>
Reference-contexts: However, most of these formalisms have not been adopted widely outside academia | their cost-saving benefits were doubtful, they lacked tool support, and were perceived difficult to apply <ref> [27] </ref>. Recently, the tools for proving properties of finite-state models are becoming increasingly available and are often used for analyzing requirements, e.g. [2, 3, 10, 4]. These tools typically require the users to specify properties using temporal logics and to describe models of systems using some finite-state transition representation.
Reference: [28] <author> N. Shankar, S. Owre, and J. Rushby. </author> <title> "The PVS Proof Checker: A Reference Manual (Beta Release)". </title> <type> Technical report, </type> <institution> Computer Science Lab, SRI International, </institution> <address> Menlo Park, CA, </address> <month> March </month> <year> 1993. </year>
Reference-contexts: Note that, although the property is fairly complicated, the proof is not long, is completely syntactic, and each step in it is easy. Similar proofs were found for all of the new edge-based formulas [24]. Such proofs can potentially be performed by a theorem-prover like PVS <ref> [28] </ref> with little guidance from the user. We are currently investigating the feasibility of doing so. 6 Discussion and Related Work Before writing this paper, we searched through numerous research publications and web sites, looking for good examples of LTL formulas containing the A.
References-found: 27

