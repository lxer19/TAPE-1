URL: ftp://cse.ogi.edu/pub/dsrg/HOPE/performance.ps.Z
Refering-URL: http://www.cse.ogi.edu/~crispin/
Root-URL: http://www.cse.ogi.edu
Email: crispin@cse.ogi.edu  hanan@csd.uwo.ca bauer@csd.uwo.ca  
Title: Performance Benefits of Optimistic Programming: A Measure of HOPE  
Author: Crispin Cowan Hanan L. Lutfiyya and Michael A. Bauer 
Date: February 2, 1995  
Address: P.O. Box 91000 Portland, OR 97291-1000  Ontario London, Ontario N6A 5B7  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute  Computer Science Department University of Western  
Abstract: Optimism is a powerful technique for avoiding latency by increasing concurrency. By optimistically assuming the results of some computation, other computations can be executed in parallel, even when they depend on the assumed result. Optimistic techniques can be particularly beneficial to parallel and distributed systems because of the critical impact of inter-node communications latency. This paper describes how optimism can be used to enhance the performance of distributed programs by avoiding remote communications delay. We then present a new programming model that automates many of the difficulties of using optimistic techniques in a general programming environment, and describe a prototype implementation. Finally, we present performance measurements showing how optimism improved the performance of a test application in this environment. Keywords: optimism, concurrency, parallelism, distributed computing, rollback, im plementation, performance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David F. Bacon and Robert E. Strom. </author> <title> Optimistic Parallelization of Communicating Sequential Processes. </title> <booktitle> In Third ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <month> April </month> <year> 1991. </year> <month> 23 </month>
Reference-contexts: S 2 takes the line number and checks to see if the line number now exceeds page size. If it does, then S 2 creates a new page; otherwise execution can immediately proceed to S 3 . Bacon and Strom <ref> [1] </ref> present an algorithm for optimistically parallelizing two such statements (Call Streaming).
Reference: [2] <author> Rajive L. Bagrodia and Wen-Toh Liao. Maisie: </author> <title> A Language for the Design of Efficient Discrete-Event Simulations. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(4) </volume> <pages> 225-238, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication [7, 15, 20, 24, 28], concurrency control [16, 18, 21, 30], and discrete event simulation <ref> [2, 13, 17, 25, 29] </ref>. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms. Writing optimistic algorithms are difficult, time-consuming, and ad hoc, since an optimistic programmer must handle the following issues.
Reference: [3] <author> R.G. Bubenik. </author> <title> Optimistic Computation. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: Previous work in supporting optimistic programming includes <ref> [3, 4, 18, 22, 27] </ref>. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [9]. In [27], computation based on an optimistic assumption is limited to the scope of an if or while statement. <p> However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [9]. In [27], computation based on an optimistic assumption is limited to the scope of an if or while statement. In <ref> [3, 4] </ref>, computation based on an optimistic assumption is limited to the scope of a previously defined encapsulation. All encapsulations must be defined ahead of this time.
Reference: [4] <author> Rick Bubenik and Willy Zwaenepoel. </author> <title> Semantics of Optimistic Computation. </title> <booktitle> In 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 20-27, </pages> <year> 1990. </year>
Reference-contexts: Previous work in supporting optimistic programming includes <ref> [3, 4, 18, 22, 27] </ref>. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [9]. In [27], computation based on an optimistic assumption is limited to the scope of an if or while statement. <p> However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [9]. In [27], computation based on an optimistic assumption is limited to the scope of an if or while statement. In <ref> [3, 4] </ref>, computation based on an optimistic assumption is limited to the scope of a previously defined encapsulation. All encapsulations must be defined ahead of this time.
Reference: [5] <author> N. Carriero and D. Gelernter. </author> <title> Linda in Context. </title> <journal> Communications of the ACM, </journal> <volume> 31(4) </volume> <pages> 444-458, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Rather, it is programming model for optimism, embodied as a set of primitives designed to be embedded in some other programming language, similar to Linda <ref> [5] </ref>. There are very few restrictions on the kinds of distributed systems in which HOPE can be embedded. HOPE can be embedded in any system providing concurrent processes that communicate with messages.
Reference: [6] <author> G. V. Cormack. </author> <title> A formalism for real-time distributed lock-free conference editing. </title> <type> private communication. </type>
Reference-contexts: We have also done preliminary investigations into the application of HOPE to replication [7] and scientific programming [8]. In future work, we will also extend the application of optimism beyond its traditional domains into new areas such as truth maintenance systems [12] and co-operative work <ref> [6] </ref>. 22 7 Acknowledgments HOPE was inspired by optimism studies at the IBM T.J. Watson Research Center. The initial inspiration for HOPE came from discussions with Robert E. Strom.
Reference: [7] <author> Crispin Cowan. </author> <title> Optimistic Replication in HOPE. </title> <booktitle> In Proceedings of the 1992 CAS Conference, </booktitle> <pages> pages 269-282, </pages> <address> Toronto, Ontario, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: If the assumption is discovered to be correct, then latency has been avoided and performance has improved. However, if the assumption is incorrect, then all computations that used the assumption must be rolled back and re-executed using correct data. Optimism has been used in various areas to enhance performance <ref> [7, 15, 26, 28] </ref>. However, optimism is mostly embedded inside systems, and not exposed to the applications programmer. Optimism is not often used in applications because optimistic programs are difficult to write and require ad hoc techniques to implement. <p> This paper presents HOPE (Hopefully Optimistic Programming Environment): a programming model for expressing optimism. Previously, we have defined the HOPE programming model and its applicability <ref> [7, 10, 23] </ref>. We have constructed a prototype HOPE system [8], defined a formal semantics for HOPE [11], and proved that some important properties of the prototype implementation are consistent with the formal semantics [9]. <p> Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication <ref> [7, 15, 20, 24, 28] </ref>, concurrency control [16, 18, 21, 30], and discrete event simulation [2, 13, 17, 25, 29]. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms. <p> The full generality of aggressive optimism is necessary for some kinds of applications, such as optimistic replication protocols <ref> [7] </ref>. However, aggressive optimism may not always deliver the best performance. To test the performance impact of speculative affirm, the response times of both aggressive and conservative optimistic programs are compared to the response times of the pessimistic programs. <p> The experiments presented exhibit a number of interesting artifacts which merit further investigation. Call Streaming is not the only kind of optimistic algorithm. In particular, an investigation should be made into the performance of optimistic replication algorithms, which often require speculative affirm primitives to function correctly <ref> [7] </ref>. However, these experiments have shown that the HOPE prototype system can deliver performance gains in program response time for all optimistic assumptions relating to remote operations tested taking more than 2.0 seconds and having a greater than 60% chance of producing the expected result. <p> We have also done preliminary investigations into the application of HOPE to replication <ref> [7] </ref> and scientific programming [8]. In future work, we will also extend the application of optimism beyond its traditional domains into new areas such as truth maintenance systems [12] and co-operative work [6]. 22 7 Acknowledgments HOPE was inspired by optimism studies at the IBM T.J. Watson Research Center.
Reference: [8] <author> Crispin Cowan. </author> <title> Optimistic Programming in PVM. </title> <booktitle> In Proceedings of the 2nd PVM User's Group Meeting, </booktitle> <institution> Oak Ridge, TN, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: This paper presents HOPE (Hopefully Optimistic Programming Environment): a programming model for expressing optimism. Previously, we have defined the HOPE programming model and its applicability [7, 10, 23]. We have constructed a prototype HOPE system <ref> [8] </ref>, defined a formal semantics for HOPE [11], and proved that some important properties of the prototype implementation are consistent with the formal semantics [9]. This paper presents the performance results of using HOPE's optimistic primitives to avoid computational latency, specifically communications latency. <p> We have also done preliminary investigations into the application of HOPE to replication [7] and scientific programming <ref> [8] </ref>. In future work, we will also extend the application of optimism beyond its traditional domains into new areas such as truth maintenance systems [12] and co-operative work [6]. 22 7 Acknowledgments HOPE was inspired by optimism studies at the IBM T.J. Watson Research Center.
Reference: [9] <author> Crispin Cowan. </author> <title> A Programming Model for Optimism. </title> <type> PhD thesis, </type> <institution> University of Western Ontario, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Previously, we have defined the HOPE programming model and its applicability [7, 10, 23]. We have constructed a prototype HOPE system [8], defined a formal semantics for HOPE [11], and proved that some important properties of the prototype implementation are consistent with the formal semantics <ref> [9] </ref>. This paper presents the performance results of using HOPE's optimistic primitives to avoid computational latency, specifically communications latency. The rest of this paper is organized as follows. Section 2 describes optimism in more detail. Section 3 describes the HOPE programming model and presents an example. <p> Previous work in supporting optimistic programming includes [3, 4, 18, 22, 27]. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation <ref> [9] </ref>. In [27], computation based on an optimistic assumption is limited to the scope of an if or while statement. In [3, 4], computation based on an optimistic assumption is limited to the scope of a previously defined encapsulation. All encapsulations must be defined ahead of this time. <p> AID processes track the set of processes that depend on the associated assumption identifier. Further details of 10 the implementation algorithm, including proofs that the implementation is consistent with HOPE's formal semantics [11], can be found in <ref> [9] </ref>. 5 Performance Results Our main purpose in this paper is to demonstrate that the HOPE prototype is a useful tool for writing optimistic programs by demonstrating that it can deliver performance gains. <p> In other work, we have defined a formal semantics for the HOPE programming model [11], and proved that some important properties of the algorithms used in the implementation described here are consistent with the formal semantics <ref> [9] </ref>. We have also done preliminary investigations into the application of HOPE to replication [7] and scientific programming [8].
Reference: [10] <author> Crispin Cowan, Hanan Lutfiyya, and Mike Bauer. </author> <title> Increasing Concurrency Through Optimism: A Reason for HOPE. </title> <booktitle> In Proceedings of the 1994 ACM Computer Science Conference, </booktitle> <pages> pages 218-225, </pages> <address> Phoenix, Arizona, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: This paper presents HOPE (Hopefully Optimistic Programming Environment): a programming model for expressing optimism. Previously, we have defined the HOPE programming model and its applicability <ref> [7, 10, 23] </ref>. We have constructed a prototype HOPE system [8], defined a formal semantics for HOPE [11], and proved that some important properties of the prototype implementation are consistent with the formal semantics [9]. <p> The pessimistic program in this example specifies the meaning of the optimistic constructs being illustrated. 3.1 Example A program increases its concurrency by making an optimistic assumption about its future state and verifying the assumption in parallel with computations based on the optimistic assumption <ref> [10] </ref>. If a computation proceeds based on an optimistic assumption and that assumption is shown to be incorrect, then all computations predicated on that assumption must be rolled back to correct for the incorrect assumption.
Reference: [11] <author> Crispin Cowan, Hanan Lutfiyya, and Mike Bauer. </author> <title> Formal Semantics for Expressing Optimism: The Meaning of HOPE. </title> <note> Submitted for review, </note> <month> January </month> <year> 1995. </year>
Reference-contexts: This paper presents HOPE (Hopefully Optimistic Programming Environment): a programming model for expressing optimism. Previously, we have defined the HOPE programming model and its applicability [7, 10, 23]. We have constructed a prototype HOPE system [8], defined a formal semantics for HOPE <ref> [11] </ref>, and proved that some important properties of the prototype implementation are consistent with the formal semantics [9]. This paper presents the performance results of using HOPE's optimistic primitives to avoid computational latency, specifically communications latency. The rest of this paper is organized as follows. <p> AID processes track the set of processes that depend on the associated assumption identifier. Further details of 10 the implementation algorithm, including proofs that the implementation is consistent with HOPE's formal semantics <ref> [11] </ref>, can be found in [9]. 5 Performance Results Our main purpose in this paper is to demonstrate that the HOPE prototype is a useful tool for writing optimistic programs by demonstrating that it can deliver performance gains. <p> These primitives have been implemented, and we have shown that they can provide performance improvements of up to 70% to distributed applications under some well-defined general circumstances. In other work, we have defined a formal semantics for the HOPE programming model <ref> [11] </ref>, and proved that some important properties of the algorithms used in the implementation described here are consistent with the formal semantics [9]. We have also done preliminary investigations into the application of HOPE to replication [7] and scientific programming [8].
Reference: [12] <author> J. Doyle. </author> <title> A Truth Maintenance System. </title> <journal> Artificial Intelligence, </journal> <volume> 12 </volume> <pages> 231-272, </pages> <year> 1979. </year>
Reference-contexts: We have also done preliminary investigations into the application of HOPE to replication [7] and scientific programming [8]. In future work, we will also extend the application of optimism beyond its traditional domains into new areas such as truth maintenance systems <ref> [12] </ref> and co-operative work [6]. 22 7 Acknowledgments HOPE was inspired by optimism studies at the IBM T.J. Watson Research Center. The initial inspiration for HOPE came from discussions with Robert E. Strom.
Reference: [13] <author> Richard M. Fujimoto. </author> <title> The Virtual Time Machine. </title> <journal> Computer Architecture News, </journal> <volume> 19(1) </volume> <pages> 35-44, </pages> <month> March </month> <year> 1991. </year> <booktitle> Re-printed from the Symposium on Parallel Algorithms and Architectures 1990. </booktitle>
Reference-contexts: Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication [7, 15, 20, 24, 28], concurrency control [16, 18, 21, 30], and discrete event simulation <ref> [2, 13, 17, 25, 29] </ref>. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms. Writing optimistic algorithms are difficult, time-consuming, and ad hoc, since an optimistic programmer must handle the following issues.
Reference: [14] <author> Al Geist, Adam Geguelin, Jack Dongarra, Wicheng Jiang, Robert Manchek, and Vaidy Sunderam. </author> <title> PVM: Parallel Virtual Machine, a Users' Guide and Tutorial for Networked Parallel Computing. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: Thus it was determined that HOPE should be built on top of a pre-existing message passing environment, preferably one with a large user base. The PVM system <ref> [14] </ref> was selected as the first target environment for HOPE. PVM (Parallel Virtual Machine) is a software package that allows a network of computers to appear as a single concurrent computational resource.
Reference: [15] <author> Arthur P. Goldberg. </author> <title> Optimistic Algorithms for Distributed Transparent Process Replication. </title> <type> PhD thesis, </type> <institution> University of California at Los Angeles, </institution> <year> 1991. </year> <note> (UCLA Tech. Report CSD-910050). </note>
Reference-contexts: If the assumption is discovered to be correct, then latency has been avoided and performance has improved. However, if the assumption is incorrect, then all computations that used the assumption must be rolled back and re-executed using correct data. Optimism has been used in various areas to enhance performance <ref> [7, 15, 26, 28] </ref>. However, optimism is mostly embedded inside systems, and not exposed to the applications programmer. Optimism is not often used in applications because optimistic programs are difficult to write and require ad hoc techniques to implement. <p> Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication <ref> [7, 15, 20, 24, 28] </ref>, concurrency control [16, 18, 21, 30], and discrete event simulation [2, 13, 17, 25, 29]. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms.
Reference: [16] <author> Maurice Herlihy. </author> <title> Apologizing Versus Asking Permission: Optimistic Concurrency Control for Abstract Data Types. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(1) </volume> <pages> 96-124, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication [7, 15, 20, 24, 28], concurrency control <ref> [16, 18, 21, 30] </ref>, and discrete event simulation [2, 13, 17, 25, 29]. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms.
Reference: [17] <author> D. Jefferson. </author> <title> Virtual Time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(7) </volume> <pages> 404-425, </pages> <month> July </month> <year> 1985. </year> <month> 24 </month>
Reference-contexts: Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication [7, 15, 20, 24, 28], concurrency control [16, 18, 21, 30], and discrete event simulation <ref> [2, 13, 17, 25, 29] </ref>. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms. Writing optimistic algorithms are difficult, time-consuming, and ad hoc, since an optimistic programmer must handle the following issues. <p> It is a theorem due to Jefferson <ref> [17] </ref> that the amount of time "wasted" on speculative computations based on incorrect optimistic assumptions would have been spent blocked waiting for results 18 in a pessimistic program. The only penalty for using optimism is the extra time required to perform checkpointing, dependency tracking, and rollback.
Reference: [18] <author> D. Jefferson and A. Motro. </author> <title> The Time Warp Mechanism for Database Concurrency Con--trol. </title> <type> Report Technical Report TR-84-302, </type> <institution> University of Southern California, </institution> <month> January </month> <year> 1984. </year>
Reference-contexts: Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication [7, 15, 20, 24, 28], concurrency control <ref> [16, 18, 21, 30] </ref>, and discrete event simulation [2, 13, 17, 25, 29]. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms. <p> Previous work in supporting optimistic programming includes <ref> [3, 4, 18, 22, 27] </ref>. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [9]. In [27], computation based on an optimistic assumption is limited to the scope of an if or while statement. <p> All encapsulations must be defined ahead of this time. This means that dependency tracking is not necessary, but it also means that the range of computation based on an optimistic assumption is statically bound. In Time Warp <ref> [18] </ref>, the amount of computation based on a optimistic assumption is not statically bound, but only one kind of optimistic assumption can be made. 2.2 HOPE Features Any optimistic assumption can be made, and any method can be used to verify an optimistic assumption, including a method selected at run-time.
Reference: [19] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Recovery in Distributed Systems using Optimistic Message Logging and Checkpointing. </title> <journal> J. Algorithms, </journal> <volume> 11(3) </volume> <pages> 462-491, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Optimistic programs have been used in a variety of applications such as fault tolerance <ref> [26, 19] </ref>, replication [7, 15, 20, 24, 28], concurrency control [16, 18, 21, 30], and discrete event simulation [2, 13, 17, 25, 29]. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms.
Reference: [20] <author> Puneet Kumar. </author> <title> Coping with Conflicts in an Optimistically Replicated File System. </title> <booktitle> In 1990 Workshop on the Management of Replicated Data, </booktitle> <pages> pages 60-64, </pages> <address> Houston, TX, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication <ref> [7, 15, 20, 24, 28] </ref>, concurrency control [16, 18, 21, 30], and discrete event simulation [2, 13, 17, 25, 29]. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms.
Reference: [21] <author> H.T. Kung and John T. Robinson. </author> <title> On Optimistic Methods for Concurrency Control. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(2) </volume> <pages> 213-226, </pages> <month> June </month> <year> 1981. </year>
Reference-contexts: The classical example is optimistic concurrency control: optimistically assume that locks will be granted, proceed with the transaction, and verify that the locks were granted at the end of the transaction <ref> [21] </ref>. If the database is distributed, the latency of accessing the locks increases, but the chance of being granted locks does not change. <p> Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication [7, 15, 20, 24, 28], concurrency control <ref> [16, 18, 21, 30] </ref>, and discrete event simulation [2, 13, 17, 25, 29]. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms.
Reference: [22] <author> Jonathan I. Leivent and Ronald J. Watro. </author> <title> Mathematical Foundations for Time Warp Systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(5) </volume> <pages> 771-794, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Previous work in supporting optimistic programming includes <ref> [3, 4, 18, 22, 27] </ref>. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [9]. In [27], computation based on an optimistic assumption is limited to the scope of an if or while statement.
Reference: [23] <author> Hanan Lutfiyya and Crispin Cowan. </author> <title> Optimistic Language Constructs. </title> <booktitle> In ICSE-17 Workshop on Research Issues in the Intersection of Software Engineering and Programming Languages, </booktitle> <address> Seattle, WA, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: This paper presents HOPE (Hopefully Optimistic Programming Environment): a programming model for expressing optimism. Previously, we have defined the HOPE programming model and its applicability <ref> [7, 10, 23] </ref>. We have constructed a prototype HOPE system [8], defined a formal semantics for HOPE [11], and proved that some important properties of the prototype implementation are consistent with the formal semantics [9].
Reference: [24] <author> Gerald J. Popek, Richard G. Guy, Jr. Thomas W. Page, and John S. Heidemann. </author> <title> Replication in Ficus Distribued Files Systems. </title> <booktitle> In 1990 Workshop on the Management of Replicated Data, </booktitle> <pages> pages 5-10, </pages> <address> Houston, TX, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication <ref> [7, 15, 20, 24, 28] </ref>, concurrency control [16, 18, 21, 30], and discrete event simulation [2, 13, 17, 25, 29]. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms.
Reference: [25] <author> B. R. Preiss, W. M. Loucks, and V. C. Hamacher. </author> <title> A Unified Modelling Methodology for Performance Evaluation of Distributed Discrete Event Simulation Mechanisms. </title> <booktitle> In Winter Simulation Conference, </booktitle> <year> 1988. </year>
Reference-contexts: Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication [7, 15, 20, 24, 28], concurrency control [16, 18, 21, 30], and discrete event simulation <ref> [2, 13, 17, 25, 29] </ref>. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms. Writing optimistic algorithms are difficult, time-consuming, and ad hoc, since an optimistic programmer must handle the following issues.
Reference: [26] <author> R.E. Strom and S. Yemini. </author> <title> Optimistic Recovery in Distributed Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: If the assumption is discovered to be correct, then latency has been avoided and performance has improved. However, if the assumption is incorrect, then all computations that used the assumption must be rolled back and re-executed using correct data. Optimism has been used in various areas to enhance performance <ref> [7, 15, 26, 28] </ref>. However, optimism is mostly embedded inside systems, and not exposed to the applications programmer. Optimism is not often used in applications because optimistic programs are difficult to write and require ad hoc techniques to implement. <p> Optimistic programs have been used in a variety of applications such as fault tolerance <ref> [26, 19] </ref>, replication [7, 15, 20, 24, 28], concurrency control [16, 18, 21, 30], and discrete event simulation [2, 13, 17, 25, 29]. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms.
Reference: [27] <author> Thomas Strothotte. </author> <title> Temporal Constructs for an Algorithmic Language. </title> <type> PhD thesis, </type> <institution> McGill University, </institution> <year> 1984. </year>
Reference-contexts: Previous work in supporting optimistic programming includes <ref> [3, 4, 18, 22, 27] </ref>. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [9]. In [27], computation based on an optimistic assumption is limited to the scope of an if or while statement. <p> Previous work in supporting optimistic programming includes [3, 4, 18, 22, 27]. However, previous work has either restricted the type of optimistic assumption that can be made, or restricted the scope of optimistic computation [9]. In <ref> [27] </ref>, computation based on an optimistic assumption is limited to the scope of an if or while statement. In [3, 4], computation based on an optimistic assumption is limited to the scope of a previously defined encapsulation. All encapsulations must be defined ahead of this time.
Reference: [28] <author> P. Triantafillou and D.J. Taylor. </author> <title> A New Paradigm for High Availability and Efficiency in Replicated and Distributed Databases. </title> <booktitle> In 2nd IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 136-143, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: If the assumption is discovered to be correct, then latency has been avoided and performance has improved. However, if the assumption is incorrect, then all computations that used the assumption must be rolled back and re-executed using correct data. Optimism has been used in various areas to enhance performance <ref> [7, 15, 26, 28] </ref>. However, optimism is mostly embedded inside systems, and not exposed to the applications programmer. Optimism is not often used in applications because optimistic programs are difficult to write and require ad hoc techniques to implement. <p> Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication <ref> [7, 15, 20, 24, 28] </ref>, concurrency control [16, 18, 21, 30], and discrete event simulation [2, 13, 17, 25, 29]. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms.
Reference: [29] <author> Brian Unger, John Cleary, Alan Dewar, and Zhong e Xiao. </author> <title> Multi-lingual Optimistic Distributed Simulator. </title> <journal> Transactions of the Society for Computer Simulation, </journal> <volume> 7(2) </volume> <pages> 121-151, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication [7, 15, 20, 24, 28], concurrency control [16, 18, 21, 30], and discrete event simulation <ref> [2, 13, 17, 25, 29] </ref>. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms. Writing optimistic algorithms are difficult, time-consuming, and ad hoc, since an optimistic programmer must handle the following issues.
Reference: [30] <author> Philip Yu and Daniel M. Dias. </author> <title> Analysis of Hybrid Concurrency Control Schemes for a High Data Contention Environment. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(2) </volume> <pages> 118-129, </pages> <month> February </month> <year> 1992. </year> <month> 25 </month>
Reference-contexts: Optimistic programs have been used in a variety of applications such as fault tolerance [26, 19], replication [7, 15, 20, 24, 28], concurrency control <ref> [16, 18, 21, 30] </ref>, and discrete event simulation [2, 13, 17, 25, 29]. In these applications optimism was used to decrease response time to enhance performance. Optimism has not been generally exploited because of the difficulty in writing optimistic algorithms.
References-found: 30

