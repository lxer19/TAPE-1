URL: http://www.csc.ncsu.edu/faculty/savage/AVAILABLE_FOR_MAILING/fixed_density_necklace_gc.ps
Refering-URL: http://www.csc.ncsu.edu/faculty/savage/papers.html
Root-URL: http://www.csc.ncsu.edu
Title: A Gray Code for Necklaces of Fixed Density  
Author: Terry MinYih Wang and Carla D. Savage 
Date: January 16, 1997  
Address: Box 8206 Raleigh, NC 27695-8206  
Affiliation: Department of Computer Science North Carolina State University,  
Abstract: A necklace is an equivalence class of binary strings under rotation. In this paper, we present a Gray code listing of all n-bit necklaces with d ones so that (i) each necklace is listed exactly once by a representative from its equivalence class and (ii) successive representatives, including the last and the first in the list, differ only by the transposition of two bits. The total time required is O(nN (n; d)), where N (n; d) denotes the number of n-bit binary necklaces with d ones. This is the first algorithm for generating necklaces of fixed density which is known to achieve this time bound. 
Abstract-found: 1
Intro-found: 1
Reference: [BuWi] <author> M. Buck and D. </author> <title> Wiedemann, "Gray codes with restricted density," </title> <note> Discrete Mathematics 48 (1984) 163-171. </note>
Reference-contexts: By applying the binary Gray code, a variety of problems have been solved and the complexities of the solutions to other problems have been improved [Gar, ChLeDu, ChChCh, Los, Ric]. There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations <ref> [BuWi, NiWi, Rus1] </ref>, compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes]. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [ChChCh] <author> C. C. Chang, H. Y. Chen and C. Y. Chen, </author> <title> "Symbolic Gray code as a data allocation scheme for two-disc systems," </title> <journal> The Computer Journal 35, </journal> <month> 3 </month> <year> (1992) </year> <month> 299-305. </month>
Reference-contexts: By applying the binary Gray code, a variety of problems have been solved and the complexities of the solutions to other problems have been improved <ref> [Gar, ChLeDu, ChChCh, Los, Ric] </ref>. There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes].
Reference: [ChLeDu] <author> C. C. Chang, R. C. T. Lee, and M. W. Du, </author> <title> "Symbolic Gray code as a perfect multiattribute hashing scheme for partial match queries," </title> <journal> IEEE Transactions on Software Engineering SE - 8, </journal> <month> 3 (May </month> <year> 1982) </year> <month> 235-249. </month>
Reference-contexts: By applying the binary Gray code, a variety of problems have been solved and the complexities of the solutions to other problems have been improved <ref> [Gar, ChLeDu, ChChCh, Los, Ric] </ref>. There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes].
Reference: [FrKe] <author> H. Fredricksen and I. J. Kessler, </author> <title> "An algorithm for generating necklaces of beads in two colors," </title> <note> Discrete Mathematics 61 (1986) 181-188. </note>
Reference-contexts: We will show that such a Gray code is always possible and that it gives rise to the most efficient algorithm known for generating necklaces of fixed density. A simple and elegant algorithm for listing the lexicographically smallest representatives of all n-bit necklaces was given in <ref> [FrMa, FrKe] </ref> and we refer to this as the FKM algorithm. It was shown in [RuSaWa] that the time required by the FKM algorithm is O (N (n)), that is, constant average time per necklace, which is best possible.
Reference: [FrMa] <author> H. Fredricksen and J. Maiorana, </author> <title> "Necklaces of beads in k colors and k-ary de Bruijn sequences," </title> <note> Discrete Mathematics 23, 3 (1978) 207-210. </note>
Reference-contexts: We will show that such a Gray code is always possible and that it gives rise to the most efficient algorithm known for generating necklaces of fixed density. A simple and elegant algorithm for listing the lexicographically smallest representatives of all n-bit necklaces was given in <ref> [FrMa, FrKe] </ref> and we refer to this as the FKM algorithm. It was shown in [RuSaWa] that the time required by the FKM algorithm is O (N (n)), that is, constant average time per necklace, which is best possible.
Reference: [Gar] <author> M. Gardner, </author> <title> "The curious properties of the Gray code and how it can be used to solve puzzles," </title> <publisher> Scientific American 227, </publisher> <month> 2 (August </month> <year> 1972) </year> <month> 106-109. </month>
Reference-contexts: By applying the binary Gray code, a variety of problems have been solved and the complexities of the solutions to other problems have been improved <ref> [Gar, ChLeDu, ChChCh, Los, Ric] </ref>. There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes].
Reference: [Gra] <author> F. Gray, </author> <title> "Pulse code communication," </title> <editor> U. S. </editor> <address> Patent 2632058 (March 17, </address> <year> 1953). </year>
Reference-contexts: 1 Introduction In a combinatorial family, a Gray code is an exhaustive listing of the objects in the family so that successive objects differ only in a small way [Wil]. The classic example is the binary reflected Gray code <ref> [Gra] </ref>, which is a list of all n-bit binary strings in which each string differs from its successor in exactly one bit.
Reference: [Joh] <author> S. M. Johnson, </author> <title> "Generation of permutations by adjacent transpositions," </title> <booktitle> Mathematics of Computation 17 (1963), </booktitle> <pages> 282-285. </pages>
Reference-contexts: By applying the binary Gray code, a variety of problems have been solved and the complexities of the solutions to other problems have been improved [Gar, ChLeDu, ChChCh, Los, Ric]. There are many examples of combinatorial families for which Gray codes are known, including permutations <ref> [Joh, Tro] </ref>, combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes].
Reference: [Kay] <author> R. Kaye, </author> <title> "A Gray code for set partitions," </title> <note> Information Processing Letters 5 (1976) 171-173. </note>
Reference-contexts: There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions <ref> [Kay] </ref>, integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes]. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [Kli] <author> P. Klingsberg, </author> <title> "A Gray code for compositions," </title> <journal> Journal of Algorithms 3, </journal> <year> (1982) </year> <month> 41-44. </month>
Reference-contexts: There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions <ref> [Kli] </ref>, set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes]. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [Los] <author> R. M. Losee, </author> <title> "A Gray code based ordering for documents on shelves," </title> <journal> Journal of American Society for Information Science 43, </journal> <month> 4 </month> <year> (1992) </year> <month> 312-322. </month>
Reference-contexts: By applying the binary Gray code, a variety of problems have been solved and the complexities of the solutions to other problems have been improved <ref> [Gar, ChLeDu, ChChCh, Los, Ric] </ref>. There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes].
Reference: [Luc] <author> J. M. Lucas, </author> <title> "The rotation graph of binary trees is hamiltonian," </title> <note> Journal of Algorithms 8 (1987) 503-535. </note>
Reference-contexts: There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees <ref> [RuPr, Luc, LuRoRu] </ref>, and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes]. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [LuRoRu] <author> J. M. Lucas, D. Roelants van Baronaigien and F. Ruskey, </author> <title> "On rotations and the generation of binary trees," </title> <journal> Journal of Algorithms 15, </journal> <month> 3 (November </month> <year> 1993) </year> <month> 343-366. </month>
Reference-contexts: There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees <ref> [RuPr, Luc, LuRoRu] </ref>, and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes]. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [NiWi] <author> A. Nijenhuis and H. S. Wilf, </author> <title> Combinatorial Algorithms for Computers and Calculators, </title> <publisher> Academic Press Inc., </publisher> <address> New York, </address> <year> (1978). </year>
Reference-contexts: By applying the binary Gray code, a variety of problems have been solved and the complexities of the solutions to other problems have been improved [Gar, ChLeDu, ChChCh, Los, Ric]. There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations <ref> [BuWi, NiWi, Rus1] </ref>, compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes]. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [PrRu1] <author> G. Pruesse and F. Ruskey, </author> <title> "Generating the linear extensions of certain posets by transpositions," </title> <note> SIAM Journal on Discrete Mathematics 4, </note> <month> 3 (August </month> <year> 1991) </year> <month> 413-422. </month>
Reference-contexts: There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions <ref> [PrRu1, PrRu2, Rus2, Sta, Wes] </ref>. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [PrRu2] <author> G. Pruesse and F. Ruskey, </author> <title> "Generating linear extensions fast," </title> <journal> SIAM Journal on Computing, </journal> <note> to appear. </note>
Reference-contexts: There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions <ref> [PrRu1, PrRu2, Rus2, Sta, Wes] </ref>. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [RaSaWe] <author> D. Rasmussen, C. Savage, and D. West, </author> <title> "Gray Codes for Families of Integer Partitions," </title> <note> to appear in Journal of Combinatorial Theory, Series A. </note>
Reference-contexts: There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions <ref> [Sav, RaSaWe] </ref>, binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes]. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [Ric] <author> D. Richards, </author> <title> "Data compression and Gray-code sorting," </title> <note> Information Processing Letters 22 (1986) 201-205. </note>
Reference-contexts: By applying the binary Gray code, a variety of problems have been solved and the complexities of the solutions to other problems have been improved <ref> [Gar, ChLeDu, ChChCh, Los, Ric] </ref>. There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes].
Reference: [Rus1] <author> F. Ruskey, </author> <title> "Adjacent interchange generation of combinations," </title> <journal> Journal of Algorithms 9, </journal> <month> 2 (June </month> <year> 1988) </year> <month> 162-180. </month>
Reference-contexts: By applying the binary Gray code, a variety of problems have been solved and the complexities of the solutions to other problems have been improved [Gar, ChLeDu, ChChCh, Los, Ric]. There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations <ref> [BuWi, NiWi, Rus1] </ref>, compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes]. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [Rus2] <author> F. Ruskey, </author> <title> "Generating linear extensions of posets by transpositions," </title> <journal> Journal of Combinatorial Theory (B) 54, </journal> <month> 1 </month> <year> (1992) </year> <month> 77-101. </month>
Reference-contexts: There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions <ref> [PrRu1, PrRu2, Rus2, Sta, Wes] </ref>. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [RuPr] <author> F. Ruskey and A. Proskurowski, </author> <title> "Generating binary trees by transpositions," </title> <journal> Journal of Algorithms 11, </journal> <month> 1 </month> <year> (1990) </year> <month> 68-84. </month>
Reference-contexts: There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees <ref> [RuPr, Luc, LuRoRu] </ref>, and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes]. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task. <p> However, in the special case when n = 2d + 1, a Gray code for n-bit necklaces of density d follows from the Gray code of Ruskey and Proskurowski <ref> [RuPr] </ref> for balanced parentheses, under a straightforward bijection between these two families and that this algorithm achieves constant average time per object. In Section 2 we present background and technical lemmas used for the main result.
Reference: [RuSaWa] <author> F. Ruskey, C. D. Savage, and T. M. Wang, </author> <title> "Generating necklaces," </title> <journal> Journal of Algorithms 13, </journal> <month> 3 (September </month> <year> 1992) </year> <month> 414-430. </month>
Reference-contexts: A simple and elegant algorithm for listing the lexicographically smallest representatives of all n-bit necklaces was given in [FrMa, FrKe] and we refer to this as the FKM algorithm. It was shown in <ref> [RuSaWa] </ref> that the time required by the FKM algorithm is O (N (n)), that is, constant average time per necklace, which is best possible. The efficiency here is achieved by amortization, rather than a Gray code, since successive representatives listed by the FKM algorithm can differ in (n) bits.
Reference: [Sav] <author> C. D. Savage, </author> <title> "Gray code sequences of partitions," </title> <journal> Journal of Algorithms 10, </journal> <month> 4 </month> <year> (1989) </year> <month> 577-595. </month>
Reference-contexts: There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions <ref> [Sav, RaSaWe] </ref>, binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes]. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [Shi] <author> Y. </author> <title> Shiloach "Fast canonization of circular strings" Journal of Algorithms 2, </title> <month> 2 </month> <year> (1981) </year> <month> 107-121. </month>
Reference-contexts: It is shown in <ref> [Shi] </ref> that for an arbitrary n-bit string, x, it is possible to check whether x 2 L (n) in time O (n). Using this fact, we show that all the tests in the CYCLE algorithm can be made in time O (n). <p> First note that by definition of r (x; d) and Corollary 1 (a), r (x; d) t if and only if u (y t ; d 1) 2 L (n), so the tests on lines (3) and (6) can be made in time O (n) using 27 the algorithm of <ref> [Shi] </ref>. By Corollary 1 (a), G n [x; d; i] is empty if u (y i ; d 1) 62 L (n) and is trivial if and only if u (y i ; d 1) 2 L (n), but v (y i ; d 1) 62 L (n).
Reference: [Sta] <author> G. Stachowiak, </author> <title> "Hamilton paths in graphs of linear extensions for unions of posets," </title> <journal> SIAM J. Discrete Math. </journal> <volume> 5 (1992), </volume> <pages> 199-206. </pages>
Reference-contexts: There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions <ref> [PrRu1, PrRu2, Rus2, Sta, Wes] </ref>. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [Tro] <author> H. F. Trotter, </author> <title> "PERM (Algorithm 115)", </title> <journal> Communications of the ACM 5, </journal> <month> 8 </month> <year> (1962) </year> <month> 434-435. </month>
Reference-contexts: By applying the binary Gray code, a variety of problems have been solved and the complexities of the solutions to other problems have been improved [Gar, ChLeDu, ChChCh, Los, Ric]. There are many examples of combinatorial families for which Gray codes are known, including permutations <ref> [Joh, Tro] </ref>, combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions [PrRu1, PrRu2, Rus2, Sta, Wes].
Reference: [Wes] <author> D. B. West, </author> <title> "Generating linear extensions by adjacent transpositions," </title> <journal> Journal of Combinatorial Theory (B), </journal> <volume> 57(1993). </volume>
Reference-contexts: There are many examples of combinatorial families for which Gray codes are known, including permutations [Joh, Tro], combinations [BuWi, NiWi, Rus1], compositions [Kli], set partitions [Kay], integer partitions [Sav, RaSaWe], binary trees [RuPr, Luc, LuRoRu], and linear extensions <ref> [PrRu1, PrRu2, Rus2, Sta, Wes] </ref>. When an application requires an exhaustive examination of all objects in a combinatorial family, Gray codes can be used to speed up the task.
Reference: [WaSa] <author> T. M. Wang and C. D. Savage, </author> <title> "A new algorithm for generating necklaces," </title> <booktitle> Proceedings, Twenty-eighth Annual Allerton Conference on Communication, Control, and Computing, Allerton, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: As the backbone of our Gray code construction, we will use a tree of elements of L (n), which was introduced in <ref> [WaSa] </ref>. <p> By induction, x is in T REE (n) at level d 1 and therefore, by definition of T REE (n), y is a child of x at level d. The following result, crucial to our construction, was proved in <ref> [WaSa] </ref>.
Reference: [Wan] <author> T. M. Wang, </author> <title> "Gray codes for necklaces of fixed density," </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Science, North Carolina State University (1994). </institution>
Reference-contexts: The procedure has been implemented in C and is included in the appendix to <ref> [Wan] </ref>. (A subsequent modification requires storage only O (n).) In this section, we show the time required is O (nN (n; d)), where N (n; d) is the number of n bit necklaces of density d.
Reference: [Wil] <author> H. S. Wilf, </author> <title> Combinatorial Algorithms: An Update, </title> <publisher> SIAM, </publisher> <address> Philadelphia (1989). </address> <month> 31 </month>
Reference-contexts: 1 Introduction In a combinatorial family, a Gray code is an exhaustive listing of the objects in the family so that successive objects differ only in a small way <ref> [Wil] </ref>. The classic example is the binary reflected Gray code [Gra], which is a list of all n-bit binary strings in which each string differs from its successor in exactly one bit.
References-found: 30

