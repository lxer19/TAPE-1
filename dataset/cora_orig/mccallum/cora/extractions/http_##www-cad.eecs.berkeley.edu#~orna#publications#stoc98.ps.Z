URL: http://www-cad.eecs.berkeley.edu/~orna/publications/stoc98.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~orna/pub.html
Root-URL: 
Email: Email: orna@eecs.berkeley.edu,  Email: vardi@cs.rice.edu,  
Title: Weak Alternating Automata and Tree Automata Emptiness  
Author: Orna Kupferman Moshe Y. Vardi 
Web: URL: http://www.eecs.berkeley.edu/  URL: http://www.cs.rice.edu/  
Address: Berkeley, Berke-ley CA 94720-1770, U.S.A.  Houston TX 77005-1892, U.S.A.  
Note: Address:  orna. Supported in part by ONR YIP award N00014-95-1-0520, by NSF CAREER award CCR-9501708, by NSF grant CCR-9504469, by AFOSR contract F49620-93-1-0056, by ARO MURI grant DAAH-04-96-1-0341, by ARPA grant NAG2-892, and by the SRC contract 95-DC-324.036. Address:  vardi. Supported in part by NSF grants CCR-9628400 and CCR-9700061, and by a grant from the Intel Corporation.  
Affiliation: UC Berkeley  Rice University  EECS Department, UC  Department of Computer Science, Rice University,  
Abstract: Automata on infinite words and trees are used for specification and verification of nonterminating programs. The verification and the satisfiability problems of specifications can be reduced to the nonemptiness problem of such automata. In a weak automaton, the state space is partitioned into partially ordered sets, and the automaton can proceed from a certain set only to smaller sets. Reasoning about weak automata is easier than reasoning about automata with no restricted structure. In particular, the nonemptiness problem for weak alternating automata over a singleton alphabet can be solved in linear time. Known translations of alternating automata to weak alternating automata involve determiniza-tion, and therefore involve a double exponential blow-up. In this paper we describe simple and efficient translations, which circumvent the need for determinization, of parity and Rabin alternating word automata to weak alternating word automata. Beyond the independent interest of such translations, they give rise to a simple algorithm for deciding the nonemptiness of nondeterministic parity and Rabin tree automata. In particular, our algorithm for Rabin automata runs in time O(n 2k+1 k!), where n is the number of states in the automaton and k is the number of pairs in the acceptance condition. This improves the known O((nk) 3k ) bound for the problem. 
Abstract-found: 1
Intro-found: 1
Reference: [ALW89] <author> M. Abadi, L. Lamport, and P. Wolper. </author> <title> Realizable and unrealizable concurrent program specifications. </title> <booktitle> In Proc. 16th Int. Colloquium on Automata, Languages and Programming, </booktitle> <volume> volume 372, </volume> <pages> pages 1-17. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: We refer to both problems as the nonemptiness problem. The nonemptiness problem is important also for reasoning about linear-time specifications of open systems, where the interaction between a correct system and its environment can be formulated by a tree automaton <ref> [ALW89, PR89] </ref>. In [MSS86], Muller et al. introduced weak automata. In a weak automaton, the automaton's set of states is partitioned into partially ordered sets. Each set is classified as accepting or rejecting.
Reference: [BL80] <author> J.A. Brzozowski and E. Leiss. </author> <title> Finite automata and sequential networks. </title> <journal> Theoretical Computer Science, </journal> <volume> 10 </volume> <pages> 19-35, </pages> <year> 1980. </year>
Reference-contexts: In the existential mode, the automaton should accept the suffix of the word from one of the states in the set, and in the universal mode, it should accept the suffix from all the states in the set. In an alternating automaton <ref> [BL80, CKS81] </ref>, both existential and universal modes are allowed, and the transitions are given as Boolean formulas over the set of states. <p> (n 2k+1 k!) upper bounds for the nonemptiness problem for parity and Rabin automata, respectively, matching the known bound for parity automata [EJS93] and improving the known O (nk) 3k bound for Rabin automata. 2 Alternating Automata Alternation was studied in [CKS81] in the context of Turing machines and in <ref> [BL80, CKS81, MH84] </ref> for finite automata. In particular, [MH84] studied alternating automata on infinite words. Alternation enables us to have both existential and universal branching choices.
Reference: [Buc62] <author> J.R. Buchi. </author> <title> On a decision method in restricted second order arithmetic. </title> <booktitle> In Proc. Internat. Congr. Logic, Method and Philos. Sci. </booktitle> <year> 1960, </year> <pages> pages 1-12, </pages> <address> Stanford, 1962. </address> <publisher> Stanford University Press. </publisher>
Reference-contexts: 1 Introduction Finite automata on infinite objects were first introduced in the 1960's. Motivated by decision problems in mathematical logic, Buchi, McNaughton, and Rabin developed a framework for automata on infinite words and infinite trees <ref> [Buc62, McN66, Rab69] </ref>. The framework has proven to be very powerful. Automata, and their tight relation to second-order monadic logics were the key to the solution of several fundamental decision problems in mathematical logic [Tho90]. Today, automata on infinite objects are used for specification and verification of nonterminating programs. <p> There are various ways to classify an automaton on infinite words. One is the type of its acceptance condition. For example, in Buchi automata, some of the states are designated as accepting states, and a run is accepting iff it visits states from the accepting set infinitely often <ref> [Buc62] </ref>. Dually, in co-Buchi automata, a run is accepting iff it visits states from the accepting set only finitely often. More general are Muller, parity, and Rabin automata, whose acceptance conditions involve several sets of states.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Computer Aided Verification, Proc. 6th Int. Conference, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-155, </pages> <address> Stan-ford, June 1994. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: In this paradigm, each specification describes a set of allowed computation trees, which can be described by an automaton over infinite trees. By translating branching-time specifications to alternating tree automata, we can reduce satisfiability to the nonemptiness problem and reduce verification to the membership problem <ref> [BVW94, Var97] </ref>. Solving the nonempti-ness problem for an alternating tree automaton is done by translating the automaton to a nondeterministic tree automaton. Deciding the membership of a program in a language of an alternating tree automaton is done by taking the product of the program and the automaton. <p> Thus, reasoning about branching-time specifications concerns two problems: the nonemptiness problem for nondeterministic tree automata and the nonemptiness problem for alternating word automata over a singleton alphabet. It is shown in <ref> [BVW94] </ref> that these problems are equivalent and that their complexities coincide. We refer to both problems as the nonemptiness problem. <p> The special structure of weak automata is reflected in their attractive computational properties. In particular, the nonemptiness problem for weak automata can be solved in linear time <ref> [BVW94] </ref>. As a comparison, the best known upper bound for the nonemptiness problem for Buchi automata is quadratic time. When defined on words, weak alternating automata are not less expressive than Buchi alternating automata, and they can recognize all the !-regular languages. <p> Note that each node of the input tree corresponds to exactly one node in the run tree. A run hT; ri is accepting iff all its paths satisfy the acceptance condition. It is shown in <ref> [BVW94] </ref> that the nonemptiness problem for nondeterministic tree automata and the nonemptiness problem for alternating word automata over a singleton alphabet are equivalent and that their complexities coincide. We refer to both problems as the nonemptiness problem. <p> We refer to both problems as the nonemptiness problem. Since the nonemptiness problem for weak alternating automata can be solved in linear time <ref> [BVW94] </ref>, Theorems 4.2 and 4.3 imply the following.
Reference: [CKS81] <author> A.K. Chandra, D.C. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28(1) </volume> <pages> 114-133, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: In the existential mode, the automaton should accept the suffix of the word from one of the states in the set, and in the universal mode, it should accept the suffix from all the states in the set. In an alternating automaton <ref> [BL80, CKS81] </ref>, both existential and universal modes are allowed, and the transitions are given as Boolean formulas over the set of states. <p> Our constructions yield O (n k ) and O (n 2k+1 k!) upper bounds for the nonemptiness problem for parity and Rabin automata, respectively, matching the known bound for parity automata [EJS93] and improving the known O (nk) 3k bound for Rabin automata. 2 Alternating Automata Alternation was studied in <ref> [CKS81] </ref> in the context of Turing machines and in [BL80, CKS81, MH84] for finite automata. In particular, [MH84] studied alternating automata on infinite words. Alternation enables us to have both existential and universal branching choices. <p> (n 2k+1 k!) upper bounds for the nonemptiness problem for parity and Rabin automata, respectively, matching the known bound for parity automata [EJS93] and improving the known O (nk) 3k bound for Rabin automata. 2 Alternating Automata Alternation was studied in [CKS81] in the context of Turing machines and in <ref> [BL80, CKS81, MH84] </ref> for finite automata. In particular, [MH84] studied alternating automata on infinite words. Alternation enables us to have both existential and universal branching choices.
Reference: [DH94] <author> D. Drusinsky and D. Harel. </author> <title> On the power of bounded concurrency I: Finite automata. </title> <journal> Journal of the ACM, </journal> <volume> 41(3) </volume> <pages> 517-539, </pages> <year> 1994. </year>
Reference-contexts: The rich structure of alternating automata also makes them more succinct. For example, translating an alternating Buchi automaton to a nondeterministic Buchi automaton might involve an exponential blow up <ref> [DH94] </ref>. The succinctness of alternating automata is crucial when we use automata for the verification of branching-time specifications. In this paradigm, each specification describes a set of allowed computation trees, which can be described by an automaton over infinite trees. <p> Such a determiniza-tion involves an exponential blow-up [Mic88, Saf88, Saf92]. Even worse, if A is an alternating automaton, then its deter-minization involves a doubly-exponential blow-up <ref> [DH94] </ref>, and hence, so does the translation to weak alternating automata.
Reference: [EJ88] <author> E.A. Emerson and C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proc. 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 368-377, </pages> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: In [Rab69], Rabin described a non-elementary procedure for checking the nonemptiness of a given Rabin automaton and showed that the problem is decidable. In [HR72, Rab72], improved algorithms were described, of complexity exponential in both n and k. Only in <ref> [EJ88, PR89] </ref>, algorithms that are exponential in k and only polynomial in n have been describes. Both works described algorithms that run in time O ((nk) 3k ). <p> The O (n 2k+1 k!) bound in Theorem 5.1 improves the known O ((nk) 3k ) upper-bound for the nonemptiness problem <ref> [EJ88, PR89] </ref> for Rabin automata. A similar bound for Streett automata follows. Solving, however, the nonempti-ness problem by translating a given automaton to an equivalent weak automaton is not very appealing in practice, as such a solution never performs better than its worst-case complexity.
Reference: [EJ91] <author> E.A. Emerson and C. Jutla. </author> <title> Tree automata, Mu-calculus and determinacy. </title> <booktitle> In Proc. 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 368-377, </pages> <address> San Juan, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Dually, in co-Buchi automata, a run is accepting iff it visits states from the accepting set only finitely often. More general are Muller, parity, and Rabin automata, whose acceptance conditions involve several sets of states. For example, in parity automata <ref> [Mos84, EJ91] </ref>, the acceptance condition is a sequence fF 1 ; F 2 ; : : : ; F k g of sets of states. A run is accepting iff the minimal index i for which the set F i is visited infinitely often is even. <p> Since the nonemptiness problem for weak automata can be solved in linear time, this enables us to improve the known upper bounds for the nonemptiness problem. We start with parity automata. It is shown in <ref> [EJ91] </ref> that formulas of the -calculus [Koz83] can be linearly translated to alternating parity tree automata 1 . Since many properties of programs are naturally specified by means of fixed points, the -calculus is an expressive and important specification language [EL86]. Following [EJ91], the verification problem for -calculus can be linearly <p> It is shown in <ref> [EJ91] </ref> that formulas of the -calculus [Koz83] can be linearly translated to alternating parity tree automata 1 . Since many properties of programs are naturally specified by means of fixed points, the -calculus is an expressive and important specification language [EL86]. Following [EJ91], the verification problem for -calculus can be linearly reduced to the nonemptiness problem for parity automata. This makes the nonempti-ness problem for parity automata of particular interest; the verification problem for -calculus is known to be in NP " co-NP [EJS93] and its precise complexity is an open problem. <p> The construction goes through a sequence of k intermediate automata. Each automaton in the sequence refines the state space of its predecessor and has one less set in its parity acceptance condition. 1 In fact, alternating parity tree automata are exactly as expressive as the -calculus <ref> [Niw88, EJ91] </ref>. On the other hand, weak alternating tree automata are exactly as expressive as the alternation-free fragment of -calculus [KV98]. Parity automata can be viewed as a special case of Rabin automata. <p> Thus, same missions are fulfilled in the same way. It turns out that when we consider runs of co-Buchi automata, we can restrict ourselves to memoryless runs. Formally, if a co-Buchi automaton A accepts a word w, then there exists a memoryless accepting run of A on w <ref> [EJ91] </ref>. Let jQj = n. It is easy to see that for every run hT r ; ri, every set of more than n nodes of the same level contains at least two similar nodes.
Reference: [EJS93] <author> E.A. Emerson, C. Jutla, and A.P. Sistla. </author> <title> On model-checking for fragments of -calculus. </title> <booktitle> In Computer Aided Verification, Proc. 5th Int. Conference, </booktitle> <volume> volume 697, </volume> <pages> pages 385-396, </pages> <address> Elounda, Crete, </address> <month> June </month> <year> 1993. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Following [EJ91], the verification problem for -calculus can be linearly reduced to the nonemptiness problem for parity automata. This makes the nonempti-ness problem for parity automata of particular interest; the verification problem for -calculus is known to be in NP " co-NP <ref> [EJS93] </ref> and its precise complexity is an open problem. Given an alternating parity word automaton with n states and k sets, we construct an equivalent weak alternating word automaton with O (n k ) states. The construction goes through a sequence of k intermediate automata. <p> Our constructions yield O (n k ) and O (n 2k+1 k!) upper bounds for the nonemptiness problem for parity and Rabin automata, respectively, matching the known bound for parity automata <ref> [EJS93] </ref> and improving the known O (nk) 3k bound for Rabin automata. 2 Alternating Automata Alternation was studied in [CKS81] in the context of Turing machines and in [BL80, CKS81, MH84] for finite automata. In particular, [MH84] studied alternating automata on infinite words.
Reference: [EL86] <author> E.A. Emerson and C.-L. Lei. </author> <title> Efficient model checking in fragments of the proposoitional Mu-calculus. </title> <booktitle> In Proc. 1st Symposium on Logic in Computer Science, </booktitle> <pages> pages 267-278, </pages> <address> Cambridge, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: We start with parity automata. It is shown in [EJ91] that formulas of the -calculus [Koz83] can be linearly translated to alternating parity tree automata 1 . Since many properties of programs are naturally specified by means of fixed points, the -calculus is an expressive and important specification language <ref> [EL86] </ref>. Following [EJ91], the verification problem for -calculus can be linearly reduced to the nonemptiness problem for parity automata.
Reference: [ES84] <author> A.E. Emerson and A.P. Sistla. </author> <title> Deciding full branching time logics. </title> <journal> Information and Control, </journal> <volume> 61(3) </volume> <pages> 175-201, </pages> <year> 1984. </year>
Reference-contexts: In [Rab69], Rabin describes a translation of formulas of monadic second order logic to Rabin tree automata. Today, Rabin automata are used in order to reason about specifications of the full branching time logic CTL ? <ref> [ES84, VS85] </ref>, as well as to model programs with fairness conditions. The nonemptiness problem for Ra-bin automata plays a crucial role in solving various decision problems in logic. As a result, many efforts have been put in developing simple algorithms for nonemptiness checking.
Reference: [HR72] <author> R. Hossley and C.W. Rackoff. </author> <title> The emptiness problem for automata on infinite trees. </title> <booktitle> In Proc. 13th IEEE Symp. on Switching and Automata Theory, </booktitle> <pages> pages 121-124, </pages> <year> 1972. </year>
Reference-contexts: As a result, many efforts have been put in developing simple algorithms for nonemptiness checking. In [Rab69], Rabin described a non-elementary procedure for checking the nonemptiness of a given Rabin automaton and showed that the problem is decidable. In <ref> [HR72, Rab72] </ref>, improved algorithms were described, of complexity exponential in both n and k. Only in [EJ88, PR89], algorithms that are exponential in k and only polynomial in n have been describes. Both works described algorithms that run in time O ((nk) 3k ).
Reference: [Koz83] <author> D. Kozen. </author> <title> Results on the propositional -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 27 </volume> <pages> 333-354, </pages> <year> 1983. </year>
Reference-contexts: Since the nonemptiness problem for weak automata can be solved in linear time, this enables us to improve the known upper bounds for the nonemptiness problem. We start with parity automata. It is shown in [EJ91] that formulas of the -calculus <ref> [Koz83] </ref> can be linearly translated to alternating parity tree automata 1 . Since many properties of programs are naturally specified by means of fixed points, the -calculus is an expressive and important specification language [EL86].
Reference: [Kur94] <author> R.P. Kurshan. </author> <title> Computer Aided Verification of Coordinating Processes. </title> <publisher> Princeton Univ. Press, </publisher> <year> 1994. </year>
Reference-contexts: By translating specifications to automata, we reduce questions about programs and their specifications to questions about automata. More specifically, questions such as satisfiability of specifications and correctness of programs with respect to their specifications are reduced to questions such as nonemptiness and language containment <ref> [VW86, Kur94, VW94] </ref>. The automata-theoretic approach separates the logical and the algorithmic aspects of reasoning about programs. The translation of specifications to automata handles the logic and shifts all the algorithmic difficulties to automata-theoretic problems.
Reference: [KV97] <author> O. Kupferman and M.Y. Vardi. </author> <title> Weak alternating automata are not that weak. </title> <booktitle> In Proc. 5th Israeli Symposium on Theory of Computing and Systems, </booktitle> <pages> pages 147-158. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1997. </year>
Reference-contexts: Such a determiniza-tion involves an exponential blow-up [Mic88, Saf88, Saf92]. Even worse, if A is an alternating automaton, then its deter-minization involves a doubly-exponential blow-up [DH94], and hence, so does the translation to weak alternating automata. Can these blow-ups be avoided? In <ref> [KV97] </ref>, we described a quadratic translation of Buchi and co-Buchi alternating word automata to weak alternating word automata, answering this question positively for the case A is either a Buchi or a co-Buchi automaton. In this paper we extend the ideas in [KV97] and describe an efficient translation of stronger types <p> Can these blow-ups be avoided? In <ref> [KV97] </ref>, we described a quadratic translation of Buchi and co-Buchi alternating word automata to weak alternating word automata, answering this question positively for the case A is either a Buchi or a co-Buchi automaton. In this paper we extend the ideas in [KV97] and describe an efficient translation of stronger types of alternating automata to weak alternating automata. Since the nonemptiness problem for weak automata can be solved in linear time, this enables us to improve the known upper bounds for the nonemptiness problem. We start with parity automata. <p> It is shown in <ref> [KV97] </ref> that every vertex hq; li in G r has a unique index i 0 such that hq; li is either eventually safe in G 2i or currently safe in G 2i+1 . <p> For m 2 IN, let [m] denote the set f0; 1; : : : ; mg, and let [m] even and [m] odd denote the sets of even and odd members of [m], respectively. In <ref> [KV97] </ref>, we proved that the rank of every vertex in G r is in [2n]. Recall that when hT r ; ri is accepting, all the paths in G r visit only finitely many ff-vertices. <p> We continue with the currently safe vertices in G 3 , which get the rank 3. The process repeats until all vertices get some rank. Note that no ff-vertex gets an odd rank. In the lemmas below, proven in <ref> [KV97] </ref>, we make this intuition formal. Lemma 3.1 For every two vertices hq; li and hq 0 ; l 0 i in G r , if hq 0 ; l 0 i is reachable from hq; li, then rank (q 0 ; l 0 ) rank (q; l). <p> We have seen that if a co-Buchi alternating automaton has an accepting run on w, then it also has a very structured accepting run on w. In <ref> [KV97] </ref> we employed this structured run in order to translate co-Buchi alternating automata to weak alternating automata: Theorem 3.3 [KV97] Let A be an alternating co-Buchi automaton. <p> We have seen that if a co-Buchi alternating automaton has an accepting run on w, then it also has a very structured accepting run on w. In <ref> [KV97] </ref> we employed this structured run in order to translate co-Buchi alternating automata to weak alternating automata: Theorem 3.3 [KV97] Let A be an alternating co-Buchi automaton. There is a weak alternating automaton A 0 such that L (A 0 ) = L (A) and the number of states in A 0 is quadratic in that of A. We describe the automaton A 0 . <p> Each path in a run of A 0 eventually gets trapped in a set of the form Q fi fjg for some j 2 [2n]. The set is accepting iff j is odd. In the next section we extend the ideas in <ref> [KV97] </ref> in order to translate parity and Rabin alternating automata to weak alternating automata. 4 From Parity and Rabin to Weak Alternating Au tomata A parity alternating automaton is A = h; Q; q in ; ffi; fii, where fi = hF 1 ; F 2 ; : : : ;
Reference: [KV98] <author> O. Kupferman and M.Y. Vardi. </author> <title> Freedom, weakness, and determinism: from linear-time to branching-time. </title> <booktitle> In Proc. 13th IEEE Symposium on Logic in Computer Science, </booktitle> <address> Indiana, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: On the other hand, weak alternating tree automata are exactly as expressive as the alternation-free fragment of -calculus <ref> [KV98] </ref>. Parity automata can be viewed as a special case of Rabin automata.
Reference: [Lin88] <author> P. Lindsay. </author> <title> On alternating !-automata. </title> <journal> Theoretical computer science, </journal> <volume> 43 </volume> <pages> 107-116, </pages> <year> 1988. </year>
Reference-contexts: As a comparison, the best known upper bound for the nonemptiness problem for Buchi automata is quadratic time. When defined on words, weak alternating automata are not less expressive than Buchi alternating automata, and they can recognize all the !-regular languages. To prove this, <ref> [MSS86, Lin88] </ref> suggest a linear translation of deterministic Muller automata to weak alternating automata. Using, however, the constructions in [MSS86, Lin88] in order translate a nondeterministic automaton A into a weak alternating automaton, one has no choice but to first translate A into a deterministic Muller automaton. <p> When defined on words, weak alternating automata are not less expressive than Buchi alternating automata, and they can recognize all the !-regular languages. To prove this, <ref> [MSS86, Lin88] </ref> suggest a linear translation of deterministic Muller automata to weak alternating automata. Using, however, the constructions in [MSS86, Lin88] in order translate a nondeterministic automaton A into a weak alternating automaton, one has no choice but to first translate A into a deterministic Muller automaton. Such a determiniza-tion involves an exponential blow-up [Mic88, Saf88, Saf92].
Reference: [McN66] <author> R. McNaughton. </author> <title> Testing and generating infinite sequences by a finite automaton. </title> <journal> Information and Control, </journal> <volume> 9 </volume> <pages> 521-530, </pages> <year> 1966. </year>
Reference-contexts: 1 Introduction Finite automata on infinite objects were first introduced in the 1960's. Motivated by decision problems in mathematical logic, Buchi, McNaughton, and Rabin developed a framework for automata on infinite words and infinite trees <ref> [Buc62, McN66, Rab69] </ref>. The framework has proven to be very powerful. Automata, and their tight relation to second-order monadic logics were the key to the solution of several fundamental decision problems in mathematical logic [Tho90]. Today, automata on infinite objects are used for specification and verification of nonterminating programs.
Reference: [MH84] <author> S. Miyano and T. Hayashi. </author> <title> Alternating finite automata on !-words. </title> <journal> Theoretical Computer Science, </journal> <volume> 32 </volume> <pages> 321-330, </pages> <year> 1984. </year>
Reference-contexts: (n 2k+1 k!) upper bounds for the nonemptiness problem for parity and Rabin automata, respectively, matching the known bound for parity automata [EJS93] and improving the known O (nk) 3k bound for Rabin automata. 2 Alternating Automata Alternation was studied in [CKS81] in the context of Turing machines and in <ref> [BL80, CKS81, MH84] </ref> for finite automata. In particular, [MH84] studied alternating automata on infinite words. Alternation enables us to have both existential and universal branching choices. <p> In particular, <ref> [MH84] </ref> studied alternating automata on infinite words. Alternation enables us to have both existential and universal branching choices.
Reference: [Mic88] <author> M. Michel. </author> <title> Complementation is more difficult with automata on infinite words. </title> <address> CNET, Paris, </address> <year> 1988. </year>
Reference-contexts: Using, however, the constructions in [MSS86, Lin88] in order translate a nondeterministic automaton A into a weak alternating automaton, one has no choice but to first translate A into a deterministic Muller automaton. Such a determiniza-tion involves an exponential blow-up <ref> [Mic88, Saf88, Saf92] </ref>. Even worse, if A is an alternating automaton, then its deter-minization involves a doubly-exponential blow-up [DH94], and hence, so does the translation to weak alternating automata.
Reference: [Mos84] <author> A.W. Mostowski. </author> <title> Regular expressions for infinite trees and a standard form of automata. </title> <booktitle> In Computation Theory, volume 208 of Lecture Notes in Computer Science, </booktitle> <pages> pages 157-168. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Dually, in co-Buchi automata, a run is accepting iff it visits states from the accepting set only finitely often. More general are Muller, parity, and Rabin automata, whose acceptance conditions involve several sets of states. For example, in parity automata <ref> [Mos84, EJ91] </ref>, the acceptance condition is a sequence fF 1 ; F 2 ; : : : ; F k g of sets of states. A run is accepting iff the minimal index i for which the set F i is visited infinitely often is even.
Reference: [MS87] <author> D.E. Muller and P.E. Schupp. </author> <title> Alternating automata on infinite trees. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 54,:267-276, </address> <year> 1987. </year>
Reference-contexts: In addition, since satisfies the parity condition fi in hT r ; ri, it satisfies the co-parity condition fi 0 as well. As discussed in <ref> [MS87] </ref>, one can complement an alter-nating automaton by dualizing its transition function and acceptance condition. Formally, given a transition function ffi, let ~ ffi denote the dual function of ffi.
Reference: [MSS86] <author> D.E. Muller, A. Saoudi, and P.E. Schupp. </author> <title> Alternating automata, the weak monadic theory of the tree and its complexity. </title> <booktitle> In Proc. 13th Int. Colloquium on Automata, Languages and Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: We refer to both problems as the nonemptiness problem. The nonemptiness problem is important also for reasoning about linear-time specifications of open systems, where the interaction between a correct system and its environment can be formulated by a tree automaton [ALW89, PR89]. In <ref> [MSS86] </ref>, Muller et al. introduced weak automata. In a weak automaton, the automaton's set of states is partitioned into partially ordered sets. Each set is classified as accepting or rejecting. <p> As a comparison, the best known upper bound for the nonemptiness problem for Buchi automata is quadratic time. When defined on words, weak alternating automata are not less expressive than Buchi alternating automata, and they can recognize all the !-regular languages. To prove this, <ref> [MSS86, Lin88] </ref> suggest a linear translation of deterministic Muller automata to weak alternating automata. Using, however, the constructions in [MSS86, Lin88] in order translate a nondeterministic automaton A into a weak alternating automaton, one has no choice but to first translate A into a deterministic Muller automaton. <p> When defined on words, weak alternating automata are not less expressive than Buchi alternating automata, and they can recognize all the !-regular languages. To prove this, <ref> [MSS86, Lin88] </ref> suggest a linear translation of deterministic Muller automata to weak alternating automata. Using, however, the constructions in [MSS86, Lin88] in order translate a nondeterministic automaton A into a weak alternating automaton, one has no choice but to first translate A into a deterministic Muller automaton. Such a determiniza-tion involves an exponential blow-up [Mic88, Saf88, Saf92]. <p> The language of A, denoted L (A), is the set of infinite words that A accepts. Thus, each word automaton defines a subset of ! . We denote by L (A) the complement language of A, that is the set of all words in ! n L (A). In <ref> [MSS86] </ref>, Muller et al. introduce weak alternating automata (WAAs).
Reference: [Niw88] <author> D. Niwinski. </author> <title> Fixed-points vs. infinite generation. </title> <booktitle> In Proc. 3rd Symposium on Logic in Computer Science, </booktitle> <year> 1988. </year>
Reference-contexts: The construction goes through a sequence of k intermediate automata. Each automaton in the sequence refines the state space of its predecessor and has one less set in its parity acceptance condition. 1 In fact, alternating parity tree automata are exactly as expressive as the -calculus <ref> [Niw88, EJ91] </ref>. On the other hand, weak alternating tree automata are exactly as expressive as the alternation-free fragment of -calculus [KV98]. Parity automata can be viewed as a special case of Rabin automata.
Reference: [PR89] <author> A. Pnueli and R. Rosner. </author> <title> On the synthesis of a reactive module. </title> <booktitle> In Proc. 16th ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: We refer to both problems as the nonemptiness problem. The nonemptiness problem is important also for reasoning about linear-time specifications of open systems, where the interaction between a correct system and its environment can be formulated by a tree automaton <ref> [ALW89, PR89] </ref>. In [MSS86], Muller et al. introduced weak automata. In a weak automaton, the automaton's set of states is partitioned into partially ordered sets. Each set is classified as accepting or rejecting. <p> In [Rab69], Rabin described a non-elementary procedure for checking the nonemptiness of a given Rabin automaton and showed that the problem is decidable. In [HR72, Rab72], improved algorithms were described, of complexity exponential in both n and k. Only in <ref> [EJ88, PR89] </ref>, algorithms that are exponential in k and only polynomial in n have been describes. Both works described algorithms that run in time O ((nk) 3k ). <p> The O (n 2k+1 k!) bound in Theorem 5.1 improves the known O ((nk) 3k ) upper-bound for the nonemptiness problem <ref> [EJ88, PR89] </ref> for Rabin automata. A similar bound for Streett automata follows. Solving, however, the nonempti-ness problem by translating a given automaton to an equivalent weak automaton is not very appealing in practice, as such a solution never performs better than its worst-case complexity.
Reference: [Rab69] <author> M.O. Rabin. </author> <title> Decidability of second order theories and automata on infinite trees. </title> <journal> Transaction of the AMS, </journal> <volume> 141 </volume> <pages> 1-35, </pages> <year> 1969. </year>
Reference-contexts: 1 Introduction Finite automata on infinite objects were first introduced in the 1960's. Motivated by decision problems in mathematical logic, Buchi, McNaughton, and Rabin developed a framework for automata on infinite words and infinite trees <ref> [Buc62, McN66, Rab69] </ref>. The framework has proven to be very powerful. Automata, and their tight relation to second-order monadic logics were the key to the solution of several fundamental decision problems in mathematical logic [Tho90]. Today, automata on infinite objects are used for specification and verification of nonterminating programs. <p> A run is accepting if there exists an index i for which the set G i is visited infinitely often and the set B i is visited only finitely often. In <ref> [Rab69] </ref>, Rabin describes a translation of formulas of monadic second order logic to Rabin tree automata. Today, Rabin automata are used in order to reason about specifications of the full branching time logic CTL ? [ES84, VS85], as well as to model programs with fairness conditions. <p> The nonemptiness problem for Ra-bin automata plays a crucial role in solving various decision problems in logic. As a result, many efforts have been put in developing simple algorithms for nonemptiness checking. In <ref> [Rab69] </ref>, Rabin described a non-elementary procedure for checking the nonemptiness of a given Rabin automaton and showed that the problem is decidable. In [HR72, Rab72], improved algorithms were described, of complexity exponential in both n and k.
Reference: [Rab72] <author> M.O. Rabin. </author> <title> Automata on infinite objects and Church's problem. </title> <journal> Amer. Mathematical Society, </journal> <year> 1972. </year>
Reference-contexts: As a result, many efforts have been put in developing simple algorithms for nonemptiness checking. In [Rab69], Rabin described a non-elementary procedure for checking the nonemptiness of a given Rabin automaton and showed that the problem is decidable. In <ref> [HR72, Rab72] </ref>, improved algorithms were described, of complexity exponential in both n and k. Only in [EJ88, PR89], algorithms that are exponential in k and only polynomial in n have been describes. Both works described algorithms that run in time O ((nk) 3k ).
Reference: [Saf88] <author> S. Safra. </author> <title> On the complexity of !-automata. </title> <booktitle> In Proc. 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 319-327, </pages> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: Using, however, the constructions in [MSS86, Lin88] in order translate a nondeterministic automaton A into a weak alternating automaton, one has no choice but to first translate A into a deterministic Muller automaton. Such a determiniza-tion involves an exponential blow-up <ref> [Mic88, Saf88, Saf92] </ref>. Even worse, if A is an alternating automaton, then its deter-minization involves a doubly-exponential blow-up [DH94], and hence, so does the translation to weak alternating automata.
Reference: [Saf92] <author> S. Safra. </author> <title> Exponential determinization for !-automata with strong-fairness acceptance condition. </title> <booktitle> In Proc. 24th ACM Symposium on Theory of Computing, </booktitle> <address> Vic-toria, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: Using, however, the constructions in [MSS86, Lin88] in order translate a nondeterministic automaton A into a weak alternating automaton, one has no choice but to first translate A into a deterministic Muller automaton. Such a determiniza-tion involves an exponential blow-up <ref> [Mic88, Saf88, Saf92] </ref>. Even worse, if A is an alternating automaton, then its deter-minization involves a doubly-exponential blow-up [DH94], and hence, so does the translation to weak alternating automata.
Reference: [Tho90] <author> W. Thomas. </author> <title> Automata on infinite objects. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 165-191, </pages> <year> 1990. </year>
Reference-contexts: The framework has proven to be very powerful. Automata, and their tight relation to second-order monadic logics were the key to the solution of several fundamental decision problems in mathematical logic <ref> [Tho90] </ref>. Today, automata on infinite objects are used for specification and verification of nonterminating programs. By translating specifications to automata, we reduce questions about programs and their specifications to questions about automata.
Reference: [Tho97] <author> W. Thomas. </author> <title> Languages, automata, </title> <booktitle> and logic. Handbook of Formal Language Theory, </booktitle> <address> III:389-455, </address> <year> 1997. </year>
Reference-contexts: Rabin automata can be translated to parity automata with an exponential blow up <ref> [Tho97] </ref>. In the full paper we show how the same ideas used for parity automata can be used in order to translate alternating Rabin automata to weak alternating automata. As in the parity case, the construction goes through a sequence of intermediate automata.
Reference: [Var94] <author> M.Y. Vardi. </author> <title> Nontraditional applications of automata theory. </title> <booktitle> In Proc. Int'l Symp. on Theoretical Aspects of Computer Software, </booktitle> <volume> volume 789, </volume> <pages> pages 575-597. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Since the combinatorial structure of alternating automata is rich, translating specifications to alternating automata is much simpler than translating them to nondeterministic automata <ref> [Var94] </ref>. Alternating automata enable a complete partition between the logical and the algorithmic aspects of reasoning about programs, and they give rise to cleaner and simpler verification algorithms [Var96]. The rich structure of alternating automata also makes them more succinct.
Reference: [Var96] <author> M.Y. Vardi. </author> <title> An automata-theoretic approach to linear temporal logic. In Logics for Concurrency: Structure versus Automata, </title> <booktitle> volume 1043 of Lecture Notes in Computer Science, </booktitle> <pages> pages 238-266. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1996. </year>
Reference-contexts: Alternating automata enable a complete partition between the logical and the algorithmic aspects of reasoning about programs, and they give rise to cleaner and simpler verification algorithms <ref> [Var96] </ref>. The rich structure of alternating automata also makes them more succinct. For example, translating an alternating Buchi automaton to a nondeterministic Buchi automaton might involve an exponential blow up [DH94]. The succinctness of alternating automata is crucial when we use automata for the verification of branching-time specifications.
Reference: [Var97] <author> M.Y. Vardi. </author> <title> Alternating automata unifying truth and validity checking for temporal logics. </title> <editor> In W. Mc-Cune, editor, </editor> <booktitle> Proc. 14th International Conference on Automated Deduction, volume 1249 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 191-206. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> july </month> <year> 1997. </year>
Reference-contexts: In this paradigm, each specification describes a set of allowed computation trees, which can be described by an automaton over infinite trees. By translating branching-time specifications to alternating tree automata, we can reduce satisfiability to the nonemptiness problem and reduce verification to the membership problem <ref> [BVW94, Var97] </ref>. Solving the nonempti-ness problem for an alternating tree automaton is done by translating the automaton to a nondeterministic tree automaton. Deciding the membership of a program in a language of an alternating tree automaton is done by taking the product of the program and the automaton.
Reference: [VS85] <author> M.Y. Vardi and L. Stockmeyer. </author> <title> Improved upper and lower bounds for modal logics of programs. </title> <booktitle> In Proc 17th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 240-251, </pages> <year> 1985. </year>
Reference-contexts: In [Rab69], Rabin describes a translation of formulas of monadic second order logic to Rabin tree automata. Today, Rabin automata are used in order to reason about specifications of the full branching time logic CTL ? <ref> [ES84, VS85] </ref>, as well as to model programs with fairness conditions. The nonemptiness problem for Ra-bin automata plays a crucial role in solving various decision problems in logic. As a result, many efforts have been put in developing simple algorithms for nonemptiness checking.
Reference: [VW86] <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proc. First Symposium on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <address> Cambridge, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: By translating specifications to automata, we reduce questions about programs and their specifications to questions about automata. More specifically, questions such as satisfiability of specifications and correctness of programs with respect to their specifications are reduced to questions such as nonemptiness and language containment <ref> [VW86, Kur94, VW94] </ref>. The automata-theoretic approach separates the logical and the algorithmic aspects of reasoning about programs. The translation of specifications to automata handles the logic and shifts all the algorithmic difficulties to automata-theoretic problems.
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: By translating specifications to automata, we reduce questions about programs and their specifications to questions about automata. More specifically, questions such as satisfiability of specifications and correctness of programs with respect to their specifications are reduced to questions such as nonemptiness and language containment <ref> [VW86, Kur94, VW94] </ref>. The automata-theoretic approach separates the logical and the algorithmic aspects of reasoning about programs. The translation of specifications to automata handles the logic and shifts all the algorithmic difficulties to automata-theoretic problems.
References-found: 37

