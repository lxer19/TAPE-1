URL: http://www.cs.toronto.edu/~ruhtra/archive/msc-thesis-Oct94.ps.gz
Refering-URL: http://www.cs.toronto.edu/~ruhtra/
Root-URL: 
Title: Filtering Run-Time Artifacts Using Software Landscapes  
Author: by Arthur Tateishi 
Degree: A thesis submitted in conformity with the requirements for the degree of Master of Science  
Note: Copyright c 1994 by Arthur Tateishi  
Address: Toronto, Ontario, Canada M5S 1A4  Toronto  
Affiliation: Department of Computer Science University of Toronto  Graduate Department of Computer Science University of  
Abstract-found: 0
Intro-found: 1
Reference: [Amdahl, 1967] <author> Amdahl, G. </author> <year> (1967). </year> <title> Validity of the Single Processor Approach to Achieving Large Scale Computing Capabilities. </title> <booktitle> In AFIPS 1967 Spring Joint Computer Conference, </booktitle> <address> Atlantic City, N.J. </address>
Reference-contexts: The third is an immediate feedback mechanism called the execution marble which shows the program flow of control as a moving dot on the landscape. 1 Amdahl's Law <ref> [Amdahl, 1967] </ref> states that the performance improvement to be gained from using a faster mode of execution is limited by the fraction of the time the faster mode can be used.
Reference: [Baecker, 1986] <author> Baecker, R. M. </author> <year> (1986). </year> <title> Panel Discussion: An Application Overview of Program Visualization. </title> <booktitle> In ACM Conference on Computer Graphics and Interactive Techniques (SIGGRAPH'86), </booktitle> <pages> page 325. </pages>
Reference-contexts: This mental image can be the result of pictures, sound, smells, graphical animations, or any combination thereof [Price, 1992]. Baecker <ref> [Baecker, 1986] </ref> provided a detailed definition which is clearly a precursor to his definition of Software Visualization: Program Visualization is the use of the technology of interactive graphics and the crafts of graphic design, typography, animation, and cinematography to enhance the presentation and understanding of computer programs.
Reference: [Baecker and Sherman, 1981] <author> Baecker, R. M. and Sherman, D. </author> <year> (1981). </year> <title> Sorting out Sorting. </title> <note> 25 minute 16mm narrated colour film. Presented at ACM SIGGRAPH '81. </note>
Reference-contexts: As well, most computer science texts make extensive use of abstract diagrams to convey an understanding of data structures and recursion. The modern renaissance of visualization is widely considered to have begun with the film Sorting out Sorting <ref> [Baecker and Sherman, 1981] </ref> and the availability of high resolution bit-mapped display technology.
Reference: [Baeza-Yates et al., 1992] <author> Baeza-Yates, R. A., Jara, L., and Quezada, G. </author> <year> (1992). </year> <title> VSS: Automatic Animation of C Programs. </title> <booktitle> In COMPUGRAPHICS'92, </booktitle> <address> Lisbon, Portugal. </address>
Reference-contexts: Instead, Lens uses the Unix dbx debugger to set breakpoints where animation steps are to be performed. The Lens system greatly decreased the amount of work and skills required to produce a useful animation. 2.3.4 PV Example: Visual C Visual C (VCC) <ref> [Baeza-Yates et al., 1992] </ref> is a system that allows the end-user to graphically visualize and animate a C program. It functions as a preprocessor that automatically annotates the code with calls to an animation library. <p> BALSA requires the manual annotation of programs with event statements. VCC <ref> [Baeza-Yates et al., 1992] </ref> parses C programs and automatically inserts statements to call the VCC visualization support library. Manual systems have the advantage of having a knowledgable expert (the animator ) to insert annotations at a high level of abstraction. <p> Closing the gap between design and implementation will help ensure that the design documents and the source code remain mutually consistent during software development. The work done by Baeza-Yates on VCC <ref> [Baeza-Yates et al., 1992] </ref> demonstrates that automatic program visualizations are possible in compiled environments like C. A weakness of VCC is its lack of effective filters for displaying and navigating a program's run-time information.
Reference: [Borning, 1981] <author> Borning, A. </author> <year> (1981). </year> <title> The Programming Language Aspects of ThingLab, a Constraint-Oriented Simulation Laboratory. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(4) </volume> <pages> 353-387. </pages>
Reference-contexts: indentation does not change the program's specification, which is a linear stream of tokens, and therefore does not qualify as being Visual Programming. 12 Given the definition of Software Visualization, the representation of a program in a VP system is a form of SV. 2.2.2 VP Example: Graphical ThingLab ThingLab <ref> [Borning, 1981, Borning, 1986] </ref> is a simulation environment that allows users to create and simulate experiments in physics and geometry by specifying the sets of constraints in a system. ThingLab has a graphical interface to program the constraints and data flow of a system (See Figure 2.1).
Reference: [Borning, 1986] <author> Borning, A. </author> <year> (1986). </year> <title> Defining Constraints Graphically. </title> <booktitle> In ACM Conference on Human Factors in Computing Systems (CHI'86), </booktitle> <pages> pages 137-143. </pages>
Reference-contexts: indentation does not change the program's specification, which is a linear stream of tokens, and therefore does not qualify as being Visual Programming. 12 Given the definition of Software Visualization, the representation of a program in a VP system is a form of SV. 2.2.2 VP Example: Graphical ThingLab ThingLab <ref> [Borning, 1981, Borning, 1986] </ref> is a simulation environment that allows users to create and simulate experiments in physics and geometry by specifying the sets of constraints in a system. ThingLab has a graphical interface to program the constraints and data flow of a system (See Figure 2.1).
Reference: [Brown, 1988] <author> Brown, M. H. </author> <year> (1988). </year> <title> Exploring Algorithms Using Balsa-II. </title> <journal> IEEE Software, </journal> <volume> 21(5) </volume> <pages> 14-36. </pages>
Reference-contexts: Some of the successful systems developed include BALSA [Brown and Sedgewick, 1984], a pioneering work in interactive algorithm animation and its successor BALSA-II <ref> [Brown, 1988] </ref>, Incense [Myers et al., 1983] and Amethyst [Myers et al., 1988] which create graphical displays of data automatically, TANGO [Stasko, 1990, Mukherjea and Stasko, 1993] which strives to make smooth algorithm animation easier, and the University of Washington Program Illustrator (UWPI) [Henry et al., 1990] which extracts high-level abstract <p> This differs from Algorithm Animation where higher-level program descriptions are visualized. The Run-Time Landscape is a PV system by these definitions although I will also use the less precise term Software Visualization in reference to the Run-Time Landscape. 2.3.2 PV Example: BALSA-II BALSA II <ref> [Brown, 1988] </ref> is an algorithm animation system that evolved from its predecessor, BALSA [Brown and Sedgewick, 1984]. BALSA II is an effective undergraduate teaching tool that shows a program's high level data structures in a GUI environment. The cost for such a system is high. <p> These systems are classified as code intrusive (CI) [Henry et al., 1990]. BALSA <ref> [Brown and Sedgewick, 1984, Brown, 1988] </ref> is an example of such a system. Some code intrusive systems enable the annotation of programs without affecting the original source code. Nevertheless, they still change the executable 15 code generated which may be undesirable.
Reference: [Brown and Sedgewick, 1984] <author> Brown, M. H. and Sedgewick, R. </author> <year> (1984). </year> <title> A System for Algorithm Animation. </title> <booktitle> In ACM Conference on Computer Graphics and Interactive Techniques (SIGGRAPH'84), volume 18,3, </booktitle> <pages> pages 177-186. 68 69 </pages>
Reference-contexts: The modern renaissance of visualization is widely considered to have begun with the film Sorting out Sorting [Baecker and Sherman, 1981] and the availability of high resolution bit-mapped display technology. Some of the successful systems developed include BALSA <ref> [Brown and Sedgewick, 1984] </ref>, a pioneering work in interactive algorithm animation and its successor BALSA-II [Brown, 1988], Incense [Myers et al., 1983] and Amethyst [Myers et al., 1988] which create graphical displays of data automatically, TANGO [Stasko, 1990, Mukherjea and Stasko, 1993] which strives to make smooth algorithm animation easier, and <p> The Run-Time Landscape is a PV system by these definitions although I will also use the less precise term Software Visualization in reference to the Run-Time Landscape. 2.3.2 PV Example: BALSA-II BALSA II [Brown, 1988] is an algorithm animation system that evolved from its predecessor, BALSA <ref> [Brown and Sedgewick, 1984] </ref>. BALSA II is an effective undergraduate teaching tool that shows a program's high level data structures in a GUI environment. The cost for such a system is high. All algorithms must be manually annotated in the code with calls to indicate interesting events. <p> These systems are classified as code intrusive (CI) [Henry et al., 1990]. BALSA <ref> [Brown and Sedgewick, 1984, Brown, 1988] </ref> is an example of such a system. Some code intrusive systems enable the annotation of programs without affecting the original source code. Nevertheless, they still change the executable 15 code generated which may be undesirable. <p> obtaining information about a program, we need to process or filter the information before it can be usefully displayed. 2.5 Techniques for Filtering Information This section discusses the techniques used by several systems to filter information down to a manageable level. 2.5.1 Restricting attention to small-scale systems The BALSA system <ref> [Brown and Sedgewick, 1984] </ref> animates algorithms in a clear manner by having an algorithm and animation expert work on small pieces of code, selectively choosing only the interesting events, and providing the most appropriate visualizations for the algorithm. There are two problems with this approach. <p> A weakness of VCC is its lack of effective filters for displaying and navigating a program's run-time information. The Run-Time Landscape uses several methods to increase the information bandwidth to the user (colour and animation) and filter extraneous data (hierarchical views). Systems without automated extraction such as BALSA <ref> [Brown and Sedgewick, 1984] </ref> cannot scale up to large software systems with the ease of automated systems like the Run-Time Landscape. One strength of the Run-Time Landscape is its generality.
Reference: [Chandhok et al., 1991] <author> Chandhok, R., Garlan, D., Meter, G., Miller, P., and Pane, J. </author> <year> (1991). </year> <title> Pascal Genie, 1.0, Pascal programming environment with integrated structure-driven editor running on Macintosh computers. </title> <booktitle> Chariot Software Group, </booktitle> <address> San Diego, CA. </address>
Reference: [Chang and Ungar, 1993] <author> Chang, B.-W. and Ungar, D. </author> <year> (1993). </year> <title> Animation: From Cartoons to the User Interface. </title> <booktitle> In ACM SIGGRAPH User Interface Systems and Technology (UIST'93), </booktitle> <pages> pages 45-55. </pages>
Reference-contexts: Motion blurring is already used by stop motion computer animators in the film industry to create more realistic and convincing pictures of moving objects. By using these techniques in software visualization, the user will be able to follow faster animations with less disorientation <ref> [Chang and Ungar, 1993, Hudson and Stasko, 1993] </ref>. 1.7.3 Selecting Data Program data is displayed in windows of the Dataview Tool and selected using a simple point-and-click interface. The user may also use the Landscape for requesting data to be viewed. <p> a sheet of rubber being stretched and provides more uniform scaling inside the stretched regions. 2.5.4 Animation principles to increase cognitive bandwidth The application of animation principles (anticipation, motion blurring, slow in/out, and follow through) in the visualization graphics enables a user to follow and understand faster, more complex visualizations <ref> [Chang and Ungar, 1993, Hudson and Stasko, 1993] </ref>. Therefore, this approach is useful in almost any system for software visualization. <p> This circle will henceforth be called an execution marble and moves smoothly between landscape boxes with the aid of cartoon animation techniques <ref> [Chang and Ungar, 1993] </ref>. See also Section 4.7 for implementation details. Multiple threads would be represented by a separate marble per thread in the same manner used by Paradocs [Price, 1990]. <p> The result was a visualization where boxes rapidly changed colour. It looked interesting but not enlightening because the lack of directional cues overwhelmed the user with flashing boxes that were hard to follow. Animation techniques such as motion blur seemed ideally suited to control flow visualization <ref> [Chang and Ungar, 1993] </ref>. <p> that even a simple version of blurred animation would reap most of the same benefits as complete implementations by providing enough information for the human observer to synthesize the illusion of motion. 4.7.2 Animation Phases Cartoon animators present the following phases to help viewers follow the action in an animation <ref> [Thomas and Johnston, 1981, Chang and Ungar, 1993] </ref>. Anticipation is a short movement opposite to the direction of travel. This brief cue signals the viewer that motion is going to take place. 54 Slow out is the acceleration phase of motion. The direction of motion becomes clear during this phase.
Reference: [Consens, 1994] <author> Consens, M. P. </author> <year> (1994). </year> <title> Creating and Filtering Structured Data Visualizations Using Hygraph Patterns. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Toronto. </institution>
Reference-contexts: The number of visualization objects can become overwhelming. Imagine a large OO system with 200 classes. The problem of filtering the information down to a manageable level is formidable but by no means hopeless. Consens and Mendel-zon have explored advanced filtering and clustering in Hy+ <ref> [Consens and Mendelzon, 1993, Consens, 1994, Mendelzon, 1993] </ref>. A good system must be intuitive and easily navigable. Systems which rely on window scrollbars to provide range selection are not very effective. Scrollbar range selectors offer linear panning but they don't provide scaling and the global context is not apparent.
Reference: [Consens et al., 1993] <author> Consens, M. P., Hasan, M. Z., and Mendelzon, A. O. </author> <year> (1993). </year> <title> Debugging Distributed Programs by Visualizing and Querying Event Traces. </title> <booktitle> In Extended Abstract in Proceedings of ACM/ONR Workshop on Parallel and Distributed Debugging. </booktitle> <institution> See also Univ. of Toronto Tech Report CSRI-285. </institution>
Reference-contexts: Also, full knowledge of the execution enables a postmortem visualization to provide better layouts than a run-time system. A postmortem based debugging and visualization system was investigated using the Hy+ system [Consens and Mendelzon, 1993] for filtering information <ref> [Consens et al., 1993] </ref>. The Run-Time Landscape follows the example of systems like Amethyst [Myers et al., 1988] and TANGO [Stasko, 1990] in providing visualizations at run-time. 2.7 Summary This chapter presented background material on Software Visualization and described methods for extracting and displaying visualization information.
Reference: [Consens and Mendelzon, 1993] <author> Consens, M. P. and Mendelzon, A. O. </author> <year> (1993). </year> <title> Hy + : A Hygraph-based Query and Visualization System. </title> <booktitle> In Proceedings of the ACM SIGACT-SIGMOD Symposium on Principles of Database Systems, </booktitle> <address> Washington, DC. </address>
Reference-contexts: The number of visualization objects can become overwhelming. Imagine a large OO system with 200 classes. The problem of filtering the information down to a manageable level is formidable but by no means hopeless. Consens and Mendel-zon have explored advanced filtering and clustering in Hy+ <ref> [Consens and Mendelzon, 1993, Consens, 1994, Mendelzon, 1993] </ref>. A good system must be intuitive and easily navigable. Systems which rely on window scrollbars to provide range selection are not very effective. Scrollbar range selectors offer linear panning but they don't provide scaling and the global context is not apparent. <p> Also, full knowledge of the execution enables a postmortem visualization to provide better layouts than a run-time system. A postmortem based debugging and visualization system was investigated using the Hy+ system <ref> [Consens and Mendelzon, 1993] </ref> for filtering information [Consens et al., 1993].
Reference: [Eick and Steffen, 1992] <author> Eick, S. G. and Steffen, J. L. </author> <year> (1992). </year> <title> Visualizing Code Profiling Line Oriented Statistics. </title> <type> Technical Report Unknown: </type> <institution> eick@research.att.com, AT&T Bell Laboratories. </institution>
Reference-contexts: Darker shades represent a higher percentage of CPU usage. Traditional Profiling Profiling systems record the execution time of calls and the number of calls to each subprogram. Some profiling systems provide better resolution and generate information for each statement <ref> [Eick and Steffen, 1992, Eick et al., 1992] </ref>. Profiling information in its raw form consists of execution time measurement data for each call which is often output as a text listing or represented as a simple histogram plot. Profiling information usually comes in two flavours.
Reference: [Eick et al., 1992] <author> Eick, S. G., Steffen, J. L., and Jr., E. E. S. </author> <year> (1992). </year> <title> Seesoft ATool For Visualizing Line Oriented Software Statistics. </title> <type> Technical Report Room IHC 1G-339, </type> <institution> AT&T Bell Laboratories. </institution>
Reference-contexts: Darker shades represent a higher percentage of CPU usage. Traditional Profiling Profiling systems record the execution time of calls and the number of calls to each subprogram. Some profiling systems provide better resolution and generate information for each statement <ref> [Eick and Steffen, 1992, Eick et al., 1992] </ref>. Profiling information in its raw form consists of execution time measurement data for each call which is often output as a text listing or represented as a simple histogram plot. Profiling information usually comes in two flavours.
Reference: [Furnas, 1986] <author> Furnas, G. W. </author> <year> (1986). </year> <title> Generalized fisheye views. </title> <booktitle> In ACM Conference on Human Factors in Computing Systems (CHI'86), </booktitle> <pages> pages 16-23. </pages>
Reference-contexts: One advantage of these displays is that the user always sees the global context around the focus area so less disorientation occurs <ref> [Furnas, 1986, Sarkar and Brown, 1992] </ref>.
Reference: [Glinert and Tanimoto, 1984] <author> Glinert, E. P. and Tanimoto, S. L. </author> <year> (1984). </year> <title> Pict: An Interactive Graphical Programming Environment. </title> <journal> IEEE Computer, </journal> <volume> 17(11) </volume> <pages> 7-25. 70 </pages>
Reference-contexts: A number of people have written taxonomies categorizing these and other systems. Myers has published a number of revisions of his taxonomy of program visualization and visual programming systems [Myers, 1986, Myers, 1988, Myers, 1990]. An early survey was 10 11 included in the paper by Glinert and Tanimoto <ref> [Glinert and Tanimoto, 1984] </ref>. Shu has also published a survey covering a number of systems [Shu, 1988]. Blaine Price, Ronald Baecker, and Ian Small wrote an extension of their earlier work to produce a newer, more comprehensive taxonomy [Price et al., 1992].
Reference: [Goldstein and von Neumann, 1947] <author> Goldstein, H. and von Neumann, J. </author> <year> (1947). </year> <title> Planning and coding problems of an electronic computing instrument. </title> <editor> In Taub, A., editor, von Neumann, J., </editor> <booktitle> Collect Works, </booktitle> <pages> pages 80-151. </pages> <address> McMillan, New York. </address>
Reference-contexts: designing a visualization system, and ends with a summary of where the Run-Time Landscape fits relative to previous systems and what design decisions were made. 2.1 History of Software Visualization The importance of pictorial representations for computer programs dates back to the use of flow charts to describe control flows <ref> [Goldstein and von Neumann, 1947, Haibt, 1959] </ref>. As well, most computer science texts make extensive use of abstract diagrams to convey an understanding of data structures and recursion.
Reference: [Haibt, 1959] <author> Haibt, L. M. </author> <year> (1959). </year> <title> A Program to Draw Multi-Level Flow Charts. </title> <booktitle> In The Western Joint Computer Conference, </booktitle> <pages> pages 131-137, </pages> <address> San Francisco, CA. </address>
Reference-contexts: designing a visualization system, and ends with a summary of where the Run-Time Landscape fits relative to previous systems and what design decisions were made. 2.1 History of Software Visualization The importance of pictorial representations for computer programs dates back to the use of flow charts to describe control flows <ref> [Goldstein and von Neumann, 1947, Haibt, 1959] </ref>. As well, most computer science texts make extensive use of abstract diagrams to convey an understanding of data structures and recursion.
Reference: [Hayes, 1993] <author> Hayes, W. </author> <year> (1993). </year> <title> Private Discussion: On Landscape Breakpoints. </title>
Reference-contexts: A commonly used form of breakpoint asks the debugger to stop execution at the entry point to a given subprogram. At this point the programmer will usually single step through the code while examining data. The landscape approach to this common operation is the addition of landscape break-points <ref> [Hayes, 1993] </ref>. The user presses a key (currently the z key) to toggle a landscape box as a breakpoint. This requests that the execution pause at any entry point within the chosen landscape box.
Reference: [Hennessy and Patterson, 1990] <author> Hennessy, J. L. and Patterson, D. A. </author> <year> (1990). </year> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California. </address>
Reference-contexts: The Speedup ratio can be defined as the ratio <ref> [Hennessy and Patterson, 1990] </ref>: Speedup = Execution time for entire task without using the enhancement Execution time for entire task using enhancement when possible 24 to represent the relative execution times. Darker shades represent a higher percentage of CPU usage.
Reference: [Henry et al., 1990] <author> Henry, R. R., Whaley, K. M., and Forstall, B. </author> <year> (1990). </year> <title> The University of Washington Program Illustrator (UWPI). </title> <booktitle> In ACM SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 223-233. </pages>
Reference-contexts: interactive algorithm animation and its successor BALSA-II [Brown, 1988], Incense [Myers et al., 1983] and Amethyst [Myers et al., 1988] which create graphical displays of data automatically, TANGO [Stasko, 1990, Mukherjea and Stasko, 1993] which strives to make smooth algorithm animation easier, and the University of Washington Program Illustrator (UWPI) <ref> [Henry et al., 1990] </ref> which extracts high-level abstract data structures automatically. A number of people have written taxonomies categorizing these and other systems. Myers has published a number of revisions of his taxonomy of program visualization and visual programming systems [Myers, 1986, Myers, 1988, Myers, 1990]. <p> These systems are classified as code intrusive (CI) <ref> [Henry et al., 1990] </ref>. BALSA [Brown and Sedgewick, 1984, Brown, 1988] is an example of such a system. Some code intrusive systems enable the annotation of programs without affecting the original source code. Nevertheless, they still change the executable 15 code generated which may be undesirable. <p> (CI) <ref> [Henry et al., 1990] </ref>. BALSA [Brown and Sedgewick, 1984, Brown, 1988] is an example of such a system. Some code intrusive systems enable the annotation of programs without affecting the original source code. Nevertheless, they still change the executable 15 code generated which may be undesirable. Data intrusive (DI) [Henry et al., 1990] systems add hookpoints in an object oriented language by subclassing object classes and replacing class methods to suit the needs of the visualization. The Smalltalk animation system developed at Tektronix uses this approach [London and Duisberg, 1985].
Reference: [Holt, 1993] <author> Holt, R. C. </author> <year> (1993). </year> <title> Private Discussion: On Principle of Minimal Change for GUIs. </title>
Reference-contexts: A menu option can be used to choose between the two preferences. 52 4.5.3 Minimizing Screen Distractions To provide an effective user interface, it is important to reduce flicker and jumpy updates so that only the changing parts of the data display are noticed. This Principle of Minimal Change <ref> [Holt, 1993] </ref> requires designing a user interface that changes as little as possible visually because the human eye is particularly adept at detecting changes and is distracted by them. The Athena widget set provides a list widget that can only be updated en masse.
Reference: [Holt and Cordy, 1988] <author> Holt, R. C. and Cordy, J. R. </author> <year> (1988). </year> <title> The Turing Programming Language. </title> <journal> Communications of the ACM, </journal> <volume> 31(12) </volume> <pages> 1410-1423. </pages>
Reference-contexts: OOT is a language based on Turing <ref> [Holt and Cordy, 1988] </ref> that supports concurrent processes, classes, inheritance, and poly-morphism. OOT provides the usual constructs available in most strongly-typed procedural programming languages including module level scope control.
Reference: [Holt et al., 1992] <author> Holt, R. C., Penny, D. A., and Mancoridis, S. </author> <year> (1992). </year> <title> Multicolour Programming and Metamorphic Programming: Object Oriented Programming-in-the-Large. </title> <booktitle> In Proceedings of the 1992 IBM CASCON Conference, </booktitle> <pages> pages 43-58. </pages>
Reference-contexts: A Software Landscape relates software design entities with source code or interface descriptions in a consistent manner governed by a set of formal rules defining well-formedness <ref> [Holt et al., 1992, Mancoridis et al., 1993a, Penny, 1992] </ref>. The Software Landscape Viewer displays boxes and arrows to represent the relationships in a design (See subsystems which combine with elision modes to allow the selective hiding of subsystem details.
Reference: [Hudson and Stasko, 1993] <author> Hudson, S. E. and Stasko, J. T. </author> <year> (1993). </year> <title> Animation Support in a User Interface Toolkit: Flexible, Robust, and Reusable Abstractions. </title> <booktitle> In ACM SIGGRAPH User Interface Systems and Technology (UIST'93), </booktitle> <pages> pages 57-67. </pages>
Reference-contexts: Motion blurring is already used by stop motion computer animators in the film industry to create more realistic and convincing pictures of moving objects. By using these techniques in software visualization, the user will be able to follow faster animations with less disorientation <ref> [Chang and Ungar, 1993, Hudson and Stasko, 1993] </ref>. 1.7.3 Selecting Data Program data is displayed in windows of the Dataview Tool and selected using a simple point-and-click interface. The user may also use the Landscape for requesting data to be viewed. <p> a sheet of rubber being stretched and provides more uniform scaling inside the stretched regions. 2.5.4 Animation principles to increase cognitive bandwidth The application of animation principles (anticipation, motion blurring, slow in/out, and follow through) in the visualization graphics enables a user to follow and understand faster, more complex visualizations <ref> [Chang and Ungar, 1993, Hudson and Stasko, 1993] </ref>. Therefore, this approach is useful in almost any system for software visualization. <p> Trace mode still allows fast enough execution that the marble would fall behind in the animation (0.5 seconds is a long time during the execution of a program). It would be preferable to have a smooth degradation in detail as in Artkit <ref> [Hudson and Stasko, 1993] </ref> since temporal consistency is an important human factor. The compromise reached was the addition of a Catch-Up Mode. If a marble movement is requested before the completion of the previous movement, Catch-Up Mode is begun.
Reference: [Letovsky, 1988] <author> Letovsky, S. </author> <year> (1988). </year> <title> Plan analysis of programs. </title> <type> Technical Report Research Report No. 662, </type> <institution> Yale University. </institution>
Reference-contexts: The time needed to annotate code makes this approach unworkable for large software systems. 2.5.2 Finding higher level abstractions Automated program recognition systems parse a program and try to match the code to known cliches to gain an understanding of the program <ref> [Letovsky, 1988, Wills, 1990, Lutz, 1992, Wills, 1992] </ref>. These systems are still in their infancy and only handle short lengths of code. However, it is conceivable that they will evolve to handle larger systems in the future.
Reference: [London and Duisberg, 1985] <author> London, R. L. and Duisberg, R. A. </author> <year> (1985). </year> <title> Animating Programs Using Smalltalk. </title> <journal> IEEE Computer, </journal> <volume> 18(8) </volume> <pages> 66-71. </pages>
Reference-contexts: Data intrusive (DI) [Henry et al., 1990] systems add hookpoints in an object oriented language by subclassing object classes and replacing class methods to suit the needs of the visualization. The Smalltalk animation system developed at Tektronix uses this approach <ref> [London and Duisberg, 1985] </ref>. Non-invasive probes extract information without affecting the source or object code. The Run-Time Landscape is such a system. The OOT pseudo-code compiler/executor can be polled for information on the state of threads or variable contents.
Reference: [Lutz, 1992] <author> Lutz, R. </author> <year> (1992). </year> <title> Plan diagrams as a basis for understanding and debugging pascal programs. </title> <editor> In Eisenstadt, M., Keane, M., and Rajan, T., editors, </editor> <booktitle> Novice pro 71 gramming environments: explorations in human-compiter interaction, </booktitle> <pages> pages 243-285. </pages> <publisher> Lawrence Erlbaum Associates, </publisher> <address> East Sussex, UK. </address>
Reference-contexts: The time needed to annotate code makes this approach unworkable for large software systems. 2.5.2 Finding higher level abstractions Automated program recognition systems parse a program and try to match the code to known cliches to gain an understanding of the program <ref> [Letovsky, 1988, Wills, 1990, Lutz, 1992, Wills, 1992] </ref>. These systems are still in their infancy and only handle short lengths of code. However, it is conceivable that they will evolve to handle larger systems in the future.
Reference: [Mancoridis, 1992] <author> Mancoridis, S. </author> <year> (1992). </year> <title> A Visual Programming Environment for Object-Oriented Turing. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Toronto. </institution>
Reference-contexts: OOT provides the usual constructs available in most strongly-typed procedural programming languages including module level scope control. The current environment is a fast pseudo-code compiler/executor combination using a front-end for the X Window System <ref> [Mancoridis, 1992, Mancoridis et al., 1993a] </ref>.
Reference: [Mancoridis et al., 1994] <author> Mancoridis, S., Holt, R. C., and Godfrey, M. W. </author> <year> (1994). </year> <title> A Program Understanding Environment Based on the "Star" approach to Tool Integration". </title> <booktitle> In Proceedings of the Twenty-Second ACM Computer Science Conference. </booktitle>
Reference-contexts: It was fortunate that a tool to generate and lay out landscapes from source code was already available. The Star System <ref> [Mancoridis et al., 1994] </ref> is a tool composed of a set of parsers and code generators for converting design relationships between numerous syntactic formats.
Reference: [Mancoridis et al., 1993a] <author> Mancoridis, S., Holt, R. C., and Penny, D. A. </author> <year> (1993a). </year> <title> A Conceptual Framework for Software Development. </title> <booktitle> In Proceedings of the Twenty-First ACM Computer Science Conference, </booktitle> <pages> pages 74-80. </pages>
Reference-contexts: OOT provides the usual constructs available in most strongly-typed procedural programming languages including module level scope control. The current environment is a fast pseudo-code compiler/executor combination using a front-end for the X Window System <ref> [Mancoridis, 1992, Mancoridis et al., 1993a] </ref>. <p> A Software Landscape relates software design entities with source code or interface descriptions in a consistent manner governed by a set of formal rules defining well-formedness <ref> [Holt et al., 1992, Mancoridis et al., 1993a, Penny, 1992] </ref>. The Software Landscape Viewer displays boxes and arrows to represent the relationships in a design (See subsystems which combine with elision modes to allow the selective hiding of subsystem details. <p> Some simple queries to show use and inheritance relations are also provided. All of these attributes come together in the Software Landscape Viewer to provide a tightly integrated system for designing and re-engineering software systems <ref> [Mancoridis et al., 1993a] </ref>. 1.5 What is the Run-Time Landscape? The Run-Time Landscape is an extension of the Software Landscape for debugging and profiling software systems while maintaining the benefits of the Landscape's hierarchical model. <p> A better solution would have a replacement list widget that permitted individual list items to be updated without affecting the whole window. The next section discusses how the original Software Landscape prototype was adapted for use in the Run-Time Landscape. 4.6 The Landscape as a Repository The Software Landscape <ref> [Penny, 1992, Mancoridis et al., 1993a] </ref> prototype written by David Penny represents the landscape diagrams in an elaborate tree structure representing the containment relations with various lists for arrows and back pointers. His prototype provided a convenient repository for storing landscape breakpoint flags and profiling data.
Reference: [Mancoridis et al., 1993b] <author> Mancoridis, S., Holt, R. C., and Penny, D. A. </author> <year> (1993b). </year> <title> A "Curriculum-Cycle" Environment for Teaching Programming. </title> <booktitle> In Proceedings of the Twenty-Fourth ACM SIGCSE Technical Symposium on Computer Science Education, </booktitle> <pages> pages 15-19. </pages>
Reference-contexts: The Run-Time Landscape evolved from the Software Landscape as a tool for debugging, profiling, and understanding Object Oriented Turing programs by exploring the run-time behaviour of the system. 1.3 Object Oriented Turing Object Oriented Turing (OOT) is the name for both the language and the software development environment <ref> [Mancoridis et al., 1993b] </ref>. OOT is a language based on Turing [Holt and Cordy, 1988] that supports concurrent processes, classes, inheritance, and poly-morphism. OOT provides the usual constructs available in most strongly-typed procedural programming languages including module level scope control.
Reference: [Mendelzon, 1993] <author> Mendelzon, A. O. </author> <year> (1993). </year> <title> Declarative Database Visualization: Recent Papers from the Hy+/Graphlog Project. </title> <type> Technical Report CSRI-285, </type> <institution> University of Toronto. </institution>
Reference-contexts: The number of visualization objects can become overwhelming. Imagine a large OO system with 200 classes. The problem of filtering the information down to a manageable level is formidable but by no means hopeless. Consens and Mendel-zon have explored advanced filtering and clustering in Hy+ <ref> [Consens and Mendelzon, 1993, Consens, 1994, Mendelzon, 1993] </ref>. A good system must be intuitive and easily navigable. Systems which rely on window scrollbars to provide range selection are not very effective. Scrollbar range selectors offer linear panning but they don't provide scaling and the global context is not apparent.
Reference: [Mukherjea and Stasko, 1993] <author> Mukherjea, S. and Stasko, J. T. </author> <year> (1993). </year> <title> Applying Algorithm Animation Techniques for Program Tracing, Debugging, </title> <booktitle> and Understanding. In 15th IEEE International Conference on Software Engineering (ICSE'93). </booktitle>
Reference-contexts: Some of the successful systems developed include BALSA [Brown and Sedgewick, 1984], a pioneering work in interactive algorithm animation and its successor BALSA-II [Brown, 1988], Incense [Myers et al., 1983] and Amethyst [Myers et al., 1988] which create graphical displays of data automatically, TANGO <ref> [Stasko, 1990, Mukherjea and Stasko, 1993] </ref> which strives to make smooth algorithm animation easier, and the University of Washington Program Illustrator (UWPI) [Henry et al., 1990] which extracts high-level abstract data structures automatically. A number of people have written taxonomies categorizing these and other systems. <p> A labour and skills intensive process such as this can never scale to systems larger than toy examples. 14 2.3.3 PV Example: Tango and Lens Tango [Stasko, 1990] is a system for generating algorithm animations similar to BALSA but based on a formal framework. When combined with the Lens <ref> [Mukherjea and Stasko, 1993] </ref> system, manual annotation is performed with a graphical user interface and code does not need to be intruded upon. Instead, Lens uses the Unix dbx debugger to set breakpoints where animation steps are to be performed. <p> Non-invasive probes extract information without affecting the source or object code. The Run-Time Landscape is such a system. The OOT pseudo-code compiler/executor can be polled for information on the state of threads or variable contents. As mentioned earlier, the Lens system <ref> [Mukherjea and Stasko, 1993] </ref> uses the Unix dbx debugger as a non-invasive probe. The performance penalty for each extraction method depends on the access patterns utilized. The CI method incurs a relatively small penalty per annotation but one pays that penalty during all code execution. <p> However, this is not always an advantage. Manual systems may require an expert of the software system who is no longer available. Furthermore, a manual system requires a lot time to annotate a piece of source code. Some manual systems such as Lens <ref> [Mukherjea and Stasko, 1993] </ref> help the animator perform the task of annotation; however, the time to annotate a program is still significant. Therefore, manual systems do not scale up to large software systems whereas automatic systems are far more likely to scale well to large systems.
Reference: [Myers, 1986] <author> Myers, B. A. </author> <year> (1986). </year> <title> Visual Programming, Programming by Example, and Program Visualization: A Taxonomy. </title> <booktitle> In ACM Conference on Human Factors in Computing Systems (CHI'86), </booktitle> <pages> pages 59-66. </pages>
Reference-contexts: A number of people have written taxonomies categorizing these and other systems. Myers has published a number of revisions of his taxonomy of program visualization and visual programming systems <ref> [Myers, 1986, Myers, 1988, Myers, 1990] </ref>. An early survey was 10 11 included in the paper by Glinert and Tanimoto [Glinert and Tanimoto, 1984]. Shu has also published a survey covering a number of systems [Shu, 1988].
Reference: [Myers, 1988] <author> Myers, B. A. </author> <year> (1988). </year> <title> The State of the Art in Visual Programming and Program Visualization. </title> <type> Technical Report Technical Report CMU-CS-88-114, </type> <institution> Computer Science Department, Carnegie Mellon University, </institution> <address> Pittsburgh, PA. </address>
Reference-contexts: A number of people have written taxonomies categorizing these and other systems. Myers has published a number of revisions of his taxonomy of program visualization and visual programming systems <ref> [Myers, 1986, Myers, 1988, Myers, 1990] </ref>. An early survey was 10 11 included in the paper by Glinert and Tanimoto [Glinert and Tanimoto, 1984]. Shu has also published a survey covering a number of systems [Shu, 1988]. <p> SV is a more general term encompassing Visual Programming, Algorithm Visualization, and Program Visualization. The next section defines Visual Programming and the following section defines Program Visualization. 2.2 Visual Programming 2.2.1 Definition Visual Programming (VP) is the use of graphical methods in the specification of a program. Brad Myers <ref> [Myers, 1988] </ref> offers the definition: Visual Programming refers to any system that allows the user to specify a pro gram in a two (or more) dimensional fashion. <p> Baecker [Baecker, 1986] provided a detailed definition which is clearly a precursor to his definition of Software Visualization: Program Visualization is the use of the technology of interactive graphics and the crafts of graphic design, typography, animation, and cinematography to enhance the presentation and understanding of computer programs. Myers <ref> [Myers, 1988] </ref> proposed that: ... in Program Visualization, the program is specified in a conventional, textual manner, and the graphics is used to illustrate some aspect of the program or its run-time execution.
Reference: [Myers, 1990] <author> Myers, B. A. </author> <year> (1990). </year> <title> Taxonomies of Visual Programming and Program Visualization. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 1(1) </volume> <pages> 97-123. 72 </pages>
Reference-contexts: A number of people have written taxonomies categorizing these and other systems. Myers has published a number of revisions of his taxonomy of program visualization and visual programming systems <ref> [Myers, 1986, Myers, 1988, Myers, 1990] </ref>. An early survey was 10 11 included in the paper by Glinert and Tanimoto [Glinert and Tanimoto, 1984]. Shu has also published a survey covering a number of systems [Shu, 1988].
Reference: [Myers et al., 1983] <author> Myers, B. A., Chandhok, R., and Sareen, A. </author> <year> (1983). </year> <title> Incense: A System for Displaying Data Structures. </title> <booktitle> In ACM Conference on Computer Graphics and Interactive Techniques (SIGGRAPH'83), </booktitle> <pages> pages 115-125. </pages>
Reference-contexts: Some of the successful systems developed include BALSA [Brown and Sedgewick, 1984], a pioneering work in interactive algorithm animation and its successor BALSA-II [Brown, 1988], Incense <ref> [Myers et al., 1983] </ref> and Amethyst [Myers et al., 1988] which create graphical displays of data automatically, TANGO [Stasko, 1990, Mukherjea and Stasko, 1993] which strives to make smooth algorithm animation easier, and the University of Washington Program Illustrator (UWPI) [Henry et al., 1990] which extracts high-level abstract data structures automatically.
Reference: [Myers et al., 1988] <author> Myers, B. A., Chandhok, R., and Sareen, A. </author> <year> (1988). </year> <title> Automatic Data Visualization for Novice Pascal Programmers. </title> <booktitle> In IEEE Workshop on Visual Languages, </booktitle> <pages> pages 192-198. </pages>
Reference-contexts: Some of the successful systems developed include BALSA [Brown and Sedgewick, 1984], a pioneering work in interactive algorithm animation and its successor BALSA-II [Brown, 1988], Incense [Myers et al., 1983] and Amethyst <ref> [Myers et al., 1988] </ref> which create graphical displays of data automatically, TANGO [Stasko, 1990, Mukherjea and Stasko, 1993] which strives to make smooth algorithm animation easier, and the University of Washington Program Illustrator (UWPI) [Henry et al., 1990] which extracts high-level abstract data structures automatically. <p> A postmortem based debugging and visualization system was investigated using the Hy+ system [Consens and Mendelzon, 1993] for filtering information [Consens et al., 1993]. The Run-Time Landscape follows the example of systems like Amethyst <ref> [Myers et al., 1988] </ref> and TANGO [Stasko, 1990] in providing visualizations at run-time. 2.7 Summary This chapter presented background material on Software Visualization and described methods for extracting and displaying visualization information. <p> This would be a form of heat trail display for data values. Another area of interest is the use of pictures in the display of data like those in Amethyst <ref> [Myers et al., 1988] </ref>. The user interface for browsing arrays is another problem that needs to be addressed. 5.3.2 Generalization The ideas presented in the Run-Time Landscape are not confined to OOT or interpretive execution.
Reference: [Pauw et al., 1993] <author> Pauw, W. D., Helm, R., Kimelman, D., and Vlissides, J. </author> <year> (1993). </year> <title> Visualizing the Behaviour of Object-Oriented Systems. </title> <booktitle> In Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA'93), </booktitle> <pages> pages 326-337. </pages>
Reference-contexts: Third, the movement of the marble may provide cues for rearrangement of the landscape layout or restructuring of the program. Deep, wasteful calling patterns become evident immediately. Wim De Pauw et al <ref> [Pauw et al., 1993] </ref> have found some interesting structures by dynamic clustering of objects according to recent object to object communications. Lastly, the patterns of movement become a rough guide for the user seeking to understand the code. <p> This approach lends itself to instance rearrangment and 67 the clustering views by Wim De Pauw et al <ref> [Pauw et al., 1993] </ref>. However, the resulting landscape may become too cluttered to use effectively. Another possibility adds small "growths" to the class box in the landscape for each instance thus maintaining a tight coupling of instance to parent class.
Reference: [Penny, 1992] <author> Penny, D. A. </author> <year> (1992). </year> <title> The Software Landscape: A Visual Formalism for Programming-in-the-Large. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Toronto. </institution>
Reference-contexts: A Software Landscape relates software design entities with source code or interface descriptions in a consistent manner governed by a set of formal rules defining well-formedness <ref> [Holt et al., 1992, Mancoridis et al., 1993a, Penny, 1992] </ref>. The Software Landscape Viewer displays boxes and arrows to represent the relationships in a design (See subsystems which combine with elision modes to allow the selective hiding of subsystem details. <p> A better solution would have a replacement list widget that permitted individual list items to be updated without affecting the whole window. The next section discusses how the original Software Landscape prototype was adapted for use in the Run-Time Landscape. 4.6 The Landscape as a Repository The Software Landscape <ref> [Penny, 1992, Mancoridis et al., 1993a] </ref> prototype written by David Penny represents the landscape diagrams in an elaborate tree structure representing the containment relations with various lists for arrows and back pointers. His prototype provided a convenient repository for storing landscape breakpoint flags and profiling data.
Reference: [Pressman, 1992] <author> Pressman, R. S. </author> <year> (1992). </year> <title> Software Engineering: A Practitioner's Approach, </title> <publisher> 3rd Ed. McGraw-Hill, </publisher> <address> New York, NY. </address>
Reference-contexts: The next section discusses the use of the Run-Time Landscape in program understanding. 3.4.3 Program Understanding Software maintenance accounts for a majority of the effort expended on computer software today <ref> [Pressman, 1992] </ref>.
Reference: [Price, 1990] <author> Price, B. A. </author> <year> (1990). </year> <title> A Framework for the Automatic Animation of Concurrent Programs. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Toronto. </institution>
Reference-contexts: He goes on to argue that conventional textual-based programming is one-dimensional since the compilers that parse such languages do so by treating the program as a one-dimensional input stream. Blaine Price, in his Master's thesis <ref> [Price, 1990] </ref>, criticizes Myers by arguing that programmers may view a textually specified program in a multidimensional manner (lines, and levels of indentation) and it is no concern that the compiler processes the same text as a linear stream. <p> See also Section 4.7 for implementation details. Multiple threads would be represented by a separate marble per thread in the same manner used by Paradocs <ref> [Price, 1990] </ref>. This marble animator on its own can still lead to disorientation if the marble moves about the display too quickly. However, the combination of execution marbles with the landscape provides a unique set of features to reduce extraneous movement. <p> Wim De Pauw et al [Pauw et al., 1993] have found some interesting structures by dynamic clustering of objects according to recent object to object communications. Lastly, the patterns of movement become a rough guide for the user seeking to understand the code. During user testing of Paradocs <ref> [Price, 1990] </ref>, Blaine Price found Paradocs test subjects narrowed down the problem area better than the control group. When debugging a system, it is useful to be able to pause at a place in the code. <p> The marble animator in the Landscape Viewer supports only a single flow of control. In a multithreaded program, the marble animator follows the global flow of control, which 40 41 exists because concurrency is simulated in OOT, instead of a separate marble following each thread <ref> [Price, 1990] </ref>. The other major omissions from the Landscape Viewer are profiling displays using colour gradations to show cumulative execution time and the tracking of created and destroyed class instances.
Reference: [Price, 1992] <author> Price, B. A. </author> <year> (1992). </year> <title> Exploring Intelligent Automatic Software Visualization. </title> <type> Ph.D. Qualifying Examination Report, </type> <institution> Human Cognition Research Lab, The Open University, Milton Keynes, UK. </institution>
Reference-contexts: This mental image can be the result of pictures, sound, smells, graphical animations, or any combination thereof <ref> [Price, 1992] </ref>. Baecker [Baecker, 1986] provided a detailed definition which is clearly a precursor to his definition of Software Visualization: Program Visualization is the use of the technology of interactive graphics and the crafts of graphic design, typography, animation, and cinematography to enhance the presentation and understanding of computer programs.
Reference: [Price, 1993] <author> Price, B. A. </author> <year> (1993). </year> <title> Research Proposal: Intelligent Automatic Software Visualization. </title> <institution> Human Cognition Research Lab, The Open University, Milton Keynes, UK. </institution>
Reference-contexts: However, it is conceivable that they will evolve to handle larger systems in the future. Once such a system understands a program, it can in principle decide the best visualization forms to present and assume the role of the expert annotator in a BALSA 17 type system <ref> [Price, 1993] </ref>. 2.5.3 Fisheye views A fish eye lens shows normal detail at the centre of attention and shrinks and distorts surrounding information to simultaneously show a full view while providing the desired level of detail at the centre of focus.
Reference: [Price et al., 1993] <author> Price, B. A., Baecker, R. M., and Small, I. S. </author> <year> (1993). </year> <title> A Principled Taxonomy of Software Visualization. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 4 </volume> <pages> 211-266. </pages>
Reference-contexts: The increasing size and complexity of each new or updated taxonomy indicates the rapid growth in the field and the desire to explore new ways to achieve various goals. Unlike the previous taxonomies, Price et al. have developed a taxonomy with a principled derivation <ref> [Price et al., 1993] </ref>. They define the term Software Visualization (SV) as: ... the use of the crafts of typography, graphic design, animation, and cinematography with modern human-computer interaction technology to facilitate both the human understanding and effective use of computer software.
Reference: [Price et al., 1992] <author> Price, B. A., Small, I. S., and Baecker, R. M. </author> <year> (1992). </year> <title> A Taxonomy of Software Visualization. </title> <booktitle> In 25th Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 597-606. </pages> <publisher> IEEE Press. </publisher> <pages> 73 </pages>
Reference-contexts: Shu has also published a survey covering a number of systems [Shu, 1988]. Blaine Price, Ronald Baecker, and Ian Small wrote an extension of their earlier work to produce a newer, more comprehensive taxonomy <ref> [Price et al., 1992] </ref>. The increasing size and complexity of each new or updated taxonomy indicates the rapid growth in the field and the desire to explore new ways to achieve various goals.
Reference: [Sarkar and Brown, 1992] <author> Sarkar, M. and Brown, M. H. </author> <year> (1992). </year> <title> Graphical Fisheye Views of Graphs. </title> <booktitle> In ACM Conference on Human Factors in Computing Systems (CHI'91), </booktitle> <pages> pages 83-91. </pages>
Reference-contexts: One advantage of these displays is that the user always sees the global context around the focus area so less disorientation occurs <ref> [Furnas, 1986, Sarkar and Brown, 1992] </ref>.
Reference: [Sarkar et al., 1993] <author> Sarkar, M., Snibbe, S. S., Tversky, O. J., and Reiss, S. P. </author> <year> (1993). </year> <title> Stretching the Rubber Sheet: A Metaphor for Viewing Large Layouts on Small Screens. </title> <booktitle> In ACM SIGGRAPH User Interface Systems and Technology (UIST'93), </booktitle> <pages> pages 81-91. </pages>
Reference-contexts: One advantage of these displays is that the user always sees the global context around the focus area so less disorientation occurs [Furnas, 1986, Sarkar and Brown, 1992]. A related approach <ref> [Sarkar et al., 1993] </ref> uses the analogy of a sheet of rubber being stretched and provides more uniform scaling inside the stretched regions. 2.5.4 Animation principles to increase cognitive bandwidth The application of animation principles (anticipation, motion blurring, slow in/out, and follow through) in the visualization graphics enables a user to
Reference: [Shilling and Stasko, 1992] <author> Shilling, J. J. and Stasko, J. T. </author> <year> (1992). </year> <title> Using Animation to Design, Document and Trace Object Oriented Systems. </title> <type> Technical Report GIT-GVU-92-12, </type> <institution> Georgia Institute of Technology. </institution>
Reference-contexts: Therefore, this approach is useful in almost any system for software visualization. The Run-Time Landscape uses these animation techniques which will be discussed in Section 4.7. 2.5.5 Focusing attention on objects of interest The GROOVE system <ref> [Shilling and Stasko, 1992] </ref> has the ability to present an animation and to focus attention on a particular object. In this way, the visualization system filters out information so the user can easily study those interactions which affect the object being studied.
Reference: [Shu, 1988] <author> Shu, N. C. </author> <year> (1988). </year> <title> Visual Programming. </title> <publisher> van Nostrand Reinhold, </publisher> <address> New York, New York. </address>
Reference-contexts: An early survey was 10 11 included in the paper by Glinert and Tanimoto [Glinert and Tanimoto, 1984]. Shu has also published a survey covering a number of systems <ref> [Shu, 1988] </ref>. Blaine Price, Ronald Baecker, and Ian Small wrote an extension of their earlier work to produce a newer, more comprehensive taxonomy [Price et al., 1992].
Reference: [Stasko, 1990] <author> Stasko, J. T. </author> <year> (1990). </year> <title> Tango: A Framework and system for algorithm animation. </title> <journal> IEEE Computer, </journal> <volume> 23(9) </volume> <pages> 27-39. </pages>
Reference-contexts: Some of the successful systems developed include BALSA [Brown and Sedgewick, 1984], a pioneering work in interactive algorithm animation and its successor BALSA-II [Brown, 1988], Incense [Myers et al., 1983] and Amethyst [Myers et al., 1988] which create graphical displays of data automatically, TANGO <ref> [Stasko, 1990, Mukherjea and Stasko, 1993] </ref> which strives to make smooth algorithm animation easier, and the University of Washington Program Illustrator (UWPI) [Henry et al., 1990] which extracts high-level abstract data structures automatically. A number of people have written taxonomies categorizing these and other systems. <p> This annotation phase requires a person familiar with both the algorithm and the BALSA animation system. A labour and skills intensive process such as this can never scale to systems larger than toy examples. 14 2.3.3 PV Example: Tango and Lens Tango <ref> [Stasko, 1990] </ref> is a system for generating algorithm animations similar to BALSA but based on a formal framework. When combined with the Lens [Mukherjea and Stasko, 1993] system, manual annotation is performed with a graphical user interface and code does not need to be intruded upon. <p> A postmortem based debugging and visualization system was investigated using the Hy+ system [Consens and Mendelzon, 1993] for filtering information [Consens et al., 1993]. The Run-Time Landscape follows the example of systems like Amethyst [Myers et al., 1988] and TANGO <ref> [Stasko, 1990] </ref> in providing visualizations at run-time. 2.7 Summary This chapter presented background material on Software Visualization and described methods for extracting and displaying visualization information.
Reference: [Thomas and Johnston, 1981] <author> Thomas, F. and Johnston, O. </author> <year> (1981). </year> <title> Disney Animation: The illusion of Life. </title> <publisher> Abbeville Press, </publisher> <address> Ney York. </address>
Reference-contexts: Therefore, it becomes necessary to give the observer better cues to follow a rapid animation. Cartoon animators have practiced their art for many years. Animators employ anticipation, slow-in/slow-out, motion blurring, arcing, and follow through to present the observer with the illusion of fast motion <ref> [Thomas and Johnston, 1981] </ref>. Motion blurring is already used by stop motion computer animators in the film industry to create more realistic and convincing pictures of moving objects. <p> that even a simple version of blurred animation would reap most of the same benefits as complete implementations by providing enough information for the human observer to synthesize the illusion of motion. 4.7.2 Animation Phases Cartoon animators present the following phases to help viewers follow the action in an animation <ref> [Thomas and Johnston, 1981, Chang and Ungar, 1993] </ref>. Anticipation is a short movement opposite to the direction of travel. This brief cue signals the viewer that motion is going to take place. 54 Slow out is the acceleration phase of motion. The direction of motion becomes clear during this phase.
Reference: [Wills, 1990] <author> Wills, L. M. </author> <year> (1990). </year> <title> Automated Program Recognition: A Feasibility Demonstration. </title> <journal> Artificial Intelligence, </journal> <volume> 45 </volume> <pages> 113-171. </pages>
Reference-contexts: The time needed to annotate code makes this approach unworkable for large software systems. 2.5.2 Finding higher level abstractions Automated program recognition systems parse a program and try to match the code to known cliches to gain an understanding of the program <ref> [Letovsky, 1988, Wills, 1990, Lutz, 1992, Wills, 1992] </ref>. These systems are still in their infancy and only handle short lengths of code. However, it is conceivable that they will evolve to handle larger systems in the future.
Reference: [Wills, 1992] <author> Wills, L. M. </author> <year> (1992). </year> <title> Automated Program Recognition by Graph Parsing. </title> <type> Technical Report AI-TR 1358, </type> <institution> MIT Artificial Intelligence Laboratory. </institution>
Reference-contexts: The time needed to annotate code makes this approach unworkable for large software systems. 2.5.2 Finding higher level abstractions Automated program recognition systems parse a program and try to match the code to known cliches to gain an understanding of the program <ref> [Letovsky, 1988, Wills, 1990, Lutz, 1992, Wills, 1992] </ref>. These systems are still in their infancy and only handle short lengths of code. However, it is conceivable that they will evolve to handle larger systems in the future.
References-found: 56

