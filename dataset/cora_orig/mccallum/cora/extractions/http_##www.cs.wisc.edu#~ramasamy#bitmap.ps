URL: http://www.cs.wisc.edu/~ramasamy/bitmap.ps
Refering-URL: http://www.cs.wisc.edu/~pmd/olapreferences.html
Root-URL: http://www.cs.wisc.edu
Email: poneil@cs.umb.edu  quass@db.stanford.edu  
Title: -1- Improved Query Performance with Variant Indexes  
Author: Patrick O'Neil UMass/Boston Dallan Quass 
Address: University  
Affiliation: Stanford  
Abstract: The read-mostly environment of data warehousing makes it possible to use more complex indexes to speed up queries than in situations where concurrent updates are present. The current paper presents a short review of current indexing technology, including rowset representation by Bitmaps, and then introduces two approaches we call BitSliced indexing and Projection indexing. A Projection index basically materializes all values of a column in RID order, and a BitSliced index essentially takes an orthogonal bit-by-bit view of the same data. While some of these concepts started with the MODEL 204 product, and both BitSliced and Projection indexing are now fully realized in Sybase IQ, this is the first rigorous examination of such indexing capabilities in the literature. We compare algorithms that become feasible with these variant index types against algorithms using more conventional indexes. The analysis demonstrates important performance advantages for variant indexes in some types of SQL aggregation, predicate evaluation, and grouping. The paper concludes by introducing a new method whereby multidimensional Group By queries, reminiscent of OLAP or Datacube queries but with more flexibility, can be very efficiently performed. 
Abstract-found: 1
Intro-found: 1
Reference: [COMER] <author> Comer, D. </author> <title> The Ubiquitous B-tree. </title> <journal> Comput. Surv. </journal> <volume> 11 (1979), </volume> <pages> pp. 121-137. </pages>
Reference-contexts: We then explain Projection and BitSliced indexes. 2.1 Traditional Value-List Indexes Database indexes provided today by most database systems use B + tree 1 structures to retrieve rows of a table with specified values involving one or more indexed columns (see <ref> [COMER] </ref>). The leaf level of the B-tree index consists of a sequence of entries for index keyvalues. Each keyvalue reflects the value of the indexed column or columns in one or more rows in the table, and each keyvalue entry references the set of rows with that value.
Reference: [EDEL95] <author> Herb Edelstein. </author> <title> Faster Data Warehouses. </title> <booktitle> Information Week, </booktitle> <month> Dec. 4, </month> <year> 1995, </year> <pages> pp. 77-88. </pages> <note> Give title and author on http://www.techweb.com/search/advsearch.html. </note>
Reference-contexts: Indeed, the Sybase IQ data warehousing product currently provides both of these variant index types <ref> [EDEL95, FREN95] </ref>, and recommends more than one index for a column in some cases. This paper represents the first time of which the authors are aware that these index structures have been examined and their differences analyzed rigorously in the database literature. <p> Thus reading the values from a Projection index requires only 1/20 the number of page access as reading the values from the rows. The Sybase IQ product is the first one to have utilized the Projection index heavily, under the name of "Fast Projection Index" <ref> [EDEL95, FREN95] </ref>. Note that the definition of the Projection index is reminiscent of the approach of vertically partitioning the columns of a table. Vertical partitioning is a good strategy for workloads where small numbers of columns are retrieved by most Select statements. <p> We give an example below that generalizes the BitSliced algorithm to an octal representation. Sybase IQ was the first product to demonstrate in practice that the same BitSliced index, called the "High NonGroup Index" <ref> [EDEL95] </ref>, could be used both for evaluating range predicates and performing Aggregates. Definition 4.1. BitSliced Indexes with a nonbinary base. We denote the representation of the column value C or the constant c1 by O K O K-1 . . .
Reference: [FREN95] <author> Clark D. </author> <title> French. "One Size Fits All" Database Architectures Do Not Work for DSS. </title> <booktitle> Proceedings of the 1995 ACM SIGMOD Conference, </booktitle> <pages> pp. 449-450. </pages>
Reference-contexts: Indeed, the Sybase IQ data warehousing product currently provides both of these variant index types <ref> [EDEL95, FREN95] </ref>, and recommends more than one index for a column in some cases. This paper represents the first time of which the authors are aware that these index structures have been examined and their differences analyzed rigorously in the database literature. <p> Thus reading the values from a Projection index requires only 1/20 the number of page access as reading the values from the rows. The Sybase IQ product is the first one to have utilized the Projection index heavily, under the name of "Fast Projection Index" <ref> [EDEL95, FREN95] </ref>. Note that the definition of the Projection index is reminiscent of the approach of vertically partitioning the columns of a table. Vertical partitioning is a good strategy for workloads where small numbers of columns are retrieved by most Select statements.
Reference: [GBLP96] <author> Jim Gray, Adam Bosworth, Andrew Layman, and Hamid Pirahesh. </author> <title> Data Cube: A Relational Operator Generalizing Group-By, </title> <booktitle> Cross-Tab, and SubTotals. Proceedings of the 12th International Conference on Data Engineering, </booktitle> <pages> pp. 152-159, </pages> <year> 1996. </year>
Reference-contexts: This approach of materializing needed aggregates is possible only when the expected set of queries is known in advance. Specifically, the OLAP approach addresses queries that group by different combinations of columns, known as dimensions. Such queries are called Datacube queries in <ref> [GBLP96] </ref>. But when ad-hoc queries must be issued that filter the rows by selection criteria that are not part of the dimensional scheme, summary tables that do not foresee such filtering cannot be used. In these cases the queries must be evaluated by accessing other indexes on the base data. <p> is a column for which we might create a Projection index, Value-List index, or BitSliced index, and AGG is an aggregate function, such as COUNT, MAX, MIN, etc. [3.2] SELECT AGG (C) FROM T WHERE condition; -12--In what follows, we usually consider only aggregate functions that are "Distributive" or "Algebraic" <ref> [GBLP96] </ref>. A Distributive function is a function that can be applied to subsets of the input and the results combined to compute the answer for the entire set. The aggregate functions COUNT, SUM, MIN, and MAX are distributive aggregate functions. Algebraic functions are evaluable using other distributive functions. <p> Algebraic functions are evaluable using other distributive functions. The function AVG (= SUM/COUNT) is an algebraic aggregate function. The MEDIAN function is neither distributive nor algebraic because it requires all values in the input simultaneously, and it is called Holistic in <ref> [GBLP96] </ref>. As we will see, the three index types have different capabilities in evaluating the different aggregate functions. Table 3.5 lists a group of aggregate functions and the index types with which we can evaluate these functions. <p> Evaluating OLAP-style Queries dimension tables known as TIME (when the sales are made), PRODUCT (product sold), and CUSTOMER (purchaser in the sale). Most OLAP products do not express their queries in SQL, but much of the work of typical queries could be represented in SQL <ref> [GBLP96] </ref> (although more than one query might be needed). -17- CUSTOMER Dimension SALES Fact PRODUCT Dimension cid gender city state zip hobby week month year holiday_flg weekday_flg pid dollar_sales dollar_cost unit_sales SKU brand size weight package_type TIME Dimension Query 5.1 retrieve total dollar sales that were made for a brand of
Reference: [GP87] <author> Jim Gray and Franco Putzolu. </author> <title> The Five Minute Rule for Trading Memory for Disk Accesses and The 10 Byte Rule for Trading Memory for CPU Time. </title> <booktitle> Proceedings of the 1987 ACM SIGMOD Conference, </booktitle> <pages> pp. 395-398. </pages>
Reference-contexts: Costs of four plans, I/O and factors contributing to CPU We can compare the four query plans in terms of total dollar cost by converting I/O and CPU costs to dollar amounts, as in <ref> [GP87] </ref>. In 1996, a 2 GB hard disk with a 10 ms access time costs roughly $600. With the I/O rate we have been assuming, this is approximately $6.00 per I/O per second.
Reference: [HRU96] <author> Venky Harinarayan, Anand Rajaraman, and Jeffrey D. Ullman. </author> <title> Implementing Data Cubes Efficiently. </title> <booktitle> Proceedings of the 1996 ACM SIGMOD Conference, </booktitle> <pages> pp. 205-216. </pages>
Reference-contexts: The higher the dimensional levels, the fewer elements that will be in the summary table, but there are a lot of possible combinations of hierarchies. Luckily, we don't need to create all possible summary tables in order to speed up the queries a great deal. For more details, see <ref> [STG95, HRU96] </ref>. By doing the aggregation work beforehand, summary tables provide quick response to queries, so long as any selection conditions are restrictions on the dimensions that have been foreseen in advance.
Reference: [INF96] <editor> INFORMIX-OnLine Extended Parallel Server: </editor> <title> A New Generation of Decision Support Indexing. </title> <type> Informix White Paper, </type> <year> 1996. </year>
Reference-contexts: physical design of the table is unaffected, but the new index allows the SQL query optimizer to perform one of the algorithms described in Section 3.1 or 3.2, depending upon whether the index created was Value-List, BitSliced, or Projection. (Virtual Value-List indexes can be defined now using Informix DSS Indexes <ref> [INF96] </ref>.) Naturally, we cannot foresee all possible functional aggregate needs, but there are often several functions which occur often enough in a query workload to justify a Virtual Column index. The need in TPC-D to calculate SUM (L_EXTENDEDPRICE*(1-L_DISCOUNT)) is such a case.
Reference: [KIMB96] <author> Ralph Kimball. </author> <title> The Data Warehouse Toolkit. </title> <publisher> John Wiley & Sons, </publisher> <year> 1996. </year>
Reference-contexts: Assume that we are given a star-join schema, consisting of a central fact table Sales, containing sales data, and dimension tables known as Stores (where the sales are made), Time (when the -2--sales are made), Product (involved in the sales), and Promotion (method of promotion being used). (See <ref> [KIMB96] </ref>, Chapter 2, for a detailed explanation of this schema. A comparable Star schema is pictured in as the total dollar sales that were made for a brand of products in a store on the East coast during the past 4 weeks with a sales promotion based on price reduction.
Reference: [M204] <institution> MODEL 204 File Manager's Guide, </institution> <note> Version 2, Release 1.0, </note> <month> April </month> <year> 1989, </year> <institution> Computer Corporation of America. -23- </institution>
Reference-contexts: Corresponding to these Fragments, the rows of a table are partitioned into Segments, with an equal number of ordinal numbered rows for each segment, corresponding to a Bitmap Fragment. For example, in MODEL 204 (see <ref> [M204] </ref>, [O'NEI87]), a Bitmap Fragment is expected to fit on a 6 KByte page, and contains about 48K bits. The table is therefore broken into segments of about 48K rows each. This segmentation has two important implications. The first implication involves RID-lists. <p> Performance of Range Evaluation by Index Type 4.2 Range Predicate Using a BitSliced Index with a NonBinary Base For many years, MODEL 204 has used a form of indexing to evaluate range predicates known as "Numeric Range" <ref> [M204] </ref>. Numeric Range performs range evaluation similar to the BitSliced Algorithm 4.2, except that numeric quantities were expressed in a larger base (base 10). It turns out that the effort of performing a range retrieval can be reduced if we are willing to store a larger number of Bitmaps.
Reference: [O'NEI87] <author> Patrick O'Neil. </author> <title> Model 204 Architecture and Performance. </title> <booktitle> Springer-Verlag Lecture Notes in Computer Science 359, 2nd International Workshop on High Performance Transactions Systems (HPTS), Asilomar, </booktitle> <address> CA, </address> <year> 1987, </year> <pages> pp. 40-59. </pages>
Reference-contexts: with a small number of keyvalues can be approximated as 4 times the number of rows in the table. 2.1.1 Bitmap Indexes Bitmap indexes were first developed for database use in the Model 204 product from Computer Corporation of America (this product has been in use since the 1960s, see <ref> [O'NEI87] </ref>). A Bitmap is an alternate method of representing RID-lists in a Value-List index. Bitmaps are more space-efficient than RID-lists when the number of keyvalues for the index is low. <p> Corresponding to these Fragments, the rows of a table are partitioned into Segments, with an equal number of ordinal numbered rows for each segment, corresponding to a Bitmap Fragment. For example, in MODEL 204 (see [M204], <ref> [O'NEI87] </ref>), a Bitmap Fragment is expected to fit on a 6 KByte page, and contains about 48K bits. The table is therefore broken into segments of about 48K rows each. This segmentation has two important implications. The first implication involves RID-lists. <p> Such an eventuality is considered unlikely in business applications, however. A user-defined method to bitslice aggregate quantities was used by some MODEL 204 users and is defined on page 48 of <ref> [O'NEI87] </ref>. Sybase IQ currently provides a fully realized BitSliced index, which is known to the query optimizer and transparent to SQL users. <p> Indeed, as explained in <ref> [O'NEI87] </ref>, the entry in the B-tree leaf level for a column C that references an all-zeros Bitmap Segment can be flagged (or simply missing), and a reasonable algorithm to AND Bitmaps will test this before accessing any Segment Bitmap pages.
Reference: [O'NEI91] <editor> Patrick O'Neil The Set Query Benchmark. </editor> <title> The Benchmark Handbook for Database and Transaction Processing Systems, </title> <editor> Jim Gray (Editor), </editor> <publisher> Morgan Kaufmann, </publisher> <address> 2nd Edition, </address> <year> 1993, </year> <pages> pp. 359-395. </pages>
Reference-contexts: Example 2.1. In the Set Query benchmark of <ref> [O'NEI91] </ref>, the measurement results from one of the SQL statements in Query Suite Q5 give a good illustration of Bitmap performance.
Reference: [O'NEI96] <author> Patrick O'Neil. </author> <title> Database: Principles, Programming, and Performance. </title> <publisher> Morgan Kaufmann, 3rd corrected printing, </publisher> <year> 1996. </year>
Reference-contexts: For example, MVS DB2 provides this kind of compression, listing one 1 B + trees are commonly referred to simply as B-trees in database documentation, and we will follow this convention. -3--keyvalue for a Fragment of up to 255 4-byte RIDs in sequence (see <ref> [O'NEI96] </ref>, Figure 7.19). Keyvalues with more than 255 associated rows require multiple Fragments of this kind, and some RID-lists are too long to materialize in memory all at once. We assume in what follows that RID-lists (and Bitmaps, which follow) are read from disk in multiples of Fragments. <p> DB2 Version 2.3, running on an IBM 9221 model 170 mainframe used an algorithm that extracted and wrote out all pairs of (K10, K25) values from the rows, sorted by value pair, and counted the result in groups, taking 248 seconds of elapsed time and 223 seconds of CPU. (See <ref> [O'NEI96] </ref> for more details.)u 2.1.3 Segmentation To optimize Bitmap index access, Bitmaps are usually broken into Fragments of equal sizes which fit on single fixed-size disk pages. <p> Since 2,000,000 rows in the Foundset B f represent only 1/50 of all rows in the SALES table, the number of disk pages that the Foundset occupies can be estimated (see <ref> [O'NEI96] </ref>, Formula [7.6.4]) as: 5 ,000,000 (1 - e -2,000,000/5,000,000 ) = 1,648,400 disk pages The time to perform such a sequence of I/Os, assuming one disk arm retrieves 100 disk pages per second in relatively close sequence on disk, is 16,484 seconds, or more than 4 hours of disk arm
Reference: [O'NGG95] <author> Patrick O'Neil and Goetz Graefe. </author> <title> Multi-Table Joins Through Bitmapped Join Indices. </title> <booktitle> SIGMOD Record, </booktitle> <month> September, </month> <year> 1995, </year> <pages> pp. 8-11. </pages>
Reference-contexts: There will be a "combinatorial explosion" of Join Indexes in terms of the number of useful columns. The Bitmap join index, defined in <ref> [O'NGG95] </ref>, addresses this problem. In its simplest form, this is an index on a table T based on a single column of a table S, where S commonly joins with T in a specified way.
Reference: [PH96] <author> David A. Patterson and John L. Hennessy. </author> <title> Computer Architecture, A Quantitative Approach. </title> <publisher> Morgan Kaufmann, </publisher> <address> 2nd Edition, </address> <year> 1996. </year>
Reference-contexts: Each disk page I/O is generally assumed to require several thousand instructions to perform (see, for example, <ref> [PH96] </ref>, the second example in Section 6.7, where 10,000 instructions are assumed). -9--Query Plan 2: Calculating the SUM through a Projection index.
Reference: [STG95] <author> Stanford Technology Group, Inc., </author> <title> An INFORMIX Company. Designing the Data Warehouse on Relational Databases. </title> <type> Informix White Paper, </type> <year> 1995, </year> <note> http://www.informix.com. </note>
Reference-contexts: The higher the dimensional levels, the fewer elements that will be in the summary table, but there are a lot of possible combinations of hierarchies. Luckily, we don't need to create all possible summary tables in order to speed up the queries a great deal. For more details, see <ref> [STG95, HRU96] </ref>. By doing the aggregation work beforehand, summary tables provide quick response to queries, so long as any selection conditions are restrictions on the dimensions that have been foreseen in advance.
Reference: [TPC] <author> TPC Home Page. </author> <title> Descriptions and results of TPC benchmarks, including the TPC-C and TPC-D benchmarks. </title> <address> http://www.tpc.org. </address>
Reference: [VALD87] <author> Patrick Valduriez. </author> <title> Join Indices. </title> <journal> ACM TODS, </journal> <volume> Vol. 12, No. 2, </volume> <month> June </month> <year> 1987, </year> <pages> Pages 218-246. </pages> <month> -24- </month>
References-found: 17

