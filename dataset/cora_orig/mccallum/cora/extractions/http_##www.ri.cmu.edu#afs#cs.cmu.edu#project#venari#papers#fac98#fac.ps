URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/venari/papers/fac98/fac.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/venari/www/fac98.html
Root-URL: 
Phone: 2  
Title: Formal Aspects of  Protective Interface Specifications  
Author: Gary T. Leavens and Jeannette M. Wing 
Address: Ames, IA 50011 USA  Pittsburgh, PA 15213 USA  
Affiliation: 1 Department of Computer Science, Iowa State University,  Computer Science Department, Carnegie Mellon University,  
Note: c  
Date: (1998) 3: 1-000  1998 BCS  
Pubnum: Computing  
Abstract: The interface specification of a procedure describes the procedure's behavior using pre- and postconditions. These pre- and postconditions are written using various functions. If some of these functions are partial, or underspec-ified, then the procedure specification may not be well-defined. We show how to write pre- and postcondition specifications that avoid such problems, by having the precondition "protect" the postcondition from the effects of partiality and underspecification. We formalize the notion of protection from partiality in the context of specification languages like VDM-SL and COLD-K. We also formalize the notion of protection from underspecification for the Larch family of specification languages, and for Larch show how one can prove that a procedure specification is protected from the effects of underspecification. 
Abstract-found: 1
Intro-found: 1
Reference: [A + 93] <author> D.J. Andrews et al. </author> <title> Information technology programming languages | VDM-SL: First committee draft standard CD1387-1. Document ISO/IEC JTC1/SC22/WG19 N-20, </title> <booktitle> International Standards Organization, </booktitle> <month> November </month> <year> 1993. </year> <month> ftp://gatekeeper.dec.com/pub/standards/vdmsl/. </month>
Reference-contexts: For example, VDM-SL <ref> [Jon90, A + 93] </ref> uses a logic called LPF [Jon90, Section 3.3] [BCJ84, BFL + 94, JM94], which has three logical values and two kinds of equality. 4 As another example, the specification language COLD-K [FJ92] uses a logic having just two logical values, but in which all other types have
Reference: [BCJ84] <author> H. Barringer, J. H. Cheng, and C. B. Jones. </author> <title> A logic covering undefinedness in program proofs. </title> <journal> Acta Informatica, </journal> <volume> 21(3) </volume> <pages> 251-269, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: For example, VDM-SL [Jon90, A + 93] uses a logic called LPF [Jon90, Section 3.3] <ref> [BCJ84, BFL + 94, JM94] </ref>, which has three logical values and two kinds of equality. 4 As another example, the specification language COLD-K [FJ92] uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions,
Reference: [BFL + 94] <author> Juan Bicarregui, John S. Fitgerald, Peter A. Lindsay, Richard Moore, and Brian Ritchie. </author> <title> Proof in VDM: A Practitioner's Guide. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1994. </year> <note> 16 G.T. Leavens and J.M. Wing </note>
Reference-contexts: For example, VDM-SL [Jon90, A + 93] uses a logic called LPF [Jon90, Section 3.3] <ref> [BCJ84, BFL + 94, JM94] </ref>, which has three logical values and two kinds of equality. 4 As another example, the specification language COLD-K [FJ92] uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions,
Reference: [Bij90] <author> A. Bijlsma. </author> <title> Semantics of quasi-boolean expressions. </title> <editor> In W. H. J. Feijen et al., editors, </editor> <booktitle> Beauty is Our Business, </booktitle> <pages> pages 27-35. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: All other values are proper. In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [Bij90, Bli91, SKT95, KTB91, WDC + 95] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses under-specification. In such a logic, one avoids specifying a value for undefined terms [GS95, Jon95].
Reference: [Bli81] <author> Andrzej Blikle. </author> <title> The clean termination of iterative programs. </title> <journal> Acta Informatica, </journal> <volume> 16 </volume> <pages> 199-217, </pages> <year> 1981. </year>
Reference-contexts: Exact Predicates For use in proving protection, we define predicates of the form Exact (`E'), based on the form (i.e., the text) of each expression E. These resemble the domain predicates, Dom (`E'), described by some authors <ref> [Ger78, CH79, Bli81] </ref>. However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial.
Reference: [Bli91] <author> A. Blikle. </author> <title> Three-valued predicates for software specification and validation. </title> <journal> Fun-damenta Informaticae, </journal> <volume> XIV:387-410, </volume> <year> 1991. </year>
Reference-contexts: All other values are proper. In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [Bij90, Bli91, SKT95, KTB91, WDC + 95] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses under-specification. In such a logic, one avoids specifying a value for undefined terms [GS95, Jon95].
Reference: [BW82] <author> Manfred Broy and Martin Wirsing. </author> <title> Partial abstract types. </title> <journal> Acta Informatica, </journal> <volume> 18(1) </volume> <pages> 47-64, </pages> <month> November </month> <year> 1982. </year>
Reference-contexts: However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial. They also resemble the definedness predicate (D) used in studies of partial algebras <ref> [BW82] </ref> and in COLD [FJ92]; however D is defined model-theoretically, not syntactically. The definition of Exact (`') is based on the exact clauses given in the trait's implications and those of included traits.
Reference: [CH79] <author> D. Coleman and J. W. Hughes. </author> <title> The clean termination of Pascal programs. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 195-210, </pages> <year> 1979. </year>
Reference-contexts: Exact Predicates For use in proving protection, we define predicates of the form Exact (`E'), based on the form (i.e., the text) of each expression E. These resemble the domain predicates, Dom (`E'), described by some authors <ref> [Ger78, CH79, Bli81] </ref>. However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial.
Reference: [CJ90] <author> J. H. Cheng and C. B. Jones. </author> <title> On the usability of logics which handle partial functions. </title> <editor> In C. Morgan and J. C. P. Woodcock, editors, </editor> <booktitle> Proceedings of the Third Refinement Workshop, Workshops in Computing Series, </booktitle> <pages> pages 51-69, </pages> <address> Berlin, 1990. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In this paper we consider what protection means with respect to partiality and underspecification. Our treatment of protection is not meant to be exhaustive, but merely to illustrate concepts that are useful with some logics that are widely used for formal specification. (See <ref> [CJ90, GS95] </ref> for surveys that also cover additional kinds of logics that might be used in formal specification, and hence might need their own concepts of protection.
Reference: [FJ92] <author> L. M. G. Feijs and H. B. M. Jonkers. </author> <title> Formal Specification and Design, </title> <booktitle> volume 35 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1992. </year>
Reference-contexts: For example, VDM-SL [Jon90, A + 93] uses a logic called LPF [Jon90, Section 3.3] [BCJ84, BFL + 94, JM94], which has three logical values and two kinds of equality. 4 As another example, the specification language COLD-K <ref> [FJ92] </ref> uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions, and also models computations that go into infinite loops or cause errors. All other values are proper. <p> However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial. They also resemble the definedness predicate (D) used in studies of partial algebras [BW82] and in COLD <ref> [FJ92] </ref>; however D is defined model-theoretically, not syntactically. The definition of Exact (`') is based on the exact clauses given in the trait's implications and those of included traits.
Reference: [GCD + 95] <author> M. Gogolla, S. Conrad, G. Denker, R. Herzig, N. Vlachantonis, and H. Ehrig. </author> <title> TROLL light | the language and its development environment. </title> <editor> In Manfred Broy and Stefan Jahnichen, editors, KORSO: </editor> <booktitle> Methods, Languages and Tools for the Construction of Correct Software, volume 1009 of Lecture Notes in Computer Science, </booktitle> <pages> pages 205-220. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: In addition, we ensure that the precondition protects itself. 2.1. Partiality Protection In a specification language like VDM-SL, COLD-K, or TROLL light <ref> [GCD + 95] </ref>, the notion of a procedure specification that protects against partiality is relatively straightforward.
Reference: [Ger78] <author> Steven M. </author> <title> German. Automating proofs of the absence of common runtime errors. </title> <booktitle> In Conference record of the Fifth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 105-118. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1978. </year>
Reference-contexts: Exact Predicates For use in proving protection, we define predicates of the form Exact (`E'), based on the form (i.e., the text) of each expression E. These resemble the domain predicates, Dom (`E'), described by some authors <ref> [Ger78, CH79, Bli81] </ref>. However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial.
Reference: [GGH90] <author> Stephen J. Garland, John V. Guttag, and James J. Horning. </author> <title> Debugging Larch Shared Language specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(6) </volume> <pages> 1044-1057, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The concept of an exact term is based on an extension to LSL that allows one to specify which terms are not intended to be underspecified. This extension to LSL provides better documentation and allows enhanced debugging (in the sense of <ref> [GGH90] </ref> [GHG + 93, Chapter 7]) of LSL specifications. 5. Summary and Conclusions In this paper we have given two definitions that are instances of the concept of protection. <p> In an LSL trait, one can state redundant properties (theorems) that one believes do (or should) hold. These redundant properties are stated in the implies section of the specification. Proofs of such properties can be attempted, and are a way of debugging the trait <ref> [GGH90] </ref> [GHG + 93, Chapter 7]. For our purposes, the most interesting kind of redundant property one can state in the implies section is that an operator is well-defined with respect to other operators.
Reference: [GHG + 93] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove anything about such a term. This kind of logic is used in the Larch Shared Language, LSL <ref> [GHG + 93, Chapter 4] </ref> [GHM90], which is the mathematical component of the Larch family BISLs [GHG + 93], in the BISLs of the RESOLVE family [OSWZ94], and in Z [Hay93, Spi92] (according to its draft standard [WJ96]). <p> This kind of logic is used in the Larch Shared Language, LSL [GHG + 93, Chapter 4] [GHM90], which is the mathematical component of the Larch family BISLs <ref> [GHG + 93] </ref>, in the BISLs of the RESOLVE family [OSWZ94], and in Z [Hay93, Spi92] (according to its draft standard [WJ96]). <p> First we define the notion of a primed LSL trait and primed LSL term. (A LSL trait is a specification of mathematical vocabulary in an augmented form of first-order logic with equality <ref> [GHG + 93, Chapter 4] </ref>.) That notion is used to describe a notion of a "completely-defined" term. An LSL term is completely-defined if it can be proved to have the same value in all models of its trait. <p> Finally we define the notion of underspec-protection itself. The notion of a primed trait and term is a variation of the idea of "priming" traits and terms found in the Larch Prover (where it is used in proving that an operator is "converted" <ref> [GHG + 93, pp. 142-4] </ref>). Definition 2.2. (Primed Trait, T 0 ) Let T be an LSL trait. <p> The trait factTrait 0 has fact replaced by fact 0 , but true and the boolean operators are not primed, and neither are 0, pred, and succ, because they are mentioned in the generated by clause of the trait Integer <ref> [GHG + 93, p. 161] </ref>. Operators mentioned in a generated by clause are meant to give a way to produce all values of a given sort; priming these would add "junk" to the specification. <p> A more interesting example is that, for factTrait, the term fact (27) is completely-defined, but both fact (-1) and fact (x), where x:Int, are not. As another example, consider the trait ChoiceSet <ref> [GHG + 93, p. 176] </ref> where the operator choose is specified as follows. b 6= - ) choose (b) 2 b For this trait, the term choose (f1g [ f2g) is not completely-defined. <p> This is done by using a converts clause. A converts clause says that the axioms of the trait uniquely define the operators named in the clause, "relative to the other operators in the trait" <ref> [GHG + 93, p. 142] </ref>. (We include in Appendix B a more detailed explanation of conversion for the sake of completeness.) However, proving that an LSL operator is converted does not mean it is completely-defined; it may still be underspecified. For example, consider the trait in Figure 8. <p> The concept of an exact term is based on an extension to LSL that allows one to specify which terms are not intended to be underspecified. This extension to LSL provides better documentation and allows enhanced debugging (in the sense of [GGH90] <ref> [GHG + 93, Chapter 7] </ref>) of LSL specifications. 5. Summary and Conclusions In this paper we have given two definitions that are instances of the concept of protection. <p> For example, the operator that returns the head of a list can be modeled as a partial function on lists; if that is done, then head (empty) fails to denote an element. (That is, head (empty) is "undefined.") The logic used by the Larch Shared Language (LSL) <ref> [GHG + 93, Chapter 4] </ref> [GHM90] deals with partiality by using underspecification. As noted in the main body, this means that one avoids specifying a value for undefined terms, but the logic assumes that all functions are total. <p> In an LSL trait, one can state redundant properties (theorems) that one believes do (or should) hold. These redundant properties are stated in the implies section of the specification. Proofs of such properties can be attempted, and are a way of debugging the trait [GGH90] <ref> [GHG + 93, Chapter 7] </ref>. For our purposes, the most interesting kind of redundant property one can state in the implies section is that an operator is well-defined with respect to other operators. <p> This is done by using a converts clause, as was done in the operators named in the clause, "relative to the other operators in the trait" <ref> [GHG + 93, p. 142] </ref>. To prove this, one must show it for all possible arguments. The Larch Prover (LP) uses the following proof technique [GHG + 93, pp. 142-4]. <p> To prove this, one must show it for all possible arguments. The Larch Prover (LP) uses the following proof technique <ref> [GHG + 93, pp. 142-4] </ref>. Let T ( ~ f ) be a trait, which names operators ~ f in converts clauses in its implies section.
Reference: [GHM90] <author> John V. Guttag, James J. Horning, and Andres Modet. </author> <title> Report on the Larch Shared Language: Version 2.3. </title> <type> Technical Report 58, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> April </month> <year> 1990. </year> <title> Order from src-report@src.dec.com. </title>
Reference-contexts: In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove anything about such a term. This kind of logic is used in the Larch Shared Language, LSL [GHG + 93, Chapter 4] <ref> [GHM90] </ref>, which is the mathematical component of the Larch family BISLs [GHG + 93], in the BISLs of the RESOLVE family [OSWZ94], and in Z [Hay93, Spi92] (according to its draft standard [WJ96]). <p> the operator that returns the head of a list can be modeled as a partial function on lists; if that is done, then head (empty) fails to denote an element. (That is, head (empty) is "undefined.") The logic used by the Larch Shared Language (LSL) [GHG + 93, Chapter 4] <ref> [GHM90] </ref> deals with partiality by using underspecification. As noted in the main body, this means that one avoids specifying a value for undefined terms, but the logic assumes that all functions are total.
Reference: [GS95] <author> David Gries and Fred B. Schneider. </author> <title> Avoiding the undefined by underspecification. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Computer Science Today: Recent Trends and Developments, number 1000 in Lecture Notes in Computer Science, </booktitle> <pages> pages 366-373. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: In this paper we consider what protection means with respect to partiality and underspecification. Our treatment of protection is not meant to be exhaustive, but merely to illustrate concepts that are useful with some logics that are widely used for formal specification. (See <ref> [CJ90, GS95] </ref> for surveys that also cover additional kinds of logics that might be used in formal specification, and hence might need their own concepts of protection. <p> The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses under-specification. In such a logic, one avoids specifying a value for undefined terms <ref> [GS95, Jon95] </ref>. In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove anything about such a term. <p> For example, head (empty) denotes some element of the appropriate type, even if the user has not specified what element that term denotes. Where an LSL specification is silent, terms take on some (unspecified) value. In common with other logics that use underspecification to avoid the undefined <ref> [GS95] </ref>, the logic of LSL is classical, and thus has several pleasing formal properties. However, as Jones pointed out in a recent paper [Jon95], there are a few subtle aspects to this kind of logic that users should be aware of. <p> For example, one can write factTrait as in Figure 6, where the equation for the recursive case is only postulated to hold for its intended domain <ref> [GS95] </ref>. By writing factTrait in that way, one avoids postulating Equation (9); that is, nothing at all is specified about the value of fact (-1). Protective Interface Specifications 15 B. Appendix: Conversion in LSL This appendix explains the notion of conversion in LSL.
Reference: [Hay93] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: This kind of logic is used in the Larch Shared Language, LSL [GHG + 93, Chapter 4] [GHM90], which is the mathematical component of the Larch family BISLs [GHG + 93], in the BISLs of the RESOLVE family [OSWZ94], and in Z <ref> [Hay93, Spi92] </ref> (according to its draft standard [WJ96]). The subtle problems that underspecification may cause for the unwary in LSL (and similar logics) are discussed in Appendix A; indeed Jones's paper pointing out these problems [Jon95] motivated the present work.
Reference: [JM94] <author> Cliff B. Jones and Kees Middelburg. </author> <title> A typed logic of partial functions reconstructed classically. </title> <journal> Acta Informatica, </journal> <volume> 31(5) </volume> <pages> 399-430, </pages> <year> 1994. </year>
Reference-contexts: For example, VDM-SL [Jon90, A + 93] uses a logic called LPF [Jon90, Section 3.3] <ref> [BCJ84, BFL + 94, JM94] </ref>, which has three logical values and two kinds of equality. 4 As another example, the specification language COLD-K [FJ92] uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions,
Reference: [Jon90] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: For example, VDM-SL <ref> [Jon90, A + 93] </ref> uses a logic called LPF [Jon90, Section 3.3] [BCJ84, BFL + 94, JM94], which has three logical values and two kinds of equality. 4 As another example, the specification language COLD-K [FJ92] uses a logic having just two logical values, but in which all other types have <p> For example, VDM-SL [Jon90, A + 93] uses a logic called LPF <ref> [Jon90, Section 3.3] </ref> [BCJ84, BFL + 94, JM94], which has three logical values and two kinds of equality. 4 As another example, the specification language COLD-K [FJ92] uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results
Reference: [Jon95] <author> C.B. Jones. </author> <title> Partial functions and logics: A warning. </title> <journal> Information Processing Letters, </journal> <volume> 54(2) </volume> <pages> 65-67, </pages> <year> 1995. </year>
Reference-contexts: The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses under-specification. In such a logic, one avoids specifying a value for undefined terms <ref> [GS95, Jon95] </ref>. In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove anything about such a term. <p> The subtle problems that underspecification may cause for the unwary in LSL (and similar logics) are discussed in Appendix A; indeed Jones's paper pointing out these problems <ref> [Jon95] </ref> motivated the present work. It is not the purpose of this paper to advocate one kind of logic over another. Some logic that deals with partiality is needed to verify client code and implementations, because of the partiality that is common in pre- and postconditions. <p> Where an LSL specification is silent, terms take on some (unspecified) value. In common with other logics that use underspecification to avoid the undefined [GS95], the logic of LSL is classical, and thus has several pleasing formal properties. However, as Jones pointed out in a recent paper <ref> [Jon95] </ref>, there are a few subtle aspects to this kind of logic that users should be aware of. We translate Jones's first example into the LSL trait shown in Figure 14. This trait defines a sort, OneElem, a constant it, and a function f. <p> This trait defines a sort, OneElem, a constant it, and a function f. Because of the generated by clause, the sort OneElem has only one element, the constant it. (The current version of LSL allows such sorts, contrary to <ref> [Jon95] </ref>.) In LSL f (-1) = it, because f has to take on some value when applied to -1, and the only possible value is it.
Reference: [KTB91] <author> B. Konikowska, A. Tarlecki, and A. Blikle. </author> <title> A three-valued logic for software specification and validation. </title> <note> Fundamenta Informaticae, XIV:411-453, </note> <year> 1991. </year>
Reference-contexts: All other values are proper. In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [Bij90, Bli91, SKT95, KTB91, WDC + 95] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses under-specification. In such a logic, one avoids specifying a value for undefined terms [GS95, Jon95].
Reference: [Lea97] <author> Gary T. Leavens. </author> <note> Larch/C++ Reference Manual. Version 5.10. Available in ftp://ftp.cs.iastate.edu/pub/larchc++/lcpp.ps.gz or on the World Wide Web at the URL http://www.cs.iastate.edu/~leavens/larchc++.html, August 1997. </note>
Reference-contexts: The pre- and postconditions follow requires and ensures, respectively; when the precondition is satisfied, the procedure must terminate in a state that satisfies the postcondition. (The keyword informally in Larch/C++ <ref> [Lea97] </ref> signals the start of an informal predicate.) This specification is ill-defined, because it is not clear what the procedure should return when x is negative.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: Checks that a VDM-SL procedure is underspec-protective can be done in same way as we described them for the Larch family. Both kinds of protection may also be useful for writers of executable specifications. For example, in a language like Eiffel <ref> [Mey88] </ref>, partiality-protection for a procedure would ensure that its precondition would be flagged as false instead of encountering an error, allowing an error to happen in its body, or encountering an error in its postcondition.
Reference: [ORSvH95] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Also PVS <ref> [ORSvH95] </ref> represents another kind of specification logic that should be considered in extending our concepts.) The first concept of protection we discuss is appropriate for behavioral interface specification languages (BISLs) that use a logic that accepts the existence of partial functions and has various non-classical ways to reason about them.
Reference: [OSWZ94] <author> William F. Ogden, Murali Sitaraman, Bruce W. Weide, and Stuart H. </author> <title> Zweben. Part I: The RESOLVE framework and discipline | a research synopsis. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 19(4) </volume> <pages> 23-28, </pages> <month> Oct </month> <year> 1994. </year>
Reference-contexts: This kind of logic is used in the Larch Shared Language, LSL [GHG + 93, Chapter 4] [GHM90], which is the mathematical component of the Larch family BISLs [GHG + 93], in the BISLs of the RESOLVE family <ref> [OSWZ94] </ref>, and in Z [Hay93, Spi92] (according to its draft standard [WJ96]). The subtle problems that underspecification may cause for the unwary in LSL (and similar logics) are discussed in Appendix A; indeed Jones's paper pointing out these problems [Jon95] motivated the present work.
Reference: [SKT95] <author> Donald Sannella Stefan Kahrs and Andrzej Tarlecki. </author> <title> The definition of Extended ML: a gentle introduction. </title> <type> Technical Report ECS-LFCS-95-322, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> October </month> <year> 1995. </year> <note> To appear in Theoretical Computer Science. </note>
Reference-contexts: All other values are proper. In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [Bij90, Bli91, SKT95, KTB91, WDC + 95] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses under-specification. In such a logic, one avoids specifying a value for undefined terms [GS95, Jon95].
Reference: [Spi92] <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: This kind of logic is used in the Larch Shared Language, LSL [GHG + 93, Chapter 4] [GHM90], which is the mathematical component of the Larch family BISLs [GHG + 93], in the BISLs of the RESOLVE family [OSWZ94], and in Z <ref> [Hay93, Spi92] </ref> (according to its draft standard [WJ96]). The subtle problems that underspecification may cause for the unwary in LSL (and similar logics) are discussed in Appendix A; indeed Jones's paper pointing out these problems [Jon95] motivated the present work.
Reference: [WDC + 95] <author> U. Wolter, K. Didrich, F. Cornelius, M. Klar, R. Wessaly, and H. Ehrig. </author> <title> How to Protective Interface Specifications 17 cope with the spectrum of spectrum. </title> <editor> In Manfred Broy and Stefan Jahnichen, editors, KORSO: </editor> <booktitle> Methods, Languages and Tools for the Construction of Correct Software, volume 1009 of Lecture Notes in Computer Science, </booktitle> <pages> pages 173-189. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: All other values are proper. In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [Bij90, Bli91, SKT95, KTB91, WDC + 95] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses under-specification. In such a logic, one avoids specifying a value for undefined terms [GS95, Jon95].
Reference: [Win83] <author> Jeannette Marie Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: We also discuss how to prove protection from the effects of underspecification. 2. Protective Procedure Specifications The idea of protection in a BISL was first formulated by Wing <ref> [Win83, Section 5.1.4] </ref>.
Reference: [WJ96] <author> Jim Woodcock and Daniel Jackson. </author> <title> About the semantics of partial functions in Z. </title> <type> Personal communication, </type> <month> April </month> <year> 1996. </year>
Reference-contexts: This kind of logic is used in the Larch Shared Language, LSL [GHG + 93, Chapter 4] [GHM90], which is the mathematical component of the Larch family BISLs [GHG + 93], in the BISLs of the RESOLVE family [OSWZ94], and in Z [Hay93, Spi92] (according to its draft standard <ref> [WJ96] </ref>). The subtle problems that underspecification may cause for the unwary in LSL (and similar logics) are discussed in Appendix A; indeed Jones's paper pointing out these problems [Jon95] motivated the present work. It is not the purpose of this paper to advocate one kind of logic over another.
References-found: 30

