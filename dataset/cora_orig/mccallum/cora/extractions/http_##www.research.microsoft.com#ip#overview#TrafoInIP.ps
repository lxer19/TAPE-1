URL: http://www.research.microsoft.com/ip/overview/TrafoInIP.ps
Refering-URL: http://www.research.microsoft.com/ip/
Root-URL: http://www.research.microsoft.com
Title: Transformation in Intentional Programming  
Author: William Aitken Brian Dickens Paul Kwiatkowski Oege de Moor David Richter Charles Simonyi 
Address: One Microsoft Way Redmond, WA 98052  
Affiliation: Microsoft Research Microsoft Corporation  
Date: September 19, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Bauer, Friedrich, et al. </author> <title> The Munich project CIP: Volume II, the Transformation System CIP-S. </title> <publisher> LNCS 292, Springer Verlag, </publisher> <year> 1987. </year> <note> See also: http://www.informatik.uni-ulm.de/abt/pm/publikationen </note>
Reference-contexts: Below we assess their relative merits, and make a comparison with Intentional Programming. Due to space constraints, we have made a selection of related work; other relevant references include <ref> [1, 3, 5, 6, 7, 10] </ref>. 5.1 Polya Of all program transformation technologies, the one most soundly based on theory is Polya [8, 9]. Polya is a programming language that allows direct expression of program transformations. Its design and implementation are being carried out at Cornell University.
Reference: [2] <author> Batory, Don, et al. </author> <title> Scalable Software Libraries. </title> <booktitle> In Procs. 6 th Symposium on the Foundations of Software Engineering. </booktitle> <address> Los Angeles, CA, </address> <month> December </month> <year> 1993. </year> <note> Available from: http://www.cs.utexas.edu/users/dsb/ </note>
Reference-contexts: Intentional programming was originally conceived by Charles Simonyi, and has been under development at Microsoft Research since 1991 [17, 18, 19, 20]. Domain specific optimizations are vital in software reuse: without them, the only tool to achieve reuse is parameterization, and this inevitably introduces a performance overhead <ref> [2, 4, 12] </ref>. However, to realize the potential of such optimizations they have to be described in a compositional fashion, so that they can be reused independent of the context in which they occur. This problem (and its solution in Intentional Programming) is the focus of the present paper.
Reference: [3] <author> Baxter, Ira D. and Pidgeon, Christopher W. </author> <title> Software Change Through Design Maintenance. </title> <note> In: Procs. of ICSM 97, IEEE 97. See also: http://www.semdesigns.com/ </note>
Reference-contexts: Below we assess their relative merits, and make a comparison with Intentional Programming. Due to space constraints, we have made a selection of related work; other relevant references include <ref> [1, 3, 5, 6, 7, 10] </ref>. 5.1 Polya Of all program transformation technologies, the one most soundly based on theory is Polya [8, 9]. Polya is a programming language that allows direct expression of program transformations. Its design and implementation are being carried out at Cornell University.
Reference: [4] <author> Biggerstaff, Ted J. </author> <title> Anticipatory Optimization in Domain Specific Translation. </title> <note> Microsoft Research technical report MSR-TR-97-22, 1997. 10pp. Available from http://www.advtech.microsoft.com/pubs/msr-bib.htm </note>
Reference-contexts: Intentional programming was originally conceived by Charles Simonyi, and has been under development at Microsoft Research since 1991 [17, 18, 19, 20]. Domain specific optimizations are vital in software reuse: without them, the only tool to achieve reuse is parameterization, and this inevitably introduces a performance overhead <ref> [2, 4, 12] </ref>. However, to realize the potential of such optimizations they have to be described in a compositional fashion, so that they can be reused independent of the context in which they occur. This problem (and its solution in Intentional Programming) is the focus of the present paper.
Reference: [5] <author> Borras, P. et al, </author> <title> CENTAUR: the system. </title> <booktitle> In Procs. ACM SIGSOFT/SIGPLAN Symposium on Practical Software Development Environments, </booktitle> <pages> pp. 14-24, </pages> <year> 1989. </year> <note> Available from: http://www.inria.fr/croap/centaur/centaur.html </note>
Reference-contexts: Below we assess their relative merits, and make a comparison with Intentional Programming. Due to space constraints, we have made a selection of related work; other relevant references include <ref> [1, 3, 5, 6, 7, 10] </ref>. 5.1 Polya Of all program transformation technologies, the one most soundly based on theory is Polya [8, 9]. Polya is a programming language that allows direct expression of program transformations. Its design and implementation are being carried out at Cornell University.
Reference: [6] <author> Boyle, James and Harmer, Terence and Winter Victor. </author> <title> The TAMPR Program Transformation System: Simplyfying the Development of Numerical Software. </title> <editor> In: Arge, Erland et al. (editors), </editor> <booktitle> Modern Software Tools for Scientific Computing. </booktitle> <address> Birkhuser Boston, </address> <year> 1997. </year> <note> Chapter 17, pp. 353-372. See also: http://www.cs.qub.ac.uk/CS/Research/Transformation/ </note>
Reference-contexts: Below we assess their relative merits, and make a comparison with Intentional Programming. Due to space constraints, we have made a selection of related work; other relevant references include <ref> [1, 3, 5, 6, 7, 10] </ref>. 5.1 Polya Of all program transformation technologies, the one most soundly based on theory is Polya [8, 9]. Polya is a programming language that allows direct expression of program transformations. Its design and implementation are being carried out at Cornell University.
Reference: [7] <author> Cordy, James and Shukla, Medha. </author> <title> Practical Metaprogramming. In Procs. CASCON 92, IBM Centre for Advances Studies Conference. </title> <note> Available from: http://www.qucis.queensu.ca/home/cordy/TXL-Info/index.html </note>
Reference-contexts: Below we assess their relative merits, and make a comparison with Intentional Programming. Due to space constraints, we have made a selection of related work; other relevant references include <ref> [1, 3, 5, 6, 7, 10] </ref>. 5.1 Polya Of all program transformation technologies, the one most soundly based on theory is Polya [8, 9]. Polya is a programming language that allows direct expression of program transformations. Its design and implementation are being carried out at Cornell University.
Reference: [8] <author> Efremides, Sofoklis. </author> <title> On Program Transformations. </title> <type> PhD thesis. </type> <institution> Cornell University, </institution> <month> May </month> <year> 1994. </year> <note> Available from: http://cs-tr.cs.cornell.edu/ </note>
Reference-contexts: Due to space constraints, we have made a selection of related work; other relevant references include [1, 3, 5, 6, 7, 10]. 5.1 Polya Of all program transformation technologies, the one most soundly based on theory is Polya <ref> [8, 9] </ref>. Polya is a programming language that allows direct expression of program transformations. Its design and implementation are being carried out at Cornell University. The programmer can introduce new types, operations on these new types, and specify their appearance.
Reference: [9] <author> Gries, David, and Volpano, Dennis. </author> <title> The transform - a new language construct. </title> <journal> Structured Programming, </journal> <volume> 11 </volume> <pages> 1-10, </pages> <year> 1990. </year>
Reference-contexts: Due to space constraints, we have made a selection of related work; other relevant references include [1, 3, 5, 6, 7, 10]. 5.1 Polya Of all program transformation technologies, the one most soundly based on theory is Polya <ref> [8, 9] </ref>. Polya is a programming language that allows direct expression of program transformations. Its design and implementation are being carried out at Cornell University. The programmer can introduce new types, operations on these new types, and specify their appearance.
Reference: [10] <editor> Hoffmann, B. and Krieg-Brckner, B. (eds.): </editor> <title> PROgram development by SPECification and TRAnsformation: Methodology - Language Family - System. </title> <note> LNCS 680, 1993. See also: http://www.informatik.uni-bremen.de/~agbkb/forschung/prospectra/prospectra.html </note>
Reference-contexts: Below we assess their relative merits, and make a comparison with Intentional Programming. Due to space constraints, we have made a selection of related work; other relevant references include <ref> [1, 3, 5, 6, 7, 10] </ref>. 5.1 Polya Of all program transformation technologies, the one most soundly based on theory is Polya [8, 9]. Polya is a programming language that allows direct expression of program transformations. Its design and implementation are being carried out at Cornell University.
Reference: [11] <author> Myers, Scott. </author> <title> Using C++ effectively: Min, Max and More. </title> <type> C++ Report, </type> <month> January </month> <year> 1995. </year> <note> Available from (requires Frame Viewer): http://www.teleport.com/~smeyers/magazines.html </note>
Reference-contexts: One could think of intentional programming as a framework for implementing programming languages in a highly extensible manner. Below we elaborate the concept of an intention, using a little example. We shall take the intentional implementation of C for granted. 2.1 An Example Our example is inspired by Myers <ref> [11] </ref>. It involves writing an implementation of the binary function min that returns the minimum of its two arguments. The function should work for any type on which the comparison operator (&lt;) is defined: that is, it is a template. Each occurrence of min should be inlined.
Reference: [12] <author> Neighbors, James M. </author> <title> Draco: A Method for Engineering Reusable Software Systems. </title> <editor> In Biggerstaff, Ted and Perlis, Alan (eds.), </editor> <booktitle> Software Reusability, </booktitle> <publisher> Addison-Wesley/ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: Intentional programming was originally conceived by Charles Simonyi, and has been under development at Microsoft Research since 1991 [17, 18, 19, 20]. Domain specific optimizations are vital in software reuse: without them, the only tool to achieve reuse is parameterization, and this inevitably introduces a performance overhead <ref> [2, 4, 12] </ref>. However, to realize the potential of such optimizations they have to be described in a compositional fashion, so that they can be reused independent of the context in which they occur. This problem (and its solution in Intentional Programming) is the focus of the present paper.
Reference: [13] <author> Paige, Robert. </author> <title> Viewing a program transformation system at work. </title> <note> In: Procs of PLILP 94, LNCS 844, </note> <editor> eds. M. Hermenegildo and J. Penjam, </editor> <publisher> Springer-Verlag, </publisher> <month> Sep. </month> <year> 1994, </year> <pages> pp. 5-24. </pages> <note> Available from: http://cs.nyu.edu/cs/faculty/paige/research.html </note>
Reference-contexts: Also, for those transformations that can be expressed, Polyas intentions are very attractive indeed. 5.2 APTS APTS is an acronym for A Program Transformation System, and it is another academic effort, by Cai and Paige of Courant Institute <ref> [13] </ref>. The system has been designed to implement some very high level design strategies in algorithm design as program transformations. The results that have been obtained in this manner are quite impressive, and the authors report a fivefold increase in programmer productivity.
Reference: [14] <author> Reasoning, Inc. </author> <title> Product data sheets. </title> <note> Available from: http://www.reasoning.com/HTML/proddata.html </note>
Reference-contexts: Since it also lacks explicit facilities for incrementally changing the language and transformations, it does not satisfy our criterion of compositional abstraction. 5.3 Reasoning5 The Reasoning5 code base management system is the only commercially available product that explicitly aims to support program transformation on a large scale <ref> [14] </ref>. It developed at Reasoning Systems Inc, a California based company that has been selling transformation technology since 1984. Reasonings products include a graphical interface for editing, userspecified rendering, report writing, and more. Here we concentrate on the transformation technology.
Reference: [15] <author> Reps, Thomas, and Teitelbaum, Tim. </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors. </title> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1988. </year> <note> See also: http://www.grammatech.com/ </note>
Reference-contexts: The details of the system are firmly based on theory. Polyas implementation is nearly complete [23]. It is implemented using the Cornell Synthesizer Generator, a product of GrammaTech <ref> [15] </ref>. This has the pleasant effect that all actions are completely incremental: when the programmer has finished his program, the transformation process has finished too. Polya offers the option of generating target code in standard ML, or in C.
Reference: [16] <author> Simonyi, Charles, and Heller, Martin. </author> <title> The Hungarian Revolution. </title> <journal> Byte, </journal> <month> August, </month> <year> 1991, </year> <note> pp.131-138. See also: http://www.freenet.tlh.fl.us/~joeo/hungarian.html </note>
Reference-contexts: For virtual intentions this prefix is vi. When naming functions, we sometimes attach a suffix that indicates the type of the argument. Hungarian naming is also the brainchild of Charles Simonyi <ref> [16] </ref>. 2.3 Contributing Methods Once an intention (virtual or real) has been declared, one can start to define its characteristics by contributing xmethods. The x stands for extension, indicating that each method further extends the behavior of an intention.
Reference: [17] <author> Simonyi, Charles. </author> <title> The Death of Computer Languages The Birth of Intentional Programming. </title> <institution> Microsoft Research technical report MSR-TR-95-52. </institution> <month> September </month> <year> 1995, </year> <pages> 25 pp. </pages> <address> http://www.advtech.microsoft.com/pubs/msr-bib.htm </address>
Reference-contexts: This contrasts with traditional programming languages, which may offer features for expressing domain specific abstractions, but rarely allow the programmer to also express his knowledge of domain specific optimizations. Intentional programming was originally conceived by Charles Simonyi, and has been under development at Microsoft Research since 1991 <ref> [17, 18, 19, 20] </ref>. Domain specific optimizations are vital in software reuse: without them, the only tool to achieve reuse is parameterization, and this inevitably introduces a performance overhead [2, 4, 12].
Reference: [18] <author> Simonyi, Charles. </author> <title> Intentional Programming - Innovation in the Legacy Age. </title> <booktitle> Presentation at IFIP WG 2.1 on Algorithmic Languages and Calculi. </booktitle> <month> June </month> <year> 1996, </year> <note> 26pp. Available from: http://www.research.microsoft.com/research/ip </note>
Reference-contexts: This contrasts with traditional programming languages, which may offer features for expressing domain specific abstractions, but rarely allow the programmer to also express his knowledge of domain specific optimizations. Intentional programming was originally conceived by Charles Simonyi, and has been under development at Microsoft Research since 1991 <ref> [17, 18, 19, 20] </ref>. Domain specific optimizations are vital in software reuse: without them, the only tool to achieve reuse is parameterization, and this inevitably introduces a performance overhead [2, 4, 12].
Reference: [19] <author> Simonyi, Charles. </author> <title> The Intentional Programming Overview. </title> <type> Unpublished paper. </type> <month> July </month> <year> 1996, </year> <note> 5pp. Available from: http://www.research.microsoft.com/research/ip </note>
Reference-contexts: This contrasts with traditional programming languages, which may offer features for expressing domain specific abstractions, but rarely allow the programmer to also express his knowledge of domain specific optimizations. Intentional programming was originally conceived by Charles Simonyi, and has been under development at Microsoft Research since 1991 <ref> [17, 18, 19, 20] </ref>. Domain specific optimizations are vital in software reuse: without them, the only tool to achieve reuse is parameterization, and this inevitably introduces a performance overhead [2, 4, 12].
Reference: [20] <author> Smaragdakis, Yannis and Batory, Don. DiSTiL: </author> <title> A Transformation Library for Data Structures. Accepted for publication, </title> <booktitle> USENIX Conference on DomainSpecific Languages, </booktitle> <month> October </month> <year> 1997. </year> <note> Available from: http://www.cs.utexas.edu/users/smaragd/research.html </note>
Reference-contexts: This contrasts with traditional programming languages, which may offer features for expressing domain specific abstractions, but rarely allow the programmer to also express his knowledge of domain specific optimizations. Intentional programming was originally conceived by Charles Simonyi, and has been under development at Microsoft Research since 1991 <ref> [17, 18, 19, 20] </ref>. Domain specific optimizations are vital in software reuse: without them, the only tool to achieve reuse is parameterization, and this inevitably introduces a performance overhead [2, 4, 12].
Reference: [21] <author> Smith, Douglas, and Green, Cordell. </author> <title> Toward Practical Applications of Software Synthesis. </title> <booktitle> In: Procs of FMSP 96, The First Workshop on Formal Methods in Software Practice. </booktitle> <address> San Diego, CA, </address> <month> January </month> <year> 1996, </year> <pages> pp. 31-39. </pages> <note> Available from: http://www.kestrel.edu/HTML/publications.html </note>
Reference-contexts: Examples of transformation plug-ins include a package for identifying and correcting year 2000 problems in Cobol programs. Reasonings products have been used for some spectacular applications, including the Kids algorithm design system at Kestrel Institute <ref> [21] </ref>. In turn, Kids has been used to produce scheduling software that is far superior to hand-coded products of others. More recently, researchers at Kestrel have started to build a system for composing software architectures, called SpecWare, also based on Reasonings technology [22].
Reference: [22] <author> Srinivas, Yellamraju, and MacDonald, James. </author> <title> The Architecture of SpecWare, a Formal Software Development System. </title> <institution> Kestrel Institute Technical Report KES.U.96.97, </institution> <month> August </month> <year> 1996. </year> <note> Available from: http://www.kestrel.edu/HTML/publications.html </note>
Reference-contexts: In turn, Kids has been used to produce scheduling software that is far superior to hand-coded products of others. More recently, researchers at Kestrel have started to build a system for composing software architectures, called SpecWare, also based on Reasonings technology <ref> [22] </ref>. The basis of CQML is not unlike the tree manipulation primitives described here. In addition to those primitives, it has some high-level abstractions for manipulating sets and relations. What is missing, again, is the ability to control the transformation order in a localized, compositional fashion. 6.
Reference: [23] <author> Van den Berg, Aswin. </author> <title> Implementing a Program Transformation System. </title> <type> Ph. D. Thesis, </type> <institution> Cornell University. Forthcoming, </institution> <year> 1997. </year> <note> See also: http://www.cs.cornell.edu/home/aswin/polya/popl98.ps </note>
Reference-contexts: Transforms can also be used to represent existing data types more concretely, for example to describe the implementation of a set by an array. The details of the system are firmly based on theory. Polyas implementation is nearly complete <ref> [23] </ref>. It is implemented using the Cornell Synthesizer Generator, a product of GrammaTech [15]. This has the pleasant effect that all actions are completely incremental: when the programmer has finished his program, the transformation process has finished too.
References-found: 23

