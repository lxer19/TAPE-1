URL: file://ftp.cc.gatech.edu/pub/coc/tech_reports/1995/GIT-CC-95-08.ps.Z
Refering-URL: http://www.cs.gatech.edu/computing/Telecomm/playground/MULTI/outline.html
Root-URL: 
Email: frdk,ammar,calvertg@cc.gatech.edu  
Title: Multi-Subsystem Protocol Architectures: Motivation and Experience with an Adapter-Based Approach  
Author: Bobby Krupczak Mostafa Ammar Ken Calvert 
Note: This research is supported by a grant from the National Science Foundation (NCR-9305115) and the TRANSOPEN project of the Army Research Lab (formerly AIRMICS) under contract number DAKF11-91-D-0004.  
Address: Atlanta, Georgia 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Date: Februrary 2, 1995 Revised July 18, 1995  
Pubnum: GIT-CC-95-08  
Abstract: Protocol software is often difficult, cumbersome, and expensive to implement and test in today's computing environments. To reduce this difficulty, several things are done: communications software is commonly subdivided into layers and organized into a protocol graph; it is developed within a protocol or networking subsystem; and it is often ported rather than developed from scratch. Inherent differences in the multitude of protocol subsystems offer a dizzying array of features, functionality, and drawbacks; their differences often reduce the portability and efficiency of protocol code. In this paper, we consider the differences in subsystems and their effect on the portability and performance of protocol implementations. We propose an approach for combining the better features of protocol subsystems by constructing protocol graphs composed of protocols residing in different subsystems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. B. Abbott and L. L. Peterson. </author> <title> A language-based approach to protocol implementation. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(1) </volume> <pages> 4-19, </pages> <month> February </month> <year> 1993. </year>
Reference: [2] <author> AT&T. </author> <title> UNIX System V/386 RELEASE 4 STREAMS Programmer's Reference Manual. </title> <publisher> Prentice-Hall Inc., </publisher> <year> 1991. </year>
Reference-contexts: In practice, several techniques are used to reduce this complexity. First, protocol code is subdivided into layers or modules and organized into a graph structure representing how those modules are combined to provide communication services. Second, protocols are developed within programming environments or subsystems (such as BSD [14], Streams <ref> [2, 22] </ref>, or the x-Kernel [18, 11]) which provide an overall protocol model and offer organized, consistent access to operating system resources. Third, protocol code is often ported from one subsystem to another rather than developed from scratch. <p> The x-Kernel work [18, 11] recognized the difficult nature of implementing protocols and addresses the problem by developing a subsystem with an explicit goal the reduction of complexity of protocol programming without hampering performance. Streams <ref> [22, 2] </ref> sought to replace the traditional UNIX 3 method for connecting processes to terminals or network devices with a flexible, consistent subsystem supporting modular protocols. These approaches improve performance and reduce implementation complexity at the expense of portability and flexibility.
Reference: [3] <author> Joshua Auerbach. </author> <title> A protocol conversion software toolkit. </title> <booktitle> In ACM SIGCOMM-1989 Symposium, </booktitle> <pages> pages 259-270, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: A substantial body of research focuses on interoperability through protocol conversion [10, 13]. Using this approach, interoperability is achieved by converting the protocols spoken by one or both of the communicating entities through gateways and intermediaries. Auerbach describes a protocol converter toolkit <ref> [3] </ref> while Calvert introduces protocol adaptors [5]. Although it is a related approach, protocol conversion focuses on a protocol's output (headers, messages, etc.) rather than on the environments in which protocols may operate. Measuring and improving protocol implementation efficiency are the approaches taken in another area of protocol research.
Reference: [4] <author> S. Bradner and A. Mankin. </author> <title> The recommendation for the IP next generation protocol. </title> <note> Anonymous FTP, January 1995. RFC 1752. </note>
Reference-contexts: In addition, the possibility of multiple subsystem protocol implementations eliminates the need to port protocols from subsystem to subsystem, thus allowing for easier introduction of new protocols. Examples of multi-subsystem protocol implementations are shown in Figure 1. Figure 1a shows a transition architecture incorporating IPv6 <ref> [4] </ref> written in Streams but not yet ported to BSD. We expect this type of architecture to allow faster adoption of new protocols. Figure 1b shows an environment supporting high performance coupled with dynamic protocol configuration.
Reference: [5] <author> K.L. Calvert and S.S. Lam. </author> <title> Adaptors for protocol conversion. </title> <booktitle> In Proceedings IEEE INFOCOM '90, </booktitle> <volume> volume 2, </volume> <pages> pages 552-60, </pages> <year> 1990. </year>
Reference-contexts: A substantial body of research focuses on interoperability through protocol conversion [10, 13]. Using this approach, interoperability is achieved by converting the protocols spoken by one or both of the communicating entities through gateways and intermediaries. Auerbach describes a protocol converter toolkit [3] while Calvert introduces protocol adaptors <ref> [5] </ref>. Although it is a related approach, protocol conversion focuses on a protocol's output (headers, messages, etc.) rather than on the environments in which protocols may operate. Measuring and improving protocol implementation efficiency are the approaches taken in another area of protocol research. <p> Both work transparently within a protocol graph. They do not produce or consume protocol headers nor communicate with remote peers. Like virtual protocols, an adapter need not have a remote peer. Subsystem adapters are also similar in nature to protocol adaptors defined by Calvert <ref> [5] </ref> except that subsystem adapters do not alter or convert protocol headers, but instead provide subsystem adaptation services. Adapter protocols reside in the subsystems between which they operate. The manner in which an adapter protocol is integrated into each subsystem depends on the subsystem in question.
Reference: [6] <author> David D. Clark, Van Jacobson, John Romkey, and Howard Salwen. </author> <title> An analysis of TCP processing overhead. </title> <journal> IEEE Communications, </journal> <volume> 27(6) </volume> <pages> 23-29, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Partridge and Pink [20] examine and improve the performance of UDP/IP within the context of the BSD subsystem. They focus on implementation efficiency rather than subsystem issues. Clark et al <ref> [6] </ref> examine implementation efficiency in isolation of the subsystem rather than in conjuncture. In each case, comparisons to other subsystems were not explored.
Reference: [7] <author> Russell J. Clark, Mostafa H. Ammar, and Kenneth L. Calvert. </author> <title> Multi-protocol architectures as a paradigm for achieving inter-operability. </title> <booktitle> In Proceedings of IEEE INFOCOM. </booktitle> <institution> Georgia Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: They focus on implementation efficiency rather than subsystem issues. Clark et al [6] examine implementation efficiency in isolation of the subsystem rather than in conjuncture. In each case, comparisons to other subsystems were not explored. Finally, the work in <ref> [7, 8] </ref> addresses protocol interoperability concerns by proposing multi-protocol architectures in which two entities communicate by mixing and matching supported protocols until they have a common subset.
Reference: [8] <author> Russell J. Clark, Kenneth L. Calvert, and Mostafa H. Ammar. </author> <title> On the use of directory services to support multi-protocol inter-operability. </title> <booktitle> In Proceedings of IEEE INFOCOM. </booktitle> <institution> Georgia Institute of Technology, </institution> <year> 1994. </year>
Reference-contexts: They focus on implementation efficiency rather than subsystem issues. Clark et al [6] examine implementation efficiency in isolation of the subsystem rather than in conjuncture. In each case, comparisons to other subsystems were not explored. Finally, the work in <ref> [7, 8] </ref> addresses protocol interoperability concerns by proposing multi-protocol architectures in which two entities communicate by mixing and matching supported protocols until they have a common subset.
Reference: [9] <author> S. H. Goldberg and J.A. </author> <title> Mouton. A base for portable communications software. </title> <journal> IBM Systems Journal, </journal> <volume> 30(3) </volume> <pages> 259-79, </pages> <year> 1991. </year>
Reference-contexts: Further, approaches that introduce new subsystems only add to the protocol portability problem. We survey current research and classify it on how it relates to portability and the interplay between the subsystem and protocol performance. In the Base subsystem <ref> [9] </ref>, the authors directly address the protocol portability problem. Recognizing the expense and difficulty of developing OSI protocols for several different IBM platforms (and accompanying protocol subsystems), the authors sought to eliminate the protocol portability problem by shifting the focus to the subsystem instead.
Reference: [10] <author> Paul E. Jr. Green. </author> <title> Protocol conversion. </title> <journal> IEEE Transactions on Communications, </journal> <volume> 34(3) </volume> <pages> 257-268, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: Once the subsystem has been ported, protocol code portability comes for free. Performance gains are obtained through subsystem and compiler efficiency. A substantial body of research focuses on interoperability through protocol conversion <ref> [10, 13] </ref>. Using this approach, interoperability is achieved by converting the protocols spoken by one or both of the communicating entities through gateways and intermediaries. Auerbach describes a protocol converter toolkit [3] while Calvert introduces protocol adaptors [5].
Reference: [11] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan </month> <year> 1991. </year>
Reference-contexts: First, protocol code is subdivided into layers or modules and organized into a graph structure representing how those modules are combined to provide communication services. Second, protocols are developed within programming environments or subsystems (such as BSD [14], Streams [2, 22], or the x-Kernel <ref> [18, 11] </ref>) which provide an overall protocol model and offer organized, consistent access to operating system resources. Third, protocol code is often ported from one subsystem to another rather than developed from scratch. A protocol's implementation is generally tightly coupled with the subsystem in which it is developed. <p> Their research focused on moving the BSD subsystem out of the kernel and into user-space. In doing so, they have taken the approach of porting the subsystem rather than porting the protocol code. The x-Kernel work <ref> [18, 11] </ref> recognized the difficult nature of implementing protocols and addresses the problem by developing a subsystem with an explicit goal the reduction of complexity of protocol programming without hampering performance.
Reference: [12] <author> Jonathan Kay and Joseph Pasquale. </author> <title> The importance of non-data touching processing overheads in TCP/IP. </title> <booktitle> ACM SIGCOMM-1993 Symposium, </booktitle> <pages> pages 259-268, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Measuring and improving protocol implementation efficiency are the approaches taken in another area of protocol research. Papadopoulos and Parulkar [19] and Kay and Pasquale <ref> [12] </ref> focus on measuring operational TCP/IP implementations in order to gain a better understanding of protocol performance issues. Partridge and Pink [20] examine and improve the performance of UDP/IP within the context of the BSD subsystem. They focus on implementation efficiency rather than subsystem issues.
Reference: [13] <author> S.S. Lam. </author> <title> Protocol conversion. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(3) </volume> <pages> 353-62, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Once the subsystem has been ported, protocol code portability comes for free. Performance gains are obtained through subsystem and compiler efficiency. A substantial body of research focuses on interoperability through protocol conversion <ref> [10, 13] </ref>. Using this approach, interoperability is achieved by converting the protocols spoken by one or both of the communicating entities through gateways and intermediaries. Auerbach describes a protocol converter toolkit [3] while Calvert introduces protocol adaptors [5].
Reference: [14] <author> Samuel J. Leffler, Marshall Kirk McKusick, Michael J. Karels, and John S. Quaterman. </author> <title> The Design and Implementation of the 4.3 BSD UNIX Operating System. </title> <publisher> Addison-Wesley, </publisher> <address> 1st edition, </address> <year> 1989. </year>
Reference-contexts: In practice, several techniques are used to reduce this complexity. First, protocol code is subdivided into layers or modules and organized into a graph structure representing how those modules are combined to provide communication services. Second, protocols are developed within programming environments or subsystems (such as BSD <ref> [14] </ref>, Streams [2, 22], or the x-Kernel [18, 11]) which provide an overall protocol model and offer organized, consistent access to operating system resources. Third, protocol code is often ported from one subsystem to another rather than developed from scratch.
Reference: [15] <author> Allen B. Montz, David Mosberger, Sean W. O'Malley, Larry L. Peterson, Todd A. Proebsting, and John H. Hartman. </author> <title> Scout: A communications-oriented operating system. </title> <type> Technical Report TR94-20, </type> <institution> Department of Computer Science, University of Arizona, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: Current trends indicate that no one protocol subsystem or operating system will prevail. In fact, these problems are becoming exacerbated as new operating systems (e.g., <ref> [15] </ref>) and accompanying protocol subsystems are deployed. In this paper we address the two issues above by allowing protocol implementations to span multiple subsystems; we call the resulting implementations multi-subsystem architectures.
Reference: [16] <author> Bodhisattwa Mukherjee, Greg Eisenhauer, and Kaushik Ghosh. </author> <title> A machine independent interface for lightweight threads. </title> <journal> Operating Systems Review, </journal> <volume> 28(1) </volume> <pages> 33-47, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: They created a portable subsystem supporting protocol development. Once they ported their subsystem to a target platform, their protocol implementations could run virtually unmodified. Unfortunately, protocol programmers are restricted to Base and must accept its (possible) restrictions for the sake of portability. Bodhi et al <ref> [16] </ref> face many of the same problems that obstruct protocol portability by addressing the problems encountered when trying to port a user-level threads package from operating system to operating system.
Reference: [17] <author> Erich M. Nahum, David J. Yates, James F. Kurose, and Don Towsley. </author> <title> Performance issues in parallelized network protocols. </title> <booktitle> In Proceedings of the First Symposium on Operating System Design and Implementation. </booktitle> <institution> Department of Computer Science, University of Massachusetts, </institution> <year> 1994. </year>
Reference-contexts: The code to save state and continue processing at a later time is generally very subsystem-specific and thus non-portable. Process architecture differences can also impose serious performance problems. For example, horizontal process architectures can suffer performance penalties due to excessive context switching due mainly to their asynchronous nature <ref> [17] </ref>. On the other hand, they may perform better in environments that can effectively reduce this overhead [24]. 4.1.3 Protocol Graph Layering is such a fundamental concept in communications architectures that it is pervasive throughout their specification and implementation.
Reference: [18] <author> S. W. O'Malley and L. L. Peterson. </author> <title> A dynamic network architecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10 </volume> <pages> 110-143, </pages> <month> May </month> <year> 1992. </year> <month> 21 </month>
Reference-contexts: First, protocol code is subdivided into layers or modules and organized into a graph structure representing how those modules are combined to provide communication services. Second, protocols are developed within programming environments or subsystems (such as BSD [14], Streams [2, 22], or the x-Kernel <ref> [18, 11] </ref>) which provide an overall protocol model and offer organized, consistent access to operating system resources. Third, protocol code is often ported from one subsystem to another rather than developed from scratch. A protocol's implementation is generally tightly coupled with the subsystem in which it is developed. <p> Alternatively, it may correspond to an implementation of a single, atomic protocol function (e.g., header checksumming) intended for use in conjunction with other protocols. This latter type, referred to as a micro-protocol, is outlined in <ref> [18] </ref>. Protocols typically execute within the context of a protocol subsystem, which organizes operating system resources like buffers and timers in a manner which eases the burden of protocol development. <p> Their research focused on moving the BSD subsystem out of the kernel and into user-space. In doing so, they have taken the approach of porting the subsystem rather than porting the protocol code. The x-Kernel work <ref> [18, 11] </ref> recognized the difficult nature of implementing protocols and addresses the problem by developing a subsystem with an explicit goal the reduction of complexity of protocol programming without hampering performance. <p> Adapter protocols are also similar to the virtual protocols defined in the x-Kernel research <ref> [18] </ref>. Both work transparently within a protocol graph. They do not produce or consume protocol headers nor communicate with remote peers. Like virtual protocols, an adapter need not have a remote peer.
Reference: [19] <author> Christos Papadopoulos and Gurudatta Parulkar. </author> <title> Experimental evaluation of SunOS IPC and TCP/IP protocol implementation. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(2) </volume> <pages> 199-216, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Although it is a related approach, protocol conversion focuses on a protocol's output (headers, messages, etc.) rather than on the environments in which protocols may operate. Measuring and improving protocol implementation efficiency are the approaches taken in another area of protocol research. Papadopoulos and Parulkar <ref> [19] </ref> and Kay and Pasquale [12] focus on measuring operational TCP/IP implementations in order to gain a better understanding of protocol performance issues. Partridge and Pink [20] examine and improve the performance of UDP/IP within the context of the BSD subsystem. They focus on implementation efficiency rather than subsystem issues. <p> Because users of both subsystems cannot avoid any of these parts, measuring its total impact is sufficient for our comparison. Our measurement of BSD/Sockets roughly corresponds with that found in <ref> [19] </ref>; we know of no similar measurements for TLI/Streams. Unfortunately, we were unable to measure this impact in the context of the x-Kernel because no such standard application-interface exists for its user-space implementation.
Reference: [20] <author> Craig Partridge and Stephen Pink. </author> <title> A faster UDP. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(4) </volume> <pages> 429-440, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Measuring and improving protocol implementation efficiency are the approaches taken in another area of protocol research. Papadopoulos and Parulkar [19] and Kay and Pasquale [12] focus on measuring operational TCP/IP implementations in order to gain a better understanding of protocol performance issues. Partridge and Pink <ref> [20] </ref> examine and improve the performance of UDP/IP within the context of the BSD subsystem. They focus on implementation efficiency rather than subsystem issues. Clark et al [6] examine implementation efficiency in isolation of the subsystem rather than in conjuncture. In each case, comparisons to other subsystems were not explored.
Reference: [21] <author> Patric Peters, Roy Dcruz, Chiun-Teh Sung, Christine Wang, and Branislav Meandzija. </author> <title> On generalizations in networking software to encourage code portability. </title> <booktitle> In Proceedings of IEEE INFOCOM, </booktitle> <pages> pages 261-267, </pages> <year> 1989. </year>
Reference: [22] <author> D. M. Ritchie. </author> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 311-324, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: In practice, several techniques are used to reduce this complexity. First, protocol code is subdivided into layers or modules and organized into a graph structure representing how those modules are combined to provide communication services. Second, protocols are developed within programming environments or subsystems (such as BSD [14], Streams <ref> [2, 22] </ref>, or the x-Kernel [18, 11]) which provide an overall protocol model and offer organized, consistent access to operating system resources. Third, protocol code is often ported from one subsystem to another rather than developed from scratch. <p> The x-Kernel work [18, 11] recognized the difficult nature of implementing protocols and addresses the problem by developing a subsystem with an explicit goal the reduction of complexity of protocol programming without hampering performance. Streams <ref> [22, 2] </ref> sought to replace the traditional UNIX 3 method for connecting processes to terminals or network devices with a flexible, consistent subsystem supporting modular protocols. These approaches improve performance and reduce implementation complexity at the expense of portability and flexibility.
Reference: [23] <author> Douglas C. Schmidt and Tatsuya Suda. </author> <title> Transport system architecture services for high-performance communications systems. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 11(4) </volume> <pages> 489-506, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Many different styles exist including vertical and horizontal; within these styles can exist heavy-weight processes (in the traditional UNIX sense) or light-weight processes and threads (See <ref> [23] </ref> for an overview of process architectures and subsystems. For the sake of compatibility, we utilize their taxonomy.). In vertical process architectures, a thread or process escorts a message through the protocol graph within a single address space. Protocols invoke one another through synchronous function calls.
Reference: [24] <author> Douglas C. Schmidt and Tatsuya Suda. </author> <title> Measuring the performance of parallel message-based process architectures. </title> <booktitle> In Proceedings of IEEE INFOCOM, </booktitle> <year> 1995. </year>
Reference-contexts: Process architecture differences can also impose serious performance problems. For example, horizontal process architectures can suffer performance penalties due to excessive context switching due mainly to their asynchronous nature [17]. On the other hand, they may perform better in environments that can effectively reduce this overhead <ref> [24] </ref>. 4.1.3 Protocol Graph Layering is such a fundamental concept in communications architectures that it is pervasive throughout their specification and implementation. First, protocol families like the Internet, OSI, and AppleTalk subdivide the task of communications into layers and corresponding protocols.
Reference: [25] <author> Gursharan S. Sidhu, Richard F. Andrews, and Alan B. Oppenheimer. </author> <title> Inside AppleTalk. </title> <publisher> Addison-Wesley, </publisher> <address> 1st edition, </address> <year> 1989. </year>
Reference-contexts: The AppleTalk protocols also provide a broad set of real user services similar to the Internet family of protocols and are in widespread 2 Please refer to <ref> [25] </ref> for more information on AppleTalk. 3 Indeed, if the AppleTalk protocol architecture is biased towards any networking subsystem, it is biased towards that contained within the Macintosh operating system. 4 use.
Reference: [26] <author> C. A. Thekkath, T. D. Nguyen, E. Moy, and E. D. Lazowska. </author> <title> Implementing network protocols at user level. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(5) </volume> <pages> 554-565, </pages> <month> October </month> <year> 1993. </year> <note> Also published in SIGCOMM '93. 22 </note>
Reference-contexts: Their work is analogous to ours in that the task of porting a user-level threads package is similar to the that of porting protocol code: both are highly dependent on the types, flavors, and interfaces of the underlying services which they depend. Thekkath et al <ref> [26] </ref> partially address one factor that makes protocol development difficult, namely, location of protocols inside the kernel. They argue that protocols and accompanying protocol subsystems should be developed as user-space modules. Their research focused on moving the BSD subsystem out of the kernel and into user-space.
References-found: 26

